 Many complex speech and natural language processing (NLP) pipelines such as Automatic Speech Recognition (ASR) and Statistical Ma-chine Translation (SMT) systems store alternative hypotheses produced at various stages of process-ing as weighted acyclic automata, also known as lattices. Each lattice stores a large number of hypotheses along with the raw system scores as-signed to them. While single-best hypothesis is typically what is desired at the end of the pro-cessing, it is often beneficial to consider a large number of weighted hypotheses at earlier stages of the pipeline to hedge against errors introduced by various subcomponents. Standard ASR and SMT techniques like discriminative training, rescoring with complex models and Minimum Bayes-Risk (MBR) decoding rely on lattices to represent in-termediate system hypotheses that will be fur-ther processed to improve models or system out-put. For instance, lattice based MBR decoding has been shown to give moderate yet consistent gains in performance over conventional MAP decoding in a number of speech and NLP applications in-cluding ASR (Goel and Byrne, 2000) and SMT (Tromble et al., 2008; Blackwood et al., 2010; de Gispert et al., 2013).

Most lattice-based techniques employed by speech and NLP systems make use of posterior quantities computed from probabilistic lattices. In this paper, we are interested in two such posterior quantities: i) n -gram expected count, the expected number of occurrences of a particular n -gram in a lattice, and ii) n -gram posterior probability, the total probability of accepting paths that include a particular n -gram. Expected counts have applica-tions in the estimation of language model statis-tics from probabilistic input such as ASR lattices (Allauzen et al., 2003) and the estimation term frequencies from spoken corpora while posterior probabilities come up in MBR decoding of SMT lattices (Tromble et al., 2008), relevance ranking of spoken utterances and the estimation of docu-ment frequencies from spoken corpora (Karakos et al., 2011; Can and Narayanan, 2013).

The expected count c ( x | A ) of n -gram x given lattice A is defined as where # y ( x ) is the number of occurrences of n -gram x in hypothesis y and p ( y | A ) is the posterior probability of hypothesis y given lattice A . Simi-larly, the posterior probability p ( x | A ) of n -gram x given lattice A is defined as where 1 y ( x ) is an indicator function taking the value 1 when hypothesis y includes n -gram x and 0 otherwise. While it is straightforward to com-pute these posterior quantities from weighted n -best lists by examining each hypothesis separately and keeping a separate accumulator for each ob-served n -gram type, it is infeasible to do the same with lattices due to the sheer number of hypothe-ses stored. There are efficient algorithms in lit-erature (Allauzen et al., 2003; Allauzen et al., 2004) for computing n -gram expected counts from weighted automata that rely on weighted finite state transducer operations to reduce the compu-tation to a sum over n -gram occurrences elimi-nating the need for an explicit sum over accept-ing paths. The rather innocent looking difference between Equations 1 and 2, # y ( x ) vs. 1 y ( x ) , makes it hard to develop similar algorithms for computing n -gram posteriors from weighted au-tomata since the summation of probabilities has to be carried out over paths rather than n -gram oc-currences (Blackwood et al., 2010; de Gispert et al., 2013).

The problem of computing n -gram posteriors from lattices has been addressed by a number of recent works (Tromble et al., 2008; Allauzen et al., 2010; Blackwood et al., 2010; de Gispert et al., 2013) in the context of lattice-based MBR for SMT. In these works, it has been reported that the time required for lattice MBR decoding is domi-nated by the time required for computing n -gram posteriors. Our interest in computing n -gram pos-teriors from lattices stems from its potential appli-cations in spoken content retrieval (Chelba et al., 2008; Karakos et al., 2011; Can and Narayanan, 2013). Computation of document frequency statis-tics from spoken corpora relies on estimating n -gram posteriors from ASR lattices. In this con-text, a spoken document is simply a collection of ASR lattices. The n -grams of interest can be word, syllable, morph or phoneme sequences. Unlike in the case of lattice-based MBR for SMT where the n -grams of interest are relatively short  X  typically up to 4-grams  X , the n -grams we are interested in are in many instances relatively long sequences of subword units.

In this paper, we present an efficient algorithm for computing the posterior probabilities of all n -grams in a lattice and constructing a minimal de-terministic weighted finite-state automaton asso-ciating each n -gram with its posterior for efficient storage and retrieval. Our n -gram posterior com-putation algorithm builds upon the custom forward procedure described in (de Gispert et al., 2013) and introduces a number of refinements to signifi-cantly improve the time and space requirements: This section introduces the definitions and nota-tion related to weighted finite state automata and transducers (Mohri, 2009). 2.1 Semirings Definition 1 A semiring is a 5-tuple ( K ,  X  ,  X  , 0 , 1) where ( K ,  X  , 0) is a commutative monoid, ( K ,  X  , 1) is a monoid,  X  distributes over  X  and 0 is an annihilator for  X  .

Table 1 lists common semirings. In speech and language processing, two semirings are of particu-lar importance. The log semiring is isomorphic to the probability semiring via the negative-log mor-phism and can be used to combine probabilities in the log domain. The tropical semiring , provides the algebraic structure necessary for shortest-path algorithms and can be derived from the log semir-ing using the Viterbi approximation. 2.2 Weighted Finite-State Automata Definition 2 A weighted finite-state automaton (WFSA) A over a semiring ( K ,  X  ,  X  , 0 , 1) is a 7-tuple A = ( X  ,Q,I,F,E, X , X  ) where:  X  is the finite input alphabet; Q is a finite set of states; I,F  X  Q are respectively the set of initial and final states; E  X  Q  X  ( X   X  X   X  } )  X  K  X  Q is a finite set of arcs;  X  : I  X  K ,  X  : F  X  K are respectively the initial and final weight functions.
Given an arc e  X  E , we denote by i [ e ] its in-put label, w [ e ] its weight, s [ e ] its source or origin state and t [ e ] its target or destination state. A path  X  = e 1  X  X  X  e k is an element of E  X  with consecutive arcs satisfying t [ e i  X  1 ] = s [ e i ] , i = 2 ,...,k. We extend t and s to paths by setting t [  X  ] = s [ e k ] and s [  X  ] = t [ e 1 ] . The labeling and the weight func-tions can also be extended to paths by defining w [ e k ] . We denote by  X ( q,q 0 ) the set of paths from q to q 0 and by  X ( q,x,q 0 ) the set of paths from q to q 0 with input string x  X   X   X  . These definitions can also be extended to subsets S,S 0  X  Q , e.g. An accepting path in an automaton A is a path in  X ( I,F ) . A string x is accepted by A if there exists an accepting path  X  labeled with x . A is determin-istic if it has at most one initial state and at any state no two outgoing transitions share the same input label. The weight associated by an automa-ton A to a string x  X   X   X  is given by J A K ( x ) = and J A K ( x ) , 0 when  X ( I,x,F ) =  X  .

A weighted automaton A defined over the prob-ability semiring ( R + , + ,  X  , 0 , 1) is said to be probabilistic if for any state q  X  Q , the sum of well-defined and in R + and 2.3 N-gram Mapping Transducer We denote by  X  n the n -gram mapping transducer (Blackwood et al., 2010; de Gispert et al., 2013) of order n . This transducer maps label sequences to n -gram sequences of order n .  X  n is similar in form to the weighted finite-state transducer rep-resentation of a backoff n -gram language model (Allauzen et al., 2003). We denote by A n the n -gram lattice of order n obtained by composing lat-tice A with  X  n , projecting the resulting transducer onto its output labels, i.e. n -grams, to obtain an automaton, removing  X  -transitions, determinizing and minimizing (Mohri, 2009). A n is a compact lattice of n -gram sequences of order n consistent with the labels and scores of lattice A . A n typi-cally has more states than A due to the association of distinct n -gram histories with states. 2.4 Factor Automata Definition 3 Given two strings x,y  X   X   X  , x is a factor (substring) of y if y = uxv for some u,v  X   X   X  . More generally, x is a factor of a language L  X   X   X  if x is a factor of some string y  X  L . The factor automaton S ( y ) of a string y is the minimal deterministic finite-state automa-ton recognizing exactly the set of factors of y . The factor automaton S ( A ) of an automaton A is the minimal deterministic finite-state automaton rec-ognizing exactly the set of factors of A , that is the set of factors of the strings accepted by A .
Factor automaton (Mohri et al., 2007) is an ef-ficient and compact data structure for representing a full index of a set of strings, i.e. an automaton. It can be used to determine if a string x is a factor in time linear in its length O ( | x | ) . By associating a weight with each factor, we can generalize the fac-tor automaton structure to weighted automata and use it for efficient storage and retrieval of n -gram posteriors and expected counts. In this section we present an efficient algorithm based on the n -gram posterior computation algo-rithm described in (de Gispert et al., 2013) for computing the posterior probabilities of all n -grams in a lattice and constructing a weighted fac-tor automaton for efficient storage and retrieval of these posteriors. We assume that the input lattice is an  X  -free acyclic probabilistic automaton. If that is not the case, we can use general weighted au-tomata  X  -removal and weight-pushing algorithms (Mohri, 2009) to preprocess the input automaton.
Algorithm 1 reproduces the original algo-rithm of (de Gispert et al., 2013) in our no-tation. Each iteration of the outermost loop starting at line 1 computes posterior probabili-ties of all unigrams in the n -gram lattice A n = ( X  n ,Q n ,I n ,F n ,E n , X  n , X  n ) , or equivalently all n -grams of order n in the lattice A . The inner loop starting at line 6 is essentially a custom for-ward procedure computing not only the standard forward probabilities  X  [ q ] , the marginal probabil-ity of paths that lead to state q , but also the label specific forward probabilities  X   X  [ q ][ x ] , the marginal probability of paths that lead to state q and include label x .  X   X  [ q ][ x ] = Just like in the case of the standard forward al-gorithm, visiting states in topological order en-sures that forward probabilities associated with a state has already been computed when that state is visited. At each state s , the algorithm examines each arc e = ( s,x,w,q ) and updates the forward probabilities for state q in accordance with the re-cursions in Equations 4 and 6 by propagating the forward probabilities computed for s (lines 8-12). The conditional on line 11 ensures that the label specific forward probability  X   X  [ s ][ y ] is propagated to state q only if label y is different from label x , the label on the current arc. In other words, if a label y repeats on some path  X  leading to state q , then  X  contributes to  X   X  [ q ][ y ] only once. This is exactly what is required by the indicator func-tion in Equation 2 when computing unigram pos-teriors. Whenever a final state is processed, the posterior probability accumulator for each label observed on paths reaching that state is updated by multiplying the label specific forward probabil-ity and the final weight associated with that state do . In topological order and adding the resulting value to the accumulator (lines 13-15). It should be noted that this algo-rithm is a form of marginalization (de Gispert et al., 2013), rather than a counting procedure, due to the conditional on line 11. If that conditional were to be removed, this algorithm would com-pute n -gram expected counts instead of posterior probabilities.

The key idea behind our algorithm is to re-strict the computation of posteriors to only those n -grams that may potentially repeat on some path of the input lattice and exploit the equivalence of expected counts and posterior probabilities for the remaining n -grams. It is possible to extend Algo-rithm 1 to implement this restriction by keeping track of repeating n -grams of order n and replac-ing the output labels of appropriate arcs in  X  n +1 with  X  labels. Alternatively we can reformulate Algorithm 1 as in Algorithm 2. In this formulation we compute n -gram posteriors directly on the in-put lattice A without constructing the n -gram lat-tice A n . We explicitly associate states in the orig-inal lattice with distinct n -gram histories which is implicitly done in Algorithm 1 by constructing the n -gram lattice A n . This explicit association lets us reuse forward probabilities computed at order n while computing the forward probabilities at or-der n + 1 . Further, we can directly restrict the n -grams for which posterior computation will be performed.

In Algorithm 2,  X   X  [ n ][ q ][ h ] represents the his-tory specific forward probability of state q , the marginal probability of paths that lead to state q and include length n string h as a suffix.  X   X  [ n ][ q ][ h ] =  X   X  [ n ][ q ][ h ] is the analogue of  X  [ q ] in Algorithm 1. It splits the forward probability of state q (Equa-tion 3), among length n suffixes (or histories) of paths that lead to state q . We can interpret  X   X  [ n ][ q ][ h ] as the forward probability of state ( q,h ) in the n -gram lattice A n +1 . Here ( q,h )  X  Q n +1 denotes the unique state corresponding to state q in the original lattice A and state h in the mapping transducer  X  n +1 .  X   X  [ q ][ h ][ x ] represents the history and n -gram specific forward probability of state q , the marginal probability of paths that lead to state q , include length n  X  1 string h as a suffix and include n -gram x as a substring.  X   X  [ q ][ h ][ x ] = 1. R [ n ] represents the set of n -grams of order n that repeat on some path of A . We start by defin-ing R [0] , {  X  } , i.e. the only repeating n -gram of order 0 is the empty string  X  , and computing  X   X  [0][ q ][  X  ]  X   X  [ q ] using the standard forward algo-rithm. Each iteration of the outermost loop start-ing at line 3 computes posterior probabilities of all n -grams of order n directly on the lattice A . At iteration n , we visit the states in topological order and examine each length n  X  1 history g associated with s , the state we are in. For each history g , we go over the set of arcs leaving state s , construct the current n -gram x by concatenating g with the cur-rent arc label i (line 11), construct the length n  X  1 history h of the target state q (line 12), and update the forward probabilities for the target state his-tory pair ( q,h ) in accordance with the recursions in Equations 8 and 10 by propagating the forward probabilities computed for the state history pair ( s,g ) (lines 14-18). Whenever a final state is pro-cessed, the posterior probability accumulator for each n -gram of order n observed on paths reach-ing that state is updated by multiplying the n -gram specific forward probability and the final weight associated with that state and adding the resulting value to the accumulator (lines 21-24).

We track repeating n -grams of order n to re-strict the costly posterior computation operation to only those n -grams of order n + 1 that can poten-tially repeat on some path of the input lattice. The conditional on line 17 checks if any of the n -grams observed on paths reaching state history pair ( s,g ) is the same as the current n -gram x , and if so adds it to the set of repeating n -grams. At each iteration n , we check if the current length n  X  1 history g of the state we are in is in R [ n  X  1] , the set of re-peating n -grams of order n  X  1 (line 9). If it is not, then no n -gram x = gi can repeat on some path of A since that would require g to repeat as well. If g is in R [ n  X  1] , then for each arc e = ( s,i,w,q ) we check if the length n  X  1 history h = g [1 : n  X  1] i of the next state q is in R [ n  X  1] (line 13). If it is not, then the n -gram x = g [0] h can not repeat either.

We keep the posteriors p ( x | A ) for n -grams that can potentially repeat on some path of the input lattice in a deterministic WFSA P 0 that we con-struct on the fly. P 0 is a prefix tree where each path  X  corresponds to an n -gram posterior, i.e. i [  X  ] = x =  X  w [  X  ] =  X  ( t [  X  ]) = p ( x | A ) . Once the computation of posteriors for possibly repeating n -grams is finished, we use the algo-rithm described in (Allauzen et al., 2004) to con-struct a weighted factor automaton C mapping all n -grams observed in A to their expected counts, i.e.  X   X  in C , i [  X  ] = x =  X  w [  X  ] = c ( x | A ) . We use P 0 and C to construct another weighted factor automaton P mapping all n -grams observed in A to their posterior probabilities, i.e.  X   X  in P , i [  X  ] = x =  X  w [  X  ] = p ( x | A ) . First we remove the n -grams accepted by P 0 from C using the dif-ference operation (Mohri, 2009), and P 0 , and finally optimize the result by remov-ing  X  -transitions, determinizing and minimizing In this section we provide experiments comparing the performance of Algorithm 2 with Algorithm 1 as well as a baseline algorithm based on the ap-proach of (Tromble et al., 2008). All algorithms were implemented in C ++ using the OpenFst Li-brary (Allauzen et al., 2007). Algorithm 1 imple-mentation is a thin wrapper around the reference implementation. All experiments were conducted on the 88K ASR lattices (total size: #states + #arcs = 33M, disk size: 481MB) generated from the training subset of the IARPA Babel Turkish lan-guage pack, which includes 80 hours of conversa-tional telephone speech. Lattices were generated with a speaker dependent DNN ASR system that was trained on the same data set using IBM X  X  At-tila toolkit (Soltau et al., 2010). All lattices were pruned to a logarithmic beam width of 5.

Figure 1 gives a scatter plot of the posterior probability computation time vs. the number of lattice n -grams (up to 5-grams) where each point represents one of the 88K lattices in our data set. Similarly, Figure 2 gives a scatter plot of the max-imum memory used by the program (maximum resident set size) during the computation of pos-teriors vs. the number of lattice n -grams (up to 5-grams). Algorithm 2 requires significantly less resources, particularly in the case of larger lattices with a large number of unique n -grams.

To better understand the runtime characteris-tics of Algorithms 1 and 2, we conducted a small experiment where we randomly selected 100 lat-tices (total size: #states + #arcs = 81K, disk size: 1.2MB) from our data set and analyzed the re-lation between the runtime and the maximum n -gram length N . Table 2 gives a runtime compari-son between the baseline posterior computation al-gorithm described in (Tromble et al., 2008), Algo-rithm 1, Algorithm 2 and the expected count com-putation algorithm of (Allauzen et al., 2004). The baseline method computes posteriors separately for each n -gram by intersecting the lattice with an automaton accepting only the paths including that n -gram and computing the total weight of the re-sulting automaton in log semiring. Runtime com-plexities of the baseline method and Algorithm 1 are exponential in N due to the explicit enu-meration of n -grams and we can clearly see this trend in the 3rd and 4th rows of Table 2. Algo-rithm 2 (5th row) takes advantage of the WFSA based expected count computation algorithm (6th row) to do most of the work for long n -grams, hence does not suffer from the same exponential growth. Notice the drops in the runtimes of Algo-rithm 2 and the WFSA based expected count com-putation algorithm when all n -grams are included into the computation regardless of their length. These drops are due to the expected count compu-tation algorithm that processes all n -grams simul-taneously using WFSA operations. Limiting the maximum n -gram length requires pruning long n -grams, which in general can increase the sizes of intermediate WFSAs used in computation and re-sult in longer runtimes as well as larger outputs.
When there is no limit on the maximum n -gram length, the output of Algorithm 2 is a weighted factor automaton mapping each factor to its pos-terior. Table 3 compares the construction and storage requirements for posterior factor automata with similar factor automata structures. We use the approach described in (Allauzen et al., 2004) for constructing both the unweighted and the ex-pected count factor automata. We construct the unweighted factor automata by first removing the weights on the input lattices and then applying the determinization operation on the tropical semir-ing so that path weights are not added together. The storage requirements of the posterior factor automata produced by Algorithm 2 is similar to those of the expected count factor automata. Un-weighted factor automata, on the other hand, are significantly more compact than their weighted counterparts even though they accept the same set of strings. This difference in size is due to ac-commodating path weights which in general can significantly impact the effectiveness of automata determinization and minimization. Efficient computation of n -gram expected counts from weighted automata was first addressed in (Allauzen et al., 2003) in the context of estimating n -gram language model statistics from ASR lat-tices. Expected counts for all n -grams of interest observed in the input automaton are computed by composing the input with a simple counting trans-ducer, projecting on the output side, and remov-ing  X  -transitions. The weight associated by the re-sulting WFSA to each n -gram it accepts is simply the expected count of that n -gram in the input au-tomaton. Construction of such an automaton for all substrings (factors) of the input automaton was later explored in (Allauzen et al., 2004) in the con-text of building an index for spoken utterance re-trieval (SUR) (Saraclar and Sproat, 2004). This is the approach used for constructing the weighted factor automaton C in Algorithm 2. While ex-pected count works well in practice for ranking spoken utterances containing a query term, poste-rior probability is in theory a better metric for this task. The weighted factor automaton P produced by Algorithm 2 can be used to construct an SUR index weighted with posterior probabilities.
The problem of computing n -gram posteriors from lattices was first addressed in (Tromble et al., 2008) in the context of lattice-based MBR for SMT. This is the baseline approach used in our experiments and it consists of building a separate FSA for each n -gram of interest and intersecting this automaton with the input lattice to discard those paths that do not include that n -gram and summing up the weights of remaining paths. The fundamental shortcoming of this approach is that it requires separate intersection and shortest distance computations for each n -gram. This shortcoming was first tackled in (Allauzen et al., 2010) by in-troducing a counting transducer for simultaneous computation of posteriors for all n -grams of order n in a lattice. This transducer works well for un-igrams since there is a relatively small number of unique unigrams in a lattice. However, it is less efficient for n -grams of higher orders. This inef-ficiency was later addressed in (Blackwood et al., 2010) by employing n -gram mapping transducers to transduce the input lattices to n -gram lattices of order n and computing unigram posteriors on the higher order lattices. Algorithm 1 was described in (de Gispert et al., 2013) as a fast alternative to counting transducers. It is a lattice specialization of a more general algorithm for computing n -gram posteriors from a hypergraph in a single inside pass (DeNero et al., 2010). While this algorithm works really well for relatively short n -grams, its time and space requirements scale exponentially with the maximum n -gram length. Algorithm 2 builds upon this algorithm by exploiting the equiv-alence of expected counts and posteriors for non-repeating n -grams and eliminating the costly pos-terior computation operation for most n -grams in the input lattice. We have described an efficient algorithm for com-puting n -gram posteriors from an input lattice and constructing an efficient and compact data struc-ture for storing and retrieving them. The runtime and memory requirements of the proposed algo-rithm grow linearly with the length of the n -grams as opposed to the exponential growth observed with the original algorithm we are building upon. This is achieved by limiting the posterior compu-tation to only those n -grams that may repeat on some path of the input lattice and using the rela-tively cheaper expected count computation algo-rithm for the rest. This filtering of n -grams in-troduces a slight bookkeeping overhead over the baseline algorithm but in return dramatically re-duces the runtime and memory requirements for long n -grams.
 The authors would like to thank Cyril Allauzen and Graeme W. Blackwood for helpful discus-sions. This work uses IARPA-babel105b-v0.4 Turkish full language pack from the IARPA Babel Program language collection and is supported by the Intelligence Advanced Research Projects Ac-tivity (IARPA) via Department of Defense U.S. Army Research Laboratory (DoD/ARL) contract number W911NF-12-C-0012. The U.S. Govern-ment is authorized to reproduce and distribute reprints for Governmental purposes notwithstand-ing any copyright annotation thereon. Disclaimer: The views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of IARPA, DoD/ARL, or the U.S. Government.
