 In the past few years there has been an increasing interest in the analysis of process logs. Several proposed techniques, such as workflow mining, are aimed at automatically de-riving the underlying workflow models. However, current approaches only pay little attention on an important piece of information contained in process logs: the timestamps, which are used to define a sequential ordering of the per-formed tasks. In this work we try to overcome these limi-tations by explicitly including time in the extracted knowl-edge, thus making the temporal information a first-class cit-izen of the analysis process. This makes it possible to dis-cern between apparently identical process executions that are performed with different transition times between con-secutive tasks.

This paper proposes a framework for the user-interactive exploration of a condensed representation of groups of exe-cutions of a given process. The framework is based on the use of an existing mining paradigm: Temporally-Annotated Sequences ( TAS ). These are aimed at extracting sequential patterns where each transition between two events is anno-tated with a typical transition time that emerges from input data. With the extracted TAS , which represent sets of pos-sible frequent executions with their typical transition times, a few factorizing operators are built. These operators con-dense such executions according to possible parallel or pos-sible mutual exclusive executions. Lastly, such condensed representation is rendered to the user via the exploration graph, namely the Temporally-Annotated Graph ( TAG ).
The user, the domain expert, is allowed to explore the different and alternative factorizations corresponding to dif-ferent interpretations of the actual executions. According to the user choices, the system discards or retains certain hypotheses on actual executions and shows the consequent scenarios resulting from the coresponding re-aggregation of the actual data.
 Copyright200 9ACM 978-1-60558 -495 -9/09/06... $ 5.00. H.2.8 [ Database Applications ]: Data mining Algorithms Workflow mining, temporal sequence mining
In the past few years, many organizations have started to use information systems to support the execution of their business processes [16]. With the increasing number of these available systems, the volume of the available collected pro-cesses logs is growing rapidly. These logs are very useful in several fields: in design and production processes, it could be important to detect the actual state of the process, how many items have been produced and in how much time; in lo-gistics, the optimization of times is crucial; every step should be made strictly on time, and if there are anomalies or prob-lems, the entire logistic solution should be redesigned. For such reasons, the interest in analysing process logs has been increasing rapidly in the last years [23, 21, 6]. How-ever, such logs are hard to analyse from different points of view because there is too much data, the original process diagram is too complex, and there are too many users to observe. Several techniques, such as workflow mining, have been proposed to automatically derive the workflow models originating from the process logs [22, 25, 11]. Their focus is to derive the process model that was actually followed, and this can be different from the original one in several ways, e.g., certain tasks from the original process were never per-formed or were performed too many times, or the tasks per-formed were not in the original diagram. In addition, these techniques answer questions such as: However, current approaches mainly use the temporal infor-mation contained in the logs just for keeping track of the temporal order of the performed tasks.

Indeed, the temporal information associated with logs in the form of timestamps conceals knowledge that allows to distinguish among different temporal behaviours. For example, suppose we have to execute tasks A, B and C and that the transition time from A to B is usually 1 minute, and from B to C it is 9 minutes. If we have a tran-sition time of 9 minutes from A to B and 1 minute from B to C, we are in the presence of an anomaly during the pro-cess, even if the sequence of the performed tasks follows the process workflow. In this case, the usual workflow mining techniques do not detect the anomaly and therefore treat the abnormal execution as normal. In addition to anomaly detection, it could be useful to highlight situations in whi ch some users are faster (or slower) than others in performing certain tasks, or situations in which some resources take to o much time to be performed. In this sense, the model re-turned by the analysis process might be even richer than the original model, since temporal features of the tasks are often kept out of the design phase, or at least they are not explicitly specified in the model.

The contributions of this paper can be summarized in 3 points: (i) a mining method that extensively takes into con-sideration the time information, i.e., the extracted patte rns representing a group of executions of a given process with similar execution times; (ii) extracted patterns are summa -rized by taking into account the semantics of the possible ex -ecutions, namely parallelism or mutual exclusion; (iii) us ers can interact with the extracted and summarized patterns and explore alternative cases proposed by the system.
The first point is based on Temporally-Annotated Se-quences ( TAS ) mining, a novel mining paradigm equipped with an efficient algorithm proposed in [7, 9] and recently successfully applied to biological data [3, 4]. TAS are se-quential patterns where each transition between two events is annotated with a typical transition time that is found fre -quently in the data. In principle, this form of pattern is useful in several contexts: for instance, (i) in web log anal -ysis, different categories of users (experienced vs. novice , interested vs. uninterested, robots vs. humans) might reac t in similar ways to some pages -i.e., they follow similar se-quences of web access -but with different reaction times; (ii ) in medicine, the relationship in time between the onset of pa -tients X  symptoms, drug consumption, and response to treat-ments; (iii) in workflow logs, the typical data is a sequence of operations performed with specific moments. From this, it could be interesting to extract frequent sequences con-taining frequent temporal annotations. TAS patterns have been also used as building blocks for a truly spatio-tempora l trajectory pattern mining framework [8]. In all these cases , enforcing fixed time constraints on the mined sequences is not a solution. It is desirable that typical transition time s, when they exist, emerge from the input data.

In summary we propose a methodology for helping the domain expert in the analysis of process logs. This method-ology aims at understanding which possible models might have generated such logs, and whether such models might also contain temporal constraints. The methodology can be broken down in 4 main pieces described later in section 4.
This framework has been applied to a real-world system: a manufacturing company. We collected the logs of 3 mil-lion transactions on 9 tasks for a total of about 1 million performed tasks processing the access to the design of var-ious mechanic components to be put into production. This factory is located worldwide and therefore the tasks are ex-ecuted by different users at different locations. The results are encouraging, and indeed unexpected behaviours emerge.
The rest of the paper is organized as follows. Section 2 summarizes work related to workflow mining and TAS . Sec-tion 3 introduces the technical details of the TAS paradigm and how it can be used for mining time-annotated data. Section 4 is the core of the paper that presents the original contributions of our work. It describes the overall method-ology: the formal definition of the factorization operators, the exploration graph TAG , and the algorithm for the inter-active workflow analysis. Section 5 presents a case study in which we applied the framework to a real dataset of process logs. Section 6 summarizes the contributions and the result s of this paper and draws some future lines of research.
In this section we summarize some literature strictly rele-vant to the topics of this paper. We first start with works re-lated to workflow mining, and then we present papers where the TAS mining paradigm is applied to different contexts.
In the past few years, research has been performed on discovering a process model from a set of process instances. Most of them assume the existence of a process model un-derlying the given set of process instances. Several differ-ent approaches have been proposed to solve such a prob-lem: in [2, 13] directed graphs are used, and in both papers, the researchers consider tasks that can be executed in par-allel. However, in [13] the notion of parallelism between tasks is more sophisticated, i.e. they go beyond the sim-ple temporal dependency between tasks that was treated in [2]: they define overlapping and disjointed activities. Finite state machines are proposed in [5], and Petri-nets are used in [24] for representing process instances. In [12] the auth ors define the concept of temporal graphs , which help in mod-eling the dependencies among the performed tasks during specific instances of the processes. They propose three dif-ferent algorithms that work with temporal graphs, itemsets or sequences. These algorithms solve the temporal pattern discovery problem, defined as the discovery of the maximal temporal graphs among all frequent temporal graphs. In this work, the authors consider the starting and ending time of each task to explicitly detect situations of parallelism or choice between pairs of tasks. However, they do not look for frequent transition times or execution times of the tasks, i .e. they use the temporal dimension only to detect the temporal dependencies between tasks. In [10] the authors deal with the problem of mining unconnected patterns in workflows, i.e. detecting sets of activities that are frequently execu ted together and do not exhibit explicit dependent relationshi ps. They present two different algorithms for solving the prob-lem. This paper uses the concept of frequency of a pattern, which we employ as well.
 For a survey on workflow mining please refer to [22, 25].
All of the above works explore only on the temporal de-pendencies among performed tasks. In this work we try to go further by looking for frequent subsequences of tasks tha t show temporal dependencies and additionally are executed with a similar transition duration.
In [4, 3] it is shown how it is possible to apply the TAS mining paradigm to medical data when its structure is a sequence of clinical observations taken at different times. In this context the temporal dimension of the data is a variable that should be taken in account in the mining process and returned as part of the extracted knowledge. In these papers a real-world medical case study was reported in which the TAS mining paradigm was applied to such a data.

In [8], the authors introduce a novel spatio-temporal pat-tern that formalizes the idea of aggregate movement be-haviour. In their approach a trajectory pattern is a sequenc e of spatial regions that, on the basis of the source trajector y data, emerge as frequently visited in the order specified by the sequence; in addition, the transition between two con-secutive regions in this sequence is annotated with typical travel times that emerge from the input trajectories.
Time in FSP (Frequent Sequence Patterns) is mainly con-sidered (i) for the sequentiality that it imposes on events; (ii) as a basis for user-specified constraints, aimed to select an interesting subset of patterns; (iii) as a pruning mechanis m to shrink the pattern search space and make computation more efficient. In all of these cases, time is not explicitly returned in the ouput as timestamps or timestamped inter-vals, although in some cases interval precedence and overla p is expressed [19, 26, 14, 17, 18, 15, 20].

The TAS mining paradigm, introduced in [9], tries to over-come such limitations, by defining a form of sequential pat-terns annotated with temporal information (or temporally-annotated sequences, TAS in short) that represent typical transition times between events in the sequence.
 More formally:
Definition 1 ( TAS ). Given a set of items I , a tempo-rally-annotated sequence of length n &gt; 0 , called n-TAS or simply TAS , is a couple T = ( s,  X  ) , where s = h s 0 , ..., s  X  0  X  i  X  n s i  X  2 I is called the sequence , and  X  = h  X  1 R + is called the (temporal) annotation . TAS will also be represented as follows:
Making use of this new form of pattern, the standard se-quential pattern mining problem is redefined as the extrac-tion of frequent TAS , in the following way.

Definition 2 (Frequent TAS ). Given a set D of TAS , a time threshold  X  and a minimum support threshold  X  , we define the  X  -support of a TAS T as supp [  X , D ] ( T ) = | { T D | T  X  T  X  } | and say that T is frequent in D , given a minimum support threshold  X  if supp [  X , D ] ( T )  X   X  .
Such definition is based on a containment relation,  X  , that extends the basic sequence containment relation by adding temporal constraints to the occurrences of the pat-tern. Such constraints essentially require that the tempor al gaps in the occurrence be similar to the transition times in the TAS , where similar means, in this context, to be equal up to a maximal deviation  X  : Definition 3 (  X  -containment (  X  )). Given a n-TAS T 1 = ( s 1 ,  X  1 ) and a m-TAS T 2 = ( s 2 ,  X  2 ) with n  X  m , and a time threshold  X  , we say that T 1 is  X  -contained in T noted as T 1  X  T 2 , if and only if there exists a sequence of integers 0  X  i 0 &lt; ... &lt; i n  X  m such that:
In this paper, we will make use of a software described in [9], named MiSTA, that extracts the complete set of frequent TAS , and returns a concise representation of the following form: that can be read as: the sequence s 0  X  . . .  X  s n appears frequently in the dataset, with typical transition times t [ a , b 1 ] for the first transition, t 2  X  [ a 2 , b 2 ] for the second one, and so on.

The software also allows to focus on contiguous occur-rences, i.e., to consider only subsequences with no gaps in the support calculation of TAS . This feature will be ex-ploited in the experimental part of the paper.
In this section we introduce a methodology for helping the domain expert in the analysis of process logs, aimed at understanding which possible models might have gener-ated such logs, and whether such models might also contain temporal constraints. The methodology is composed of the following elements:
Performing these operations manually, by analyzing large quantities of information (such as 1 million of tasks per-formed as in our case study in section 5) is unfeasible and may not guarantee to discover what the domain expert or the workflow designer was looking for.

In the following, we start the discussion by summariz-ing the ultimate objective of this work, i.e., an interactiv e workflow analysis system. Then, for ease of presentation, we first describe the kind of data our analysis starts from (i.e., workflow traces) and define the above mentioned fac-torization operators over such data type. After that, the TAS -based representation of the input data is briefly de-scribed, extending the factorization operators to the case of TAS and defining a graph summarization of sets of TAS . Both the factorization operators and the graph representa-tion will be the building blocks of the final analysis system, which is then described in more detail.
One of the most important objectives in workflow analysis consists in reconstructing (part of) the workflow model that has generated a given dataset of process execution traces. This sort of reverse engineering operation is often very use-ful for comparing the model derived from the traces with the original model that generated them. This kind of compari-son might highlight some design mistakes, useless or redun-dant parts of the model or, in general, a usage of the model that differs from the intentions of its designer (e.g., conta in-ing the systematic adoption of actions that were originally meant to be exceptional measures).

Reconstructing the model underlying a set of process traces usually requires to make some guesses about the scheduled order of operations in the model, or whether some sets of actions were executed in parallel ( parallelism ) or they were executed as mutually exclusive alternatives ( choice ). The method proposed in this work tries to perform such a re-construction in a step-by-step fashion, selecting (with th e aid of the user) and isolating at each stage a single relation between actions, and iterating the process till all signific ant relations were caught. The whole process can be sketched as follows: 1: Represent the input set of process traces through a set 2: while user does not stop the execution do 3: Compute a graph-based summary of the actual set of 4: Detect the potential cases of parallelism and choice 5: Ask the user to choose a single case of parallelism or 6: if backtrack
As we can see, the approach requires the interaction with the user, for choosing, among the several possible alterna-tives available at each step, the factorization that looks more promising. Performing such choice automatically would re-quire to have a function that correctly evaluates the qualit y or utility of any alternative (i.e., any case of parallelism or choice ) and selects the best one. To the best of our knowl-edge, the state-of-art of the field is still far from defining any function of this kind having a sufficiently wide applica-bility, therefore our solution demands this heavily domain -dependent evaluation to the user. The interaction with the user is facilitated by means of a graphical, graph-based, su m-marization of the set of TAS at hand, which provides a com-plementary, more readable view of the same data, that can help in choosing the next most interesting factorization st ep to perform, among those listed by the system. These aspects are detailed in Sections 4.6 and following ones.
The digital traces collected during the re-iterated execu-tion of a workflow process essentially have a sequential na-ture, and describe the ordered list of actions executed in ea ch run, together with the agents who performed them and the date/time of execution: Definition 4 (Workflow trace, Workflow log).
 Let A be a finite set of actions and U a finite set of users. Then  X  = h ( a 1 , u 1 , t 1 )( a 2 , u 2 , t 2 ) . . . ( a A , u i  X  U and t i is a timestamp describing when the user u atomically performed a i , is a Workflow trace or Process instance . A set L of workflow traces is a Workflow log . Therefore, a workflow log describes several runs (i.e., in-stances) of the same workflow process, each run being rep-resented as a sequence of operations. An example of such a data can be found in Table 1 in Section 4.8, where two workflow traces (identified by the column  X  X nst.ID X ) are rep-resented, each containing 4 actions (tasks) performed by a unique user at different times.

Basic applications of workflow log analysis focus on the sequences of actions performed in each trace, therefore dis re-garding the user identity and the temporal information, and representing each trace essentially as a sequence of items. For instance, the sample workflow log in Table 1 could be reduced to a set of two sequences: { x  X  a  X  b  X  c, x  X  b  X  a  X  c } .
As mentioned above, a typical workflow model can sched-ule the actions in several ways, including sequential execu -tion (action a must be executed before b ), parallel execution ( a and b are launched together), and choice (only one be-tween a and b is executed). A simple way to infer the pres-ence of a parallelism or of a choice looking at a set of process instances, then, consists in locating possible evidences ( or just clues) of such relations in the traces. On one hand, two actions invoked in parallel can appear in the traces in any order; on the other hand, two actions that form a choice can never appear one after the other. Following these basic idea s we define two relations between actions, that hold when the workflow traces suggest that a pair of actions might be ex-ecuted in parallel or as a choice:
Definition 5 (Items relationships). Let I be a set of items, and S be a set of sequences of items. Then, given a, b, x  X  I , we define the relations a k x b (read  X  a is parallel to b w.r.t. x  X ) and a % x b (read  X  a is in choice with b w.r.t. x  X ) as follows: where  X  is the substring relation, i.e., s  X  s  X  X  iff all items of s appear in s  X  in the same order and in contiguous positions.
In the above definition, the relation between two items takes into consideration not only their relative positions in the input sequences, but also a limited form of context : both items ( a and b ) are preceded by a common item ( x ). This is a trade-off between more conventional relations defined in literature (e.g., [16]), mostly focused only on the items involved, and a more general approach that takes into con-sideration a larger number of items in the past context and a number of items also in the future context , i.e., situations like x 1  X   X  x N  X  a  X  b  X  y 1  X  y M . In our case, essentially, we are considering N = 1 and M = 0.

Example 1 ( k x ). If we have the sequences: x  X  a  X  b, x  X  b  X  a , then, according to Definition 5, we can write: a k x b . On the contrary, in the case of sequences: x  X  a  X  b, y  X  b  X  a there is no parallelism under our definition, since each context (resp. x and y ) leads to a distinct and coherent order of a and b . More standard definitions of parallelism do not consider the provenance of subsequences a  X  b and b  X  a , therefore they are mixed up and interpreted as a unique evidence of a parallelism.
Example 2 ( % x ). If we have the sequences: x  X  a  X  b, x  X  b  X  d , then, according to Definition 5, we can write: a % x b . If we add the sequence x  X  b  X  a to this example, a % x b does not hold anymore, while now it holds a k x b .
After defining which pairs of items/actions might poten-tially be in relation, we provide a function that lists all su ch relations, divided in parallelisms and choices:
Definition 6 (Parallelism detector). We define an unary operator P ( S ) that associates to a set of sequences S the collection of relations of parallelism contained in S , i.e., P ( S ) = { ( x, a, b ) | a k x b in S } .

Definition 7 (Choice detector). We define an unary operator C ( S ) that associates to a set of sequences S the col-lection of relations of choice contained in S , i.e., C ( S ) = { ( x, a, b ) | a % x b in S }
Example 3 (Detectors). Given a set of sequences S = { x  X  a  X  b  X  c, x  X  b  X  a } , the following holds:
The approach proposed in this work consists in iteratively selecting one of the possible relations between items, and then factorizing it in the traces, i.e., locating the occurrences of such relation and replacing the items involved with a new element that represents the pair of items and the relation that connects them. That yields a new set of traces, where the selected relation between items has been isolated and emphasized.

Definition 8 (Factorize k ). Let S be a set of sequences. Given ( x, a, b )  X  P ( S ) , we define the operator F actorize k (( x, a, b ) , S ) = S  X  , where every subsequence x  X  a  X  b or x  X  b  X  a of s  X  S is replaced with x  X  a k b , where a k b is a new item.

Definition 9 (Factorize % ). Let S be a set of sequences. Given ( x, a, b )  X  C ( S ) , we define the operator F actorize % (( x, a, b ) , S ) = S  X  , where every subsequence x  X  a or x  X  b of s  X  S is replaced with x  X  a % b , where a % b is a new item.

On the new set of traces obtained by applying one of the factorization operators above, the same kind of analysis (d e-tection of relations) and transformation (factorization) can be applied, iteratively.
 Example 4 (Factorization). Given S , P ( S ) and C ( S ) as in Example 3, we can apply the factorization oper-ators in the following way:
Applying the operators described above to the raw work-flow traces has some drawbacks, mainly due to the possible presence or errors (missing actions, or actions registered by mistake) or very rare behaviours that we might want to ex-clude from the analysis.

Our approach provides that the analysis is carried out not on the original traces but on a set of TAS that represent the frequent behaviours (w.r.t. a given frequency threshold) a nd their temporal characteristics. That yields two results: An example of TAS obtained from an input dataset of work-flow traces is given in Table 2. Each TAS represents a se-quence of actions (e.g., x  X  a in the first TAS listed) to-gether with the set of typical transition times taken to move from one action to the next one (e.g., any time t  X  [18 , 20], for the first TAS ).

The set of TAS used to represent the original traces can be selected following different criteria. Beside adopting diff er-ent parameters and thresholds for the TAS mining phase, we could choose to use all the TAS extracted, or just the maxi-mal ones, or those that satisfy other constraints, for insta nce temporal (e.g., take only patterns having duration longer than 5 minutes) or structural constraints (e.g., exclude pa t-terns where the same action appears twice, thus evidencing the presence of a loop). For simplicity, in this paper we will adopt the first option, thus using all the TAS extracted. However, the whole analysis process can be equally applied with different selection criteria.

In the following we extend the operators described above in order to treat TAS , instead of simple sequences.
All the definitions given for workflow traces do not take into account the temporal dimension contained in the data we work with. In order to add the time to our model, we redefine them for the case where the input sequences are a set of TAS , as follows.

From now on, we assume to have a set of TAS T , each TAS being represented as a pair t = ( s,  X  ), where s is a sequence of items and  X  is a sequence of transition times. We also define as S T the set of sequences that appear in T , without times, i.e., S T = { s | ( s,  X  )  X  T } . Then, definitions 5, 6 and 7 can be applied to S T , essentially defining and locating parallelisms and choices only on the sequence component of our TAS .

However, since when we solve a parallelism or choice in-stance we have to perform some operations to the temporal annotations on the corresponding sequences, we should re-define the factorization operators as follows.
 Definition 10 (Factorize k ). Let T be a set of TAS . Given ( x, a, b )  X  P ( S T ) , we define the operator F actorize k (( x, a, b ) , T ) = T  X  , where every temporally an-notated substring x  X  0  X  X  X  X  a  X  1  X  X  X  X  b of ( s,  X  )  X  T is replaced by x  X  0  X  X  X  X  a k b , and every temporally annotated substring x  X  X  X  X  b  X   X  1  X  X  X  X  a of ( s  X  ,  X   X  )  X  T is replaced by x  X   X  where a k b is a new item.
 Definition 11 (Factorize % ). Let T be a set of TAS . Given ( x, a, b )  X  C ( S T ) , we define the operator F actorize % (( x, a, b ) , T ) = T  X  , where every temporally anno-tated substring x  X  0  X  X  X  X  a of ( s,  X  )  X  T is replaced by x a % b , and every temporally annotated substring x  X   X  0  X  X  X  X  b of ( s,  X  )  X  T is replaced by x  X   X  0  X  X  X  X  a % b , where a % b is a new item.
 Example 5 (Factorization). Given a set of frequent a } , its corresponding set of sequences is S T = { x  X  a  X  b  X  c, x  X  b  X  a } . Then, we can apply the factorization operators in the following way:
The set of TAS extracted from a database of workflow traces can be rather large, though usually much less than the original data. That makes it difficult for a human expert to obtain an overall picture of the sequences of tasks describe d by the data by simply sifting through them. For this reason, in this work we define a graph data structure that provides a complementary, lossy yet easy-to-read view of the set of TAS under analysis.
 Definition 12 (Temporally-Annotated Graph).
 Given a set T of frequent TAS , we define the temporally-annotated graph ( TAG ) for T as a labeled graph G ( T ) = h V, E, l i , whose nodes represent the actions appearing in T , the edges represent pairs of actions performed consecutive ly in at least one TAS of T , and the label of each edge is a set containing all the transition times that occurred in any TAS between the two corresponding consecutive actions. More formally: Figure 1 shows the Temporally-Annotated Graph correspond-ing to the starting set of TAS in Example 5. As we can see, all actions, all transitions between consecutive actions a nd all transition times contained in the TAS are depicted in the graph. On one hand, the graph loses some information, since all sequences longer than 2 in the TAS are virtually broken into pieces of length 2, not allowing to understand whether there is a loop in the starting sequences ( a  X  b  X  a ) or whether b  X  c is preceded by a in any sequence or, on the contrary, any sequence that passes through a terminates at b . On the other hand, the graph allows to understand at first sight some useful properties, for instance the fact tha t x plays the role of a source node, and c that of a terminal Figure 2: TAG after choice factorization in Examp. 5 node, while between a and b there is not a strict order, which might be due to a loop or a case of parallelism. For compar-ison, in Figure 2 it is reported the TAG corresponding to the previous set of TAS after the factorization of a choice case. Notice that: (i) factorizing the choice case has as a side effe ct the disappearance of the parallelism located in the origina l set of TAS , due to the fact that the two relations were in con-flict and therefore the user must give priority to only one of them and disregard the other; (ii) the transition times for the rightmost edge ( b  X  a % c ) are obtained as union of those of b  X  a and b  X  c , which is a direct effect of the way the labels of edges are defined in Definition 12.

Notice that our definitions of parallelism and choice in-volve a notion of context , that leads, in the case of paral-lelism, to check relations between actions in sequences of length 3 (which might become longer, if we extend the defi-nitions to consider a longer context). That means that such relations cannot be clearly identified from the graph alone, and therefore the factorization analysis must be performed directly on the TAS , as done in Section 4.5.
The operators defined in the previous section allow to de-tect particular situations present in the dataset (paralle lisms and choices), and to transform the latter in order to group the items involved.

We remark that the order of application of the operations is relevant, since after applying an operator the condition s for applying another operator could be not valid anymore (e.g., the result of a factorization for parallelism could d e-stroy the subsequences that created a situation of choice), or simply the result could affect a different part of the dataset. In order to take into consideration all the possible sequenc es of operators applicable, we define a graph that represents the partially ordered set ( poset ) of all datasets that can be obtained from the original one ( T ), through a sequence of factorizations.
 Definition 13 (Poset graph). Given a dataset T of TAS, we represent the poset of transformations of T through a poset graph P G ( T ) = ( V, E ) , where: such that i.e., V is the fix-point of operator P C  X  applied to the original dataset, which yields the set of datasets obtained through a sequence of factorizations, and E connects each dataset with the dataset it was obtained from. If the original dataset of TAS is complex and contains critical situations, such that items involved in several parallelis ms or choices, loops, etc., the set of transformed datasets can be very large. Therefore, it could be impractical for the end -user to simply fetch the whole graph of transformations. In Algorithm 4.7, we sketch an interactive procedure that ex-tracts only a subset of the possible transformations, by ask -ing the user which branch of the graph to explore, possibly backtracking to previous nodes of the graph: Figure 3 shows Input: dataset of process logs L
Output: a set T of (factorized) TAS
Algorithm 1: Interactive Poset Graph Navigation an example of a complete poset graph for a small dataset. The topmost TAG represents the (graph representation of the) set of TAS exctracted from the input workflow log, as described in steps 1 X 3 of Algorithm 1. Then, each arrow rep-resents a possible factorization operation for a given set o f TAS (see step 4), and each time the user chooses one of such operations (step 5) the algorithm factorizes the actual set of TAS accordingly, and re-iterates the computation focusing on the resulting set of TAS .
In this section we present a run-through example on a toy dataset of only 2 days of logs, where each day represents a transaction. For each transaction we have a sequence of performed tasks, together with their timestamps. Table 1 shows the data under investigation. On this data we apply the TAS mining paradigm, in order to extract sequences that are executed frequently with typical transition times. Tab le 2 shows the TAS mined with minimum support  X  = 10% and temporal tolerance  X  = 1.

Figure 3 shows the poset graph of TAG that can be ob-tained starting from the TAG G 1, which is the root of the graph. As we can see, we can have several possibilities at a certain level, for example after we generate graph G 2. Each of them corresponds to having chosen to solve a particular parallelism or choice, first by enumerating all the possibil -ities by using one of the two detector operators defined in Section 4, then by applying the corresponding factorizatio n operator. Choosing which parallelism or choice to solve wil l correspond to choose a path of TAG along the graph. In this way we can navigate through all the possible actions that we can perform on the original mined workflow TAG .
In this section we present the work done as a case study on real-life data. The dataset comes from the usage of a real-world system developed by Think3[1], which is an ob-ject repository managing system, that allows the users to operate on the same objects from different locations. The timestamps contained on the logs represent the exact mo-ment in which the event occurred. In particular, we did not have the starting and ending time of an operation, so we as-sumed that they are instantaneous and that the timestamps generally refer to the pair (execution time, transition tim e).
The dataset contains about 300000 transactions on 9 tasks, for a total of about 1 million of performed tasks. The logs span along 6 months of executions. For our analysis, we used a quite low support threshold of 0.5%, coupled with a  X  of 1000 (seconds). Surprisingly, even these thresholds wer e enough to cut away two tasks from the frequently obtained annotated sequences. This proves that by manipulating the  X  and  X  parameters one can perform different grained anal-ysis, even focusing on a frequently performed subprocess. Figure 4 shows a graph derived from the sequences of the original dataset of process logs in input, obtained with a procedure identical to the construction of TAG , but without dealing with the temporal information.

Figure 5 shows the TAG resulting from the initial mining step, before looking for any dependency among the activi-ties. As we can see, the  X  and  X  parameter played already an interesting role in this first step: several paths in the grap h have disappeared, making 2 out of 9 tasks disappear as well. Of course, using a lower minimum support and/or a higher  X  would have resulted in a more selective mining, making several other paths and tasks disappear from the graph.
We then followed the steps we have described on the pre-vious section: after running the TAS mining software, we applied all the operators we have in our framework, look-ing for interesting dependency situations. After one step of analysis, we found one parallelism and several choices. We followed the parallelism, obtaining the TAS graphically depicted in Figure 6.

If we go one step forward, solving the choice between (Ad-ministrator) and (Modify) , we can note an interesting event: due to the particular handling of the temporal annotations and to the definition of the choice splitter, the annotations of the (Administrator) task became split between the choice node and what was left to the old (Administrator) node. Thanks to this particular feature, it was possible to detect frequent temporal behaviours that can be actually divided in two sub-behaviours. This situation is depicted in Figure 7. As we can see, this framework is particularly suitable for any kind of temporal analysis of process logs. Thanks to the temporal annotations, it is easily possible to find bottlene cks on the process, unexpected behaviours, separate useless or redundant temporal information while performing business process analysis and so on. The TAS mining paradigm gives also the possibility, by a proper use of the minimum support parameter (  X  ), to look at the executed task with different granularity, looking for the most followed paths. The frame -work hence results particularly suitable for performing De lta Analysis and Performance Analysis. Analysts, in fact, can take advantage of our methodology in two ways: by using it-eratively and interactively the two operators described in the paper, they can detect situations of choice and parallelism performed by the users (either as their free choice or becaus e it was an intrinsic requirement of the corresponding tasks) that were not designed, and discover a workflow diagram dif-ferent from the designed one (Delta Analysis); or they can take advantage of the temporal information contained in the TAG to discover bottlenecks or to optimize the execution of (part of) the process, by looking at the expected (possibly
Figure 7: The TAG after two factorization steps designed) time needed to perform particular (sequences of) tasks (Performance Analysis).
In this work we have introduced a novel framework for mining workflow graphs from process logs that enables the user to perform a temporal analysis by means of a TAS -based mining paradigm. We have presented a methodology for helping the domain expert in the analysis of process logs , aimed at understanding which possible models might have generated such logs, and whether such models might also contain frequent temporal behaviours.

After a run-through example, we have presented a case study in which our model and framework have been used to perform visual temporal analysis on a real-life process log dataset. Based on this work, we have thus showed how the framework results suitable for performing Delta Anal-ysis and Performance Analysis involving also the temporal dimension contained in the data. The results in these di-rections are encouraging, and indeed let emerge unexpected behaviours in our case study.

We plan to develop a complete software for performing such an analysis, which will guide the user through an iter-ative and interactive navigation of the poset of the possibl e workflow diagrams that the data can support. We plan also to investigate the possibility of extending the management of the transition times, in order to handle non-instantaneous ly executed tasks, which will enable an even more sophisticate d temporal analysis of the data.

A possible research direction would be also to take the original designed workflow diagram as input, considering it during the mining step to better analyze the process logs. [1] The think3 company. http://www.think3.com. [2] Rakesh Agrawal, Dimitrios Gunopulos, and Frank [3] Michele Berlingerio, Francesco Bonchi, Fosca [4] Michele Berlingerio, Francesco Bonchi, Fosca [5] A. Datta. Automating the discovery of AI-IS business [6] P. Lawrence (ed). Workflow Handbook 1997, Workflow [7] Fosca Giannotti, Mirco Nanni, and Dino Pedreschi. [8] Fosca Giannotti, Mirco Nanni, Dino Pedreschi, and [9] Fosca Giannotti, Mirco Nanni, Dino Pedreschi, and [10] Gianluigi Greco, Antonella Guzzo, Giuseppe Manco, [11] Gianluigi Greco, Antonella Guzzo, Luigi Pontieri, and [12] San-Yih Hwang, Chih-Ping Wei, and Wan-Shiou [13] San-Yih Hwang and Wan-Shiou Yang. On the [14] Steffen Kempe and Jochen Hipp. Mining sequences of [15] Frank Klawonn. Finding informative rules in interval [16] Hongyan Ma. Process-aware information systems: [17] Fabian Moerchen. Algorithms for time series [18] Panagiotis Papapetrou, George Kollios, Stan Sclaroff, [19] Dhaval Patel, Wynne Hsu, and Mong Li Lee. Mining [20] Po shan Kam and Ada Wai chee Fu. Discovering [21] S.Jablonski and C.Bussler. Workflow Management: [22] W. M. P. van der Aalst, B. F. van Dongen, J. Herbst, [23] Wil M. P. van der Aalst, J  X org Desel, and Andreas [24] Wil M. P. van der Aalst and Kees M. van Hee.
 [25] T. Weijters and W. M. P. van der Aalst. Process [26] Edi Winarko and John F. Roddick. Discovering richer
