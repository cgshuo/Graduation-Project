 Structural joins, or containment joins, have been identified as important oper-ations for finding structural relationships, such as ancestor-descendant, within XML documents [1, 3, 6, 13, 15]. Important for XML query processing, a struc-tural join is a set-at-a-time operation that finds all the ancestor-descendant relationships between two different sets of node elements.

Many prior approaches to structural joins assume that each node element is first labeled as an interval [3, 6, 15], ( start, end ), a pair of numbers representing the start and end positions of the element in the document tree [4, 15], encoding the region of the node. 1 Structural joins are then performed on these intervals. In this paper, we similarly assume that node elements are labeled as intervals.
With region-encoded intervals, a structural join can be formally defined as follows. Given two input lists, A and D ,where A contains intervals representing ancestor node elements and D contains intervals representing descendant node elements, a structural join is to report all pairs ( a, d ), where a  X  A and d  X  D , such that a.start &lt; d.start &lt; d.end &lt; a.end .Inotherwords, a contains d .
Various approaches have been proposed to perform structural joins. Most of them assume (i) offline indexes are maintained on disks for both input sets [9, 15, 3, 6], or (ii) the elements in both input sets are sorted [8, 15, 1, 3, 6], or (iii) both. However, maintaining indexes on disks incurs both storage and CPU costs for storing and updating the indexes, and sorting the elements is rather time consuming. More important, as pointed out in [13], not all elements in an XML document are indexed or sorted beforehand. In contrast, we describe an on-demand, in-memory indexing approach, which does not require node elements to be sorted. To the best of our knowledge, this is the first on-demand, in-memory indexing approach to efficient structural joins.

Because node elements are labeled as intervals, we discover that there are similarities between the problems of structural joins and stabbing queries [11]. A stabbing query problem is to find all the intervals that are stabbed by a point. A structural join problem is to find all the ancestor/descendant element pairs in an XML document. The two problems are similar if we treat all the ancestor elements as intervals and use the start points (or end points) of all the descendant elements to stab the ancestor intervals. Unfortunately, previous work on stabbing queries is not directly applicable to structural joins. For example, although efficient in search time, the state-of-the-art CEI (Containment-Encoded Interval) index [14] can incur a high storage cost for structural joins.
In this paper, we develop a new, on-demand, stabbing query-based index for structural joins, referred to as StabQ-OD . Besides keeping the advantage of fast search time, it considerably l essens the high-storage-cost problem by two storage reduction techniques: unit-length grid elimination and domain range partitioning . We found that the storage cost can be reduced by almost 50% by eliminating the unit-length grid intervals. Moreover, the entire domain range of the ancestor elements can be divided into multiple ampartitions. Structural joins can then be performed serially or in parallel on individual domain partitions.
In [1], an in-memory stack was used to facilitate structural joins of two or-dered interval lists. It was the state-of-the-art non-indexed, main memory-based approach, but the elements in both input sets must be in a sorted order. In [3, 6], offline indexes were maintained on disks on the elements to help skip those with-out matches. A B + -tree was proposed in [3] to skip descendants without matches. An XR-tree was proposed in [6] to skip b oth ancestors and descendants without matches. The XR-tree was the state-of-the-art approach that uses indexes to skip elements. However, some elements might not have pre-built indexes. In [13], a relational DB-based approach to structural joins was proposed. Each XML node element was labeled with a number derived from embedding the XML document tree onto a perfect binary tree. After the labeling, structural joins are transformed into equi-joins and the traditional join operator of a relational DBMS can be called upon to perform the operations. There is no need to sort the elements or maintain indexes on disks. However, this is not a main memory-based approach like ours. In [12], a partition-based scheme was proposed for efficient processing of XML containment queries. However, it is not an index-based approach like ours. A staircase join was proposed in [5]. It is based on ordered encoding of XML documents and never builds indexes.

Finally, structural joins can also be applied to the problem of holistic twig joins [2, 7], which finds the occurrences of a much more complex structural path or twig in an XML document. It can be performed by first applying structural joins to individual sub-paths between two node elements and then combining the intermediate results. However, holistic joins are outside the scope of this paper. In this paper, we focus on structural joins between two sets of node elements.
The rest of the paper is organized as follows. Section 2 briefly summarizes the original CEI indexing scheme for stabbing queries. Section 3 describes the StabQ-OD schemes for structural joins. Section 4 shows our performance studies. Finally, Section 5 summarizes the paper. 2.1 Containment-Encoded Intervals Fig. 1 shows an example of containment-encoded intervals and their local ID labeling for CEI indexing. Assume the range of interest of an attribute A is [0 ,r ). First, the range is partitioned into r/L segments of length L , denoted as S ,where i =0 , 1 ,  X  X  X  , ( r/L  X  1), L =2 k ,and k is an integer. Note that r is assumed to be a multiple of L .Segment S i contains all the attribute values in [ iL, ( i +1) L ). Then, 2 L  X  1 CEI X  X  are defined for each segment.

These 2 L  X  1 CEI X  X  have containment relationships among them. The labeling of CEI X  X  is encoded with such relationships. The ID of a CEI has two parts: the segment ID and the local ID. For each segment, 1 , 2 ,  X  X  X  , 2 L  X  1 are assigned to each of the 2 L  X  1 CEI X  X  as their local IDs. The local ID assignment follows the labeling of a perfect binary tree. Fig. 1 shows the assignment of local IDs to CEI X  X  within a segment. The global unique ID for a CEI in segment S i ,where i =0 , 1 ,  X  X  X  , ( r/L )  X  1, is simply computed as l +2 iL ,where l is the local ID. The local ID of the parent of a CEI with local ID l is l/ 2 , and it can be efficiently computed by a logical right shift by 1 bit.
 Note that CEI X  X  can be alternatively viewed as multi-layered grid intervals. There are k + 1 layers, where k = log( L ). The length of a grid interval at layer i is exactly twice that of a grid interval at layer i +1, where 0  X  i  X  k .Layer-0 grid intervals have a length of L while layer-k grid intervals have a length of 1. 2.2 Insertion and Search Operations To insert a query interval, it is first decomposed into one or more grid intervals, then its ID is inserted into the ID lists associated with the decomposed grid intervals [14]. Fig. 2 shows an example of CEI indexing. It shows the decom-position of four query intervals: Q 1 ,Q 2 ,Q 3and Q 4 within a specific segment containing grid intervals of c 1 ,  X  X  X  ,c 7. Q 1 completely covers the segment, and itsIDisinsertedinto c 1. Q 2 lies within the segment and is decomposed into c 5 and c 6, the largest grid intervals that can be used. Q 3 also resides within the segment, but its right endpoint coincides with a guiding post. As a result, we can use c 3, instead of c 7and c 8 for decomposition. Similarly, c 2isusedtodecompose Q 4. As shown in Fig. 2, query IDs are inserted into the ID lists associated with the decomposed grid intervals.
The search algorithm is simple and efficient [14]. As an example, to search with a data value x in Fig. 2, the local ID of the unit-length grid interval that contains it is first computed. In this case it is c 5. Then, from c 5, the local IDs of all its ancestors that contain c 5 can be efficiently computed via containment encoding. Namely, the parent of a grid interval with local ID l can be computed by a logical right shift by 1 bit of l . In this case, they are c 2and c 1. As a result, the search result is contained in the 3 ID lists associated with c 1 ,c 2and c 5. We can verify from Fig. 2 that the result indeed contains Q 1 ,Q 2 ,Q 3and Q 4. 3.1 StabQ-SP With each node element encoded with a pair of integers, ( start, end ), the struc-tural relationship between two elements can be easily determined [6, 15, 1, 3]. For any two distinct elements u and v in a tree-structured document, the following holds [6]: (1) The region of u is either completely before or completely after that of v ;or(2)theregionof u either contains that of v or is contained by that of v . Namely, two intervals never partially overlap with each other.

With this complete containment property, the problem of structural joins of two sets of intervals can be transformed into one that searches the CEI index of the ancestor intervals with the start, or end, points of the descendant intervals. Theorem 1. A structural join of two sets of intervals, A and D , can be carried out by (a) constructing a CEI index with all the intervals in A ,(b)usingthe start (or end) point of each interval d ,where d  X  D ,tosearchtheCEIindex, and (c) constructing a join pair ( a, d ) for each a  X  A d ,where A d is the set of interval IDs from the search output in (b).
 Proof: Fig. 3 shows an example of structural joins viewed as stabbing the an-cestor intervals with descendant start points. We draw each element interval as a horizontal line segment. Let A d be the set of interval IDs stabbed by the vertical line at the start point of a descendant interval d . Because there is no partial overlapping between any two elements, each a  X  A d must completely contain d . Since the result of searching the CEI index with the start point of a descendant interval d contains all the ancestor intervals that cover the point, such a search operation generates all the join output pairs involving d . Similar arguments can be made regarding the end point of a descendant interval.
 Note that because of node element nesting, not uncommon in XML documents, we can use only the start or end point of a descendant element to search the CEI index of the ancestor elements for performing structural joins. For example, in Fig. 3, a 2 contains d 3 , but not d 2 . 3.2 StabQ-OD Unit-Length Grid Elimination. The storage cost of the StabQ-SP can be too high, especially if the domain range r is large. From Fig. 2, the pointer array will be large if r is large.
 Theorem 2. For structural joins, the unit-length grid intervals can be com-pletely eliminated. Proof: A unit-length grid interval can only appear at the left endpoint and/or the right endpoint of an ancestor element after decomposition [14]. Because node elements are encoded with a pair of integers, representing the start and end positions of the element in the document, no two elements can share the same endpoint and the minimal length of an descendant interval is 1. As a result, the start point of a descendant element would never stab at the portion of an ancestor element that corresponds to a unit-length grid interval. Hence, unit-length grid intervals can be eliminated.
 Note that the minimal ancestor element that can possibly contain a descendant element has a length of at least 3 (see Fig. 4). This is because (a) the length of any descendant element must be greater than or equal to 1 and (b) any pair of elements cannot share the same endpoint. Therefore, ancestor elements of length 1 or 2 can be ignored in index construction. Theorem 3. For structural joins, any grid interval of length greater than or equal to 2 cannot be eliminated, even if the minimum length of a descendant element is greater than 2.
 Proof: This theorem can be proved by a counter example. Fig. 5 shows an example of a descendant element of length 4. It is contained by an ancestor element of length 6. However, the start point of the descendant element d stabs the ancestor element at the decomposed grid interval c 1 , which is of length 2. Hence, we cannot eliminate grid intervals of length 2. Domain Range Partitioning. Even with unit-length grid intervals completely eliminated, the index storage cost of StabQ-OD can still be high. Containing lots of empty pointers, the pointer array can be replaced with a hash table. However, a hash computation can be too costly, compared with a direct array access.
Instead, we can divide the domain range into multiple partitions and perform structural joins serially or in parallel on individual domain partitions. For exam-ple, assume we divide the entire domain range [0 ,r ) into 2 partitions: P 1 :[0 ,r/ 2) and P 2 :[ r/ 2 ,r ). To perform a structural join between A and D , we can perform 2 in-memory scans of A and D . During the first scan, all the elements from A that overlap with P 1 are used to build a StabQ-OD index and all the starting points of elements in D that are less than r/ 2 are used to search the index to find the join output. The elements in A that are disjoint with P 1 are ignored; the elements in D with starting points outside P 1 are also ignored. During the second scan, the rest of the elements in A and D are processed.
 Structural Join Algorithms with StabQ-OD. With Theorems 2 and 3, we now describe the structural join algorithm using the StabQ-OD with P =1, where P denotes the number of domain range partitions. Fig. 6 shows the pseudo code for StructuralJoin , which takes two interval sets, A and D , as inputs and produces an output that contains all the ( a, d )pairswhere a  X  A , d  X  D and a contains d .Foreach a  X  A , it calls Insertion function with the element ID and its start and end points as the input parameters. This builds a CEI index for the ancestor set. After that, each descendant element is used to search the CEI index by calling Search with the start point as the input parameter. Search returns a set of ancestor elements that co ntain the descendant element. Each of the elements in the returned set can be used to form a join output pair.
Most of the Insertion and Search algorithms are similar to those for the original CEI indexing [14]. However, for the StabQ-OD, there is only L grid intervals for each segment, hence the glo bal ID of a grid interval with a segment ID S i and a local ID l is S i L + l , instead of 2 S i L + l . Because no unit-length grid intervals are used, the search algorithm finds the local ID of the grid interval of length 2 and more stabbed by a data point x . 4.1 Simulation Studies We implemented 5 algorithms for structural joins: the XR-tree [6], the XB-tree [2], the Stack [1], the StabQ-SP and the StabQ-OD. For the XR-tree and the XB-tree, we constructed in-memory indexes for both A and D lists. Once the indexes are built, the elements on the leaf nodes are in sorted order. Hence, we did not sort the elements again and no sorting time was included. However, for the Stack approach, we did. For the Stab-SP and StabQ-OD approaches, only a CEI index was built for the A list. We implemented the domain range partitioning in a single machine and performed the structural joins serially on each domain partition. The simulations were performed on an RS 6000 model 43P machine running AIX 5.1. We conducted structural joins on 8 XML workloads: 4 synthetic and 4 real (see Table 1 for the characteristics of these XML documents).
The synthetic XML documents were generated based on two DTDs used in [6]. Fig. 7 shows the two DTDs, one for departments and one for confer-ences. For the departments XML, we created two workloads, 1 and 2, and used employee/name and employee/email , respectively, as the ancestor and descen-dant pairs. The employee node elements can be highly nested in the document. For the conferences XML, we used paper/author and paper/title as the an-cestor/descendant pairs for two different workloads, 3 and 4. The paper node elements are fairly flat for the conferences DTD.

For real XML documents, we used the DBLP and the Treebank XML doc-uments downloaded from [10]. The Treebank XML contains English sentences, tagged with parts of speech. The nodes in this document are deeply recursive. For this XML, PP/NP and VP/NP were chosen as the ancestor and descendant pairs of two different workloads, 5 and 6. DBLP stands for Digital Bibliography Library Project. The DBLP XML document contains bibliographic informa-tion on major computer science journals and proceedings. For DBLP, we used inproceedings/author and article/author as the ancestor and descendant pairs for two different workloads, 7 and 8. The inproceedings and article node elements in the document are relatively flat, similar to the conferences DTD as shown in Fig. 7.

Note that some readers might not think that it is fair to include the index construction time for the prior approaches, such as the XR-trees, because they were not designed for on-demand indexing and the indexes can be pre-built offline. However, as we have discussed in Section 1, not all node elements would have the indexes built beforehand when the join operations are performed. In such cases, the indexes must be built on the fly and the index construction time must be counted in the total join time.

The maximal grid interval length L has impacts on both storage cost and total join time. Detailed studies on the performance impact of L are not provided here and can be found in [14]. In general, L should not be too small or too large. The optimal L for the 8 different workloads varies from 8, 16 and 32. However, the difference is rather small among three of them. Hence, we chose L = 16 for all of our studies in this paper. 4.2 Comparisons of Different Join Algorithms Figs. 8 and 9 show the index storage costs and total join times of 5 different structural join algorithms using the 4 synthetic and real XML workloads, re-spectively. Here, we used a single domain range partition for the StabQ-OD, denoted as StabQ-OD(P=1). Each workload has a different join selectivity, as evidenced by the different output sizes among the workloads (see Table 1). For all workloads, the StabQ-OD substantially outperforms the XR-tree, the XB-tree and the Stack approaches in terms of total join time. The total join time of the StabQ-SP is comparable to that of the StabQ-OD. However, the storage cost of the StabQ-SP is almost twice as high as that of the StabQ-OD(P=1), which is also higher than those of the XR-tree and XB-tree. Note that there is no index storage cost for the Stack approach. 4.3 Impacts of Input Sizes and Domain Range Partitioning In order to understand the sensitivity of the join algorithms to the sizes of A and D , we created 8 individual subsets of A and D , respectively, A 0 ,  X  X  X  ,A 7and D 0  X  X  X  ,D 7, from each of the 8 XML workloads, following a similar approach used in [6]. The results are similar among all 8 workloads. In this section, we only show the results using the synthetic departments XML workload 1 (see Table 1). Each subset was chosen uniformly from the original A and D as shown in Table 1 and each subset is a fraction of the original set. For example, A 0, A 1 ,A 2, A 3, A 4 ,A 5, A 6and A 7 are 90%, 70%, 55%, 40%, 25%, 15%, 5% and 1%, respectively, of the original employee element set. D 0 ,  X  X  X  ,D 7 were similarly chosen from the original name element set. We conducted four different sets of experiments using these 16 subsets of A and D .

Experiments I and II were designed to show the sensitivity of these join al-gorithms to the size of D while maintaining the same A for each experiment. Experiment I used A 0 (90% of A ) while experiment II used A 6 (5% of A ). Both perform similarly. We only show the results of expriment I due to space limita-tion.

Fig. 10 shows the impacts of the descendant set size on the index storage costs and total join times of various structural join algorithms when the ancestor set is fixed at a large size. In general, the total join time increases as the size of the descendant set increases in size for all algorithms. However, the total join times of the three StabQ-OD schemes, with different domain range partitioning, are less sensitive to the increase in descendant set. For StabQ-OD, the index build time is the same for all the cases in this experiment since the same ancestor set is used. On the other hand, the XR-tree and the XB-tree need to construct on demand two complex indexes. The Stack approach needs to sort two input sets. Hence, their total join times are more positively correlated to the size of the descendant set. The XR-tree, the XB-tree and the Stack approaches are all outperformed by the three StabQ-OD schemes for all the cases. Moreover, the performance advantages of the StabQ-OD schemes over the XR-tree, the XB-tree and the Stack approaches increase as the descendant set increases in size.
Note that we performed the structural joins serially with domain range par-titioning. Hence, the total join time is the entire elapsed time of the structural join times for all the domain partitions. However, the index storage cost is mea-sured by the maximal index storage cost of individual partitions. As shown in Fig. 10, the index storage cost of StabQ-OD can be effectively reduced with do-main range partitioning with P = 4. Moreover, the storage reduction is achieved without a noticeable increase in total join time.

Experiments III and IV show the sensitivity of the structural join algorithms to the size of A while using the same D for each experiment. Experiment III used D 0 (90% of D ) while experiment IV used D 6 (5% of D ). Again, we only show the results of expriment III due to space limitation.

Fig. 11 shows the impacts of different-sized ancestor sets when the descen-dant set is large. In this experiment, all three StabQ-OD schemes with different domain range partitioning almost completely overlap in terms of total join times and they all outperform the XR-tree, the XB-tree and the Stack approaches, especially when A is small. Note that the storage cost of the StabQ-OD(P=4) is lower than those of the XR-tree and the XB-tree in Fig. 11. We have described an on-demand indexing approach to performing structural joins, called StabQ-OD. It incorporates the concept of stabbing query-based indexing, such as CEI indexing, with two storage reduction techniques: unit-length grid elimination and domain range partitioning. There is no need to sort the elements or maintain indexes on disks beforehand. Simulations show that (a) The StabQ-OD outperforms substantially prior techniques, such as the XR-tree, the XB-tree and the Stack approaches; (b) The two storage reduction techniques of the StabQ-OD approach are effective.

