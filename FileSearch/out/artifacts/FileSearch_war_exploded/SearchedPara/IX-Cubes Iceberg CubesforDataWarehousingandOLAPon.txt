 With increasing amoun t of data being stored in XML for-mat, OLAP queries over these data become imp ortan t. OLAP queries have been well studied in the relational database sys-tems. However, the evaluation of OLAP queries over XML data is not a trivial extension of the relational solutions, esp ecially when a schema is not available. In this pap er, we introduce the IX-cub e (Iceb erg XML cub e) over XML data to tackle the problem. We extend OLAP operations to XML data. We also dev elop e X cien t approac hes to IX-Cub e computation and OLAP query evaluation using IX-cub es. Categories and Sub ject Descriptors H.3.5[Online Information Services]: Web-based services General Terms Algorithms, Performance
Building data cub es [6] has been well recognized as one of the most imp ortan t and most essen tial operations in OLAP (On Line Analytical pro cessing). Man y metho ds have been prop osed to compute and store data cub es e X cien tly from relational data, suc h as [4, 12, 13, 8].

With more and more data stored in XML format, it is natural to extend OLAP to semi-structured data. For ex-ample, an OLAP query on the DBLP database [1] may ask for the num ber of distinct authors group ed by conference, year, publisher, organization (e.g., ACM and IEEE), and their com binations. Online answ ering suc h OLAP queries on XML data is far from trivial. At least two challenges may arise in general.

First, how can we handle incomplete and irregular XML data? XML data entries of the same type may be stored in very di X eren t ways. For example, as sho wn in Figure 1, en-tries about two books may be represen ted di X eren tly. More-over, missing data can be common. For instance, some con-ferences may not have the information about organizations. Second, how can we compute aggregates ?In this pap er, we tackle the problem of supp orting OLAP on XML data and dev elop an IX-Cub e approac h: we construct an iceb erg data cub e on an XML data set so that various aggregate queries can be answ ered e X cien tly. We mak e the follo wing con tri-butions. Firstly , we extend data cubes from relational data to XML data . The extension is non-trivial. We prop ose the concept of IX-Cub e (for Iceb erg XML Cub es) and dev elop metho ds to handle incomplete and irregular XML data. Sec-ondly , we investigate how to use IX-Cub es to answer OLAP queries . We study both aggregate cell queries and sub-cub e queries. To accelerate query answ ering, we presen t a B+-tree index on IX-cub es. To the best of our kno wledge, this is the  X rst systematic study on constructing, storing, indexing and using data cub es on XML data. While the study of query pro cessing on semi-structured or XML data has receiv ed much atten tion, there has been little work on OLAP queries on suc h data. [5] analyzes the op-portunities and challenges of analytical pro cessing of XML data. [3, 2] study the problems of extending XQuery to supp ort analytical queries over XML data. [7] explores the problem of integrating XML data and relational data into a \virtual" OLAP DB, over whic h the OLAP operations are executed. [10] federates the external XML data with OLAP data, and prop oses query optimization techniques for suc h federations. [9] prop oses how to compute data cub e from distributed data, and use XML to represen t the cub e and the cub e schema. None of these work touc hes the details of de X ning, computing and querying a cub e computed from XML data. To our kno wledge the only work that deals with datacub e for XML data is [11]. The semi-structured nature of XML documen ts is handled by a systematic relaxation pro cess in [11]: the dimensions in a datacub e are speci X ed by a target tree and the possibilit y of missing entries is mo d-eled by relaxing the target tree, forming all possible subtrees by remo ving branc hes or replacing paren t-child relationship by ancestor relationship. However, this mo del does not cater for other di X eren t possible path patterns for the same dimen-sion. We pro vide a more general solution by allo wing users to specify the desired datacub e in a more  X  X xible and more precise manner.
An XML documen t can be mo deled as a tree. We as-sume that eac h node in the tree has an attribute tag . For an elemen t/attribute node, we tak e the tag name as the tag. For a text node, the tag is simply \text" , and a text Figure 1: An example XML tree. The lab els b e-sides no des (e.g., p 1 and b 1 ) are to facilitate some discussion in the pap er. Figure 2: The tag path trie for the example XML tree in Figure 1. no de has an additional attribute textc ontent . Figure 1 sho ws the tree represen tation of an XML do cumen t ab out litera-ture in a library . T ak e no de b 1 in the  X gure as an example. b :tag =b o ok. W e call b 1 a b o ok no de. a 1 is a text no de, and a 1 :tag = \text" , a 1 :textcontent =John.
 A tag p ath is a list of tags from the ro ot to a leaf no de. Clearly , giv en an XML tree, all distinct tag paths in the tree can b e organized in to a pre X x-trie called the tag p ath trie . F or example, Figure 2 sho ws the tag path trie of the XML tree in Figure 1. Since all text no des ha v e the same tag \text" , there are t ypically only a small n um b er of distinct tag paths ev en in a large XML tree.

Generally , this tag path trie is not a sc hema. A general sc hema should b e a graph, whic h leads to tag paths of un-kno wn length. Ho w ev er, for a sp eci X c do cumen t, there are only a limited n um b er of paths. Therefore, the tag path trie can serv e as the hidden sc hema for the do cumen t.
Moreo v er, an XML do cumen t ma y not conform to an y sc hema, but it m ust ha v e suc h a tag path trie describing all the p ossible distinct tag paths that app ear in the do cumen t. Therefore, in the follo wing discussion, w e assume that suc h a tag path trie is a v ailable b y some prepro cessing. Apparen tly , building suc h a tag path trie needs at most one scan of the XML tree.
 XP ath is a language for selecting no des in an XML tree. F or example, the XP ath expression \/library/region[asia]// b o ok" selects all b o oks no des whic h are descendan ts of a region no de with an asia c hild. An XP ath expression can b e v ery complicated. T o k eep our discussion simple, w e consider only XP ath expressions using branc hings ( \[]" ), self axis( \." ), c hild axis( \/" ), attribute axis( \@" ), descendan t axis ( \//" ), wild card ( \*" ), and axis for selecting all text c hildren of the con text no de( \text()" ) and paren t( \.." ). F or simplic-it y , later on w e call an XP ath expression a path .
Conceptually , a (relational) data cub e [6] is the set of all p ossible group-b y aggregates on a m ultidimensional data set. F or example, giv en a table (y ear, author, category , pub-lisher, title), w e can sp ecify a data cub e using attributes y ear, category , and publisher as the dimensions , using at-tribute title as the me asur e , and using COUNT() as the ag-gregate function. Then, an aggr e gate c el l in the cub e is an aggregate on a group-b y using a subset of the dimensions, suc h as the total n um b er of b o oks b y category and publisher. A data cub e is the complete set of all p ossible aggregate cells.
A data cub e can b e h uge if there are man y dimensions and the cardinalities of dimensions are high. Often, users are only in terested in signi X can t aggregates. Giv en a user sp eci X ed aggregate threshold, an ic eb er g cub e is the set of aggregate cells whose aggregates pass the threshold.
No w, let us consider ho w to extend data cub es to XML data. Sp ecifying a data cub e on XML data is more com-plicated b ecause of the incompleteness and irregularit y of XML, as illustrated in Section 1. P articularly , w e need to handle t w o c hallenges.

The irr e gularity . The en tries (i.e., the corresp onden ts of tuples in the relational case), the dimension v alues and the measure attribute v alues are semi-structured in an XML do cumen t. Therefore, w e need to sp ecify ho w the en tries, the dimension v alues, and the measure attribute v alues can b e found and asso ciated with eac h other.

The inc ompleteness . Some dimensions ma y b e missing in some en tries. Then, w e need to pro vide an e X ectiv e w a y to determine whether there are some missing dimension v alues for an en try , and, if so, ho w suc h an en try is aggregated.
W e refer to a datacub e to b e deriv ed from a XML do c-umen t as an IX-Cub e. T able 1 sho ws an example of an IX-Cub e sp eci X cation on the XML tree in Figure 1. Before w e giv e the formal de X nition, this example can help us un-derstand some essen tial issues in the IX-Cub e sp eci X cation. Sp ecifying an en try is straigh tforw ard. W e can use an XP ath expression to sp ecify the set of target en tit y set that is of in terest for aggregation. F or example, the target en tit y set de X ned b y \//b o ok" indicates that w e w an t to build a data cub e ab out b o ok no des.
 A dimension can also b e de X ned b y an XP ath expression. Ho w ev er, the path is relativ e. That is, after an en try is iden ti X ed, we should evaluate the XP ath expression starting from the entry. The path leads us to the dimension value. For example, in Figure 1, path \./category/text()" may lead to the category of a book, and thus can be used to de X ne di-mension category . Due to the irregularit y of XML data, we may need more than one path to specify a dimension. For example, in Figure 1, some book entries need path \./cat-egory/text()" to  X nd the categories, and some others need path "./../category/text()" . In the dimension speci X cation, both paths should be included.

Similarly , we can use a relativ e path to specify the mea-sure. An aggregate function should be pro vided. Putting things together, we de X ne IX-Cub e, an iceb erg cub e on XML data, as follo ws.
 Definition 1 (IX-Cube) . Giv en an XML tree, an IX-Cub e is speci X ed by a 3-tuple h E xcube ; M xcube ; D xcube E xcube is an entity, M xcube is a measure, and D xcube is a set of dimensions. E xcube is given by a path ending in a la-bel of interest. Once we  X nd a node in the XML documen t that matc hes E xcube , we call it a con text node . A dimen-sion is de X ned by 2-tuple h DName, Paths i , where DName is the dimension name, and Paths denote a set of paths whose starting point is the con text node. A measure is de X ned by a 3-tuple h AggF unction, Paths, min supp i , where Agg-Function is an aggregate function, Paths is a set of paths to be considered for the aggregation whose starting point is the con text node, and min supp is the aggregate threshold. Only aggregates passing the threshold are stored in the IX-Cub e.
 Let us consider the example of IX-Cub e speci X cation in Table 1 again. Dimension \publisher" says that given a book node (curren t con text node), its publisher information may either be found as a text child of a publisher child node, or as the name attribute of a publisher child of its grand-grand-paren t. h COUNT , f . g , 25000 i is a measure, whic h coun ts the num ber of books in the documen t. If eac h book has an attribute of inventory , whic h records the num ber of copies, a possible measure would be h SUM , f ./in ventory/text() g , 300000 i , whic h calculates the total num ber of copies for all books.
We use a tree to store an IX-Cub e. Giv en an XML tree and an IX-Cub e de X nition h E xcube ; M xcube ; D xcube i , the re-sulting IX-Cub e is a directed lab eled tree T xcube = h root; E; V; l E i , where
Figure 3 sho ws the IX-Cub e computed on the XML tree in Figure 1 given the speci X cation in Table 1. We use the di-mension value to represen t a node. The num ber in brac ket beside the value is the aggregate. Limited by space, we do not sho w the con text nodes asso ciating with eac h node, i.e. the ins attribute of a node. For example, the ins at-tribute of the node in the dashed circle is f b 1 g . The pur-pose of keeping suc h information in the tree is for easy in-cremen tal update of the IX-Cub e. A path from the root to a node represen ts a cell in an IX-Cub e. For example, the node in the dashed circle represen ts a cell \( f CUPress g , *, f Ben,John g :1)" , whic h means the num ber of books pub-lished by CUPress and written by Ben and John together is 1, coun ting all the categories. Note that a total order on the dimensions is assumed, whic h can be an arbitrary choice or one based on the statistics of queries. In the example, the order is publisher  X  category  X  author. In the next section we shall see how the order can a X ect the performance of answ ering some queries.

As we can see, common pre X xes are shared in the tree structure so that space can be saved. Besides, this construct allo ws the aggregates of the internal nodes to be computed so that the early pruning can be applied based on the iceb erg threshold [12].

The dashed lines partition the aggregates for di X eren t di-mensions. They also separate an IX-Cub e into di X eren t lay-ers , one for eac h dimension (or concept hierarc hy for a di-mension). There is a special layer for \All" , whic h is called the top layer . The layer con taining the leaf nodes is called the bottom layer .
In this section, we discuss how an IX-Cub e can be used to answ er OLAP queries, and how an index can be built to accelerate suc h queries. Here, we assume that an IX-Cub e is materialized. The computation of IX-Cub es will be discussed in Section 6. A cell query asks for the aggregate of a speci X c group-b y. For example, one may query \the total num ber of books writ-ten by Ben and John published by CUPress" . This query has two dimensions, \publisher" and \author" . For con venience, we use an SQL-lik e syn tax as follo ws.

The answ er to this query is a cell in the IX-Cub e, i.e., the cell represen ted by the node with dashed circle in Figure 3. Answ ering a cell query using an IX-Cub e is straigh tforw ard. To answ er the above query , we traverse the IX-Cub e starting from the root until we get a path \/ro ot/ f CUPress g / f Ben,John g ", where the lab els l f CUPree g ) = publisher, l E ( f CUPress g , f Ben,John g ) = au-thor. Then, the path, together with the aggregate stored in the node with value f Ben,John g , form the resulting cell, i.e. \( f CUPress g , *, f Ben,John g :1)" .
 In general, given a cell query using a set of dimensions D = f D 1 = V 1 ; D 2 = V 2 ;: : : ;D m = V m g , where D D k are in the IX-Cub e, we get the path P cell =\/ro ot/ e . . . / e k " in the IX-Cub e suc h that e i :val = V i and l is D i :DN ame , where 1  X  i  X  k and e 0 = root . The cell formed by P cell and e k :ag g should be returned.
OLAP queries often involve rep ort-st yle queries, whic h are queries on a sub-cub e of the iceb erg cub e. Since the IX-Cub e materializes all cub oids (group-b y's of all subsets of dimensions), we can generate the result from an IX-Cub e by looking up the corresp onding layers of the IX-cub e, e.g., from the root, get all publisher child nodes, and from eac h suc h node get all the author child nodes, those nodes form the cub oid. In OLAP , roll-up is to clim b a concept hierarc hy for a dimension or to reduce the num ber of dimensions, while drill-do wn is the opp osite operation. By going up or down the branc hes in the IX-cub e, we can also perform roll-up or drill-do wn operations.
To accelerate query answ ering, we prop ose a B+-tree style index on IX-Cub e. We call the index Cub eIndex . Giv en an IX-Cub e T = h root; E; V; l E i , for eac h node e k with in-coming path \ro ot/ e 1 / e 2 / : : : / e k l ( e i Cub eIndex using the key h d 1 ; d 2 ; : : : ; d k ; e 1 :val; e e :val i . We also store e k :ins and e k :ag g .

To answ er a cell query , we can searc h the Cub eIndex with dimension names and values as the key. Using the IX-Cub e in Figure 3 as an example. To access the cell in dashed cir-cle, we searc h the Cub eIndex by key h publ isher ; author ; f CU P ress g ; f Ben; John gi , and get the aggregate, i.e., 1. Then, a cell \( f CUPress g , *, f Ben,John g :1)" is formed and returned. In this section, we discuss how to compute an IX-Cub e. Our prop osed cubing algorithm is a bottom-up approac h. The input consists of an XML tree T , an IX-Cub e de X nition, h E and eac h D i is a 2-tuple h D i :DN ame; D i :P aths i , and two user-de X ned parameters,  X  and minsupp , where  X  is for get-ting valid dimension and measure values, and minsupp is for computing iceb erg IX-Cub e. T xcube = h root; V; E; l E i can be computed by the follo wing steps.

For those dimensions whose values are missing, we use  X  as the place holder. Then, for eac h con text node, its measure value and all dimension values form a tuple. Then, we apply a similar idea as the BUC algorithm [4] to compute the IX-Cub e. We store the results into the B+-tree Cub eIndex for the resulting IX-cub e. We call our algorithm RCub eAlg and there are two steps:
Step 1: Flatten the tree. The task of this step is to trans-form the relev ant datacub e information from the XML data into a relational table. We call suc h a table a base table . The basic idea is as follo ws. We scan the XML tree in pre-order. For eac h con text node, we pick up its dimension or measure values according to the paths in the dimension or measure de X nitions. For those dimensions whose values are missing, we using  X  as the place holder. Then all the values form a tuple.

Step 2: Giv en the base table, we apply the BUC algo-rithm[4] to compute a cub e based on the base table. The output cub e is stored as an IX-Cub e as introduced in Section 4.2. Note that, as the structure features are eliminated af-ter  X  X ttening the tree, the lab els of the edges in an IX-Cub e computed by RCub eAlgo are dimension names.
In this pap er, we prop ose a new data structure, IX-Cub e, over XML data. Although the purp ose of computing data cub e over XML data is the same as that of relational data, the technique is quite di X eren t due to the di X culties in han-dling the semi-structure nature of XML data. We  X rst intro-duce the de X nition of IX-Cub e, whic h includes the de X nition of a target entity, a measure and multiple dimensions. Next a computing algorithm is prop osed, and OLAP operations over the IX-Cub e are de X ned.
