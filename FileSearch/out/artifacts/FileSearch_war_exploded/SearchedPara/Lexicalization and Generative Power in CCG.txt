 Link  X  oping University University of Potsdam University of Padua
The weak equivalence of Combinatory Categorial Grammar (CCG) and Tree-Adjoining Gram-of combinatory rules on a per grammar basis, whereas modern CCG assumes a universal set
CCG formalism are strictly less powerful than TAG. 1. Introduction
Since the late 1970s, several grammar formalisms have been proposed that extend the power of context-free grammars in restricted ways. The two most prominent members of this class of  X  X ildly context-sensitive X  formalisms (a term coined by Joshi 1985) are Tree-Adjoining Grammar (TAG; Joshi and Schabes 1997) and Combinatory Categorial
Grammar (CCG; Steedman 2000; Steedman and Baldridge 2011). Both formalisms have been applied to a broad range of linguistic phenomena, and are being widely used in computational linguistics and natural language processing.
 other mildly context-sensitive formalisms X  X ead Grammar (Pollard 1984) and Linear Indexed Grammar (Gazdar 1987) X  X ll characterize the same class of string languages.
However, when citing this result it is some times overlooked that the result applies to a version of CCG that is quite different from the versions that are in practical use today.
The goal of this article is to contribute to a b etter understanding of the significance of this difference.
 backward-crossed composition. The general form of this rule looks as follows:
This rule is frequently used in the analysis of heavy NP shift, as in the sentence Kahn blocked skillfully a powerful shot by Rivaldo (example from Baldridge 2002). However, backward crossed composition cannot be universally active in English as this would cause the grammar to also accept strings such as *a powerful by Rivaldo shot ,whichis ism of Vijay-Shanker and Weir (1994), one may restrict backward-crossed composition to instances where X and Y are both verbal categories X  X hat is, functions into the unwanted derivation in Figure 1 can be blocked, and a powerful shot by Rivaldo is still accepted as grammatical. Other syntactic phenomena require other grammar-specific restrictions, including the complete ban of certain combinatory rules (cf. Steedman 2000, Section 4.2.1).
 fully lexicalized grammars (Baldridge and Kruijff 2003; Steedman and Baldridge 2011), in which as much grammatical information as possible is pushed into the lexicon. This follows the tradition of other frameworks such as Lexicalized Tree-Adjoining Grammar (LTAG) and Head-Driven Phrase Structure Grammar (HPSG). Grammar-specific rule restrictions are not connected to individual lexicon entries, and are therefore avoided.
Instead, recent versions of CCG have introduced a new, lexicalized control mechanism the modern version of backward-crossed composition (Steedman and Baldridge 2011) takes the following form, where  X  is a slash type that allows crossed but not harmonic composition: 188
The derivation in Figure 1 can now be block ed by assigning the slash in the category of powerful a type that is incompatible with  X  , and thus cannot feed into type-aware backward-crossed composition as an input category. This  X  X odalization X  of grammati-cal composition, which imports some of the ce ntral ideas from the type-logical tradition of categorial grammar (Moortgat 2011) into the CCG framework, is attractive because it isolates the control over the applicability of combinatory rules in the lexicon. Quoting Steedman and Baldridge (2011, p. 186): of combinatory rules in terms of lexically sp ecified, typed slashes. But to what extent can this goal actually be achieved? So far, there have been only partial answers X  X ven when, as in the formalism of Vijay-Shanker and Weir (1994), we restrict ourselves to the rules of composition, but exclude other rules such as type-raising and substitution.
Baldridge and Kruijff (2003) note that the machinery of their multi-modal formalism can be simulated by rule restrictions, which shows that this version of lexicalized CCG is at most as expressive as the classical formalism. At the other end of the spectrum, we have shown in previous work that a  X  X ure X  form of lexicalized CCG with neither rule restrictions nor slash types is strictly less expressive (Kuhlmann, Koller, and Satta 2010).
The general question of whether  X  X lassical X  CCG (rule restrictions) and  X  X odern X  CCG (slash types instead of rule restrictions) are weakly equivalent has remained open. make the classical CCG formalism weakly equivalent to TAG (Section 3). We do so by focusing on a class of grammars that we call prefix-closed . Unlike the  X  X ure X  grammars (under certain conditions that seem to be satisfied by linguistic grammars). We show that the generative power of prefix-closed CCG depends on its ability to express target restrictions , which are exactly the functions-into type of restrictions that are needed to block the derivation in Figure 1. We prove that the full class of prefix-closed CCGs is weakly equivalent to TAG, and the subclass that cannot express target restrictions is capacity of CCG.
 Weakly equivalent to TAG Strictly less powerful than TAG VW-CCG
Prefix-closed VW-CCG Prefix-closed VW-CCG with target restrictions (Theorem 2) without target restrictions (Theorem 3) restrictions. More specifically, we look at a variant of CCG consisting of the composition rules implemented in OpenCCG (White 2013), the most widely used development platform for CCG grammars. We show that this formalism is (almost) prefix-closed and cannot express target restrictions, which enables us to apply our generative capacity result from the first step. The same result hol ds for (the composition-only fragment of) the formalism of Baldridge and Kruijff (2003). Thus we find that, at least with existing means, the weak equivalence result of Vijay-Shanker and Weir cannot be obtained for lexicalized CCG. We conclude the article by discussing the implications of our results (Section 5). 2. Background basic architecture of CCG, present the formalism of Vijay-Shanker and Weir (1994), and set the points of reference for our results about generative capacity. 2.1 Basic Architecture of CCG
The two central components of CCG are a lexicon that associates words with categories, and rules that specify how categories can be combined. Taken together, these compo-nents give rise to derivations, such as the one shown in Figure 3.

Lexicon. A category is a syntactic type that identifies a constituent as either  X  X omplete X  or  X  X ncomplete. X  The categories of complete constituents are taken to be primitives; the categories of incomplete constituents are m odeled as (curried) functions that specify from Steedman 2012), an English intransitive verb such as walks has a category that backward slash) and returning a complete sentence; and a transitive verb such as admires has a category that identifies it as a function seeking an (object) noun phrase to its right (indicated by a forward slash) and returning a constituent that acts as an intransitive verb. We denote lexical assignment using the  X  X olon equals X  operator: the primitive syntactic types. It is the smallest set such that 1. if A  X  A then A  X  C ( A ); 190 2. if X , Y  X  C ( A )then X / Y  X  C ( A )and X arbitrary categories, and the symbol | to denote slashes (forward or backward). We convention, every category X canbewrittenintheform where m  X  0, A is an atomic category that we call the target of X ,andthe slash X  X ategory pairs that we call the arguments of X . Intuitively, the target of X is the atomic category that is obtained after X has been applied to all of its arguments. We use the Greek letters  X  ,  X  ,  X  to denote (potentially empty) sequences of arguments. The number m is called the arity of the category X .

Rules. Categories can combine under a number of rules ; this gives rise to derivations two input categories into an output category. The two most basic rules of CCG are the directed versions of function application: egories. A rule instance is obtained by substituting concrete categories for all variables in the rule. For example, the derivation in Figure 3 contains the following instances of function application. We denote rule instances by using a triple arrow instead of the double arrow in our notation for rules. mar. Indeed, versions of categorial grammar where application is the only mode of combination, such as AB-grammar (Ajdukie wicz 1935; Bar-Hillel, Gaifman, and Shamir 1960), can only generate context-free languages. CCG can be more powerful because it also includes other rules, derived from the combinators of combinatory logic (Curry, restrict our attention to the rules of (generalized) composition, which are based on the B combinator. 1 input categories are distinguished into one primary (shaded) and one secondary input category. The number n of outermost arguments of the secondary input category is called the degree of the rule. 2 In particular, for n = 0 we obtain the rules of function application. In contexts where we refer to bo th application and composition, we use the latter term for composition rules with degree n &gt; 0.

Derivation Trees. Derivation trees can now be schematically defined as in Figure 5. They contain two types of branchings: unary branchings correspond to lexicon entries; binary branchings correspond to rule instances. The yield of a derivation tree is the left-to-right concatenation of its leaves. 2.2 Classical CCG
We now define the classical CCG formalism that was studied by Vijay-Shanker and Weir (1994) and originally in troduced by Weir and Joshi (1988) . As mentioned in Section 1, the central feature of this formalism is its ability to impose restrictions on the applicability of combinatory rules. Specifically, a restricted rule is a rule annotated with constraints that (a) restrict the target of the primary input category; and/or (b) restrict the secondary input category, either in parts or in its entirety.
Every grammar lists a finite number of restricted rules (where one and the same base rule may occur with several different restrictions). A valid rule instance is an instance that is compatible with at least one of the restricted rules.
 Example 1
Linguistic grammars make frequent use of rul e restrictions. To exclude the undesired derivation in Figure 1 we restricted backwar d crossed composition to instances where both the primary and the secondary input ca tegory are functions into the category of 192 restricted rule can be written as Definition 1 A combinatory categorial grammar in the sense of Vijay-Shanker and Weir (1994), or VW-CCG for short, is a structure where  X  is a finite vocabulary, A is a finite set of atomic categories, the lexicon : a finite relation between the sets  X   X  = X   X  X   X  } and C ( A restricted rules, and S  X  A is a distinguished atomic category.

The grammar G generates astring w if there exists a derivation tree whose yield is w and whose root node is labeled with t he distinguished atomic category S .The language L ( G ) generated by G is the set of all generated strings.
 Example 2 We specify a VW-CCG G 1 = (  X  1 , A 1 ,: = 1 , R 1 , S 1 ) that generates the language Let  X  1 = { a , b , c } , A 1 = { A , B , C , S } , S 1 =
Finally, let R 1 consist of the following rules: 1. Forward and backward application. 2. Forward and backward composition of degree 1. 3. Forward and backward composition of degree 2.
 shows a derivation that is not valid in G 1 because it uses application rules in which the target of the primary input category is B or C (rather than S ).
 Example 3
AB-grammar is a categorial grammar formalism in which forward and backward appli-cation are the only combinatory rules that ar e allowed. Furthermore, it does not support rule restrictions. 3 Every AB-grammar can therefore be written as a VW-CCG that allows all instances of application, but no other rules.
 shall use at several places in this article . Both of them are minor variants of lemmas proved by Vijay-Shanker and Weir (1994) (Lemma 3.1 and Lemma 3.2) and were previ-ously stated by Weir and Joshi (1988).
 Lemma 1 The set of arguments that occur in the derivations of a VW-CCG is finite. Proof
No composition rule creates new arguments : Every argument that occurs in an output category already occurs in one of the input categories. Therefore, every argument must many.
 Lemma 2
The set of secondary input categories that occur in the derivations of a VW-CCG is finite. 194 Proof
Every secondary input category is obtaine d by substituting concrete categories for the variables that occur in the non-shaded component of one of the rules specified in
Figure 4. After the substitution, all of these categories occur as part of arguments. Then, with Lemma 1, we deduce that the substituted categories come from a finite set. At the same time, each grammar specifies a finite set of rules. This means that there are only finitely many ways to obtain a secondary input category.
 we use a special type of restricted rule that we call templates . A template is a restricted rule that simultaneously fixes both (a) the target of the primary input category of the rule, and (b) the entire secondary input category.
 We illustrate the idea with an example.
 Example 4 symbol as a placeholder for that part of a primary input category that is uncon-arguments.

For example, template (1) characterizes backward application ( the primary input category is S and the secondary input category is A , and template (4) characterizes forward composition of degree 2 ( &gt; 2 input category is S and the secondary input category is B finite set of combinatory rules; the set of possible targets of the primary input category of each rule is finite because each target is an atomic category; and the set of possible secondary input categories is finite because of Lemma 2. 2.3 Tree-Adjoining Grammar
In this article we are interested in the gener ative power of CCG, in particular in its re-lation to that of Tree-Adjoining Grammar. We therefore provide a compact introduction to TAG. For more details, we refer to Joshi and Schabes (1997).

Elementary Trees. Tree-Adjoining Grammar is a formalism for generating trees. These trees can be characterized as rooted, ordered trees in which internal nodes are labeled with nonterminal symbols X  X ncluding a distinguished start symbol S  X  X nd leaf nodes are labeled with nonterminals, terminals, or the empty string. Every grammar specifies a finite set of such trees; these are called elementary trees .Therearetwotypes: ini-tial trees and auxiliary trees . They differ in that auxiliary trees have a distinguished nonterminal-labeled leaf node, called foot node ; this node is conventionally marked with an asterisk. An elementary tree whose root node is labeled with a nonterminal A is called an A -tree.

Substitution and Adjunction. New trees may be derived by combining other trees using two operations called substitution and adjunction . Substitution replaces some leaf replaces some internal node u of a given tree with an auxiliary tree (or a tree derived from an auxiliary tree); the subtree with root u replaces the foot node of the auxiliary tree. All replacements are subject to the condition that the node being replaced and the root of the tree that replaces it are labeled with the same nonterminal.

Generated Languages. The tree language generated by a TAG is the set of all trees that can be derived from its initial S -trees. Derivations are considered complete only if they satisfy additional, node-specific constraints. In particular, substitution is obligatory at every node where it is possible, and adjun ction may be specified as either obligatory (OA, Obligatory Adjunction) or forbidden (NA, Null Adjunction) at a given node. In terminal symbols. The left-to-right con catenation of these symbols forms the yield of the tree, and the yields of all trees in the tree language form the string language generated by the TAG.
 Example 5
Figure 8 shows a TAG that generates the language L
Example 2. Derivations start with adjoining the auxiliary tree t tree t 1 . New trees can be derived by repeatedly adjoining t 196 2.4 Generative Capacity of Classical CCG Vijay-Shanker and Weir (1994) proved the following: Theorem 1 VW-CCG and TAG are weakly equivalent.
 chain of inclusions that connects VW-CCG and TAG via Linear Indexed Grammar (LIG;
Gazdar 1987) and Head Grammar (HG; Pollard 1984). All of these inclusions were proved by Vijay-Shanker and Weir (1994). Here we sketch a proof of the inclusion of the TAG languages in the VW-CCG languages. Our proof closely follows that of Weir (1988, Section 5.2.2), whose construction we shall return to when establishing our own results.
 Lemma 3 The TAG languages are included in the VW-CCG languages.
 Proof (Sketch)
We are given a TAG G and construct a weakly equivalent VW-CCG G .Thebasicideais to make the lexical categories of G correspond to the elementary trees of G ,andtoset up the combinatory rules and their restrictions in such a way that the derivations of G correspond to derivations of G .

Vocabulary, Atomic Categories. The vocabulary of G is the set of all terminal symbols of G ; the set of atomic categories consists of all symbols of the form A ther A is a nonterminal symbol of G and t  X  X  a , c } ,or A is a terminal symbol of G and t = a . The distinguished atomic category of G is S a of G .

Lexicon. One may assume (cf. Vijay-Shanker, Weir, and Joshi 1986) that G is in the normal remaining elementary trees are auxiliary trees of one of five possible types. For each such tree, one constructs two lexicon entries for the empty string
Figure 9. Additionally, for each terminal symbol x of G , one constructs a lexicon entry x : = x a .

Rules. The rules of G are forward and backward application and forward and backward composition of degree at most 2. They are used to simulate adjunction operations |
A t can be eliminated by means of an application rule only if t a composition rule only if t = c . This enforces two properties that are central for the correctness of the construction (Weir 1988, p. 119): First, the secondary input category in every instance of composition is a category that has just been introduced from the tions are: 1. Forward and backward application are restricted to instances where both 2. Forward and backward composition are restricted to instances where the Using our template notation, the restricted rules can be written as in Figure 10. of VW-CCG to assign lexicon entries to the empty string. Such lexicon entries violate one of the central linguistic principles of CCG, the Principle of Adjacency, according to which combinatory rules may only apply to pho nologically realized entities (Steedman VW-CCG without lexicon entries for the e mpty string remains weakly equivalent to
TA G. 198 3. Relevance of Target Restrictions in Prefix-Closed CCG VW-CCGs that we call prefix-closed and show that for this class, weak equivalence with
TAG stands and falls with the ability to specify target restrictions. 3.1 Prefix-Closed Grammars
Rule restrictions are important tools in grammars for natural language; but not all of their potential uses have obvious linguistic m otivations. For instance, one could write a grammar that permits all compositions with a functional category A input category, but rules out application with the  X  X horter  X  category A .Suchconstraints do not seem to be used in linguistically moti vated grammars; for example, none of the grammars developed by Steedman (2000) needs them. In prefix-closed grammars, this use of rule restrictions is explicitly barred.
 Definition 2
A VW-CCG is prefix-closed if it satisfies the following implication: and similarly for backward rules.
 crucial property is that, if a certain combin atory rule applies at all, then it also applies to combinations where the secondary input category has already been applied to some ( k  X  n )orevenall( k &gt; n )ofitsarguments.
 Example 6
We illustrate prefix-closedness using some examples: 1. Every AB-grammar (when seen as a VW-CCG) is trivially prefix-closed; in 2. The  X  X ure X  grammars that we considered in our earlier work (Kuhlmann, 3. The grammar G 1 from Example 2 is prefix-closed. 4. The grammars constructed in the proof of Lemma 3 are not prefix-closed; Example 7
The linguistic intuition underlying prefix-closed grammars is that if such a grammar allows us to delay the combination of a functor and its argument (via composition), then it also allows us to combine the functor and its argument immediately (via ap-tions related to the discussion of word order in Swiss German subordinate clauses (Shieber 1985):
Derivation (5) (simplified from Steedman and Baldridge 2011, p. 201) starts by com-posing the tensed verb h  X  alfed into the infinitive aastriche and then applies the resulting category to the accusative argument of the infinitive, es huus .Prefix-closednessim-200
Thus prefix-closedness predicts derivation (6), and along with it the alternative word order
This word order is in fact grammatical (Shieber 1985, pp. 338 X 339). 3.2 Generative Capacity of Prefix-Closed Grammars
We now show that the restriction to prefix-closed grammars does not change the gen-erative capacity of VW-CCG.
 Theorem 2 Prefix-closed VW-CCG and TAG are weakly equivalent.
 Proof
Every prefix-closed VW-CCG is a VW-CCG, therefore the inclusion follows from The-orem 1. To show that every TAG language can be generated by a prefix-closed VW-
CCG, we recall the construction of a weakly equivalent VW-CCG for a given TAG that we sketched in the proof of Lemma 3. As already mentioned in Example 6, the grammar G constructed there is not prefix-closed. However, we can make it prefix-closed by explicitly allowing the  X  X issing X  rule instances:
We shall now argue that this modification does not actually change the language generated by G . The only categories that qualify as secondary input categories of the new instances are atomic categories of the form B the TAG G .Nowthe lexical categories of G either are of the form x terminal symbol) or are non-atomic. Categories of the form B targets have the form B a . This means that the new rule instances can never be used in a complete derivation of G , and therefore do not change the generated language. Thus we have a construction that turns a T AG into a weakly equivalent prefix-closed
VW-CCG. 3.3 Prefix-Closed Grammars Without Target Restrictions
In this section we shall see that the weak equivalence between prefix-closed VW-CCG constraints is without target restrictions . This property can be formally defined as follows. Definition 3
A VW-CCG is without target restrictions if it satisfies the following implication: and similarly for backward rules.

Example 8 1. Every AB-grammar is without target restrictions; it allows forward and 2. The grammar G 1 from Example (2) is not without target restrictions, languages; recall our discussion of backward-crossed composition in Section 1. As we shall see, target restrictions are also relevant from a formal point of view: If we require
VW-CCGs to be without target restrictions, then we lose some of their weak generative following standard concept from formal language theory: Definition 4
Two languages L and L are Parikh-equivalent if for every string w permuted version w of w such that w  X  L , and vice versa.
 Theorem 3
The languages generated by prefix-closed VW-CCG without target restrictions are prop-erly included in the TAG languages.
 Proof
Every prefix-closed VW-CCG without target r estrictions is a VW-CCG, so the inclusion follows from Theorem 1. To see that the inclusion is proper, consider the TAG language
L = { a n b n c n | n  X  1 } from Example 5. We are interested in sublanguages L are Parikh-equivalent to the full language L 1 .Thispropertyistriviallysatisfiedby L itself. Moreover, it is not hard to see that L 1 is in fact the only sublanguage of L this property. Now in Section 3.4 we shall prove a central lemma (Lemma 6), which asserts that, if we assume that L 1 is generated by a prefix-closed VW-CCG without target restrictions, then at least one of the Parikh-equivalent sublanguages of L context-free. Because L 1 is the only such sublanguage, this would give us proof that L is context-free; but we know it is not. Therefore we conclude that L a prefix-closed VW-CCG without target restrictions.
 results about the languages generated by grammars without target restrictions. Lemma 4
The languages generated by prefix-closed VW-CCG without target restrictions properly include the context-free languages. 202 Proof
Inclusion follows from the fact that AB-grammars (which generate all context-free lan-guages) are prefix-closed VW-CCGs without target restrictions. To see that the inclusion is proper, consider a grammar G 2 that is like G 1 but does not have any rule restrictions.  X  X ure X  in the sense of Kuhlmann, Koller, and Satta (2010). The language L contains all the strings in L 1 = { a n b n c n | n  X  1 } the string bbbacacac , whose derivation we showed in Figure 7. It is not hard to see that all of these additional strings have an equal number of a s, b s, and c s. We can therefore write L 1 as an intersection of L 2 and a regular language: L contradiction, suppose that L 2 is context-free; then because of the fact that context-free languages are closed under intersection with regular languages, the language L be context-free as well X  X ut we know it is not. Therefore we conclude that L context-free either.
 Lemma 5
The class of languages generated by prefix-cl osed VW-CCG without target restrictions is not closed under intersection with regular languages.
 Proof
If the class of languages generated by prefix-closed VW-CCG without target restrictions was closed under intersection with regular languages, then with L mentioned in the previous proof) it would also include the language L
However, from the proof of Theorem 3 we know that L 1 is not generated by any prefix-closed VW-CCG without target restrictions. 3.4 Proof of the Main Lemma for VW-CCG We shall now prove the central lemma that we used in the proof of Theorem 3. Lemma 6 (Main Lemma for VW-CCG)
For every language L that is generated by some prefix -closed VW-CCG without target restrictions, there is a sublanguage L  X  L such that 1. L and L are Parikh-equivalent, and 2. L is context-free.
 target restrictions. The basic idea is to transform the derivations of G into a certain spe-cial form, and to prove that the transformed d erivations yield a context-free language.
The transformation is formalized by the rewriting system in Figure 12. the rules of this system work, consider rul e R1; the other rules are symmetric. Rule R1 rewrites an entire derivation into another derivation. It states that, whenever we have a situation where a category of the form X / Y is combined with a category of the form
Y  X / Z by means of composition, and the resul ting category is combined with a cate-gory Z by means of application, then we may just as well first combine Y and then use the resulting category as a secondary input category together with X
R3 and R4 produce a derivation that yields a permutation of that sentence: The order of the substrings corresponding to the categories Z and X
X /
Y (in the case of rule R4) is reversed. In particular, R3 captures the relation between the two derivations of Swiss German word orders shown in Figure 11: Applying R3 may reorder the yield of a derivation, every t ransformed derivation still is a derivation of G .
 Example 9 If we take the derivation in Figure 6 and exhaustively apply the rewriting rules from
Figure 12, then the derivation that we obtain is the one in Figure 7. Note that although the latter derivation is not grammatical with respect to the grammar G it is grammatical with respect to the grammar G 2 from the proof of Lemma 4, which is without target restrictions.
 the normal form of Eisner (1996). This normal form is used in practical CCG parsers to solve the problem of  X  X purious ambiguity,  X  where one and the same semantic interpre-tation (which in CCG takes the form of a lambda term) has multiple syntactic derivation trees. It is established by rewriting rules such as the following: rules R3 and R4) may reorder the yield of a der ivation, whereas Eisner  X  X  normal form 204 preserves yields. Second, our rules decrease the degrees of the involved composition operations, whereas Eisner X  X  rules may in fact increase them. To see this, note that the left-hand side of derivation (7) involves a composition of degree the right-hand side involves a composition of degree rewriting will increase the degree in situations where only fire in the case where the combination with Z happens by means of an appli-
Lemma 7. 3.4.1 Properties of the Transformation. The next two lemmas show that the rewriting system in Figure 12 implements a total function on the derivations of G . Lemma 7
The rewriting system is terminating and confluent: Rewriting a derivation ends after a finite number of steps, and different rewriting orders all result in the same output. Proof other secondary input categories are left un changed. As an example, consider rewriting under R1. The secondary input categories in the scope of that rule are Y on the left-hand side and Y  X  and Z on the right-hand side. Here the arity of Y equals the arity of Y  X / Z , minus one. Because the system is terminating, to see that it is also confluent, it suffices to note that the left-hand sides of the rewrite rules do not overlap.
 Lemma 8 The rewriting system transforms derivations of G into derivations of G .
 Proof
We prove the stronger result that every rewriting step transforms derivations of G into rules are similar. Assume that R1 is applied to a derivation of G . The rule instances in the scope of the left-hand side of R1 take the following form: Turning to the right-hand side, the rule in stances in the rewritten derivation are closed grammars (Definition 2): If instance (8) is valid, then because G is prefix-closed, instance (11) is valid as well. Similarly, the relation between instances (9) and (10) is the characteristic relation of grammars withou t target restrictions (Definition 3): If in-stance (9) is valid, then because G is without target restrictions, instance (10) is valid as well. We conclude that if R1 is applied to a derivation of G , then the result is another derivation of G .
 exhaustive application of the rewriting rules produces another uniquely determined derivation of G . We shall refer to this derivation as R ( d ). A transformed derivation is any derivation d such that d = R ( d ) for some derivation d . 3.4.2 Language I nclusion and P arikh-E quival ence Lemma 9 The yields of the transforme d derivations are a subset of and Parikh-equivalent to L ( G ). Proof
Let Y be the set of yields of the transfor med derivations. Every string w from a string w  X  L ( G ) by choosing some derivation d of w , rewriting this derivation into the transformed derivation R ( d ), and taking the yield. Inclusion then follows from
Lemma 8. Because of the permuting rules R3 and R4, the strings w and w will in general be different. What we can say, however, is that w and w will be equal up to permutation. Thus we have established that Y and L ( G ) are Parikh-equivalent.
 formed derivations form a context-free language. 3.4.3 Context-Freeness of the Sublanguage. In a derivation tree, every node except the root node is labeled with either the primary or t he secondary input category of a combina-tory rule. We refer to these two types of nodes as primary nodes and secondary nodes , respectively. To simplify our presentation, we shall treat the root node as a secondary the root node is labeled with the di stinguished atomic category S . For a leaf node u , the projection path of u is the path that starts at the parent of u and ends at the first secondary node that is encountered on the way towards the root node. We denote a projection path as a sequence X 1 , ... , X n ( n  X  1), where X of u and X n is the category at the secondary node. Note that the category X from the lexicon, while every other catego ry is derived by combining the preceding category on the path with some secondary input category (not on the path) by means of some combinatory rule.
 Example 10 lexical category. In Figure 7, the projection path of the first b ends at the root, while the projection paths of the remaining b s end at the nodes with category B ,andtheprojection paths of the c s end at the nodes with category C . 206 composition rules. Note that any part may consist of a single category only, in which which alternates between composition (with C Lemma 10 In transformed derivations, e very projection path is split.
 Proof
We show that as long as a derivation d contains a projection path that is not split, it can be rewritten. A projection path that is not split contains three adjacent categories
U , V , W ,suchthat V is derived by means of a composition with primary input U ,and W is derived by means of an application with primary input V . Suppose that both the composition and the application are forward. (The arguments for the other three cases are similar.) Then U can be written as X / Y for some category X and argument can be written as X  X / Z for some argument / Z and some (possibly empty) sequence of arguments  X  ,and W can be written as X  X  . We can then convince ourselves that d contains the following configuration, which matches the left-hand side of rewriting rule R1: Lemma 11 The set of all categories that occur in t ransformed derivations is finite. Proof
Every category that occurs in transformed der ivations occurs on some of its projection paths. Consider any such path. By Lemma 10 we know that this path is split; its two parts, here called P 1 and P 2 , are visualized in Figure 13. We now reason about the arities of the categories in these two parts. 1. Because P 1 only uses application, the arities in this part get smaller and 2. Because P 2 only uses composition, the ariti es in this part either get larger
Thus the arities of our chosen path are bounded by the maximum of three grammar-specific constants: the maximal arity of a lexical category, the arity of S (which is 0), and the maximal arity of a secondary input category. The latter value is well-defined because there are only finitely many such categories (by Lemma 2). Let k be the maximum among the three constants, and let K be the set of all categories of the form A | m X m  X  X  X | 1 X 1 where A is an atomic category of G , m argument that may occur in derivations of G .Theset occur on some projection path, and therefore all categories that occur in transformed derivations, but it may also include other categories. As there are only finitely many atomic categories and finitely many arguments (Lemma 1), we conclude that the set well.
 Lemma 12 The transformed derivations yield a context-free language.
 Proof We construct a context-free grammar H that generates the set formed derivations. To simplify the pres entation, we first construct a grammar H that generates a superset of Y .

Construction of H . The construction of the grammar H is the same as the construction in the classical proof that showed the context-freeness of AB-grammars, by Bar-Hillel,
Gaifman, and Shamir (1960): The production rules of H are set up to correspond to the valid rule instances of G . The reason that this construction is not useful for VW-CCGs in general is that these may admit infinitely many rule instances, whereas a context-free grammar can only have finitely many productions. The set of rule instances may be infinite because VW-CCG has access to composition rules (specifically, rules of degrees greater than 1); in contrast, AB-grammars are r estricted to application. Crucially though, by Lemma 11 we know that as long as we are interested only in transformed derivations it is sufficient to use a finite number of rule instances X  X ore specifically those whose input and output categories are included in the set K of arity-bounded categories. Thus for every instance X / YY  X  X  X  where all three categories are in production 208 and similarly for backward rules. (We enclose categories in square brackets for clarity.)
In addition, for every lexicon entry  X  : = X in G we add to H aproduction[ X ]
As the terminal alphabet of H we choose the vocabulary of G ; as the nonterminal atomic category S . Every transformed derivation of G corresponds (in an obvious way) to some derivation in H ,whichprovesthat Y  X  L ( H ). Conversely, every derivation of H represents a derivation of G (though not necessarily a transformed derivation), thus L ( H )  X  L ( G ).

Construction of H. The chain of inclusions Y  X  L ( H )
Lemma 6: Because Y and L ( G ) are Parikh-equivalent (which we observed at the be-of the properties claimed in Lemma 6, even though this does not suffice to prove our current lemma. However, once H is given, it is not hard to also obtain a grammar H that generates exactly Y . For this, we need to filter out deriva tions whose projection paths do not have the characteristic property of transformed derivations that we established in
Lemma 10. (It is not hard to see that every derivation that does have this property is a transformed derivation.) We annotate the left-hand side nonterminals in the produc-tions of H with a flag t  X  X  a , c } to reflect whether the corresponding category has been derived by means of application ( t = a ) or composition ( t simply the type of combinatory rule that gave rise to the production. The nonterminals combinations are ruled out:
These combinations represent exactly the cases where the output category of a compo-sition rule is used as the primary input cat egory of an application rule, which are the cases that violate the  X  X plit X  prope rty that we established in Lemma 10. 3.5 Discussion
Theorem 3 pinpoints the exact mechanism that VW-CCG uses to achieve weak equiv-frequently used in linguistically motivated grammars, it is important and perhaps surprising to realize that they are indeed necessary to achieve the full generative capacity of VW-CCG.
 tributed to generalized composition, and indeed we have seen (in Lemma 4) that even grammars without target restrictions can ge nerate non-context-free languages such as
L ( G 2 ). However, our results show that composition by itself is not enough to achieve weak equivalence with TAG: The yields of the transformed derivations from Section 3.4 compositions, including compositions of degree n &gt; 2. In addition to composition, VW-enforce alternations of composition and application (as in the derivation shown in
Figure 6), while transformed derivations are c haracterized by projection paths without such alternations (Lemma 10).
 that are crucial for the generative capaci ty of VW-CCG are not those on generalized composition, but those on function application. To see this we can note that the proof of Lemma 8 goes through also only if application rules such as (9) and (10) are without target restrictions. This means that we have the following qualification of Theorem 1. Lemma 13
Prefix-closed VW-CCG is weakly equivalent to TAG only because it supports target restrictions on forward and backward application.
 uses target restrictions on the application rules. 4. Generative Capacity of Multimodal CCG
After clarifying the mechanisms that  X  X lassical X  CCG uses to achieve weak equivalence with TAG, we now turn our attention to  X  X odern, X  multimodal versions of CCG (Baldridge and Kruijff 2003; Steedman and Baldridge 2011). These versions emphasize instead equip slashes with types in order to control the use of the combinatory rules.
Our central question is whether the use o fslashtypesissufficienttorecoverthe expressiveness that we lose by giving up rule restrictions.

Published works on multimodal CCG differ wi th respect to the specific inventories of slash types they assume. Some important de tails, such as a precise definition of gener-alized composition with slash types, are typically not discussed at all. In this article we define a variant of multimodal CCG which we call O-CCG. This formalism extends our definition of VW-CCG (Definition 1) with the slash inventory and the composition rules of the popular OpenCCG grammar development system (White 2013). Our technical result is that the main Lemma (Lemma 6) also holds for O-CCG. With this we can conclude that the answer to our question is negative: Slash types are not sufficient to primarily a theoretical result, at the end of t his section we also discuss its implications for practical grammar development. 4.1 Multimodal CCG We define O-CCG as a formalism that extends VW-CCG with the slash types of
OpenCCG, but abandons rule restrictions. Note that OpenCCG has a number of ad-ditional features that affect the generative capacity; we discuss these in Section 4.4.
Slash Types. Like other incarnations of multimodal CCG, O-CCG uses an enriched notion of categories where every slash has a type . There are eight such types: 210
The basic idea behind these types is as follows. Slashes with type to instantiate application rules. Type also licenses harmonic composition rules, and type  X  also licenses crossed composition rules. Type  X  is the least restrictive type and can be used to instantiate all rules. The remaining types refine the system by incorpo-rating a dimension of directionality. The exa ct type X  X ule compatibilities are specified in Figure 14.

Inertness. O-CCG is distinguished from other versions of multimodal CCG, such as that inertness status . Inertness was introduced by Baldridge (2002, Section 8.2.2) as an im-plementation of the  X  X ntecedent government X  ( ANT ) feature of Steedman (1996), which is used to control the word order in certain English relative clauses. It is a two-valued feature. Arguments whose slash type has inertness status + whose slash type has inertness status  X  are called inert . Only active arguments can be eliminated by means of combinatory rule s; however, an inert argument can still be consumed as part of a secondary input categ ory. For example, the following instance of application is valid because the outermost slash of the primary input category has inertness status + : slash type t and inertness status s .
 Rules. All O-CCG grammars share a fixed set of combinatory rules, shown in Figure 15.
Every grammar uses all rules, up to some grammar-specific bound on the degree of generalized composition. As mentioned e arlier, a combinatory rule can only be in-uniform direction. This is a somewhat pecu liar feature of OpenCCG, and is in contrast to VW-CCG and other versions of CCG, which also allow composition rules with mixed directions.
 is based on the direction of the slashes in the secondary input category. If these have the same direction as the outermost slash of t he primary input category, then the rule is called harmonic; otherwise it is called crossed. 6 are simply copied into the output category, as in VW-CCG. The one exception happens slash type (left or right). In this case, the a rguments of the secondary input category become inert. Thus the inertness status of an argument may change over the course of a derivation X  X ut only from active to inert, not back again.
 Definition 5
A multimodal combinatory categorial grammar in the sense of OpenCCG, or O-CCG for short, is a structure where  X  is a finite vocabulary, A is a finite set of atomic categories, : between  X  and the set of (multimodal) categories over A , d of generalized composition, and S  X  A is a distinguished atomic category. guage to categories over slashes with types a nd inertness statuses in the obvious way:
Instead of two slashes, we now have one slash for every combination of a direction, type, and inertness status. Similarly, we generalize the concepts of a grammar being prefix-closed (Definition 2) and without target restrictions (Definition 3) to O-CCG. 212 4.2 Generative Capacity
We now investigate the generative capacity o f O-CCG. We start with the (unsurprising) observation that O-CCG can describe non-context-free languages.
 Lemma 14 The languages generated by O-CCG properly include the context-free languages. Proof
Inclusion follows from the fact that every AB-grammar can be written as an O-CCG with only application ( d = 0). To show that the inclusion is proper, we use the same argument as in the proof of Lemma 4. The grammar G 2 that we constructed there can be turned into an equivalent O-CCG by decorating each slash with type, and setting its inertness status to + .
 VW-CCG and TAG. Our main result is that this is not the case.
 Theorem 4 The languages generated by O-CCG are properly included in the TAG languages.
O-CCG without Inertness. To approach Theorem 4, we set inertness aside for a moment and focus on the use of the slash types as a mechanism for imposing rule restrictions.
Each of the rules in Figure 15 requires all of the slash types of the n outermost arguments of its secondary input category to be compatible with the rule, in the sense specified instance, then the new instance is clearly still valid, as we have reduced the number of potential violations of the type X  X ule compatibility. This shows that the rule system is prefix-closed. As none of the rules is conditioned on the target of the primary input category, the rule system is even without tar get restrictions. With these two properties established, Theorem 4 can be proved by lit erally the same arguments as those that we gave in Section 3. Thus we see directly that the theorem holds for versions of multi-modal CCG without inertness, such as the formalism of Baldridge and Kruijff (2003).
O-CCG with Inertness. In the general case, the situation is complicated by the fact that the crossed composition rules change the iner tness status of some argument categories if the slash types have conflicting directions. This means that the crossed composition rules in O-CCG are not entirely prefix-closed, as illustrated by the following example. Example 11 Consider the following two rule instances:
Instance (12) is a valid instance of forward crossed composition. Prefix-closedness status of match the required direction. In instance (13) the argument therefore the inertness status of category.
 O-CCG: Lemma 15 (Main Lemma for O-CCG)
For every language L generated by some O-CCG there is a sublanguage L 1. L and L are Parikh-equivalent, and 2. L is context-free.

This lemma implies that the language L 1 = { a n b n c n | generated by O-CCG (but by prefix-closed VW-CCG with target restrictions, and by
TAG). The argument is the same as in the proof of Theorem 3. 4.3 Proof of the Main Lemma for O-CCG
The proof of Lemma 15 adapts the rewriting system from Figure 12. We simply let each rewriting step copy the type and inertness status of each slash from the left-hand side to the right-hand side of the rewriting rule. With this change, it is easy to verify that the proofs of Lemma 7 (termination and confluence), Lemma 10 (projection paths in transformed derivations are split), Lemma 11 (transformed derivations contain a finite number of categories), and Lemma 12 (transformed derivations yield a context-free language) go through without problems. The proof of Lemma 8, however, is not straightforward, because of the dynamic natu re of the inertness statuses. We therefore restate the lemma for O-CCG: Lemma 16 The rewriting system transforms O-CCG derivations into O-CCG derivations. Proof
As in the proof of Lemma 8 we establish the stronger result that the claimed property holds for every single rewriting step. We on ly give the argument for rewriting under R3, which involves instances of forward crossed composition. The argument for R4 is anal-ogous, and R1 and R2 are simpler cases because they involve harmonic composition, where the inertness status does not change.
 form, the rule instances in the scope of the le ft-hand side of R3 may be written as follows, where the function  X  is defined as specified in Figure 15: 214
Here instance (14) is an instance of forward-crossed composition, so each of the types t is compatible with that rule. Because the two marked arguments are identical, we have  X  ( s 1 ) =+ . This is only possible if the inertness statuses of the slashes in the context of derivation (14), that is, if  X  ( s t , ... , t and (15) as Then the rule instances in the rewritten d erivation can be written as follows: earlier observations about the t i and their compatibility with crossed composition, we also see that instance (17) is a valid instance of forward crossed composition (if n or of forward application (if n = 1).
 to also establish the inclusion of the O-CCG languages in the TAG languages. This is a known result for other dialects of multimodal CCG (Baldridge and Kruijff 2003), but O-CCG once again requires some extra work because of inertness.
 Lemma 17 The O-CCG languages are included in the TAG languages.
 Proof (Sketch)
It suffices to show that the O-CCG languages are included in the class of languages generated by LIG (Gazdar 1987); the claim then follows from the weak equivalence of
LIG and TAG. Vijay-Shanker and Weir (1994, Section 3.1) present a construction that transforms an arbitrary VW-CCG into a weakly equivalent LIG. It is straightforward to adapt their construction to O-CCG. As we do not have the space here to define LIG, we only provide a sketch of the adapted construction.
 ten down using our template notation. The adapted construction converts each such template into a production rule of a weakly equivalent LIG. Consider for instance the following instance of forward crossed composition from Example 11: This template is converted into the following LIG rule. We adopt the notation of Vijay-Shanker and Weir (1994) and write  X  X  X  for the tail of a stack of unbounded size.
In this way, every O-CCG can be written as a weakly equivalent LIG. 4.4 Discussion
In this section we have shown that the languages generated by O-CCG are properly included in the languages generated by TAG, and equivalently, in the languages gen-erated by VW-CCG. This means that the multimodal machinery of OpenCCG is not powerful enough to express the rule restrictions of VW-CCG in a fully lexicalized way. The result is easy to obtain for O-CCG without inertness, which is prefix-closed
O-CCG with inertness, which is not prefix-closed. As we have already mentioned, the result carries over also to other multimodal versions of CCG, such as the formalism of Baldridge and Kruijff (2003).

To illustrate this, recall Example 7, which showed that every VW-CCG without target restrictions for Swiss German that allows cr oss X  X erial word orders as in derivation (5) also permits alternative word orders, as in derivation (6). By Lemma 15, this remains true for O-CCG or weaker multimodal formalisms. This is not a problem in the case of Swiss German, where the alternative wor d orders are grammatical. However, there is at least one language, Dutch, where dependencies in subordinate clauses must cross.
For this case, our result shows that the modalized composition rules of OpenCCG are not powerful enough to write adequate grammars. Consider the following classical example:
The straightforward derivation of the cro ss X  X erial dependencies in this sentence (adapted from Steedman 2000, p. 141) is exemplified in Figure 16. It takes the same form as derivation (5) for Swiss German: The verbs and their NP arguments lie on a single, right-branching path projected from the tensed verb zag .Thisprojectionpathis not split; specifically, it starts with a composition that produces a category which acts as the primary input category of an application. As a consequence, the derivation can be transformed (by our rewriting rule R3) in exactly the same way as instance (5) could be transformed into derivation (6). The cruc ial difference is that the yield of the trans-formed derivation, *ik Cecilia zag de paarden voeren , is not a grammatical clause of Dutch. clauses, the VW-CCG grammar of Steedman (2000) and the multimodal CCG grammar tion. In particular, they assume that all complement noun phrases undergo obligatory type-raising, and become primary input ca tegories of application rules. This gives rise to derivations such as the one shown in Figure 17, which cannot be transformed using our rewriting rules because the result of the forward crossed composition 216 now is a secondary rather than a primary input category. As a consequence, this grammar is capable of enforcing the obligatory cross-serial dependencies of Dutch.
However, it is important to note that it requi res type-raising over arbitary categories
This kind of type-raising is allowed in many variants of CCG, including the full for-malism underlying OpenCCG. VW-CCG and O -CCG, however, are limited to gen-unbounded type-raising required by the Steedman X  X aldridge analysis of Dutch would translate into an infinite lexicon, and so this analysis is not possible in VW-CCG and O-CCG.
 that we have not captured in O-CCG. First, OpenCCG allows us to use generalized composition rules of arbitrary degree; there is no upper bound d on the composi-capacity of CCG beyond that of TAG (Weir 1988). Second, OpenCCG allows cate-gories to be annotated with feature struct ures. This has no impact on the generative compiled into the atomic categories of th e grammar. Finally, OpenCCG includes the combinatory rules of substitution and coordination, as well as multiset slashes ,an-other extension frequently used in linguistic grammars. We have deliberately left these constructs out of O-CCG to establish the most direct comparison to the literature on
VW-CCG. It is conceivable that their inclusion could restore the weak equivalence of Vijay-Shanker and Weir (1994). Regarding multiset slashes, it is also worth noting that these were introduced with the expressed goal of allowing more flexible word order, whereas restoration of weak equivalence would require more controlled word order. 5. Conclusion
In this article we have contributed two techni cal results to the literature on CCG. First, we have refined the weak equivalence result for CCG and TAG (Vijay-Shanker and
Weir 1994) by showing that prefix-closed grammars are weakly equivalent to TAG only if target restrictions are allowed. Second, we have shown that O-CCG, the formal, composition-only core of OpenCCG, is not weakly equivalent to TAG. These results point to a tension in CCG between lexicalizat ion and generative capacity: Lexicalized versions of the framework are less powerfu l than classical versions, which allow rule restrictions.
 tive. One way to look at CCG is as a system for defining formal languages. Under this view, one is primarily interested in results on generative capacity and parsing complex-ity such as those obtained by Vijay-Shanker and Weir (1993, 1994). Here, our results clarify the precise mechanisms that make CCG weakly equivalent to TAG. Perhaps surprisingly, it is not the availability of gener alized composition rules by itself that ex-plains the generative power of CCG, but the a bility to constrain the interaction between generalized composition and function application by means of target restrictions. developing grammars for natural languages (Steedman 2000; Baldridge 2002; Steedman 2012). From this point of view, t he suitability of CCG for the development of lexicalized grammars has been amply demonstrated. However, our technical results still serve as important reminders that extra care must be taken to avoid overgeneration when designing a grammar. In particular, it i s worth double-checking that an OpenCCG grammar does not generate word orders that the grammar developer did not intend. Here the rewriting system that we presented in Figure 12 can serve as a useful tool:
A grammar developer can take any derivation for a grammatical sentence, transform derivation still yields a grammatical sentence.
 and lexicalization might be reconciled. A simple answer is to add some lexicalized method for enforcing target restrictions to CCG, specifically on the application rules.
However, we are not aware that this idea has seen widespread use in the CCG literature,
O-CCG in such a way that they are no longer prefix-closed X  X or example, by introducing set aside in O-CCG (such as type-raising, substitution, and multiset slashes) might be sufficient to achieve the generative capacity of classical CCG and TAG. A detailed study of the expressive power of these constructs wo uld make an interesting avenue for future research.
 Acknowledgments 218
