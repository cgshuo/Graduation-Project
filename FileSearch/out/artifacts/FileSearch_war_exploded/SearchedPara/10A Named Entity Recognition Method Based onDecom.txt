 Named entity (NE) recognition is a process by which the names of particular classes and numeric expressions are recognized in text. NEs include person names, locations, organizations, dates, times, and so on. NE recognition is one of the basic technolo-gies used in text processing, including information extraction (IE), question answering (QA), and information retrieval (IR).

Supervised learning algorithms have been applied successfully to create NE rec-ognizers. In the early stages, algorithms for training classifiers, including maximum entropy models [Uchimoto et al. 2000], AdaBoost-based learning algorithms [Carreras et al. 2002; Iwakura 2011], and support vector machines (SVMs) [Yamada 2007] were widely used. Recently, learning algorithms for structured prediction, such as linear-chain structured predictions, and semi-Markov model-based ones have been widely used. Examples of linear-chain structured predictions include conditional random fields (CRFs) [Lafferty et al. 2001], structured perceptron [Collins 2002a], passive aggressive-based structured prediction [Crammer et al. 2006], adaptive regu-larization of weights-based structured prediction [Mejer and Crammer 2010], and so on. Examples of semi-Markov model-based learning algorithms include semi-Markov model perceptron [Cohen and Sarawagi 2004], semi-Markov CRFs [Sarawagi and Cohen 2004], and so on. These structured prediction algorithms have recently been used more than algorithms for training classifiers because of their good performance in terms of accuracy.

However, the computational cost of using these algorithms for structured prediction can become problematic when handling a large number of NE classes. The computa-tional cost of learning first-order Markov models with linear-chain CRFs or structured perceptron is O ( K 2 N ) , where K is the number of classes and N is the length of a sentence. Semi-Markov-based algorithms, such as semi-Markov perceptron and semi-Markov CRFs, enumerate NE candidates represented by word chunks in advance for capturing features such as the first and last word of a chunk. Therefore, on a semi-Markov-based model, if a sentence that has N words is processed with the upper-bound length of word chunks L , about L  X  N word chunks are generated. If only current word chunks X  classes are taken into consideration, the computational cost is O ( KLN ) , where K is the number of classes. If the classes of previous chunks are taken into considera-tion, the computational cost is O ( K 2 LN ) .

The computational cost might not be a big problem when we use these learning al-gorithms to recognize a small number of NE classes, such as the seven classes in MUC [Grishman and Sundheim 1996], the eight classes in IREX [IREX Committee 1999], and the four classes in the CoNLL shared task [Tjong Kim Sang and De Meulder 2003]. However, the computational cost will be higher when we recognize a large number of classes, such as an English fine-grained NE type that includes 64 classes [Weischedel and Brunstein 2005], and Sekine X  X  extended NE hierarchy that includes about 200 classes of NEs for covering several types of needs of IE, QA, and IR [Sekine et al. 2002]. In addition, these days, in order to attain high accuracy with machine learning algorithms, larger training data can be made by asking several annotators in a short period of time [Snow et al. 2008]. The computational cost would be higher than ever on training with such large training data for predicting large classes. This article proposes a word-chunk-based NE recognition method for creating fast NE recognizers, while high accuracy is maintained by capturing rich features extracted from word chunks. Our method recognizes NEs from word-chunk sequences identified by a base chunker. When we use a base chunker with a computational cost of O ( KN ) or lower, we can maintain the computational cost of our method as O ( KN ) , because the length of the word-chunk sequence is less than or equal to the sentence length N . In addition, our method can use features extracted from word chunks that cannot be obtained in word-based NE recognition.

However, each word chunk may include part of an NE or multiple NEs. To solve this problem, we use the following operators: SHIFT for separating the first word from a word chunk, POP for separating the last word from a word chunk, JOIN for con-catenating two word chunks, and REDUCE for assigning an NE class label to a word chunk. Therefore, we call our method SHIFT-POP-JOIN-REDUCE parser (SPJR).
We demonstrate experimentally that the training and processing speeds of SPJR-based NE recognizers can be considerably faster than those of a linear-chain-perceptron and a semi-Markov-perceptron, while maintaining high accuracy. This section describes our method that recognizes NEs from word-chunk sequences. We assume that word-chunk sequences are given by a base chunker, which is described in Section 3.5. When we recognize NEs from word-chunk sequences, we should solve the following problems. The first is that each word chunk may include part of an NE or multiple NEs. The other is that an NE may consist of more than one word chunk.

To recognize NEs from word-chunk sequences correctly, we use SHIFT and POP for decomposing word chunks, JOIN for concatenating two word chunks, and REDUCE for assigning one of the defined NE class labels. SHIFT and POP are used for recognizing NEs from word chunks that include a part of an NE or multiple NEs. JOIN is used for recognizing NEs that consist of more than one word chunk.

In the following, C = C 1 ,..., C | C | denotes a word-chunk sequence. cbw word of C j ,and cew j is the last word of C j .  X  REDUCE . This operator assigns one of the NE labels to a word chunk. Therefore,
REDUCE is defined for each NE class.  X  POP . This operator separates the last word from a word chunk, and the separated word is treated as a new word chunk. POP is only applied to a word chunk con-sisting of more than one word. When POP is applied to C j separated from C j . Indices of the following word chunks C incremented by 1, and the separated word cew j becomes new C ceptional procedure for POP to use as much initial chunk information as possible. If
POP is successively applied to the j th chunk, the separated words are concatenated and regarded as the ( j + 1 ) th chunk. For example, if C and POP is applied to both y and z, then the C j + 1 will be considered to be  X  X  z X .  X  SHIFT . This operator separates the first word from a word chunk, and the sepa-rated word is treated as a new word chunk. SHIFT is only applied to a word chunk consisting of more than one word. When SHIFT is applied to C is separated from C j . Indices of the word chunks C k ( j by 1, and the separated word cbw j becomes new C j .  X  JOIN . This operator concatenates two adjacent word chunks. When JOIN is applied to C j and C j + 1 , C j and C j + 1 are concatenated for creating new C word chunks C k ( j + 2  X  k  X | C | ) are decremented by 1. To avoid an endless loop by generating previously processed word chunks, we forbid JOIN from occurring immediately after POP or SHIFT. The input to our training procedure is the word chunks of a base chunker along with the NE labels on those correct word chunks. To train an NE recognizer, we first gen-erate training samples and then run a machine-learning algorithm over the train-ing samples. Figure 1 shows a pseudocode of the procedure for generating training samples from the i th input. { T 1 ,... T M } is a set of training data consisting of M sentences.
 chunk of T i ,and l ( T i , j ) is the NE label of T i , j
The procedure for T i runs by checking the following conditions, and the procedure is terminated when all word chunks in T i are processed.  X ( S0 ). We generate initial word chunks C from the word sequence consisting of T with the given base chunker. We start to check the following steps from (S1) to (S5) for generating samples. The following process continues until all word chunks in T are processed.  X ( S1 ). If the current chunk C j is equivalent to the correct chunk T training sample for REDUCE = l ( T i , j ) . This means REDUCE for annotating a word chunk with l ( T i , j ) . If all word chunks are processed, the generation of training data for T i is terminated. If not, we move to the next word chunk ( j ++).  X ( S2 ). If the label of the last word of the current chunk cew for applying POP to C j is generated. Then POP is applied to C  X ( S3 ).If the label of the first word of the current chunk cbw for applying SHIFT to C j is generated. Then SHIFT is applied to C  X ( S4 ). If a word or words included in C j are not the constituents of T sample for applying POP to C j is generated.
  X ( S5 ). If all the preceding steps are not executed, the correct NE exists across more than one chunk. Therefore, we generate a sample of current word chunk for JOIN.

After generating training samples for all the inputs, we train a model from the train-ing samples with a machine-learning algorithm. Consider the following training data T i .  X  [Mr.] O [Ken Ono] PER [went] O [skiing] O
We first identify base chunks, and the result is as follows.  X  [Mr. Ken] [Ono went] [skiing]
We denote this base chunking result as C . Word chunks are indicated by bracketing, and a current chunk is underlined.

We first compare T i ,1 and C 1 . C 1 is not equivalent to T first word of C 1 ,  X  X r. X , is  X  X  X . Therefore, we generate a training sample for applying SHIFT to C 1 by (S3) and apply SHIFT to C 1 . The current C would be the following.  X  [Mr.] [Ken] [Ono went] [skiing]
We compare C 1 and T i ,1 again, and C 1 is equivalent to T a training sample for applying REDUCE = O to C 1 by (S1) and move to the next word chunk.  X  [Mr.] [Ken] [Ono went] [skiing]
C 2 is not equivalent to T i ,2 ,and C 2 does not satisfy (S1) to (S4). We generate a training sample of JOIN for C 2 by (S5) and apply JOIN to C  X  [Mr.] [Ken Ono went] [skiing] C 2 is still not equivalent to T i ,2 , and the NE label of the last word  X  X ent X  is  X  X  X . Therefore, we generate a training sample for applying POP to C POP to C 2 .  X  [Mr.] [Ken Ono] [went] [skiing]
C 2 is equivalent to T i ,2 , and a training sample for REDUCE = PER is generated. The next processed chunk is C 3 .  X  [Mr.] [Ken Ono] [went] [skiing] The current chunk is C 3 , and the chunk is equivalent to T for REDUCE = O is generated.  X  [Mr.] [Ken Ono] [went] [skiing] The remaining chunk C 4 is also equivalent to T i ,4 . A training sample for REDUCE = O is generated, and the generation of training samples for T Figure 2 shows a pseudocode of our NE recognition method. When recognizing NEs from a given word sequence, we first identify an initial word chunk sequence of the input with a base chunker as in the training.

Then we process each word chunk from the beginning of the sentence to the end of the sentence. An operator to use on the current word chunk is decided upon with a trained model, and each word chunk is processed according to the selected operator. If all the word chunks are processed, we return word chunks with their NE labels. Consider the following input data.  X  Mr. Jim Ji goes to U.K.

We identify base chunks of the input, and the identified result is as follows.  X  [Mr. Jim Ji] [goes] [to] [U.K.] We denote this base NE chunking result as C . An operator for each word chunk in C is selected with a trained model Model . Here, we assume SHIFT is selected and apply SHIFT to C 1 . After applying SHIFT to C 1 , C 1 becomes [Mr.], and C [Jim Ji].  X  [Mr.] [Jim Ji] [goes] [to] [U.K] We start to select an operator for the new C 1 , and REDUCE = O is selected. We keep O as the NE class of C 1 , and move to the next chunk C 2  X  [Mr.] O [Jim Ji] [goes] [to] [U.K.] Next, we select an operator for the C 2 , and REDUCE = PER is selected. We keep PER as the NE class of C 2 and move to the next chunk C 3  X  [Mr.] O [Jim Ji] PER [goes] [to] [U.K.] For the current chunk C 3 , REDUCE = O is selected. We keep O as the NE class of C and move to the next chunk C 4 .  X  [Mr.] O [Jim Ji] PER [goes] O [to] [U.K.] For the current chunk C 4 , REDUCE = O is selected, too, and we move to the next chunk C 5 .  X  [Mr.] O [Jim Ji] PER [goes] O [to] O [U.K.]
For the current chunk C 5 , REDUCE = LOC is selected, and the recognition is termi-nated. Finally, the final word chunks with their NE labels are returned as the recogni-tion result of the input. We used an extended NE corpus for our evaluation [Hashimoto et al. 2008]. This Japanese corpus consists of about 8,500 articles from the 2005 Mainichi newspaper. NE tags on this corpus are based on the extended NE hierarchy introduced by Sekine et al. [2002]. The corpus includes 240,337 tags for 191 types of NEs. To segment words from Japanese sentences, we used ChaSen. 2
Words may include partial NEs because words segmented with ChaSen do not al-ways correspond with NE boundaries. If such problems occur when we segment the training data, we annotated a word chunk with the type of the NE included in the word chunk. In this experiment, 2.65% of NEs in the training data did not correspond with the correct NE boundaries after segmenting the training data. We did not deal with the difference between NE boundaries and word boundaries in test phases. The evaluations are performed based on the gold standard data for the both the develop-ment and the test.

We created the following sets for this experiment.  X  Training data . News articles from January to October 2005 in the corpus. The train-ing data includes 1,806,772 words and 205,876 NEs.  X  Development data . News articles in November 2005 in the corpus. The development data includes 145,635 words and 15,405 NEs.  X  Test data . News articles in December 2005 in the corpus. The test data includes 177,159 words and 19,056 NEs.

Our evaluation metrics are recall, precision, and F-measure (FM). Recall, precision, and F-measure are defined as follows. and where NE ok is the number of correctly recognized NEs, NE in data, and NE rec is the number of all recognized NEs. The following algorithms are compared with our method.  X  Linear-chain structured perceptron (Linear-Chain) [Collins 2002a] . This is a perceptron-based algorithm for labeling tags to word-sequences. In this algorithm, features are only generated from each word and its surrounding words.  X  Semi-Markov perceptron (Semi-Markov) [Cohen and Sarawagi 2004] . This algo-rithm is based on sequentially classifying chunks of several adjacent words, rather than single words. Ideally, all the possible word chunks of each input should be con-sidered for this algorithm. However, the training of this algorithm requires a great deal of memory. Therefore, we limit the maximum length of the word chunks. We use word chunks consisting of up to five or ten words, because when we trained a Semi-Markov-based recognizer without the chunk length constraint, the Semi-
Markov-based recognizer used 72GB memory, which is our machine memory size, and 1 GB swap region on its hard disc.  X  NE chunking and classification (NECC) [Carreras et al. 2002] . This method consists of two parts. The first is a base NE recognition, as in our method. The second is NE classification. Unlike in our method, this method just classifies given word chunks without decomposing and concatenating them. This method was used in the best system of the shared task of CoNLL 2002 [Tjong Kim Sang 2002].  X  Shift-reduce parser for NE recognition (SR) [Yamada 2007] . This algorithm is based on shift-reduce parsing for word-sequences. It uses two operators. The first is reduce for annotating an NE label to a current word chunk. The other is shift that concate-nates a previous word of a current word chunk to the current word chunk. SR is different from ours in that the initial inputs of their method are word sequences.
SR starts from the process of a single word, and SR cannot use features extracted from chunks without applying shift. If shift is selected, a new chunk is generated by concatenating the previous word of the current word to the current word. After that, features extracted from a chunk can be used in SR. Therefore, SR cannot use fea-tures obtained from word chunks at the early stage. 3 In contrast, our SPJR handles word-chunk sequences, and SPJR can use features extracted from chunks from the beginning.
 sequence that consists of n words, and w i be a current word to be processed. If a current chunk consists of only a word w i , an operator applied to w features extracted from a word w i and its surrounding words, as in Linear-Chain.
The features include the left word of chunk w i  X  1 , the right word of chunk w current word w i ,andsoon.If reduce is applied to w i , an NE label is assigned to w
Otherwise, shift is chosen, and a new chunk that consists of w concatenating the previous word w i  X  1 to w i . If a new chunk that consists of w w i is created, SR chooses an operator with features extracted from the chunk and its surrounding words. In this case, the features extracted from the chunk are such as the beginning word of chunk w i  X  1 , the last word of chunk w words w i  X  1 -w i , and so on, in addition to features extracted from contexts (e.g., the left word of chunk w i  X  2 , the right word of chunk w i + label of chunk w i  X  1 and w i + 1 is decided. Otherwise, a new chunk that consists of w i  X  2 , w i  X  1 and w i is created. We use the multiclass perceptron algorithm for NECC, SR, and SPJR. Thus, all of the algorithms are based on perceptron [Rosenblatt 1958]. We apply the averaged perceptron [Collins 2002a] for all the training algorithms. All the learners and NE rec-ognizers were implemented with C ++. We used perceptron-based algorithms because perceptron-based algorithms usually show faster training speed and lower usage of memory than training algorithms, such as MEMM [McCallum et al. 2000], CRFs [Lafferty et al. 2001], and so on. Actually, when we applied a CRF implementation based on LBFGS [Liu and Nocedal 1989] to the training data, the implementation consumed 72 GB of memory, which is our machine memory size.

We set the number of iterations to the value that yields the highest F-measure in the development data for each NE recognizer. We set the maximum iteration number to 50. The features used in our experiment are shown in Table I. As features for Linear-Chain perceptron, we used the following. Here, k denotes the current word position, w k th word, and p k is the part-of-speech (POS) tag of the k th word. We used the word and the POS of the k th word and the words in two-word windows before and after the k th word with the current NE-tag t k and the NE tag t k  X  NE tag is represented as IOB1 [Ramshaw and Marcus 1995]. This representation uses three tags X  X , O, and B X  X o represent the inside, outside, and beginning of a chunk, respectively. B is only used at the beginning of a chunk which immediately follows another chunk that has the same NE class. Each tag is expressed with NE classes, like I-CL, B-CL, where CL is an NE class.

This experiment uses IOB1 because IOB1 has one of the lowest number of NE tags, and the number of NE tags is related to the training speed of Linear-Chain. We com-pared five types of chunk representation: IOB1 , IOB2, IOE1, IOE2 [Tjong Kim Sang and Veenstra 1999], and Start / End (SE) [Uchimoto et al. 2000] in terms of the number of the NE tags. The number of the NE tags for each representation is as follows: IOB1 is 202, IOB2 is 377, IOE1 is 202, IOE2 is 377, and SE is 730. Actually, Linear-Chain using IOB1-based training data was about 2.4 times faster than Linear-Chain using SE-based training data in our pilot study with small training data.

To realize a fast training speed for Linear-Chain, we only used the valid combination of t k and t k  X  1 in terms of the chunk representation.

Semi-Markov, NECC, SR, and SPJR, using word chunks, used features extracted from words in a word chunk and the words in two-word windows before and after the word chunk. The features extracted from chunks differ from those of Linear-Chain. The NE labels of previous word chunks can be used in these methods. However, the original SR parser does not use previous NE labels. Therefore, to compare the SPJR parser to the SR parser in the same condition, we did not use previous NE labels. NECC and SPJR require a base chunker. To compare performances obtained with dif-ferent base chunkers, we used the following four chunkers.  X  A rule-based chunker (RC) . We used a chunker that concatenates successive words with two rules as a base chunker. The first rule concatenates successive words that have noun or unknown POS tags. The other rule concatenates words existing in brackets. This chunk identification method is fast because the chunker only checks
POS tags.  X  A Japanese base phrase chunker (JBC) . We used Japanese base phrases, called bun-setsu, as base chunks. Bunsetsu is a basic unit in Japanese and basically consists of content words followed by function words, such as postpositions. To identify bun-setsu, we used CaboCha [Kudo and Matsumoto 2002] 4 . We used CaboCha 0.53 be-cause this version supports a Japanese morphological analyzer ChaSen that we used in this experiment. CaboCha 0.53 uses a model trained with SVMs from the Kyoto
University text corpus [Kurohashi and Nagao 1998] for recognizing Japanese base phrases.  X  A dictionary-based chunker (DC) . This chunker identifies word sequences that are included in a given dictionary with longest match as chunks. If there are words that are not included in the dictionary, each word is treated as a chunk. We extracted 1,272,871 gazetteer entries from the Japanese Wikipedia entries of February 20, 2012, and used them as the dictionary of this experiment. We used Wikipedia as the dictionary because previous researches showed the usefulness of Wikipedia for NE recognition tasks [Kazama and Torisawa 2007, 2008; Nothman et al. 2009].  X  A shift-reduce-based NE chunker (SRC) . This NE chunker is trained with the same
SR-based algorithm [Yamada 2007] described in Section 3.2. The difference is that this chunker distinguishes just two chunks: NE and non-NE. To train an NE chun-ker, we first converted the given training data into a training data for base chunkers.
For example, the following labeled input is converted as follows.
BNE indicates that the word chunk becomes NE, and O indicates non-NE.
The converted training data are used for training a base NE chunker that identifies base NEs and non-NEs. Words identified as non-NEs are treated as word chunks consisting of a word.

Then we split the converted training data into five portions. To obtain a training set for recognizing NEs, we repeated the following process for all the five portions.
We trained a base NE chunker with four out of five portions of the converted train-ing data. The base NE chunker identified base NEs from the remaining portion.
After all the portions were processed, we trained the SPJR-or NECC-based NE recognizer from the five portions along with the NE labels on those correct word chunks.

For recognizing NEs in the test phase, we used a base NE chunker trained with all the given training data converted by the method. To examine whether we can attain high accuracy while maintaining fast training and processing speed, we used
SR, the fastest algorithm among our compared algorithms, for training base NE chunkers. Table II shows the experimental results. We used a machine with Intel(R) Xeon(R) CPU X5680 @ 3.33GHz and 72 GB memory. The NE recognizers based on our method showed good performance. SPJR (RC) is the second-and SPJR (JBC) is the third-best F-measure on test data. The best and the fourth systems are Semi-Markov-based ones. These results indicate that features extracted from word chunks contributed to improved accuracy.

SPJR (RC) showed the best accuracy among four SPJR-based chunkers on test data. To compare the results of SPJR (RC) with the others, we employed a McNemar paired test on the labeling disagreements, as was done in Sha and Pereira [2003]. We compared results on test data by character units, as in Japanese morphological analysis [Kudo et al. 2004], because the ends or beginnings of Japanese NEs do not always correspond with word boundaries. All the results except for these of Semi-Markov ( L = 10) indicate that there is a significant difference ( p &lt; 0.01). This result shows that SPJR (RC) showed high accuracy. 5 Our method also showed faster training and processing speeds than those of Linear-Chain and Semi-Markov. Specifically, our proposed method with RC showed about a-87 times faster training speed and about a 27 times faster processing speed than those of Linear-Chain. Our method showed about a 7 times faster training speed and about a 21 times faster processing speed than those of Semi-Markov ( L = 10). In ad-dition, our algorithm requires a lower maximum memory size than Linear-Chain and Semi-Markov.

Table III shows the recall measured by each NE size on test data. The NE size of an NE means the number of words included in the NE in this article. Semi-Markov ( L = 10) showed better recall on all NE sizes than our proposed method-based ones. Semi-Markov ( L = 5) showed better recall on NE sizes 1, 2, 3, and 4 than our proposed method-based ones, too. For NE sizes 3 and 4, Semi-Markov ( L = 5) showed the best recall. However, Semi-Markov ( L = 5) showed the worst recall on the NE size to the constraint of the maximum length of chunks.

Linear-Chain showed good recall on larger NE sizes. For NE size showed the best recall. Our method showed better recall on smaller NE sizes than on larger NE sizes. In fact, the average NE size in test data is 2.12, and 73.3% of NEs are size 1 or 2. We can see that our method improved recall of smaller NE sizes with features obtained from word chunks. This seems to be related to the average NE size in the training data. The average NE size in the training data is approximately 1.8. In addition, approximately 84.5% of NEs consist of one word or two words. Therefore, features that indicate smaller NE sizes like chunk size 1 are preferred to features that indicate larger NE sizes like chunk size greater than 4. As a result, methods using chunks should prefer small NEs to large NEs. Our algorithm showed much faster speed than Linear-Chain. This is due to the difference of computational procedure. Linear-Chain-based ones run the Viterbi algorithm to select the best labeled sequence in terms of the scores assigned by a trained model for each input in both training and testing. When running the Viterbi algorithm, Linear-Chain-based ones have to check the connections of class labels. The number of connections is up to K 2 , where K is the number of types of class labels. On the other hand, SPJR-based ones greedily recognize NEs. Since the maximum length of the word chunks affects the performance of Semi-Markov, we evaluated Semi-Markov using two types of the maximum lengths of the word chunks. Semi-Markov ( L = 5) showed faster training and processing speed than Semi-Markov ( L = 10). However, SPJR-based ones still showed much faster training and processing speed than Semi-Markov ( L = 5). In addition, compared with Semi-Markov ( L = 5), SPJR (RC) and SPJR (JBC) showed higher accuracy, and SPJR (SRC) showed competitive accuracy. This result indicates that SPJR-based ones show faster speed than Semi-Markov, giving up accuracy for improving speed. SR showed faster training and processing speeds than those of SPJR and NECC using the SR-based base NE chunker. Specifically, SR showed about a 2.4 times faster training speed and about a 1.6 times faster processing speed than those of SPJR. This is because SPJR and NECC require training for the SR-based NE chunker and base NE recognition. However, SPJR showed better accuracy than SR. In addition, SPJR (RC) showed faster processing speed than SR. These results indicate that our method using an appropriate base chunker enables fast processing speed while maintaining accuracy. SPJR (RC), SPJR (JBC), and SPJR (DC) showed much higher accuracy than NECC with those base chunkers, because NECC can only identify correct NEs from correct chunks. Table IV shows the recall of each base chunker for identifying chunks that are NEs. For example, the SR-based base NE chunker (SRC) identifies 86.56% of word chunks that are NEs in development data. However, RC, JBC, and DC identified only 50.75%, 3.97% and 56.96%, respectively. Therefore, NECC (RC), NECC (JBC), and NECC (DC) showed low accuracy. These results indicate that our method based on decomposition and concatenation of word chunks contributed to improving accuracy.
However, SPJR (RC) showed more memory usage than SPJR (SR)-and NECC-based ones. This is also related to the accuracy of each base chunker. To correctly recognize NEs from word chunks wrongly identified, more training samples for decomposition or concatenation were generated. Table V shows the number of training samples gener-ated by SPJR or NECC with each base chunker. We can see that when we used RC and JBC, the number of training samples is about two times those of SRC.

NECC showed slightly faster training and processing speeds than SPJR. This may be because NECC identifies the NE class of each word chunk without decomposition or concatenation. Our algorithm showed faster training and processing speeds than Linear-Chain and Semi-Markov. Formally, the computational cost of Semi-Markov is O ( KLN ) , where L is the upper-bound length of word chunks, N is the length of the sentence, and K is the size of the label set. As for Semi-Markov, L is 10 and K is 191 in this experiment. The computational cost of the first-order Linear-Chain perceptron is O ( K 202 in this experiment. In contrast, the computational cost of NECC, SR, and SPJR is O ( KN ) ,and K is 191.

Semi-Markov required more memory usage than the other algorithms. The num-ber of word chunks of each sentence in Semi-Markov is roughly LN . In contrast, the number of word chunks or words of each sentence for Linear-Chain, NECC, SR, and SPJR is up to N . This indicates that Semi-Markov handles about L times larger space than the other algorithms in terms of the number of nodes. Therefore, it requires more memory usage than the others. We examined the four types of base chunkers described in Section 3.5. The experi-mental results showed that there were differences in terms of training speed, memory usages, and processing speed.

One of the reasons for the difference of memory usages is the accuracy of each base chunker for recognizing word chunks that are NEs. For example, most Japanese base phrase bunsetsu do not correspond with chunks that are NEs. As described in Table IV, JBC only identifies 3.97% of word chunks that are NEs in development data, and more concatenation and decomposition procedures are required to identify correct NEs. We can see from Table V that SPJR (JBC) generated the largest number of training samples, too. In contrast, SPJR (SRC) generated about half of the number of training samples compared with those of SPJR (JBC). As a result, memory usage is increased.
A reason for the difference of training speed is how to generate training samples in addition to the accuracy of each base chunker. For example, to generate training sam-ples for SPJR (SRC), we split the training data into five portions and create five base chunkers using four out of five portions. Then each base chunker identified chunks from the rest of the five portions and the identified results were used as initial chunks for training. This procedure requires a longer time than the other base chunker-based methods. As a result, although the number of training samples generated by SPJR (SRC) is smaller than those of SPJR (RC) and SPJR (DC), the total training time of SPJR (SRC) is longer than the total training time of SPJR (RC) and SPJR (DC).
In addition to the accuracy of base chunking, the identification speed of base chunks affects processing speed. For example, although RC showed the second-worst base chunking accuracy, SPJR (RC) showed the fastest speed among four SPJR-based NE recognizers. In fact, RC showed the fastest base chunking speed. For example, the chunk identification speed of RC is approximately two times faster than DC that showed the second fastest processing speed. In addition, we see from Table II that SPJR (RC) showed the second fastest speed among the compared algorithms. These results indicate that SPJR with a fast base chunker contributes to fast processing speed while maintaining high accuracy.

In terms of accuracy, we see from Table II that our proposed method showed sta-ble performance despite the accuracy of base chunking. For example, although JBC showed much lower base chunking accuracy than SRC in Table IV, the accuracy of SPJR (JBC) is slightly better than that of SPJR (SRC). These results indicate our method based on decomposition and concatenation of word chunks contributed to im-proving accuracy. There have been methods proposed for improving the training speed for semi-Markov-based models and perceptron-based methods. With regard to reducing the space of lattices built into the Semi-Markov-based algorithms, a method was proposed to filter nodes in the lattices with a naive Bayes classifier [Okanohara et al. 2006].
Another approaches for improving training speed include a distributed training method. To improve training speed of the structured perceptron, distributed training strategies and convergence bounds for a particular mode of the distributed structured perceptron training are provided [McDonald et al. 2010]. Another training method is distributed asynchronous learning. The training method asynchronously updates a model with the subgradient calculated from a subset of training examples [Gimpel et al. 2010].

While the formulation is different, SPJR shares a similar idea with transformation-based learning [Brill 1995]. For example, a transformation-based POS tagging alters the POS tag of each word with an ordered list of transformations. These transforma-tions alter the POS tag of each word based on contextual cues.

Methods using rich information other than semi-Markov-based algorithms are pro-posed as well. Previous works use N-best outputs to obtain rich features. For example, a boosting-based algorithm [Collins 2000] and a perceptron-based algorithm [Collins 2002b] for reranking N-best outputs were proposed.
 Another approach uses feature forests generated from N-best outputs [Huang 2008]. This method merges N-best outputs into a single lattice. In contrast with these meth-ods, which require a computational cost for processing N-best outputs, our method only handles an output. Our proposed method showed good accuracy and fast processing speed. However, there is a drawback due to our recognition strategy. Since NE recognizers based on our proposed method recognize NEs greedily, a minor error at the NE recognition phase have a substantial effect on the later recognition process. In the future, we consider methods that incorporate techniques used in shift-reduce parsing [Huang and Sagae 2010], like beam search or dynamic programming, into our recognition method for solving the problem.

Some languages, such as Japanese and Chinese, have the problem that NEs do not always correspond with word boundaries. Some previous works proposed meth-ods for coping with the word boundaries problem. One of the methods uses transfor-mation rules to modify the word units given by a morphological analyzer [Uchimoto et al. 2000]. In addition to the transformation-based method, in order to produce more fine-grained output, Isozaki and Kazawa [2002] tuned the parameters of a statistical morphological analyzer. Character-based NE recognition methods have also been used [Asahara and Matsumoto 2003; Iwakura 2011; Kazama and Torisawa 2008]. Another approach uses operators for segmenting characters from words in a shift-reduce-based NE recognition method [Yamada 2007]. In future work, we X  X  like to examine these approaches to get higher accuracy.

Our proposed method can be applied to other chunking tasks and other NE recogni-tion tasks of different languages. We would also like to evaluate our method on such tasks such as NP chunking, Text Chunking [Sang and Buchholz 2000], and multilin-gual NE recognition tasks [Tjong Kim Sang 2002; Tjong Kim Sang and De Meulder 2003].

We used four types of base chunkers. However, there is still an unclear point in terms of the impact of a base chunker X  X  performance on accuracy. To analyze the impact of base chunkers elaborately, evaluations of our method with different base chunkers, such as text chunkers for English [Sang and Buchholz 2000] and a Japanese clause boundaries annotation program [Maruyama et al. 2004], are necessary. We proposed a method for recognizing NEs from word-chunk sequences with operators for decomposing and concatenating word chunks. Experimental results showed that the training and processing speeds of our method are faster than those of linear-chain structured perceptron and semi-Markov perceptron, while maintaining high accuracy.
