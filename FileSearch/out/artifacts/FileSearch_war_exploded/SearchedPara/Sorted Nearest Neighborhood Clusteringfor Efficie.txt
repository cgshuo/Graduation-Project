 Integrating large volumes of data from different sources is an important data pre-processing step in many data mining applications [1]. Since unique entity identifiers are not always available in all the databases to be linked, common identifying attributes, such as names an d addresses, are often used to identify records that need to be reco nciled to the same real-world entities. The degraded quality of data residing in databases (due to transcription errors, missing values, or inconsistent formats), makes the task of integrating databases challenging [2]. Integrating such data in the presence of data quality errors requires approxi-mate comparison functions to be employed to identify if two entities are the same [1]. These comparison functions are often expensive in terms of computa-tional complexity. A naive pair-wise comparison of two databases is of quadratic complexity in their sizes. This makes the record linkage process not scalable to large databases. The scalability problem has been studied by introducing two-step linkage algorithms that avoid all pair-wise comparisons by employing a blocking or indexing technique [3] in the first step, so that detailed comparisons using expensive similarity comparison functions are only made in the second step on a smaller number of candidate record pairs.

Linking data across databases from different organizations is more challenging due to privacy and confidentiality issues that often preclude exchanging sensitive information regarding the entities. Identifying which records in two databases have the same or approximately the same values for a set of attributes with-out revealing the actual values of these attributes is known as the problem of  X  X rivacy-preserving record linkage X  (PPRL) [4 X 6]. Blocking for PPRL needs to be conducted in such a way that no sensitive information that can be used to infer individual records and their attribute values is revealed to any party involved in the process, or to an external adversary. The scalability challenge of PPRL has been addressed by several recent approache s that adapt existing blocking tech-niques, such as standard blocking [7], mapping based blocking [8], clustering [9], and locality sensitive hashing [10], into a privacy-preserving context.
One popular blocking technique used in traditional record linkage is the sorted neighborhood approach [11, 12], where database tables are sorted according to a  X  X orting key X  over which a sliding window of fixed size is moved. Candidate record pairs are then generated from the records that are within the current window. This approach is very efficient compared to other blocking techniques in that its resulting number of candidate record pairs is O (( n A + n B ) w ), com-pared to O (( n A  X  n B ) /b ) for other blocking techniques [3], where n A and n B are the number of records in the two databases to be linked, b is the number of blocks generated, and w is the size of the window. However, the use of sorted neighborhood methods for private blocking has so far not been studied.
We propose an efficient three-party blocking technique for PPRL based on the sorted neighborhood approach using a combination of two privacy techniques: k -anonymous clustering [13] and public reference values [14]. The aim of this approach is to efficiently create k -anonymous clusters re presented by reference values from which candidate record pairs are generated, without revealing any information that can be used to infer individual records and their values. The contributions of this paper are (1) an efficient blocking technique for PPRL based on the sorted neighborhood approach; (2) two variations to gener-ate k -anonymous clusters; (3) an analysis of our solution regarding complexity, privacy, and quality; and (4) an empirical evaluation using real-world datasets. We compare our approach with two state-of-the-art three-party private blocking techniques, which are Karakasidis et al. X  X  [15] approach based on k -nearest neigh-bor clustering, and Durham X  X  [16] approach based on Hamming based locality sensitive hashing.

The remainder of this paper is structured as follows. In the following section, we provide an overview of related work in private blocking. In Sect. 3 we describe our protocol using two small example datasets. In Sect. 4 we analyse the protocol and in Sect. 5 we validate these analyses through an empirical study. Finally we summarize our findings and provide directions for future research in Sect. 6. The use of a blocking technique is crucial in PPRL applications to make the link-age across large databases scalable [3]. Several approaches have been proposed for private blocking. Most work in PPRL that has investigated scalability has employed the basic standard blocking approach [17 X 20]. In traditional standard blocking, all records that have the same blocking key value (the value of a single attribute or a combination of attributes) are inserted into the same block, and only the records within the same block are compared in detail with each other in the comparison step. Each record is inserted into one block only [3]. Al-Lawati et al. [17] explored three methods of token blocking to group hash signatures of the TF-IDF distances of attribute values. Karakasidis et al. [20] proposed phonetic based private blocking where an encoding function, such as Soundex or NYSIIS [1], is used to group records that have similar (sounding) values into the same block. Generalization techniques, such as value generalization hierar-chies [18], k -anonymity [13] and binning [21], have been used for private blocking to generalize records with similar characteristics into the same blocks. Mapping based blocking [8] is another technique that has been employed in PPRL. Scannapieco et al. [22] and Yakout et al. [23] used a multi-dimensional embedded space into which attribute values are mapped while preserving the distances between these values. A cluster ing or nearest neighbor approach is then applied on these multi-dimensional objects to extract candidate record pairs.
Karakasidis et al. [15] used the k -nearest neighbor clustering algorithm to group records such that similar records are put into the same clusters, and each cluster consists of at least k elements to provide a k -anonymous privacy guarantee. Initially clusters are generat ed for a set of reference values that are shared by the database owners, such that each cluster consists of at least k reference values. Each database owner assigns their records into these clusters based on their similarity. These clusters are sent to a third party that merges the corresponding clusters to generate candidate record pairs.

Locality sensitive hashing (LSH) has r ecently been investigated as an efficient technique for scalable record linkage [10, 16]. LSH allows hashing of values in such ways that the likelihood that two similar values are hashed into the same block can be specified through the use of certain hashing functions. Durham [16] investigated how LSH can be applied in Bloom filter based PPRL to reduce the number of record pair comparisons. A Bloom filter is a bit array data structure where hash functions are used to map a set of elements ( q -grams extracted from attribute values) into the bit array. For private blocking, an iterative pruning approach is employed, where random bits are sampled at each iteration from the Bloom filters and sent to a third party. The third party then uses Hamming based LSH functions to compute the Hamming distance that allows efficient generation of candidate record pairs. In this section we describe the steps of our sorted neighborhood clustering (SNC) based private blocking method, and illustrate it with an example consisting of two small databases with given names and surnames, as shown in Fig. 1. Assume Alice and Bob are the two owners of their respective databases D A and D B ,and Carol is the trusted third party. Alice and Bob share the sorted reference list R containing n R reference values selected from the publicly available reference dataset R . Fig. 2 illustrates the three-party setting for private blocking.
The two database owners Alice and Bob perform the following steps: 1. Agree upon the list of attributes to be used as the sorting keys, the reference 2. Alice and Bob each selects and sorts n R ( n R  X | R | ) reference values. The 3. Alice and Bob individually insert thei r records based on the records X  sort-4. The next step is to create k -anonymous clusters. After inserting records into 5. Once the k -anonymous clusters are created, they need to be sent to a third Carol receives the k -anonymous clusters from Alice and Bob and performs the following steps: 6. Find corresponding clusters from Alice and Bob based on the reference po-7. Carol sends the record IDs of the candidate pairs C back to Alice and Bob In this section we analyse our SNC private blocking approach in terms of com-plexity, privacy, and quality. 1. Complexity: Assuming both databases contain n records ( n = n A = 2. Privacy: We assume that all parties that participate in the protocol follow 3. Quality: A good blocking technique should have two properties [3]: (1) We conducted experiments using a real Australian telephone database contain-ing 6,917,514 records. We extracted four attributes commonly used for record linkage: Given name (with 78,336 unique values), Surname (with 404,651 unique values), Suburb (town) name (13,109 unique values), and Postcode (2,632 unique values). To generate datasets of different sizes, we sampled 0.1%, 1%, 10% and 100% of records in the full database twice each, and stored them into pairs of files such that 25%, 50% or 75% of records appeared in both files of a pair. Table 1 provides an overview of the twelve pairs of datasets we generated.
The record pairs that occur in both datas ets are exact matches. To investigate the performance of our protocol in the context of  X  X irty data X  (where attribute values contain errors and variations), we generated another series of datasets where we modified each attribute value by applying one randomly selected char-acter edit operation (insert, delete, substitute, or transposition) [25]. As it turns out, there is no difference in the perform ance of our protocol with modified and not modified datasets, and we theref ore only report averaged results.
We prototyped the protocol using the Python programming language (version 2.7.3). We also implemented prototypes of Karakasidis et al. [15] X  X  k -anonymous nearest neighbor clustering and Durham [16] X  X  Hamming based locality sensitive hashing for comparative analysis and evaluation. We name these two techniques as k -NN and HLSH in the results, respectivel y. We used parameter settings for the k -NN and HLSH methods in a similar range as used by the authors of these two state-of-the-art private blocking methods. For k -NN, k is set to 3 and the similarity threshold is set as s t =0 . 6. In the HLSH method, the number of iterations is set to  X  = 20, the number of hash functions is 30, and the number of bits to be sampled from the Bloom filters at each iteration is  X  = 24. The parameters for the SNC approacheswere set as k = 100 and s t =0 . 9. All tests were run on a compute server with 64 bit Intel Xeon (2.4 GHz) CPUs, 128 GBytes of main memory and running Ubuntu 11.04. The prototype and test datasets are available from the authors. Fig. 5 shows the total time required for private blocking of the four approaches. As can be seen from the figure, the SNC approach (both variations of SNC-Sim and SNC-Size) requires nearly two magnitudes less time by the database owners than the other two approaches (i.e. around 100 times faster) and is also linear in the size of the databases. We were unable to conduct experiments for the HLSH and k -NN approaches on the 1,729,379 datasets due to their memory requirements. The k -NN approach requires less time for the third party than the SNC approaches, because a smaller number of candidate record pairs are generated with the k -NN approach at the cost of much reduced number of true matched record pairs (as is illustrated in the right plot in Fig. 7).
Reduction Ratio (RR) and Pairs Completeness (PC) can be used to assess the efficiency and effectiveness of blocking, respectively [3]. RR is the fraction of record pairs that are removed by a blocking technique and PC is the fraction of true matching record pairs that are included in the candidate record pairs generated by a blocking technique. The SNC approaches achieve high values for bothPCandRRevenwhen k = 100, which gives a strong privacy guarantee (Fig. 6 left plot). As discussed in Sect. 4 , the effectiveness of blocking increases with k while efficiency decreases. As expect ed, the SNC-Sim approach provides a relatively higher PC than the SNC-Size. The right plot in Fig. 6 shows the scalability of our approach with different values for k .

The size of the clusters generated by the four approaches and the resulting PC and RR values are presented in Fig. 7. The SNC approaches have lower variances between the cluster sizes which makes a f requency attack by Carol harder. As illustrated in the left plot, the SNC approaches generate nearly uniform distri-butions of clusters. The k -NN approach has a higher RR but lower PC, while a lower RR and higher PC are achieved with the HLSH approach. The SNC approach performs superior compared to the other two approaches by achieving higher results for both RR and PC. In this paper, we proposed an efficient private blocking technique that can be used to make privacy-preserving record linkage applications scalable to large databases. Our method is based on the sorted nearest neighborhood clustering approach, and uses a combination of the privacy techniques reference values and k -anonymous clustering. Experiments conducted on real-world large databases, each containing nearly 2 million records, validate that our approach is scalable and effective in generating candida te record pairs w hile preserving k -anonymity privacy characteristics. Our approach also outperforms two existing state-of-the-art private blocking techniques in terms of speed, efficiency, and effectiveness.
As discussed earlier, three-party solutions are often susceptible to collusion between parties. As future work, we aim to study how the sorted neighborhood clustering can be used for private blocking in a two-party context. Theoretically analyzing and modelling the privacy, complexity, and quality of our solution is another direction for future research.

