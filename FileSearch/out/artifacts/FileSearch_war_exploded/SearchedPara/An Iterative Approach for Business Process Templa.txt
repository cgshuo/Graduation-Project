 Recently, there has been a growing interest in compliance checking of business op-SOX [1]. The purpose of these initiatives is to enforce controls on the business opera-tions. Such controls relate to the execution order of business activities, the absence of activity execution in a dedicated data context, or restrictions on role resolution to realize separation of duty.

Driven by these trends, numerous approaches have been presented to address com-pliance management of business processes. In general, we can distinguish two types of approaches. First, compliance rules can guide the design of a business process [12,13]. These approaches ensure compliance by design by identifying compliance violations in the course of process model creation. Second, existing process models are verified against compliance rules [10,6]. Given compliance requirements and a process model as input, these approaches identify violations on the process model level.

Evidently, addressing compliance during t he design of business operations has many advantages. Non-compliant processing is prevented at an early stage of process im-plementation and costly post-implementation compliance verification along with root cause analysis of non-compliance is not needed. In most cases, process models that are synthesized from compliance rules cannot be directly used for implementing a business process. Instead, they should be seen as a blueprint that is used as a basis for negotiation between business and compliance experts. Hence, we refer to these process models as process templates in order to emphasize that further refinements are needed to actually implement the business process. While this approach has been advocated by other au-thors, e.g., [12,11,25], existing approaches are limited when it comes to data-dependent compliance requirements.

In this paper, we present an approach to the synthesis of compliant process templates that avoids some of the pitfalls of existing approaches. We start with a set of compli-ance rules specified in LTL. Hence, we do not require the definition of explicit points in time as in [12,11], but focus on relative execution order dependencies. Further, we also consider data flow dependencies between act ivity executions, which is neglected in [25]. These rules are then enriched with general constraints related to business process execu-tion to avoid phenomena such as vacuous satisfia bility. Subsequently, a process template is generated automatically if the compliance requirements are satisfiable. We also illus-trate how generated templates are applied during process design and how the template generation may identify inconsistencies and open questions. Hence, the template guides further refinements of the process model and the compliance requirements. To evaluate the applicability of our approach, we present a prototypical implementation. Our contri-bution is a complete approach to process design grounded in compliance rules.
Against this background, the remainder of this paper is structured as follows. The next section introduces preliminaries for our work, such as the applied formalism. Sec-tion 3 introduces our approach of synthesizing process templates from a given set of compliance rules. We also elaborate on how to use these templates as a basis for pro-cess design. A prototypical implementation o f our approach is presented in Section 4. Finally, we discuss related work in Section 5 and conclude in Section 6. This section gives preliminaries for our work. Section 2.1 clarifies our notion of exe-cution semantics. Section 2.2 presents LTL as the logic used in this paper. Section 2.3 summarizes existing work on generating a behavioral model from a given LTL formula. 2.1 Process Runs as Linear Sequences In this paper, we rely on trace semantics for process models. An execution sequence  X  of a process model is referred to as a process run or trace  X  a finite linear sequence of states  X  : s 0 ,s 1 ,...,s n with a start state s 0 andanendstate s n . Evidently, a process model as well as a set of compliance requi rements allow for many conforming traces. are the driving force of a trace and refer to the execution of business activities. This, in turn, may effect or be constrained by results, which relate to data values of the business The action that represents the execution of this activity may have the result of setting the state of the data object to  X  X igh X  or  X  X ow X . The execution of another activity, i.e., has been set to  X  X igh X , occurred. Both, actions and results, are represented by Boolean propositions at each state. For instance, proposition ra being  X  X rue X  at a state s i means that the action, i.e., execution of activity  X  X isk analysis X , has happened at state s i .In contrast, proposition ra being  X  X alse X  at state s i means that the action did not happen at is true in state s i ,for 0  X  i  X  n and p  X   X  if there is a state s i in  X  where p  X  s i ,for some 0  X  i  X  n .

We represent an execution sequence as a linear sequence of states where states are labelled with both actions and results, and (unl abelled) edges between states represent the temporal ordering in the sequence. Hence, we rely on Linear Temporal Logic (LTL) in order to formulate statements about traces. 2.2 Linear Temporal Logic Linear Temporal Logic (LTL) [20] is a logic specifically designed for expressing and reasoning about properties of linear sequences of states. The formulae of LTL are built from atomic propositions using the connectives of  X  (or),  X  (and),  X  (not) and  X  (im-plication), and the following temporal connectives: X (next), F (eventually), G (always), U (until) and B (before). The latter are interpreted as follows: X  X  : in the neX t state,  X  holds F  X  : there is some state either now or in the F uture where  X  holds G  X  : in every state G lobally from now on,  X  holds  X  U  X  : there is some state, either now or in the future, where  X  holds, and  X  holds in  X  B  X  : B efore  X  holds, if it ever does,  X  must hold.
 We apply LTL to encode compliance requirements. Hence, we obtain a set of formulae  X  expressing the constraints to which compliant traces have to conform. 2.3 Finding All LTL-Models of a Given LTL Formula Given a collection of compliance requirements expressed as a set  X  of LTL-formulae, we seek to find a behavioral model that captures all formula-models , i.e., traces in our setting, which satisfy  X  . That is, such a model describes all linear sequences of states s ,s 1 ,...,s n such that  X  is true at s 0 .Since  X  may contain eventualities ,suchas X  X   X  2 is true eventually at some state s i with 0 we are not given a single trace, but construct all traces satisfying the given constraints.
The first step is to determine whether the constraints are satisfiable. If not, the spec-ification is erroneous since no trace can conform to the given constraints. The second step is the creation of the behavioral model that describes all traces.

For both steps, we use a tableaux-based method introduced in [24,23]. In essence, this approach works as follows. We start by creating a root node containing  X  and proceed in two phases. First, a finite (cyclic) graph of tableau nodes is created by ap-plying tableau-expansion rules that capture the semantics of LTL and by pruning nodes containing local cont radictions [24]. Second, once the graph is complete a reachability algorithm is used to determine which nodes d o not satisfy their eventualities. These nodes are removed and the reachability algor ithm is reapplied until no nodes may be removed. The set of formulae  X  is satisfiable, if and only if the root node has not been removed [24]. Further, the graph created by the tableau algorithm, referred to as the pseudomodel , describes all possible formula-mode ls, i.e., possible traces [24]. We use this pseudomodel to extract possible t races during our synthesis approach. In this section, we describe our approach to the synthesis of process models from a set of compliance rules expressed in temporal logic. First, Section 3.1 gives an overview of the approach and introduces an example set of compliance rules used to illustrate all subsequent steps. Section 3.2 describes the LTL encoding of the compliance rules and additional domain knowledge. Section 3.3 el aborates on the extraction of traces from a behavioral model, while Section 3.4 focuses on consistency of these traces. Synthesis of a process template from these traces is disc ussed in Section 3.5. Finally, we elaborate on the evaluation of synthesized templates in Section 3.6. 3.1 Overview The process model in Fig. 1 visualizes the steps to synthesize a process template out of a set of compliance rules. First, a set of c ompliance rules is collected. In order to identify whether these requirements are c onsistent and thus a process template can be synthesized, related domain-specific knowl edge is identified. In Section 3.2 we give details on the LTL encoding of both compliance rules and domain knowledge.

For the conjunction of these LTL formulae, we verify satisfiability as it has been summarized in Section 2.3. If the set is not satisfiable then no trace can be constructed to satisfy the given LTL formulae so the inconsistency is reported to the user. If the set is satisfiable then the satisfiability check er automatically returns the pseudomodel which is a behavioral model of all traces that obey the given constraints.

As a next step, finite traces are extracted from the pseudomodel by following all choice points and stopping when a trace becomes cyclic. We focus on this step in Sec-tion 3.3. Having a finite set of t races that satisfy the complia nce rules, we check it for consistency. This check guarantees that a tem plate can be generated. Inconsistent traces hint at issues in the specification, so that a new iteration of the synthesis may be started with refined compliance rules or adapted domain knowledge. We focus on the analysis of traces in Section 3.4. If the traces are cons istent, we apply a process synthesis algo-rithm to extract a process template. Details on this step are given in Section 3.5. The synthesized template is then analyzed to iden tify discrepancies th at stem, e.g., from un-derspecification. Depending on the result of this analysis, again, a new iteration of the synthesis may be started. We discuss the evaluation of process templates in Section 3.6. Example. We illustrate our approach with an example from the financial domain. Anti money laundering guidelines [8] address fina ncial institutes, e.g., banks, and define a set of checks to prevent money transfers with the purpose of financing criminal actions. We focus on the following guidelines for opening new bank accounts: R 1 : A risk assessment has to be conducted for each  X  X pen account X  request. R 2 : A due diligence evaluation has to be conducted for each  X  X pen account X  request. R 3 : Before opening an account the risk associ ated with that account must be low. Oth-R 4 : If due diligence evaluation fails, the client has to be added to the bank X  X  black list. 3.2 LTL Encoding Once the compliance rules have been collected, a behavioral model that represents all traces conforming to these rules is created. I n order to arrive at such a model, we need to collect extra domain-specific rules. Much of the domain-specific rules can be generated automatically from a higher level descripti on. Such a description needs to be defined by a human expert in the first place and comprises the following information.
 Actions and Goals. The set of all actions is denoted by A .Thesetof goal actions Results and Initial Values. The set of all results is denoted by R . The initial values Relation between Actions and Results. The mapping from actions to sets of results is Based on this information and two additional actions start and end that represent the initial and final states of a trace (independent of any goal states), we derive LTL rules to represent the domain knowle dge according to Table 1. Common process de-scription languages, e.g., BPMN or EPCs, assume interleaving semantics, which is enforced by formula interleaving and progress . The information on exclusiveness constraints and on contradicting actions and results yields the formulae mutex and contra . The formula causality guarantees correct implementation of dependencies be-tween actions and results. Finally, the formulae once , final , goals ,and initial ensure correct initialization and successful termin ation of any trace. The combination of all these formulae yields the formula domain , which represents the domain knowledge. domain = start  X  G initial  X  F goals  X  F end  X  G interleave  X  G progress Example. For our example, an expert first identifi es the following actions and results. Actions = { ra, edd, og, od, bl } Results = { ri, rh, rl, ei, ef ,ep } ra : conduct a risk assessment ri : risk assessment is initial edd : evaluate due-diligence rh : risk was assessed as high og : grant a request to open an account rl : risk was assessed as low od : deny a request to open an account ei : due-diligence evaluation is initial bl : blacklist a client. ef : due-diligence evaluation failed Note that the results are all descriptive statements, while the actions refer to activities. Moreover, we introduce positive representations for the states  X  X igh X  and  X  X ow X  of the risk object, even though both states are opposed. That is due to the three possible states of the risk object: high, low, or initial. The same holds true for the the due-diligence object.

Based on these actions and results, the compliance rules are encoded in LTL. As receiving such a request. Therefore, rules 1 and 2 are interpreted as  X  X  risk assessment has to be conducted X  and  X  X  due diligence eval uation has to be conducted X , respectively. The third rule is interpreted to mean that the risk associated with opening an account must be low at the time the request is granted , rather than at some point in the past. Similarly is the case when denying the open request, the risk has to be high. R 1 : A risk assessment has to be conducted.
 R 2 : A due diligence evaluation has to be conducted.
 R 3 : The risk associated with opening an account must be low when the request is R 4 : If due diligence evaluation fails, the client has to be added to the bank X  X  black list. As a next step, the domain knowledge is defined in more detail. For instance, the action mapping defines ra  X  X  rh, rl } and ra  X  X  X  ri } . The former says that action ra causes the risk object to take a concrete value of  X  X igh X  or  X  X ow X . The latter means that ra causes the risk to stop being  X  X nitial X  by forcing ri to not hold. Excluding results are defined, e.g., { ri, rl, rh } states that at most one of the propositions ri, rh, rl can values { ri, ei } signifies that initially, both risk and due-diligence objects, are put to an initial, unknown, value. There are also contradicting actions, { og  X  X  od } ,od  X  { og }} , ensuring that we cannot grant and deny a request within the same trace. Based on Table 1, this specification is converted into LTL. For example, this yields the formula progress = ra  X  edd  X  og  X  od  X  bl  X  start  X  end . The final set of LTL formulae is the union of the domain formula with all four formulae representing the compliance rules. 3.3 Extracting Traces Given a set of LTL formulae, we apply the technique summarized in Section 2.3 to determine whether the constraints are satisfiable. If so, we obtain a pseudomodel that describes all traces that conform to the set o f formulae. To create a process template, these traces are extracted. Any sequence  X  = s 0 ,...,s n of states, starting at the root node of the pseudomodel can be extended into a trace. As we are modeling finite se-quences with an end state, we consider a trace to be complete if end  X  s n . Because of the once constraint introduced in the previous section, there will be no loops in the pseu-domodel between the start and the end. Hence, the finite set of paths in the pseudomodel between the root state and a state labeled with end is the set of correct traces.
Note that it is possible to extract traces th at take repetition of activities into account by omitting the once constraint in the domain knowledge. Still, for our purpose, this does not seem to be appropriate. Compliance rules rarely forbid the repetition of activity execution, so that modeling all potential loops blurs up the structure of a generated process template. As this hinders discussions between business and compliance experts, we neglect potential repetition for our synthesis approach.
 Example. Some of the traces extracted from the pseudomodel of our running example are illustrated in Table 2. Here, the states of a trace are characterized by the conjunction of propositions that hold true in the respective state. 3.4 Analysis of Extracted Traces As stated earlier, the goal of synthesizing a process template out of compliance rules is to support experts in getting a better unders tanding of the compliance aspects and to discover missing or under-specified requirements. However, it is possible to detect such under-specification by analysis of extracted traces before proceeding to synthesizing a process template. Yet, not every semantical error in the specification can be detected, so that a human expert has to validate the synthesized process template. We address the issue of under-specified LTL specification by correctness criteria for the extracted traces.

Let P be a set of traces derived from a pseudomodel, cf., Section 3.3. We leverage the information whether an action a  X  A is optional for completing the process. Definition 1 (Optional Actions). Given a set of actions A and a set of traces P ,the set A O of optional actions is defined as A O = { a  X  A :  X   X   X  X  .a  X   X  } . We argue that correctness of a specificatio n where some activity is optional implies the existence of a specific data condition under which the optional activity is executed. For the traces in Table 2, for instance, og and od are optional activities. The condition under which og executes is ( rl  X  ef )  X  ( rl  X  ep )  X  ( rl  X  ei ) , i.e., the risk object assumes the state  X  X ow X . Action og is executed independently from the state of the due diligence none of the objects influences the decision of executing bl ,since bl appears with all combinations of data values. Yet, bl is optional. This indicates an under-specified LTL specification as conditions for executing optional activities are not stated explicitly. Definition 2 (Optional Action Execution Condition). Let A O be the set of optional actions, P a set of traces, and RE the set of mutually exclusive results. For an action a  X  A cond a = {{ x 1 ,...,x n } :  X   X   X  X  .  X  s  X   X .a  X  s  X  x 1  X  s  X  x 1  X  S 1  X  S 1  X  RE  X  X  X  X  X  x n  X  s  X  x n  X  S n  X  S n  X  RE  X  n = | RE |} .
 This definition describ es the conditions under which an actio n executes by investigating as a . If an optional activity a has an execution condition, which is a proper subset of the combination of non-exclusive results, then this indicates a well specified set of compliance rules. We formalize this tr ace correctness criterion as follows. Definition 3 (Proper Execution of Optional Actions). Let A O be the set of optional actions with respect to a set of traces P and RE the set of mutually exclusive results. We define the set of all possible results interactions as RI = {{ x 1 ,...,x n } : x 1  X  S proper execution iff cond a  X  RI .
 The proper execution of actions is the first correctness criterion to be investigated on traces before synthesizing a template. Re ferring to the set of traces in Table 2, we find that this criterion is not met for activity bl . This problem is reported to the user so that the compliance rules are refined and a new set of traces is extracted.
 Another correctness criterion for a set of traces is data-completeness . A set of traces P is data-complete if for every possible combination of results resulting from the mandatory activities, there is a trace in which this combination occurs.
 Definition 4 (Traces Data-Completeness). Let P be a set of traces, AM be the set of action mappings, A M = A \ A O be the set of mandatory actions and RE M = {
S :  X  a  X  A M . ( a, S )  X  AM  X  S =  X  X  be the set of mutually exclusive results of mandatory actions. We define the set CO = {{ x 1 ,...,x n } : x 1  X  S 1  X  S 1  X  RE M  X  X  X  X  X  x n  X  S n  X  S n  X  RE M  X  n = | RE M |} .Thesetoftraces P is data-complete iff  X  C  X  CO  X   X   X  X  X  s i  X   X  :  X  x  X  Cx  X  s i where i&gt; 0 .
 Even if data incompleteness is detected fo r a set of traces, a process template may be generated. Nevertheless, the template would suffer from deadlocks as for some com-binations of results, continuation of proce ssing is not defined. Therefore, we proceed solely in case the set of traces shows data completeness.
 Example. For our running example, we find that the set of traces lacks the proper exe-cution condition for activity bl . To address this issue, a compliance expert might add an an additional constraint G ( bl  X  ef ) . Repeating all steps from satisfiability checking 3.5 Generating Process Templates Given a set of traces within which activ ities have proper execution conditions, process mining [4] is applied to generate a process tem plate. Most mining algorithms neglect the difference between control flow depe ndencies and data flow dependencies when generating a process model. Therefore, we cannot apply an existing algorithm directly. Instead, we use the  X  -algorithm [4] and incorporate the respective data aspects. Order of actions. As a first step, we extract the precedence of actions. To this end, we employ an adapted version of the order relations known from the  X  -algorithm [4]. Definition 5 (Order Relations). Let P be a set of traces and A the sets of actions. We define the following order relations for two actions a 1 ,a 2  X  A with R a 2 = ( a as the set of results of a 2 . a 1 &gt;a 2 : iff either a 1 a 2 : iff a 1 &gt;a 2 and a 2 &gt;a 1 a For two actions ordered by &gt; , we know that the first action appears immediately before the second action. This notion of order is stronger than the one originally used in the a 1 a 2 . However, it might be the case that a 1 a 2 , a 2 a 3 and a 1 a 3 .Inthis case, we drop the dependency a 1 a 3 as it unnecessarily comp licates the template synthesis. Thus, we use the more strict precedence relation  X  .

In contrast to common order relations known in process mining, the precedence de-pendencies in our approach may be guard ed by conditions, captured as follows. Definition 6 (Precedence Condition). Let P be a set of traces, A the sets of actions, AM the mapping from actions to results, and a 1 ,a 2  X  A two actions in precedence, a s  X  r  X  s we define the precedence condition cond ( a 1 ,a 2 ) as follows. According to this definition, we distinguish two types of precedence conditions. First, precedence holds for a proper subset of the res ults of the first action. Then, the prece-dence condition is the disjunction of results that can be caused by the first action. The second case captures unconditioned preceden ce, i.e., the precedence holds independent of any results. For our running example, we observe ra  X  og . This precedence is guarded, as we observe this dependency solely in case of the result rl .Inotherwords, only if action ra yields the result rl , we observe the action og subsequently. Synthesis of process model. Based on the precedence among activities, the precedence conditions, along with the knowledge on optionality of activities, we proceed to build a process template. First, the overall stru cture of a process model is derived from the precedence relation. This step yields a graph with all nodes representing actions, while the precedence relation defines directed e dges between them. Second, control nodes (split and join nodes) that realize the behavior routing in the process model have to be introduced whenever a node has more than one predecessor or successor.
 Starting with split nodes, our approach inserts nodes that implement either AND-, XOR-, or OR-logic. The routing semantics d epends on the precedence conditions for the edges to succeeding nodes. If all preceden ces originating at an action are uncondi-tioned, an AND-split node is inserted. If all precedences are conditioned and those con-ditions do not overlap, an XOR-split node is inserted and each outgoing edge inherits the respective precedence c ondition. Similarly, an OR-split is applied if the conditions are overlapping.

The case of join nodes, nodes with multiple predecessors, is not straightforward. We distinguish the following cases.  X  All precedences of an action a are conditioned, we use an AND-join to synchronize  X  Only a proper subset of precedences of an action a is conditioned, we use an OR- X  All precedences of an action a are unconditioned. If a is mandatory, we apply either Applying these steps yields a process template. Still, our approach to model synthesis is rather naive and may create OR-joins for which the synchronization behavior could be implemented using solely AND-and XOR-joins. However, existing methods for restructuring a process model are used to replace these OR-joins with a semantically corresponding structure of AND-and XOR-joins, see [22]. Example. After we adapted the set of constraints for our running example as discussed above, we derive the basic graph structure for the template based on the precedence relation. Fig. 2 visual-izes this structure in a BPMN-like notation. Here, the start and end actions are represented by start and end events. Activities depicted with a dashed border are optional. After inserting control nodes (aka gateways in BPMN) into the graph, the com-plete process template is derived. The first ver-sion of the generated process template is shown in Fig. 3a. Application of the restruc-turing according to [22] yields the process template shown in Fig. 3b.
 3.6 Evaluation of the Synthesized Process Template Process templates aim at supporting experts i n getting a better understanding of the com-pliance aspects and to discover missing or under-specified requirements. Such under-specification is manifested in the process t emplate in terms of semantical problems. Those problems can only be detected by human experts. In this section, we will fur-ther elaborate on the running example to illu strate such problems. Using the process template in Fig. 3a as a basis of the discussion between compliance expert and busi-ness expert, they identify that the template allows for executing both black listing the client and granting to open the account in the same instance. This is an example of the aforementioned semantical problems caused by under-specified compliance rules. The compliance expert refines the set of constraints by indicating that black listing and grant-ing open the account are contradicting, cf. the CA relation in Section 3.2, formalized as G ( og  X  G (  X  bl )) and G ( bl  X  G (  X  og )) . Repeating the steps of our approach reveals that the adapted set of compliance r ules yields a set of traces that is data incom-plete. This is explained based on the two added constraints as follows. By forcing bl and og to be exclusive, we implicitly require bl to be executed only with the condition ef  X  rh , while og is executed only with the condition ep  X  rl . Other combinations of results are not considered. There is no trace that addresses the situation where ef  X  rl holds in some state. This contradicts with our requirement to execute either og or od in each run. Since the condition ef  X  rl enables neither of them, it is not observed in any of the generated traces.
As a consequence, another adap-tation of our set of compliance requirements is needed. The missing interaction ef  X  rl has to be handled.
 One solution is to update the condi-tions under which og and od are ex-ecuted, i.e., G ( og  X  ep  X  rl ) and G ( od  X  ( ef  X  rh )) . With these updated constraints, another iteration of behavior synthesis is started. This time, the generated set of traces shows data completeness. The final gener-ated process template is visualized in Fig. 4. We created a prototypical impl ementation to validate our a pproach. Fig. 5 shows a snap-shot of it. It relies on a specification of domain knowledge, such as activity results and contradicting activities, which has to be defined once by a human expert. Given a set of compliance rules, our implementation adds extra rules to control the behavior synthesis and to enforce domain knowledge automati cally. The satisfiability checking is done by an implementation of Wolper X  X  method for checking LTL satisfiability [24] developed by the authors at the School of Computer Science of the Australian National Univer-sity 1 . If the rules are satisfiable, the checker generates the pseudomodel of all possible traces. Next, our implementation extracts fi nite traces, analyzes them and synthesizes the process template, if the extracted traces pass quality tests, cf. Section 3.4. At that point, the resulting template is visualized using GraphViz [9]. In case that traces do not pass checks, the found problems are reported on the  X  X nalysis result X  tab.
 constraints of the process are unrestricted logical formulae. Even without pathological constraints, if there is a lot of freedom or non-local conditions then the satisfiability checking phase can take a considerable amount of time. The once constraint helps limit this, and too much freedom can often be a sign that other conditions have been omitted. We aim evaluating these issues in further case studies.
 Compliance checking of business process models with a focus on execution order con-straints has been approached from two angl es: namely compliance by design and com-pliance checking of existing models. The latter has been tackled using model checking techniques [6,10,14]. Our work follows a compliance by design approach that has also been advocated in [11,12,13,15,16,25]. Close to our work, the authors of [12,11] em-ploy temporal deontic assignments to specify what can or must be done at a certain point in time and synthesize a process template from these assignments. In contrast to our work, however, the approach is limited to temporal dependencies between activity executions and the underlying logic require s an encoding of these dependencies via explicit points in time. Another approach to synthesize compliant processes was intro-duced in [25]. The authors employ a set of compliance patterns expressed in Linear Temporal Logic (LTL). For each pattern a fin ite state automaton (FSA) is defined. To synthesize a process, the FSAs of the involved patterns are composed. Next, the user is required to select for each composition an execution path in order to synthesize the process. That approach is able to genera te processes with sequence and choice only. Moreover, it does not consider data flow aspects in the synthesized process.
Related to our approach to process model synthesis is work on process mining, which aims at automatic construction of a process model from a set of logs [5,4,3]. We adapted the  X  -algorithm [4], a standard mining approach, for our purposes. Besides the com-monalities, there are some important differences between process mining and process template synthesis. We consider control flow routing based on data values. This aspect is often neglect in process mining algorith ms. Only recently, time information and data context have been considered when predic ting the continuation of a trace based on its current state [21,2]. Further, process mining approaches have to be robust against incor-rect data (log noise). As we derive a model fro m artificially generated traces, this is not an issue for our approach.

Work on declarative business process mode ling is also related to our work. The au-thors of [17,19] propose to model processes by specifying a set of execution ordering which are used to generate an automaton that is used to both guide the execution and monitor it. That is similar to our appro ach of generating a pseudomodel. Recently, the authors also showed how finite traces that re spect interleaving semantics can be ex-that [18] does not model data constraints as we do. They also change the semantics of LTL rather than by using standard LTL as we do. Finally, we initially tried the ap-proach of extracting B  X  uchi automata from our LTL specifications for our example, but found that the automata approach required hours to return the automata whereas our LTL satisfiability checker returns a pseudomodel in less than a second. In this paper, we introduced an approach to synthesize business process templates out of a set of compliance rules expressed in LTL. We also showed that extra domain-specific knowledge is required to decide about consis tency of such requirements and introduced an LTL encoding for compliance rules and domain knowledge. This was used to gener-ated traces, which are analyzed for inconsistencies. Finally, we proposed an approach to the synthesis of process templates that goes beyond existing work on process mining by focusing on data dependencies of activity execution. We also discussed the analysis of generated templates with respect to semantical errors.

In our approach, we addressed control-and data-flow aspects of compliance rules, in contrast to similar approaches that focus o n control-flow aspects only. The considera-tion of data-flow aspects comes with new challenges which we addressed in this paper by introducing correctness criteria for the set of generated traces. We illustrate that data dependencies may show rather interactions that are hard to handle at the first place. As a consequence, our approach is iterative  X  the required knowledge is built incremen-tally each time constraints are under-specified. In future work, we want to consider constraints on role resolution for generating process templates.

