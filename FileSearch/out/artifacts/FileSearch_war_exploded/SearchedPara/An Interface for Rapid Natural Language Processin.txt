 In the days when public libraries were the center of information exchange , the job of the librarian was to serv e as an interface between the complex l i-brary system and the average user. The librarian made it poss i ble for one to access specific sources of info r mation wit h out memorizing the Dewey Decimal System or flipping through the card cat a-log . Ana l ogous to the great librarians of yesteryear, the A n notation L i brarian serves the average Jav a developer in the creation and management of ann o-tations within natural language processing (NLP) projects built using the open source Apache U n-structured Info r mation Management Architecture 
Many NLP tasks are performed in processing steps that build upon one another. Systems d e-signed in this fashion are called pipelines because text is processed and then passed from one step to the next li ke water flowing through a pipe. Each step in the pipeline adds structured data on top of the text called an notations . An annotation can be as simple as a classification of a span of text or complex with attributes and mapp ings to coded values. As pipeline systems have caught on, the ability to standardize functionality in and even across pipelines has emerged. UIMA provides a powerful infrastructure for the storage, transport, and retrieval of document and annotation knowledge accumulated in NLP pipeline systems (Ferrucci 2004). UIMA provides tools that allow testing and visualizing system results, integration w ith Eclipse 2 , and use of standard XML descri p-tion files for maintainability and interoperability. Because UIMA provides the underlying data mo d-el for storing meta -data and annotations with do c-ument text and the interface for interacting between processing steps, it has become a popular platform for the development of reusable NLP sy s-tems ( D X  X volio 2010, Coden 2009, Sav o va 2008 ). The most notable example of UIMA c a pabilities is Watson, the question -answering system that co m-peted and won two Jeopardy! matches aga inst the all -time -winning human champions (Ferrucci 2010). In addition to its successful implementations in NLP , UIMA supports all types of unstructured i n-formation  X  video, audio, images, etc  X  and so all UIMA constructs generalize beyond text. While handling multiple data types increases the utility of the framework, developers new to UIMA may feel they need to understand the entire framework b e-fore being able to distinguish and focus solely on text. The Annotation Librarian aids both no v ice and expe rienced UIMA developers by pro viding intuitive and NLP -centric functionality. The Annotation Librarian was developed as an i n-terface that synthesizes many of the most frequent annotation management tasks encountered in NLP system developmen t and presents them in a ma n-ner easily accessed for those familiar with general Java development methods. It provides conve n-ience methods that mirror Java String manipul a-tion, allowing developers to sea m lessly combine document text and annotation s with the same commands familiar to anyone who has parsed a S tring or written a regular expressi on. Advanced functionality allows developers to examine spatial relationships among annotations and perform a n-n o tation pattern matching. In this demonstration, we presen t the general functionality of the Annot a-tion Librarian in the context of the health care r e-search projects that necessitat ed the creation of the interface.

The interface does not replace the need for NLP algorithms  X  developers have a plethora of patterns and decision rules, symbolic grammars, and m a-chine learning techniqu es to create annotations. The Annotation Toolkit, though, provides a co n-venient way for developers to use existing annot a-tions in their algorithms. This feeds the pipeline workflow that a llows more complex annotations to be built in later processing steps using the annot a-tions created in earlier steps.

The Annotation Librarian was developed and modified in response to four research projects in the health care domain that relied on NLP extr a c-tion of concepts from clinical text. The diversity of the different tasks in each of these use cases a l-lowed the interface to include functionality co m-mon to different types of NLP system development. Interface functionality will be d e-scribed as groups o f related methods in the context of the four research projects and cover pattern matching, span overlap, relative position, annot a-tion modification, and retrieval. All projects r e-ceived Institutional Review Board approval for data use and only synth etic do cuments, no t real patient records, are shown in the examples presen t-ed in this paper . Name entity recognition and semantic classific a-tion tasks often require advanced concept identif i-cation techniques. I dentifying mentions of pr e-scriptions in a document using regular expre s sions, for example, would require hundreds of thousands of patterns for names of medicines and have to a c-count for misspelling, abbreviations, and acr o-nyms. Re g ular expressions are commonly used to solve simple NLP tasks , though, and can be ut i-lized as part of a more complex information extra c-tion strategy , such as understanding the context in which a term is used in the text ( Garvin 2011, McCrae 2008 , Frenz 2007, Chapman 2001 ) . Negex (Chapman 2001) is an alg o rithm for ide ntifying words before or after a term that suggest , for e x-ample, that a particular symptom is not present in a patient:  X  X he patient has no fever. X  Other met h ods for understanding the context around terms i n clude the use of an inclusion and exclusion list (Akbar 2009) , temporal locality search ( Grouin 2009 ) , window search (Li 2009), and combination s of the above techniques (Hamon 2009).
 built using existing annotations along with doc u-ment text. This functionali ty combines the power of finding concepts that require complex means with the simplicity of regular expressions. The sy n-tax mirrors that of the Java Pattern 3 and Matcher classes, but allows for an extended regular expre s-sion gramma r to identify Annotation s. Pattern matching is accomplished in three phases: the i n-put pattern is compiled, the document and annot a-tions are analyzed for matches, and matches are returned along with span information.
 tures will illus trate the use of pattern matching with the Annotation Librarian. Clinicians order microbiology cultures to determine whether a p a-tient has a bacterial infection and which antibiotics would be most effective at treating the infe c tion. Susceptibility is the measure of whether an antib i-otic can effectively treat an organism or whether the organism is resistant to it.
 in Figure 1 and visua l ized annotations for the same sample are shown in Fi g ure 2. the simple pattern of a d rug annotation followed by an equals sign and then by a susceptibility a n not a-tion will be used. 3 .1 Pattern Compilation The patter n matching process begins when a new instance of an AnnotationPattern is created from the static compile method . AnnotationPattern is analogous to the Java Pattern 3 class.

The method takes advantage of the UIMA i m-plementation of annotations. Each annotation is an instance of a class that inherits from the UIMA class Annotation 5 . UIMA allows developers to cr e-ate new types of annotations ( in this example O r-ganism, Antibiotic, and Susceptibility) that become Java classes. The compile method input string pattern uses XML tags to repr e sent Annotation classes and tag attributes to denote the name of method calls and return values in the format of :
When the extra constraint of matching on some method return values is not needed, the tag attri b-ute is left blank. Portions of the pattern that are not contained in XML tags are compiled as Java reg u-lar expressions. For our example, the in put pattern would be : or further constrained as : which would only match if the particular medic a-tion ( ciprofloxacin ) and susceptibility ( S ) matched as well.

The pattern is converted into a finite state m a-chine (F SM ) in a process d e scribed by Fegaras (2005). With our pattern, a four -state FSM would be generated. To arrive in S tate 1 , an Antib i otic annota tion must match . To arrive in State 2 , a reg u lar expression for  X  =  X  must match . The F inal S tate is reached when a match ing Susceptibility annotation is found . Any other input would result in a transition back to the S tart S tate.
 3 .2 Match Analysi s The second phase of pattern matching processes the document text and annotation set to determine if any matches can be found. This phase is tri g-gered by a call to the static matcher method that returns a new i n stance of an AnnotationMatcher object . Annot ationMatcher is analogous to the Java Matcher 4 class.

This phase just checks to ensure that each ann o-tation type has at least one instance in the doc u-ment. Otherwise, a pattern match is not possible. Here , the cas parameter refers to the UIMA Common Analysis Structure, the object containing the do c ument and annotation information. 3 .3 Finding Matches The final phase of pattern matching involves a call to the AnnotationMatcher find meth od . This call results i n a FSM t raversal at the starting position parameter. D upl i cate match candidates starting at the same point are pooled in each state . The cand i-date pool in each st ate is traversed with a binary s earch alg o rithm, which reduces overall traversal time. Note the following example in which a rel a-tionship is created through a new user -defined A n-notation class type . 
Similar to the Java Matche r 4 find method , the first match is found from the starting posi tion . The start and end positions are also set wit h in the A n-notationMatcher instance object , which facilitates the creation of new annotations that span the co m-plete pattern . The Annotation Librarian pattern matching fun c tionality allows the inclusi on of a n-notation s , which provides an added level of power beyond regular expressions on text data o n ly. The r etrieval methods allow developers to interact with annotations and metadata. This set of methods includes the ability to get the file nam e and path of the doc ument, get all annotations in the doc u ment, and get all annotations of just a partic u lar type. The a nnotation m odification methods allow prev i-ous annotations to be altered by trimming whitespace and removing punctuation. W hile these are trivial tasks performed on Java Strings, an a n-notation is just a pointer to the text. U pdating the annotation with the correct character span r e quires understanding of UIMA functions and can intr o-duce errors if not done carefully . The Annot a tion Librarian ensures accuracy by handl ing these tasks with straightforward programmatic calls .
Identifying the organism s from the microbiol o-gy reports relied on splitting template text. Th e project described in Section 3 for pattern matching utilized the Annotation Librarian fun c tionality to clean up spurious characters and whitespace i n-cluded in annotations . Th is set of methods describes how annotations r e-late to each other spatially by a n swering questions such as: Does one annotation completely contain the other? Do the annotations ove r lap in the text? D o they both cover the same span of text ?
In a system built for identifying medication s in discharge summaries, the brand and generic names would often both be listed . Name entity recogn i-tion would end up mapping at multiple granular i-ties  X  b rand name only, generic name o n ly, brand and generic name combinations, and even name and dose co m bina tions. The s pan o verlap methods were used to identify and combine overlapping names. Figure 5 shows the annotations that were found and r e solved using s pa n o verlaps. The r elative p osition methods allow developers to access annotations based on their pos i tion in the text to each other. These methods can determine the next or previous adjacent anno tation or the text that exists between two annotations. Often, a task r e quired determining which concepts were found in the same sentence or finding all concepts in a certain section. Methods in this set provide fun c-tionality to find annotations that cover ing the span of another annotation s or all annotations co n tained within the span of an other annotation . T he Annotation Librarian was developed and mo d-ified over a number of different NLP use ca s es. Because of the diversity of tasks in each of th e se use cases, the toolkit includes functionality co m-mon to various types of NLP system develo p ment. It includes over two -dozen functions that were used more than one hundred times in each of the four systems listed above. Use of this interface r e-duced the amount of repeated code; it simplified common tasks, and provided an int u i tive interface for NLP -centric annotation ma n agement without requiring the presence of an NLP developer who has in timate knowledge of the UIMA data stru c-ture. The extended capability provided by the p a t-tern m atching methods a l lows system developers to ca pitalize on the pipeline approach to NLP d e-velopment in dete r mining patterns. The ability to use annotations along with text significantly i n-creases the types of patterns that can be ide n tified without complex regular expressions . The Annotati on Librarian has been enhanced over the course of a num ber of biomedical NLP use cases and we plan to continue to enhance the inte r-face as new use cases arise. Some planned e n-hancements include performance improvements and expanding the AnnotationPattern i nput pattern syntax to include regular expressions for method return values and a nnotation c lass names . We plan to provide additional functionali ty such as pattern fr e quency counts .

We see the ability for the Annotation Librarian to help identify patterns through active learning or unsup ervised techniques. In this way, relationships between annotations could be inferred based on those existing in the document set. Such functio n-ality would also provide the ability for more inte l-ligent analysis of future docu ment sets or observation systems by allowing previously ident i-fied relationships to be utilized in other use cases. This work was supported using resources and faci l-ities at the VA Salt Lake City Health Care System with funding support from the VA Informatics and Computing Infrastructure (VINCI), VA HSR HIR 08 -204 and the Consortium for Healthcare Info r-matics Research ( CHIR), VA HSR HIR 08 -374. Views expressed are those of the authors and not necessarily those of the Department of Veterans Affairs.

