 We present a unifying view of temporal concepts and data models in order to categorize existing approaches for un-supervised pattern mining from symbolic temporal data. In particular we distinguish time point-based methods and interval-based methods as well as univariate and multivari -ate methods. The mining paradigms and the robustness of many proposed approaches are compared to aid the selec-tion of the appropriate method for a given problem. For time points, sequential pattern mining algorithms can be used to express equality and order of time points with gaps in multivariate data. For univariate data and limited gaps suffix tree methods are more efficient. Recently, efficient algorithms have been proposed to mine the more general concept of partial order from time points. For time interval data with precise start and end points the relations of Allen can be used to formulate patterns. The recently proposed Time Series Knowledge Representation is more robust on noisy data and offers an alternative semantic that avoids ambiguity and is more expressive. For both pattern lan-guages efficient mining algorithms have been proposed. Multivariate time series and other time related data oc-cur in many areas and mining this data poses interesting challenges. There are many different approaches for tem-poral pattern mining based on various data models. They are usually designed with a particular application in mind. Many terms are used in different publications with very dif-ferent meanings, e.g., events [69; 40; 56; 99] or episodes [69; 22; 49]. We present a unifying view on the temporal concepts that can be discovered by a certain method and a common language for the underlying data models. Existing approaches for unsupervised pattern mining from symbolic temporal data are categorized accordingly.
 On a coarse level we distinguish between time point-based methods and interval-based methods. Another important feature is the applicability to univariate or multivariate data. We further discuss the temporal concepts a pattern lan-guage can express, the robustness to noise, and the mining paradigm used. The goal is to give researchers a guideline to select the appropriate method for their purpose. If a certai n pattern language is more flexible than necessary the mining will be more costly. If the given data is noisy one needs to be aware of the influence on the resulting patterns. We define common temporal data models in Section 2 and temporal concepts within these models in Section 3 to pro-vide a common language for the later sections. Section 4 lists temporal operators that have been used in temporal data mining to express the different concepts. The relations of the data models with the most important temporal con-cepts and operators are shown in Figure 1 for time point and Figure 2 for time interval data respectively. Figure 1: Temporal concepts and operators for time point data models.
 Figure 2: Temporal concepts and operators for time interval data models.
 In Section 5 we review methods for unsupervised mining of frequent patterns that relate time point-based properties of a temporal process. Patterns from time interval data are compared in Section 6. The approaches are discussed in Section 7 and Section 8 lists related work. In Section 9 we conclude this survey with some implications for possible future research. This section introduces temporal data models and temporal concepts that are building blocks of many temporal data mining methods. See [74; 77] for formal definitions. Usually temporal data is represented based on observations at discrete time instants. Often, time is uniformly sampled . If not, there is usually some lower bound for the granularity of time. We refer to this finest level of temporal detail as ordering is given, the order can be mapped to integer values. A time series is a set of unique time points. A time sequence is a multiset of time points, i.e., it can include duplicates . A pair of time points defines a time interval starting at the earlier point and ending at the later point inclusively. Two intervals overlap if there is at least one time point that lie s within both intervals. An interval series is a set of non-overlapping time intervals. In a contiguous interval series no gaps between two consecutive intervals are allowed. An interval sequence can include overlapping and even equal time intervals. The series data types can be univariate , i.e., consisting of a single series or multivariate where several series cover the same but not necessarily equally sampled time range.
 A numeric time series is a time series with numerical values for each time point. This is the data model commonly used in statistics, see Figure 3(a) for an example. A numeric time sequence , i.e., a time sequence with numerical values per point, is rarely used. A symbolic time series is a time series with nominal values for each point (see Figure 3(b)). It can be obtained from numeric time series by discretizatio n (e.g. [62]). A symbolic time sequence has nominal values with possible duplicate time points (see Figure 3(c)). The symbols A -D are observed at certain time points and two or more symbols can be observed at the same time. A typical example are status events in network monitoring [68]. A numeric interval series is a series of non-overlapping time intervals with numerical values for each interval, a symbolic interval series has nominal values, respectively. A multi-variate symbolic interval sequence is shown in Figure 3(d). The symbols A -C are observed during certain time intervals. These data models are commonly obtained from univariate or multivariate numeric time series by segmentation (e.g. [57]) and feature extraction (e.g. [51]). Numeric interval data models can be used to mine quantitative association rules, e.g., for stock prices [60].
 An itemset sequence is a time sequence where an itemset is assigned to each time point. An itemset is a subset of a set of symbols. This data model is used in sequential association rule mining [2], see Figure 3(e) for an example. Univariate symbolic time series and symbolic time sequence s are special cases of itemset sequences with itemsets of size one. Multivariate symbolic time series are itemset sequenc es with itemsets of size equal to the dimensionality of the time series.
 For each data model there can be a single long series or se-quence or a database of (short) series or sequences, e.g., se ts of numeric time series [29] or more typically sets of itemset databases [16] sequences. A set of short sequences or series can be obtained from a longer one with a sliding window. With overlapping windows this can cause redundancy because many fragments of a frequent patterns will be observed. This can be avoided by restricting patterns such that they start at the first time point in the window [20].
 The concept of duration is the persistence or repetition of a property over several time points. Duration is what distinguishes time point from time interval data models. Time points express instantaneous information, e.g., ligh t-ning during a thunderstorm. According to the time reso-lution of our visual perception lightning is perceived as an instantaneous event without duration. The following thun-der, however, usually lasts for a few seconds and can thus be described by an interval and has a duration.
 The concept of order is the sequential occurrence of time points or time intervals. Lightning is always followed by a thunder in a storm.
 The concept of concurrency is the closeness of two or more temporal events in time in no particular order. In a heavy thunderstorm lightning and gusts of wind occur concur-rently, but there is no typical order relation between these events. Concurrency is often used for time points, especial ly for the data model of time sequences where the exact local order of time points is not necessarily meaningful. With intervals it correspond to the occurrence of two or more in-tervals within a larger sliding window and no further con-straints on their relative position.
 The concept of coincidence describes the intersection of sev-eral intervals. If rain coincides with sunshine, there will of-ten be a rainbow visible. Both rain and sunshine could have started earlier or lasted longer, but only when they coincid e the rainbow is visible.
 The concept of synchronicity is the synchronous occurrence of two temporal events, i.e., equality of time points or time intervals. The flash of lightning and the shrinking of our pupils to adjust for the brightness are synchronous time point events (at the temporal resolution of our perception) . For time intervals imagine a sunny spring afternoon with a cloud passing the sun. During this time interval it will be slightly darker and cooler. Both effects set in and end synchronously with the shadow approaching and receding. Before we turn our attention to temporal pattern mining we review temporal operators that have been used to relate time points and time intervals expressing the identified tempora l concepts. For two points in time there are three binary operators: be-fore , equals , and after . Both before and after can be ac-companied by a threshold, e.g., after at most (least) k time units. This corresponds to a complete ordering of the time stamps and is used in many temporal data mining algo-rithms. Sometimes an operator is used to specify that two or more time stamps lie within a time interval expressing concurrency [67; 26; 112].
 In [15] an operator called temporal constraint with granular-ity expresses the operators before , after , and equals w.r.t. a granularity of time. The authors argue, that one day is not equivalent to 24h, because the latter could cover parts of tw o days, an important distinction in some applications. Also, finer granularities do not necessarily have to correspond to larger ones: an hour is always part of a day, but not ev-ery hour is part of a business day. Thus, the result of the operator can be undefined. A fuzzy extension for temporal reasoning has been proposed in [28] expressing relations li ke much before or closely after . For the purpose of temporal reasoning Allen formalized tem-poral logic on intervals by specifying 13 interval relation s [4] and showing their completeness. Any two intervals are re-lated by exactly one of the relations. The operators are: before , meets , overlaps , starts , during , finishes , the corre-sponding inverses after , met by , overlapped by , started by , contains , finished by , and equals (see Figure 4). The relations are commonly used beyond temporal reason-ing, e.g., for the formulation of temporal patterns (see Sec -tion 6). In [11] a fuzzy extension of Allen X  X  interval relati ons is proposed by adding a preference degree to each possible Figure 4: Examples of Allen X  X  interval relations between th e intervals A and B . The first six can be inverted. relation. For other approaches to fuzzy time interval rela-tions see [17; 79; 82]. In [100] a relaxed version of Allen X  X  relations, called TIME, is described. The strict meets , starts , and finishes operators are relaxed using a threshold (origi-nally proposed in [3]) and intervals far apart are defined to have no relation . Freksa generalized Allen X  X  interval relations by using sem i-intervals [32]. There are 10 operators that relate two inter -vals by using only one boundary of each. The operators older with inverse younger and head to head shown in the first two rows of Figure 5 relate two intervals by their corresponding start points. The operators survives with inverse survived by and tail to tail shown in the next two rows are defined using the end points of each interval. The operators precedes with inverse succeeds and born before death with inverse died after birth relate the start point of one interval with the end point of the other. These operators can be combined to form the additional operators: contemporary ( dies after birth or born before death ), older &amp; survived by , younger &amp; survives , older contemporary , surviving contemporary , survived by contem-porary , and younger contemporary .
 The generalization to semi-intervals was motivated by the observation that  X  X n no case, more than two relations be-tween beginnings and endings of events must be known for uniquely identifying the relation between the correspondi ng events X  . For temporal reasoning the semi-interval represen-tation has the advantage that coarse or incomplete knowl-edge is represented by simpler formulas instead of long dis-junctions. A concept of similarity among the relations is de -scribed. Freksa X  X  semi-interval relations were used to min e temporal association rules in [91]. Roddick combined Allen X  X  interval relations with the five point-interval relations of [106] considering the relativ e po-sitions of the interval midpoints [92]. A total of 49 relatio ns is obtained, e.g., nine different versions of overlaps . Two examples based on Allen X  X  relation A overlaps B are shown in Figure 6(a). In the first case the midpoints of each in-terval are within the other interval. In the second case the midpoint of A is before B and the midpoint of B is after A . The two different versions of Allen X  X  relation can thus be interpreted as large or small overlap. The motivation for th e new operators is handling data with coarse time stamps and data from streams with arbitrary local order. The authors Figure 5: Examples of Freksa X  X  semi-interval relations be-tween the intervals A and B . Inverse operators are shown in italics. also describe the relation between the models of Allen and Freksa and the respective extensions to midpoints and/or intervals of equal durations. The containment operator used in [107] is equivalent to the disjunction of Allen X  X  equals , starts , during , and ends . The Unification-based Temporal Grammar (UTG) proposed by Ultsch contains an approximate version of Allen X  X  equals op-erator called more or less simultaneous [104; 39; 105] (see Figure 6(b)). The start and end points of the intervals are not required to be exactly equal, they only need to be within a small time interval. A further generalization, called co-incides , was proposed in [75] by dropping the constraints on the boundary points, only requiring some overlap be-tween the intervals (see Figure 6(c)). For two intervals thi s is equivalent to the disjunction of Allen X  X  overlaps , starts , during , finishes , the four corresponding inverses, and equals . Temporal logic operators apply to data given as temporal facts. They evaluate the truth of facts at time points or during time intervals.
 In [10] first order Linear Temporal Logic (LTL) is used for planning tasks. LTL is an extension of First Order Logic (FOL) used to specify temporal facts about predicates in a sequence of worlds. The main temporal operators are un-til and next , additionally the derived operators always and eventually are used. An extension with the core operators since , until , next , and previous , called First Order Temporal Logic (FOTL), is described in [83]. The operators always , sometimes , before , after , and while can be derived. In [24; 25] a first order language with the temporal base operators sometimes , always , next , and until and some derived oper-ators is used to form temporal classification rules. In [93] three interval predicates are used: always , sometime , and true-percentage . The predicates explicitly include start and end points of an interval and are evaluated on facts instan-tiated at time points. The truth of a static predicate, e.g., a range condition for a numeric variable, is tested for each time point in an interval, counting how often it is true. For always this needs to be true for all time points, sometimes corresponds to least one success, and true-percentage can be parametrized as a compromise of the other two. The Event logic defined in [99] is a combination of Allen X  X  re-lations with logical predicates that hold on intervals. The AMA ( and meets and ) logic used in [31] is a subset of the complete Event logic restricted to conjunctions of several meeting conjunctions of positive interval literals. The most commonly searched temporal concept in univari-ate symbolic time series is order, i.e., a sub-sequence of sy m-bols occurring sequentially but not necessarily consecuti vely. In Figure 7(a) the occurrences of the sequence B  X  C  X  B are shown. Similar problems occur in string matching and computational biology (see [41]). The discovery of typical patterns in a single symbolic time series can be done by con-structing a suffix tree or a variant thereof. The method de-scribed in [109] supports patterns with wild cards and group characters. The wild cards can be used to model (short) gaps in a pattern. A pattern trie with statistics stored in the tre e nodes is built to efficiently find the most frequent patterns in a long symbolic time series [109; 110]. The higher the min-imum frequency is set, the faster the algorithm runs. The maximum length of a pattern needs to be specified upon tree construction when all sub-sequences of a certain length are extracted from the time series with a sliding window. The efficient calculation of several interestingness measures f or such sub-sequences is described in [5]. Over-and underrep-resented sequences w.r.t. a binomial or Markov background model can be found efficiently. The interestingness can be visualized with suffix trees using different font sizes and col -ors for the nodes [6]. In [55] several traversal strategies o f suffix tries are compared for efficiency.
 The Interagon Query Language (IQL, [54]) is a flexible pat-tern language for univariate symbolic time series similar t o regular expressions [34] including, e.g., negation and dis junc-tions. It covers the temporal concepts of order, concurrenc y, and duration. Duration is modelled by allowing repetition o f symbols. In Figure 7(b) we show the occurrences of the pat-tern B  X  X  C  X  ( A | B ) ( B is followed by something other than C and then by A or B ). IQL patterns are mined in [94] using Genetic Programming [58] where each individual is the syntax tree of a candidate pattern. The candidates are evaluated using special hardware to speed up the search. The search of frequent itemset sub-sequences is commonly called sequential pattern mining [2]. One typical applica-tion is customers purchasing sets of items at different times , where the seller is interested in products typically bought some time after an initial purchase to give recommendations . The pattern { B } X  X  C } X  X  A, D } if shown in Figure 7(c). Usually a set of itemset sequences is searched but using a sliding window such a set can be obtained from a single long itemset sequence. All approaches for mining itemset sequences can also be applied to symbolic time series and sequences by considering each symbol as an itemset of size one. Sequential patterns can express patterns with gaps of arbitrary length unless explicitly restricted, e.g., by th e slid-ing window length.
 The first method to mine itemset sequences was the Aprio-riAll [2] algorithm based on the Apriori principle of mining small frequent patterns first and combining them to form larger patterns [1]. A faster method is SPADE (Sequential Pattern Discovery using Equivalence classes) [124]. Gener al-izations of sequential patterns using concept hierarchies and temporal constraints were proposed in [101]. In [90] sequen -tial patterns are combined with multidimensional records associated with the sequential data. They also describe a fast algorithm called GSP (Generalized Sequential Pattern ). Recently, an efficient bitmap based algorithm has been pro-posed [8].
 An algorithmically different approach for mining sequentia l patterns is called pattern-growth [44] using, e.g., the Pre-fixSpan [87] algorithm. The pattern-growth approach uses a depth-first search that avoids the generation and testing of candidate patterns. Another advantage of this method is the possibility to push user defined constraints [34] deep into the mining algorithm, pruning the search space as early as possible [86; 88]. The SPAM (Sequential Pattern Mining, [9]) approach is also a depth-first search using a memory resident bitmap representation to achieve a high speedup compared to SPADE in general and to PrefixSpan for large data sets. In [34] regular expressions constraints are used to guide the search.
 The number of reported sequential pattern patterns can be reduced by restricting the search to closed sequential patterns, i.e., patterns with no super-patterns of the same frequency. The CloSpan [115] algorithm uses the pattern growth paradigm to mine closed sequences. To free the user from choosing the minimum frequency [103] propose to mine the top k closed patterns raising the threshold dynam-ically [103]. In [111] the Bi-Directional Extension checki ng (BIDE) algorithm is demonstrated to outperform CloSpan. The Apriori and PrefixSpan algorithms were extended to multivariate sequential data in [123]. In [122; 35] sequent ial patterns with temporal annotations quantifying the dura-tion between successive symbols are mined. Approximate sequential patterns are defined in [59]. For more publica-tions and more details on the mining algorithm see [126]. Sequential patterns are capable of expressing order and syn -chronicity. The Episode patterns of [69; 68] are more gen-eral, because they can also express concurrency. Serial Episodes express an order of time points. The length of the pattern is restricted by a maximum temporal distance between the first and the last symbol. In parallel Episodes the symbols of a pattern can occur in any order within the window. In partially ordered Episodes both concepts are mixed, e.g., an order of parallel Episodes or concurrent ser ial Episodes. The parallel combination of two serial Episodes i s shown in Figure 7(d) with a graph based representation of the order relations on the right. An Apriori algorithm is use d for mining Episodes. The type of patterns and the width of a sliding window need to be specified by the user. Typical applications for Episodes include analysis of telecommuni -cation data or web server logs.
 Different methods have bee used for counting the occur-rences of Episodes. The WINEPI [69] method uses the rela-tive frequency, i.e., the number of windows with the pattern divided by the total number of windows. The MINEPI [67] method uses the concept of minimal occurrences, i.e., a win-dow around the pattern that does not contain sub windows with the same pattern. In [12; 18] these approaches are criticized for the need of a fixed maximum window length. Instead they constrain the maximum distance between suc-cessive symbols in a pattern. This way an Episode pat-tern can be arbitrarily long. The frequency counting is per-formed with respect to the pattern length. [70] show that the method of [18] is incomplete and propose the WinMiner algorithm [70].
 An extension of Episodes expressed as temporal logic pro-grams with operators like until or since is described in [83]. In [66] Episodes are mined with an generative approach. [46] mines closed sets of Episodes. Efficient detection of occur-rences of known Episodes in data can be done using directed acyclic sub-sequence graphs [102]. In [42] the significance of Episodes for Bernoulli and Markov background models is calculated. A formal connection between Episodes and dis-crete Hidden Markov Models is shown in [61] and utilized in discovering frequent Episodes.
 In [71] Episodes are combined with a subset of Allen X  X  re-lations to express more temporal relations among Episodes than concurrency. Within each frequent Episode sub pat-terns are searched such that between the time intervals de-fined by the start and end point of each sub pattern the during, overlaps, or meets relation holds.
 In [89] it is shown that Episodes cannot express all possi-ble partial orders. An example from [89] is shown in Fig-ure 7(e) on the right hand side. In [19] such partial orders were mined from of itemset sequences as follows: First, an algorithm for mining closed sequential patterns was applie d [115; 111; 103]. The authors note that pairs of a closed se-quential pattern and the corresponding list of sequences in which they appear, unlike for closed itemsets [85], do not form a Galois lattice [33]: There can be sequential patterns occurring in the same sequences (or windows) that are not contained in one another. In the next step pairs consisting o f a set of closed sequential patterns and a set of transactions in which all these patterns occur are formed. The algorithm ensures maximality of these pairs in the sense that no ad-ditional sequence occurs in all the transactions and there is no additional transaction in which all the sequences oc-cur. These maximal pairs form a Galois lattice and each of them is converted into a partial order resulting in a lattice of closed partial orders. In [74] it is noted that forming suc h pairs is an instance of the frequent itemset problem and the CHARM [125] algorithm is used to mine them. [89] pro-poses a more efficient pattern-growth algorithm to directly mine closed partial order patterns.
 The approaches for unsupervised pattern discovery in sym-bolic time series and sequences are summarized in Table 1 roughly ordered by increasing expressivity of the pattern language. For several contributing authors the earlier pub li-cation is listed. All methods for symbolic time sequences ca n also be applied to univariate symbolic time series. An exten -sion to multivariate symbolic time series is usually possib le as well.
 The first two methods are targeted at univariate data. Se-quences are designed to find order relations, while IQL is very flexible and can express all temporal concepts appli-cable to univariate time series. Sequential patterns can be mined in itemset time sequences, symbolic time sequences, and multivariate symbolic time series. By allowing several symbols in the pattern for a single time point they can ex-press synchronicity. Episodes additionally express the co n-cept of concurrency, because in parallel Episodes no order constraint is placed on the involved symbols. Episodes are typically mined from symbolic time sequences, but an ex-tension to itemsets expressing synchronicity is possible. In [19] such an extension is mentioned for partial orders. The interval data model implicitly covers the concept of tem -poral duration, but the length of the interval is not always used in selecting or expressing the patterns.
 The search for containments of intervals in a multivariate symbolic interval series or sequences is described in [107] . A containment pattern expresses the temporal concept of coincidence. A containment lattice is constructed from the intervals and implication rules are generated. The duratio n of the intervals is not used. Two examples of A contains B contains C are shown in Figure 8(a).
 In [56] interval patterns are composed with Allen X  X  relatio ns. The patterns can express the temporal concepts of coinci-dence, synchronicity, and order. The duration of an interva l is not explicitly used. The patterns are mined from a set of interval sequences with an Apriori algorithm. The sup-port of a pattern is determined by counting the sequences in which it appears. This can easily be generalized to count-ing the occurrences within sliding windows of a single long interval sequence. The search space is restricted to right concatenations of intervals to existing patterns, so-call ed A1 patterns, and by a threshold for the maximum length of a pattern. In Figure 8(b) two patterns are shown that could be described as ((( A starts B ) overlaps C ) overlaps D ) as indicated by the nested dashed boxes in the first example. In the second example the boxes correspond to a different possible representation of the same pattern, namely ((( A be-fore C ) started by B ) overlaps D ) . Note that we exchanged the vertical position of B and C to better nest the boxes, but did not change the positioning of the intervals on the time axis. Both representations would be reported by the algorithm with identical support because they describe the same qualitative pattern.
 In [22] a subset of Allen X  X  relations is used to mine associ-ation patterns, called Fluents, in multivariate symbolic i n-terval series [22; 23]. Patterns are searched with an Apri-ori algorithm over sliding windows. A set of interval se-quences could be used alternatively. The meets and before relations are merged. Duration of intervals is not modelled . The patterns are restricted to composites of single interva ls and/or already found patterns. The significance of such a pair is determined with contingency tables counting co-occurrences. In Figure 8(c) we used the same intervals as in Figure 8(b) and indicated the following two possible rep-resentations with dashed boxes: ( A starts B ) overlaps ( C during D ) and ( A before C ) starts ( B overlaps D ) . Note that the A1 formulations are also possible with Fluents but not vice versa. Which pattern is reported depends on the pairwise significance scores. Again, several representati ons could be reported for the same qualitative pattern. In contrast, the pattern format proposed in [48; 52] offers a unique representation by including the pairwise relation s of all intervals according to Allen. The interval constella -tion from the previous examples in Figure 8(b)-(c) would be described as A starts B , A overlaps D , A before C , B overlaps D , B overlaps C , C during D . A single symbolic interval series is mined using a sliding window and an Apri-ori algorithm. The support is not determined by counting occurrences as in [56; 22] but rather by recording the life-time of a pattern within the sliding window. The pattern format can of course also be used with a set of interval se-quences and occurrence counting. The usage of quantitative attributes, e.g., the length of the intervals or gaps are pro -posed in [53]. This way duration is expressible in addition t o the concepts of coincidence, synchronicity, and order. Fur -ther extensions for handling feature ambiguity [50] and rul e set condensation [49] are proposed.
 Later, a similar solution was independently described in [8 4]. The pattern format is equivalent to [52] but uses only a sub-set of Allen X  X  relations. A tree-based enumeration algorit hm [13] is used for efficient mining. In [113] the patterns of [52] are mined with a modified sequential pattern algorithm [63]. The TCon method for temporal knowledge conversion pre-sented in [37; 40; 38] does not use Allen X  X  interval relation s. They are criticized for the strict conditions relating inte r-val boundaries. The patterns are instead expressed with the Unification-based Temporal Grammar (UTG) [104; 39; 105], a hierarchical pattern language developed for the descript ion of patterns in multivariate time series. So-called Tempora l Complex Patterns are constructed via several abstraction levels. The patterns on each level are associated with a lin-guistic representation in form of temporal grammatical rul es to enable the interpretation by experts. First a multivari-ate symbolic interval series is obtained from numeric time series. Event patterns describe several more or less simul-taneous intervals and express the concept of synchronicity. Two example of the Events involving the intervals A , C , E and A , D , E , respectively, are shown in Figure 8(d) with the dashed boxes. The duration of Events is annotated in the UTG rule and significance is measured by conditional proba-bility estimates. Events are required to contain one interv al from each dimension of the multivariate interval series. Se -quence patterns express an ordering of several Events. The larger dashed boxes in Figure 8(d) indicate the Temporal Complex Pattern A , C , E more or less simultaneous fol-lowed by A , D , E more or less simultaneous . Most steps of TCon are performed manually based on visualizations and statistical summaries of the patterns of the previous level s, no algorithms for the automatic discovery of the temporal concepts of synchronicity and order are described. The tem-poral concept of coincidence is not expressible by the UTG patterns, because the intervals are required to start and en d almost simultaneously. This makes the UTG less expressive than patterns formulated with Allen X  X  relations [74]. The Time Series Knowledge Representation (TSKR) [74; 73; 77] extends the UTG by replacing the temporal concept of synchronicity with the more general coincidence and relax-ing the strict order in Sequences to a partial order. Chord patterns describe a time interval where several observed in -tervals overlap, no conditions are placed on the interval en d points. In Figure 8(e) we indicated eight Chord patterns with the dashed boxes. The letter combinations at the bot-tom indicate which intervals coincide. An important featur e of Chords is that sub-intervals of an observed interval are allowed. Different parts of the observed interval B on the left contribute to the three Chords A coincides with B ; A , B , C coincide ; and B coincides with C . Phrase patterns describe a partial order of several Chords. The two similar Chord sequences of length four in Figure 8(e) as indicated with the outer dashed boxes are summarized by the partial order graph of the Phrase shown in Figure 8(f).
 Using partial order and allowing sub-intervals in a pattern makes the TSKR more expressive than the UTG and the proposed pattern formats using Allen X  X  relations [73]. A more flexible pattern language increases the space and calls for efficient mining algorithms. The Time Series Knowledge Mining (TSKM) framework [74; 72; 77] describes methods to obtain TSKR patterns from numeric time series and sym-bolic interval series. Chords are similar in structure to th e well known itemsets [1]. Each symbolic interval correspond s to an item and a Chord to an itemset. Chords can thus be mined efficiently, e.g., with a version of the CHARM [125] algorithm modified to measure support of Chords as the sum of the durations of the occurrences. Phrases express a par-tial order similar to the time points patterns in Section 5. The mining can be performed in several steps: The interval sequence of Chords is converted to an itemset sequence with one itemset per interval where no Chords change containing all currently active Chords. Next, an algorithm for closed sequence mining, e.g. CloSpan [115], is applied using a win-dowing of the itemset sequence. Similar to [19] the closed sequences are grouped according to their transaction lists . Each group is then converted to a partial order.
 In Table 2 the properties of the described approaches for pattern discovery in interval series and sequences are list ed in order of increasing expressivity of the pattern language and earlier publication. All except the second method work on multivariate interval series and interval sequences. The first approach is limited to a single temporal concept and may only be useful in certain applications. Allen X  X  in-terval relations provide a higher temporal expressivity of the resulting patterns and rules. In contrast to [48] the methods of [56] and [22] do not model duration. The pat-tern format of [48] has been further used by other authors [84; 113]. The UTG/TCon also offers duration but not co-incidence. The successor TSKR can express all identified temporal concepts. When searching for frequent temporal structure in data one can sometimes choose between the time point and the time interval data model. Numerical time series can be converted to symbolic time series or symbolic interval time series by segmentation [60; 52; 57], discretization [108; 62; 27; 76] or clustering [40; 78]. Which one is more appropriate depends on the data. If the temporal process behaves rather smooth and the discretization contains many repetitions of symbol s we recommend using intervals because they more compactly represent the data and make mining more efficient. For time point data the methods from Section 5 can be used to mine frequent patterns. If the data is univariate, only th e temporal concept of order is interesting, and patterns with no or just short gaps are sufficient, using the sequence ap-proach will be most efficient. A summary of the data is built as a preprocessing step such that the support of can-didate patterns can be determined more quickly than with repeated scans of the input data. A limited amount of noise can be handled by allowing gaps. Regular expression or the IQL language offer more expressive patterns. Even duration can be modeled by repetition. The mining with Genetic Pro-gramming can be quite expensive, however, special hardware is used in [94] to evaluate candidate patterns.
 For multivariate data sequential patterns should be consid -ered. They can handle gaps more naturally and express order and synchronicity. There are plenty of algorithms to choose from and this is still a area of active research [8]. In applications where the local order of symbols can be dis-turbed by noise or is not relevant in the first place, Episodes or full partial order patterns should be used. Considering that partial orders are more expressive and that an efficient mining algorithm is available [89] we think that they are preferable to Episodes. More research is needed to transfer the generation of implication rules from frequent patterns or the implementation of user defined constraints [88] from Episodes to full partial order patterns.
 For time interval data patterns based on Allen X  X  relations have been most widely used. The relations were originally developed in the context of temporal reasoning [95] where inference about past, present, and future supports applica -tions in planning, understanding, and diagnosis. The in-put usually consists of exact but incomplete input data and temporal constraints, often expressed by Allen X  X  relation s. Typical problems include determining the consistency of th e data and answering queries about scenarios satisfying all constraints. But these problems do not occur in the data mining context: almost the complete interval data is given and meaningful and understandable patterns are searched [52]. One may have to cope with some missing data, but more importantly with possibly noisy and incorrect data. As discussed in detail in [74; 73; 77] there are several prob-lems when using Allen X  X  relations in the context of data min-ing. First, patterns from noisy interval data expressed wit h Allen X  X  interval relations are not robust. Several of Allen  X  X  relations require the equality of two or more interval end points. Small disturbances in interval end points can creat e patterns where a very similar relationship between interva ls is fragmented into different relations, see Figure 9 for an example.
 There have been attempts to relax the strictness of Allen X  X  Figure 9: Examples for different patterns according to Allen that are fragments of the same approximate relation almost equals .
 univariate numeric interval relations. For fuzzy relations [11] it is not clear how to best determine the membership values for the rela-tions between two given intervals. Threshold can be used to consider temporally close interval boundaries equal [3] . Fragmented patterns are still possible with this approach i f noise causes interval boundaries to be shifted around the threshold value.
 Further, the patterns are ambiguous because as demon-strated in Figure 10 the same relation of Allen can visu-ally and intuitively represent very different situations. E ven more ambiguous is the compact representation of patterns from [56; 22], because as described in Section 6 several dif-ferent descriptions are valid for the exact same pattern. Figure 10: Three instances of Allen X  X  overlaps relation with large quantitative differences.
 Ambiguity could be reduced by splitting patterns with po-tential high variability into several different patterns, e .g. using the mid points [92]. But using 49 instead of 13 rela-tions with many additional conditions requiring equality o f time points will in turn increase effects of pattern fragmen-tation.
 The UTG was the first method that departed from Allen X  X  relations when forming patterns from intervals. Instead of relying on techniques designed for a different purpose, the UTG was designed from scratch for unsupervised pattern mining involving time intervals. The UTG Event patterns are more robust than Allen X  X  relations, by matching inter-val endpoints with a threshold. The UTG cannot, however, express all patterns that can be formulated with Allen, be-cause Events cannot express overlapping intervals in gener al and the number of intervals in an Event is restricted [74]. An important feature of the UTG is the separation of the temporal concepts over several hierarchical levels. Using this divide and conquer strategy reduces the search space for the separate algorithms and offers unique possibilities in relevance feedback during the knowledge discovery process and in the interpretation of the results [105]. An expert can focus on particularly interesting rules and discard valid b ut known rules before the next level constructs are searched. After obtaining the final results an expert can zoom into each rule to learn about how it is composed and what its meaning and consequences might be supporting the zoom, filter, and details on demand paradigm [98].
 The TSKR was built upon these ideas inheriting the advan-tages while fixing the identified discrepancies. As shown in [74; 77] it is more expressive than the UTG and the pro-posed pattern formats using Allen X  X  relations. In contrast to Allen X  X  relations the Chord and Phrase patterns of the TSKR are designed to be easily understandable and avoid ambiguities. A TSKR pattern always describes similar sit-uation in the data and can be described with textual rules, with example instances from the input data, or with a visu-alization of the partial order graph in the Phrase (see Fig-ure 8(f) abstracting over quantitative aspects of the parti cu-lar observations. The TSKR operator coincides is extremely robust against noise in the interval boundaries because it only considers the intersection of all participating inter vals, any interval can individually be stretched to infinity witho ut changing the pattern at all.
 All described interval pattern languages may suffer from fre -quent short interruptions of otherwise long intervals caus ed by noise. Smoothing the original numerical data, if avail-able, can reduce such effects. The interval data can also be filtered [74](Chapter 8.3.5) to create longer intervals whe re a certain property is almost always observed corresponding to the true-percentage operator of [93]. The unsupervised search for frequent temporal patterns can easily lead to result sets that are too large to analyze. Ofte n, the user has some idea of the type or structure of the pat-terns he wishes to find. User defined constraints in general and temporal constraints in particular are important tools to guide the search in these cases. Limits on the minimum or maximum time gap between adjacent elements in a se-quential pattern can be easily integrated into Apriori-bas ed mining [101]. In [86; 88] it is shown how the temporal con-straints on the length, duration, and gaps can be efficiently mined with a prefix-growth algorithm.
 In addition to the temporal concepts used above, time point data can be mined for periodicity [43]. Given a period length, patterns are mined with an Apriori algorithm. For a period k the patterns consist of k positions filled with symbols or wild cards and cover the temporal concepts of order and periodicity. The period is mined along with the patterns [119]. The method allows missing occurrences as well as shifted periods between segments of occurrence. In subsequent work surprising periodic patterns are mined us-ing an information measure rather than support [120; 121]. Recently, extensions for more robust pattern matching al-lowing random replacements [117] and meta patterns [118] have been proposed. In [14] the Fast Fourier Transform (FFT, [97]) of binary vectors for each symbol is used to ob-tain candidates for the algorithm of [43]. In contrast [30] uses a single pass of the data to mine periodic patterns with a similar method. An incremental version of [43] is proposed in [7]. A different approach to periodicity mining based on inter arrival times of a symbol is presented in [64]. Mining candidate periods before association rules is fast, while t he opposite is more robust, because random occurrences of a pattern are less likely than those of a single symbol. Peri-odical patterns are typically searched in retail data, wher e discovered periodicity can be used for supply chain manage-ment or advertisement.
 Many of the above described frequent temporal patterns can be used to generate implication rules similar to associatio n rules [69; 107; 22; 48; 94; 71]. Often, only implications for -ward in time are used to ensure the use of the rule for predic-tion. Other method directly mine implication rules. In [26] the sequential implication rules of two symbols are mined in univariate symbolic time series. In [81] this is extended to multivariate time series and concurrency. The search space is systematically searched in a general to specific manner. Possible performance problems can be overcome by parallel implementations [80]. In [47] the author presents a method for directly mining Episode rules from multivariate symbol ic time series or symbolic time sequences [47; 45]. The an-tecedent and consequent part of the rule must be separated by a time lag. In addition to order and concurrency, syn-chronicity is supported by creating new symbols for syn-chronous pairs.
 In [60] association rules are mined from interval data. Each interval is associated with several numeric or symbolic fea -tures and a single symbolic target attribute. Association rules on pairs of adjacent intervals predicting the target a t-tribute are mined using the Info-Fuzzy Network (IFN, [65]). Duration can be expressed by using it as a numerical feature for the intervals. We reviewed pattern languages and algorithms for unsuper-vised mining of symbolic temporal data. Elementary tempo-ral concepts and data models were defined to implement the comparison. In Section 7 we discussed the merits of different methods trying to help researchers in selecting the appro-priate method. For time points the concept of partial order has recently drawn much attention [66; 36; 18; 89]. Inter-esting further research direction include transferring mi ning techniques from sequences to partial orders, e.g., rule gen -eration, clustering [116], or indexing [21]. For interval d ata Allen X  X  relation have been omnipresent. The recently pro-posed TSKR offers alternative semantics for interval pat-terns that are more expressive and more robust. One way to increase the expressivity of patterns using Allen X  X  rela -tions would be to allow patterns with only partially related intervals. In [96] a temporal reasoning framework based on time points and time intervals is described and applied to medical domains [114] using domain knowledge. To the best of our knowledge there has been no data mining approach to unsupervised pattern mining for data with time points and time intervals as may be appropriate for applications like fault monitoring where single events and states with dura-tions can be observed. The five point-interval relations of [106] as used in [92] could be used to formulate patterns. [1] R. Agrawal, T. Imielinski, and A. N. Swami. Min-[2] R. Agrawal and R. Srikant. Mining sequential pat-[3] M. Aiello, C. Monz, L. Todoran, and M. Worring. [4] J. F. Allen. Maintaining knowledge about temporal [5] A. Apostolico, M. E. Bock, S. Lonardi, and X. Xu. [6] A. Apostolico, F. Gong, and S. Lonardi. Verbumculus [7] W. G. Aref, M. G. Elfeky, and A. K. Elmagarmid. [8] S. Aseervatham, A. Osmani, and E. Viennet. [9] J. Ayres, J. Flannick, J. Gehrke, and T. Yiu. Sequen-[10] F. Bacchus and F. Kabanza. Using temporal logics to [11] S. Badaloni and M. Giacomin. A fuzzy extension of [12] J. Baixeries, G. Casas-Garriga, and J. L. Balcazar. [13] R. J. Bayardo. Efficiently mining long patterns from [14] C. Berberidis, I. Vlahavas, W. G. Aref, M. Atallah, [15] C. Bettini, X. Sean Wang, S. Jajodia, and J.-L. [16] M. H. B  X ohlen, R. Busatto, and C. S. Jensen. Point-[17] M. Calin and D. Galea. A fuzzy relation for compar-[18] G. Casas-Garriga. Discovering unbounded episodes in [19] G. Casas-Garriga. Summarizing sequential data with [20] G. Chen, X. Wu, and X. Zhu. Mining sequential pat-[21] H. Cheng, X. Yan, and J. Han. SeqIndex: Indexing [22] P. R. Cohen. Fluent learning: Elucidating the struc-[23] P. R. Cohen, C. Sutton, and B. Burns. Learning effects [24] P. Cotofrei and K. Stoffel. Rule extraction from time [25] P. Cotofrei and K. Stoffel. First-order logic based [26] G. Das, K.-I. Lin, H. Mannila, G. Renganathan, [27] C. S. Daw, C. E. A. Finney, and E. R. Tracy. A review [28] D. DuBois and H. Prade. Processing fuzzy temporal [29] A. Dugarjapov and G. Lausen. Mining sets of time [30] M. G. Elfeky, W. G. Aref, and A. K. Elmagarmid. Us-[31] A. Fern, R. Givan, and J. M. Siskind. Specific-to-[32] C. Freksa. Temporal reasoning based on semi-[33] B. Ganter and R. Wille. Formal Concept Analysis. [34] M. N. Garofalakis, R. Rastogi, and K. Shim. SPIRIT: [35] F. Gianotti, M. Nanni, and D. Pedreschi. Effi-[36] A. Gionis, T. Kujala, and H. Mannila. Fragments of [37] G. Guimar  X aes. Eine Methode zur Entdeckung von kom-[38] G. Guimar  X aes, J. Peter, T. Penzel, and A. Ultsch. A [39] G. Guimar  X aes and A. Ultsch. A symbolic representa-[40] G. Guimar  X aes and A. Ultsch. A method for tempo-[41] D. Gusfield. Algorithms on strings, trees, and se-[42] R. Gwadera, M. J. Atallah, and W. Szpankowski. [43] J. Han, W. Gong, and Y. Yin. Mining segment-[44] J. Han and J. Pei. Pattern growth methods for se-[45] S. K. Harms and J. Deogun. Sequential association [46] S. K. Harms, J. S. Deogun, J. Saquer, and T. Tadesse. [47] S. K. Harms, J. S. Deogun, and T. Tadesse. Discov-[48] F. H  X oppner. Discovery of temporal patterns -learning [49] F. H  X oppner. Discovery of core episodes from sequences [50] F. H  X oppner. Handling feature ambiguity in knowl-[51] F. H  X oppner. Learning dependencies in multivariate [52] F. H  X oppner. Knowledge Discovery from Sequential [53] F. H  X oppner and F. Klawonn. Finding informative [54] Interagon. The Interagon Query Language -A refer-[55] L. Jiang and H. J. Hamilton. Methods for mining fre-[56] P.-S. Kam and A. W.-C. Fu. Discovering temporal [57] E. Keogh, S. Chu, D. Hart, and M. Pazzani. Seg-[58] J. R. Koza. Genetic programming. In J. G. Williams [59] H.-C. Kum, J. Pei, W. Wang, and D. Duncan. Approx-[60] M. Last, Y. Klein, and A. Kandel. Knowledge discov-[61] S. Laxman, P. Sastry, and K. Unnikrishnan. Discov-[62] J. Lin, E. Keogh, S. Lonardi, and B. Chiu. A sym-[63] M.-Y. Lin and S.-Y. Lee. Fast discovery of sequen-[64] S. Ma and J. L. Hellerstein. Mining partially periodic [65] O. Maimon and M. Last. Knowledge Discovery and [66] H. Mannila and C. Meek. Global partial orders from [67] H. Mannila and H. Toivonen. Discovering generalized [68] H. Mannila, H. Toivonen, and A. I. Verkamo. Discov-[69] H. Mannila, H. Toivonen, and I. Verkamo. Discovery of [70] N. M  X eger and C. Rigotti. Constraint-based mining of [71] C. Mooney and J. F. Roddick. Mining relation-[72] F. M  X orchen. Algorithms for time series knowledge [73] F. M  X orchen. A better tool than allen X  X  relations for [74] F. M  X orchen. Time Series Knowledge Mining . PhD the-[75] F. M  X orchen and A. Ultsch. Mining hierarchical tempo-[76] F. M  X orchen and A. Ultsch. Optimizing time series dis-[77] F. M  X orchen and A. Ultsch. Efficient mining of under-[78] F. M  X orchen, A. Ultsch, and O. Hoos. Extracting [79] G. Nagypal and B. Motik. A fuzzy model for represent-[80] T. Oates, M. D. Schmill, and P. R. Cohen. Parallel [81] T. Oates, M. D. Schmill, D. Jensen, and P. R. Cohen. [82] H. J. Ohlbach. Relations between fuzzy time intervals. [83] B. Padmanabhan and A. Tuzhilin. Pattern discovery [84] P. Papaterou, G. Kollios, S. Sclaroff, and D. Gunopou-[85] N. Pasquier, Y. Bastide, R. Taouil, and L. Lakhal. Dis-[86] J. Pei and J. Han. Constrained frequent pattern min-[87] J. Pei, J. Han, B. Mortazavi-Asl, H. Pinto, Q. Chen, [88] J. Pei, J. Han, and W. Wang. Constraint-based se-[89] J. Pei, H. Wang, J. Liu, K. Wang, J. Wang, and P. S. [90] H. Pinto, J. Han, J. Pei, K. Wang, Q. Chen, and [91] C. Rainsford and J. Roddick. Adding temporal seman-[92] J. F. Roddick and C. H. Mooney. Linear temporal se-[93] J. J. Rodriguez, C. J. Alonso, and H. Bostr  X om. Learn-[94] P. Saetrom and M. L. Hetland. Unsupervised tempo-[95] E. Schwalb and L. Vila. Temporal constraints: A sur-[96] Y. Shahar. A framework for knowledge-based tempo-[97] H. Shatkay. The Fourier transform -A primer. Tech-[98] B. Shneiderman. The eyes have it: A task by data [99] J. M. Siskind. Grounding the lexical semantics of [100] C. Snoek and M. Worring. Multimedia event based [101] R. Srikant and R. Agrawal. Mining sequential pat-[102] Z. Tron  X  X  X cek. Episode matching. In A. Amir and G. M. [103] P. Tzvetkov, X. Yan, and J. Han. TSP: Mining Top-[104] A. Ultsch. Eine unifikationsbasierte Grammatik zur [105] A. Ultsch. Unification-based temporal grammar. Tech-[106] M. Vilain. A system for reasoning about time. In Pro-[107] R. Villafane, K. A. Hua, D. Tran, and B. Maulik. [108] R. Villafane, K. A. Hua, D. Tran, and B. Maulik. [109] J. Vilo. Discovering frequent patterns from strings. [110] J. Vilo. Pattern Discovery from Biosequences . PhD [111] J. Wang and J. Han. BIDE: Efficient mining of [112] G. M. Weiss. Timeweaver: A genetic algorithm for [113] E. Winarko and J. F. Roddick. Armada -an algo-[114] S. Y. and M. M.A. Knowledge-based temporal ab-[115] X. Yan, J. Han, and R. Afshar. CloSpan: Min-[116] J. Yang and W. Wang. CLUSEQ: Efficient and ef-[117] J. Yang, W. Wang, and P. Yu. STAMP: Discovery of [118] J. Yang, W. Wang, and P. Yu. Discovering high order [119] J. Yang, W. Wang, and P. S. Yu. Mining asynchronous [120] J. Yang, W. Wang, and P. S. Yu. InfoMiner: Min-[121] J. Yang, W. Wang, and P. S. Yu. InfoMiner+: Mining [122] M. Yoshida, T. Iizuka, H. Shiohara, and M. Ishiguro. [123] C.-C. Yu and Y.-L. Chen. Mining sequential patterns [124] M. J. Zaki. Efficient enumeration of frequent se-[125] M. J. Zaki and C.-J. Hsiao. Efficient algorithms for [126] Q. Zhao and S. Bhowmick. Sequential pattern min-
