 Collaborative filtering (CF) is a successful approach com-monly used by many recommender systems. Conventional CF-based methods use the ratings given to items by users as the sole source of information for learning to make rec-ommendation. However, the ratings are often very sparse in many applications, causing CF-based methods to degrade significantly in their recommendation performance. To ad-dress this sparsity problem, auxiliary information such as item content information may be utilized. Collaborative topic regression (CTR) is an appealing recent method taking this approach which tightly couples the two components that learn from two different sources of information. Neverthe-less, the latent representation learned by CTR may not be very effective when the auxiliary information is very sparse. To address this problem, we generalize recent advances in deep learning from i.i.d. input to non-i.i.d. (CF-based) in-put and propose in this paper a hierarchical Bayesian model called collaborative deep learning (CDL), which jointly per-forms deep representation learning for the content informa-tion and collaborative filtering for the ratings (feedback) matrix. Extensive experiments on three real-world datasets from different domains show that CDL can significantly ad-vance the state of the art.
 H.1.0 [ Information Systems ]: Models and Principles X  General ; J.4 [ Computer Applications ]: Social and Be-havioral Sciences Recommender systems; Deep learning; Topic model; Text mining
Due to the abundance of choice in many online services, recommender systems (RS) now play an increasingly signif-c  X  2015 ACM. ISBN 978-1-4503-3664-2/15/08 ...$15.00. icant role [40]. For individuals, using RS allows us to make more effective use of information. Besides, many compa-nies (e.g., Amazon and Netflix) have been using RS exten-sively to target their customers by recommending products or services. Existing methods for RS can roughly be cate-gorized into three classes [6]: content-based methods, col-laborative filtering (CF) based methods, and hybrid meth-ods. Content-based methods [17] make use of user profiles or product descriptions for recommendation. CF-based meth-ods [23, 27] use the past activities or preferences, such as user ratings on items, without using user or product content information. Hybrid methods [1, 18, 12] seek to get the best of both worlds by combining content-based and CF-based methods.

Because of privacy concerns, it is generally more difficult to collect user profiles than past activities. Nevertheless, CF-based methods do have their limitations. The predic-tion accuracy often drops significantly when the ratings are very sparse. Moreover, they cannot be used for recommend-ing new products which have yet to receive rating informa-tion from users. Consequently, it is inevitable for CF-based methods to exploit auxiliary information and hence hybrid methods have gained popularity in recent years.

According to whether two-way interaction exists between the rating information and auxiliary information, we may further divide hybrid methods into two sub-categories: loosely coupled and tightly coupled methods. Loosely coupled meth-ods like [29] process the auxiliary information once and then use it to provide features for the CF models. Since informa-tion flow is one-way, the rating information cannot provide feedback to guide the extraction of useful features. For this sub-category, improvement often has to rely on a manual and tedious feature engineering process. On the contrary, tightly coupled methods like [34] allow two-way interaction. On one hand, the rating information can guide the learn-ing of features. On the other hand, the extracted features can further improve the predictive power of the CF models (e.g., based on matrix factorization of the sparse rating ma-trix). With two-way interaction, tightly coupled methods can automatically learn features from the auxiliary informa-tion and naturally balance the influence of the rating and auxiliary information. This is why tightly coupled methods often outperform loosely coupled ones [35].

Collaborative topic regression (CTR) [34] is a recently proposed tightly coupled method. It is a probabilistic graph-ical model that seamlessly integrates a topic model, latent Dirichlet allocation (LDA) [5], and a model-based CF method, probabilistic matrix factorization (PMF) [27]. CTR is an appealing method in that it produces promising and in-terpretable results. Nevertheless, the latent representation learned is often not effective enough especially when the aux-iliary information is very sparse. It is this representation learning problem that we will focus on in this paper.
On the other hand, deep learning models recently show great potential for learning effective representations and de-liver state-of-the-art performance in computer vision [38] and natural language processing [15, 26] applications. In deep learning models, features are learned in a supervised or unsupervised manner. Although they are more appealing than shallow models in that the features can be learned au-tomatically (e.g., effective feature representation is learned from text content), they are inferior to shallow models such as CF in capturing and learning the similarity and implicit relationship between items. This calls for integrating deep learning with CF by performing deep learning collabora-tively.

Unfortunately, very few attempts have been made to de-velop deep learning models for CF. [28] uses restricted Boltz-mann machines instead of the conventional matrix factor-ization formulation to perform CF and [9] extends this work by incorporating user-user and item-item correlations. Al-though these methods involve both deep learning and CF, they actually belong to CF-based methods because they do not incorporate content information like CTR, which is cru-cial for accurate recommendation. [24] uses low-rank matrix factorization in the last weight layer of a deep network to sig-nificantly reduce the number of model parameters and speed up training, but it is for classification instead of recommen-dation tasks. On music recommendation, [21, 39] directly use conventional CNN or deep belief networks (DBN) to as-sist representation learning for content information, but the deep learning components of their models are deterministic without modeling the noise and hence they are less robust. The models achieve performance boost mainly by loosely coupled methods without exploiting the interaction between content information and ratings. Besides, the CNN is linked directly to the rating matrix, which means the models will perform poorly when the ratings are sparse, as shown in the following experiments.
 To address the challenges above, we develop a hierarchical Bayesian model called collaborative deep learning (CDL) as a novel tightly coupled method for RS. We first present a Bayesian formulation of a deep learning model called stacked denoising autoencoder (SDAE) [32]. With this, we then present our CDL model which tightly couples deep represen-tation learning for the content information and collaborative filtering for the ratings (feedback) matrix, allowing two-way interaction between the two. Experiments show that CDL significantly outperforms the state of the art. Note that al-though we present CDL as using SDAE for its feature learn-ing component, CDL is actually a more general framework which can also admit other deep learning models such as deep Boltzmann machines [25], recurrent neural networks [10], and convolutional neural networks [16].

The main contribution of this paper is summarized below:
Similar to the work in [34], the recommendation task con-sidered in this paper takes implicit feedback [13] as the train-ing and test data. The entire collection of J items (articles or movies) is represented by a J -by-S matrix X c , where row j is the bag-of-words vector X c,j  X  for item j based on a vo-cabulary of size S . With I users, we define an I -by-J binary rating matrix R = [ R ij ] I  X  J . For example, in the dataset citeulike-a R ij = 1 if user i has article j in his or her per-sonal library and R ij = 0 otherwise. Given part of the rat-ings in R and the content information X c , the problem is to predict the other ratings in R . Note that although we focus on movie recommendation (where plots of movies are con-sidered as content information) and article recommendation like [34] in this paper, our model is general enough to handle other recommendation tasks (e.g., tag recommendation).
The matrix X c plays the role of clean input to the SDAE while the noise-corrupted matrix, also a J -by-S matrix, is denoted by X 0 . The output of layer l of the SDAE is de-noted by X l which is a J -by-K l matrix. Similar to X c j of X l is denoted by X l,j  X  . W l and b l are the weight ma-trix and bias vector, respectively, of layer l , W l,  X  n column n of W l , and L is the number of layers. For conve-nience, we use W + to denote the collection of all layers of weight matrices and biases. Note that an L/ 2-layer SDAE corresponds to an L -layer network. We are now ready to present details of our CDL model. We first briefly review SDAE and give a Bayesian formula-tion of SDAE. This is then followed by the presentation of CDL as a hierarchical Bayesian model which tightly inte-grates the ratings and content information.
SDAE [32] is a feedforward neural network for learning representations (encoding) of the input data by learning to predict the clean input itself in the output, as shown in Figure 2. Usually the hidden layer in the middle, i.e., X the figure, is constrained to be a bottleneck and the input layer X 0 is a corrupted version of the clean input data. An x x SDAE solves the following optimization problem: where  X  is a regularization parameter and k X k F denotes the Frobenius norm.
If we assume that both the clean input X c and the cor-rupted input X 0 are observed, similar to [4, 19, 3, 7], we can define the following generative process: 1. For each layer l of the SDAE network, 2. For each item j , draw a clean input 1 Note that if  X  s goes to infinity, the Gaussian distribution in Equation (1) will become a Dirac delta distribution [31] function. The model will degenerate to be a Bayesian for-mulation of SDAE. That is why we call it generalized SDAE.
Note that the first L/ 2 layers of the network act as an en-coder and the last L/ 2 layers act as a decoder. Maximization
Note that while generation of the clean input X c from X L is part of the generative process of the Bayesian SDAE, gen-eration of the noise-corrupted input X 0 from X c is an arti-ficial noise injection process to help the SDAE learn a more robust feature representation. of the posterior probability is equivalent to minimization of the reconstruction error with weight decay taken into con-sideration.
Using the Bayesian SDAE as a component, the generative process of CDL is defined as follows: 1. For each layer l of the SDAE network, 2. For each item j , 3. Draw a latent user vector for each user i : 4. Draw a rating R ij for each user-item pair ( i,j ): Here  X  w ,  X  n ,  X  u ,  X  s , and  X  v are hyperparameters and C a confidence parameter similar to that for CTR ( C ij = a if R ij = 1 and C ij = b otherwise). Note that the middle layer X
L/ 2 serves as a bridge between the ratings and content in-formation. This middle layer, along with the latent offset is the key that enables CDL to simultaneously learn an ef-fective feature representation and capture the similarity and (implicit) relationship between items (and users). Similar to the generalized SDAE, for computational efficiency, we can also take  X  s to infinity.

The graphical model of CDL when  X  s approaches positive infinity is shown in Figure 1, where, for notational simplicity, we use x 0 , x L/ 2 , and x L in place of X T 0 ,j  X  , X T respectively. Figure 3: NN representation for degenerated CDL.
Based on the CDL model above, all parameters could be treated as random variables so that fully Bayesian methods such as Markov chain Monte Carlo (MCMC) or variational approximation methods [14] may be applied. However, such treatment typically incurs high computational cost. Besides, since CTR is our primary baseline for comparison, it would be fair and reasonable to take an approach analogous to that used in CTR. Consequently, we devise below an EM-style algorithm for obtaining the MAP estimates, as in [34].
Like in CTR, maximizing the posterior probability is equiv-alent to maximizing the joint log-likelihood of U , V , { X X , { W l } , { b l } , and R given  X  u ,  X  v ,  X  w ,  X  s , and  X 
L =  X   X  u If  X  s goes to infinity, the likelihood becomes: where the encoder function f e (  X  , W + ) takes the corrupted content vector X 0 ,j  X  of item j as input and computes the encoding of the item, and the function f r (  X  , W + ) also takes X 0 ,j  X  as input, computes the encoding and then the recon-structed content vector of item j . For example, if the num-ber of layers L = 6, f e ( X 0 ,j  X  , W + ) is the output of the third layer while f r ( X 0 ,j  X  , W + ) is the output of the sixth layer.
From the perspective of optimization, the third term in the objective function (2) above is equivalent to a multi-layer perceptron using the latent item vectors v j as target while the fourth term is equivalent to an SDAE minimizing the re-construction error. Seeing from the view of neural networks (NN), when  X  s approaches positive infinity, training of the probabilistic graphical model of CDL in Figure 1(left) would degenerate to simultaneously training two neural networks overlaid together with a common input layer (the corrupted input) but different output layers, as shown in Figure 3. Note that the second network is much more complex than typical neural networks due to the involvement of the rating matrix.

When the ratio  X  n / X  v approaches positive infinity, it will degenerate to a two-step model in which the latent repre-sentation learned using SDAE is put directly into the CTR. Another extreme happens when  X  n / X  v goes to zero where the decoder of the SDAE essentially vanishes. On the right of Figure 1 is the graphical model of the degenerated CDL when  X  n / X  v goes to zero. As demonstrated in the experi-ments, the predictive performance will suffer greatly for both extreme cases.
 For u i and v j , coordinate ascent similar to [34, 13] is used. Given the current W + , we compute the gradients of L with respect to u i and v j and set them to zero, leading to the following update rules: u v where U = ( u i ) I i =1 , V = ( v j ) J j =1 , C i = diag( C is a diagonal matrix, R i = ( R i 1 ,..., R iJ ) T is a column vec-tor containing all the ratings of user i , and C ij reflects the confidence controlled by a and b as discussed in [13].
Given U and V , we can learn the weights W l and biases b l for each layer using the back-propagation learning algo-rithm. The gradients of the likelihood with respect to W and b l are as follows: By alternating the update of U , V , W l , and b l , we can find a local optimum for L . Several commonly used techniques such as using a momentum term may be used to alleviate the local optimum problem. For completeness, we also provide a sampling-based algorithm for CDL in the appendix.
Let D be the observed test data. Similar to [34], we use the point estimates of u i , W + and j to calculate the predicted rating:
E [ R ij | D ]  X  E [ u i | D ] T ( E [ f e ( X 0 ,j  X  , W where E [  X  ] denotes the expectation operation. In other words, we approximate the predicted rating as: Note that for any new item j with no rating in the training data, its offset  X  j will be 0 .
Extensive experiments are conducted on three real-world datasets from different domains to demonstrate the effective-ness of our model both quantitatively and qualitatively 2
We use three datasets from different real-world domains, two from CiteULike 3 and one from Netflix, for our experi-ments. The first two datasets, from [35], were collected in different ways, specifically, with different scales and different degrees of sparsity to mimic different practical situations. The first dataset, citeulike-a , is mostly from [34]. The sec-ond dataset, citeulike-t , was collected independently of the first one. They manually selected 273 seed tags and collected all the articles with at least one of those tags. Similar to [34], users with fewer than 3 articles are not included. As a re-sult, citeulike-a contains 5551 users and 16980 items. For citeulike-t , the numbers are 7947 and 25975. We can see that citeulike-t contains more users and items than citeulike-a . Also, citeulike-t is much sparser as only 0 . 07% of its user-item matrix entries contain ratings but citeulike-a has rat-ings in 0 . 22% of its user-item matrix entries.

The last dataset, Netflix , consists of two parts. The first part, with ratings and movie titles, is from the Netflix chal-lenge dataset. The second part, with plots of the corre-sponding movies, was collected by us from IMDB 4 . Similar to [41], in order to be consistent with the implicit feedback setting of the first two datasets, we extract only positive rat-ings (rating 5) for training and testing. After removing users with less than 3 positive ratings and movies without plots, we have 407261 users, 9228 movies, and 15348808 ratings in the final dataset.

We follow the same procedure as that in [34] to preprocess the text information (item content) extracted from the ti-tles and abstracts of the articles and the plots of the movies. After removing stop words, the top S discriminative words according to the tf-idf values are chosen to form the vocab-ulary ( S is 8000, 20000, and 20000 for the three datasets). For each dataset, similar to [35, 36], we randomly select P items associated with each user to form the training set and use all the rest of the dataset as the test set. To eval-uate and compare the models under both sparse and dense settings, we set P to 1 and 10, respectively, in our experi-ments. For each value of P , we repeat the evaluation five times with different randomly selected training sets and the average performance is reported.

As in [34, 22, 35], we use recall as the performance measure because the rating information is in the form of implicit
Code and data are available at www.wanghao.in
CiteULike allows users to create their own collections of articles. There are abstract, title, and tags for each arti-cle. More details about the CiteULike data can be found at http://www.citeulike.org . http://www.imdb.com feedback [13, 23]. Specifically, a zero entry may be due to the fact that the user is not interested in the item, or that the user is not aware of its existence. As such, precision is not a suitable performance measure. Like most recommender systems, we sort the predicted ratings of the candidate items and recommend the top M items to the target user. The recall@ M for each user is then defined as: The final result reported is the average recall over all users.
Another evaluation metric is the mean average precision (mAP). Exactly the same as [21], we set the cutoff point at 500 for each user.
The models included in our comparison are listed as fol-lows:
In the experiments, we first use a validation set to find the optimal hyperparameters for CMF, SVDFeature, CTR, and DeepMusic. For CMF, we set the regularization hyper-parameters for the latent factors of different contexts to 10. After the grid search, we find that CMF performs best when the weights for the rating matrix and content matrix (BOW) are both 5 in the sparse setting. For the dense setting the weights are 8 and 2, respectively. For SVDFeature, the best performance is achieved when the regularization hyperpa-rameters for the users and items are both 0 . 004 with the learning rate equal to 0 . 005. For DeepMusic, we find that the best performance is achieved using a CNN with two con-volutional layers. We also try our best to tune the other hy-perparameters. For CTR, we find that it can achieve good prediction performance when  X  u = 0 . 1,  X  v = 10, a = 1, b = 0 . 01, and K = 50 (note that a and b determine the con-fidence parameters C ij ). For CDL, we directly set a = 1, b = 0 . 01, K = 50 and perform grid search on the hyperpa-rameters  X  u ,  X  v ,  X  n , and  X  w . For the grid search, we split the training data and use 5-fold cross validation.

We use a masking noise with a noise level of 0 . 3 to get the corrupted input X 0 from the clean input X c . For CDL with more than one layer of SDAE ( L &gt; 2), we use a dropout rate [2, 33, 11] of 0 . 1 to achieve adaptive regularization. In terms of network architecture, the number of hidden units K l is set to 200 for l such that l 6 = L/ 2 and 0 &lt; l &lt; L . While both K and K L are equal to the number of words S in the dictionary, K
L/ 2 is set to K which is the number of dimensions of the learned representation. For example, the 2-layer CDL model ( L = 4) has a Bayesian SDAE of architecture  X 8000-200-50-200-8000 X  for the citeulike-a dataset. Figures 4 and 5 show the results that compare CDL, CTR, DeepMusic, CMF, and SVDFeature using the three datasets under both the sparse ( P = 1) and dense ( P = 10) set-tings. We can see that CTR is a strong baseline which beats DeepMusic, CMF, and SVDFeature in all datasets even though DeepMusic has a deep architecture. In the sparse setting, CMF outperforms SVDFeature most of the time and sometimes even achieves performance compara-ble to CTR. DeepMusic performs poorly due to lack of rat-ings and overfitting. In the dense setting, SVDFeature is significantly better than CMF for citeulike-a and citeulike-t but is inferior to CMF for Netflix . DeepMusic is still slightly worse than CTR due to the reasons mentioned in Section 1. To focus more specifically on comparing CDL with CTR, we can see that for citeulike-a , 2-layer CDL out-performs CTR by a margin of 4.2%  X  6.0% in the sparse set-ting and 3.3%  X  4.6% in the dense setting. If we increase the number of layers to 3 ( L = 6), the margin will go up to 5.8%  X  8.0% and 4.3%  X  5.8%, respectively. Similarly for citeulike-t , 2-layer CDL outperforms CTR by a margin of 10.4%  X  13.1% in the sparse setting and 4.7%  X  7.6% in the dense setting. When the number of layers is increased to 3, the margin will even go up to 11.0%  X  14.9% and 5.2%  X  8.2%, respectively. For Netflix , 2-layer CDL outperforms CTR by a margin of 1.9%  X  5.9% in the sparse setting and 1.5%  X  2.0% in the dense setting. As we can see, seamless and success-ful integration of deep learning and RS requires careful de-signs to avoid overfitting and achieve significant performance boost.

Table 1 shows the mAP for all models in the sparse set-tings. We can see that the mAP of CDL is almost or more than twice of CTR. Tables 2 and 3 show the recall@300 re-sults when CDL with different numbers of layers are applied to the three datasets under both the sparse and dense set-tings. As we can see, for citeulike-t and Netflix , the recall increases as the number of layers increases. For citeulike-a , CDL starts to overfit when it exceeds two layers. Since the standard deviation is always very small (4 . 31  X  10  X  5 9 . 31  X  10  X  3 ), we do not include it in the figures and tables as it is not noticeable anyway.

Note that the results are somewhat different for the first two datasets although they are from the same domain. This is due to the different ways in which the datasets were col-lected, as discussed above. Specifically, both the text in-formation and the rating matrix in citeulike-t are much sparser. 5 By seamlessly integrating deep representation learn-ing for content information and CF for the rating matrix, CDL can handle both the sparse rating matrix and the
Each article in citeulike-a has 66 . 6 words on average and that for citeulike-t is 18 . 8. Figure 6: Performance of CDL based on recall@ M for different values of  X  n on citeulike-t . The left plot is for L = 2 and the right one is for L = 6 . sparse text information much better and learn a much more effective latent representation for each item and hence each user.

Figure 6 shows the results for different values of  X  ing citeulike-t under the dense setting. We set  X  u = 0 . 01,  X  v = 100, and L to 2 and 6. Similar phenomena are ob-served when the number of layers and the value of P are varied but they are omitted here due to space constraints. As mentioned in the previous section, when  X  n is extremely large,  X  n / X  v will approach positive infinity so that CDL de-generates to two separate models. In this case the latent item representation will be learned by the SDAE in an un-supervised manner and then it will be put directly into (a simplified version of) the CTR. Consequently, there is no interaction between the Bayesian SDAE and the collabora-tive filtering component based on matrix factorization and hence the prediction performance will suffer greatly. For the other extreme when  X  n is extremely small,  X  n / X  v will ap-proach zero so that CDL degenerates to that in Figure 1 in which the decoder of the Bayesian SDAE component essen-tially vanishes. This way the encoder of the Bayesian SDAE component will easily overfit the latent item vectors learned by simple matrix factorization. As we can see in Figure 6, the prediction performance degrades significantly as  X  n gets very large or very small. When  X  n &lt; 0 . 1, the recall@ M is already very close to (or even worse than) the result of PMF.
To gain a better insight into CDL, we first take a look at two example users in the citeulike-t dataset and represent the profile of each of them using the top three matched top-ics. We examine the top 10 recommended articles returned by a 3-layer ( L = 6) CDL and CTR. The models are trained under the sparse setting ( P = 1). From Table 4, we can spec-ulate that user I might be a computer scientist with focus on tag recommendation, as clearly indicated by the first topic in CDL and the second one in CTR. CDL correctly recom-mends many articles on tagging systems while CTR focuses on social networks instead. When digging into the data, we find that the only rated article in the training data is  X  X hat drives content tagging: the case of photos on Flickr X , which is an article that talks about the impact of social networks on tagging behaviors. This may explain why CTR focuses its recommendation on social networks. On the other hand, CDL can better understand the key points of the article (i.e., tagging and CF) to make appropriate recommendation ac-cordingly. Consequently, the precision of CDL and CTR is 70% and 10%, respectively.

From the matched topics returned by both CDL and CTR, user II might be a researcher on blood flow dynamic the-ory particularly in the field of medical science. CDL cor-rectly captures the user profile and achieves a precision of 100%. However, CTR recommends quite a few articles on astronomy instead. When examining the data, we find that the only rated article returned by CTR is  X  X imulating de-formable particle suspensions using a coupled lattice-Boltzmann and finite-element method X . As expected, this article is on deformable particle suspension and the flow of blood cells. CTR might have misinterpreted this article, focusing its rec-ommendation on words like  X  X lows X  and  X  X ormation X  sepa-rately. This explains why CTR recommends articles like  X  X ormation versus destruction: the evolution of the star clus-ter population in galaxy mergers X  (formation) and  X  X acro-scopic effects of the spectral structure in turbulent flows X  (flows). As a result, its precision is only 30%.

From these two users, we can see that with a more effective representation, CDL can capture the key points of articles and the user preferences more accurately (e.g., user I). Be-sides, it can model the co-occurrence and relations of words better (e.g., user II).

We next present another case study which is for the Net-flix dataset under the dense setting ( P = 10). In this case study, we choose one user (user III) and vary the number of ratings (positive feedback) in the training set given by the user from 1 to 10. The partition of training and test data remains the same for all other users. This is to examine how the recommendation of CTR and CDL adapts as user III expresses preference for more and more movies. Table 5 shows the recommendation lists of CTR and CDL when the number of training samples is set to 2, 4, and 10. When there are only two training samples, the two movies user III likes are  X  X oonstruck X  and  X  X rue Romance X , which are both romance movies. For now the precision of CTR and CDL is close (20% and 30%). When two more samples are added, the precision of CDL is boosted to 50% while that of CTR remains unchanged (20%). That is because the two new movies,  X  X ohnny English X  and  X  X merican Beauty X , belong to action and drama movies. CDL successfully captures the user X  X  change of taste and gets two more recommendations right but CTR fails to do so. Similar phenomena can be ob-served when the number of training samples increases from 4 to 10. From this case study, we can see that CDL is sensi-tive enough to changes of user taste and hence can provide more accurate recommendation.
Following the update rules in this paper, the computa-tional complexity of updating u i is O ( K 2 J + K 3 ), where K is the dimensionality of the learned representation and J is the number of items. The complexity for v j is O ( K K 3 + SK 1 ), where I is the number of users, S is the size of the vocabulary, and K 1 is the dimensionality of the out-put in the first layer. Note that the third term O ( SK is the cost of computing the output of the encoder and it is dominated by the computation of the first layer. For the update of all the weights and biases, the complexity is O ( JSK 1 ) since the computation is dominated by the first layer. Thus for a complete epoch the total time complexity is O ( JSK 1 + K 2 J 2 + K 2 I 2 + K 3 ).

All our experiments are conducted on servers with 2 In-tel E5-2650 CPUs and 4 NVIDIA Tesla M2090 GPUs each. Using the MATLAB implementation with GPU/C++ ac-celeration, each epoch takes only about 40 seconds and each run takes 200 epochs for the first two datasets. For Netflix it takes about 60 seconds per epoch and needs much fewer epochs (about 100) to get satisfactory recommendation per-formance. Since Netflix is much larger than the other two datasets, this shows that CDL is very scalable. We expect that changing the implementation to a pure C++/CUDA one would significantly reduce the time cost.
We have demonstrated in this paper that state-of-the-art performance can be achieved by jointly performing deep rep-resentation learning for the content information and collab-orative filtering for the ratings (feedback) matrix. As far as we know, CDL is the first hierarchical Bayesian model to bridge the gap between state-of-the-art deep learning models and RS. In terms of learning, besides the algorithm for at-taining the MAP estimates, we also derive a sampling-based algorithm for the Bayesian treatment of CDL as a Bayesian generalized version of back-propagation.
 Among the possible extensions that could be made to CDL, the bag-of-words representation may be replaced by more powerful alternatives, such as [20]. The Bayesian na-ture of CDL also provides potential performance boost if other side information is incorporated as in [37]. Besides, as remarked above, CDL actually provides a framework that can also admit deep learning models other than SDAE. One promising choice is the convolutional neural network model which, among other things, can explicitly take the context and order of words into account. Further performance boost may be possible when using such deep learning models.
This research has been partially supported by research grant FSGRF14EG36. [1] D. Agarwal and B.-C. Chen. Regression-based latent [2] P. Baldi and P. J. Sadowski. Understanding dropout. [3] Y. Bengio, L. Yao, G. Alain, and P. Vincent.
 [4] C. M. Bishop. Pattern Recognition and Machine [5] D. M. Blei, A. Y. Ng, and M. I. Jordan. Latent [6] J. Bobadilla, F. Ortega, A. Hernando, and [7] M. Chen, Z. E. Xu, K. Q. Weinberger, and F. Sha. [8] T. Chen, W. Zhang, Q. Lu, K. Chen, Z. Zheng, and [9] K. Georgiev and P. Nakov. A non-iid framework for [10] A. Graves, S. Fern  X andez, F. J. Gomez, and [11] G. E. Hinton, N. Srivastava, A. Krizhevsky, [12] L. Hu, J. Cao, G. Xu, L. Cao, Z. Gu, and C. Zhu. [13] Y. Hu, Y. Koren, and C. Volinsky. Collaborative [14] M. I. Jordan, Z. Ghahramani, T. Jaakkola, and L. K. [15] N. Kalchbrenner, E. Grefenstette, and P. Blunsom. A [16] A. Krizhevsky, I. Sutskever, and G. E. Hinton. [17] K. Lang. Newsweeder: Learning to filter netnews. In [18] W.-J. Li, D.-Y. Yeung, and Z. Zhang. Generalized [19] D. J. C. MacKay. A practical Bayesian framework for [20] T. Mikolov, I. Sutskever, K. Chen, G. S. Corrado, and [21] A. V. D. Oord, S. Dieleman, and B. Schrauwen. Deep [22] S. Purushotham, Y. Liu, and C.-C. J. Kuo.
 [23] S. Rendle, C. Freudenthaler, Z. Gantner, and [24] T. N. Sainath, B. Kingsbury, V. Sindhwani, E. Arisoy, [25] R. Salakhutdinov and G. E. Hinton. Deep Boltzmann [26] R. Salakhutdinov and G. E. Hinton. Semantic hashing. [27] R. Salakhutdinov and A. Mnih. Probabilistic matrix [28] R. Salakhutdinov, A. Mnih, and G. E. Hinton.
 [29] S. G. Sevil, O. Kucuktunc, P. Duygulu, and F. Can. [30] A. P. Singh and G. J. Gordon. Relational learning via [31] R. S. Strichartz. A Guide to Distribution Theory and [32] P. Vincent, H. Larochelle, I. Lajoie, Y. Bengio, and [33] S. Wager, S. Wang, and P. Liang. Dropout training as [34] C. Wang and D. M. Blei. Collaborative topic modeling [35] H. Wang, B. Chen, and W.-J. Li. Collaborative topic [36] H. Wang and W. Li. Relational collaborative topic [37] H. Wang, X. Shi, and D. Yeung. Relational stacked [38] N. Wang and D.-Y. Yeung. Learning a deep compact [39] X. Wang and Y. Wang. Improving content-based and [40] W. Zhang, H. Sun, X. Liu, and X. Guo. Temporal [41] K. Zhou and H. Zha. Learning binary codes for
For completeness we also derive a sampling-based algo-rithm for the Bayesian treatment of CDL. It turns out to be a Bayesian and generalized version of the well-known back-propagation (BP) learning algorithm. Due to space constraints we only list the results here without detailed derivation.

For W +: We denote the concatenation of W l,  X  n and b l as W is denoted as X + l,j  X  . The subscripts of I are ignored. Then
For X l,j  X  ( l 6 = L/ 2 ) : Similarly, we denote the concatena-tion of W l and b l as W + l and have Note that for the last layer ( l = L ) the second Gaussian
For X l,j  X  ( l = L/ 2 ) : Similarly, we have
For v j : The posterior p ( v j | X L/ 2 ,j  X  , R  X  j , C
For u i : The posterior p ( u i | R i  X  , V , X  u , C i  X  Interestingly, if  X  s goes to infinity and adaptive rejection Metropolis sampling (which involves using the gradients of the objective function to approximate the proposal distri-bution) is used, the sampling for W + turns out to be a Bayesian generalized version of BP. Specifically, as Figure 7 shows, after getting the gradient of the loss function at one point (the red dashed line on the left), the next sample would be drawn in the region under that line, which is equivalent to a probabilistic version of BP. If a sample is above the curve of the loss function, a new tangent line (the black dashed line on the right) would be added to better approx-imate the distribution corresponding to the loss function. After that, samples would be drawn from the region under both lines. During the sampling, besides searching for lo-cal optima using the gradients (MAP), the algorithm also takes the variance into consideration. That is why we call it Bayesian generalized back-propagation.
