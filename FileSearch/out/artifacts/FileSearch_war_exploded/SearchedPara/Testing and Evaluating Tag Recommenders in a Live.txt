 The challenge to provide tag recommendations for collabo-rative tagging systems has attracted quite some attention of researchers lately. However, most research focused on the evaluation and development of appropriate methods rather than tackling the practical challenges of how to integrate recommendation methods into real tagging systems, record and evaluate their performance.

In this paper we describe the tag recommendation frame-work we developed for our social bookmark and publication sharing system BibSonomy. With the intention to develop, test, and evaluate recommendation algorithms and support-ing cooperation with researchers, we designed the framework to be easily extensible, open for a variety of methods, and usable independent from BibSonomy. Furthermore, this pa-per presents a first evaluation of two exemplarily deployed recommendation methods.
 H.3.5 [ Information Systems ]: Online Information Ser-vices X  Web-based services ; H.2.8 [ Information Systems ]: Database Applications X  Data Mining Design, Experimentation, Measurement Tag Recommender, Social Bookmarking, Framework
Collaborative tagging systems are web based systems that allow users to assign keywords  X  so called tags  X  to arbitrary resources. Tags are used for navigation, finding resources and serendipitous browsing and thus provide an immediate benefit for users. These systems usually include tag recom-mendation mechanisms easing the process of finding good tags for annotating a resource. Recommending tags can serve various purposes, such as: increasing the chances of getting a resource annotated, reminding a user what a re-source is about and consolidating the vocabulary across the users. Furthermore, as Sood et al. [9] point out, tag recom-mendations  X  X undame ntally change the tagging process from generation to recognition X  which requires less cognitive effort and time.

Our contributions with this paper are: (i) presenting and evaluating a tag recommendation framework deployed in BibSonomy, an open collaborative tagging system, (ii) pro-viding researchers a testbed to test and evaluate their meth-ods in a live system, and (iii) showing first results which indicate that the framework canbeusedtoimproverecom-mendation performance, e. g., by clever selection strategies.
As foundation and testbed for our framework we use our social bookmark and publication sharing system BibSon-omy [5]. Users of BibSonomy can organize their bookmarks and publication references by annotating them with tags. Plenty of features support them in their work: groups, tag editors, relations, various import and export options, etc. In particular, a REST-like API 1 eases programmatic inter-action with BibSonomy and is the cornerstone of external cooperation with the presented tag recommendation frame-work. Technically, BibSonomy is based on several Java mod-ules 2 which are merged in a Java Servlet/ServerPages based web application with an SQL database as backend.

The datastructure underlying most collaborative tagging systems is called folksonomy . It describes the assignment of tags by users to resources . Formally, a folksonomy is a tuple F := ( U, T, R, Y )where U , T ,and R are finite sets, whose elements are called users , tags and resources , resp., and is a ternary relation between them, i. e., Y  X  U  X  T  X  R , whose elements are called tag assignments ( tas ). 3
Currently, tag recommendations in BibSonomy appear in two situations: when the user edits a bookmark or publica-tion post. Since the part of the user interface showing rec-ommendations is very similar for both the bookmark posting and the publication posting page, we show in Figure 1 the relevant part of the  X  X ostBookmark X  page only. http://www.bibsonomy.org/help/doc/api.html
Some of them are freely available at http://dev. bibsonomy.org/ .
In the original definition [6], we introduced additionally a subtag/supertag relation, which we omit here. Figure 1: BibSonomy X  X  recommendation interface on the bookmark posting page.

The  X  X ags X  box contains a text input field where the user can enter the (space separated) tags, tags suggested for auto-completion, the tags from the recommender (bold), and the tags from the post the user just copies. To the very right of the recommendation is a small icon depicting the reload button. It allows the user to request a new tag recommen-dation if he is unsatisfied with the one shown or wants to request further tags.

Besides triggering autocompletion with the tabulator key during typing, users can also click on tags with their mouse. They are then added to the input box. When the user copies a resource from another user X  X  post, the tags the other user used to annotate the resource are shown below the recom-mended tags ( X  X ags of copied item X ). They are also regarded for autocompletion.

The tag recommendation task is: Given a resource r and auser u who wants to annotate r , the recommender shall return a set of recommended tags T ( u, r ):= { t 1 ,...,t together with a scoring function f : T ( u, r )  X  [0 , 1] which assigns to each tag a score. 4 The value of k is fixed to 5 throughout this paper.
Although having a different recommendation target (re-sources rather than tags), the REFEREE framework de-scribed by Cosley et al. [4] is most closely related to our work. It provided recommendations for the CiteSeer (for-merly ResearchIndex) digital library. Besides the different recommendation target, the focus of the work is more on the evaluation of several different strategies than on the de-tails of the framework. A powerful, open, and well docu-mented framework for recommendations is the Duine Frame-work 5 developed by Novay. It is based on work by van Set-ten [10] and has a focus on explicit user ratings and non re-occuring items, e. g., like in a movie recommendation sce-nario where one does not recommend movies the user has already seen. This is in contrast to tag recommendations, where re-occuring tags are a crucial requirement of the sys-tem. Similar to what we present in Section 4.2, the frame-work implements various hybrid recommenders (for a survey on hybrid recommender see e. g., [2]).
Although, of course, f also depends on u and r , we will omit those two variables to simplify notation. Since f al-ways appears together with T ( u, r ), it should be clear from context, which f is meant. http://duineframework.org/
The topic of tag recommendations in social bookmark-ing systems has attracted quite a lot of attention in the last years. Most related work describes recommendation approaches which could be used within our framework. The existent approaches usually lay in the collaborative filtering and information retrieval areas [8, 3, 9]. Xu et al. [12] iden-tify properties of good tag recommendations like high cov-erage of multiple facets, high popularity, or least-effort and introduce a collaborative tag suggestion approach. Further examples include Basile et al. [1], suggesting an architecture of an intelligent tag recommender system, and Vojnovic et al. [11], trying to imitate the learning of the true popularity ranking of tags for a given resource during the assignment of tags by users.
Figure 2 gives an overview on the components of BibSon-omy involved in a recommendation process. The web ap-plication receives the user X  X  HTTP request and queries the multiplexer (cf. Sec. 4.4) for a recommendation  X  providing it post information like URL, title, user name, etc.. In addi-tion, click events are logged in a database. The multiplexer then requests the active recommenders to produce recom-mendations and selects one of the results. The suggested tags together with the post are then logged in a database and the selected recommendation is returned to the user.
One central element of the framework is the recommender interface. It specifies which data is passed from a recommen-dation request to one of the i mplemented recommenders and how they shall return their result. The getRecommended-Tags method returns  X  given a po st  X  a sorted set of tags; ad-dRecommendedTags adds to a given (not necessarily empty) collection of tags further tags. Since  X  given a post and an empty collection  X  addRecommendedTags should return the same result as getRecommendedTags , the latter can be im-plemented by delegation to the former. For measuring and thus potentially improving its performance, the final post, as it is stored in the database, is given to the recommender via the setFeedback method. Two further classes augment the interface: The RecommendedTag class basically extends the Tag class as used in the BibSonomy API by adding a floating point score attribute. A corresponding RecommendedTag-Comparator can be used to compare tags, e. g., for sorted sets.

Our implementation is based on Java and all described classes are contained in the module bibsonomy-model ,which is available online as JAR file in a Maven2 repository. 6 ever, implementations are not restricted to Java  X  using the remote recommender (see Sec. 4.3) one can implement a rec-ommender in any language which is then integrated using XML over HTTP requests.
Meta or hybrid recommenders [2] do not generate rec-ommendations on their own but instead call other recom-menders and modify or merge their results. Since they implement the same interface, they can be used like any other recommender. More formally, given n recommenda-tions T 1 ( u, r ) ,...,T n ( u, r ) and corresponding scoring func-tions f 1 ,...,f n , a meta recommender produces a merged recommendation T ( u, r ) with scoring function f .
As an example of a cascade hybrid, the idea behind this recommender is to re-order the tags of one recommenda-tion using scores from anoth er recommendation. More pre-cisely, given recommendations T 1 ( u, r )and T 2 ( u, r )andcor-responding scoring functions f 1 and f 2 , this recommender returns a recommendation T ( u, r ) with scoring function which contains all tags from T 1 which appear in T 2 (with f ( t ):= f 2 ( t )) plus all the remaining tags from T 1 (with lower f but respecting the order induced by f 1 ). If T 1 does not contain enough recommendations, T is filled by the not yet used tags from T 2 ( u, r )  X  again with f being lower than for the already contained tags and respecting the order induced by f 2 .
This weighted hybrid recommender enables merging of recommendations from different sources and weighting of their scores. Given n recommendations T 1 ( u, r ) ,...,T corresponding scoring functions f 1 ,...,f n , and (typically fixed) weights  X  1 ,..., X  n (with merging recommender returns a recommendation T ( u, r ):= S i =1 T i ( u, r ) and a scoring function f ( t ):= (with f i ( t ):=0for t  X  T i ( u, r )).
The remote recommender retrieves recommendations from an arbitrary external service using HTTP requests in REST-based interaction. Therefore, it uses the XML schema of the BibSonomy REST-API. 7 This recommender has three advantages: it allows us to distribute the recommendation work over several machines, it opens the framework to in-clude recommenders from auxilliary partners, and it en-ables programming language independent interaction with the framework.
Our framework X  X  technical core component is the so called multiplexing tag recommender (see Fig. 2). Implementing BibSonomy X  X  tag recommender interface, it provides the web application with tag recommendations, using one of the rec-ommenders available. All recommendation requests and each recommender X  X  corresponding result are logged in a database. http://dev.bibsonomy.org/maven2/org/bibsonomy/ bibsonomy-model/ http://www.bibsonomy.org/help/doc/xmlschema.html For this purpose, every tag recommender is registered dur-ing startup and assigned to a unique identifier. For tech-nical reasons, we differentiate between locally installed and remote recommenders (cf. Sec. 4.3).

Whenever the getRecommendedTags method is invoked, the corresponding recommendation request is delegated to each recommender, spawning se parate threads for each rec-ommender. After a timeout period of 100 ms, one of the collected recommendations is selected, applying a preconfig-ured selection strategy :
For our evaluation process we implemented a  X  sampling with replacement  X  strategy, choosing exactly one recommender i and all of its recommended tags T i ( u, r ) together with its scoring function f i . If the user requests tag recommenda-tions more than once (e. g., using the  X  X eload X  button), this process is repeated independently from previous requests.
Here we describe two of the recommenders which are cur-rently active in BibSonomy. The short names in parentheses are for later reference.
We implemented a variant of the most popular  X  -mix rec-ommender described in [7]. The recommender has been im-plemented as a combination of three recommenders, using a value of  X  =0 . 6: a) the most popular tags by resource recom-mender which returns the k tags T 1 ( u, r ) which have been attached to the resource most often, b) the most popular tags by user recommender which returns the k tags T 2 ( u, r i. e., the relative tag frequency), and c) the weighted merging meta recommender described in Section 4.2.2 which merges the tags of the two former recommenders, with weights  X  1  X  =0 . 6and  X  2 =1  X   X  =0 . 4.
This method ranks tags extracted from the resource X  X  ti-tle using the frequency of the tags used by the user. Tech-nically, this is again a combination of three recommenders: a) a simple content based recommender , which extracts k tags T 1 ( u, r ) from the title of a resource, cleans them and checks against a multilingual stopword list, b) the most pop-ular tags by user recommender as described in the previous section  X  here returning all tags T 2 ( u, r ) the user has used (by setting k =  X  ), and c) the first weighted by second meta recommender described in Section 4.2.1 which weights the tags from the content based recommender by the frequency of their usage by the user as given by the second recom-mender.
As performance measures we use precision, recall, and f1-measure (f1m). For each post ( u, T ur ,r )wecomparethe recommended tags T ( u, r ) with the tags T ur the user has finally assigned. Then, precision and recall of a recom-mendation are defined as recall( T ( u, r )) = | T ur  X  T ( u,r ) | values over all posts in the given set and compute the f1-
Before intersecting T ur with T ( u, r ), we clean the tags by ignoring their case and removing all characters which are neither numbers nor letters. Finally, we ignore tags which are  X  X mpty X  after normalization (i. e., they neither contained a letter nor number) or which are equal to the strings im-ported , public , systemimported , nn , systemunfiled .
We store in a database for each recommendation process the corresponding bookmark or B ib T E X entry, each recom-mender X  X  recommendation, as well as the applied selection strategy together with the recommenders and tags selected are stored. Additionally, the user interaction is tracked by logging mouse click events using JavaScript. Each click on one of BibSonomy X  X  web pages is logged using AJAX into a separate logging table. Information like the shown page, the DOM path of the clicked element, the underlying text, etc is stored.
For space reasons we provide only a brief analysis of the framework on data from posting processes between April 8th and May 8th 2009. On ly public posts from users not flagged as spammer were taken into account.

We start with some general numbers: In the analysed period, 4,372 posting processes (2,168 for B ib T E for bookmarks) have been provided with tag recommenda-tions. The MP  X  -mix recommender served recommendations for 2,276 postings, the TbyU recommender for 2,251. In general, the f1-measure is rather low: For the MP  X  -mix rec-ommender it increases from 0.162 for one tag to 0.244 for five tags; for the TbyU recommender from 0.171 to 0.222.
Looking at the influence of the  X  X eload X  button we discov-ered that in 669 (258 bookmark, 411 B ib T E X) of the 4,372 posting processes the users requested to reload the recom-mendation. Thus, in around 15 % of all posting processes users requested another recommendation.

Next we evaluate the data from the log which records when a user clicked on a recommended tag. Evaluation re-vealed, that although clicks are rather sparse (in only 802 of the 4,372 posting processes users clicked on a recommen-dation), a large fraction of correctly recommended tags has been clicked instead of typed.

An investigation of the average f1-measure of each recom-mender shows that the performance for most of the users does not vary much. However, there are users where one of the two recommenders performed better than the other, even for users with higher post counts. Once such a user is identified, one could primarily select recommendations from the user X  X  preferred recommender.
In this paper, we presented the tag recommendation frame-work we developed for BibSonomy. It allows us to not only integrate and judge recommendations from various sources but also to develop clever selection strategies. A strength of the framework is its ability to log all steps of the recommen-dation process and thereby making it traceable. The frame-work will be the cornerstone of this year X  X  ECML PKDD Discovery Challenge, 8 where one task requires the partici-pants to deliver live recommendations for BibSonomy. Acknowledgement. Part of this research was funded by the European Union in the Tagora (FET-IST-034721) project http://www.kde.cs.uni-kassel.de/ws/dc09 and by the DFG in the project  X  X nfo 2.0  X  Informationelle Selbstbestimmung im Web 2.0 X . [1] P. Basile, D. Gendarmi, F. Lanubile, and G. Semeraro. [2] R. Burke. Hybrid recommender systems: Survey and [3] A. Byde, H. Wan, and S. Cayzer. Personalized tag [4] D. Cosley, S. Lawrence, and D. M. Pennock.
 [5] A.Hotho,R.J  X  aschke, C. Schmitz, and G. Stumme. [6] A.Hotho,R.J  X  aschke, C. Schmitz, and G. Stumme. [7] R. J  X  aschke,L.Marinho,A.Hotho, [8] G. Mishne. Autotag: a collaborative approach to [9] S. Sood, S. Owsley, K. Hammond, and L. Birnbaum. [10] M. van Setten. Supporting people in finding [11] M. Vojnovic, J. Cruise, D. Gunawardena, and [12] Z. Xu, Y. Fu, J. Mao, and D. Su. Towards the
