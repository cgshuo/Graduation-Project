 1. Introduction
Content-based image retrieval (CBIR) ( Datta, Joshi, Li, &amp; Wang, 2007 ) systems support a search paradigms that is becom-ing day by day more important. Given an image, used as a query by example, users can ask the CBIR system for identifying a given number of images that are the most similar to the query by comparing their visual contents. More specifically, this content-based similarity search is realized in terms of k nearest neighbors (kNN) queries that exploit an appropriate distance measure, defined over the vectors of visual features extracted from each image.

Indeed, such search paradigm fits not only digital images, but also other data types, such as audio-videos, bio-medical data, financial data, and many other scientific data. They constitute the largest fraction of data produced daily in the e-society. All these dominant data sets can be represented in feature spaces that are inherently multi-dimensional. Providing an effective and efficient way to search such multi-dimensional data sets is very challenging. This is not only due to the curse of dimensionality of the visual feature spaces used to represent images, but also to the colossal size of multimedia data over  X  which such content-based search paradigm could be applied. Just to mention some numbers about the hugeness of such data sets, we can refer to a report by an EMC-sponsored research team of International Data Corporation (IDC). This report states that about 281 exabytes (281 billion gigabytes) of digital data were available in the world in 2007, and that by 2011 the aggregate amount of digital data will reach about 1.8 zettabytes (1800 exabytes) ( John et al., 2008 ). Already in 2008, more than 80% of the size of digital contents was related to images: pictures, surveillance videos, TV streams, and so forth. More-over, if we consider the Web, we know that about 15 billions of images and 220 millions of new photos per week were up-loaded to Facebook in May 2009, and about 4 billions of images and 100 millions of new photos per month were uploaded to Flickr in October 2009.

In this paper we focus on the general issue of making CBIR systems scalable, and tackle this goal by proposing a novel similarity cache that intercepts the kNN content-based similarity queries directed to a CBIR system. We show that our cache is able to satisfy a large number of these requests, with exact or approximate results. Since a hit on our cache requires a time much shorter than a kNN query on the whole index, the overall query throughput of the CBIR system is remarkably improved.
 Our similarity cache differs from a traditional query result cache (e.g., the one exploited by Web search engines ( Fagni, Perego, Silvestri, &amp; Orlando, 2006 )), and is based on the mathematical foundations of metric spaces ( Ch X vez, Navarro, Baeza-Yates, &amp; Marroqu X n, 2001 ). More specifically, the measurable similarity between the query and the cached objects is exploited for increasing the cache hit rate by allowing approximate cache hits. Besides the traditional exact answers, which occur when the same image query has been submitted in the past and its result set has not yet evicted from the cache, our cache can also return approximate answers. To this end, we exploit the cached visual features of the images belonging to the result sets of previous queries, and use them to identify the associated images that are closest to the query. Obviously, the effectiveness of our similarity cache approach cannot be evaluated in terms of the usual hit ratio only. So in our tests we also considered the quality of the approximate results returned by the cache to show the effec-tiveness of our approach.

It is worth remarking that, given a query q , when the result set returned by the cache is the same as the one retrieved in the past by the back-end for the same query q , we consider it as an exact hit. Obviously, the CBIR back-end can in turn exploit any query answering approach and return either exact or approximate kNN results sets. In the last case also a cache exact hit actually returns an approximate kNN result. Our similarity cache is thus a general approach to improve CBIR throughput since it can improve the response time of any exact or approximate CBIR back-end.

In Falchi, Lucchese, Orlando, Perego, and Rabitti (2009) we investigated an important characteristic of our similarity cache for CBIR systems: its robustness with respect to the near-duplicate images. A popular image has in fact thousands of slightly different versions in the Web. In case of near-duplicate queries, that are variants of previously cached queries, our similarity cache can return high-quality answers, namely approximate hits, without querying the CBIR back-end.

The experimental setting exploited for testing and evaluating our similarity cache is unique in the panorama of multime-Layout, Edge Histogram, Homogeneous Texture ) of a collection of 100 millions of Flickr photos. The set of visual descriptors associated with this image collection is publicly available for research purposes ( CoPhIR : Content-based Photo Image Retrie-external images  X  i.e. images belonging to the indexed CoPhIR collection or uploaded by the user.

We analyzed a log of the queries submitted to MUFIN CBIR system between March 20th and October 28th, 2009, with the aim of devising common patterns of user behaviors that can be exploited to better understand user desiderata, improve the design of a large-scale CBIR system and its caching system, and tune its performance. To the best of our knowledge, no sim-ilar analysis was conducted before on such kind of query logs. Even if this query log is not huge if compared to the size of commonly studied query logs of Web Search engines, it can be considered representative of Web user behavior. The log in fact records 65,063 queries issued during 5004 sessions by 3390 distinct users. We experimentally show that the distribution mitted by the same and different users during their search sessions, so that the distribution of the popularity of such results is highly skewed. Moreover, we mined from the log of the MUFIN system providing the novel content-based similarity search paradigm, the most common behaviors of users, and measured their preferences for using similarity and/or text queries.
Moreover, we exploited the large experimental setting illustrated above, the MUFFIN query log and the CoPhIR collection, Top -200 exact closest results present in the CoPhIR collection, and used them as a sort of ground truth to estimate the quality of the approximate results returned by our cache, and thus to evaluate the actual benefits of using the cache in terms of improved query throughput and approximation error. It is worth mentioning that the preliminary conclusions reported in Falchi, Lucchese, Orlando, Perego, and Rabitti (2008), Falchi et al. (2009) , where we exploited a synthetic query log and a smaller image database, were not only confirmed but made remarkably stronger: our caching strategy behaves much better with a larger database and a real-life query log.
The rest of the paper is organized as follows. Section 2 reviews related work, while Section 3 discusses the results of the analysis conducted on the query log recording the content-based similarity queries issued by Web users to the MUFIN Image
Search system. In Section 4 the issues related to caching the results of similarity search queries are outlined, and the frame-work for evaluating the efficiency and effectiveness is presented. Section 5 describes experimental settings, and reports on the results of the experiments conducted. Finally, Section 6 draws some conclusions. 2. Related work
There are three main research topics that are related to our work. The first is concerned with WSE query log analysis and the methods for caching query results. Another is concerned with approximate search in metric spaces and the metrics for measuring effectiveness of such methods. Finally, independent of our work, another notion of similarity cache has been re-cently introduced. The problem as been designed and studied in a completely different context, in particular as a method to make faster contextual advertising systems.

Query result caching. Query logs constitute the most valuable source of information for evaluating the effectiveness of caching systems storing the results of past WSE queries. Many studies confirmed that users share the same query topics analyzed the design and the management of such server-side caches, and reported about their performance ( Markatos, 2001; Lempel &amp; Moran, 2003; Fagni et al., 2006; Baeza-Yates et al., 2008 ). Lempel and Moran proposed PDC (Probabilistic Driven that can be submitted to a search engine ( Lempel &amp; Moran, 2003 ). PDC uses a combination of a SLRU cache (for queries regarding the first page of results), and a heap for storing answers of queries requesting pages next to the first. Priorities are computed on the basis of historical data. PDC performance measured on a query log of AltaVista was very promising (up to 53.5% of hit ratio with a cache of 256,000 elements and 10 pages prefetched).

Fagni et al. showed that combining static and dynamic caching policies together with an adaptive prefetching policy to static caching along with prefetching obtains the best hit ratio. They also showed the impact of having a static portion of the cache on a multithreaded caching system. Through a simulation of the caching operations they showed that, due to the lower contention, the throughput of the caching system can be doubled by statically fixing a half of the cache entries. This behavior was confirmed also in Baeza-Yates et al. (2008) were the impact of different approaches, such as static vs. dynamic caching, and caching query results vs. caching posting lists was studied.

To the best of our knowledge this is the first paper that analyzes the query log recorded by a CBIR system. Even if the dimension and the characteristics of the query log analyzed do not allow too strong conclusion to be drawn, we can claim that a good level of locality and self-similarity among the submitted queries can be found even in a stream of content-based image searches. Moreover, caching the results of user queries in this case has the interesting opportunity of exploiting these self-similarities with the aim of retrieving from the cache also high-quality approximate answers.

Approximate search in metric spaces. Similarity search, in particular in metric spaces, has been extensively studied in &amp; Savino, 2008; Esuli, 2009; Gennaro, Amato, Bolettieri, &amp; Savino, 2010 ).
 Several approximate techniques have been studied to improve efficiency at the price of obtaining approximate result sets.
A general justification for the use of approximation is given by the fact that similarity measures are indeed an approximation of user perception.

As suggested in Ferhatosmanoglu, Tuncel, and Agrawal (2001) , approaches to approximate similarity search can be broadly classified into two categories: approaches that exploit transformations of the metric space , and approaches that reduce the subset of data to be examined . In the transformation approaches, approximation is achieved by changing the object rep-resentation and/or distance function with the objective of reducing search costs. The second category of approaches is based on reducing the amount of data examined. To this aim, two basic strategies are used: early termination , and relaxed branching strategies, where the first stops the similarity search algorithm before its  X  X  X recise X  X  end, while the second avoids accessing data regions that are not likely to contain close objects. A survey of approximate similarity search techniques up to 2006 can be found in Zezula et al. (2006) .

Recently, some approximate systems belonging to the family of permutation-based indexes have been proposed ( Amato 2008 ), PP-Index ( Esuli, 2009 ) and the Lucene based approach proposed in Gennaro et al. (2010) have also be used to effi-ciently index the same collection of 100M images for approximate CBIR using a central server. Finally, in Novak and Batko (2009) a novel indexing and searching mechanism called M-Index that employs most of the principles of metric space par-titioning, pruning and filtering is presented. It enables approximate search indexing the data in well-established structures such as the B+-tree or even in a distributed storage. Metric Index has been used to build the MUFIN image search system ( Batko et al., 2009; Novak &amp; Batko, 2009 ). MUFIN is the most scalable academic CBIR prototype supporting a comprehensive content-based similarity search service on visual descriptors.

In this paper we study how a cache, storing content-based similarity queries and associated results, can be used to return approximate answers with acceptable quality guarantee, even when an exact image match is not found in the cache. Thus, our proposal introduces a novel class of approximation techniques, based on reusing the results of previously submitted queries.

Similarity cache. Recently, and independently of our work, the authors of Chierichetti, Kumar, and Vassilvitskii (2009) discussed a concept of similarity caching, which appears to be very close to our work. In a later work, they also applied the idea of similarity caching to Web advertising ( Pandey et al., 2009 ). The context of application is however very different, since the authors aim to exploit similarity caching to make faster contextual advertising systems. In addition, there are sev-eral other differences with respect to our work, concerning the way the cache is maintained, and how the cache is queried to determine whether a cache hit or miss occurs.

In case of a miss, the feature vector of the query q (the authors call this query a key , that may correspond to a page visited by a user) is used to perform a kNN query on a disk-based database aimed at retrieving a much larger number of results than those actually needed. The query thus returns a large set of k relevant advertisement candidates close to q . The authors call this set of candidates the value associated with the key , and store the pair (key, value) in the cache. In the experiments they fixed k = 1000, while the final advertisement  X  X  X election X  X  involves choosing a few relevant advertisements among the k neigh-bors of q stored in the cache.

The main novelty of this similarity caching proposal, which to some extent is common to ours, is the cache look-up strat-egy. It may also be approximate, by exploiting query similarity. Due the large set of advertisement candidates stored in the cache for each past query, given an incoming query q , the approximate cache look-up only aims at finding the cached query p that is the most similar to q . A similarity threshold is set to decide when p can be considered a good approximation, and thus corresponds to a cache hit. The retrieved data is the value associated with p , i.e. the k neighbor advertisements, over which the final selection is carried out.

Storing a large number of result for each cached query may improve the quality of  X  X  X pproximate hits X  X , but affects signif-icantly the memory footprint of the algorithm. The cache look-up method we propose here is more complex, since it con-siders not only one, but the h cached queries close to q . This allows us to store small result sets, providing a fine grained coverage of the database, potentially capable of answering a more diverse set of queries. Also, we exploit the metric prop-erties of the similarity measures to establish some guarantees about the quality of the results retrieved from the cache.
An interesting point in Pandey et al. (2009) is the way the cache content is managed. In particular, cache lines are evicted not only as a consequence of a cache miss. Indeed, the history of the queries answered by each cache line is stored. On the basis of this history, a cache line can be replaced also as a consequence of an approximate cache hit, with the aim of improv-ing the quality of future approximate cache hits. On the other hand, in the design of our metric cache we adapted the classic LRU cache replacement policy: we mark as the most recently used the cache line that contains the past query that mostly contributes to an approximate answer to a given query.

D-cache, a main-memory structure that keeps track of distances computed for answering the queries received so far with-in the runtime session was proposed in Skopal and Bustos (2009) . Our proposed cache is a higher-level concept that can be combined with any solution employed in a content-based retrieval system. Nevertheless, the two approaches can coexist in the same system by putting our caching module in front of a D-cache-enhanced metric access structure. 3. The CBIR system query log
Although there exist several CBIR prototypes, 3 no log of content-based similarity queries is publicly available. Recently, both Google and Microsoft Bing introduced some limited possibilities for content-based search within their popular image search services. However, no study on the use of such services is available yet.
 We had access to the query log recorded by the MUFIN image search system ( Novak &amp; Batko, 2009; Batko et al., 2009 ). MUFIN is the most scalable academic CBIR prototype, and supports a comprehensive content-based similarity search service on the MPEG-7 visual descriptors of the CoPhIR collection. Indeed, CoPhIR is the largest publicly available collection of meta-Edge Histogram, Homogeneous Texture ), and other textual information (title, tags, comments, etc.) associated with more than 100 million of photos stored on the Flickr photo-sharing website.

Besides content-based similarity, MUFIN Image Search also permits textual queries, which are simply forwarded to Flickr for retrieving a set of relevant photos according to the associated tag metadata. As regards similarity queries, any image in a MUFIN result page can be used to issue a new query by example by simply clicking on it. A user can start search from the home page of MUFIN, which visualizes a set of randomly chosen images from the CoPhIR dataset, or can use a Firefox brow-ser plugin which allows any image displayed on a web page to be used to submit a similarity query over the CoPhIR collec-tion. This is an interesting use of the system: while browsing the Web, a user likes a visualized image and searches the MUFIN index for similar ones.

The MUFIN system is quite popular in the Czech Republic, because its launch as an image search service was covered by a public TV channel. We had access to a query log storing the queries issued to MUFIN between March 20th and October 28th, 2009. The log records 65,063 queries issued during 5004 sessions by 3390 distinct Web users. Even if this query log is not huge when compared to the size of a query log of a commercial Web search engine, to some extent we believe that it can be considered representative of the behavior of Web users coming into contact with a novel search paradigm, where text-based and content-based queries can easily be interleaved.

User Sessions. Splitting the sequence of all the queries submitted by a given user into sessions , i.e., subsequences of some-ner, 2008 ). Indeed, we reconstructed user sessions from the MUFIN query log in a simple way. By using IP addresses we preliminary identified all the queries coming from the same user. The queries of each user were then sorted chronologically by timestamp, and each one of this sequences split to create the user sessions. A splitting point occurs when two consecutive queries are temporally far away, i.e., theirs distance is more than 30 min.

Unlike other approaches, we do not represent a user session as a simple sequence, but rather as a tree of queries. In fact, the log contains information about the navigational behavior of users. For example, a user who, during her session, goes back to a previously evaluated result page, and uses any result object to issue a new query. This behavior is quite common in the query log analyzed and may generate possibly complex trees of queries. Whenever possible, we used the HTTP referrer infor-mation to reconstruct the actual user behavior. Otherwise, we simply considered two consecutive queries in a session as linked.

Table 1 reports some statistics about the 5004 user sessions obtained from the query log. In particular, the first row of the table reports the minimum, average, and maximum number of queries per user session. It is interesting to note that the aver-age length of user sessions in our log is much longer than whose measured on Web search engines query logs (usually only a ferent search tools. Moreover, the second row of the table refers to the out-degree of internal nodes of session trees. Note that the average out-degree of internal nodes is 1.19, indicating that returning back to a previously retrieved set of results for submitting another query is quite common. For the same reason, the average depth of the session trees (9.44) is remark-ably smaller of the average number of queries issued per session (13.00).

Since our query log record both text-and content-based queries, we assigned Txt and Sim labels to differentiate among them. The latter category contains queries generated by clicking on either an image displayed as a result of a previous query, or images taken from the Web through the browser plugin, or images displayed on the MUFIN home page that shows some randomly chosen pictures of the CoPhIR collection. The queries labeled with Sim are 38,727 (79.16% of the total), while 10,197 are the Txt queries (20.84%). About 15% of the Sim queries were submitted through the browser plug-in.
Table 2 reports the frequencies of the various transitions/arcs among node types present in the user tree sessions. Note that the total number of transitions to nodes of type A is different from the total number of nodes labeled A , because a node can have multiple outgoing edges as discussed above, or a user can end her session. For example, the total number of links from Sim nodes to Sim/Txt nodes are less than the total number of Sim nodes (38,727). In this case, the small number of out-going edges suggests that the user is likely to end her session after having seen the result of a similarity query. Also, we can
Table 3 reports statistics on chain patterns mined from the log. Given a session tree, a chain pattern consists of a path of parent-child relationships between nodes of the same type. We report the absolute amounts of the chains having a length of up to 15 nodes, but also the conditional probability of issuing the i th query given that a chain of length i 1 has been issued. a 70% conditional probability that the user will issue another Sim query in the same session. This probability tends to in-crease with the length of the chain.

In the log we found 5560 Sim chains having length 15. If we consider that there are only 101 textual chains of the same length, we can assert that the easiness of query reformulation and specification is much higher for the similarity search paradigm, than in traditional textual search.

In Table 4 , we report the number of stars patterns present in the log. For stars pattern we intend a set of nodes of a given type having the same parent of a possibly different type. This kind of patterns corresponds to a node that originates different searches of the same type. The most common star pattern, when considering up to five children, has both root and child-nodes labelled as Sim , even though the conditional probability of observing a second or a third child are rather small, respec-tively 12% and 3%. An interesting pattern found in the log is given by a Txt root node followed by Sim children. This pattern indicates a quite common behavior: a users who exploits the image result of a textual query forwarded to Flickr to start one or more similarity search queries over the MUFIN index. If a Txt node has one child, the probability of having a second or a third child are quite larger than before, respectively 31% and 14%.
 Ground truth. Most of the 38,727 Sim queries contained in the query log use images taken from the CoPhIR collection. For these images, we have the associated visual features, on whose knowledge we base the implementation of our simi-larity cache. The remaining Sim queries were instead submitted by using images taken from some Web page. Unfortu-nately, even if the log stores the URL of these images, 415 of them are not today available for downloading. Since we need to access them to extract the associated visual features, we were forced to remove these queries from the log. The cleaned query log still contains 30,514 distinct query objects, accounting for a total of 38,312 similarity queries. In order to analyze the level of sharing of images returned for user queries, and for establishing the ground truth necessary to mea-sure approximation errors deriving from our caching approach, we computed, for each similarity query present in the query log, the Top-200 exact closest results present in the 100 M images CoPhIR collection. Building such ground truth is not trivial: a brute force approach would require to compute about 3 10 12 distances! Moreover, centralized metric data structures cannot help since they does not scale to such a large number of objects. Thus, we addressed this scalability issue by extensively using optimized pivoted filtering techniques for speeding-up the computation ( Bustos, Navarro, &amp; Ch X vez, 2003 ). Considering that we have to perform a large number of kNN operations on the same objects from the CoPhIR col-lection, we can in fact exploit the knowledge of the already computed distances between the current object and some que-ries to devise a lower bound to the distance between the current object and the current query. The above solution resulted very effective and allowed us to save more than 80% of distance computations in building our ground truth knowledge-base containing the Top-200 exact closest results present in the CoPhIR collection for all the distinct queries recorded in the log.

Query Locality. The most important aspect to be evaluated for the design of an effective query caching strategy is the presence of locality in users queries. In particular, query caching takes advantage of temporal locality, which occurs when the same queries are issued by many users in small temporal intervals. Indeed, it is well-known that the topic popularity in text queries submitted to Web search engines is highly skewed, and even with a small cache we can obtain a significant hit ratio ( Fagni et al., 2006 ). In the following, we investigate this skewness property in the context of similarity content-based queries. In particular, we focus on the Sim queries present in our query log. As above mentioned, the cleaned query log contains 38,312 similarity queries, 30,514 of which are distinct. These figures already give some idea of the potential ben-efits deriving from caching. The maximum hit ratio achievable on this query stream with a traditional cache would be equal to (38,312 X 30,514)/38,312 0.20. Once more we can note that the locality present in the query log of text-based Web search engines is remarkably higher. For example, the maximum hit ratio measured on a AltaVista query log studied in Fagni et al. (2006) is 0.57.
 To confirm this assertion, one of the curves of Fig. 1 a, labeled with Sim Thr = 0, shows the distribution of popularity of the Sim queries corresponding to distinct images. The queries are sorted by descending frequency. This distribution has a very little skew: the most frequent query image occurs in the log only 49 times! The highly skewed distribution of query topic popularity observed in the logs of textual Web search engines is very far from this figure. The high dimensionality of sim-ilarity queries, and the very sparse query space lead to a limited effectiveness of any traditional caching approach based on exact matches only.

On the other hand, the presence of near-duplicates and/or very similar images on the Web may induce a more complex form of locality in similarity image queries. To investigate the presence of self-similarity among the queries in our log, we clustered them using a centroid-based algorithm. The algorithm aims to cluster together images that are similar one to each other, up to a fixed small similarity threshold. The queries in a cluster likely share something in their result sets, and our similarity cache may exploit this property. Fig. 1 a shows that, as the similarity threshold increases ( Sim Thr ranging from 0.2 to 0.5), also the skewness of popularity distribution increased.

A complementary analysis was conducted on the result sets of the log queries. Note that the result sets depends on the indexed collection, and for this analysis we used the previously discussed ground truth built over the CoPhIR collection, i.e., ciated with the various queries. Also these images were sorted in descending frequency order. Note the high skewness of this curve, with an exponent a of the fitting power law distribution equal to 0.49, thus confirming our intuition about the sharing of the results among the content-based queries. Finally, Fig. 1 c further corroborates this intuition. Suppose we store in a cache a fraction of the distinct images returned as result for the logged queries. Obviously, we start filling the cache with the most popular images. Then we measure the percentage of all the image results that can be retrieved from the cache, as a function of its size. From Fig. 1 c we can see that 1% of most popular images counts for about 15% of all the images re-trieved for answering all the similarity queries present in the log.

Such large level of sharing of a small portion of the images in the collection is a worthwhile opportunity for caching result objects, that strongly motivate our similarity caching strategy. 4. Caching content-based query results
Let C be our similarity cache hosted on the front-end of a large-scale CBIR system, which stores recently or/and frequently submitted queries and associated results (see Fig. 2 ). In order to compute the similarity between the cache content and the query, our method needs to keep in cache not only the identifiers of the results returned for a cached query, but also the fea-tures (e.g., the MPEG-7 visual descriptors) associated with them. As a consequence, look-up, update, eviction, and insertion operations on such a similarity cache are much more complex than those performed on a simple hash-based cache. However, a hit on the similarity cache is much cheaper to process than a query on the whole index, whose cost grows rapidly with the size of the indexed collection ( Zezula et al., 2006; Weber, Schek, &amp; Blott, 1998 ).
Our similarity cache is based on the mathematical foundations of the metric space , which is a very general and well stud-the features of a pair of images is assumed to be metric. 4.1. Using cache content for approximate answering
Let D be a collection of objects belonging to the universe of valid objects U . Hereinafter we assume that each object o 2U are represented as vectors of F features (i.e., points in a F -dimensional vector space ( Ch X vez et al., 2001 )), over which we define a metric distance function . In this work we assume that this holds for a CBIR system that manages a database D of ob-jects. In CBIR an object is typically a description of the visual content of the images (e.g., color, texture) encoded in one or more features. A CIBR returns the most relevant images to the query by searching for similar features (objects) to the ones obtained from the query image. The relevance of the results are computed in terms of a metric distance between pairs of objects, i.e. the extracted features. In our experiments we used the MPEG-7 visual descriptors ( Salembier &amp; Sikora, 2002; Bolettieri et al., 2009 ) as features.

More formally, let d be a metric distance, d : UU) R , which measures the dissimilarity between the vector represen-tations of a pair of objects of U . Thus, the following properties ( Ch X vez et al., 2001 ) hold:
There are basically two types of queries of interest in this metric space that can be used to retrieve from D the most sim-ilar objects to a given query element/example q 2U . The these queries are range queries , and k nearest neighbors queries (kNN queries).
 Definition 1. [Range query] A range query returns all the objects in D at distance at most r from a given query object q 2U . nearest neighbors in D . More formally, $ r q such that 8 x 2 kNN D  X  q ; k  X  , we have that d ( q , x ) 6 r q .
Since a CBIR system is usually asked to retrieve the Top@k relevant images to a given query example q , in the following we will assume that a kNN queries (for some fixed k ) is exploited.

Our cache C stores a set of past queries and associated results. Therefore, when we say that q i 2C , we actually mean that C while a query q i may not. Users can in fact submit any image as query example to the CBIR system. Moreover, the same ob-ject o 2D can be shared by several result sets kNN D  X  q i ; k  X  stored in C , and thus if o 2C , then it may belong to any set kNN D  X  q i ; k  X  associated with a cached query q i .

Let us now consider a query q arriving to the CBIR system. The look-up of C can result in two possible cache hits (besides obviously a cache miss ): exact hit : if another occurrence of q was previously submitted, and still not evicted from C , then its exact k results in kNN D  X  q ; k  X  are known, and can be immediately returned to the user. approximate similarity hit :if q is not currently present in C , but some similar queries were previously seen, we are inter-ested in understanding whether the cached objects could be used to return some  X  X  X pproximate X  X  results for kNN D  X  q ; k  X  .A cache hit occurs if the quality of such results is good enough, otherwise we have a miss.

Before discussing our algorithm to manage the cache, we formalize the problem, and discuss some theoretical results that can be used to evaluate the quality of an approximate similarity hit.
 lowing theorem and corollary hold.
 Theorem 1. Given a query q, and a previously submitted query q i 2C such that d  X  q ; q i  X  &lt; r q i , let be the safe radius of q with respect to the cached query object q i . The following holds: where k 0  X j R C  X  q ; s q  X  q i  X  X j 6 k.

Proof. Let o be an object in R D  X  q ; s q  X  q i  X  X  . From the triangle inequality property, we can derive that d ( o , q i ) 6
Since d ( o , q ) 6 s q ( q i ), we have that cached result set, then we can conclude that o 2C .

We have proved that o 2 R D  X  q ; s q  X  q i  X  X  implies o 2C , and therefore o 2 R C  X  q ; s q  X  q i  X  X  , i.e. R D  X  q ; s q  X  q definition of kNN, R D  X  q ; s q  X  q i  X  X  X  kNN D  X  q ; k 0  X  . h
Corollary 1. Given a query object q, let be the maximum safe radius of q w.r.t. the current content of cache C . We can exactly solve in C the range query R D  X  q ; s q R  X  q ; s q  X  X  R D  X  q ; s q  X  .
 only using the cached objects. In turn, the result of such range query corresponds to the top k 0 , k 0  X j R C  X  q ; s q  X j X j R nearest neighbors of q in D . These objects can be thus used to build an approximate result set for query q , where k 0 of the objects retrieved from C are exactly the top k 0 results of kNN D  X  q ; k 0  X  .

Fig. 3 shows a simple example with objects and queries in a two-dimensional Euclidean space. Intuitively, every cached plete knowledge of the k 0 , k 0 6 k , nearest neighbors of q . 4.2. The QCache algorithm In a previous work ( Falchi et al., 2008 ) we introduced two different algorithms, RCache (Result Cache) and QCache (Query Cache), which exploit the above Theorem and Corollary to manage a similarity cache C . Since QCache resulted to be more efficient than RCache , whereas the quality of the returned approximate results were comparable, in this paper we focus on QCache and discuss some further improvements to the adopted similarity caching algorithm.

QCache adopts a traditional hash table used to detect whether an incoming query was already seen in the past and not evicted from the cache. If an exact hit occurs, the associated results can be soon returned to the user. Otherwise, even if the submitted query was never seen before, QCache can still provide an approximate result set from C , without querying the CBIR back-end. In addition, it is possible to guarantee the quality of the returned objects. In summary, QCache : in addition to exact hits, is able to answer with approximate similarity hits, thus improving the overall hit ratio and thus increasing the CBIR system throughput; evaluates and guarantees the quality of the approximate results returned to users.

A straightforward way to implement such a similarity cache is to evaluate the distance between a new query q and the q , then the associated results can be retrieved from the cache and returned to the user. The assumption that similar queries have similar results is strongly reasonable under the metric space assumption. Note that, even if q and q i are not very close, this method could also work reasonably if, for each cached query, we store a large set of nearest objects (much more than k ) h most similar queries present in the cache that may answer q with sufficient accuracy. This choice of caching short result lists has some interesting advantages. First, the CBIR back-end is not overloaded with wide , and thus expensive, queries. Sec-ond, this allows to store more queries in the limited-size cache, thus resulting in a larger representativity of D in the cached data.

Hence, when a new query q arrives, and it does not exactly match any past queries, QCache has to perform similarity search over the cache content to choose the h most similar past queries and build the approximate result set. Unfortunately, similarity search is computationally expensive, and searching over all the queries and the associated result objects may im-pact negatively on the efficiency of the cache. We overcome this issue by exploiting a metric data structure 5 for indexing the quently, also the time for searching over the similarity index is significantly improved.
 detailed the knowledge about the portion of space surrounding q and the probability of providing high-quality approximate results are. Unfortunately, when the value of h is increased, also the cost of building R q ; k increases correspondingly.
However, in order to efficiently build R q ; k , instead of trivially computing h k distances, we exploit a max heap data prune o ij , i.e. to decide that surley o ij R R q ; k without computing the actual distance d ( q , o ij ). Lemma 1. If j d(q i ,o ij ) d(q i ,q) j P d(q,z), then o ij is surely not closer to q than z, i.e. d(o ij ,q) P d(z,q).
Note that, besides d ( q , z ), both d ( q i , o ij ) and d ( q i , q ) are already known, and thus if j d ( q i , o ij ) d ( q clude that o ij R R q ; k . Conversely, if j d ( q i , o ij ) d ( q i , q ) j &lt; d ( q , z ), the actual distance d ( q , o ij we add o ij to R q ; k and update the max heap accordingly.

Once the approximate result set R q ; k has been built, QCache has to asses its quality, thus deciding whether it can be re-turned as a approximate hit. Otherwise a miss occurs, and the CBIR back-end must be queried. To this end, QCache adopts the following two-step heuristic strategy. 1. Safe radius. By using the theoretical results of the previous section, we could consider R q ; k an approximate hit if thus we may not able to compute s q . Fig. 3 shows an example of this case. Suppose that j Q j = h = 1. In order to determine imate hit. However, we experimentally evaluated that only using this technique for assessing the quality of R q ; k is often too conservative. For example, R q ; k very often returns correct objects even when s q 6 0, and thus q is not contained in any of the hyperspheres of the queries in Q . Therefore, rather than considering R q ; k as a miss, we further estimate its quality by using the second heuristic discussed below. 2. Probability distributions of distances from q. Given the closest h queries in Q , we assume that their corresponding results have a similar distribution in this portion of the search space. Therefore, also R q ; k should comply with such distribution in order to be a high-quality result. More formally, let d i j be the distance of the i -th result from its corresponding query q j from N X  l i ; r 2 i  X  , denoted with P ( r i j Q ). The quality of R q ; k can finally be estimated over all the k distances r i function: Thus, QCache has a tuning parameter, i.e. a minimum required goodness threshold that we denote with c . Only if Goodness  X R q ; k j Q  X  &lt; c , we consider R q ; k as a miss, otherwise QCache returns this result set as a approximate hit. follows: where W is a normalizing constant summing up the weights d ( q , q j ) 5 . Similarly for the variance r 2 i .
Finally, it is worth mentioning that the usual update of the cache to implement the LRU replacement policy not only oc-curs for exact hits, but also for approximate hits. Thus, whenever an approximate result set R q ; k is considered of sufficient it is marked as the most recently used in order to procrastinate its eviction from the cache.

Algorithm 1. Algorithm QCache 1: procedure LookUp q , k 2: if q 2H then 3: Results H : get  X  q  X  4: H : move to front  X  q  X  5: else 6: Q kNN M  X  q ; h  X  7: O f o 2 kNN D  X  q j ; k  X j q j 2 Q g 8: R q ; k kNN O  X  q ; k  X  9: ~ q argmax q i 2 Q s q  X  q i  X  10: ~ s q s q  X  ~ q  X  11: if sufficientQuality ( R q ; k ; ~ s q ) then 12: H : move to front  X  ~ q  X  13: Results R q ; k 14: else 15: Results kNN D  X  q ; k  X  16: H : put  X  q ; Results  X  17: M : put  X  q  X  18: end if 19 end if 20: return Results 21: end procedure
The algorithm .In Algorithm 1 we show the pseudocode of our QCache algorithm. We make use of a hash table H which is used to store and retrieve efficiently queries and their result lists, by using queries as hash keys. Given a new incoming query object q , the first step is to check whether q is present or not in cache (line 2).

If this is not the case, the algorithm tries to use stored results to devise an approximate answer. This step uses the metric index M , which contains only the recent past query objects q i 2C to find the h cached queries that are the closest ones to q (line 6). The resulting set Q is first used to retrieve from the cache all the associated h k results (line 7), and to extract from them only the k closest objects to query q (line 8). Such objects form the approximated result list R q ; k . Then Q , is used to find an approximation ~ s q of the maximum safe radius and the corresponding query ~ q (lines 9 X 10). The safe radius ~ s q is needed to understand which of the top results are guaranteed to be correct according to Theorem 1 .

The expected quality of the approximate answer, considering also the safe radius ~ s q , is then evaluated (line 11). However, ough, we still have an approximate hit. Otherwise, we have a miss, and the query is forwarded to D . Its (exact) results are added into the two indexing structures H and M (lines 15 X 17).

Note that the hash table H is managed with a simple LRU policy. If a new insertion cannot be satisfied because the cache is queries to persist in cache. 5. Results assessment
To the best of our knowledge, this is the first rigorous evaluation in the area of multimedia content-based search involv-ing a real-life query log, generated by the search activity of a large number of users, over a large collection of objects. As discussed in Section 3 , our evaluation is based on a query log of the MUFIN Image Search system, which answers to content-based similarity queries over the CoPhIR collection.

The distance between two images is computed as a weighted sum of the distances between each of the five MPEG-7 descriptors used. These distances were proposed by the MPEG group ( ISO/IEC, 2003; Salembier &amp; Sikora, 2002 ). The distance between two images is thus metric, according to our metric space assumptions. For more details see ( Batko et al., 2009 ).
A total of 38,312 similarity queries, where extracted from the MUFIN query log. Among them, we used the chronologically first 8312 queries to warm-up the cache, and the remaining 30,000 to actually measure the effectiveness of our caching algorithm.

Whenever a cache miss occur, the query q should be forwarded to CBIR back-end to retrieve the k nearest neighbors of q in the CoPhIR collection. Note that, in order to achieve scalability and near real-time responsiveness, the MUFIN system re-turns approximate results. Conversely, for a precise evaluation of the quality of the approximate answers returned by QCache , we preferred to pre-compute the exact results for each query in the log. We called this knowledge the  X  X  X round truth X  X  associated with the query log and the image CoPhIR collection.

Most of the tests were conducted by varying the cache size, ranging from as little as 10 X 500 MB. Note that the size of the five visual features associated with an image is about 1KB. Therefore, a cache being 10MB large can store up to 10,000 ob-jects, both results and queries, and index 10,000/(20 + 1) 476 queries, since we stored 20 results for each cached query. Finally, for each query in the log, the kNN query was issued with parameter k = 20, which is a reasonable number of results for an image search system, and QCache searched for the h = j Q j = 20 closest queries to build the approximate result. We found experimentally that a good minimum goodness threshold is c = 15, this setting was used in all the tests but the ones measuring efficiency and efficacy of QCache as a function of c . 5.1. Cache hit ratios has a remarkably large hit ratio, larger than 40% for the largest cache size experimented. However, even with the smallest cache size of 10MB, QCache achieves a hit ratio slightly larger than the infinite cache hit ratio ( 26%). Note that a 500 MB cache can store just 0.5% of the feature database. Since, on large collections, processing a similarity query via a metric index technique can have an impressive impact on the overall performance of a CBIR system.

Finally, we would like to highlight an interesting trade-off arising when the cache may return approximate answers. In case of a miss, QCache may answer approximately without querying the underlying database. On the one hand, this improves the throughput of the system, since less queries are processed by the slower back-end. On the other hand, if the same query occurs again in the log, the cache will not store the corresponding results, and it will probably answer again approximately. Therefore, approximate hits may reduce the number of exact ones. This explains why the number of exact hits is remarkably smaller of that measured for an infinite cache, even with the largest cache size.
However, the sum of exact and approximate hits succeeds in dramatically breaking the barrier of the infinite cache, allowing to answer even to queries that were never seen before. In the following, we evaluate the quality of such approximate results. 5.2. Approximation quality
We distinguish between ranking-based and distance-based quality measures. The former compare the given approximate latter are based on the distances of the results from the query. Rather than comparing the objects X  positions, these measures take into consideration their distances from the query. Distance-based measures are quite relevant for similarity search, since they allow to measure the quality of approximate results on the basis of their similarity to the query.
In order to assess the efficacy of QCache , we measure the quality of the generated results by considering only the approx-imate hits and not the exact ones. Given an approximate result set R q ; k returned by QCache and the corresponding exact re-sult set kNN D  X  q ; k  X  , we consider the following quality measures:
Distance-based error measures:  X  Relative Error on the Sum of distances (RES):  X  Relative Error on the Maximal distance (REM):
Ranking-based quality measures:  X  Precision (P):  X  Top-K Correctness (TK): RES is basically the well-known total distance ratio used in Tuncel, Ferhatosmanoglu, and Rose (2002) and Ferhatosmanoglu inally proposed in Arya, Mount, Netanyahu, Silverman, and Wu (1998) .

Fig. 4 b plots the values of the average RES and REM error measures on varying the cache size. The plot reports the quality of the approximate results actually returned by the cache, but also of the potential results that could be extracted from QCache and were not returned in case of a cache miss, i.e. when the expected quality of the result set was not considered good enough. The error measured for the misses is always much larger than the one measured for the hit cases, meaning that, on average, the estimate of the results quality was correct. More importantly, both the average and maximum approach 10% for the larger, and more realistic, cache sizes. This shows that approximate results produced by QCache exhibit good quality consistently.

In Fig. 4 c and d we report on Top-K Correctness and Precision. In this case, the impact of cache size is much more appar-ent. The fraction of approximate result lists containing at least 10 correct objects doubles from 20% to 40% when using the largest cache size. However, both Precision and Top-K Correctness witness the goodness of the QCache algorithm. About 90% of the approximate results contain at least three correct objects, and in 1/4th of the cases those three results are exactly the three nearest neighbors. The Top-K Correctness drops more quickly. Still, almost 40% of the approximate results contain at least 10 correct objects. 5.3. Impact of the number h of close cached queries considered ber of approximate hits is very small. A small number of cached queries does not provide a sufficient number of high-quality result objects. When increasing h , the QCache algorithm can choose among a larger number of results, and build a sufficiently good approximate results set. The number h of close queries considered may affect the performance of QCache . However, the increased.

From the figure we can see however that the increase in the number of approximate hits may reduce the number of exact ones. In fact, as above discussed, when a query is answered with an approximate hit, the same is likely to happen for the next occurrences of the same query. This fact could merit further attention. We leave as future work the analysis of this issue, and of effective heuristics aimed at improving selectively the quality of approximation for popular queries. 5.4. Efficiency versus efficacy trade-off
Finally, in Fig. 4 e we analyze the sensitivity of the algorithm to the minimum quality threshold c . Not only the threshold c can be used to tune the quality of the returned approximate results, but it has an important role in the overall performance of 85%. Conversely, with a less strict threshold c = 0, the precision of results drops to about 45%, but the hit ratio measured exceeds the 50% of the queries threshold. Note that the precision reported in this plot includes both exact and approximate hits.

The above numbers are very competitive in the field of CBIR approximate answering. In particular, the precision figures measured on the same dataset for the PP-Index ( Esuli, 2009 ), and MI-File ( Amato &amp; Savino, 2008 ) systems are 65%, and 55% respectively. On the other hand, MUFIN achieves almost 80% precision by exploiting an index distributed over 32 machines working in parallel. The precision of the QCache algorithm (considering both exact and approximate hits) ranges from 45% to nite size. Therefore, we can claim that our cache provides high quality results in the context of CBIR systems, and high hit ratios.

By looking at Fig. 4 e we can see that the value of c drives the tradeoff between hit ratio and the quality of the returned results. It is easy to find a proper value accomplishing the desired quality of results. More interestingly, the threshold could be used dynamically according to some external policy. For instance, in presence of bursts of queries, a less strict threshold would allow to keep up with a large number of users and to reduce to load at the back end of the system. On the other hand, when user load is low, the quality of results returned may be pursued at the cost of an increased load on the CBIR back-end. 6. Conclusions
Starting from the analysis of a query log recording the behavior of Web users experimenting a uncommon paradigm of image search based on image content similarity, we have discussed and evaluated a model for caching query results based on the concept of similarity. Our goal was to show that similarity caching is a viable and effective way to improve efficiency of a large-scale CBIR system processing a realistic workload.

We studied a large log recording the queries issued to the MUFIN Image Search system in a 7-months period. Although its age Web user. From the analysis of the logged user sessions we detected common patterns that highlight differences in the behavior of users of a CBIR and a traditional text-based search engine. In particular we devised a tree model for user sessions, and measured the frequencies of different chain and star patterns appearing in the log, which are motivated by the particular browsing possibilities offered by the user interface of the CBIR system. We also estimated and discussed the distribution of the popularity of the content-based queries present in the log. Unlike keyword-based searches, the analysis showed a limited skewness that prevent a successful exploitation of the query result caching strategies developed for Web search engines. On the other hand, we identified the presence of self-similarities among the user queries, and, more importantly, we demon-strated that the distribution of most frequently relevant images is very skewed. This experimental evidence was possible due to the public availability of the collection indexed, which allowed us to derive the  X  X  X round truth X  X , i.e., the exact set of top-200 results closest to each query image in the log. This evidence strongly motivated the exploitation in a similar set-ting of our novel caching approach, which, unlike traditional caching strategies, may return a set of approximate results also when the submitted query object was never seen in the past, or was previously evicted from the cache. By testing our sim-ilarity cache with the log query stream, we got very high hit ratios and tunable small approximation error figures. As an example, a similarity cache with a size equal to 500 MB obtained a hit ratio equal to 42%, with a precision at 20 of 60%. More-over, the largest contribution to the hit ratios was due to approximate cache answers, once more showing that it is worth pursuing this research direction. Our caching algorithm should not be considered an approximate search technique, but rather an orthogonal approach aiming at improving the response time of any exact or approximate similarity search system.
The generality of metric space, which is the only assumption of our work, makes our contribution even more important, as our similarity cache can be applied at a large variety of application scenarios, such as biology, geography, multimedia, data cleaning and integration, etc.

Future work will regard the application of our similarity caching approach to other areas (e.g. advertisement, video rec-ognition, data cleaning, etc.). Moreover, even if our approach has its mathematical foundation and result quality guarantees on the notion of metric spaces, it would be interesting to investigate its applicability, with possible performance degradation, to similarity search systems in quasi-metric or non-metric feature spaces. Another interesting issue regards investigating the adoption of an incremental caching policy, similar to that proposed in Puppin, Silvestri, Perego, and Baeza-Yates (2010) ,to improve the precision of results returned by the similarity cache for queries having an increasing popularity: when a query resulting in an approximate hit is going to become popular, it may be worthwhile to fill the cache with its precise results in order to improve the quality of results for future occurrences of the same query.
 Acknowledgments
We would like to thank Pavel Zezula and his group at the Masaryk University (Brno, Czech Republic) for making available to us the query log of the MUFIN Image Search system. This work would have not been possible without their contribution.
We acknowledge the partial support of S-CUBE (EU-FP7-215483), ASSETS (CIP-ICT-PSP-250527), and VISITO Tuscany (POR-FESR-63748) projects.
 References
