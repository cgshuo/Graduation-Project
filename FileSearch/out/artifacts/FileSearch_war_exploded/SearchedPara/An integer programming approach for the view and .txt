 1. Introduction corresponding dimensions could be product sold , date and time of sale , customer ,and sales representative . distinct attributes that are stored in a separate dimension table (e.g., attributes of pre-compute and store ( materialize ) auxiliary data, such as views or indexes [14] . collection of queries) while observing a given storage-space limit.
 for the given queries.
 solutions can be extremely large. Note that for a collection of k attributes, we have 2 view v .
 model to manageable levels so that it can be solved using a commercial IP solver (such as CPLEX 10). 1.1. Related work much as it is theoretically possible.
 direction include the work presented in [3] and [21] .
 cannot provide the stated worst-case performance ratios unless P=NP.
 index-maintenance costs alongside query-response costs. The paper proposes to use a views or indexes are eliminated in a greedy manner, until the storage-space constraint is satisfied. are selected iteratively from the initial sets through two greedy algorithms called index spy and view spy. smaller than the case without strong attribute correlations.
 views and indexes simultaneously, and we seek an optimal solution for the combined problem. 2. Preliminaries single fact table and several dimension tables. We consider relational select subset of the collection of attributes in the data warehouse, and vice versa. We have a total of 2 the number of attributes in the data warehouse.
 more manageable, in our study we consider only fat indexes over the view set Studying the types of indexes to which our current solutions can be directly extended is part of our ongoing work. set of attributes in the GROUP BY clause of q and those attributes in the definition, each query q can be answered using the raw-data view in the view set. of attributes in the GROUP BY clause of q and of those attributes in the for that view, and we use the letter q to represent both a query and the collection of attributes in the query plus those attributes in the WHERE clause of the query that are compared with constants.
Example 1. Consider view v ={ a , b , c , d } and queries q attributes that are either in the GROUP BY clause of q 1 , or among those attributes in the constants. Similarly, attributes d and e form the collection of attributes that are either in the attributes in the WHERE clause of q 2 that are compared with constants. Since q q v , view v cannot answer query q 2 . 2.1. Cost model of a view or a portion of a view as the number of rows in that view or in the portion thereof. is equal to the size of view v itself. However, when we answer query q using view v and an index
Suppose A 1 is the set of attributes in the GROUP BY clause of query q , and A constants in the WHERE clause of query q . Also suppose B is the set of grouping attributes of view v . Let view v , i.e., a permutation of attributes in the set B . (Recall that we use the character ( A 1  X  A 2 ) p B .

Let us use the notation c q ( v ,  X  ) to denote the estimated cost of answering query q using view v and its index defined only if view v can be used to answer query q , i.e., if ( A the relationship between its index  X  and the collection of attributes A grouping attributes is identical to the largest subset of A attributes that are compared with constants in the WHERE clause of q , and form a prefix of the following formula to estimate the cost of answering query q using view v and index
Here, size ( v ) represents the size of view v as defined above. which is aggregated on all of the attributes of the database, and define size ( individual queries.
 attributes of the view. Otherwise, we estimate the size of the view by sampling from the raw data. WHERE clause and are compared with constants, whereas the forms a prefix of  X  . With minor modifications, all results that we obtain here are valid without this assumption.
Example 2. Consider a view v ={ a , b , c , d }, an index stated above, a and b are in the WHERE clause of query q and are compared with constants, whereas the empty. In this example we have v  X  ( q )={ a }, and the estimated cost of answering query q using view v and index c v ;  X  2.2. Problem statement is the workload (which is a set of parameterized queries), and b is the storage limit.
De answered using the views in VI , and (2) the set VI satis
De all of the views and indexes in VI .

De fi nition 3. ( OLAP-VI problem) For a given problem input D problem of fi nding an optimal set of views and indexes, as de on D and all additional views that we choose to materialize), a set each element of Q and its corresponding elements of V * and used to answer each query in Q .
 proposed models this assumption can be easily removed. 3. An integer programming model and its properties programming models belong to a larger collection of models known as mathematical programming models. A mathematical model all variables are restricted to integer values.
 small, it is essential to keep the size of the model as small as possible. 3.1. Integer programming model IP1 For a given problem input D ; Q ; b  X  X  , we define the following notation.
V the set of all views in the original search space of views  X  ( v ) the set of all fat indexes of view v ,  X  v  X  V
Q ( v ) the set of all queries in the set Q that can be answered by view v , section and throughout the paper.
 each view v , the cardinality of the corresponding set of (fat) indexes of v ,i.e.,|  X  ( v )|=(| v |)!. For a given view v j we denote its l th index by indexes associated with v j by  X  j . In other words, we use to denote the i th element of the given set of queries Q ,i.e., Q ={ q represent the collection of views each of which can be used to answer query q subscripts, i.e., J i ={ j  X  J : v j  X  V i }.
 for subscript values i =1, 2, ... , m , j  X  J i , and l =1, 2,
The following variables are defined for subscript values j =1,2, model we use the notation c ijl to represent the value c q its index  X  jl , as defined earlier. Correspondingly, we use the notation d using view v j with no indexes. As stated earlier, we have d of rows that we can store. Constraint (5) states that index
Similarly, constraint (6) states that query q i can be answered by view v constraint (7) states that query q i can be answered by view v (8) simply states that the raw-data view is always selected. 3.2. Reducing the size of the IP model
Note that for a database with k dimensions (attributes) the total number of views in the view set is 2 indexes. For an instance of the problem with k attributes and m queries this results in 3.2.1. Reducing the set of views this article. Please see [6] for the details.

Observation 1. Given an instance of the OLAP-VI problem with input D in the set Q , then the problem has an optimal solution that does not include view v.
Observation 2. Given an instance of the OLAP-VI problem with input data D not in any of the queries in Q ( v ), then the problem has an optimal solution that does not include view v. (reduced) set of views as V  X  .
 with r queries (for all 1  X  r  X  Q jj ) and add the resulting view to the set V answer. Note that we always add the raw-data view to the set V O 2
Q jj , while the computational requirement of the second method is of order O Q jj 2 and Q jj , we choose either the first or the second method, whichever results in smaller computational effort. 3.2.2. Reducing the set of indexes identify a relatively small subset of these indexes for inclusion in our model. In particular, for each view v
 X   X  to characterize this restricted collection of indexes  X   X  associated with this view.
 combination of r queries, for r =1,2, ... ,| Q ( v )|, there is a node in digraph G is associated with the view v itself, and the other node represents the empty set an arc from w 1 to w 2 if and only if w 1  X  w 2 and there is no node w single sink v . For a given view v , the total number of nodes in G of nodes in G v may be smaller than this limit.
De fi nition 4. Given a view v and its corresponding digraph G any node w of G v . For a given index  X   X   X  ( v ) we say that in P is a prefix of  X  .

De fi nition 5. Given a view v and its corresponding digraph G a node w s . Suppose the order of the nodes on path P is  X  query q agrees with path P up to node w i if the set of attributes of each of the nodes w attributes of the node w i is not a subset of q .

Lemma 1. Given a view v and its corresponding digraph G v path in G v , then c q ( v ,  X  1 )= c q ( v ,  X  2 ) for every query q
Proof. Let the source-sink path be denoted by P . Consider the relationship between an arbitrary query q q  X  w = w and q  X  z = w . This is because if q has some of the attributes in z nodes w and z . We know that this is not the case, since there is an arc from node z to node w in G  X  same as the largest subset of q that forms a prefix of  X  2
Lemma 2. Given a view v and its corresponding digraph G v digraph G v , then there exists another index  X   X  of view v associated with a source-sink path in G query q  X  Q ( v ).

Proof. Let P (  X  ) be thelongest path of G v that is associated with with any source-sink path of G v , P (  X  ) is not a source-sink path; thus w first r attributes is ( a r +1 , a r +2 , ... , a | v | ). We define the set Q
Q w order of the first r attributes in  X  . We now show that c
Consider any query q a Q ( v ). One of the following cases is true: (1) ( q  X  w )  X  w ;or (2) q = w ;or (3) q  X  w .

If case (1) is true, i.e., q has some (but not all) of the attributes of w ,thenwehave v all of the attributes of w as their prefix in the same order. If case (2) is true, then we clearly have v (3)istrue.If q has all of the attributes in { a r +1 , a r +2 contain a r +1 , then v  X  ( q )= w . Also, we know thatthe order of the first r attributes in does not contain a r +1 then we have v  X   X  q  X  X  t v  X  q  X  X  . Now let us consider the case where q contains a does not include the attribute a h +1 . It follows that q w  X  { a r +1 , a r +2 , ... , a h } p w h .Thus v  X  ( q ) p
P ,alloftheattributesof w h form a prefix of  X   X  .Thus v  X   X 
We conclude that v  X   X  q  X  X  t v  X  q  X  X  for any query q in Q ( v ). Thus we have size ( v for every query q a Q ( v ).  X 
From Lemma 1 it follows that if two indexes of view v are associated with the same source-sink path of digraph G v that is not associated with any source-sink path of digraph G source-sink path of G v and is at least as effective as  X  define the set  X   X  ( v ) for each view v a V  X  .

De fi nition 6. For a given view v construct the corresponding digraph G digraph. For each source-sink path P i obtained in this manner, determine an associated index of all indexes for view v obtained in this manner.
 Following is a small illustrative example.

Example 3. Consider view v ={ a , b , c , d , e , f , g } and suppose Q ( v ) consists of the following queries: q q ={ e , f , g }. Fig. 1 represents digraph G v for v . The source-sink paths in this digraph are as follows: 1. ( X )  X  ( c )  X  ( a , b , c )  X  ( a , b , c , d , e , f , g ) 2. ( X )  X  ( c )  X  ( c , d , e )  X  ( a , b , c , d , e , f , g ) 3. ( X )  X  ( e )  X  ( c , d , e )  X  ( a , b , c , d , e , f , g ) 4. ( X )  X  ( e )  X  ( e , f , g )  X  ( a , b , c , d , e , f , g ) associated with the second, the third, and the fourth path, respectively. Thus, we have:
We note that in this example, |  X   X  ( v )|=4, whereas |  X 
From the above discussion it follows that for each view v and for each query q search space of indexes in the OLAP-VI problem by limiting our search to the smaller collection 3.3. Modi fi ed integer programming model IP2
In this model we use the following notation to represent various restricted subsets of views and indexes and their corresponding collections of subscripts. For each i =1,2, that can be used to answer query q i (where V  X  is as defined in Section 3.2 ), and let J subscripts, i.e., J i  X  ={ j a J : v j a V i  X  }. Also let J represent the restricted collection of its indexes as defined above, and let L i.e., L j  X  ={ l :  X  jl a  X   X  ( v j )}. We can now write the integer programming model IP2 using this notation. The following theorem follows directly from Observations 1 and 2, and Lemmas 1 and 2 .
Theorem 1. Given an OLAP-VI problem with input ( D , Q , b ) , if we define the set V
Definition 6 , then we have the following. corresponding number in model IP1 . This is partly due to the fact that the restricted set of views V than the original set V , and partly due to the smaller number of indexes 3.4. Numeric results 4. An IP-based heuristic method selection problem. In this context, we limit the choice of indexes for each view v of promising alternatives for this view, which we refer to as OLAP-VI problem. In Section 4.1 we discuss an algorithm to obtain the collection present numeric results comparing the size of the reduced IP model with that of the original model. 4.1. Reduced collection of indexes optimal solution of the original OLAP-VI problem. Larger values of N select the value of N v equal to | Q ( v )|. This choice of value for N of indexes for view v at the optimal solution of model IP2 presented in Section 3.2 (note that each query q optimally by view v with at most one index for this view.)
N
We define the reduced collection of indexes  X   X  X  ( v )as{ less than | Q ( v )|, we select all indexes in  X   X  ( v ) for this view.) 4.1.1. Model IPN We define the model IPN similar to model IP2, except that we use the set of indexes model IP2 , the optimal solution of this model is no longer guaranteed to be optimal for the original problem. In the remainder of this section, we present an efficient algorithm to determine the set this algorithm as Algorithm IPNIDX. 4.1.2. Algorithm IPNIDX one index, that is, in the first iteration we find  X  v 1 , in the second iteration we find sink node v , and we declare the corresponding order perm ( v ) as the index selected in this iteration.
At the end of each iteration, we update the value of MCS ( q ) for each q attributes of w , i.e., queries in the set Q  X  ={ q  X  Q temp in w \ u . Thus, we need to find the parent of w that yields the minimum total cost of answering the queries in Q in Q  X  ; thus we can compute cost ( u )=  X  q a Q  X  min { cost ( u , q ), MCS ( q )} for each parent node u of node w .
Given the digraph G v for view v , the computational requirement of Algorithm IPNIDX is O ( N this, note that the while loop of Algorithm IPNIDX is repeated N ( the number of nodes ) 2  X | Q ( v )| times.) 4.2. Numeric results results in Section 5 and in [6] . 5. Experimental results and the quality of the solutions obtained by this model.
 have created using the data in the TPC-H benchmark at  X  scale factor one, mentioned in the schema. (For instance, one of the databases that we created consists of the TPC-H data tables as applicable and report our findings.
 models. 5.1. Data sets b . We used two different databases of the TPC-H benchmark (see [40] ) views in the view set for the scale-one databases used in this experiment. [3,13,16,25] ).
 query as a randomly generated integer ( t ) between 1 and k the collection of attributes for that query. 6 sufficient for storing the raw-data view (which is a required selection). If the view-and index-selection problem to be nontrivial, we need to have 0
In our experiments for each instance we set the value of  X  5.2. Results of instances, we make the following observations:  X   X  that the cost obtained via IPN is at most 4% larger than a corresponding lower bound (i.e., the number of queries). execution time would be excessive.
 result in reasonably good solutions. See [21] for further discussion on this subject. existing view, so as to maximize the resulting immediate  X  with p attributes the corresponding value of m would be 2 17-attribute database and obtained similarly good results within reasonable execution time. 6. Concluding remarks in much less computation time.
 one such approach would be to cluster  X  like  X  queries into one analytic properties and through a computational study. We refer to this metric as the cost [23] . We hope to extend this approach for the view-and index-selection problem in the near future. Acknowledgment improve the presentation of material in this article.

References
