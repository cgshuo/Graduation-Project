 The Information Systems discipline studies different ways in which information can be processed, often algorithmically using process modeling practices. Workflow manage-ment systems, business process management s ystems, and enterprise information sys-tems are examples of Process-Aware Information Systems (PAISs) [1]. PAISs support executions of operational processes on the basis of process models that are usually ex-pressed in languages such as the Web Services Business Process Execution Language (WS-BPEL) or the Business Process Model and Notation (BPMN). For example, Fig. 1 shows a BPMN model that describes various scenarios for handling travel quote requests.
Process models describe vast amounts of executions, or process instances , for han-dling similar scenarios. The number of instances captured in a process model is expo-nential in the number of decisions that one can take when executing the model. This number explodes with respect to the amount of tasks that can be executed simultane-ously in a model. Moreover, a model can describe an infinite number of instances, in case of loops.

As it becomes increasingly common for organizations to adopt the process-oriented approach to model and execute their routines, organizations often end up managing repositories that comprise up to thousands of process models. For example, Suncorp, the Australian insurer, maintains a repository of more than 3,000 models [2,3].
Process model repositories are immense information resources. In order to reduce this information overload , one should be striving for automated retrieval systems. Ac-curate and efficient retrieval of information about process instances that are stored in process model repositories is interesting for several reasons, including:  X  Reuse/redesign. When developing new or modifying existing process models, one  X  Compliance. Process models are subject to constraints enforced by regulations  X  Standardization. Standard process models are exemplar models that should be used For example, an organization can issue a compliance rule which checks that in every travel handling scenario it is never possible that both tasks  X  Get flight prefer-ences  X  X nd X  Adjust flight preferences  X  occur together. This rule can be triggered to avoid internal adjustments of travel pref erences. In this case, the model in Fig. 1 must be retrieved as one that violates the rule. Alternatively, one may want to redesign rou-tines so that every time flight and hotel quotes are processed, there is also an option to propose a quote for renting a car. To implement this intent, one can start by retrieving all models that describe instances in which both tasks  X  Get flight quote  X  X nd X  Get hotel quote  X  occur.

The contribution of this paper is threefold. First, it proposes an index data struc-ture that is tailored towards efficient retrieval of process models based on information about process instances. The index is due to an alternative representation of models, called representative untanglings . The unique characteristics of this index allow for a novel querying experience. Second, it demonstrates this novel querying experience using query primitives that take the form of an extended version of the classical ex-ecutability problem [7], called the total executability problem. Given a model and a set of tasks as input, the total executab ility problem deals with deciding if the model describes at least one instance in which all tasks from the given set occur. Among other applications, a solution to the total executability problem can be used to implement the above illustrated retrieval scen arios. Third, it suggests an efficient solution to the to-tal executability problem using representativ e untanglings. Experi ments with industrial models show up to three orders of magnitude speed up compared to the state of the art.
The rest of the paper is organized as follows: Sect. 2 positions our research in the light of related work. Next, Sect. 3 provides preliminary notions. Sect. 4 describes a novel index data structure. Sect. 5 exemplifies the use of this index for querying process model repositories. Sect. 6 reports on the p erformance measurements of a prototype that implements the developed querying tec hnique. Finally, Sect. 7 concludes the paper. Querying deals with retrieving information that is relevant to a given information need from a collection of information resources . In case of process model querying, informa-tion resources are process models ( structural information ) as well as process instances that these process models describe ( behavioral information ).

There exist various techniques to query process model repositories based on structural information, cf. [2,3,8,9,10]. Given a query specified as a structural pat-tern, or a structural template with wildcards, these techniques are capable of retrieving process models which are formalized as stru ctures that match the pattern, or fit the tem-plate. First, indexing techniques are employed to filter the repository by obtaining a set of candidate models that fit the indexed features of the query. Second, graph isomor-phism or graph-edit distance techniques [11] are applied to identify the models from the candidate set that score an exact match, or are sufficiently similar, to the query. In contrast, we propose a technique that retrieves process models based on behavioral information.

Other techniques retrieve process models based on abstractions of behavioral in-formation, cf. [12,13]. They accept loss of behavioral information, and consequently decrease in precision and recall, as the price fo r efficient retrieval. Our retrieval tech-nique is precise and sensitive , i.e., it always retrieves all and only models that match the query.

Model checking is a technique that can be used to verify various properties of pro-cess models [7]. This technique usually pro ceeds by constructing an alternative repre-sentation of a model and then uses this representation for efficient verification. Model checking can be used to implement precise an d sensitive process model retrieval that is based on behavioral information. Indeed, behavioral information needs can be ex-pressed as properties to be verified. Similar to model checking, our technique makes retrieval decisions based on alternative representations of process models. Unlike in model checking, once constructed, our representations can be reused much more often than those employed for model checking purposes, as model checking usually relies on a fresh artifact for verification of every new property. This reuse of untanglings yields significant performance gains when querying process model repositories. This section introduces formalisms that will be used to support subsequent discussions. 3.1 Petri Nets and Net Systems Petri nets are a well-established formalism for modeling distributed systems, e.g., PAISs. For many high-level process modeling languages, including WS-BPEL and BPMN, there exist mappings to the Petri net formalism [14]. The benefits of such mappings are twofold: (i) rigorous definition of an execu tion semantics of a high-level language, and (ii) reuse of the mathematical theory of Petri nets for analysis of process models. This section introduces the basic Petri net terminology and notations.
 P and T are finite disjoint sets of places and transitions , respectively, and F  X ( P  X  T ) X  ( T  X  P ) is a flow relation.  X  By  X  x ( x  X  ), x  X  P  X  T , we denote the preset (the postset )of x  X  the set of all input x  X  P  X  T is a source (a sink ) node of N iff  X  x = X  ( x  X = X  ). Given a net N  X =( P , T , F ) ,by Min ( N ) ( Max ( N ) ) we denote the set of all source (all sink) nodes of N . For technical convenience, we require all n ets to be T-restricted. A net N is T-restricted iff the preset and postset of every transition is non-empty, i.e.,  X  t  X  T  X  X  X  t  X  X  X  X  t  X  .

We distinguish between observable and sile nt transitions of a net via the notion of a labeled net because we shall define our query primitives on observable behavior. is a net, T is a set of labels, where  X   X  X  is a special label, and  X   X  T  X  X  is a function that assigns to each transition in T a label in T .  X  If  X  ( t ) X   X  ,where t  X  T ,then t is observable ;otherwise, t is silent .

The execution semantics of Petri nets is based on states and state transitions and is best perceived as a  X  X oken game X . A state of a net is represented by a marking ,which describes a distribution of tokens on the net X  X  places.
 Definition 3.3 (Marking of a net). A marking ,ora state ,ofanet N  X =( P , T , F ) is a relation M  X  P  X  N 0 that assigns to each place p  X  P a number M ( p ) of tokens in p . 1  X  In the sequel, we shall often refer to a marking M as to the multiset containing M ( p ) copies of place p for every p  X  P . 2 A net system is a Petri net at a certain state/marking. Definition 3.4 (Net system). A net system ,ora system , is an ordered pair S  X =( N , M ) , where N is a net and M is a marking of N .  X  In the graphical notation, a common practice i s to visualize places as circles, transi-tions as rectangles, the flow relation as dir ected edges, and tokens as black dots inside assigned places; see Fig. 2 for an exam ple of a net system visualization.
Whether a transition is enabled at a given marking depends on the tokens in its input places. An enabled transition can occur , which leads to a new marking of the net. Definition 3.5 (Semantics of a system). Let S  X =( N , M ) , N  X =( P , T , F ) , be a system.  X  A transition t  X  T is enabled in S , denoted by S [ t  X  , iff every input place of t contains  X  If a transition t  X  T is enabled in S ,then t can occur , which leads to a step from Fig. 2 shows the labeled net system that f ormalizes the execution semantics of the BPMN model in Fig. 1. Empty rectangles denote silent transitions. Rectangles with labels inside denote observable transitions. These labels refer to the short names shown next to task nodes in Fig. 1; e.g., the full label of transition t 2 in Fig. 2 is  X  Get flight preferences  X .

A net system induces a set of its instances (in the context of Petri nets usually referred to as occurrence sequences )and reachable markings .
 Definition 3.6 (Occurrence sequence). Let S 0  X =( N , M 0 ) be a net system.  X  A sequence of transitions  X   X = t  X  A marking M is reachable in S Given a net system S ,by  X  ( S ) and [ S  X  , we denote the set of all occurrence sequences and the set of all reachable markings in S , respectively. A net system S  X =( N , M ) , N  X = (
P , T , F ) ,is n-bounded ,or bounded , iff there exists a number n  X  N 0 such that for every reachable marking M  X  in S and for every place p  X  P it holds that the amount of tokens reachable markings in a bounded net system is finite. 3.2 Processes of Net Systems Occurrence sequences suit well when it comes to describing orderings of transition occurrences. In this section, we present processes of net systems [15]. One can rely on processes to adequately represent causality and concurrency relations on transition occurrences. A process of a net system is a net of a particular kind, called a causal net , together with a mapping from elements of the causal net to elements of the net system. Definition 3.7 (Causal net). Anet N  X =( B , E , G ) is a causal net iff: (i) for every b  X  B it holds that  X  X  X  b  X  X  X  1and  X  b  X  X  X  X  1, and (ii) N is acyclic, i.e., G + is irreflexive. 4  X  Elements of E are called events , whereas elements of B are called conditions of N .Two nodes x and y of a causal net N  X =( B , E , G ) are causal iff ( x , y ) X  G + . Nodes x and y (with respect to set inclusion) set of its pairwise concurrent conditions.
 One can utilize events of causal nets to represent transition occurrences.
 Definition 3.8 (Process, adapted from [15]) N  X   X =( B , E , G ) is a causal net and  X   X  B  X  E  X  P  X  T is such that:  X   X  ( B ) X  P and  X  ( E ) X  T , i.e.,  X  preserves the nature of nodes,  X  for every event e  X  E and for every place p  X  P it holds that Let  X   X =( N  X  ,  X  ) be a process of a net system S . It is known that every cut of N  X  encodes a reachable marking in S .
 Theorem 3.9 (Cuts and reachable markings, cf. [15, Theorem 3.5]) Let  X   X =( N  X  ,  X  ) ,N  X   X =( B , E , G ) , be a process of a net system S. If C  X  BisacutofN  X  , then M  X = m (  X  , C ) is a reachable marking in S.  X  Fig. 3 shows two processes of the net system in Fig. 2. When visualizing processes,  X  ( distinguish between shapes of events that co rrespond to silent transitions and those that correspond to observable ones only for clarity. Fig. 3(b) shows a process and four cuts of its causal net N  X  . Each cut is defined as a set of conditi ons that intersect with the respec-tive dashed line. For example, cut D 1 is defined as the set of conditions { c 3 , c 6 } .Note that cuts D min and D max are equal to Min ( N  X  ) and Max ( N  X  ) , respectively. Moreover, both cuts D 1 and D max encode the same marking m (  X  , D 1 )=[ p 3 , p 6 ]= m (  X  , D max ) , which is a reachable marking in the net syste m in Fig. 2, for instance via occurrence se-of the net system in Fig. 2 is infinite . This section proposes to use untanglings of process models, or more precisely of the cor-responding net systems, as data structures that improve the speed of retrieving process instances stored in process model repositories. Similar to database indexes, untanglings require the use of additional storage space to maintain the extra copy of data. However, at this additional cost, they can be used to quickly discover requested process instances without having to iterate over all instances, of which there can be infinitely many.
An untangling of a net system is a set of its processes. A process of a system is a static model that describes a finite portion of its occurrence sequences, cf. Sect. 3.2. For example, in [16], J  X  org Desel suggests to enhance a causal net N  X  of a pro-cess  X   X = ( N  X  ,  X  ) of a system S  X = ( N , M ) with a marking M  X  that puts one token at every source condition of N  X  and no tokens elsewhere. Then, every occurrence sequence in the fresh system ( N  X  , M  X  ) represents (via mapping  X  ) an occurrence se-quence in S . E.g., consider the net system S  X  composed of the causal net in Fig. 3(b) and a marking that puts one token at condition c 1 and no tokens elsewhere. Then,  X  ( the net system in Fig. 2. Observe that in this way S  X  represents six occurrence sequences of the net system in Fig. 2.

The number of occurrence sequences that are represented in a single process ex-plodes with respect to the amount of its pairwise concurrent events. This hints at the fact that processes are highly suitable for indexing occurrence sequences. Still, it is easy to see that one might often need an infinite number of processes to represent  X  as per the above proposed intuition  X  all occurrence sequences in a system; e.g., con-sider the net system in Fig. 2. Clearly, every index must be finite. To this end, we rely on an enhanced interpretation of processes, which allows treating a process as a static model that can represent an infinite number of occurrence sequences. This enhanced in-terpretation is formalized in the notion of a process set system , where every process set system can be seen as a semantic union of elementary models, called process systems .
A process system is an abstract model that suggests a way a process of a system can encode a possibly infinite number of occurrence sequences.
 Definition 4.1 (Process system). A process system of a net system S  X =( N , M 0 ) in-duced by a process  X  of S is an ordered triple S  X   X =( N , M ,  X  ) ,where M is a marking of N .  X  The semantics of process systems  X  similarly t o the semantics of net systems, cf. Def-inition 3.5  X  consists of the transition enablement and transition occurrence rules. The enablement rule of a net system ( N , M ) depends on the structure of the net N ,i.e.,on tokens in presets of transitions of the net. In contrast, the enablement rule of a process system ( N , M ,  X  ) relies on the structure of the causal net of  X  .
 Definition 4.2 (Semantics of a process system). Let S  X   X =( N , M ,  X  ) , N  X =( P , T , F ) ,  X   X =( N  X  ,  X  ) , N  X   X =( B , E , G ) , be a process system of a net system S .  X  A transition t  X  T is enabled in S  X  , denoted by S  X  [ t  X  , iff there exist a cut C  X  B of  X  If a transition t  X  T is enabled in S  X  then t can occur , which leads to a step from S  X  According to Theorem 3.9, if C  X  B is a cut of a causal net N  X   X =( B , E , G ) taken from a process ( N  X  ,  X  ) of a system S  X =( N , M ) ,then m (  X  , C ) is a reachable marking in S . Moreover, it is easy to see that, in general, if D  X  B is a subset of conditions, e  X  E is an event, and  X  e  X  D , then transition t  X =  X  ( e ) is enabled in N at the marking m (  X  , D ) ; this follows from the fact that  X  preserves the nature of nodes and environment of of the net system ( N , M ) to those reachable markings that are induced by cuts of N  X  and to those transition occurrences that are captured by events of N  X  .

Similar to net systems, a sequence of transitions  X  is an occurrence sequence in a process system S  X  if  X  is empty or the first transition in  X  is enabled in S  X  and an occurrence of a transition from  X  in S (except of an occurrence of the last transition in  X  ) leads to a process system that enables the next transition in  X  . We accept that a process  X  of a net system S  X =( N , M ) represents all those occurrence sequences in S which are also occurrence sequences in the process system ( N , M ,  X  ) .

As an example consider a process system S  X   X =( N , M ,  X  ) ,where ( N , M ) is the net There exists only one cut in Fig. 3(b) that induces marking [ p 8 ] ; this is cut D 2 . Finally, system S  X  represents infinitely many occurrence sequences in the net system in Fig. 2; transition t 3 via cut D 1 . Moreover, S  X  represents infinite occurrence sequences; those in which transitions t 3 ... t 9 can occur infinitely often.

Every process system has its natural boundaries on what portion of process instances it can describe. Process set systems aim to overcome these boundaries.
 Definition 4.3 (Process set system) A process set system of a net system S  X =( N , M 0 ) induced by a set of processes  X  of S is an ordered triple S  X   X =( N , M ,  X  ) ,where M is a marking of N .  X  The semantics of a process set system S X =( N , M ,  X  ) is  X  X omposed X  of all the semantics of individual process systems that are induced by processes in  X  .
 Definition 4.4 (Semantics of a process set system) Let S X =( N , M ,  X  ) , N  X =( P , T , F ) , be a process set system.  X  A transition t  X  T is enabled in S , denoted by S[ t  X  , iff there exists a process  X   X   X   X  If a transition t  X  T is enabled in S ,then t can occur , which leads to a step from S As an example consider a process set system S X =( N , M , {  X  1 ,  X  2 }) ,where ( N , M ) is, again, the net system in Fig. 2, and  X  1 and  X  2 are the processes in Figs. 3(a) and 3(b), respectively. The sequence of transitions t 1 t 2 t 3 t 4 t 5 t 6 is an occurrence sequence in S which leads to the process set system S  X   X =( N , [ p 8 ] , {  X  1 ,  X  2 }) ; again, a sequence of transitions  X  is an occurrence sequence in a process set system S if the first transition in  X  is enabled in S and an occurrence of a transition from  X  in S (except that of the last transition) leads to a process set system that enables the next transition in  X  . Transitions t and t 10 are enabled in S  X  . Transition t 7 is enabled due to cut D 2 and event e 7 in  X  2 . Transition t 10 is enabled due to cut D and event e 10 in  X  1 . An occurrence of t 10 in S  X  leads to the process set system ( N , [ p 11 ] , {  X  1 }) , which does not enable any transition.
The process set system ( N , M , {  X  1 ,  X  2 }) from the example above represents a big portion of the occurrence sequences in ( N , M ) . Still, it fails to represent all of them. E.g., it does not represent occurrence sequences in which both t 7 and t 10 occur. A rep-resentative untangling of a net system S is a collection of its processes that induces a process set system which represents all the occurrence sequences in S .
 Definition 4.5 (Representative untangling). An untangling  X  (i.e., a set of pro-cesses) of a net system S  X =( N , M ) is representative if every occurrence sequence in S is also an occurrence sequence in the process set system ( N , M ,  X  ) .  X  In [17], we demonstrated that: (i) one can always construct a finite representative un-tangling of a bounded net system, and (ii) a net system S and a process set system S of S induced by a representative untangling of S are occurrence net equivalent [18], i.e., they are two different specifications of exactly the same distributed system.
In [17], we proposed the first algorithm for constructing representative untanglings of bounded net systems. Given the net system in Fig. 2 as input, this algorithm returns two processes shown in Figs. 3(a) and 4 as its representative untangling. A representative untangling of a system S is another specification that represents all and only occurrence sequences in S . This section shows how one can employ the unique characteristics of representative untangli ngs to engineer a process model querying tech-nique. To this end, Sect. 5.1 proposes the total executability problem and its efficient solution in terms of representative untanglings, whereas Sect. 5.2 uses this solution to formulate basic query primitives . 5.1 Executability executability problem deals with deciding whether some transition in U can ever be  X  X xecuted X  (can occur) in S . It is a fundamental problem in concurrency theory, e.g., a solution to the executability problem can help deciding reachability and safety [7]. Definition 5.1 (Executability, cf. [7]) A net system S  X =( N , M ) , N  X =( P , T , F ) , can execute some transition in U  X  T iff there exist an occurrence sequence  X  in S and a transition t  X  U such that t occurs in  X  .  X  One can solve the executability problem of a system using its representative untangling. Lemma 5.2 (Executability) Let  X  be a representative untangling of a net system S  X =( N , M ) ,N  X =( P , T , F ) . Then, S can execute some transition in U  X  T iff there exist a process  X   X =( N  X  ,  X  ) ,N  X   X = ( B , E , G ) ,in  X  , a transition t  X  U , and an event e  X  E for which it holds that  X  ( e )= t.  X  The proof of Lemma 5.2 is similar to the proof of correctness of a solution to the total executability problem that is proposed below.

For example, according to Lemma 5.2, one can decide that the net system S in Fig. 2 describes an occurrence sequence that contains transition t 3 using event e 3 of process  X  in Fig. 3(a) for which it holds that  X  ( e 3 )= t 3 . Moreover, one can use  X  to generate sam-ple occurrence sequences that contain t 3 ; these are occurrence sequences in a process system of S induced by  X  that contain t 3 ,e.g., t 1 t 2 t 4 t 3 is one such sequence.
The executability problem is a decision problem on the level of process instances and as such can be naturally applied to for mulate queries for searching process models problem can be formulated as follows:  X  X ind all process models that describe a process instance in which a given transition occurs. X  Alternatively, one can search for exemplary process instances in which a given task occurs. Clearly, one can answer both these questions efficiently using representative untanglings and the result of Lemma 5.2.
In fact, representative untanglings can be used to efficiently solve an extended ver-sion of the classical executability problem. As we shall see, this solution broadens the applicability of representative untanglings when searching process model repositories.
Given a net system S  X =( N , M ) , N  X =( P , T , F ) , and a set of transitions U  X  T ,the total executability problem deals with deciding whether there exists an occurrence sequence in S which contains all the transitions in U .
 Definition 5.3 (Total executability) A net system S  X =( N , M ) , N  X =( P , T , F ) , can execute all transitions in U  X  T iff there exists an occurrence sequence  X  in S such that every transition t  X  U occurs in  X  .  X  The total executability problem can be solved using representative untanglings. The proof of correctness of this solution relies on the next corollary.
 Corollary 5.4 (Processes and occurrence sequences). Let  X   X =( N  X  ,  X  ) , N  X   X = (
B , E , G ) , be a process of a net system S . Then, there exists an occurrence sequence  X  in S such that for every event e  X  E it holds that transition  X  ( e ) occurs in  X  .  X  Please note that Corollary 5.4 is a special case of Lemma 1 in [16]. Finally, the solution to the total executability problem proceeds as follows.
 Lemma 5.5 (Total executability). Let  X  be a representative untangling of a net sys-tem S  X =( N , M ) ,N  X =( P , T , F ) . Then, S can execute all transitions in U  X  Tiffthere exists a process  X   X =( N  X  ,  X  ) ,N  X   X =( B , E , G ) ,in  X  such that for every transition t  X  U there exists an event e  X  E for which it holds that  X  ( e )= t.  X  Proof. We prove each direction of the statement separately. ( X ) Proof by construction . Assume that S can execute all transitions in U . According ( X ) Proof by contradiction . Assume that there exists a process  X   X =( N  X  ,  X  ) , N  X   X = For instance, according to Lemma 5.5, one can decide that the net system S in Fig. 2 describes an occurrence sequence that contains transitions t 3 , t 7 ,and t 9 using events e and  X  ( e 9 )= t 9 . This conclusion is due to the process system S  X  of S induced by  X  ; e.g., t 1 ... t 9 is one of infinitely many occurrence sequences in S  X  that contains all the three transitions.
 The total executability problem can be solved efficiently using untanglings. Proposition 5.6. Given a representative untangling  X  of a net system S  X =( N , M ) ,N  X = (
P , T , F ) , and a set of transitions U  X  T , the following problem can be solved in linear time in the size of  X  : To decide if S can execute all transitions in U .  X  The proof of Proposition 5.6 is due to Lemma 5.5. Clearly, one can solve the total exe-cutability problem by visiting each event of the representative untangling once. Hence, representative untanglings can be used to efficiently retrieve process models and/or ex-emplary process instances in which all task s from a given set of tasks occur. Note that, in general, the existence of certain tasks in a process model does not imply the fact that this model describes a process instance in which all these tasks occur; this is due to conflicting process instances and/or behavioral anomalies, like deadlocks [19]. 5.2 Query Primitives This section proposes query primitives that are founded on the definition of the (total) executability problem. The basi c construct for all the subsequently proposed primitives is a predicate that given a labeled system S and a set of labels L tests if there exists an occurrence sequence  X  in S such that some transitions that are labeled with labels in L occur in  X  . This basic predicate can be specialized into four tests:  X  CanOccurOne (labeled system S , set of labels L )  X = X   X   X   X  ( S ) X  l  X  L  X  l  X   X  ; 6  X  CannotOccurOne (labeled system S , set of labels L )  X = X   X   X   X  ( S ) X  l  X  L  X  l /  X   X  ;  X  CanOccurAll (labeled system S , set of labels L )  X = X   X   X   X  ( S ) X  l  X  L  X  l  X   X  ;  X  CannotOccurAll (labeled system S , set of labels L )  X = X   X   X   X  ( S ) X  l  X  L  X  l /  X   X  ; For example, one can find all process models that describe a process instance in which task  X  Obtain flight price  X  occurs by selecting every model K (from a given repertoire of models) for which test CanOccurOne ( S , {  X  Obtain flight price  X  } ) evaluates to true, where S is a labeled net system that corresponds to K (refer to Sect. 3.1 for details).
Process model repositories often suffer from inconsistent usage of labels, i.e., seman-tically similar tasks might  X  X ear X  different labels, e.g.,  X  Get flight quote  X  X nd X  Obtain flight price  X . Consequently, the search procedure that is exemplified above will not re-trieve the process model in Fig. 1, which can be accepted as a model that matches the query semantically. To address this issue, we  X  X xpand X  the predicates. In information retrieval, a query expansion is a process of reformulating a seed query to improve effec-tiveness of search results. Every label that is used as input to one of the above proposed seed predicates can be expanded to a set of sem antically similar labels, e.g., using the approach in [20]. Accordingly, the pre dicates get reformulated as follows:  X  CanOccurOneExpanded (labeled system S , set of sets of labels L X ={ L  X  CannotOccurOneExpanded (labeled system S , set of sets of labels L X ={ L  X  CanOccurAllExpanded (labeled system S , set of sets of labels L X ={ L  X  CannotOccurAllExpanded (labeled system S , set of sets of labels L X ={ L For instance, if one is interested in process instances (or models) in which tasks  X  Obtain flight price  X  X nd X  Obtain hotel price  X  (or semantically similar tasks) occur together, one can start by constructing sets of similar labels, e.g., L 1  X = {  X  Obtain flight price  X , X  Get flight quote  X  } and L 2  X = {  X  Obtain hotel price  X , X  Get hotel quote  X  } . Then, the model in Fig. 1 is a match to the query CanOccurAllExpanded ( S , { L 1 , L 2 } ), where S ,again,is the net system in Fig. 2. Indeed, the model in Fig. 1 describes process instances in which both tasks  X  Get flight quote  X  X nd X  Get hotel quote  X  occur. Finally, the model in Fig. 1 can be ranked as one that is less relevant to the query as some other model that is retrieved based on labels  X  Obtain flight price  X  X nd X  Obtain hotel price  X , as these labels were initially provided as input, cf. [20] for f urther details on how results can be ranked.
The above proposed predicates explore all possible configurations of the (to-tal) executability problem and the suggested query expansion principle. These predicates are provided for the sak e of completeness. However, only three (out of the total of eight) checks specify distinct computation patterns. Indeed, ev-ery CannotOccurXY , X  X  {  X  One  X , X  All  X  } , Y  X  {  X  X , X  Expanded  X  } , predicate is the negation of the CanOccurXY check. CanOccurOneExpanded ( S , L ) can be imple-mented via CanOccurOne ( S ,  X  L  X  X  L ). Note that two out of the three remain-ing predicates can be expressed in terms of the third one, i.e., CanOccurOne ( S , L )  X =  X  l  X  L CanOccurAll ( S , { l } )and CanOccurAllExpanded ( S , { L 1 ... L n } )  X =  X  multiple CanOccurAll checks which require multiple (a nd as it turns out unnecessary) traversals of representative untanglings.

Because of Proposition 5.6, the CanOccurAll ( S , L ) test can be accomplished in lin-ear time in the size of a representative untangling  X  of S ; one has to verify if  X  contains a process which for every label l in L contains an event that describes an occurrence of a transition labeled with l . Similarly, because of Lemma 5.2, when evaluating the CanOccurOne ( S , L ) predicate one needs to search for a process in  X  which contains an event that describes an occurrence of a transition labeled with some label in L . Finally, because of Lemma 5.5, in order to fulfill the CanOccurAllExpanded ( S , L ) predicate, there should exist a process in  X  that for every set of labels L in L contains an event which describes an occurrence of a transition labeled with some label in L . For all the above checks it suffices to perform a single tra versal of a representative untangling of S . The proposed querying approach has been implemented and is publicly available as part of the jBPT initiative [21]. Using this implementation, we conducted an experiment to assess the performance of the approach in terms of querying time and accuracy of re-sults. The experiment was performed on a computer with a dual core Intel CPU with 2.26 GHz, 4GB of memory, running Windows 7 and SUN JVM 1.7 (with standard al-location of memory). To elimin ate load time from the measures, each test was executed six times, and we recorded average tim es of the second to sixth executions.
The study was conducted on a collection of 448 bounded systems that model pro-cesses from financial services, telecommunications, and other domains. These systems were selected from a larger collection of 735 models [19]; systems that do not model concurrency were filtered out as they do not suffer from the state space explosion prob-lem and can be handled efficiently using structural analysis methods.

The study is subdivided into two stages. First, representative untanglings of all sys-tems from the data set are constructed  X  the indexing stage . Then, the resulting untan-glings are employed for efficient validation of queries  X  the querying stage .
An extensive experiment that assesses the performance of the indexing stage is re-ported in [17]. This experiment can be downloaded and reproduced. 7 Next, we sum-marize basic measures on constructing representative untanglings of the 448 systems. The indexing stage requires 2.72s. Hence, on average, a representative untangling is constructed in 6.06ms; the minimal and maximal construction times are 0.58ms and 221ms, respectively. The average duplication factor, i.e., the average number of times the size of an untangling is larger than the size of its corresponding system (in the number of nodes), is 3.54.

Once constructed, representative untanglings are stored and reused for querying pur-poses. Table 1 reports average times (in microseconds) of performing CanOccurOne and CanOccurAll checks. The first two columns re port on the characteristics of the model collection by providing information on the number  X  X  X  of systems within a given  X  X ize X  range (measured as the number of nodes). The number of labels used as input to queries ranged from one to five (see the second row and columns three to twelve in the header of the table). Each value is meas ured as the average time of executing 100 random queries. For example, the value of 9.36 in the third row and fifth column in Ta-ble 1 reports the average time (in microseconds) of performing CanOccurOne checks for the input of three random labels over 44 systems, each of size within the range from 101 to 150 nodes; in total, 4400 different queries were checked to obtain this average value. The last row in the table shows average times of performing queries over all systems in the collection; these are plotted in Fig. 5(a). One can observe a quasi-linear dependency between the average time of performing a single check and the size of the set of labels provided as input. The average values for CanOccurOne checks show a negative slope. Indeed, as the size of the input set of labels increases, the chance of discovering an occurrence sequence that includes at least one transition labeled with a label from the input set of labels increases as well. On the other hand, more labels in the input sets of CanOccurAll queries lead to slower checks as more conditions need to be satisfied.

Table 2 shows average querying times (columns two to seven) and compares accu-racy of retrieved results with label filtering techniques (columns eight to thirteen). The first column lists sizes of input sets of labels; we also vary the sizes of sets used as inputs to CanOccurAllExpanded checks. For instance, the value of 7.32 in the second row and fifth column in Table 2 is the ave rage time (in milliseconds) of querying 448 systems using the CanOccurAllExpanded primitive for an input set that contains two sets, each composed of three labels. Aver age querying times report on a quasi-linear dependency with the size of the input set of labels, cf. Fig. 5(b).

When searching for process models, one often starts by performing a filtering step, e.g., filtering out those models that do not contain tasks with labels of interest [9,10]. Af-terwards, computation intensive methods, either structural or behavioral, cf. Section 2, are applied to a much smaller (pre-selected) collection of models. Query primitives from Section 5.2 can improve effectiveness of exis ting filtering techniques. To verify this ex-perimentally, we implemented filtering primitives that  X  X imic X  the primitives from Sec-tion 5.2; these fresh primitives analyze process models rather than process instances. For instance, the filtering counterpart of the CanOccurOne check from Section 5.2 ver-ifies if a given process model contains a task labeled with some label from a given set of labels. In Table 2, columns eight to thirteen report average numbers of retrieved sys-tems over 100 random queries using both types of primitives. For example, 2.7/6.67 in the third row and eleventh column reports that, on average, the behavioral version of the CanOccurAllExpanded primitive retrieved 2.7 systems while the structural version re-trieved 6.67 systems. The additional systems selected by analyzing models rather than their instances are false positives in the situation when one is interested in systems that describe instances in which giv en transitions occur together.

Finally, we experimented with a behavioral querying approach that relies on the model checking technique described in [7]. Model checking of our query primitives requires, on average, 4ms (based on an implementation that uses Uma 8 ). Though this is approximately 2ms faster than constructing a representative untangling (see above), un-tanglings can be reused for checking query primitives over any combination of labels, i.e., a single untangling of a system fits all, while a fresh model checking exercise has to be performed for every fresh combination of labels. Note that the time of 4ms, which is required to perform a single model checking exercise, is often comparable with the average time of performing a query over 448 systems that we report in Table 2. 9 This paper proposed a technique for instance-based retrieval of process models from process model repositories. The technique relies on the use of an index, called a rep-resentative untangling, whic h is optimized towards accura te and efficient retrieval of process instances. The use of this index is exemplified via a family of query primitives that are founded on the extended version of the classical executability problem. The basic construct for all the primitives is a check on the existence of a process instance in which all tasks from a given set of tasks occur. As exemplified, these primitives can be effectively applied in practice, e.g., for pro cess reuse, compliance, and standardization. Finally, a set of experiments conducted on a large repository of process models from practice showed that during retrieval the use of our index leads to an up to three orders of magnitude speed-up compared to techniques that rely on model checking.

Our approach works on Petri nets. This means that it can also be used to check behavioral properties of models defined in languages such as BPMN and EPCs, so long as these models can be translated to Petri nets. We envision that our index can be of great use when designing efficient implementations of other query primitives, e.g., those that explore the relations of causality and concurrency [22]. Studies of these primitives will contribute to the maturity of process model query languages, e.g., BPMN-Q [9] and APQL [23]. Another avenue for future work is to evaluate the perceived usefulness of behavioral querying with end users.
 Acknowledgments. This work is partly funded by the ARC Linkage Project LP110100252 . NICTA is funded by the Australian Government (Department of Broad-band, Communications and the Digital Economy) and the Australian Research Council through the ICT Centre of Excellence program.

