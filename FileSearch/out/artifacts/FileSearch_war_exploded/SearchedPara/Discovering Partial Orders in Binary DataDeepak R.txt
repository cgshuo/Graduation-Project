
We approach the problem of discovering interesting or-ders in data. In many applications, it is more important to find interesting partial orders since there is often no clear ordering between certain sets of elements. Furthermore, a partial order is more robust against partially erroneous data. We present the notion of fundamental partial orders (FPO), and argue that any partial order that satisfies this property is an interesting partial order. To mine such par-tial orders, we present a two-stage methodology that first finds an interesting total order, and then discovers a partial order satisfying FPO using this total order. To illustrate, we focus on { 0 , 1 } data. This is an important problem with many applications, e.g., in paleontology, where we chrono-logically order fossil sites by minimizing Lazarus counts. We present the experimental results of our method on pale-ontological data, and show that it outperforms existing ap-proaches. The techniques developed here are general and can be abstracted for mining partial orders in any setting.
The vast field of data mining, also known as knowledge-discovery in databases, primarily deals with searching for patterns in large volumes of data for a variety of purposes. We consider a particular aspect, one that relates to discover-ing interesting orders in data. The problem of finding order-ing relationships in data is an extremely important problem, and with a large variety of applications. At the same time, the problem often requires a different solution approach in each domain depending on the criterion for selecting the ordering. Furthermore, in certain applications, there is no clear ordering between certain elements. Thus, what is of-ten required is a partial ordering.

We introduce the notion of  X  X undamental partial orders X , and emphasize that it can be used for any ordering problem where there is no interesting total ordering among data. As-sume that we wish to find the data order that minimizes cer-tain objective  X  . Our general methodology has two stages. First, we find a total order that minimizes objective  X  . Then, using this total order, we discover a minimal partial order that also attains the same minimum value of objective  X  . We argue that our methodology is a fundamentally sound approach for discovering interesting partial orders.
In this paper, we focus on an application from paleon-tology and describe techniques for discovering interesting partial orders. In this application, we wish to chronologi-cally order fossil sites based on the presence of various gen-era at these sites; see [2, 8, 9, 17, 6] for some approaches. Since there are often errors in the data, and there is often no clear chronological ordering between certain pairs of sites, we need to find partial orders; see Section 1.2 for a detailed discussion. For this problem, the criterion used for selecting the ordering is minimizing the Lazarus count.

Discovering interesting partial orders in binary data has many applications, even within the vast field of biology. The most widely used strategy in the Human Genome Project for mapping of chromosomes is the Sequence-Tagged-Site mapping strategy [16]. In this technique, a chromosome is broken down into overlapping fragments (clones) for detailed study. Relatively short substrings (probes) are extracted from the chromosome, and used to find interesting partial orders among the clones [1, 5]. These partial orders are then used to map the chromosome in its entirety. In this problem, the criterion used for selecting the ordering reduces to finding a good dependency graph.
Applications also abound in other fields, and even in other data mining frameworks such as pattern discovery. In this application, a collection of patterns is used to estimate the frequencies of other patterns. In [14], the authors ad-dress the problem of discovering an ordering among this collection of patterns. The criteria for selecting the order-ing here is decreasing informativeness for the estimation method. Thus, while the criteria, and hence the techniques used, vary depending on the application, the goal is the same: to find an interesting partial order in data.
Before we describe our methodology in detail, we intro-duce and define all the concepts used in this paper. Some of these concepts are also formally defined in [17], which is most closely related to our work.
The data can be represented without loss of generality as a { 0 , 1 } matrix. Here, rows represent the sites and columns represent the genera. For any site/genus combination, the matrix has a 1 if a record of the genus is present at the site, and 0 otherwise. We represent this matrix by  X  and refer to the element in row i and column k by  X  [ i,k ] . Using this information, we wish to find the chronological ordering of the sites. Observe that any permuted matrix  X  is equivalent to a total ordering of the sites; illustrating the equivalence between total orders, permutations and matrices.

To illustrate many of the con cepts introduced in this pa-per, we use Example E 1, presented in Table 1. We see for instance that genus C is present at sites a , d ,and e .
Throughout this paper, we use index k for genera, and i, j, l for sites. As is convenient , we interchangeably use rows/sites/nodes and genera/columns. Let N and M be the set of sites and genera, respectively. Let n := | N | and m := |
M | . The size of the problem is therefore O ( nm ) . For ease of exposition, we also treat N and M as lists.

An order (partial or total) i s a collection of precedence relations among the sites. Thus, it is natural to represent an order as a set of ordered pairs of elements. In such a set, we include as elements all pairs of sites that have a precedence relation amongst them. Let T be a partial order. Using i&lt; j to denote that site i precedes site j in the partial order T , Naturally, not all sets of ordered pairs represent a partial order. Next, we provide conditions on when a set of pairs of elements represents a partia l order. We revisit Example E and introduce the set of ordered pairs T 1 . From Definition 1, this set of ordered pairs represents a partial order. Definition 1 Partial Orders: Any collection T of ordered pairs of sites corresponds to a partial order if and only if  X  The order T is transitive; i.e., if ( i, j )  X  T and ( j, l )  X  If ( i, j )  X  T ,then ( j, i ) /  X  T .  X  ( i, i ) /  X  T .
 A total order is a special case of partial orders: there exists a precedence relation between al l pairs of elements. In other words, for any two sites i and j , either i&lt; T j or j&lt; i . Thus, a partial order T is a total order if and only if |
T | = n ( n  X  1) / 2 . Since this can be a large set, for ease of exposition, we present total orde rs as permutations of sites. Revisiting Example E 1, we introduce total order T 2 . An order can also be represented using a graph where the sites correspond to nodes, and there exists an arc from node i to node j if and only if ( i, j )  X  T . This demonstrates the equivalence between partial orders and graphs. Since any order is transitive (Definition 1), this directed graph must be acyclic. Redundant arcs correspond to ordered pairs which can be derived from other ordered pairs using transitivity. Definition 2 Redundant Arcs/Ordered Pairs: Given order T , an ordered pair ( i, j )  X  T is redundant if there exists l  X  N such that i&lt; T &lt;l&lt; T j . For example, in partial order T 1 ,arc ( a, d ) is redundant since a&lt; T e&lt; T d . In Figure 1, we present the graphi-cal representation of orders T 1 and T 2 .
 a
Given matrix  X  and partial order T , a non-existing genus k at site i is called a Lazarus event if genus k exists at sites before and after (as defined by &lt; T ) site i . In both T T , genus D of site e is a Lazarus event. The Lazarus count of a partial order T is the number of Lazarus events. Definition 3 Lazarus Count: The Lazarus count of a partial order T , denoted by L ( T ) , is the number of Lazarus events. Formally, L ( T )= |{ ( i, k ):(  X  [ i,k ] =0) We leave it to the reader to verify that the Lazarus counts of orders T 1 and T 2 are: Consider two partial orders T a and T b such that T a  X  T other words, every precedence relation between sites i and j in T a also exists in T b . Therefore, if genus k at site i is a Lazarus event for partial order T a , then it is also a Lazarus event for partial order T b . We have proved the following. Theorem 1 If T a  X  T b ,then L ( T a )  X  L ( T b ) . Observe that the trivial partial order ( i.e. , when there is no order among the data; T =  X  ) has Lazarus count 0 . This is because, for any site i , there exist no sites that pre-cede/follow it in the partial order  X  . Therefore, we restrict ourselves to total orders while minimizing Lazarus counts. We define the minimum Lazarus count l  X  (  X  ) as the mini-mum over all total orders for given matrix  X  .For  X  1 defined in Example E 1, the minimum Lazarus count is 1 ; i.e. , T 3 attains this Lazarus count, where T 3 = { e, d, a, b, c There may be other minima; i.e. , other total orders with minimum Lazarus counts. For exa mple, the total order de-fined by T 4 also has L ( T 4 )=1 ,where T 4 = { e, d, b, a, c
Recall that we wish to discover the chronological order of fossil sites. To see why mi nimizing Lazarus counts is a good objective, consider a particular genus k . If the matrix is sorted correctly, then the values of column k will never change from 1 to 0 and back to 1 , since this would indicate that the genus became extinct and reappeared later. Thus, we want to find whether matrix  X  has the  X  X onsecutive-ones X  property; i.e. , whether there exists some matrix  X  ob-tained by permuting the rows of  X  such that all 1 sinany column of  X  are adjacent to each other. In fact, this is an easy problem. (One can obtain a consecutive-ones permu-tation of a matrix in linear time, if such a permutation exists [4, 10].) Therefore, if  X  is perfect (no errors), then chrono-logically sorting sites is an easy problem. Revisiting Exam-ple E 1, we see from equality 1 that there exist errors in  X  However, if genus B of site a in data set  X  1 is equal to 1 , then the optimal Lazarus count (attained by T 3 )is 0 ; i.e. ,the resulting matrix is error-free.

However, there are often errors in the data, and thus we would like to minimize the number of Lazarus counts. This is a hard problem, and has been approached by a variety of heuristic techniques [3, 2]. Furthermore, these sites have a large number of  X  X alse zeros X , often as much as half of the data. This is not surprising since the existence of a genus during the time of a particular site does not mean that it will be present in the fossils at the site. Many 1 s get recorded as 0 s. Therefore, the optimal L azarus count for p aleontologi-cal data tends to be quite large.

Since there are false 0 s in the data, it is difficult to de-termine an ordering between some pairs of sites based on the data. Techniques that find a total order enforce an order among all sites, even those that should not be ordered. This usually manifests itself in the fact that many total orders are optimal (have the same minimum Lazarus count).

We believe that the best method should discover a partial order. This argument is also the basis of [13, 17], where the authors consider a different approach to solving the prob-lem. Furthermore, any technique that discovers partial or-ders must not attempt to find a partial order that minimizes the Lazarus count, since T =  X  has a Lazarus count of 0 .
Minimizing Lazarus counts is not the only criteria that can be used for minimizing the number of Lazarus events. For instance, one could minimize the number of blocks of 0 s with 1 s above and below (number of blocks of consecutive Lazarus events as opposed to the total number of Lazarus events). This metric has been argued to be more appropriate for certain ordering problems; in particular, the problem of mapping chromosomes [1, 5]. This problem also reduces to the consecutive-ones problem in the absence of errors.
We reiterate that all the methodologies and metrics pro-posed in this paper extend to other applications for discov-ering interesting partial order s in data. However, the tech-niques used may differ since the sorting criteria varies.
From the previous discussion, it is clear that we wish to discover partial orders with low Lazarus counts (to find the right ordering), but at the same time not achieve this objective by discovering partial orders with small size. For two partial orders with the same Lazarus count, the one with lower size is unarguably better since it only captures the important ordered pairs. We wish to discover a partial order that satisfies the following property.
 Definition 4 Fundamental Partial Order (FPO): A partial order P satisfies the FPO property if  X  Among all partial orders with the same Lazarus count,  X  The optimal total order has Lazarus count  X  L ( P ) . This is a key contribution: we believe that the ideal par-tial order satisfies FPO, and claim that this is a better mea-sure than other techniques used in the literature. The second condition is required to eliminate partial orders that have a small Lazarus count because their size is small.

This notion (property FPO) can be analogously defined for any criteria for selecting the ordering. For chronologi-cally ordering fossil sites, the criteria for ordering is to min-imize Lazarus counts. For mapping chromosomes, the cri-teria for selecting the ordering can be reduced to finding appropriate dependency graphs. Nevertheless, the notion of FPO can be defined for this problem. Furthermore, the methodology proposed in Section 1.4 can be applied. How-ever, the analysis and solution techniques will change.
Now, we propose our technique for finding partial orders that satisfy property FPO. We believe that a minimal par-tial order is a good candidate for satisfying property FPO; see Theorem 2. In a minimal partial order, removing any precedence relation in the order reduces its Lazarus count. Definition 5 Minimal Partial Order: Given a number, we say that a partial order P is minimal with respect to s if 1. L ( P )= s , and 2. For all partial orders P  X  P , L ( P ) &lt;s .
 In Theorem 2, we prove that ever y partial order that satisfies property FPO is minimal. This is the primary justification behind restricting our search to minimal partial orders. Theorem 2 For partial order P ,let L ( P )= s .If P satis-fies property FPO, then it is minimal with respect to s .
Proof: Consider any P 1  X  P . To prove that P is min-imal with respect to s , we need to show that the Lazarus count of any such partial order P 1 is less than s , i.e., L ( P 1 ) &lt;s . From Theorem 1, L ( P 1 )  X  s . We show that L ( P 1 ) = s by contradiction. Assume that L ( P 1 )= s .Since P satisfies FPO, it is the smallest among all partial orders with the same Lazarus count. In particular | P | X | P 1 | .We have a contradiction since P 1  X  P .
 The converse is not necessarily true. We wish to discover the minimal partial order with minimum size, since such a partial order satisfies property FPO. Let M ( T ) be the set of all minimal partial orders such that P  X  T and L ( P )= L ( T ) .Wewanttofind P m ,definedas This is a hard optimization problem, and is computationally intractable. Observe that the definition of T m depends on the total order T . Since we would like to discover partial or-ders that satisfy property FPO and have low Lazarus counts, we discover minimal partia l orders with the same Lazarus count as the minimum total order ( = l  X  ) . We believe that this is a good technique for finding interesting partial orders among all those with property FPO.

We solve the problem in two stages. We first find inter-esting total orders, and then discover minimal partial orders.  X  Problem 1 ( P 1): Given a matrix  X  ofsitesasrows  X  Problem 2 ( P 2): Given total order T ,wefindamini-We mention that our proposed algorithms for Problems P 1 and P 2 are not parametric in nature. They are randomized algorithms; however, we will see in Section 4.3 that they are quite indifferent to the randomization.

We mainly compare against the pioneering work of [17], which also attempts to discover partial orders among fossil sites using { 0 , 1 } data. The authors mention that they wish to discover partial orders that minimize L ( P )+  X  ( P ) ,where  X  is a monotonically decreasing function of the size of P . However, such an approach (if solved to optimality) will al-ways yield total orders. Since this is a difficult problem, the authors develop an algorithm that first samples many frag-ments (small number of sites) and then finds partial orders from these fragments. The authors consider fragments of 5 sites each, collect a predetermined number of good frag-ments, and merge them to discover partial orders.

In [17], the authors evaluate the quality of their solutions using L ( P ) . We believe that trying to only minimize the Lazarus count can result in small partial orders (no incen-tive against trivial orders). On the other hand, the objective L ( P )+  X  ( P ) , while avoiding trivial orders, prefers total orders to partial. Our two-phased approach for discovering minimal partial orders that satisfy property FPO avoids both pitfalls (trivial partial orders and total orders).
While the approach of [17] finds interesting partial orders, these partial orders generally have much higher Lazarus counts than the optimal total order. Moreover, these partial orders are usually not minimal. Thus, these partial orders do not satisfy property FPO. Furthermore, the algo-rithm in [17] is highly parametric, and needs a large amount of tuning to find interesting partial orders. We also show that our algorithm discovers partial orders that are much closer to the accepted ordering/classification (by human ex-detailed computational comparison in Section 4.

In Section 2, we first attempt to solve Problem 1 exactly using integer programming (IP) techniques. We present two formulations, and discuss why both formulations are inef-fective in solving even small problems. As a result, we re-sort to heuristic techniques. We present a heuristic in Sec-tion 2.4. Given a total order T , we find a minimal partial order in Section 3. In Section 4, we test our algorithm us-ing a real data instance, and illustrate the effectiveness of our method. Finally, we conclude in Section 5 with some observations and directions for future research.
We first present two integer programming formulations for Problem 1. For a detailed study of integer programming, its applications and solution techniques, we refer the reader to [15]. Integer programming problems are usually solved using enumerative bounding schemes such as branch-and-bound. The time needed to solve problems optimally in this framework largely depends on the strength of the relax-ation used. Therefore, the strength of the linear program-ming (LP) relaxation largely determines the computational effectiveness of any integer programming formulation.
The two formulations presented here are derived from the two paradigms for representing orders: permutations and graphs. In the first, we use variables indicating whether a row is in a certain position in the permuted matrix. In the second, we use variables indicating whether an arc exists between two sites in the graph representation of the order.
In both formulations, variables z , w ,and y are intro-duced to calculate the Lazarus count of a given partial or-der. Variable z k j is forced to 1 if there exists at least one site i preceding site j such that genus k is present at site i . i such that genus k is present at site i . Therefore, a Lazarus event occurs at genus k of site j if both w k j and z k j genus k is not present at site j ; in this case, variable y forced to 1 .

We tried both formulations on random problem in-stances, but were unable to solve instances larger than 15  X  10 in less than an hour (using CPLEX[11] 9.0 on a 1.7GHz IBM ThinkPad). This can be attributed to their weak LP relaxations. In Section 2.3, we study the LP re-laxations of both formulations and discuss why they are in-effective in solving problems of even reasonable size.
Finally, we present an improv ement heuristic that effi-ciently discovers an interesting total order. We remark that real data instances are usually of size greater than 100  X  No brute-force search techni ques can be expected to com-plete in a reasonable amount of time; since the size of the feasible solutio n space exceeds 100! .
Given data matrix  X  , we find the total order T with mini-mum Lazarus count by using variables for row i in position j . In this paradigm (permutations of sites), site i precedes site j ( i&lt; T j ) if the position of row i is less than the posi-tion of row j . We describe the required decision variables in Table 2. Variables v indicate the actual ordering of sites.
Observe that variables x can be derived in terms of vari-ables v ; they are introduced only for the sake of exposition. Problem 1 can now be formulated as: Constraints 2 ensure that each row is assigned to some po-sition. Constraints 3 ensure that each position is assigned to some row. Constraints 4 define x . Constraints 5 and 6 define z j by ensuring that it is 1 if there exists a 1 before position j for genus k . Constraints 7 and 8 define w k j by ensuring that it is 1 if there exists a 1 after position j for genus k . Con-straints 9 ensure that variable y k j is 1 whenever genus k at position j is a Lazarus event. Observe that we only enforce v to be binary; other variables are continuous.
 Theorem 3 When v is { 0 , 1 } , x , w , z , and y are also
Proof: From constraints 4, variables x are binary when-ever variables v are binary. From constraints 5-8, all vari-ables z and w are not smaller than some variable x .In other words, variables z and w are bounded from below by some variable x . Since we are minimizing an increasing function of y , and y is a monotonically increasing function of z and w , all variables z and w will be set to their smallest possible values in any optimal solution to Formulation F 1. As variables z and w are bounded from below by variables x , which are binary when v is binary, we are done. In the preceding proof, we also show that we do not need upper bounds on variables y , w ,and z . This formulation has O ( n max { m, n } ) variables and O ( mn ) constraints.
Here, we discover a total order T with minimum Lazarus count l  X  (  X  ) by using the variables for arcs between pairs of sites (nodes). In this paradigm, site i precedes site j ( i&lt; T j ) if there exists an arc from node i to node j .Wede-scribe the required decision va riables in Table 3. Variables u indicate the presence of arcs between pairs of nodes. Recall that we consider both redundant and non-redundant arcs in this paradigm. As a result u i,j =1 corresponds to all cases where site i precedes site j , not just the adjacent sites.
Any total order can be represented as an acyclic directed graph where, for all pairs of nodes i and j , there is an arc either from node i to node j or from node j to node i . Prob-lem 1 can now be formulated as: In any total order, either site i must precede site j ,orvice versa. This forces one of the variables u i,j or u j,i to 1 ,and the other to 0 , which is enforced by constraints 10. Con-straints 11 and 12 ensure that the graph represented by vari-ables u is acyclic. Constraints 13 define z k j by ensuring that it is 1 if there exists a 1 before site j for genus k . Con-straints 14 define w k j by ensuring that it is 1 if there exists a 1 after site j for genus k . Since we do not know a priori which sites will precede a particular site j , for each genus k at site j , constraints 13 and 14 need to be defined for all sites i  X  N . Constraints 15 ensures that variable y k j whenever genus k of site j is a Lazarus event.

Observe that only variables u need to be binary. All other variables can be continuous. This can be shown using argu-ments very similar to Theorem 3; we just state it here. Theorem 4 When u is { 0 , 1 } , w , z , and y are also { 0 , 1 Furthermore, since we are minimizing an increasing func-tion of variables y , we do not need upper bound constraints for all variables. This formulation has O ( n max { m, n variables and O ( n 2 max { m, n } ) constraints.
Both formulations F 1and F 2 perform poorly primarily because the problem is very symmetric; in the sense that many total orders usually have the same Lazarus count. Of-ten, such sets of total orders (with same Lazarus count) can be found by minor perturbations among themselves. Fur-thermore, given a total order T , the total order given by its exact reversal also has the same Lazarus count. More for-mally, given total order T ,wehave L ( T )= L ( T ) ,where T = { ( i, j ):( j, i )  X  T } .

This symmetry manifests itself in two ways. The former is more critical, and causes weak LP relaxations, resulting in poor performance of integer programming techniques. The strength of a relaxation is often measured using its  X  X n-tegrality gap X , and is calculated as 100  X  ( 1  X  ratio between the LP and IP optimal solutions). A smaller integrality gap usually results in better performance. Unfortunately, the op-timal LP relaxation solution for both formulations F 1and F 2isalways 0 ; proved in Theorems 5 and 6. Thus, the integrality gap for both formulations is always 100% . Theorem 5 For any  X  , the optimal LP solution for F 1is 0 .
Proof: We prove this by constructing a feasible so-lution with objective 0 . Consider the solution given by v i,j =1 /n,  X  i  X  N,  X  j  X  N . This allocation to variables v satisfies constraints 2 and 3. Let  X  k = i  X  N  X  [ i,k ] from constraint 4, we get x k j =  X  k /n,  X  j  X  N,  X  k  X  M . Satisfying constraints 5-8, for all j  X  N, k  X  M ,we set w k j = z k j =  X  k /n .Since  X  k  X  n , setting y k j 0 ,  X  j  X  N,  X  k  X  M satisfies constraints 9.
 Theorem 6 For any  X  , the optimal LP solution for F 2is 0 .
Proof: We prove this by constructing a feasible solution with objective 0 . Consider the solution given by u i,j = 1 / 2 ,  X  j  X  N,  X  i  X  N,j = i , and u i,i =0 ,  X  i  X  N . This allocation to variables u satisfies constraints 10, 11, and 12. Satisfying constraints 13 and 14, for all j  X  N, k  X  M ,weset w k j = z k j =1 / 2 . Now, setting y j =0 ,  X  j  X  N,  X  k  X  M satisfies constraints 15.
 The latter manifestation of symmetric structure is that it sig-nificantly worsens the convergence of the branch and bound tree. As a result, the tree has to explore and prune out many more nodes before it can terminate. Since all exact algo-rithms to solve P 1 are too time-consuming even for small instances, we turn our attention to heuristic techniques. Recall that the LP relaxa tions of formulations F 1and F 2 are weak (optimal LP solution is always 0). Further-more, these optimal solutions are symmetric and contain no useful information. For Formulation F 1, the optimal LP relaxation solution has v i,j =1 /n,  X  i  X  N,  X  j  X  N . For Formulation F 2, the optimal LP relaxation solution has u i,j =1 / 2 ,  X  j  X  N,  X  i  X  N,j = i . Thus, any heuristic based on the LP relaxation solutions is potentially no better than a random permutation of the sites.

Problem P 1 lends itself to improvement heuristics since it is easy to evaluate the Lazarus count for a given permu-tation of sites. For ease of exposition, we refer to permu-tations of sites, instead of matrices/graphs. Given a permu-tation, our heuristic improves the solution ( i.e. , finds a per-mutation with smaller Lazarus count) using the following operations: exchange, reverse, or insert; see Figure 2.  X  EXC (  X , i, j ) : By applying EXC (  X , i, j ) ,weex- X  REV (  X , i, j ) : By applying REV (  X , i, j ) ,wereverse  X  INS (  X , i, j ) : By applying INS (  X , i, j ) , we insert the Thus, given a total order defined by permutation  X  0 , our algorithm ( A 1) uses the preceding operations for all combi-nations of sites so long as it keeps finding better solutions. 1.  X  :=  X  0 2. l = L (  X  ) 3. While  X  i, j such that L ( EXC (  X , i, j )) &lt;l , 4. While  X  i, j such that L ( REV (  X , i, j )) &lt;l , 5. While  X  i, j such that L ( INS (  X , i, j )) &lt;l , 6. If L (  X  ) &lt;l , goto Step 2.
 In each of these steps, the sequence in which i, j are chosen depends on the implementation of the algorithm. One can develop various  X  X anking X  criteria and sort the sites based on such criteria. For the EXC and REV operations, we consider pairs i, j that are most dissimilar first. The moti-vation behind this is that changing the relative positions of highly dissimilar sites change s the Lazarus count most dra-matically. For INS , we consider sites that are most similar first. By doing so, we try to put similar sites together first. Thus, we use a notion of similarity between sites based on the ranking criteria to choose pairs of sites. A simple crite-rion that works well is sorting the sites based on the number of active genera on the site ( i.e. , number of 1 sinrow). Of course, one could use any ranking criteria based on the pair-wise distance (for instance, the L 1 distance) between sites.
Another strategy that speeds up the algorithm is switch-ing between the three operations often (see Section 4 for a computational example). However, the final total order does not seem to depend on the criteria. In our computations, we choose pairs of sites randomly, and initialize the algorithm with a random  X  0 . In Section 4.3, we show that Algorithm A 1 is quite insensitive to the randomization.
Now we present our technique for discovering a minimal partial order, given a total order T . This partial order must be minimal with respect to L ( T ) .Inotherwords,givena total order T ,wewishtofind P  X  T such that L ( P )= L ( T ) ,and L ( P ) &lt;L ( P ) ,  X  P  X  P .

Any partial order P can be represented as an acyclic di-rected graph G P =( V, A P ) ,where V  X  N is the set of nodes, and A P is the set of arcs. In this representation, we include both redundant and non-redundant arcs in A P (see Definition 2). For each ordered pair of sites ( i, j ) in the par-tial order P , there exists an arc from node i to node j in A We d e fi n e f P ( i ) as the set of sites in P that are immediate successors of node i ; i.e. , f P ( i ) is the set of all nodes to whom there exists a non-redundant arc from node i . Thus, The set f P (  X  ) is crucial in the development of an incre-mental algorithm to discover a minimal partial order. Let j  X  f P ( i ) . Given a partial order P , we can obtain partial order P  X  P such that | P | = | P | X  1 by removing ( i, j ) from P ,forsome i  X  N . In fact, this is the only operation that reduces | P | by exactly 1 . In other words, if we elimi-nate ( i, l ) where l/  X  f P ( i ) , then the resulting set of ordered pairs is not a partial order since it is not transitive.
The simple operation REDU CE removes exactly one element from a partial order such that the resulting collec-tion of elements is also a partial order.  X  REDU CE ( P, i, j ) . We define this operation only for Next, we prove that this simple operation is non-exclusive; i.e. , all minimal partial orders can be found using it. Theorem 7 Any partial order P such that P  X  P can be discovered by a sequence of REDU CE operations from P .
Proof: (By construction.) Consider any partial order  X  P such that P  X   X  P  X  P .Let D be the set of arcs that define non-redundant orderings in  X  P , but not in P .Since D = by applying REDU CE (  X  P,i,j ) for some ( i, j )  X  D ,we get a new partial order  X  P such that  X  P  X   X  P . Setting  X  P , and repeating this until D =  X  ,weget P from P . From Theorem 1, L ( P )  X  L ( P ) for all P  X  P .Inother words, for all partial orders that are subsets of partial order P , the Lazarus count must be no greater than the Lazarus count of P . Furthermore, if the Lazarus count of all such partial orders is strictly less the Lazarus count of P ( i.e. , L ( P ) &lt;L ( P ) ,  X  P  X  P ), then partial order P is minimal with respect to L ( P ) (from Definition 5).

This motivates an intuitive algorithm for discovering minimal partial orders. We keep removing ordered pairs from our partial order as long as the Lazarus count does not decrease. In other words, we successively apply operation REDU CE while ensuring that the Lazarus count remains the same. When we can not find such an ordered pair to remove, we terminate with a minimal partial order. We for-malizes this method for finding a minimal partial order with respect to L ( T ) as Algorithm A 2. 1. P := T 2. While  X  j  X  f P ( i ) such that P = REDU CE ( P, i, j ) In this algorithm, the sequence in which i and j are chosen is unspecified above. For a suitably defined distance metric, we could choose pairs of sites i, j that are most similar first. This is motivated by the argument that such arcs between similar sites are more likely to be redundant.

In our implementation, we chose these pairs of sites ran-domly. In Section 4.3, we present a computational test that indicates that our algorithm is insensitive to the random-ization. The implementation can be done more efficiently using appropriate data structures that track the  X  X ext X  and  X  X revious X  1 s for each Lazarus event. For any implementa-tion of Algorithm A 2, we state the following result. Theorem 8 A 2 terminates with a minimal partial order.
In this section, we analyze the performance of our algo-rithms. We study the partial order discovered in the best run of our algorithm, and compare our results with [17]. Recall that our algorithm is non-parametric. However, it is randomized. In Section 4.3, we show that our algorithm is quite insensitive to the seeding. On the other hand, the al-gorithm presented in [17] is highl y parametric. Therefore, it requires a lot of tuning. This is why, in Table 4, we present only one run of our algorithm, while presenting a statistical summary of the runs in [17].

We test our algorithms on only one dataset, for two rea-sons. Firstly, we are not aware of other datasets of compa-rable size that have been classified by experts with domain information. Secondly, this dataset has been used in other work, in particular [17], allowing for a direct comparison.
This data is taken from the NOW database [12]. This database contains a record of Miocene to Pleistocene land mammal species at various Eurasian fossil sites. These sites have been classified into MN classes by experts with do-main information. In fact, we analyze our algorithm by comparing its partial ordering with the partial ordering ob-tained from this classification. To compare our results with [17], we consider the same set of sites and genera. ( 124 sites and 139 genera). We remark that this instance has a very large solution space ( &gt; 100! feasible orders). Recall that Algorithm A 1 uses three operations: EXC , REV ,and INS . We observed that the algorithm is much faster when we switch between the operations often. In this experiment, we vary how often we switch between oper-ations. We run the algorithm with four settings: change operation after every n/ 6 , n/ 3 , n ,and 3 n/ 2 improvements, respectively. On the y -axis, we plot the Lazarus count of the total order obtained by the algorithm as a function of time (on the x -axis). From Figure 3, we see that the Lazarus count reduces more appreciably in the initial stages when we switch operations more often. This indicates that the marginal improvement with each operation reduces with time. Nevertheless, the final Lazarus count generally does not seem to depend on the strategy.

Let MN ( i ) be the MN classification for site i .Forany total order T of 124 sites, | T | = 7626 . To quantitatively compare the performance of our algorithm with [17], we use the following attributes of a partial order P .Thefirsttwo attributes quantify the size and Lazarus count of a partial order. The latter three measur e its  X  X loseness X  to the partial order P MN defined by the MN classification scheme.  X  Completeness:  X  P .
  X  Lazarus count: L ( P )  X  Success count: c P  X  Similarity count: d P  X  Compatibility: r P We note that in [17], the authors also include, for all sites i  X  N , the ordered pair ( i, i ) in the description of partial orders. This offsets the size of any partial order P by n .but does not affect the Lazarus count, success count, similarity count, or the compatibility. However, the value of com-pleteness changes slightly; we adjust for this appropriately in our comparisons.

Recall that we wish to discover a partial order (say P ) satisfying property FPO. We want P to have the lowest completeness among all partial orders with Lazarus count L ( P ) . To illustrate the strength of our methodology, we also want to prove that partial orders that satisfy property FPO are closer to P MN . To this effect, we introduce the notion of dominance for comparing two partial orders. One partial order dominates another if it scores better in terms of both Lazarus count and success count.
 Definition 6 Dominance: We say that partial order P 0 dominates partial order P if 1. c P 0 &gt;c P , and 2. L P 0 &lt;L P .
 We see next that while the algorithm in [17] gives interest-ing partial orders, they are dominated by our partial order. We present the results of a run our algorithms ( followed by A 2), and analyze the output in detail. We present the final partial order in Figure 4 (created using Graphviz[7]). We refer to this partial order as P 0 .Forthe sake of illustration, we only present the non-redundant arcs in the graph. Furthermore, we break the graph into three pieces; the graph should be read from top to bottom and from left to right. Each node represents a site, and the num-ber in square braces is its MN classification.

In Table 4, we compare the performance of our algorithm with [17]. In columns 2, 3, and 4, we present the average, best, and standard deviation for 24 runs (with different set-tings) of the algorithm presented in [17]. We note that in [17], the best values of the various attributes are from dif-ferent runs. In column 1, we present the values of the pre-ceding attributes for the partial order P 0 given in Figure 4. In column 5, we present these values for P MN . 1 L ( P ) 3228 3687 3233 212.3 2957 2 c P 6723 6474 6587 62.6 6995 3 d P 274 25.6 53 14.7 631 4 r P 6997 6511 6588 74.6 7626 5  X  P 0.964 0.972 0.944 0.014 0.917 Comparing columns 1 and 2, we see that our partial order P 0 has a lower Lazarus count than [17], and at the same time higher success counts, similarity counts, and compatibility. In fact we obtain lower Lazarus counts (columns 1 and 3) and higher success counts, similarity counts, and compati-bility (columns 1 and 3) than all runs in [17]. In other words, P 0 dominates all the partial orders in [17]. This illustrates the effectiveness of our methodology and algorithm.
The biggest difference in performance between the two approaches is in compatibility (row 4). The compatibility of our partial order ( r P 0 = 6997 ) is significantly larger than that of any runs in [17] (maximum r = 6588 ). This shows that our technique matches up with the MN classi-fication system much better. Even comparing the success count (row 2) and similarity count (row 3) separately, we see that P 0 outperforms all partial orders in [17].
Looking at the success counts and completeness (rows 2 and 5), we see that partial order P 0 (column 1) has much higher success count ( 6723 ) than partial orders from [17] (column 2) even though its completeness is smaller. Thus, even though the size of P 0 is smaller, it still gets more orders in sync with the MN classification.

We next analyze why partial orders we find are more likely to satisfy FPO. We see that P 0 has lower complete-ness (row 5) than [17]. This is because we find minimal partial orders, removing all orderings that do not contribute to the Lazarus count.

From column 6, we see that P MN has a much lower completeness (row 5), but this is not surprising considering how it is constructed (no ordering among sites in the same class). We also see that P MN has a much lower Lazarus count (row 1), but that can be attributed to its lower com-pleteness. Also, P MN attains the maximum values of the compatibility parameter; r P ( P MN )= | T | . Thisisnosur-prise since this parameter measures how well a partial order matches with the MN classes.
 Finally, we qualitatively analyze how the partial order P 0 matches with the MN classification system. From Ta-ble 4, we see that P 0 matches very well with the classifi-cation system ( r P / | T | =0 . 92 ). For example, all the sites in the MN =9 class (early late Miocene localities) clus-ter together (Can Ponsic/Esselborn to Los Valles de Fuen-tidue  X  na). At the same time, it bodes well to reevaluate the classification for certain sites which seem highly out of place in P 0 (for instance, Layna and Poksheshty). In fact, even in the partial order illustrated in Figure 2 in [17], Layna, which has an MN classification of 13  X  14 , is placed alongside sites with MN classification 17 .
We present a statistical analysis of many runs of our al-gorithms, each run with a different seed to the random num-ber generator. Table 5 summari zes the results of this exper-iment. In row 1, we present the statistics for the Lazarus count of the total order found by Algorithm A 1. In row 2, we present the statistics for the size of the minimal partial order discovered by Algorithm A 2. To compare  X  X pples against apples X , all runs of Algorithm A 2 are seeded with the same total order as in Sec tion 4.2. We repeated this ex-periment for algorithm A 2 with different initial total orders, but the numbers were comparable; we do not present them here. In columns 1, 2, 3, and 4, we display the average, minimum, maximum and standard deviation for these runs. 1 A 1 Lazarus count 3236 3228 3244 3.7 2 A 2 Size 7409 7331 7451 26.3
From row 1, we see that Algorithm A 1 is extremely ro-bust. The standard deviation of the Lazarus counts is 3 . 7 , less than 2% of the average ( 3236 ). Algorithm A 2isalso quite robust, with the standard deviation of the size of the partial orders at 26 . 3 ,lessthan 4% of the average partial order of the sample ( 7409 ). This illustrates that our algo-rithms, while not guaranteeing optimality, yield results that are quite good all the time. There is minimal dependence on the inherent randomization in the algorithms.

To illustrate how small this dependence is, we present the output of Algorithm A 2 in detail. Observe that the size of a total order of 124 sites is 7626 . In Figure 5, we plot the size of the partial orders found by Algorithm A 2. We see that the variation in the size of the partial order discovered by Algorithm A 2 is small. 7000 8000 6000
We have shown that the performance of our randomized algorithms is highly insensitive to its randomization.
In this paper, we introduced a new methodology for dis-covering interesting partial orders in data, in that we aim to discover partial orders that satisfy property FPO. We fo-cused on an application from paleontology where we need to chronologically order fossil sites. These sites can be or-dered by minimizing Lazarus counts. To achieve this goal, we first calculated interesting total orders, and then deter-mined a minimal partial order.

In the first problem, we wish to find the total order with minimum Lazarus count. We firs t formulated this problem using exact integer programming techniques. These integer programming formulations performed poorly even for small problems; we proved that this is because they have weak LP relaxations. As a result, we resorted to heuristics, and described an improvement algorithm to discover interesting total orders. Then, given this to tal order, we described an al-gorithm to discover a minimal partial order. We performed a sensitivity analysis on our algorithms, and showed that the performance is quite insensitive to this randomization.
Finally, we presented computations that illustrate the ef-fectiveness of our algorithm, mainly comparing our results with the most closely related work of [17]. We showed that the partial order found by us is significantly better than par-tial orders presented in [17] for the same data set, for a va-riety of benchmarks. In particular, our partial order domi-nates all partial orders presented in [17].

For future work, we intend to continue in two distinct di-rections. In the former, we wish to focus on this application, and plan to study the problem of chronologically ordering fossil sites in more detail. In particular, we would like de-velop to more effective exact techniques for solving prob-lems P 1and P 2 (possibly using better IP formulations). In the latter direction, we wish to apply our methodology to other domains, on other ordering problems.

