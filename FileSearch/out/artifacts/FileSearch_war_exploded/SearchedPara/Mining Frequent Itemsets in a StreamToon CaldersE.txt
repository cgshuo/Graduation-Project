
We study the problem of finding frequent itemsets in a continuous stream of transactions. The current frequency of an itemset in a stream is defined as its maximal frequency over all possible windows in the stream from any point in the past until the current state that satisfy a minimal length constraint. Properties of this new measure are studied and an incremental algorithm that allows, at any time, to im-mediately produce the current frequencies of all frequent itemsets is proposed. Experimental and theoretical analy-sis show that the space requirements for the algorithm are extremely small for many realistic data distributions.
Mining frequent sets over streams of itemsets presents interesting new challenges over traditional mining in static databases. Due to the speed of new arriving data, it is as-sumed that the history of the stream can not be revisited, unless it is stored. Storing large parts of a stream, however, is impossible as the amount of data is typically huge.
Most previous work on mining frequently occurring itemsets over data streams either focusses on (1) the sliding window model, (2) the time-fading model, or (3) the land-mark model. Each of these models requires a fixed window length or decay factor, given by the user. In many applica-tions, however, choosing such parameters that are most ap-propriate for every itemset at every timepoint in an evolving stream is almost impossible. For example, consider a large retail chain of which sales can be considered as a stream. Then, in order to find frequent sets to do market basket analysis, it is very difficult to choose in which period of the collected data you are interested. For many products, the amount of them sold depends highly on the period of the year. In summer time, e.g., sales of ice cream increase and during the soccer world cup, sales of beer increase. Such seasonal behavior of a specific item or combination of items can only be discovered when choosing the correct window size for that item(set). This size, however, can hide a similar behavior of other item(set)s in another window.

Therefore, we propose to consider for each itemset the window in which it has the highest frequency. More specif-ically, we define the current frequency of an itemset as the maximum over all windows from the past until the current state that satisfy a minimal size constraint. Notice that this is an extension of the max-frequency measure defined be-fore for items [1]. Hence, when the stream evolves, the length of the window containing the highest frequency for a given itemset can change continuously. This new stream measure turns out to be very suitable to early detect sud-den bursts of occurrences of itemsets, while still taking into account the history of the itemset. This behavior might be particularly useful in applications where hot topics, or pop-ular combinations of topics need to be tracked. Examples of such applications include, e.g., identifying stocks with a strong growth or tracking popular search terms on the inter-net. In these applications it is of vital importance to identify sudden bursts quickly, while still taking into account the history.

Concretely, our contributions are the following. First, (1) the max-frequency measure [1] is extended to itemsets and minimal window length, and (2) a detailed study of its behavior is performed, taking into account minimal win-dow length and minimal frequency thresholds, resulting in several important properties. (3) An efficient algorithm for computing the exact frequencies for all frequent itemsets at any time is proposed; this in contrast to the often only ap-proximate algorithms for other methods. Finally, (4) a the-oretical and empirical evaluation of our proposed method is given.

The organization of the paper is as follows. In Section 2, the new measure is defined and the central problem state-ment is formally introduced. Section 3 gives several prop-erties of the max-frequency and states the main theorem, on which the incremental algorithm in Section 4 is based. In Section 5, a theoretical analysis for the worst case is done. Experimental results in Section 6 show that the memory re-quirements for the algorithm are extremely small for many real-life data distributions. In Section 7, the relation be-tween our measure and existing related work is explored, and Section 8 concludes the paper.
A stream I 1 I 2 ... I n is a sequence of itemsets, de-noted S , where n = | S | is the length of the stream. I 1 considered the first and oldest itemset in the stream, and I the latest and most recent. We assume that the items in the stream come from a finite set of items I .

The number of sets in a stream S that con-tain itemset I is denoted count ( I, S ) . For example, count ( a, ab c adf )=2 and count ( af, ab c adf )= 1 .The frequency of I in S is defined as For example, freq ( a, ab c adf )=2 / 3 and freq ( af, ab c adf )=1 / 3 .
 Let S 1 be I 1 1 ...I 1 n 1 , S 2 be I 2 1 ...I 2 n 2 , ... and S m be I m 1 ...I m n m .The concatenation of the streams S ,..., S m , denoted S 1  X  S 2  X  ...  X  S m ,is
Let S = I 1 I 2 ... I n . Then, S [ s, t ] denotes the sub-stream or window I s I s +1 ... I t . The sub-stream of S consisting of the last k items of S , denoted last ( k, S We are now ready to define our new frequency measure: Definition 1 Given a minimal window size mwl ,the max-frequency mfreq mwl ( I, S ) of itemset I inastream S is de-fined as the maximum of the frequencies of I over all win-dows, of size at least mwl , extending from the end of the stream; that is: mfreq mwl ( I, S ) := max If the length of the stream is less than mwl , the max-frequency is defined to be 0 .

The longest window in which the maximum frequency is reached is called the maximal window for I in S , and its starting point is denoted startmax mwl ( I, S ) . That is, startmax mwl ( I, S ) is the smallest index such that mfreq mwl ( I, S )= freq ( I, S startmax mwl ( I, S ) , | S | mwl wil be omitted when clear from the context.
 Example 1 Let mwl =3 .
Figure 1. Max-frequency for minimal window lengths 1 , 3 ,and 10 .

In the definition of the max-frequency, an explicit lower bound is given on the size of the windows in which the fre-quencies are considered. This lower bound is given to re-lieve the undesirable effect of having a frequency of 100% in a window of length 1 , every time the target item arrives in the stream. The effect of the minimal window length mwl is illustrated in Figure 1. It is clear that for longer mini-mal window lengths, there are still jumps in the frequency, but they are less pronounced. Hence, setting an appropriate minimal window length effectively resolves the instability of the max-frequency measure.
A stream was defined as a statical object. In reality, how-ever, a stream is an evolving object that is essentially un-bounded. When processing a stream, it is to be assumed that only a small part of it can be kept in memory.
S t will denote the stream S up to timestamp t ; that is, the part of the stream that already passed at time t , S t = S For simplicity, we assume that the first itemset arrives at timestamp 1 , and since then, at every timestamp a new item-set is inserted into the stream.

The main problem we study in this paper is the fol-lowing: Given a minimal frequency threshold and a min-imal window length, for an evolving stream S , main-tain a small summary of the stream in time, such that, at any timepoint t , all current frequent itemsets can be produced instantly from this summary. More formally, we will introduce a concise summary, summary ( S t ) , and efficient procedures Update , and Get mfreq , such that Update ( summary ( S t ) ,I ) equals summary ( S t  X  I ) , and Get mfreq ( summary ( S t +1 )) equals mfreq mwl ( A, S t +1
Because Update has to be executed every time a new itemset arrives, it has to be extremely efficient in order to be finished before the next itemset arrives. Similarly, because the stream continuously grows, the summary must be inde-pendent of the number of items seen so far, or, at least grow very slowly as the stream evolves. The method we develop will indeed meet these criteria, as the theoretical analysis in Section 5, and the experiments in Section 6 show.
For ease of presentation, we present our solution in a modular way; first we present how a summary can be main-tained that allows for one itemset A , to produce its max-frequency at any point in time, for the case no minimal win-dow length has been set. Notice that no minimal window length actually corresponds to having a minimal window length of 1 . We denote the max-frequency of A in S with-out minimal window length simply as mfreq 1 ( A, S ) . Then, we extend the method to work with minimal window length and minimal frequency, but still for only one target itemset A . Finally, we show how to combine everything into one solution for mining all frequent itemsets at once, without having to maintain a separate summary for every itemset.
In this section, we show some properties of max-frequency for one itemset A without a minimal window length constraint. These properties will be crucial for the incremental algorithm that maintains the summary of the stream for A .

Obviously, checking all possible windows to find the maximal one is infeasible algorithmically, given the con-straints of stream problems. Fortunately, not every point in the stream needs to be checked. The theoretical results from this section show exactly which points need to be inspected. These points will be called the borders in the stream. The summary of the stream will consist exactly of the recording of these borders, and the corresponding frequency of the target itemset.
 Definition 2 Timestamp q is called a border for set A in S there exists a stream B such that q = startmax ( A, S  X  B Thus, a border is a point in the stream that can still become the starting point of the maximal window. Based on the next theorem, it is possible to give an exact syntactic characteri-zation of the borders.
 Theorem 1 Let S be a stream of length L , and let S [ q, L ] be the maximal window for the itemset A . Then, for any p , r with p&lt;q  X  r : freq ( A, S [ p, q  X  1]) &lt; freq ( A, Proof 1 Let B 1 denote S [ p, q  X  1] , B 2 denote S [ q, r ] , and B 3 denote S [ r +1 ,L ] . Because B 2  X  B 3 is the maximal window for A in S , it holds that the frequency of A in B 2  X  B 3 is strictly higher than in B 1  X  B 2  X  B 3 and it is at least as high as in B 3 (remember that in the case of multi-ple windows with maximal frequency the largest one is se-lected). Now, let l 1 = | B 1 | , l 2 = | B 2 | , and l 3 and let a 1 = count ( A, B 1 ) , a 2 = count ( A, B 2 ) , and a 3 = count ( A, B 3 ) , as depicted in: Then, the conditions on the frequency translate into: From these conditions, it can be derived that Corollary 1 Let S be a stream of length L , and let 1  X  q L . Position q is a border for target itemset A in S if and only if for all indices j, k with 1  X  j&lt;q and q  X  k  X  L ,it holds that freq ( A, S [ j, q  X  1]) &lt; freq ( A, S [ q, k ]) . Proof 2 Only if: Follows directly from Theorem 1.
If: We need to show that there exists a continuation S of stream S (resulting in stream S  X  S )inwhich q is the starting point of the maximal window. We consider two cases: either q is the rightmost border in S , or not. If q is the rightmost border, then q is the maximal border in S , because for any other border p&lt;q , freq ( A, S [ p, q  X  1]) &lt; freq ( A, which implies freq ( A, S [ p, L ]) &lt; freq ( A, S [ q, L ]) , and hence the Corollary holds.

In the other case, we will show that it is always possible to continue S in such a way that the rightmost border disap-pears, while all other borders remain and no new borders are introduced. By consecutively applying this procedure, any border will eventually become the rightmost border at one point, and hence become the starting point of the maxi-mal window.

Let q&lt;q be the two largest borders in S . Since, because of the only-if part of this theorem, we can always find positive integers x  X  y such that: Then, the following continuation of S has exactly the same borders as S , except from q , which is no longer a border: Example 2 Assume we have the stream S 27 , given in Fig-ure 2 and we focus on target { a } . In this stream, two posi-tions have been marked with a backslash. Both these points do not meet the criteria to be a border given in Corollary 1. Indeed, for both positions, a block before and after it is in-dicated such that the frequency in the before-block is higher than in the after-block. The only positions that do meet the requirement are indicated by vertical bars.
Based on the results of Section 3, we present an incre-mental algorithm to efficiently maintain the summary for one itemset A allowing us to produce the current max-frequency (without minimal window length constraint) of an itemset instantly at any time.
Let p 1 &lt;p 2 &lt; ... &lt; p r be the border positions for itemset A in the stream S t , ordered from oldest to most re-cent. Let a i = count ( A, S t [ p i ,p i +1  X  1]) be the number of occurrences of the target itemset A in between two subse-quent border positions p i and p i +1 (for i =1 ,...,r  X  1 ). a r = count ( A, S t [ p r ,t ]) denotes the number of occur-rences of A since the last border. The summary S t of S t is defined as the array We can easily compute the frequencies of itemset A for any of the border positions from this summary: Example 3 The summary S 17 for target a in stream We can find the frequencies of itemset { a } since any of the border positions:
We now give some properties of the summary that will be used by the algorithm. First of all, we show that the fractions in the blocks in between two subsequent border positions are increasing, and as a consequence, among all equal to r .
 Property 1 Let S t be a stream and summary ( S t )= [( p 1 ,a 1 ) ,..., ( p r ,a r )] . Then, and freq ( A, S t [ p 1 ,t ]) &lt; freq ( A, S t [ p 2 ,t ]) &lt; (The proof is a direct consequence of Corollary 1).
From this property, it follows directly that the last entry of a summary always represents the max-frequency.
On every timestamp a new itemset arrives and the summary needs to be updated. Algorithm 1 presents the pseudo-code of the algorithm. First the summary is initialized after the first target itemset entered the stream. Then, we consider the following cases. 1. A superset of the target itemset arrives in the stream (lines 6 X 10): (a) (lines 7 X 8) If the frequency of the last block is 1 , and (b) None of the existing borders can be removed from the 2. An itemset not containing the target itemset arrives in the stream (lines 11 X 20): (a) No new borders need to be added to the summary. (b) This is the only case in which borders can actually Algorithm 1 Update ( S t ,I ) for target itemset A on time t +1 Require: S t = summary ( S t )=[( p 1 ,a 1 ) ,  X  X  X  , ( p r Ensure: S t +1 = summary ( S t +1 )= summary ( S t  X  I ) 2: if ( S t is empty) then 3: if (target itemset A  X  I ) then 4: S t +1 := [( t +1 , 1)] 5: else 6: if (target itemset A  X  I ) then 7: if a r = t  X  p r +1 then 8: S t +1 := [( p 1 ,a 1 ) ,  X  X  X  , ( p r ,a r + 1)] 9: else 10: S t +1 := [( p 1 ,a 1 ) ,  X  X  X  , ( p r ,a r ) , ( t +1 , 1)] 11: else 13: i := r 14: while i&gt; 1 do 17: remove ( p i ,a i ) from S t +1 18: i := i  X  1 19: else 20: i := 1 Example 4 The working of the algorithm is explained in detail for the following stream and target itemset { a } . In Figure 3, a sample run of the algorithm is illustrated for each timepoint.

In this example, some interesting things happen. First of all, the stream starts with an itemset, { b } , that does not con-tain the target itemset { a } . Therefore, Update ( S 0 , Update ([ ] , { b } ) at timestamp 1 remains empty, i.e., S [] . At timestamp 2 , Update ([ ] , { a } ) results in S [(2 , 1)] , corresponding to the stream b | a with a border at position 2 and the corresponding frequency 1 / (2  X  2+ 1) = 1 / 1 . At timestamp 8 , something interesting hap-pens. S 7 = [(2 , 3) , (6 , 2)] , corresponding with stream b | aaab | aa . Update ( S 7 , { b } ) will yield S 8 = [(2 , 5)] , and not [(2 , 3) , (6 , 2)] . Because the corresponding frequencies decrease from the border at position 2 to the border at position 6 , namely (3+2) / [(6  X  2)+(8  X  6+1)] = 5 / 7 &gt; 2 / (8  X  6+1)=2 / 3 , we can conclude that position 6 is no longer a border. This is reflected in summary S 8 [(2 , 3 + 2)] and can be visualised by b | aaabaab .
Until now, we assumed that for the target itemset we need to be able to report its frequency exactly. We will now relax this requirement by setting a minimal frequency threshold minfreq . That is, for the target itemset, we should be able, at any timepoint, to produce its exact frequency only if it is above the frequency threshold. This relaxation allows us to decrease the size of the summary.

Let S t be a stream with S t =[( p 1 ,a 1 ) ,..., ( p r ,a suppose that Then we can safely remove ( p 1 ,a 1 ) from the left-side of the summary; even though it is possible that p 1 can still become the starting point of a maximal window in the future, it can be proven that it can never be the starting point of a maxi-mal window in which the target item is above the threshold . Indeed; suppose that freq ( A, ( S t  X  B )[ p 1 ,t + | B | the minimal frequency threshold, then it is easy to show that freq ( A, B ) must be even larger, and hence p 1 is not the maximal border. In order to be able to perform this pruning efficiently, we store and maintain for the summaries also the count total = a 1 + a 2 + ... + a r . When the left-most border is pruned, total is decreased by a 1 to reflect the new total.
In the algorithm without minimal window length, as given in Algorithm 1, we use the fact that a border q in stream S can be pruned if we can find two blocks B 1 = S [ p, q  X  1] and B 2 = S [ q, r ] such that the frequency of the target in B 1 is higher than in B 2 . The intuition behind the proof of this theorem is that in such a situation, q can never become a border again, because either the window starting  X  X  X  a  X  X  X  2 2 3  X  X  X  2 9 a  X  X  X  2 12 17 at p will have higher frequency, or the window starting at r +1 has. When we are working with a minimal window length, however, this observation does no longer imply that q can be pruned! Indeed; it could be the case that the suffix of the stream starting at r +1 does not meet the minimal window length requirement. In that case, even though the window starting at q has lower frequency than the window starting at r +1 , it can still have the highest frequency of all windows that meet the minimal window requirement !The next example illustrates this situation.
 Example 5 Consider stream S = | aaab | aa in which the borders 1 and 5 are marked with a vertical bar. When itemset { b } arrives in the stream, resulting in | aaabaab , then position 5 is no longer a border, as the block aaab before position 5 has a higher frequency of the target item than the block aab after position 5 . Therefore, in the algorithm without minimal window length, the border at position 5 is pruned, because no matter how the stream evolves, position 5 will never be a border again.
However, consider now the case where we do have a min-imal window length of 3 . Then, position 5 can still become a border again! Indeed, suppose two more target itemsets are added to the stream, resulting in: | aaab.aab | aa . In this stream, the window starting at position 5 has the highest frequency of the target items among the windows satisfying the minimal window length .

Similarly, the minimal window length also has an influ-ence on the pruning of summary entries based on the mini-mal frequency. In the case we have to check if we have to remove the last entry of a summary [( p, a )] of a stream we test whether a/ ( t  X  p +1) &lt; minfreq , and the reason-ing is that if this is the case, every extension B that would turn p into a maximal and frequent border, would be even more frequent itself, so p can be removed as a border. With minimal window length, this is no longer true, though, as this B could not meet the minimal window length. In this case, p might be the starting point of the maximal window of length at least mwl .

Fortunately, as the next theorem states, this problem can easily be resolved as follows: Theorem 2 Let S be a stream of length L , and let mwl be the minimal window length. Let S  X  mwl denote S [1 ,L  X  mwl ] .If q = startmax mwl ( A, S ) , then,  X  either, q = L  X  mwl +1 ,  X  or, q is a border in S  X  mwl .
 Proof 3 Notice that, because the length of the maximal window is at least mwl , we have q  X  L  X  mwl +1 . Hence, either q = L  X  mwl +1 ,or q&lt;L  X  mwl +1 . In the latter case, we have to show that q is a border in S [1 ,L  X  mwl ] . Because of Theorem 1 it now suffices to show that for any positions p and r in S [1 ,L  X  mwl ] , such that 1  X  p&lt;q&lt;r  X  L  X  mwl , the frequency of A in S [ p, q  X  1] is less than the frequency of A in S [ q, r ] . We denote the number of occurrences of target A in S [ p, q  X  1] by a and q  X  p by b , and we denote the number of occurrences of the target A in S [ q, r ] by c and r  X  q +1 by d . The number of occurrences of the target A in
S [ r +1 ,L  X  mwl ] is denoted x and y is L  X  mwl  X  r and the number of occurrences of the target A in last ( mwl , by t . These notations are summarized in the next picture: Using basic arithmetic operations, it is easy to show that in this setting, freq ( A, S [ p, q  X  1]) &lt; freq ( A, S i.e. a/b &lt; c/d .

Hence, in order to know the maximal frequency with a minimal window length mwl , it suffices to apply the method without any minimal window length to keep track of the bor-ders for the stream S [1 ,L  X  mwl ] . Then, when we need the max-frequency, we check the borders of S [1 ,L  X  mwl ] in the complete stream S , and the minimal window itself, last ( mwl , S ) .
Until now, we merely focused on mining a single fre-quent itemset. Of course, in reality, the goal is to find all frequent itemsets in the stream. A straightforward way to do this is to apply Algorithm 1, together with Theorem 2 for all itemsets at the same time. That is, for every itemset, we maintain a summary for the stream minus the last mwl transactions. Of course, this is impossible to do for all item-sets. Fortunately, this can be resolved using the following observation (without proof due to space limitations). Theorem 3 Let S be a stream of length L . S  X  mwl denotes S [1 ,L  X  mwl ] . Suppose that mfreq mwl ( A, S )  X  minfreq . If q = startmax mwl ( A, S ) , then,  X  either L  X  2  X  mwl +2  X  q  X  L  X  mwl +1  X  or, the following conditions are all fulfilled: Proof 4 First of all, because the length of the maximal window is at least mwl , we have that q  X  L  X  mwl +1 .We now can have that q&gt;L  X  2 mwl +1 or q  X  L  X  2 mwl +1 . The first case, q&gt;L  X  2 mwl +1 , leads to the situation L  X  2 mwl +2  X  q  X  L  X  mwl +1 . In the case that q  X  L  X  2 mwl +1 , we have to prove the above three statements.

This can easily be proven using similar techniques as in the proof of Theorem 2.

Hence, we do not need to maintain the summaries of all itemsets, but only of those that were once frequent in the minimal window, and that are, at the same time, frequent now within the part of the stream S [1 ,L  X  mwl ] . Further-more, we need to find the frequent itemsets in the mwl win-dows S [ L  X  2 mwl +1 ,L ] , ... , S [ L  X  mwl, L ] .
Hence, the algorithm to update the summary when a new transaction T arrives is as follows: for every itemset A for which we are maintaining a summary, update the summary with the transaction that leaves the minimal window. Check if max-frequency in the part of the stream without the min-imal window is still frequent. If not, remove the summary. Then, for all itemsets that are frequent in the minimal win-dow and for which we are not yet maintaining a summary, start a summary. In this way, we guarantee that we are able to capture all maximal windows with q  X  L  X  2  X  mwl . Furthermore, we always keep the last 2  X  mwl transactions. When the frequent itemsets are required, we need to gener-ate all frequent itemsets from the summaries plus all item-sets frequent in one of the windows S [ L  X  2 mwl +1 ,L ] , ... , S [ L  X  mwl, L ] . This can be done efficiently with a small adaptation to efficient incremental algorithms that have al-ready been proposed in literature [11].
In this section we study how large the summary can be in worst case. For a specific streamlength l , we will identify a stream of this length that maximizes the number of borders. Farey sequences play an important role in this analysis.
Consider a stream of length l in which we have N bor-ders, and the blocks separated by these borders have lengths l , ..., l N , and contain respectively a 1 , ..., a N times the target:
From Theorem 1, we know that the frequencies of the target itemset in the blocks must be increasing: Thus, with every stream with N borders corresponds such an increasing sequence of N fractions. We call this se-quence of fractions the block frequency sequence of the stream. The length of the stream is the sum of the denom-inators l 1 + ... + l N . The other direction is also true: for every increasing sequence of numbers we can find a stream of length l 1 + ... + l N with N borders, namely: We will call this stream the canonical stream associated with the sequence a 1 /l 1 &lt;a 2 /l 2 &lt; ... &lt; a N fore, finding the maximal number of borders for a stream length l corresponds to finding the largest number of dif-ferent fractions between 0 and 1 , of which the sum of the denominators adds up to l . In this context, the notion of Farey sets and Farey sequences will be very useful. Definition 3 The Farey set of order k , denoted F k is the following set of completely reduced fractions: The Farey Sequence [2] of order k , is the list where the elements of F k are ordered in increasing order.

Just like any other increasing sequence of fractions, also the Farey sequence F k can be associated with its canonical stream F k , which has | F k | borders, and a length that equals the sum of the denominators of the elements in F k .For example, consider the Farey sequence of the fifth order: The corresponding Farey stream of the fifth order, F 5 ,is given in Figure 4. This stream has | F 5 | =10 borders and a total length of 5+4+3+5+2+5+3+4+5+1=37 .

We will now show that the Farey streams have the maxi-mal number of borders; that is, for every stream S of length equal to the length of F k , the number of borders in S is less than or equal to the number of borders in F k = | F k | .This result is based on the following straightforward observation. is the sum of the denominators of the elements in S . Lemma 1 Let S = { a 1 /l 1 ,...,a N /l N } be a set of N dif-ferent fractions, with 0 &lt;a i &lt;l i , for all i =1 ...N . Let k be such that | S | &gt; | F k | , then Theorem 4 Let S be a stream with L = | F k | . Then, the number of borders in S is at most the number of borders in F .
 Corollary 2 Let l = dsum ( F k ) , and N = | F k | , for a fixed k . A stream of length l has maximally N borders.
For a Farey stream F k the number of borders in it equals |
F k | and the length equals dsum ( F k ) . This representation does, however, not reveal the actual ratio between the size and the number of borders of a stream. Therefore, the as-ymptotic behavior of these quantities has been worked out, based on known results in number theory. This leads to the observation that, asymptotically, the num-ber of borders N and the length of the stream L in worst case are related as follows: Experiments for Farey streams up to length 10 7 has shown this approximation to be extremely accurate.
Figure 6. Size of the summaries for a real-life dataset
From the description of the algorithm it is clear that the update procedure is very efficient, given that the summaries remain small. Producing the current support of the target itemset is obviously very efficient, as it amounts to simply a lookup of the most recent entry. Hence, the complete ap-proach will be feasible if and only if the summaries remain small. Therefore, for different synthetical streams, we have recorded the size of the summary. The results are reported in Figure 5. For didactic reasons, we consider streams over two items a and b . Note that it does not matter whether we report for 2 itemsets or for 1 000 itemsets, as the itemsets do not influence the size of each others summary. The streams have a length of 10 7 , and after every 10 000 items, the size of the summary for the items a and b are reported. The streams are randomly generated. The probability of having itemset { a } in the stream is given by the line P ( a ) . Thus, in the random graph, the probability of having a is 1 / 2 in the whole stream, independent of the moment. The probability of b is 1 minus the probability of a . The graphs report the average over 100 streams, generated with the indicated dis-tributions. In general, we can conclude that the size of the summary is extremely small w.r.t. the size of the stream. If the probability of the target item increases also the size of the summary will increase, when the probability decreases the summary will shrink. This is easily explained by the en-tries in the summary that need to have increasing frequency.
In Figure 6, this experiment is repeated for a real-life dataset. This dataset was obtained by collecting one month of click-stream data of visitors of the website of the Uni-versity of Antwerp. For every minute a transaction is gen-erated, consisting of the set of all webpages visited in that minute. For every webpage the max-frequency is monitored with a minimal window length of 60 . No minimal support threshold was used. At every timepoint, the maximal and the average number of borders is plotted for all web-pages. As can be seen in this real-life experiment, again the sizes | aaabb | aab | aaab | aaaab | a of the summaries remain extremely small, leading to a very efficient algorithm.
There are already many other measures defined for fre-quency of itemsets over streams. These measures can roughly be divided into three categories: the sliding win-dow model [3, 6, 7, 8, 10, 12], the time fading model [9], and the landmark model [7, 8, 13]. The different frequency measures are illustrated in Figure 7. The bottom line reports the probability at that timepoint in the stream of the itemset for which the frequency is reported. Notice that this bottom line only gives the probability; the actual frequency can be slightly different. At every timestamp, the frequency of the target itemset has been plotted for the different measures.
In the time-fading model [9], the entire stream is taken into account to compute the frequency of an itemset, but more recent transactions contribute more to the frequency than older ones. This is achieved by introducing a decay factor d&lt; 1 . A transaction that is n timepoints in the past, is weighted d n , thus the weight is exponentially de-creasing. In general, the closer to 1 the decay, the more the history is taken into account. In Figure 7, the time-fading frequency has been given for two different decay factors, 0 . 99 and 0 . 999 . Notice that although these two values are very similar, the evolution of the frequency is very different.
In the sliding window [3, 6, 7, 8, 10] model, at every time point, only the data in the most recent window of a prede-fined fixed length (measured either in duration or in number of transactions) is considered. In Figure 7, the sliding win-dow frequency is plotted for window lengths 200 and 400 . Notice that for window length 400 , some of the frequency jumps go by unnoticed and others are significantly lowered, because of the smoothing implied by a large window length.
In the landmark model [7, 8, 13], particular timepoints, called landmarks, are fixed. The analysis of the stream is performed for only the part of the stream between the landmarks and the current time instance. Clearly, this method is less suitable for evaluating evolving and un-bounded streams.

The tilted-time windows [5, 4] can be seen as a combina-
Figure 7. Comparison of different frequency measures tion of the different models. For an itemset, frequencies are computed for the most recent windows of lengths w , 2 w , 4 w , 8 w , etc. So, the most recent part of the stream is cov-ered more thoroughly. The combination of these frequen-cies allow for efficient query answering over the history of the stream.

Also the max-frequency is given (the top line) in Fig-ure 7. As can be seen in the illustration, max-frequency takes into account the history without fading away sudden jumps in the frequency. As a direct result of this, the line for the max-frequency is less smooth than the other lines, be-cause the actual frequency of the item only approximates the given distribution. Notice that these deviations also show in the time-fading model (e.g. with decay .99), al-though in a far less pronounced way. The other methods do not show the existing short deviations from the ideal distrib-ution, as they are less sensitive to short-time changes. Max-frequency is much less dependent on finding the exact right parameter setting than other models, because it only deter-mines a lower bound on the window size; e.g., for a stream of length 10 000 , and extreme minimum window lengths of 10 and 1 000 , still 9 010 of the 10 000 windows are treated in the same way for both parameter settings. In the other models, the parameters completely determine the weight of every point in the stream; for different parameter settings, all 10 000 points in the stream will be handled differently.
We presented a new frequency measure for itemsets in streams that does not rely on a fixed window length or a time-decaying factor. Based on the properties of the mea-sure, an algorithm to compute it was shown. An experimen-tal evaluation supported the claim that the new measure can be computed from a summary with extremely small mem-ory requirements, that can be maintained and updated ef-ficiently. The summary of the stream consists of the bor-ders and their corresponding frequencies. For a specific type of streams, the so-called Farey streams, we theoreti-cally showed an upper bound on the size of the summary, by giving an upper bound on the size of the borders.
