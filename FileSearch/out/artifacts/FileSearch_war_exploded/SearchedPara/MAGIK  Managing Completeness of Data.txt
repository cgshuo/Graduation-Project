 MAGIK demonstrates how to use meta-information about the com-pleteness of a database to assess the quality of the answers returned by a query. The system holds so-called table-completeness (TC) statements, by which one can express that a table is partially com-plete, that is, it contains all facts about some aspect of the domain.
Given a query, MAGIK determines from such meta-information whether the database contains sufficient data for the query answer to be complete. If, according to the TC statements, the database content is not sufficient for a complete answer, MAGIK explains which further TC statements are needed to guarantee completeness.
MAGIK extends and complements theoretical work on model-ing and reasoning about data completeness by providing the first implementation of a reasoner. The reasoner operates by translat-ing completeness reasoning tasks into logic programs, which are executed by an answer set engine.
 H.2.7 [ Database Management ]: Database Administration X  Repos-itory, Data warehouse, Security, integrity, and protection Algorithms, Management Data Quality, Data Completeness, Answer Set Programming
Completeness is a central aspect of data quality which only re-cently has received increased attention in research (cf. [1, 2]) In particular, there are no established techniques and systems to man-age the completeness of data sets up to now.

Recently, Razniewski and Nutt revisited the problem of data com-pleteness. The work was motivated by a project to create a school information system that can give guarantees about the complete-ness of its data X  X n application that shares characteristics with other applications in data integration and decision support [6]. In this scenario, a database instance D may be partially complete in that it contains, e.g., all pupils of classes 1a and 1b, but generally incom-plete because it contains only some of the pupils of other classes.  X 
This work was partially supported by the ESF project 2-299-2010  X  X IS X  X ir verbinden Menschen X , and the European commission FP7 project ICT-2009.4.2  X  X ERENCE X .

Building upon previous work by Motro [5] and Levy [4], they developed a framework to reason about the question whether a gen-erally incomplete database D contains sufficient information to re-turn a complete answer for a specific query Q . In this framework, one can express which parts of which tables are complete, using so-called table-completeness (TC) statements (also called  X  X ocal completeness statements X  in [4]). For instance, one can write TC statements which say that the database instance contains  X  X ll pupils of class 1a X  ( TC 1a ),  X  X ll pupils of class 1b X  ( TC 1b ),  X  X ll pupils in classes of the science branch X  ( TC sc ) or the  X  X umanities branch X  ( TC hum ) of a school, respectively. We expect that in an applica-tion, TC-statements will be generated automatically. For instance, a workflow engine could create a statement after concluding the task of registering the pupils of a class.
 Given a collection of TC statements that hold over an instance D of our school database, we can ask whether they entail that for a certain query Q the set of answers Q ( D ) is complete, that is, whether Q ( D ) contains all answer records that one would expect if D were complete. Examples of queries are the ones for  X  X ll pupils in a class of level 1 X  ( Q lev1 ), or  X  X ll pupils of the school X  ( Q
To find out whether a set of TC statements implies completeness of a query is called TC-QC reasoning. In [6], the authors assessed the complexity of TC-QC reasoning for several types of TC state-ments and queries, under both set and bag semantics.

They did not show, however, how to implement reasoners for these problems. Neither did they take into account the integrity constraints that hold over a database, although in many cases query completeness is only implied by a set of TC statements together with key, foreign key (FK), or finite domain constraints (FD). For instance, in general completeness of the query Q lev1 does not follow from TC 1a and TC 1b alone, but it does if we know in addition that the only code letters for a class are  X  X  X  and  X  X  X , which is a finite domain constraint. As another example, consider query Q sch the two statements TC sc and TC hum . Then completeness of Q does not follow from these two TC statements alone, but it does if in addition there is the FK constraint that every pupil belongs to a class in some branch and if there is the FD constraint that science and humanities are the only branches.

With the MAGIK demonstrator for completeness reasoning, we have made the following contributions:
Section 2 presents a possible demo session of MAGIK, Section 3 sketches the translation of completeness reasoning to answer set programming, and Section 4 gives an overview of the architecture.
MAGIK can reason about queries posed over a fixed schema with key, FK, and FD constraints. Schema and constraints can be loaded from an existing database or can be manually edited. One interacts with MAGIK via a web interface.

This section shows by way of examples which kinds of reason-ing problems MAGIK solves and how one can interact with the sys-tem. We assume that we have defined the schema of a toy school database with the relations Here, pupil ( fred , 1 , a ) means that Fred is a pupil in class 1a; class ( 1 , a , sci ) means class 1a belongs to the science branch; and learns ( fred , french ) that Fred learns French. Underlined attributes make up the primary keys and foreign key constraints hold as one would expect.

Figure 2 is a screenshot of the main page of the MAGIK demo, where we have loaded the schema above as a virtual schema, that is, as a manually edited schema without connection to a database. The page contains four main components: (1) Foreign key constraints, (2) Finite domain constraints, (3) Table completeness statements, and (4) Queries. For each component one can create new entries and modify existing ones. To specify a reasoning task, one acti-vates constraints, TC statements, and a query by clicking. Below, we discuss four examples, where MAGIK analyzes a query with respect to some constraints and TC statements.
 Query Q 1a :  X  X elect the names of all pupils in class 1a X : Suppose, we activate no constraints and no TC statements, only query Q 1a . By pushing  X  X un Query X , we call the reasoner, which replies  X  X uery is not complete X . It analyzes, which parts of the database that are needed for the query are incomplete, suggests to supply the necessary data, and to confirm this by adding a TC state-ment. TC statements are written in a datalog-like syntax. Syntac-tically, a statement for a table R consists of two parts: an R -atom, representing a selection on R and, possibly, a condition, represent-ing a semijoin with other tables. In the current example, the pro-posed statement has the form The atom pupil(P_name,1,a) , where P_name is a variable and 1 , a are constants, represents all records satisfying the selection  X  level=1 , code=a ( pupil ) . We see that, unsurprisingly, MAGIK sug-gests the statement TC 1a from above, or, in words, it proposes to complete the pupils of class 1a.
 Query Q lev1 :  X  X elect the names of all pupils at level 1, X  obtained from Q 1a by dropping the condition  X  p.code =  X  X  X   X . We also activate the FD constraint which states that possible codes for classes are only a and b . Fi-nally, we activate TC statement TC 1a . Clearly, Q lev1 cannot be an-swered completely because information about class 1a is complete, but not about class 1b. Exploiting the FD constraints, MAGIK is able to deduce this and suggests that is, to complete the pupils of class 1b.
 Query Q fr :  X  X elect the pupils of the science branch learning French X : This example illustrates the role of foreign keys. We assume that our database is complete for all learners of French ( TC fr and that the FKs from learns to pupil and from pupil to class are enforced in our database. Then MAGIK reasons that for every learner of French, there are a corresponding pupil record and a corresponding class record. Thus, one can check for each learner of French whether they attend a class of the science branch, so that the query can be answered completely.
 Query Q lfr :  X  X ow many languages does each learner of French learn? X : Since bag semantics is the default in SQL, the query returns each name of a learner of French as many times as there are learns tu-ples with that name. If we only activate TC fr , that is, if we suppose that we are complete for the French learners, but not necessarily for other languages, then MAGIK requests that is, to complete the learns tuples for the names of those pupils who learn French (note, the request is not for all tuples, but only those whose Tl2_name variable satisfies the condition). If we add the keyword DISTINCT , that is, indicate that the query is to be eval-uated under set semantics, then MAGIK finds out correctly that the query is complete, because tuple l2 in the query is superfluous.
To check completeness of a query, MAGIK generates a disjunc-tive logic program, which is executed by the DLV answer set engine [3]. In essence, the program contains a protoypical complete data-base (the ideal database), where the query returns an answer. This ideal database is extended to satisfy FK and instantiated to satisfy FD constraints. The program then constructs for each instantiation a minimal real database, which contains just the necessary data that it is required to contain according to the TC statements. Finally, it tests whether the query also returns an answer over all the new real databases. If it does, then MAGIK replies  X  X uery complete. X  If not, we generate an explanation out of the comparison between ideal and real database.

In our translation, we exploit various features of disjunctive logic programs and answer set programming (ASP): (1) an FK constraint is translated into a non-monotonic rule with a Skolem function, which generates a referenced tuple if none exists; (2) an FD con-straint is translated into a disjunctive rule, which nondeterministi-cally instantiates constrained variables with FD values; (3) cautious reasoning [3] is applied to check whether the query is satisfied by all resulting real databases.

Our translation creates always programs that are just as complex as needed: for classes of reasoning problems that are in PTIME, in NP, or in  X  P 2 , the resulting ASP programs have the same difficulty. System architecture. MAGIK is a web application that consists of three layers (Figure 2). The web interface layer is implemented using Java Server Pages that are executed on an Apache-Tomcat Web server. The reasoning layer is the core part of the system. It encodes the the problem into a logic program and passes it on to the DLV answer set engine [3]. Based on the returned answers, it suggests the minimal set of TC statements that are missing to guarantee query completeness. Lastly, the data layer manages TC statements, queries and schema constraints. It can also connect to a database, extract schema and constraints, and evaluate the an-alyzed query. Currently, MAGIK is set up to communicate with PostgreSQL databases.
 System functionalities. MAGIK can be accessed in two modes. The database mode illustrates a scenario where a completeness manager is added to an existing database. Here, MAGIK imports table declarations and foreign keys from the database catalog. In the virtual mode one can define arbitrary new schemas with keys and foreign keys for testing purposes. In both modes, FD con-straints, TC statements and queries are created, edited, or deleted by the user. Currently, MAGIK accepts SQL select-project-join queries where selections are equality tests. Moreover, queries can have the key word DISTINCT or grouping with the aggregate func-tion count( * ) . MAGIK analyzes a query with respect to com-pleteness and, in database mode, also evaluates the query. System usage. After starting the demo the user is located on the schema selection page where several virtual and database schemas are offered. Then he chooses the mode and a schema and is led to the main page where he can create, edit, and activate the input parameters: FK constraints, FD constraints, TC statements and a query. When he runs the query, the result field appears and displays a  X  X ompleteness certificate X  for the query. Depending of the mode, also the query answer is printed. In case the query is not found to be complete, the system proposes a minimal set of TC statements that are needed to guarantee completeness of the query. Those TC state-ments can be added to the existing statements by clicking. Finally, one can inspect the answer set program that encodes the reasoning problem.
With MAGIK, we show how one could build a completeness management component for an information systems that collects data coming from different sources and/or different business pro-cesses and therefore is generally incomplete. MAGIK demonstrates the key functionalities of a such a component: it would document the content of an information system in terms of table complete-ness (TC) statements and it would analyze whether a query can be answered completely, based on the TC statements and the integrity constraints that the database satisfies. Such reasoning services have been proposed in the literature and have independently been re-quested by practitioners. MAGIK shows how such services can be realized with an answer set engine and offers a platform to experi-ment with them. The preview of the MAGIK demo is available at http://magik-demo.inf.unibz.it/cikm2012 . [1] W. Fan and F. Geerts. Relative information completeness. In [2] W. Fan and F. Geerts. Capturing missing tuples and missing [3] N. Leone, G. Pfeifer, W. Faber, T. Eiter, G. Gottlob, S. Perri, [4] A. Levy. Obtaining complete answers from incomplete [5] A. Motro. Integrity = Validity + Completeness. ACM TODS , [6] S. Razniewski and W. Nutt. Completeness of queries over
