 XML has become the standard of exchanging a wide variety of data on Web and elsewhere. XML is essentially a directed labeled tree. XPath[1] is a simple and popular query language to navigate XML trees and extract information from them. 
XPath expression p is said to contain another XPath expression q , denoted by q querying on D contains the resulting set of q . Containment checking becomes one of the most important issues in XPath queries. Query containment is crucial in many contexts, such as query optimization and reformulation, information integration, integrity checking, etc. However, [2] shows that containment in fragment XP {[ ],*,//} is co-NP complete. The authors proposed a co mplete algorithm for containment, whose complexity is EXPTIME. The authors also proposed a sound but incomplete PTIME algorithm based on homomorphism. This algorithm may return false negatives because the homomorphism relationship between two XPath trees is a sufficient but not necessary condition for the containment relationship. In many practical situations containment can be replaced by homomorphism. 
The homomorphism algorithms proposed in [2][3] are mainly focused on how to resolve the containment problem between two XPath expressions. In [3] the authors proposed hidden-conditioned homomorphism to further narrow the discrepancy between homomorphism and containment based on [2]. However, the homomorphism relationship was considered in these works only between two XPath trees. In practice we may need to verify the homomorphism relationship between an arbitrary tree in a large query set. It is inefficient to check one by one using the homomorphism algorithm, because the same prefix and br anch in multi-trees will cause redundant computing. Although a method handling this was discussed in [4], it will return false negatives for some XPath expressions which have containment relationship, such as XPath expressions p = / a //*/ b , q = / a /*// b etc. multi-trees to a single XPath tree based on automata.We also narrow the discrepancy between homomorphism and containment as possible as we can. Our major contributions are: 1)We propose the fixed tr ee and alterable tree to describe the XPath tree, and define homomorphism based on them. 2)We define XTHC machine, a kind of indexed incremental automata with prefix-sharing of multi-trees, and our method can give the optimal automata. 3)We propose an algorithm to check homomorphism from multi-trees to a single tree based on XTHC machine. 4)The experiment results demonstrate both the practicability and efficiency of our techniques. 
The rest of this paper is organized as follows. Section 2 gives some basic notations XTHC machine and how to use XTHC to resolve the homomorphism problem. The last two sections present the experimental evaluation and conclusions, respectively. edges into child-edge and descendant-edge according to the type of axes in the XPath expression. This description is straightforward and easy to understand, however, difficult to expand. If there is any backward axis (parent-ax is or ancestor-axis) in the XPath expression, this method is no longer applicable to describing the tree structure. the node tests, and recorded at the corresponding node in the XPath tree. Our work is limited to XP {[ ],*,//} expression only. respectively. The relationship between nodes in tree T is given as: When / n , L ( v )=[1, 1]; and L ( v )=[1,  X  ] when // n. or n' [ n ], L ( v )=[1, 1]; and L ( v )=[1,  X  ] when n' // n or n' [.// n ] . v node y by nid [ a , b ] , where [ a , b ] equals to L ( y ). 
Informally, key nodes in an XPath tree are branching nodes (nodes with outdegree greater than 1), leaves, and root. 
There are often some wildcard location step s without predicate used in an XPath expression, which are represented as non-branching nodes  X * X , such as the expression descendent node of the removed wildcard node. Fig. 1(a) illustrates the two XPath nodes, where L ( b ) is revised. In the following context, all XPath trees are those trees from which the non-branching wildcard nodes are removed. FNODES ( T ) be the set of fixed nodes, NODES ( T )={ ROOT ( T )}  X  CNODES ( T ) n  X  FNODES ( T ); if b =  X  , then n  X  CNODES ( T ). When CNODES ( T ) is not empty, the XPath tree T is an alterable tree , otherwise it is a fixed tree . As an example, the XPath tree of the XPath expression / a /*/ b [.//*/ c ]// d is shown in node, so the corresponding XPath tree is an alterable tree. Definition 4: Function h : NODES ( p )  X  NODES ( q ) describes the homomorphism relationship from XPath tree p to XPath tree q : 1) h ( ROOT ( p )) = ROOT ( q ); 2)For each x  X  NODES ( p ), LABEL ( x ) = '*' or LABEL ( x ) = LABEL ( h ( x )); 3)For each edge ( x,y )  X  EDGES ( p ), where x,y  X  NODES ( p ), L ( x,y )  X  L ( h ( x ), h ( y )); Fig. 2 shows the homomorphism mapping h from XPath tree p to XPath tree q based on XPath expressions / a /*// b and / a [ c ]//*/*// b . 3.1 Construction of Basic XTHC Machine We will incrementally construct NFA with prefix-sharing on the set of XPath trees fragment in NFA, and such a fragment has a unique start state and a unique end state. There are two cases while constructing the fragment from the node nid [ a , b ] : respectively. Since a represents the minimum number of levels between node states along the arcs labeled  X * X , which are called extended states ; we then exist extended states in the automata fragment based on nid [ a , b ] when a &gt;1. 2. When b =  X  , nid [ a , b ] is an alterable node, many kinds of automata fragment can be constructed, one example is shown in Fig.3(b). Similarly to that in case 1, we first construct a -1 extended states and the end state s + a -1, starting from state s -1. Since the start state and the extended states, is denoted by extended state-chain . Fig.3(b) only shows one self-looping arc at last state of the extended state-chain. Obviously, an automata fragment corresponding to an alterable node nid [ a , b ] ( a &gt;1) in an XPath self-looping arc, and this state must be the last state along the extended state-chain. Definition 5: Suppose the NFA constructed from set P of XPath trees is A , called the XHTC machine. We can create the following two index tables for each state s in A : LB( s ) is non-empty. 
Fig. 4(b) is the XTHC machine constructed from XPath trees p 1 , p 2 , and p 3 which descendant-axis type. Definition 6: A basic non-deterministic XTHC machine A is defined as: where  X 
Q s is the set of NFA states;  X   X  is the set of input symbols;  X  q s 0 is the initial (or start ) NFA state of A , i.e. the root state;  X   X  is the set of state transition functions, it contains at least the NFA state transition  X 
F  X  Q s is the set of final states, it is also the set of leaf states;  X 
B  X  Q s is the set of branching states; subset of Q s . 3.2 Running an XTHC Machine In order to resolve the homomorphous relationship using an XTHC machine, a depth-first traverse on the input XPath tree is required to generate SAX events. These events will be used as input to the XTHC machine for the XTHC machine running. tree p : startXPathTree, startElement, endElement and endXPathTree. Time of these events being generated is: 1) send startXPathTree event when entering root of p ; 2) send startElement event when entering non-root node of p ; 3) send endElement event when tracing back to non-root node of p ; 4) send endXPathTree event when tracing back to root of p . events are sent at entering or tracing back to node nid [ a , b ] : 1) the startElement event sequence sent when a = b is shown in Fig.5(a); 2) the startElement event sequence sent when b =  X  is shown in Fig.5(b). 
In particular, there are some restrictions applied on a startElement( X // X ) event: 1) it occurs only when node nid [ a , b ] is an alterable node; 2) state transition driven by this event occurs only at state s in the extended state-
Similarly, more than one endElement event are sent when tracing back to node nid [ a , b ] in the tree, which are shown in Fig. 5(c) and 5(d). 
Fig. 6 shows rules of processing SAX events in an XTHC machine. The an input tree q can be resolved by running the XTHC machine. When the XTHC machine is running,  X  p  X  P , homomorphism information between each node v in p reset information about the mapping in the XPath tree p : 
The time complexity of the algorithm resolving homomorphism from one XPath prefix-sharing automata. However, if prefix-sharing automata is used, the time complexity is O( m | q | 2 ), where m is the number of states in NFA. When XPath trees in much more efficient to resolve homomorphi sm from multi-XPath trees to one single XPath tree using prefix-sharing automata. An algorithm resolving homomorphism based on the XTHC machine (XHO) was implemented using Java. The experimental platform is on Windows XP operation system, Pentium 4 CPU, with frequency of 1.6GHz and memory of 512MB. We compared several algorithms: the homomorp hism algorithm (HO)[2], the complete algorithm in a cononical model (CM), branch homomorphism algorithm(BHO)[4], and the proposed XHO algorithm. We checked the scope of each algorithm at resolving containment of XPath expressions (see table 1, where T/F represents p containing/not containing q ), and the time complexity of these algorithms(see Fig. 7). This experiment shows XHO is as capable as existing homomorphism algorithms. Furthermore, XHO supports containment calculation from multi-XPath expressions to one single XPath expression. Although BHO also supports such calculation, it may rather different from the correct result CM gives. Compared to BHO, XHO gives smaller discrepancy between containment and homomorphism. This paper considers an algorithm to resolve containment between multi-XPath expressions and one single XPath expression through homomorphism. While high efficiency is kept at calculating multi-containment relationships, we also consider discrepancy between containment and homomorphism. The algorithm works correctly on calculating containment of a special type of XPath expressions. Experiments showed that our algorithm is more complete than conventional homomorphism algorithms. Future research can be done on how to resolve homomorphism between one XPath tree and multi-XPath trees simultaneously. 
