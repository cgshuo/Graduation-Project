 Caching technology has been frequently used to improve the performance of serv-ing dynamic contents at Web sites. The key problem in using caching technology for dynamic contents lies in update management; that is, cached contents should be ensured consistent to the original data in databases. Thus, an effective update management mechanism is of utmost importance for dynamic content caching. Moreover, an update management scheme should be very efficient without im-posing much extra burden to the system, especially to the origin database server. Note that the database server can be easily a bottleneck to overall Web site X  X  performance. Thus, if not efficient, the advantage of using the cache will be sig-nificantly impaired due to the extra overhead to keep the freshness of the cached data.

In this paper, we propose an efficient update management mechanism for dynamic content caching, more specifically, for query result caching [5,6,8,2] in database-driven Web sites. The idea of query result caching is to store results of frequently-issued queries and reuse the results to obtain the results of subsequent queries, significantly saving computatio nal cost to process queries and retrieve results. Our method, upon r eception of an update request, instantly processes the update and invalidates affected query res ults in the cache. In doing so, the cache initiates and takes in charge of the update management process, and minimizes the involvement of the database server. In other reported update management schemes [4,3,1], the servers are heavily responsible for the overall update process. In addition, our mechanism employees a two-phase consistency checking method in which the expensive part, i.e., join checking, is performed only once to a group of queries. In this fashion, the method prunes out unaffected queries at the earliest possible moment. Thus, the method scales well with a high number of cached instances. The number of quer y instances can be v ery high especially for range queries.

This paper is organized as follows. In s ection 2, we describe the cache consis-tency mechanism. In section 3, we evaluate and analyze the performance of the mechanism. Finally in section 4, we present conclusions. 2.1 Query Templates and Query Instances Before describing our mechanism, we introduce the notions of query templates and instances. In Web-based applicatio ns, a user usually submits a request by using a HTML form. Figure 1 shows a simple example. A user types a search keyword and clicks the submit button in the form. Then, a WAS generates a query from the form and sends it to a database server. The generation of the query is done as encoded in the applications. Thus, each HTML form can be translated to a template of queries through the encoding. We call such a template a query template . The queries generated from the same HTML form, i.e., from the same query template are of the same form; they share the same projection attributes, base tables, and join conditions. The only difference among the queries lies in their selection regions, which are specified by users. We call the individual queries generated upon user X  X  requests query instances .
We characterize a query template QT =( T,PA,JC ) as follows. T is a set of tableswhicharespecifiedina FROM clause. PA is a set of projection attributes. JC is a set of join conditions. T ( QT ), PA ( QT ), and JC ( QT ) denotes T, PA, and JC of a query template QT respectively. We define a query group of a template QT as QG ( QT )= { Q i } where Q i is generated from QT . A query instance Q i is said to be affected by an update if Q i is modified by the update. 2.2 Architectural Overview Under the proposed mechanism, a caching system conceptually consists of the Consistency Maintainer (CM) and the Read-Query Processor (RQP) (see Figure 2). CM performs the consistency c heck to identify query results affected by a given update and invalidates affect ed results. RQP is a main component of the caching system, which stores quer y results and serves read queries.
Figure 2 depicts the processing flow of the consistency check. A WAS sends an update query to CM (1). CM forwards the update to the origin database server (2). In order to find the templates whic h can include the que ry instances affected by the update, CM investigates query template information kept in RPQ (3) and sends to the database server a join check query (4), which will be discussed in detail in section 2.3. Once the templates are determined, CM finds affected query instances in the templates (5) and removes them from the cache (6). 2.3 Two-Phase Consistency Check Consistency check is to test if there exist any query instances which are affected by an update. This involves repeated matching of each query instance against a given update, and thus costs serious computation overhead. We identify that there are many computation steps which are repeated in testing different in-stances. To avoid such repetition, we propose a two-phase consistency checking mechanism. We note that different query instances generated from the same query template differ only in their select ion regions. Thus, during the first step called template check , we match the query template against the update and identifies if it is possible that any of the query instances from the template are affected by the update. Then, dur ing the second step, called instance check , individual instances are matched against the update.
 Template Check. The following three conditions are satisfied, if U affects any query instances in QG ( QT ). 1. If a set of attributes modified by U intersects PA ( QT ). Note that, for INSERT 2. If a table on which U is performed is included in T ( QT ). 3. If one or more newly inserted tuples by U satisfy JC ( QT ). If QT has join Example 1. Let us consider a query template QT , a query instance Q ,andan update U as follows. Q is generated from QT .
 The conditions (1) and (2) are easily evaluated as trues. U modifies the pro-jection attribute I TITLE and the table ITEM . For checking the condition (3), a cache sends to a database server a join check query as shown below. This query examines whether the table AUTHOR has the tuples which can be joined with the tuple inserted by U . Because the join attribute value of the inserted tuple is 100, the join check query finds the tuples with A ID = 100. If the result of the query is not null, we know that the inserted tuple is joined.
 SELECT A ID FROM AUTHOR WHERE AUTHOR.A ID = 100
As described in the example 1, the join check requires the query processing of a database server. The two-phase consistency check performs the join check over each query template, not each query inst ance. Thus, it drama tically decreases the overhead to a database server.
 Instance Check. Once a template passed the template check, the query in-stance check is applied to the template. It finds the affected query instances by comparing the selection r egion of an update query to those of query instances. If the selection region of a query instance overlaps that of an update query, we know that the query instance is affected by the update. In the example 1, the query instance Q is affected by the update U because the selection region of Q , I PUBLISHER= X  X cGrowHill X  , is equal to that of U . Experimental Setup. We measured the update throughputs of the query re-sult caching system adopting the proposed mechanism. We sent update queries to the caching system. For each update, the caching system forwards the update query and sends join check queries to a database server. Under this situation, the throughput is limited by the amount of processing these queries in the database server. Figure 3 shows the setup for evaluating the proposed mechanism. The Query Generator emulates a group of Web application s ervers, generating queries. It runs on a machine with a Pentium III 800MHz, 256MB RAM. For the database server, we used Oracle 8i with the default buffer pool size of 16MB. The database server runs on a machine with a Pentium IV 1.5GHz, 512M RAM. The caching system runs on the machine with a Pentium III 1GHz, 512M RAM. We imple-mented the proposed mechanism as a part of WDBAccel query result caching system [5]. All machines run Linux and are connected through a 100Mbps Eth-ernet.

We populated the database of the TPC-W benchmark in the database server at 100K scale 1 . The TPC-W benchmark [7] is an industrial standard benchmark to evaluate the performance of database-driven Web sites. We used the update query modified from one used in Admin Confirm Web page of TPC-W: INSERT INTO ITEM (I ID, I A ID, I COST, I PUBLISHER)VALUES (@I ID, @I A ID, @I COST,  X  X I PUBLISHER X ) . This query inserts information on a book into ITEM . The values of the attribute I ID follow the random distribution.
 Experimental Results. In order to determine the p erformance improvement by the two-phase consistency check, we measured the update throughputs of the two-phase check and the brute-force approach. In the brute-force approach, the join check is performed against individual query instances. (Note that in the two-phase check, the join check is performed against a query template.)
Figure 4 shows the update throughputs as the number of query instances ranging from 50 to 200. The figure show s that the throughput s of the two-phase check are equal. This means that the two-phase check imposes the same overhead on a database server regardless of how many query instances are. The amount of overhead of the two-phase check will depend on only the number of query templates. The two-phase check gener ates a join check query for each query template. In this paper, we proposed a scalable update management mechanism for the query result caching systems. We divided a consistency check to two phases, template check and instance check. The t emplate check is performed over a query template, not an individual instance. We presented the experimental results that verify a high level of the scalability of the mechanism.

