 In current trends of consumer products market, there is a growing significance of the role of retailers in the governance of supply chains. RFID is a promising infrastructure-less technology, allowing to connect an object with its virtual counterpart, i.e. , its representation within information sys-tems. However, the amount of RFID data in supply chain management is vast, posing significant challenges for attain-ing acceptable performance on their analysis. Current ap-proaches provide hard-coded solutions, with high consump-tion of resources; moreover, these exhibit very limited flexi-bility dealing with multidimensional queries, at various lev-els of granularity and complexity. In this paper we propose a general model for supply chain management based on the first principles of linear algebra, in particular on tensorial calculus . Leveraging our abstract algebraic framework, our technique allows both quick decentralized on-line process-ing, and centralized off-line massive business logic analy-sis, according to needs and requirements of supply chain actors. Experimental results show that our approach, uti-lizing recent linear algebra techniques can process analysis efficiently, when compared to recent approaches. In particu-lar, we are able to carry out the required computations even in high memory constrained environments, such as on mo-bile devices. Moreover, when dealing with massive amounts of data, we are capable of exploiting recent parallel and dis-tributed technologies, subdividing our tensor objects into sub-blocks, and processing them independently.
 H.2.7 [ Database Management ]: [Data warehouse and repos-itory]; I.1.4 [ Symbolic and Algebraic Manipulation ]: Applications Management, Performance, Experimentation Supply chain, algebraic models, multidimensional analysis.
A supply chain is a complex system for transferring prod-ucts or services from a supplier to a final customer. In the management of a supply chain, main retailers are investing in new technologies in order to boost the information ex-change. To this aim, RFID, the Radio-Frequency Identifica-tion, is a recent potential wireless technology, which enables a direct link of a product with a virtual one within informa-tion systems. Currently, RFID tags attached to products store an identification code named EPC, used as a key to retrieve relevant properties of an object from a database, usually within a networked infrastructure. An RFID appli-cation usually generates a stream of tuples, usually called raw data , of the form of a triple ( e,l,t ), where e is an EPC, l represents the location where an RFID reader has scanned the e object, and t is the time when the reading took place. Other properties can be retrieved, e.g. , temperature, pres-sure, and humidity. A single tag may have multiple readings at the same location, thus potentially generating an immense amount of raw data. Therefore, a simple data cleaning tech-nique consists in converting raw data in stay records of the form ( e,l,t i ,t o ), where t i and t o are the time when an object enters or leaves a location l , respectively.

In this manuscript, we address the challenging problem of efficiently managing the tera-scale amount of data per day, generated by RFID applications [2, 3, 8, 13], focusing on stay records as the basic block to store RFID data. Recently, two models have been proposed: a herd and a single model. The former [8] proposes a warehousing model observing that usually, products move together in large groups at the be-ginning, and continue in small herds towards the end of the chain: this allows the aggregation and reduces significantly the size of the database. On the contrary, the latter [13] focuses on the movement of single, non grouped tags, defin-ing query templates and path encoding schemes to process tracking and path oriented queries efficiently. Both of these approaches present limited flexibility dealing multidimen-sional queries at varying levels of granularity and complex-ity. To exploit the compression mechanism, such proposals have to fix the dimensions of analysis in advance and im-plement ad-hoc data structures to be maintained. It is not known in advance whether objects are sorted and grouped, and therefore, it is problematic to support different kinds of high-level queries efficiently.
 poses a general model of supply chains, mirrored with a formal tensor representation ( i.e. a generalization of lin-ear forms, usually represented by matrices) and endowed with specific operators, allowing both quick decentralized on-line processing, and centralized off-line massive business logic analysis, according to needs and requirements of sup-ply chain actors. Our model and operations, inherited by linear algebra and tensor calculus, is therefore theoretically sound, and its implementation may benefit of several nu-merical libraries developed in the past. Additionally, due to the properties of our tensorial model, we are able to at-tain two significative features: the possibility of conducting computations in memory-constrained environments such as on mobile devices, and exploiting modern parallel and dis-tributed technologies, owing to the possibility for matrices, and therefore tensors, to be dissected into several chunks, and processed independently ( i.e. , also on-the-fly). tion 2 we will briefly recall the available literature, while Section 3 will be devoted to the introduction of tensors and their associated operations. The general supply chain model, accompanied by a formal tensorial representation is supplied in Section 4, subsequently put into practice in Section 5, where we provide the reader a method of analyzing RFID data within our framework. We benchmark our approach with several test beds, and supply the results in Section 6. Finally, Section 7 sketches conclusion and future work.
In a real scenario, great lapse and huge amounts of data are generated. To this aim, knowledge representation tech-niques focus on operating deep analysis in such systems. There exists two main approaches to the management of RFID data: the processing is performed off-line, once RFID data are aggregated, compressed and stored [8, 13]. An al-ternative approach consists in warehousing RFID data and performing multidimensional analyses on the warehouse. The focus here is on data compression techniques and on stor-age models with the goal of achieving a more expressive and effective representation of RFID data. A straightforward method is to provide a support to path queries ( e.g. , find the average time for products to go from factories to stores in Seattle) by collecting RFID tag movements along the sup-ply chain. Usually, the tag identifier, the location and the time of each RFID reading is gathered and stored in a huge relational table. Gonzalez et al. [8] have presented a new storage model, based on a data warehousing approach, in which items moving together are grouped and data analysis is preformed in a multidimensional fashion, as it happens in a typical data warehouse. Finally, Lee et al. have pro-posed an effective path encoding approach to represent the data flow representing the movements of products [13]. In a path, a prime number is assigned to each node and a path is encoded as the product of the number associated with nodes. Mathematical properties of prime numbers guaran-tee the efficient access to paths.

As we have noticed in the Introduction, a major limitation of the majority of these approaches have to fix the dimen-sions of analysis in advance to exploit ad-hoc data structures to be maintained. It follows that, in many application sce-nario the compression loses its effectiveness and the size of tables does not be reduced significantly. Moreover, most of the approaches presented in this section present a limited flexibility when multidimensional queries, at varying levels of granularity and complexity, need to be performed.
The following paragraphs will be devoted to a brief recall of tensor representations, which is preliminary to the intro-duction of our model in the ensuing sections. We take for granted notions and notations of groups , vector spaces , ma-trix rings , and for a thorough review of vector spaces and tensors, we refer the reader to [11], [1] [10], and [12]. Linear forms on a vector space V defined over a field F , and belonging to its dual space V  X  , are maps  X  : V  X  F associate to each pair  X   X  V  X  , and v  X  V , an element e  X  This is usually denoted by the pairing  X   X ,v  X  = e , or by definition, with a functional notation, i.e. ,  X  ( v ) = e . Such mapping exhibits the linearity property, i.e. ,  X   X , X v +  X w  X  =  X   X   X ,v  X  +  X   X   X ,w  X  . Generalizing the concept of linearity, we hence may introduce the following:
Definition 1 (Tensor). A tensor is a multilinear form  X  on a vector space V , i.e. , a mapping the form  X  assumes also the name of tensor of rank k (or rank-k tensor).

As with linear forms, one possible representation of a ten-sor is with elements of the matrix ring . Therefore, a rank-k tensor may be represented by M  X  M i 1 i 2 ...i k ( F ), that is a k -dimensional matrix with elements in F .

Definition 2 (Hadamard Product). The Hadamard product of two vectors v,w  X  V is the entry-wise product of their components, i.e. ,
Since a tensor of rank k will henceforth be denoted by a multidimensional matrix, we shall simplify notations by a variant of Einstein X  X  notation . Such variant will be em-ployed wherever a summation occurs: where we encounter two identical indices in a given expression, a summation on that index is implicitly defined. Let us consider for exam-ple, a notable form, the inner product (  X  ) between two vec-tors, known also as scalar product . We mention in passing that an inner product arises in defining a particular class of rank-2 tensors: symmetric (or Hermitian) positive-definite forms. If we consider a standard cartesian metrics, i.e. , an orthonormal basis [11], the inner product notation can be written leveraging the summation notation described above: v  X  w = P j v j w j =: v j w j . As with linear applications, rep-resented by matrices, tensors may be applied to elements of vector spaces, giving rise the following:
Definition 3 (Application). The application of a k -ranked tensor  X  , represented by the matrix M  X  M i 1 i 2 to a vector v  X  V is a rank k  X  1 tensor represented by the matrix f M :
The reader should notice that the previous definition of application is a generalization of the common matrix-vector product. In other terms, applying a tensor to a vector sim-ply  X  X ats X  one dimension, as evidenced by the indices in the previous definition. Following a standard algebraic practice, indices may be rendered more intelligible when dealing with a tiny number of dimensions, e.g. , do not exceed 4 dimen-sions: in this case, instead of using M i 1 i 2 i 3 i 4 , we will employ the easier notation of M ijkl .
Example 1. Let us consider a rank-3 tensor  X  represented by the matrix M  X  M 333 ( R ) and a vector v  X  R 3 : The result of the application of  X  to v is a rank-2 tensor
Definition 4 (Kroneker Tensor). The rank-k ten-sor  X  i 1 i 2 ...i k , whose matricial representation is M iff i 1 = i 2 = ... = i k , is called Kroneker tensor .
Kroneker tensor is well known in diverse fields ranging from computer science to economics, and it is commonly known as Kroneker delta . Moreover, with the canonical du-ality between forms and vectors [11], it is common to employ the very same symbol for a vector specification, e.g. , v  X  with v =  X  2 = (0 1 0) t . Note as the notation  X  2 does not contain any reference to the dimension, due to any lack of ambiguity, since here  X  2  X  R 3 ; this notation means that each component in a position different from 2 has value 0, while the component in position 2 has value 1.

Definition 5 (Map). The map is a function with do-main a pair constituted by a function and a vector space, and codomain a second vector space: which associates to each component of a vector, the result of the application of a given function to the component itself: with f : V  X  W , v  X  V , and w  X  W .
This section is devoted to the definition of a general model capable of representing all aspects of a given supply chain. Our overall objective is to give a rigorous definition of a sup-ply chain, along with few significant properties, and show how such representation is mapped within a standard ten-sorial framework.
Let us define the set E as the set of all EPCs, with E being finite. A property of an EPC is defined as an ap-plication  X  : E  X   X , where  X  represents a suitable prop-erty codomain. Therefore, we define the application of a property  X  ( e ) :=  X   X ,e  X  , i.e. , a property related to an EPC e  X  E is defined by means of the pairing EPC-property; a property is a surjective mapping between an EPC and its corresponding property value. A supply chain is defined as the product set of all EPCs, and all the associated proper-ties. Formally, let us introduce the family of properties  X  i = 1 ,...,k + d &lt;  X  , and their corresponding sets  X  i may therefore model a supply chain as the product set
We highlight the indices employed in the definition of the supply chain. The reader should notice as we divided explic-itly the first k spaces E ,  X  1 ,...,  X  k  X  1 , from the remaining ones. As a matter of fact, properties may be split into two different categories: countable and uncountable ones. By definition, a set A is countable if there exists a function f : A  X  N , with f being injective; for example, every subset of natural numbers U  X  N is countable (possibly infinite), and relative and rational sets, Z and Q , respectively, are countable.
In the following we will focus on some of the properties related to EPCs, i.e. , we will model some codomains  X  and their associated features.
 Location. Let us briefly model the location associated to an EPC. It is common to employ a GPS system in order to track the position on earth, however, any fine-grained space is sufficient to our purposes. In particular, being the earth homeomorphic to a 3-sphere, any ordered triple of real numbers suffices, leading us to the following definition:
Definition 6 (Location). Let L be the set of ordered location set , ` 1 , ` 2 and ` 3 as location coordinates .
A commonly employed coordinate system is the GPS loca-tion, i.e. , latitude and longitude, with an additional altitude coordinate. However, in many cases the altitude has no in-fluence from an applicative point of view, thus leading the location to be defined by a couple of real numbers, or better, ` = ( ` lat ,` long ,` alt  X  0). Some standard representation of locations abstract their geographical information, preferring to employ a simple mapping between locations and a sub-set of natural numbers, representing the location identifier . Which representation is more suitable to an application, is a matter of choice with respect to the domain of the problem. product (EPC), we resort to an ordered couple of elements from the ring of real numbers. This suffices to specify, e.g. , the entry and exit time of a product from a given location. With this point of view, we model time as follows:
Definition 7 (Time). Let T be the set of ordered cou-ples  X  := ( t i ,t o ) , with t i ,t o  X  R . We name T as time set , t and t o as incoming and outcoming timestamps , respectively.
We highlight the fact that time spaces need not to be mod-eled as real numbers: in fact, natural numbers may also be suitable within a particular context, e.g. , employing UNIX timestamps. However, our model aims at generality, and therefore the real ring is the most appropriate choice, being N a proper subset of the real numbers ring.

Definition 8 (Inner sum). Let us define the inner sum of two time elements  X  1 = ( t 1 i ,t 1 o ) ,  X  2 = ( t 2 ator  X  : T  X T  X  X  :
With the above operator, we have that ( T ,  X  ) assumes the algebraic structure of an abelian group. Such operation allows us to rigorously model the  X  X ddition of products X : the overall timeframe of two products is, in fact,
Definition 9 (Lifetime). We define as lifetime the linear form  X  : T  X  R defined as follows:
Due to the linearity, we are allowed to construct equiva-lence classes in T as follows:
The canonical representative elements of the above equiv-alence classes are defined as (0 ,t o ), with t o  X  R .
Definition 10 (Admissible time). Given a time ele-ment  X   X  X  , we say that  X  = ( t i ,t o ) is admissible iff
Let us now introduce a formal tensorial framework ca-pable of grasping all properties related to a supply chain, as proposed in Section 4.1. As previously outlined, we di-vide properties into two categories, countable and uncount-able spaces. This separation allows us to represent count-able spaces with natural numbers, therefore mapping their product space to N k , while leaving the product space of all uncountable properties into a collective space U :
Such mapping will therefore introduce a family of injective functions called indexes , defined as: When considering the set E , we additionally define a sup-plemental index, the EPC index function idx 0 : E  X  N consequently completing the map of all countable sets of a supply chain S to natural numbers. It should be hence straightforward to recognize the tensorial representation of a supply chain:
Definition 11 (Tensorial Representation). The tensorial representation of a supply chain S , as introduced in equation (5) , with countability mapping as in (7) is a multilinear form
A supply chain can be therefore rigorously denoted as a rank-k tensor with values in U , mapping countable to un-countable product space.
Preliminary to describing an implementation of our supply chain model, based on tensorial algebra, we pose our atten-tion on the practical nature of a supply chain. Our treatment is general, representing a supply chain with a tensor, i.e. , with a multidimensional matrix. Several other approaches are available in literature on the same topic, with a graph being the preferred supply chain model [7]. These mod-els are thoroughly represented by our tensorial approach, due to the well known mapping between graphs and matri-ces (cf. [4]). However, a matrix-based representation need not to be complete . Supply chain rarely exhibit completion: practical evidence [7] suggests that products, identified by their EPC, for example, seldom present themselves in ev-ery location. The same consideration applies also to other properties, in particular, to countable properties. Hence, our matrix effectively requires to store only the information regarding connected nodes in the graph: as a consequence, we are considering sparse matrices [5], i.e. , matrices storing only non-zero elements.
 Figure 1: An example supply chain represented by a directed graph. Callouts represent lists of tuple con-stituted by an EPC with the associated time ( t i ,t o ) . notations (cf. [14] and [5]), however, for simplicity X  X  sake, we adopt the tuple notation . This particular notation declares the components of a tensor M i 1 i 2 ...i k ( U ) in the form of where we implicitly intended u 6 = 0  X  0 U . As a clarifying example, consider a vector  X  4  X  R 5 : its sparse representa-tion will be therefore constituted by a single tuple of one component with value 1, i.e. , {{ 4 } X  1 } .
 Example 2. Let us consider the supply chain pictured in Figure 1, described tensorially by  X  : N 2  X  X  , whose repre-sentative matrix is as follows: 0 B @ where, for typographical simplicity, we omitted 0 T = (0 , 0) , denoted with a dot. For clarity X  X  sake, we outline the fact that  X  is a rank-2 tensor with dimensions 5 (i.e. the rows), 8 (i.e. the columns). In fact, the EPC and locations sets are, respectively where idx 0 ( E 10) = 1 , idx 0 ( E 11) = 2 , ... , idx 0 and similarly idx 1 ( L 1) = 1 , ... , idx 1 ( L 8) = 8 . In the sparse representation we have {{ 1 , 1 }  X  (0 , 2) , { 1 , 4 }  X  (5 , 7) ,..., { 5 , 8 } X  (9 , 11) } .
 spect to summations, we actually may split a matrix in sub-matrices, carry out the application and finally, thanks to the associativity, add the partial results obtaining the correct solution. For example, if A  X  M 22 ( R ), and v  X  R 2 being a suitable vector, the matrix can be divided in two (or more) sub-matrices, thus giving the ability to perform computa-tions independently, as Av = ( A 0 + A 00 ) v = A 0 v + A performing A 0 v , we actually do not need any information re-garding the subsequent A 00 matrix and vice versa, and as a result, we may choose not to store its elements in memory. Additionally, multiplication of a sparse matrix (or tensor) with a vector has a sub-quadratic computational complexity (cf. [5]), and even quasi-linear asymptotic complexity [9]. On a final note, being the two multiplications independent from one another, we are capable of exploit recent paral-lel and distributed technologies, parallelizing multiplication and then reducing by summation their partial results.
Based on our conceptual framework, in this section we will provide a method to analyze RFID data represented by a tensor. With reference to the example provided in Sec-tion 4, in the following we simplify our notation, employing two countable sets, EPC E and location L indexes, in that order, and the uncountable time set T , i.e. , a matrix M referring to EPCs, and j being the index of locations. Such choice of attributes introduce no limitations on the general-ity of our approach, due to the fact that, in essence, apply-ing a tensor to a vector means summing all the components sharing an index, regardless of ranks and dimensions.
A tracking query finds the movement history for a given tag identifier e  X  X  . We can comfortably perform the query efficiently, using the model described in Section 4, by apply-ing the tensor application. Therefore, given i = idx( e ), we build a Kroneker vector as a vector  X  i , with |  X  i | = |E| , and finally apply of the rank-2 tensor represented by M ij to  X  For instance, referring to the example pictured in Figure 1, let us consider the tag E 13, we have i = idx( E 13) = 4, and therefore our vector will be  X  4 = {{ 4 } X  1 } . Consequently, the resulting vector will be r = M ij  X  4 = {{ 2 } X  (0 , 4) , { 5 } X  (5 , 6) , { 8 } X  (8 , 9) } , or in another notation, L 2  X  L 5  X  L 8.
A path oriented query returns the set of tag identifiers that satisfy different conditions. Following the query templates given in [13], we subdivide path oriented queries into two main categories: path oriented retrieval and path oriented aggregate queries. The former returns all tags covering a path satisfying given conditions, while the latter computes an aggregate value. It is possible to formulate a grammar for these queries, similar to XPath expressions; in particular, path oriented retrieval and path oriented aggregate queries are respectively indicated as follows: where L 1 ,...L n is the path condition , i.e. , the sequence of locations covered by the tag, and cond i is the info condi-tion ; for more information about such expressions, we re-fer the reader to [13]. A path condition expresses parent-hood between locations, indicated as L i /L j , or ancestry with L //L j ; an info condition, on the other hand, indicates con-ditions on tag properties, e.g. , StartTime and EndTime . ented retrieval query as in (11a) is easily performed by ex-ploiting the tensor application coupled with the Hadamard product. Given the location set L , for each z = idx( L with k = 1 ,...,n , we create a Kroneker vector  X  z and subse-quently apply the rank-2 tensor, resulting in a set of vectors r z = M ij  X  j , where for typographical reasons, we dropped the subscript intending  X   X   X  z . Finally, we apply the condi-tion function to each r z employing the map operator. This yields a set of vectors whose Hadamard multiplication generates the final result: reminding the reader that only non-zero values are stored, and therefore given as a result of a computation. The cond functions, as indicated above, are maps between properties of supply chains and a suitable space F , e.g. , natural num-bers for a boolean result. For an example, referring to Fig-ure 1, let us consider the query L 3[ StartTime &gt; 0] //L 8[ EndTime  X  StartTime &lt; 4] . In this case, given idx( L 3) = 3 and idx( L 8) = 8, we build  X  and  X  8 , and generate the partial results r 8 = M ij  X  8 = {{ 2 } X  (4 , 9) , { 4 } X  (8 , 9) , { 5 } X  (9 , 11) } where evidently the application was performed along the second dimension, i.e. , for each  X   X  {  X  3 , X  8 } , we compute M ij  X  j . Finally, subsequent to mapping conditions on the results, in this case cond 3 = t i (  X  ) &gt; 0 and cond 8 we obtain the correct outcome  X  r = e r 3  X  e r 8 = {{ 5 } X  (9 , 11) } , i.e. , E 14.

Considering parenthood as in (11b) instead of ancestry, i.e. , L i /L j , we briefly sketch the fact that such query does not, in fact, differ from the above, except for one particu-lar: each resulting EPC, when subject to a tracking query, produces a sparse vector whose length , i.e. , the number of non-zero stored elements, is exactly equal to the number of locations under analysis.
 may be represented as  X  f,Q  X  =: f ( Q ) where f is an aggre-gate function , e.g. , average or minimum, and Q is the result of a path oriented retrieval query. Therefore, let  X  r result of Q , and let f be a function defined on vectors of supply chain elements, we simply have that a path aggre-gate may be expressed as f (  X  r Q ). Referring to Figure 1, let us consider the query expressed in the grammar of [13] it is easily performed by applying the function f := average( t to the outcomes of the path oriented retrieval query on L 8, resulting in  X  r = average( { 4 , 8 , 9 } ) = 7.
We performed a series of experiments aimed at evaluating the performance of our approach, reporting the main results in the present section.
 GHz Intel with 2 GB of main memory running on Linux, where we implemented our framework 1 in C++ within the Mathematica 8.0 computational environment. Our results have been compared to the ones from the approach in [13], tested against a generated synthetic RFID data in terms of stay records, and considering products moving together in small groups or individually, a behavior called IData in [13]: data production followed the same guidelines on a supply chain of 100 locations. Finally the complete data set com-prises 10 5 , 5  X  10 5 , 10 6 , 5  X  10 6 , and 10 7 stay records. In the following, we will denote our tensorial approach T , while the proposed one in [13] with P .
A prototype implementation is available at http://pamir. dia.uniroma3.it:8080/SimpleWebMathematica data loading and querying. Referring to the former, the main advantage of our approach is that we are able to per-form loading without any particular relational schema, when compared to P , where a schema coupled with appropriate indexes have to be maintained by the system. In this case, loading execution times are 0.9, 11, and 113 seconds, for sets of 10 5 , 10 6 , and 10 7 stay records, respectively; on the contrary, P timings were in order of minutes and hours. Another significant advantage of T relies in memory con-sumption: we need 13, 184, and 1450 MB to import the above mentioned sets; as a side-note, we highlight the fact that the 10 7 set required a division in smaller blocks, e.g. , 10 6 , due to the limited memory at disposal. With respect to query execution, T presents a similar behavior and ad-vantages with respect to P , for both time and memory con-sumption. We performed cold-cache experiments, i.e. , drop-ping all file-system caches before restarting the systems and running the queries, and repeated all the tests three times, reporting the average execution time. As in [13], we formu-lated 12 queries to test the two systems as reported in [6]. In brief, Q1 is a tracking query, Q2 to Q5 are path oriented re-trieval queries, while Q6 to Q12 are path oriented aggregate queries. Due to the nature of P , we were able to perform a comparison only on centralized off-line massive analysis. Figure 2: Speed-up logarithmic graph for all queries with 10 5 (solid), 10 6 (dashed), and 10 7 (dotted).
A significant result is the speed-up between the two ap-proaches, as shown in Figure 2; again, Q1 label is dropped due to typographical causes. We computed the speed-up for all data sets as the ratio between the execution time of P , and that of our approach T , or briefly S = t P / t T . In general, T performs very well with respect to P in any dataset, par-ticularly for queries related to the object transition, e.g. , Q2, Q4, Q5, Q10. The query performance of T is on the average 19 times better than that of P , 150 times on the maximum, i.e. , Q10. Another strong point of T is a very low consump-tion of memory, due to the sparse matrix representation of tensors and vectors. Figure 3 illustrates the main memory consumption of each query with respect to 10 5 , 10 6 , and 10 stay records. On the average, tracking queries require very few bytes of memory for any dataset, path oriented queries few KBytes, topping 1 MB for 10 7 . Results demonstrate how our approach can be used in a wide range of applications, where devices with limited calculus resources may process large amount of data in an efficient and effective way.
We have presented an abstract algebraic framework for the efficient and effective analysis of RFID data in sup-ply chain management. Our approach leverages tensorial calculus, proposing a general model that exhibits a great Figure 3: Main memory consumption for each query: black bars refer to 10 5 , dark gray to 10 6 , and light gray to 10 7 data size. flexibility with multidimensional queries, at diverse granu-larity and complexity levels. Experimental results proved our method efficient when compared to recent approaches, yielding the requested outcomes in memory constrained ar-chitectures. For future developments we are investigating the introduction of reasoning capabilities, along with a thor-ough deployment in highly distributed Grid environments. In addition, we are about to test our model on mobile de-vices, comprising more complex properties and queries. [1] R. Abraham, J. E. Marsden, and T. Ratiu. Manifolds, [2] R. Angeles. Rfid technologies: supply-chain [3] Y. Bai, F. Wang, P. Liu, C. Zaniolo, and S. Liu. Rfid [4] A. Bondy and U. S. R. Murty. Graph Theory .
 [5] T. A. Davis. Direct Methods for Sparse Linear [6] R. De Virgilio and F. Milicchio. Tensor calculus for [7] R. Derakhshan, M. E. Orlowska, and X. Li. Rfid data [8] H. Gonzalez, J. Han, X. Li, and D. Klabjan.
 [9] F. G. Gustavson. Two fast algorithms for sparse [10] J. H. Heinbockel. Introduction to Tensor Calculus and [11] K. M. Hoffman and R. Kunze. Linear Algebra .
 [12] B. Jancewicz. The extended grassmann algebra of R 3 [13] C.-H. Lee and C.-W. Chung. Efficient storage scheme [14] O. Osterby and Z. Zlatev. Direct Methods for Sparse
