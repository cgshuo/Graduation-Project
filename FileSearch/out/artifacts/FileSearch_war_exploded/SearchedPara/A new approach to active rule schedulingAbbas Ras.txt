 is compared with those rule scheduling approaches that are unconstrained 1. Introduction
Common (Traditional) database systems are often of a passive nature. This means that operations such as querying, updating, insert-ing, deleting, and reporting are performed only in the event that users request them. Database Management Systems, abbreviated to DBMSs, cannot automatically react when various events occur. Many applica-tionssuchasreal-timeexpertsystems( Hangos et al., 2001; Farias et al., 2009 ), warehousing programs, the automation of processes, and com-plex fi nancial calculations in stock markets need automatic control for handling events that have occurred. Active Database Systems ( Kasbon et al., 2012 ), abbreviated to ADSs, meet the requirements of such applications by de fi ning ECA (Event-Condition-Action) rules, referred to as active rules. An ECA rule has three main sections: Event, Condition, and Action. An ECA rule for the context of buying and selling stocks ( Zong et al., 2007 )isde fi ned as follows: active rule has two other features: event-condition coupling mode and condition-action coupling mode. When an event E 1 occurs, the event-condition coupling mode of each rule triggered by E determines the time when the condition section of the rule should be evaluated. There are three choices for the event-condition coupling mode of each active rule: immediate , deferred , and independent . If the event-condition coupling mode of an activated rule is immediate, the condition of the rule should be evaluated immediately. If the event-condition coupling mode of an activated rule is deferred, the evaluation of the condition of the rule should be deferred until the execution of the action section of the rule that is being executed is terminated. If the event-condition coupling mode of an activated rule is independent, the condition section of the rule is evaluated only after the condition sections of all activated rules with the immediate and deferred modes have been evaluated. For example, suppose there are some activated rules, waiting to be evaluated. The condition sections of the rules with the independent event-condition coupling mode are not evaluated until the condition sections of the other rules have been evaluated.
If the condition section of an activated rule is evaluated to true, the condition-action coupling mode of the rule determines the time when its action section should be executed.

Similarly, there are three choices for the condition-action coupling mode of each rule: immediate, deferred, and independent. If the condition-action coupling mode of a ready-to-be-executed rule (a rule whose condition-section has been e valuated to true) is immediate, its action section must be executed immediately. If the condition-action coupling mode of a ready-to-be-exec uted rule is deferred, the execu-tion of its action section should be deferred until the execution of the action section of the rule that is being executed is terminated. If the condition-action coupling mode o f a ready-to-be-executed rule is independent, the action section of the rule is executed only after the action sections of ready-to-be-executed rules with immediate and deferred modes have been executed.
 Events can be classi fi ed as primitive or composite events.
Primitive events refer to elementary occurrences which are pre-de fi ned in the system. Primitive events are typically further categorized as database events, temporal events, transaction events, etc. Database events are related to database operations and are further classi fi ed into Insert, Delete, and Update. A temporal event can be an absolute point in time, de fi ned by the system clock (e.g., 9:00:00 a.m., April 10, 1988), relative (30 s after event A occurred), or periodic (every day at midnight). As the name implies, transaction events are kinds of events related to transac-tions; for example, the beginning and end of a transaction are events signaled at the beginning and end of the transaction. A composite event is a set of primitive events which are combined using event operators (such as  X  and  X  ,  X  or,  X  and  X  not event speci fi cation.

An ADS processes its active rules to automatically control various events. The rules processing cycle, elaborated on in Section 2 , consists of the following steps ( Meenakshi and Thiagarasu, 2014 ): 1) Event Signaling: When a primitive event occurs, the primitive event detector signals it. In addition, the composite event detector considers the occurring primitive events to investigate the occurrence of composite events. 2) Rule Triggering: After an event is signaled, those ECA rules that correspond to the signaled event are activated. One instance of each activated rule is created, which includes some additional information (such as a timestamp, a deadline, and an execution time) depending on the scheduling mechanism used by the rule scheduler. These instances are buffered to be used in the next step. 3) Condition Evaluation: In this step, the rule scheduler sequen-tially selects the instances created in the previous step, and their conditions are evaluated. If the condition section of an instance is evaluated to true, the instance is added to the ready-to-be-executed buffer. 4) Transaction Selection: In this step, the rule scheduler selects the ready-to-be-executed rules in order of priority. A transac-tion is generated for each ready-to-be-executed rule based on its action section. The transaction is then sent to the execution unit. This step is also called the transaction scheduling phase. 5) Transaction Execution: The transactions generated in the previous phase are executed in this step.

ADSs have many applications in controlling and automatic handling of processes in different areas such a s the stock exchange organization, portfolio management systems, automatic traf fi c control systems, all applications with continuous monitoring, and real-time systems as real-time active database systems ( Kasbon et al., 2012; Ale and Espil, 2003; Spokoiny and Shahar, 2007; Badia, 2003; Qiao et al., 2007 ). An ADSplaystheroleofanautomaticcontrollerbyde fi ning and executing several active rules. During the running of the system, several activated rules with different event-condition and condition-action coupling modes are waiting to be evaluated or executed.

There is an important question here: why is it important to have an effective and ef fi cient rule scheduling algorithm in ADSs? To answer this question, consider a stock exchange system that uses an ADS. This ADS has tens of thousands of users, and the number of active rules in their rule-bases reaches hundreds of thousands of rules. For example, suppose there are n users in the electronic management system of the stock exchange. Each user has de different number ( m 1 ; ... ; m n ) of active rules. The de these rules is illustrated in Table 16 (see Appendix). After each update operation (i.e. edit, insert, or delete) in the electronic management system of the stock exchange, thousands of rules are activated. Suppose that in a stock exchange system with tens of thousands of users, n 0 number of users ( n 0 o n and n 0 is rather big; for example, n 0 is about two or three thousands), de fi ne some rules triggered by each update on the price of Mercedes Benz. When the price of this stock is updated, in a moment, the corresponding rules are activated. At this moment, the stock price of the Volvo Company may be updated as well. And this may cause thousands of other rules to be activated. Such scenarios may continue. There are several similar scenarios that may happen during the running of the electronic management system of the stock exchange. It is obvious that during the running of these kinds of systems in the real-world, many activated rules wait to be evaluated and exe-cuted. And in these situations, even milliseconds matter. If a rule, de fi ned by user X , is not executed at the desired moment, the goal of a user X is not satis fi ed. This goal may be  X  buying a stock A  X  selling a stock B,  X  so user X does not obtain his/her expected bene fi t. Thus, the importance of having an effective and ef rule scheduling mechanism is quite evident.

So far many rule scheduling mechanisms have been introduced such as Random ( Adaikkalavan and Chakravarthy, 2012 ), FCFS (First Come, First Served) ( Sarkar and Debnath, 2012 ), and E x (Extended Shortest Job First) ( Rasoolzadegan et al., 2008 ), pre-sented in Section 3 . There are also some criteria for evaluating the effectiveness (performance) and ef fi ciency of rule scheduling approaches such as Average Response Time, Throughput, and CPU Utilization, presented in Section 2 .
 The scheduling of active rules is one of the main research topics in ADSs ( Rasoolzadegan, 2007; Ceri et al., 2003; Jin, 2009; Jin et al., 2007; Meenakshi and Thiagarasu, 2014; Meenakshi and Thiagarasu, 2014; Saravanapandi Solairajan et al., 2013; Narang et al., 2013 ). There have been several attempts in this area. The focus is mainly on the unconstrained rule scheduling approaches -such as the various versions of E x -SJF-ratherthanonthoseintroducedforconstrained rule scheduling approaches -such as the  X  Static Priority Constrained rule scheduling approaches are used when rules have some restrictions (or constraints) s uch as deadlines or priorities. For example, in safety-critical and high-integrity systems  X  such as the automatic control system of an airplane  X  priorities are assigned to rules according to their importance. Among all activated or ready-to-be-executedrules,therulethathasthehighestpriorityisselectedtobe evaluated or executed fi rst. The priority of rules is determined by rule developers before the running of the system. In real-time systems, each rule has its own deadline. Therefore, initially, it is necessary to de thedeadlineofeachruleaccurately.Thedeadlineofaruleisthe greatest amount of time that the execution of the action section of the rule can be postponed after its condition is evaluated to true. In real-time systems, the rule scheduler should always select the rule that has the nearest deadline among all activated or ready-to-be-executed rules.
In such systems, the greater the number of missed deadlines, the less effectivetheybecomeincriticalsit uations. However, in systems where rules do not have any constraints (all kinds of systems and applications except safety-critical, high-integrity, and real-time systems) such as a stock exchange system, unconstrained rule scheduling algorithms serially schedule the rules based on some criteria such as activation time and execution time. Each rul e scheduling mechanism suffers from some disadvantages in the scheduling process of active rules.
The performance and ef fi ciency of a rule scheduling approach, used in an ADS, directly impact the overall performance and ef fi the ADS.

This study investigates the advantages and limitations of various rule scheduling approaches in ADSs, according to the literature review. In order to improve the scheduling process of active rules, this work equips the most effective existing uncon-strained approach (i.e. E X -SJF PRO -V.2.8 ( Rasoolzadegan, 2007 )) with a learning module. The learning module helps to make better estimates of the probability of truth of the condition section of each rule  X  which, in turn, improves the performance of the rule scheduling process. This work also proposes a new framework for comparing and evaluating existing rule scheduling approaches.
This framework consists of an active database system simulator, named ADSS 1 as well as some standard criteria for evaluating rule scheduling approaches. Our new approach, referred to as E -SJF
EsTLA , is compared with the previously developed unconstrained scheduling approaches according to the mentioned criteria in ADSS. The results of these experiments could show that E X improves the rule scheduling process.

The rest of this paper is organized as follows: section two presents a set of key terms that are necessary to be able to communicate the scope and contributions of this work. This section also de fi nes the problem to be solved by the proposed approach. In section three, existing rule scheduling approaches are reviewed. Section four introduces the new rule scheduling approach. This section de fi nes learning automata and elaborates on how a learning automaton helps us improve the rule scheduling process. Then in section fi ve, ADSS is explained. This section describes the design of the experiments. Two cases of experiments are designed: the rules used in one of the two cases are more highly correlated and more dependent than those of the other. The results of experiments are illustrated, using several tables and charts. The results could show that the proposed approach improves the effectiveness of the rule scheduling process. Finally, section six presents the conclusions and discusses the suggestions for future work. 2. Key concepts and de fi nitions is executed as a transaction. One of the main characteristics of
ADSs, called active work load, is the dynamic activation of rules and subsequently the dynamic generation of transactions during the running of the system. Each transaction causes additional events to occur in the system during its execution, for example, through data manipulation (inserting, updating, deleting, or restor-ing data) in the database . The new events that have occurred may activate other rules, and subsequently, some new transactions may be added to the rules processing cycle. The execution of each new transaction may trigger other events. The newly triggered events may, in turn, activate further rules. Such an iterative cycle may continue to some levels. Those transactions that lead to generation of additional transactions during their execution are called transactions,  X  and the generated transactions are called transactions.  X  Similarly, the rules that can potentially activate other rules are called  X  parent rules,  X  and the activated rules are named  X  child rules.  X  Moreover, we formally de fi ne four time-related idioms for each transaction: (1) Expected Execution Time (EET), (2) Actual Execution Time (AET), (3) Expected Termination Time (ETT), and (4) Actual Termination Time (ATT). The formal de of these idioms are depicted in Table 1 .
 transaction is expectedly terminated if the execution time of the transaction is terminated, and all of its immediate child transactions are expectedly terminated. A transaction is actually terminated if the execution time of the transaction is terminated, and all of its immediate and deferred child transactions are actually terminated. 2.1. An example for active work load mechanism used for scheduling the transactions of Fig. 1 is FCFS, which is discussed in Section 3.2.2.1 . This fi gure indicates the dynamic generation of transactions up to four levels. In this example, a transaction, called T , has already been generated and is ready to be executed at t 0 ( a  X  T  X  ). The execution of T starts at t 2 ( s  X  T  X  ). This transaction generates two deferred transactions T and T def 2 at t 4 and t 5 and one immediate transaction T during its execution. The execution of T imm 1 starts at t execution of T imm 1 , two deferred transactions T def 3 and T generated. The execution of T imm 1 is expectedly terminated at t
Now the execution of T continues until another immediate trans-action T imm 2 is generated by T at t 14 . After the execution of T actually terminated at t 15 (expected termination time and actual termination time of T imm 2 are equal because T imm 2 dose not generate any other transaction during its life time), the execution of T continues, and one independent transaction T ind 1 is generated at t 16 . Although it was expected that the execution of T be terminated at t 17 ( ETT  X  T  X  ), its execution is actually terminated after the mentioned T imm 2 is actually terminated at t 15 , so as soon as T and T 1 be actually terminated, T is actually terminated too). The execution of T def 1 starts at t 17 , and one immediate transaction T is generated during its execution. Two deferred and independent transactions T def 5 and T ind 2 are generated by T def 1 respectively. The execution of T def 1 is terminated expectedly at t
The execution of T def 2 starts at t 23 . This transaction causes two immediate transactions T imm 4 and T imm 5 to be generated. The execu-tion of T def 2 is actually terminated at t 28 . The execution of T at t 28 and causes two immediate transactions T imm 6 and T imm executed. The execution of T def 3 is actually terminated at t is time for T def 4 and T def 5 to be executed. The execution of T at t 33 . One independent transaction T ind 3 and one immediate transaction T imm 8 are generated during the execution of T execution of T def 4 and T imm 8 are actually terminated at t mentioned T def 3 and T def 4 are actually terminated at t respectively, so their parent transaction, T imm 1 , is actually termi-nated at t 37 . It is now time for the execution of T def of this transaction and T def 1 are actually terminated at t quently the execution of T is actually terminated at t 39
Table 2 presents some information regarding the transactions executed during the life-time of transaction T. The information is about (1) the time when each transaction is activated, starts to be executed, expectedly terminated, and actually terminated (2) the expected and actual execution time of each transaction, and (3) the number of the immediate, deferred, and independent transactions generated during the execution of the parent transactions. As is observed in Table 2 , the actual execution time of each parent transaction is directly related to the number and the actual execution time of its deferred and immediate children. 2.2. Active rule processing cycle
Fig. 2 illustrates how the rules processing cycle works in an ADS. The application runs until an internal event  X  such as inserting, deleting, or updating of data  X  or an external one whose origin is out of the system's scope  X  such as an increase or decrease of temperature reported by the sensors  X  occurs at the runtime of the system; then the rule processing unit takes the control of the system (stage A). The rule processing unit activates those rules of the rule-base triggered by the events that have occurred. The activated rules are then placed in one of the lists numbered 2, 4, or 6 according to their event-condition coupling modes (stage B). The condition section of each of the activated rules that are in the immediate, deferred, or independent lists has the fi rst, second, or third priority to be evaluated, respectively. For example, the condition section of none of the rules that are in the deferred or independent lists is evaluated as long as there is an activated rule in the immediate list. In for condition evaluation depends on the scheduling mechanism used by the rule scheduler (stage C). If the condition section of a rule holds trueattheevaluationtime,theruleisplacedintooneofthelists numbered 1, 3, or 5 according to its c ondition-action coupling mode.
Similarly, the action section of each of the ready-to-be-executed rules that are in the immediate, deferred, or independent lists has the second, or third priority to be executed, respectively. The rule scheduler chooses the ready-to-be-executed rule that has the highest priority to execute its action section as a transaction (stage D). New events may occur during the execution of the action section of the rule being executed. The rules triggered by the new events that have occurred are activated and entered into the rules processing cycle. This cycle continues until there are no rules remaining in any of the six lists. Then control is returned to the application.

In general, the rules that are in the lists numbered 1, 2, 3, 4, 5, and 6havethe fi rst to sixth priorities, respectively. For example, the condition section of none of the rules in the  X  immediate-activated-rules  X  list (list number 2) will be evaluated as long as there is a rule in the  X  immediate-ready-to-be-executed-rules  X  list (list number 1). How-ever,theselectioncriterionfortherulesplacedineachlistis determined by the scheduling mec hanism used. Active rules are scheduled for two purposes: (1) to evaluate the condition section of each rule that is in the  X  activated-rules  X  lists (lists number 2, 4, or 6) and (2) to execute the action section of each rule that is in the to-be-executed-rules  X  lists (lists number 1, 3, or 5). 2.3. Rule scheduling evaluation criteria There are several approaches to the scheduling of active rules.
These approaches are discussed in Section 3 .Thereare fi ve criteria used to evaluate the effectiveness and ef fi ciencyoftherulescheduling approaches. These criteria are Average Response Time, Response Time
Standard Deviation, Throughput, CPU Utilization, and Time Overhead per Transaction ( Silberschatz et al., 2012 ; Reid and Sanders, 2012 ): 1. Average Response Time: The response time of a given rule is 2. Response Time Standard Deviation: The response time stan-3. Throughput: Throughput, which is another standard metric for 4. CPU utilization: CPU utilization is de fi ned as the amount of 5. Time Overhead per Transaction: Time Overhead per Transac-4 def rule scheduling mechanism includes every extra or indirect computation time that is required to execute active rules. 2.4. Estimation of actual execution time
The accurate estimation of the actual execution time of a given rule is needed for scheduling rules effectively. Although it is possible to calculate the actual execution time of each active rule at run time, such a calculation imposes too much time overhead on the system. This time overhead signi fi cantly decreases the effec-tiveness and ef fi ciency of the scheduling process. As an alternative, the behavior of each active rule could be estimated before the run time. To do so, the child rules of each parent rule should be estimated before run time. In order to make such an estimation, some preprocessing should be applied to the rule-base. For example, it needs to discover the dependencies of all active rules on each other in the rule-base as a hierarchical model, called rule-base tree ( Rasoolzadegan et al., 2006; Rasoolzadegan et al., 2006 ). Fig. 3 depicts the hierarchical model of the execution of transaction T and its children whose life time is illustrated in Fig. 1 .
As previously mentioned, the execution of the action section of an active rule depends on the evaluation result of its condition section at evaluation time. In other words, the probability of the execution of an active rule equals the probability of truth of its condition section. If the condition section of a rule is evaluated to false, its action section is not executed. The probability of truth of the condition section of an active rule is the extent to which it is possible for the condition section of the rule to be true at the evaluation time during the system's running process. The truth (or falsehood) of the condition section of each child rule, activated during the execution of a parent rule, affects the actual execution time of the parent rule. The more accurately the execution probabilities of active rules are estimated, the more precisely the actual execution times of the rule are calculated ( Rasoolzadegan et al., 2006 )  X  which, in turn leads to more effective and ef scheduling of active rules. Estimation of the actual execution times of active rules has the main role for introducing an effective rule scheduling process ( Rasoolzadegan, 2007; Rasoolzadegan et al., 2008; Rasoolzadegan et al., 2006 ). One key issue is being able to accurately estimate how long an active rule takes to be executed.
E X -SJF EsTLA , using learning machine capabilities, improves the active rule scheduling process proposed by E x -SJF PRO -V.2.8. The E -SJF EsTLA approach uses learning to make better estimates of the probability of truth of the condition section of each rule turn, improves the performance of the rule scheduling process of ADSs. This work is a step towards the accurate estimation of the actual execution time of active rules. 3. Related works
As shown in Fig. 4 , existing rule scheduling approaches are divided into two major categories: (1) concurrent scheduling approaches and (2) serial scheduling approaches. The fi rst category is fundamentally different from the second, and so they are not comparable with each other. Concurrent scheduling approaches require special hardware and software platforms. In these approaches, an ADS evaluates or executes triggered rules concurrently. Serial scheduling methods are divided into two groups: (1) constrained approaches and (2) unconstrained approaches. The former includes EDF-based approaches and the static priority approach. The latter includes the random scheduling mechan-ism, FCFS, and the SJF-based scheduling approaches. Constrained approaches are used when rules have some restrictions (or constraints) such as deadlines or priorities. Unconstrained approaches can be used for all purposes except when the rules have some restrictions. In other words, unconstrained scheduling algorithms serially schedule the rules thatdonothaveanyconstraintssuchasprioritiesordeadlines.

As mentioned in Fig. 2 , the processing cycle of active rules consists of two scheduling phases: (1) scheduling activated rules to evaluate their condition sections (Stage C), and (2) scheduling ready-to-be-executed rules to execute their action sections (Stage D). Although scheduling phases 1 and 2 are completely separated, each existing scheduling approach, elaborated on in the following subsections, uses the same mechanism for both scheduling phases mentioned. In other words, although rule scheduling in phases 1 and 2 are totally independent to each other, according to the rule scheduling algorithm used in each existing rule scheduling approaches, each approach uses a special method of scheduling
T for both phases. The rule scheduling approaches categorized in
Fig. 4 are brie fl y introduced in the following subsections in order of presence in this fi gure. 3.1. Concurrent scheduling approach
HiPAC ( Zong et al., 2007 )andFAR( Ceri et al., 2003 ) active database systems support this approach. In HiPAC, the rules processing cycle is invoked whenever an event occurs and triggers some rules. This method differs from other approaches to scheduling multiple triggered rules. Therefore, it cannot be compared with serial scheduling approaches. HiPAC evaluates or execu tes triggered rules concurrently.
This means that if some rules are tri ggered during the execution of a rule, they are evaluated or executed concurrently. IRS and CIRS are two other concurrent rule scheduling a pproaches which are presented in
Jin et al. (2007) and Jin (2009) , respectively. The performance of parallel scheduling methods is better than sequential ones, but they are not able to be executed in all hardware and software platforms. As mentioned in Jin et al. (2007) ,oneoftheopenproblemsofADSs, which prevents the widespread use of ADSs, is lack of an effective rule scheduling approach that can be used in various hardware and software circumstances. 3.2. Serial rule scheduling approaches
As previously mentioned, serial scheduling methods are divided into two groups: 1) constrained approaches and 2) unconstrained approaches. 3.2.1. Constrained approaches
This group of scheduling approaches includes EDF-based approaches and the static priority approach. Constrained approaches are used when rules have some restrictions (or constraints) such as deadlines or priorities. There are no other kinds of constraints or restrictions for active rules except deadline or priority. 3.2.1.1. EDF based scheduling approach. Earliest Deadline First (EDF) is one of the best classic algorithms that have so far been introduced for rule scheduling in real-time systems ( Anderson et al., 2008; Ceri et al., 2003; Kudrab, 2010 ). The EDF based approach, which is constrained approach, schedules active rules based on their deadlines in Real-time
Active Databases (RADBs). When a n active rule should be selected among a set of rules to be evaluated or executed, the rule, which has the nearest deadline, is selected. The EDF based approach has three different versions: EDF PD ,EDF DIV ,andEDF SL .InEDF PD , the deadline assigned to each rule is not altered during its life-time. However, in
EDF DIV and EDF SL , the deadline assigned to each rule is dynamically altered during its life-time according to the number of the immediate and deferred rules activated due to its execution. EDF SL
Slack First (LSF) technique. In this approach, the deadline of a rule is estimated according to (1) the estimation of the execution time of the rule, (2) the number of the rules that have been activated since the start of the execution of the rule, and (3) the estimation of the number of the rules that will be activated during the remainder time of the execution of the rule. In order to use EDF SL , the information mentioned above (in particular, the third one) should be available. If the required information is available for all rules, EDF SL is the most effective approach among the three versions of the EDF based approach ( Rasoolzadegan and Abdollahzadeh 2006 ). 3.2.1.2. Static priority scheduling approach. In this constrained approach, the system assigns a numerical priority to each ECA rule ( Azmi et al., 2011 ). The priorities need not be unique. Ariel and
Postgres systems assign a static priority, between -1000 and  X  1000, to each rule. When an active rule should be selected among a set of rules to be evaluated or executed, the rule that has the minimum static priority is selected ( Adaikkalavan and
Chakravarthy, 2012 ; Krosing et al., 2013 ;( Stankovic et al., 2014 ). 3.2.2. Unconstrained approaches scheduling mechanism, FCFS, and the SJF-based scheduling approaches. Unconstrained approaches can be used for all pur-poses except when the rules have some restrictions. 3.2.2.1. Random scheduling approach. Random scheduling is one of the easiest approaches to scheduling active rules in ADSs ( Adaikkalavan and Chakravarthy, 2012 ). This approach has been implemented in RPL and Ode active database systems ( Rasoolzadegan et al., 2006 ). The random scheduling approach selects one of the activated or ready-to-be-executed rules randomly. The main characteristic of this unco-nstrained approach is its simplicity, though at the cost of ef 3.2.2.2. FCFS scheduling approach. FCFS is one of the classic appro-aches used for rule scheduling in ADSs. When an event occurs, and the corresponding rule(s) is (are) triggered, an instance of each triggered rule is generated. Each instance contains a timestamp, which shows the time when the corresponding rule is triggered. When an active rule should be selected among a set of rules to be evaluated or executed, the rule that has the earl iest timestamp is selected. This scheduling approach, used in SAMOS ( Adaikkalavan and Chakravarthy, 2012; Sarkar and Debnath, 2012 ), is a unconstrained approach. 3.2.2.3. SJF-based scheduling approaches (E x -SJF). E x -SJF is based on the SJF algorithm. SJF is one of the most effective classic scheduling algorithms ( Rasoolzadegan et al., 2008; Rasoolzadegan et al., 2006 ). It is useful for scheduling the rules (as jobs) when their execution duration is fi xed and deterministic. Due to the active work load nature of ADSs, the SJF algorithm needs to go through some changes to be appropriate for scheduling active rules ( Rasoolzadegan and Abdollahzadeh, 2006 ). It needs to be able to estimate the execution time of rules, and that is what E x E x -SJF uses the rule tree construct, previously introduced in Fig. 3 . be scheduled based on the actual execution time of generated transactions. In a higher level view, each transaction along with all its immediate and deferred children can be considered as a virtual transaction. SJF based approaches should schedule virtual transac-tions generated during the run time of the system. As previously mentioned, E x -SJF constructs hierarchical models (rule trees) to prepare a rule-base for scheduling active rules according to the actual duration of their execution ( Rasoolzadegan et al., 2006 ). different in fl uences on the calculation process of the execution time of parent rules in different versions of E x -SJF. There are four versions of E x -SJF; namely, E x -SJF EXA ,E x -SJF PRO ,E x -SJF PRO ( Rasoolzadegan et al., 2006 ). All versions of E x -SJF construct the hierarchical models of the execution process of active rules to predict their execution time ( Rasoolzadegan et al., 2008 ). The difference between these versions is the manner in which the execution of active rulesisestimated.In Section 4 ,weintroducea fi fth version of E
All versions of E x -SJF, which are unconstrained, try to predict the actual execution time of active rules before run time.
 expressions. Suppose the condition section of a rule R is de of truth of the condition section of R is calculated as follows: PA 4 B  X  X  3 C 4 D  X  X   X   X  PA 4 B  X  X  X  PC 4 D  X  X  P  X  A 4 B 4
Supposing that A , B , C , and D are independent of each other, we will have:
PA
If the probability of truth of each of A , B , C , and D is available, the probability of truth of the condition section of R can be calculated precisely by putting the probabilities in relation (1) .As mentioned in Section 2 , the probability of truth of the condition section of each active rule should be estimated before run time.
Subsequently, the actual execution time of each active rule is approximated by relation (2) before run time.

XR  X  X  X  LR  X  X  X   X 
PR  X  X  The probability of truth of the condition section of an
X  X  R
 X  The actual execution time of an immediate or deferred n  X  R  X  Number of those deferred and immediate rules activated LR  X  X  The expected execution time of R
XR  X  X  The actual execution time of R 3.2.2.3.1. E x -SJF EXA scheduling approach. In this approach, the probability of truth of the condition section (the probability of the execution) of each rule is considered as 1 ( PR i  X  X  X  1) ( Rasoolzadegan et al., 2008 ), ( Rasoolzadegan and Abdollahzadeh, 2006 ). 3.2.2.3.2. E x -SJF PRO scheduling approach. In this approach, the probability of truth of each conditional statement in the condition section of each rule is uniformly considered as 0.5. Based on relation (1) , the probability of truth of the condition section of R will be:
PR  X  X  X  PA 4 B  X  X  3 C 4 D  X  X   X   X  1 2 1 2  X  1 2 1 2 1 2 1 2
The actual execution time of each rule in this approach is estimated by relation (2) before run time ( Rasoolzadegan et al., 2008 ). This rule scheduling mechanism hypothesizes that the logical statements of the condition section of each rule are independent of each other. Such an assumption decreases the accuracy of the estimation process. However, this approach esti-mates the actual execution time of each active rule more accurately than E x -SJF EXA . 3.2.2.3.3. E x -SJF PRO -V.1.8 scheduling approach. Before run time,
E -SJF PRO -V.1.8 calculates the actual execution time of each rule as E -SJF PRO does ( Rasoolzadegan, 2007; Rasoolzadegan et al., 2006 ). At run time, when rule R that has the shortest actual execution time among all activated rules is selected to be eval-uated, the probability of truth of each logical statement ( LS condition section of R ; i.e. PR ; LS i  X  X  is calculated and stored by relation (3) .

PR ;
LS i  X  X  X  T 1 T
T 1 shows the number of times LS i has been evaluated to true so far, and T 2 shows the number of times R has been activated so far.
This process is repeated for each logical statement of the condition section of each activated rule during the running of the system until the change rate of the probability of truth of the logical statement achieves a desired value (e.g., 0.0000001 referred to as in general mode). At this time, the initial value (i.e. 0.5) is replaced with the new one. If after a speci fi c period of time, the change rate of the probability of truth of a logical statement does not converge into  X  , the average of the results calculated up to that time is considered as the fi nal value of the probability, and the updating process of the probability is stopped. It is evident that the smaller the value  X  , the more exact the calculation of PR ; LS i the probability of truth of each logical statement of a condition is updated, the probability of truth of the condition is also updated. Finally, the actual execution time of R is updated according to relation (2) , whenever the probability of the execution (the prob-ability of truth of the condition section) of each of its deferred and immediate children is updated. After a short time passes from the beginning of the running of the system, which is trivial in comparison with the total running time of the system, the actual execution times of all rules are calculated with suf fi cient precision, depending on the value  X  . This approach is a step towards the accurate calculation of the actual execution time of each active rule. 3.2.2.3.4. E x -SJF PRO -V.2.8 scheduling approach. E X and E X -SJF PRO -V.1.8 estimate the execution probability of each active rule with two different mechanisms ( Rasoolzadegan 2007 ). As mentioned earlier, the condition section of each rule is com-posed of some logical statements. Table 3 shows four condition sections belonging to four given rules, and Table 4 shows the domain of each conditional variable used in the condition section of each rule mentioned in Table 3 . For instance, the condition section of R 1 is true if the data item A ( DI A ) is greater than the data item B ( DI B ).

The probability of truth of each logical statement can be calculated mathematically before the system run time, according to the following facts and assumptions: (1) the condition section of each rule and the domains of the conditional variables used in the condition sections are de fi ned before run time, (2) logical state-ments are independent, and (3) the probability distribution of a conditional variable is uniform; i.e., the values belonging to the domain of the variable have the same probability of occurrence.
Here, the probability of truth of the condition section of rule R is calculated based on the assumptions and information mentioned in Tables 3 and 4 .

As illustrated in Fig. 5 , DI A is greater than DI B in each point inside the trapezoid S1 , and DI A is smaller than DI B in each point inside the triangle S2 . Therefore, the probability of truth of DI
A 4 DI B , on the assumption that the area of the trapezoid S1 is equal to S S1 , and the area of the triangle S2 is equal to S calculated with relation (4) : P  X  R 1  X  X  S S 1 S
Then the appropriate values are assigned to the variables of relation (4) , so we will have:
P  X  R 1  X  X   X  110 100  X  X  X  X  100  X  50  X  25  X  100 160  X  14750
Similarly, the probability of truth of the condition section (the execution probability of the action section) of each rule is calcul-able before run time. After calculating these probabilities, the actual execution time of each rule can be calculated with relation (2) before run time. At run time, the scheduler continuously selects the rule that has the shortest actual execution time among those activated rules whose condition sections are evaluated to true.
Then the scheduler passes the operations of the action section of the selected rule to the transaction execution unit to be executed.
As previously mentioned, in this method, the probability distribu-tion of conditional variables is assumed uniform in the calculation process of the actual execution time of each rule. However, in real systems, the probability distribution of conditional variables is not usually uniform. In order to calculate the actual execution time of each rule more precisely, this approach follows a certain procedure during the running of the system:
At run time, during the de fi nite periods of time (  X  t i assigned values and the duration of their assignment are recorded for every conditional variable of the condition section of each activated rule. The duration of the assignment of a value to a conditional variable is a period of time during which the value is assigned to the conditional variable. Table 5 , using an example, reveals how the assigned values of a conditional variable DI well as the duration of their assignment are stored during the successive periods of time (  X  t i ). In this example, each 1000 minutes is considered as a period of time  X   X  t  X  . Table 5 shows that value has been assigned to DI A during  X  t 1 for 10 minutes, and value has been assigned to this variable during  X  t n for 320 minutes. within the domain of each conditional variable is calculated according to the duration of the assignment of the value to the conditional variable during  X  t ( Rasoolzadegan and Abdollahzadeh, 2006 ). This process is repeated for each value of the domain of each conditional variable until the change rate of the occurrence probability of that value reaches a speci fi c quantity (e.g., 0.001 referred to as  X  in general mode). If after a speci fi c period of time, the change rate of the occurrence probability of a value does not converge into  X  , the average of the results calculated up to that time is considered as the fi nal value of the probability, and the updating process of the probability is stopped. At this time, the initial value is replaced with the new one. It is evident that the smaller the value  X  is, the more accurate the calculation of the distribution probability of each conditional variable will be. When the occurrence probability of each value within the domain of each conditional variable that exists in the condition section of a rule R is updated, the probability of truth of the condition section of R is mathematically updated. Such an updating is based on the newly updated probability distribution of all its conditional variables, and the initial value is replaced with the new one. Finally, the actual execution time of R is updated based on relation (2) , whenever the probability of truth of the condition section of each of its child rules is updated. The actual execution time of each rule is updated with the desired precision (the amount of this precision depends on the value  X  ) after the passage of a short time from the beginning of the system's running process, and consequently, the system reaches the stable state. Indeed, the system reaches the stable state, as soon as the process of calculating and updating the actual execution time of all rules is completed.
 for scheduling the de fi ned rules, but also for performing other tasks and functions such as daily computational and operational activities.
Based on the assumption that idle times mean the times when the system is doing none of its daily computational and operational tasks, if the termination time of each  X  t and the idle times of the system can be synchronized, the above-mentioned calculations related to the scheduling process can be done during the idle times of the system, and less computational overhead is imposed on the system. Such synchronizationispossibleifandonlyiftheidletimesofthesystem are regular. If the system does not have a heavy workload at run time, or it can perform the rule scheduling process along with the other computational tasks without delay, it is not necessary to synchronize the termination time of each  X  t with the idle or low work times of the system. It is evident that the longer the period between the idle times of the system gets, the longer each  X  t becomes. The length of a not have any in fl uence on the effectiveness of the system in the stable state but may affect the effectiveness of the system before it reaches thestablestate.Thesmallerthelengthofeach  X  t , the more frequently the probability of truth of the cond ition section of each rule is updated  X  which, in turn, may cause the system to reach the stable state sooner.
This also helps the system become more effective before it reaches the stable state, but at the cost of impo sing some computational overhead on the system. The administrator of a system should adjust to the required effectiveness and ef fi ciency of the system. The appropriate threshold of effectiveness and ef fi ciency differs from one system to another; therefore, the value  X  varies in different situations and environments.

Before introducing the new rule scheduling approach in the next section, the advantages and drawbacks of the existing rule scheduling approaches are qualitatively summarized in Table 6 .
It is worth mentioning that the advantages and drawbacks of the unconstrained rule scheduling approaches are quantitatively eval-uated and discussed in terms of Effectiveness (Average Response Time, Response Time Standard Deviation, and Throughput) and
Ef fi ciency (Time Overhead per Transaction and CPU Utilization) in
Section 5 . The advantages and drawbacks of the constrained rule scheduling approaches (the Static Priority and EDF based approaches) have also been discussed in ( Rasoolzadegan et al., 2008 ), ( Rasoolzadegan et al., 2006 ), ( Rasoolzadegan et al., 2006 ). 4. The new rule scheduling approach A new rule scheduling approach, called E X -SJF EsTLA (E x [based on]-Estimation-[using]-Learning Automata), is proposed by equipping E X -SJF PRO -V.2.8 with a learning module. This learning module, used during the scheduling process of activated rules, is based on learning automata. It helps the rule scheduler estimate the probability of truth of the condition section of each activated rule more accurately. In other words, the learning module improves the estimation process of the execution probability of each rule. The role of the learning module in the scheduling process will be elaborated further in the following section.
All ready-to-be-executed rules are sequentially executed in the order determined by the rule scheduling mechanism used. In other words, the selection of each ready-to-be-executed rule de leads to a useful action; i.e., the execution of the action section of the selected rule. However, the selection process of an activated rule for evaluation of its condition section is not always a useful action; the rule scheduler throws the selected rule out of the rules processing cycle if its condition section is evaluated to false. Therefore, the evaluation process of the condition section of each activated rule that is evaluated to false is useless for the system. Indeed, here the term  X  useful  X  means that the scheduling process will ultimately lead to the execution of the action section of the selected rule. In contrast, the term  X  useless  X  means that the scheduling process will not ultimately lead to the action section of the selected rule being executed.

Now a question comes to mind: is it possible to reduce the side effects of these useless actions during the scheduling process of the activated rules? The response to this question is the idea behind E -SJF EsTLA . The higher the priority of those activated rules with condition sections that are more likely to be true at evaluation time, the more effective the rule scheduler will be. To do so, we have chosen the probability of truth of the condition section of each rule as a metric for scheduling activated rules. Therefore, it is necessary to estimate the probability of truth of the condition section of each rule as accurately as possible before run time. The estimation process is divided into two phases: (1) before system run time, E X -SJF EsTLA calculates the initial probability of truth of the condition section of each rule as E X -SJF PRO -V.2.8 does, and (2) during the running of the system, the real values of the initial probabilities are approximated by the learning automaton embe-dded in E X -SJF EsTLA . The learning automaton uses the previous results of the condition evaluation of each rule for estimating the probability of truth of the condition section of the rule in the future. Therefore, the system learns to gradually estimate the real value of each initial probability. The probabilities are estimated more accurately as time passes. The more accurately the probabil-ities are estimated, the more likely the activated rules whose conditions are evaluated to true are selected. This increases the number of useful actions -which, in turn, improves the effective-ness and ef fi ciency of the scheduling process.

In summary, E X -SJF EsTLA is designed based on the estimation of the execution probability of rules as E X -SJF PRO -V.1.8 and E
However, E X -SJF EsTLA attempts to improve the rule scheduling process by increasing the precision of estima tion of the execution probability of rules, using learning automata. As previously mentioned, the rules processing cycle consists of two sc heduling phases: (1) scheduling activated rules to evaluate their condition sections, and (2) scheduling ready-to-be-executed rules to execute their action sections. All sche-duling approaches, which have already been introduced, have the same mechanism for both scheduling phases. For example, in both scheduling phases of the E X -SJF PRO -V.2.8 approach, active rules are scheduled based on the actual execution time. In E X -SJF scheduling mechanisms of activated rules and ready-to-be-executed rules are different from each other: E X -SJF EsTLA schedules ready-to-be-executed rules as E X -SJF PRO -V.2.8 does, but it schedules activated rules according to the probability of truth of their condition sections, using a learning automaton. 4.1. Learning Automaton
Reinforcement learning is the study of how arti fi cial systems can learn to optimize their behavior in the face of rewards and punishments. Learning automata (LA), as one of the earliest models of reinforcement learning, are adaptive decision-making devices operating on unknown random environments ( Russell and Norvig, 2009 ; Torkestani and Meybodi, 2010 ;( Narendra and Thathachar, 2013 ). A learning automaton has a fi nite set of actions, and each action has a certain probability (unknown to the automaton) of getting rewarded by the environment of the automaton. The aim is to learn how the optimal action (i.e., the action with the highest probability of being rewarded) is chosen through repeated inter-action with the environment, using a proper learning algorithm.
An environment can be described by triple E  X  V ;  X  ; C ;
V  X f  X  1 ; ... ;  X  r g shows a set of inputs,  X   X f  X  1 ; ... ;  X  outputs, and C  X f c 1 ; ... c r g is a set of probability distributions over  X  . If the environment response takes binary values, such a learning automata model is referred to as P -model, where  X  1  X  1and are considered as the penalty and reward, respectively, and if it takes a fi nite output set with more than two values in the interval [0, 1], such a model is referred to as Q -model, and when the output of the environment is a continuous variable in the interval [0, 1], it is referred to as S -model. Learning automata can be classi two main families: fi xed structure learning automata (FSLA) and variable structure learning automata (VSLA).
 A fi xed structure learning automaton can be represented by a tuple
V  X   X f  X  1 ; ... ;  X  m g is an environment response set,  X   X f set of internal states,  X  :  X   X  - X  is a state transition function, which determines the state of the automaton at an instant n  X  1withrespect toitsstateandinputsattheinstant n ,and G :  X  - X  is an output function, which determines the output of the automaton at an instant n according to its state at the same instant.

A variable structure learning automaton is a quadruple f V  X   X f  X  1 ; ... ;  X  m g is an environment response set, and the probability set P  X f P 1 ; ... ; P r g contains r probabilities, each being the probability of performing a given action in the current internal state of the automaton. The function T is a reinforcement algo-rithm, which modi fi es the action probability vector P with respect to the performed action and received response. The selection probability vector of actions at an instant n is as follows:
Pn  X  X  X  p 1 n  X  X  ; p 2 n  X  X  ; ... ; p r n  X  X  stationary environment with  X   X f 0 ; 1 g . The reinforcement algorithm used in the function T forupdatingactionsprobabilitiesisgenerallyas follows: 4.2. How does a learning automaton help us improve the rule scheduling process? of truth of their condition sections, using a learning automaton. The learning automaton should update the selection probability of each of its actions (i.e., activated rules) according to the responses received from the environment (i.e., the truth or falsehood of the condition sectionofeachactivatedrule).Asmentionedinsubsection4.1,the current action of a fi xed structure learning automaton depends on its current state, and all the time, in such a state, this action is its sole option. This means that if a FSLA is in a state  X  j , the corresponding action  X  j is always selected to be executed. A variable structure learning automaton, in each selection time, unlike a fi xed structure automaton, selects the action that has the greatest success probability among all existing actions. In a VLSA, it is not possible to make a deterministic assignment of an action to a state due to the continual changes of the structure. A learning automaton with a variable structure should be used in the proposed approach because: (1) the learning automaton should select an action (an activated rule) among all existing actions based on the success probability of each action (the probability of truth of the condition section of each activated rule), (2) the number of activated rules changes continuously, and (3) the probability of truth of the condition section of each activated rule is updated continually.
After selection of an activated rule using the learning automaton, the selection probability of the rule should be updated based on one of the three existing mechanisms: L RI , L RP ,and L R  X  P .Wehavedonesome experiments to select one of these updating mechanisms. It is possible to implement these mechanisms in a learning automaton, using some low cost and partial changes into the base automaton. The results of all experiments reveal that with some minor difference, among these three mechanisms, L RI has the best performance for updating the selection probability of each active rule. Moreover, the model of the learning automaton, used in the proposed approach, should be P, in which the input from the environment can take only one of the two values 0 or 1. The response value 1 corresponds to an  X  unfavorable response and occurs when the condition section of the selected rule is evaluated to false, while the output value 0 means the action is  X  favorable  X  and occurs when the condition section of the selected rule is evaluated to true. At each moment, the learning automaton should select one of the activated rules to evaluate its condition section. The number of activated rules at each moment is variable. Consequently, the number of the actions of the automaton is variable too. The set of actions at an instant k is shown by Vk  X  X  ,where Vk  X  X  is a subset of V .It should be mentioned that the selection probability of each action at the instant k is proportionate to the probability of the truth of the condition section of the corresponding rule at the same instant: p k  X  X  X  prob  X  k  X  X  X   X  i The truth probability of the condition section of R i at instant k E -SJF EsTLA initially calculates the probability of truth of the condi-tionsectionofeachactiveruleasE x -SJF PRO -V.2.8 does. If S 0  X  X  ,shows the sum of the truth probabilities of the condition sections of all rules each action is calculated on scale 1 as follows: p 0  X  X  X  X  The truth probability of the condition section of R 0  X  = S  X  0  X 
At instant k, based on the assumption that the actions belonging to Vk  X  X  are active, the selection probabilities of the actions are updated according to relations (6)  X  (8) : Sk  X  X  X   X  a) The favorable response from the environment in the response of b) The unfavorable response from the environment in the resp-onse of  X  q A V  X  k  X  : p q k  X  1  X  X  X  p q k  X  X  c) For each  X  i = 2 V  X  k  X  : p i k  X  1  X  X  X  p i k  X  X 
Fig. 6 shows how the probability of truth of the condition section of each activated rule is updated, using LA. The cycle of updating the mentioned probabilities is iterated as long as there is more than one activated rule. If there is only one activated rule, it is selected to be evaluated, without changing the selection probabil-ities of the rules.

At the run time of the system, during de fi nite periods of time (  X  t i ), the probability of truth of the condition section (the prob-ability of the execution) of each active rule is updated by the same method mentioned in section 3.6.4. Moreover, at the beginning of  X  t i  X  1 , the selection probabilities of the actions of the learning automaton are updated based on 1) the probability of truth of the condition section of each active rule and 2) the selection prob-ability of each action of the learning automaton at the end of according to relation (9) : calculated by E X -SJF PRO -V.2.8 at the end of  X  t k in scale 1 calculated by the learning automaton at the end of  X  t k
The selection probability of the i th action (rule R i ) used by the learning automaton at the beginning of  X  t k  X  1 : P 5. Experimental setup and evaluation
At fi rst, an evaluation framework is proposed and explained in subsection 5.1. The design of the experiments, along with the evaluation results of E X -SJF EsTLA in comparison with the other unconstrained rule scheduling approaches, are then described in
Section 5.2 . 5.1. The proposed evaluation framework
One of the main issues in the fi eld of ADSs is the absence of standard test-beds for the comparison and evaluation of the solutions proposed for different sections of ADSs. For instance, no standard test-bed has been presented for the evaluation of rule scheduling mechanisms yet. We have de fi ned a framework for the comparison and evaluation of existing rule scheduling methods. In this framework, a laboratory environment named ADSS has been designed and implemented to simulate the behavior of active database systems. Each rule scheduling approach can be imple-mented in ADSS for the evaluation of its effectiveness and ef -ciency. The details of the design and implementation of ADSS are extensively described in reference ( Rasoolzadegan and
Abdollahzadeh, 2006 ). This framework contains fi ve evaluation criteria: Average Response Time, Response Time Standard Devia-tion, Throughput, Time Overhead per Transaction, and CPU Utiliza-tion. The three fi rst criteria are used to evaluate the performance and effectiveness of rule scheduling approaches, and the latter two criteria are used to evaluate the ef fi ciency of rule scheduling approaches. These criteria are formally de fi ned in Table 7 . In this table, T is the total cumulative time that an approach has been spent on scheduling active rules in the operational environment of
ADSS, and T n is the total time spent on the execution of the action sections of active rules during a test.
 real behavior of ADSs as much as possible, (2) simulating the various kinds of active rules with different features as well as performing different experiments in several situations (including various rule sets, diverse coupling modes, and different levels of dependency) such that all possible states, which may occur in an
ADS, are covered. This is a step towards the development of an appropriate test bed for the evaluation of the effectiveness and ef fi ciency of rule scheduling mechanisms.
 instructions, actually. It means in ADSS, active rules are actually compiled during the evaluation and execution of their condition and action sections. These two type of compilation help re behavior of ADSs as much as possible  X  which, in turn, increase the validity of the results of the experiments. For the evaluation of the condition section of a rule, the conditional variables and compara-tive operators in the condition section of the rule are identi separated from each other, and then the following steps are perfo-rmed: (1) the current value of the conditional variables are fetched from the database, (2) if there are some computational statements in the condition section (such as x n 2in x n 2 r 40), the required computations are performed, (3) the conditional expressions are evaluated according to the prede fi ned orders and principles, and (4) the evaluation result (true or false) is determined. Similarly, all instructions in the action section of each rule are actually executed.
The execution of the action section of each rule causes the occurrence of corresponding events, and consequently related rules are activated.

In the development cycle of ADSS, we used object oriented principles such as modularity and polymorphism to improve its fl exibility. This allows us to simply change the rule scheduling mechanism used. The ADSS has a three-tier architecture:  X  manager unit  X  ,  X  rule manager unit,  X  and  X  transaction manager unit  X  ( Rasoolzadegan and Abdollahzadeh, 2006 ). In ADSS, we have considered and implemented the required aspects of ADSs to cover all modes and properties of active rules in the real world.
Active rules, generated in the experiments, have been designed based on the ECA model. This means that each rule has three main sections: event, condition, and action. The event section of a rule is randomly de fi ned based on the various types of real events such as changes in the values of the data items that exist in the database of ADSS (internal events), time-sensitive events, receipt of information from sensors (external events), or a combination of them. The condition section of each rule is randomly de fi based on the various types of real conditions; i.e., simple condi-tional expressions or different combinations of them, using logical operators ( 3 ; 4 ; and : ). Simple conditional expressions are randomly de fi ned, using various data items that exist in the database and different comparative operators. The initial values of data items are also determined randomly; however, their values may be changed by the execution of the action section of each rule at run time. The action section of each rule consists of some instructions which manipulate the data items of the database.

In an ADS, according to the requirements and goals of the system, required reactions for various events that might occur are de fi ned in terms of some active rules with appropriate conditions and actions. In ADSS, we have tried to simulate various events of the real world. Each rule, in addition to its three main sections, contains such other sections for de fi ning its event-condition coupling mode, condition-action coupling mode, priority, deadline, time-stamp, and execution duration. The sections assigned for the priority, deadline, time-stamp, and the execution time of each rule make it possible to use and evaluate the static priority, EDF-based, FCFS, and SJF-based rule scheduling approaches, respectively. Each of these sections is activated and initialized manually or randomly, provided that the corresponding scheduling method is used as the scheduling mechanism of the rule scheduler. A rule generator has been developed to generate various active rules with the men-tioned characteristics. The rule generator gets some information as input  X  for example the number of data items, conditions, actions, events, and rules involved in each experiment  X  and generates some appropriate rules randomly, as output, according to the input information. It is possible to record the generated rules to be used in various experiments. 5.2. Evaluation of rule scheduling approaches
In this section, we present the evaluation results of the proposed approach in comparison with the other unconstrained rule scheduling approaches discussed earlier. The experiments were designed in two different cases as follows: in the fi rst case, some sets of rules with normal correlation and dependencies were used. The second case consists of the rules that are more correlated and dependent than the rules of the fi rst case. The greater the number of the rules activated due to the execution of a given rule belonging to a rule set, the more correlated and interdependent the rules of the set will be. Each case of experiments was performed in three modes:  X  Deferred mode  X  ,  X 
Immediate mode,  X  and  X  Composite mode.  X  In the fi rst mode, ADSS uses only the rules whose event-condition and condition-action coupling modes are deferred. In the second mode, ADSS uses only rules with immediate event-condition and condition-action coupling modes, and ultimately in the third one, ADSS uses various rules with different modes.
 experiments. The fi elds that are assigned to the event-condition coupling mode and the condition-action coupling mode of each generated rule are initiated according to the input mode. If the input mode is  X  deferred  X  or  X  immediate,  X  the value  X  deferred  X  immediate  X  is assigned to the event-condition coupling mode and the condition-action coupling mode of each generated rule, respectively. If the input mode is  X  composite,  X  one of the values  X  deferred  X  ,  X  immediate,  X  or  X  independent  X  is randomly assigned to the event-condition coupling mode and the condition-action coupling mode of each generated rule. Moreover, in the composite mode, the rule generator helps de fi ne what percentage of the event-condition and condition-action coupling of generating rules are immediate, deferred, or independent modes.
 method in each of the two cases and the three modes, 20 rule sets (rule-bases) of each size n ( n A {100, 200, 400, 800, 1200, 1800, 2100, 2500, 3000, 4000, 5000, 6000, 7000, 8000}) were generated in each case and mode. Each scheduling method was examined, using each rule set, 20 time periods in ADSS. Each experiment lasted t hour(s) ( t A i :  X  j 1 r i r 20 ). In other words, to make accurate results, each scheduling method was examined under each rule-base for 20 time periods. Some of these results are illustrated in Figs. 7  X  17 . Moreover, the results were statistically analyzed by t-test. The results of our statistical analysis are presented in Tables 8  X  15 .

It is worth mentioning that the main task of ADSS is to prepare the grounds for evaluating the effectiveness and the ef fi the various rule scheduling approaches using the de fi ned rule sets. To do so, at the beginning of each experiment, a rule is randomly selected and executed. The execution of the action section of the selected rule causes the corresponding events to occur, and consequently, the related rules are activated. The rule scheduler starts scheduling the activated rules by the rule scheduling approach being evaluated. The process of rule scheduling con-tinues until the end of the experiment. At the end of the experi-ment, the effectiveness and ef fi ciency of the rule scheduling approach is calculated in terms of the de fi ned metrics. Then, the results along with the required parameters of the experiment are saved in a table for later analysis of the results. 5.2.1. Evaluation in the fi rst case
We have done several experiments in the fi rst case in the immediate, deferred, and composite modes. One of the other inputs of the rule generator is the  X  case  X  of experiments. In the fi rst case, the input value  X  1  X  is sent to the generator to determine the case of the experiments. In the fi rst case, the rules used in the experiments should have normal correlation and dependencies. Therefore, the event and action sections of the rules are randomly de fi ned without any restrictions.

Fig. 7 illustrates the average response time of the unconstrained approaches to scheduling thousands a ctive rules with various features in the composite mode. As Fig. 7 shows, E x -SJF EsTLA has the least (best) average response time during the running of the system, and E V.2.8 occupies the second rank from the viewpoint of this criterion. The Random scheduling approach has the greatest (worst) average response time among the evaluated approaches. Fig. 7 reveals that the Average Response Time of each of the E x -SJF-based approaches is less than the Random and FCFS approaches. Fig. 8 shows the throughput of the unconstrained scheduling approaches to scheduling different numbers of active rules (between 100 and 8000) in the composite mode. It can be inferred that E x -SJF EsTLA has the greatest (best) throughput, and E x -SJF PRO-V.2.8 occupies the second place based on this criterion. FCFS has the worst throughput.

Fig. 9 shows the time overhead per transaction of the uncon-strained rule scheduling approaches for different numbers of active rules in the composite mode. Considering Fig. 9 , we can easily conclude that the Random approach has the least (best) time overhead per transaction during the running of the system; however, the other scheduling mechanisms (including E x -SJF etc.) have almost equal time overhead per transaction. Fig. 10 reveals the response time standard deviation of the unconstrained rule scheduling approaches for different rule sets in the composite mode. As Fig. 10 depicts, E x -SJF EsTLA and E x -SJF PRO-v.2.8 difference, have the least (best) response time standard deviation among all the unconstrained scheduling mechanisms during the running of the system. E x -SJF PRO-V.1.8 ,E x -SJF PRO , and E occupy the next places, respectively, in this criterion. The Random scheduling approach has the greatest (worst) response time standard deviation. Considering Fig. 10 , we can say that the Response Time Standard Deviation of E x -SJF EsTLA and E x v.2.8 is less than those of the Random and FCFS approaches.
Figs. 11  X  17 (see Appendix) show some evaluation results for the unconstrained scheduling approaches in the immediate and deferred modes of the fi rst case. The results of our experiments in the deferred, immediate, and composite modes are shown in Tables 8  X  10 ,respec-tively. The content of each cell shows the rank of the corresponding scheduling method based on the corresponding evaluation criterion. In each column in these tables, the low er the value is, the higher the rank will be. For example, in Table 10 , the Random approach has the rank among all the unconstrained scheduling approaches from the viewpoint of time overhead per transaction, because as indicated in Fig. 9 , it has the least time overhead per transaction among the unconstrained approaches. As another instance, E x -SJF EsTLA rank among the unconstrained scheduling approaches from the view-point of throughput in the composit emode,becauseithasthegreatest throughput among the evaluated approaches. It is worth mentioning that these ranks have been determined based on statistical analysis of experimental results using t-test.

In each case of experiments, there is an inverse relationship between the fi nal rank of an approach k and its total score (S  X  k  X  )in comparison with the other unconstrained approaches. S  X  k  X  is calculated as:
Sk  X  X  X   X  3 i  X  j  X  where i and j are also considered as follows:
In relation (10) , Rnk i ; j k  X  X  is the rank of the approach k in the j mode in terms of the i th evaluation metric. For an example, we can calculate S  X  Random  X  in the fi rst case of experiments as follows:
S Random  X  X  X   X  3  X   X  3  X  X  Rnk 1 ; 1 Random  X  X  X  Rnk 2 ; 1 Random  X  X  X  Rnk 3 ; 1 Random  X  X 
According to relation (10) , Rnk 5 ; 1 Random  X  X  is the rank of the random approach in the  X  deferred  X  mode in terms of  X  CPU Utilization.  X  According to Table 8 , Rnk 5 ; 1 Random  X  X  is equal to 3.
Rnk 1 ; 2 Random  X  X  is the rank of the random approach in the  X  immediate  X  mode in terms of  X  Average Response Time.  X  Accord-ing to Table 9 , Rnk 5 ; 1 Random  X  X  is equal to 5. Therefore, the total score of the Random scheduling approach is calculated according to relation (10) and Tables 8  X  10 as:
S Random  X  X  X   X  3 strained scheduling approaches in the fi rst case of experiments. scheduling approaches do not change in the experiments of the second case in comparison with those of the fi rst one. In both and second cases, E X -SJF EsTLA and E x -SJF PRO -V.2.8 have the the second ranks among all the unconstrained approaches, respec-tively. However, their difference (in terms of ef fi ciency and effec-tiveness) in the second case is greater than that of the fi
Such a difference is discussed statistically in the rest of this section and Section 5.2.2 .
 analyzed using t -test. As an instance, we use the t -test to investigate whether the effectiveness and ef fi ciency of the rule scheduling process is signi fi cantly improved in E X -SJF EsTLA in comparison with E
V.2.8 as the most effective existing approach. The t-test is used for comparing the means of the two samples (or treatments), even if they have different numbers of replicates. In simple terms, the t-test compares the actual difference between the two means in relation to the variation in the data (expressed as the standard deviation of the difference between the means). Based on the characteristics of our experiments, an unpaired t-test, assuming unequal variances, is used to statistically analyze the signi fi cance of the experimental results ( Motulsky 2010 ).
 values: X 1 , X 2 (the means of the two samples),  X  2 1 , of the samples), n 1 , n 2 (the sample sizes of the samples), and df (degrees of freedom): the critical t value according to t -table at the chosen con level (normally p  X  0.05 ). If the calculated t value exceeds the tabulated value, we say that the means are signi fi cantly different at that level of probability ( p  X  0.05 ). A signi fi cant difference at p  X  0.05 means that we can be reasonably con fi dent that the samples/treatments do differ from one another, but we still have nearly a 5% chance of being wrong in reaching this conclusion.
E X -SJF EsTLA and E x -SJF PRO -V.2.8 in the fi rst case of experiments, in terms of Average Response Time, Response Time Standard Devia-tion, and Throughput. Table 13 presents the results of the statistical evaluation of E X -SJF EsTLA and E x -SJF PRO -V.2.8 in the experiments in terms of Time Overhead per Transaction and CPU
Utilization. As previously mentioned, in each of the 14 sizes of rule sets ({100, 200, 400, 800, 1200, 1800, 2100, 2500, 3000, 4000, 5000, 6000, 7000, 8000}), 3 modes (the deferred, immediate, and independent modes), and 2 cases (the fi rst and second cases), the effectiveness and ef fi ciency of each rule scheduling approach has been evaluated 20 time periods using 20 rule sets. Each experi-ment lasted t hour(s) ( t A i :  X  j 1 r i r 20 ). Indeed, in each size, mode, and case, 400 experiments (20 20) were designed for the evaluation of each rule scheduling approach. Therefore, the value that has been inserted in each cell of Tables 12  X  15 is the average of the results of 400 experiments.
 experiments of the fi rst case, E X -SJF EsTLA signi fi cantly improved the rule scheduling process in terms of throughput in comparison with E x -SJF PRO -V.2.8 in all the deferred, immediate, and independent modes.
In addition, E X -SJF EsTLA signi fi cantly decreased the average response time of the rule scheduling process in comparison with E x in the immediate mode. A close-to-signi fi cant decrease in the average response time of the rule scheduling process was also obtained by E -SJF
EsTLA in comparison with E x -SJF PRO -V.2.8 in the deferred and independent modes. Moreover, E X -SJF EsTLA decreased the response time standard deviation of the rule scheduling process in comparison with E x -SJF PRO -V.2.8, but not to a statistically signi
The calculated t -values presented in Table 13 imply that the difference between the ef fi ciency of E X -SJF EsTLA and E is negligible in terms of Time Overhead per Transaction and CPU
Utilization in the experiments of the fi rst case. In other words, neither E X -SJF EsTLA nor E x -SJF PRO -V.2.8 is signi fi than the other in terms of Overhead per Transaction and CPU
Utilization because the corresponding t -values are much less than the critical t-value, i.e. 2.06. 5.2.2. Evaluation in the Second Case
In the second case, we have done several experiments, using more correlated and interdependent rules in the immediate, deferred, and independent modes. In this case, thousands of rules, which are more dependent on each other in comparison with the fi rst case, have been generated and inserted in the rule-base. This means that the average rate of the activation of child rules in the experiments of the second case is more than that of the fi  X  which, in turn, makes the number of the child rules activated during the execution of their parents exponentially increase in the second case of the experiments in comparison with the fi rst case of the experiments. In other words, if the number of the child rules activated during the execution of their parents is n in the of the experiments and is m in the second case of the experiments, then m is much greater than n ( m 4 n ). For example, 800 experi-ments have been done in each of the immediate, deferred, and composite modes to evaluate the effectiveness and ef fi ciency of E -SJF
EsTLA , using 20 rule sets of size 8000 (400 experiments per each of the fi rst and second cases). The average rate of the activation of child rules in the experiments of the fi rst case is 2. This rate has been increased to 10 in the second case. Based on the assumptions that: (1) each experiment lasts t hours ( t A i :  X  j 1 r (2) the average execution time of the rules executed during the experiments is t 0 , n and m are calculated as: n  X  1  X  2 1  X  2 2  X  ...  X  2 k  X   X  k m  X  1  X  10 1  X  10 2  X  ...  X  10 k  X   X  k where k t = t 0 . The greater the value of k is, the greater the difference of n and m will be. As previously mentioned, one of the inputs of the rule generator is the  X  case  X  of experiments. In the second case, the input value  X  2  X  is sent to the rule generator to determine the case of the experiments. To produce a rule set with more correlated and dependent rules, it is suf fi cient to generate rules with more correlated event and action sections. To do so, a set of correlated and dependent events and operations have been de fi ned. In the second case, the operations are de fi ned such that a greater number of events canbetriggeredduringtheirexecutionincomparisonwiththe experiments of the fi rst case. The rule generator randomly assigned the de fi ned events and operations to the event and action sections of the generating rules, respectively. Indeed, in the second case, we increased the correlation of the event and action sections of the generating rules. This caused more events to be triggered when the operations of the action section of a rule were executed, and this consequently caused more rules to be activated. In other words, the operations de fi nedintheactionsectionofeachrulecausedmore events to occur, and the events that have occurred were used in the event section of more rules.

The results of the experiments in the second case con fi rmed the results obtained in the fi rst case of the experiments. Moreover, these results indicated that as the rate of dependency and correlation between rules increases, the more effective the proposed approach becomes. The increase in the number of child rules activated while a parent rule is being executed results in an increase in the frequency of estimating the probability of truth of each condition section. As previously mentioned, estimation is the basis of the calculation of the actual execution time of each rule, so in the second case, the accuracy of the estimation process has a greater effect on the precision of the calculation of the actual execution time of each rule. In other words, the more interdependent the active rules are, the more bene fi cial the role of the estimation process becomes in calculating the actual execution time of each rule. Therefore, the effectiveness of those approches (such as E X -SJF EsTLA )thatcalculatetheactualexecu-tion time of a rule based on estimating the probability of truth of the conditionsectionoftheruleismuchmoreobviousinthesecondcase of the experiments.

SJF EsTLA and E x -SJF PRO -V.2.8 in the second case of the experiments in terms of Average Response Time, Response Time Standard
Deviation, and Throughput. Table 15 presents the results of the statistical evaluation of E X -SJF EsTLA and E x -SJF PRO second case of the experiments in terms of Time Overhead per Transaction and CPU Utilization.
 experiments of the second case, E X -SJF EsTLA signi fi cantly improved the rule scheduling process in terms of average response time and throughput in comparison with E x -SJF PRO -V.2.8 in all the deferred, immediate, and independent modes. Moreover, E X -SJF EsTLA ased the response time standard deviation of the rule sched-uling process in comparison with E x -SJF PRO -V.2.8, but not to a statistically signi fi cant degree.

The calculated t -values presented in Table 15 imply that the difference between the ef fi ciency of E X -SJF EsTLA and E was negligible in terms of Time Overhead per Transaction and CPU
Utilization in the experiments of the second case. In other words, neither E X -SJF EsTLA nor E x -SJF PRO -V.2.8 is signi fi than the other in terms of Overhead per Transaction and CPU
Utilization because the corresponding t -values are much less than the critical t-value, i.e. 2.06.

The results of the experiments revealed that E x -SJF EsTLA greatest positive impact on the performance and effectiveness (average response time, response time standard deviation, and throughput) of ADSs. E x -SJF EsTLA calculates the actual execution time of each rule more precisely, using a learning automaton, than other versions of the E x -SJF approach, and this fi nally leads to the improvement of the rule scheduling process. The estimation process of the execution probability of a rule does not impose computational overhead on the system, so it does not have a negative impact on the time overhead per transaction and CPU utilization ( Rasoolzadegan et al., 2006 ).Therefore, E X
E -SJF PRO -V.2.8 have the same ef fi ciency from the viewpoints of time overhead per transaction and CPU utilization. More informa-tion about the details of the results obtained through various experiments is accessible at http://ceit.aut.ac.ir/islab/Researches/ ADS/Experiment-Results.rar .
 E -SJF EsTLA improves the rule scheduling process of activated rules. The occurrence of such improvement is logically expected.
The activated rules whose condition sections are false at the evaluation time are not executed. The time spent for the selection and evaluation of these activated rules is counted as the wasted time in the system, which decreases the effectiveness of the system. If the priority of the selection of these activated rules is decreased, the effectiveness of the system is increased. E schedules activated rules based on the probability of truth of their condition sections -which, in turn, decreases the priority of the selection of the activated rules with condition sections that are more likely to be false at evaluation time. The computational overhead of E X -SJF EsTLA in comparison with E X -SJF PRO in the updating of the probability of truth of the condition section of some activated rules, using relation (9) , which is trivial. 6. Conclusion and future work
In this paper, at fi rst a set of key terms necessary to commu-nicate the scope of ADSs, such as active work load, the rule scheduling process, and rule scheduling evaluation criteria, were de fi ned. Moreover, the position and importance of the rule scheduling process in an ADS were explained. Afterwards, the existing rule scheduling approaches, as related works, were intro-duced. As mentioned in ( Rasoolzadegan, 2007; Ceri et al., 2003; Jin, 2009; Jin et al., 2007; Meenakshi and Thiagarasu, 2014; Meenakshi and Thiagarasu, 2014; Saravanapandi Solairajan et al., 2013; Narang et al., 2013 ) one of the open problems of ADSs, which prevents the widespread use of ADSs, is lack of an effective rule scheduling approach that can be used in various hardware and software circumstances. One of the most challenges against introducing an effective rule scheduling process is the estimation of the act-ual execution times of active rules as accurate as possible ( Rasoolzadegan, 2007; Rasoolzadegan et al., 2008; Rasoolzadegan et al., 2006 ).

In this study, to improve the most effective unconstrained rule scheduling approach (E X -SJF PRO -V.2.8), a new rule scheduling approach was developed which is equipped with a learning automaton. The new approach was called E x -SJF EsTLA . The learning automaton helps E x -SJF EsTLA in improving the effectiveness of the rule scheduling process from two viewpoints: (1) estimating the actual execution time of each active rule more precisely, (2) decreasing the priority of the selection of the activated rules whose condition sections are false at the evaluation time. The time spent for the selection and evaluation of these activated rules is counted as the wasted time in the system, which decreases the effectiveness of the system. Then the effectiveness and ef the unconstrained rule scheduling approaches were evaluated in terms of fi ve evaluation criteria in a laboratory environment called ADSS. The results of the experiments show that E x -SJF EsTLA positive impact on the average response time, response time standard deviation, and throughput of an ADS and does not have any negative impact on its time overhead per transaction and CPU utilization.

In the future, we intend to improve EDF DIV and EDF SL , as the most effective constrained rule scheduling approaches, using learning automata. As mentioned in Section 3.2.1.1 , in these two approaches, the deadline assigned to each rule is dynamically altered during its life-time according to the number of the immediate and deferred rules activated due to its execution. In EDF SL , the deadline of a rule is estimated according to (1) the estimation of the execution time of the rule, (2) the number of the rules that have been activated since the start of the execution of the rule, and (3) the estimation of the number of the rules that will be activated during the remainder time of the execution of the rule. Learning automata may increase the precision of estimating the above-mentioned information. The more precise the estimation of the above-mentioned information, the more effective the rule scheduling process in the EDF-based approaches.

Moreover, considering the unsupervised nature of learning in our proposed approach, unsupervised neural networks (such as SOM and ART ( Haykin, 2007 )) would be a future work for investigating the feasibility of solving the rule scheduling problem using the mentioned neural networks.
 Appendix See Figs. 11  X  17 and Table 16 .
 References
