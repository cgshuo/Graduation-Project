 The revolution in computer systems and torrent of applications is led by growth in enabling technologies. The systems are incr easing annually for 20 years by roughly a factor of 2 (disk capacity), 1.6 (Moore X  X  Law), and 1.3 (personal networking; modem to Digital Subscriber Line (DSL)), respec tively. The cost attached to manage the complex system of today is a lot more then the actual cost of the system. Among those applications (i.e. mission-critical applications, automatic process of business policies, procedures, and business logics) time is decisive. Better representation, organization and management of business processes in agile computing have helped optimize and fine tune the processes with the help of computer systems. Moreover, as the software industry has developed rapidly in various forms and smaller life cycles of software systems, companies need to produce highly competitive applications with many features like user adaptation, customization, software reusability, timeliness, low maintenance and fault free service etc. The component oriented software engineering has stepped up and component-based software systems are growing in popularity. When software is divided into many dynamically connected components, the cost of immediate adjustment to new business processes or rearrangement of existing processes climbs high. So it is essential to develop software components that possess features of extensibility and flexibility, adapting to diverse requirements required upon each component X  X  development and maintenance. Many researchers proposed a variety of adaptation methods for software components, emphasizing on extensibility and adaptability. However the application of those solutions in a real time application decreases performance that is the motivation of our work. In order to answer this weak point, the techniques of rule-based component development are proposed. For extensibility and adaptability of components, the techniques separate business variability [1] from the component X  X  internal code by keeping separate rules. Upon the occurrence of requirement changes, a new requirement can be satisfied with changes in rules without changes in components. However, this technology usually needs some additional script language to describe rule expression, which has the limitation in expressing complex business rules. Also, this script-based rule handling is not suitable to the system that requires high performance. 
In this paper, we propose the compilation-based rule engine for performance enhancement and improving rule expression to cope with dynamic system requiring runtime adjustments. Unlike interpretation-based rule engines proposed as contemporary solutions, our rule engine does not require any additional script language for expressing rules resulting into better performance in terms of time compilation and overall performance. Moreover, the solution we propose is able to use the current existing libraries for condition/action codes of rules in legacy systems, such as string, number, and logical expression etc, so that it may not only express complex condition or action statements but also easily integrate the existing systems developed in Java language. In agile business computing environments, computing systems have become highly capricious and complex. Our rule-based automatically changeable mechanism is an appropriate solution for bringing the benefits of automatic computing, trustworthy management, consistency, and easy maintenance in rule-based systems. 
The remainder of this paper is organized as follows: In section 2 we present a scenario and functional features for better understanding. In section 3 we present the architecture of the rule engine proposed in this paper. We describe performance and compare the features of JSR-94 and the rule engine proposed in this paper in section 4. We discuss the related work in section 5 and lastly we conclude this paper along with the future work in section 6. In order to apply a changing rule to a dyna mically adjustable rule engine, it is an integral proposition that the rule engine should be adaptable to coupe up with regular updates and changes. The main procedure of our dynamically adjustable rule engine is that a rule writer composes a condition and an action part of a rule expression in Java language. The condition code and action code of a rule expression converts into condition and action object with hook method respectively and put them into an object pool. After finding a specific rule, our rule engine takes the condition and action objects specified by the rule X  X  configuration from the object pool for rule execution. Processing a sample scenario is introduced in the following subsections. 2.1 A Sample Scenario of the Dynamically Adjustable Rules Figure 1 shows the application example of customer X  X  credit rule. Suppose that there is a rule of the customer X  X  credit in import and export business domain. 
Let us consider a simple credit rule:  X  If a customer X  X  credit limit is greater than the invoice amount and the status of the invoice is  X  X npaid X , the credit limit decreases by taking off the invoice amount and the status of the invoice becomes  X  X aid X  . X  
In this scenario, the process of applying the dynamically adjustable rules can be divided into 3 phases: 1) the rule expression phase, 2) the rule initialization phase, 3) and the rule execution phase. During the rule expression phase, a rule writer writes condition and action parts of the customer X  X  credit rule using a rule editor as in figure 2. After writing the rule, the rule writer saves the customer X  X  credit rule-related information to a rule base in form of an XML file. Figure 3 shows an example of XML-based rule base for the customer X  X  credit rule. 
During the rule initialization phase, the rule engine makes Java source files from the Java codes of condition and action in figure 2, compiles them, makes instance of the classes and deploys them to the object pool. During the rule execution phase, if the rule application domain sends request event messages to the rule engine, the rule engine extracts the event identifier from the request event message. The rule engine finds the rule from a rule base by matching the event identifier. The rule engine takes condition and action objects from the object pool and invokes the hook method of the condition and action objects. In figure 2, the rule identifier is the unique name for finding the specified rule and the rule priority specifies the order of executing rules. It is also possible to use the existing libraries specified in CLASSPATH . If necessary, a rule writer can write multiple action codes for a rule. 2.2 Code Generation and Operation in the Rule Engine In order to generate condition and action classes, the rule engine uses a template method pattern. Figure 4 shows the class diagram for applying the temple method pattern to our rule engine. The name of hook method for condition and action classes are  X  Compare  X  and  X  Execute  X , respectively. Figure 5 shows condition or action codes generated automatically through the template method pattern. The condition and action objects are made from the CreditRuleCondition and the CreditRuleAction class and put into an object pool to be used fo r executing the rule. When a rule application sends request events for rule execution to the rule engine, the rule engine extracts the event identifier from the request event message. The event identifier is the string of  X  X omain name: task identifier: rule name X  . The rule engine finds the rule from a rule base by matching the event identifier. The rule matched has rule configuration, such as rule identifier, rule name, condition or action class name, and rule priority. The rule engine takes condition and action objects from the object pool and invokes the hook method of the condition and action objects. In the previous section, we studied a sample scenario with processing flow. This section introduces the architecture of the dynamically adjustable rule engine, which is operated based on compilation. Also we present flow of the initialization process in the rule engine and execution process of rules. In figure 6, we show the software architecture of the proposed rule engine. The rule engine is mainly comprised of three parts: the Admin Console, Rule Repository, and Core Modules . The Admin Console is the toolkit for the expressing and managing of rules. The Rule Repository saves the xml-based rule information expressed by the toolkit. The Core Modules are in charge of finding, paring, and executing rules. There are a number of modules in the Core Modules. The responsibility of the Rule Engine is to receive request message from a client and to execute rules. To find an appropriate rule, it sends the request message to the Rule Parser . The Rule Parser extracts the event identifier from the request message, compares it with the event identifier of a parsing table, and finds the rule. The event identifier is the string of  X  X omain name: task identifier: rule name X . After finding the rule, the Rule Engine knows the names of condition and action objects from the configuration of a rule and has the references of them from the ObjectPool Manager . 
The Rule Parser is responsible to find rules. The ObjectPool Manager manages the condition and action objects specified in rule expression. The RuleInfor Manager performs CRUD (Create, Read, Update, and Delete) action on the Rule Repository . The JavaCode Builder makes Java source files, compiles them, makes instances of the classes, and deploys them to the object pool. The Condition and Action Objects are the objects made from condition and action codes of rule expression. 
The Rule Engine is required to initialize before executing rules. In figure 7, we show the collaboration diagram to show the flow of the process for rule engine initialization. The Rule Engine sends an initialization request to the RuleInfor Manager . The RuleInfor Manager reads rule information from the Rule Repository and save it to a buffer. Recursively, the RuleInfor Manager extracts condition and action codes of rules, makes object instances, and deploys to the object pool through the ObjectPool Manager . After the Rule Engine initializes the condition and action parts of rule, it calls the Rule Parser for building a parsing table. The Rule Parser gets a pair of rule identifiers and names from the RuleInfor Manager, and builds the parsing table with them for finding appropriate rules. 
Figure 8 presents the collaboration diagram to show the flow for rule execution. A client sends request messages to the Rule Engine . The Rule Engine saves it to a buffer through the EventBuffer Manager and then gets the request message with highest priority from the EventBuffer Manager . 
The Rule Engine calls the Rule Parser for finding the rule matched with the rule identifier. The Rule Parser searches the parsing table to find appropriate rules. After finding the rule, the Rule Engine calls the ObjectPool Manager to get the condition and action objects specified in the founded rule and then calls the  X  X ompare X  hook method of the condition object. If the result of invocation of the condition object is true, the Rule Engine calls the  X  X xecute X  hook method of the action object. If a rule has many action objects, the Rule Engine calls them according to the order of the action object specified in rule expression. The rule engine also supports the forward-chaining rule execution. It allows the action of one rule to cause the condition of other rules. In this section, we show the experimental performance results of the compilation-based rule engine proposed in this paper. We use the Microsoft 2003 server for operation system, WebLogic 6.1 with SP 7 for web application server, and Oracle 9i for relational database. As for load generation, WebBench 5.0 tool is employed. TPS (Transactions per Seconds) and execution time are used for the metric of performance measurement. For performance comparison in J2EE environment, we use a servlet object as a client of the rule engine. 4.1 Experimental Environment Before showing the performance results, we introduce the workloads that were used in the experiments. Generally, business rules are classified into business process rules and business domain rules. Business domain rules define the characteristics of variability and the variability methods which analyzes these characteristics for an object. Business process rules define the occupation type, sequence, and processing condition, which is necessary to process an operation. In the business process rule, the variability regulations for process flows are defined as the business process rules. Table 1 shows the workload configuration for experiments. Among the five rules, two rules are the business process rules and the other two rules are the business domain rules. In an e-business environment, as the business domain rules are more freq-uently used than the business process rules, we give more weight to the business domain rules. 
The  X  Customer Age  X  rule measures a customer X  X  age is according to problem request. The  X  Interest Calculation  X  rule calculates interest according to the interest rates. The  X  Role Checking  X  rule specifies the assertion of the  X  X n authorized user can access certain resources. X  The rule engine takes role information from the profiles of the customer and decides whether the requesting jobs are accepted or not. 4.2 Performance Comparison The performance of the proposed rule engine is compared with Java Rule Engine API (JSR-94) in figure 9. The proposed rule engine achieved 395 transactions per second (TPS) in maximum workload. While JSR-94 achieved 150 TPS in maximum. The proposed rule engine in this paper processes 245 more transactions per second than JSR-94. We believe that the rule engine proposed achieved 2.5 times better performance than JSR 94 because of its special emphasis on features like ease in order to compare performances of sub-modules of the rule engine, Figure 10 shows load analysis of two rule engines. Since the proposed rule engine operates on compilation-based rule processing, performance in the module of generating objects may take a long execution time, but there is not a big different in performance. Moreover, the proposed rule engine achieves better performance results in parsing and executing rules. It is because it divides the condition and action class into separate parts which gives ease at run time when rules are called in an object pool. . Moreover one does not have to define separate condition statement for multiple actions the proposed rule engines provides the facility of defining more than one executions for one condition which can help in fault tolerance in a hybrid environment. 4.3 Feature Comparison In table 2, we compare the features of the two rule engines. In contrast to JSR-94, the proposed rule engine expresses each business rule by a business task unit. If there are one or more rules in a task, each rule is categorized in a unique rule name. 
The proposed rule engine uses Java language for writing business rules without using any additional script languages for expressing rules. Although it might seem odd to assume that we assume that the user must have knowledge of java la nguage we foresee that the business rules, when converted into Java language, eliminates the fuzziness and brings clarity to the conditions and actions. Moreover syntax of java is the same everywhere in the world so it would be easier to embed the proposed rule engine into applications facing diverse environment. However, we aim to build a GUI based front end the rule engine proposed in this paper as future work. 
Whenever executing each business rule in the proposed rule engine, the step for matching rule conditions is not required. In other words, after finding the required business rule from a rule base, the proposed rule engine executes it without parsing the rule and matching the rule conditions due to Java-based rule expression. The proposed rule engine converts the condition and action codes of a rule into condition and action objects, respectively and puts it into an object pool for improving performance and dynamic changeability. Thus, it can execute the newly changing business rule without restarting itself. The Business Rules Group [2] defines a business rule as  X  a statement that defines and constraints some aspects of business  X . It is intended to assert business structure or to control or influence the behavior of the business. The Object Management Group (OMG) is working on Business Rules Semantics [3]. Nevertheless, several classifications of different rule types have emerged [2, 4, 5]. In [4], business rules are classified into four different types, such as integrity rules, derivation rules, reaction rules, and demonic assignments. A well-known algorithm for matching rule conditions is RETE [6]. For business rule expression, rule markup language is needed. Currently, BRML (Business Rule Markup Language) [7], Rule Markup Language (RuleML) [8], and Semantic Web Rule Language (SWRL) [9] are proposed as rule markup languages. The IBM took initiative of developing Business Rule Markup Language (BRML) for the Electronic Commerce Project [7]. The BRML is an XML encoding which represents a broad subset of KIF. The Simple Rule Markup Language (SRML) [10] is a generic rule language consisting of a subset of language constructs common to the popular forward-chaining rule engines. Another rule markup approach is the Semantic Web Rule Language (SWRL), a member submission to the W3C. It is a combination of OWL DL an OWL Lite sublanguages of the OWL Web Ontology language [9]. The SWRL includes an abstract syntax for Horn-like rules in both of its sublanguages. Most recently, the Java Community Process finished the final version of their Java Rule Engine API. The JSR-094 (Java Specification Request) was developed in November 2000 to define a runtime API for different rule engines for the Java platform. The API prescribes a set of fundamental rule engine operations based on the assumption that clients need to be able to execute a basic multiple-step rule engine cycle (parsing the rules, addi ng objects to an engine, firing rules, and The Java Rule API is already supported (at least partially) by a number of rule engine vendors (cf. Drools [12], ILOG [13] or JESS [14]) to support interoperability. As business applications become complex and changeable, rule-based mechanism is needed for automatic adaptive computi ng as well as trustworthy and easy maintenance. For this purpose, we propose a compilation-based rule engine that can easily express business rules in Java codes. It does not need additional script language for expressing rules. It can create and execute condition and action objects at run time. Moreover, it can use existing libraries for condition or action codes of rules (i.e., String, Number, and Logical Expression) so that it can not only express complex condition or action statements but also easily integrate the existing systems developed in Java. So the compilation-based rule engine, proposed in this paper, shows better performance than JSR-94, a generally used interpretation-based rule engine. According to our experiments, the proposed rule engine processes 245 more transactions per second than JSR-94. We intend to test the performance of the rule engine proposed in this research with different weights and in different conditions. This will not only gives us a better idea about the working capacity of the outcome of this research, it will give clear application of are for this rule engine too. Moreover we intend to develop a GUI that could assist the users who have limited knowledge of java in operating with this rule engine. 
