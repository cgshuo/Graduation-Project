 Given a set of client locations, a set of facility locations where each facility has a service capacity, and the assump-tions that: (i) a client seeks service from its nearest facil-ity; (ii) a facility provides service to clients in the order of their proximity, we study the problem of selecting all pos-sible locations such that setting up a new facility with a given capacity at these locations will maximize the num-ber of served clients. This problem has wide applications in practice, such as setting up new distribution centers for on-line sales business and building additional base stations for mobile subscribers. We formulate the problem as location selection query for utility maximization . After applying three pruning rules to a baseline solution,we obtain an effi-cient algorithm to answer the query. Extensive experiments confirm the efficiency of our proposed algorithm.
 H.2.8 [ Database Management ]: Database Applications X  Spatial databases and GIS Algorithms, Performance, Theory Location Selection, Capacity Constraints
A common problem in operation management is to select optimal locations to build facilities. The choice is based on factors such as the gain on profits and improvement on service quality. Let us consider an example in online sales business. To ensure quick shipment, customers are served by their nearest distribution centers. In Fig.1 rectangles represent the distribution centers. Every distribution center has a capacity that indicates the number of customers it can serve. When the number of customers exceeds its capacity, the distribution center only serves the customers in the order of their proximity. Hence, there may be unserved customers. In the figure, the capacities of distribution centers f 1 and f 3 are 3, 4, and 5, respectively. Circles and black dots indicate the served and unserved customers, respectively. The customer c 4 is unserved since its nearest distribution center f 1 only has a capacity of 3, which has been used up by c 1 , c 2 , c 3 since they are nearer to f 1 than c 4 . Assume that we want to build a new distribution center with a capacity of 4. Setting it up in any region in the set { R 1 , R 2 , R will serve 4 more customers, which reaches its full capacity. This is the highest utility that can be achieved. Therefore, { R 1 , R 2 , R 3 , R 4 , R 5 } is the answer to this query.
We assume that a facility only serves clients who perceive it as their nearest facility and it serves clients to its capacity in an ascending order of the distances to them.
 Definition 1. In a 2-dimensional data space S , let F de-note the facility set containing locations of existing facilities f , C denote the client set containing locations of clients c , v ( f ) denote the capacity of a facility f , and SE ( C, F ) denote the number of served clients. Given the capacity v ( f n ) of a new facility f n , the location selection query for utility maximization returns a set M of regions which contains all regions such that if f n is set up in any of them, the number of newly served clients (utility of the new facility), denoted as u ( R ) = SE ( C, F  X  { f n } )  X  SE ( C, F ) , is maximized.
Practically, a client may require multiple units of service, which can be considered as the weight of the client. In this general setting, we still follow the serving order rule. The f n may contribute to increasing u ( R ) in two ways: (i) to directly serve unserved clients; (ii) to share the balance of overloaded facilities by serving already served clients, so that they have the capacity to serve unserved clients. In Fig.1, if f n is set up in R 1 or R 5 , it directly serves 4 unserved clients. If f n is located in R 2 , c 7 is taken over by f n , then f to serve unserved c 9 . Meanwhile, f n directly serves unserved c , c 6 and c 8 . The number of newly served clients is also 4. Similar cases happen when f n is located in R 3 or R 4 . The optimization goal is global, considering only unserved clients is not enough in solving our problem.

In this paper, we make following contributions: (i) A new type of query, named location selection query for utility maximization , is proposed; (ii) Arc based methods are in-troduced to describe and validate regions; (iii) An efficient algorithm to answer the query is obtained via applying three pruning rules to a straightforward solution; (iv) Extensive experiments are conducted. The results confirm the effi-ciency of the proposed algorithm.
Our problem is based on b ichromatic r erverse n earest n eighbor (BRNN) query introduced by Korn et al. [3]. For the situation where database is updated frequently, a two-stage approximate Voronoi diagram algorithm is proposed to efficiently answer the query [5]. Recent progress on im-proving the efficiency of computing RNN can be found in many studies [12, 1].

Some distance based location selection queries aim at op-timizing distance functions. Minimizing the average dis-tance between clients and facilities by locating a new facility is studied [14, 4]. Finding the optimal matching between clients and facilities under capacity constraints is also tack-led [11, 8, 7]. All above studies concentrate on optimizing distance functions or matching applications, thus the solu-tions are inapplicable to our problem. Some influence based queries define the number of RNN of a facility as its influ-ence. Xia et al.[13] find locations with maximal influence in a given query region. Wong et al.[10] extend similar work to L -norm space of two and three dimensionality [9]. Huang et al.[2] find those locations among a candidate set. However, no capacity constraints are considered.
Assume that every client has only one nearest facility [6, 15]. Given a client c , the nearest facility circle (NFC) [3] of c , denoted as n ( c ), is a circle that centers at c and has a radius of dist ( c, f ), where f is the nearest facility of c and dist ( c, f ) is the Euclidean distance between c and f . We denote the set of all the points within n ( c ) as  X  c and the set of all the points outside as  X  c . The points right on n ( c ) cannot be answers to the query on the above assumption. Definition 2 (consistent region). A consistent region R is a set of points satisfying that: 1)  X  c  X  C,  X  p i , p Definition 3 (maximal region). A consistent region R is a maximal region if  X  R  X   X  R 6 =  X  , then R  X   X  R .
For example, in Fig.1, the set of all points in R 4 is a consistent region, while set { c 10 , c 11 } is not. According to the definition, two different maximal regions cannot overlap . Because once they overlap, they share at least one point, thus they are subsets of each other. They are therefore the same region. Fig.2(b) shows an example of four maximal regions  X  c 1  X   X  c 2 ,  X  c 1  X   X  c 2 ,  X  c 1  X   X  c 2 two overlapped NFCs. Note that a maximal region does not have to be a connected region. Fig.2(c) shows an example.
Let B ( f ) denote the BRNN set of a facility f , which con-tains the clients whose nearest facility is f . Similarly, B ( p ) denotes the BRNN set of a point p . The following two lem-mas show the one-to-one relationship between a maximal region and a BRNN set.
 Lemma 1.  X  p i , p j in a region R , we have B ( p i ) = B ( p Lemma 2.  X  p i , p j , if B ( p i ) = B ( p j ) , then p i the same maximal region.

Thus a maximal region can be represented by a BRNN set. Points in the corresponding maximal region of a BRNN set must satisfy: (1) lying within the NFCs of all clients in the BRNN set; and (2) locating outside of the NFC of any other client not in the set. Actually, the data space is parti-tioned into many maximal regions by the NFCs of all clients. Hence, we are able to describe a maximal region by using  X  c or  X  c . Formally, given a BRNN set B ( p ), the corresponding maximal region is R = ( T c possible to get all maximal regions through all combinations of clients. For | C | clients in C , there are totally 2 | C | ble BRNN sets can be enumerated. Some enumerations may have no corresponding maximal regions (or in other words the corresponding regions are empty sets). For example, in Fig.2(c), the region  X  c 1  X  c 2  X  c 3 for the enumerated BRNN set { c 2 , c 3 } actually does not exist. Techniques on checking the validation of an enumerated BRNN set will be discussed in the next section.

When adding a new facility f n with a given capacity in a region, we can get the total weight of newly served clients according to the corresponding B ( f n ) [6]. This total weight is the facility utility. So to get the highest utility, we can use maximal regions as basic units to search the whole space. A maximal region is enclosed by arcs generated from some NFCs intersecting with each other. Given an enumerated BRNN set, we need to validate it and find its corresponding maximal region. In our problem the containment relation-ship between NFCs is impossible [10], only the intersection and separation relationship need to be considered.
We adopt an incremental way of checking. During the validating process, a temporary maximal region R is incre-mentally maintained. When a new client c is involved for checking, based on the geographic relationship between n ( c ) and R , the temporary maximal region is updated. Checking one client after another, if R becomes an empty set, then the enumeration is invalid. However, if R is not empty after the checking process, we are sure that it is valid, and the current temporary maximal region R is its corresponding maximal region.

When checking a new client c , we need to update the arcs enclosing R . Given an NFC, a point has three states in terms of their positional relationship: in , on , and out . According to the states of the two end points of an arc, to a given NFC, there are 12 cases of the location relationship between them. We show all the 12 cases in Fig.2(a). For all the cases, we update those enclosing arcs accordingly. If it is  X  c , then we keep the inside part of the arc, else the outside part is kept. In addition, new enclosing arcs are generated when n ( c ) intersects with R . The new NFC is partitioned into a number of arcs by the intersect points between n ( c ) and the existing arcs. For each arc, we only need to check its middle point. If its middle point is in R , it is a new enclosing arc. Otherwise it is not. When finishing the updating and insertion of arcs, the temporary maximal region becomes a new one.

We use an example in Fig.2(b)(c) to illustrate the validat-ing process. In this example, we need to validate  X  c 1  X  c the temporary maximal region be R =  X  c 1  X  c 2 , whose enclos-ing arcs are a 1 and a 2 . When checking c 3 , both a 1 and a are updated according to case 12, leading to 4 smaller arcs remained. Finally, two new arcs a 3 and a 4 from the new NFC are added, which causes the two shadowed regions to be the maximal region of  X  c 1  X  c 2  X  c 3 .
A straightforward solution is to enumerate all combina-tions of clients, validate each enumeration, compute the in-crement of its corresponding BRNN set [6] and get the util-ity. Since a meaningful result serves at least one client, we can therefore get all possible cases by enumerating maximal regions within one NFC, then another. To enumerate within one NFC, we only need to consider those NFCs that inter-sect with it. To avoid repetitions, we assign each NFC an unique ID so that they can be scanned in order.

An example is shown in Fig.2(d). There are six NFCs and we assign each an unique ID. We start from the NFC with the smallest ID 1. Since 1 only intersects with 2 and 3. Then, all BRNN sets we will enumerate for the NFC 1 are 123  X  4  X  5  X  6 , 12  X  3  X  4  X  5  X  6 , 1  X  23  X  4  X  5  X  6 and 1 2, it intersects with 1 , 3 , 4, since 1 is smaller than 2, thus we will only enumerate  X  1234  X  5  X  6 ,  X  1  X  23  X  4  X  5  X  6 , this way, the maximal region that lies in both 1 and 2, i.e. 123  X  4  X  5  X  6, will not be repeated.
Though the baseline algorithm can avoid a large percent-age of enumerations, it is still not efficient. We propose three pruning rules to speedup the search process. (I) In each step of the baseline algorithm, the maximal regions within an NFC n ( c ) are checked. We can treat n ( c ) as the root of this search step. Given an NFC n ( c ), we denote the set of clients whose NFC intersects with n ( c ) and having a larger ID than c as C e ( c ). Baseline algorithm enumerates all combinations of clients in C e ( c ). However, before enumerating, we can estimate the upper bound utility of all maximal regions within n ( c ), denoted as u ( c ), it helps us determine whether the n ( c ) is worth exploring or not.
For presenting convenience, we give some relevant defini-tions used here. Given a facility f , its work load denoted by wl ( f ), is the total weight of all clients in its BRNN set. The max increment of a facility f , denoted by inc ( f ) equals to denote the weight of c . Given a client c and its nearest fa-cility f , the increment of c , denoted by inc ( c ) equals to (1)
With all clients in C e ( c ), we have u ( c ) = min { v ( f P weight of newly served clients. This is only an ideal case, for it does not consider the serving order and dynamic updates of the increments of existing facilities. With the estimated upper bound, we can effectively prune the search space. (II) Besides pruning at the branch root, unnecessary search can also be avoided at lower levels. For every f , the best case is the f n shares exactly inc ( f ) of its work load. If the input capacity v ( f n ) equals to the total weight of unserved clients and there exists a region that can make them all served, then f n must share inc ( f ) workload of every existing facility. For example, in Fig.2(e), the number inside each n ( c ) denotes the weight of c , the capacity of f 1 and f 2 is respectively 2 and 5, and the dashed NFCs denote unserved clients. The shadowed region can make all unserved clients fully served if we add f n with a capacity v ( f n ) = 10  X  7 = 3 in it. The shared workload of f 1 and f 2 is exactly 2 and 1, respectively.
In this case, any other region that shares more than the max increment of any facility will not be a result. In more general situations, such a region may not exist, but we can record the current highest utility u h , which is not more than v ( f n ). Given the input capacity v ( f n ), for any existing fa-cility f , a promising maximal region shares not more than inc ( f ) + v ( f n )  X  u h workload of f . Otherwise, with less remained, even this part can be fully utilized, the final util-ity is less than inc ( f ) + ( u h  X  inc ( f )) = u h . To sum up, when enumerating all combinations of clients in C e ( c ), we can use the maximal workload that a facility can be shared as an upper bound to prune unpromising branches. (III) The baseline algorithm checks whether a maximal region exists only when it gets a possible combination of all clients in C e ( c ). However, we can check the exitance of the temporary maximal region at a higher level. If the temporary maximal region corresponding to a subset of an enumeration does not exist, then there is no need to enu-merate remained clients. Based on the above pruning rules, we propose the our solution in Algorithm 1.
 Algorithm 1: Pruning Algorithm (a) Arc NFC relationship a f  X  c  X  c
We implemented all algorithms using C++. All experi-ments are conducted on a 64-bit Windows machine with an Inter(R) Core(TM)2 1.86GHz CPU and 7.00GB memory.
 Because it is possible to read all locations into the main memory, we only include the running time as the indica-tor of performance. Both real world datasets and synthetic datasets are used. Two real world datasets NE and NA are downloaded from http://www.rtreeportal.org/spatial.html. In NE there are 123,593 addresses of north east of USA and in NA there are 24,493 locations of North America. When using NE or NA, we uniformly sample from it to generate C and F . We also generate C and F with Zipfian distri-bution. The proposed algorithms take different weights of client points into account . Yet through the experiments, we find the weight of clients has little impact on the comparison on performance. We therefore set the weights of all clients as one (although in real applications, it may be a large value) in our study. We use kd-tree to answer the nearest neighbor query and R*-tree to answer the range query.

Before conducting experiments, we analyze three datasets specifically on the clients density because the number of in-tersections determines the search space of our problem. The results are shown in Table 1. For example, in NE, when | C | / | F | is set to 20, in average an NFC will intersect ap-proximately 54 other NFCs, which is the highest among all used datasets. So the number of actual regions produced by NFCs is dramatically smaller than that in the worst case, where each NFC intersects all other NFCs.

In the following subsections, we study the performance of the baseline ( basic ), baseline with first ( 1-p ), second ( 2-p ), third ( 3-p ) pruning rule and the pruning algorithm ( all-p ) which features all three pruning rules.
We study the clients density effect by varying | C | / | F | from 1 to 20. Fig.3(a)(b)(c) show the performance of the base-line on datasets with | C | / | F | bigger than 2 is unacceptable and thus omitted. Both 1-p and 2-p have marginally advan-tages over the baseline, yet they fail to provide competitive performance when | C | / | F | is more than 5. 3-p alone gives acceptable performance as its cost of time grows smoothly towards the growth of | C | / | F | , outperforming others by or-ders of magnitude when the varying ratio becomes larger. The pruning algorithm is always the best one among all al-gorithms, with marginal advantages over 3-p. Overall, this set of experiments verifies the effectiveness of pruning rules.
Then, we study the impact of the cardinality of datasets on the performance of algorithms. Considering that the baseline algorithm does not scale to large | C | / | F | , we set | C | / | F | to 2 in following experiments. The input capacity is also set to | C | / | F | . The result is shown in Fig.3(d)(e)(f).
From the figures, we observe that on all datasets the re-sults are similar. Baseline algorithm provides the worst per-formance while 1-p and 2-p perform marginally better. Both 3-p and the pruning algorithm give magnitude better per-formance especially when datasets grow, with the pruning algorithm outperforming 3-p in almost one order of magni-tude. In terms of growth trend, it is also 3-p and the pruning algorithm that give the slowest increase rate. We also find that when the datasets are really small, such as | C | = 20, all algorithms with pruning rules might be beaten by the base-line algorithm. This is simply because in this condition, the cost of pruning itself overweights the gain on performance it earns from tightening the search space. Yet in practical applications, such tiny datasets are of less interests.
Note that there are some inflection points in the results, e.g., | C | = 500 for Fig.3(f). This is because the distribution of facilities in different samples of a dataset may vary sig-nificantly, which may cause the maximal number of NFCs intersecting with an NFC varies in different samples.
We study the impacts of existing capacities, input capac-ity and dataset size on the pruning algorithm, respectively. For existing capacities, we uniformly sample 5412 (2194) and 52992 (22299) points from NE (NA) as facilities and clients. We also generate 10K and 100K points as facilities and clients. We adjust the expectation of the existing capac-ities from 10 to 30, i.e., 1 to 3 times of | C | / | F | . As shown in Fig.3(g), the larger the existing capacities, the better per-formance of the algorithm. This is because larger capacities result in less clients being unserved, which makes the first and second pruning techniques work more effectively.
To investigate the impact of the input capacity v ( f n ), We fix the number of facilities and clients at 0.4K and 4K, and vary v ( f n ) from 30 to 170. The result in Fig.3(h) shows that when the input capacity is relative small, it costs less time to answer the query. However, when it becomes large enough, the performance almost does not change. The reason is the smaller v ( f n ) is, the more effective the second pruning tech-niques will be, for it uses the input capacity as an indicator to reduce the search space.
 Finally, we study the scalability of the pruning algorithm. We use the real-world dataset NE by testing it from a 25% sampling to the original size. We also generate 20K facili-ties and 200K clients as synthetic dataset. Fig.4 shows when the cardinality of datasets climbs rapidly, the cost of compu-tation increases gradually, which suggests the pruning algo-rithm can be a valid option for solving the proposed location selection query in real-world applications.
Location selection queries have attracted much attention due to their wide applications in real world. Since service-providing facilities are constrained by their capabilities, there may be unserved clients in a booming market. In this pa-per, we study on selecting all the regions in a data space such that if a new facility of a given capacity is added in any location in these regions, its capacity will be best uti-lized. Through introducing the concept of maximal regions and the methods of validating them, we proposed a baseline algorithm to solve the problem. To improve its efficiency, we proposed three pruning rules to tighten the search space. With all these three rules, we proposed an efficient pruning algorithm. Extensive experimental results show that the pruning algorithm outperforms the baseline in terms of run-ning time by up to three orders of magnitude and it can be a valid option to answer the proposed query.

Further work may involve proposing worst case bounded approximate algorithms with much less cost of computa-tion. Another interesting track would be considering moving clients instead of assuming that all clients are static. This work is partially supported by NSFC under the grant No. 61003085 and 61170010
