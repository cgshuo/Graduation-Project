 1. Introduction the source information to be mapped to the format expected by the application. de fi reasoners [10  X  12] that implement DL algorithms [13,14] . amount of changes in the initial architecture of CLIPS.
  X  knowledge, based on the inferencing capabilities of DL reasoners [10  X  capabilities without interfacing physically the DL reasoner. heterogeneous environments. An example of such an application domain, in which CLIPS symptoms.
 present an example of a rule-based application that uses the results of CLIPS work and we conclude, respectively. 2. Background and motivation 2.1. The Web Ontology Language
The Web Ontology Language (OWL) is the W3C recommendation for de
The modeling in OWL is performed using concepts, properties and instances. The oriented nature of OWL accounts for a great degree of expressiveness during concept de semantics relevant to sets, such as intersection.
 acteristic, such as symmetric, transitive, inverse and others. (class subsumption), as well as, based on the complex class constructors that are de and property restrictions.

Furthermore, two or more instances in OWL may be de fi ned as identical ( refer to the same resource. 2.2. OWL DL reasoning  X  ontology. The reasoner also checks the ontology for inconsistencies.  X  instances belong and the instance property values. 2.3. The CLIPS production rule engine and the COOL language integrates the production rule paradigm with the OO model, which can be de to be altered on rules actions (RHS).
 current data are triggered and placed in the con fl ict set. The con 2.3.1. COOL syntax and semantics
The COOL language of CLIPS provides the necessary constructs in order to de data model, that is, the objects and their attribute values. 2.3.1.1. Classes and attributes. TheclassesinCOOLareregardedastypesofobjectsandmayde called multislots . For each attribute, a number of constraints may be de basic syntax for de fi ning classes in COOL is shown below. (defclass b name N
A class is de fi ned by specifying the name, one or more superclasses, constraints. We will be interested in the type, allowed-classes, allowed-values objects that an attribute can take, using the INSTANCE-NAME restricted to a speci fi c set of values, for example { yes no attribute. As an example, we present the de fi nition of the classes of the class Human . (defclass Human (defclass Man the attributes that are inherited from the superclasses.
 value, using the following syntax: (make-instance [ b name N ]of b class N
For example, an object of the class Man above is de fi ned as it follows: (make-instance [ george] of Man In that way, [ george ] is an object of the classes Man and 2.4. Approaches for using ontologies with rules in rule engines. More details can be found in the surveys [19 2.4.1. Interfacing external ontology reasoners with rule engines ontology reasoner to the rule engine and thus, the ontology knowledge remains unmodi 2.4.2. Mapping ontology reasoners on the data model of rule engines since all the ontological knowledge exists in its KB. 2.4.3. Strong coupling of ontologies and rules 2.5. CLIPS  X  OWL: the basic idea in Table 1 that de fi nes the class Department , the class with domain and range restrictions the classes Chair and Department belongs to the class Department and the instance nick of the class
By using a DL reasoner, it can be inferred that the instance object nick should return both the classes Chair and Professor
COOL model that CLIPS  X  OWL generates for the example. (defclass Department (is-a owl:Thing)) (defclass Professor (is-a owl:Thing)) (defclass Chair (is-a Professor) (make-instance [ csd] of Department) (make-instance [ nick] of Chair (isHeadOf [ csd] ))
In the following, we elaborate on some of the main characteristics of CLIPS 2.5.1. Powerful rule-based applications ontologies. We consider this capability quite challenging, since CLIPS is a highly ef based applications using traditional production rule engine features (con modules and many others). 2.5.2. Practical implementation forward the development of rule-based applications that use ontological knowledge. complex task compared to a rule engine that has been developed for this speci infrastructure of CLIPS, resulting in a completely different architecture with unspeci away decades of development on the ef fi cient and robust RETE-based CLIPS rule engine. 3. CLIPS  X  OWL transformation functions
Before de fi ning the transformation procedure, it is important to clarify the way CLIPS the multiple instance concept memberships. 3.1. Concept equivalence
COOL, since subclass cycles are not allowed. To overcome this restriction, CLIPS the COOL model, (b) the non-delegator concepts are de fi ned as subclasses of (indirect) objects, as well.
 same results, as the equivalent semantics of OWL impose for the corresponding concepts. 3.2. Multiple instance concept membership instance concept membership to an object class type declaration is impossible.
To overcome this limitation, the transformation procedure of CLIPS 3.3. Transformation procedure CLIPS  X  OWL.
 In the rest of the discussion, we represent the TBox results as a tuple of the form where CN R is the set with the named ontology concepts, PN relationships 3 between the concepts (represented with the symbol OBJ R and DAT R are de fi ned as follows. 4 Regarding the ABox results, they are represented as a tuple of the form where IN R is the set with the names (IDs) of the ontology individuals, I is the set with the object property values of instances and DatV and DatV R are de fi ned as follows. 5
The COOL schema is represented as a set of tuples of the form superclasses of c (represented using the notation  X  o ) and P
The COOL objects are represented as a set of tuples of the form set of the slot values tuples of i of the form  X  p , v  X  . More speci
The function f sch transforms the TBox results into a COOL schema of class de f
The transformation procedure involves two phases: 3.3.1. Delegator management The premapping phase starts by assigning delegators based on the function f where TBox D  X   X  CN D , H D , PN D , DOM D , OBJ D , DAT D CN = CN R , PN D = PN R and DAT D = DAT R .
 More speci fi cally,
The delegator concept y of x is the fi rst element of the sorted collection concept set. If x does not have equivalent concepts, then it is the delegator of itself. way, the H D set is de fi ned as delegators. Therefore, the DOM D and OBJ D sets are de fi 3.3.2. Multiple domain/range restrictions restrictions, the property value should belong to all the range concepts.
The transformation function f M where TBox M  X   X  CN M , H M , PN M , DOM M , OBJ M , DAT M therefore, PN M = PN D and DAT M = DAT D .
 domain(s):
Based on the DOM MC set, the set DOM M of TBox M is de fi concept. More speci fi cally, are hierarchically related exist in C , only the most speci is, all properties have single domain restrictions in DOM The same rational holds for the OBJ M set, which is based on the set OBJ property and MC is the set with its range(s).

It should be noted that  X  ( x , y )  X  OBJ M ,  X  ( x , z ), y Due to the system generated concepts, the sets CN M and H restrictions: 3.3.3. Instance management The instance concept memberships should refer only to delegator concepts. The function f where generating a tuple ABox D  X   X  IN D , I D , ObjV D , DatV D reference to a non-delegator concept in I R is substituted with its delegator, that is de fi ned as This function generates a tuple ABox M  X   X  IN M , I M , ObjV procedure similar to Section 3.3.2 . More speci fi cally, the set I instance and MC is the set of its concept memberships.
 case the instance have more than one concept memberships, that is, | MC | the single concept membership.

It should be noted that  X  ( x , y )  X  I M ,  X  ( x , z ), y function f M 3.3.4. Mapping phase The mapping of the TBox M tuple on the COOL sch set is performed by the function f
COOL sch is a set that contains tuples of the form  X  c , S More speci fi cally, every class c in COOL exists in the set CN slot type de fi nitions of c are determined based on the DOM The mapping of the ABox M tuple on the COOL data set is performed by the function f
COOL data is a set that contains tuples of the form  X  i , c More speci fi cally, every instance i in COOL exists in the set IN property values of i are determined based on the sets ObjV schema and objects consist of two function compositions of the form. t each tuple  X  i , c i , PV i  X   X  COOL data ,a make-instance v  X   X  PV i , the value v is inserted into the slot p (Procedure 1). 4. Using CLIPS  X  OWL for developing a production rule program develop a production rule program in CLIPS that derives facts of the form ( the following relationships: u1. A FullProfessor is also a FacultyMember u2. A NonTeachingFullPRofessor is a FullProfessor that does not teaches a course u3. The instance set of the concept Course is the union of the instances of the concepts u4. The concepts AdvancedCourse and BasicCourse are disjoint u5. mary is a FullProfessor and teaches only advanced courses. u6. paul is a Student u7. john is a FullProfessor u8. ai (arti fi cial intelligence) is an AdvancedCourse u9. kr (knowledge representation) is a Topic u10. lp (logic programming) is a Topic u11. john teaches ai 4.1. Transforming the ontology example By applying a DL reasoner on the ontology example, we have for the TBox For the ABox R results, we have that membership relationships. Therefore, TBox R = TBox M and ABox The COOL data set is de fi ned as
By applying the code generator procedure using the COOL sch (defclass owl:Thing (is-a USER) (defclass FacultyMember (is-a owl:Thing)) (defclass Course (is-a owl:Thing)) (defclass AdvancedCourse (is-a Course)) (defclass NonTeachingFullProfessor (is-a owl:Thing)) (defclass FullProfessor (is-a FacultyMember)) (defclass Topic (is-a owl:Thing)) (defclass Student (is-a owl:Thing)) (defclass BasicCourse (is-a Course)) (make-instance [ ai] of AdvancedCourse) (make-instance [ lp] of Topic) (make-instance [ john] of FullProfessor (teaches [ ai])) (make-instance [ paul] of Student) (make-instance [ kr] of Topic) (make-instance [ mary] of FullProfessor) of CLIPS production rules. 4.2. CLIPS production rules =
N . The conditions can match both facts and objects, whereas the actions de all the conditions. The facts consist of a symbol followed by a sequence of zero or more openingparenthesis onthe leftand a closingparenthesis onthe right. The the remaining fi elds in theordered fact, for example, ( father-ofjackbill (defrule test-rule1 = N b object-pattern N ::= (object b attribute-constraint N *) b attribute-constraint N ::= (is-a b constraint N )| prints all the objects of the class Person is presented below. (defrule test-rule2 = N 4.3. Example rule program
For the example rule program, we use the following facts and rules in CLIPS: (mayDoThesis ?x ?y)  X  Student "?x" can do a thesis with professor "?y" (curr ?x ?y)  X  Student "?x" has topic "?y" in his/her curriculum (expert ?x ?y)  X  Professor "?x" is an expert on topic "?"y (exam ?x ?y)  X  Student "?x" passed the exam on topic "?y" (subject ?x ?y)  X  Course "?"x covers topic "?y"  X  (defrule mayDoThesis = N (defrule curr = N
More speci fi cally, the curr rule asserts a fact (curr ?x ?z) mayDoThesis rule asserts a fact (mayDoThesis ?x ?y) if ?x member that teaches at least one advanced course. By loading the facts (subject [ ai] [ kr]), (subject [ ai] [ lp]), (expert [ mary] [ lp]), (expert [ john] [ kr]), (exam [ paul] [ ai]), and running the production rules, we result in the addition of the fact speci fi cally, the curr rule is activated and asserts the facts mayDoThesis rule is activated, since fact (expert [ john] [ kr]) values.Forexample,the maydothesis rulematchesobjectsoftheclass using multi fi eld wildcards that produce every possible match combination. 4.4. Memory consumption and rule activation time
UOBM-1) after Pellet DL reasoning. The COOL model was generated by the CLIPS Person who like at least one similar thing to the head of the (defrule query11-fact = N (defrule query11-cool = N resource in a single object de fi nition. 5. Related work
Therefore, OntoJava is not able to perform, for example, sophisticated instance classi
In CLIPS-OWL, a richer mapping of OWL semantics on the COOL model is de semantics.
 ontology reasoner should be used, as CLIPS  X  OWL does with the use of a DL reasoner. scenarios compared to ours.
 approach does not actually transform OWL into the OO model, but it rather de since we use the COOL model only as query infrastructure in CLIPS and not as an API. OWL that de fi nes a mapping to the COOL language.
 mapping and the generated OO model are different from the corresponding ones of CLIPS are derived directly from the DL reasoner. For example, O-DEVICE requires the de limited OWL entailment rule set, such as O-DEVICE follows.
Jena model. This is an one-time-mapping approach, just like CLIPS mapping the ontologies.
 ef fi query models. 6. Conclusions and future work the suitability depends on the application domain and user requirements. that allows the existence of a Java OO model (beans). CLIPS represent software project management knowledge. We plan also to use CLIPS Appendix A. Complete mapping example depicted in Table 6 and refers to the university domain. More speci a 1. A chair is also a professor a 2. A person who is the head of a department is also a chair a 3. A person is a man or a woman a 4. All persons are individuals and vice versa a 5. A department is also an organization a 6. All organizations are institutes and vice versa a 7. The domain of the property isHeadOf is the concept Individual a 8. The domain of the property isHeadOf is the concept Professor a 9. The range of the property isHeadOf is the concept Organization a 10. The instance csd belongs to the Department concept a 11. The instance nick belongs to the Person concept a 12. nick is the head of the computer science department Appendix A.1. Reasoning results After the DL reasoning procedure, we have the following TBox Regarding the ABox R results, we have the following.
 Appendix A.2. De fi ning the delegators In our example, there are two equivalent concept sets among named classes: {
Institute }. Assuming that the concepts Individual and Institute de fi ned as as delegators. The sets DOM D and OBJ D are de fi ned as follows. Appendix A.3. Multiple domain/range restrictions The isHeadOf property has two domain restrictions and therefore as subclass of the two concepts that will be added to the CN follows.
 Appendix A.4. Instance management In order to handle the multiple instance concept memberships, the set I The csd instance belongs to the Department and Institute concepts. However, H new concept. Similarly, Chair is subclass of Individual and concept. The I M set is de fi ned as Appendix A.5. Mapping phase
Based on the CN M , H M , DOM M , OBJ M and DAT M  X  X  X  sets, the COOL
Based on the IN M , I M , ObjV M and DatV M  X  sets, the COOL
Based on the codeGenerator procedure and the COOL sch , COOL (defclass owl:Thing (is-a USER)) (defclass Person (is-a owl:Thing)) (defclass Professor (is-a owl:Thing)) (defclass Organization (is-a owl:Thing)) (defclass Individual (is-a Person)) (defclass Institute (is-a Organization)) (defclass Man (is-a Individual)) (defclass Woman (is-a Individual)) (defclass IndividualProfessor (is-a Individual Professor) (defclass Chair (is-a IndividualProfessor)) (defclass Department (is-a Institute)) (make-instance [csd] of Department) (make-instance [nick] of Chair (isHeadOf [ csd])) Appendix B. Proofs Appendix B.1. Instance concept memberships
More formally, we will prove that  X  i , c ( i , c )  X  H R f Appendix B.1.1. Single instance concept membership I )). Since c  X  CN R  X  CN R = CN D  X  CN D p CN M  X  c  X  CN M c =  X  c , S c , P c  X  . Therefore, an ontology concept in CN by the transformation procedure.
 Regarding the instance, we have that i  X  IN R  X  IN R = IN that  X  i  X  IN M ,  X  i o  X  COOL data : i o =  X  i , c  X  i , PV
COOL sch is de fi ned in such a way, so as  X  c  X  i  X  CN M a single object i o of the class c  X  o i in COOL.
 ( i , a )  X  I D .Since i is assumed to belong to a single concept, then ( i ,{ a }) an instance of a single concept in I M , then we can conclude that a = c
In order to prove that i o is an object of the class c o , we should prove that a
From the de fi nition of the set H D , we have that ( c , a ) c )  X 
H M . Therefore, if a o =  X  a , S a , P a  X  , then c  X  S a Appendix B.1.2. Multiple instance concept memberships CN  X  c 2  X  CN R  X  ...  X  c N  X  CN R  X  ( i , c 1 )  X  I R  X  ( i , c CN  X  c k  X  CN M . Based on the de fi nition of COOL sch , we have that c is mapped on a single class c o k in COOL.
 Regarding the instance, we have that i  X  IN R  X  IN R = IN that  X  i  X  IN M ,  X  i o  X  I o : i o =  X  i , c  X  i , PV i  X   X  set COOL sch is de fi ned in such a way, so as  X  c  X  i  X  CN on a single object i o of the class c  X  o i in COOL.

Furthermore, based on thede fi nition of the set I D ,wehavethat
Since i belongs to multiple concepts, we have that ( i ,{ a ... , a N ), that is, ( i , a i )  X  I M . Accordingto the de fi nition of H of a single concept in I M ,weconcludethat a i = c  X  i and therefore, a that i o is an object of all the a o k classes, we should prove that a
According to the de fi nition of H D , we have that  X  k ( c c )  X  H M . Furthermore, we have shown previously that  X  k ( a relationship). Thus, if a o i =  X  a i , S a i , P a i  X  , we have from the set COOL class a o i is subclass of all the c o k classes in COOL and i the OO environment of COOL.
 Appendix B.2. Instance property values prove that  X  x , p , y ( x , p , y )  X  ObjV R  X  DatV R  X  X  X  Thetransformationproceduredoesnot modify theproperty-valuesets.Therefore, ObjV and( x , p , y )  X  ObjV R  X  DatV R  X  ( x , p , y )  X  ObjV of COOL data ,  X  x  X  IN M ,  X  i o x  X  COOL data : i o x =
Therefore,  X  c x , PV x  X  c , c x , PV x  X   X  COOL data  X   X 
References
