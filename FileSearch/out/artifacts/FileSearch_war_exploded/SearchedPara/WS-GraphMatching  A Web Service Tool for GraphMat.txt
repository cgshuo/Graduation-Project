 Some emerging applications deal with graph data and relie on graph matching and mining. The service-oriented graph matching and mining tool has been required. In this demo we present the web service tool WS-GraphMatching which supports the efficient and visualized matching of polytrees, series-parallel graphs, and arbitrary graphs with bounded feedback vertex set. Its embedded matching algorithms take in account the similarity of vertex-to-vertex and graph struc-tures, allowing path contraction, vertex deletion, and vertex insertions. It provides one-to-one matching queries as well as queries in batch modes including one-to-many matching mode and many-to-many matching mode. It can be used for predicting unknown structured information, comparing and finding conserved patterns, and resolving ambiguous identi-fication of vertices.

WS-GraphAligner is available as web-server at: E.1 [ Data ]: DATA STRUCTURE X  Graphs and networks ; F.2.2 [ Theory of Computation ]: ANALYSIS OF ALGO-RITHMS AND PROBLEM COMPLEXITY-Nonnumerical Algorithms and Problems[Computations on discrete struc-tures, Pattern matching]; D.2.2 [ Software ]: SOFTWARE ENGINEERING-Design Tools and Techniques[Object-oriented design methods] Algorithms,Design,Experimentation Graph mining, graph matching
Graph, essential to represent structured data, has gained popular applications in social science, homeland security, system security, and scientific/medical informatics. Given two graphs, representing networks in the same class, e.g. the query one and the being-queried one, graph compari-son is to check whether these two graphs are similar or not. The graph matching process can be used to find conserved patterns, to transfer knowledge from the well-known struc-tured data to an unknown one, and further to facilitate the inference and analysis of the structured data.

However the class problem of graph matching is NP-complete [3] even when searching a match for a tree in acyclic net-works. Existing approaches to subgraph iso-and homeomor-phism [4, 6] restrict the size, or topology of the patterns, or use hueristics and approximation algorithms. By allowing the mapping of different nodes from the query graph into the same node from the being queried one, the characteris-tics of graph homomorphism is injected [1] to the matching with the wider applications[5].

The web service tool, named WS-GraphMatching, pro-vides a platform to match polytrees, series-parallel graphs, and even arbitrary graphs with bounded feedback vertex set with the characteristics of both homeomorphism and homo-morphism[1, 2]. By customizing different parameters, the tool efficiently find a best mapping from query graphs to arbitrary being-queried graphs, allowing path contraction, vertex deletion, and vertex insertions. It also provides sim-ple and intuitive web-interfaces and several services such as graph retrieval, visualization and upload services.
We distinguish two kinds of vertex deletions: a bypass deletion of a vertex v with a single incoming and a single outgoing edge is the replacing of a u -v -w -path with a single ( u,w )-edge formally represented as mapping v into b . A strong deletion of a vertex v is removing of arbitrary vertex v together with all its incoming and outgoing edges which is formally represented as mapping into d .

Let graphs P = ( V P ,E P ) and T = ( V T ,E T ) represent a query graph and a being-queried graph, respectively. Let f : P  X  T map every vertex in V P to V T  X  X  b , d } . A pair of pattern vertices u,v  X  V P is called contracted if u and v are mapped into two different text vertices and either ( u,v )  X  V
P or there exists a u -v -path in P whose all intermediate vertices are bypass deleted. Let E f P be the set of all vertex pairs in P contracted by f (note that E P  X  E f P ). The mapping f is called a graph matching if for each contracted T . The number of insertions, i.e., the minimum number of intermediate vertices in such path is denoted  X  ( f ( u ) ,f ( v )).
The alignment should be penalized (i) for mismatches be-tween matched vertices, (ii) for strong deletions, (iii) for bypass deletions, and (iv) for insertions. Thus we obtain the following cost function. where  X ( u,f ( u )) is the penalty of mismatch between ver-tices corresponding to u  X  V P and f ( u )  X  V T ,  X ( u, d ) and  X ( u, b ) are penalties for strong and bypass deletions, re-spectively, and  X  is the penalty for a single vertex insertion. By setting infinity to the parameters such as the ones for the mismatches, deletions, and insertions, we can obtain the results for specified inexact graph matching.

As for the vertex-to-vertex dissimilarity, users can use the default methods to measure the dissimilarity, e.g. calculat-ing vertex-to-vertex distance based on the data types vertex represents. We allow users to upload the | V P | X | V T | matrix in which every entry [ i,j ] corresponds to the dissimilarity score between vertex v i  X  V P and u j  X  V T .

Given two graphs P and T , the problem is to find the optimal (minimum-cost) graph matching from P to T . We provides embedded fast algorithms for matching polytrees, series-parallel graphs, and even arbitrary graphs with bounded feedback vertex set.
Three-tier Architecture . The 3-tier architecture of the preliminary system is shown in Figure 1. It will consist of representation tier, logic tier, and data tier and provide a series of services, e.g. service for matching query, uploading plain graph data and vertex-to-vertex dissimilarity matrix, graph visualization service and some additional value service Implementation and features . WS-GraphMatching em-ploys Apache Tomcat/Axis for web service development en-vironment on Windows XP/Linux/Unix. We also uses MySQL as the data storage server. Matching algorithms are imple-mented by ANSI C and interfaces to the web are coded by JAVA. A web browser with Java SE 6 installed is required for graph visualization.

The work with WS-GraphMatching is divided into three phases: first, a set of parameters must be specified to de-scribe the matching mode, parameters, randomized compu-tation modes and scoring schemes. Second, a user chooses graphs for one-to-one matching, e.g. as the query graph and the being-queried graph from the existing database. The result of the one-to-one matching model will be visualized (See Fig. 2). The graph layout is based on a force-directed method. A user can customize the visualization by drag-ging vertices with the mouse and share it with other people. Labels with a light blue background represent the vertices in the query graph and those with a white background rep-resent vertices in the being-queried graph. Third, for the batch modes, the best K matching results are sorted by P-value or alignment score. The detailed information about the options, parameters and modes can be found online. Figure 2: A sample of graph matching in the appli-cation of biological graph matching. The upper part is the visualization for these two graphs; the bottom part is the matching result.
The WS-GraphMatching will be demonstrated by differ-ent matching algorithms and different matching query modes. We will show examples and their applications to biological network data and system security, e.g. how to catch model inconsistencies and to infer missing elements. The demon-stration process will follow the flow starting from matching configuration, through uploading graph data, visualizing the graph data, customizing matching query, to visualizing the matching results for the analysis and mining. [1] Q. Cheng, P. Berman, R. Harrison, and A. Zelikovsky. [2] Q. Cheng and A. Zelikovsky. Optimal mapping of multi [3] M. Garey and D. Johnson. Computers and [4] N. Ketkar, L. Holder, D. Cook, R. Shah, and et al. [5] R. Sharan and T. Ideker. Modeling cellular machinery [6] X. Yan and J. Han. gspan: Graph-based substructure
