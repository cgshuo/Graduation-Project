 Query recommendation has been widely used in modern search engines. Recently, several context-aware methods have been proposed to improve the accuracy of recommen-dation by mining query sequence patterns from query ses-sions. However, the existing methods usually do not address the ambiguity of queries explicitly and often su er from the sparsity of the training data. In this paper, we propose a novel context-aware query recommendation approach by modeling the high-order relation between queries and click-s in query log, which captures users' latent search intents. Empirical experiment results demonstrate that our approach outperforms the baseline methods in providing high quality recommendations for ambiguous queries.
 H.3.3 [ Information Storage and Retrieval ]: Information Search and Retrieval| Query formulation Algorithms, Experimentation, Theory Context-Aware, High-Order Model, Search Intent
Tradition query recommendation approaches often nd similar queries to suggest for each other[2, 1]. However, s-ince queries are usually very short and ambiguous[6], a same query may convey totally di erent search intents in di erent cases. For example, the query \saturn" may either refer to a planet name or a car manufacturer. To only suggest similar queries based on the current query may not work well in such cases.

Recently, some context-aware approaches have been pro-posed to address the problem of recommendation for am-biguous queries[5, 3]. The basic idea of these methods is to Fi gure 1: Query frequency with (a) di erent number of previous queries in the same session, (b) di erent number of clicks in query logs leverage the query sequence patterns from query sessions 1 That is, if a user queried \solar system" recently, it would be naturally recommend \planet saturn" or \uranus" to him when he is searching \saturn".

However, these context-aware methods based on query se-quence patterns matching have two major weaknesses. First-ly, they do not address the ambiguity of queries explicitly. Queries are usually viewed as the basic units in previous ap-proaches without modeling their underlying search intents. Secondly, they mainly rely on the query sequence patterns existing in query logs, hence may su er from the sparsity of data. We examined one month query logs from a commercial search engine. As Figure 1(a) shows, the number of query sequence patterns drops dramatically as their length increas-ing. Even worse, about 80% queries come from single-query sessions which means no previous queries existed.
On the contrary, we nd that the click-through from a query often provides rich information that can clarify user's search intent for ambiguous queries. For example, when a user submits a query\saturn", the search engine may return pages about both the Saturn planet and Saturn cars. Once the user clicking a URL in result pages about planet, it's clear that he cares about Saturn planet. Compared to the previous queries, the click-through from the current query always plays more direct e ect on user's next search behavior Besides, we also nd the click-through information is often more abundant than query sequence patterns in query logs, as Figure 1(b) shows, more than half of queries has one or more clicks, which may alleviate the sparsity problem.
Motivated by the above observations, we propose a prob-abilistic context-aware query recommendation approach by modeling the high-order relations between the current query, its click and the next query for recommendation. In our model, the ambiguity of queries can be resolved by intro-
A query session is regard as a sequence of queries and clicks, performed by a user within a short period of time (e.g. 30 minutes) in a search process Fi gure 2: Graphical structure for a RUT triple  X  q , u, q t  X  . ducing the latent factors over queries and their clicks. Once we have learned the ne-grained search intents underlying a query and its click-through, we can generate more accurate context-aware recommendation.
To facilitate the discussion, we will rst de ne some ter-minologies, and then give a formulation of our problem.
De nition 1. if a query q t closely follows q r in a query session, we denote q r as a refer query (of q t ), and q t target query (of q r ). All of the refer queries in query logs form the refer query set Q r . Correspondingly, we de ne the target query set Q t as the set of all target queries in query logs.

De nition 2. if a query q t closely follows q r in a query ses-sion, and a URL u is a click-through with q r in this session, we call the triple  X  q r , u, q t  X  a RUT triple.
From a probabilistic view, the query recommendation task is to nd top ranked q t s with respect to the probability P ( q t | q r , u ) for recommendation, given the contextual infor-mation  X  q r , u  X  . Because P ( q r , u ) is xed when  X  en, the condition probabilty is proportional to the joint one P ( q r , u, q t ). Therefore, the remaining problem is how to es-timate the joint probability P ( q r , u, q t ). Now we summarize the objective of our model as follows:
Problem Statement 1. Given a set of RUT triples and their frequencies, the objective is to learn the probability P ( q for q r  X  Q r , q t  X  Q t and u  X  U , where U is the URLs set in query logs.
To estimate the probability P ( q r , u, q t ), we propose a gen-erative model which captures the high-order relations be-tween user's current query, click and the next query. The graphical structure of our model is shown in Figure 2. It explains a query re nement process as follows. At rst, a user has search intent i with probability P ( i ). He submits query q r with probability P ( q r | i ), and then clicks a URL in result pages with probability P ( u | i ). Depending on his last search intent, he derives another related search intent j with probability P ( j | i ), and formulate the next query q with probability P ( q t | j ). Here we name search intent i as refer intent (of search intent j ), and search intent j as target intent ( of search intent i ) for convenience.

Based on the above generative model, we can write the joint distribution as
Furthermore, we assume all the RUT triples follow an identical independent distribution. The likelihood of all the observed data then can be written as l = The parameters can be learned by the Expectation Maximization (EM) algorithm[4]. By standard calculates one arrives at the following E-step and M-step, which will be repeated alternatively until convergence.
 E-step :
P ( i, j | q r , u, q t ) = P ( i, j ) P ( q r M-step :
However, the EM algorithm in this problem may not be very ecient because of the extremely high dimensions of queries and URLs. In fact, we may not necessarily rely on the speci c clicked URL u to identify the refer intent. We can leverage the topic or semantic category of the clicked URL u for the same purpose. Therefore, we map the URLs to their semantic categories c , whose dimensions are much lower than the URLs.
 Here we use the Open Directory Project 2 data for the URL-category mapping. In ODP, a URL might be assigned to more than one categories. Hence, a URL u corresponds to a vector  X  X  in the category space as follows where w u;c is the weight of each category for u de ned by: w
Finally, we transform each RUT triple to RCT triples (Refer query, Category, Target query) as The frequency of a RCT triple, denoted by n (  X  ), can be calculated as the product of the weight and the frequency of h ttp://www.dmoz.org/ th e corresponding RUT triple We can then obtain a similar high-order model over the RCT triples and estimate the corresponding parameters with a much lower cost.
With the above learned models, we now describe how to generate recommendations for a given context pair  X  q r , u Our approach is based on the assumption that the URL is conditionally independent on queries given the categories of a URL. In this way, P ( q t | q, u ) can be calculated as: By considering we have if q r and u are given, we combine (9) and (13) and result in
P ( q t | q r , u )  X  g ( q t ; q r , u ) = Therefore, we can use g ( q t ; q r , u ) as a score function of q Q t for recommendation.
In practice, the performance of the EM algorithm is highly related to two factors: the number of latent factors and ini-tialized parameters. We propose a special clustering method to tackle these two problems together, so that we can further improve both the eciency and e ectiveness of the learning process.

Hidden Dimension Selection by clustering . We in-troduce this clustering method by taking clustering over q as an example. Firstly, since the feature space { X  q r , c is sparse, we assume that if two target query q t 1 and q occurred with the same  X  q r , c  X  , they tend to have the same target intent. We extract all the q t 's from RCT triples as an initial cluster for each  X  q r , c  X  . The weight of each q  X  q , c, q t  X  in the query log.

Secondly, since many  X  q r , c  X  pairs may have similar la-tent search intent, we utilize traditional clustering method-s (e.g. hierarchical clustering) to merge the initial clusters based some similarity measure (e.g. cosine similarity). In-stead of specifying the clusters number, a minimal similarity threshold min s is used to control the merging steps. Once two clusters are merged, the weights of each q t are accumu-lated.

We also clustering q r 's in the same way, by considering  X  c, q t  X  as a single target intent as an initial cluster. Fi gure 3: Example of (a) a  X  i, q r , c  X  tripartite graph, (b) a  X  i, q r , q t , j  X  multipartite graph
Parameters Initialization . By utilizing the clustering results to initialize the parameters, we can signi cantly re-duce the number of parameters.
 tering results by normalizing the weights of queries in each ized from the clustering result. However, given all P ( q lation between c and i , and between intent i and intent j by putting them in multipartite graphs showing in Figure 3. Figure 3(a) is constructed by connecting a refer intent node i q k to a category node c k if n ( q r k , c k ) &gt; 0 in the training RCT triples. The idea is that we only need to initialize such P ( c | i )s that there exists a path from c to i in the tripartite graph. For other P ( c | i )s, even if we assign them non-zero values, the EM iterations will reduce them to zero at last. The proof is not dicult and we skip it due to the space limitation. After extracting all such kind of P ( c | i )s, we ran-domly initialize them and then perform normalization for each intent i . The P ( i, j ) initialization is almost the same, with a di erent multipartite graph showing in Figure 3(b). P ( q t k | j k ) &gt; 0.
Our experiments are based on the \Spring 2006 Data As-set" distributed by Microsoft Research 3 . We compared our result with three baselines: Co-occurrence (Co-occ), which recommends queries occurring after (may not adjacent) test query q most often in training query sessions; N-gram, which recommends queries closely following the query sequence most often; Context-Aware and Concept-Based method (CACB) [3]. The only di erence of CACB from N-gram is that CACB clusters queries to\concepts"by their clicks, and then trans-form query sequences into concept sequences. To generate recommendation, a concept is represented by the most fre-quent query in it.

We compared these methods based on a collection of am-biguous queries. Here, we take a simple approach to extract possible ambiguous queries. By exploiting the URL-category data we extracted from ODP, we nd queries with clicked URLs from multiple di erent categories are more likely to be ambiguous. We thus randomly extract 1000 query ses-sions, whose last query's clicked URL belongs to di erent h ttp://research.microsoft.com/users/nickcr/wscd09/ T able 1: Examples for refer intents and target in-tents involve the query \saturn", but with two dif-ferent means. The second row is top 5 queries in the intent, and the third row is categories corresponding to refer intent T able 2: Query recommendation examples with dif-ferent context ca tegories, as our test data. Recommendation is conduct on the last query of each session. Finally, the recommenda-tion results are manually assessed by three judges to decide whether the recommendation is meaningful or not.

Precision and recall are used to evaluate the quality of the results of these methods quantitatively. Here, precision is de ned as the average ratio of meaningful ones over the all recommendations generated by a method for a test query. While recall is de ned as the average ratio of meaningful recommendations found by a method over all meaningful ones in the training data. Nevertheless, it's impossible to collect all the meaningful recommendations in such a large scale data. Instead, we use the TREC pooling method to construct a pool of meaningful recommendations collecting from the top 5 recommendations of all these methods. Recall metric of each method is then calculated base on this pool.
Qualitative Evaluations . In Table 1, we show two re-fer intents and two target intents learned by the high-order model. It's clear that i 1935 and j 34564 talk about cars, which is consistent with the ODP category \Automotive", while i 19645 and j 29915 are about planet. Furthermore, Table 2 shows recommendations of all the methods under di erent contexts, we can see that the High-order model can provide more accurate results than others in these cases.
Quantitative Evaluations . Figure 4 shows the preci-sion and recall across the top 5 positions for each method. In precision, the High-order method outperforms N-gram and CACB. All of the three methods can outperform the Co-occ method signi cantly. It shows that for ambiguous queries, the context-aware manner can capture users' search intent more accurately than the context-free ones. In recall, our High-order method signi cantly outperforms the other methods. The sequence pattern based methods performs Fi gure 4: (a) Precision and (b) Recall of query rec-ommendation across the top 5 positions over di er-ent methods worst, due to the sparsity of the sequence patterns in query logs. While our approach can clearly bene t from the rich click-through information.
We address the problem of context-aware query recom-mendation. Unlike the existing approaches which leverage query sequence patterns in query sessions, we use the click-through of the given query as the major clue of users' search intents to provide context-aware recommendation. We pro-posed a probabilistic model by learning the High-order re-lations between the current query, its click-though and the next query. Compared with existing methods, our approach achieves both better precision and recall on recommenda-tions for ambiguous queries. This research work was funded by the National High-tech R&amp;D Program of China under grant No. 2010 AA 012500, and the National Natural Science Foundation of China under Grant No. 61003166 and Grant No. 60933005.
