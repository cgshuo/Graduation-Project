 1. Introduction 1.1. Motivating example u visiting the web site at subsequent time periods p 2 ; p 3 the evolutionary nature of web usage data leads to the following two challenging problems:
Maintenance of web user clustering results : Take the web sessions in Fig. 2 as an example. Although users u accessed similar web pages in the period p 1 , they visited different pages in p requires development of efficient incremental web user clustering techniques. focus here is the second problem. Particularly, we propose a new web user clustering method, tics of their usage data.
 web session subtree to denote the subtree), which is highlighted by dotted lines in Fig. 3 . Similarly, users u in the context of XML documents in our previous work [5].
 the evolutionary characteristics of each user X  X  usage data, we propose to use the sions in Fig. 2 , our proposed clustering method COWES will cluster u 1.2. Applications
Similar to existing web user clustering, the results of COWES used in various web personalization applications. In contrast to existing methods, evolutionary characteristics of users X  information needs. Thus, the results of scenarios. We elaborate two of the applications of COWES in the following paragraphs. in appropriate web pages. Web user clusters generated by COWES know that the variation of information needs of u 1 is different from that of users u is targeting all the three users. Although all of them accessed the page a = b = e in the current period p should be put in the page a = b instead of a = b = e for user u Used), which assigns priorities to the most recently accessed pages. Web user clusters generated by LRU to manage the caching region more optimally. For example, analyzing the clusters generated by u accesses different pages under a = c in a subsequent time period, such as p under a = d so that their eviction from the cache becomes more probable. 1.3. Overview of COWES
The overview of COWES system is presented in Fig. 4 . The input is a collection of web users f u ciated with a sequence of historical web sessions that are collected at a sequence of time periods h p particular time granularity. Each sequence of web sessions of user u h S i ; S tionary characteristics of their usage data. In particular, we mine quently undergo significant changes together, from each user X  X  historical web session trees and use feature. Then, each web user can be represented as a set of sure the similarity between users based on their FRACTURE generated.
 web users. 1.4. Contributions The main contributions of this paper are summarized as follows: users based on the evolutionary features of historical web sessions. ters generated based on this pattern are useful in real-life applications. terms of their evolutionary patterns, respectively.
 onstrate the performance of COWES and the novelty of generated clusters. The rest of the paper is organized as follows. In Section 2, we explain the notion of paper appeared in [6]. Table 1 summarizes the notations used in this paper. 2. FRequently And Concurrently muTating substructUREs (FRACTURE) In this section, we briefly introduce the evolutionary pattern refer to our previous work [5] for details.
 s  X h N i ; E i i is a web session subtree, denoted as s i S , if and only if (1) N s ;  X  4  X  for a node x 2 N ,if x 2 N i then all descendants of x (if any) must be in N tree as follows.
 node of node y in a web session tree.
 Delete  X  x  X  : This operation is the inverse of the insertion one. It removes node x from a web session tree.
For example, the sequence of web session trees of user u 2 is a changed subtree in the two versions.
 Changed web session subtrees are elements of FRACTURE . In order to measure the interestingness of a significant changes together.

Definition 1 ( DoC ). Given two versions of a web session subtree s p
Degree of Change  X  DoC  X  of web session subtree s in the two versions is subtrees, X  X f s 1 ; s 2 ; ... ; s m g , where 8 j  X  1 6 j the p i version to the p i  X  1 th version. The Frequency of Change ( FoC ) of the set X is: FoC  X  X  X  X  3 = 3  X  1 as both subtrees changed in the three transitions of successive versions. subtrees, X  X f s 1 ; s 2 ; ... ; s m g , where 8 j  X  1 6 j threshold of DoC a , the Significance of Change ( SoC ) of the set X is defined as follows: the last two times. Hereafter, we omit the subscript of SoC when the DoC threshold a is clear from the context. Based on the above metrics, the FRequently And Concurrently muTating substructUREs ( subtrees, X  X f s 1 ; s 2 ; ... ; s m g , where 8 j  X  1 6 j threshold b and SoC threshold c ; X is a FRequently And Concurrently muTating substructURE ( two conditions: (1) FoC of the set is no less than the user-defined FoC threshold b ; FoC  X  X  X  P b . (2) SoC of the set is no less than the user-defined SoC threshold c ; SoC  X  X  X  P c . are: a  X  b  X  c  X  0 : 5. Let X be the two subtrees a = b and a = d in Fig. 5 . Then X is a SoC  X  X  X  0 : 67 P c .
 a  X  b  X  c  X  0 : 5. Table 2 shows the discovered FRACTURE s of each user 3. Similarity measure Similarity .
 Given two users represented as two sets of FRACTURE s, they may share some of their features is the combination of the two set of FRACTURE s. For example, suppose user u u has a set of FRACTURE s f X 1 ; X 3 g . The complete set of features are f X Suppose a similarity measure FRACTURE Similarity  X  FS  X  can be computed on a pair of shared
For the k th FRACTURE , compute a similarity, FS  X  u 1 ; u
Define an indicator variable d k , such that Compute the overall similarity between the two users using the following formula: However, in our application, we observed that such a similarity measure has the following two limitations. First, the denominator in Eq. (1) counts only the number of shared not shared by the two users affects the proximity of the users as well. Consider two users who have m and n that the total number of FRACTURE s of the two users are considered.
Second, the numerator in Eq. (1) treats all shared FRACTURE s (e.g., we will define two types of shared FRACTURE s, Identical ducing weights to different types of shared FRACTURE s. Consequently, the numerator of Eq. (1) becomes: where x k is the weight of the k th shared FRACTURE .
 In the following, we first introduce the two types of shared 3.1. Types of shared FRACTUREs type of FRACTURE s shared by two users as Identical FRACTURE
Definition 5 ( Identical FRACTURE s ). Let X 1  X f s 1 ; ... ; s the root of web session subtree s . X 1 and X 2 is a pair of Identical 8 i  X  1 6 i 6 m  X  ; 9 j  X  1 6 j 6 n  X  s : t : L  X  s i  X  X  L  X  s the corresponding subtrees have same labels. For example, consider the pair of Identical FRACTURE s . The two users u 2 and u 3 share another two pairs of Identical are semantically related. For example, given two web session subtrees s
L  X  s 1  X  is a prefix of L  X  s 2  X  , the two web session trees are semantically related, e.g., s
Identical FRACTURE s, we define another type of shared FRACTURE
Definition 6 ( Approximate FRACTURE s ). Let X 1  X f s 1 ; ... ; s arriving at the root of web session subtree s . X 1 and X (2) 8 i  X  1 6 i 6 m  X  ; 9 j  X  1 6 j 6 n  X  s : t : L  X  s i 9 i  X  1 6 i 6 m  X  s : t : L  X  s j  X  is a prefix of L  X  s i and labels of corresponding subtrees have prefix relationships. For example, the two We now explain how to assign different weights to different types of shared whose labels have prefix relationship, we define Prefix Level to measure the distance between the two subtrees.
Definition 7 ( Prefix Level ). Let s i and s j be two web session subtrees s.t. L  X  s denoted as j L  X  s i  X j , is the number of edges traversed by the path. Then, the Prefix Level between s can be computed as For example, consider the two subtrees in the pair of Approximate the subtrees are a = c = i and a = c , the Prefix Level between the two subtrees is 1. Note that, Identical Identical FRACTURE sis0.
 related the two subtrees. Given a pair of Identical/Approximate ously, the less the sum, the more importance the shared FRACTURE to a pair of shared FRACTURE s can be computed as follows.

Definition 8 ( Weight ). Given a pair of shared FRACTURE s X
The weight assigned to the pair of FRACTURE s, denoted as x  X  X
Thus, when the pair of shared FRACTURE s are Identical FRACTURE
FRACTURE s, X 2 1 X 1 2 ,in Table 2 can be computed as follows. x  X  X 3.2. FRACTURE Similarity (FS) A pair of shared FRACTURE s may have different FoC and SoC values. Hence, we define the metric measure the similarity of shared FRACTURE s in terms of their FoC and SoC values. measure the distance between the FoC and SoC values of a pair of Identical/Approximate values of a pair of shared FRACTURE s X 1 and X 2 . In order to define the FRACTURE Similarity based on the distance between FoC and SoC values of shared tonic decreasing function to convert the distance to a similarity Definition 9 ( FRACTURE Similarity ). Let X 1 and X 2 be a pair of Identical/Approximate distance between the FoC and SoC values of X 1 and X 2 . The is defined as, FRACTURE s, the higher the FS . FS have the following two properties.
Property 1 ( Positivity Property ). FS  X  X 1 ; X 2  X  X  1 only if X That is, given two FRACTURE s X 1 and X 2 ; FS  X  X 1 ; X 2 distance is a metric, which has the Positivity Property, d  X  X
Property 2 ( Symmetry Property ). FS  X  X 1 ; X 2  X  X  FS  X  X
Again, since Mahalanobis distance is a metric, d  X  X 1 ; X SoC is
For the pair of Identical FRACTURE s, X 3 2  X  X 3 3 ; d  X  X values. While, for the pair of Approximate FRACTURE s, X 2 3.3. User Similarity different types of shared FRACTURE s, the User Similarity can be formally defined as follows.
Definition 10 ( User Similarity ). Let u 1  X f X 1 1 ; X 2 two sets of FRACTURE s. Suppose there exists k  X  0 6 k 6 m Users , denoted as US  X  u 1 ; u 2  X  , is defined as, If each pair of corresponding FRACTURE s of the two users are Identical mum value of 1. Otherwise, if the two users share no FRACTURE hold for US as well.

Property 3 ( Positivity Property ). US  X  u 1 ; u 2  X  X  1 only if u First, if u 1  X  u 2 , which means u 1 and u 2 share all of their 1, then it is obvious US  X  u 1 ; u 2  X  X  1. Second, if u 1
Positivity Property holds for US .
Property 4 ( Symmetry Property ). US  X  u 1 ; u 2  X  X  US  X  u
According to Definition 8, x  X  X i 1 ; X i 2  X  X  x  X  X i 2 US  X  u 1 ; u 2  X  X  US  X  u 2 ; u 1  X  .

Example 2. Consider the users and their FRACTURE sin Table 2 again. Since the two users u
FRACTURE s, where each pair has the FS value 1 ; US  X  u 2
Approximate FRACTURE s with FRACTURE similarity equal to 0.15 and assigned weight being 0.37. Then US  X  u 4. Framework of COWES sequence of his historical web sessions, COWES generates the clusters of users in the follows phases: Phase I. From the historical web sessions of each user, we extract a set of features for clustering.
 Phase II. Compute the similarity matrix between pairs of web users based on the defined similarity measure US . Phase III. Perform clustering on the generated similarity matrix of web users.
In [5], we have proposed two algorithms of mining FRACTURE
FRACTURE and FPG -FRACTURE . We discuss the Phases II and III in the following subsections. 4.1. Similarity computation As the output of Phase I, each web user is represented as a set of ond phase.
 Given two web users represented as two sets of FRACTURE s, we first compute an optimal assignment of their
TURE s is minimized). For example, suppose u 1  X f X 1 1 g where X
X  X f a = b = e ; a = c = i g . Although X 1 1 is approximate with both X zation or operations research in mathematics, which can be defined as follows [25]: for B, or both.
 In our problem, A is the set of FRACTURE s of one user, B is the set of between matched subtrees from a pair of shared FRACTURE s 4.2. Cluster generation functions used by us are shown in Eqs. (4) X (7) , where k is the number of clusters, n and v are two individual users, C i is the i th cluster and C represents clusters other than C 5. Experimental results their characteristics in usage data evolution. The first two steps of professional. 5.1. Experiments on synthetic data 5.1.1. Synthetic data generator We implemented a synthetic data generator which generates by the generator are shown in Table 3 (a), where the third column shows the default values of the parameters. tree is less than or equal to R or the total number of nodes reaches N . Then, we select subtrees from the general web session tree to compose P tree.
 Then, we organize FRACTURE s into FRACTURE groups. We sample the size of a Finally, we generate FRACTURE s for web users. For each web user, we decide the number of obtained from a normal distribution with mean 0.5 and variance 0.1. Then, when adding tion level of the group. To model the phenomenon of Approximate selected FRACTURE from a uniform distribution in the range of [0,1]. dense, which affects the performance of clustering methods. 5.1.2. Result analysis the dataset D 2 using the partitional methods with criterion functions I in the remaining experiments.
 study the performance of 6 alternative similarity measures as in Table 4 . For example, for US both FS and x . While, for US 2 , we use the function e d for FS and 1 (and US 6 ) to consider Identical FRACTURE s only. That is, x is either 1 for Identical
We perform clustering with the six similarity measures on datasets D internal similarity of clusters, which can computed as follows. while, ES refers to the average external similarity of clusters, which is defined as Eq. (9). following observations: versa. For example, US 5 can achieve high IS value, while its ES is quite high as well. Similarly, although US generates low ES , it sacrifices too much in IS . Generally, US 10, generates good IS without sacrificing too much in ES .
 because the generated IS is lower than ES in many cases).
 values generated by the partitional clustering method with the I sets. We learned that US 2 and US 5 always achieve the highest IS ( ES ) while US measure US 4 is used. It can be observed that the partitional clustering method using the criterion function I also in controlling the balance of the cardinality of the clusters. 5.2. Experiments on real data We also conducted three experiments on real-life data. In the first experiment, we compare the accuracy of shows the performance variation with respect to the parameters of 5.2.1. Datasets by whether COWES can generate clusters of high quality based on evolutionary features of the requests. 5.2.2. Result analysis
We first conduct experiments to evaluate the accuracy of COWES the partitional clustering method with criterion function I Classical web user clustering methods usually represent each web session as a bag pages. However, sions is 1/3. Since COWES represents web sessions as trees also, it is fair to compare sical web user clustering algorithms.
 The experimental results are shown in Fig. 12 . The DoC ; FoC and SoC thresholds for we generate 3 through 6 clusters. We observed that for Dataset I, the accuracy achieved by perform as well as COWES on Dataset II is as follows. STRUCTURE similar pages, COWES can distinguish them if they share similar served that although they share similar pages with other hosts in Dataset II, they share a particular pair of  X  X  X 659229.boeing.com X , FoC of the FRACTURE is 0.22 and SoC of the quently vary their information needs under the two web session subtrees together. ilarity measure while the latter considers Identical FRACTURE IS .
 are high, fewer FRACTURE s can be discovered and web users probably share fewer threshold of FoC . The reason is that even if the threshold of FoC is lowered, it is not necessary more for each user, because the threshold of SoC is fixed. Generally, the performance of
COWES need to adjust the thresholds until acceptable IS and ES values are reached. 6. Related work sessions.
 date knowledge, whereas we mine the historical web usage data to obtain novel knowledge. 7. Conclusions In this paper, we have presented a novel web user clustering method called characteristics of web usage data, we mine evolutionary patterns, covered patterns as the clustering features. We identified two types of users in terms of their shared FRACTURE s.
 clustering methods and graph-based methods in our application.

References
