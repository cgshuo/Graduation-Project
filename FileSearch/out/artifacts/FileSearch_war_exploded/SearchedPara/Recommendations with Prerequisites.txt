 We consider the problem of recommending the best set of k items when there is an inherent ordering between items, expressed as a set of prerequisites (e.g., the course  X  X eal Analysis X  is a prerequisite of  X  X omplex Analysis X ). Since this problem is NP-hard, we develop 3 approximate algorithms to solve this problem. We experimentally evaluate these algorithms on synthetic data.
 H.3.3 [ Information Storage and Retrieval] ]: Informa-tion Search and Retrieval X  Information Filtering Algorithms, Experimentation, Theory Recommendation Algorithms, Graph Theory
Traditional recommendation systems deal with the prob-lem of recommending items or sets of items to users by using various approaches [2, 9]. However, most of these approaches fail to take into account prerequisites while recommending an item: A prerequisite of an item i is another item j that must be taken or consumed (watched, read, ...) in advance of i . Thus, it makes sense to consider prerequisites when making recommendations. For example, university courses often have prerequisites. If course i cannot be taken unless course j has been completed, then it does not make sense to recommend to a student course i if j has not been taken. We could maybe recommend both i and j , or perhaps we could recommend some other course k that may be less desirable then i but whose prerequisites have been met.

We are interested in the problem of prerequisites in the context of our CourseRank project at Stanford University. CourseRank is a social tool developed in our InfoLab and used by students to evaluate courses and plan their aca-demic program. CourseRank is currently used by over 9,000 Stanford students (out of 14,000); the vast majority of un-dergraduates use it regularly. One of the CourseRank goals is to recommend courses that are not just  X  X ood X  but also help students meet academic requirements [7]. (Academic requirements describe the constraints on the courses needed to complete a major.) In addition, we would like to take into account prerequisites, which the current production system does not take into account. Since this shortcoming is serious, we have developed a model and algorithms for recommen-dations constrained by prerequisites, which we describe and evaluate in this paper. Our plan is to incorporate one of our algorithms into the production system.

Although our focus is on prerequisites in an academic en-vironment, prerequisites also arise in other recommendation contexts. Movies, for instance, often are best watched in a sequence. For example, the movie  X  X odfather I X  should be watched before  X  X odfather II X , and both these movies should be watched before  X  X odfather III X . Drama TV seri-als tend to proceed in sequential fashion, and need to be watched in sequence. Novels tend to be sequential as well. While movies tend to have relatively few sequels, a fiction series could have several books that should be read in order.
We approach the problem of recommendations with pre-requisites in the following way. We are given a set of items, each with an initial score that describes how desirable that item is for a particular user. The initial scores can be de-rived using traditional recommendations techniques, e.g., a movie may have a high score if people like our given user have watched that movie. We also know which items the user has consumed already. We now wish to recommend to the user a set of k desirable items, such that the set can be taken without further prerequ isites. That is, the prerequi-site of any item in the set has either been satisfied or is in the set itself. For example, if we wish to recommend  X  X ord of the Rings II X  to a user as one of the k items, then we have to recommend  X  X ord of the Rings I X  (a prequel, and there-fore a prerequisite) as another one of the k items (unless the user has already watched part I).

In Section 2 we formally define the problem of set rec-ommendations, and we show that selecting the best set is NP-hard. In Section 3 we present three heuristic algorithms that find good sets.
We now formally define the problem of recommendation with prerequisites. (We will briefly discuss extensions to the problem in Sec. 3.6). We wish to recommend a set of k items from a set of items V . We are also given a directed graph G (
V , E ), where the vertices v  X  X  corresponds to items, and directed edges ( u, v )  X  X  correspond to prerequisites, i.e., item u needs to be taken before item v . We assume that each item in V has been already assigned a score ,which corresponds to how  X  X ood X  the item is. This score could be obtained by various approaches  X  content-based, collabo-rative filtering [9, 2, 3] etc. Note that we do not include in G nor in V items that have already been taken or watched. taken, then we can ignore j and its prerequisite.
Our task is to pick a set A ,ofsize | A | = k , such that score ( A ) is maximized: In addition, we also have the following constraint to ensure that prerequisites are satisfied:
Note that these equations above inherently assume that the items being recommended are independent of each other, except for those that are related via set E .Thatis,the scores of items (not connected through E ) do not change if we recommend them together or separately.
 We assume that the directed graph G consists of a forest C of chains , C i ,whereeach C i consists of items in sequence. A chain consists of items a 1  X  a 2  X  ...  X  a n , such that there exists only the following edges involving a 1 ,...,a ( a be 1, in which case the node has no edges either coming into or going out of it.

For example, if the items we wish to recommend are movies, then nodes corresponding to movies  X  X odfather I X ,  X  X odfa-ther II X  and  X  X odfather III X  would form a chain as follows: Godfather I  X  Godfather II  X  Godfather III. On the other hand, the movie  X  X hawshank Redemption X  would form a sin-gleton node with no edges either going in or coming out.
If a 1  X  a 2  X  ...  X  a n is a chain, then a 1  X  a 2  X  ... a ,i  X  n is a sub-chain , while a 1  X  a 2  X  ...  X  a n  X  ... a n + m ,m  X  0isa super-chain .
 The problem of picking the best set A, | A | = k ,satisfy-ing prerequisites as described above is NP-Hard. We prove hardness via a reduction from the 0-1 Knapsack problem [6].
Since the problem of recommendation with prerequisites is NP-Hard, we can only provide approximate solutions. We illustrate the three algorithms using an example, and then discuss them in more detail in subsequent sections.
Consider the following graph:  X  a (0 . 5)  X  j (0 . 8)  X  k (0 . 9)  X  b (0 . 6)  X  g (0 . 7)  X  c (0 . 3)  X  h (0 . 8)  X  i (0 . 2)  X  d (0 . 7)  X  e (0 . 2) Each letter above indicates a node in the prerequisite graph, and the arrows show the pre requisites. For example, a is a prerequisite of j , which is a prerequisite of k . We include a score of picking each item, displayed in brackets next to the node corresponding to the item. As an example, h has a score of 0.8.

Our aim is to pick a set of size k , such that prerequisites are retained, and score of the set as defined in Eq. 1 is maximized. If say k = 4, then the optimal solution which does not violate prerequisites is { a, j, k, d } ,witha score of 2.9. We leave the proof that this set is optimal as an exercise for the reader. We define boundary ( A )ofaset A as the set of items in A that can be deleted, without violating the prerequisites of any other items in the set, i.e., if x  X  boundary ( A ), then there is no y  X  A and x 1 ,x 2 ,...,x n such that there ex-ists a sequence of edges ( x, x 1 ) , ( x 1 ,x 2 ) ,..., ( x the above example, if A = { a, g, c, h } ,then boundary ( A )= { a, g, h } , any of which can be discarded without affecting the prerequisites of other items in A .

We define external ( A )ofaset A as the set of items that are not in A and can be potentially added to A without violating prerequisites, i.e., if x  X  external ( A ), then there is no y, x 1 ,x 2 ,...,x n such that the edges ( y, x 1 ) , ( x contains the items in V that have no edges coming into them. { a, i, g, d, e } , any of which can be added without violating any prerequisites. For example, adding k would create a new inconsistency since a is not present in A . However, all the items that have no prerequisites are present in external ( A ), along with i , whose prerequisites c and h , are present.
We describe the execution of this algorithm on the graph in Sec. 3.1. We try to pick a set of size k =4.

Step 0 : We start by picking nodes whose prerequisites have been satisfied (or do not exist). Thus, the candidates g (whose prerequisite, b , is now present), and then a ,until |
A | = k .This A is { a, b, g, d } .

Step 1 : Consider all nodes whose parents are in A or those who have no prerequisites. Here, we have B = { j, c, e } a greedy fashion, we try to see if we can replace the worst node in A (that can be removed) with the best node in B all the time maintaining prerequisites. In this case, we first examine j , the item with the highest score in B .Theworst node in A is a . However, j is a child of a . We therefore we cannot pick b . Instead, we pick one of d or g , g (say). B = { c, e, g, k } ,andthenew A = { a, j, b, d } . Step 2 : The best node in B is k (since its parent, j  X  A ). We then replace (the worst node in A that can be removed) b with k , giving us A = { a, j, k, d } ,and B = { b, c, e
Step 3 : The best node in B , b , is no longer better than any node in A , and we then terminate the algorithm, with optimal A = { a, j, k, d }
Note that in Step 1 ,ifwehadremoved d instead of g ,we would have ended up with the same A , in more iterations.
As listed in Algorithm 1 , we initialize the set A with the best k items by picking greedily the best item from among the items whose prerequisites have been satisfied, but are not already in the set A , i.e., external ( A ) (line 2-4).
We then greedily try to replace items from boundary ( A ), i.e., the items that are non-essential to A ,withthosefrom external ( A ), those whose prerequisites have been satisfied (line 7-14). However, we make sure that we do not delete the parent of a child (line 8).
 Algorithm 1 BreadthF irstP ickings :BFPickings 1: A  X  X  X  2: while size ( A ) &lt;k do 4: end while 5: B  X  external ( A ) 6: while there exist items in B do 10: A  X  A  X  X  a } X  X  b } 11: B  X  external ( A ) 12: else 13: remove b from B 14: end if 15: end while 16: return A
We use a max-priority-queue for this algorithm, and in-sert sets of items into the queue. The max-priority-queue is sorted on the average score of the items in the sets, and on querying returns the set with the largest average score.
We describe the execution of this algorithm on the graph in Sec. 3.1. For every chain in the above graph, we insert all sub-chains as sets into the max-priority-queue. For ex-ample, for chain a  X  j  X  k , we insert into the queue the
We keep popping sets with the maximum average score from the queue, see if the number of items in the set is greater than the remaining capacity that we can accommo-date. If so, we discard it, if not, we add the set to A .In this case, we pop B = { a, j, k } first, whose average score is 0.73, and whose size is 3. Let k denote the current size of A , k =0. Since k + size ( B )  X  4, we let A  X  A  X  B .
We then update the average score and size of all sets in the queue that correspond to super-chains and sub-chains of chain a  X  j  X  k , assuming that the set { a, j, k } has been picked. For example, the average score of a  X  j is now set to 0 (since { a, j } is already in A ). If a  X  j  X  k  X  y ,then and size = 1 (since a, j, k have been picked).

Now k  X  k = 1, so only sets of size 1 can be picked. Once again, in this case, B = { d } with average score = 0.7, is added to A .Thus A = { a, j, k, d } ,theoptimalset.
We list the pseudocode for in Algorithm 2 .Weinsert all sub-chains present in graph G (as sets) into the queue (line 3-7), sorted on average score , i.e., the sum of score of the items in the chain, divided by the size of the chain.
Now, as long as we have not picked enough items in A , we keep picking chains by popping sets from the queue (line 8-9). If the popped set is small enough to be accommodated in A (line 10), we add it to A (line 11), and update the values of other sets that correspond to super-chains (line 12-16) and sub-chains (line 17-19). Super-chains will now get truncated given that the set corresponding to the current chain has been picked. Sub-chains can no longer be picked, since the current chain has been picked.
 Algorithm 2 GreedyV alue :GVPickings 1: A  X  X  X  2: Q  X  X  X  3: for all chains C i  X  G do 6: end for 7: end for 8: while size ( A ) &lt;k  X  Q =  X  do 11: A  X  A  X  m 12: for all super-chains c  X  Q where c contains m do 13: old  X  size ( c ) 16: end for 17: for all sub-chains c  X  Q where m contains c do 18: remove c from Q 19: end for 20: end if 21: end while 22: return A
Here we sort all nodes in decreasing order of score ,and initially let A be the top-k ,inthiscase(say): { j, k, g, h now try to add the prerequisites of these items, starting from the item with the highest score. The set of items already considered is B , which is currently empty.

The best item in A is k ,witha score of 0.9. Item k needs the set C = { a, j } .Since a is missing in A ,weadd a ,and delete the node with the worst score from the boundary of A , but that which has not already been considered (i.e., is not in B ), in this case, g .Thuswenowhave A = { a, j, k, h We keep track of the nodes already considered so far in B , which is now { k } .
 Next, we try to see if j  X  X  prerequisites are present in A . They (i.e., { a } ) already are. The set B now becomes { k, j
The next item from A  X  B is h .Now,wetrytoadd h  X  X  prerequisites. Deleting another node from the boundary of A (which contains only k ) cannot be done since k has already been considered (i.e., is present in B )  X  we keep this constraint because we do not want worse items to override better ones. We instead try to replace h with a node that does not need any new prerequisites. Here h is replaced by Set A now becomes { a, j, k, d } .Set B now becomes { j, k, h
We now pick the next best item from A  X  B to check if its prerequisites are present. This item is d , whose prerequisites are present, so we do not add or delete any items from A . The set B now becomes { d, j, k, h } .Next, a is picked, and once again, there is no change to A .

Thus we once again get the optimal solution, A = { a, j, k, d
In Algorithm 3 we start off with the best set of items of size k (line 1), and try to incrementally add prerequisites. We keep track of items that we have already added prerequisites for in B (line 6), and never let such items be deleted.
We pick the items in order of decreasing scores from A  X  B , i.e., the items that have not been examined already (line 4). We then check if the prerequisites of the item are already present in A (line 7), if so, we examine the next item.
If there are still some s prerequisites required (line 8), we replace items from A if possible (line 11-14,18). These items are picked from boundary ( A ), but should not be present in the items already considered B (line 12-13).

If sufficient items cannot be found we replace the item under consideration with an item from external ( A ) (line 16), i.e., those items that can be potentially added because their prerequisites are present.
 Algorithm 3 T opDownP ickings :Top-DownPickings 1: A  X  best set of size k 2: B  X  X  X  3: while there exists items  X  A  X  B do 5: C  X  prerequisites of a 6: B  X  B  X  X  a } 7: if ( C  X  A ==  X  )continue 9: A  X  A 10: R  X  X  X  /* deletions from A */ 13: if a exists, R  X  R  X  a ; A  X  A  X  a 14: end while 15: if size ( R ) &lt;s then 16: replace a in A with item with largest score from 17: else 18: A  X  ( A  X  R )  X  C 19: end if 20: end while 21: return A
We are not aware of any prior work in the area of set recommendations that take prerequisites into account.
However, there is a large body of work on traditional rec-ommendation systems, aimed at coming up with a single  X  X core X  for each item, combining approaches that look at us-ing ratings given by other  X  X imilar X  users [9], other  X  X imi-lar X  items that the user liked [8], and other approaches [3]. All of these techniques could be used in generation of the score function that we use as a black box, therefore our work builds on top of other recommender systems work.
The body of work on Top-N recommendation systems [4] solve a different problem. Their aim is: given a user X item matrix of scores, and given the set of items that a given user has consumed, recommend an ordered set of up to N items that the user has not consumed. In this case there is no inherent ordering of items that needs to be respected when recommending N items, which is the case in our problem.
Ziegler et. al. [10] consider the case of recommending lists of items taking into account diversity among items in the list. Prerequisites are not considered; additionally, our al-gorithms can be generalized to handle the case of complex scoring functions where the score of a set is not just the sum of scores of the items contained in the set (See [6]).
Some of the recommendation questions we pose can be written in RQL (Recommendation Query Language) [1], or expressed as constraints [5], however, our aim in this paper is to consider efficient algorithms that solve those recommen-dation questions, and not posing those questions themselves.
In this paper, we studied how prerequisites affect the prob-lem of recommendations. We focused on the problem of rec-ommending a set of items with high score, while satisfying prerequisites. We proved that this problem is NP-Hard, and suggested 3 approximate algorithms to solve this problem.
For the three algorithms that we described above we an-alyzed termination, worst case complexity, and worst case performance bounds in the extended technical report [6]. Also, in [6], we generalized our algorithms for directed acyclic graphs , and for returning multiple recommended sets (or-dered by score).

In [6], for a synthetic dataset, we compared the three al-gorithms with the best set that could be returned without regard to prerequisites. We found that the greedy value pick-ings algorithm consistently performs better than the other two algorithms, and performs even better if we increase the number of items picked relative to the number of chains. However, this algorithm may be more expensive computa-tionally than the other two.

We also found that there are cases where the breadth first pickings algorithm does better than the top down pickings algorithm, specifically when the number of items is small rel-ative to the number of chains. When the number of items is large relative to the number of chains, the top down pickings algorithm tends to do better. [1] G. Adomavicius, A. Tuzhilin, and R. Zheng. Rql: A [2] G. Adomavicius and E. Tuzhilin. Toward the next [3] R. Burke. Hybrid recommender systems: Survey and [4] M. Deshpande and G. Karypis. Item-based top-n [5] A.FelfernigandR.Burke.Constraint-based [6] A. Parameswaran and H. Garcia-Molina.
 [7] A. Parameswaran, P. Venetis, and H. Garcia-Molina. [8] M. Pazzani and D. Billsus. Content-based [9] B. Sarwar, G. Karypis, J. Konstan, and J. Reidl. [10] C.-N. Ziegler, S. M. McNee, J. A. Konstan, and
