 In this paper, we describe a system incorp orating an improved technique that detects the similarity of two XML documents based on content and structure similarity using keys. The technique consists of three major components : a subtree generator and validator , a key generator , and similarity components that compare content and structur e of the XML documents . First, an XML document is stored in a relational database and extracted into small subtrees using leaf -node parents . The leaf -node parents are considered as a root of a subtree which is th en recursively traversed bottom -up for matching. Second, a possible key(s) is identified in order to match XML subtrees from two documents efficiently . Key matchings help in reduc ing the number of comparisons dramatically. In addition , the number of subtre es to be processed is reduced in the subtree validation phase using instance statistics and taxonomic analyzer. The subtrees are matched by the key(s) first and the remaining subtrees are matched by finding degrees of similarity in content and structure. To obtain improved similarity comparison results , XML element names are transformed according to their semantic similarity. The results show that the clustering points are selected appropriately and the overall execution time is reduced dramatically.
 H.2.8 [ Database Management ]: Database Applications  X  Data Mining H.3.3 [ Information Storage and Retrieval ]: Information Search and Retrieval  X  Clustering, Information Filtering, Selection process Measurement, Performance, Verification.
 XML, Similarity measures , Keys, C lustering , Taxonomy Analyzer XML is a standard for data representation and interchang ing of data on the Internet because of its ability to represent data from a wide variety of sources. Data such as DBLP [16] and ACM SIGMOD Record [1] are published and shared using the XML format on the Internet. XML is likely to be the language which can ease integration of data from multiple sources; however, correlating XML data sources has to cope with additional complexities due to the structure of XML documents, which cannot be ig nored. Different data sources may have similar content but may be described using different tag names and structures such as [1, 3] . In this paper, we describe a system based on our research incorporating additional improvement s to XML Document Integration (XDoI ) [13] which considers both the data structure and the content for approximately matching XML documents to integrate XML data sources together using keys. XDoI clusters an XML document into small er subtrees , considered as individual objects using lea f-node parents which may generate a very large number of clustered subtrees due to overlapped subtrees. The large number of clustered subtrees would affect the computational time of comparison in order to find similarities among the subtrees and the result of matching subtrees. To eliminate non -necessary subtrees for comparison , we utilize a taxonomic analyzer to analyze how close element names X  meanings are and transform them into the same category. For example, an XML document contains an element name  X  X  ages X  which has two sub -elements  X  X nitPage X  and  X  X ndPage X  as descendants. These three element names can be categorize d in the same group using the taxonomic analyzer. We also use the instance statistics concept [14] to determine the relationship of element names and keep subtrees that have a one -to -one relationship between XML elements. The system analyzes the information from the results of matching with keys by using improper match es to determine non -appropriate leaf -node parents that are not relevant to the other document in order to be compared during the similarity comparison . The aftermath of the e xperiment shows that the system results in better improvement in the overall computation and still keeps the same result quality . The remainder of the paper is organized as follows. Section 2 presents some background information concerning the XML document integration. Section 3 describes t he overview of the previous work . Section 4 introduces the improved approach and the system architecture of the approach i n details. The algorithm of the approach is defined in Section 5. Section 6 presents the performance results and Section 7 concludes the work. XML documents can be considered as collections of objects. To develop a scalable integration technique for the growing number of XML data sources, XML integration technique generally starts by extracting XML document s into subtrees according to their seman tics. The subtrees are represented as individual objects. The clustered subtrees are evaluated in order to detect the similarity among them. The similar subtrees in structure and semantics are integrated.
 Clustering XML documents automatically into proper objects is challenging. There are existing XML documents clustering techniques such as LAX [9] , SLAX [10], S-GRACE [7] . After clustering XML documents into subtrees , they are compared in order to find subtree similarity . The similarity measurements can be plac ed into one of these three categories: (1) structure similarity, (2) content similarity, and (3) structure and content similarity. There are existing works [2, 3] on structure -oriented similarity which aimed to extract pure structural information from doc uments. Tree Edit Distance measures the minimum number of node insertions, deletions and substitutions which are required to convert one tree into another. Tree Edit Distance assigns a unit cost to each edit operation by default . The edit distance betw een two trees is the smallest cost of transforming tree  X  [18] . This transformation process is computationally very expensive and leads to a prohibitively high run time. Computation al time of the Tree Edit Distance is in  X  (  X   X   X  X  X   X  (  X  ,  X  ) ) time and  X  (  X   X  ) space for a tree with n nodes, l leaves, and depth d . Thus, it is not practical for similarity matching over large XML data repositories . The traditional content similarity methods can be roughly separated into two groups: character -based techniques and vector -space based techniques. Tree Edit Distance can be applied to measure context similarity as well for the character -based technique . This technique relies on character edit operations. The latter group transforms strings into vector representation on which similarity computations are performed.
 The content similarity can be measure d based on the information content of the least common subsume r (LCS) of concepts A and B in a hierarchy . L CS is the most specific concept that is an ancestor of both concepts A and B. These measures include Resnik [12] , Jiang [6] and Lin [11] . These three required a source for information content for concepts such as WordNet . WordNet [5] is a utility program that allows a user to compute information content values from the Brown Corpus, the Penn Treebank, the British National Corpus, or any given co rpus of raw text.
 Liang et al. also proposed the measurement in structure and content similarity in [8] called a path -sequence based discrimination to solve the problem of the one -to -multiple matching problem in leaf -clustering based approximate XML join algorithms. When calculating similarity scores, only identical text nodes are considered and the number of the sam e labels is counted. This method decreases the occurrence rate of one -to -multiple matching . These solutions are easy to implement and g ive interesting results ; however, they experience several limitations. For example, computing tree edit di stance is a ti me -consuming task and so it is not practical for similarity matching over large XML data repositories. Similar arguments also hold for [10] which uses Brute -Force algorithm for comparing path similarity degree s. In this section, we discuss the overview of the previous system using XDoI approach [13 ]. We then focus on how XDoI system outperform s SLAX approac h and address about the drawbacks of XDoI approach which affect the similarity computation perfomance. In our previous work, we have proposed XDoI approach for evaluating the approximate similarity between XML documents. The two XML documents to be integrated are fragmented into subtrees representing independent objects because many real XML documents are constructued by repeating elements. They can be divided into independent subtrees at the repeating elements using leaf -node parents. The XML keys introduced in [4] play a n essential role for subtree matching. They are used to identi fy their own subtree . The key(s) for XML documents are found by observing a leaf -node value match for all unique node values with the same path.
 The subtree similarities are determined by the k ey(s) matching first and then by the tree similarity degrees that measure the approximate similairty between them. The keys in the base subtrees found are used to match with the keys in the target subtrees. Matching the keys of base XML tree and target XML tree dramatically reduce s the number of unnecessary subtree matching s. The non -matched subtrees are evaluated for approximate similarity between them by the subtree similarity degrees based on content and structure of the XML documents . The matched -subtree pairs are determin ed from the maximum similarity degree which is greater than a user defined threshold.
 The entire system approach is to map first XML documents to relational databases and then use SQL queries to execute the following modules: (1) clustering XML documents into independent subtrees using leaf -node parents, (2) finding keys, (3) measuring subtree similarity degrees in content and structure , and (4) matching subtrees. The results of matched subtree pairs are still in the relational databases which are easy to integrate together and output in XML format . XDoI d ivides XML documents into subtree in a data centric manner using leaf -node parents. Our previous experimental results show that there is no missing information after clustering with XD oI. We have implemented SLAX [10] in a relational database manner using XRel [17] in order to support large XML documents. The experiment al results show that SLAX does not perform well for cluster ing the complex XML documents into proper subtrees since its clustering method ignores semantic information . This is because SLAX considers the weighting factor computed from the multiplication of the number of link branches and the depth of the element to define clustering spots. A depth of an element is the dista nce from its furthest child. A link branch is a link between two candidate elements which has at least two subtree can be generated by deleting the link branch below the clustering point . The clustering point is calculated from the maximum weighting factor of the multiplication between the height level and the number of link branches. We found that the clustered subtrees by SLAX may not be appropriate ly clustered subtrees in order to be c ompared with other subtrees fro m the other XML document. We have shown in [13] that SLAX cannot cluster XML documents into proper subtrees for some deep and complex XML structures which cause inaccurate matching results. Clustering XML documents using leaf -node parents can also produce a very large number of subtrees because of subtree overlap. An example from two XML documents are provided : SigmodRecord and DBLP in Figure 1 shows the results of clustered subtree using lea f-node parents which are  X  X ssue X ,  X  X rticle X , and  X  X uthors X . Obviously, there are three overlapped subtrees in the SigmodRecord. The  X  X ssue  X  subtree contains two different levels of subtrees inside which are the subtrees rooted by  X  X rticle X  and the subtrees rooted by  X  X uthors X . A large number of clustered subtrees definitely affects high computation cost for finding similarity degrees. Automatically elimimating non -necessary subtrees is not simple. In order to discard the non -necessary subtrees, we need mor e information to help us decide what subtrees should be removed. In this section , we introduce the improved approach XML Data Integration based on Content and Structure Similarity Using Keys (XDI -CSSK ) and show how the approach can be employed in order to accomplish the problem discussed in Section 3.3 . In addition , we also discuss the system design . We describe the overall of the system architecture of XDI -CSSK that is comprised of four components: (1) XML d ocument storage, (2) Subtree Generat or and Validat or , (3) XML Key Generator, and (4) Subtree similarity components.
 Figure 2 shows the overall architecture of our system. Firstly, XML documents are s tored into a relational database in order to increase scalability and avoid problems from memory restrictions . Secondly, XML documents are clustered into subtrees by using leaf -node parents. The clustered su btrees are verified for subtree integrity in orde r to be compared in the next step by the subtree filter. The subtree filter utilizes the XML instance statistics concept and a taxonomic analyzer to eliminate non -appropriate subtrees before processing the subtree comparison. After filtering subtrees, the similarity components come into the picture in order to determine the similarity in terms of content and structure. This process consist s of three similarity measurements: (1) subtree similarity degree based on based document (SSD1), (2) subtree similarit y degree based on both documents (SSD2) , and (3) path subtree similarity degree (PSSD). The highest similarity degrees of subtree pairs are selected as matched subtree pairs in order to integrate together later on.
 For scalability , the XML documents are loaded into a relational database using XRel [17]. The database is designed to store XML documents and degrees of XML document similarity. XRel decomposes an XML document into nodes on the basis of its tree structure and stored in relational tables according to the node type, with path information from the root to each node. The basic XRel schema consists of the following four relational schemas : Document, Element , Attribut e , Text , and Path shown in Figure 3. Document (docID, value) Element (docID, pathID, start, end, index, reindex) Attribute (docID, pathID, start, end, value) Text (docID, pathID, start, end, value) Path (pathID, pathexp) The database attributes  X  X ocID X ,  X  X athID X ,  X  X tart X ,  X  X nd X  , and  X  X alue X  represent the document identifier, simple path expression identifier, start position of a region, end position of a region, and the string -value respectively. The occ urrence of an element node or a leafnode is identified by its region and stored in the relations Element and Text . To identify each of the attribute nodes, the attribute name is kept as the suffix of the simple path expression of an attribute node and the attribute value is stored in the relation Attribute . The database attribute  X  X athexp X  in the relation Path stores simple path expressions. In order to store leaf -node parents, clustered subtrees and degrees of subtree similarity, we have built three more relations shown in Figure 4.
 The leafnode_parent relation stores path expressions that have leaf -nodes and their parent path expressions. The  X  X athids X  of parent paths can be retrieved from the path relation. The subtree relation keeps the clustered subtrees which are used in similarity comparison later on. Each subtree contains path information; these are the conten t values at the leafnode level and the key flag. The key flag is used to identify unique leafnodes. The subtree_similarity_score relation stores the results of similarity comparison. This similarity measurement attributes are named as SSD1, SSD2 and PSSD d iscussed in the similarity components section earlier. The attribute  X  X atch_type X  identifies a measurement match of each subtree pair. This attribute can be either  X  X SD1 X ,  X  X SD2 X  or  X  X SSD X . The similarity measurement functions are discussed in details in o ur XDoI paper [13]. Leanode_parent (docID, ppathExp, ppathid, pathexp, pathid) Subtree (docID, ppathID, pst, ped,pathid, st, ed, value, key, subtreeid) Subtree_similarity_score (base_docid, base_subtreeid, target_docid, target_subtreeid, ssd1, ssd2, pssd, match_type) These t hree relation s will help in reducing the complexity of SQL queries (reducing natural joins, nested sub -queries, and correlated sub -queries), and minimizing the size of the SQL queries thereby improving the performance of the approach. The subtree generator and validat or procedure is separate d into three sub -procedures: (1) extracting leaf -node parents, (2) validating leaf -node parents using taxonomy analyzer, and (3) clustering XML documents into subtrees The s ubtree generator is implemented in or der to produce small independent items by clustering XML documents into meaningful subtrees. Each clustered subtree represents independent items. A well -clustered subtree requires (1) each subtree to represent one independent item, (2) each independent ite m is clustered into one subtree , and (3) the leaf nodes belonging to that item should be included in the subtree. In some circumstances, fragmenting an XML tree into well -clustered subtrees is not easy . A less difficult way of clustering an XML tree into an independent item is to use leaf -node parents as clustering poin ts because we know the nature of XML documents containing content information at the leaf -node level. As the contents of the XML documents are stored at the leaf -node level, we utilize leaf -node parents as the clustering points to fragment them into subtrees so as to capture the content. The leaf -node parents are found using the SQL query in Figure 5 . SELE CT distinct docid, p.pathid as pathid, pathexp FROM text l, path p WHERE p.pathid = l.pathid The query searches for the paths that contain content at the leaf expressions ) which have content values associated. The returned path expressions from the query are trimmed by removing the last element of the path expressions. The trimmed path expressions are call ed leaf -node par ents X  path expressions. These path expressions are stored in the leafnode_parent relation . The leaf -node parents from SigmodRecord in Figure 1 (a) are as follows: (1) #/SigmodRecord#/issue, (2) #/SigmodRecord#/issue#/articles#/article and (3) #/SigmodRecord#/issue#/articles#/article#/authors#/author The leaf -node parents from DBLP in Figure 1 (b) are: (1) #/dblp#/inproceedings (2) #/dblp#/proceedings Since we employ leaf -node parents as clustering points, the leaf -node parents become the root of the clustered subtrees. A subtree should contain different attributes of an object. It should not have only one kind of information. Thus, we apply the instanc e statistics concept [14] in order to check th e relationship between the leaf -node parent and its children in order to determine whether they preserve a one -to -one relationship . For example, in Figure 1 (a) a subtree  X  X   X  X uthors X  node is the parent of two  X  author X  nodes which are leaf nodes. The  X  X uthors X  node is considered as a root of the subtree which has two  X  X uthor  X  nodes as children. This subtree obviously does not contain a variety of information and it is not useful to extract this kind of the subtree representing as an individual object to be compared in subtree similarity measurement. To determine the variety of information, we check the relationship between the leaf -node parents and their children. First, we test whether the children are semantically similar by measuring semantic similarity among the children. We use the Wu &amp; Palmer X  X  metric [15] to measure the similarity between tw o words. This metric takes into account both path length and depth of the least common subsumer based on the lexical database WordNet [5] as the following formula: where s and t denote the source an d target words being compared, depth(s) is the shortest dis tance from root node to a node s on the taxonomy where the synset of s lies, LCS denotes the least common subsumer of the words s and t . If the sim(s, t) is greater than a given threshold, we consi der that both are semantically similar. The words s and t are relabeled to the LCS word instead; for example,  X  X uthor X  and  X  X riter X  are semantically similar and relabeled to their LCS,  X  X uthor X . For the cases when XML element names do not exist in the dictionary, we use the edit -distance similarity instead to measure the similarity ; for example, short form s of initial page,  X  X nitPage X  and end page,  X  X ndPage X  , do not appear in WordNet. We use leaf -node par ents as the clustering points that sometimes can generate a very large number of clustered subtrees which affects the computation time of similarity comparison. DELETE FROM leafnode_parent WHERE ppathexp IN ( SELECT ppathexp FROM leafnode_parent GROUP BY ppathexp HAVING count(pathexp) = 1)
Figure 6: SQL for removing leaf -node parents not having In order to reduce the number of generated subtrees, we apply the concept of instance statistics [14] to check the relationship between the leaf -node parents and their children. The leaf -node parents not having a one -to -one relationship to their children a re removed from the leafnode_parent relation using the SQL in Figure 6.
 The leaf -node paren t #/SigmodRecord#/issue#/articles#/article#/authors#/author in Figure 1 is eliminated at this step . Thus, the remaining leaf -node parents from SigmodRecord in Figure 1(a) are: (1)#/SigmodRecord#/issue, (2) #/SigmodRecord#/issue#/articles#/article and The leaf -node parents from DBLP in Figure 1 (b) are: (1) #/dblp#/inproceedings (2) #/dblp#/proceedings Understandably, if we consider the  X  X uthor  X  node as a leaf -node parent, it would generate subtrees at least equal to the number of subtrees generated by the  X  X rticle  X  node. The remaining leaf -node parents are used to generate subtrees. We consider these subtre es as proper subtrees which contain a variety of information. The subtrees can be generated by the pseudocode in Figure 7 . $record_set = SELECT distinct e.docid, e.pathid as rootsubtree, e.st, e.ed FROM leafnode_parent p, element1 e WHERE p.docid = e.docid AND p.ppathid = e.pathid AND e.docid = $docid ORDER BY e.docid, st for each $r in $record_set{ INSERT INTO subtree(docid, ppathid, pst, ped,pathid, st,ed, key, subtreeid, value) SELECT docid, ppathid, scope_start, scope_end, pathid, st, ed, ' ',subtreeid , value FROM txt1 WHERE docid = $r.docid AND st &gt;= $r.st 
AND ed &lt;= $r.ed) } First, we select the region (the attributes start and end from the element relation) that are covered by each leaf -node parent. The selected regions are matched with the regions in the text relation in order to find all content nodes at the leaf -node level under the leaf -node parent. The content values for each leaf -node parent are grouped together by the attribute  X  X ubtreeid X .
 We categorize clustered subtrees into two different types: (1) simple subtree and (2) complex subtree. The simple subtrees have only leaf nodes under their root. The complex subtrees have one or more subtrees under the root of their subtree with at least o ne leaf node originat ing from their root.
 In Figure 1 , the SigmodRecord document is clus tered into two different levels of subtrees . One is rooted by the  X  X ssue X  node and the other one is rooted by the  X  X rticle X  node. The subtrees rooted rooted by the  X  X ssue X  node are called complex subtrees. Notice there are no subtrees rooted by the  X  X uthor X  node as it is dismissed after va lidating leaf -node parents. Key is a unique value that can be used to identify a particular item or distinguish items from others. The key of a subtree is modeled as an XML attribute which is one of leaf nodes in a subtree. It has a unique va lue and is able to identify other attributes. We identify the possible key(s) for the XML document by the SQL query in Figure 8 , retrieving unique value s from the text relation that can be used to distinguish ite ms from others . SELECT do cid, pathid, value FROM text GROUP BY docid, PathID,Value HAVING Count(Value) = 1 The leaf nodes returned are considered as a key. We flag  X  X  X  in the attribute  X  X ey X  on the matched records (according to their docid, pathid, and value) in the subtree relation.
 From this point, it is possible that XML documents may not contain a key in some subtrees. It is also possible that an item in either base or target XML tree has a key but the same ite m may not appear in the other XML tree. In addition, a subtree may have multiple alternate keys. Consequently , subtree matching using key(s) may cause one -to -multiple matching . We continue in order to find the best matching for this case by comparing rest of the subtrees. However, a key(s) , wherever available , helps to reduce the number of matching subtree s. We separate this procedure into two sub -procedures: (1) matching subtrees with keys and (2) matching subtrees using similarity measurements based on XML content and structure.
 We take advantage of key(s) found in Section 4.1.4 by matching subtrees in order to find out the best matched subtree pairs. We then use subtree similarity measurements to compare the rest of non -matched subtrees. First the subtrees from the base and target document s are matched by key(s) generated from the key generator section using the SQL in Figure 9 . We match them by comparing the leaf -node values which are marked as  X  X ey X . The results of matched subtrees using key(s) are stored in a temporary table called v_key_match . This table will be used to find characteristics of subtree matching later on. There are two characteristics of subtree matching : (1) one -to -one matching which is considered as the best subtree -pair match and (2) one -to -multiple matching which can occur due to the multiple alternate keys mentioned earlier. The results of matched subtree pairs (one -to -one) are then stored in the subtree_similarity_score relation and flagged as  X  X ey X  in order to distinguish the match type from the other similarity comparison. For the matched subtree pa irs categorized as one -to -multiple matching, we analyze them to find out non -necessary leaf -node parents that are not appropriate to be compared with the subtrees in the other document. The subtrees generated from the leaf -node parent #/SigmodRecord#/issu e in Figure 1 (a) should not be compared with the subtrees in Figure 1 (b) as they are different kinds of entities. SELECT DISTINCT s1.docid as base_docid, s1.subtreeid AS base_subtreeid, s2.docid as target_docid, s2.subtreeid AS target_subtreeid FROM subtree s1, subtree s2 WHERE s1.docid = docid of the base document AND s2.docid = docid of the target document AND (s1.KEY = 'Y' AND s2.KEY = 'Y') AND s1.VALUE = s2.VALUE SELECT 'doc_base' as doc_type, base_docid as docid, base_subtreeid as subtreeid, count(*) as match_cnt FROM v_key_match GROUP BY base_docid, base_subtreeid HAVING count(*) &gt; median # of alternate keys in the base document UNION SELECT 'doc_target' as doc_type, ta rget_docid as docid, target_subtreeid as subtreeid, count(*) as match_cnt FROM v_key_match GROUP BY target_docid, target_subtreeid HAVING count(*) &gt; median # of alternate keys in the target document
Figure 10 : SQL query for finding multiple matched subtrees SELECT distinct docid, ppathid FROM subtree MINUS SELECT distinct v.docid, s.ppathid FROM v_key_manymatching v, subtree s WHERE v.docid = s.docid and v.subtreeid = s.subtreeid Figure 11 : SQL query for finding proper leaf -node parents In order to reduce the number of one -to multiple matching , we analyze the matching information, the results from the SQL in Figure 10, to find out non -necessary leaf -node parents generating subtrees that cause excessive multiple matching s. The SQL in Figure 11 returns only the path expression of leaf -node parents that have the number of subtree matching s less than the median number of al ternate keys. These leaf -node parents are taken into account as proper clustering points. Thus the clustered subtrees not rooted by these proper clustering points are dropped from this point onwards.
 The complex subtree like the subtrees rooted by the  X  X ss ue X  node intends to contain many alterna te keys since the keys from each article subtree are the part of the issue subtree. The leaf -node parent #/SigmodRecord#/issue in Figure 1 (a) is dismissed. Therefore, the subtrees need to be compared in the further step are the subtree rooted by : For SigmodRecord in Figure 1 (a) is: (1) #/SigmodRecord#/issue#/articles#/article and For DBLP in Figure 1 (b) are: (1) #/dblp#/inproceedings (2) #/dblp#/proceedin gs The remaining subtrees are measured in both the content and the structure of the base and target XML trees by comparing PCDATA value (content approach) and signatures (structure approach) to decide which subtrees are the proper match. We use three similarity components in order to compute similarity degrees in contents and structures using Subtree Similarity Degree based on the base document (SSD1), Subtree Similarity Degree based on the both documents (SSD2) and Path Subtree Similarity Degree (PSSD). Subtree Similarity Degree based on the base document (SSD1) is the percentage of the number of leaf nodes having the same PCDATA value out of the total number of leaf nodes in  X   X  and  X   X  X  X  be two subtrees from the base document and target document respectively and a ssume  X  n is the number of leaf nodes having the same PCDATA value and  X   X  X  X  represents the number of leaf nodes in  X   X  X  X  . SSD1 can be calculated using the formula. SSD2 is the ratio of common matched leaf -node values between the base and target subtrees. It can be written as: Where  X   X  X  X  is the number of leaf nodes in the target subtree. For scoring rule each common node is worth 1 point and a common node defined as a key is worth 2 points. The scores SSD1 and SSD2 of all remaining subtree pairs are calculated and stored in the subtree_similarity _score relation. We select the matched pair by selecting subtree pairs having the highest similarity score. However, the one -to -multiple matching may happen. To find out which subtree pair is the best match, we measure similarity on the signature of match ed leaf -node values using Path Similarity Degree (PSD). Before performing path similarity measurement s, we semantically transform XML element names of the both XML documents , using LCS discussed in Section 4.1.2.2.1 in order to get mo re precise similarity results . Path Similarity Degree (PSD) is the ratio of common labels N on paths from the base and target subtrees having the same PCDATA value to the number of path elements in the base subtree . Path Subtree Similarity Degree (PSSD) is an average of Path matched leaf node paths in the base subtree between 1 to  X  paths. The matched subtree is defined as the pair of subtrees that has the maximum subtree similarity degree in terms of content and structural similarity which is greater than a given threshold . In this section, we discuss the system design , the requirements of the system and how the system has been implemented. Java 5.0 ( JDK 5) and Oracle 10G are selected as a programming language and a relational database respectively . XRel exploits the functionalities of the validating XML parser and SAX (Simple API for XML) in order to convert XML document s into the relati ons mentioned in Section 4.1.1 using JDBC to connect with the database. For the interface, the XML documents are parsed by the Java API for XML Processing (JAXP) which enables applications to parse, transform, validate and query XML documents using an API independent of a particular XML processor implementation. The XML docume nts are then displayed in a tree data structure by JTree. Our approach from Section 4 written in a pseudocode is given in Figure 12 . This algorithm is processed after XML documents are parsed into a relational database. There are three main modules: (1) subtree generator and validat or , (2) key generator, and (3) subtrees matching by similarity component s. The inputs of this algorithm are two XML documents stored in a relational database. First , the XML documents are fragmented into small subtrees using leaf -node parents. In Module 1, we find leaf -node pa rents and validate them using the taxonomy analyzer and the instance statistics concepts before clustering the XML documents into subtrees. We then generate subtrees using the generated leaf -node parents.
 All possible key(s) are found in Module 2. They are used to identify their subtree s. At this point, the subtree relation is updated by marking the attribute  X  X ey X  as  X  X  X  discussed in Section 4.1.4.
 In Module 3, subtree matching, we separate this module into two sub -modules : Module 3.1 and Module 3.2 . First, the clustered subtrees from the both base and target documents are compared by the identified key(s) in the function  X  X atch_with_key() X  . The results of the matching with key(s) can possibly be the best matched subtree s or multiple matched subtrees. The best matched subtrees are stored as the outputs. Multiple -matched subtrees occur when the subtrees have more than one alternate key. These subtrees are not considered as the best matched subtrees. The results of multiple matched subtrees are analyzed by the function  X  X ind_proper_leafnode_parent X  in order to find and eliminate non -relevant subtrees by comparing with the median number of alternate keys per subtree . These non -relevant subtrees no longer count as subtrees so they are removed from the subtre e relation . The remainder of non -matched subtrees and multiple -matched subtrees from th is module are determined to find subtree similarity degree s in Module 3.2.
 Algorithm XDI -CSSK Input: XML document tree T b and T t Output: Set of matched subtree pairs {(t bi ,t tj )} base document tree temporary table and MaxSim &gt;  X  ){ //Count the number of maximum similarity degrees For Module 3.2, the remaining subtrees  X   X  X  X  from the base document tree  X   X  are selected . Each subtree is compared with the remaining subtree s  X   X  X  X  from the target document  X  subtree similarity degree s ( SSD1 and SSD2 ). The maximum subtree similarity degree s (MaxSim) for each subtree  X  stored in a temporary table in order to discover the best match later on. The best match is defined as a subtree pair (  X  which has a maximum subtree similarity degree and its similarity degree is greater than a user defined threshold  X  . In the cases when we have more than one pair having the same maximum subtree similarity degree which is greater than the defined threshold after calculating SSD1 and SSD2, path subtree similarity degree (PSSD) is computed for those pairs and the best matched subtree is selected from the maximum path sub tree similarity degree.
 From this point, we have the best matched subtree pairs as the outputs. They can be joined together in order to integrate them. It is not difficult to join the matched subtrees since they are stored in a relational database. In this section we exhibit our improvement in terms of XML document clustering and similarity comparison. We conducted experiments by comparing XML documents from Sigm odRecord [1] and DBLP [16]. We used the same data sets from the XDoI X  X  experiments which are SigmodRecord and portions of 700 KBs of DBLP. Three random ly selected fragments of DBLP from the XDoI X  X  experiments are used in the experiments named DBLP1, DBLP2 and DBLP3. The first document pair is SigmodRecord and DBLP1, the second pair is SigmodRecord and DBLP2, and the third pair is SigmodRecord and DBLP3.
 First, we stored the XML documents into an Oracle 10G database using XRel [17]. Parsing and storing are the two steps of storing XML documents into a database. The parsing and storing time of the XML documents are shown in Figure 13 using the vertical axis with log scale. They took less than 41 seconds to complete both processes.
 Second, we evaluated the dif ference of the clusterings between XDoI X  X  and XDI -CSSK X  X . Table 1 shows the results of clustering points and the number of clustered subtrees from XDoI and XDI -CSSK. This is obvious that the number of clustered subtrees on SigmodRecord from XDI -CSSK is les s than XDoI X  X . The validation of leaf -node parents and the information from multiple matching using keys assists the system to find out non -necessary leaf -node parents. Therefore, only proper and relevant subtrees are left to be measured.
 We did conduct ex periments to see the result quality and the overall execution time in computing including clustering, finding key(s), measuring similarity and matching in both approaches . We ran both the approaches with three pairs of the fragments from the two documents. The similarity thresholds for the experiments are given as 0.7 % and 0.5%. We define the result quality of subtree matching as  X  =  X  X   X  X   X  , where Sn is the number of matched subtrees by a given approach and An is the number of actual matched subtrees. The qualities of the results shown in Figure 14 from the both approaches are identical since they use the same similarity measures. Figure 14 shows that the higher threshold is defined, the higher quality we get. Figure 15 depicts the results of XDI -CSSK X  X  an d XDoI X  X  overall execution time. XDI -CSSK outperforms XDoI approach because XDI -CSSK is able to eliminate non -appropriate subtrees using subtree validation and information from the results of multiple matchings using keys. In addition, the finding commonal ity of content using SQL queries on indexed relations improves the performance in terms of computation time. Notice that t he third pair in Figure 15 requires more execution time because the number of clustered subtree comparisons is higher than the number of subtree comparisons in the first two pairs shown in Table 2. In this paper, we have described the XDI -CSSK, a system that finds semantic similarity degrees using the XML key concept, XML content and XML structure. Major challenges in XML int egration are how to identify proper subtrees representing individual objects and how to define and eliminate non -necessary clustered subtrees which are the main factors causing high computation in the similarity measurements. We utilize leaf -node parents as clustering points and validate them using the instance statistics and a taxonomy analyzer. We also use the information from the results of subtree matching using the defined key s to purge non -related subtrees to the other document. Matching subtrees with the keys and validating subtrees by eliminating non -necessary subtrees reduces certainly the workload of the system in terms of subtree similarity comparison. From the experim ents, XDI -CSSK works effectively with the bibliography documents: SigmodRecord and DBLP. We believe that XDI -CSSK can possibly work well with other domains and different types of XML schema trees such as shallow, deep, etc . We have applied taxo nomy of concepts in order to determine the structural similarity (path similarity) from XML element names but the comparison in content similarity for XDI -CSSK is still a string matching technique which may not reveal exactly how similar the two strings ar e. For the future work, we would like to focus on finding the content semantic similarity by applying the taxonomy of concepts with acceptable execution time in results . In addition, we would like to expand the scope of comparison between only two XML docu ments to different versions of two XML documents. [1] ACM SIGMOD Record in XML. Retrieved March 2006. DOI= [2] Augsten, N., Bohlen, M., &amp; Gamper J. 2005. Approximate [3] Bille, P. 2003. Tree edit distance, alignment distance and [4] Buneman, P., Davidson, S., Fan, W., Hara, C., &amp; Tan, W. 2002. [5] Christiane, F. 1998 . WordNet: An Elect ronic Lexical Database. [6] Jiang, J., &amp; Conrath, D. 1997. Semantic similarity based on [7] Lian, W., Cheung, D. W. -l., Mamoulis, N., &amp; Yiu, S. -M. 2004. [8] Liang, W., &amp; Yokota, H. 2006. A path -sequence based [9] Liang, W., &amp; Yokota, H. 2005. LAX: An Efficient Approximate [10 ] Liang, W., &amp; Yokota, H. 2006. SLAX: An Improved Leaf -[11 ] Lin, D. 1998. An info rmation -theoretic definition of similarity. [12 ] Resnik, P. 1995. Using information content to evaluate semantic [13 ] Viyanon, W., Madria, S. K., &amp; Bhowmick S. 2008. XML Data [14 ] Weis, M. 2005. Fuzzy Duplicate Detection on XML Data. In [15 ] Wu, Z., &amp; Palmer, M. 1994. Verbs semantics and lexical [16 ] XML Version of DBLP. Retrieved May 2006 . [17 ] Yoshikawa, M., Amagasa, T., Shimura, T., &amp; Uemura, S. 2001. [18 ] Zhang, K., &amp; Shasha, D. (1989). Simple fast algorithms for the 
