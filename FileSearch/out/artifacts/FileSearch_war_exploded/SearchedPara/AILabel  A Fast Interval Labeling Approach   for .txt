 In recent years, graph model is getting increasingly popular with many new applica-tions such as computational biology, computer networks and ontology management. How to efficiently answer reachability quer ies has attracted lots of interests[1]. 
There are two classical reachability computation approaches. One is to employ a depth-first search (DFS) or breath-first search (BFS) on the original graph rather than constructing indexes. Its computation complexity is O( m + n ) in the worst case, where n and m denote the number of the nodes and edges respectively. The other is to pre-answered in O(1) time. However, the transitive closure requires a quadratic space complexity. Because of the large index size and the high computation complexity, the two approaches face the bottleneck of scalability for handling large graphs. 
In order to efficiently solve this problem, quite a few graph approaches have been proposed[2-13]. All these approaches lie between the two classical computation query time. Compared with the classical approaches, existing approaches can be extended to larger graphs. However, these approaches still have their own limitations. Besides, most approaches are not designed for dynamic graph. proach D-AILabel handling dynamic graph. AILabel not only can scale the existing D-AILabel can handle dynamic graph effectively. We make the following contributions:  X  We design a novel interval labeling approach AILabel. The index construction time is O( m + n ) and the query time is O( m -n ).  X  We propose four filtering optimizations to improve AILabel.  X  We propose D-AILabel index to answer the reachability in dynamic graphs.  X  Our experiments show the high efficiency and scalability of AILabel and effective-ness of D-AILabel. The paper is organized as follows. Section 2 introduces related work. Section 3 gives some basic concepts. Section 4 proposes AILabel index, including index construction, querying, and optimization. Section 5 discusses dynamic graph index D-AILabel. paper. Existing approaches processing reachability queries can be classified into two catego-ries: hop labeling approaches and interval labeling approaches. 
Hop labeling approaches encode the reachability information on the nodes. Each proach. The approach selects some intermediary nodes as hop nodes to encode the reachability information. However, 2-hop labeling approach takes high computational complexity. Naturally, a number of improved approaches are further proposed[3-5]. 
The other category is interval labeling approaches. Inspired by [14], Optimal Tree-mation, additional interval label is required to store the information of non-tree edges. Optimal Tree-cover is hard to be applied to large graphs, although an optimization to labeling approach designed for processing sparse graph. With the graph getting dens-er, the construction and storage of index become larger and the performance becomes worse. 
GRAIL[9], Ferrari[10], GRIPP[11] and RIAIL[12] are all interval labeling ap-proaches, and they are closely related to our method. GRAIL is an approximate inter-val labeling approach that has good performance dealing with negative queries. While Inspired by GRAIL, Seufert S et al.[10] proposed Ferrari. A tradeoff between the number of labels and practical memory space is given. While both GRAIL and Ferrari need to store index and original graph in memory to keep efficiency. Further Yes-Label[13] is proposed to reduce operations on original graph. A novel indexing struc-original graph cannot be stored in memory simultaneously. Different from GRAIL and Ferrari, in GRIPP, some nodes have replicated storage with extra intervals. Thus, when the query cannot be answered directly, the query is decomposed into a series of queries. Because of the iterative query, the query time of GRIPP is higher than O( m -Besides, the optimization of GRIPP can be also leveraged in RIAIL to speed up negative queries. 
Optimal Tree-cover[6] and DAGGER[15] are both designed for handling dynamic efficiency after a certain update operation. But DAGGER induce the update of all the ancestor nodes of the new update nodes. Thus, each update will cost longer time. Both of the two approaches have their own limitations in dealing with dynamic graphs.  X  Tree edge and Non-tree edge: Given a span ning tree of the graph, all the edges are edges not in the spanning tree (non-tree edges). 
There are two main interval labeling types: [ pre , post ], where pre and post are pre-min_pre is the minimum pre of all the descendant nodes in original graph. special node and the ending node as hop node. spanning tree, then we denote the ending nodes of non-tree edges starting from w as the hop nodes of u .  X  The special nodes of u : we denote all the special nodes which are the descendants of u in the spanning tree as the special nodes of u . We use an example to demonstrate the definition. In Fig. 1, we employ a depth-first nodes of B are G and K , and the special nodes of B are F , I , J and H . In this paper, we just discuss the situation of Directed Acyclic Graphs (DAGs) in the absence of special statement, because a di rected graph can be transformed into DAG after folding each Strongly Connected Component (SCC) into a single node. Besides, we assume that there is at most one edge between a certain pair of nodes. 4.1 B-AILabel Index query, GRIPP performs not satisfying. To reduce the iterative times, a directly way is to assign a set of hop nodes to each node. Thus, we propose B-AILabel. Each node is in Section 3 and hops is the set of hop nodes of the certain node. 
To get B-AILabel index, we start at each root node. During the depth-first traversal through the tree edge. Thus, B-AILabel index can be generated through a single tra-versal, and the construction time is O( m + n ). Unfortunately, to get hops set, we need to put the children X  X  hops into their parents. This will increase index construction time greatly with the increase of non-tree edges. 4.2 AILabel Index To solve the shortage of B-AILabel, we propose AILabel. Each node is assigned a in definition. If v is a special node, we regard all the hop nodes of v that connected to B-AILabel. can be easily gotten. For hops , when a node v is visited through a non-tree edge starting ed to all its ancestor nodes X  directs . Table 1 shows AILabel index of G dag in Fig. 1. Theorem 1. There is no duplication in directs of any node. 
Proof: Assume that directs of node u contains a duplicate node q . According to the description of directs , there must be two different paths from node u to node q in the coming edges in the spanning tree, which is contrary to the property of spanning tree. According to Theorem 1, there is no need to perform extra set merging operation. The index construction time of AILabel is also O( m + n ). As we release the set merg-ing operation, AILabel has better performance than B-AILabel in fact. But it is hard upper bound of index size. Lots of experiments demonstrate that index size of AILabel is less than B-AILabel in most datasets. 
Following we will show how to answer reachability query whether u is reachable to v using AILabel. The process has two steps as follows: reachable to v . Otherwise, carry on next step. reachable to v . Otherwise, u is unreachable to v .  X  Type 2: The queries are whether the nodes in u  X  X  directs can reach v . These que-swered through the second step. After iteratively querying, the answer is got negative. 4.3 Optimization To improve the performance, we propose the following four filtering optimizations:  X  Optimization 1: Identify Duplicate Queries. Lots of duplicate queries will be generated in the second step, thus duplicate removal should be computed thrice. Hence, we employ a set to store the visited nodes. Before generating new queries, search the set and check whether it has been answered before.  X  Optimization 2: Reduce Interval Containment Judgment. If a new query is generated by directs , the query just need to be answered through the B  X  X . And because we have got that the interval of C is not contained in B  X  X , there is no need to repeatedly query Q ( I , C ) through the first step.  X  Optimization 3: Approximate Interval Labels. This optimization is good at dealing with the queries with negative answers. We adopt [ min_pre , post ] interval labeling method defined in Section 3. For a certain node pair reach v . Otherwise, if contained, we need to do the normal querying.  X  Optimization 4: Level Filter[14]. We assign level=0 to the root nodes. And levels of the other nodes are the maximum smaller than v  X  X , v cannot reach u . B-AILabel and AILabel introduced above are both working on static graphs. Neverthe-less, graphs are not always static in practical applications such as twitter and Facebook. Hence, how to deal with graph update operations is a great challenge. In this section, we further propose D-AILabel, an approach that can handle dynamic graphs efficiently based on AILabel. For the reason that the updates on original graph can be transformed into the updates on DAG, we simply discuss the updates on DAG in this paper. 5.1 D-AILabel Index post , hops , directs have the same definitions as those in AILabel. For the root nodes that have no parent nodes, its tree_parent sets -1. Thus, D-AILabel can be also con-Figure 1, the value of the rest attributes is the same as those in Table 1. 5.2 Querying D-AILabel There are four types of update: node insertion, node deletion, edge insertion and edge insertion just need to set index on the new node, we just consider two situations: edge insertion and edge deletion. Edge Insertion. 
There are four cases when an edge ( u , v ) is inserted into DAG:  X  Case 1: Both u and v are not isolated nodes in DAG.  X  If v has no parent node, ( u , v ) must be a tree edge. And:  X  If v has a parent node, ( u , v ) must be a non-tree edge. And:  X  Case 2: u is not an isolated node and v is an isolated node. 
The new edge ( u , v ) must be a tree edge. Thus, we add ( u , v ) into the spanning tree and recall a new traversal to refresh the intervals.  X  Case 3: u is an isolated node and v is not an isolated node.  X  If v has no parent node. The operation can refer to Case 1.  X  Case 4: u and v are both isolated nodes. 
We add ( u , v ) into the spanning tree and assign the interval of u and v as [ maxid +1, maxid +4] and [ maxid +2, maxid +3] separately. u  X  X  tree_parent sets v . Edge Deletion. 
We divide edge deletion ( u , v ) operations into following two cases:  X  Case 1: The edge ( u , v ) is a tree edge. 
We delete v from directs of u and u  X  X  ancestor nodes in the spanning tree. And set u  X  X  tree_parent as -1, which means that v has no parent node in the spanning tree. 
Then we will relabel the spanning tree whose root is v . according to whether ( u , v ) is the only non-tree edge outgoing from u .  X  ( u , v ) is the only non-tree edge outgoing from u : 
After ( u , v ) is deleted, u is no more a special node. Thus, we delete u from directs delete v from the hops of u .  X  ( u , v ) is not the only non-tree edge outgoing from u : from u . And we just need to delete v from u  X  X  hops . In our experiments, all approaches are implemented using C++. And all the experi-ments are performed on the computer equipped with Intel Quad-Core i7-2600 CPU at 3.40DHz and 4GB of main memory. The operating system in use is a 64-bit installa-tion of Ubuntu 12.04 LTS with kernel 3.2.0. 6.1 Experiment on Statics Graph  X  Datasets. We conduct experiments on real and synthetic graph shown in Table 3.  X  Approaches. B-AILabel: In order to reduce the index construction time of B-AILabel, we uses hash set to store hops of each node. 
GRAIL and Ferrari: We set the relevant parameters of GRAIL and Ferrari based on the recommendation in original paper. And we got the codes of the two approaches 1 . 
GRIPP: Different from the other approaches, GRIPP is a database-implemented experiments in the same environment as [7] to compare AILabel with GIRPP.  X  Methodology. The metrics we compare on are: index size, query performance and index construction time. Index size denotes the size of all the labels. The type of label is Integer in our experiments; Query performance is the querying time of 100000 queries. In our ex-periment, the 100000 queries are the same to those in paper [14]; Index construction time is the time cost to establish the index. Small Sparse Graph As shown in Fig. 3(a), the index construction time of B-AILabel is almost twice as long as traversal is required. Moreover, GRAIL requires twice traversals, and Ferrari requires an labels on each node. And the query performance is shown in Fig. 3(c). Ferrari has the best The performance of AILabel is much closely to Ferrari, and then comes GRIAL. That is original graph, however AILabel just traverses the non-tree edges. Small Dense Graph other datasets. More non-tree edges are generated, so AILabel takes more space to main-tain directs . However, GRAIL and Ferrari need to put the index and the original graphs in memory simultaneously. Fig. 4(c) shows the query time of the four methods. Query time multiple interval labels on each node which can answer the queries quickly. Large Graph Fig. 5 shows that index construction time of B-AILabel is 2-3 times longer than GRIPP. citeseer and uniprot22m are large sparse graphs. In the experiment, AILabel However GRAIL and Ferrari cannot simply utilize the optimization, because these two approaches need to put the original graph in main memory and there is no more space for additional intervals. For go-uniprot , the performance of AILabel is the best. That is because we cannot store the index of Ferrari and the original graph in memory simultaneously. Thus disc I/O is avoidless, resulting the longer query time. Synthetic Graphs The result is shown in Table 4, Table 5 and Table 6, where -t donates that the query cannot be finished in 5 minutes and -m denotes that the index cannot be constructed in 5 minutes. The index construction time of B-AILabel is 2-4 times longer than AILabel and the index size of B-AILabel is obviously larger than AILabel. Though Ferrari-L and Ferrari-G can construct indexes on 10m2x, but the query time of Ferra-ri-L and Ferrari-G can X  X  be accepted. Because the original graph and the index cannot be stored in the memory together, disc I/O cannot be avoided. Especially, GRAIL failed in dealing with these two synthetic dataset. 6.2 Experiment on Dynamic Graph We utilize some of the datasets in Section 7.1. Each dataset will generate 5000 update ( a , d , e , n are add, delete, edge, node for short respectively.) 
Table 8 shows the average update time. From the result, we can conclude that the needs to set an interval to the new node. In comparison, the other three update opera-relabeling nodes. What X  X  more, the average edge insertion operating time of citeseer changes greatly for different datasets. 
We further test the scalability of D-AILabel in Fig. 6 and Fig. 7. In the experiment of Fig. 6, we set the amount of nodes to a fixed number 50000 and change the average domly. From Fig. 6, we get the conclusion that when the average degree is less than 4, the change of edge insertion is not obvious. This is because that the increase of non-tree edges brings much difficulty. Fig. 7 shows the update performance of D-AILabel with a fixed average degree 2. We range the node amount from 10k to 500k. In par-The update time of node insertion stays stable. Combining the result from Fig. 6, we conclude that the average update time of D-AILabel mainly depends on the average degree of the DAG. Reachability query is a basic issue in the management of graph data. With the devel-How to adapt to these changes and answer reachability queries accurately, rapidly and extensively is a very important issue. Therefore, we propose an approach AILabel that can answer reachability queries on static graphs and also propose D-AILabel dealing bility of D-AILabel are also demonstrated. But AILabel cannot be expanded to the queries with label constraint in the future work. Acknowledgement. This work is supported by the National Basic Research 973 Pro-gram of China under Grant (2012CB316201) and the National Natural Science Foun-dation of China under Grant (61033007, 61472070). 
