 1. Introduction tection tool is a necessity.
 There are two types of XML documents; data-centric and document-centric. Data-centric is structured data wrapped inside document-centric XML change detection, where  X  round-tripping [31] for storing XML documents which uses a fixed relational schema to help in the change detection process.
The change detection algorithms (GNU Diff, HTML Diff) and [7] based on Longest Common Subsequence (LCS) [17] are not unordered XML documents.

Our approach, XREL_CHANGE_SQL, uses SQL queries over an XRel model to detect changes between two unordered XML doc-based comparison algorithms, in XRel_Change_SQL the memory requirement is independent of the size of the XML documents. subtree algorithm that uses both a bottom-up and a top-down approach as well as keys to reduce the matching space and dered trees is NP-Complete [32] .

XRel_Change_SQL follows a modified definition of optimal delta defined in X-Diff. X-Diff defines the quality of the delta as the minimum-cost edit script (operations) that is required to transform one XML version into another.  X  proach outperforms X-Diff on the result quality when the change ratio is more than 20%. concludes the paper with a summary and directions toward future work. 2. Related work
The algorithm MH-DIFF [8] uses minimum edit operations over structured data which can be applied to data without node identifiers. However, a node in an XML document can be distinguished not only by its content, but also by its type (tag names). It has, according to the authors, a heuristic solution with worst-case O (n an average of O (n 2 ) time. A change detection  X  top-down algorithm some domains since the algorithm assumes the existence of an order over all the tags, which constraints the ancestor
XMLTreeDiff does ordered tree to tree comparison in order to detect changes between two XML documents. XMLTreeDiff treats moves as a pair of delete and insert. The cost of XMLTreeDiff is at least O (N differences between DOM representations of XML documents. DOM is simple to use, it is relatively slow and cannot handle a deletion and an insertion of a subtree is only considered as a modification (update) of values. DeltaXML is a commercial tool for detecting both ordered and unordered changes between two XML documents. By default, the XML document using the eXtended Stylesheet Language (XSL) and adding two attributes named and therefore, it is mainly suited for the document-centric XML.

WebCQ [16] is a prototype system for large scale WWW information monitoring and delivery. WebCQ has a change detection moderate scalability and performance improvement when comp ared with other ordered tree-based algorithms like XyDiff. XANDY is an approach for detecting unordered changes between two XML documents using a relational database model called However, using iterative SQL in a relational database is against the SQL design guidelines. the number of nodes in the XML document#1and T2 is the number of nodes in the XML document#2.
In summary, our work here considers the much harder problem of detecting changes between two unordered XML data ver-are not possible using X-diff or DeltaXML tools. 3. Preliminaries: XML storage schema ments. The basic XRel schema uses paths as a unit of decomposition of the XML trees. For each node, an XML data model instance, XRel stores the information on the path from the root node to all other nodes as
Consider the example in Table 2 where the node  X  issue  X  is a descendant from the  X 
SigmodRecord  X  node. XRel will store the  X  issue  X  node signature as might share the same path, storing only the simple path expressions may lead to a loss of precedence relationship among an element are essential for our SQL-based unordered change detection algorithm. data as shown in Table 2 .
 documents are stored in the relational database tables shown in Tables 3, 5a, 5b, and 5c ). The
Docid (to distinguish each XML document) and the whole document under the
The versions. The database attribute Value represents a string-value.
 tree as tuples, thus preserving the information of the topology of the XML tree and expanded-names of nodes. (St), and End (Ed) is a key of the relations  X  Element  X  and also provide definitions for the insert, delete, update and move operations. 3.1. Modi fi ed XRel database schema
We have modified the XRel implementation by adding two additional columns in the (XRel_Change_SQL). It also facilitates XML queries issued against the underlying database as shown in Section 5 . with its parent start region begins at 0 (Pst=0). All leaf node values are stored in the
The  X  Attribute  X  Table 4 (c) keeps all attribute values. The structure of this table is similar to the attribute which is equal to 152,033. Values of attributes are treated the same way as values of text (leaf node). 4. Change detection
Given any two document-ids (Docid), XRel_Change_SQL detects unordered changes between the two versions of XML docu-duplicated instances in the same document, so it should not have the same finally detection of deleted, inserted or updated leaf nodes.
 from the  X  Subtrees  X  table, (c) applying the prefix closed property ( If the node pair (x,y) tinct matching complex subtrees and pure subtrees (subtrees with only non-leaf nodes are called Pure subtrees). table (explained in Section 4.1 ).
 of the algorithm, then the set (S1  X  M1) will be detected as deleted subtrees and the set (S2 region. (b) Let D1 and I1 be the sets of all matched leaf nodes from the tively. The set (D1  X  M1) will be detected as leaf node delete candidates and the set (I1 same matching parents, but their values are not equal. 4.1. Pre-processing
We do some pre-processing on the two versions of the XML document and store the results in temporary database tables to
The  X  the subtree elements and store them in a separate temporary table called gether in another temporary table called  X  Leafnodes  X  . The relational schema of these two tables is shown as follows: Subtrees (Docid, Pathid, Start, End, Index, ReIndex, Ppathid, Pstart, Pend, Pidx, Preidx, Flag); Leafnodes (Docid, Pathid, Start, End, Index, ReIndex, Ppathid, Pstart, Pend, Pidx, Preidx, Flag); tion describes in detail the four phases of our change detection algorithm along with the change detection SQL queries. 4.2. Phase I: fi nding matching subtrees
XRel_Change_SQL is primarily based on identifying the key for every Leaf node's parent . best match, even if there is no key(s) identified in step 1.
 key. We classify these cases of finding a complex key as follows: a. A combination of attributes may be the key b. A combination of text elements may be the key c. A combination of attributes and text elements may form the key detection process.

De fi nition 1(a). Finding matching leaf node parents ing leaf node's parents iff a. S1 and S2 have the same node signatures i.e., Pathid(S1)=Pathid(S2). duplicates in order to reduce the subtree matching space. A
The performance of the  X  update  X  query (query 1) will depend on the character lengths of the values in the notes the document id of the second version of the XML document.
 vided in Table 6a . By matching unique values defined in Definition 1 (a), we find that for the
De fi nition 1(b). Similarity score for matching leaf node parents
Let P be the set of matching leaf nodes' parents found using Definition 1 (a). Every pair (x,y) equal to the  X  match-count  X  divided by their total number of children: where,  X  m  X  is the  X  match-count  X  for the leaf node parent match (x,y) and  X  x  X  and  X  y  X  .

The next step is to find the unmatched leaf node parents from the more leaf node matches within the unmatched leaf node parents.

Example : In the example provided in Fig. 1 , unmatched leaf node parent will provide only one follows both the bottom-up and top-down approaches for finding the matching leaf node parents. vided in Table 2 , this step will match the common  X  articles node parent subtrees. Queries 3 to 9 in Table 8 are for matching subtrees. parents from query2. This approach separates the  X  complex subtrees  X  cally) in cases where a complex subtree has a unique leaf node value match. pure subtrees, the pure subtrees that were not matched earlier, are matched according to Definition 2 (b).
De fi nition 2(a). Similarity score for matching pure subtrees found using Definitions 1a and 1b within their regions. Let subtree regions.

De fi nition 2(b). Matching pure subtrees matching subtrees iff : a. S1 and S2 have same node signatures i.e., Pathid(S1)=Pathid(S2). b. There exists a leaf node parent match p, such that p  X  similarity_score refers to (2a).
In the example in Table 2 (b), consider S1 and S2 to be the subtrees rooted by the node apply Definiton 2(b) for matching pure subtrees. This definition will apply only to the case where we have another of  X  issue  X  . The subtree rooted by the node  X  issues  X  will be matched in this step. tree. The pure subtrees in the example provided in Table 2 (b) are the nodes queries are provided in Table 8 (Queries 3  X  9). The first row in Table 9 shows the similarity score of the root node having six matched leaf-node parents which are the node  X  we update their similarity scores according to Definition 2 (c) given next.
De fi nition 2(c). Similarity score for subtrees with equal similarity scores in their region, i.e., all their descendant subtree's similarity scores. Let tree regions and  X  s i  X  denote the similarity score for the subtree pair prefix closed feature of the subtrees in the XML document. This matching is based on Definitions 3 and 4.
De fi nition 3. Pre fi x closed property: propagate  X  top-down  X  and second versions, respective ly. A pair (p, q) in S2 and S3 are possible matching subtrees iff p parent subtrees.
 in both XML DOM trees are updated with their respective ancestor regions found using Definition 2 (b). Then the best match is found between those subtrees.

De fi nition 4. Pre fi x closed property: Propagate  X  top-down  X  the regions of p and q must be bounded by their matching parent subtrees.
 in both XML DOM trees are updated with their respective ancestor regions found using Definition 2 (b). Then, the proving the performance of XRel_Change_SQL. This step is done by queries 10 we eliminate the duplicate matches and retain only the match that has the highest similarity score. A store the best matched subtrees among all the subtree matches.

This concludes our matching subtree phase using the bottom-up approach based on the unique values match and then top-down approach that propagates matching subtrees from root to leaf nodes; based on the prefix closed property. 4.3. Phase II: subtree moves
In this section, we discuss subtree move candidates, subtree moves and the subtree detecting the move candidates and the final subtree matching are provided in queries 15 in Definition 5 .

De fi nition 5. Subtree moves ing subtrees from Definitions 1 (a) and (b), but eliminated in the final matching subtree table. For all leaf nodes p leaf node q i where Pathid(p i )=Pathid(q i ) and Value(p The move definition states that a subtree can be considered as a move candidate only if it is already matched under
Example : Consider the example provided in Fig. 1 , the order in which an not significant in the change detection, but if an  X  article  X  of a moved subtree in Fig. 4 . 4.4. Phase III: detecting deleted and inserted subtree node(s) leted and inserted subtrees. The subtree delete and insert definition are provided in Definition 6 .
De fi nition 6. Deleted and Inserted subtree nodes and M2 be the sets of matched leaf node parents from Phase-1 of the algorithm, then the set (S1 subtrees and the set (S2  X  M2) will be detected as inserted subtrees.

Table 2 b, SQL query 18 will detect the deleted  X  authors 4.5. Phase IV: detecting leaf node changes (delete, insert and update) ( Fig. 5 ). The SQL queries for finding the exact leaf node value matches among leaf nodes are queries 20
De fi nition 7. Delete and insert candidates be the sets of all matched leaf nodes from the  X  matching be detected as leaf node delete candidates and the set (I1
De fi nition 8. Updated leaf nodes and second versions of the XML document iff  X  leaf nodes p (p)=parent(q) and matching_parent(q)=parent(p) and Value(p)!=Value(q).
 shown in Table 11 and Fig. 6 .
 are provided in Table 12 and Fig. 8 . 4.6. Complexity analysis space complexity of the modified implementation of XRel to store XML documents (Preprocessing). The time complexity for words,  X  N  X  represents the combined cardinality of  X  SubTrees spectively and |L1| and |L2| represent the cardinality of the ument, respectively.
 4.6.1. Time-complexity parent matches are found after matching the unique leaf node values for each first step.
 all the possible subtree matching candidates. The upper bound for the complexity of this step is of the order O (|S1| documents.
 Now consider phases 3 (detecting deleted and inserted subtree nodes) and 4 (detecting leaf node changes) explained in down approach and tries to find a match for all the unmatched leaf nodes from step 1. Let after step 1. In that case, the run time of our algorithm will be linear time i.e., O (|N-S1|) or O (|N-S2|). 4.6.2. Space complexity of modi fi ed XRel ment  X  table and stores the text node values in the  X  Text database schema, the  X  Element  X  table has 6 columns, the be the total number of nodes in an XML document. Let  X  S  X   X 
A  X  5. Performance evaluation
XML change detection algorithms such as X-Diff and XANDY. Note that DeltaXML [11,12,18] requires custom defined keys cluded DeltaXML in our performance evaluation. 5.1. Experimental setup and data sets The XRel_Change_SQL algorithm is implemented using SQL queries on an Oracle 10 g RDBMS. The modified implementation of memory using Windows XP professional edition.

The XRel_Change_SQL implementation is tested using benchmark XML datasets SIGMOD [25] and Washington University [27] are evenly distributed among  X  insert  X  ,  X  delete  X  ,  X  update
XRel_Change_SQL detects changes in unordered XML documents. The ordering of the child nodes in the same level under the the experiments, we set both X-Diff and XANDY to get the  X  5.2. Parsing, storing, and diff time schema has been modified by including the immediate parent information for every node in the against the benchmark dataset provided in Table 14 .

We compare large XML documents with shallow and semi-shallow depths from the datasets mentioned in Table 14 . Fig. 11 shows the execution times for X-Diff, XRel_Change_SQL and XANDY. The change percentage considered is 30% (insert only if one does not consider detecting the move operation which consumes much more additional time. Fig. 11 also shows that XRel_Change_SQL performs much better than XANDY [IDM] for the shallow and semi-shallow documents between lations are eliminated.

Fig. 12 shows the execution times of these algorithms for different change percentages (File Sizes 2 of the number of nodes rather than the change percentage as mentioned in Section 4.6 . this test case is 30% (insert  X  10%, delete  X  10%, update date operations, whereas X-Diff, XANDY and DeltaXML do not identify subtree moves between two unordered XML documents. delta in many cases where the XML documents have keys or duplicates.
 considering  X  nschool2.xml  X  and  X  Mvp_100k_0.xml  X  XML documents, XRel_Change_SQL's performance is much slower for  X  nschool2.xml  X  compared to  X  Mvp_100k_0.xml  X  even though both documents have the same number of elements. However, X-
Diff fails to produce any delta for deep XML documents with more than 35,000 nodes and the performance of XANDY is much approach of XRel_Change_SQL has much better scalability compared to tree-based in-memory XML comparison algorithms (X-base, it is independent of RAM and the number of nodes in XML documents. 5.3. Result quality ity definition than that stated in X-Diff is used. The result quality of the XML delta is evaluated as: where  X  An  X  is the number of nodes in the XRel_Change_SQL delta and provided in Table 15 , the  X  chapter  X  subtrees titled  X  Chapter-2 sion have been deleted and the  X  chapter  X  subtrees titled
Since X-Diff and XANDY define the optimal delta based on the minimal number of change operations, the above mentioned for the change operations.
 titled by Chapter-3, Insert a subtree title by Chapter-4 and Insert a subtree titled by Chapter 5. deletes, 2 subtree inserts and 2 updates. XANDY detects the and subtree insert respectively and detects all the leaf nodes in the
Also, XRel_Change_SQL will detect the changes in the  X  chapter updated leaf nodes, since there is a unique leaf node value match value  X  Normalization  X  is updated to  X  DB applications  X  minimum cost-edit script defined in X-Diff, when considering the subtree insert operation as a basic edit operation. subtree phase (Phase-1).
 and XANDY, the quality may not be optimal for change ratios over 20%. 6. Conclusions and future work able for large unordered XML documents than the in-memory tree-based comparison approaches. For example, XRel_-
Change_SQL performs better than X-Diff for large XML documents, but comparatively slower for XML documents ranging from moves between XML documents, which are not considered in the previous unordered XML change detection algorithms. There-fore, the delta is more accurate, minimal, and the miss ratio is minimal.
The performance of XRel_Change_SQL can still be improved by using user-defined optimization techniques. For example, we study the knowledge discovery, data mining and clustering [1] of semi-structured data using XML deltas [30] .
References
