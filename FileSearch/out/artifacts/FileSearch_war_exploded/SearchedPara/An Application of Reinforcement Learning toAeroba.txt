 Autonomous helicopter flight represents a challenging cont rol problem with high-dimensional, asymmetric, noisy, nonlinear, non-minimum phase dynamics . Helicopters are widely regarded to be significantly harder to control than fixed-wing aircraft. (See, e.g., [14, 20].) At the same time, helicopters provide unique capabilities, such as in-place hover and low-speed flight, important for many applications. The control of autonomous helicopters t hus provides a challenging and impor-tant testbed for learning and control algorithms.
 In the  X  X pright flight regime X  there has recently been consid erable progress in autonomous helicopter flight. For example, Bagnell and Schneider [6] achieved sust ained autonomous hover. Both LaCivita et al. [13] and Ng et al. [17] achieved sustained autonomous h over and accurate flight in regimes achieved vision based autonomous hover and landing. In cont rast, autonomous flight achievements in other flight regimes have been very limited. Gavrilets et a l. [9] achieved a split-S, a stall turn and a roll in forward flight. Ng et al. [16] achieved sustained aut onomous inverted hover.
 The results presented in this paper significantly expand the limited set of successfully completed aerobatic maneuvers. In particular, we present the first suc cessful autonomous completion of the following four maneuvers: forward flip and axial roll at low s peed, tail-in funnel, and nose-in funnel. Not only are we first to autonomously complete such a single fli p and roll, our controllers are also able to continuously repeat the flips and rolls without any pa uses in between. Thus the controller has to provide continuous feedback during the maneuvers, and cannot, for example, use a period of hovering to correct errors of the first flip before performing the next flip. The number of flips and rolls and the duration of the funnel trajectories were chose n to be sufficiently large to demonstrate that the helicopter could continue the maneuvers indefinite ly (assuming unlimited fuel and battery endurance). The completed maneuvers are significantly more challenging than previously completed maneuvers.
 going from the right to the left of the helicopter). To preven t altitude loss during the maneuver, the helicopter pushes itself back up by using the (inverted) mai n rotor thrust halfway through the flip. In the (right) axial roll the helicopter rotates 360 degrees around its longitudinal axis (the axis going from the back to the front of the helicopter). Similarly to th e flip, the helicopter prevents altitude loss by pushing itself back up by using the (inverted) main ro tor thrust halfway through the roll. In of the circle. For the trajectory to be a funnel maneuver, the helicopter speed and the circle radius are chosen such that the helicopter must pitch up steeply to s tay in the circle. The nose-in funnel is similar to the tail-in funnel, the difference being that t he nose points to the center of the circle throughout the maneuver.
 The remainder of this paper is organized as follows: Section 2 explains how we learn a model from flight data. The section considers both the problem of data co llection, for which we use an appren-ticeship learning approach, as well as the problem of estima ting the model from data. Section 3 explains our control design. We explain differential dynam ic programming as applied to our heli-copter. We discuss our apprenticeship learning approach to choosing the reward function, as well as other design decisions and lessons learned. Section 4 des cribes our helicopter platform and our experimental results. Section 5 concludes the paper. Movie s of our autonomous helicopter flights are available at the following webpage: 2.1 Data Collection The E 3 -family of algorithms [12] and its extensions [11, 7, 10] are the state of the art RL algorithms for autonomous data collection. They proceed by generating  X  X xploration X  policies, which try to visit inaccurately modeled parts of the state space. Unfort unately, such exploration policies do not even try to fly the helicopter well, and thus would invariably lead to crashes. Thus, instead, we use the apprenticeship learning algorithm proposed in [3], whi ch proceeds as follows: This procedure has similarities with model-based RL and wit h the common approach in control to first perform system identification and then find a controller using the resulting model. However, the key insight from [3] is that this procedure is guaranteed to converge to expert performance in a polynomial number of iterations. In practice we have needed at most three iterations. Importantly, unlike the E 3 family of algorithms, this procedure never uses explicit ex ploration policies. We only have to test controllers that try to fly as well as possible (ac cording to the current simulator). 2.2 Model Learning The helicopter state s comprises its position ( x, y, z ), orientation (expressed as a unit quaternion), velocity (  X  x,  X  y,  X  z ) and angular velocity (  X  action space ( u can rotate the helicopter around each of its main axes and bri ng the helicopter to any orientation. This allows the pilot to direct the thrust of the main rotor in any particular direction (and thus fly in any particular direction). By adjusting the collective p itch angle (control input u adjust the thrust generated by the main rotor. For a positive collective pitch angle the main rotor will blow air downward relative to the helicopter. For a negative collective pitch angle the main rotor will blow air upward relative to the helicopter. The latter a llows for inverted flight.
 Following [1] we learn a model from flight data that predicts a ccelerations as a function of the current state and inputs. Accelerations are then integrated to obta in the helicopter states over time. The key idea from [1] is that, after subtracting out the effects of gr avity, the forces and moments acting on the helicopter are independent of position and orientation of t he helicopter, when expressed in a  X  X ody coordinate frame X , a coordinate frame attached to the body o f the helicopter. This observation allows us to significantly reduce the dimensionality of the model le arning problem. In particular, we use the following model: By our convention, the superscripts b indicate that we are using a body coordinate frame with the spect to the helicopter. We note our model explicitly encode s the dependence on the gravity vector and inputs. This sparse dependence was obtained by scoring d ifferent models by their simulation ac-curacy over time intervals of two seconds (similar to [4]). W e estimate the coefficients A and E optimized extended Kalman filter, then we use linear regress ion to estimate the coefficients. The terms w perturbations to the accelerations due to noise (or unmodel ed effects). Their variances are estimated as the average squared prediction error on the flight data we c ollected.
 The coefficient D tail rotor. The term E when flying at higher speed. Specifically, during hover, the h elicopter X  X  rotor imparts a downward velocity on the air above and below it. This downward velocit y reduces the effective pitch (angle of attack) of the rotor blades, causing less lift to be produced [14, 20]. As the helicopter transitions into faster flight, this region of altered airflow is left behind an d the blades enter  X  X lean X  air. Thus, the angle of attack is higher and more lift is produced for a given choice of the collective control ( u The translational lift term was important for modeling the h elicopter dynamics during the funnels. The coefficient C zero since (after equipping our helicopter with our sensor p ackages) the center of gravity is further backward than the center of main rotor thrust.
 There are two notable differences between our model and the m ost common previously proposed models (e.g., [15, 8]): (1) Our model does not include the ine rtial coupling between different axes of rotation. (2) Our model X  X  state does not include the blade-fl apping angles, which are the angles the rotor blades make with the helicopter body while sweeping th rough the air. Both inertial coupling and blade flapping have previously been shown to improve accu racy of helicopter models for other RC helicopters. However, extensive attempts to incorporat e them into our model have not led to improved simulation accuracy. We believe the effects of ine rtial coupling to be very limited since the flight regimes considered do not include fast rotation ar ound more than one main axis simulta-neously. We believe that X  X t the 0.1s time scale used for contr ol X  X he blade flapping angles X  effects are sufficiently well captured by using a first order model fro m cyclic inputs to roll and pitch rates. Such a first order model maps cyclic inputs to angular acceler ations (rather than the steady state angular rate), effectively capturing the delay introduced by the blades reacting (moving) first before the helicopter body follows. 3.1 Reinforcement Learning Formalism and Differential Dyn amic Programming (DDP) A reinforcement learning problem (or optimal control probl em) can be described by a Markov deci-sion process (MDP), which comprises a sextuple ( S, A , T, H, s (0) , R ) . Here S is the set of states; A is the set of actions or inputs; T is the dynamics model, which is a set of probability distribu tions time t are s and u ); H is the horizon or number of time steps of interest; s (0)  X  S is the initial state; R : S  X A X  R is the reward function.
 A policy  X  = (  X  tions A , one mapping for each time t = 0 ,  X  X  X  , H . The expected sum of rewards when acting according to a policy  X  is given by: E[ P H ( S, A , T, H, s (0) , R ) is the policy that maximizes the expected sum of rewards. In p articular, the optimal policy is given by  X   X  = arg max The linear quadratic regulator (LQR) control problem is a sp ecial class of MDPs, for which the optimal policy can be computed efficiently. In LQR the set of s tates is given by S = R n , the set of actions/inputs is given by A = R p , and the dynamics model is given by: random variable (with finite variance). The reward for being in state s ( t ) and taking action/input u ( t ) is given by: Here Q ( t ) , R ( t ) are positive semi-definite matrices which parameterize the reward function. It is which can be efficiently computed using dynamic programming . Although the standard formula-tion presented above assumes the all-zeros state is the most desirable state, the formalism is easily extended to the task of tracking a desired trajectory s  X  rather than the actual state s ( t ) . (See, e.g., [5], for more details on linear quadratic metho ds.) Differential dynamic programming (DDP) approximately sol ves general continuous state-space MDPs by iterating the following two steps: In our experiments, we have a quadratic reward function, thu s the only approximation made in the first step is the linearization of the dynamics. To bootstrap the process, we linearized around the 3.2 DDP Design Choices the rotation that transforms the coordinate frame of the tar get orientation into the coordinate frame of the actual state. This axis angle representation results in the linearizations being more accurate approximations of the non-linear model since the axis angle representation maps more directly to the angular rates than naively differencing the quaternion s or Euler angles.
 Cost for change in inputs. Using DDP as thus far explained resulted in unstable control lers on the real helicopter: The controllers tended to rapidly swit ch between low and high values, which resulted in poor flight performance. Similar to frequency sh aping for LQR controllers (see, e.g., [5]), we added a term to the reward function that penalizes the chan ge in inputs over consecutive time steps.
 Controller design in two phases. Adding the cost term for the change in inputs worked well for the funnels. However flips and rolls do require some fast chan ges in inputs. To still allow aggressive maneuvering, we split our controller design into two phases . In the first phase, we used DDP to find the open-loop input sequence that would be optimal in the noi se-free setting. (This can be seen as a planning phase and is similar to designing a feedforward co ntroller in classical control.) In the second phase, we used DDP to design our actual flight controll er, but we now redefine the inputs as the deviation from the nominal open-loop input sequence. Pe nalizing for changes in the new inputs penalizes only unplanned changes in the control inputs.
 Integral control. Due to modeling error and wind, the controllers (so far descr ibed) have non-zero steady-state error. Each controller generated by DDP is des igned using linearized dynamics. The orientation used for linearization greatly affects the res ulting linear model. As a consequence, the linear model becomes significantly worse an approximation w ith increasing orientation error. This in turn results in the control inputs being less suited for th e current state, which in turn results in in PID control X  X e augment the state vector with integral term s for the orientation errors. More specifically, the state vector at time t is augmented with P t  X  1 performed significantly better with integral control. For t he flips and rolls the integral control seemed Factors affecting control performance. Our simulator included process noise (Gaussian noise on the accelerations as estimated when learning the model from data), measurement noise (Gaussian noise on the measurements as estimated from the Kalman filter residuals), as well as the Kalman filter and the low-pass filter, which is designed to remove the high-frequency noise from the IMU measurements. 3 Simulator tests showed that the low-pass filter X  X  latency an d the noise in the state estimates affect the performance of our controllers most. P rocess noise on the other hand did not seem to affect performance very much. 3.3 Trade-offs in the reward function squared inputs, the squared change in inputs between consec utive timesteps, and the squared integral of the error state variables. For the reinforcement learnin g algorithm to find a controller that flies  X  X ell, X  it is critical that the correct trade-off between th ese features is specified. To find the correct trade-off between the 24 features, we first recorded a pilot X  s flight. Then we used the apprentice-ship learning via inverse reinforcement learning algorith m [2]. The inverse RL algorithm iteratively provides us with reward weights that result in policies that bring us closer to the expert. Unfortu-nately the reward weights generated throughout the iterati ons of the algorithm are often unsafe to fly on the helicopter. Thus rather than strictly following th e inverse RL algorithm, we hand-chose reward weights that (iteratively) bring us closer to the exp ert human pilot by increasing/decreasing the weights for those features that stood out as mostly diffe rent from the expert (following the phi-losophy, but not the strict formulation of the inverse RL alg orithm). The algorithm still converged in a small number of iterations. Videos of all of our maneuvers are available at the URL provid ed in the introduction. 4.1 Experimental Platform The helicopter used is an XCell Tempest, a competition-clas s aerobatic helicopter (length 54 X , height 19 X , weight 13 lbs), powered by a 0.91-size, two-stroke engi ne. Figure 2 (c) shows a close-up of the helicopter. We instrumented the helicopter with a Microstr ain 3DM-GX1 orientation sensor, and a Novatel RT2 GPS receiver. The Microstrain package contains triaxial accelerometers, rate gyros, and magnetometers. The Novatel RT2 GPS receiver uses carrie r-phase differential GPS to provide real-time position estimates with approximately 2cm accur acy as long as its antenna is pointing at the sky . To maintain position estimates throughout the flips and rol ls, we have used two different se-tups. Originally, we used a purpose-built cluster of four U-Blox LEA-4T GPS receivers/antennas for velocity sensing. The system provides velocity estimates w ith standard deviation of approximately 1 cm/sec (when stationary) and 10cm/sec (during our aerobat ic maneuvers). Later, we used three PointGrey DragonFly2 cameras that track the helicopter fro m the ground. This setup gives us 25cm accurate position measurements. For extrinsic camera cali bration we collect data from the Novatel RT2 GPS receiver while in view of the cameras. A computer on th e ground uses a Kalman filter to estimate the state from the sensor readings. Our controller s generate control commands at 10Hz. 4.2 Experimental Results For each of the maneuvers, the initial model is learned by col lecting data from a human pilot fly-ing the helicopter. Our sensing setup is significantly less a ccurate when flying upside-down, so all data for model learning is collected from upright flight. The model used to design the flip and roll controllers is estimated from 5 minutes of flight data during which the pilot performs frequency sweeps on each of the four control inputs (which covers as sim ilar a flight regime as possible with-out having to invert the helicopter). For the funnel control lers, we learn a model from the same frequency sweeps and from our pilot flying the funnels. For th e rolls and flips the initial model was sufficiently accurate for control. For the funnels, our init ial controllers did not perform as well, and we performed two iterations of the apprenticeship learning algorithm described in Section 2.1. 4.2.1 Flip In the ideal forward flip, the helicopter rotates 360 degrees forward around its lateral axis (the axis going from the right to the left of the helicopter) while stay ing in place. The top row of Figure 1 (a) shows a series of snapshots of our helicopter during an auton omous flip. In the first frame, the helicopter is hovering upright autonomously. Subsequentl y, it pitches forward, eventually becoming vertical. At this point, the helicopter does not have the abi lity to counter its descent since it can only produce thrust in the direction of the main rotor. The flip con tinues until the helicopter is completely inverted. At this moment, the controller must apply negativ e collective to regain altitude lost during the half-flip, while continuing the flip and returning to the u pright position.
 We chose the entries of the cost matrices Q and R by hand, spending about an hour to get a controller that could flip indefinitely in our simulator. The initial con troller oscillated in reality whereas our human piloted flips do not have any oscillation, so (in accord ance with the inverse RL procedure, see Section 3.3) we increased the penalty for changes in inputs o ver consecutive time steps, resulting in our final controller. 4.2.2 Roll In the ideal axial roll, the helicopter rotates 360 degrees a round its longitudinal axis (the axis going from the back to the front of the helicopter) while staying in place. The bottom row of Figure 1 (b) shows a series of snapshots of our helicopter during an auton omous roll. In the first frame, the helicopter is hovering upright autonomously. Subsequentl y it rolls to the right, eventually becoming inverted. When inverted, the helicopter applies negative co llective to regain altitude lost during the first half of the roll, while continuing the roll and returnin g to the upright position. We used the same cost matrices as for the flips. 4.2.3 Tail-In Funnel The tail-in funnel maneuver is essentially a medium to high s peed circle flown sideways, with the tail of the helicopter pointed towards the center of the circ le. Throughout, the helicopter is pitched backwards such that the main rotor thrust not only compensat es for gravity, but also provides the centripetal acceleration to stay in the circle. For a funnel of radius r at velocity v the centripetal acceleration is v 2 /r , so X  X ssuming the main rotor thrust only provides the centrip etal acceleration and compensation for gravity X  X e obtain a pitch angle  X  = atan( v 2 / ( rg )) . The maneuver is named after the path followed by the length of the helicopter, whic h sweeps out a surface similar to that of an inverted cone (or funnel). 4 For the funnel reported in this paper, we had H = 80 s, r = 5 m, and v = 5 . 3 m/s (which yields a 30 degree pitch angle during the funnel). Figure 1 (c) shows an overlay of snapshots of the helicopter throughout a tail-in funnel.
 The defining characteristic of the funnel is repeatability X  X  he ability to pass consistently through the same points in space after multiple circuits. Our autonomou s funnels are significantly more accurate than funnels flown by expert human pilots. Figure 2 (a) shows a complete trajectory in (North, East) coordinates. In figure 2 (b) we superimposed the heading of th e helicopter on a partial trajectory (showing the entire trajectory with heading superimposed g ives a cluttered plot). Our autonomous funnels have an RMS position error of 1.5m and an RMS heading e rror of 15 degrees throughout the twelve circuits flown. Expert human pilots can maintain t his performance at most through one 4.2.4 Nose-In Funnel The nose-in funnel maneuver is very similar to the tail-in fu nnel maneuver, except that the nose points to the center of the circle, rather than the tail. Our a utonomous nose-in funnel controller performance that is difficult for a human pilot to match. Figu re 1 (d) shows an overlay of snapshots throughout a nose-in funnel. To summarize, we presented our successful DDP-based contro l design for four new aerobatic ma-design decisions for the DDP-based controller to fly our heli copter successfully are the following: We penalized for rapid changes in actions/inputs over conse cutive time steps. We used apprentice-ship learning algorithms, which take advantage of an expert demonstration, to determine the reward function and to learn the model. We used a two-phase control d esign: the first phase plans a feasible trajectory, the second phase designs the actual controller . Integral penalty terms were included to reduce steady-state error. To the best of our knowledge, the se are the most challenging autonomous flight maneuvers achieved to date.
 We thank Ben Tse for piloting our helicopter and working on th e electronics of our helicopter. We thank Mark Woodward for helping us with the vision system.

