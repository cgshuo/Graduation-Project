 1. Introduction level, there are two main issues: entity resolution and conflict resolution [7 separately, few of them consider both in the same setting [12 conflict resolution issue at instance level integration.
 [26 data, and to update incorrect data from heterogeneous sources with user's integration decisions. update propagation. As an example, if one source s 1 storesinformationondateintheformat keeps only the value of  X  year  X  , s 1 may not be properly updated based on the value of s in integration processes, which is used throughout this paper.
 from  X  Integrating ... X  to  X  Integration ... X  ; 2. paper's year is copied from John to Jack ; 3. author copied from John to Jack ;5. pages is copied from John to Mary ; and 6. author actions (i.e., 7 to 10) represent copies, which are similar to actions 2, 4 and 5. detected inconsistencies.  X  decisions to be reproduced in future iterations of the process.
 paper title:  X  X n teg rating... X  year:  X 2009 X  ven ue:  X  X IKM X  p ag es:  X 260-275 X  auth o r auth o r level data integration, so schema integration and entity resolution are out of the scope of this paper.
We have designed PrInt to provide the following major characteristics, described as follows.  X  inconsistencies among data sources. Operations are stored in a repository.  X  that the reapplication of the operations leaves the data consistent.  X  same conflicts in future integration processes.  X  These properties maintain the accuracy of the reapplication process.
Section 7 validates PrInt through performance tests, and Section 8 concludes the paper. 2. Related work issues that are not tackled by Orchestra. operations, operation reapplication and safe reordering, and introduce the related algorithms. cleaning data to be automatically reapplied in subsequent integration processes. limitations previously discussed for Orchestra also apply to ETL processes. 3. The proposed PrInt model heterogeneous during an integration process with other sources. For instance, consider three sources s
In a subsequent integration process, which we denote as IntProc (Fig. 2 e). Thus, before reapplying the operations defined by IntProc to those new inconsistencies originated from source updates since IntProc  X  item in S is updated at most once by operations in R .  X  between operations are described in Section 5 , along with our approach for detecting and managing them. the same values. Once one of them, say v 2 is modified to v 4. Storage of integration decisions as operations show how to map user's actions to operations.

O  X  O of subobjects. We represent the elements of these sets as o consider that each object o can be uniquely identified by a set A object in s identified by A  X  k .

Regarding the schema of the repository R , it is a sequence of records with the following attributes.  X  id : an integer that identifies an operation in R , such that id  X  op : the type of the operation;  X  origin : source that provides the correct value;  X  target : source that is the target of the operation;  X  objKey : values of key attributes of the object;  X  objAtt : attribute name involved in op ;  X  originValue : origin 's attribute value;  X  targetValue : original target 's attribute value before the execution of op . different values for the attributes originValue and targetValue . attribute, while values of the remaining attributes are set to objAtt , originValue and targetValue set to  X  null  X  , as it is an object operation. is a unary and object operation.

An edit action takes as input an s target source, the values of the key attributes A repository R as described in Eq. (1).
A copy action takes as input an s origin and an s target sources, the values of the key attributes A its v origin and v target values, and is mapped to a copy operation (i.e., operation type
An insert action takes as input an s origin and an s target created object with values obtained from source s origin , as described in Eq. (3).
A remove action takes as input an s target source, the values of the key attributes A removed, as described in Eq. (4). 3 for removing author  X  Bob  X  from Mary consists of an edit operation for setting (operation 3 in Fig. 3 ), followed by a remove operation (operation 4 in Fig. 3 ). two records, r 1 and r 2 , r 1 b r 2 if r 1 occurs before r 5. Consistency of the repository are no two operations that determine the final value of a data item. detecting and managing inconsistencies among operations. 5.1. Relationships between operations as stated in Definitions 1 and 2 , respectively.

De following conditions hold: 1. Index ( a ) b Index ( b ); 2. a.objKey = b.objKey ; 3. a.target = b.origin ; and 4. a.objAtt = b.objAtt .  X  non-reflexive closure of transitive operations.

De a set of operations { b 1 , ... , b n }, n  X  1, such that a Definitions 3 and 4 .

De the following conditions hold: 1. Index ( a ) b Index ( b ); 2. a.objKey = b.objKey ; 3. a.origin = b.target ; and 4. a.objAtt = b.objAtt .  X 
De fi the following conditions hold: 1. Index ( a ) b Index ( b ); 2. a.objKey = b.objKey ; 3. a.target = b.target ; and 4. a.objAtt = b.objAtt .  X 
The inconsistency is also propagated to Jack and Mary , since 13
Intuitively, a  X  t b if both operations writes on the same data item, and a precisely specify in Definition 5 our notion of repository consistency.
De fi operations.  X  instance, the repository of Fig. 3 shows a consistent repository. 5.2. The redo policy consistency, which is based on modifying and reordering of operations. b.originValue , this new value should also be propagated to a.target (i.e., b
Example 3. Consider origin overlapping operation 13 depicted in Fig. 4 , such that 5 5 and 12 are updated from  X  Conference ... X  to  X  XX Conference 12 are moved in the repository to positions after operation 13.

We now turn our attention to target overlapping operations. Recall that if a to a must be adjusted. This is be cause given an operation c ,if a
Example 4. Consider target overlappingoperation 14 depicted in Fig. 5 ,suchthat13 operations 5 and 12 are updated from  X  XX Conference ... X  this integration process.  X  detailed as follows.
 Algorithm 1. Redo (R, Op) Require : R {repository }, Op {operation to be inserted}
Ensure : R {updated repository} 1: R  X  R + Op 2: DetectOverlapping ( R , Op , OvlpedOp , OvlpingType ) 3: if OvlpingType =  X  origin  X  then 4: OvlpedOp.originValue  X  Op.originValue 5: Move OvlpedOp to the end of R 6: Redo OvlpedOp 7: else if OvlpingType =  X  target  X  then 8: Op.targetValue  X  OvlpedOp.targetValue 9: R  X  R  X  { OvlpedOp } 10: end if 11: if OvlpingType b &gt;  X  none  X  then 12: TransOp  X  FindDirectTransOp ( R , OvlpedOp ) 13: TransOp  X  TransOp + FindIndirectTransOp ( R , TransOp ) 14: for all operation d in TransOp do 15: d.originValue  X  Op.originValue 16: Move d to the end of R 17: Redo d 18: end for 19: end if
OvlpedOp . If there is no overlapped operation, OvlpedOp is returned as performed within the loop take constant time O (1), the time complexity of this algorithm is O (| R |).
Op constant time O (1), the time complexity of this algorithm is O (| R |).
Considering that all other operations take constant time O (1) and that | TransOp | O (| R | 2 +(| R |  X  ro )).
 Algorithm 2. DetectOverlapping (R, Op, OvlpedOp , OvlpingType ) Require : R {repository}, Op {overlapping operation}
Ensure : OvlpedOp {overlapped operation}, OvlpingType 1: OvlpedOp  X  null 2: OvlpingType  X   X  none  X  3: for i =0 to | R | do 4: if ( R [ i ]. objKey = Op.objKey and 5: if ( R [ i ]. origin = Op.target ) then 6: OvlpedOp  X  R [ i ] 7: OvlpingType  X   X  origin  X  8: return 9: else if ( R [ i ]. target = Op.target ) then 10: OvlpedOp  X  R [ i ] 11: OvlpingTyp e  X   X  target  X  12: return 13: end if 14: end if 15: end for Algorithm 3. FindDirectTransOp (R, Op, TransOp) Require : R {repository}, Op {overlapped operation}
Ensure : TransOp {direct transitive operations} 1: TransOp  X   X  2: for i = Index ( Op )+1 to | R | do 3: if ( R [ i ]. origin = Op.target and 4: TransOp  X  TransOp  X  { R [ i ]} 5: end if 6: end for specified in Definition 6 .

De fi nition 6. The redo policy guarantees the consistency of the repository. 6. Reapplication of operations tasks are performed before each subsequent integration process.
 Algorithm 4. FindIndirectTransOp (R, TransOp) Require : R {repository}, TransOp {direct transitive operations}
Ensure : TransOp {updated with indirect transitive operations} 1: while  X  Op  X  TransOp such that Op has not been visited do 2: for j = Index ( Op )+1 to | R | do 3: if ( R [ j ]. origin = Op.target and 4: TransOp  X  TransOp  X  { R [ j ]} 5: end if 6: end for 7: Mark Op as visited 8: end while 6.1. Validation intervention to solve the inconsistency.

Example 5. In the repository of Fig. 3 , operation 11 copies the value  X  2008  X  . If operation 11 is reapplied exactly as stored in the repository, it would write value year on origin and target inconsistent.

Now consider that the target is not validated, i.e., Mary has updated attribute year from Example 6 .

Example 6. Consider operations 5 and 12 of Fig. 3 ,suchthat5  X  that in Jack .
 operations are valid.
 relationship between the notions of validation and repository consistency.
De fi nition 7. A consistent repository remains consistent after the validation of its operations. 6.2. The VRT method used in the new integration process, with all previous decisions made by the user already in place. coincide both with values stored in the origin and target (line 9). times. Therefore, the time complexity of Algorithm 5 is O (| R |* | DS |). Algorithm 5. VRT (R, DS) Require : R {repository}, DS {set of data sources}
Ensure : R {updated repository}, DS {set of updated data sources} 1: for all operation d in R do 2: Origin  X  datasource  X  DS such that datasource = d.origin 3: if d.originValue b &gt; value in Origin then 4: R  X  R  X  { d } 5: else 6: Target  X  datasource  X  DS such that datasource = d.target 7: if d.targetValue b &gt; value in Target then 8: R  X  R  X  { d } 9: else 10: Reapply d 11: end if 12: end if 13: end for 6.3. Safe reordering of operations given in Definition 8 .

De 1. It does not change the order of transitive operations; and 2. It does not change the order of operations that update the value of key attributes.
Considering two operations a and b of a repository R , Definition 8 states that given { a , b or 2 holds, then Index ( a ) b Index ( b ) must hold as the result of safe reordering of R . while using the repository of Fig. 3 this source is loaded four times. outputs a reorderedand updatedversionof R . The outerloop iteratesover all operations R [ i ]( i between the notions of reordering and repository consistency.

De fi nition 9. A consistent repository remains consistent after the safe reordering of its operations. described in Section 7.3. Algorithm 6. SafeReordering (R) Require : R {repository}
Ensure : R {repository safe-reordered} 1: for i  X  1to| R | do 2: reordering  X  'origin' 3: for j  X  ( i  X  1) downto 0 do 4: if reordering ='origin' then 5: if R [ i ]. origin = R [ j ]. origin then 6: candInd  X  j +1 {candidate index for reordering} 7: reordering  X  ' target ' 8: else if ( R [ i ]. origin = R [ j ]. target and 9: {found a transitive or key changing operation} 10: break inner loop 11: end if 12: end if 13: if reordering =' target ' then 14: if R [ i ]. origin = R [ j ]. origin then 15: if R [ i ]. target = R [ j ]. target then 16: ReorderedOperation  X  R [ i ] 17: Increment by 1 the index of all operations 18: R [ j +1 ]  X  ReorderedOperation 19: break inner loop 20: end if 21: else 22: ReorderedOperation  X  R [ i ] 23: Increment by 1 the index of all operations with 24: R [ candInd ]  X  ReorderedOperation 25: break inner loop 26: end if 27: end if 28: end for 29: end for 7. Performance evaluation which were composed of the attributes name , citation name and citation order . our experiments.
 where aligned but had different values. In this case, values of attributes from s
In this case, the entity was inserted into s 2 using the values of its attributes obtained from s whenever an entity was present in s 2 but not in s 1 . In this case, the entity was removed from s seconds. 7.1. Management of overlapping operations elapsed time grew linearly with the number of transitive operations. repository did not impair the performance of the redo policy, since its cost was nearly constant. showed a quadratic growth in time in the experiments illustrated in Figs. 8 and 9 . 7.2. Management of operation reapplication describes a manually integration process performed by real users. 7.2.1. Investigating the VRT method and our automatic reapplication approach as the VRT method .
 the operations repository, and validate and reapply the stored operations. build the new objects.
 well with the number of input sources, while a simple log file approach based on user's actions did not. the largest number of sources.
 7.2.2. Investigating a manually integration process about 348 operations in the average.
 of magnitude) and represent one of the biggest contributions of our work. 7.3. Management of safe reordering described as follows.  X   X  reduced to the minimum.

Section 7.3.2 describes results considering increasing number of sources. 7.3.1. Increasing number of operations configuration 2 the VRT method took only 9.5 s to execute the same 10,000 operations. of operations ( Algorithm 6 ) showed a time complexity of O ( n 7.3.2. Increasing number of sources i.e., the safe reordering took 0.02 s, independent of the number of sources processed. which there are no two operations writing on the same object. 8. Conclusions and future work by the sources until the proper authority decides to update them. operations stored in the repository to improve the performance of the reapplication of user's decisions. indiscriminately. This leads to an optimized reapplication process. real integration applications.
 described as follows.  X   X  performed, and so on.  X   X  the number or the size of the sources.  X  for rule-based changes (e.g., convert all dates from the MM an implicit knowledge that  X  CIKM 2009  X  was at  X  Hong Kong Acknowledgments
References
