 1. Introduction between pairs of objects [5  X  7] .
 are also of great need to find frequently occurring patterns.
 algorithm was proposed for graphs with at most three edges incident on every vertex [17] . graphs to have edge labels; hence it is not applicable to labeled graphs [1] . complexity isO n canonical codes are identical. Below are the brief discussions of these methods. commonly used methods for exact graph matching [20] .
 can work under the structural constraints as synthetic rules and label constraints as semantic rules . vertices are partitioned into c classes  X  1 ,  X  2 , ... , approaches [1] .
 search state-space tree) is O(  X  i =1~ c (|  X  i |!)), in which the product of all | labeled graph isomorphism testing such as graph-based data mining. with future direction. 2. Background and de fi nitions to unlabeled graphs, each vertex in labeled graphs is given a vertex identifier , usually denoted as v gives examples such as l ( v 2 )=  X  B  X  and l ( v 2 , v 3 bijection f such that f ( v 1 )= w 3 , f ( v 2 )= w 1 , f ( v are partitioned into the same equivalence class. If the vertices of a graph are partitioned into c classes all possible codes need to be generated in order to obtain the canonical one is O( summation, which becomes 3! + 5! + 6! + 4! + 2! (= 872).

De fi nition 1. Vertex signature l ( v p (2), ... , p ( m ) is a permutation of 1, 2, ... , m , which satisfies the following criteria: (1) l ( v , v p ( k ) )  X  l ( v , v p ( k +1) ), for all k ,1 Therefore, the lexicographic order of vertex signatures is totally ordered as normal strings.
By Definition 1 , the vertex signature sig ( v 3 ) of graph G neighbors of v . Hence the larger neighbor of vertex v 3 of graph G signature of a graph from vertex signature as Definition 2 .
De fi nition 2. Graph signature sig ( v p ( n ) ), where p (1) p (2) ... p ( n ) is a permutation of 1 concatenation of the vertex signatures. The graph signature of graph G sig ( v 2 ), sig ( v 6 ), sig ( v 3 ), sig ( v 1 ), and sig ( v edges is O( n 2 log n + m log m ), or equivalently O( n 2 of the adjacency list [27] .
 v , v the time-consuming matching process has not begun. This property is stated as the following lemma:
Lemma 1. Given two graph signatures Sig ( G 1 ) and Sig ( G Sig ( G 1 ) 1 Sig ( G 2 ).

Proof. We prove this lemma by showing that if G 1 is isomorphic to G bijection f that maps each vertex v i of G 1 to a vertex f ( v obtained by sorting all the vertex signatures in this graph, these two graph signatures must be equal. Sig ( G 2 )= Sig ( G 3 ), G 2 is not isomorphic to G 3 .
 becomes ( totally ) ordered partition as in Definition 3 .

De fi nition 3. Ordered partition  X  ( G )={  X  1 ( G ),  X  2 ( G ), ... ,  X  c ( G )} satisfies the following properties: (1) For all vertex pairs u , v  X   X  k ( G ), sig ( u )= sig ( v ), for all k ,1 (2) For all vertex pairs u  X   X  k ( G ) and v  X   X  h ( G ), sig ( u ) in Definition 3 holds. Since the partitions  X  i ( G ), 1  X  signatures. For the vertex signatures defined in Definition 1 , the ordered partitions on graphs G  X  ( G 1 )={  X  1 ={ v 4 , v 5 },  X  2 ={ v 2 , v 7 },  X  3 ={ v 3 , v  X  are ordered by their vertex id s. For example, class_no ( v the partition  X  ( G 1 ). It is trivial to see that a vertex of G vertices of any two corresponding classes for two isomorphic graphs are both identical, namely, sig ( |  X  ( G 1 )| = |  X  i ( G 2 )|, for all i no greater than the number of classes.
Lemma 2. For vertices v  X   X  k ( G 1 ) ,w  X   X  k ( G 2 ) , and a smaller neighbor v cannot be mapped to any smaller neighbor of w in graph G 2
Proof. Suppose there is an isomorphism function f that maps v to w and maps v assumed. From the definition of isomorphism we have l ( v , v of a vertex v in G 1 can be mapped to a smaller neighbor of a vertex w in G
Lemma 3. Let  X  ( G 1 ) and  X  ( G 2 ) are the ordered partitions of labeled graphs G maps each vertex v  X   X  k ( G 1 ) to a vertex w  X   X  k ( G 2
Proof. Since no local bijection exists between  X  k ( G 1 ) and any vertex of  X  k ( G 2 ). From Lemma 2 we know that a vertex v in vertex exists in  X  k ( G 2 ) to be mapped by v , no other vertex in V( G is not isomorphic to G 2 .  X 
Lemma 3 reveals an important fact that G 1 is not isomorphic to G  X  ( G 1 ) and  X  k ( G 2 ). Based on this conclusion, a  X  global bijection between  X  1 ( G 1 ) and  X  1 ( G 2 ) first, then find the local bijection between patterns between  X  1 ( G 1 ) and  X  1 ( G 2 ), i.e., the mapping procedure between two corresponding classes independent , it works under the restrictions made by the previous mapping (all procedures are successfully proceeded from  X  1 ( G 1 ) and bijection cannot be produced.
 within each local tree. However, the worst case for all the known methods including CISC is O n 3. The proposed method
The key features of the proposed algorithm CISC are as follows: proved in our experiments later. state-space trees) is O(  X  i =1~ c (|  X  i |!)) instead of O( state-space tree as previous works (the process will be described in Subsection 3.1 ). 3.1. Descriptions of CISC The main program of CISC is shown as Algorithm 1 .
 Algorithm 1. CISC the vertex signatures as stated in Definition 3 . In steps 5 and 6, each corresponding class pair of G Algorithm 2. Class_Test(class_no)
Algorithm 3. DFS_Traverse(k, m, class_no) a True flag.
 all local bijective functions between two corresponding classes searching process.
 smaller-neighbor test .
 Algorithm 4. Feasibility_Test(v, w, k, class_no) Algorithm 5. Peer_Test(v, w, k, class_no) depicted in step 4 of Algorithm 3 DFS_Traverse ,ifvertex v is the k -th vertex in (1  X  i  X  k  X  1) has temporarily been mapped to a vertex w j in identical to the edge label between w and each w j , i.e., l ( v , v notbeadjacentto w j .
 candidate w under the constraint that w is not in TMP [1] ~ TMP [ k violate the Ances_SNP [] patterns recorded from level 1 through level k Algorithm 6. Smaller_Neighbor_Test(v, w, k) patterns do not violate the ancestor patterns Ances_SNP []. The matching is done by dividing the set S neighbors of v ) into subsets S 1,1 , S 1,2 , ... , S 1, m must be equal, i.e., | S 1 ,i |=| S 2, i |, 1  X  i  X  m . When we try to find a pattern matching S scanned in order to locate a pattern that matches every vertex v given below). Hence no backtracking is needed in step 6.
 data structures CMP [] and Ances_SNP []. 3.2. Examples and correctness proof
Example 1. Consider the two graphs in Fig. 3 (a) and (b), the ordered partitions of G { v , v 7 }, { v 3 , v 6 }, { v 1 , v 8 }} and  X  ( G 2 )={{ w smallest class  X  1 ( G 1 ): 1. Class_Test (1) succeeds and it constructs CMP [1] = {( v
Feasibility_Test ( v 4 , w 7 ) is done first. Since at this stage v the feasibility test and become a temporary match recorded in TMP [1]. Advance to next DFS level, we perform
Feasibility_Test ( v 5 , w 8 ). The peer of v 5 is v 4 and the peer of w v v 5 : w 8 . In the same manner, the other DFS path reached solution v 2. Class_Test (2) succeeds and it constructs CMP [2] = {( v v 2 has been matched with w 3 (no peervertices and smaller neighbors), Feasibility_Test ( v of v 7 is v 2 and the vertex of w 4 is w 3 .Wefoundthatvertexpairs( v have no smaller neighbors, hence they pass the feasibility test and this DFS path reached a solution of v manner we can reach another solution v 2 : w 4 and v 7 : w 3. Class_Test (3) succeeds and it constructs CMP [3] = {( v
Feasibility_Test ( v 3 , w 5 ) is done first. The smaller neighbors of v neighbor tests, we found that the first pattern of CMP [1] matches v pattern of CMP [2] matches v 2 with w 3 and l ( v 3 , v 2 next level with the same operations, this DFS path reached a solution v another solution v 3 : w 6 and v 6 : w 5 . 4. Class_Test (4) succeeds and it constructs CMP [4] = {( v reached that G 1 is isomorphic to G 2 .
 The local state space trees are shown in Fig. 4 .

The orderedpartitionsof G 1 and G 2 are respectively  X  ( G a  X  f are vertex identifiers rather than vertex labels. that simultaneously contains (C: c ,-,E: e , -) or (C: e ,-E: c , -), where f are the smaller neighbors of vertex b .

By Lemma 3 , the testing process stops and the conclusion is that G Theorem 1. Algorithm CISC is correct .
 isomorphism is correct.

A. No false dismissal occurs (no isomorphism is ignored) because all possible matching are tested: matching patterns between the vertices of  X  i (G 1 ) and  X  words, those pairs that do not pass the feasibility test are by no means promising.
B. No false alarm occurs because the vertex labels, edge labels, and adjacency relations are preserved: 1. The preservation of vertex labels is assured since a vertex v in class vertices in the corresponding classes  X  i (G 1 ) and  X  i (G 2. The preservation of edge labels is assured. Suppose v 1 the isomorphism function. Also suppose l ( v 1 )= l ( w 1 numbers of vertices v 1 and v 2 may exist: (a) class_no ( v 1 )= class_no ( v 2 ): in this case v 1 and v (b) class_no ( v 1 ) N class_no ( v 2 ): since smaller classes are tested first, v (c) class_no ( v 1 ) b class_no ( v 2 ): analogous to case (b), which is also impossible. w 2  X  V(G 2 ), where f ( v 1 )= w 1 , f ( v 2 )= w 2 . Also suppose l ( v case that ( w 1 , w 2 )  X  E(G 2 )but( v 1 , v 2 )  X  E(G 1 (b) class_no ( v 1 ) N class_no ( v 2 ): by step 3 of Algorithm 6 Smaller_Neighbor_Test ( v (c) class_no ( v 1 ) b class_no ( v 2 ): analogous to case (b), which is also impossible. 3.3 .
 Time complexity analysis edges is O( n 2 log n+m log m )orO( n 2 log n ), since m =O( n number of nodes in the state space tree for a class with | the edge label of edge ( v i , w j )andentryM ii stores the vertex label of vertex v maximal possible mapping patterns found in the previous trees 1 ~ i O(
 X 
Compared with the previous work [1] with O(  X  i =1~ c (|  X  addition, in the worst case, the time complexity is O(  X  i =1~ c practical application. 4. Experimental results constraints. These four methods were run on a mobile Pentium 4.1 .
 Description of the dataset follows, which is similar to those in [19,25] .

Randomly connected (RC) graphs are the graphs that each vertex pair has a probability and each vertex has n  X  connected edges in average. The values of couples for RC graphs is 10(size)  X  3(probability)  X  3(label)  X  40(couple) = 3600 couples. The total number of couples is 10(size)  X  3(label)  X  40(couple) = 1200 couples. applications in the presence of slightly distorted meshes. The number of added edges is n 3(label)  X  40(couple) = 3600 couples.
 10(size)  X  3(valence)  X  3(label)  X  40(couple) = 3600 couples. 4.2 . Results graph file. The results are reported by the categories of graphs as follows. 4.2.1 . Randomly connected graphs Notice that the unit of the vertical axis is second in logarithmic scale. small ( n = 20 and 40) graphs, FSG is better than VF2 and Ullmann and is only slightly slower than CISC. classes between two graphs is still remained. 4.2.2 . Regular 2D meshes labels are shown in Fig. 7 (a)(b), (c)(d), and (e)(f), respectively. graphs, the results here for R2DM graphs are acceptable. 4.2.3 . Irregular 2D meshes relative behaviors of the methods with respect to  X  = 0.2 and for the unlabeled IR2DM graphs. Time(sec) Time(sec) 4.2.4 . Bounded valence graphs
The performance of the four compared methods applied on bounded valence graphs with and ten labels is shown in Fig. 9 (a)(b), (c)(d), and (e)(f), respectively. Again, only the results of relative behaviors of the four methods in the other two cases ( graphs. 4.2.5 . Irregular bounded valence graphs
The performance of the four compared methods applied on irregular bounded valence graphs with the relative behaviors of the four methods in the other two cases ( Time(sec) Time(sec) Time(sec) behaviors as for IR2DM graphs.
 graphs in the first stage if their graph signatures are not identical. Time(sec) CISC Time(sec) Time(sec) 5. Conclusion backtrackings to occur within the same partition classes.
 Time(sec) Time(sec)
References Time(sec) Time(sec) Time(sec)
