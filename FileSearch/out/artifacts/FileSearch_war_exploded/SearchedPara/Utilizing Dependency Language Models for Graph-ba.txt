 In recent years, there are many data-driven mod-els that have been proposed for dependency parsing (McDonald and Nivre, 2007). Among them, graph-based dependency parsing models have achieved state-of-the-art performance for a wide range of lan-guages as shown in recent CoNLL shared tasks (Buchholz and Marsi, 2006; Nivre et al., 2007). In the graph-based models, dependency parsing is treated as a structured prediction problem in which the graphs are usually represented as factored struc-tures. The information of the factored structures de-cides the features that the models can utilize. There are several previous studies that exploit high-order features that lead to significant improvements.
McDonald et al. (2005) and Covington (2001) develop models that represent first-order features over a single arc in graphs. By extending the first-order model, McDonald and Pereira (2006) and Car-reras (2007) exploit second-order features over two adjacent arcs in second-order models. Koo and Collins (2010) further propose a third-order model that uses third-order features. These models utilize higher-order feature representations and achieve bet-ter performance than the first-order models. But this achievement is at the cost of the higher decoding length of the input sentence. Thus, it is very hard to develop higher-order models further in this way.
How to enrich high-order feature representations without increasing the decoding complexity for graph-based models becomes a very challenging problem in the dependency parsing task. In this pa-per, we solve this issue by enriching the feature rep-resentations for a graph-based model using a depen-dency language model (DLM) (Shen et al., 2008). The N-gram DLM has the ability to predict the next child based on the N-1 immediate previous children and their head (Shen et al., 2008). The basic idea behind is that we use the DLM to evaluate whether a valid dependency tree (McDonald and Nivre, 2007) is well-formed from a view of large scope. The pars-ing model searches for the final dependency trees by considering the original scores and the scores of DLM.

In our approach, the DLM is built on a large amount of auto-parsed data, which is processed by an original first-order parser (McDonald et al., 2005). We represent the features based on the DLM. The DLM-based features can capture the N-gram in-formation of the parent-children structures for the parsing model. Then, they are integrated directly in the decoding algorithms using beam-search. Our new parsing model can utilize rich high-order fea-ture representations but without increasing the com-plexity.

To demonstrate the effectiveness of the proposed approach, we conduct experiments on English and Chinese data. The results indicate that the approach greatly improves the accuracy. In summary, we make the following contributions:  X  We utilize the dependency language model to  X  The new parsing model uses the rich high-order  X  Our parser achieves the best accuracy on the Language models play a very important role for sta-tistical machine translation (SMT). The standard N-gram based language model predicts the next word based on the N  X  1 immediate previous words. How-ever, the traditional N-gram language model can not capture long-distance word relations. To over-come this problem, Shen et al. (2008) proposed a dependency language model (DLM) to exploit long-distance word relations for SMT. The N-gram DLM predicts the next child of a head based on the N  X  1 immediate previous children and the head itself. In this paper, we define a DLM, which is similar to the one of Shen et al. (2008), to score entire dependency trees.

An input sentence is denoted by x = ( x 0 , x 1 , ..., x i , ..., x n ) does not depend on any other token in x and each token x dency tree for x and H ( y ) be a set that includes the words that have at least one dependent. For each x h  X  H ( y ) ( x the children on the left side from the farthest to the nearest and x side from the nearest to the farthest. Probability P ( D h ) is defined as follows: Here P probabilities respectively. Suppose, we use a N-gram dependency language model. P follows: P where the approximation is based on the n th order Markov assumption. The right side probability is similar. For a dependency tree, we calculate the probability as follows:
In this paper, we use a linear model to calculate the scores for the parsing models (defined in Section 3.1). Accordingly, we reform Equation 3. We define f which is based on arbitrary features of P x . Then, the DLM score of tree y is in turn computed as the inner product of f DLM with a corresponding weight vector w DLM . In this section, we propose a parsing model which includes the dependency language model by extend-ing the model of McDonald et al. (2005). 3.1 Graph-based parsing model The graph-based parsing model aims to search for the maximum spanning tree (MST) in a graph (Mc-Donald et al., 2005). We write ( x if there is a dependency in tree y from word x to word x dent). A graph, denoted by G of nodes V arcs (edges) E ( V x  X  x 0 ) } in x . Let T ( G x ) be the set of all the subgraphs of G Nivre, 2007) for sentence x .

The formulation defines the score of a depen-dency tree y  X  T ( G scores, where g is a spanning subgraph of y . g can be a single dependency or adjacent dependencies. Then y is represented as a set of factors. The model scores each factor using a weight vector w that con-tains the weights for the features to be learned dur-ing training using the Margin Infused Relaxed Algo-rithm (MIRA) (Crammer and Singer, 2003; McDon-ald and Pereira, 2006). The scoring function is where f ( x, g ) is a high-dimensional feature repre-sentation which is based on arbitrary features of g and x .

The parsing model finds a maximum spanning tree (MST), which is the highest scoring tree in T ( G x ) . The task of the decoding algorithm for a given sentence x is to find y  X  , y 3.2 Add DLM scores In our approach, we consider the scores of the DLM when searching for the maximum spanning tree. Then for a given sentence x , we find y  X  y
DLM = arg max
After adding the DLM scores, the new parsing model can capture richer information. Figure 1 illus-trates the changes. In the original first-order parsing model, we only utilize the information of single arc ( x If we use 3-gram DLM, we can utilize the additional information of the two previous children (nearer to x Figure 1-(b).
 3.3 DLM-based feature templates We define DLM-based features for D ( x the left side, we have P refers to the N  X  1 immediate previous right chil-dren and head x for each child on the right side. Let P (
P u ( ch ) We use the map function  X ( P predefined discrete value (defined in Section 5.3). The feature templates are outlined in Table 1, where TYPE refers to one of the types: P L or P R , h pos refers to the part-of-speech tag of x to the lexical form of x speech tag of x form of x In this section, we turn to the problem of adding the DLM in the decoding algorithm. We propose two ways: (1) Rescoring, in which we rescore the K-best list with the DLM-based features; (2) Intersect, in which we add the DLM-based features in the de-coding algorithm directly. 4.1 Rescoring We add the DLM-based features into the decoding procedure by using the rescoring technique used in (Shen et al., 2008). We can use an original parser to produce the K-best list. This method has the po-tential to be very fast. However, because the perfor-mance of this method is restricted to the K-best list, we may have to set K to a high number in order to find the best parsing tree (with DLM) or a tree ac-ceptably close to the best (Shen et al., 2008). 4.2 Intersect Then, we add the DLM-based features in the decod-ing algorithm directly. The DLM-based features are generated online during decoding.

For our parser, we use the decoding algorithm of McDonald et al. (2005). The algorithm was ex-tensions of the parsing algorithm of (Eisner, 1996), which was a modified version of the CKY chart parsing algorithm. Here, we describe how to add the DLM-based features in the first-order algorithm. The second-order and higher-order algorithms can be extended by the similar way.

The parsing algorithm independently parses the left and right dependents of a word and combines them later. There are two types of chart items (Mc-Donald and Pereira, 2006): 1) a complete item in which the words are unable to accept more depen-dents in a certain direction; and 2) an incomplete item in which the words can accept more dependents in a certain direction. In the algorithm, we create both types of chart items with two directions for all the word pairs in a given sentence. The direction of a dependency is from the head to the dependent. The right (left) direction indicates the dependent is on the right (left) side of the head. Larger chart items are created from pairs of smaller ones in a bottom-up style. In the following figures, complete items are represented by triangles and incomplete items are represented by trapezoids. Figure 2 illustrates the cubic parsing actions of the algorithm (Eisner, 1996) in the right direction, where s , r , and t refer to the start and end indices of the chart items. In Figure 2-(a), all the items on the left side are complete and the algorithm creates the incomplete item (trapezoid on the right side) of s  X  t . This action builds a de-pendency relation from s to t . In Figure 2-(b), the item of s  X  r is incomplete and the item of r  X  t is complete. Then the algorithm creates the complete item of s  X  t . In this action, all the children of r are generated. In Figure 2, the longer vertical edge in a triangle or a trapezoid corresponds to the subroot of the structure (spanning chart). For example, s is the subroot of the span s  X  t in Figure 2-(a). For the left direction case, the actions are similar.

Then, we add the DLM-based features into the parsing actions. Because the parsing algorithm is in the bottom-up style, the nearer children are gen-erated earlier than the farther ones of the same head. Thus, we calculate the left or right side probabil-ity for a new child when a new dependency rela-tion is built. For Figure 2-(a), we add the features of P
Rc ( x t | HIS ) c x . In the figure, HIS includes c
We use beam search to choose the one having the overall best score as the final parse, where K spans are built at each step (Zhang and Clark, 2008). At each step, we perform the parsing actions in the cur-rent beam and then choose the best K resulting spans for the next step. The time complexity of the new de-coding algorithm is O ( Kn 3 ) while the original one is O ( n 3 ) , where n is the length of the input sentence. With the rich feature set in Table 1, the running time of Intersect is longer than the time of Rescoring. But Intersect considers more combination of spans with the DLM-based features than Rescoring that is only given a K-best list. 5.1 Baseline parser a freely available implementation of the graph-based model proposed by (McDonald and Pereira, 2006). We train a first-order parser on the training data (de-scribed in Section 6.1) with the features defined in McDonald et al. (2005). We call this first-order parser Baseline parser. 5.2 Build dependency language models We use a large amount of unannotated data to build the dependency language model. We first perform word segmentation (if needed) and part-of-speech tagging. After that, we obtain the word-segmented sentences with the part-of-speech tags. Then the sentences are parsed by the Baseline parser. Finally, we obtain the auto-parsed data.

Given the dependency trees, we estimate the prob-ability distribution by relative frequency:
No smoothing is performed because we use the mapping function for the feature representations. 5.3 Mapping function We can define different mapping functions for the feature representations. Here, we use a simple way. First, the probabilities are sorted in decreasing order. Let N o ( P in the sorted list. The mapping function is:  X ( P u ( ch )) = where TOP10 and TOP 30 refer to the position num-bers of top 10% and top 30% respectively. The num-bers, 10% and 30%, are tuned on the development sets in the experiments. We conducted experiments on English and Chinese data. 6.1 Data sets For English, we used the Penn Treebank (Marcus et al., 1993) in our experiments. We created a stan-dard data split: sections 2-21 for training, section 22 for development, and section 23 for testing. Tool pendency structures using a standard set of head rules (Yamada and Matsumoto, 2003). Following the work of (Koo et al., 2008), we used the MX-POST (Ratnaparkhi, 1996) tagger trained on training data to provide part-of-speech tags for the develop-ment and the test set, and used 10-way jackknifing to generate part-of-speech tags for the training set. For the unannotated data, we used the BLLIP corpus (Charniak et al., 2000) that contains about 43 million trained on training data to assign part-of-speech tags and used the Baseline parser to process the sentences of the BLLIP corpus.

For Chinese, we used the Chinese Treebank the  X  X enn2Malt X  tool to convert the data and cre-ated a data split: files 1-270 and files 400-931 for training, files 271-300 for testing, and files 301-325 for development. We used gold standard segmenta-tion and part-of-speech tags in the CTB. The data partition and part-of-speech settings were chosen to match previous work (Chen et al., 2008; Yu et al., 2008; Chen et al., 2009). For the unannotated data, we used the XIN CMN portion of Chinese Giga-which has approximately 311 million words whose segmentation and POS tags are given. We discarded the annotations due to the differences in annotation policy between CTB and this corpus. We used the MMA system (Kruengkrai et al., 2009) trained on the training data to perform word segmentation and POS tagging and used the Baseline parser to parse all the sentences in the data. 6.2 Features for basic and enhanced parsers The previous studies have defined four types of features: (FT1) the first-order features defined in McDonald et al. (2005), (FT2SB) the second-order parent-siblings features defined in McDonald and Pereira (2006), (FT2GC) the second-order parent-child-grandchild features defined in Carreras (2007), and (FT3) the third-order features defined in (Koo and Collins, 2010).

We used the first-and second-order parsers of the MSTParser as the basic parsers. Then we en-hanced them with other higher-order features us-ing beam-search. Table 2 shows the feature set-tings of the systems, where MST1/2 refers to the ba-sic first-/second-order parser and MSTB1/2 refers to the enhanced first-/second-order parser. MSTB1 and MSTB2 used the same feature setting, but used dif-ferent order models. This resulted in the difference of using FT2SB (beam-search in MSTB1 vs exact-inference in MSTB2). We used these four parsers as the Baselines in the experiments.

We measured the parser quality by the unlabeled attachment score (UAS), i.e., the percentage of to-kens (excluding all punctuation tokens) with the cor-rect HEAD. In the following experiments, we used  X  X nter X  to refer to the parser with Intersect, and  X  X escore X  to refer to the parser with Rescoring. 6.3 Development experiments Since the setting of K (for beam search) affects our parsers, we studied its influence on the development set for English. We added the DLM-based features to MST1. Figure 4 shows the UAS curves on the development set, where K is beam size for Inter-sect and K-best for Rescoring, the X-axis represents K, and the Y-axis represents the UAS scores. The parsing performance generally increased as the K increased. The parser with Intersect always outper-formed the one with Rescoring.
Table 3 shows the parsing times of Intersect on the development set for English. By comparing the curves of Figure 4, we can see that, while using larger K reduced the parsing speed, it improved the performance of our parsers. In the rest of the ex-periments, we set K=8 in order to obtain the high accuracy with reasonable speed and used Intersect to add the DLM-based features.

Then, we studied the effect of adding different N-gram DLMs to MST1. Table 4 shows the results. From the table, we found that the parsing perfor-mance roughly increased as the N increased. When N=3 and N=4, the parsers obtained the same scores for English. For Chinese, the parser obtained the best score when N=4. Note that the size of the Chi-nese unannotated data was larger than that of En-glish. In the rest of the experiments, we used 3-gram for English and 4-gram for Chinese. 6.4 Main results on English data We evaluated the systems on the testing data for En-glish. The results are shown in Table 5, where -DLM refers to adding the DLM-based features to the Baselines. The parsers using the DLM-based fea-tures consistently outperformed the Baselines. For the basic models (MST1/2), we obtained absolute improvements of 0.94 and 0.63 points respectively. For the enhanced models (MSTB1/2), we found that there were 0.63 and 0.66 points improvements re-spectively. The improvements were significant in McNemar X  X  Test ( p &lt; 10  X  5 )(Nivre et al., 2004). 6.5 Main results on Chinese data The results are shown in Table 6, where the abbrevi-ations used are the same as those in Table 5. As in the English experiments, the parsers using the DLM-based features consistently outperformed the Base-lines. For the basic models (MST1/2), we obtained absolute improvements of 4.28 and 3.51 points re-spectively. For the enhanced models (MSTB1/2), we got 3.00 and 2.93 points improvements respec-tively. We obtained large improvements on the Chi-nese data. The reasons may be that we use the very large amount of data and 4-gram DLM that captures high-order information. The improvements were significant in McNemar X  X  Test ( p &lt; 10  X  7 ). 6.6 Compare with previous work on English Table 7 shows the performance of the graph-based systems that were compared, where McDonald06 refers to the second-order parser of McDonald and Pereira (2006), Koo08-standard refers to the second-order parser with the features defined in Koo et al. (2008), Koo10-model1 refers to the third-order parser with model1 of Koo and Collins (2010), Koo08-dep2c refers to the second-order parser with cluster-based features of (Koo et al., 2008), Suzuki09 refers to the parser of Suzuki et al. (2009), Chen09-ord2s refers to the second-order parser with subtree-based features of Chen et al. (2009), and Zhou11 refers to the second-order parser with web-derived selectional preference features of Zhou et al. (2011).

The results showed that our MSTB-DLM2 ob-tained the comparable accuracy with the previous state-of-the-art systems. Koo10-model1 (Koo and Collins, 2010) used the third-order features and achieved the best reported result among the super-vised parsers. Suzuki2009 (Suzuki et al., 2009) re-ported the best reported result by combining a Semi-supervised Structured Conditional Model (Suzuki and Isozaki, 2008) with the method of (Koo et al., 2008). However, their decoding complexities were higher than ours and we believe that the performance of our parser can be further enhanced by integrating their methods with our parser.
 6.7 Compare with previous work on Chinese Table 8 shows the comparative results, where Chen08 refers to the parser of (Chen et al., 2008), Yu08 refers to the parser of (Yu et al., 2008), Zhao09 refers to the parser of (Zhao et al., 2009), and Chen09-ord2s refers to the second-order parser with subtree-based features of Chen et al. (2009). The results showed that our score for this data was the best reported so far and significantly higher than the previous scores.
 Dependency parsers tend to perform worse on heads which have many children. Here, we studied the ef-fect of DLM-based features for this structure. We calculated the number of children for each head and listed the accuracy changes for different numbers. We compared the MST-DLM1 and MST1 systems on the English data. The accuracy is the percentage of heads having all the correct children.
 Figure 5 shows the results for English, where the X-axis represents the number of children, the Y-axis represents the accuracies, OURS refers to MST-DLM1, and Baseline refers to MST1. For example, for heads having two children, Baseline obtained 89.04% accuracy while OURS obtained 89.32%. From the figure, we found that OURS achieved bet-ter performance consistently in all cases and when the larger the number of children became, the more significant the performance improvement was. Several previous studies related to our work have been conducted.

Koo et al. (2008) used a clustering algorithm to produce word clusters on a large amount of unan-notated data and represented new features based on the clusters for dependency parsing models. Chen et al. (2009) proposed an approach that extracted partial tree structures from a large amount of data and used them as the additional features to im-prove dependency parsing. They approaches were still restricted in a small number of arcs in the graphs. Suzuki et al. (2009) presented a semi-supervised learning approach. They extended a Semi-supervised Structured Conditional Model (SS-SCM)(Suzuki and Isozaki, 2008) to the dependency parsing problem and combined their method with the approach of Koo et al. (2008). In future work, we may consider apply their methods on our parsers to improve further.

Another group of methods are the co-training/self-training techniques. McClosky et al. (2006) presented a self-training approach for phrase structure parsing. Sagae and Tsujii (2007) used the co-training technique to improve perfor-mance. First, two parsers were used to parse the sentences in unannotated data. Then they selected some sentences which have the same trees produced by those two parsers. They retrained a parser on newly parsed sentences and the original labeled data. We are able to use the output of our systems for co-training/self-training techniques. We have presented an approach to utilizing the de-pendency language model to improve graph-based dependency parsing. We represent new features based on the dependency language model and in-tegrate them in the decoding algorithm directly us-ing beam-search. Our approach enriches the feature representations but without increasing the decoding complexity. When tested on both English and Chi-nese data, our parsers provided very competitive per-formance compared with the best systems on the En-glish data and achieved the best performance on the Chinese data in the literature.

