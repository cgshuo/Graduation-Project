 Ian J. Goodfellow goodfeli@iro.umontreal.ca David Warde-Farley wardefar@iro.umontreal.ca Mehdi Mirza mirzamom@iro.umontreal.ca Aaron Courville aaron.courville@umontreal.ca Yoshua Bengio yoshua.bengio@umontreal.ca 2920, chemin de la Tour, Montr  X eal, Qu  X ebec, Canada, H3T 1J8 Dropout (Hinton et al., 2012) provides an inexpensive and simple means of both training a large ensemble of models that share parameters and approximately aver-aging together these models X  predictions. Dropout ap-plied to multilayer perceptrons and deep convolutional networks has improved the state of the art on tasks ranging from audio classification to very large scale ob-ject recognition (Hinton et al., 2012; Krizhevsky et al., 2012). While dropout is known to work well in prac-tice, it has not previously been demonstrated to actu-ally perform model averaging for deep architectures 1 . Dropout is generally viewed as an indiscriminately ap-plicable tool that reliably yields a modest improvement in performance when applied to almost any model. We argue that rather than using dropout as a slight performance enhancement applied to arbitrary mod-els, the best performance may be obtained by directly designing a model that enhances dropout X  X  abilities as a model averaging technique. Training using dropout differs significantly from previous approaches such as ordinary stochastic gradient descent. Dropout is most effective when taking relatively large steps in param-eter space. In this regime, each update can be seen as making a significant update to a different model on a different subset of the training set. The ideal oper-ating regime for dropout is when the overall training procedure resembles training an ensemble with bag-ging under parameter sharing constraints. This differs radically from the ideal stochastic gradient operating regime in which a single model makes steady progress via small steps. Another consideration is that dropout model averaging is only an approximation when ap-plied to deep models. Explicitly designing models to minimize this approximation error may thus enhance dropout X  X  performance as well.
 We propose a simple model that we call maxout that has beneficial characteristics both for optimization and model averaging with dropout. We use this model in conjunction with dropout to set the state of the art on four benchmark datasets 2 . Dropout is a technique that can be applied to deter-ministic feedforward architectures that predict an out-put y given input vector v . These architectures contain a series of hidden layers h = { h (1) ,...,h ( L ) } . Dropout trains an ensemble of models consisting of the set of all models that contain a subset of the variables in both v and h . The same set of parameters  X  is used to parameterize a family of distributions p ( y | v ;  X , X  ) where  X   X  X  is a binary mask determining which vari-ables to include in the model. On each presentation of a training example, we train a different sub-model by following the gradient of log p ( y | v ;  X , X  ) for a different randomly sampled  X  . For many parameterizations of p (such as most multilayer perceptrons) the instantiation of different sub-models p ( y | v ;  X , X  ) can be obtained by elementwise multiplication of v and h with the mask  X  . Dropout training is similar to bagging (Breiman, 1994), where many different models are trained on dif-ferent subsets of the data. Dropout training differs from bagging in that each model is trained for only one step and all of the models share parameters. For this training procedure to behave as if it is training an ensemble rather than a single model, each update must have a large effect, so that it makes the sub-model in-duced by that  X  fit the current input v well.
 The functional form becomes important when it comes time for the ensemble to make a prediction by aver-aging together all the sub-models X  predictions. Most prior work on bagging averages with the arithmetic mean, but it is not obvious how to do so with the exponentially many models trained by dropout. For-tunately, some model families yield an inexpensive ge-ometric mean. When p ( y | v ;  X  ) = softmax( v T W + b ), the predictive distribution defined by renormalizing the geometric mean of p ( y | v ;  X , X  ) over M is simply given by softmax( v T W/ 2+ b ). In other words, the aver-age prediction of exponentially many sub-models can be computed simply by running the full model with the weights divided by 2. This result holds exactly in the case of a single layer softmax model. Previous work on dropout applies the same scheme in deeper ar-chitectures, such as multilayer perceptrons, where the W/ 2 method is only an approximation to the geometric mean. The approximation has not been characterized mathematically, but performs well in practice. The maxout model is simply a feed-forward achitec-ture, such as a multilayer perceptron or deep convo-lutional neural network, that uses a new type of ac-tivation function: the maxout unit. Given an input x  X  R d ( x may be v , or may be a hidden layer X  X  state), a maxout hidden layer implements the function b  X  R m  X  k are learned parameters. In a convolutional network, a maxout feature map can be constructed by taking the maximum across k affine feature maps (i.e., pool across channels, in addition spatial loca-tions). When training with dropout, we perform the elementwise multiplication with the dropout mask im-mediately prior to the multiplication by the weights in all cases X  X e do not drop inputs to the max operator. A single maxout unit can be interpreted as making a piecewise linear approximation to an arbitrary convex function. Maxout networks learn not just the rela-tionship between hidden units, but also the activation function of each hidden unit. See Fig. 1 for a graphical depiction of how this works. Maxout abandons many of the mainstays of traditional activation function design. The representation it pro-duces is not sparse at all (see Fig. 2), though the gradient is highly sparse and dropout will artificially sparsify the effective representation during training. While maxout may learn to saturate on one side or the other this is a measure zero event (so it is almost never bounded from above). While a significant pro-portion of parameter space corresponds to the function being bounded from below, maxout is not constrained to learn to be bounded at all. Maxout is locally lin-ear almost everywhere, while many popular activation functions have signficant curvature. Given all of these departures from standard practice, it may seem sur-prising that maxout activation functions work at all, but we find that they are very robust and easy to train with dropout, and achieve excellent performance. A standard MLP with enough hidden units is a uni-versal approximator. Similarly, maxout networks are universal approximators. Provided that each individ-ual maxout unit may have arbitrarily many affine com-ponents, we show that a maxout model with just two hidden units can approximate, arbitrarily well, any continuous function of v  X  R n . A diagram illustrating the basic idea of the proof is presented in Fig. 3. Consider the continuous piecewise linear (PWL) func-tion g ( v ) consisting of k locally affine regions on R n Proposition 4.1 (From Theorem 2.1 in (Wang, 2004)) For any positive integers m and n , there exist two groups of n + 1 -dimensional real-valued parame-ter vectors [ W 1 j ,b 1 j ] ,j  X  [1 ,k ] and [ W 2 j ,b 2 j such that: That is, any continuous PWL function can be ex-pressed as a difference of two convex PWL functions. The proof is given in (Wang, 2004).
 Proposition 4.2 From the Stone-Weierstrass ap-proximation theorem , let C be a compact domain C  X  R n , f : C  X  R be a continuous function, and &gt; 0 be any positive real number. Then there exists a continuous PWL function g , (depending upon ), such that for all v  X  C , | f ( v )  X  g ( v ) | &lt; . Theorem 4.3 Universal approximator theorem . Any continuous function f can be approximated arbitrar-ily well on a compact domain C  X  R n by a maxout network with two maxout hidden units.
 Sketch of Proof By Proposition 4.2, any continuous function can be approximated arbitrarily well (up to ), by a piecewise linear function. We now note that the representation of piecewise linear functions given in Proposition 4.1 exactly matches a maxout network with two hidden units h 1 ( v ) and h 2 ( v ), with suffi-ciently large k to achieve the desired degree of approx-imation . Combining these, we conclude that a two hidden unit maxout network can approximate any con-tinuous function f ( v ) arbitrarily well on the compact domain C . In general as  X  0, we have k  X  X  X  .
 We evaluated the maxout model on four benchmark datasets and set the state of the art on all of them. 5.1. MNIST The MNIST (LeCun et al., 1998) dataset consists of 28  X  28 pixel greyscale images of handwritten digits 0-9, with 60,000 training and 10,000 test examples. For the permutation invariant version of the MNIST task, only methods unaware of the 2D structure of the data are permitted. For this task, we trained a model consist-ing of two densely connected maxout layers followed by a softmax layer. We regularized the model with dropout and by imposing a constraint on the norm of each weight vector, as in (Srebro &amp; Shraibman, 2005). Apart from the maxout units, this is the same archi-tecture used by Hinton et al. (2012). We selected the hyperparameters by minimizing the error on a valida-tion set consisting of the last 10,000 training examples. To make use of the full training set, we recorded the value of the log likelihood on the first 50,000 exam-ples at the point of minimal validation error. We then continued training on the full 60,000 example train-ing set until the validation set log likelihood matched this number. We obtained a test set error of 0.94%, which is the best result we are aware of that does not use unsupervised pretraining. We summarize the best published results on permutation invariant MNIST in Table 1.
 We also considered the MNIST dataset without the permutation invariance restriction. In this case, we used three convolutional maxout hidden layers (with spatial max pooling on top of the maxout layers) fol-lowed by a densely connected softmax layer. We were able to rapidly explore hyperparameter space thanks to the extremely fast GPU convolution library devel-oped by Krizhevsky et al. (2012). We obtained a test set error rate of 0.45%, which sets a new state of the art in this category. (It is possible to get better results on MNIST by augmenting the dataset with transfor-mations of the standard set of images (Ciresan et al., 2010) ) A summary of the best methods on the general MNIST dataset is provided in Table 2.
 5.2. CIFAR-10 The CIFAR-10 dataset (Krizhevsky &amp; Hinton, 2009) consists of 32  X  32 color images drawn from 10 classes split into 50,000 train and 10,000 test images. We pre-process the data using global contrast normalization and ZCA whitening.
 We follow a similar procedure as with the MNIST dataset, with one change. On MNIST, we find the best number of training epochs in terms of validation set error, then record the training set log likelihood and continue training using the entire training set un-til the validation set log likelihood has reached this value. On CIFAR-10, continuing training in this fash-ion is infeasible because the final value of the learn-ing rate is very small and the validation set error is very high. Training until the validation set likelihood matches the cross-validated value of the training like-lihood would thus take prohibitively long. Instead, we retrain the model from scratch, and stop when the new likelihood matches the old one.
 Our best model consists of three convolutional maxout layers, a fully connected maxout layer, and a fully con-nected softmax layer. Using this approach we obtain a test set error of 11.68%, which improves upon the state of the art by over two percentage points. (If we do not train on the validation set, we obtain a test set error of 13.2%, which also improves over the previous state of the art). If we additionally augment the data with translations and horizontal reflections, we obtain the absolute state of the art on this task at 9.35% error. In this case, the likelihood during the retrain never reaches the likelihood from the validation run, so we retrain for the same number of epochs as the valida-tion run. A summary of the best CIFAR-10 methods is provided in Table 3.
 5.3. CIFAR-100 The CIFAR-100 (Krizhevsky &amp; Hinton, 2009) dataset is the same size and format as the CIFAR-10 dataset, but contains 100 classes, with only one tenth as many labeled examples per class. Due to lack of time we did not extensively cross-validate hyperparameters on CIFAR-100 but simply applied hyperparameters we found to work well on CIFAR-10. We obtained a test set error of 38.57%, which is state of the art. If we do not retrain using the entire training set, we obtain a test set error of 41.48%, which also surpasses the cur-rent state of the art. A summary of the best methods on CIFAR-100 is provided in Table 4. 5.4. Street View House Numbers The SVHN (Netzer et al., 2011) dataset consists of color images of house numbers collected by Google Street View. The dataset comes in two formats. We consider the second format, in which each image is of size 32  X  32 and the task is to classify the digit in the center of the image. Additional digits may appear beside it but must be ignored. There are 73,257 digits in the training set, 26,032 digits in the test set and 531,131 additional, somewhat less difficult examples, to use as an extra training set. Following Sermanet et al. (2012b), to build a validation set, we select 400 samples per class from the training set and 200 sam-ples per class from the extra set. The remaining digits of the train and extra sets are used for training. For SVHN, we did not train on the validation set at all. We used it only to find the best hyperparameters. We applied local contrast normalization preprocessing the same way as Zeiler &amp; Fergus (2013). Otherwise, we followed the same approach as on MNIST. Our best model consists of three convolutional maxout hidden layers and a densely connected maxout layer followed by a densely connected softmax layer. We obtained a test set error rate of 2.47%, which sets the state of the art. A summary of comparable methods is provided in Table 5. One obvious question about our results is whether we obtained them by improved preprocessing or larger models, rather than by the use of maxout. For MNIST we used no preprocessing, and for SVHN, we use the same preprocessing as Zeiler &amp; Fergus (2013). How-ever on the CIFAR datasets we did use a new form of preprocessing. We therefore compare maxout to rec-tifiers run with the same processing and a variety of model sizes on this dataset.
 By running a large cross-validation experiment (see Fig. 6) we found that maxout offers a clear im-provement over rectifiers. We also found that our preprocessing and size of models improves rectifiers and dropout beyond the previous state of the art re-sult. Cross-channel pooling is a method for reducing the size of state and number of parameters needed to have a given number of filters in the model. Perfor-mance seems to correlate well with the number of fil-ters for maxout but with the number of output units for rectifiers X  X .e, rectifier units do not benefit much from cross-channel pooling. Rectifier units do best without cross-channel pooling but with the same num-ber of filters, meaning that the size of the state and the number of parameters must be about k times higher for rectifiers to obtain generalization performance ap-proaching that of maxout. Having demonstrated that maxout networks are effec-tive models, we now analyze the reasons for their suc-cess. We first identify reasons that maxout is highly compatible with dropout X  X  approximate model averag-ing technique.
 The intuitive justification for averaging sub-models by dividing the weights by 2 given by (Hinton et al., 2012) is that this does exact model averaging for a single layer model, softmax regression. To this characteriza-tion, we add the observation that the model averaging remains exact if the model is extended to multiple lin-ear layers. While this has the same representational power as a single layer, the expression of the weights as a product of several matrices could have a differ-ent inductive bias. More importantly, it indicates that dropout does exact model averaging in deeper archi-tectures provided that they are locally linear among the space of inputs to each layer that are visited by applying different dropout masks.
 We argue that dropout training encourages maxout units to have large linear regions around inputs that appear in the training data. Because each sub-model must make a good prediction of the output, each unit should learn to have roughly the same activation re-gardless of which inputs are dropped. In a maxout network with arbitrarily selected parameters, varying the dropout mask will often move the effective in-puts far enough to escape the local region surround-ing the clean inputs in which the hidden units are lin-ear, i.e., changing the dropout mask could frequently change which piece of the piecewise function an input is mapped to. Maxout trained with dropout may have the identity of the maximal filter in each unit change relatively rarely as the dropout mask changes. Net-works of linear operations and max(  X  ) may learn to exploit dropout X  X  approximate model averaging tech-nique well.
 Many popular activation functions have significant curvature nearly everywhere. These observations sug-gest that the approximate model averaging of dropout will not be as accurate for networks incorporating such activation functions. To test this, we compared the best maxout model trained on MNIST with dropout to a hyperbolic tangent network trained on MNIST with dropout. We sampled several subsets of each model and compared the geometric mean of these sam-pled models X  predictions to the prediction made using the dropout technique of dividing the weights by 2. We found evidence that dropout is indeed performing model averaging, even in multilayer networks, and that it is more accurate in the case of maxout. See Fig. 7 and Fig. 8 for details. The second key reason that maxout performs well is that it improves the bagging style training phase of dropout. Note that the arguments in section 7 moti-vating the use of maxout also apply equally to rectified linear units (Salinas &amp; Abbott, 1996; Hahnloser, 1998; Glorot et al., 2011). The only difference between max-out and max pooling over a set of rectified linear units is that maxout does not include a 0 in the max. Su-perficially, this seems to be a small difference, but we find that including this constant 0 is very harmful to optimization in the context of dropout. For instance, on MNIST our best validation set error with an MLP is 1.04%. If we include a 0 in the max, this rises to over 1.2%. We argue that, when trained with dropout, maxout is easier to optimize than rectified linear units with cross-channel pooling. 8.1. Optimization experiments To verify that maxout yields better optimization per-formance than max pooled rectified linear units when training with dropout, we carried out two experiments. First, we stressed the optimization capabilities of the training algorithm by training a small (two hidden convolutional layers with k = 2 and sixteen kernels) model on the large (600,000 example) SVHN dataset. When training with rectifier units the training error gets stuck at 7.3%. If we train instead with max-out units, we obtain 5.1% training error. As another optimization stress test, we tried training very deep and narrow models on MNIST, and found that max-out copes better with increasing depth than pooled rectifiers. See Fig. 9 for details. 8.2. Saturation Optimization proceeds very differently when using dropout than when using ordinary stochastic gradi-ent descent. SGD usually works best with a small learning rate that results in a smoothly decreasing objective function, while dropout works best with a large learning rate, resulting in a constantly fluctuat-ing objective function. Dropout rapidly explores many different directions and rejects the ones that worsen performance, while SGD moves slowly and steadily in the most promising direction. We find empirically that these different operating regimes result in differ-ent outcomes for rectifier units. When training with SGD, we find that the rectifier units saturate at 0 less than 5% of the time. When training with dropout, we initialize the units to sature rarely but training grad-ually increases their saturation rate to 60%. Because the 0 in the max(0 ,z ) activation function is a con-stant, this blocks the gradient from flowing through the unit. In the absence of gradient through the unit, it is difficult for training to change this unit to be-come active again. Maxout does not suffer from this problem because gradient always flows through every maxout unit  X  X ven when a maxout unit is 0, this 0 is a function of the parameters and may be adjusted Units that take on negative activations may be steered to become positive again later. Fig. 10 illustrates how active rectifier units become inactive at a greater rate than inactive units become active when training with dropout, but maxout units, which are always active, transition between positive and negative activations at about equal rates in each direction. We hypothesize that the high proportion of zeros and the difficulty of escaping them impairs the optimization performance of rectifiers relative to maxout.
 To test this hypothesis, we trained two MLPs on MNIST, both with two hidden layers and 1200 fil-ters per layer pooled in groups of 5. When we in-clude a constant 0 in the max pooling, the resulting trained model fails to make use of 17.6% of the filters in the second layer and 39.2% of the filters in the sec-ond layer. A small minority of the filters usually took on the maximal value in the pool, and the rest of the time the maximal value was a constant 0. Maxout, on the other hand, used all but 2 of the 2400 filters in the network. Each filter in each maxout unit in the network was maximal for some training example. All filters had been utilised and tuned. 8.3. Lower layer gradients and bagging To behave differently from SGD, dropout requires the gradient to change noticeably as the choice of which units to drop changes. If the gradient is approximately constant with respect to the dropout mask, then dropout simplifies to SGD training. We tested the hypothesis that rectifier networks suffer from dimin-ished gradient flow to the lower layers of the network by monitoring the variance with respect to dropout masks for fixed data during training of two different MLPs on MNIST. The variance of the gradient on the output weights was 1.4 times larger for maxout on an average training step, while the variance on the gradi-ent of the first layer weights was 3.4 times larger for maxout than for rectifiers. Combined with our previ-ous result showing that maxout allows training deeper networks, this greater variance suggests that maxout better propagates varying information downward to the lower layers and helps dropout training to better resemble bagging for the lower-layer parameters. Rec-tifier networks, with more of their gradient lost to satu-ration, presumably cause dropout training to resemble regular SGD toward the bottom of the network. We have proposed a new activation function called maxout that is particularly well suited for training with dropout, and for which we have proven a univer-sal approximation theorem. We have shown empirical evidence that dropout attains a good approximation to model averaging in deep models. We have shown that maxout exploits this model averaging behavior because the approximation is more accurate for max-out units than for tanh units. We have demonstrated that optimization behaves very differently in the con-text of dropout than in the pure SGD case. By de-signing the maxout gradient to avoid pitfalls such as failing to use many of a model X  X  filters, we are able to train deeper networks than is possible using rectifier units. We have also shown that maxout propagates variations in the gradient due to different choices of dropout masks to the lowest layers of a network, en-suring that every parameter in the model can enjoy the full benefit of dropout and more faithfully emulate bagging training. The state of the art performance of our approach on five different benchmark tasks moti-vates the design of further models that are explicitly intended to perform well when combined with inex-pensive approximations to model averaging.
 The authors would like to thank the developers of Theano (Bergstra et al., 2010; Bastien et al., 2012), in particular Fr  X ed  X eric Bastien and Pascal Lamblin for their assistance with infrastructure development and performance optimization. We would also like to thank Yann Dauphin for helpful discussions.

