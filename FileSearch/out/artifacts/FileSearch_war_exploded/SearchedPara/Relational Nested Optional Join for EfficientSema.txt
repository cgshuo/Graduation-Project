 The Semantic Web [6] has recently gained tremendous momentum due to its great potential for providing a common framework that allows data to be shared and reused across application, enterprise, and community boundaries. Semantic data is represented in Resource Descrip tion Framework (RDF) [1], the standard language for annotating resources on the Web, and queried using the SPARQL [3] query language for RDF that has been r ecently proposed by the World Wide Web Consortium. RDF data is a collection of statements, called triples ,ofthe form &lt;s,p,o&gt; ,where s is a subject, p is a predicate and o is an object, and each triple states the relation between the sub ject and the object. Such collection of triples can be represented as a directed gr aph, in which nodes represent subjects and objects, and edges represent predica tes connecting from subject nodes to object nodes. SPARQL allows the specification of triple and graph patterns to be matched over RDF graphs.

Increasing amount of RDF data on the Web d rives the need for its efficient and ef-fective management. In this light, numerous researchers [12,9,20,19,14,22,7,21,18] have proposed to use RDBMSs to store and query RDF data using the SQL and SPARQL query languages. One of the most challenging problems in such an ap-proach is the translation of SPARQL queries into relational algebra and SQL. The first few attempts [9,12] at the SPARQL-to-SQL translation, although successful, revealed serious difficultie s related to correctness and e fficiency of such translation in the presence of nested optional graph patterns. The challenges of the SPARQL query processing in the presence of nested OPTIONAL patterns include:  X  Basic semantics of OPTIONAL patterns . The evaluation of an OPTIONAL clause  X  Semantics of shared variables in OPTIONAL patterns . In general, shared vari- X  Semantics of nested OPTIONAL patterns . Before a nested OPTIONAL clause is
In existing SPARQL-to-SQL translation work [9,12,14,20], the handling of these three semantics in a relational database relies on the use of the left outer join (LOJ) defined in the relational algebra and SQL: (1) basic semantics of OPTIONAL patterns is captured by LOJ; (2) semantics of shared variables is treated with the conjunction of equalities of corresponding relational attributes in the LOJ condition; (3) semantics of nested OPTIONAL patterns is preserved by the NOT NULL check in the LOJ condition for one of the attributes/variables that correspond to the parent of a nested OPTIONAL clause. In the following, we present our running example to illustrate the translation of a SPARQL query with a nested OPTIONAL into a relational algebra ex pression, in which LOJ is used for implementing nested optional graph patterns; the example motivates the introduction of a new relational operator for a more efficient implementation. Example 1. (Sample SPARQL query and its relational equivalent)
Consider the RDF graph presented in Figure 1(a). The graph describes aca-demic relations among professors and graduate students in a university. The RDF schema defines two concepts/classes ( Professor and GradStudent )andtwo relations/properties ( hasAdvisor and hasCoadvisor ). Each relation has the Grad-Student classasadomainandthe Professor class as a range. Additionally, two instances of Professor , two instances of GradStudent and relations among these instances are defined as shown in the figure.
 We design a SPARQL query that returns (1) every graduate student in the RDF graph; (2) the student X  X  advisor if this information is available; and (3) the student X  X  coadvisor if this information is available and if the student X  X  advisor has been successfully retrieved in the pr evious step. In other words, the query returns students and as many advisors as possible; there is no point to return a coadvisor if there is even no advisor for a student. The SPARQL representation of the query is as follows.
The query has three variables: ?stu for the student, ?adv for the advisor, and ?coadv for the coadvisor. There are two OPTIONAL clauses, where the innermost one is the nested OPTIONAL clause.

Based on our translation strategy in [9], we translate the SPARQL query into a relational query as follows. Matching triples for the triple patterns ?stu rdf:type :GradStudent , ?stu :hasAdvisor ?adv ,and ?stu :hasCoadvisor ?coadv are retrieved into relations R 1 ,R 2 ,andR 3 , respectively. Note that the triple patterns are annotated with the corresponding relations and relational schemas in the SPARQL query above. Then the equivalent relational algebra representation is
Each OPTIONAL clause corresponds to the left o uter join, the shared variable ?stu participates in the join conditions, and the nested OPTIONAL implements the NOT NULL check on the adv attribute to ensure that its parent clause has indeed succeeded. The graphical represent ation of the relational query is shown in Figure 1(b); the projection operators are not shown for ease of presentation.
The running example motivates our research. The following is our insight to how the LOJ based query in Figure 1(b) wastes some computations: (1) Based on the result of the first LOJ and the semantics of the nested OPTIONAL pattern, we know that the NULL padded tuple ( Natalia , NULL ) will also be NULL padded in the second LOJ. After all, there is n o need for this tuple to participate in the second LOJ condition. (2) On the other hand, we know that the successful match in the tuple ( Artem , Shiyong )containsno NULL s. There is no need to apply the NOT NULL check to this tuple.

In this paper, we propose to extend relational databases with an innova-tive operator that mimics the nested optional pattern semantics of SPARQL to enable efficient processing of nested op tional patterns in RDBMSs. The main contributions of our work include:  X  We propose to extend relational databases with a novel relational operator,  X  We design three efficient algorithms to implement the new operator in rela- X  Based on a real life RDF dataset, we demonstrate the efficiency of our al-Organization . The rest of the paper is organized as follows. In Section 2, we present our NOJ operator and highlight its advantages. We design three algo-rithms to implement NOJ in relational databases in Section 3 and report the results of our performance study in Section 4. In Section 5, we discuss related work. Finally, we provide our conclusions and future work in Section 6. In this section, we present our nested optional join operator that is to be used to evaluate nested OPTIONAL patterns in relational databases and highlight its advantages over the left outer join.

The operands of NOJ are twin relations instead of conventional relations. The notion of twin relation is introduced as follows.
 Definition 1 (Twin Relation). A twin relation, denoted as ( R b , R o ), is a pair of conventional relations with identical relational schemas and disjoint sets of tuples. The schema of a twin relation is denoted as  X  ( R b , R o ). R b with the schema  X  ( R b , R o )iscalleda base relation and R o with the schema  X  ( R b , R o )iscalledan optional relation . A distinguished tuple n  X  ( R in which each attribute takes a NULL value. Intuitively, a base relation is used to store tuples that have a potential to satisfy a join condition of a nested optional join. An optional relation is used to store tuples that are guaranteed to fail a join condition of a nested optional join. We incorporate the twin relation into the relational algebra by introducing the following additional operators, and  X  , such that  X  ( R b ,R o )= R b  X  R o ,and  X   X  ( R )=( R,  X  ), where  X  is an instance of empty relation with the same
Note that  X  is not a reversed operator of , because  X  ( ( R b ,R o )) =( R b ,R o ) in general.

We also extend the projection and selection operators to a twin relation as definition of a complete algebra for a twin relation is not our focus in this paper;  X  and  X  are sufficient for our running example and experimental study and, as we believe, for most SPARQL-to-SQL translations.

In the following, we define a novel relational operator, nested optional join , using the tuple calculus.
 Definition 2 (Nested Optional Join). A nested optional join of two twin ( S b ,S o )=( Q b ,Q o ) ,where Q b = r ( a )= s ( b ) } and Q o = { t | t = rn  X  ( r  X  R o  X  ( r  X  R b  X  X  X  s [( s  X  S b  X  s  X  S s ( b )  X   X  ( S b ,S o ) are join attributes, n = n  X  ( S In other words, the result base relation Q b contains tuples t made up of two parts, r and s ,where r must be a tuple in relation R b and s must be a tuple in S b or S o .Ineachtuple t , the values of the join attributes t ( a ), belonging to r , are identical in all respects to the values of join attributes t ( b ), belonging to s . The result optional relation Q o contains tuples t made up of two parts, r and n , where r must be a tuple in R o with no other conditions enforced, or r must be a tuple in R b and there must not exist a tuple s in S b or S o that can be combined with r based on the predicate r ( a )= s ( b ).

The graphical illustration of the NOJ operator is shown in Figure 2. Note how well it emphasizes one of the advantages of NOJ: the flow of tuples from R o to Q o bypasses the join condition and does not interact with tuples from any other relation. Obviously, the behavio r of this flow can be implemented to have linear time performance in the worst case  X  the property that is, in general, not available in the LOJ implementations. The second important advantage of NOJ  X  X oneedforthe NOT NULL check  X  is discussed in the following example that describes the translation of our sample SPARQL query into a relational algebra expression with our extensions.
 Example 2 (Evaluation of the sample SPARQL query using NOJs)
We use the same RDF graph as presented in Figure 1(a) and the SPARQL query described in Example 1. The translation strategy is similar to the one illus-trated in Example 1 except that we use NOJ instead of LOJ. Matching triples for the triple patterns ?stu rdf:type :GradStudent , ?stu :hasAdvisor ?adv , and ?stu :hasCoadvisor ?coadv are retrieved into relations R 1 ,R 2 ,andR 3 , respectively. Then the equivalent relatio nal algebra representation using NOJ is
The graphical representation of the relational query is shown in Figure 3; the conversion and projection operators are not shown for ease of presentation. Note that this query does not contain the NOT NULL check, because all the tuples that have not succeeded in the first join are padded with NULL values and stored into the optional relation R 4 o ; the tuples of R 4 o bypass the second join condition and are copied directly to R res o with additional NULL -padding.
 Therefore, NOJ is superior to LOJ when we apply them to translate SPARQL nested OPTIONAL clauses to relational queries. The main advantages of NOJ are (1) NOJ allows the processing of the tuples that are guaranteed to be NULL padded very efficiently (in linear time), (2) NOJ does not require the NOT NULL check to return correct results, and (3) NOJ significantly simplifies the SPARQL-to-SQL translation, eliminating the need to choose a relational attribute for the NOT NULL check 1 and, in some cases (see [9]) when such an attribute can not be chosen from available ones, the need to introduce a new variable and even a new triple pattern into a SPARQL query. Our performance study showed that these advantages bring substantial speedup to the query evaluation. Previously, we defined NOJ through the tuple calculus, but it is also possi-ble to express the NOJ result relations using standard operators of the rela-( S direct translation will be inefficient if i mplemented. Therefore, in this section, we design our own algorithms to implement NOJ in a relational database. Our algorithms, NL-NOJ , SM-NOJ ,and SH-NOJ , employ the classic methods used to implement relational joins: nested-loops, sort-merge, and hash-based join meth-ods, respectively. 3.1 Nested-Loops Nested Optional Join Algorithm The simplest algorithm to perform the NOJ operation is the nested-loops NOJ algorithm, denoted as NL-NOJ . The algorithm (see Figure 4) is self-descriptive, and thus we only clarify some importan t details. Note that for efficiency, the inner loop in line 07 should iterate over the tuples of a (twin) relation with higher cardinality. This remark is only valid when I/O operations are involved, and can be ignored for in-memory join processing. In the figure, we assume that ( S b ,S o ) has more tuples than R b . Also, note that the tuples of R o are processed in linear time in lines 17-19.

The results of our complexity and applicability analysis are  X  NL-NOJ complexity :  X  ( | R b | X  ( | S b | + | S o | )+ | R o | ).  X  NL-NOJ applicability : NOJs with high selectivity factors (see our perfor-
The comprehensive analysis of the performance and applicability of the nested-loopsjoinmethodispresentedin[17].Int he join processing literature, there is a number of optimizations on the nested-loops join method that are also applica-ble to NL-NOJ : e.g., the block nested-loops join method [15,13] and  X  X ocking X  the inner relation optimization [16] that reduce the number of I/O operations. 3.2 Sort-Merge and Simple Hash Nested Optional Join Algorithms Due to the space limitation, we omit (see [8] for details) the description of the sort-merge NOJ algorithm, SM-NOJ , and the simple hash NOJ algorithm, SH-NOJ .

The results of our complexity and applicability analysis are  X  SM-NOJ applicability : SM-NOJ is the best choice when NL-NOJ or SH-NOJ  X  SH-NOJ applicability : NOJs with low selectivity factors.

The comprehensive analysis of the performance and applicability of these join methods is presented in [17]. This section reports the performance experiments conducted using the NOJ algorithms and an in-memory relational database. The performance of the NOJ algorithms is compared with the performance of the corresponding LOJ-based implementations. In addition, the behavior of the NOJ algorithms with respect to the NOJ selectivity factor is explored and reported in [8]. 4.1 Experimental Setup We implemented in-memory representations of a relation and a twin relation, such that each relation was represented by a double-linked list of tuples, where each tuple corresponds to an array of pointers to attribute data values, and each twin relation was represented by pointers to two conventional relations. The memory to store relations and their tuples was allocated dynamically in the heap.

Our algorithms NL-NOJ , SM-NOJ and SH-NOJ were implemented in C++ using MS Visual C++ 6.0. To compare the performance of queries evaluated with our algorithms and corresponding left outer join algorithms, we implemented nested-loops LOJ ( NL-LOJ ), sort-merge LOJ ( SM-LOJ ), and simple hash LOJ ( SH-LOJ ) algorithms (see, e.g., [17]).
 The experiments were conducted on the PC with one 2.4 GHz Pentium IV CPU and 1024 MB of main memory operated by MS Windows XP Professional.
The timings reported below are the mean result from five or more trials with warm caches. 4.2 Dataset and Queries We conducted the experiments using the OWL representation of WordNet [5] (version: 1.2; author: Claudia Ciorascu), a lexical database for the English language.

We chose nine SPARQL [3] queries to evaluate in our experiments based on the following criteria: (1) most queries should have nested OPTIONAL clauses; (2) the input, intermediate, and output (twin) relations involved in the query evaluation should fit into the main memory; and (3) some queries should have common patterns to reveal p erformance changes with increasing complexity of the queries.

An important characteristic of the test queries is that they only involve joins, whose selectivity factors are less than 0.0002 and, for most joins, are less than 0.00002. Join selectivity factor (JSF) is a factor to represent the ratio of the cardinality of a join result to the cross product of the cardinalities of the two join (twin) relations. The reason why we chose queries with only joins with low selectivity factors is that the result of a join should fit into the main memory. 4.3 Experiments Figure 5 shows the results of four experiments that measure query evaluation time for the NOJ and LOJ algorithms. Note that the NOJ algorithms outper-formed the LOJ-based implementation s for all queries except for Q1 and Q2, because Q1 and Q2 contained no nested OPTIONAL s and thus could not benefit from NOJ. Corresponding NOJ and LOJ based implementations showed equal performance for Q1 and Q2.

The description of the algorithm performance for individual test queries is available in [8].

In summary, NOJ, (R b ,R o )  X  (S b ,S o ), has the performance advantage over the left outer join counterpart when used to evaluate nested OPTIONAL s, because (1) R o is always processed in linear time by a NOJ algorithm and (2) NOJ does not require the NOT NULL check. Our experiments on the real life dataset showed that this advantage is significant.
 The join operation defined in the relational data model [10,11] is used to combine tuples from two or more relations based on a specified join condition. Several types of joins, such as theta-join, equi-join, natural join, semi-join, self-join, full outer join, left outer join, and right outer join, are studied in database courses [15,13] and implemented in RDBMSs. We introduce a new type of join, nested optional join, whose semantics mimics the semantics of optional graph patterns in SPARQL [3]. NOJ is defined on two twin relations, where each twin relation contains a base relation and an optional relation; therefore, NOJ can be viewed as a join of four conventional relations. The result of NOJ is also a twin relation, whose base relation sto res tuples that have been concatenated and whose optional relation stores tuples that have been NULL padded. The above semantic and structural characteristics differentiate NOJ from any other join defined in the literature. We propose NOJ as a favorable alternative to the LOJ-based implementations for the nested optional graph pattern processing with relational databases. Note that NOJ is not a replacement of LOJ: their semantics are different, such as LOJ needs a special NOT NULL check to return similar results to the NOJ results and this check is not part of NOJ.
The join processing in relational databases has been an important research for over 30 years and the related literature is abundant [17]. To design algorithms for NOJ, we use three classical methods for implementing joins in RDBMSs: nested-loops, sort-merge, and hash-based join methods [15,13]. These methods have numerous optimizations which are out of the scope of this paper.
In this paper, for the SPARQL-to-SQL translation, we used our SPARQL-toSQL algorithm presented in [9]; SPARQLtoSQL translates SPARQL queries with arbitrary complex optional patterns into SQL.

It is worthwhile to mention that SPARQL is not the only RDF query language that supports optional graph patterns. Other examples include SeRQL [4] and RDFQL [2], and NOJ is useful for these languages, too. We have proposed a novel relational operator, nested optional join, that enables efficient processing of Semantic Web queri es with nested optional patterns. The computational advantage of NOJ over the currently used LOJ-based implemen-tations comes from the two superior characteristics of NOJ: (1) NOJ allows the processing of the tuples that are guaranteed to be NULL padded very efficiently (in linear time) and (2) NOJ does not require the NOT NULL check to return cor-rect results. In addition, (3) NOJ significantly simplifies the SPARQL-to-SQL translation. To facilitate the implementation of NOJ in relational databases, we have designed three efficient algorithms: (1) nested-loops NOJ algorithm, NL-NOJ , (2) sort-merge NOJ algorithm, SM-NOJ , and (3) simple hash NOJ al-gorithm, SH-NOJ . Based on the real life RDF dataset, we verified the efficiency of our algorithms by comparing them with the corresponding left outer join implementations. The experimental res ults are very promising; NOJ is a favor-able alternative to the LOJ-based evaluation of nested optional patterns in the Semantic Web query processing with relational databases.

The future work includes the introduction of a parallel optional join operator for parallel OPTIONAL s in SPARQL and the definition of a relational algebra for SPARQL with these novel operators.

