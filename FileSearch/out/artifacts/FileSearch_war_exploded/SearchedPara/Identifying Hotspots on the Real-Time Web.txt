 We study the problem of automatically identifying  X  X otspots X  on the real-time web. Concretely, we propose to identify highly-dynamic ad-hoc collections of users  X  what we re-fer to as crowds  X  in massive social messaging systems like Twitter and Facebook. The proposed approach relies on a message-based communication clustering approach over time-evolving graphs that captures the natural conversa-tional nature of social messaging systems. One of the salient features of the proposed approach is an efficient locality-based clustering approach for identifying crowds of users in near real-time compared to more heavyweight static cluster-ing algorithms. Based on a three month snapshot of Twit-ter consisting of 711,612 users and 61.3 million messages, we show how the proposed approach can efficiently and effec-tively identify Twitter-based crowds relative to static graph clustering techniques at a fraction of the computational cost. H.3.3 [ Information Search and Retrieval ]: Clustering; H.3.4 [ Systems and Software ]: Current awareness sys-tems Algorithms, Performance, Experimentation Real-time, Social, Graph, Clustering
This paper focuses on identifying emerging  X  X otspots X  on the real-time social web. The social web is the fastest grow-ing phenomenon on the web, enabling millions of users to generate and share knowledge. Example sites include Face-book, Flickr, and Twitter; similar social systems are increas-ingly being adopted by governments and enterprises inter-ested in exploiting the emergent collective knowledge ( X  X is-dom of the crowds X ) embedded in the activities and actions of their users. In general, a  X  X otspot X  could be defined by the posting and sharing actions of users in social systems, for ex-ample triggered by an offline event (e.g., Facebook posts and Tweets in response to a live Presidential debate or a chemical fire at a nearby refinery) or by an online phenomenon (e.g., reaction to Internet memes, online discussion). Detecting these hotspots as they arise in real-time is an important and fundamental building block for enabling new real-time web applications, applications related to identification and dis-semination of disaster and emergency-related information, content personalization, social information discovery, among many other emerging social mining applications.

Towards the goal of identifying online hotspots, we fo-cus in this paper on identifying crowds of users through an analysis of their online actions. A single user action  X  for example, posting a Tweet mentioning a smoke plume at a nearby factory  X  though perhaps interesting itself, does not convey a strong community or social-based importance to the user action. In contrast, a flurry of activity associated with a  X  X rowd X  is a strong indicator of an emergent online phenomenon that may be worth identifying and directing to interested users. Unlike the more static and long-lived group-based membership offered on many social networks (e.g., fan of the LA Lakers), our goal is to support the discov-ery of organic and highly-temporal group affiliation, which we refer to as transient crowds .

Transient crowds are dynamically formed and potentially short-lived. Hence, it is a major challenge to efficiently iden-tify coherent crowds across a potentially vast collection of non-obviously connected user actions. Considering Twitter alone, there are potentially 100s of millions of active users inserting new messages into the system at a high-rate. How can we identify and extract real-time crowds efficiently with-out sacrificing crowd quality?
We propose to model crowd formation through a message-based communication clustering approach over time-evolving graphs. The efficient locality-based clustering approach for identifying crowds of users is developed on the notion that changes in a small region of a graph should not affect the entire graph (reflecting locality in the messaging system).
Historically, direct communication between people has been mostly unobservable or unavailable for large-scale web min-ing. But with the rise of new social messaging systems like Twitter and Facebook, communications between users can be monitored. For example, Twitter supports the public messaging of users through the inclusion of @  X  username  X  in a Twitter post (a  X  X weet X ). So a tweet from the user nod can be addressed to the user kykamath like so:  X  X kykamath What do you think about the new iPad? X . This type of ob-servable communication is on the rise and a significant por-tion of all messages posted on Twitter, with estimates plac-ing the percent of all tweets containing the @  X  username  X  at 30% (or about 7 million observable communications per day) [1]. Based on these observable communication patterns, we study how to efficiently discover transient crowds. We now give some definitions before framing the problem.
 Definition (Time-Evolving Communication Network) A time-evolving communication network is an undirected graph G t ( V, E ) graph with | V | = n vertices and | E | = m edges, where each vertex corresponds to a user in the social messaging system and an edge corresponds to a communi-cation between two users. The weight of an edge between vertices u and v at time t is represented by w t ( u, v ).
The communication network is time evolving because the relationship between users  X  as indicated by w t ( u, v )  X  changes over time. For concreteness, we focus on purely communication-based properties (the recency and number of messages between the users) for determining the edge weights in the time-evolving communication network. Definition (Transient Crowd) : A transient crowd C  X  K t is a time-sensitive collection of users who form a cluster in G t , where K t is the set of all transient crowds in G A transient crowd represents a collection of users who are actively communicating with each other at time t .

Our goal then is to discover the set of transient crowds K that exist in the communication network G t ( V, E ) at time t . For practical crowd discovery in a large time-evolving com-munication network, however, we face two key challenges: First, systems like Facebook and Twitter are extremely large (on the order of 100s of millions of unique users), plac-ing huge demands on the computational cost of traditional community detection approaches (which can be O ( n 3 the number of users [3]). Second, these services support a high-rate of edge addition (new messages) so the discovered crowds may become stale quickly, resulting in the need to re-identify all crowds at regular intervals (again, incurring the high cost of community detection). The bursty nature of user communication demands a crowd discovery approach that can capture these highly-temporal based clusters.
To support transient crowd discovery in Twitter-like ser-vices with 100s of millions of participants, we propose to leverage the inherent locality in social messaging systems. Intuitively, transient crowds are made up of a very small percentage of users compared to the entire population of the social network. Hence, new messages (corresponding to the addition of edges to the communication network) should have only a local influence on the crowds that exist at any given time. That is, changes in a small region of a graph should not affect the entire graph. In a dataset of 61 mil-lion Twitter messages described in Section 3, we have con-firmed the existence of this spatial locality by finding that only about 1% of users are within two hops, meaning that an edge insertion has only a local effect.

To take advantage of spatial locality, we propose to aug-ment a traditional (expensive) graph clustering algorithm by selectively applying the algorithm to small portions of the entire communication network, thereby saving the compu-tational cost of running the algorithm over the entire large network. Let C ti represents the i th crowd in K t . Users are assigned to one and only one crowd, i.e., C ti  X ,  X  C ti ,C tj  X  K t . To discover K t , we could apply one of a number of graph clustering algorithms, including MCL [6], multilevel graph clustering [2], etc. For concreteness in this paper, we consider min-cut clustering [3, 4], a popu-lar graph clustering algorithm that has shown good success across real-world datasets like web pages, citation networks, etc. To begin our development of locality-based clustering, we first present some preliminaries to describe min-cut clus-tering.
 Minimum cut: The minimum cut of a graph G with re-spect to vertices s and t , where s  X  S,t  X  T , is defined as partition of V into S and T such that, the total weight of edges connecting the partitions is minimum. This is repre-sented as c ( S,T ). For an undirected graph G we can define a weighted tree T G called the minimum-cut tree [4]. We can determine c ( S,T ) by analyzing the path from s to t in T where the value of c ( S,T ) is equal to the smallest edge on this path.
 Min-cut clustering: The min-cut clustering algorithm [3] clusters a graph G first by adding an artificial sink t . All of the vertices of G are connected to the artificial sink with an edge capacity of  X  , to form a modified graph G 0 , where  X  is a parameter guiding the quality guarantees of the resulting clusters. The minimum-cut tree T 0 for G 0 is then calculated. The connected components of T 0 obtained after removing the artificial sink t are clusters in G . Min-cut clustering relies on the special parameter  X  to ensure the quality of the clusters generated, where: with, P  X  Q =  X  and P  X  Q = S . By tuning this  X  parameter, the number and size of the resulting clusters can be varied (from one large cluster with all nodes to a trivial clustering consisting of n singleton nodes).
Of course, we could directly apply the min-cut clustering algorithm to the large time-evolving communication network G t directly. The output would be a set of clusters K t which we could take to be transient crowds, however, at a con-siderable expense. Coupled with the need to re-compute clusters as the network evolves, straightforward application of a traditional graph clustering approach is infeasible for efficient transient crowd discovery. Towards exploiting spa-tial locality for efficient crowd discovery, we must address two issues: (i) The application of min-cut clustering to a particular subgraph of the entire communication network; and (ii) The determination of which subgraphs of the com-munication network to select for clustering.
 Subgraph clustering: The first challenge is to perform local clustering, given an identified region of the commu-nication network (corresponding to some locally impacted portion of the network). By clustering a local region of the communication network we can begin to reduce the expense of clustering the entire network. Given a subgraph S (the part of the communication network impacted by edge addi-tion) to cluster, the algorithm first contracts G t to G 0 shown Algorithm 1, this approach then creates a new graph G t by adding an artificial sink w s to G 0 t and connecting all the vertices of S to t with edges of capacity  X  and all the ver-tices in ( V 0  X  S ) with edges of capacity of  X  | V  X  S | as in [5]. It then determines the minimum-cut tree T 00 t for G 00 t connected components obtained after removing w s from T 00 are the new clusters (which correspond to transient crowds). In this way, only a small portion of the communication net-work is impacted, leading to more efficient clustering that clustering the entire network.
 Algorithm 1 ClusterSubGraph ( S ) 1. Contract G t : Reduce G t to G 0 t by replacing vertices
V  X  S with a new vertex x . All the resulting loops are deleted and parallel edges are replaced with a single edge with weight equal to the sum of the edges. 2. Expand G 0 t : Construct a new graph G 00 t by adding vertex w s to G 0 t ( V 0 ,E 0 ). Connect w s to v,  X  v  X  S with edge capacity of  X  and w s to v 0 ,  X  v 0  X  ( V 0  X  S ) with edge capacity of  X  | V  X  S | . 3. Minimum-cut tree: Determine minimum-cut tree
T 00 t for G 00 t . The connected components obtained in T after removing vertices w s and x from it are the clusters in S .
 Subgraph selection: The second challenge is to deter-mine which subgraphs are to be selected for clustering, i.e. how do we select S in Algorithm 1? Selecting too many subgraphs for re-clustering may result in expensive compu-tation, whereas selecting too few may result in poor crowd quality. Following [5], we adopt an approach triggered on each edge insertion to identify subgraphs that need to be clustered. Depending on the position where an edge is in-serted and the effect of edge addition on the quality of clus-tering there are four ways to select clusters for local clus-tering. The first case is when an edge is added within an existing cluster C u . In this case there is a probability that this addition might have resulted in subclusters within C that improve clustering quality. Hence, only C u is selected for clustering ( Case i ). An edge can also be added between 2 clusters. In this case, if the quality of clustering is main-tained in spite of this edge addition, then re-clustering is not required ( Case ii ). Otherwise, if the quality of cluster-ing is reduced, then we select both clusters for re-clustering ( Case iv ). If the addition of an edge between 2 clusters results in satisfying the condition for cluster merging, then the 2 clusters are merged ( Case iii ). The pseudocode for subgraph selection is given in Step 2 of Algorithm 2.
In this section we explore the impact of locality-based crowd discovery compared to the static graph clustering ap-proach without the locality optimizations.
To study crowd detection in a real-world setting, we focus on the Twitter micro-blogging service. Through a mix of Algorithm 2 Locality Clustering Algorithm
For every new edge ( u,v ) added to the graph, perform the following 3 steps. 1. Initialization: If the added edge has vertices that have not been observed before add them to vertex set
V . Create singleton clusters for the new vertices and add them to cluster set K . 2. Clustering: Let u , v belong to clusters C u and C v respectively. Now depending on the conditions that match perform the corresponding clustering operations: updating the edge weights might have resulted in forma-tion of clusters within this cluster. Check for new clusters using ClusterSubGraph ( C u ).
 and the addition of the edge does not reduce the qual-ity of clustering, then perform no action. The quality of the clustering is maintained if the following inequalities (Equation 1) are satisfied. and the addition of the edge satisfies the merging condi-ters and the previous 2 conditions are not met then the quality of clustering has reduced. Hence, perform
ClusterSubGraph ( C u  X  C v ) to generate clusters that maintain clustering quality. crawling and API calls to the Twitter service, we collected a sample of tweets from October 1 st to December 31 st , 2008, accounting for 2208 hours (see Table 1 for details). The dataset includes over 710,000 users and over 61.3 million status updates ( X  X weets X ) of 140 characters or less. Users can annotate their tweets via the inclusion of hashtags (e.g.,  X #redsox X ) to indicate a particular topic. Similarly, users can include @mentions of the form @  X  username  X  within a tweet to reference another user. While these @mentions can serve many purposes, the most popular use is as a simple messaging framework, so that a message posted by user u 1 including @  X  u 2  X  is considered a message from u 1 to u
Of the, 61.3 million tweets in the dataset, 20.4 million contain the @  X  username  X  syntax and are considered mes-sages from one user to another. 3.7 million pairs of users are connected by these messages.

In the first set of experiments, we investigate the efficiency and quality of the proposed locality-based clustering ap-proach for crowd discovery. Since social messaging systems are large with a high rate of new messages, it is important for crowd discovery to be efficient; but efficiency must be balanced with the quality of the discovered crowds. As a baseline for comparison, we considered the min-cut cluster-ing algorithm [3] without the locality-based optimizations. Since min-cut clustering is designed for static graphs, we took snapshots of the time-evolving communication network every hour and then ran min-cut clustering over each of these hourly snapshots, resulting in 2208 total crowd sets. Running time : In Figure 1(a), we show the running time comparisons between min-cut clustering and the locality-based crowd discovery approach (note that we focus on the first 30 hours for presentational detail; the general trends hold across the duration). The top plot in Figure 1(a) shows the growth in users and messages; the middle plot shows the running time of min-cut clustering; the bottom plot shows the running time of online clustering algorithm. The first ob-servation is that the proposed approach is at least 100 times faster than non-locality optimized approach in all cases, and upwards of 1,000 times faster in some cases. Next, we ob-serve the impact the growing number of users and interac-tions has on the running time of these algorithms. We see that the running time of the min-cut algorithm is propor-tional to the increase in users and interactions, while our algorithm, because of its locality optimizations, has almost a constant running time. Spatial locality allows our algo-rithm to cluster a relatively small part of the graph. Crowd quality : Although the proposed locality-based ap-proach results in a much faster crowd discovery, there may be a cost in terms of crowd quality. To gauge this cost, we measure the quality of the discovered crowds using the ratio-association value [2], which seeks to maximize the weight of edges within a cluster: maximize P k i =1 c ( C i this objective, we measure the ratio-association values for both min-cut clustering and the proposed approach. In Fig-ure 1(b), we show the ratio of ratio-association values for both algorithms versus the proposed approach; the ratio-association value for local-clustering (online) is indicated using black bars of height 1. We see that during the ini-tial intervals, the ratio-association of the min-cut algorithm is more than that for the locality-based approach, but the ratio continues to decrease with time. We see significant improvements by the time we reach the 30 th interval. This shows that as the size of the graph grows the quality of clusters generated by the locality-based approach increases.
Toward the goal of detecting hotspots on the real-time web, we have studied the problem of automatically discov-ering transient crowds in highly-dynamic social messaging systems like Twitter. We presented a locality-based cluster-ing algorithm for a time-evolving communication network that relies on the inherent spatial locality of transient crowds to support efficient crowd detection. As part of future work, we plan to investigate hybrid approaches that build on the communication-based approach presented here  X  e.g., by considering content-based and geographic-based similarity across users to serve as the basis of crowd formation. [1] A website that maintains statistical information about [2] I. Dhillon, Y. Guan, and B. Kulis. A fast kernel-based [3] G. W. Flake, R. E. Tarjan, and K. Tsioutsiouliklis. [4] R. E. Gomory and T. C. Hu. Multi-terminal network [5] B. Saha and P. Mitra. Dynamic algorithm for graph [6] S. Van Dongen. Graph clustering via a discrete
