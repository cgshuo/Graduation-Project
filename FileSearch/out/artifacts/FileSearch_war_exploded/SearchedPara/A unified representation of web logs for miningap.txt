 Abstract The collective feedback of the users of an Information Retrieval (IR) system has been shown to provide semantic information that, while hard to extract using standard IR techniques, can be useful in Web mining tasks. In the last few years, several approaches have been proposed to process the logs stored by Internet Service Providers (ISP), Intranet proxies or Web search engines. However, the solutions proposed in the literature only partially represent the information available in the Web logs. In this paper, we propose to use a richer data structure, which is able to preserve most of the information available in the Web logs. This data structure consists of three groups of entities: users, documents and queries, which are connected in a network of relations. Query refinements correspond to separate transitions between the corresponding query nodes in the graph, while users are linked to the queries they have issued and to the documents they have selected. The classical query/document transitions, which connect a query to the documents selected by the users X  in the returned result page, are also considered. The resulting data structure is a complete representation of the collective search activity performed by the users of a search engine or of an Intranet. The experimental results show that this more powerful repre-sentation can be successfully used in several Web mining tasks like discovering seman-tically relevant query suggestions and Web page categorization by topic.
 Keywords Web logs User feedback Query similarity Query recommendations Query suggestions Text categorization for the web 1 Introduction In the last few years there has been a growing interest from the IR community on how the implicit feedback from users can be used to deliver a better search experience. For example, the feedback has been shown to allow a better understanding of users X  search needs and to help in establishing document relevance with a higher degree of accuracy than what can be provided by standard IR techniques. While the analysis of the users X  inter-action is potentially relevant for any IR system, most work in the literature concentrates on Web logs, because they are widely available in many contexts, as they are stored by Web search engines, Internet providers and by many institutions and enterprises that manage a HTTP proxy as a gateway for their Intranets.

A common approach is to represent the user feedback as a query/document bi-partite graph (Craswell and Szummer 2007 ; Baeza-Yates et al. 2005b ), where the queries are connected to the corresponding documents selected by the users and vice versa. The bipartite graph has been shown to be useful in improving the ranking of pages, for example by providing additional results for a query by selecting documents among the relevant results of similar queries (Craswell and Szummer 2007 ). Using random walks over the bi-partite graph, it is also possible to determine groups of related entities, which can be used in several applications like document or query suggestion (Baluja et al. 2008 ).
Other authors focused on modeling the users X  query refinements (sequence of queries issued in a single search session) by building a query-flow graph (Boldi et al. 2008 ; Baeza-Yates et al. 2005b ). Another related approach has been proposed in the context of mod-eling folksonomies, which can be represented as a tri-partite document-user-tag graph, which has been successfully applied in Web ranking tasks (Hotho et al. 2006 ).

In spite of the good results obtained by these approaches, these data representations do not fully capture the richness of the information available in the Web logs. In this paper, we start from the query-document bi-partite graph proposed in (Craswell and Szummer 2007 ), which is augmented to represent each single user as a separate node. User nodes are then linked to the queries they have issued and to the documents they have selected. Furthermore, we directly represent query refinements performed by the users as separate transitions between the corresponding query nodes in the graph similarly to (Boldi et al. 2008 ). The resulting data structure is a much richer representation of the collective search sessions, since it can compactly and consistently represent all the fundamental actions performed by the users such as issuing queries, selecting documents, and query refine-ments. We present two general learning frameworks to process the data structure in supervised and unsupervised Web mining tasks. The frameworks scale up to graphs with billion of nodes that are the norm in the Web context. The experimental results evaluate the proposed learning frameworks and confirm that this extended representation can be suc-cessfully used both in clustering and classification tasks. In particular, we report experi-ments on discovering semantically relevant query suggestions and on text categorization by topic.

The outline of the paper is the following; Sect. 2 shows how the graphical representation of the Web logs is built. Section 3 introduces some applications that can be potentially faced by using the proposed data structure. Section 4 presents the unsupervised algorithmic solutions that have been devised to discover related entities over the graph, while Sect. 5 presents the approach adopted to perform entity classification over the graph. Section 6 reports some experiments showing the effectiveness of the proposed solution over the task of discovering query suggestions and Web page categorization by topic. Finally, Sect. 7 draws some conclusions (Fig. 1 ). 2 A complete graphical representation of web logs Three classes of entities emerge as the fundamental actors when analyzing Web sessions: users, queries and documents. These entities feature specific relationships among them: a user issues a query for which a set of documents is returned. The user then either selects a document, or refines the previous query, or ends the search session.

Most work in the literature has so far focused on creating a graphical model of a subset of the information available in the logs by using either:  X  the query-document bi-partite graph (Craswell and Szummer 2007 ), connecting each  X  the query-flow graphs representing query refinements (Jones et al. 2006 ; Boldi et al.  X  the document-user-tag tri-partite graph to represent folksonomies (Hotho et al. 2006 ). However, richer models and algorithms that are able to represent and take into account all the users X  actions composing the search sessions could provide a significant advantage in many applications. This section attempts at defining this more representative data structure.
Let G be a graph formed over a set of nodes, each of which corresponds to an entity in the logs (either a user, a query or a document). As explained in the following sections, the nodes are connected based on relationships among the corresponding entities. Let Q ; D ; U be the set of nodes representing the queries, the documents and the users, respectively. It holds that each node in G belongs to exactly one of Q ; D ; U . Thus, Q\D X  Q\U X D\U X ; .

Each edge connecting two nodes in G is assigned a weight modeling the strength of the connection. In the following paragraphs, we explain how the connections are formed and how the corresponding weights are determined. Obviously, while the employed heuristics are natural and sound, they are by no means the best conceivable and other approaches could be pursued. 2.1 Queries and documents This portion of the graph has been extensively studied in the previous literature. We followed exactly the approach proposed in (Craswell and Szummer 2007 and Szummer and Craswell 2008 ) to establish the connections and set the weights between query and doc-ument nodes. Let s ( q , d ) be the number of times that the document d has been selected by a user after having issued a query q . Then, where S QD is a smoothing factor which penalizes the connections departing from nodes that have been observed few times in the available logs and for which the weights can not be estimated with high confidence (e.g. relations for which little evidence is available tend to get assigned a smaller strength weight, this a common assumption made in Bayesian parameter estimation). a QD is a parameter which determines the limit for total sum of the query-document edge weights, exiting from any query node q .If P i 2D s  X  q ; i  X  S QD , then query nodes.

A document is connected to set the of queries for which it has been selected. The weight associated to each connection is where S DQ is the smoothing factor for this set of edge weights and a DQ is a parameter determining the limit for the total sum of the document-query weights for each document node.

Please note that document-to-query and query-to-document connections are symmetric but their associated weights are not. This is needed to enforce that the sum of all weights have a probabilistic interpretation. 2.2 Users and documents Every time a user visits a document, he/she is expressing a preference for that document to some extent. Let v ( u , d ) be the number of times a user u visited a document d , then the weight of the ( u , d ) connection is set equal to where S UD is the smoothing factor used for this category of weights and a UD determines the total strength of the user-document connections out of any user u .

Similarly, the weight of the connection from a document to a user is determined by where S DU is another smoothing factor and a DU determines the total strength of the doc-ument-user connections for each single document node u .
Please note that the definition of visit has been left very general on purpose: a user can visit a document after having issued a query to a search engine or, in general, as the result of his/her browsing activity. Search engines can track only the user visits in response to a search or the entire browsing session may be occasionally available via toolbar logs. An Internet provider or a HTTP proxy for an Intranet can always track all users X  visits, creating a larger number of connections. Our model can deal with both these cases, even if only visits following searches have been tested in the experimental section. 2.3 Users and queries Let n ( q , u ) be the number of times a query q has been issued by a user u . Using the same approach as for the previous entity types and where S UQ and S QU are the smoothing factors, a UQ and a QU determine the upper limit of the total sums of the user-to-query and query-to-user edge weight, respectively. 2.4 Query refinements Query-query connections model query refinements. A query refinement is a pair of queries that are often issued in a sequence by the users and that share a common or closely related search goal. Those queries should be treated as part of a single search session. This class of node connections is harder to model starting from the logs, because it is not often clear when a query refinement has happened versus when there is a shift in the goal of the search activity (in the latter case the queries do not belong to the same session and should not be connected). Determining whether two queries are part of the same logical session is still an open research problem (He et al. 2002 ; Huang et al. 2004 ) and the commonly employed techniques rely on simple heuristics. In our implementation, we consider two queries as part of the same session, if they are consecutive and they are issued within 300 s. While this definition triggers many false positives, the weight computation described in the following of the paragraph keeps the resulting noise under control.

Let | q | be the number of times that a query q has been issued. The prior probability that a user will issue q as his/her next query is: p  X  q  X  X  j q j P link assigned to the weight where a QQ is a constant parameter setting the upper limit for the total sum of the refinement weights for any query node
As shown by ( 1 ), the weight of a link connecting a query q to one of its refinements q 0 is issue q 0 as a refinement is larger than the prior probability of query q 0 . If a query does not have any refinement which occurs more often that its prior probability, no refinement connections are established.

Let r  X  q ; q 0  X  be the number of times that a user refined the query q with q 0 , p  X  q 0 j q  X  is refinements that have been observed only few times.

Substituting in ( 1 ) the estimates for p  X  q 0 j q  X  and p  X  q 0  X  , yields 2.5 Building the complete graph As explained in the next sections, some Web mining applications require to perform random walks over the graph representation of the logs. In order to have a parameter controlling the speed of convergence for the walk, it is useful to add a self-connection of each node to itself. We indicate with s ( i ) the weight of the self-connection for node i . Larger self-connection weights increase the expected number of iterations needed to move away from any starting point during the random walk.

In our setting, all the self-connection weight are initially assigned the same value s ,in the following of this section we explain how they are later adjusted for each single node.
The graph G is built by considering the self-connections together with all the con-nections defined in Sects. 2.1 , 2.2 , 2.3 , 2.4 . In order to be able to perform random walks over the generated graph, the connections exiting from each node should sum up to one. Therefore, we impose that s  X  a QU  X  a QD  X  a QQ  X  1 for each node corresponding to a query, s  X  a DQ  X  a DU  X  1 for each document node and, finally, s  X  a UD  X  a UQ  X  1 for each user node.

Unfortunately, the smoothing factors used for all the transition weights prevent the sum of all the weights out of a node from summing up to one. Let X  X  for example consider the query-document weights, for any node q , it holds that P d 2D w  X  q ; d  X  \ a QD .

For each query node q , we introduce the set of differences that measure the amount needed to fulfill the probabilistic constraint Similarly for each document node d , And, finally for, each user node u , These quantities can significantly differ over the nodes.

For each node i , the overall amount missing to achieve stochasticity is
The self-connection weight can be used to fulfill the probabilistic normalization for each node i by adding k ( i ) to the initial value s This choice models the fact that the less amount of evidence is globally available in a node, the less the connections can be reliably established. In the context of random walks, this increases the probability of  X  X  X onservatively X  X  remaining in the current state (node). 3 Applications The proposed graphical representation of Web logs has many potential applications, which can be approached within two different frameworks. Unsupervised algorithms can be applied to group the nodes of the graph according to some similarity criterion, for instance to find related queries, users or documents. On the other hand, supervised multi-class classification require to determine if each node of the graph is belonging or not to a set of predefined categories. This is commonly performed by assigning a score for each category to each node. The scores are learned starting from a set of labeled nodes with supervised scores. A non-exhaustive list of applications falling in the first group is the following:  X  Query recommendation . This problem can be formulated as a semantic clustering  X  Related document suggestion . This is also a semantic clustering problem: given a  X  User clustering and personalization . Given a user, find other users that share common
A few examples of tasks falling in the second category are:  X  Document ranking . Given a query, order the documents by their relevance. This is  X  Document categorization . The goal of this task is to classify each document as 3.1 Target applications The experimental section of this paper is focused on the following two applications: discovering query suggestions (unsupervised Web mining task) and classification-by-topic (supervised Web mining task).

The problem of finding good query suggestions have been extensively studied in the literature. Most of the studies concentrated on using query refinements (Baeza-Yates et al. 2004 ; Boldi et al. 2008 ), the intersection among the result sets using the query-document bi-partite graph (He et al. 2002 ), or term-based statistics (Collins-Thompson and Callan 2005 ). In this paper we employ the Web logs to extract semantically relevant suggestions by observing that similar queries tend to select (be connected) to similar sets of documents and they are issued by similar sets of users. Furthermore, related queries tend to be often issued sequentially in the same search sessions. The Web log graph proposed in this paper captures the information needed to take advantage of all these properties at the same time and allows using unified processing methodologies as explained in Sect. 4 .

Document classification-by-topic is a very well studied problem. Most of the work in the literature concentrates on classification using the textual content (Sebastiani 2002 ). A few papers do not consider documents as separate entities, but embed them into a network of connections. For example, (Chakrabarti et al. 2001 ;Fu  X  rnkranz 1999 ) exploit the HTML links among Web pages to improve the performances of a classifier. However, we think that the information stored by the logs is more direct and valuable than that provided by the HTML links. We propose to use a diffusion algorithm similar to what proposed by (Zhou et al. 2004 , 2005 ; Zhou and Scholkopf 2004 ). As described in Sect. 5 , the diffusion algo-rithm starts from a small set of examples of documents on a topic T to discover new documents belonging to the same topic. Indeed, documents belonging to the same topic tend to attract visits from users sharing a common interest on the topic. It is therefore likely that a user that visited an on-topic document also visited other similar ones. The same reasoning holds for query-document connections: a specific query determines the topic of the docu-ments that are selected by the users after having issued it. So, queries and users can be used as a gateway to extend our supervised knowledge to other documents. Since the connections are built from the contextual behavior of the users X  X ho are supposed to semantically understand the content of the pages, the proposed methodology should be more accurate on pages mainly containing images (and no text) and more robust with respect to spammers than purely content-based approaches. This methodology is therefore a perfect candidate to integrate content-based approaches for Web text categorization applications. 4 Markovian node clustering The general framework described in this section can be used to detect related or similar entities on the graph, it is therefore suited to tackle any application involving unsupervised learning.

Please note that the matrix W collecting the weights w ( i , j ) defined in the previous section is by construction stochastic. Consider now the Markov process whose transition matrix is W , we indicate with w n ( i , j ) the ( i , j ) th element of W n representing the proba-assume that i and j are nodes representing queries. In the simplified case where W repre-sents a bi-partite graph containing only the query-document connections, a non-null w ( i , j ) value, obtained by iterating the Markov model for two steps, is higher as the larger is the intersection between the two sets of documents selected for the queries i and j . The proposed model extends this concept by considering also the transitions between other node types. Therefore, w 2 ( i , j ) can increase also if i and j tend to be issued by a similar set of users and/or if j is a common query refinement of i . By computing higher powers W n , n [ 2, the clusters are grown recursively and objects representing more distant semantic concepts are merged. Generally speaking, w n ( i , j ) will indicate how the element j is semantically similar to the element i according to the users X  search sessions. Please note that since the initial matrix is stochastic, any power of the matrix remains stochastic. This means that the value of any element ( i , j ) remains in the [0, 1] range. For the i -th entity in the graph, the most related entities are discovered by starting the random walk from the i -th node and letting it run for n steps. The similarity degree between entity i and j is pro-portional to the probability of ending the walk in node j . Please note that once W n has been computed, it is not needed to run a separate walk for each entity, as the i -th row of W n already contains the probability distribution over the entities of the graph for a walk starting in i . This means that it is possible to rank the entities by their similarity with the entity i by sorting them according to their corresponding values on the i -th row of W n .Itis now possible to define a threshold to select the top entities to be returned for the target application. This clustering algorithm is similar to other clustering algorithms based on Markov processes like MCL (Enright et al. 2002 ).

The optimal value for n can not be determined a-priori and depends on the application that defines the desired semantic homogeneity of the elements. In particular, larger values of n will tend to create similarity relations that are less semantically homogeneous and should be used when higher recall is desired. For most of the semantic clustering appli-cations on the Web, n [ [2, 5] should be appropriate. In the experimental section, the impact of n on the accuracy of the discovered similarity relations is studied in more details. The self-connection s has also an influence on the selected value for n , since larger values slow down the diffusion of the information.
 From an implementation point of view, W can be huge containing billions of rows. However, W is typically very sparse and, as long as n is low, W n remains sparse in most applications. This allows us to get advantage of the fact that products between sparse matrices can be efficiently computed, and W n can be iteratively computed as W  X  W  X  W  X  ...  X  WW  X  X  X  X  . When working at a very large scale, the computation can be par-allelized using a distributed computational schema like MapReduce (Dean and Ghemawat 2008 ), which has been successfully applied to matrix multiplication problems with billion of nodes (Papadimitriou and Sun 2008 ; Cohen 2009 ). 5 Regularization in discrete domains for supervised tasks Given a graph representing similarity relationships among a set of entities, it is possible to ticular, we consider a general formulation of transductive node classification in discrete domains based on a regularization principle (Zhou and Scholkopf 2004 ; Zhou et al. 2004 ). This class of algorithms exploits a set of examples (labeled nodes) and the connections (graph edges) among the objects. Entity classification is performed by computing a function that is defined over the graph nodes (each node representing an object to be classified) and that is enough smooth when considering nearby nodes. Basically, gener-obtained by exploiting the graph topology. This approach is particularly interesting for the considered task, since it may be difficult to provide useful features to describe some of the considered entities (e.g., users) from query logs, whereas a set of similarity relationships can be easily computed as shown in Sect. 2 .

Discrete domain regularization infers a function assigning a classification score to each node of the graph, starting from a small set of labeled nodes which are assigned a given target score. Typically, a score equal to ? 1( -1) is used to indicate a page belonging (not belonging) to the target category. The values in the range ( -1,1) can be used to indicate the confidence of the classification of the node into the corresponding category, assuming the value 0 as the threshold for the decision. This approach allows us to define a binary classification scheme for each considered class (i.e., we decide to attach a given class label to an item without considering the results for the other classes). When facing a multiclass classification problem with mutually exclusive classes, the procedure is applied for each class and the final classification is performed by selecting the class yielding the maximum value (eventually considering rejection if the maximum is below a given confidence threshold).
 More formally, let us suppose we are given a graph G and let V G be the set of nodes in G . Each edge of the graph is assigned a weight representing the strength of the connection between the corresponding nodes. In particular, given two nodes u , v [ V G , w uv 0 indi-cates the weight of the connection between u and v . w uv = 0 is equivalent to not having a connection between the nodes. In the considered framework, the connection weights define similarity between the two connected nodes). In fact, if the weights are computed using the procedure proposed in Sect. 2 , their value is related to the observed correlation between the considered nodes.

The graph G can be represented via its adjacency matrix W , whose ( u , v ) -th element regularization estimates the function f ( v ), v [ V G by computing a score value for each node  X  X  X mooth X  X  variations over the graph connections. In particular, the learning problem determines the vector f H minimizing the following cost functional, where R G is a regularization matrix defined to penalize non-smooth solutions, y is the vector of target scores, whose non-supervised entries are set to 0, and 0 k 1isa constant determining the trade off between regularization and error over the training nodes.
The optimal solution minimizing ( 3 ) can be computed by finding its stationary points, obtained by solving
If ( I ? k R G ) is invertible, f H exists, is unique and it is equal to
In order to provide a meaningful definition of R G , we start from a regularization connected nodes, weighted by the strength of the connection, where f u is the value of f for the u th node. This functional favors functions assuming close values on nodes that are strongly connected.
 Equation 5 can be rearranged as The weights w uv are symmetric ( w uv  X  w vu 8 u ; ), therefore it holds that Thus, we obtain Let W be a symmetric square matrix having w uv as ( u , v ) th element and D be a diagonal matrix with its u th element d u equal to can be expressed as f T Df and f T Wf , respectively.
 Therefore, C R G [ f ] can be compactly rewritten as which expresses the regularizer in the form required by ( 3 ). Now, setting R G  X  D W into ( 4 ) allows us to compute the optimal score vector as Since D W is diagonally dominant, I  X  k D k W is also diagonally dominant and, therefore, invertible. Thus, the optimal solution f H exists and is uniquely defined by the graph and the supervised vector of target scores.

Equation 9 requires the inversion of a square matrix, which has size equal to the number of nodes in the input graph. This graph can have billions of nodes in Web applications, and direct inversion can be intractable. However, if the largest eigenvalue of k  X  D W  X  lays inside the unit circle and W is sparse, the solution can be efficiently found by solving the following iterative equation, Interestingly, this iterative equation represents a diffusion process of the labels through the graph. 6 Experimental results The experiments have been carried on the user logs released by AOL in 2005. The dataset is a sample of the search activity of 658000 anonymized US-based users over a three month period (March to May 2005). This has been estimated to be a sample of approxi-mately 1.5% of the overall AOL users in the considered period. The dataset contains 4.8 million queries and 1.8 million URLs. Since we are aware of the privacy concerns of this dataset, the graph has been pruned to remove queries and documents that have been issued by less than four users. This should remove personal queries and documents that could allow us to associate any anonymous user id to a real person. Furthermore, the graph has been pruned by removing all users that had issued less than three queries. The final graph contains 982354 nodes of which 646603 represent queries, 130502 documents and 205249 users. Please note that this dataset is specific to a single language and country. When working with locale heterogeneous Web logs, it may be more effective to create separate graphs for each locale and iteratively apply the proposed approach. 6.1 Discovering semantic query suggestions This set of experiments aims at showing how the augmented data structure can be used to extract high quality query suggestions.

The Web logs have been used to build the following five graphs, where the connections are set using the methodology explained in Sect. 2 . The first graph G qq considers only query refinements, i.e., a QQ = 1 -s while all other a parameters are set to zero. This is equivalent to considering only the query nodes and the edges directly connecting them. The second graph G qd considers only document-query and query-document transitions: a
QD  X  a DQ  X  1 s , while a QQ  X  a DU  X  a UD ; a UQ  X  a QU  X  0. The third graph G qu con-siders only query-user and user-query transitions: a QU  X  a UQ  X  1 s , with the other a parameters set to zero. The fourth graph G qqu considers query-query, query-document and document-query connections: a QQ  X  a QD  X  1 s 2 ; a DQ = 1 -s and the other a parameters set to zero. Finally, the fifth graph G all equally weights all the connections across different connection parameter s has been set to 0.5 for all the graphs.
 G qqu ; G all ; respectively.

Analysis of the accuracy provided by the graph sub-portions . Three propagation steps The selection of only three iterations for the propagation step is motivated by the results reported in the following.

We randomly sampled 125 original queries that have been discovered to be similar to at least another query with a score higher than 0.01 in at least one of the above matrices. For each selected query, the query itself and up the 10 most similar corresponding queries for been previously instructed on the desired rating policies and their scores calibrated on validation data. The raters marked the single queries in each set as relevant or irrelevant according to the supposed search goal of the user. Given the high number of pairs (original query, suggested query) to score, each pair was scored by a single rater. However, a corrections was around 4%).

When considering only the sub-graph containing the query-document connections, the query discovery approach is similar to what proposed in (Craswell and Szummer 2007 ). Therefore, we will consider this result as a baseline.

Table 1 reports the precision scores when considering the top N [ {1, 3, 5, 10} query unknown, it is not possible to measure recall directly. We instead used a pseudo-recall metric, which measures the percentage of queries for which N query suggestions are available. Table 2 reports the obtained values for this pseudo-recall metric for N [ {1, 3, 5} for each experiment.

The experimental results show that the query-query connections are the most powerful, closely followed by the query-document ones. User-query transitions are less useful in discovering relevant query suggestions but they still help in finding some. As expected, most of the gains come from the combination of the query-query and query-document connections. This combination significantly improves what can be achieved by considering a single set of connections. However, the precision and recall of the diffusion schema can be further improved by using the complete graph, which includes all the available infor-orthogonal in terms of the discoverable suggestions. Therefore, even the query-user con-nections, which are weaker when considered in isolation, play an important role in increasing the precision and recall of the overall results. This result is particularly inter-esting as the previous work in the literature focused on a few single sub-portions of the Web log graph. According to these results, only query-rephrasing appears to be a very strong signal in isolation. Any other portion of the graph provides a weaker signal, which can still be successfully exploited by cross-reinforcing them with the signals coming from the other portions.

Table 3 reports the query recommendations assigned to a score above 0.01 in any of the different sub-graphs for a small set of user queries. This small set of examples shows how the proposed methodology is able to extract relevant suggestions. In particular, some recommendations show a strong semantic relation with the initial query and it would be hard to extract them without using the collective feedback of the users. Most of the highly semantic related queries come from the query-query portion. Query-document connections provide other relevant recommendations, which are often different from those provided by the query-query connections. As shown by the  X  X  X apquest X  X  example query, performing graph propagation over the entire graph is not equivalent to an a-posteriori merging of the results of the propagation over the single sub-portions. The recommendation can be reinforced by signal propagation across paths crossing multiple different sub-portions, making the process highly non-linear. This means that a recommendation can get a small score when considering any single connection type, while it gets a higher positive score when propagating over the entire graph.

Analysis of the obtained accuracy when varying the propagation steps . A second set of experiments studies how the precision and recall results provided by the system vary when changing the number of propagation steps. This set of experiments was carried out on the complete graph containing all the available information. First, the matrixes W n all with n = 2, 3, 4, 6 have been computed. A set of randomly sampled queries and the corre-sponding extracted similarity ranks have been sent to a set of human raters (using the same rating methodology previously explained). These scores have been used to determine the precision scores of the obtained query suggestions. Recall was measured using the same methodology explained in the previous paragraph.

Tables 4 and 5 show the Precision@N and the percentage of queries for which N suggestions are available obtained for a different number of propagation steps. As expected, a 2-step propagation provides high precision but a relatively lower recall. On the other hand, the precision scores steeply decrease when propagating for 4 or more steps. Employing a 3-step propagation provides a very nice trade-of between precision and recall. These results suggest that a limited number of steps should be employed for all clustering applications.

Query Suggestion Categories . Query suggestions can be subdivided into the following categories:  X  Generalization . The suggestion denotes a more general concept than the original query.  X  Specification . The suggestion denotes a more specific concept than the original query.  X  Related . The suggestion delivers a concept that is related to the original query and has  X  Stemming-based suggestions. The suggestion is a different linguistic morphology of the  X  Equivalence . The suggestion delivers the same semantic meaning of the original query  X  Spell-correction . The suggestion is a spell-corrected form of the original query. For
Multiple suggestion categories can correspond to get a single suggestion. For example  X  X  X ps tracking X  X  and  X  X  X edex X  X  is a related query of a generalization, while  X  X  X ps traking X  X  ?  X  X  X edex tracking X  X  is a spell correction of a related query.

All the above suggestion types can be useful and relevant depending on the context. In particular, suggestions in the  X  X  X elated X  X  category are often regarded as particularly intriguing. Indeed, suggestions in this category are often very useful for the users, but also very hard to discover, since they require to understand the semantic of the query and of the associated suggestions.

Figure 2 shows the distribution by category of the relevant suggestions that are discover when propagating over each single sub-portion of the graph and when considering all the available data at the same time (all). Suggestions in the equivalence class are quite common for all methods, followed by suggestions in the specification and spell-correction classes. Stemming-based rewrites appear to be more rare in our data. It is interesting to note that the query-query connections are a great source of suggestions in the related category. 6.2 Web page categorization by topic Documents on a given topic T tend to be connected to the users interested on T and to the queries issued for information requests about T . Therefore, assuming to know the category among sets of connected nodes to extrapolate the category of other unlabeled entities. In this section, we show how the structured representation of the Web logs presented in the previous sections can be used to improve classical categorization by topic, commonly purely based on page content. Classification is performed using the methodology described in Sect. 5 .

We are not aware of any categorization supervised dataset built on top of the AOL data, we thus built our own datasets using the following methodology, which aims at minimizing the need of performing a manual labeling of the data:  X  all the documents in the dataset have been downloaded from the Internet. Since the  X  A set of  X  X  X nambiguous X  X  keywords have been selected to describe various categories as  X  A sample of 1% of the overall number of documents have been selected as negative  X  A labeled dataset of pages has been compiled for each category by adding the  X  The URLs are discarded from the data representation of the documents and never used  X  The labeled dataset for each category is randomly split into a training and a test set of
Whereas we are aware that the labeling procedure described above can introduce some bias in the selection of the training data, it has the advantage that allows us to build an arbitrary large number of training and test sets with a limited amount of manual labeling. Each training labeled dataset has been used to train an SVM classifier (Scholkopf and Smola 2001 ) based on a linear kernel and processing the bag-of-word representation of the pages, containing plain term frequency (tf) features. The bag-of-word representation has been extracted using the HTML parsing library part of the open source lynx browser. 1 The SVM classifier has been implemented using the SVMlib software library. 2 We decided to employ an SVM classifier in our experiments, since it has been shown to provide state-of-the-art results on text categorization tasks with little tuning (Joachims 1998 ). The graph regularization scheme defined in Sect. 5 is applied over the stochastic W matrix, whose construction methodology has been defined in Sect. 2.5 . Since W is stochastic, its largest eigenvalue is equal to 1 (Seneta 2006 ). If k 1, the iterative ( 10 ) can be efficiently used to solve the minimization problem. This is indeed the employed opti-mization schema used to compute the experimental results presented in this section.
For each category and crossvalidation fold, a labeled vector y has been constructed starting from the corresponding training dataset. For each labeled vector, graph diffusion has been performed using ( 10 ) for 5 iterations. Even if 5 steps are usually not enough to reach convergence, no consistent accuracy gain was observed by increasing the number of iterations and, therefore, we early interrupted the process to save computational resources.
Given the representation of an input document x , let O SVM ( x ) and O PROP ( x ) be the output of the trained SVM classifier and of the graph propagation (PROP), respectively. The classification for the SVM ? PROP classifier was trivially performed by outputting a page as belonging to a category if at least one of the classifiers returns a positive value:  X  O
SVM  X  x  X  [ 0  X _ X  O PROP  X  x  X  [ 0  X  .
Table 6 compares the classification accuracy for various text categories as an average over the 20 crossvalidation sub-samples. The approach integrating SVM and graph propagation consistently improves the baseline provided by the SVM classifier for all the tested categories. In particular, the accuracy gain of the PROP ? SVM versus the SVM categories  X  X  X orn X  X ,  X  X  X occer X  X ,  X  X  X ovies X  X ,  X  X  X ennis X  X ,  X  X  X ravel X  X  and  X  X  X asinos X  X . Table 7 reports the precision and recall for the positive class obtained when using the SVM ? PROP and SVM classifiers. The SVM ? PROP classifiers show an increase of the average recall versus the SVM ones for all classes. In particular, the recall gains are statistically significant for the classes  X  X  X orn X  X ,  X  X  X occer X  X  and  X  X  X asinos X  X . The SVM ? PROP also features a small increase in precision for most of the classes but it is never statistically significant. The PROP classifiers provide a lower accuracy than the corresponding SVM classifiers. However, this is mainly due to the their low recall as shown by Table 7 . On the other hand, their precision scores for the positive class are consistently very high, meaning that they very rarely tag a document as belonging to a class, when the document does not really belong to that class. This explains why the ensemble classifier, merging the outputs of the SVM and PROP classifiers using a simple OR, over performs the single underlying classifiers. Indeed, the ensemble classifier relies on the SVM classifier most of the time, but it is able to recover some mistakes by trusting the PROP classifier when it triggers.
Table 7 also provides some insights about the results shown in Table 6 . Indeed, it explains that the previously reported accuracy gains are mainly coming from an increase in recall provided by the SVM ? PROP classifier over the SVM one. Indeed, the SVM ? PROP approach is able to classify some pages with little or misleading textual content that are common on the Web, for which the SVM classifier performs poorly. 7 Conclusions and future work This paper presents a graphical representation of the collective search tasks performed by the users. The representation can be directly extracted from the Web logs of Intranet HTTP proxies, Internet providers, or search engines. This representation improves what has previously proposed in the literature because it models searches, user visits and query refinements all in a comprehensive data structure. The paper studies how it is possible to process the graph in Web mining applications defining either a supervised or unsupervised learning task. Unsupervised tasks can be approached using a diffusion algorithm based on a ments or users). Supervised learning tasks can be tackled using a regularization schema defined over discrete domains.

The experimental results presented in this paper concern the tasks of discovering semantically relevant query suggestions and Web document categorization. For the query suggestion tasks, the experiments measure the accuracy provided by the single sub-por-tions of the graph. In particular, the portion of the graph modeling query refinements (query-query connections) has been proved to be the most powerful to solve the studied task. The portion including document-query links closely follows, while document-user connections are less useful for this application. Whereas all the previous works in the literature focused on a subset of the available information in the Web logs, the experiments coverage of the query suggestions by using all the available information at the same time.
For the document categorization task, the experimental results show how it is possible to improve content-based state-of-the-art categorization methods. In particular, this improvement can be obtained via a simple combination of the output of the content-based text categorizer with the output of the propagation schema defined by the graph regular-ization framework.

The data structure could also be enriched by integrating other information that, whereas external to the Web logs, it is commonly available to search engines. For example, we plan to study the integration of the Web graph in the proposed Web log graph. The Web graph represents the known HTML links between pairs of pages and, while noisy, it could improve to smear the information available in the Web logs about popular resources (which are covered by the Web logs with high recall) to more exotic pages. We plan to study this extension in the future, together with studying other Web mining applications like document ranking and user/document clustering. Toolbar logs can track the behavior of the users document and/or document to document transitions. Another extension we plan to study is to integrate content-based information from classical IR, like query similarities using edit distances, or document pair-wise cosine similarities, as weighted connections on the graph. This would allow us to process content and behavioral information in a unified way. References
