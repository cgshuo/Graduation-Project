 Modern NLP systems have increasingly used data-intensive models that capture many or even all substructures from the training data. In the do-main of syntactic parsing, the idea that all train-ing fragments 1 might be relevant to parsing has a long history, including tree-substitution grammar (data-oriented parsing) approaches (Scha, 1990; Bod, 1993; Goodman, 1996a; Chiang, 2003) and tree kernel approaches (Collins and Duffy, 2002). For machine translation, the key modern advance-ment has been the ability to represent and memo-rize large training substructures, be it in contigu-ous phrases (Koehn et al., 2003) or syntactic trees (Galley et al., 2004; Chiang, 2005; Deneefe and Knight, 2009). In all such systems, a central chal-lenge is efficiency: there are generally a combina-torial number of substructures in the training data, and it is impractical to explicitly extract them all. On both efficiency and statistical grounds, much recent TSG work has focused on fragment selec-tion (Zuidema, 2007; Cohn et al., 2009; Post and Gildea, 2009).

At the same time, many high-performance parsers have focused on symbol refinement ap-proaches, wherein PCFG independence assump-tions are weakened not by increasing rule sizes but by subdividing coarse treebank symbols into many subcategories either using structural anno-tation (Johnson, 1998; Klein and Manning, 2003) or lexicalization (Collins, 1999; Charniak, 2000). Indeed, a recent trend has shown high accura-cies from models which are dedicated to inducing such subcategories (Henderson, 2004; Matsuzaki et al., 2005; Petrov et al., 2006). In this paper, we present a simplified parser which combines the two basic ideas, using both large fragments and symbol refinement, to provide non-local and lo-cal context respectively. The two approaches turn out to be highly complementary; even the simplest (deterministic) symbol refinement and a basic use of an all-fragments grammar combine to give ac-curacies substantially above recent work on tree-substitution grammar based parsers and approach-ing top refinement-based parsers. For example, our best result on the English WSJ task is an F1 of over 88%, where recent TSG parsers 2 achieve 82-84% and top refinement-based parsers 3 achieve 88-90% (e.g., Table 5).

Rather than select fragments, we use a simplifi-cation of the PCFG-reduction of DOP (Goodman, 1996a) to work with all fragments. This reduction is a flexible, implicit representation of the frag-ments that, rather than extracting an intractably large grammar over fragment types , indexes all nodes in the training treebank and uses a com-pact grammar over indexed node tokens . This in-dexed grammar, when appropriately marginalized, is equivalent to one in which all fragments are ex-plicitly extracted. Our work is the first to apply this reduction to full-scale parsing. In this direc-tion, we present a coarse-to-fine inference scheme and a compact graph encoding of the training set, which, together, make parsing manageable. This tractability allows us to avoid selection of frag-ments, and work with all fragments.

Of course, having a grammar that includes all training substructures is only desirable to the ex-tent that those structures can be appropriately weighted. Implicit representations like those used here do not allow arbitrary weightings of fragments. However, we use a simple weight-ing scheme which does decompose appropriately over the implicit encoding, and which is flexible enough to allow weights to depend not only on fre-quency but also on fragment size, node patterns, and certain lexical properties. Similar ideas have been explored in Bod (2001), Collins and Duffy (2002), and Goodman (2003). Our model empir-ically affirms the effectiveness of such a flexible weighting scheme in full-scale experiments.

We also investigate parsing without an explicit lexicon. The all-fragments approach has the ad-vantage that parsing down to the character level requires no special treatment; we show that an ex-plicit lexicon is not needed when sentences are considered as strings of characters rather than words. This avoids the need for complex un-known word models and other specialized lexical resources.

The main contribution of this work is to show practical, tractable methods for working with an all-fragments model, without an explicit lexicon. In the parsing case, the central result is that ac-curacies in the range of state-of-the-art parsers (i.e., over 88% F1 on English WSJ) can be ob-tained with no sampling, no latent-variable mod-eling, no smoothing, and even no explicit lexicon (hence negligible training overall). These tech-niques, however, are not limited to the case of monolingual parsing, offering extensions to mod-els of machine translation, semantic interpretation, and other areas in which a similar tension exists between the desire to extract many large structures and the computational cost of doing so. 2.1 All-Fragments Grammars We consider an all-fragments grammar G (see Figure 1(a)) derived from a binarized treebank B . G is formally a tree-substitution grammar (Resnik, 1992; Bod, 1993) wherein each subgraph of each training tree in B is an elementary tree, or fragment f , in G . In G , each derivation d is a tree (multiset) of fragments (Figure 1(c)), and the weight of the derivation is the product of the weights of the fragments:  X  ( d ) = Q f  X  d  X  ( f ) . In the following, the derivation weights, when nor-malized over a given sentence s , are interpretable as conditional probabilities, so G induces distribu-tions of the form P ( d | s ) .

In models like G , many derivations will gen-erally correspond to the same unsegmented tree, and the parsing task is to find the tree whose sum of derivation weights is highest: t max = arg max t P d  X  t  X  ( d ) . This final optimization is in-tractable in a way that is orthogonal to this pa-per (Sima X  X n, 1996); we describe minimum Bayes risk approximations in Section 4. 2.2 Implicit Representation of G Explicitly extracting all fragment-rules of a gram-mar G is memory and space intensive, and imprac-tical for full-size treebanks. As a tractable alter-native, we consider an implicit grammar G I (see Figure 1(b)) that has the same posterior probabil-ities as G . To construct G I , we use a simplifi-cation of the PCFG-reduction of DOP by Good-man (1996a). 4 G I has base symbols, which are the symbol types from the original treebank, as well as indexed symbols, which are obtained by assigning a unique index to each node token in the training treebank. The vast majority of sym-bols in G I are therefore indexed symbols. While it may seem that such grammars will be overly large, they are in fact reasonably compact, being linear in the treebank size B , while G is exponen-tial in the length of a sentence. In particular, we found that G I was smaller than explicit extraction of all depth 1 and 2 unbinarized fragments for our (a) (b) treebanks  X  in practice, even just the raw treebank grammar grows almost linearly in the size of B . 5
There are 3 kinds of rules in G I , which are illus-trated in Figure 1(d). The BEGIN rules transition from a base symbol to an indexed symbol and rep-resent the beginning of a fragment from G . The CONTINUE rules use only indexed symbols and correspond to specific depth-1 binary fragment to-kens from training trees, representing the internal continuation of a fragment in G . Finally, END rules transition from an indexed symbol to a base symbol, representing the frontier of a fragment.
By construction, all derivations in G I will seg-ment, as shown in Figure 1(d), into regions corre-sponding to tokens of fragments from the training treebank B . Let  X  be the map which takes appro-priate fragments in G I (those that begin and end with base symbols and otherwise contain only in-dexed symbols), and maps them to the correspond-ing f in G . We can consider any derivation d I in G
I to be a tree of fragments f I , each fragment a token of a fragment type f =  X  ( f I ) in the orig-inal grammar G . By extension, we can therefore map any derivation d I in G I to the corresponding derivation d =  X  ( d I ) in G .

The mapping  X  is an onto mapping from G I to G . In particular, each derivation d in G has a non-empty set of corresponding derivations { d I } =  X   X  1 ( d ) in G I , because fragments f in d corre-spond to multiple fragments f I in G I that differ only in their indexed symbols (one f I per occur-rence of f in B ). Therefore, the set of derivations in G is preserved in G I . We now discuss how weights can be preserved under  X  . 2.3 Equivalence for Weighted Grammars In general, arbitrary weight functions  X  on frag-ments in G do not decompose along the increased locality of G I . However, we now consider a use-fully broad class of weighting schemes for which the posterior probabilities under G of derivations d are preserved in G I . In particular, assume that we have a weighting  X  on rules in G I which does not depend on the specific indices used. There-fore, any fragment f I will have a weight in G I of the form: where b is the BEGIN rule, r are CONTINUE rules, and e are END rules in the fragment f I (see Fig-ure 1(d)). Because  X  is assumed to not depend on the specific indices, all f I which correspond to the same f under  X  will have the same weight  X  I ( f ) in G I .

In this case, we can define an induced weight for fragments f in G by  X  G ( f ) = X where now b 0 , r 0 and e 0 are non-indexed type ab-stractions of f  X  X  member productions in G I and n ( f ) = |  X   X  1 ( f ) | is the number of tokens of f in B .

Under the weight function  X  G ( f ) , any deriva-tion d in G will have weight which obeys and so the posterior P ( d | s ) of a derivation d for a sentence s will be the same whether computed in G or G I . Therefore, provided our weighting function on fragments f in G decomposes over the derivational representation of f in G I , we can equivalently compute the quantities we need for inference (see Section 4) using G I instead. 3.1 Classical DOP1 The original data-oriented parsing model  X  X OP1 X  (Bod, 1993) is a particular instance of the general weighting scheme which decomposes appropri-ately over the implicit encoding, described in Sec-tion 2.3. Figure 2 shows rule weights for DOP1 in the parameter schema we have defined. The END rule weight is 0 or 1 depending on whether A is an intermediate symbol or not. 6 The local fragments in DOP1 were flat (non-binary) so this weight choice simulates that property by not al-lowing switching between fragments at intermedi-ate symbols.

The original DOP1 model weights a fragment f in G as  X  G ( f ) = n ( f ) /s ( X ) , i.e., the frequency of fragment f divided by the number of fragments rooted at base symbol X . This is simulated by our weight choices (Figure 2) where each fragment f I in G I has weight  X  I ( f I ) = 1 /s ( X ) and therefore,  X  Given the weights used for DOP1, the recursive formula for the number of fragments s ( X i ) rooted at indexed symbol X i (and for the CONTINUE rule X i  X  Y j Z k ) is where s ( Y j ) and s ( Z k ) are the number of frag-ments rooted at indexed symbols Y j and Z k (non-intermediate) respectively. The number of frag-ments s ( X ) rooted at base symbol X is then s ( X ) = P X
Implicitly parsing with the full DOP1 model (no sampling of fragments) using the weights in Fig-ure 2 gives a 68% parsing accuracy on the WSJ dev-set. 7 This result indicates that the weight of a fragment should depend on more than just its fre-quency. 3.2 Better Parameterization As has been pointed out in the literature, large-fragment grammars can benefit from weights of fragments depending not only on their frequency but also on other properties. For example, Bod (2001) restricts the size and number of words in the frontier of the fragments, and Collins and Duffy (2002) and Goodman (2003) both give larger fragments smaller weights. Our model can incorporate both size and lexical properties. In particular, we set  X  CONT ( r ) for each binary CON -TINUE rule r to a learned constant  X  BODY , and we set the weight for each rule with a POS parent to a constant  X  LEX (see Figure 2). Fractional values of these parameters allow the weight of a fragment to depend on its size and lexical properties.

Another parameter we introduce is a  X  X witching-penalty X  c sp for the END rules (Figure 2). The DOP1 model uses binary values (0 if symbol is intermediate, 1 otherwise) as the END rule weight, which is equivalent to prohibiting fragment switching at intermediate symbols. We learn a fractional constant a sp that allows (but penalizes) switching between fragments at annotated symbols through the c allows fragments to be assigned weights based on the binarization status of their nodes.

With the above weights, the recursive formula for s ( X i ) , the total weighted number of fragments rooted at indexed symbol X i , is different from DOP1 (Equation 1). For rule X i  X  Y j Z k , it is s ( X i ) =  X  BODY . ( c sp ( Y j )+ s ( Y j ))( c sp ( Z The formula uses  X  LEX in place of  X  BODY if r is a lexical rule (Figure 2).

The resulting grammar is primarily parameter-ized by the training treebank B . However, each setting of the hyperparameters (  X  BODY , X  LEX ,a sp ) defines a different conditional distribution on trees. We choose amongst these distributions by directly optimizing parsing F1 on our develop-ment set. Because this objective is not easily dif-ferentiated, we simply perform a grid search on the three hyperparameters. The tuned values are  X  BODY = 0 . 35 ,  X  LEX = 0 . 25 and a sp = 0 . 018 . For generalization to a larger parameter space, we would of course need to switch to a learning ap-proach that scales more gracefully in the number of tunable hyperparameters. 8 The previously described implicit grammar G I de-fines a posterior distribution P ( d I | s ) over a sen-tence s via a large, indexed PCFG. This distri-bution has the property that, when marginalized, it is equivalent to a posterior distribution P ( d | s ) over derivations in the correspondingly-weighted all-fragments grammar G . However, even with an explicit representation of G , we would not be able to tractably compute the parse that maxi-mizes P ( t | s ) = P d  X  t P ( d | s ) = P d I  X  t P ( d (Sima X  X n, 1996). We therefore approximately maximize over trees by computing various exist-ing approximations to P ( t | s ) (Figure 3). Good-man (1996b), Petrov and Klein (2007), and Mat-suzaki et al. (2005) describe the details of con-stituent, rule-sum and variational objectives re-spectively. Note that all inference methods depend on the posterior P ( t | s ) only through marginal ex-pectations of labeled constituent counts and an-chored local binary tree counts, which are easily computed from P ( d I | s ) and equivalent to those from P ( d | s ) . Therefore, no additional approxima-tions are made in G I over G .

As shown in Table 1, our model (an all-fragments grammar with the weighting scheme shown in Figure 2) achieves an accuracy of 88.5% (using simple parent annotation) which is 4-5% (absolute) better than the recent TSG work (Zuidema, 2007; Cohn et al., 2009; Post and Gildea, 2009) and also approaches state-of-the-art refinement-based parsers (e.g., Charniak and Johnson (2005), Petrov and Klein (2007)). 9 4.1 Coarse-to-Fine Inference Coarse-to-fine inference is a well-established way to accelerate parsing. Charniak et al. (2006) in-troduced multi-level coarse-to-fine parsing, which extends the basic pre-parsing idea by adding more rounds of pruning. Their pruning grammars were coarse versions of the raw treebank gram-mar. Petrov and Klein (2007) propose a multi-stage coarse-to-fine method in which they con-struct a sequence of increasingly refined gram-mars, reparsing with each refinement. In par-ticular, in their approach, which we adopt here, coarse-to-fine pruning is used to quickly com-pute approximate marginals, which are then used to prune subsequent search. The key challenge in coarse-to-fine inference is the construction of coarse models which are much smaller than the target model, yet whose posterior marginals are close enough to prune with safely.

Our grammar G I has a very large number of in-dexed symbols, so we use a coarse pass to prune away their unindexed abstractions. The simple, intuitive, and effective choice for such a coarse grammar G C is a minimal PCFG grammar com-posed of the base treebank symbols X and the minimal depth-1 binary rules X  X  Y Z (and with the same level of annotation as in the full grammar). If a particular base symbol X is pruned by the coarse pass for a particular span ( i,j ) (i.e., the posterior marginal P ( X,i,j | s ) is less than a certain threshold), then in the full grammar G I , we do not allow building any indexed symbol X l of type X for that span. Hence, the pro-jection map for the coarse-to-fine model is  X  C : X l ( indexed symbol )  X  X ( base symbol ) .

We achieve a substantial improvement in speed and memory-usage from the coarse-pass pruning. Speed increases by a factor of 40 and memory-usage decreases by a factor of 10 when we go from no pruning to pruning with a  X  6 . 2 log pos-terior threshold. 10 Figure 4 depicts the variation in parsing accuracies in response to the amount of pruning done by the coarse-pass. Higher pos-terior pruning thresholds induce more aggressive pruning. Here, we observe an effect seen in previ-ous work (Charniak et al. (1998), Petrov and Klein (2007), Petrov et al. (2008)), that a certain amount of pruning helps accuracy, perhaps by promoting agreement between the coarse and full grammars (model intersection). However, these  X  X ortuitous X  search errors give only a small improvement and the peak accuracy is almost equal to the pars-ing accuracy without any pruning (as seen in Fig-ure 5). 11 This outcome suggests that the coarse-pass pruning is critical for tractability but not for performance. 4.2 Packed Graph Encoding The implicit all-fragments approach (Section 2.2) avoids explicit extraction of all rule fragments. However, the number of indexed symbols in our implicit grammar G I is still large, because ev-ery node in each training tree (i.e., every symbol token) has a unique indexed symbol. We have around 1.9 million indexed symbol tokens in the word-level parsing model (this number increases further to almost 12.3 million when we parse char-acter strings in Section 5.1). This large symbol space makes parsing slow and memory-intensive.
We reduce the number of symbols in our im-plicit grammar G I by applying a compact, packed graph encoding to the treebank training trees. We collapse the duplicate subtrees (fragments that bottom out in terminals) over all training trees. This keeps the grammar unchanged because in an tree-substitution grammar, a node is defined (iden-tified) by the subtree below it. We maintain a hashmap on the subtrees which allows us to eas-ily discover the duplicates and bin them together. The collapsing converts all the training trees in the treebank to a graph with multiple parents for some nodes as shown in Figure 6. This technique re-duces the number of indexed symbols significantly as shown in Table 2 (1.9 million goes down to 0.9 million, reduction by a factor of 2.1). This reduc-tion increases parsing speed by a factor of 1.4 (and by a factor of 20 for character-level parsing, see Section 5.1) and reduces memory usage to under 4GB.

We store the duplicate-subtree counts for each indexed symbol of the collapsed graph (using a hashmap). When calculating the number of frag-ments s ( X i ) parented by an indexed symbol X i (see Section 3.2), and when calculating the inside and outside scores during inference, we account for the collapsed subtree tokens by expanding the counts and scores using the corresponding multi-plicities. Therefore, we achieve the compaction with negligible overhead in computation. 5.1 Character-Level Parsing The all-fragments approach to parsing has the added advantage that parsing below the word level requires no special treatment, i.e., we do not need an explicit lexicon when sentences are considered as strings of characters rather than words.

Unknown words in test sentences (unseen in training) are a major issue in parsing systems for which we need to train a complex lexicon, with various unknown classes or suffix tries. Smooth-ing factors need to be accounted for and tuned. With our implicit approach, we can avoid training a lexicon by building up the parse tree from char-acters instead of words. As depicted in Figure 7, each word in the training trees is split into its cor-responding characters with start and stop bound-ary tags (and then binarized in a standard right-branching style). A test sentence X  X  words are split up similarly and the test-parse is built from train-ing fragments using the same model and inference procedure as defined for word-level parsing (see Sections 2, 3 and 4). The lexical items (alphabets, digits etc.) are now all known, so unlike word-level parsing, no sophisticated lexicon is needed.
We choose a slightly richer weighting scheme for this representation by extending the two-weight schema for CONTINUE rules (  X  LEX and  X   X 
SENT for CONTINUE rules in the lexical layer, in the portion of the parse that builds words from characters, and in the portion of the parse that builds the sentence from words, respectively. The tuned values are  X  SENT = 0 . 35 ,  X  WORD = 0 . 15 ,  X 
LEX = 0 . 95 and a sp = 0 . The character-level model achieves a parsing accuracy of 88.0% (see Table 3), despite lacking an explicit lexicon . 12
Character-level parsing expands the training trees (see Figure 7) and the already large indexed symbol space size explodes (1.9 million increases to 12.3 million, see Table 2). Fortunately, this is where the packed graph encoding (Section 4.2) is most effective because duplication of character strings is high (e.g., suffixes). The packing shrinks the symbol space size from 12.3 million to 1.1 mil-lion, a reduction by a factor of 11. This reduction increases parsing speed by almost a factor of 20 and brings down memory-usage to under 8GB. 13 5.2 Basic Refinement: Parent Annotation In a pure all-fragments approach, compositions of units which would have been independent in a basic PCFG are given joint scores, allowing the representation of certain non-local phenom-ena, such as lexical selection or agreement, which in fully local models require rich state-splitting or lexicalization. However, at substitution sites, the coarseness of raw unrefined treebank sym-bols still creates unrealistic factorization assump-tions. A standard solution is symbol refinement; Johnson (1998) presents the particularly simple case of parent annotation, in which each node is marked with its parent in the underlying treebank. It is reasonable to hope that the gains from us-ing large fragments and the gains from symbol re-finement will be complementary. Indeed, previous work has shown or suggested this complementar-ity. Sima X  X n (2000) showed modest gains from en-riching structural relations with semi-lexical (pre-head) information. Charniak and Johnson (2005) showed accuracy improvements from composed local tree features on top of a lexicalized base parser. Zuidema (2007) showed a slight improve-ment in parsing accuracy when enough fragments were added to learn enrichments beyond manual refinements. Our work reinforces this intuition by demonstrating how complementary they are in our model (  X  20% error reduction on adding refine-ment to an all-fragments grammar, as shown in the last two rows of Table 4).

Table 4 shows results for a basic PCFG, and its augmentation with either basic refinement (parent annotation and one level of markovization), with all-fragments rules (as in previous sections), or both. The basic incorporation of large fragments alone does not yield particularly strong perfor-mance, nor does basic symbol refinement. How-ever, the two approaches are quite additive in our model and combine to give nearly state-of-the-art parsing accuracies. 5.3 Additional Deterministic Refinement Basic symbol refinement (parent annotation), in combination with all-fragments, gives test-set ac-curacies of 88.5% (  X  40 words) and 87.6% (all), shown as the Basic Refinement model in Table 5. Klein and Manning (2003) describe a broad set of simple, deterministic symbol refinements be-yond parent annotation. We included ten of their simplest annotation features, namely: UNARY-DT, None of these annotation schemes use any head information. This additional annotation (see Ad-ditional Refinement, Table 5) improves the test-set accuracies to 88.7% (  X  40 words) and 88.1% (all), which is equal to a strong lexicalized parser (Collins, 1999), even though our model does not use lexicalization or latent symbol-split induc-tion. 6.1 Parsing Speed and Memory Usage The word-level parsing model using the whole training set (39832 trees, all-fragments) takes ap-proximately 3 hours on the WSJ test set (2245 trees of  X  40 words), which is equivalent to roughly 5 seconds of parsing time per sen-tence; and runs in under 4GB of memory. The character-level version takes about twice the time and memory. This novel tractability of an all-fragments grammar is achieved using both coarse-pass pruning and packed graph encoding. Micro-optimization may further improve speed and mem-ory usage. 6.2 Training Size Variation Figure 8 shows how WSJ parsing accuracy in-creases with increasing amount of training data (i.e., percentage of WSJ sections 2-21). Even if we train on only 10% of the WSJ training data (3983 sentences), we still achieve a reasonable parsing accuracy of nearly 84% (on the development set,  X  40 words), which is comparable to the full-system results obtained by Zuidema (2007), Cohn et al. (2009) and Post and Gildea (2009). 6.3 Other Language Treebanks On the French and German treebanks (using the standard dataset splits mentioned in Petrov and Klein (2008)), our simple all-fragments parser achieves accuracies in the range of top refinement-based parsers, even though the model parameters were tuned out of domain on WSJ. For German, our parser achieves an F1 of 79.8% compared to 81.5% by the state-of-the-art and substantially more complex Petrov and Klein (2008) work. For French, our approach yields an F1 of 78.0% vs. 80.1% by Petrov and Klein (2008). 14 Our approach of using all fragments, in combi-nation with basic symbol refinement, and even without an explicit lexicon, achieves results in the range of state-of-the-art parsers on full scale tree-banks, across multiple languages. The main take-away is that we can achieve such results in a very knowledge-light way with (1) no latent-variable training, (2) no sampling, (3) no smoothing be-yond the existence of small fragments, and (4) no explicit unknown word model at all. While these methods offer a simple new way to construct an accurate parser, we believe that this general ap-proach can also extend to other large-fragment tasks, such as machine translation.
 This project is funded in part by BBN under DARPA contract HR0011-06-C-0022 and the NSF under grant 0643742.
