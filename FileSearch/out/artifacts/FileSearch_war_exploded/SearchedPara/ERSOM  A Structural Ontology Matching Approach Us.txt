 In the recent years, it becomes evident that one of the most important directions of improvement in natural language processing (NLP) tasks, like word sense disambiguation, coreference resolu-tion, relation extraction, and other tasks related to knowledge extraction, is by exploiting seman-tics resources (Bryl et al., 2010). Nowadays, the Semantic Web made available a large amount of logically encoded information (e.g. ontologies, RDF(S)-data, linked data, etc.), which constitutes a valuable source of semantics. However, extend-ing the state-of-the-art natural language applica-tions to use these resources is not a trivial task mainly due to the heterogeneity and the ambiguity of the schemes adopted by the different resources of the Semantic Web. How to utilize these re-sources in NLP tasks comprehensively rather than choose just one of them has attracted much atten-tion in recent years.

An effective solution to the ontology hetero-geneity problem is ontology matching (Euzenat et al., 2007; Shvaiko and Euzenat, 2013), whose main task is to establish semantic correspondences between entities (i.e., classes, properties or in-stances) from different ontologies.

Ontology matching is usually done by measur-ing the similarity between two entities from two different ontologies. To effectively calculate the similarities, almost all types of descriptions of an entity should be used. In previous works, given the different nature of different kinds of descriptions, similarities are normally measured separately with different methods and then aggregated with some kind of combination strategy to compute the final similarity score. For example, Mao et al. (2010) defined three single similarities (i.e., Name simi-larity , Profile similarity and Structural similarity ) based on the descriptions of an entity, then they employed a harmony-based method to aggregate the single similarities to get a final similarity for extracting the final mappings. However, treating different kinds of descriptions of an entity sepa-rately suffers from two limitations. First, it lim-its the capacity of modeling the interactions be-tween different descriptions. For example, entity X  X  label is always a specific substitution of its ID; en-tity X  X  comment is a semantic definition for its ID; a class can be characterized with its related prop-erties, and a property is usually restricted by its domain and range. These potential correlations of the descriptions are very important to measure the similarity between entities since they can be treat-ed as some potential features describing an entity. Second, it is difficult to estimate how many and which kind of single similarities are needed for an aggregation method to get a satisfactory result.
On the other hand, in order to find more map-pings, many structural ontology matching meth-ods are proposed. To the best of our knowledge, previous structural methods are either local meth-ods (Le et al., 2004; Sunna and Cruz, 2007) or global (i.e. iterative) methods but only use part of the structure information of the ontology (Li et al., 2009; Ngo and Bellahsene, 2012). For ex-ample, the ontology matching system YAM++ (N-go and Bellahsene, 2012) utilizes a global struc-tural method but it only uses the structure informa-tion of classes and properties to create the propa-gation graph to find mappings between classes and properties. A large amount of instances and their relations to classes and properties in the ontology haven X  X  been exploited in this system.

To overcome the existing limitations, we pro-pose in this paper a representation learning method to capture the interactions among entity X  X  descrip-tions; then we present our global structural method which exploits more abundant structure informa-tion of the ontology. We summarize our contribu-tions as follows.  X  We propose to use the deep neural network  X  We propose a global similarity propagation
To evaluate the effectiveness of our approach, we conduct experiments on the public datasets from OAEI campaign (We select the OAEI data sets mainly because evaluation metrics have been well defined on these data sets and comparision can be easily made). The experimental result-s show that our matching approach can achieve a competitive matching performance compared to the state-of-the-art systems. Ontology is a formal, explicit specification of a shared conceptualization in terms of classes, prop-erties and relations (Euzenat et al., 2004). The pro-cess of ontology matching is to find mappings (or correspondences) between entities (classes, prop-erties or individuals) from two ontologies. A map-ping is defined as a four-tuple as written in Eq.(1), where e 1 and e 2 represent the entity in ontology O 1 and O 2 respectively, r is a kind of matching relation (e.g., equivalent, subsume) and k  X  [0 , 1] is the degree of confidence of matching relation between e 1 and e 2 (Mao et al., 2010). Similar with most of the OAEI systems (Li et al., 2009; Ngo and Bellahsene, 2012; Cheatham and Hitzler, 2013b), we focus on discovering only e-quivalent mappings between classes and proper-ties with cardinality 1:1. That is, one class (prop-erty) in ontology O 1 can be matched to at most one class (property) in ontology O 2 and vise versa. In this paper, we propose a structural ontology matching approach using automatically learned entity representation, which we call ERSOM. Fig.1 shows the architecture of our approach. The details of its major modules are given in the fol-lowing sections. 3.1 Learning the representation of entity In this section, we present how to learn the high-level abstract representations for ontology entities. The motivations are: 1) we regard different kinds of the descriptions of an entity as a whole to avoid Figure 1: The architecture of ERSOM. Given the two to-be-matched ontologies, we first extract the descriptive information for each entity, then learn the entity X  X  abstract representation based on its de-scriptions, and finally utilize the representations to compute the similarities between entities to initial-ize the similarity propagation method to find final mappings. separatively calculating the similarities and aggre-gating them later with a combination method; 2) the learned representation can not only express the meaning of the original descriptions of an entity but also captures the interactions among different descriptions. 3.1.1 Creating term vector for entity We first generate a combination of the entity X  X  de-scriptions (CDs for short) and then create a term vector for each entity. In particular, the CDs of a class = the class X  X  ID + label + comments + it-s properties X  descriptions + its instances X  descrip-tions. The CDs of a property = the property X  X  ID + label + its domain + its range (or its textual val-ue when the property is a datatype property). And the CDs of an instance = the instance X  X  ID + la-bel + its properties X  values. A binary term vector is created for each entity with the pre-processing that consists of tokenizing, removing stop words, stemming and deleting superfluous words. In the binary term vectors, element 1 and 0 refer to the existence and inexistence of a specific word, re-spectively. 3.1.2 Learning entity representations In the ontology matching area, training data usual-ly refers to a pair of ontologies with correct map-pings created by domain experts between their en-tities. The acquisition of such dataset is time-consuming and laborious. We state in this sec-tion how to learn the abstract representations for entities from their binary term vectors with an un-supervised way. The deep neural network (DNN) (Hinton et al., 2006; Bengio et al., 2007) is a multi-layer learning model. It is mainly used for learning the high-level abstract representations of original input data. Given the generalization and the ab-straction introduced in the representation learning procedure, DNN allows us to better model the in-teractions among different kinds of input features, and measure the similarity at a more general lev-el. Inspired by the work in (Hinton, 2007; Bengio et al., 2012; He et al., 2013; Cui et al., 2014), we use auto-encoder (Bourlard and Kamp, 1988; Hin-ton and Zemel, 1994) to learn the representations for classes and properties. The auto-encoder is one of the neural network variants that can automati-cally discover interesting abstractions to represent an unlabeled dataset.
 Figure 2: Unsupervised representation learning.
As shown in Fig.2, the input to the auto-encoder is denoted as x , which indicates a binary term vec-tor of a class or a property. Auto-encoder tries to learn an approximation to the identity function h ( x ) , so as to output b x that is similar to x . More specifically, the auto-encoder consists of an encod-ing process h ( x ) = f ( Wx + b 1 ) and a decod-ing process g ( h ( x )) = f ( W T h ( x ) + b 2 ) , where f is a activation function like the sigmoid func-tion f ( x ) = 1 / (1 + exp (  X  x )) , W is the weight matrix and b is the bias term. The goal of the auto-encoder is to minimize the reconstruction er-maximum information. Through the combination and transformation, auto-encoder learns the ab-stract representation h ( x ) of the input binary term vector. The representation is a real vector with val-ues between 0 and 1.

In consideration of the large number of units in the hidden layer (as marked in Fig.2), a sparsity constraint is imposed on the hidden units to hold the capacity to discover interesting structure in the data. We use sparse auto-encoder (Coates et al., 2011) to learn the correlations between descrip-tions from their binary term vectors. The sparse auto-encoder attempts to minimize the following loss function: J ( W,b ) = inal k X k F is the Frobenius norm,  X  controls the weight of the sparsity penalty term, H is the set of hidden units, and  X  is the sparsity parameter. For-mally, KL (  X  k b  X  h ) =  X  log  X  is the Kullback-Leibler (KL) divergence between a Bernoulli random variable with mean  X  and a Bernoulli random variable with mean b y h .
Figure 3: Learning higher level representations. 3.1.3 Learning higher level representations The auto-encoder which only has one hidden layer may not be enough to learn the complex interac-tions between input features. Inspired by the work of Vincent et al. (2010) and He et al. (2013), we build multi-layer model to learn more abstract en-tity representations. To achieve this, we repeatedly stack new sparse auto-encoder on top of the previ-ously learned h ( x ) (i.e., the higher level represen-tations are formed by combination of lower lev-el representations). This model is called Stacked Auto-Encoder (SAE) by Bengio et al. (2007). In this way, when we input the binary term vector to the network, we can get its abstract represen-tations in different levels. In other words, with the layer-by-layer learning, we obtain different level-s of representations. The top-level representation, which models the final interactions of the original descriptions, can be used to measure the similarity between classes and properties.

The prototype of Stacked Auto-Encoder (SAE) is shown in Fig.3, where f ( h ( x )) ( m ) denotes the final representation learned by the top-level hidden layer and superscript m means the SAE consists of m sparse auto-encoders. 3.2 Optimizing with the ontology structure The above method can only consider the local de-scriptions (such as ID, label and comments etc.) of entities in ontology. According to the study in (Melnik et al., 2002), we present our struc-tural method or called Similarity Propagation (SP) method, which exploits more abundant structure information of the ontology to discover more map-pings globally. The intuition behind the propaga-tion idea is that the similarity between two entities is not only about their neighbor entities, but it is about all other entities (neighbor entities X  neigh-bor entities) in the ontologies. This idea has also been used in the ontology matching systems Ri-MOM(Li et al., 2009) and YAM++(Ngo and Bel-lahsene, 2012) in order to find mappings between classes and properties. But the nodes in their propagation graph are just limited to class pairs and property pairs, and the propagation edges are transformed from relations between two classes, two properties or a class and a property. The dif-ference of our SP method is that we consider the instances and its relations with classes and prop-erties when creating the propagation graph even if we also only find mappings between classes and properties. This is because (1) the similar degree of two classes will be increased if they have some of similar instances; (2) the similar degree of two properties will be increased if the instances that own these properties are similar. The propagation graph in our SP method will be much more com-plete compared with the previous ones.
Algorithm 1 presents the procedures of our SP method. In the first two steps of it, we repre-sent each to-be-matched ontology to a Directed Labeled Graph (DLG). Each edge in the DLG has format ( s,p,o ) , where s and o are the source and target nodes (each node represents a class, a property or an instance), and the edge X  X  label p comes from one of the seven ontology relation-s including HasSubClass , HasSubProperty , Ha-sObjectProperty , HasDataProperty , HasInstance , HasDomain , HasRange . Then we create a Pair-wise Connectivity Graph (PCG) from two DLGs by merging edges having the same labels.
 Algorithm 1: Our SP Algorithm
Input : The to-be-matched ontologies, O R
Output : The updated similarity matrix, M 1 ;
DLG 1  X  Transform ( O R ) ;
DLG 2  X  Transform ( O T ) ;
PCG  X  Merge ( DLG 1 ,DLG 2 ) ;
IPG  X  Initiate ( PCG,M 0 ,W ) ; M 1  X  Propagation ( IPG,Normalized ) ;
In the fourth step of Algorithm 1, for a PCG, we assign weight values to edges as the inverse of the number of out-linking relationships of it-s source node (Melnik et al., 2002). For the n-odes that consist of two classes or two properties, we assign them values calculated with the cosine similarity between their representations learned in section 2.1.3. For the node consisting of two in-stances, the similarity value assigned to it is mea-of instances. In this way, we construct an Induced Propagation Graph (IPG) on which the propaga-tion algorithm will run iteratively. Let  X  ( x,y ) de-notes the similarity score between entities x and y for node ( x,y ) in the IPG. At the ( i + 1) th itera-tion, the similarity score is updated as follows: where z is the normalization factor defined as z = max the initial time and i th iterations, respectively.  X  () is the function to compute the similarities propa-gated from the adjacent node  X  i j connected to n-ode ( x,y ) in the ( i + 1) th iteration. And w j is the weight of edge between the node ( x,y ) and its j th neighboring node.

During each iteration in the final step of Algo-rithm 1, only the similarity value between two en-tities in the node will be updated. At the end of each iteration, all similarity values are normalized by a Normalized function to all in range [0 , 1] . The iteration stops after a predefined number of steps. 3.3 Mapping selection Similar with the work in (Wang and Xu, 2007; Huang et al., 2007; Ngo and Bellahsene, 2012), we use the Stable Marriage (SM) algorithm (Melnik et al., 2002) to choose the 1:1 mappings from the M rows and N columns similarity matrix, where M and N is the number of classes and properties in ontologies O 1 and O 2 , respectively. In addition, before we run the SM algorithm we set the value of cell [ i,j ] of the similarity matrix to zero if i and j correspond to different types of entities. Thus, we remove lots of redundant data and only find the mappings between classes or properties. 4.1 Data sets and evaluation criteria The annual OAEI campaign is an authoritative contest in the area of ontology matching, we choose the data from OAEI in our experiments, because the evaluation metrics have been well de-fined and the comparision can be easily made. We observe strong structure similarities lies be-tween OAEI ontologies and ontologies used in NLP tasks, such as WordNet and HowNet for WS-D (Li et al., 1995; Agirre et al., 2009), and Free-base, YAGO, and knowledge graph for IE, text mining and QA (Yao and Van Durme, 2014; Yao et al., 2014), both describe entities and their rela-tions with class, properties and instances.
Development dataset: the Standard Bench-mark 2012 dataset that OAEI provides for devel-opers to test their system before participating in the competition is used as the development dataset in our experiments. This dataset contains one ref-erence ontology and 109 target ontologies. We use this dataset to test various values for the parame-ters in our ERSOM and apply the best ones to the experiments on the testing datasets.

Testing dataset: (1) the Benchmark-Biblio 2012 dataset which contains one reference ontol-ogy and 94 target ontologies; (2) the Benchmark-Biblioc 2013 dataset which has five sub-datasets and there are one reference ontology and 93 target ontologies in each sub-dataset. We use these two datasets to evaluate the performance of our ER-SOM approach.

In the matching scenario, each target ontolo-gy should be mapped to the reference ontology. We followed the standard evaluation criteria from the OAEI, calculating the precision, recall and f-measure over each test. The version computed here is the harmonic mean of precision and recall. 4.2 Experimental design and results 4.2.1 Evaluation for representation learning tract descriptions for entities according to the de-scription in section 2.1.1, then we create a vocabu-lary based on the dataset and denote each class and property as a binary term vector. We apply the L-BFGS algorithm (Ngiam et al., 2011) to train the stacked auto-encoder described in section 2.1.3. The size of the input layer is equals to the length of the vocabulary created from the dataset. We fix the parameters  X  = 1 e  X  4 ,  X  = 3 and  X  = 0 . 25 in Eq.2, and set the size of the first and second hidden layer of the stacked auto-encoder to 200 and 100, respectively, by experience. The number of itera-tions of the L-BFGS algorithm is set to 500. We use the learned representations to measure the sim-ilarities between classes and properties and apply the strategy presented in section 2.3 to extract final mappings. The matching results of our Unsuper-vised Representation Learning (URL) method on the development dataset and testing datasets are shown in Table 1 and Table 2, respectively. Table 1: Representation learning on dev. dataset.
In Table 1, TV denotes the matcher in which the similarities are calculated between binary ter-m vectors of classes and properties by using co-sine measure. URL( i ), where i  X  { 1 , 2 } , repre-sents that we use the representations learned by the i th hidden layer of the stacked auto-encoder to measure the similarities between classes and prop-erties to find mappings. Table 1 shows that on the development dataset, the F-measure of TV is 0.748 and it is improved 9.6% and 12.8% when we use the representations learned by the single-layer and double-layer auto-encoder to find the mappings, respectively. It illustrates that we have learned some useful information from the term vectors, which can be explained as the interactions between descriptions of entities. From the last two rows in Table 1, we can find that the F-measure im-proved by 2.9% when we use the representations learned by the second hidden layer (i.e., URL(2)) to measure the similarities.
 Table 2: Representation learning on test datasets.
From Table 2 we can see that the F-measures are increased on both of the testing datasets when we use the learned representations to measure simi-larities between classes and properties compared with using term vectors, but the amount of im-provements are less than that on the development dataset. This is because we estimate the parame-ters of the representation learning model on the de-velopment dataset and then apply them on the test tasks directly. The precision is reduced when we use URL method, this may be due to the learned representations of entities are too general. In ad-dition, in the parameter adjustment process, we try to make the F value maximization, but not to care about mapping precision. This is because we usually compare the performance of the systems based on their matching F values. 4.2.2 Comparison with aggregation methods Aggregating different similarities is pervasive in ontology matching systems that contain mul-tiple single matchers, for example, Falcon-AO(Qu et al., 2006), RiMOM(Li et al., 2009), YAM++(Ngo and Bellahsene, 2012), etc. Since our representation learning method also combines all descriptions of an entity together in an unsu-pervised way, we compare it with previous unsu-pervised aggregation strategies, that is, Max, Av-erage, Sigmoid, Weighted(Cruz et al., 2010) and Harmony(Mao et al., 2008, 2010). As the work in (Mao et al., 2010; Ngo and Bellahsene, 2012), we first define three context profiles including in-dividual profile, semantic profile and external pro-file for each class and property (this equivalent to divide the collection of descriptions of a class or a property into three different parts). Then we ap-ply a vector space model with TFIDF weighting scheme and cosine similarity measure to compute similarity scores between profiles. And finally, we aggregate these three single similarities using dif-ferent aggregation methods.
 Table 3: Comparison with aggregation methods.
Table 3 shows the F-measure of the single matchers and aggregation methods on the devel-opment dataset (Dev. for short) and two test-ing datasets (i.e., Tes.1 and Tes.2, which refer to the Benchmark-Biblio 2012 dataset and the Benchmark-Biblioc 2013 dataset, respectively). First, the performance of single matcher is poor, the highest F-measures are 0.668, 0.612 and 0.611 on the datasets Dev., Tes.1 and Tes.2, respective-ly. And when we use external profile to calcu-late the similarities, the F-measures are reduced to 22%. Second, the performance is dramatical-ly boosted by aggregation methods and they al-l achieve F-measures higher than 0.7, so the ag-gregation methods are very effective in improving the performance of mapping approaches that re-ly on measuring multiple similarities. And finally, our Unsupervised Representation Learning (URL) method holds the highest F-measure both on the development dataset and on the testing datasets. 4.2.3 Evaluation for our structural method In this experiment, we compare our Similarity Propagation (SP) method to other structure based methods, that is, ADJACENTS and ASCOPATH in (Le et al., 2004); DSI and SSC in (Sunna and Cruz, 2007); Li X  X  SP (Li et al., 2009) and Ngo X  X  SP (Ngo and Bellahsene, 2012). We first use enti-ty X  X  ID to compute the similarity between classes and properties to provide an unified initial simi-larity matrix as input (or initialization) for our SP and other structural methods. Then, a new similar-ity matrix will be created and updated by consid-ering the initial similarities and different structure information. And finally, we extract the mappings from the newly created similarity matrix with the strategy described in section 2.3.
 Table 4: Comparison with structural methods.
In ADJACENTS method, the parameter W k , where k  X  { 1 , 2 , 3 } , is set to 1/3. The parameter MCP in the methods DSI and SSC is set to 0.75 as reported in their work. The iterative times to SP al-gorithm are fixed to 50. Table 4 reports the match-ing F-measures of these structure based methods on the development dataset (Dev. for short) and testing datasets (Tes.1, Tes.2 for short).

From table 4 we can see that the local-structure based methods (i.e., ADJACENTS, ASCOPATH, DSI and SSC) provide low matching quality. It means that these methods did not discover enough additional correct mappings or even find some in-correct mappings. For example, the F-measure even reduced on the development dataset when use ASCOPATH method. This is because if two enti-ties don X  X  have any common entity in their ances-tors, their similarity is equal to 0. Whereas, Li X  X  SP and Ngo X  X  SP are global-structure based meth-ods, and they seem to work well. The F-measure has even improved by 21.9% when using the N-go X  X  SP compared with the initial matcher. This is because in the SP method, the similarity score of a pair of entities depends on not only their cur-rent status but also on the status of the other pairs. That explains why SP outperforms all other local based structural methods. In our SP, all instances and their relations to other entities in ontology are exploited to help find the mappings between class-es and properties, therefore the matching quality is distinctly improved.

The last two rows of Table 4 shows that when we use the learned representations to cre-ate the initial similarity matrix to initialize our SP method, the matching quality is significantly im-proved. For example, the F-measure is improved from 0.810 to 0.903 on the development dataset. This illustrates that the initialization step is very important to the SP method. 4.2.4 Comparison with other ontology We compare our ontology matching approach, called ERSOM, with other multi-strategy match-ing systems on the testing datasets. Fig.4 lists the results of top five matching systems according to their F-measures on the Benchmark-Biblio 2012 dataset and Benchmark-Biblioc 2013 dataset.
As shown in Fig.4, ERSOM outperforms most of the participates except the systems YAM++ and CroMatcher whose F-measures are 0.89 and 0.88 in 2013, respectively. CroMatcher achieves the same level of recall as YAM++ but with consis-tently lower precision (Grau et al., 2014). Un-like MapSSS, our approach does not use any exter-nal resources such as Google queries in its current version. In YAM++ approach, the gold standard datasets that taken from Benchmark dataset pub-lished in OAEI 2009 are used to generate training data to train a decision tree classifier. And in the classifying phase, each pair of elements from two to-be-matched ontologies is predicted as matched or not according to its attributes. However, ER-SOM is an unsupervised approach, but it does not exclude using external resources and training da-ta to help learning the representations of entities and provide the initial similarity matrix for the SP method to further improve the performance. There are many studies on Ontology Matching (Euzenat et al., 2007; Shvaiko and Euzenat, 2013). Currently, almost all ontology matching system-s exploit various kinds of information provided in
Figure 4: Comparison with other OAEI systems. ontologies to get better performance. To aggre-gate the different similarity matrixes, various ap-proaches have been proposed.

Pirr  X  o and Talia (2010) is a generic schema matching system. It exploits Max , Min , Average and Weighted strategies for the combination. The weighted method assigns a relative weight to each similarity matrix, and calculates a weighted sum of similarity for all similarity matrixes. The Aver-age method is a special case of Weighted , which considers each similarity matrix equally important in the combination. Max and Min are two extreme cases that return the highest and lowest similari-ties in all similarity matrixes respectively. Ji et al. (2011) use the Ordered Weighted Average (OWA) to combine different matchers. It is a kind of ontology-independent combination method which can assign weights to the entity level, i.e., it use a specific ordered position rather than a weight as-sociated with a specific similarity matrix to aggre-gate multiple matchers. Jean-Mary et al. (2009) combines different matchers by using a weighted sum strategy that adjusts weights empirically, or based on some static rules. This approach cannot automatically combine different matchers in vari-ous matching tasks.

There are several works which exploit the su-pervised machine learning techniques for ontolo-gy matching. Eckert et al. (2009), string-based, linguistic and structural measures (in total 23 fea-tures) were used as input to train a SVM clas-sifier to align ontologies. CSR (Classification-based learning of Subsumption Relations) is a generic method for automatic ontology matching between concepts based on supervised machine learning (Spiliopoulos et al., 2010). It specifically focusses on discovering subsumption correspon-dences. SMB (Schema Matcher Boosting) is an approach to combining matchers into ensembles (Gal, 2011). It is based on a machine learning technique called boosting, that is able to selec-t (presumably the most appropriate) matchers that participate in an ensemble.

The difference of our work is that the textual descriptions are not been directly used to measure the similarities between entities. We learn a rep-resentation for each ontology entity in an unsuper-vised way to capture the interactions among the descriptions, which avoid the problem of selecting and aggregating different individual similarities. The successful ontology matching is very impor-tant to link heterogeneous ontologies for NLP. In this paper, we have proposed an ontology match-ing approach, ERSOM, which describes the class-es and properties in ontology with abstract repre-sentations learned from their descriptions and im-proves the overall matching quality using an it-erative Similarity Propagation (SP) method based on more abundant structure information. Experi-mental results on the datasets from OAEI demon-strate that our approach performs better than most of the participants and achieves a competitive per-formance. In our future work, we will consid-er to use the ontology matching approach to the matching between different NLP-oriented ontolo-gies such as wordnet, Freebase, YAGO, etc.
 This research is supported by National Key Basic Research Program of China (No.2014CB340504) and National Natural Science Foundation of China (No.61375074,61273318). The corresponding au-thors of this paper are Baobao Chang and Zhifang Sui.
 Agirre, E., De Lacalle, O. L., Soroa, A., and
Fakultatea, I. (2009). Knowledge-based wsd and specific domains: Performing better than generic supervised wsd. In IJCAI , pages 1501 X  1506. Citeseer.
 Bengio, Y., Courville, A. C., and Vincent, P. (2012). Unsupervised feature learning and deep learning: A review and new perspectives. CoRR abs/1206.5538 .
 Bengio, Y., Lamblin, P., Popovici, D., and
Larochelle, H. (2007). Greedy layer-wise train-ing of deep networks. Advances in neural infor-mation processing systems , 19:153.
 Bourlard, H. and Kamp, Y. (1988). Auto-association by multilayer perceptrons and sin-gular value decomposition. Biological cyber-netics , 59(4-5):291 X 294.
 Bryl, V., Giuliano, C., Serafini, L., and Ty-moshenko, K. (2010). Supporting natural lan-guage processing with background knowledge: Coreference resolution case. In The Semantic Web X  X SWC 2010 , pages 80 X 95. Springer.
 Cheatham, M. and Hitzler, P. (2013a). String similarity metrics for ontology alignment. In The Semantic Web X  X SWC 2013 , pages 294 X 309. Springer.
 Cheatham, M. and Hitzler, P. (2013b). Stringsauto and mapsss results for oaei 2013. Ontology Matching , page 146.
 Coates, A., Ng, A. Y., and Lee, H. (2011). An analysis of single-layer networks in unsuper-vised feature learning. In International Con-ference on Artificial Intelligence and Statistics , pages 215 X 223.
 Cruz, I. F., Stroe, C., Caci, M., Caimi, F., Pal-monari, M., Antonelli, F. P., and Keles, U. C. (2010). Using agreementmaker to align on-tologies for oaei 2010. In ISWC Interna-tional Workshop on Ontology Matching (OM).

CEUR Workshop Proceedings , volume 689, pages 118 X 125.
 Cui, L., Zhang, D., Liu, S., Chen, Q., Li, M.,
Zhou, M., and Yang, M. (2014). Learning top-ic representation for smt with neural networks.
In Proceedings of the 52nd Annual Meeting of the Association for Computational Linguistics , volume 1, pages 133 X 143.
 Eckert, K., Meilicke, C., and Stuckenschmidt,
H. (2009). Improving ontology matching us-ing meta-level learning. In The Semantic We-b: Research and Applications , pages 158 X 172. Springer.
 Euzenat, J., Euzenat, J., Shvaiko, P., et al. (2007). Ontology matching . Springer.
 Euzenat, J., Le Bach, T., Barrasa, J., Bouquet, P., De Bo, J., Dieng-Kuntz, R., Ehrig, M.,
Hauswirth, M., Jarrar, M., Lara, R., et al. (2004). State of the art on ontology alignment. Knowledge Web Deliverable D , 2:2 X 3.
 Gal, A. (2011). Uncertain schema matching. Syn-thesis Lectures on Data Management , 3(1):1 X  97.
 Grau, B. C., Dragisic, Z., Eckert, K., Euzenat, J., Ferrara, A., Granada, R., Ivanova, V., Jim  X  enez-Ruiz, E., Kempf, A., Lambrix, P., et al. (2014).
Results of the ontology alignment evaluation initiative 2013. In International Workshop on Ontology Matching, collocated with the 12th
International Semantic Web Conference-ISWC 2013 , pages pp X 61.
 He, Z., Liu, S., Li, M., Zhou, M., Zhang, L., and
Wang, H. (2013). Learning entity representation for entity disambiguation. In ACL (2) , pages 30 X 34.
 Hinton, G. E. (2007). Learning multiple layers of representation. Trends in cognitive sciences , 11(10):428 X 434.
 Hinton, G. E. and Zemel, R. S. (1994). Au-toencoders, minimum description length, and helmholtz free energy. Advances in neural in-formation processing systems , pages 3 X 3.
 Huang, J., Dang, J., Vidal, J. M., and Huhns, M. N. (2007). Ontology matching using an artificial neural network to learn weights. In Proc. IJCAI Workshop on Semantic Web for Collaborative Knowledge Acquisition (SWeCKa-07), India .
 Jean-Mary, Y. R., Shironoshita, E. P., and Kabuka,
M. R. (2009). Ontology matching with semantic verification. Web Semantics: Science, Services and Agents on the World Wide Web , 7(3):235 X  251.
 Ji, Q., Haase, P., and Qi, G. (2011). Combination of similarity measures in ontology matching us-ing the owa operator. In Recent Developments in the Ordered Weighted Averaging Operators: Theory and Practice , pages 281 X 295. Springer. Le, B. T., Dieng-Kuntz, R., and Gandon, F. (2004).
On ontology matching problems. ICEIS (4) , pages 236 X 243.
 Li, J., Tang, J., Li, Y., and Luo, Q. (2009). Ri-mom: A dynamic multistrategy ontology align-ment framework. Knowledge and Data En-gineering, IEEE Transactions on , 21(8):1218 X  1232.
 Li, X., Szpakowicz, S., and Matwin, S. (1995). A wordnet-based algorithm for word sense disam-biguation. In IJCAI , volume 95, pages 1368 X  1374. Citeseer.
 Mao, M., Peng, Y., and Spring, M. (2008). A harmony based adaptive ontology mapping ap-proach. In SWWS , pages 336 X 342.
 Mao, M., Peng, Y., and Spring, M. (2010). An adaptive ontology mapping approach with neu-ral network based constraint satisfaction. Web Semantics: Science, Services and Agents on the World Wide Web , 8(1):14 X 25.
 Melnik, S., Garcia-Molina, H., and Rahm, E. (2002). Similarity flooding: A versatile graph matching algorithm and its application to schema matching. In Data Engineering, 2002.
Proceedings. 18th International Conference on , pages 117 X 128. IEEE.
 Ngiam, J., Coates, A., Lahiri, A., Prochnow, B.,
Le, Q. V., and Ng, A. Y. (2011). On optimiza-tion methods for deep learning. In Proceedings of the 28th International Conference on Ma-chine Learning (ICML-11) , pages 265 X 272.
 Ngo, D. and Bellahsene, Z. (2012). Yam++: a multi-strategy based approach for ontology matching task. In Knowledge Engineering and Knowledge Management , pages 421 X 425. Springer.
 Pirr  X  o, G. and Talia, D. (2010). Ufome: An on-tology mapping system with strategy prediction capabilities. Data &amp; Knowledge Engineering , 69(5):444 X 471.
 Qu, Y., Hu, W., and Cheng, G. (2006). Construct-ing virtual documents for ontology matching.
In Proceedings of the 15th international confer-ence on World Wide Web , pages 23 X 31. ACM.
 Shvaiko, P. and Euzenat, J. (2013). Ontology matching: state of the art and future challenges.
Knowledge and Data Engineering, IEEE Trans-actions on , 25(1):158 X 176.
 Spiliopoulos, V., Vouros, G. A., and Karkaletsis,
V. (2010). On the discovery of subsumption re-lations for the alignment of ontologies. Web Se-mantics: Science, Services and Agents on the World Wide Web , 8(1):69 X 88.
 Sunna, W. and Cruz, I. F. (2007). Structure-based methods to enhance geospatial ontology align-ment. In GeoSpatial Semantics , pages 82 X 97. Springer.
 Vincent, P., Larochelle, H., Lajoie, I., Bengio, Y., and Manzagol, P.-A. (2010). Stacked denoising autoencoders: Learning useful representations in a deep network with a local denoising criteri-on. The Journal of Machine Learning Research , 11:3371 X 3408.
 Wang, P. and Xu, B. (2007). Lily: the results for the ontology alignment contest oaei 2007. In
Proceedings of the Second International Work-shop on Ontology Matching , pages 179 X 187. Citeseer.
 Yao, X., Berant, J., and Van Durme, B. (2014).
Freebase qa: Information extraction or semantic parsing? ACL 2014 , page 82.
 Yao, X. and Van Durme, B. (2014). Information extraction over structured data: Question an-swering with freebase. In Proceedings of ACL .
