 Linked Data (or LD) [2] has pervaded various domains and constitutes a web-scale data network. When users want to search entities, the users require special knowledge for LD such as SPARQL query language [8] as well as vocabularies, locations (or URLs) of SPARQL endpoints, and underlying structures of LD datasets. For example, suppose that a user wants to obtain movie and actor information, there are two steps she must do: (1) she describes her informa-tion need in SPARQL, and (2) she posts the SPARQL query onto appropriate SPARQL endpoints which contain movie and actor information (e.g., DBpedia 1 , or LinkedMDB 2 ). In this situation, she cannot obtain expected information un-less she properly knows how to describe her information demand in SPARQL and locations of SPARQL endpoints. Hence, searching over LD is still not an easy tool for non-professional users if they do not understand SPARQL, vocabularies and datasets in LD, and SPARQL endpoints.
 SANT , a C entralized R elati O nal I nterface for Web-S cale S P A RQL endpoi NT s (Section 2). In the proposed model, each view is defined by a view designer who quarries partial information from a SPARQL endpoint, and views are stored in a centralized management server. Views enable non-professional users to easily access necessary information without knowledge about SPARQL, vocabularies, and locations of SPARQL endpoints. When users query to the registered views, CROISSANT performs queries on the views and returns results to users. SPARQL endpoints and result transport latencies, thus, this paper introduces three optimization strategies, namely, view materialization , selection push-down , and view query merge (Section 3). As discussed on materialized view in relational database [16], materializing views is highly effective to reduce process-ing costs, when the materialized views are up-to-date. While, SPARQL endpoints are on the Web, thus it is needed to perform remote query processing, which is costly for query processing on SPARQL endpoints as well as result transport. Thus, it is important to reduce the number of results from remote SPARQL endpoints. To realize the reduction, this paper applies selection push-down opti-mization which puts selection conditions in the user queries into view queries to filter unnecessary results out from transport. More complicated queries such as joining multiple views takes more transport costs as the number of views in the queries. View query merge optimization copes with this situation, by combining view queries if they are connectable and on the same SPARQL endpoints. SPARQL endpoints, and the aforementioned optimizations achieve better pro-cessing time comparing with a na X ve approach (Section 4). As expected from the success of relational database optimizations, materialization optimization works best among the optimizations and a pure execution. Selection push-down also successfully filters unnecessary results on the views and reduces transport costs. View query merge decreases the selectivity of the concatenated queries than that of original view queries, and succeeds to reduce query execution costs.  X  CROISSANT : This paper proposes a centralized relational interface for
Web-scale SPARQL endpoints, which manages pre-defined views and realizes user-friendly interfaces.  X  Optimizations : This paper proposes three optimization techniques, namely, view materialization, selection push-down, and view query merge.  X  Experimentation : CROISSANT and the optimizations are examined on a real-world largest SPARQL endpoint, DBpedia, and shows applicability of CROISSANT as well as effectiveness of the optimization techniques.
 Fig. 1: SPARQL queries on views: movies containing movie information (i.e., ID, title, and country), actors with ID, name, and birthplace, and starring relation-ships which connect movies and actors views with dbp:starring predicates. CROISSANT is a centralized view management system for SPARQL endpoints, which provides relational interfaces based on pre-defined views on SPARQL end-points. CROISSANT involves two actors, view designers and users . The for-mer define views on SPARQL endpoints and store views on CROISSANT, and the latter ask queries (i.e., SQL queries) on views to CROISSANT and receive results of the queries. The pre-defined views are managed by CROISSANT which keeps the views in a view database. CROISSANT accepts user queries written in SQL, rewrites them into SPARQL queries, processes the queries onto corre-sponding SPARQL endpoints, and returns the results of the queries to users. plet as follows: Though schemas of views can be any format like relational, XML, JSON, and so on, this paper assumes the format is relational because relational format is one of the most common formats for Web applications and relational format directly fits to returned results from SPARQL queries. Fig. 1 shows three example view queries (namely, movie view, actor view, and starring view).
 CROISSANT (1) extracts relevant views for the input user query, (2) performs the view queries to obtain individual results, and (3) processes user queries over the results. The first step determines SPARQL endpoints and corresponding SPARQL queries related with user queries. Then, CROISSANT executes the SPARQL queries on corresponding SPARQL endpoints to materialize contents of the views onto the local storage. Finally, for the materialized views, CROIS-SANT executes the user queries to obtain results. The na X ve method has critical performance drawbacks as follows:  X  Execution cost : The na X ve executes view query on SPARQL endpoints. The cost depends on the query processing performances of SPARQL endpoints.  X  Transport cost : Results of view queries must be transported to the local server. The cost depends on the size of the results. In order to overcome the drawbacks of the na X ve method, CROISSANT em-ploys three optimization strategies for performing user queries. The individual optimization strategies will be discussed in the next sections as follows:  X  Materialized view (Section 3.1): Materializing views store the executed re-sults of the view queries onto the local storage in advance, thus it can reduce view query execution and transport costs of view query results.  X  Selection push-down (Section 3.2): Selection conditions on user queries are pushed down onto view queries if possible, and the numbers of view contents are reduced so that execution and transport costs can be reduced.  X  View query merge (Section 3.3): When views in user queries can be on the same SPARQL endpoints, these view queries are merged into one single
SPARQL query in order to reduce the number of SPARQL query executions, and, in consequence, transport costs are reduced. 3.1 View Materialization Performing SPARQL queries onto remote SPARQL endpoints is costly compar-ing with SQL performing on local server (i.e., CROISSANT server), and, in such situation, materialized views realize significant performance improvements. If the latest data of a view are available on the local server, CROISSANT can perform SQL query processing directly to materialized views without accessing to remote SPARQL endpoints. CROISSANT in this paper assumes relational views on SPARQL endpoints, thus each view can be materialized into local relational database. For other formats, view data are stored in a corresponding databases, for example, MongoDB 3 for JSON views, and BaseX 4 for XML views. Materialized views suffer from view update problem and query processing using materialized and non-materialized views.
 trigger functionalities help notify changes to database management systems and run program to restore the query results to materialized view. This is obviously not applicable to SPARQL endpoints on the Web, because they are not under control of CROISSANT. Some researches have attempted to realize the notifi-cation functionality (like [15, 20]), it is possible to use the functionality to know when to update the materialized views, however this is still an open problem. pages in Web crawling applications. In Web crawling researches, Poisson distri-bution is a popular distribution of page updates [5, 4]. Web crawlers can check cached Web pages based on the Poisson distribution. Observations of LD dynam-ics [11, 17] can be a help to introduce when to check updates of LD datasets, however, these observations are still not much helpful to characterize LD datasets in terms of update frequency. Consequently, periodical checking for updates of LD datasets is a compromising approach. If the update frequency on an LD data source follows a probability distribution (like Poisson distribution), Web crawl-ing strategies are applicable, that is, checking updates of view query results in periods derived from the probability distribution.
 frequency is quite high (more than query response, for example), it is not good option to materialize because of freshness of data in views. If a view is not mate-rialized, query processing on views suffer from time of view query processing and transport of results. Thus, if the update frequency of original data of a view in SPARQL endpoints is high, the view is kept non-materialized and CROISSANT executes view queries whenever users execute their queries. While, if the update frequency is low, the view is materialized eagerly and CROISSANT executes user queries directly on the materialized relational view. 3.2 Selection Push-down As optimization techniques in relational databases [16], in which selection push-down is a typical and significant approach to reduce the number of relevant re-sults on query operators, CROISSANT employs selection push-down approach. The number of records which meet selection conditions is typically significantly smaller than that of records in the tables. This observation indicates that selec-tion conditions should performed as soon in query plans as possible, especially when join operations are included in the query.
 queries. As user queries are written in SQL language, selection conditions on user queries can be represented as selection operators. CROISSANT then classifies the extracted selection operations into views (obviously, once CROISSANT knows chosen relations and selection conditions on attributes of them, it also knows corresponding views and SPARQL variables on the views). Finally, CROISSANT puts FILTER clauses into view queries.
 &lt; ,  X  , = ,  X  , and &gt; ) to compare an attribute with numeric values and regu-lar expression-based comparators for textual values. In order to deal with these operators, CROISSANT includes rules to convert selection conditions into FIL-TER expressions. This paper defines three basic rules in Table 1. The first rule is about numeric conditions which directly put in the FILTER clause. The second rule is about textual equality conditions. Because textual values in RDF typically have language information (e.g., @en means English text), direct comparisons do not work, str(  X  ) function is applied to return language-ignored textual values of variables. The third rule is about regular expression-based textual match-ing. Fortunately, SPARQL includes regular expression function called regex(  X  ) which judges whether textual values match with input regular expressions. =  X  X nited States X   X  on movies table (Fig. 1(a)), CROISSANT pushes the se-lection condition  X  country =  X  X nited States X   X  into the view query of the movies view as Fig. 2. Due to the selection condition includes the textual value Table 1: Conversion from selection conditions to SPARQL FILTER clauses. (i.e.,  X  X nited States X ), CROISSANT understands the variable country must have textual values and then applies the second rule in Table 1. 3.3 View Query Merge Query performance of user queries depends on the numbers of views included in the user queries because the numbers of views are corresponding with that of SPARQL queries to be performed. However, some of views may be of same SPARQL endpoints. If the graph patterns in SPARQL queries in the view queries can be connected (i.e., share same variables), these queries can be integrated as a single SPARQL query. As a result of combination, there are two benefits: (1) as graph patterns get complicated, the number of results matching with the query can be decreased, in consequence, result transport cost can be reduced; and (2) (relational) join processing on the local server (typically, this is costly) can be ignored, because the single SPARQL query returns the joined results. tions between views, then merges corresponding views with the join conditions. CROISSANT accepts a common join operation called  X  -join which conditions can be either &lt; ,  X  , = ,  X  , or &gt; . CROISSANT merges views on the same SPARQL endpoints with the join conditions as following steps: (1) CROISSANT extracts returned variables for each view, makes a list of the variables for merged views with duplicate elimination, and puts the list into SELECT clause; (2) CROIS-SANT extracts graph patterns in WHERE clause for each view, eliminates du-plicates of the graph patterns, and puts them into WHERE clause; (3) Finally, CROISSANT adds FILTER clauses for all join conditions. This simple query merging approach can generate redundant graph patterns. For example, sup-pose joining tables of view in Fig. 1 with equality conditions movies.movieID = starring.movieID and actors.actorID = starring.actorID , the equal-ity conditions are no more necessary because starring relationship concatenates movieID and actorID with the dbp:starring predicate. Hence, if join condi-tions are about to natural join, the conditions can be ignored. As a result, merged queries can be simplified.
 queries corresponding with the query as Fig. 3(b). The query is related with the Fig. 3: Example query for view query merge (a) and the merged view query (b). The three views in Fig. 1 are merged in terms of ID variables, thus join conditions are eliminated. three views in Fig. 1 and they are of the same SPARQL endpoint, then CROIS-SANT merges their view queries and remove redundant projection conditions as well as equality conditions between variables. 3.4 Query Execution Consequently, CROISSANT performs the aforementioned optimization tech-niques simultaneously. Algorithm 1 summarizes the query execution process with the optimizations. First of all, CROISSANT groups views related to the input user query Q into a series of view sets which are of same SPARQL endpoints (Line 2). Then, CROISSANT materializes views onto the local storage (Line 4 to 19). If all views in a group are already materialized, CROISSANT keeps these views into processing tables referred to as M (Line 5 to 6). Otherwise, CROISSANT needs to process SPARQL queries of the views (Line 7 to 17). In this process, CROISSANT applies the optimization techniques step by step. CROISSANT first determines subset of views which are mergeable in terms of join conditions in the user query (Line 8). Then, CROISSANT generates a merged query, perform selection push-down, executes the optimized SPARQL queries on SPARQL endpoints, and materializes to the local server (Line 9 to 11). Views which are not grouped in the previous process are performed selection push-down and materialization (Line 13 to 17). Finally, CROISSANT rewrites the user query by removing unnecessary conditions which are consumed in the optimizations and executes the rewritten query on the materialized views. The experimental evaluation attempts to answer the following questions. Q1: Is CROISSANT applicable to real-world SPARQL endpoints? Q2: How much performance improvements can be achieved when the proposed optimization techniques are applied? Algorithm 1 Query Execution with Optimization In order to answer these questions, CROISSANT runs on a local server holding a relational database (PostgreSQL 5 in this implementation), this paper designs views and queries on real-world SPARQL endpoints on the Web, and evaluates CROISSANT in terms of processing performance. The following sections explain experimental settings (Section 4.1) and evaluation results (Section 4.2). 4.1 Experimental Settings In order to answer Q1 , CROISSANT is applied to the most popular SPARQL endpoint, DBpedia which is the largest knowledge base on the Web and contains large variations of entities. SPARQL endpoint of DBpedia is very stable and reasonably fast, thus it is good for evaluation.
 manage movies (Fig. 1(a)), actors (Fig. 1(b)), and starring relationships among them (Fig. 1(c)). The number of results of the movie view is about 0.3 million, that of the actor view is about 1.3 million, and that of the relationship view is about 0.3 million. These numbers indicate that the actor view is more preferred to be materialized, otherwise it takes time to materialize the view online due to the number of results. In addition, if the number can be reduced by optimization techniques, the cost of transporting the results can be reduced.
 whether optimizations work. The queries include two simple selection queries ( q0 and q1 ) and two join queries with and without selection conditions ( q2 and q3 ). The former two queries are used for observing effectiveness of selection push-down, and the latter two queries are used for observing effectiveness of view query merge as well as selection push-down. Fig. 4: A set of queries for evaluation. q0 and q1 are simple selection queries. q2 is a join query among the three tables without selection condition. q3 is analogous to q2 with selection conditions.
 measures the average time for executions and transports over 10 trials for each optimization strategy. The optimization strategies are ( P ) pure execution, ( M ) materialization, ( SP ) selection push-down, ( MG ) view query merge, and ( MGSP ) view query merge with selection push-down.  X  ( P ): CROISSANT purely executes view queries of input queries, stores the results into the local storage, and executes user queries over the local storage.  X  ( M ): CROISSANT materializes all views into the local storage in advance, and, then executes on demand user queries on the materialized views.  X  ( SP ): CROISSANT performs selection push-down if available, executes view queries with pushed down selection conditions, stores the results and executes user queries over the local storage.  X  ( MG ): CROISSANT performs view query merge if possible, executes merged queries, stores the results into the local storage, and executes user queries.  X  ( MGSP ): This is concatenation of ( SP ) and ( MG ). 4.2 Results Fig. 5 shows processing times for each query in terms of five optimization strategies, and the figure indicates that CROISSANT is applicable to real-world SPARQL endpoints and optimization improves query processing performance. As expected, materialization works the best among optimizations for all queries in this experiment. In the case where materialization is not applicable, selection push-down and view query merge are good optimization choices as shown for q0 , q2 , and q3 . In particular, the combination of selection push-down and view query merge ( MGSP ) for q3 achieves significant improvements from individual optimizations (i.e., MG and SP ).
 A1: CROISSANT is applicable to a representative real-world SPARQL end-point. In terms of query performance, CROISSANT is reasonably applicable if materialization is doable, but CROISSANT requires more improvements in some cases like queries with high selectivity.
 A2: Optimizations work well, materialization is quite effective if available, selec-tion push-down and view query merge are also effective, and their combination is more. In the case where materialization is not doable, CROISSANT does not work well for high selectivity queries (like q1 ). Views on RDF have been studied in these decades [18, 19, 6]. For example, Schenk et al. [18] have proposed Networked Graphs which is a means of describing RDF graphs, it acts as views on RDF data, Shaw et al. [19] have defined a view definition language called vSPARQL , and Etcheverry et al. have surveyed views over RDF datasets [6]. RDF views have been used in various purposes: Abel et al. [1] utilize views for access control on RDF datasets, many works have attempted to improve query performances by view materialization.
 plex queries, such as aggregation queries [9, 10] and join queries [3], as well as for view selection [10, 7, 13, 14]. Hung et al. [9] have proposed views for aggregation over RDF data and how to maintain the aggregated values on the views. The basic model of them is local RDF database, and their approach is not easily ap-plicable to SPARQL endpoints on the Web. Ibragimov et al. [10] have proposed an optimization mechanism for aggregate SPARQL queries using materialized views. They assume that analytical processing over RDF data, thus they select views to be materialized based on the data cube lattice. As well, in their view selection algorithm, they select the best view in order to perform user queries, meaning that they do not taking multiple view optimization into their consider-ation. Castillo et al. [3] have discussed materialized views over RDF databases in order to process RDF data efficiently by reducing join processing. They assume local RDF database, and their work is not directly applicable to SPARQL end-points on the Web. Goasdou X  et al. [7] have proposed view selection algorithm for RDF databases based on a given set of SPARQL queries and query workloads in order to optimize the query cost, view storage, and view maintenance cost. Le et al. [13] have proposed an SPARQL query rewriting scheme over SPARQL views, which automatically choose a set of views matching with the input SPARQL queries and rewrite the queries using the view queries in order to obtain re-sults from RDF datasets under the views. Lynden et al. [14] have proposed a hybrid approach to LD query processing, which simultaneously querying over Web of LD and SPARQL endpoints to obtain fresh information. Even though they do not use views for SPARQL endpoints, their idea can be combined to the query processing mechanism which may query both materialized and virtual views simultaneously.
 For the JSON views, query processing system accepts Language-Integrated Query (or LINQ) 6 . The query processing system executes view queries on SPARQL end-points and then perform LINQ queries over the views. The previous work [12] was a prototypical framework and did not include any optimization method-ologies in order to improve query processing performance. While, this paper arranges target query language from LINQ to SQL because SQL is more popu-lar in Web application development, and proposes optimization strategies over query processing.
 of SPARQL endpoints (i.e., how frequently SPARQL endpoints are updated) are still not evident. There are few works dealing with update detection for SPARQL endpoints [15, 20]. Passant and Mendes [15] have proposed push notification mechanism on SPARQL endpoints with PubSubHubbub protocol 7 . Teymourian et al. [20] have proposed an optimization schema for subscribing DBpedia data through DBpedia live 8 . If other SPARQL endpoints are able to provide change event streams like DBpedia live, their approach may be available, however, most of SPARQL endpoints are not not available on that functionality for now. This paper proposes CROISSANT, an ostensible (relational) interface for SPARQL endpoints using views. To cope with performance issues on CROISSANT, this paper proposes three optimization techniques, namely, view materialization, se-lection push-down, and view query merge. The experiments show that the view materialization realizes the quickest processing if materialization is available. Otherwise, the selection push-down performs better as the selectivity of queries decreases, and the view query merge improves query performance when queries are complicated (joining three or more tables on the same SPARQL endpoints). Acknowledgement This research was partly supported by the program Research and Development on Real World Big Data Integration and Analysis of RIKEN, Japan.

