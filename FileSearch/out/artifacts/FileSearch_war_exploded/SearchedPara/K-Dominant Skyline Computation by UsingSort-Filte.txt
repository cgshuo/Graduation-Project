 Skyline queries have attracted considerable attention due to its importance in many applications such as multi-criteria decision making, data mining, and user preference queries [1]. Given a database X , an object p is said to be in skyline of X if there is no other object q in X such that q is better than p in all dimensions. If there exist such a q ,thenwesaythat p is dominated by q ,or q dominates p . A number of efficient algorithms for co mputing all skyline objects have been reported in the literature [1,2,3,4,5].

There are two problems in conventional skyline queries: (i) As the number of dimensions increases, the number of skyline objects increases substantially because it becomes difficult to dominate other objects. (ii) Usually, users have to select some noteworthy objects from skyline objects. Sometimes, the users may have to select many objects. Sometimes, they have to select a few objects. Conventional skyline query cannot control such selectivity.

In this paper, we consider k -dominant skyline queries [6], which are considered to overcome the above problems.
 1.1 Motivated Example Assume a person want to purchase a notebook computer and is looking for suitable one. Assume there is a database containing eight notebooks as listed in Table 1. In the table, each notebook is represented as a tuple containing sixattributes,CPU,RAM,HDD,HDDspeed,Quality,andVRAM.Without loss of generality, we assume larger value is better in each attribute and all the attributes have equal importance.
 Conventional skyline query for this database returns six notebooks: N 2 , N 3 , N 4 , N 5 , N 6 and N 7 . N 1 and N 8 are not in skyline because both are dominated by N 2 . If we look the six skyline notebooks, we can find that not all notebooks are significant in a sense. For example, N 3 is survived only by its value of  X  X DD Speed X  and N 7 is survived only for  X  X AM X  size. N 6 is skyline because no other notebook fails to dominate it in all dimensions, even though it does not have any maximal feature values. In such situation, the person naturally consider to eliminate the skyline notebooks by using stronger criterion.
 Chan et al. considered k -dominant skyline query to handle the problem [6]. They relaxed the definition of  X  X ominated X  so that an object is likely to be dominated by another. Given a database X consists of n attributes, an object p is said to be in k -dominant skyline of X if there is no object q in X such that q is better than p in k (  X  n) dimensions. If there exist such a q ,thenwesaythat p is k -dominated by q or qk -dominates p .

In the example, if we consider 5-dominant skyline instead of conventional skyline, i.e., 6-dominant skyline, N 1 , N 3 , N 5 , N 6 ,and N 8 are eliminated from 5-dominant skyline because they all are 5-dominated by N 2 . N 7 fails to become 5-dominant skyline because it is 5-dominated by N 4 .

If the person is satisfied with the selectivity of 5-dominant skyline, he/she can analyze the returned notebooks intensively. If he/she is still unsatisfied with the selectivity, he/she can compute further k -dominant skyline query with smaller k .Thus, k -dominant query solve the problems of conventional skyline query for high dimensional databases.

The contributions of this paper are as follows: 1) We have developped an efficient method for computing k -dominant skyline by using a Sort-Filtering method that sorts objects by domination power .2)Wehaveperformedintensive experiments on a variety of synthetic an d real datasets to demonstrate that the proposed method is efficient and perfor ms better than other existing methods. 2.1 Preliminaries the j -th dimension value of p i .

An object p i is said to dominate another object q j , denoted as p i  X  q j ,if p one dimension d t (1  X  t  X  n ). We call such p i a dominant object and such q j a dominated object between p i and q j . An object p i  X  X is said to be a skyline object of X if p i is not dominated by any other object in X .

An object p i is said to k -dominate another object q j , denoted as p i  X  k q j ,if p d among the k attributes. We call such p i as k -dominant object and such q j as k -dominated object between p i and q j . An object p i is said to be a k -dominant skyline object of X , if and only if there does not exist any object p j ( j = i )in X that k -dominates p i .

An object p i is said to have  X  -domination power if there are  X  attributes in which p i is better than or equal to all other objects of X . 2.2 A Priori Property A k -dominant object has the following a priori property.
 Theorem 1. Any ( k  X  1 )-dominant object must be a k -dominant object for any k such that 1 &lt;k  X  n .
 Theorem 2. Any k -dominated objects cannot be a ( k  X  1 )-dominant object for any k such that 1 &lt;k  X  n .
 Proof. Based on the definition, a ( k  X  1)-dominant object p is not ( k  X  1)-dominated by any other objects in X . It implies that p is not k -dominated by any other objects. Therefore, we can say p is k -dominant object. On the other hand, if an object q is k -dominated by another object, it must be ( k  X  1)-dominated by the object. Therefore, q cannot be a ( k  X  1)-dominant object.
 The conventional skyline is the n -dominant skyline. If we decrease k of the k -dominant skyline, more objects are eliminated. For example, N 1 and N 8 of Table 1 are not in skyline because they are dominated ( n -dominated) by N 2 . So, they can X  X  be a candidate of k -dominant skyline object for k&lt;n .Wecan prune such non-skyline objects for further procedure of the k -dominant query. If we consider 5-dominant query, N 3 , N 5 , N 6 ,and N 7 are 5-dominated objects in addition to the 6-dominated objects, N 1 and N 8 . Therefore, we can prune those objects in 5-dominant query computation. Thus, by decreasing k ,more dominated objects can be pruned away. In this section, we present an efficient method for computing k -dominant skyline objects from X . We used a Sort-Filtering method that consists of two parts: one is  X  X omination power X  calculation and sorting, and the other is k -dominant skyline objects checking. 3.1 Domination Power Calculation Objects whose sum of all their dimension values is large are likely to dominate other objects, while objects whose sum is small are likely to be dominated. Therefore, we sort the whole tuples in X in descending order of the sum of all their dimension values. This preproce ss, sorting by sum, has been proposed by Chomicki et al. [4]. By this preprocessing, we can eliminate some of non-skyline objects easily. Chan et al. used the popular preprocessing in their OSA algorithm for k -dominant query [6]. But this p reprocess is not effective for k -dominant query computation especia lly when values of each attr ibute is not normalized. For example, assume p (9,1,2) and q (3,2,3) are two objects in 3D space. Although the object p has greater sum than object q but p fails to become 2-dominant of q . Here, object p is 2-dominated by object q .

Therefore, in order to prune unnece ssary objects efficiently in the k -dominant skyline computation, we compute domination power of each object, i.e., how many maximal values it has within all of dimensions. Then, we sort objects in descending order by domination power. If more than one objects have same domination power then we sort those objects in descending order of the sum value.

Without apply any sorting Table 2 represent the domination power and sum of the each Notebook PC X  X  of Table 1. Table 3 is the example of sorted database (sort Notebook PC X  X  in descending order by corresponding domination power and for same domination power sort in descending order of the sum value) of the Notebook PC X  X  database of Table 1. In the sorted table, N 2 has the highest dominant power 4 and N 8 , N 1 and N 6 have no dominant power. Note that N 2 dominates all notebooks lie below it in four attributes, CPU, HDD, Quality, and VRAM.
 Let X be the sorted database of X . X has the following property.
 Theorem 3. Let p i be the i -th object in the ordered object sequence of X .If p i has  X  -domination power, it  X  -dominates p j for j such that j&gt;i in the sequence of X .
 Proof. An object p i with  X  -domination power is  X  -dominant object to any other object in X .Since X is sorted by domination power in descending order, an object with  X  -domination power always comes before objects whose domination power is less than  X  . Therefore, from the definition we can say p i is a  X  -dominant foranyotherobject p j since j&gt;i .
 By using this property, an object with k -domination power k -dominates all other following less domination power objects. Moreover, when more than one object has same domination power then our proposed method sort those objects in de-scending order of the sum values. Therefore higher objects in the sorted sequence are likely to dominate other objects. Th is sort filtering preprocessing helps to reduce the computational cost of k -dominant skyline.

The sorted sequence roughly reflects the importance of objects and our method can progressively output the k -dominant objects bas ed on the sequence. It helps users X  to make their decision more practical. 3.2 k-Dominant Checking By using X , we progressively output k -dominant skyline objects as follows. We scan X to compare each object p  X  X against the first object q .Inthescan procedure, objects that are k -dominated by the first o bject are removed from X . During the procedure, if the first object q is k -dominated by any other objects p  X  X ,weremove q from X and stop the scanning procedure. If q is not removed in the scanning procedure, then output q as a k -dominant object and remove q from X . We repeat this scanning procedure until X becomes empty.
Applying the k -dominant check with k = 5 for Table 3, we note that in the first scan N 5 , N 3 , N 8 , N 1 and N 6 are 5-dominated by the first object, N 2 . Therefore, those dominated objects are removed from X . On the other hand, N 2 is not 5-dominated by any other notebooks. So, after the first scan, our method outputs N 2 as a 5-dominant skyline object and then remove N 2 from X .Inthe second scan, N 4 becomes the first object and it 5-dominates N 7 .So,weremove N 7 and outputs N 4 as a 5-dominant skyline object. Similarly, if we apply k =4 for the same database X , then our Sort-Filtering method returns only N 2 as a 4-dominant skyline object. Chan et al. introduce k -dominant skyline query [6]. They proposed three algo-rithms to compute the k -dominant skyline query. The first algorithm, One-Scan Algorithm (OSA), uses the property that a k -dominant skyline objects cannot be worse than any skyline on more than k dimensions. This algorithm maintains the skyline objects in a buffer during a scan of the dataset and uses them to prune away objects that are k -dominated. As the whole set of skyline objects can be large, the authors proposed the Two-Scan Algorithm (TSA). In the first scan, a candidate set of dominant skyline o bjects is retrieved by comparing every object with a set of candidates. The second scan verifies whether these objects are truly dominant skyline objects. This method turns out to be much more efficient than the one-scan method. A theo retical analysis is provided to show the reason for its superiority. The third algorithm, Sorted Retrieval Algorithm (SRA), is motivated by the rank aggregation algorithm proposed by Fagin et al., which pre-sorts data objects separately according to each dimension and then merges these ranked lists [7].

As the authors mentioned in the OSA, skyline objects need to be maintained to compute the k -dominant skyline objects. Since the set of skyline objects could be much larger than the set of k -dominant skyline objects, maintaining skyline can incur large space and computation overhead.

Compared with their works, the proposed method can find k -dominant skyline objects without maintaining skyline. Therefore, there is no possibility for space and computational overhead. In addition, TSA algorithm scans whole data twice. In first scan, it generates candidate set o f dominant skyline objects by comparing every object with a set of candidates a nd in second scan it verifies whether these objects are truly dominant skylin e objects, while the proposed method can compute dominant skyline directly and does not suffer for false positive elimination procedure. As for SRA, the performance is un certain because it depends crucially on the choice of proper dimension. Section 5 demonstrates that the performance of our algorithm is better than all of the three algorithms proposed in [6].

Algorithm called CoSMuQ also computes k -dominant skyline [8]. It divides the space in pairs of attributes and maintains a grid for each pair of dimensions. Each grid maintains its skyline tuples. Finally, the k -dominant skyline is obtained by the union of the skylines of these grids. T his method has two severe problems, in high dimensional case. It needs to maintain huge number of grids. For example, if dimension size is equal to 15, then this algorithm needs to maintain 105 grids. In addition to the space complexity problem, CoSMuQ always needs to maintained 2-dominant skyline to compute k-dominant skyline. Compared with theirs, the proposed method does not suffer from such kinds grid as well as 2-dominant skyline maintaining problems. We have conducted a series of experiments to evaluate the performance of our Sort-Filtering method. We also compare the performance with all the algorithms proposed by Chan et al. which are One-Scan Algorithm (OSA), Two-Scan Algo-rithm (TSA) and Sorted Retrieval Algorithm (SRA) [6]. To make the comparison fair, we have include all the preprocessing cost, i.e., cost of domination power computation and sorting. 5.1 DataSets We use both synthetic datasets and real d atasets in the experiments. The gen-eration of the synthetic datasets is controlled by three parameters, dimension number n ,datasize Size and distribution Dist . There are three optional distri-butions in the synthetic data sets: Correlated, Independent and Anti-Correlated. Table 4 shows the number of the k -dominant skyline objects on 15-dimensional data set with 100k objects on different distributions and different constraint parameter k .

When k is close to the dimension size, the number of k -dominant skyline objects in the anti-correlated dataset becomes much larger than that of the independent and correlated datasets. However, when k is small, the correlated dataset can still have some dominant skyline objects, while no dominant skyline objects can be found on the other two distributions.

We also examine the performance for a real dataset. We used the NBA statis-tics. This dataset contains 17000 players season records on 17 attributes from the first season of NBA in 1945. Every records contain the statistical value of a player X  X  performance in one season, such as game played(GP), field goal made(FGM), total assists(AST) and so on. One player may have several records if he played in NBA for more than one season. 5.2 Performance We evaluated the computational cost of our Sort-Filtering method and compared the result with all three algorithms proposed by Chan et al. with similar param-eter setting. The proposed method is implemented in Java. All experiments were conducted on a PC with an Intel Pentium 3GHz CPU and 2G main memory, which is running on Microsoft Windows XP operating systems. Figure 1, 2, and 3arethetimetocompute k -dominant skyline for synthetic datasets.

Figure 1 examines the effect of the k value. We observe that our method is more efficient than other three met hods on all distributions when k varies from 8 to 14. Because, maintaining the set of skyline objects for OSA incurs large space and computation overhead. To compute k -dominant skyline, TSA suffered for false candidates elimination. Again, the performance of SRA is not better than Sort-Filtering because this approach crucially depends on the choice of proper dimension.
 Figure 2 examines the effect of the dimension value. When k is small, TSA, RSA and Sort-Filtering are much faster than OSA on all three distributions. With increasing dimensionality TSA is several times slower than the other three algorithms. As shown in the figure, our Sort-Filtering is more scalable on high dimensional data sets.

In order to evaluate the effect of cardinality on the performance of the four algorithms, we use datasets with cardinality 50k, 100k, 150k and 200k. In this experiment, we fixed the size of n to 15 and k to 11. Figure 3 shows that when the size of the data set increases from 50k to 200k, the computation time of the four algorithms maintain a positive correlation. Notice that our Sort-Filtering performs best while OSA is the most worst.

In Figure 4, we show the experimenta l result on the NBA data set. When varying the constraint parameter k , TSA and our Sort-Filtering are the efficient algorithm when k&lt; 14, but RSA is worst among the four algorithms when k&gt; 15. Sort-Filtering and SRA are faster than other two when k is large. We consider k -dominant skyline query problem and present a Sort-Filtering method. We demonstrate that our method is easy to compute and can be used for high dimensional large datasets. Performance evaluations show the superiority of the proposed method against the OSA, TSA and SRA algorithms. k -Dominant skyline reduces the number o f interesting objects returned by skyline. But sometimes the number of k -dominant skyline objects can still be large when k is not sufficiently small. If k is too small, no (or few) k -dominant skyline objects are returned. Though o ur efficient computation allows us to com-pute k -dominant objects for various k , proper guide for choosing the right value of k is an open problem.
 This work was supported by KAKENHI (19500123) and Md. Anisuzzaman Sid-dique was supported by the scholarship of MEXT Japan.

