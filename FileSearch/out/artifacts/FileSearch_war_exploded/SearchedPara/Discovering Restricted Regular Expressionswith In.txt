 When XML is used for data-centric applications such as integration, there may be no order constraint among siblings [1]. Meanwhile, the relative order within siblings may be still important. For example, consider a ticket system with two ticket machines, where there are two bunches of tourists lining up waiting to buy tickets. Each group has two tourists. We can then define the unordered schema for the ticket system. The ordered gro ups preserve only the relative order of their members. This not only allows individual tourists to insert themselves within a group, but also lets two groups interleave their members. The exact XML Schema Definition (XSD) for the purchasing sequence can be essentially member in the i th group can buy zero or more tickets. The representation is minimal by Definition 2. It shows the length of the exact regular expression can be exponential when compared to the number of members in sequences.
 minimal ones, which may permit invalid XML documents (i.e., over-permissive). For example, it may permit the second member in the sequence of the first group to purchase tickets before the first member. There are many negative consequences of over-permissive [3]. Thus it is necessary to study how to infer an unordered minimal schema for this kind of XML documents.

Previous researches on XML Schema inf erence have been done mainly in the context of ordered XML, which can be re duced to learn regular expressions. Gold [9] showed the class of regular expressions is not identifiable in the limit. Therefore numerous papers ( e.g.[2,5,6,12]) studied inference algorithms of re-stricted classes of regular expressions. Most of them were based on properties of automata. Bex et al. [2] proposed learning algorithms for single occurrence regular expressions (SOREs) and chain regular expressions (CHAREs). Frey-denberger and K  X  otzing [12] gave more efficient a lgorithms learning a minimal generalization for the above classes. The approach is based on descriptive gen-eralization [12] which is a natural extension of Gold-style learning.
However, there is no such kind of automata for regular expressions with inter-leaving since they do not preserve the total order among symbols. Thus we have to explore new techniques. While Ciucanu [13] proposed learning algorithms for two unordered schema formalisms: disjunctive multiplicity schemas (DMS) and its restriction, disjunction-free multip licity schemas (MS), both of them disallow concatenation within siblings. Thus they are less expressive than ours. Moreover, the ordering information in our schema formalism can not be fully captured by the three characterizing triples used to construct a DMS or MS.

Inference algorithms in this paper use some similar techniques with algorithms mining global partial orders from sequence data [14,15,17]. However, the seman-tic concepts there are typically quite d ifferent from ours. Mannila et al. [15] tried to find mixture models of parallel partial orders. However, to learn un-ordered regular expressions, series pa rallel orders may not be sufficient since they can conflict with some data in the whole data set. Another restriction in the above method is that it can only be applied to strings where each symbol occurs at most once. Particularly, Gio nis et al. [14] emphasised on recovering the underlying ordering of the attributes in high-dimensional collections of 0-1 data. An implicit assumption is that attribute can also occur at most once. For learning regular expressions with interleaving, symbols in strings can present any times and partial orders among siblings are independent with no violations. Hence many techniques from data mining are not directly applicable. Therefore, learning restricted regular expressions with interleaving remains a challenging problem.

In this paper, we address the problem of discovering a minimal regular ex-pression with interleaving from positive examples. The main contributions of the paper are listed as follows: -We propose a better and more suitable formalism to specify precise unordered
XML: the subset of regular expressions with interleaving (SIREs). SIREs can express the content models succinctly a nd concisely. For example, the above example can be depicted as ( g 1 .m 1  X  g 1 .m 2  X  )&amp;( g 2 .m 1  X  g 2 .m 2  X  ). -We introduce the notion of SIRE-minimal in the terminology of [12] and some properties of SIRE-minimal. -We prove the problem of finding a minimal SIRE is NP-hard and develop an approximation algorithm conMiner to find solutions with worst-case quality guarantees and a heuristic algorithm conDAG that mostly finds solutions of better quality as compared to the approximation algorithm conMiner. -We conduct experiments comparing our methods with Trang [8] on real world data, incorporating small and large data sets. Our experiments show that conMiner and conDAG outperform existing systems on such data.
 The rest of the paper is organized as follo ws. Section 2 contains basic definitions. In Section 3 we discuss properties of minimal-SIRE. In Section 4 an approx-imation algorithm conMiner and a heuristic algorithm conDAG are proposed. Section 5 gives the empirical results . Conclusions are drawn in Section 6. Let u and v be two arbitrary strings. By u &amp; v we denote the set of strings that is obtained by interleaving of u and v in every possible way. That is, u &amp;  X  = can be then extended to regular languages as a binary operator in the canonical way. Let  X  be an alphabet of symbols. The regular expressions with interleaving or E 1 &amp; E 2 is a regular expression for regular expressions E 1 and E 2 .Theyare denoted as RE(&amp;). The language described by E is defined as follows: L (  X  )=  X  ; of E + and EE  X  , respectively. We consider th e subset of regular expressions with interleaving (SIREs) defined by the following grammar.
 Definition 1. The restricted class of regular expressions with interleaving (RREs) are RE (&amp;) over  X  by the following grammar for any a  X   X  : The subset of regular expressions with interleaving (SIREs) are those RREs in which every symbol can occur at most on ce. Since SIREs disallow repetitions of symbols, they are certainly deterministic and satisfy the UPA constraint required by the XML specification.

A partial order M for a string s is a binary relation that is reflexive, an-tisymmetric and transitive. We write a  X  b if a is before b in the partial or-der. For string s = x 1  X  X  X  x l ,the transitive closure of s is denoted by tr ( s )= { ( x i ,x j ) | 1  X  i&lt;j  X  l } ,where l is the length of s . For example s = abcd , tr ( s )= { ab,ac,ad,bc,bd,cd } .

A partial-order set t is a set of symbols together with a partial ordering. We say ab  X  t if a precedes b in every string in a string collection. Consistent partial order set (CPOS) T is a set which contains all the disjoint partial-order sets t of the given examples. For example, consider W = { abcd, dabc } . Obviously, a  X  b  X  c , T = { abc, d } . The connection between CPOS and SIRE is directly. That is, given a CPOS, we can write it to the form of SIRE by combining all the elements in CPOS with &amp;. For example, in this case the corresponding SIRE s = abc &amp; d . Therefore, the problem of finding a minimal SIRE can be reduced to the problem of finding a minimal CPOS. This section introduces the notion of minimal expressions. Roughly speaking minimal is the greatest lower bound of a language L within a class of expressions, which is conceptually similar with infimum in the terminology of mathematics. Definition 2 ([12]). Let D be a class of regular expressions over some alphabet  X  .A  X   X  X  is called D -minimal of non-empty language S  X   X   X  ,if L (  X  )  X  S and there is no  X   X  X  such that L (  X  )  X  L (  X  )  X  S .
 Proposition 1. Let n be the number of alphabet symbols. The number of pair-Proof. Disregarding operators ?,+,*, the number of SIREs over a finite  X  is equivalent to the number of ordered partitioning |  X  | symbols. The number of these partitions is given by the |  X  | th ordered Bell numbers [11]. For instance, if  X  = { a, b, c } , the 3th ordered Bell number a (3) = 13, and the ordered partitions symbol a in  X  has four forms which can be represented as a, a ? ,a + and a  X  ,the We can then prove the existence of mini mal regular expressions for SIRE. Proposition 2. Let  X  be a finite alphabet. For every language L  X   X   X  ,there exists a SIRE-minimal SIRE  X  s .
 Proof. Assume there is a language L over  X  such that no expression  X   X  SIRE is SIRE-minimal. This implies that there is an infinite sequence (  X  i ) i  X  0 of ex-pressions from SIRE with  X  =  X  0 and L (  X  i )  X  L (  X  i +1 )  X  L for all i  X  0. This contradicts the fact that there are only a finite number of non-equivalent SIREs over  X  by Proposition 1. &amp; s l be a SIRE such that E  X  L ( S ) . S is a minimal SIRE if and only if: (1) the number of s i is minimized and (2) the size of each s i is as large as possible.
 The proof was omitted for space reasons.

In other words, a minimal SIRE is the most specific SIRE that consistent with S 3 = ad &amp; bc can accept E = is not minimal. As for S 2 and S 3 ,since L ( S 2 )= { abcd, abdc, adbc, dabc } and L ( S 3 )= { bcad, bacd, badc, abcd, abdc, adbc } , this means S 3 is not minimal. As we shall see, S 2 is a better approximation of E .Infact, S 2 can be verified to be a minimal by referring to Proposition 3. In this section, we first prove finding a minimal SIRE for a given set of strings is NP-hard by reducing from finding a maximum independent set of a graph, which is a well-known NP-hard graph pro blem [7]. Then we present learning algorithms that construct approximatively minimal SIREs. 4.1 Exact Identification First, we introduce the notion of maximum independent set of a graph [7]. Consider an undirected graph G ( V,E ), an independent set (IS) is a set that  X  u, v  X  IS, u,v  X  Vand ( u, v ) /  X  E . The maximum independent set (MIS) problem consists in computing an IS of the largest size. Next, we define the problem all_mis which takes a graph G as input, finding a MIS S of G by applying function max_independent_set , and repeating the step for subgraph G [ V  X  S ] until there exists no vertex in the subgraph. In other words, all_mis is to divide V into disjoint subsets by max_independent_set . Clearly, problem all_mis is NP-hard. For example, consider G ( V,E )which V = { 1 , 2 , 3 , 4 } ,E = { (1 , 2) , (1 , 3) , (2 , 3) , (2 , 4) , (3 , 4) } .Theresultof max_independent_set(G) is { 1 , 4 } .Theresultof max_independent_set(G[V-{1,4}]) is { 2 } .Thustheresult of all_mis(G) is {{ 1 , 4 } , { 2 } , { 3 }} .

The main idea of finding a minimal SIRE is based on the observation that there are sets of conflicting siblings that cannot be divided into the same subset of CPOS. A pair xy is called forbid pair in a string database if both xy and yx exists in the transitive closure of strings. The set of forbid pairs is called a constraint . By Proposition 3, if we split the set of symbols in a constraint into several subsets t 1 ,  X  X  X  ,t n such that n is minimized and for each i  X  [1 ..n ], t i is the longest of its alternatives. Then the set of t i where i  X  [1 ..n ], is a minimal CPOS which can be transformed to a minimal SIRE.
 Lemma 1. Minimal SIRE finding problem is NP-hard.
 Proof. We demonstrate that all_mis can be reduced in polynomial time to minimal SIRE finding problem. Given an instance of all_mis , we can generate a corresponding instance of minimal SIRE finding as follows. For the graph G in all_mis , the reduction algorithm computes the constraint set by adding all edges in G to constraint , which is easily obtained in polynomial time. The output of the reduction algorithm is the instance set constraint of minimal SIRE finding problem. t i in CPOS is the longest of its alternatives if and only if all_mis computes a maximum independent set at the i th step. Thus, minimal SIRE finding problem is equivalent to the original all_mis .Since all_mis is NP-hard, minimal SIRE finding problem is NP-hard. 4.2 Approximation Algorithm The process of this approach is formalized in Algorithm 1. Algorithm 1 works in four steps and we illustrate them on the sample E = { abcd, aadbc, bdd } . The first step (lines 1-2) computes the non-constraint and constraint set using the func-tion tran_reduction . The transitive closure of E is tr = { ab,ac,ad,bc,bd,cd,db, dc } .Add uv to constraint if vu  X  tr .Add uv to consist tr otherwise. We get consist tr = { ab, ac, ad, bc } and constraint = { bd, cd, db, dc } . Construct an undi-rected graph G using element in constraint as edges. The second step (lines 3-7) is to select a MIS of G , add it to list allmis and delete the MIS and their re-lated edges from G . The process is repeated until there exists no nodes in G . The problem of finding a maximum independent set is an NP-hard optimization problem. As such, it is unlikely that there exists an efficient algorithm for finding a maximum independent set of a graph. However, we can find a MIS in polyno-mial time with a approximation algorithm, e.g. the clique_removal algorithm proposed in [19] that finds the approximation of maximum independent set with performance guarantee O ( n/ (log n ) 2 ) by excluding subgraphs. For graph G ,we obtain allmis = {{ b, c } ,d } . Next, we add the non-constraint symbols to the first MIS. Then we have allmis = {{ a, b, c } ,d } . The third step (lines 8-10) computes the topological sort for all subgraphs induced by subset of consist tr and add the result to T . For the sample, it returns T = { abc, d } . Finally, the algorithm re-turns the SIRE whose corresponding counting operators 1 ,  X  , + , ? can be inferred using technique in algorithm CRX [4]. For the sample, it returns a  X  bc ?&amp; d + .
When carefully implemented, clique removal involves ( | V | + | E | ) work [19], where | E | is O ( | V | 2 ). The total running time of conMiner is ( n 3 + m ), where m is the sum of length of the input example strings, n the number of alphabet symbols. 4.3 Heuristic Algorithm Although a number of approximation algorithms and heuristic algorithms have been developed for the maximum independent set problem, on any given in-stance, they may produce a SIRE that is very far from optimal. We introduce a heuristic directed acyclic graph construction algorithm directly computing a min-imal SIRE. The main idea is to cluster the vertices of the existing directed graph Algorithm 1. conMiner ( W ) into several disconnected subgraphs. The graph is construct ed incrementally to preserve CPOS within each vertex using a greedy approach. The pseudocode of algorithm conDAG is given in Algorithm 2.

The input to this algorithm is the same as the input of the conMiner .The algorithm maintains lists p, q as records to keep track of pairs violating the partial order constraint and lists s, t to record pairs violating the partial order constraint of the string under reading. Note that ( a, b ) violating the partial order constraint means there exist some w 1 ,w 2  X  W such that a  X  b in w 1 and b  X  a in w 2 .

Let ab be two adjacent symbols in a word w .The add_or_break function checks whether edge ab is added to the present graph G. If there exists no path from b to a ,nopathfrom a to b in G and edge ab will not make a connection between some p [ i ]and q [ i ], we add edge a  X  b in G. Self-loops such as f  X  f are always ignored since they have no influence on the partial order constraints. paths from b to a . The breakpoint can be found as below. Suppose there exists then we delete edge  X  i  X  1  X   X  i ,addedge  X   X   X  i for all nodes  X  that  X   X  b , and add edge  X  i  X  1  X   X  for all nodes  X  that a  X   X  . In the end, append string b X  and q,t are  X  i ...a .
Example in Figure 1 shows how the function works. W = {  X abcd X , cda } , still empty. When reading da  X  w 2 , there already exists a path abcd and ( d, a ) /  X  cda , breakpoint is c . Then we delete edge b  X  c , and add edges  X   X  c , b  X   X  .In the end, append string ab to list p , s andappendstring cd to list q , t .
The consistent function scans the whole string w by sequence to exe-cute add_or_break function. Each time after reading two adjacent symbols ab , (  X  1 a X  2 , X  3 c )or(  X  3 c,  X  1 a X  2 ) w , c  X  b is also in w .Consider acab as an example, c and a have been two parts after reading ca , a has been added to p and s and c added to q and t .Afterread-ing the next two symbols ab ,addedge a  X  b . Next we should consider cb since a  X  s [0] ,c  X  t [0], thus add edge c  X  b .The topological_sort(g) construct a topological ordering of DAG in linear time. The learner_oper is used to infer operators ? , + ,  X  for each vertex.

The conDAG algorithm combines all the functions. The constructed graph is denoted by G and the corresponding set of partitions by C . In each iteration, it invokes consistent to update G using the i th string. Then it adds all the paths from the set of vertices of in-deg ree zero to the set of vertices of out-degree zero. To be able to calculate the largest independent partial-order plans, a preprocessing phase is implemented. First, we consider the elements of C in decreasing order of size. In each iteration, whenev er we find two elements that the one contains elements of p [ i ] and the other one contains elements of q [ i ], we updates the shorter one by removing the common elements. Next, we merge all the lists in C that share common elements. The preprocess terminates when every symbol is included in one and only one list. The following steps of the algorithm are the same as the third and the forth step of the conMiner .
The time complexity analysis of this algorithm is straightforward. add or brea k ( G, w, a, b, p, q, s, t ) can find all possible paths between two given nodes by mod-Therefore, an overall time complexity for add or break is O ( | V | + | E | ). The length of w can at most be n and | E | is O ( | V | 2 ). So the total time of consisitent is O ( n 3 ). Algorithm 2. conDAG ( W )
The tran reduction computation requires O ( n 2 ) time, where n is the number of distinct symbols. Each iteration requires O ( n 3 ) time to maintain the graph. Computing all paths from source to destination can be done in O ( n 2 ) time, and topological sort ( g ) constructs a topological ordering of DAG in linear time, thus O ( Hence the time complexity of the algorithm is O ( n 4 + m ), where m is the sum of length of the input example strings, n the number of alphabet symbols.
To illustrate our algorithm, consider the example E = { abcd, aadbc, bdd } , consist tr = { ab, ac, ad, bc } , constraint = { bd, cd, db, dc } in the above section. A directed graph which consists of vertex V = { a, b, c, d } and edges E = { ab, bc, ad } can be obtained. p = { bc } and q = { d } . All paths from source to destination are C = { abc, ad } .Since bd  X  constraint , C [2] is updated by removing the common elements between C [1] and C [2]. C [2] is d . The final C is { abc, d } . The following steps are the same. In this section, we validate our approaches on real-life DTDs, and compare them with that of Trang [8]. All experiments were conducted on an IBM T400 laptop computer with a Intel Core 2 Duo CPU(2.4GHz) and 2G memory. All codes were written in python.

The number of corpora of XML documents with an interesting schema is rather limited. We obtained our real-life DTDs from the XML DATA repos-itory maintained by Miklau [18]. Unfortunately, most of them are either not data-centric or not with a DTD. Specifically, We chose the DBLP Computer Science Bibliography corpus, a data-centric database of information on major computer science journals and proceedin gs. The code and data are available at http://lcs.ios.ac.cn/ ~ pengff/projects.html . Table 1 lists the non-trivial element definitions in the above mentioned DTD together with the results de-rived by exact algorithm, heuristic algorithm conMiner, approximation algorithm conDAG, and Trang. We implement the exact algorithm by replacing function clique_removal in conMiner with an exponential time algorithm proposed by S. Tsukiyama [20]. It can be verified th at all expressions learned by exact al-gorithm, conDAG and conMiner are more strict than that of Trang and the original DTDs which indicates there exists much more over-permissive in both the original DTDs and the results of Trang. Moreover, although the results of conMiner and conDAG are not the ideal optimum, they are very close to that of exact algorithm thus are nearly as good.
 There may exist many minimal expressi ons given a set of unordered strings. For instance, for phdthesis , the form of the result of conDAG is the same with the exact minimal expression. The orders among symbols of their first siblings, however, differ widely. This is due to the fact that a diagraph may have several different topological sorts. Therefore, we ignore the sequel in the symbols and only compare their simplified form which concerns only the length of each sibling and the number of interleavings. For example, the We measure the similarity by formula sim ( vec ( t e ) ,vec ( t c )) = vector of the result of exact algorithm, vec ( t c ) the vector of the result of conDAG or conMiner, sim c is the cosine similarity between two vector and num the number of interleavings. For the similarity between exact algorithm and con-we can get sim ( vec ( t e ) ,vec ( t c )) = (33 / ( 2 shows clearly that conDAG yields concise super-approximations to the exact minimal expressions thus can find solutions of better quality as compared to the solutions found by the approximation algorithm. This paper proposes a strategy for learn ing a class of regular expressions with interleaving: first, compute consistent partial order T , then equip each factor with counting operators. As future work, we will investigate several interesting problems inspired by this study. First, we would like to extend our algorithms for more expressive schemas, for example schemas allow disjunction  X  |  X  within siblings. Second, how to extend algorithms to mine all the independent frequent closed partial orders [17] i s also an attractive topic.
 Acknowledgement. We thank the users of Stack Overflow [21], for reminding us the maximum independent set problem.

