 A data stream is an ordered sequence of items that arrive in timely manner. Motivation applications include financial applications, stock tickers, sensor net-works and telecom call records, etc. The volume of a stream is unbounded and the rate of a stream is rapid. Lots of applications prefer to sliding window model where only a collection of latest N elements are considered. Distributed pro-cessing is another key topic in stream applications. In distributed environments, each stream is observed and summarized by its party and the resulting synopses are then collected at a central site, where queries over the entire collection of streams can be processed [8].
 cardinalities of set expressions over multiple streams. Assume three streams of IP addresses ( A, B, C ) are seen at routers R 1 , R 2 and R 3 . A network manager may want to know the number of distinct IP addresses rising at either R 1 or R 2 but not R 3 . It is equally estimating the number of distinct elements for ( A  X  B  X  C ). In [7], Ganguly et al. devised an algorithm to estimate the cardinalities of set expressions. Unfortunately, their method is lack of ability to handle sliding window situations.
 ity of set expressions over sliding windows. Based on a hash based synopsis data structure, termed improved 2-level hash sketch , our algorithm can provide low-error, high-confidence estimates with small memory space. We will firstly de-scribe improved 2-level hash sketch in Section 2, followed which, a novel solution is presented in Section 3.
 Problem Definition Let { X  X  X  , a t  X  2 , a t  X  1 , a t ,  X  X  X } be a stream of data elements, where a t represents the data element observed at time t , a t  X  [1 ..u ]. In sliding window model, at any and B N denote two itemsets, each containing N latest elements in streams A and B . Three set operators are defined as follows. (1) ( Union ) Operator A  X  B returns an itemset containing all items in A N and B N . The frequency of each item is the sum of each item in A N and B N respectively. (2) ( Difference ) Operator A  X  B returns an itemset containing all items in A N but not in B N . The frequency of an item is equal to the frequency of the item in A N . (3) ( Intersect ) Operator A  X  B returns an itemset containing all items in A N and B N at the same time. The frequency of an item is the sum of the frequency of the item in A N and B N . S ,  X  X  X  ,S k are k input streams and op i is a set operator defined above. The goal of the query is to estimate the cardinality of an itemset generated by expression E and a predefined window size N .
 Related Work Recently, many researches have focused on processing data streams[2]. Several literatures are done for sliding window model[5][11]. Estimating the cardinality of a stream is a basic problem, which has been widely studied including the algorithm by Flajolet and Martin [6] and its variant[1].
 In [8], Gibbons .et al considered the problem on the union of streams, followed which, in [9], Gibbons extended their work to meet sliding windows. The method of Minwise Independent Permutations (MIP)[3][10] can estimate the result car-dinality of set operators. Ganguly et al.[7] proposed another solution, which can query set-expressions over update streams. Their recent work[4] focuses on esti-mating cardinality of set expressions in distributed applications with a goal to minimize transmission costs. Notice that neither of above work [3][4][7][10] has considered the sliding window model. An improved 2-level hash sketch , as shown in Fig. 1, is in fact an improvement upon 2-level hash sketch (please refer to [7] for detailed information) in two aspects. Firstly, it contains a time level , which does not appear in 2-level hash sketch . Secondly, each counter in second-level only occupies 1 bit, not log N bits. Three kinds of hash functions are applied in an improved 2-level hash sketch including one first-level hash function h ( h :[ M ]  X  [ M k ]), s second-level hash functions, g 1 ,  X  X  X  ,g s ( g :[ M ]  X  [2]) and one LSB operator ( LSB :[ M ]  X  [log M ] and Pr [ LSB ( j )= l ]= 1 2 l +1 ).
 counters in the first-and second-levels of sketch X . Additionally, X.time [ i 1 ] .P rev and X.time [ i 1 ] .Latest are used to represent counters in time level . Field Latest represents the time when the latest tuple is mapped to the bucket. Field Prev represents the time for the latest different tuple. Algorithm Maintain ( X, e, t )(Fig. 2) demonstrates the way to process an element e arriving at time t . Detailed de-scriptions are omitted due to lack of enough space.
 version of a 2-level hash sketch , it also owns six elementary properties of the latter. We list them here. Assume X A , X B are sketches for streams A and B . (1) SingletonBucket ( X A ,i,t,N ) checks if only one item in the window mapped to the i th first-level bucket of X A ; (2) EmptyBucket ( X A ,i,t,N ) checks if no element in the window mapped to the i th first-level bucket of X A . (3) IdenticalSingletonBucket ( X A , X B ,i,t,N ) checks if one identical element is mapped to the i th first-level bucket of X A and X B at the same time; (4) SingletonUnionBucket ( X A , X B ,i,t,N ) checks if there is only one element in A  X  B mapped to the i th first level bucket of X A and X B ; (5) AtomicDifference ( X A ,X B ,i,t,N ) checks whether there is one element in A  X  B mapped to the i th first-level bucket of X A and X B . It is worth noting that AtomicDifference returns 1 when (( not EmptyBucket ( X A ,i,t,N )) and EmptyBucket ( X B ,i,t,N )) is equal to true . (6) AtomicIntersection ( X A , X B ,i,t,N ) checks whether there is one element in A  X  B mapped to the i th first-level bucket. It returns 1 when (( not EmptyBucket ( X A ,i,t,N )) and not EmptyBucket ( X B ,i,t,N )) = true . In this section, we will introduce our solutions. Firstly, three algorithms, termed WinUnion , WinDiff and WinIntersect , are presented to estimate the cardinality of three basic set operators, such as union , difference and intersection . We then claim that our algorithms can be extended to cope with a general set expression. synopses built over streams A and B , denoted as { X i A } , { X i B } . Notice that X
A and X Algorithm 1 WinUnion( { X i A } , { X i B } ,t,N) Algorithm 2 WinDiff( { X i A } , { X i B } ,u, ,t,N) estimate the cardinality of A  X  B . Algorithm WinDiff can estimate the cardi-nality of A  X  B by following steps. Firstly, an estimate for | A  X  B | is calculated through WinUnion as input variable u . Then, calculate | A  X  B | / | A  X  B | to es-timate | A  X  B | . Notice that is an error parameter for Algorithm WinDiff ; Algorithm WinIntersect can estimate the cardinality of A  X  B . we omit the algorithm description because it is similar to WinDiff except that at Line 3, AtomicDifference is replaced by AtomicIntersection .
 Analysis. In [7], by using 2-level hash sketch , Ganguly et al. have given out three algorithms, SetUnionEstimator, SetDifferenceEstimator and SetIntersec-tionEstimator, to estimate three set operators, including union , difference and intersection . Our new algorithms are similar to them except that the basic data structure changes to be improved 2-level hash sketch . Remember that improved 2-level hash sketch is in fact an extension of 2-level hash sketch , our three algo-rithms can become an ( ,  X  )-algorithms when given same number of first-and second-level buckets. And, For the reason that a second-level counter only oc-cupies 1 bits in an improved 2-level hash sketch , the space requirement of our algorithms are reported in Theorem 1. Theorem 1. Algorithms WinUnion , WinDiff and WinIntersect can return an ( ,  X  ) -estimate for the cardinality of set union A  X  B , set difference A  X  B and set intersection A  X  B over sliding windows by using improved 2-level hash sketch respectively.
 Extended to General Set Expression. Algorithms WinUnion , WinDiff and WinIntersect are devised to estimate the cardinality of single set operator, including union , difference , and intersection over sliding windows. These algo-rithms can be extended to estimate the cardinality of a general set-expression by using WinUnion with the if -condition at Line 5 changed to: not EmptyBucket ( X A 1 , j,t,N ) or  X  X  X  or not EmptyBucket ( X A n ,j,t,N ). Secondly, estimate |
E | / | X  i A i | in a way similar to WinDiff . Remember that WinDiff identifies a wit-ness of A  X  B by AtomicDifference . we can also identify a witness of E by check-ing a condition integrated with AtomicDifference , AtomicIntersection and WinUnion . For example, assume E =(( A  X  B )  X  C )  X  D . A witness is found iff ex-pression (((( not EmptyBucket ( X A ,i,t,N )) and EmptyBucket ( X B ,i,t,N )) and ( not EmptyBucket ( X C ,i,t,N ))) or ( not EmptyBucket ( X D ,i,t,N ))) returns true. We report experimental results here. All codes were written in C and imple-mented at a 2.8GHz PC with 1G memory. Our experiments are done upon a synthetic dataset following zipfian distribution with z =0 . 8. The dataset con-tains 1,000,000 elements each in a range of [1 ,  X  X  X  , 2 20 ]. The first half and the rest are simulated as stream A and B respectively. The size of sliding window N is set to 50,000 elements. Fig. 3 shows the true values of | A  X  B | , | A  X  B | , | B  X  A | and | A  X  B | at time points N ,2 N ,  X  X  X  ,10 N . We can observe that | A  X  B | is far smaller than | A  X  B | and | B  X  A | .
 the estimate can be defined as the ratio |  X  e  X  X  E || / | E | . According to Theorem 1, the error is greatly influenced by the number of improved 2-level hash sketch synopses. Fig. 4 and 5 demonstrate the error change with 500 and 1000 improved 2-level hash sketch synopses respectively. Although both settings are far smaller than the theoretic boundaries, the errors of all set operators are below 25%. The errors are greatly reduced when the number of synopses is doubled. The estimate for | A  X  B | owns smallest error, while the estimate for | A  X  B | owns largest error. It is because that | A  X  B | &lt; | A  X  B | . Estimating the cardinality of set expressions defined over multiple streams is perhaps one of the most fundamental problems over data stream. Earlier work focused solely on the unbounded model(all tuples in a stream are considered). Sliding window model is very important when only latest N tuples of a stream are considered. In this paper, we have restudied previous work and devise a probabilistic space-efficient algorithmic solution to estimate the cardinality of set expressions over sliding windows. Our experimental results evaluate the cor-rectness of algorithms.

