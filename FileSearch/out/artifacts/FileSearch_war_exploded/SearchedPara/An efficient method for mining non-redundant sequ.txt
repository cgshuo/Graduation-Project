 culties in the mining of sequential patterns by reducing the number of fi x-tree. In the pre fi x-tree building process, each node on the pre 1. Introduction
Mining sequential patterns from a sequence database ( Agrawal and Srikant, 1995; Ayres et al., 2002; Gouda et al., 2010; Pei et al., 2004; Srikant and Agrawal, 1996; Zaki, 2000 ) may generate many sequential patterns especially when the support thresholds are low. These patterns may be irrelevant and a sequence of events that appear frequently in a database is thus insuf fi cient for predicting events. Therefore, the sequential rule mining problem was proposed ( Fournier-viger et al., 2011, 2012a, 2012b; Harms and Deogun, 2004; Lo et al., 2009; Spiliopoulou, 1999; Van et al., 2011; Zang et al., 2010 ) and sequential rules are used to allow better prediction. Sequential rules express the relationships between sequential patterns from a sequence database ( Spiliopoulou, 1999; Lo et al., 2009; Van et al., 2011 ) and can be considered as a natural extension of original sequential patterns, just as association rules are a natural extension of frequent itemsets ( Srikant and Agrawal, 1996 ). They have been applied to many application areas, including the stock market ( Berry and
Wu et al., 2012 ), DNA sequence analysis ( Chang et al., 2012 ); web usage behavior analysis ( Jeong et al., 2011; Wang and Lee, 2011 ), trading ( Dong and Pei, 2007 ), e-learning ( Faghihi et al., 2010 ), weather observation ( Hamilton and Karimi, 2005 ), and software engineering ( Lo and Khoo, 2006 ). Using sequential rules, the series of events that usually occurs after a series of previous ones can be predicted. Sequential rules are rather simple, but their information has many important implications, which can be used for decision-making, management and behavior analysis. Compared with sequential patterns, sequential rules can help users better under-stand the chronological order of the sequences present in a sequence database.
 A sequential rule has the form X ) Y ( Sup , Conf ), where X and
Y are sequential patterns, X \ Y  X   X . A sequential rule can be created by splitting a sequential pattern into two parts: the pre and the post fi x( post ). If pre is concatenated with post , denoted pre  X  X  post , then the result is the original sequential pattern.
However, generating a full set of sequential rules is very costly, even for a sparse dataset. In addition, a lot of low-quality rules that are almost meaningless are generated. To address these problems, mining non-redundant sequential rules has been proposed. A rule
SR 1 is called a redundant rule if it can be inferred from another rule SR 2 , where SR 1 and SR 2 have the same support and con
When a set of mined rules is considered as a composite fi replacing a full set of rules with its corresponding non-redundant set of rules does not affect the accuracy of the fi lter. Several methods for mining non-redundant sequential rules have been proposed ( Lo et al., 2009; Zang et al., 2010 ). These methods remove a signi fi cant number of redundant sequential rules but require a lot of time to check sequential generator patterns and closed sequential patterns to generate rules.
 patterns to enumerate all sequential rules/non-redundant sequen-tial rules, which satisfy the minimum con fi dent threshold, from a sequence database. Meanwhile, tree structure is a good method commonly used to describe candidates (sequential patterns) in which each sequential pattern will be stored in one node in the tree. Once the tree structure storing the sequential pattern is built, we can apply the procedure traversed on the tree (the width search tree or depth search tree) to enumerate the candidate list (sequential rule/non-redundant sequential rule), but for mining sequential rules/non-redundant sequential rules from a sequence database, building a pre fi x-tree is very time consuming (may take more time than generating sequential rules/non-redundant sequential rules). For the above reason, this paper has proposed a method for mining non-redundant sequential rules by using the attributed Pre fi x-trees, and applying the child  X  parent relationship of the pre fi x-tree structure for mining non-redundant sequential rules, which greatly reduces the mining time required. reuse the tree-building results in the fi rst stage for mining non-redundant sequential rules with different minConf values as minConf  X  0%, 50%, 70%, and so on. Hence we only build the pre fi x-tree one time. In the second stage, by passing on the pre fi x-tree, non-redundant sequential rules can be easy mined with different minConf thresholds. Two stages are proposed as follows: (1) building a pre fi x-tree that stores all sequential patterns in a sequence database and (2) generating non-redundant sequential rules from this pre fi x-tree. In the pre tree building process, each node on the pre fi x-tree has a indicates whether this node is a minimal sequential generator pattern ( IsmSGP ), and another fi eld that indicates whether this node is a closed sequential pattern ( IsCSP ). By traversing the pre fi x-tree, non-redundant sequential rules can be easily mined from a sequence X at the node whose IsmSGP value is true ( T )toa sequence Y at the node whose IsCSP value is true ( T ) such that X is apre fi xof Y . In addition, to prune the search space in the mining process, the proposed algorithm does not generate rules from the root node of the subtree to its itemset-extended nodes set, but derives rules for sequences on the subtree whose nodes are sequence-extended nodes of the root node of the subtree. Experi-mental results show that the number of non-redundant sequential rules is less than that of the full sequential rules. Besides, the execution time for mining non-redundant sequential rules using the pre fi x-tree structure is much less than that using closed sequential patterns and generator sets ( Zang et al., 2010 ). that an item may/may not appear in the chain of transactions, not concerned about the weight of the item, such as price and number of items which purchased in each transaction of the attached corresponding sequences. The sequential currently mining algo-rithms popular currently are working on this kind of database.
In fact, there are plenty of algorithms proposed for mining association rules from quantitative databases but they posed to resolve for the other problems such as: mining high utility item-sets ( Le et al., 2011; Shie et al., 2013; Wu et al., 2013 ), mining frequent weighted itemsets ( Vo et al., 2013 ), etc.

The rest of this paper is organized as follows. Section 2 reviews works related to mining sequential rules and non-redundant sequential rules. Section 3 presents problem de fi nitions related to this paper. The proposed method for mining non-redundant sequential rules is described in Section 4 . Section 5 describes the experimental results. The conclusion and future work are given in
Section 6 . 2. Related work
Spiliopoulou (1999) proposed a method for generating a full set of sequential rules from a set of discovered frequent sequences in a sequence database. Harms and Deogun (2004) then proposed the
Minimal Occurrences With Constraints and Time Lags ( MOWCATL ) method for mining frequent sequential association rules from multiple sequential databases. The method combines the concept of association rules with frequent episodes, time lags between the occurrences of an antecedent sequence of a mined rule, and event constraints to fi nd relationships between sequences in multiple datasets. However, this method is only used for mining episode rules that can be considered as a variant of sequential rules with constraints. Fournier-viger et al. (2011, 2012a, 2012b) then pro-posed the RuleGrowth , CMRULES and TRuleGrowth algorithms for generating sequential rules common to sequences in sequence databases.

Based on the method of Spiliopoulou (1999) , Lo et al. (2009) proposed a generalized algorithm, called the Full algorithm, to mine a full set of sequential rules, Van et al. (2011) improved the
Full algorithm ( Lo et al., 2009 ) and proposed the MSR-ImpFull algorithm for fi nding sequential rules between pairs of sequential patterns. The algorithm was improved by sorting all sequential patterns in an ascending order of sizes. Sequences that are pre of a sequence X only appear before X in the list of sequential patterns. Based on the property of pre fi x-tree structure, the authors also presented another algorithm, called MSR-PreTree ( Van et al., 2011 ), which could directly generate all sequential rules by traversing the pre fi x-tree.

Lo et al. (2009) introduced several rule sets generated by using the composition of various types of pattern sets including gen-erators, projected-database generators, closed sequences, and projected-database closed sequences. They also proposed a com-pressed set of non-redundant rules that were generated from two pattern sets: the projected database closed pattern set ( LS-Closed ) and the closed pattern set ( CS-Closed )( Lo et al., 2009 ). The antecedent of a rule is a sequence in an LS-Closed set, and the consequence is a sequence in a CS-Closed set. The authors proved that the compressed set of non-redundant rules was complete and tight, and proposed an algorithm for mining this set.

From the basis of description for redundant rules ( Spiliopoulou, 1999 ) and a theory of non-redundant rules ( Lo et al., 2009 ), Zang et al. (2010) then proposed a method for mining non-redundant sequential association rules from frequent closed sequences and sequence generator sets. They also proposed an algorithm called
CSGM (closed sequence and sequence generator mining), which were extended from Pre fi xSpan ( Pei et al., 2004 ) and CloSpan ( Yan et al., 2003 ), for mining frequent closed sequences and sequence generators at the same time. Zang et al. (2010) then were based on the achieved results, which are the set of closed sequences and the set of sequence generators generated from the CSGM method, to propose a method for mining non-redundant sequential associa-tion rules. This method ( Zang et al., 2010 ) removes a signi number of redundant sequential rules, but it requires a lot of time for checking sequential generator patterns and closed sequential patterns to generate rules. 3. De fi nitions 3.1. Sequence and sequence database
Let I  X  { i 1 , i 2 , ... , i m } be a set of items and S  X  { s set of sequences, where each sequence s j is an ordered list of itemsets and each itemset is a set of items. Thus, s j  X   X  and x 1 , x 2 , ... , x p D I. Besides, x 1 occurs before x before x 3 , and so on. The size of a sequence is the number of itemsets in the sequence. The length of a sequence is the number of occurring items contained in the sequence. A sequence with size k is called a k -sequence. A sequence with length k is called a k -pattern sequence. For example, given a sequence s  X   X  ( AB )( B )( B ) ( B ), ( AC ), and has totally 9 items contained in them. Note that an item appearing in two itemsets is counted twice. So, the size of the sequence s is 6 and it is called a 6-sequence. However, the length of the sequence s is 9 and it is called a 9-pattern sequence. A sequence database SD is composed of a set ( S ) of sequences. 3.2. Subsequence and supersequence
Given two sequences s 1  X   X  a 1 , a 2 , ... , a n  X  and s where a i , b j are itemsets and n r m , sequence s 1 is called a subsequence of s 2 , denoted as s 1 D s 2 (i.e., s 2 contains s exist some integers 1 r j 1 o j 2 o  X  o j n r m such that a a D and E are items, then s 1 is a subsequence of s 2 and s supersequence of s 1 . 3.3. Pattern
A pattern is a subsequence of a sequence. Each itemset in a pattern is called an element or an event. 3.4. Support and sequential pattern
Given a sequence database SD and sequence s , the support of s in SD , denoted Sup ( s ), is the number of sequences in SD containing s. s is called a frequent sequence in SD if Sup ( s ) Z minSup (a minimum support threshold). A frequent sequence is also called a sequential pattern. 3.5. Closed sequential pattern and sequential generator pattern
Let s be a sequential pattern. s is called a closed sequential : ( t such that s + t (i.e., s contains t ) and Sup ( s )  X  Sup ( t ). 3.6. Minimal sequential generator pattern
Let SGP ( t ) denote the set of sequential generator patterns of t.  X  A
S GP( t ) is a minimal sequential generator pattern if it does not have any of its subsets in SGP ( t ). For example, given t  X  ( B ): 3  X  is a closed sequential pattern, s  X   X  ( AB )( B ): 3 generator pattern of t , and SGP ( t )  X  {  X  ( A )( B ): 3 pattern. 3.7. Pre fi x, incomplete pre fi x and post fi x( Van et al., 2011 )
Given two sequences s 1  X   X  a 1 , a 2 , ... , a n  X  and s where a i and b j are itemsets and m 4 n , sequence s 1 is a pre if and only if a i  X  b i for all 1 r i r n . After the pre removed from the sequence s 2 , the remaining part of sequence s is called a post fi xof s 2 . Sequence s 1 is an incomplete pre ( b n a n ) (the remaining items after the items in a n are removed from b n ) occur after the items in a n in a lexicographic order. From ( k 1) pre fi xes. For example, the sequence  X  ( A )( BC )( D ) fi xes:  X  ( A )  X  and  X  ( A )( BC )  X  . Therefore,  X  ( BC )( D ) pre fi x  X  ( A )  X  , and  X  ( D )  X  is the post fi x of the pre fi ( B )  X  and  X  ( BC )  X  are not considered as the pre fi x of the given sequence, but  X  ( A )(B)  X  is an incomplete pre fi x of it and the size of  X  ( A )(B)  X  is equal to the size of  X  ( A )( BC )  X  . 3.8. Con fi dence of a sequential rule
Let s and t be two different sequential patterns in SD . The con fi dence of a sequential rule SR : s ) t , denoted Conf ( SR ), is de fi sequences that contain both s and t in SD . 3.9. Redundant sequential rule
Assume there is a set of sequential rules SR  X  { SR 1 , SR in which all the rules have the same support and con fi dence values. Sequential rule SR j in SR is called a redundant sequential rule if and only if there exists another sequential rule SR such that SR j can be inferred by SR i ( i a j ). For example, consider the following set of sequential rules: SR  X  { SR 1 :  X  A  X   X 
A  X  )  X  E , F  X  ;SR 3 :  X  A  X  )  X  B , C , D  X  } with the same support and con fi dence values. SR 1 is redundant since it can be inferred by SR 3.10. Min-max sequential rule
This de fi nition is extended from the association rule mining ( Pasquier et al., 2005 ) to the sequential rule mining. Let SR be a s et of sequential rules. A sequential rule SR 1 : s 1 ) t 1 a min-max sequential rule if : ( SR 2 : s 2 ) t 2 A SR such that s
D s 2 , t 2 D t 1 , Sup ( SR 1 )  X  Sup ( SR 2 ), and Conf ( SR max sequential rules are non-redundant sequential rules with the antecedent is a minimal sequence and the consequent is a maximal sequence.

Suppose g , s 1 and s 2 are three sequential patterns, with g
C s considered as the closed sequence of g , and similar to closure( s and closure( s 2 )). Also assume the two sequential rules SR 1 :g ) ( s \ g ) and SR 2 :s 1 ) ( s 2 \ s 1 ) have the same con fi dence, where s a subsequence of s 2 by removing the sequence s 1 from s 2 antecedent of SR 1 is thus shorter than that of SR 2 , and the consequent of SR 1 is longer than that of SR 2 .If s 2 is a closed sequential pattern, g is a sequential generator pattern of s s  X  closure( s 2 ) and g is a minimal sequence which has the same shortest antecedent and the longest consequent w.r.t. SR 2 ( s \ s ) where g D s 1 C s 2 . Hence, in a way similar to the min-max exact rules with con fi dence being 1 ( Pasquier et al., 2005 ) which are generated by using a closed itemset and its generator, the sequential min-max exact rules can be generated by using a closed sequential pattern and its sequential generator patterns. The sequential min-max exact rules can be de fi ned as follows. 3.11. Sequential min-max exact basis ( Zang et al., 2010 ) closed sequential pattern c , let SGP c denote the set of sequential generators of c . The sequential min-max exact basis is de follows: f r : g ) X  c n g  X j c A CSP 4 g A SGP c 4 g a c g :
Suppose that g 1 , s 1 , c 1 , g 2 and s 2 are sequential patterns, terns, c 1 and c 2 are closed sequential patterns, and the two sequential rules SR 1 :g 1 ) ( c 2 \ g 1 ) and SR 2 :s 1 ) ( c same con fi dence. If the antecedent of SR 1 is shorter than that of
SR 2 and the consequent of SR 1 is longer than that of SR that SR 2 is redundant to SR 1 and should not be generated. Since c is a closed sequential pattern and g 1 is a sequential generator pattern, another sequence g such that g C g 1 , Sup ( g )  X  Sup ( g ) cannot be found. So, g 1 ) ( c 2 \ g 1 ) is considered a non-redundant rule, and all the rules s 1 ) ( c 2 \ s 1 ) with g 1 D s 1 redundant. It means that a non-redundant sequential rule can be generated from a sequential generator pattern and a closed sequential pattern. Hence, in a way similar to min-max approx-imate rules ( Pasquier et al., 2005 ) containing non-redundant ones with con fi dence being less than 1, the sequential min-max approximate rules can be generated. The sequential min-max approximate rules can thus be de fi ned as follows. 3.12. Sequential min-max approximate basis ( Zang et al., 2010 )
Let CSP be the set of closed sequential patterns and GenSet be the set of sequential generators of the sequential closed patterns in
CSP , the min-max approximate basis is de fi ned below: f r : g ) X  c n g  X j c A CSP 4 g A GenSet 4 Closure  X  g  X  c g : 4. Mining non-redundant sequential rules from the pre fi x-tree structure
In this section, a method is proposed for mining non-redundant sequential rules based on the pre fi x-tree structure. This method fi rst builds a pre fi x-tree, and after that it uses the IsmSGP and IsCSP fi elds from this pre fi x-tree to mine non-redundant sequential rules. According to the de fi nition of min-max sequential rules in Section 3 and the structure of the pre fi x-tree, non-redundant sequential rules can be mined from a minimal sequential generator pattern X to a closed sequential pattern Y such that X is a pre The process for building the pre fi x-tree is fi rst stated below. 4.1. Building a pre fi x-tree Theorem 1. Let s and t be two sequential patterns such that s a minimal sequential generator pattern.

Proof. Since Sup ( s )  X  Sup ( t ) and s C t , s is a proper sequential sequential pattern, and t is not a minimal sequential generator pattern.  X  frequent items in frequency-descending order and ensures the tree can maintain as much pre fi x sharing as possible among patterns in the transaction database. It is a highly compact tree structure that enables highly ef fi cient mining. However, FP-tree only handles the frequent items in a database and it requires two database scans, which are the key limitations of applying the
FP-tree in the sequence database mining. So, Pre fi x-tree can be used in the frequent pattern mining to address the problems of numerous candidate patterns, time complexity, and multiple database scans for Apriori algorithms. Pre fi x-tree based techniques follow a pattern growth approach that avoids candidate genera-tion and test costs by generating a frequent pattern from its pre
Pre fi x-tree structure with one database scan that captures the full database information, inherits the compactness of the FP-tree, and yields better mining performance.

In this paper, a pre fi x-tree, denoted pretree , is constructed by applying Theorem 1 to determine from two patterns with the same supports which pattern is a closed sequential pattern and which is a minimal sequential generator pattern that help mine non-redundant sequential rules. It is similar to a lexicographic tree ( Gouda et al., 2010; Pham et al., 2012; Van et al., 2011 ), which starts from the tree with the root at level 0 and with a null sequence  X  . Besides, each child node stores a sequential pattern, a support value, an IsmSGP value ( true T or false F ), and an IsCSP item, its support value, an IsmSGP value of true ( T ), and an IsCSP value of true ( T ); at level k , each node is set with a k -pattern.
Recursively, there are nodes at the next level ( k  X  1) after a k -pattern is extended with a frequent item. The IsmSGP and IsCSP values of each extended node are determined according to
Theorem 1. The tree-building algorithm also needs to traverse pretree to update the corresponding IsmSGP and IsCSP values of nodes. There are two ways to extend a sequence: sequence extension and itemset extension ( Gouda et al., 2010 ). In sequence extension, an item is appended from I to the sequence as a new itemset, and the sequence-extended sequence size always increases. A sequence s is a pre fi x of all sequence-extended sequences of s , and s is the pre fi x of all children nodes of the nodes that are sequence-extended in s . In itemset extension, an item is appended to the last itemset in the sequence, so this item must be greater than all the items in the last itemset. The size of itemset-extended sequences does not change and s is an incom-plete pre fi x of all children nodes of the itemset-extended nodes in s . The pseudo-code of the algorithm for building a pre given in Fig. 1 . First, the algorithm initializes the pre ( pretree ) with the root node being null and its child nodes being sequential 1-patterns with their IsmSGP and IsCSP fi elds as true.
Each child node cn on pretree is then considered as a root node for the EXTEND_TREE ( cn , pretree ) function to create its children nodes and extend the pretree . In this function, each child node of the root node P is created by itemset extension or sequence extension. To effectively represent candidate sequences and determine the frequency for each candidate, it uses the prime block encoding approach and the join operations over the prime blocks in Gouda et al. (2010) . Each newly created child node, Pnew , is always the values of Pnew.IsmSGP and P.IsCSP are set to false . The NSR minConf
UPDATE_PRETREE ( Pnew , pretree ) function is then called to update the closed sequential patterns and their sequential generator patterns on the pretree tree. Finally, the algorithm returns the corresponding pretree . Fig. 2 shows the pre fi x-tree built by the algorithm in Fig. 1 , from the sequence database in Table 1 with minSup  X  50%. 4.2. Proposed algorithm de fi nition of the min-max sequential rule in Section 3 , an algo-rithm called MNSR-Pretree is proposed for generating all non-redundant sequential rules. The detail of the algorithm is shown in pretree , the algorithm only mine rules from a parent node whose
IsmSGP value is true ( T ) to children nodes whose IsCSP value is true ( T ), so that the sequence at the parent node is considered as an antecedent of the rules to be generated, and the consequents of rules are generated by removing the pre fi x part, which the sequence at the parent node has, from closed sequential patterns. minConf . For each node SP at level 1 of the pre fi x-tree, the algorithm calls the GENERATE_NSR_FROM_ROOT ( SP ) procedure to generate non-redundant sequential rules from each subtree with
SP as its root node. Finally, it returns the set of non-redundant sequential rules NSR. There are two types of nodes on pretree : sequence-extended and itemset-extended nodes To prune the search space in the mining process according to the de fi the incomplete pre fi x in itemset extension, the procedure
GENERATE_NSR_FROM_ROOT ( SP ) does not generate rules from the root node SP to its itemset-extended nodes set, but only rules from sequences on the subtree whose nodes are sequence-extended nodes of the root can be generated. When the root node SP of the subtree is a minimal sequential generator pattern ( SP.IsSGP is true ), non-redundant sequential rules from this subtree can be gener-ated by calling the procedure GENERATE_NSR ( SP , Subtree ). In the procedure GENERATE_NSR ( SP , Subtree ), the input includes the root node of the subtree SP that is a minimal sequential generator pattern and Subtree so that the sequence at the root SP , denoted as Pre , is a common pre fi x of all the sequences on the subtree. Thus,
Pre forms the pre fi x of all extended sequences from the sequence-extended nodes of the root and non-redundant sequential rules are generated from the sequences following the pre fi x Pre on the subtree, which are the closed sequential patterns. For each node n
If Conf Z minConf , then a sequential rule SR :  X  Pre ) Post generated such that Post is a post fi x of the sequence kept at node n with respect to the pre fi x Pre and the sequential rule SR is added into NSR . All the extended nodes (itemset-extended nodes and sequence-extended nodes) of the current root then become pre-fi xes (root nodes) of the subtrees at the next level, so some sequential rules are generated from the itemset-extended nodes, and this procedure is recursively called for every extended node of the root. This recursive process is repeated until the last level of the pre fi x tree is reached. 4.3. An example
Consider the pre fi x-tree pretree in Fig. 1 for the sequence database presented in Table 1 for minSup  X  50%. Each node in pretree contains a sequential pattern, its corresponding support, and the corresponding IsmSGP and IsCSP values. Table 2 shows the number of sequential patterns and non-redundant sequential rules generated from Fig. 2 .

In Table 2 , the complete set of non-redundant sequential rules consists of only 5 rules whereas the whole set of sequential rules consists of 23 rules. The number of non-redundant sequential rules is thus much lower than that of sequential rules in the example. Considering the process of generating non-redundant sequential rules from pretree with the root node {} in Fig. 2 , each node on pretree has two types of nodes: sequence-extended and itemset-extended nodes. Based on the de fi nition of itemset exten-sion, the size of the sequences at the itemset-extended node set does not change w.r.t. the size of the sequence at the root node, and the root node becomes an incomplete pre fi x of its itemset-extended nodes and all the sub-nodes of these itemset-extended nodes. To prune the search space in the mining process, we thus does not generate rules from the root node of the subtree, which is an incomplete pre fi x of its itemset-extended nodes and all the sub-nodes of these itemset-extended nodes, to its itemset-extended nodes set and all the sub-nodes of these itemset-extended nodes. Instead, only rules from sequences on the sub-trees whose nodes are sequence-extended nodes of the root can be generated. Take the pre fi x subtree with the root node
Fig. 2 as an example. The root node  X  ( A )  X  has an IsmSGP value of true ( T ) and an IsCSP values of false ( F ) since all its sequence-extended children nodes including  X  ( A )( B )  X  :3,  X  ( A )( C ) ( B )  X  closed sequential pattern  X  ( AB )( B )( B )  X  :3or  X  ( AB )( B )( C ) to the de fi nitions. Although  X  ( A )  X  is the complete pre sequences of  X  ( A )  X  , but  X  ( A ),( B )  X  and  X  ( A ),( C ) sequential patterns of  X  ( A )  X  . Hence there are no non-redundant sequential rules generated from these sequences. Similar to ( B )  X  and  X  ( A ),( C )  X  ,  X  ( A ),( B )  X  and  X  ( A ),( C )  X  generator patterns (have the IsmSGP value of false ( F )) of ( B )  X  and  X  ( A ),( B )( C )  X  , so no non-redundant sequential rules are generated.  X  ( A )  X  is a minimal sequential generator pattern of  X  ( AB )  X  , no non-redundant sequential rules are thus generated. The pre fi x subtree with the root node  X  ( B )  X  has an IsmSGP value of true ( T ) and its sequence-extended children nodes, which have IsCSP values of true ( T ), include sequences  X  ( B )( B )  X  ,  X   X  tial rules are thus generated from these sequences:  X  ( B ) (5,1);  X  ( B )  X  )  X  ( AB )  X  (3,0.6);  X  ( B )  X  )  X  ( B )( B )
Sequence  X  ( AB )( B )( B )  X  is a closed sequential pattern of ( B )  X  , and sequence  X  ( AB )( B )( C )  X  is a closed sequential pattern of  X  ( A ),( B ),( C )  X  , but they do not have the same pre fi  X  tial pattern of the sequence  X  ( B ),( BC )  X  is  X  ( B )( B )( BC ) not have the same pre fi x. Hence, in the non-redundant sequential rule mining process, there are no non-redundant sequential rules generated by these sequential patterns. The above process is repeated for the remaining nodes on pretree . The fi nal results are shown in Table 2 . 5. Experimental results
To evaluate the performance of the proposed algorithm for mining non-redundant sequential rules from the pre fi x-tree structure, its performance is compared with those of the Full algorithm ( Lo et al., 2009 ) and another algorithm for mining non-redundant sequential rules from closed sequential pattern and generator sets ( Zang et al., 2010 ), denoted NR (Non-redundant
Rule). All experiments were performed on a PC with a dual-core 2.81-GHz CPU and 2 GB of RAM, running Windows XP Profes-sional, and implemented in C#. The synthetic and real databases, including C6T5S4I4N1kD1k , Chess , Mushroom and Connect ,were used in the experiments. The synthetic data generator provided by
IBM was used to generate C6T5S4I4N1kD1k with the following parameters: C is the average number of itemsets per sequence, set to 6 (denoted as C 6), T is the average number of items per itemset, set to 5 (denoted as T 5), S is the average number of itemsets in maximal sequences, set to 4 (denoted as S 4), I is the average number of items in maximal sequences, set to 4 (denoted as I 4),
N is the number of distinct items, set to 1000 (denoted as N 1 k ), and D is the number of sequences, set to 1000 (denoted as D 1 k ).
The Chess , the Mushroom , and the Connect databases were down-loaded from http:// fi mi.ua.ac.be/data/ , where each itemset in a sequence of these databases is a single item. The Chess database includes 3196 sequences with 76 distinct items, the Mushroom database includes 8124 sequences with 120 distinct items, and the
Connect database includes 67 557 sequences with 104 distinct items. Table 3 shows the number of sequential rules generated from the full set of sequential patterns by the Full algorithm, the number of non-redundant sequential rules generated from the set of sequential generator patterns and closed sequential patterns by the proposed algorithm, and the ratio of the numbers of non-redundant sequential rules and sequential rules corresponding to their minimum supports.

The experimental results show that the number of non-redundant sequential rules is always much lower than that of sequential rules in all the three databases, especially for mining with a low support. For example, for the Mushroom database with minSup  X  10% and minConf  X  0%, the numbers of non-redundant sequential rules and sequential rules are 109,845 and 606,851, respectively. The ratio is 18.10%. The run time for mining non-redundant sequential rules is lower than that required for mining a full set of sequential rules in all cases, as shown in Figs. 4
Figs. 8  X  11 compare the time required for mining non-redundant sequential rules for the proposed algorithm and that for the NR algorithm ( Zang et al., 2010 ) to generate all non-redundant sequential patterns with minConf being 0%. The results show that the run time of the proposed MNSR_Pretree algorithm is always faster than that of the NR algorithm, because the former uses the child  X  parent relationship of the pre fi x-tree and the
IsmSGP and IsCSP fi elds to generate rules whereas the latter must check the pre fi x property in the whole set of closed sequential patterns for each sequential generator pattern. In addition, the
MNSR_Pretree algorithm used the property of the incomplete Table 4 also shows that the required ratio of mining time by the
MNSR_Pretree algorithm is much less than that of the NR algo-rithm. For example, in the C6T5S4I4N1kD1k database with minSup  X  0.4% and minConf  X  0% with totally 80 112 non-redundant sequential rules generated, the MNSR_Pretree algorithm spent only 0.347 s, while the NR algorithm spent 862.194 s. The ratio of mining time of the MNSR_Pretree algorithm over that of the NR algorithm is thus 0.04%. Table 5 shows the results of non-redundant rules with the different minConf values. 6. Conclusions and future work
Mining non-redundant sequential rules could reduce the num-ber of sequential rules and the execution time required. In this paper, an effective method for mining this kind of rules is proposed. First, the pre fi x-tree structure is built to aid in the mining process for improving the performance. An algorithm called MNSR_Pretree is then designed for generating all non-redundant sequential rules. It uses the child  X  parent relationship in the pre fi x-tree structure and the IsmSGP and IsCSP fi node to reduce the search space. In our study, we have used the C6T5S4I4N1kD1k (synthetic database) provided by IBM for evalu-ating the experiments. Each sequence in the C6T5S4I4N1kD1k synthetic database includes the set of itemsets, each of which is an ordered list of items. The Chess , the Mushroom and the Connect are popularly used in association rule mining. The experimental results on synthetic and real databases show that the number of non-redundant sequential rules is much smaller than that of sequential rules, and that the time required for mining non-redundant sequential rules is much less than that required for mining sequential rules. Besides, the results also show that the time required for mining non-redundant sequential rules by the proposed algorithm is less than that required by an existing algorithm. Instead of using more synthetic databases, we want to use real databases as Chess , Mushroom and Connect where each itemset in a sequence is a single item (applied in web usage mining, for example). In the future, we will try to fi nd more sequence datasets to evaluate the proposed approach.

In our study, we have just worked on sequence databases that have been discretized. For continuous domains, we may use the partition or fuzzy-set strategies ( Hong et al., 2008 ) to solve the problem. The problem is interesting and may be considered in the future work.

Inter-sequences mining ( Vo et al., 2012 ) is one of the approaches for sequence mining where sequential patterns can be mined inside a transaction and inter-transaction patterns in several transactions to mine sequential patterns. In the future, we will study methods for mining inter-sequences using the pre tree. Rules from the inter-sequence set will then be generated.
Furthermore, a lattice-based approach has been proposed for mining association rules and classi fi cation-based association rules ( Nguyen et al., 2012; Vo and Le, 2011; Vo et al., 2013 ). This type of approach will be applied for mining sequential patterns and sequential rules as well.
 Acknowledgments This work was funded by Viet Nam's National Foundation for Science and Technology Development (NAFOSTED) under Grant No. 102.05-2013.20.
 References
