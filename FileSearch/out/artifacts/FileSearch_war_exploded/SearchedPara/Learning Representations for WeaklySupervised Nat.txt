 Temple University Northwestern University Northwestern University Northwestern University Temple University Temple University extracting features from n-gram models, Hidden Markov Models, and other statistical language models, including a novel Partial Lattice Markov Random Field model. Experiments on part-of-speech tagging and information extraction, among other tasks, indicate that features taken from statistical language models, in combination with more traditional features, outperform traditional representations alone, and that graphical model representations outperform n-gram models, especially on sparse and polysemous words. 1. Introduction
NLP systems often rely on hand-crafted, carefully engineered sets of features to achieve strong performance. Thus, a part-of-speech (POS) tagger would traditionally use a feature like,  X  X he previous token is the  X  X ohelpclassifyagiventokenasanoun these traditional features yield state-of-the-art results. However, NLP systems are in-creasingly being applied to the Web, scientific domains, personal communications like e-mails and tweets, among many other kinds of linguistic communication. These texts have very different characteristics from traditional training corpora in NLP. Evidence from POS tagging (Blitzer, McDonald, and Pereira 2006; Huang and Yates 2009), parsing (Gildea 2001; Sekine 1997; McClosky 2010), and semantic role labeling (SRL) (Pradhan,
Ward, and Martin 2007), among other NLP tasks (Daum  X  e III and Marcu 2006; Chelba and Acero 2004; Downey, Broadhead, and Etzioni 2007; Chan and Ng 2006; Blitzer,
Dredze, and Pereira 2007), shows that the accuracy of supervised NLP systems degrades significantly when tested on domains different from those used for training. Collecting labeled training data for each new target domain is typically prohibitively expensive.
In this article, we investigate representations that can be applied to weakly supervised learning, that is, learning when domain-specific labeled training data are scarce. manually crafted features for a variety of NLP tasks limit systems X  performance in this weakly supervised learning for two reasons. First, feature sparsity prevents systems from generalizing accurately, because many words and features are not observed in training. Also because word frequencies are Zipf-distributed, this often means that there cially in new domains (Huang and Yates 2009). For example, word-type features form the backbone of most POS-tagging systems, but types like  X  X ene X  and  X  X athway X  show up frequently in biomedical literature, and rarely in newswire text. Thus, a classifier trained on newswire data and tested on biomedical data will have seen few training examples related to sentences with features  X  X ene X  and  X  X athway X  (Blitzer, McDonald, and Pereira 2006; Ben-David et al. 2010).
 generalizing to situations in which words have different meanings. For instance, the word type  X  X ignaling X  appears primarily as a present participle (VBG) in Wall Street
Journal(WSJ)text,asin, X  X nterestratesrose,signalingthat... X (Marcus,Marcinkiewicz, and Santorini 1993). In biomedical text, however,  X  X ignaling X  appears primarily in the phrase  X  X ignaling pathway, X  where it is considered a noun (NN) (PennBioIE 2005); this phrase never appears in the WSJ portion of the Penn Treebank (Huang and Yates 2010). sentations is to seek new representations that allow systems to generalize to previously unseen examples. That is, we seek representations that permit classifiers to have close to the same accuracy on examples from other domains as they do on the domain of the training data. Our approach depends on the well-known distributional hypothesis , which states that a word X  X  meaning is identified with the contexts in which it appears representations , or mappings from word tokens and types to real-valued vectors, from statistical language models. Because statistical language models are designed to model words X  contexts, the features they produce can be used to combat problems with polysemy. And by careful design of the statistical language models, we can limit 86 the number of features that they produce, controlling how sparse those features are in training data.
 1. We show how to generate representations from a variety of language 2. We quantify the performance of these representations in experiments 3. We analyze how sparsity, polysemy, and differences between domains learning for NLP. Section 3 presents novel representations based on statistical language models. Sections 4 and 5 discuss evaluations of the representations, first on sequence-labeling tasks in a domain adaptation setting, and second on a weakly supervised set-expansion task. Section 6 concludes and outlines directions for future work. 2. Background and Previous Work on Representation Learning 2.1 Terminology and Notation
In a traditional machine learning task, the goal is to make predictions on test data using a hypothesis that is optimized on labeled training data. In order to do so, practitioners predefine a set of features and try to estimate classifier parameters from the observed features in the training data. We call these feature sets representations of the data. possible labels for an instance, and let f : X  X  Z be the target function to be learned. A representation is a function R : X  X  Y , for some suitable feature space
We refer to dimensions of Y as features , and for an instance x for particular dimensions of R ( x )as features of x . Given a set of training examples, a learning machine X  X  task is to select a hypothesis h from the hypothesis space of Z R ( X ) . Errors by the hypothesis are measured using a loss function measures the cost of the mismatch between the target function f ( x ) and the hypothesis h ( R ( x )).
 sentences, and Z is the space of POS sequences containing labels like NN (for noun) and
VBG (for present participle). The target function f is the mapping between sentences into sequences of vectors, one for each word position. Each vector contains values for typical loss function would count the number of words that are tagged differently by f ( x )and h ( R ( x )). 2.2 Representation-Learning Problem Formulation Machine learning theory assumes that there is a distribution D over data is sampled. Given a training set S = { ( x 1 , z 1 ), ... ,( x representation R , a hypothesis space H , and a loss function algorithm seeks to identify the hypothesis in H that will minimize the expected loss over samples from distribution D : resentation R . Instead, we allow a space of possible representations problem can then be formulated as the task of identifying the best R simultaneously: reduced to the general learning formulation in Equation (1) by setting the fixed rep-resentation R to be the identity function, and setting the hypothesis space to be from the representation-learning task. We introduce the new formulation primarily as a way of changing the perspective on the learning task: most NLP systems consider a fixed, manually crafted transformation of the original data to some new space, and investigate hypothesis classes over that space. In the new formulation, systems learn regression algorithms. 2.3 Theory on Domain Adaptation We refer to the distribution D over the instance space sentences about governments and current events; the biomedical literature domain gives high probability to sentences about proteins and regulatory pathways. In domain x  X  X are drawn from a source domain D amples drawn from a separate target domain D T . We assume that large quantities of unlabeled data are available for the source domain and target domain, and call these 88 samples U S and U T , respectively. For any domain D ,let R ( distribution over the feature space Y given by Pr R ( D ) open-domain learning machine X  X  performance. Their analysis shows that the choice of representation is crucial to domain adaptation. A good choice of representation must important, however, is that the representation must simultaneously make the source and target domains look as similar to one another as possible. That is, if the labeling function f is the same on the source and target domains, then for every h provably bound the error of h on the target domain by its error on the source domain plus a measure of the distance between D S and D T : where the variation divergence d 1 is given by where B is the set of measurable sets under D and D (Ben-David et al. 2007, 2010). tion. The more that features appear with different frequencies in different domains, the worse this bound becomes. In fact, one lower bound for the d of the best classifier for predicting whether an unlabeled instance y = R ( x ) belongs to domain S or T (Ben-David et al. 2010). Thus, if R provides one set of common features for examples from S , and another set of common features for examples from T , the domain of an instance becomes easy to predict, meaning the distance between the domains grows, and the bound on our classifier X  X  performance grows worse.

NLP are inadequate for domain adaptation because they contribute to the d between domains. Although many previous studies have shown that lexical features allow learning systems to achieve impressively low error rates during training, they also make texts from different domains look very dissimilar. For instance, a feature based on the word  X  X ank X  or  X  X EO X  may be common in a domain of newswire text, but scarce or nonexistent in, say, biomedical literature. Ben David et al. X  X  theory predicts greater variance in the error rate of the target domain classifier as the distance grows. sufficient training data for the relevant parameters of the system. In traditional super-vised NLP systems, there are parameters for each word type in the data, or perhaps even combinations of word types. Because vocabularies can be extremely large, this leads to an explosion in the number of parameters. As a consequence, for many of their parameters, supervised NLP systems have zero or only a handful of relevant labeled examples (Bikel 2004a, 2004b). No matter how sophisticated the learning technique, it across domains, domain adaptation greatly exacerbates this issue of data sparsity. 2.4 Problem Formulation for the Domain Adaptation Setting
Formally, we define the task of representation learning for domain adaptation as the following optimization problem: Given a set of unlabeled instances U source domain and unlabeled instances U T from the target domain, as well as a set of labeled instances L S drawn from the source domain, identify a function R space of possible representations R that minimizes where  X  is a free parameter.
 tive function: The best representation for the source domain would naturally include domain-specific features, and allow a hypothesis to learn domain-specific patterns. on training data from one domain (or a few domains). The domain-specific features domains not seen in training. By optimizing for this combined objective function, we allow the optimization method to trade off between features that are best for classifying source-domain data and features that allow generalization to new domains. tion (5) does not reduce to the standard machine-learning problem (Equation (1)). In a sense, the d 1 term acts as a regularizer on R , which also affects learning for domain adaptation is a fundamentally novel learning task. 2.5 Tractable Representation Learning: Statistical Language Models as Representations
For most hypothesis classes and any interesting space of representations, Equations (2) and (5) are completely intractable to optimize exactly. Even given a fixed representation, it is intractable to compute the best hypothesis for many hypothesis classes. And the d metric is intractable to compute from samples of a distribution, although Ben-David et al. (2007, 2010) propose some tractable bounds. We view these problem formulations as high-level goals rather than as computable objectives.
 statistical language models as a way to represent the meanings of words. This approach depends on the well-known distributional hypothesis , which states that a word X  X  meaning is identified with the contexts in which it appears (Harris 1954; Hindle 1990).
From this hypothesis, we can formulate the following testable prediction, which we call the statistical language model representation hypothesis ,orLMRH: ing a representation from the task of optimizing a hypothesis. To learn a representation, we can train a statistical language model on unlabeled text, and then use parameters or latent states from the statistical language model to create a representation function.
Optimizing a hypothesis then follows the standard learning framework, using the representation from the statistical language model. 90 supervised approaches to machine learning, such as Alternating Structure Optimization (ASO) (Ando and Zhang 2005) and Structural Correspondence Learning (SCL) (Blitzer, unlabeled data as a way to harness the manifold and cluster assumptions. However, the LMRH is distinct from at least ASO and SCL in important ways. Both ASO and SCL create multiple  X  X ynthetic X  or  X  X ivot X  prediction tasks using unlabeled data, and find transformations of the input feature space that perform well on these tasks. The LMRH, on the other hand, is more specific  X  it asserts that for language problems, if we opti-mize word representations on a single task (the language modeling task), this will lead to strong performance on weakly supervised tasks. In reported experiments on NLP tasks, both ASO and SCL use certain synthetic predictors that are essentially language modeling tasks, such as the task of predicting whether the next token is of word type w .
To the extent that these techniques X  performance relies on language-modeling tasks as their  X  X ynthetic predictors, X  they can be viewed as evidence in support of the LMRH. developed techniques and models from statistical language modeling. Section 3 presents a series of statistical language models that we investigate for learning repre-sentations for NLP. 2.6 Previous Work
There is a long tradition of NLP research on representations, mostly falling into one of four categories: 1) vector space models of meaning based on document-level lexical co-occurrence statistics (Salton and McGill 1983; Sahlgren 2006; Turney and Pantel 2010); 2) dimensionality reduction techniques for vector space models (Deerwester et al. 1990; Ritter and Kohonen 1989; Honkela 1997; Kaski 1998; Sahlgren 2001, 2005; Blei, Ng, and features (Miller, Guinness, and Zamanian 2004; Ratinov and Roth 2009; Lin and Wu 2009; Candito and Crabbe 2009; Koo, Carreras, and Collins 2008; Suzuki et al. 2009; Zhao et al. 2009); and, recently, 4) neural network statistical language models (Bengio 2008;
Bengio et al. 2003; Morin and Bengio 2005; Mnih, Yuecheng, and Hinton 2009; Mnih and Hinton 2007, 2009) as representations (Weston, Ratle, and Collobert 2008; Collobert and Weston 2008; Bengio et al. 2009). Our work is a form of distributional clustering for representations, but where previous work has used bigram and trigram statistics to form clusters, we build sophisticated models that attempt to capture the context of a word, and hence its similarity to other words, more precisely. Our experiments show that the new graphical models provide representations that outperform those from previous work on several tasks.
 perplexity results (Mnih and Hinton 2009), and representations based on them have im-proved in-domain chunking, NER, and SRL (Weston, Ratle, and Collobert 2008; Turian, Bergstra, and Bengio 2009; Turian, Ratinov, and Bengio 2010). As far as we are aware,
Turian, Ratinov, and Bengio (2010) is the only other work to test a learned representation on a domain adaptation task, and they show improvement on out-of-domain NER with their neural net representations. Though promising, the neural network models are computationally expensive to train, and these statistical language models work only on fixed-length histories ( n -grams) rather than full observation sequences. Turian, better than neural net models on all of their chunking and NER tests. We concentrate on probabilistic graphical models with discrete latent states instead. We show that HMM-based and other representations significantly outperform the more commonly used
Brown clustering (Brown et al. 1992) as a representation for domain adaptation settings of sequence-labeling tasks.
 labeled data are available in both the source and target domains (Chan and Ng 2006; and Zhai 2007a, 2007b; Dredze and Crammer 2008; Finkel and Manning 2009; Dredze,
Kulesza, and Crammer 2010). Learning bounds for this domain-adaptation setting are known (Blitzer et al. 2007; Mansour, Mohri, and Rostamizadeh 2009). Approaches to this problem setting have focused on appropriately weighting examples from the source and target domains so that the learning algorithm can balance the greater relevance of the target-domain data with the larger source-domain data set. In some cases, researchers combine this approach with semi-supervised learning to include unlabeled examples from the target domain as well (Daum  X  e III, Kumar, and Saha 2010). These techniques do not handle open-domain corpora like the Web, where they require expert input to acquire labels for each new single-domain corpus, and it is difficult to come up with a representative set of labeled training data for each domain. Our technique requires only unlabeled data from each new domain, which is significantly easier and cheaper to acquire. Where target-domain labeled data is available, however, these techniques can in principle be combined with ours to improve performance, although this has not yet been demonstrated empirically.
 without labeled data in the target domain. Perhaps the best known is Blitzer, McDonald, and Pereira X  X  (2006) Structural Correspondence Learning (SCL). SCL uses  X  X ivot X  words common to both source and target domains, and trains linear classifiers to predict these pivot words from their context. After an SVD reduction of the weight vectors for these obtain new features that are added to the original feature space. Like SCL, our language modeling techniques attempt to predict words from their context, and then use the output of these predictions as new features. Unlike SCL, we attempt to predict all words from their context, and we rely on traditional probabilistic methods for language mod-eling. Our best learned representations, which involve significantly different techniques from SCL, especially latent-variable probabilistic models, significantly outperform SCL in POS tagging experiments.
 main include Satpal and Sarawagi (2007), who show that by changing the optimization function during conditional random field (CRF) training, they can learn classifiers that distance between training text and unlabeled test text, but unlike our techniques, theirs cannot learn representations with features that do not appear in the original feature set. In contrast, we learn hidden features through statistical language models. McClosky,
Charniak, and Johnson (2010) use classifiers from multiple source domains and features that describe how much a target document diverges from each source domain to deter-mine an optimal weighting of the source-domain classifiers for parsing the target text.
However, it is unclear if this  X  X ource-combination X  technique works well on domains that are not mixtures of the various source domains. Dai et al. (2007) use KL-divergence between domains to directly modify the parameters of their naive Bayes model for a 92 text classification task trained purely on the source domain. These last two techniques are not representation learning, and are complementary to our techniques. semi-supervised learning. Of the vast number of semi-supervised approaches to (2008) combination of HMMs and CRFs that uses over a billion words of unlabeled text to achieve the current best performance on in-domain chunking, and semi-supervised approaches to improving in-domain SRL with large quantities of unlabeled text
Lapata 2009). Ando and Zhang X  X  (2005) semi-supervised sequence labeling technique has been tested on a domain adaptation task for POS tagging (Blitzer, McDonald, and
Pereira 2006); our representation-learning approaches outperform it. Unlike most semi-supervised techniques, we concentrate on a particularly simple task decomposition: un-supervised learning for new representations, followed by standard supervised learning.
In addition to our task decomposition being simple, our learned representations are also task-independent, so we can learn the representation once, and then apply it to any task. is based on the HMM (Rabiner 1989). HMMs have of course also been used for super-vised, semi-supervised, and unsupervised POS tagging on a single domain (Banko and Moore 2004; Goldwater and Griffiths 2007). Recent efforts on improving unsupervised
POS tagging have focused on incorporating prior knowledge into the POS induction model (Grac  X a et al. 2009; Toutanova and Johnson 2007), or on new training techniques
Despite the fact that completely connected, standard HMMs perform poorly at the POS for a supervised POS tagger. Experiments in information extraction have previously also shown that HMMs provide informative features for this quite different, semantic processing task (Downey, Schoenmackers, and Etzioni 2007; Ahuja and Downey 2010). representations X  X he naive Bayes representation and PL-MRF representation (Huang gence; by testing on new data sets including a Chinese POS tagging task; and by pro-viding an empirical comparison with Brown clusters as representations. 3. Learning Representations of Distributional Similarity
In this section, we will introduce several representation learning models. 3.1 Traditional POS-Tagging Representations tagging experiments). The instance set X is the set of English sentences, and of POS tag sequences. A traditional representation T RAD -R maps a sentence x sequence of boolean-valued vectors, one vector per word x for each latent vector include indicators for the word type of x features. Table 1 presents the full list of features in T word types rather than tokens, this baseline is not appropriate for that task. Herein, we describe how we can learn representations R by using a variety of statistical language tagging inherit the features from T RAD -R; all representations for IE do not. 3.2 n -gram Representations n -gram representations, which we call n -GRAM -R, model a word type w in terms of the n -gram contexts in which w appears in a corpus. Specifically, for word w we generate the vector P ( w w w ) / P ( w ), the conditional probability of observing the word sequence w to the left and w to the right of w . Each dimension in this vector represents a com-bination of the left and right words. The experimental section describes the particular corpora and statistical language modeling methods used for estimating probabilities.
Note that these features depend only on the word type w , and so for every token x n -GRAM -R provides the same set of features regardless of local context.
 are as sparsely observed as the lexical features in T RAD tures can be obtained from larger corpora. As an alternative, we apply latent semantic analysis (LSA) (Deerwester et al. 1990) to compute a reduced-rank representation. For word w ,let v right ( w ) represent the right context vector of w , which in each dimension 94 of right context vectors and the set of left context vectors separately, of several context word types. We then use each component of v as features. After experimenting with different choices for the number of dimensions to reduce our vectors to, we choose a value of 10 dimensions as the one that maximizes model L SA -R. 3.3 A Context-Dependent Representation Using Naive Bayes
The n -GRAM -R and L SA -R representations always produce the same features F for a given word type w , regardless of the local context of a particular token x remaining representations are all context-dependent, in the sense that the features provided for token x i depend on the local context around x
S = { 1, ... , K } . First, we form trigrams from our sentences. For each trigram, we form a separate Bayes net in which each token from the trigram is conditionally independent given the latent state. For tokens x i  X  1 , x i ,and x i + 1 latent state Y i = y is given by:
The probability of a whole sentence is then given by the product of the probabilities of its trigrams. Figure 1 shows a graphical representation of this model. We train our models using standard expectation-maximization (Dempster, Laird, and Rubin 1977) with random initialization of the parameters.
 trigrams overlap, the resulting statistical language model is mass-deficient. Worse still, it is throwing away information from the dependencies among trigrams which might help make better clustering decisions. Nevertheless, this model closely mirrors many of the clustering algorithms used in previous approaches to representation learning for sequence labeling (Ushioda 1996; Miller, Guinness, and Zamanian 2004; Koo, Carreras, and Collins 2008; Lin and Wu 2009; Ratinov and Roth 2009), and therefore serves as an important benchmark.
 tion that produces | S | boolean features F s ( x i ) for each token x state s  X  S : in a sufficiently large training data set. Therefore, compared with n -produces far fewer features. On the other hand, its features for x the contexts in which x i has appeared in the statistical language model X  X  training data, but also on x i  X  1 and x i + 1 in the current sentence. Furthermore, because the range of the features is much more restrictive than real-valued features, it is less prone to data sparsity or variations across domains than real-valued features. 3.4 Context-Dependent, Structured Representations: The Hidden Markov Model In previous work, we have implemented several representations based on hidden
Markov models (Rabiner 1989), which we used for both sequential labeling (like POS tagging [Huang et al. 2011] and NP chunking [Huang and Yates 2009]) and IE (Downey, Schoenmackers, and Etzioni 2007). Figure 2 shows a graphical model of an HMM. An
HMM is a generative probabilistic model that generates each word x conditioned on a latent variable y i . Each y i in the model takes on integral values from 1 to K , and each one is generated by the latent variable for the preceding word, y joint distribution for a corpus x = ( x 1 , ... , x N ) and a set of state vectors y = ( y is given by: P ( x , y ) = i P ( x i | y i ) P ( y i |
P ( x tasks and one for IE. For sequence labeling, we use the Viterbi algorithm to produce the optimal setting y  X  of the latent states for a given sentence x ,or y use the value of y  X  i as a new feature for x i that represents a cluster of distributionally
Applying Bayes X  rule to the HMM parameters, we compute a distribution P ( Y where Y is a single latent node, x is a single token, and w is its word type. We then use 96 of features represents a  X  X oft clustering X  of w into K different clusters. We refer to these representations as H MM -T OKEN -R and H MM -T YPE -R, respectively.
 work (Huang and Yates 2010). This model trains an ensemble of M independent HMM models on the same corpus, initializing each one randomly. We can then use the Viterbi-optimal decoded latent state of each independent HMM model as a separate feature for a token, or the posterior distribution for P ( Y | x = w ) from each HMM as a separate set of features for each word type. We refer to this statistical language model as an I-HMM, and the representations as I-H MM -T OKEN -R and I-H MM -T
Although not traditionally described as such, Brown clustering involves constructing an HMM model in which each word type is restricted to having exactly one latent state that may generate it. Brown et al. describe a greedy agglomerative clustering algorithm for training this model on unlabeled text. Following Turian, Ratinov, and Bengio (2010), we use Percy Liang X  X  implementation of this algorithm for our comparison, and we test runs with 100, 320, 1,000 and 3,200 clusters. We use features from these clusters identical to Turian et al. X  X . 2 Turian et al. have shown that Brown clusters match or exceed the performance of neural network-based statistical language models in domain adaptation experiments for named-entity recognition, as well as in-domain experiments for NER and chunking.
 features, they have a much greater potential to combat sparsity than do n -gram mod-els. Furthermore, for token-based representations, these models can potentially handle polysemy better than n -gram statistical language models by providing different features in different contexts. 3.5 A Novel Lattice Statistical Language Model Representation
Our final statistical language model is a novel latent-variable statistical language model, called a Partial Lattice MRF (PL-MRF), with rich latent structure, shown in Figure 3. The model contains a lattice of M  X  N latent states, where N is the number of words in a sentence and M is the number of layers in the model. The dotted and solid lines in the figure together form a complete lattice of edges between these nodes; the PL-MRF uses only the solid edges. Formally, let c = N 2 , where N is the length of the sentence; let i odd, or if j is even and i &gt; c , we delete edges between y lattice. The same set of nodes remains, but the partial lattice contains fewer edges and paths between the nodes. A central  X  X runk X  at i = c connects all layers of the lattice, and branches from this trunk connect either to the branches in the layer above or the layer below (but not both).
 unlike the complete lattice, it supports tractable inference. As M , N every six edges from the complete lattice appear in the PL-MRF. However, the PL-MRF makes the branches conditionally independent from one another, except through the trunk. For instance, the left branch between layers 1 and 2 (( y
Figure 3 are disconnected; similarly, the right branch between layers 2 and 3 (( y and ( y 5,2 , y 5,3 )) are disconnected, except through the trunk and the observed nodes. As y a result, excluding the observed nodes, this model has a low tree-width of 2 (excluding observed nodes), and a variety of efficient dynamic programming and message-passing inference algorithm passes information from the branches inwards to the trunk, and then upward along the trunk, in time O ( K 4 MN ). In contrast, a fully connected lattice model has tree-width = min( M , N ), making inference and learning intractable (Sutton,
McCallum, and Rohanimanesh 2007), partly because of the difficulty in enumerating and summing over the exponentially-many configurations y for a given x .
 capture the multi-dimensional nature of words. Linguists have long argued that words have many different features in a high dimensional space: They can be separately described by part of speech, gender, number, case, person, tense, voice, aspect, mass vs. count, and a host of semantic categories (agency, animate vs. inanimate, physical vs. abstract, etc.), to name a few (Sag, Wasow, and Bender 2003). In the PL-MRF, each layer of nodes is intended to represent some latent dimension of words.
 decompose over cliques in the MRF graph. Let Cliq ( x , y ) represent the set of all maximal cliques in the graph of the MRF model for x and y . Expressing the lattice model in log-linear form, we can write the marginal probability P ( x ) of a given sentence x as: between two adjacent latent variables on layer j :  X  trans also includes observation parameters for latent variables and tokens, as well as for pairs of adjacent latent variables in different layers and their tokens:  X  y = s , y i , j + 1 = s ,and x i = w . 98 tokens and one for types. For tokens, we decode the model to compute y optimal latent state values for sentence x . For each layer j and and each possible latent state value k , we add a boolean feature for token x i that is true iff y types, we compute distributions over the latent state space. Let y be a column vector of latent variables for word type w . For a PL-MRF model with M layers of binary variables, distribution over these 2 M possible values, and uses each probability as a feature for w . 3 We refer to these two representations as L ATTICE -T OKEN respectively.
 iteratively optimizes the following objective function on a corpus X : sentence x . Contrastive estimation seeks to move probability mass away from the per-turbed neighborhood sentences and onto the original sentence. We use a neighborhood function that includes all sentences which can be obtained from the original sentence by swapping the order of a consecutive pair of words. Training uses gradient descent over this non-convex objective function with a standard software package (Liu and Nocedal 1989) and converges to a local maximum or saddle point.
 at a time. Let  X  i represent the set of parameters relating to features of layer i ,andlet  X  i represent all other parameters. We fix  X   X  0 = 0 , and optimize  X  estimation. After convergence, we fix  X   X  1 , and optimize  X  layer, we use a convergence threshold of 10  X  6 on the objective function in Equation (7), and each layer typically converges in under 100 iterations. 4. Domain Adaptation with Learned Representations
We evaluate the representations described earlier on POS tagging and NP chunking tasks in a domain adaptation setting. 4.1 A Rich Problem Setting for Representation Learning
Existing supervised NLP systems are domain-dependent: There is a substantial drop in their performance when tested on data from a new domain. Domain adaptation is the task of overcoming this domain dependence. The aim is to build an accurate system for a target domain by training on labeled examples from a separate source domain. This problem is sometimes also called transfer learning (Raina et al. 2007).
 bated by domain adaptation. New domains come with new words and phrases that with data sparsity. And even for words that do appear commonly in both domains, the contexts around the words will change from the training domain to the target domain.
As a result, domain adaptation adds to the challenge of handling polysemous words, whose meaning depends on context.

We now present several experiments testing our representations against state-of-the-art POS taggers in a variety of domain adaptation settings, showing that the learned representations surpass the previous state-of-the-art, without requiring any labeled data from the target domain. 4.2 Experimental Set-up For domain adaptation, we test our representations on two sequence labeling tasks:
POS tagging and chunking. To incorporate learned representation into our models, we follow this general procedure, although the details vary by experiment and are given in the following sections. First, we collect a set of unannotated text from both the training domain and test domain. Second, we learn representations on the unannotated text.
We then automatically annotate both the training and test data with features from the learned representation. Finally, we train a supervised linear-chain CRF model on the annotated training set and apply it to the test set.
 in which the latent variables form a path with edges only between consecutive nodes in the path, and all latent variables are globally conditioned on the observations. Let X be a random variable over data sequences, and Z be a random variable over corresponding label sequences. The conditional distribution over the label sequence Z given X has the form and the labels at positions i and i  X  1 in the label sequence, and  X  estimated from training data.
 transition and observation. Transition feature functions indicate, for each pair of labels each label l and each feature f provided by a representation, whether z feature f . For each label l and each real-valued feature f in representation R , real-valued observation feature functions have value f ( x )if z i = l , and are zero otherwise. 100 4.3 Domain Adaptation for POS Tagging earlier on an English POS tagging task, trained on newswire text, to tag biomedical re-search literature. We follow Blitzer et al. X  X  experimental set-up. The labeled data consists of the WSJ portion of the Penn Treebank (Marcus, Marcinkiewicz, and Santorini 1993) as source domain data, and 561 labeled sentences (9,576 tokens) from the biomedical research literature database MEDLINE as target domain data (PennBioIE 2005). Fully 23% of the tokens in the labeled test text are never seen in the WSJ training data. The unlabeled data consists of the WSJ text plus 71,306 additional sentences of MEDLINE text (Blitzer, McDonald, and Pereira 2006). As a preprocessing step, we replace hapax legomena (defined as words that appear once in our unlabeled training data) with the special symbol *UNKNOWN* , and do the same for words in the labeled test sets that never appeared in any of our unlabeled training text.
 R, I-H MM -T OKEN -R (between 2 and 8 layers), and L and 20 layers). Each latent node in the I-HMMs had 80 possible values, creating 80 8  X  10 15 possible configurations of the eight-layer I-HMM for a single word. Each node in our PL-MRF is binary, creating a much smaller number (2 configurations for each word in a 20-layer representation. To give the n -gram model the largest training data set available, we trained it on the Web 1Tgram corpus (Brants and Franz 2006). We included the top 500 most common n -grams for each word type, and then used mutual information on the training data to select the top 10,000 most relevant n -gram features for all word types, in order to keep the number of features manageable. We incorporated n -gram features as binary values indicating whether x appeared with the n -gram or not. For comparison, we also report on the performance of
Brown clusters (100, 320, 1,000, and 3,200 possible clusters), following Turian, Ratinov, and Bengio (2010). Finally, we compare against Blitzer, McDonald, and Pereira (2006)
SCL technique, described in Section 2.6, and the standard semi-supervised learning algorithm ASO (Ando and Zhang 2005), whose results on this task were previously reported by Blitzer, McDonald, and Pereira (2006).
 the PL-MRF, 7 layers for the I-HMM, and 3,200 clusters for the Brown clustering. All statistical language model representations outperform the T best representation, the 20-layer L ATTICE -T OKEN -R, reduces error by 47% (35% on
OOV) relative to the baseline T RAD -R, and by 44% (24% on out-of-vocabulary words (OOV)) relative to the benchmark SCL system. For comparison, this model achieved a 96.8% in-domain accuracy on Sections 22 X 24 of the Penn Treebank, about 0.5 percentage point shy of a state-of-the-art in-domain system with more sophisticated supervised learning (Shen, Satta, and Joshi 2007). The B ROWN
Turian, Ratinov, and Bengio (2010) demonstrated performed as well or better than accuracies between the SCL system and the H MM -T OKEN -R. The W
I-H MM -T OKEN -R, and L ATTICE -T OKEN -R all performed quite close to one another, but the I-H MM -T OKEN -R and L ATTICE -T OKEN -R were trained on many orders of magnitude less text. The L SA -R and NB-R outperformed the T not the SCL system. The n -GRAM -R, which was trained on the same text as the other representations except the W EB 1T-n -GRAM -R, performed far worse than the W
EB 1T-n -GRAM -R. of these representations. This is apparent in the difference between W
Rand n -GRAM -R, but it is also true for our other representations. Figure 4 shows the accuracy of a representative subset of our taggers on words not seen in labeled training data, as we vary the amount of unlabeled training data available to the language 102 models. Performance grows steadily for all representations we measured, and none of the learning curves appears to have peaked. Furthermore, the margin between the more complex graphical models and the simpler n -gram models grows with increasing amounts of training data. 4.3.1 Sparsity and Polysemy. We expected that statistical language model represen-tations would perform well in part because they provide meaningful features for sparse and polysemous words. For sparse tokens, these trends are already evident
HMM-based models, tend to outperform models that provide huge numbers of fea-T the n -GRAM -R. The n -GRAM -R X  X  features do not depend on a token type X  X  context at all, and the NB-R X  X  features depend only on the tokens immediately to the right and left of the current word. In contrast, the HMM takes into account all tokens in the surrounding sentence (although the strength of the dependence on more distant words decreases rapidly). Thus the performance of the HMM compared with n -as well as the performance of the L ATTICE -T OKEN produce better features.
 our test data, along with 296 non-polysemous word types. The set of polysemous word
POS tags that began with distinct letters (e.g., VBZ and NNS). An initial set of non-polysemous word types was selected by filtering for types that appeared with just cases of word types that were in fact polysemous within a single part-of-speech, such fewer in all of our unlabeled data, and we define non-sparse word types as those that appear at least 50 times in our unlabeled data. Table 3 shows our POS tagging results on the tokens of our labeled biomedical data with word types matching these four categories.
 a larger margin on polysemous words than on non-polysemous words. The margin between graphical model representations and the W EB creases on polysemous words, except for the NB-R. The W EB of the local context to decide which features to provide, and the NB-R uses only the immediate left and right context, so both models ignore most of the context. In contrast, in the surrounding sentence, which helps to explain their relative improvement over W EB 1T-n -GRAM -R on polysemous words.
 models perform better relative to the W EB 1T-n -GRAM sparse words. By reducing the feature space from millions of possible n -gram fea-be observed often in a reasonably sized training data set. Thus representations based on graphical models help address two key issues in building representations for POS tagging. 4.3.2 Domain Divergence. Besides sparsity and polysemy, Ben-David et al. X  X  (2007, 2010) theoretical analysis of domain adaptation shows that the distance between two domains under a representation R of the data is crucial for a good representation. We test their predictions using learned representations.
 the d 1 divergence, that is computationally intractable to calculate. For our analysis, we resort instead to two different computationally efficient approximations of this measure. The first uses a more standard notion of distance: the Jensen-Shannon Divergence ( d a distance metric for probability distributions: whether features appear more commonly in one domain than in the other. For instance, the biomedical domain is far from the newswire domain under the T sentation because word-based features like protein , gene ,and pathway appear far more commonly in the biomedical domain than the newswire domain. Likewise, bank and president appear far more commonly in newswire text. Since the d to the optimal classifier for distinguishing two domains, it makes sense to measure the distance by comparing the frequencies of these features: a classifier can easily use the occurrence of words like bank and protein to accurately predict whether a given sentence belongs to the newswire or biomedical domain. 104 that f can take on. Let U S be an unlabeled sample drawn from S , and likewise for U T . We first compute the relative frequencies of the different values of f in R ( U
R ( U T ), and then compute d JS between these empirical distributions. Let p empirical distribution over V estimated from observations of feature f in R ( U q represent the same distribution estimated from R ( U T ).
 Definition 1 JS domain divergence for a feature or d f ( U S , U domains S and T under feature f from representation R , and is given by weighted sum over the domain divergences for its features. Because individual features their importance to the overall distance between the domains. We set the weight w for feature f proportional to the L 1 norm of CRF parameters related to f in the trained
POS tagger. That is, let  X  be the CRF parameters for our trained POS tagger, and let  X  = {  X  l , v | l be the state for z i and v be the value for f Definition 2
JS Domain Divergence or d R ( U S , U T ), is the distance between domains S and T under representation R , and is given by divergence, which we also experimented with. He trains a CRF classifier on examples labeled with a tag indicating which domain the example was drawn from. We refer to this type of classifier as a domain classifier . Note that these should not be confused with our CRFs used for POS tagging, which take as input examples which are labeled with POS sequences. For the domain classifier, we tag every token from the WSJ domain as 0, and every token from the biomedical domain as 1. Blitzer then uses the accuracy of his domain classifier on a held-out test set as his measure of domain divergence. A high accuracy for the domain classifier indicates that the representation makes the two domains easy to separate, and thus high accuracy signifies a high domain divergence. To measure domain divergence using a domain classifier, we trained our representations on all of the unlabeled data for this task, as before. We then used 500 randomly sampled sentences from the WSJ domain, and 500 randomly sampled biomedical sentences, and the error rate of our domain-classifier CRF as the average error rate across folds when performing three-fold cross-validation on these 1,000 sentences. Target Domain Tagging Accuracy 20 layer LATTICE 
Figure 6 shows the difference between target-domain error and source-domain error suring domain divergence. These results give empirical support to Ben-David et al. X  X  (2007, 2010) theoretical analysis: Smaller domain divergence X  X hether measured by
JS domain divergence or by the accuracy of a domain classifier X  X orrelates strongly with better target-domain accuracy. Furthermore, smaller domain divergence correlates target domains.
 106 Target Domain approximations of the d 1 metric for domain divergence, they agree very strongly:
In both cases, the L ATTICE -T OKEN -R representations had the lowest domain diver-gence, followed by the I-H MM -T OKEN -R representations, followed by T n -GRAM -R somewhere between L ATTICE -T OKEN -R and I-H MM difference between the two metrics appears to be that the JS domain divergence gives a greater domain divergence to the eight-layer L ATTICE n -GRAM -R, placing them past the four-through eight-layer I-H tations. The domain classifier places these models closer to the other L representations, just past the seven-layer I-H MM -T OKEN gence, remain significantly far from zero, even under the best representation. As a result, there is ample room to experiment with even less-divergent representations of the two domains, to see if they might yield ever-increasing target-domain accuracies. Note that this is not simply a matter of adding more layers to the layered models. The I-H T
OKEN -R model performed best with seven layers, and the eight-layer representation had about the same accuracy and domain divergence as the five-layer model. This may be explained by the fact that the I-HMM layers are trained independently, and so additional layers may be duplicating other ones, and causing the supervised classifier for constraining the domain divergence in our representations X  X he decrease in domain divergence from our more sophisticated representations is a coincidental byproduct of our training methodology, but there is no guarantee that our current mechanisms will continue to decrease domain divergence simply by increasing the number of layers. An important consideration for future research is to devise explicit learning mechanisms that guide representations towards smaller domain divergences. 4.4 Domain Adaptation for Noun-Phrase Chunking and Chinese POS Tagging
We test the generality of our representations by using them for other tasks, domains, and languages. Here, we report on further sequence-labeling tasks in a domain adaptation setting: noun phrase chunking for adaptation from news text to biochemistry journals, and POS tagging in Mandarin for a variety of domains. In the next section, we describe the use of our representations in a weakly supervised information extraction task. source-domain labeled data (Sections 15 X 18 of the WSJ portion of the Penn Treebank, biochemistry journal data from the Open American National Corpus of the authors manually labeled 198 randomly selected sentences (5,361 tokens) from the OANC biochemistry text with noun-phrase chunk information. phrase chunks because they are relatively easy to annotate manually, but contain a large variety of open-class words that vary from domain to domain. The labeled training set consists of 8,936 sentences and 211,726 tokens. Twenty-three percent of chunks in the test set begin with an OOV word (especially adjective-noun constructions like  X  X queous formation X  and  X  X ngular recess X ), and 29% begin with a word seen at most twice in and 45,000 sentences (1,083,000 tokens) from the OANC X  X  biochemistry section. We tested T RAD -R (augmented with features for automatically generated POS tags), L n -
GRAM -R, NB-R, H MM -T OKEN -R, I-H MM -T OKEN -R (7 layers, which performed best for POS tagging) and L ATTICE -T OKEN -R (20 layers) representations.
 performance improvements for the HMM-based chunkers are impressive: L T
OKEN -R reduces error by 57% with respect to T RAD -R, and comes close to state-of-the-art results for chunking on newswire text. The results suggest that this representation allows the CRF to generalize almost as well to out-of-domain text as in-domain text. 108 0.65 0.75 0.85 0.95 Improvements are greatest on OOV and rare chunks, where L absolute improvements over T RAD -R by 0.17 and 0.09 F1, respectively. Improvements for the single-layer H MM -T OKEN -R were smaller but still significant: 36% relative re-duction in error overall, and 32% for OOV chunks.
 how well the chunker could work without some of its other features. We removed all tag features and orthographic features and all features for word types that appear fewer than 20 times in training. This chunker still achieves 0.91 F1 on OANC data, and 0.93
F1 on WSJ data (Section 20), outperforming the T RAD -R system in both cases. It has only 20% as many features as the baseline chunker, greatly improving its training time.
Thus these features are more valuable to the chunker than features from automatically produced tags and features for all but the most common words.
 (Tao and Xiao 2007), which is part of the Lancaster Corpus of Mandarin Chinese (LCMC). The UCLA Corpus consists of 11,192 sentences of word-segmented and POS-tagged text in 13 genres (see Table 4). We use gold-standard word segmentation labels for training and testing. The LCMC tagset consists of 50 Chinese POS tags. On average, each genre contains 5,284 word tokens, for a total of 68,695 tokens among all genres. We use the  X  X ews X  genre as our source domain, which we use for training and development data. For test data, we randomly select 20% of every other genre. For our unlabeled data, we use all of the  X  X ews X  text, plus the remaining 80% of the texts from the other genres. As before, we replace hapax legomena in the unlabeled data with the special symbol *UNKNOWN* , and do the same for word types in the labeled test sets that never appear in our unlabeled training texts. We compare against a state-of-the-art Chinese POS tagger for in-domain text, the CRF-based Stanford tagger (Tseng, Jurafsky, and
Manning 2005). We obtained the code for this tagger, 8 and retrained it on our training data set.
 outperforms the state-of-the-art Stanford tagger on all target domains. Overall, on all out-of-domain tests, L ATTICE -T OKEN -R provides a relative reduction in error of 13.8% compared with the Stanford tagger. The best performance is on the  X  X ystery X  domain, where the L ATTICE -T OKEN -R model reaches 91.3% accuracy, a 3.9 percentage points improvement over the Stanford tagger. Its performance on the in-domain  X  X ews X  test set is significantly worse (1.7 percentage points) than the Stanford tagger, suggesting that the Stanford tagger relies on domain-dependent features that are helpful for tagging news, but not for tagging in general. The L ATTICE -T OKEN cantly worse on out-of-domain text than in-domain text, but the gap between the two (8.3 percentage points) is better than the gap for the Stanford tagger (11.8 percentage points). We believe that the lower out-of-domain performance of our Chinese POS tagger, compared with our English POS tagger and our chunker, was at least in part due to having far less unlabeled text available for this task. 110 5. Information Extraction Experiments semantic, rather than syntactic, information. Specifically, we investigate a set-expansion task in which we X  X e given a corpus and a few  X  X eed X  noun phrases from a semantic category (e.g., Superheroes), and our goal is to identify other examples of the category in the corpus. This is a different type of weakly supervised task from the earlier domain adaptation tasks because we are given only a handful of positive examples from a cate-gory, rather than a large sample of positively and negatively labeled training examples from a separate domain.
 noun phrases for a given semantic class are ranked based on how similar their contex-tual distributions are to those of the seeds. Here, we measure how performance on the set-expansion task varies when we employ different representations for the contextual distributions. 5.1 Methods
The set-expansion task we address is formalized as follows. Given a corpus, a set of seeds from some semantic category C , and a separate set of candidate phrases P , output a ranking of the phrases in P in decreasing order of likelihood of membership in the semantic category C .
 straightforward: We rank candidate phrases in increasing order of the distance between their feature vectors and those of the seeds. The particular distance metrics utilized are detailed subsequently.
 kens, it requires type-based representations. We compare H L
ATTICE -T YPE -R, and B ROWN -T YPE -R in this experiment. We used a 25-state HMM, and the L ATTICE -T YPE -R as described in the previous section. Following previous set-expansion experiments with n -grams (Ahuja and Downey 2010), we use a trigram model with Kneser-Ney smoothing for n -GRAM -R.
 n -
GRAM -R, and L ATTICE -T YPE -R representations are calculated by first creating a distance measure between vectors (in this case, probability distributions), we compute the average of five standard distance measures, including KL and JS divergence, and cosine, Euclidean, and L1 distance. In experiments, we found that improving upon this simple averaging was not easy X  X n fact, tuning a weighted average of the distance measures for each representation did not improve results significantly on held-out data. the similarity between two Brown representation feature vectors to be the number of features they share in common (this is equivalent to the length of the longest common prefix between the two original Brown cluster labels). The candidate phrases are then ranked in decreasing order of the sum of their similarity scores to each of the seeds. We experimented with normalizing the similarity scores by the longer of the two vector similarity scores for Brown clusters in our experiments. 5.2 Data Sets
We utilized a set of approximately 100,000 sentences of Web text, joining multi-word named entities in the corpus into single tokens using the Lex algorithm (Downey,
Broadhead, and Etzioni 2007). This process enables each named entity (the focus of the set-expansion experiments) to be treated as a single token, with a single representation vector for comparison. We developed all word type representations using this corpus.  X  X istOf X  pages from Pantel et al. (2009) and augmented these with our own manually defined categories, such that each list contained at least ten distinct examples occurring in our corpus. In all, we had 432 examples across 16 distinct categories such as Coun-tries, Greek Islands, and Police TV Dramas. 5.3 Results examples, treating the unselected members of the category as positive examples, and all other candidate phrases as negative examples. We evaluate using the area under the precision-recall curve (AUC) metric.
 a random baseline, equal to the average AUC over five random orderings for each category, and the graphical models outperform the n -gram representation. I-H T YPE -R and Brown clustering in the particular case of 1,000 clusters perform best, with H
MM -T YPE -R performing nearly as well. Brown clusters give somewhat lower results as the number of clusters varies.
 performance on the IE task by providing informative features for sparse word types.
However, because the IE task classifies word types rather than tokens, we expect the rep-resentations to provide less benefit for polysemous word types. To test these hypotheses, we measured how IE performance changed in sparse or polysemous settings. We identi-fied polysemous categories as those for which fewer than 90% of the category members had the category as a clear dominant sense (estimated manually); other categories were considered non-polysemous. Categories whose members had a median number of occurrences in the corpus of less than 30 were deemed sparse, and others non-sparse. 112 model representations outperform the n -gram representation more on sparse words, as expected. For polysemy, the picture is mixed: The L n -G RAM -R on polysemous categories, whereas HMM-T YPE tage over n -G RAM -R decreases.
 well than the H MM -T YPE -R, whereas the reverse is true on POS tagging. We suspect that the difference is due to the issue of classifying types vs. tokens. Because of their more complex structure, PL-MRFs tend to depend more on transition parameters than do HMMs. Furthermore, our decision to train the PL-MRFs using contrastive estimation with a neighborhood that swaps consecutive pairs of words also tends to emphasize transition parameters. As a result, we believe the posterior distribution over latent states given a word type is more informative in our HMM model than the PL-MRF model. H ( P PL-MRF ( y | x = w )) = 9 . 95 bits, compared with H ( P supports the hypothesis that the drop in the PL-MRF X  X  performance on IE is due to its dependence on transition parameters. Further experiments are warranted to investigate this issue. 5.4 Testing the Language Model Representation Hypothesis in IE
The language model representation hypothesis (Section 2) suggests that all else being equal, more accurate language models will provide features that lead to better perfor-mance on NLP tasks. Here, we test this hypothesis on the set expansion IE task. language modeling accuracy of the underlying HMM. Language modeling accuracy is measured in terms of perplexity on held-out text. Here, we use set expansion data sets from previous work (Ahuja and Downey 2010). The first two are composed of extractions from the TextRunner information extraction system (Banko et al. 2007) and are denoted as Unary (361 examples) and Binary (265 examples). The second, Wikipedia (2,264 examples), is a sample of Wikipedia concept names. We evaluate the performance of several different trained HMMs with numbers of latent states K ranging from 5 to 1,600 (to help illustrate how IE and LM performance varies even when model capacity is fixed, we include three distinct models with K = 100 states trained separately over the full corpus). We used a distributed implementation of HMM training and corpus partitioning techniques (Yang, Yates, and Downey 2013) to enable training of our larger capacity HMM models on large data sets.
 showing that IE performance does tend to improve as language model perplexity decreases. On the smaller Unary and Binary sets (Figure 10), although IE accuracy 114 does decrease for the lowest-perplexity models, overall language model perplexity exhibits a negative correlation with IE area under the precision-recall curve (the Pearson correlation coefficient is  X  0 . 18 for Unary, and  X  0 . 28 for Binary). For Wikipedia (Fig-correlation coefficient is  X  0 . 90).
 mance correlates most strongly with model perplexity (  X  0 . 68 Pearson correlation,
Spearman correlation), followed by corpus size (0.66, 0.71) and model capacity ( 0.38). The small negative Pearson correlation between model capacity and IE perfor-
This model has a large parameter space and sparse training data, and thus suffers from overfit model, the Pearson correlation between model capacity and IE performance for the other models in the Figure is 0.24.
 quality of the latent variable model used to measure distributional similarity improves.
A similar trend was exhibited in our previous work (Ahuja and Downey 2010); here, we extend the previous results to models with more latent states and a larger, more reliable test set (Wikipedia). The results suggest that scaling up the training of latent variable direction for improving IE capabilities. 6. Conclusion and Future Work
Our study of representation learning demonstrates that by using statistical language models to aggregate information across many unannotated examples, it is possible to find accurate distributional representations that can provide highly informative features to weakly supervised sequence labelers and named-entity classifiers. For both domain adaptation and weakly supervised set expansion, our results indicate that graphical models outperform n -gram models as representations, in part for their greater ability to handle sparsity and polysemy. Our IE task provides important evidence to support the
Language Model Representation Hypothesis, showing that the AUC of the IE system correlates more with language model perplexity than the size of the training data or the capacity of the language model. Finally, our sequence labeling experiments provide empirical evidence in support of theoretical work on domain adaptation, showing that target-domain tagging accuracy is highly correlated with two different measures of domain divergence.
 ments in various NLP tasks. The representations we have described are trained in an unsupervised fashion, so a natural extension is to investigate supervised or semi-supervised representation-learning techniques. As mentioned previously, our current techniques have no built-in methods for enforcing that they provide similar features in different domains; devising a mechanism that enforces this could allow for less domain-divergent and potentially more accurate representations. We have considered sequence labeling, but another promising direction is to apply these techniques to more complex structured prediction tasks, like parsing or relation extraction. Our current approach to sequence labeling requires retraining of a CRF for every new domain; incremental retraining techniques for new domains would speed up the process. Finally, models that combine our representation learning approach with instance weighting and other forms of supervised domain adaptation may take better advantage of labeled data in target domains, when it is available.
 Acknowledgments References 116 118
