 The problem of decentralized data sharing is relevant for a wide range of applications and is still a source of major the-oretical and practical challenges, in spite of many years of sustained research in information integration. We focus on the challenge of efficiency of query evaluation in information-integration systems, with the objective of developing query-processing strategies that are widely applicable and easy to implement in real-life applications. In our algorithms we take into account important features of today X  X  data-sharing applications, namely: XML as likely interface to or repre-sentation for data sources; potential for information overlap across data sources; and the need for inter-source processing (i.e., joins of data across data sources) in many applications.
To the best of our knowledge, our methods are the first to account for the practical issues of information overlap across data sources and of inter-source processing. While most of our algorithms are platform-and implementation-independent, we also propose XML-specific optimization tech-niques that allow for system-level tuning of query process-ing performance. Finally, using real-life datasets and our implementation of an information-integration system shell, we provide experimental results that demonstrate that our algorithms are efficient and competitive in the information-integration setting. For all the details, please see [1]. Categories and Subject Descriptors: H.2.4 [Database Management]: Systems X  Query Processing General Terms: Algorithms, Performance, Design
This section outlines our basic query-processing algorithms for information integration. (Please see [1] for the details.) All our algorithms, with the exception of semantic opti-mization for XQuery (see Section 1.4), are platform-and implementation-independent. To the best of our knowledge, our methods are the first that account for information over-lap across data sources, as well as for inter-source processing.
This approach is based on generating and executing local and inter-source subqueries for the user query, and merging their results to obtain the query answer. A local subquery is executed on data from a single source, while an inter-source subquery is executed on data from multiple sources.

Example 1. Consider a system with four information sources and a mediator. Query Q =  X  B,C  X  P ( r 1 s ) in-volves relations r ( A,B ) and s ( A,C ) in the mediator schema. Assume XML data sources with different schemas; Figure 1 shows some of the data in two of the sources. Figure 1: Part of information in two data sources.

Given the query Q , we have (up to) 4 2 = 16 subqueries, 1 namely,  X  B,C  X  P ( r i ./ s j ) ,i,j = 1 ,..., 4 , where r sents the fragment of r that is contributed by source i . Only four of these subqueries,  X  B,C  X  P ( r i ./ s i ) ,i = 1 ,..., 4 , are local; the remaining twelve are inter-source subqueries. The local subqueries are translated to queries on the source schemas and executed locally; the results are sent to the me-diator. For an inter-source subquery such as  X  B,C  X  P ( r s ) , either the data for r 1 is sent to Source 2, or the data for s is sent to Source 1. (We have implemented [4] algorithms for data transmission and subquery execution for XML data sources.) Finally, the mediator merges all partial results in order to obtain the final answer to the user query.
The optimized-subquery approach uses our formal results to eliminate, to the extent possible, inter-source processing. Based on key and foreign-key constraints that are relevant to the query, all or some of inter-source subqueries may be redundant and will not be evaluated. The savings can be
If source i has no data for relation r then all subqueries involving fragment r i are empty and need not be executed. substantial; for instance, given a query involving k mediator-based relations in a system with n data sources, there are only n local subqueries, while the number of inter-source subqueries can be as large as n k  X  n ; see [1] for the details.
Example 2. In the setting of Example 1, suppose that attribute A is the key for r and that a foreign-key constraint holds from s.A to r.A . Then, by our formal results [1], no inter-source processing is needed. This reduces the processing from sixteen to four (all local) subqueries that are translated and executed locally on the data sources.
In the wrapper approach, we generate only one local query per data source; the query extracts from the source the minimum amount of information that is needed to answer the user query. This extraction can be viewed as a (query-specific) wrapper that collects the needed information from each source. Compared to the approaches based on sub-queries, the information extracted from each source in the wrapper approach is richer than the result of the local sub-query on the same source, thus making it possible to obtain the full answer to the user query by further processing. In-tuitively, the information collected by the local (wrapper) query corresponds to the full outer-join of the relations in-volved. In a large class of applications, an efficient chase -based algorithm [9] can be applied to the extracted informa-tion to obtain the full answer to the user query.
 Example 3. Consider the user query  X  B,C  X  P ( r ./ s ) of Example 1. Suppose that A is the key of r , but no foreign-key constraint holds from s to r (thus, according to our formal results, inter-source processing is needed.) In the wrapper approach, each source i generates a relation t i ( A,B,C ) cor-responding to the full outer-join of r i and s i and sends it to the mediator. The mediator combines the relations, applies chase, and enforces the query conditions and projections. In our example, Source 1 (see Figure 1) has the following tuples (among others): (a1, b1) and (a2, b2) for r 1 , and (a1, c1) and (a1, c2) for s 1 . Hence t 1 contains (a1, b1, c1), (a1, b1, c2), and (a2, b2, null). Source 2 has tuple (a3, b3) for r and tuples (a2, c3) and (a3, c4) for s 2 . Then t (a2, null, c3) and (a3, b3, c4). The result of unioning t and t 2 and chasing w.r.t. the key constraint generates a new tuple (a2, b2, c3) in the result. The final step is to enforce predicate P and to project onto output attributes B,C . The answer contains (b2, c3) (unless filtered out by P ).
Note that in the subquery-based approaches (Sections 1.1 X  1.2), the answer (b2, c3) of Example 3 is generated by inter-source subquery  X  B,C  X  P ( r 1 ./ s 2 ). Thus, while executing only local queries, the wrapper approach is able to generate at the mediator the results of inter-source subqueries.
In the approaches presented in Sections 1.1 X 1.3, the sys-tem generates queries to be executed on local data (e.g., XQuery queries on XML data). In our implementation frame-work of [4], the resulting queries tend to have a large number of variables resulting in performance degradation. This phe-nomenon can occur in any system that automatically gen-erates XQuery queries. Our platform-specific semantic opti-mization rewrites XQuery queries into more efficient equiva-lent queries with fewer joins and variables. The effect of our semantic optimization can be significant (up to two orders of magnitude for certain queries); please see [1] for the details.
In this section we outline the results of our evaluation of the impact of our query-processing techniques on query performance in our information-integration system shell [4]. Our experimental results (see [1] for a full report) demon-strate that our algorithms are efficient and competitive.
We carried out extensive experiments on different datasets and queries. In these experiments we used the setup of [8], with the modification that in addition to the queries used in [8] we defined extra queries that would require more inter-source processing. The setup includes the  X  X B-research X  dataset, which contains data sources pertaining to several universities, research organizations, and publication infor-mation from sources such as CiteSeer [2], DBLP [3], and SIGMOD [7]. Please see [1] for the details.

The experiments were executed using PostgreSQL [5] ver-sion 8.1.3 and SAXON [6] version 8 on a 2.0 GHz Pentium M computer with 768 MB memory and 40 GB hard disk running Windows XP Pro.

Figure 2 illustrates the performance of our algorithms for the DB-Research dataset experiments.
 Figure 2: Experimental results for DB-Research.

The X-axis lists the queries, and the Y-axis the respective execution times in milliseconds. For each query, we show the running times for four algorithms. The materialization is the baseline algorithm using naive materializtion of the me-diator view and is included for comparison. The three other algorithms are the subqueries, optimized subqueries and the wrapper algorithms with semantic optimization (marked by the asterisk *) as discussed in Section 1. As shown, the Subqueries* and Optimized-Subqueries* techniques seem to be the algorithms of choice for most cases. Sometimes (e.g., for Q 4) the Wrapper* method is more efficient than Optimized Subqueries* , in cases where the data are very regular at each source, and each source contributes to all relations in the query.
