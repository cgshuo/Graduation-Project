 1. Introduction
The Semantic Web [7,47] has recently gained tremendous momentum due to its great potential for providing a common to be matched over RDF graphs.
 use a relational database management system (RDBMS) as a backend to manage RDF data. The main advantage of the as SPARQL query solutions.

We identify three goals of SPARQL-to-SQL translation that are very important to achieve: relational models, in general, and between SPARQL and SQL, in particular. cient SQL queries. Our main contributions are summarized in the following: which is used to establish the equivalence relationship 2 tation and a mapping-based representation.
 used to establish the equivalence relationship between a relation produced by the relational algebra based SPARQL straints. trans is the first provably semantics preserving translation in the literature. oso, DLDB, RDFSuite, DBOWL, PARKA, RDFProv, and RDFBroker.
 ries, and extend eval and trans to support the bag semantics of a SPARQL query solution. schema dependent translations and how our proposed simplifications affect query performance. and b , that are first defined at the data level and later passed as parameters to the translation. sible future work. 2. Related work vances in RDF store design.
 Based on database schemas employed by existing relational RDF stores, we can classify them into four categories: of RDF schema or ontology evolution, since it employs a generic database representation.
Clustered(s ; o 1 ; o 2 ; ... ; o n ) , which stores subjects s and objects o h sp [1].
 expensive.
 of the hybrid and schema-aware approaches.
 proaches. Several data mapping strategies and algorithms are presented in [12]. include [66,36,32,4] .
 patterns which are not well-designed.
 queries.
 called nested optional join , that shows better performance than conventional left outer join implementations. pose a framework for developing such benchmarks. 3. Preliminaries overview of the mapping-based semantics [39] of SPARQL. 3.1. Syntax of SPARQL and RDF pattern, and SPARQL query.
 predicate, and object, respectively. An RDF graph G is a set of RDF triples. note IRIs, and rectangles denote literals.
 We focus on the core fragment of SPARQL defined in the following.
 subject pattern, predicate pattern, and object pattern, respectively.
 Definition 3.3 ( Graph pattern ). A graph pattern gp is defined by the following abstract grammar: where AND , OPT , and UNION are binary operators that correspond to SPARQL conjunction, ments of the set IVL , constants, logical connectives ( : , _ , ^ ), inequality symbols ( &lt; , appear in gp .

Definition 3.4 ( SPARQL query ). A SPARQL query sparql is defined as SPARQL queries that can be generated by the defined grammar.
 we present in this article, are fully applicable to blank nodes without any modification. 3.2. An overview of the mapping-based semantics of SPARQL the mapping-based semantics of SPARQL defined in [39].
 represents a SPARQL query solution.
 is represented as follows: is the result of successful match of the triple pattern  X  ? a ; email ; ? e  X  against triple  X  B of successful match of the triple patterns  X  ? a ; email ; ? e  X  and  X  ? a ; web ; ? w  X  against triples  X  B  X  B ; web ; www : starr : edu  X  , respectively.

Two mappings l 1 and l 2 are compatible when for all x 2 dom  X  l with disjoint domains are always compatible; and l ; is compatible with any other mapping. Let X pings. In [39], the following operators (join, union, difference, and left outer join) are defined between X X 1 ffl X 2  X f l 1 [ l 2 j l 1 2 X 1 ; l 2 2 X 2 are compatible mappings}, X 1 [ X 2  X f l j l 2 X 1 or l 2 X 2 g , X 1 n X 2  X f l 2 X 1 j for all l 0 2 X 2 ; l and l 0 are not compatible}, X 1 : ffl X 2  X f X 1 ffl X 2  X  X [ X 1 n X 2  X  X g .
 The mapping-based semantics of SPARQL is defined as a function s t define the evaluation of triple pattern tp , gp 1 AND gp is available in [39].
 based semantics of SPARQL. However, formalizing such a semantics is challenging because: relational representation of a SPARQL query solution is required.
 arbitrary duplicate relational attributes, which are disallowed in the relational model. that must be eliminated.
 relational schema. A different mechanism is needed to deal with this situation. 4. Relational algebra based semantics of SPARQL semantics of SPARQL and prove its equivalence to the mapping-based semantics. Definition 4.1 ( Relational representation of a SPARQL query solution ). Let a tuple r : IVL ! IBL [f itself or to NULL , and a variable is mapped to an element of set IBL [f SPARQL query solution.
 r is the result of successful match of the triple pattern  X  ? a ; email ; ? e  X  against triple  X  B of successful match of the triple patterns  X  ? a ; email ; ? e  X  and  X  ? a ; web ; ? w  X  against triples  X  B  X  B ; web ; www : starr : edu  X  , respectively.
 follows.
 x 2 n  X  r  X  , x 2 V and r  X  x  X  is not NULL , then x 2 dom  X  l  X  and l  X  x  X  X  r  X  x  X  . between SPARQL query solutions when different representations are used. verify that k  X  R  X  X
R and genPR , in the following.
 relational attribute c R n  X  R  X  = f a ; b g , the relational operator y attribute c in the following way: for each tuple r 2 R ,if r  X  a  X  is not We show that y can be derived from existing relational operators.

Theorem 4.6. Relational operator y can be derived from existing relational operators as follows:
The proof of Theorem 4.6 is available in [15].
Example 4.7 ( Relational operator y ). Consider the following evaluation of y Further, we extend the definition of the y operator to multiple attribute pair merging.
Definition 4.8 ( Extended relational operator y ). Given a relation R with schema n  X  R  X  , n pairs  X  a c ; c 2 ; ... ; c n R n  X  R  X  = f a 1 ; b 1 ; a 2 ; b 2 ; ... ; a
Example 4.9 ( Function genCond ). Given triple patterns tp following conditions for tp 1 and tp 2 to match t :
For triple t  X  X  B 2 ; email ; john @ john : edu  X  , genCond  X  tp
For triple t  X  X  B 2 ; email ; john @ john : edu  X  , genCond  X  tp therefore, tp 2 does not match t .
 renaming, the schema of the resulting relation does not have duplicate attribute names. additional triple  X  B 5 ; email ; B 5  X  . Given triple patterns tp following relational algebra expressions:
Let relation R store the subset of triples of G that match tp follows: explained in the following.
 the new relation R 2 is created. Finally, R 2 is assigned as a solution to the triple pattern.
Example 4.11 ( Rule 7: eval  X  tp ; G  X  ). The evaluation of the triple pattern tp follows:
Rule 8 defines the evaluation of the AND of two graph patterns gp and R 2  X  eval  X  gp 2 ; G  X  . The join condition ensures that for every pair of common relational attributes R a 2 n  X  R 1  X \ n  X  R 2  X  , their values are equal R 1 : a i dant attributes of the join-resulting relation into one, such that out of each pair of attributes ( R jected and renamed into a i . R 1 : a i is projected for those tuples whose corresponding value is not projected. Other attributes of R 1 and R 2 are projected per se.

Example 4.12 ( Rule 8: eval  X  gp 1 AND gp 2 ; G  X  ). Given triple patterns tp evaluation of the graph pattern  X  tp 1 AND tp 2  X  over the RDF graph G in Fig. 2 is as follows. Let eval  X  tp 4.11) and eval  X  tp 2 ; G  X  X  R 2 (see Example 4.11), then
Rule 9 defines the evaluation of the OPT of two graph patterns gp
R respectively.

Example 4.13 ( Rule 9: eval  X  gp 1 OPT gp 2 ; G  X  ). Given triple patterns tp of the graph pattern  X  tp 1 OPT tp 2  X  over the RDF graph G in Fig. 2 is as follows. Let eval  X  tp eval  X  tp 2 ; G  X  X  R 2 (see Example 4.11 ), then
Rule 10 defines the evaluation of the UNION of two graph patterns gp
R computes the union of the resulting relations [18].If R 1 is equivalent to the relational union, i.e. R 1 ] R 2 R 1
Example 4.14 ( Rule 10: eval  X  gp 1 UNION gp 2 ; G  X  ). Given triple patterns tp evaluation of the graph pattern  X  tp 1 UNION tp 2  X  over the RDF graph G in Fig. 2 is as follows. Let eval  X  tp eval  X  tp 2 ; G  X  X  R 2 , then
R follows. Let eval  X  gp ; G  X  X  R (see Example 4.13), then
Finally, Rule 12 defines the evaluation of a SPARQL query as the projection of specified variables v relation corresponding to the evaluation of the query graph pattern gp .
Example 4.16 ( Rule 12: eval  X  SELECT  X  v 1 ; v 2 ; ... ; v RDF graph G in Fig. 2 is as follows. Let eval  X  gp ; G  X  X  R (see Example 4.13 ), then
SPARQL query Q i below and the RDF graph G in Fig. 2 , one can verify that k  X  eval  X  Q based semantics of SPARQL defined in [39].
 OPTIONAL s.

R 1  X  eval  X  X  ? a ; name ; ? n  X  ; G  X  X f X  B 1 ; name ; paul  X  ;  X  B
R 2  X  eval  X  X  ? a ; email ; ? e  X  ; G  X  X f X  B 2 ; email ; john @ john : edu  X  ;  X  B
R 3  X  eval  X  X  ? a ; web ; ? w  X  ; G  X  X f X  B 3 ; web ; www : george : edu  X  ;  X  B
R 4  X  eval  X  X  ? a ; name ; ? n  X  OPT  X  ? a ; email ; ? e  X  ; G  X  X y paul ; NULL ; NULL  X  ;  X  B 2 ; name ; john ; email ; john @ john : edu  X  ;  X  B ringo : edu  X g
R 1  X  eval  X  X  ? a ; name ; ? n  X  ; G  X  X f X  B 1 ; name ; paul  X  ;  X  B
R 2  X  eval  X  X  ? a ; email ; ? ew  X  ; G  X  X f X  B 2 ; email ; john @ john : edu  X  ;  X  B
R 3  X  eval  X  X  ? a ; web ; ? ew  X  ; G  X  X f X  B 3 ; web ; www : george : edu  X  ;  X  B
R 4  X  eval  X  X  ? a ; name ; ? n  X  OPT  X  ? a ; email ; ? ew  X  ; G  X  X  y paul ; NULL ; NULL  X  ;  X  B 2 ; name ; john ; email ; john @ john : edu  X  ;  X  B edu  X g The third query includes two OPT operators that correspond to the case of so called nested
R 1  X  eval  X  X  ? a ; name ; ? n  X  ; G  X  X f X  B 1 ; name ; paul  X  ;  X  B
R 2  X  eval  X  X  ? a ; email ; ? e  X  ; G  X  X f X  B 2 ; email ; john @ john : edu  X  ;  X  B
R 3  X  eval  X  X  ? a ; web ; ? w  X  ; G  X  X f X  B 3 ; web ; www : george : edu  X  ;  X  B
R 4  X  eval  X  X  ? a ; email ; ? e  X  OPT  X  ? a ; web ; ? w  X  ; G  X  X  y john @ john : edu ; NULL ; NULL  X  ;  X  B 4 ; email ; ringo @ ringo : edu ; web ; www : starr : edu  X g george  X  .
 R 1  X  eval  X  X  ? x ; name ; paul  X  ; G  X  X f X  B 1 ; name ; paul  X g R 2  X  eval  X  X  ? y ; name ; george  X  ; G  X  X f X  B 3 ; name ; george  X g
R 3  X  eval  X  X  ? x ; email ; ? z  X  ; G  X  X f X  B 2 ; email ; john @ john : edu  X  ;  X  B
R 4  X  eval  X  X  ? y ; name ; george  X  OPT  X  ? x ; email ; ? z  X  ; G  X  X  X  R george ; B 4 ; email ; ringo @ ringo : edu  X g UNION contain the same variables ? a and ? p , while differ in predicate patterns phone and cell .
R 1  X  eval  X  X  ? a ; name ; ? n  X  ; G  X  X f X  B 1 ; name ; paul  X  ;  X  B
R 2  X  eval  X  X  ? a ; phone ; ? p  X  ; G  X  X f X  B 1 ; phone ; 111 1111  X  ;  X  B R 3  X  eval  X  X  ? a ; cell ; ? p  X  ; G  X  X f X  B 4 ; phone ; 444 4444  X g
R 4  X  eval  X  X  ? a ; phone ; ? p  X  UNION  X  ? a ; cell ; ? p  X  ; G  X  X  R  X  B 4 ; NULL ; 444 4444 ; cell  X g
The above examples illustrate that our proposed semantics eval provides the same solutions as the mapping-based is equivalent to the mapping-based semantics s t defined in [39] under the interpretation function k . k  X  eval  X  sparql ; G  X  X  s sparql t G .
 The proof of Theorem 4.18 is available in [15].

The presented relational algebra based semantics of SPARQL provides an important bridge between Semantic Web and 5. Semantics preserving SPARQL-to-SQL translation lation is semantics preserving with respect to the relational algebra based semantics of SPARQL. S for which both a and b are many-to-one mappings.
 relation in which all the triples that may match tp are stored.
 tion pos .
 An example of mappings a and b for different RDBMS-based RDF store schemes is presented in the following. store RDF triples. For the RDF graph G in Fig. 2 , the relation is as follows:
In this case, for any triple pattern tp , a  X  tp  X  X  Triple
P  X  s ; p ; o  X  , where p i is a particular predicate (property). Each relation P predicate value p i , e.g., and similarly for P web and P cell .

In this case, a and b can be calculated as follows. For any triple pattern tp ,if tp : pp R V , then a  X  tp  X  X  P a  X  tp  X  X  Triple ; b  X  tp ; sub  X  X  s , b  X  tp ; pre  X  X  p , and b  X  tp ; obj  X  X 
Finally, consider an RDBMS-based RDF store that employs relation Triple(s,p,o) , property relations P called subject relations S s j and object relations O o k result of partitioning relation Triple based on a subject (object) value s and so forth.

In this case, a and b can be calculated as follows. For any triple pattern tp ,if tp : sp R V , then a  X  tp  X  X  P tp : op R V , then a  X  tp  X  X  P tp : op , otherwise if tp : pp R V , then a  X  tp  X  X  P b  X  tp ; pre  X  X  p , and b  X  tp ; obj  X  X  o .
 that we should address as described in the following.
 Virtuoso, DBOWL, and the schema-oblivious version of RDFProv.

P  X  s ; p ; o  X  , where p i is a particular predicate (property), are usually simplified as P codes the name of the predicate p i and attribute p , which always stores the value of p ply ignoring undefined values in SQL projection lists and join/selection conditions. simplicity of presentation.
 fined genCond and genPR , but generate expressions in SQL syntax.
 tp : sp  X  tp : op and tp : op  X  tp : pp .

Example 5.4 ( Function genCond -SQL ). Given triple patterns tp defined as b  X  tp ; sub  X  X  s , b  X  tp ; pre  X  X  p , and b  X  tp ; obj  X  X  projection and renaming, the schema of the resulting relation does not have duplicate attribute names.
Example 5.5 ( Function genPR -SQL ). Given triple patterns tp and name  X  email  X  X  email ), genPR -SQL generates the following SQL strings: In the rest of the examples in this section, we assume that for any triple pattern tp , a  X  tp  X  X  expressions of the form  X  X  True And subexpression  X  are simplified as  X  X  subexpression  X . Fig. 7 and is explained in the following.
 matching tuple must satisfy the condition generated by genCond -SQL  X  tp ; b  X  in the SQL clause.

Rule 14 defines the translation of the AND of two graph patterns gp respond to graph pattern translations trans  X  gp 1 ; a ; b  X  and rans  X  gp join condition ensures that common attributes r 1 : name  X  c  X  and r relations are projected per se and (2) common attributes are projected as
The SQL construct Coalesce , similar to the y operator, returns the value of r r name  X  c  X  .

Example 5.7 ( Rule 14: trans  X  gp 1 AND gp 2 ; a ; b  X  ). Given triple patterns tp translation of the graph pattern gp  X  X  tp 1 AND tp 2  X  into SQL is as follows:
Rule 15 defines the translation of the OPT of two graph patterns gp correspond to graph pattern translations trans  X  gp 1 ; a The join condition in the On clause and the projection in the
Example 5.8 ( Rule 15: trans  X  gp 1 OPT gp 2 ; a ; b  X  ). Given triple patterns tp translation of the graph pattern gp  X  X  tp 1 OPT tp 2  X  into SQL is as follows:
Rule 16 defines the translation of the UNION of two graph patterns gp sented by the two SQL statements. The first statement left outer joins relations r on the false condition, resulting in a relation with the tuples of r statement left outer joins relations r 3  X  trans  X  gp 2 ; with the tuples of r 3 NULL -padded to schema n  X  r 3  X [ n  X  r statement and so forth. In particular, unique attributes of trans  X  gp  X  terms  X  gp 1  X  terms  X  gp 2  X  X  , are projected at first; unique attributes of trans  X  gp set  X  terms  X  gp 2  X  terms  X  gp 1  X  X  , are projected at second; and common attributes of trans  X  gp correspond to elements of ordered set  X  terms  X  gp 1  X \ terms  X  gp
Example 5.9 ( Rule 16: trans  X  gp 1 UNION gp 2 ; a ; b  X  ). Given triple patterns tp translation of the graph pattern gp  X  X  tp 1 UNION tp 2  X  into SQL is as follows: based on condition transexpr  X  expr  X  . The transexpr translation procedure is described in Fig. 7 . trans  X  gp ; a ; b  X  X  q (see Example 5.8 ), then
Finally, Rule 18 defines the translation of a SPARQL query with graph pattern gp and projection list v projection of relational attributes name  X  v 1  X  ; name  X  v
Example 5.11 ( Rule 18: trans  X  SELECT v 1 ; v 2 ; ... ; v trans  X  gp ; a ; b  X  X  q (see Example 5.8 ), then Additionally, we present the translation of several SPARQL queries whose evaluation is described in Example 4.17. Example 5.12 ( SPARQL-to-SQL translation ). As before, we assume an RDBMS-based RDF store with a single relation a  X  tp  X  X  Triple , b  X  tp ; sub  X  X  s , b  X  tp ; pre  X  X  p , and b  X  tp ; obj  X  X  The following are sample SPARQL queries and their SQL counterparts:
Q 1 : SELECT ?a, ?n, ?e, ?w WHERE (((?a, name, ?n) OPT (?a, email, ?e)) OPT (?a, web, ?w)). q 1  X  trans((?a, name, ?n), a ; b  X  X 
Select Distinct s As a, p As name, o As n From Triple Where p= X  X ame X  q 2  X  trans((?a, email, ?e), a ; b  X  X 
Select Distinct s As a, p As email, o As e From Triple Where p= X  X mail X  q 3  X  trans((?a, web, ?w), a ; b  X  X 
Select Distinct s As a, p As web, o As w From Triple Where p  X   X  X eb X  q 4  X  trans(((?a, name, ?n) OPT (?a, email, ?e)), a ; b  X  X  Select Distinct name,n,email,e,Coalesce(r1.a,r2.a) As a
From ( q 1 ) r1 Left Outer Join ( q 2 ) r2 On (r1.a=r2.a Or r1.a Is Null Or r2.a Is Null) trans  X  Q 1 ; a ; b  X  X  Select Distinct a,n,e,w From ( Select Distinct name,n,email,e,web,w,Coalesce(r3.a,r4.a) As a From ( q 4 ) r3 Left Outer Join ( q 3 ) r4 On (r3.a=r4.a Or r3.a Is Null Or r4.a Is Null)) r5
Q 2 : SELECT ?a, ?n, ?ew WHERE (((?a, name, ?n) OPT (?a, email, ?ew)) OPT (?a, web, ?ew)). q 1  X  trans((?a, name, ?n), a ; b  X  X 
Select Distinct s As a, p As name, o As n From Triple Where p= X  X ame X  q 2  X  trans((?a, email, ?ew), a ; b  X  X 
Select Distinct s As a,p As email,o As ew From Triple Where p = X  X mail X  q 3  X  trans((?a, web, ?ew), a ; b  X  X 
Select Distinct s As a, p As web, o As ew From Triple Where p = X  X eb X  q 4  X  trans(((?a, name, ?n) OPT (?a, email, ?ew)), a ; b  X  X  Select Distinct name,n,email,ew,Coalesce(r1.a,r2.a) As a
From ( q 1 ) r1 Left Outer Join ( q 2 ) r2 On (r1.a  X  r2.a Or r1.a Is Null Or r2.a Is Null) trans  X  Q 2 ; a ; b  X  X  Select Distinct a,n,ew From ( Select Distinct name,n,email,web,Coalesce(r3.a,r4.a) As a, Coalesce(r3.ew,r4.ew) As ew From ( q 4 ) r3 Left Outer Join ( q 3 ) r4 On ((r3.a  X  r4.a Or r3.a Is Null Or r4.a Is Null) And (r3.ew=r4.ew Or r3.ew Is Null Or r4.ew Is Null))) r5
Q 3 : SELECT ?a, ?n, ?e, ?w WHERE ((?a, name, ?n) OPT ((?a, email, ?e) OPT (?a, web, ?w))). q 1  X  trans((?a, name, ?n), a ; b  X  X 
Select Distinct s As a, p As name, o As n From Triple Where p= X  X ame X  q 2  X  trans((?a, email, ?e), a ; b  X  X 
Select Distinct s As a, p As email, o As e From Triple Where p= X  X mail X  q 3  X  trans((?a, web, ?w), a ; b  X  X 
Select Distinct s As a, p As web, o As w From Triple Where p = X  X eb X  q 4  X  trans(((?a, email, ?e) OPT (?a, web, ?w )), a ; b  X  X  Select Distinct email,e,web,w,Coalesce(r1.a,r2.a) As a
From ( q 2 ) r1 Left Outer Join ( q 3 ) r2 On (r1.a  X  r2.a Or r1.a Is Null Or r2.a Is Null) trans  X  Q 3 ; a ; b  X  X  Select Distinct a,n,e,w From ( Select Distinct name,n,email,e,web,w,Coalesce(r3.a,r4.a) As a From ( q 1 ) r3 Left Outer Join ( q 4 ) r4 On (r3.a  X  r4.a Or r3.a Is Null Or r4.a Is Null)) r5
Q 4 : SELECT ?x, ?y, ?z WHERE ((?x, name, paul) OPT ((?y, name, george) OPT (?x, email, ?z))). q 1  X  trans((?x, name, paul), a ; b  X  X 
Select Distinct s As x, p As name, o As paul From Triple Where p= X  X ame X  And o= X  X aul X  q 2  X  trans((?y, name, george), a ; b  X  X 
Select Distinct s As y, p As name, o As george From Triple Where p= X  X ame X  And o= X  X eorge X  q 3  X  trans((?x, email, ?z), a ; b  X  X 
Select Distinct s As x, p As email, o As z From Triple Where p= X  X mail X  q 4  X  trans(((?y, name, george) OPT (?x, email, ?z )), a ; b  X  X 
Select Distinct y,name,george,x,email,z From ( q 2 ) r1 Left Outer Join ( trans  X  Q 4 ; a ; b  X  X  Select Distinct x,y,z From ( Select Distinct paul,y,george,email,z,Coalesce(r3.x,r4.x) As x, Coalesce(r3.name,r4.name) As name From ( q 1 ) r3 Left Outer Join ( q 4 ) r4 On ((r3.x=r4.x Or r3.x Is Null Or r4.x Is Null) And (r3.name=r4.name Or r3.name Is Null Or r4.name Is Null))) r5
Q 5 : SELECT ?a, ?n, ?p WHERE ((?a, name, ?n) AND ((?a, phone, ?p) UNION (?a, cell, ?p))). q 1  X  trans((?a, name, ?n), a ; b  X  X 
Select Distinct s As a, p As name, o As n From Triple Where p= X  X ame X  q 2  X  trans((?a, phone, ?p), a ; b  X  X 
Select Distinct s As a, p As phone, o As p From Triple Where p= X  X hone X  q 3  X  trans((?a, cell, ?p), a ; b  X  X 
Select Distinct s As a, p As cell, o As p From Triple Where p= X  X ell X  q 4  X  trans(((?a, phone, ?p) UNION (?a, cell, ?p )), a ; b  X  X 
Select phone,cell, r1.a As a, r1.p As p From ( q 2 ) r1 Left Outer Join ( Union
Select phone,cell, r3.a As a, r3.p As p From ( q 3 ) r3 Left Outer Join ( trans  X  Q 5 ; a ; b  X  X  Select Distinct a,n,p From (
Select Distinct name,n,phone,p,cell,Coalesce(r5.a,r6.a) As a From ( Inner Join ( q 4 ) r6 On (r5.a=r6.a Or r5.a Is Null Or r6.a Is Null)) r7 mappings a and b , and an RDF graph G , DB is a relational storage of G , denoted as DB the same subsets of triples in G and in DB , i.e. 4 formally defined in [15]. To relate a solution produced by exec , e.g., R by eval , e.g., R 2  X  eval  X  sparql ; G  X  , we define an interpretation function / as follows.
Definition 5.14 ( Interpretation function / ). Given a relation R relation R 2 , that is derived from R 1 by renaming its relational attributes, such that 8 x 2 n  X  R function of name .
 and returns this relation as a result.
 semantics of SPARQL and the mapping-based semantics of SPARQL in the following theorem and corollary. Theorem 5.15. Given a SPARQL query sparql 2 Q , an RDF graph G, and a relational storage DB semantics of SPARQL under the interpretation / , i.e. 8 sparql 2 Q , /  X  exec  X  trans  X  sparql ; a ; b  X  ; DB The proof of Theorem 5.15 is available in [15].
 Corollary 5.16. Given a SPARQL query sparql 2 Q , an RDF graph G, and a relational storage DB SPARQL under the interpretations k and / , i.e. 8 sparql 2 Q , k  X  /  X  exec  X  trans  X  sparql ; a ; b  X  ; DB
The proof of Corollary 5.16 directly follows from Theorems 4.18 and 5.15 . 6. Simplification of the SPARQL-to-SQL translation
The following are six important simplifications that we pursue. 6.1. Simplification 1 any one of the available attributes, since the SQL Select name  X  x  X 2 n  X  trans  X  gp ; a ; b  X  X  . 6.2. Simplification 2 Our second observation is related to the projection expression and 15, where r 1 corresponds to  X  trans  X  gp 1 ; a ; b  X  X  , r that, if  X  trans  X  gp 1 ; a ; b  X  X  contains no left outer joins, r by the Coalesce function. Therefore, the second simplification is to replace the original expression with r name  X  c  X  when  X  trans  X  gp 1 ; a ; b  X  X  contains no left outer joins. 6.3. Simplification 3
The third simplification is related to the join condition
Null) in Rules 14 and 15, where r 1 corresponds to  X  trans  X  gp c 2 X  terms  X  gp 1  X \ terms  X  gp 2  X  X  . This expression can sometimes be replaced with a simpler one as follows: (i) True ,if c is a URI or a literal. A URI or literal attribute name  X  c  X  can be either  X  X  X nbound X  ( (ii) ( r 1 : name  X  c  X  X  r 2 : name  X  c  X  Or r 2 : name  X  c  X  Is Null) ,if trans  X  gp (iii) ( r 1 : name  X  c  X  X  r 2 : name  X  c  X  Or r 1 : name  X  c  X  Is Null) ,if trans  X  gp (iv) ( r 1 : name  X  c  X  X  r 2 : name  X  c  X  ) , if both trans  X  gp sponding graph pattern translation (e.g., trans  X  gp 1 ; a values (e.g., relation r 1 ), and therefore, the Is Null check (e.g., r affect the evaluation of the original expression. 6.4. Simplification 4 The fourth simplification is to rewrite predicates of the form  X  X  6.5. Simplification 5 in Rule 16 is to extend the relational schemas of n  X  trans  X  gp n  X  trans  X  gp 1 ; a ; b  X  X [ n  X  trans  X  gp 2 ; a ; b  X  X  . When the two relations  X  trans  X  gp the schema extension is not needed, since n  X  trans  X  gp 1 for both relations should be in the same order to ensure correct result of the SQL 6.6. Simplification 6 Our last simplification is to push projection in Rule 18 into immediately contained such that only required variables are projected in the subqueries directly. stricter conditions; we leave them for our future work.

We apply our translation with the above simplifications to our sample SPARQL queries in the following example. tp , a  X  tp  X  X  Triple , b  X  tp ; sub  X  X  s , b  X  tp ; pre  X  X  The following are sample SPARQL queries (same as in Example 5.12) and their SQL counterparts:
Q 1 : SELECT ?a, ?n, ?e, ?w WHERE (((?a, name, ?n) OPT (?a, email, ?e)) OPT (?a, web, ?w)). q 1  X  trans((?a, name, ?n), a ; b  X  X  Select Distinct s As a, o As n From Triple Where p= X  X ame X  q 2  X  trans((?a, email, ?e), a ; b  X  X  Select Distinct s As a, o As e From Triple Where p= X  X mail X  q 3  X  trans((?a, web, ?w), a ; b  X  X  Select Distinct s As a, o As w From Triple Where p= X  X eb X  q 4  X  trans(((?a, name, ?n) OPT (?a, email, ?e)), a ; b  X  X 
Select Distinct n, e, r1.a As a From ( q 1 ) r1 Left Outer Join ( trans  X  Q 1 ; a ; b  X  X  Select Distinct Coalesce(r3.a,r4.a) As a, n, e, w From ( q 4 ) r3 Left Outer Join ( q 3 ) r4 On (r3.a=r4.a Or r3.a Is Null)
Q 2 : SELECT ?a, ?n, ?ew WHERE (((?a, name, ?n) OPT (?a, email, ?ew)) OPT (?a, web, ?ew)). q 1  X  trans((?a, name, ?n), a ; b  X  X  Select Distinct s As a, o As n From Triple Where p= X  X ame X  q 2  X  trans((?a, email, ?ew), a ; b  X  X  Select Distinct s As a, o As ew From Triple Where p= X  X mail X  q 3  X  trans((?a, web, ?ew), a ; b  X  X  Select Distinct s As a, o As ew From Triple Where p= X  X eb X  q 4  X  trans(((?a, name, ?n) OPT (?a, email, ?ew)), a ; b  X  X 
Select Distinct n, ew, r1.a As a From ( q 1 ) r1 Left Outer Join ( trans  X  Q 2 ; a ; b  X  X  Select Distinct Coalesce(r3.a,r4.a) As a, n, Coalesce(r3.ew,r4.ew) As ew From ( q 4 ) r3 Left Outer Join ( q 3 )r4 On ((r3.a=r4.a Or r3.a Is Null) And (r3.ew =r4.ew Or r3.ew Is Null))
Q 3 : SELECT ?a, ?n, ?e, ?w WHERE ((?a, name, ?n) OPT ((?a, email, ?e) OPT (?a, web, ?w))). q 1  X  trans((?a, name, ?n), a ; b  X  X  Select Distinct s As a, o As n From Triple Where p= X  X ame X  q 2  X  trans((?a, email, ?e), a ; b  X  X  Select Distinct s As a, o As e From Triple Where p= X  X mail X  q 3  X  trans((?a, web, ?w), a ; b  X  X  Select Distinct s As a, o As w From Triple Where p= X  X eb X  q 4  X  trans(((?a, email, ?e) OPT (?a, web, ?w )), a ; b  X  X 
Select Distinct e, w, r1.a As a From ( q 2 ) r1 Left Outer Join ( trans  X  Q 3 ; a ; b  X  X  Select Distinct r3.a As a, n, e, w From ( q 1 ) r3 Left Outer Join ( q 4 ) r4 On (r3.a=r4.a Or r4.a Is Null)
Q 4 : SELECT ?x, ?y, ?z WHERE ((?x, name, paul) OPT ((?y, name, george) OPT (?x, email, ?z))). q 1  X  trans((?x, name, paul), a ; b  X  X  Select Distinct s As x From Triple Where p= X  X ame X  And o= X  X aul X  q 2  X  trans((?y, name, george), a ; b  X  X 
Select Distinct s As y From Triple Where p= X  X ame X  And o= X  X eorge X  q 3  X  trans((?x, email, ?z), a ; b  X  X  Select Distinct s As x, o As z From Triple Where p= X  X mail X  q 4  X  trans(((?y, name, george) OPT (?x, email, ?z )), a ; b  X  X 
Select Distinct y, x, z From ( q 2 ) r1 Left Outer Join ( trans  X  Q 4 ; a ; b  X  X  Select Distinct r3.x As x, y, z From ( q 1 ) r3 Left Outer Join ( q 4 ) r4 On (r3.x=r4.x Or r4.x Is Null)
Q 5 : SELECT ?a, ?n, ?p WHERE ((?a, name, ?n) AND ((?a, phone, ?p) UNION (?a, cell, ?p))). q 1  X  trans((?a, name, ?n), a ; b  X  X  Select Distinct s As a, o As n From Triple Where p= X  X ame X  q 2  X  trans((?a, phone, ?p), a ; b  X  X  Select Distinct s As a, o As p From Triple Where p= X  X hone X  q 3  X  trans((?a, cell, ?p), a ; b  X  X  Select Distinct s As a, o As p From Triple Where p= X  X ell X  q 4  X  trans(((?a, phone, ?p) UNION (?a, cell, ?p )), a ; b  X  X 
Select a, p From ( q 2 ) r1 Union Select a, p From ( q 3 )r2 trans  X  Q 5 ; a ; b  X  X 
Select Distinct r3.a As a, p, n From ( q 1 ) r3 Inner Join ( the same final result.
 7. Extension of the semantics and translation to support the bag semantics of a SPARQL query solution and the SPARQL-to-SQL translation can be extended to support the bag semantics of a SPARQL query solution. the rules defining the SPARQL-to-SQL translation still hold, except we eliminate the SQL ries in Rules 13, 14, 15, and 18 and substitute the SQL Union tuples are preserved.
 We show how a sample SPARQL query is evaluated and translated with eval and trans under the bag semantics.
Example 7.1 ( eval and trans under the bag semantics ). In this example, we use SPARQL query Q translation under the set semantics were presented in Examples 4.17 and 5.12/6.1 , respectively. The evaluation of Q 5 under the bag semantics over the RDF graph G in Fig. 2 is as follows. Q 5 : SELECT ?a, ?n, ?p WHERE ((?a, name, ?n) AND ((?a, phone, ?p) UNION (?a, cell, ?p))).
R 1  X  eval  X  X  ? a ; name ; ? n  X  ; G  X  X f X  B 1 ; name ; paul  X  ;  X  B
R 2  X  eval  X  X  ? a ; phone ; ? p  X  ; G  X  X f X  B 1 ; phone ; 111 1111  X  ;  X  B R 3  X  eval  X  X  ? a ; cell ; ? p  X  ; G  X  X f X  B 4 ; phone ; 444 4444  X g
R 4  X  eval  X  X  ? a ; phone ; ? p  X  UNION  X  ? a ; cell ; ? p  X  ; G  X  X  R f X  B 1 ; phone ; 111 1111 ; NULL  X  ;  X  B 4 ; phone ; 444 4444 ; NULL  X  ;  X  B Given an RDBMS-based RDF store scheme, i.e. for any triple pattern tp , a  X  tp  X  X 
Q 5 : SELECT ?a, ?n, ?p WHERE ((?a, name, ?n) AND ((?a, phone, ?p) UNION (?a, cell, ?p))). q 1  X  trans  X  X  ? a ; name ; ? n  X  ; a ; b  X  X  Select s As a ; o As n From Triple Where p  X   X  name  X  q 2  X  trans  X  X  ? a ; phone ; ? p  X  ; a ; b  X  X  Select s As a ; o As p From Triple Where p  X   X  phone  X  q 3  X  trans  X  X  ? a ; cell ; ? p  X  ; a ; b  X  X  Select s As a ; o As p From Triple Where p  X   X  cell  X  q 4  X  trans  X  X  X  ? a ; phone ; ? p  X  UNION  X  ? a ; cell ; ? p  X  X  ; a ; b  X  X 
Select a, p From ( q 2 ) r1 Union All Select a, p From ( q trans  X  Q 5 ; a ; b  X  X 
Select r3.a As a, p, n From ( q 1 ) r3 Inner Join ( q 4 ) r4 On (r3.a=r4.a) 8. Experimental study
In this section, we present our experimental study with the following two main goals: Community Edition and Oracle 9i Enterprise Edition.
 Q6 X  X 9, as well as Q4, appeared to be much more selective and efficient. running MS Windows XP Professional.
 of more sophisticated query optimization techniques used by this database management system. ized database view that used three inner joins ( triples ffl incomplete tuple  X  B 3 ; george ; NULL  X  instead of expected tuple  X  B translation for all the queries except Q9.

With respect to the experimental study goals and based on our empirical data, we conclude: 9. Conclusions and future work reference solution for researchers and developers of relational RDF stores. We identify the following directions for future work: the forward-chaining inference technique.
 Providing native support for these features might result in faster query evaluation. serving SPARQL-to-SQL translation. We are interested in exploring some of these important challenges.
References
