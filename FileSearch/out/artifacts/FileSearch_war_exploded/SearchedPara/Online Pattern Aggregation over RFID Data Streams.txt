 tracking [4, 5], anti-counterfeiting [6] and facility surveillance [7] . from the shelves and doors in a retail store only tell us when and where tags are de-out: an item has been picked up from a shelf and then taken out of the store without being checked out. tion logic as complex events, and then detecting such complex events[8]. In this situa-chain manager know the amount of the goods which have been transported along the path Airport(Hong Kong)  X  Port(Shanghai)  X  Warehouse(Beijing) quickly. 
In typical RFID applications, memory resource is bounded, but events streams are and sliding window [10]. In this paper, we focus on the aggregation of complex event query (WPAQ) . other. A WPAQ example is as follows. continuously and update the result every w2 interval. Q1 is described by the composition of the SASE declarative language [9] and the CQL-like language [11]. SEQ is the operator to construct a sequential complex event from primitive events. RANGE specifies the size of sliding window. SLIDE specifies how the window moves. challenges. z Composite aggregate data . In traditional data streams, aggregation queries z Temporal . Aggregate objects in XML data streams [12] are composite data, summarized as follows. streams which have not been studied before. sliding window into several sub-windows and computes the aggregate value from the corresponding values of sub-windows, thus achieves high efficiency. (3) We propose optimization techniques for RFID_PAQ. We design different mapping functions based on the distribution characteristics of RFID data streams. efficient. Section 3 , we define valid aggregate objects and present the types of aggregate func-presented in Section 5 . Finally, we conclude this paper with Section 6 . SASE represents the structure of complex events by non-deterministic finite automata However, SASE does not support aggregation queries. Siemens RFID middleware event processing is implemented by a graph computation model. It is an off-line sys-tem and lacks the expressiveness of the SASE language. In [17], a marvelous storage and in which pattern aggregate queries performs well. But as we know, [17] is based on Path Database [16] which is offline. 
From Q1 , we can see that WPAQ focuses on aggregations of composite data rather rithms[11,18,19]. In [11,19], a framework for defining window semantics is presented ing strategies between different aggregate functions and different sliding-windows are XML data don X  X  contain time constrains. The algorithms presented in [12] can not be applied to RFID data streams. 3.1 Valid Objects ferred from Hong Kong past Shanghai to Beijing in the past ten hours. In RFID appli-represented by RFID complex events. For a RFID complex event instance p contrib-utes to a WPAQ , it must satisfy the following two constraints. Constraint 1. All the components of p have been detected. Constraint 2. The start time and end time of p are in current sliding window. window. 
A primitive RFID event has the format of (tag id, reader id, timestamp) , where tag and timestamp records the reading X  X  occurrence time. w(Start_Time, End_Time) , p X  X  active period should be included in w . That is as shown in Figure 1. 3.2 Aggregate Functions In a WPAQ , multiple aggregate functions may be computed simultaneously, such as Q2 . which follow the special path A  X  B  X  C in recent 24 hours and update the result every 1 hour. 
The proposed RFID_PAQ algorithm supports multiple aggregate functions such as of multiple aggregate functions does not consume significant additional CPU time. 4.1 Framework of RFID_PAQ size. We first sub-aggregate the stream over independent sub-streams, which we call sub-windows, and then we aggregate over the sub-window-aggregates to get window-aggregate strategy can be described by Formula 1. aggregating strategy has the following advantage. 
If the data within a sub-window expire, they would not affect the aggregate values of other sub-windows. 
Each primitive event will be dispatched to a sub-window. Unlike the case of tradi-mined by its timestamp only. Consider the following example. event instance. quent events belong to the same sub-window as which it belongs to. Let FC represent and a sub-window w is as follows.  X  (w, E, W(RANGE,SLIDE)) ={ e  X  E | } Whether a complex event instance p belongs to a specific sub-window is determined window w can be described by the following formula.  X  (w, P, W(RANGE,SLIDE)) = { p  X  P | } which sub-windows they belong to. It includes two steps: locating a sub-window and cost can be brought down from two perspectives. One is to speed up query processing in sub-windows, the other is to reduce the cost of locating the target sub-window. events, such as timestamp and reader id , does not need to be reserved. 
Note that searching sub-windows sequentially to identify the target sub-window is windows, as shown in next section. reaches the final state, the aggregate value of the sub-window will be updated accord-results of all its sub-windows. event is considered to expire only after its corresponding sub-window falls out of the current sliding window. This expiration approach avoids frequently updating B+ trees and the aggregate values of sub-windows. When a sub-window becomes out-of-date, Consider the following example. Example 2. Let the punctuation PSLIDE identify the end of a sub-window. In Figure 2, processing of query SELECT count(*) FROM S WHERE SEQ(A,B,D) RANGE T hours SLIDE t hour is as follows. (1) When an event a i is detected, map it to the sub-window m. Because a i is an FC (2) When an event d n is detected, map it to the sub-window k, and then update the 4.2 Mapping Functions uniform distribution and normal distribution . Table 1 shows some application exam-normal distribution or approximate normal distribution . sub-windows in the following way. (1) Constant Distribution CurSLIDENo stand for the number of current sub-window. The distance of target sub-sub-window can be computed by Formula 4. (2) Uniform Distribution T  X  window. We call this method boundary search . The No. of w max can be calculated by Formula 5. (3) Normal Distribution (Gauss Distribution) T events around  X  -Slide . We call this method surrounding search . The No. of the sub-window  X  -Slide can be calculated by Formula 6.  X  of this article, we will not discuss the detail methods here. 4.3 State Codes Since integer comparisons are faster, we in troduce prime numbers to encode the states of tags when implementing RFID_PAQ . From the fundamental theorem of arithmetic the product of prime numbers. If we use different prime numbers to identify the steps greater than 1. Consider a processing logic de scribed as Figure 3. Each step is moni-tored by a RFID reader and represented by a prime number. If a tag has gone through tag k i is 42=2*3*7 , k i must have gone through the path A  X  B  X  D . 5.1 Data Sets ments on synthetic data. In our data generator, RFID readers are deployed as shown in ess, we assume that each tag generate only one reading when it arrives at a reader. will move from reader X to reader Y . 
Timestamps of the events from reader A follow t~U(0,3600) distribution. Parame-between reader X and reader Y . Our machine environment is AMD Athlon Dual Core Processor 5000B 2.61G HZ CPU, 1.87 G Memory, 250G 7200 r/s Disk. 5.2 Performance Evaluation (1) Mapping Method vs. Directly Search We began our study by examining the effectiveness of mapping functions.We compared two algorithms : Direct Seach and Mapping . In this set of experiments, we used the following query: SELECT COUNT(*) FROM S WHERE SEQ(A,C,D) RANGE 4800 SLIDE 50. S stands for a data stream,which changes from S1 to S5 .We distribution . 
Figure 5 shows the running time of two algorithms.The mapping method performs Because the target sub-window can be fixed without searching in constant distribution situations, the gap between the two methods are more obvious. (2) Size of Sub-windows In this set of experiments, we used the following query: SELECT COUNT(*) FROM S5 WHERE SEQ(A,C,D) RANGE x SLIDE var . Var changes from 5 to 600.The first expiring data. The second experiment measured the running time with RANGE RFID_PAQ algorithm achieves. The efficiency of RFID_PAQ is determined by time-consuming. The reduction of the time to map events to sub-windows can size of sub-windows is, the less objects the sub-window contains, the faster B+ tree queries are, and cons equently the faster RFID_PAQ performs. (3) Multiple Aggregate Functions WHERE SEQ(A,C,D) RANGE 1200 SLIDE 80 . Agg came from the following data sets. in Figure 7, we can see that additional aggregate functions do not bring more running same. When the complex event pattern is the same, we only need to check Constrain time. event streams X  RFID_PAQ . RFID_PAQ supports multiple aggregation functions and achieves high efficiency. 
The values computed by RFID_PAQ are accurate. In practice, approximate values may be good enough for users. Our next work is to study online approximate pattern aggregate algorithms for RFID applications. Acknowledgments. Our work is supported by National Science Foundation of China, with project no. 60720106001. 
