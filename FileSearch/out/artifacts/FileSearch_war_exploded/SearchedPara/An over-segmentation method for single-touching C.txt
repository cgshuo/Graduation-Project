 ORIGINAL PAPER Liang Xu  X  Fei Yin  X  Qiu-Feng Wang  X  Cheng-Lin Liu Abstract The segmentation of touching characters is still a challenging task, posing a bottleneck for offline Chinese handwriting recognition. In this paper, we propose an effec-tive over-segmentation method with learning-based filter-ing using geometric features for single-touching Chinese handwriting. First, we detect candidate cuts by skeleton and contour analysis to guarantee a high recall rate of charac-ter separation. A filter is designed by supervised learning and used to prune implausible cuts to improve the precision. Since the segmentation rules and features are independent of the string length, the proposed method can deal with touching strings with more than two characters. The proposed method is evaluated on both the character segmentation task and the text line recognition task. The results on two large databases demonstrate the superiority of the proposed method in deal-ing with single-touching Chinese handwriting.
 Keywords Single-touching strings  X  Chinese handwriting  X  Over-segmentation  X  Learning-based filtering  X  Geometric features 1 Introduction To deal with the ambiguity of character segmentation, hand-writtentextrecognitionisusuallyaccomplishedbyintegrated segmentation and recognition [ 1 ]. An effective approach is to over-segment the text line (character string) into primitive segments each being a character or a part of character, com-bine adjacent primitive segments into candidate characters and evaluate candidate characters using a character recog-nizer and contexts. The over-segmentation of touching char-acters, which occur frequently in handwritten documents, is a challenging task and is crucial to the string recognition performance [ 2  X  6 ].

There have been many over-segmentation algorithms for dealing with touching characters, but most of them are based on heuristic rules [ 2 , 6  X  17 ]. This makes them hard to gen-eralize from one application problem to another. Even if using problem-specific rules, there still remain many over-segmentation failures (under-segmentation errors) (cf. the experimental results in [ 3 ]). On one hand, we need to devise splitting algorithms to improve the recall rate of cut (sep-arating line) detection. On the other hand, it is demanding to design a learning-based over-segmentation algorithm to improve its robustness [ 18 ], specifically, to better balance the recall rate and precision. The cut classification algorithm of Bayer and Kressel [ 19 ] can be viewed as a learning-based one, but classification on each column of string image is too computationally demanding. A more promising strategy is to over-generate candidate cuts using heuristic shape analysis and then filter out redundant cuts using a classifier [ 20 ]. In either cut detection or filtering, the considered geometric fea-tures or rules are hoped to be independent of the string length (number of characters in the string image) because the string length is unknown a priori. However, some previous meth-ods have assumed known string length (e.g., character pair) or use features depending on the string length (e.g., [ 21 ]). These methods are hard to generalize to touching strings of variable length.

In Chinese handwriting, character segmentation is dif-ficult due to the large category set, complex character structure and writing style variability [ 3 , 22  X  24 ]. The seg-mentation of touching characters in Chinese and Japanese handwriting has drawn considerable attention but is still a bottleneck that hinders high performance in text line recog-nition [ 3 ]. To detect touching points with a high recall rate can guarantee that different characters are mostly separated in over-segmentation. However, a high recall rate is usu-ally accompanied with many redundant cuts (false positives), which make the segmentation-recognition candidate path evaluation and search in string recognition complicated and may deteriorate the recognition performance. We thus have been exploring over-segmentation algorithms for achieving high detection rate of touching points while compressing false positives.

To enable fair evaluation of Chinese touching character segmentation algorithms, we recently released a touching character database called CASIA-HWDB-T [ 25 ], compiled from the Chinese handwriting database CASIA-HWDB [ 26 ]. The database reveals that single-touching strings (in which two adjacent characters are touched with one connected stroke) are the dominant type (more than 95%) among all touching samples. The focus of this work is thus to deal with this majority type of single-touching. Figure 1 shows some examples of single-touching strings and multiple-touching ones. In our previous work [ 27 ], we developed a foreground skeleton-based segmentation algorithm which can detect most touching points with a moderate ratio of redundant cuts. This work extends the previous method and improves the handwritten text line recognition performance mainly in two aspects. First, we refine the cut detection steps to improve the recall rate with moderate computation. Second, we design a supervised learning-based filter for reducing redundant cuts and balance the recall rate and precision. The used geomet-ric features and rules in cut detection and filtering are inde-pendent of string length and so are applicable to strings of variable length. Our experimental results on the touching character database CASIA-HWDB-T demonstrate the effec-tiveness of the proposed method and its benefit to text line recognition.

The rest of this paper is organized as follows. Section 2 reviews related works in Chinese handwriting segmentation; Sect. 3 gives an overview of our over-segmentation method; Sect. 4 describes the algorithm for candidate cut generation; Sect. 5 describes the learning-based filter using geometric features; Sect. 6 describes the postprocessing step; Sect. 7 presents the experimental results and Sect. 8 concludes the paper. 2 Related works Character segmentation in Chinese/Japanese handwriting for character string (text line) recognition has been studied in different application scenarios: bank check reading [ 9 , 12 ], mail address interpretation [ 2 , 8 , 13  X  16 , 21 , 28 ] and handwrit-ten text recognition [ 10 , 11 , 17 , 27 ]. Some of the methods are aimed for segmentation-then-recognition, and some are aimed for integrated segmentation-recognition. The latter case is over-segmentation with the objective of separating characters with as less redundant cuts as possible. In either case, the splitting of touching characters is the main task, as the separation of non-touching characters can be easily achieved by connected component analysis. In the follow-ing, we briefly review some existing segmentation methods in Chinese/Japanese handwriting recognition.

Tseng and Chen [ 10 ] proposed a segmentation method based on stroke extraction. They extract eight types of strokes by run scanning in binary image. The highly horizontally overlapped strokes are heuristically merged into primitive segments, which are partitioned into characters by dynamic programming incorporating character-like geometric prop-erties. By this method, touching characters can be separated in stroke extraction of different types, but the segmentation performance is influenced by the accuracy of stroke extrac-tion. A similar stroke extraction-based method was presented by Wang et al. [ 16 ]. The segmentation method of Tseng and Lee [ 11 ] is recognition-based. They generate nonlin-ear separating lines (cuts) by probabilistic Viterbi search on equally sampled vertical positions of string image and filter out redundant cuts by heuristics such as overlapping ratio of adjacent cuts. Separating lines passing through foreground strokes can split touching characters. The final segmentation of characters is determined by shortest path search in a graph of candidate segmentation incorporating character recogni-tion confidence and character-like geometric features.
Suwa [ 15 ] proposed a recognition-based touching char-acter segmentation algorithm, using a graph to represent the skeleton of character image with each node denoting a corner or fork point and each edge denoting a stroke segment. For splitting touching characters, potential edge cuts are selected using empirical rules about the node type, the length and slant of edge. The optimal segmentation result is found on the candidate character lattice with character recognition confidence. The recognition-based segmentation method of Yamaguchi et al. [ 13 , 14 ] similarly represents the foreground skeleton as a graph. They use valleys of projection profile and stroke crossing counts to prune redundant skeleton fork or corner points, and form candidate cuts from the remain-ing fork and corner points. Further, a heuristic based on the overlapping width of two adjacent candidate characters and the angle of virtual corner is used to filter out unnecessary cuts. Finally, touching pattern image is over-segmented at candidate separating lines. Graph-based segmentation well exploits the stroke structure of touching characters, but the proper selection of edge cuts is not trivial.

ThemethodofLiuetal.[ 2 ]detectscandidatecutsinpoten-tial touching patterns (which are connected components of large width or width-to-height ratio) by local contour analy-sis in single-stroke regions (horizonal positions with single vertical stroke crossing and limited run length). For detecting touching point, they match the local contour shape with seven empirically defined touching types, extended from those of Ikeda et al. [ 7 ]. After splitting based on touching type detec-tion, a postprocessing step based on projection profile is applied to generate extra cuts on components which are still wide enough. This method has shown promise in Japanese mail address reading [ 2 ] and recently in Chinese handwrit-ten text recognition [ 3 ]. The remaining under-segmentation errors are mainly due to the failure of touching point detec-tion in single-stroke regions.

The segmentation method of Zhao et al. [ 21 ]usesthe skeletons of both the foreground and the background of binary image. On potential touching patterns, they extract stroke segments from the foreground skeleton, detect candi-date segmentation points from fork and corner points and form nonlinear separating lines incorporating both fore-ground and background skeleton information. They then ver-ify the separating lines using a trained fuzzy decision tree classifier with geometric features (e.g., the width ratio of left and right parts). Some of the geometric features assume char-acter pairs and so are not suitable for touching strings with more than two characters. On the other hand, the background thinning in this method consumes considerable computation and may generate many spurious branches to complicate sep-arating line detection. The method of Liang and Shi [ 28 ] similarly detects separating lines from foreground and back-ground skeletons, but verifies them using a mixture density probability model.

The previous works evaluated the performance of charac-ter segmentation in different metrics, some in the character stringrecognitionperformance(string-levelorcharacter-level accuracy), some in the percentage of correctly segmented characters and some from the viewpoint of segmentation point (cut) detection (recall rate, precision and F-measure). Some focus on touching characters or even touching char-acter pairs only, and some count on character strings con-taining both touching and non-touching characters. Among the works, Suwa [ 15 ] reported a correct segmentation rate of 93.8% on one hundred touching Japanese Kanji characters. Yamaguchi et al. [ 14 ] reported a correct segmentation rate of 83.0% on 456 touching patterns from handwritten mail address images. Zhao et al. [ 21 ] evaluated their segmentation method on one thousand handwritten Chinese mail address strings, and as well, on 1,960 touching characters reported 52.1% segmentation correct rate. Liu et al. [ 2 ] reported only string recognition rates on handwritten Japanese mail address images. Wang et al. [ 3 ] show that on the test text lines of data-base CASIA-HWDB, the over-segmentation method of [ 2 ] remains 4.46% under-segmentation errors. These results are not directly comparable since these methods were evaluated on different datasets, and some methods utilized character recognizer while some not.

Along with Chinese character segmentation, there have been many segmentation methods proposed in handwritten digit segmentation [ 29  X  33 ] and other scripts. Some impor-tant separating techniques based on contour, stroke and background skeleton analysis were firstly proposed for hand-written digits and then accustomized to Chinese characters (e.g., [ 21 , 28 ]). 3 Overview of our over-segmentation method Our over-segmentation method for handwritten Chinese text linerecognitionisaimedforseparatingcharacterswithasless primitive segments as possible, and particularly for touching characters, finding the separating lines with high recall rate and precision. The block diagram of the method is shown in Fig. 2 . By the method, the input character string image (in horizontalorientation)isfirstsegmentedintoconnectedcom-ponents (CCs). After merging highly horizontally overlapped CCs, we treat the resulted components with large width or width-to-heightratioascandidatetouchingpatterns.Tojudge the width, the string image height, denoted as SI height , is esti-mated as the mean of height of bounding box of every pair of consecutive components [ 2 ]. Then, a component is taken as candidate touching pattern if its width exceeds  X  1  X  SI height or the width-to-height ratio exceeds  X  2 .  X  1 and  X  2 are empir-ically set as 0.6 and 0.8, respectively, such that nearly all the touching characters are detected. Each candidate touch-ing pattern is then processed in four steps: construction of candidate separating lines, verification of separating lines by heuristics and by learning-based filtering and postprocessing.
Candidateseparatinglinesaregeneratedbasedonthefore-ground skeleton of string image (after thinning) and contour information (before thinning). To save computation, we do not skeletonize the background area. On tracing the skele-ton image both from the upper side and from the lower side, the common skeleton (called common stroke) in both upper and lower traces is analyzed to detect characteristic points, including fork points, corner points and smooth touching points. Candidate separating lines are constructed on these characteristic points by connecting corresponding points in the upper and lower contours of the string image (see Sect. 4 ). Redundant separating lines are filtered out using some simple rules and a learning-based filter with geometric features (see Sect. 5 ). The postprocessing step is to separate the remain-ing components which are sufficiently wide to generate extra separating lines by projection analysis (see Sect. 6 ). After separating the touching patterns at the detected and verified separating lines, the resulted primitive segments are fed into a character string (text line) recognition system. Figure 3 gives an illustrative example of the over-segmentation steps. 4 Construction of candidate separating lines Candidate separating lines are constructed in two steps: char-acteristic point detection and candidate separating line gen-eration. 4.1 Characteristic point detection In single-touching Chinese characters, the touching points are mostly lying on the common skeleton traced from upper side and from lower side. We hence detect candidate sepa-rating points only from the foreground skeleton, unlike some previous methods that skeletonize both foreground and back-ground. A similar scheme analyzing common skeleton was adopted for separating touching digits [ 33 ].

First, we skeletonize the binary image of touching pattern using a thinning algorithm [ 34 ]. If the touching pattern con-tains multiple CCs, we select the widest CC for foreground skeleton tracing. The pixels of skeleton are traced from left to right clockwise in the upper side and counter-clockwise in the lower side. The left end and right end are denoted as the start point (S) and the end point (E), respectively. On the com-mon part of the upper and lower traces, the fork points (those have more than two eight-connected branches) are marked as characteristic points. The skeleton segment between two adjacent fork points is a common stroke.

In addition to fork points, a corner point on common skele-ton can also be a touching point. We detect corner points from each common stroke in two steps: corner detection according to the local maximum of turning angles using the algorithm of Rosenfeld and Johnston [ 35 ] and polygonal approximation on each segment between two corner points using the algo-rithm of Ramer [ 36 ]. This scheme has been used in stroke extraction [ 37 ]. Both the corner points and the vertices of polygonal approximation are taken as characteristic points. Figure 4 shows an example of common skeleton and charac-teristic points.

In addition to the fork points and corner points on common skeleton, characters may touch on a smooth stroke without corners, such as the case in Fig. 5 . We call this case as smooth touching, which is generally lying on a long common stroke with nearly horizontal direction. We detect smooth touching strokes according to three conditions as below: 1. The horizontal width of the common stroke is greater 2. Its direction is near horizontal, say, the angle with the 3. It overlaps with at least a single-stroke region in the string We denote the total overlapping width of a common stroke with all the single-stroke regions as homo-length . The single-stroke region is defined in [ 2 ] as a horizontal region with only one vertical stroke crossing. An example is shown in Fig. 6 a. The homo-length is also useful for separating line generation as will be described later. 4.2 Candidate separating line generation Each characteristic point (fork, corner or smooth touching point) indicates a candidate cut for separating touching char-acters. From a characteristic point, a separating line can be formed by connecting one point from the upper contour and one from the lower contour of the touching pattern image. It is observed in Chinese handwriting that most touching char-acters can be separated by vertical lines. Thus, we consider only vertical separating lines for simple implementation.
First, the upper contour and lower contour are traced from left to right clockwise and counter-clockwise, respectively. To generate a separating line for each characteristic point, we need to find two suitable terminal points, one on the upper contour and one on the lower contour.

Since a corner point or a smooth touching point lies between fork points and is distant from other strokes, we can simply search a separating line with minimum weighted dis-tance in the neighborhood. The weighted distance is defined as d = d 1 + 0 . 4  X  d 2 , where d 1 is the vertical length of the separating line (distance between the paired points in upper and lower contours) and d 2 is the horizontal distance between the separating line and the characteristic point. The neigh-borhood is empirically confined to be within one-tenth of the string image height, horizontally from the characteristic point.

For a fork point, we need to decide on which common stroke (left or right side) to generate the separating line. The fork point is related to the common skeleton in two possible cases: 1. The fork point is a terminal of one common stroke on 2. The fork point is shared by two common strokes on both In the first case, it is clear that the separating line should be on the side of the single common stroke. For the second case, we design a simple and effective criterion for selecting a common stroke based on single-stroke region analysis. To do this, we divide the touching pattern image into single-stroke region(s) and multiple-stroke region(s), as shown in Fig. 6 a. Then the homo-length value of each common stroke is cal-culated as the total overlapping width between the common stroke and all the single-stroke regions. Figure 6 bshowsthe homo-length values of the common strokes in Fig. 4 b. The selection criterion is based on the fact that most touching points lie on or near a single-stroke region, according to our investigation on a large database of touching characters (see Sect. 7.1 ). Thus, we select the common stroke with larger value of homo-length to generate the separating line. If the two adjacent common strokes have equal homo-length ,we generate a separating line on both sides. Again, the separating lineonacommonstrokeisonapixelwithminimumweighted distance d = d 1 + 0 . 4  X  d 2 from the fork point, in a neigh-borhood with horizontal length ( l Ngb ) empirically set as one-tenth of the string image height. Figure 7 shows an illustrative example of separating line generation for a fork point. 5 Verification of candidate separating lines The generated candidate separating lines (cuts) contain gen-uine ones that separate characters at touching points, and redundant ones that lie within characters. The objective of cut verification or filtering is to prune redundant cuts while keeping genuine ones as much as possible. The filtering can be seen as a two-class classification problem, which is both imbalanced (there are much more redundant cuts than gen-uine ones) and cost-sensitive (rejecting a genuine cut is more costly than detecting a redundant one) [ 20 ].We perform cut filtering in two steps using simple rules in the first step and a learning-based filter (linear classifier) in the second step. The flowchart of filtering is depicted in Fig. 8 . The combi-nation of nonlinear rules and linear classifier provides good trade-off between classification performance and computa-tional complexity.

We use the following notations for characterizing a can-didate separating line ( Line i ), formed by a pair of upper contour point ( x i , y u i ) and lower contour point ( x  X   X   X   X   X  L  X  L f 5.1 Filtering by simple rules We first apply three simple heuristic rules to remove the sep-arating lines that are apparently redundant. Denoting the height of the touching pattern image as H , the rules are described below.  X  RULE1: If the length of a separating line is too long, i.e.,  X  RULE2: If the foreground pixel ratio of a separating line  X  RULE3:Ifaseparatinglineisveryclosetotheleftorright
The above thresholds are selected such that only those separating lines that are apparently redundant are removed. And the remaining separating lines are to be evaluated by the learning-based filter. Figure 3 f shows an example of verified separating lines after filtering by three simple rules. 5.2 Learning-based filtering The classification performance of learning-based filtering largely depends on the extracted features as well as the train-ing data. While the training data is specified in the experi-mental section, the geometric features are described below. 5.2.1 Geometric features of candidate separating line From each candidate separating line, we extract nine geo-metric features which are independent of the string length (number of characters in the string image). The features can be grouped into two categories depending on whether they characterize an individual separating line (unary features) or the adjacent image segments after splitting at the separating line (binary features). Figure 9 gives an example showing some binary geometric features.

The four unary features ( f 1  X  f 4 ) and five binary features ( f indicates that the feature is normalized by the image height H , the column  X  X ef X  gives the references that the feature is adapted from. We present the feature f 4 based on the obser-vation that a certain type of touching is likely to take place in a stable vertical position. The feature f 7 refers to Fig. 9 , where the foreground pixel in the left segment nearest to the center of the separating line is on the upper part of the right bound. When the left and right segments are overlapped, a small dy implies a low likelihood that the candidate separating line should be a genuine one. This feature was presented in [ 14 ] for being complementary to the horizontal overlapping width ox . When the left and right segments are not overlapped, we set ox = 0 and d y = 0 . 5.2.2 Learning-based filter The verification of candidate separating lines is a two-class classification problem: classify to positive class  X  1 (genuine cut) or negative class  X  0 (redundant cut). Using a learning-based filter has two benefits: optimize the combination of fea-tures via supervised learning, flexible balance of the recall rate and precision of cut detection via adjusting only one threshold. We use a linear classifier to combine the fea-tures, and specifically, have tested two linear classifiers: lin-ear discriminant function (LDF) [ 39 ] and linear support vec-tor machine (SVM) [ 40 ]. We have also tested nonlinear SVM but do not observe significant performance gain. On a feature vector x , the output of two-class linear classifier is f ( x ) = w T x + b , (1) where w , b are the vector of linear weights and the bias of theclassifier,respectively.Theweightsandbiasareestimated in different ways, i.e., assuming equal-covariance Gaussians by LDF and minimizing margin-regularized hinge loss by SVM. For decision, f ( x )&gt; 0 indicates that the input sample (candidate cut) is positive, and f ( x )  X  0 indicates that the candidate cut is negative (redundant). The classifier output is often transformed to probability by the sigmoidal function: Prob ( X  1 | x ) = where  X  and  X  can be simply set as 1 and 0, respectively. By this transformation, we can select a threshold for the proba-bility from ( 0 , 1 ) .

Based on the classifier output, we can make a decision on an individual candidate cut or on two neighboring cuts. The decision on an individual cut is below.  X  RULE4: If Prob ( X  P between the recall rate and precision of genuine cut detec-tion. A default threshold is P thr = 0 . 5. Figure 10 bshows an example of removing two redundant separating lines by RULE4.

If two separating lines are close to each other, it is very likely that only one of them is genuine. So, we have a decision based on two neighboring candidate cuts:  X  RULE5: If two separating lines are neighboring, the one The neighboring condition for two adjacent separating lines ( Line i and Line j )is dc ij &lt; T dc , where dc ij denotes the contour distance defined as max {|  X  up ( i )  X   X  up ( j ) | , |  X   X  shows an example of removing four redundant separating lines by RULE5. 6 Postprocessing The postprocessing step is adapted from the forced splitting rule of Liu et al. [ 2 ]. To make this paper self-contained, we outline here the technique and show an example. Though carefully designed, the above separating line detection and verification techniques may fail to split some touching characters which have unusual touching shape. The forced splitting rule utilizes the segmentation ability of projection profile: a minimum of vertical projection is likely to cor-respond to a touching point. The method of [ 2 ] combines the projection profile weighted with vertical crossing count and the horizontal distance from the center of touching pat-tern into a characteristic function and locates the x position of minimum characteristic function as a splitting point. The separating line at the point is simply the vertical line at the x position. Figure 11 a shows a touching pattern that is failed to split by skeleton-based separating line detection. Figure 11 b shows that it is correctly separated by forced splitting in post-processing. 7 Experimental results We evaluated the over-segmentation performance of the pro-posed method and its effect on string recognition on the touching character database CASIA-HWDB-T [ 25 ].
 7.1 Databases and comparison methods The Chinese handwriting database CASIA-HWDB [ 26 ] con-tains three datasets of isolated characters (DB1.0 X 1.2) and three datasets of handwritten texts (DB2.0 X 2.2), produced by 1,020 writers. There are 5,091 pages of handwritten texts which contain about 1.35 million character samples. The database CASIA-HWDB-T contains touching charac-ter images collected from CASIA-HWDB. One subset in the database, CASIA-HWDB-ST, contains 54,651 single-touching strings, including 48,536 single-touching pairs and 6,115 single-touching strings with more than two characters. The database provides the ground-truth information of the touching point X  X  location, character class, estimated stroke width (SW) and estimated text line height (string height).
We further partition the single-touching subset into three sets for training, validation and testing, respectively. The training set contains 9,904 single-touching pairs from the training set of DB2.1. All the candidate separating lines gen-erated by our method on the training set are used to train the linear classifier. A candidate separating line is treated as a positive sample if the chessboard distance between its center and a labeled touching point is smaller than a thresh-old (2  X  SW), otherwise a negative sample. The training set has 55,067 candidate separating lines, including 8,665 positive samples and 46,402 negative samples. The valida-tion set contains 1,905 single-touching pairs from the test set of DB2.1. The test set is made up of the remaining 36,727 single-touching pairs and all the single-touching strings with more than two characters. In implementing the learning-based filter, we used the LibSVM package [ 41 ] for training the linear SVM classifier.

We investigated the locations of touching points in all single-touchingpairsfromCASIA-HWDB-ST,andobserved that 76% of touching points lie in one of the single-stroke regions (cf. Fig. 6 a). The percentage increases to 91% if we allow a touching point to lie near one of the single-stroke regions within a small horizontal threshold (SW). This indi-cates that it is reasonable to use homo-length to assist the generation of candidate separating lines in Sect. 4.2 .
To evaluate the effect of the proposed over-segmentation method on string recognition, we conducted experiments of string recognition on the single-touching strings in the test set of CASIA-HWDB-ST, using the text line recognition sys-tem of [ 3 ] only with a character classifier on the primitive segments produced by over-segmentation. We did not use a language model since a touching string normally contains only two or three characters. The second dataset is made up of 1,542 handwritten text lines with nearly 43,000 characters, selected from the test set of DB2.0. Each text line selected has at least one single-touching string. For this dataset, the string recognition system uses both a character classifier and a tri-gram language model on the primitive segments.
We compare the segmentation performance of our pro-posed method with other three segmentation methods in the literature: 1. The over-segmentation of Liu et al. [ 2 ], which has applied 2. The method of Zhao et al. [ 21 ]; 3. Our previous method based on heuristics [ 27 ]; We implemented the method of [ 21 ] as the source codes from the authors are not available. We did not use the fuzzy deci-sion tree classifier for filtering because the filter was designed for touching character pairs while we consider touching strings of variable length.

We implemented the algorithms in C++, and experi-mented on a personal computer with Intel Core i5-2400 CPU 3.1GHz, 4GB of RAM and Windows7 professional 64bit. The algorithms of Liu et al. [ 2 ], Zhao et al. [ 21 ], our pre-vious method [ 27 ] and the current proposed method, spend about 0.1, 4, 2 and 1.6ms on a single-touching string image of 70  X  128 pixels, respectively. 7.2 Results on character segmentation task For evaluating the over-segmentation performance with-out character recognition, we use the chessboard distance between the center of the detected separating line and that of the labeled separating line (touching point) to judge whether the detected separating line is correct or not. We decide a cor-rect separation when the chessboard distance is less than a threshold (2  X  SW empirically). If there are multiple detected separating lines within a distance threshold from a labeled touching point, only the nearest one is considered correct. The performance of over-segmentation is measured by the recall rate R and the precision P , defined below: R = #correct detected separating lines P = #correct detected separating lines R is also called as correct segmentation rate in [ 4 , 13 , 14 ].
The results of the proposed method and three compari-son methods on the test set of CASIA-HWDB-ST are shown in Table 2 , where the learning-based filter in the proposed method takes a threshold P thr = 0 . 76 so as to well balance the recall rate and precision. We can see that the proposed method can outperform the method of [ 2 ] in both recall rate and precision. Compared with the method of [ 21 ] (without verification by fuzzy decision tree classifier), the proposed method yields a little lower recall rate but much higher pre-cision. Our previous method in [ 27 ] outperforms the one of the [ 21 ] in both recall rate and precision. To compare the proposed method with the one in [ 27 ], we turn to view the precision X  X ecall curve by varying the decision threshold P in Fig. 12 . We can see that at certain threshold, the proposed method can yield both higher recall rate and higher precision.
Figure 12 shows the precision X  X ecall curves of two clas-sifiers in filtering (LDF and linear SVM) and their variations without simple rules (RULE1 X  X ULE3) or neighboring prun-ing rule RULE5. It is seen that the two classifiers perform comparably with variable thresholds, and with proper thresh-olds, both outperform the previous methods of Liu et al. [ 2 ], Zhao et al. [ 21 ] and Xu et al. [ 27 ]. The learning-based filter has a further advantage that the trade-off between recall rate and precision can be flexibly tuned according to the needs of different applications.

We investigated the impacts of two levels of filtering (i.e., simple rules and learning-based filter). On one hand, we plot the performance curve of our proposed method (SVM) with-out filtering by simple rules, denoted as  X  X VM (w/o Simple) X  in Fig. 12 . Compared with the proposed method (SVM), it is shown that simple rules help improve the performance slightly, and thus, are complementary to the learning-based filter. On the other hand, we give the performance of our pro-posed method without the learning-based filter (i.e., filtering with only simple rules), denoted as  X  X imple X  in Fig. 12 .Itis shown that the three simple rules can only filter out a small portion of obvious redundant cuts while keep most of the genuine ones. In contrast, the learning-based filter can fil-ter out more redundant cuts while sacrifice some genuine ones to improve the precision. In learning-based filtering, it is inevitable to prune some genuine cuts because some of them are very similar to redundant cuts in local shape.
In Fig. 12 , we also give the precision X  X ecall curves of LDF/SVM filtering without neighboring pruning rule RULE5 (w/o R5). Compared to the default settings of LDF/SVM filtering with RULE5, it is shown that RULE5 decreases the recall rate abruptly when the precision is low. When increasing the precision, however, RULE5 gives bet-ter precision X  X ecall trade-off than filtering without RULE5. This justifies the effectiveness of RULE5 in pruning redun-dant cuts.

In order to judge the effectiveness of each stage of our proposed method (SVM with P thr = 0 . 76), we show the intermediate results in Table 3 . After the step of candidate cuts generation (before RULE1), most of touching points are detected (high recall rate) with many redundant can-didate cuts (low precision). After filtering by simple rules RULE1, RULE2 and RULE3, some obvious redundant cuts are removed (a small increase in precision), with most gen-uine ones kept. After SVM filtering (RULE4), most redun-dant cuts are removed (precision increased 40.5%) while many genuine ones are also wrongly filtered out (recall rate decreased 40.7%). The filtering step of RULE5 fur-ther improves the precision by 19.1% with the recall rate decreased only 2.3%. Finally, by re-generating some cuts in postprocessing step, we obtained the result reported in Table 2 , with recall rate increased 21.5% and precision decreased 5.5%.

For the learning-based filter, we also evaluated the effects of different geometric features. We adopt a wrapper method [ 42 ] with LDF to select feature subsets sequen-tially (sequential forward search on training data by five-fold cross validation). As a result, the order of features being selected is { f 8 , f 9 , f 6 , f 5 , f 4 , f 7 , f 2 , f recall curves using nine subsets comprising one to nine ordered features are shown in Fig. 13 . It is shown that classi-fication with all the nine features gives the best performance. The feature f 3 is last selected implying least effective but still helps improve the performance slightly. This result indi-cates that all the nine geometric features are effective for filtering candidate separating lines. The convergence of all the nine curves to a unique point ( R = 60 . 9% , P = 75 . is due to the effect of postprocessing that re-generates many separating lines even if the learning-based filter prunes all the candidate cuts at threshold P thr = 1. Our later results in Sect. 7.3 show that a moderate threshold P thr for higher recall rate than postprocessing only is beneficial for text line recognition. 7.2.1 Segmentation error analysis Figure 14 shows some examples of separating lines generated by the proposed method (SVM with P thr = 0 . 5) and three previous methods. We can see that the proposed method can correctly over-segment all the three touching images while themethodofLiuetal.[ 2 ]failsmainlyforthefailedmatching of empirically defined touching types. This contributes to an increase in recall rate. Compared with the methods of [ 21 , 27 ], the proposed method produces less redundant separating lines. This contributes to the improvement of precision.
The over-segmentation errors (failure of touching point detection) can be categorized into three types. The first type is the failure of candidate touching pattern detection, i.e., touching pattern is not processed by the splitting procedure because of small width and width-to-height ratio. Figure 12 shows that the highest recall rate is about 92%, while among the remaining 8% segmentation errors, about half (4%) are due to the failure of touching pattern detection. The second typeresultsfromthemisclassificationofagenuineseparating line as redundant one by the filter when P thr = 0 . 5. The third type is caused by the fault of RULE5 based on comparing the probabilities of neighboring candidate cuts: the probability of a genuine cut may be smaller than a neighboring redundant one. Figure 15 shows examples of three types. 7.3 Results on text line recognition task Using a text line recognition system with character classi-fier and linguistic context, we evaluated the effects of over-segmentation in terms of the string recognition performance on the test sets of touching strings in CASIA-HWDB-ST and text line images containing touching characters in CASIA-HWDB2.0. On segmenting the string image into primitive segments, consecutive segments are combined into candi-date character patterns subject to the maximum number of segments and constraint of character width. The candidate characters form a candidate segmentation lattice (an exam-ple shown in Fig. 16 ), where each path is evaluated by fus-ing character classification scores and linguistic model, and the optimal path gives the final result of character segmen-tation and recognition. The string recognizer uses a modi-fied quadratic discriminant function (MQDF) classifier [ 43 ] for character classification and character tri-gram language model, as in [ 3 ].

The string recognition performance is measured by two character-level criteria: accuracy rate (AR) and correct rate (CR) as in [ 3 , 24 ]. CR represents the percentage of characters correctly recognized while AR further considers the number of incorrect characters inserted due to over-segmentation.
In string recognition, we compared our proposed over-segmentation method with the ones of Liu et al. [ 2 ], Zhao et al. [ 21 ] and our previous method [ 27 ]. Since the post-processing step of Liu et al. [ 2 ] alone gives fairly high precision and recall rate as shown in Fig. 13 , we also evalu-ated this step for over-segmentation in string recognition. The string recognition results on single-touching strings are shown in Table 4 . It is seen that our proposed method yields the best performance in terms of AR compared with the previous over-segmentation methods. Though our pre-vious method [ 27 ] has higher recall rate of touching point detection, the number of over-segmented primitive segments complicates the path evaluation in candidate segmentation lattice and finally deteriorates the string recognition per-formance, particularly, the low AR indicates high percent-age of over-segmentation. The proposed method can flexibly adjust the trade-off between the recall rate and precision of touching point detection, and at certain threshold P thr ,itcan yield both higher AR and CR in string recognition than the other methods. The previous method of Liu et al. [ 2 ] per-forms fairly well for its balanced recall rate and precision. Using the postprocessing step only for over-segmentation, the obtained string recognition performance is inferior to that of the method of Liu et al. [ 2 ], because the low recall rate prevents some characters from being correctly segmented.
The recognition results on 1,542 text lines contain-ing touching strings from CASIA-HWDB2.0 are shown in Table 5 . For our proposed method, we set the default thresh-old P thr = 0 . 5 which allows splitting of most touching points with a moderate ratio of over-segmentation. In this case of realistic text line recognition, the string recognizer uses lin-guistic model (character tri-gram) as well as the character classifier. We can see in Table 5 that our proposed method performs best (highest AR and CR) among the comparison methods in string recognition on realistic text line images. Since linguistic context was used on these long text lines (on average, over 20 characters per line), the correct rates AR and CR are much higher than those on short touching strings (Table 4 ). And since the realistic text lines have a low proportion of touching characters, the difference of over-all performance between different over-segmentation meth-ods is small. In this case, using the postprocessing step only for over-segmentation again yields inferior string recognition performance to the method of Liu et al. [ 2 ]. This indicates that the trade-off between the recall rate and precision of over-segmentation is important for string recognition. 8 Conclusion We proposed an effective over-segmentation method with learning-based filtering for splitting Chinese handwritten characters of single-touching, which is the dominant touch-ing type in Chinese handwriting. After detecting touching points and generating candidate separating lines (cuts) with a high recall rate, we prune redundant cuts using some simple rules and a linear classifier using geometric features extracted from candidate cut and the pair of separated image segments. The geometric features are independent of the string length (number of characters) such that the proposed method is applicable to touching strings of variable length. Our experi-ments on a database of single-touching strings show that the proposed method is able to yield good trade-off between the recall rate and precision of cut detection. The extracted nine geometric features are shown to perform well in filtering with alinearclassifier.Experimentsofcharacterstringrecognition on short touching strings and on long text lines containing touching strings show that the proposed over-segmentation method leads to improved string recognition performance. The splitting of the remaining under-segmentation errors on single-touching strings and the separation of multiple-touching strings are to be addressed in our future work. References
