 Nesterov X  X  accelerated gradient is an iterative algo-rithm that was originally derived for non-stochastic gradients. It is initialized by setting k = 0, a 0 = 1,  X  1 = y 0 , y 0 to an arbitrary parameter setting, z to an arbitrary parameter setting, and " 1 = k y 0 z k / kr f ( y 0 ) r f ( z ) k . It then repeatedly updates its parameters with the following equations: f ( y a y The above presentation is relatively opaque and could be di cult to understand, so we will rewrite these equations in a more intuitive manner.
 The learning rate " t is adapted to always be smaller than the reciprocal of the  X  X bserved X  Lipshitz coe -cient of r f around the trajectory of the optimization. Alternatively, if the Lipshitz coe cient of the deriva-tive is known to be equal to L ,thensetting " t =1 /L for all t is su cient to obtain the same theoretical guarantees. This method for choosing the learning rate assumes that f is not noisy, and will result in too-large learning rates if the objective is stochastic. To understand the sequence a t , we note that the function x ! 1+ x ! x +0 . 5 from below as x !1 ,so a t  X  ( t + 4) / 2 for large t , and thus ( a t 1) /a t +1 (from eq. 9) behaves like 1 3 / ( t + 5).
 Finally, if we define then the combination of eqs. 9 and 11 implies: which can be used to rewrite eq. 7 as follows: where eq. 13 is a consequence of eq. 10. Alternatively: where  X  t  X  1 3 / ( t + 5). (Nesterov, 1983) shows that if f is a convex function with an L -Lipshitz contin-uous derivative, then the above method satisfies the following: To understand the quadratic speedup obtained by the momentum, consider applying momentum to a linear function. In this case, the i -th step of the momentum method will be of distance proportional to i ; therefore N steps could traverse a quadratically longer distance: 1+2+  X  X  X  + N = O ( N 2 ).
 We will first formulate and prove a result which es-tablishes the well known fact that first-order meth-ods such CM and NAG are invariant to orthonormal transformations (i.e. rotations) such as U . In partic-ular, we will will show that the sequence of iterates obtained by applying NAG and CM to the reparam-eterized quadratic p , is given by U times sequence of iterates obtained by applying NAG and CM to the original quadratic q . Note that the only fact we use about U at this stage is that it is orthonormal/unitary, not that it diagonalizes q .
 quence of learning rates, let x 0 ,v 0 be an arbitrary ini-tial position and velocity, and let { ( x i ,v i ) } 1 i =0 sequence of iterates obtained by CM by optimizing q starting from x 0 ,v 0 , with the learning parameters  X  i at iteration i .
 Next, let y 0 ,w 0 be given by Ux 0 ,Uv 0 , and let { ( y i ,w i ) } 1 i =0 be the sequence of iterates obtained by CM by optimizing p starting from y 0 ,w 0 ,withthe learning parameters  X  i , " i at iteration i . Then the following holds for all i : The above also applies when CM is replaced with NAG. Proof. First, notice that and that The proof is by induction. The claim is immediate for i = 0. To see that it holds for i + 1 assuming i , consider: w ) Using the above, we get This completes the proof for CM; the proof for NAG is nearly identical.
 Given this result, and reparameterization p of q ac-cording to its eigencomponents, the results of Theorem 2.1 can thus be Proof of Theorem 2.1. We first show that for separa-ble problems, CM (or NAG) is precisely equivalent to many simultaneous applications of CM (or NAG) to the one-dimensional problems that correspond to each problem dimension. We then show that for NAG, the e  X  ective momentum for a one-dimensional problem de-pends on its curvature. We prove these results for one step of CM or NAG, although these results generalize to larger n .
 Consider one step of CM v : CM v (  X , p, y, v )=  X v " r p ( y ) =(  X  [ v ] 1 " r [ y ] =(  X  [ v ] 1 " r [ p ] 1 ([ y ] 1 ) ,..., X  [ v ] n " r [ p ] =( CM v (  X , [ p ] 1 , [ y ] 1 , [ v ] 1 ) ,...,CM v (  X , [ p ] This shows that one step of CM v on q is precisely equivalent to n simultaneous applications of CM v to the one-dimensional quadratics [ q ] i , all with the same  X  and " . A similar argument shows a single step of each of CM x , on N AG x , and N AG v can be obtained by applying each of them to the n one-dimensional quadratics [ q ] i .
 Next we show that NAG, applied to a one-dimensional quadratic with a momentum coe cient  X  , is equiva-lent to CM applied to the same quadratic and with the same learning rate, but with a momentum co-e cient  X  (1 " ). We show this by expanding N AG v (  X , [ p ] i ,y,v )(where y and v are scalars):
N AG v (  X , [ q ] i ,y,v )=  X v " r [ p ] i ( y +  X v ) Since Eq. 2 is identical to 4, it follows that for all i .
 We experiment with the three autoencoder problems from Hinton &amp; Salakhutdinov (2006), which are de-scribed in Table 6.
 We considered 4 of the pathological long term de-pendency  X  X roblems X  from Hochreiter &amp; Schmidhu-ber (1997), which consist of artificial datasets designed to have various non-trivial long-range dependencies. These were the 5-bit memorization task, the 20-bit memorization task, the addition problem, and the mul-tiplication problem. These artificial problems were each designed to be impossible to learn with regular RNNs using standard optimization methods, owing to the presence of long-range temporal dependencies of the target outputs on the early inputs. And in partic-ular, despite the results of ? , they cannot be learned with ESNs that have 100 conventional hidden units (Jaeger, 2012) 1 .
 In the 5-bit memorization problem, the input sequence consists of 5 bits that are followed by a large number of blank symbols. The target sequence consists of the same 5 bits occurring at the end of the sequence, pre-ceded by blanks. The 20-bit memorization problem is similar to the 5-bit memorization problem, but the 5-bits are replaced with ten 5-ary symbols, so that each sequence contains slightly more than 20 bits of infor-mation. In the addition problem, the input sequence consists of pairs ( x, y ) of real numbers presented in se-quence, where each x is a drawn from U [0 , 1] and each y is a binary  X  X arker X  in { 0 , 1 } . The final entry of the target output sequence is determined as the sum of the x component for the two pairs whose y component is 1. The multiplication problem is analogous, and we follow the precise format used by Martens &amp; Sutskever (2011). To achieve low error on each of these tasks the RNN must learn to memorize and transform some in-formation contained at the beginning of the sequence within its hidden state, retaining it all of the way to the end. This is made especially di cult because there are no easier-to-learn short or medium-term dependencies that can act as hints to help the learning see the long-term ones, and because of the noise in the addition and the multiplication problems.
 In our experiments, we observed that the hidden state oscillations, which are likely important for relaying in-formation across long distances, had a tendency to dis-appear after the early stages of learning (see fig. 3), causing the optimization to converge to a poor local optimum. We surmised that this tendency was due to fact that the smallest modification to the parame-ters (as measured in the standard norm -the quantity which steepest descent can be thought of as minimiz-ing) that allowed the output units to predict the av-erage target output, involved making the outputs con-stant by way of making the hidden state constant. By centering the target outputs, the initial bias is correct by default, and thus the optimizer is not forced into making this  X  X oor early choice X  that dooms it later on.
 Similarly, we found it necessary to center the inputs to reliably solve the multiplication problem; the mo-mentum methods were unable to solve this problem without input centering. We speculate that the reason for this is that the inputs associated with the multipli-cation problem are positive, causing the hidden state to drift in the direction of the input-to-hidden vector, which in turn leads to saturation of the hidden state. When the inputs are centered, the net input to the hid-den units will initial be closer to zero when averaged over a reasonable window of time, thus preventing this issue.
 Figure 3 shows how the hidden state sequence evolves when the output units are not centered. While the oscillations of the RNN X  X  hidden state are preserved if the output bias is initialized to be the mean of the targets, they disappear if the output bias is set to zero (in this example, the mean of the targets is 0 . 5). This is a consequence of the isotropic nature of stochastic gradient descent which causes it to minimize the L 2 distance of its optimization paths, and of the fact that the L 2 -closest parameter setting that outputs the av-erage of the targets is obtained by slightly adjusting both the biases and making the hidden states constant, to utilize the hidden-to-output weights.
 Our hybrid HF-momentum algorithm, is characterized by the following changes to the original approach out-lined by Martens (2010): we disposed of the line search and used a fixed learning rate of 1 which, after some point chosen by hand, we gradually decayed to zero us-ing a simple schedule; we gradually increased the value of the decay constant (similarly to how we increased  X  ); and we used smaller minibatches, while computing the gradient only on the current minibatch (as opposed to the full dataset -as is commonly done with HF). Analogously to our experiments with momentum, we adjusted the settings near the end of optimization (af-ter the transient phase) to improve fine-grained local convergence/stochastic estimation. In particular, we switched back to using a more traditional version of HF along the lines of the one described by Martens (2010), which involved using much larger minibatches, or just computing the gradient on more data/the entire training set, raising the learning rate back to 1 (or as high as the larger minibatches permit), etc., and also decreasing the L2 weight decay to squeeze out some extra performance.
 The results of these experiments were encouraging, al-though preliminary, and we report them in Table 1, noting that they are not directly comparable to the experiments performed with CM and NAG due to the of use incomparable amounts of computation (fewer iterations, but with large minibatches).
 For each autoencoder training task we ran we hand-designed a schedule for the learning rate ( " ), decay constant (  X  ), and minibatch size ( s ), after a small amount of trial and error. The details for CURVES and MNIST are given below.
 For CURVES, we first ran HF iterations with 50 CG steps each, for a total of 250k CG steps, using " =1 . 0,  X  =0 . 95 and with gradient and curvature products computed on minibatches consisting of 1/16th of the training set. Next, we increased  X  to 0.999 and an-nealed " according to the schedule 500 / ( t 4000). The error reach 0.0094 by this point, and from here we tuned the method to achieve fine local conver-gence, which we achieved primarily through running the method in full batch mode. We first ran HF for 100k total CG steps with the number of CG steps per update increased to 200,  X  lowered to 0.995, and " raised back to 1 (which was stable because we were running in batch mode) . The error reach 0.087 by this point. Finally, we lowered the L2 weight decay from 2e-5 (which was used in (Martens, 2010)) to near zero and ran 500k total steps more, to arrive at an error of 0.058.
 For MNIST, we first ran HF iterations with 50 CG steps each, for a total of 25k CG steps, using " =1 . 0,  X  =0 . 95 and with gradient and curvature products computed on minibatches consisting of 1/20th of the training set. Next, we increased  X  to 0.995, " was an-nealed according to 250 /t , and the method was run for another 225k CG steps. The error reach 0.81 by this point. Finally, we focused on achieving fine conver-gence and started computing the gradient on the full training set (but still computing the curvature prod-ucts on minibatches of size 1/20th). With " set back to 1, we ran another 125k total CG steps to achieve a final error of 0.69. The L2 weight decay was set to
 Ilya Sutskever 1 ilyasu@google.com James Martens jmartens@cs.toronto.edu George Dahl gdahl@cs.toronto.edu Geo  X  rey Hinton hinton@cs.toronto.edu Deep and recurrent neural networks (DNNs and RNNs, respectively) are powerful models that achieve high performance on di cult pattern recognition prob-lems in vision, and speech (Krizhevsky et al., 2012; Hinton et al., 2012; Dahl et al., 2012; Graves, 2012). Although their representational power is appealing, the di culty of training DNNs has prevented their widepread use until fairly recently. DNNs became the subject of renewed attention following the work of Hinton et al. (2006) who introduced the idea of greedy layerwise pre-training. This approach has since branched into a family of methods (Bengio et al., 2007), all of which train the layers of the DNN in a sequence using an auxiliary objective and then  X  X ine-tune X  the entire network with standard optimization methods such as stochastic gradient descent (SGD). More recently, Martens (2010) attracted considerable attention by showing that a type of truncated-Newton method called Hessian-free Optimization (HF) is capa-ble of training DNNs from certain random initializa-tions without the use of pre-training, and can achieve lower errors for the various auto-encoding tasks con-sidered by Hinton &amp; Salakhutdinov (2006). Recurrent neural networks (RNNs), the temporal ana-logue of DNNs, are highly expressive sequence mod-els that can model complex sequence relationships. They can be viewed as very deep neural networks that have a  X  X ayer X  for each time-step with parame-ter sharing across the layers and, for this reason, they are considered to be even harder to train than DNNs. Recently, Martens &amp; Sutskever (2011) showed that the HF method of Martens (2010) could e  X  ectively train RNNs on artificial problems that exhibit very long-range dependencies (Hochreiter &amp; Schmidhuber, 1997). Without resorting to special types of memory units, these problems were considered to be impossi-bly di cult for first-order optimization methods due to the well known vanishing gradient problem (Bengio et al., 1994). Sutskever et al. (2011) and later Mikolov et al. (2012) then applied HF to train RNNs to per-form character-level language modeling and achieved excellent results.
 Recently, several results have appeared to challenge the commonly held belief that simpler first-order methods are incapable of learning deep models from random initializations. The work of Glorot &amp; Ben-gio (2010), Mohamed et al. (2012), and Krizhevsky et al. (2012) reported little di culty training neural networks with depths up to 8 from certain well-chosen random initializations. Notably, Chapelle &amp; Erhan (2011) used the random initialization of Glorot &amp; Ben-gio (2010) and SGD to train the 11-layer autoencoder of Hinton &amp; Salakhutdinov (2006), and were able to surpass the results reported by Hinton &amp; Salakhutdi-nov (2006). While these results still fall short of those reported in Martens (2010) for the same tasks, they indicate that learning deep networks is not nearly as hard as was previously believed.
 The first contribution of this paper is a much more thorough investigation of the di culty of training deep and temporal networks than has been previously done. In particular, we study the e  X  ectiveness of SGD when combined with well-chosen initialization schemes and various forms of momentum-based acceleration. We show that while a definite performance gap seems to exist between plain SGD and HF on certain deep and temporal learning problems, this gap can be elimi-nated or nearly eliminated (depending on the prob-lem) by careful use of classical momentum methods or Nesterov X  X  accelerated gradient. In particular, we show how certain carefully designed schedules for the constant of momentum  X  , which are inspired by var-ious theoretical convergence-rate theorems (Nesterov, 1983; 2003), produce results that even surpass those re-ported by Martens (2010) on certain deep-autencoder training tasks. For the long-term dependency RNN tasks examined in Martens &amp; Sutskever (2011), which first appeared in Hochreiter &amp; Schmidhuber (1997), we obtain results that fall just short of those reported in that work, where a considerably more complex ap-proach was used.
 Our results are particularly surprising given that mo-mentum and its use within neural network optimiza-tion has been studied extensively before, such as in the work of Orr (1996), and it was never found to have such an important role in deep learning. One explanation is that previous theoretical analyses and practical bench-marking focused on local convergence in the stochastic setting, which is more of an estimation problem than an optimization one (Bottou &amp; LeCun, 2004). In deep learning problems this final phase of learning is not nearly as long or important as the initial  X  X ransient phase X  (Darken &amp; Moody, 1993), where a better ar-gument can be made for the beneficial e  X  ects of mo-mentum.
 In addition to the inappropriate focus on purely local convergence rates, we believe that the use of poorly de-signed standard random initializations, such as those in Hinton &amp; Salakhutdinov (2006), and suboptimal meta-parameter schedules (for the momentum con-stant in particular) has hampered the discovery of the true e  X  ectiveness of first-order momentum methods in deep learning. We carefully avoid both of these pit-falls in our experiments and provide a simple to under-stand and easy to use framework for deep learning that is surprisingly e  X  ective and can be naturally combined with techniques such as those in Raiko et al. (2011). We will also discuss the links between classical mo-mentum and Nesterov X  X  accelerated gradient method (which has been the subject of much recent study in convex optimization theory), arguing that the latter can be viewed as a simple modification of the former which increases stability, and can sometimes provide a distinct improvement in performance we demonstrated in our experiments. We perform a theoretical analysis which makes clear the precise di  X  erence in local be-havior of these two algorithms. Additionally, we show how HF employs what can be viewed as a type of  X  X o-mentum X  through its use of special initializations to conjugate gradient that are computed from the up-date at the previous time-step. We use this property to develop a more momentum-like version of HF which combines some of the advantages of both methods to further improve on the results of Martens (2010). The momentum method (Polyak, 1964), which we refer to as classical momentum (CM), is a technique for ac-celerating gradient descent that accumulates a velocity vector in directions of persistent reduction in the ob-jective across iterations. Given an objective function f (  X  ) to be minimized, classical momentum is given by: where " &gt; 0 is the learning rate,  X  2 [0 , 1] is the mo-mentum coe cient, and r f (  X  t ) is the gradient at  X  t . Since directions d of low-curvature have, by defini-tion, slower local change in their rate of reduction (i.e., d r f ), they will tend to persist across iterations and be amplified by CM. Second-order methods also am-plify steps in low-curvature directions, but instead of accumulating changes they reweight the update along each eigen-direction of the curvature matrix by the in-verse of the associated curvature. And just as second-order methods enjoy improved local convergence rates, Polyak (1964) showed that CM can considerably accel-erate convergence to a local minimum, requiring times fewer iterations than steepest descent to reach the same level of accuracy, where R is the condition number of the curvature at the minimum and  X  is set to ( Nesterov X  X  Accelerated Gradient (abbrv. NAG; Nes-terov, 1983) has been the subject of much recent at-tention by the convex optimization community (e.g., Cotter et al., 2011; Lan, 2010). Like momentum, NAG is a first-order optimization method with better convergence rate guarantee than gradient descent in certain situations. In particular, for general smooth (non-strongly) convex functions and a deterministic gradient, NAG achieves a global convergence rate of O (1 /T 2 )(versusthe O (1 /T ) of gradient descent), with constant proportional to the Lipschitz coe cient of the derivative and the squared Euclidean distance to the solution. While NAG is not typically thought of as a type of momentum, it indeed turns out to be closely re-lated to classical momentum, di  X  ering only in the pre-cise update of the velocity vector v , the significance of which we will discuss in the next sub-section. Specifi-cally, as shown in the appendix, the NAG update may be rewritten as: While the classical convergence theories for both meth-ods rely on noiseless gradient estimates (i.e., not stochastic), with some care in practice they are both applicable to the stochastic setting. However, the the-ory predicts that any advantages in terms of asymp-totic local rate of convergence will be lost (Orr, 1996; Wiegerinck et al., 1999), a result also confirmed in ex-periments (LeCun et al., 1998). For these reasons, interest in momentum methods diminished after they had received substantial attention in the 90 X  X . And be-cause of this apparent incompatibility with stochastic optimization, some authors even discourage using mo-mentum or downplay its potential advantages (LeCun et al., 1998).
 However, while local convergence is all that matters in terms of asymptotic convergence rates (and on cer-tain very simple/shallow neural network optimization problems it may even dominate the total learning time), in practice, the  X  X ransient phase X  of convergence (Darken &amp; Moody, 1993), which occurs before fine lo-cal convergence sets in, seems to matter a lot more for optimizing deep neural networks. In this transient phase of learning, directions of reduction in the ob-jective tend to persist across many successive gradient estimates and are not completely swamped by noise. Although the transient phase of learning is most no-ticeable in training deep learning models, it is still no-ticeable in convex objectives. The convergence rate of stochastic gradient descent on smooth convex func-tions is given by O ( L/T + / variance in the gradient estimate and L is the Lip-shits coe cient of r f . In contrast, the convergence rate of an accelerated gradient method of Lan (2010) (which is related to but di  X  erent from NAG, in that it combines Nesterov style momentum with dual aver-aging) is O ( L/T 2 + / tives, momentum-based methods will outperform SGD in the early or transient stages of the optimization where L/T is the dominant term. However, the two methods will be equally e  X  ective during the final stages of the optimization where / (i.e., when the optimization problem resembles an es-timation one). 2.1. The Relationship between CM and NAG From Eqs. 1-4 we see that both CM and NAG compute the new velocity by applying a gradient-based correc-tion to the previous velocity vector (which is decayed), and then add the velocity to  X  t . But while CM com-putes the gradient update from the current position  X  , NAG first performs a partial update to  X  t , comput-ing  X  t +  X v t , which is similar to  X  t +1 ,butmissingthe as yet unknown correction. This benign-looking dif-ference seems to allow NAG to change v in a quicker and more responsive way, letting it behave more sta-bly than CM in many situations, especially for higher values of  X  .
 Indeed, consider the situation where the addition of  X v t results in an immediate undesirable increase in the objective f . The gradient correction to the ve-locity v t is computed at position  X  t +  X v t and if  X v t is indeed a poor update, then r f (  X  t +  X v t ) will point back towards  X  t more strongly than r f (  X  t )does,thus providing a larger and more timely correction to v t than CM. See fig. 1 for a diagram which illustrates this phenomenon geometrically. While each iteration of NAG may only be slightly more e  X  ective than CM at correcting a large and inappropriate velocity, this di  X  erence in e  X  ectiveness may compound as the al-gorithms iterate. To demonstrate this compounding, we applied both NAG and CM to a two-dimensional oblong quadratic objective, both with the same mo-mentum and learning rate constants (see fig. 2 in the appendix). While the optimization path taken by CM exhibits large oscillations along the high-curvature ver-tical direction, NAG is able to avoid these oscillations almost entirely, confirming the intuition that it is much more e  X  ective than CM at decelerating over the course of multiple iterations, thus making NAG more tolerant of large values of  X  compared to CM.
 In order to make these intuitions more rigorous and help quantify precisely the way in which CM and NAG di  X  er, we analyzed the behavior of each method when applied to a positive definite quadratic objective q ( x )= x &gt; Ax/ 2+ b &gt; x . We can think of CM and NAG as operating independently over the di  X  erent eigendi-rections of A . NAG operates along any one of these directions equivalently to CM, except with an e  X  ective value of  X  that is given by  X  (1 " ), where is the associated eigenvalue/curvature.
 The first step of this argument is to reparameterize q ( x ) in terms of the coe cients of x under the basis of eigenvectors of A . Note that since A = U &gt; DU for a diagonal D and orthonormal U (as A is symmetric), we can reparameterize q ( x ) by the matrix transform U and optimize y = Ux using the objective p ( y )  X  y
Dy/ 2+ c &gt; y ,where c = Ub . We can further rewrite p as p ( y )= and i &gt; 0 are the diagonal entries of D (and thus the eigenvalues of A ) and correspond to the curva-ture along the associated eigenvector directions. As shown in the appendix (Proposition 6.1), both CM and NAG, being first-order methods, are  X  X nvariant X  to these kinds of reparameterizations by orthonormal transformations such as U . Thus when analyzing the behavior of either algorithm applied to q ( x ), we can in-stead apply them to p ( y ), and transform the resulting sequence of iterates back to the default parameteriza-tion (via multiplication by U 1 = U &gt; ).
 Theorem 2.1. Let p ( y )= [ p ] i ( t )= i t 2 / 2+ c i t . Let " be arbitrary and fixed. Denote by CM x (  X ,p,y,v ) and CM v (  X ,p,y,v ) the pa-rameter vector and the velocity vector respectively, ob-tained by applying one step of CM (i.e., Eq. 1 and then Eq. 2) to the function p at point y , with velocity v , momentum coe cient  X  ,andlearningrate " . Define NAG x and NAG v analogously. Then the following holds for z 2 { x , v } :
CM z (  X ,p,y,v )= NAG z (  X ,p,y,v )= Proof. See the appendix.
 The theorem has several implications. First, CM and NAG become equivalent when " is small (when "  X  1 for every eigenvalue of A ), so NAG and CM are distinct only when " is reasonably large. When " is relatively large, NAG uses smaller e  X  ective momentum for the high-curvature eigen-directions, which prevents oscillations (or divergence) and thus allows the use of a larger  X  than is possible with CM for a given " . The aim of our experiments is three-fold. First, to investigate the attainable performance of stochastic momentum methods on deep autoencoders starting from well-designed random initializations; second, to explore the importance and e  X  ect of the schedule for the momentum parameter  X  assuming an optimal fixed choice of the learning rate " ; and third, to compare the performance of NAG versus CM.
 For our experiments with feed-forward nets, we fo-cused on training the three deep autoencoder prob-lems described in Hinton &amp; Salakhutdinov (2006) (see sec. A.2 for details). The task of the neural net-work autoencoder is to reconstruct its own input sub-ject to the constraint that one of its hidden layers is of low-dimension. This  X  X ottleneck X  layer acts as a low-dimensional code for the original input, similar to other dimensionality reduction techniques like Princi-ple Component Analysis (PCA). These autoencoders are some of the deepest neural networks with pub-lished results, ranging between 7 and 11 layers, and have become a standard benchmarking problem (e.g., Martens, 2010; Glorot &amp; Bengio, 2010; Chapelle &amp; Er-han, 2011; Raiko et al., 2011). See the appendix for more details.
 Because the focus of this study is on optimization, we only report training errors in our experiments. Test error depends strongly on the amount of overfitting in these problems, which in turn depends on the type and amount of regularization used during training. While regularization is an issue of vital importance when de-signing systems of practical utility, it is outside the scope of our discussion. And while it could be ob-jected that the gains achieved using better optimiza-tion methods are only due to more exact fitting of the training set in a manner that does not generalize, this is simply not the case in these problems, where under-trained solutions are known to perform poorly on both the training and test sets (underfitting).
 The networks we trained used the standard sigmoid nonlinearity and were initialized using the  X  X parse ini-tialization X  technique (SI) of Martens (2010) that is described in sec. 3.1. Each trial consists of 750,000 parameter updates on minibatches of size 200. No reg-ularization is used. The schedule for  X  was given by the following formula: where  X  max was chosen from tivated by Nesterov (1983) who advocates using what amounts to  X  t =1 3 / ( t +5) after some manipulation (see appendix), and by Nesterov (2003) who advocates a constant  X  t that depends on (essentially) the con-dition number. The constant  X  t achieves exponential convergence on strongly convex functions, while the 1 3 / ( t +5) schedule is appropriate when the function is not strongly convex. The schedule of Eq. 5 blends these proposals. For each choice of  X  max , we report the learning rate that achieved the best training error. Given the schedule for  X  , the learning rate " was in order to achieve the lowest final error training error after our fixed number of updates.
 Table 1 summarizes the results of these experiments. It shows that NAG achieves the lowest published results on this set of problems, including those of Martens (2010). It also shows that larger values of  X  max tend to achieve better performance and that NAG usually outperforms CM, especially when  X  max is 0.995 and 0.999. Most surprising and importantly, the results demonstrate that NAG can achieve results that are comparable with some of the best HF results for training deep autoencoders. Note that the previ-ously published results on HF used L2 regularization, so they cannot be directly compared. However, the table also includes experiments we performed with an improved version of HF (see sec. 2.1) where weight decay was removed towards the end of training. We found it beneficial to reduce  X  to 0.9 (unless  X  is 0, in which case it is unchanged) during the final 1000 parameter updates of the optimization without reducing the learning rate, as shown in Table 2. It appears that reducing the momentum coe cient al-lows for finer convergence to take place whereas oth-erwise the overly aggressive nature of CM or NAG would prevent this. This phase shift between opti-mization that favors fast accelerated motion along the error surface (the  X  X ransient phase X ) followed by more careful optimization-as-estimation phase seems consis-tent with the picture presented by Darken &amp; Moody (1993). However, while asymptotically it is the second phase which must eventually dominate computation time, in practice it seems that for deeper networks in particular, the first phase dominates overall computa-tion time as long as the second phase is cut o  X  before the remaining potential gains become either insignifi-cant or entirely dominated by overfitting (or both). It may be tempting then to use lower values of  X  from the outset, or to reduce it immediately when progress in reducing the error appears to slow down. However, in our experiments we found that doing this was detri-mental in terms of the final errors we could achieve, and that despite appearing to not make much progress, or even becoming significantly non-monotonic, the op-timizers were doing something apparently useful over these extended periods of time at higher values of  X  . A speculative explanation as to why we see this be-havior is as follows. While a large value of  X  allows the momentum methods to make useful progress along slowly-changing directions of low-curvature, this may not immediately result in a significant reduction in er-ror, due to the failure of these methods to converge in the more turbulent high-curvature directions (which is especially hard when  X  is large). Nevertheless, this progress in low-curvature directions takes the optimiz-ers to new regions of the parameter space that are characterized by closer proximity to the optimum (in the case of a convex objective), or just higher-quality local minimia (in the case of non-convex optimiza-tion). Thus, while it is important to adopt a more careful scheme that allows fine convergence to take place along the high-curvature directions, this must be done with care. Reducing  X  and moving to this fine convergence regime too early may make it di cult for the optimization to make significant progress along the low-curvature directions, since without the benefit of momentum-based acceleration, first-order methods are notoriously bad at this (which is what motivated the use of second-order methods like HF for deep learn-ing).
 3.1. Random Initializations The results in the previous section were obtained with standard logistic sigmoid neural networks that were initialized with the sparse initialization technique (SI) described in Martens (2010). In this scheme, each ran-dom unit is connected to 15 randomly chosen units in the previous layer, whose weights are drawn from a unit Gaussian, and the biases are set to zero. The in-tuitive justification is that the total amount of input to each unit will not depend on the size of the previ-ous layer and hence they will not as easily saturate. Meanwhile, because the inputs to each unit are not all randomly weighted blends of the outputs of many 100s or 1000s of units in the previous layer, they will tend to be qualitatively more  X  X iverse X  in their response to inputs. When using tanh units, we transform the weights to simulate sigmoid units by setting the biases to 0.5 and rescaling the weights by 0.25.
 We investigated the performance of the optimization as a function of the scale constant used in SI (which defaults to 1 for sigmoid units). We found that SI works reasonably well if it is rescaled by a factor of 2, but leads to noticeable (but not severe) slow down when scaled by a factor of 3. When we used the factor 1/2 or 5 we did not achieve sensible results. Echo-State Networks (ESNs) is a family of RNNs with an unusually simple training method: their hidden-to-output connections are learned from data, but their re-current connections are fixed to a random draw from a specific distribution and are not learned. Despite their simplicity, ESNs with many hidden units (or with units with explicit temporal integration, like the LSTM) have achieved high performance on tasks with long range dependencies ( ? ). In this section, we inves-tigate the e  X  ectiveness of momentum-based methods with ESN-inspired initialization at training RNNs with conventional size and standard (i.e., non-integrating) neurons. We find that momentum-accelerated SGD can successfully train such RNNs on various artificial datasets exhibiting considerable long-range temporal dependencies. This is unexpected because RNNs were believed to be almost impossible to successfully train on such datasets with first-order methods, due to var-ious di culties such as vanishing/exploding gradients (Bengio et al., 1994). While we found that the use of momentum significantly improved performance and robustness, we obtained nontrivial results even with standard SGD, provided that the learning rate was set low enough. Each task involved optimizing the parameters of a ran-domly initialized RNN with 100 standard tanh hidden units (the same model used by Martens &amp; Sutskever (2011)). The tasks were designed by Hochreiter &amp; Schmidhuber (1997), and are referred to as training  X  X roblems X . See sec. A.3 of the appendix for details. 4.1. ESN-based Initialization As argued by Jaeger &amp; Haas (2004), the spectral ra-dius of the hidden-to-hidden matrix has a profound e  X  ect on the dynamics of the RNN X  X  hidden state (with a tanh nonlinearity). When it is smaller than 1, the dynamics will have a tendency to quickly  X  X or-get X  whatever input signal they may have been ex-posed to. When it is much larger than 1, the dy-namics become oscillatory and chaotic, allowing it to generate responses that are varied for di  X  erent input histories. While this allows information to be retained over many time steps, it can also lead to severe explod-ing gradients that make gradient-based learning much more di cult. However, when the spectral radius is only slightly greater than 1, the dynamics remain os-cillatory and chaotic while the gradient are no longer exploding (and if they do explode, then only  X  X lightly so X ), so learning may be possible with a spectral ra-dius of this order. This suggests that a spectral radius of around 1 . 1maybee  X  ective.
 To achieve robust results, we also found it is essential to carefully set the initial scale of the input-to-hidden connections. When training RNNs to solve those tasks that possess many random and irrelevant distractor in-puts, we found that having the scale of these connec-tions set too high at the start led to relevant informa-tion in the hidden state being too easily  X  X verwritten X  by the many irrelevant signals, which ultimately led the optimizer to converge towards an extremely poor local minimum where useful information was never re-layed over long distances. Conversely, we found that if this scale was set too low, it led to significantly slower learning. Having experimented with multiple scales we found that a Gaussian draw with a standard deviation of 0.001 achieved a good balance between these con-cerns. However, unlike the value of 1.1 for the spectral radius of the dynamics matrix, which worked well on all tasks, we found that good choices for initial scale of the input-to-hidden weights depended a lot on the particular characteristics of the particular task (such as its dimensionality or the input variance). Indeed, for tasks that do not have many irrelevant inputs, a larger scale of the input-to-hidden weights (namely, 0.1) worked better, because the aforementioned dis-advantage of large input-to-hidden weights does not apply. See table 4 for a summary of the initializations used in the experiments. Finally, we found centering (mean subtraction) of both the inputs and the outputs to be important to reliably solve all of the training problems. See the appendix for more details. 4.2. Experimental Results We conducted experiments to determine the e -cacy of our initializations, the e  X  ect of momentum, and to compare NAG with CM. Every learning trial used the aforementioned initialization, 50,000 param-eter updates and on minibatches of 100 sequences, and the following schedule for the momentum co-e cient  X  :  X  =0 . 9 for the first 1000 parameter, after which  X  =  X  0 ,where  X  0 can take the fol-lowing values { 0 , 0 . 9 , 0 . 98 , 0 . 995 } . For each  X  use the empirically best learning rate chosen from { 10 3 , 10 4 , 10 5 , 10 6 } .
 The results are presented in Table 5, which are the av-erage loss over 4 di  X  erent random seeds. Instead of re-porting the loss being minimized (which is the squared error or cross entropy), we use a more interpretable zero-one loss, as is standard practice with these prob-lems. For the bit memorization, we report the frac-tion of timesteps that are computed incorrectly. And for the addition and the multiplication problems, we report the fraction of cases where the RNN the error in the final output prediction exceeded 0.04. Our results show that despite the considerable long-range dependencies present in training data for these problems, RNNs can be successfully and robustly trained to solve them, through the use of the initial-ization discussed in sec. 4.1, momentum of the NAG type, a large  X  0 , and a particularly small learning rate (as compared with feedforward networks). Our results also suggest that with larger values of  X  0 achieve bet-ter results with NAG but not with CM, possibly due to NAG X  X  tolerance of larger  X  0  X  X  (as discussed in sec. 2). Although we were able to achieve surprisingly good training performance on these problems using a suf-ficiently strong momentum, the results of Martens &amp; Sutskever (2011) appear to be moderately better and more robust. They achieved lower error rates and their initialization was chosen with less care, although the initializations are in many ways similar to ours. No-tably, Martens &amp; Sutskever (2011) were able to solve these problems without centering, while we had to use centering to solve the multiplication problem (the other problems are already centered). This suggests that the initialization proposed here, together with the method of Martens &amp; Sutskever (2011), could achieve even better performance. But the main achievement of these results is a demonstration of the ability of momentum methods to cope with long-range tempo-ral dependency training tasks to a level which seems su cient for most practical purposes. Moreover, our approach seems to be more tolerant of smaller mini-batches, and is considerably simpler than the partic-ular version of HF proposed in Martens &amp; Sutskever (2011), which used a specialized update damping tech-nique whose benefits seemed mostly limited to training RNNs to solve these kinds of extreme temporal depen-dency problems. Truncated Newton methods, that include the HF method of Martens (2010) as a particular example, work by optimizing a local quadratic model of the objective via the linear conjugate gradient algorithm (CG), which is a first-order method. While HF, like all truncated-Newton methods, takes steps computed using partially converged calls to CG, it is naturally accelerated along at least some directions of lower cur-vature compared to the gradient. It can even be shown (Martens &amp; Sutskever, 2012) that CG will tend to fa-vor convergence to the exact solution to the quadratic sub-problem first along higher curvature directions (with a bias towards those which are more clustered together in their curvature-scalars/eigenvalues). While CG accumulates information as it iterates which allows it to be optimal in a much stronger sense than any other first-order method (like NAG), once it is terminated, this information is lost. Thus, standard truncated Newton methods can be thought of as per-sisting information which accelerates convergence (of the current quadratic) only over the number of itera-tions CG performs. By contrast, momentum methods persist information that can inform new updates across an arbitrary number of iterations.
 One key di  X  erence between standard truncated New-ton methods and HF is the use of  X  X ot-started X  calls to CG, which use as their initial solution the one found at the previous call to CG. While this solution was com-puted using old gradient and curvature information from a previous point in parameter space and possi-bly a di  X  erent set of training data, it may be well-converged along certain eigen-directions of the new quadratic, despite being very poorly converged along others (perhaps worse than the default initial solution of ~ 0). However, to the extent to which the new local quadratic model resembles the old one, and in partic-ular in the more di cult to optimize directions of low-curvature (which will arguably be more likely to per-sist across nearby locations in parameter space), the previous solution will be a preferable starting point to 0, and may even allow for gradually increasing levels of convergence along certain directions which persist in the local quadratic models across many updates. The connection between HF and momentum methods can be made more concrete by noticing that a single step of CG is e  X  ectively a gradient update taken from the current point, plus the previous update reapplied, just as with NAG, and that if CG terminated after just 1 step, HF becomes equivalent to NAG, except that it uses a special formula based on the curvature matrix for the learning rate instead of a fixed constant. The most e  X  ective implementations of HF even employ a  X  X ecay X  constant (Martens &amp; Sutskever, 2012) which acts analogously to the momentum constant  X  .Thus, in this sense, the CG initializations used by HF allow us to view it as a hybrid of NAG and an exact second-order method, with the number of CG iterations used to compute each update e  X  ectively acting as a dial between the two extremes.
 Inspired by the surprising success of momentum-based methods for deep learning problems, we experimented with making HF behave even more like NAG than it al-ready does. The resulting approach performed surpris-ingly well (see Table 1). For a more detailed account of these experiments, see sec. A.6 of the appendix. If viewed on the basis of each CG step (instead of each update to parameters  X  ), HF can be thought of as a peculiar type of first-order method which approx-imates the objective as a series of quadratics only so that it can make use of the powerful first-order CG method. So apart from any potential benefit to global convergence from its tendency to prefer certain direc-tions of movement in parameter space over others, per-haps the main theoretical benefit to using HF over a first-order method like NAG is its use of CG, which, while itself a first-order method, is well known to have strongly optimal convergence properties for quadrat-ics, and can take advantage of clustered eigenvalues to accelerate convergence (see Martens &amp; Sutskever (2012) for a detailed account of this well-known phe-nomenon). However, it is known that in the worst case that CG, when run in batch mode, will converge asymptotically no faster than NAG (also run in batch mode) for certain specially designed quadratics with very evenly distributed eigenvalues/curvatures. Thus it is worth asking whether the quadratics which arise during the optimization of neural networks by HF are such that CG has a distinct advantage in optimizing them over NAG, or if they are closer to the aforemen-tioned worst-case examples. To examine this question we took a quadratic generated during the middle of a typical run of HF on the curves dataset and compared the convergence rate of CG, initialized from zero, to NAG (also initialized from zero). Figure 5 in the ap-pendix presents the results of this experiment. While this experiment indicates some potential advantages to HF, the closeness of the performance of NAG and HF suggests that these results might be explained by the solutions leaving the area of trust in the quadratics be-fore any extra speed kicks in, or more subtly, that the faithfulness of approximation goes down just enough as CG iterates to o  X  set the benefit of the acceleration it provides. Martens (2010) and Martens &amp; Sutskever (2011) demonstrated the e  X  ectiveness of the HF method as a tool for performing optimizations for which previ-ous attempts to apply simpler first-order methods had failed. While some recent work (Chapelle &amp; Erhan, 2011; Glorot &amp; Bengio, 2010) suggested that first-order methods can actually achieve some success on these kinds of problems when used in conjunction with good initializations, their results still fell short of those re-ported for HF. In this paper we have completed this picture and demonstrated conclusively that a large part of the remaining performance gap that is not addressed by using a well-designed random initializa-tion is in fact addressed by careful use of momentum-based acceleration (possibly of the Nesterov type). We showed that careful attention must be paid to the mo-mentum constant  X  , as predicted by the theory for local and convex optimization.
 Momentum-accelerated SGD, despite being a first-order approach, is capable of accelerating directions of low-curvature just like an approximate Newton method such as HF. Our experiments support the idea that this is important, as we observed that the use of stronger momentum (as determined by  X  ) had a dra-matic e  X  ect on optimization performance, particularly for the RNNs. Moreover, we showed that HF can be viewed as a first-order method, and as a generalization of NAG in particular, and that it already derives some of its benefits through a momentum-like mechanism.
