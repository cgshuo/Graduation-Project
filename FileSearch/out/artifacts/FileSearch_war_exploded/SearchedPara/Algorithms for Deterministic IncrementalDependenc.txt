 V  X  axj  X  o University, Uppsala University have often been considered inadequate for natural language parsing because of the massive ambiguity typically found in natural language grammars. Nevertheless, it has been shown for deterministic incremental dependency parsing, formalized as transition systems. We then describe and analyze two families of such algorithms: stack-based and list-based algorithms. projectivevariant.Foreachofthefouralgorithms,wegiveproofsofcorrectnessandcomplexity. In addition, we perform an experimental evaluation of all algorithms in combination with
SVMclassifiersforpredictingthenextparsingaction,usingdatafromthirteenlanguages.We proportion of non-projective constructions. However, the projective algorithms often produce comparableresultswhencombinedwiththetechniqueknownaspseudo-projectiveparsing.The linear time complexity of the stack-based algorithms gives them an advantage with respect to beequallyefficientinpractice.Moreover,whentheprojectivealgorithmsareusedtoimplement pseudo-projectiveparsing,theysometimesbecomelessefficientinparsing(butnotinlearning) thanthenon-projectivelist-basedalgorithm.Althoughmostofthealgorithmshavebeenpartially algorithmswithinaunifiedframework. 1. Introduction
Because parsers for natural language have to cope with a high degree of ambigu-ity and nondeterminism, they are typically based on different techniques than the ones used for parsing well-defined formal languages X  X or example, in compilers for programming languages. Thus, the mainstream approach to natural language parsing typically making use of dynamic programming and well-formed substring tables or charts. When disambiguation is required, this approach can be coupled with a statistical model for parse selection that ranks competing analyses with respect to plausibility.
Although it is often necessary, for efficiency reasons, to prune the search space prior to the ranking of complete analyses, this type of parser always has to handle multiple analyses.
 techniques, which are maximally efficient in that they only derive one analysis. This is possible because the formal language can be defined by a non-ambiguous formal grammar that assigns a single canonical derivation to each string in the language, a property that cannot be maintained for any realistically sized natural language gram-mar. Consequently, these deterministic parsing techniques have been much less popular for natural language parsing, except as a way of modeling human sentence process-ing, which appears to be at least partly deterministic in nature (Marcus 1980; Shieber 1983).
 for natural language can be achieved using a pseudo-deterministic approach, where treebank-induced classifiers are used to predict the optimal next derivation step when faced with a nondeterministic choice between several possible actions. Compared to the more traditional methods for natural language parsing, this can be seen as a severe form of pruning, where parse selection is performed incrementally so that only a single analysis is derived by the parser. This has the advantage of making the parsing process very simple and efficient but the potential disadvantage that overall accuracy suffers because of the early commitment enforced by the greedy search strategy. Somewhat surprisingly, though, research has shown that, with the right choice of parsing algorithm and classifier, this type of parser can achieve state-of-the-art accuracy, especially when used with dependency-based syntactic representations.
 (2002) for unlabeled dependency parsing of Japanese with head-final dependencies only. The algorithm was generalized to allow both head-final and head-initial depen-dencies by Yamada and Matsumoto (2003), who reported very good parsing accuracy for English, using dependency structures extracted from the Penn Treebank for training and testing. The approach was extended to labeled dependency parsing by Nivre, Hall, and Nilsson (2004) (for Swedish) and Nivre and Scholz (2004) (for English), using a different parsing algorithm first presented in Nivre (2003). At a recent evaluation of data-driven systems for dependency parsing with data from 13 different languages (Buchholz and Marsi 2006), the deterministic classifier-based parser of Nivre et al. (2006) reached top performance together with the system of McDonald, Lerman, and Pereira (2006), which is based on a global discriminative model with online learning. These results indicate that, at least for dependency parsing, deterministic parsing is possible without a drastic loss in accuracy. The deterministic classifier-based approach has also been applied to phrase structure parsing (Kalt 2004; Sagae and Lavie 2005), although the accuracy for this type of representation remains a bit below the state of the art. In this setting, more competitive results have been achieved using probabilistic classifiers and beam search, rather than strictly deterministic search, as in the work by Ratnaparkhi (1997, 1999) and Sagae and Lavie (2006).
 parsing algorithm, which defines the derivation of a syntactic analysis as a sequence 514 of elementary parsing actions; a feature model, which defines a feature vector represen-tation of the parser state at any given time; and a classifier, which maps parser states, as represented by the feature model, to parsing actions. Although different types of parsing algorithms, feature models, and classifiers have been used for deterministic dependency parsing, there are very few studies that compare the impact of different components. The notable exceptions are Cheng, Asahara, and Matsumoto (2005), who compare two different algorithms and two types of classifier for parsing Chinese, and
Hall, Nivre, and Nilsson (2006), who compare two types of classifiers and several types of feature models for parsing Chinese, English, and Swedish.
 families of algorithms that can be used for deterministic dependency parsing, supported partially processed tokens and is restricted to the derivation of projective dependency structures. The algorithms of Kudo and Matsumoto (2002), Yamada and Matsumoto (2003), and Nivre (2003, 2006b) all belong to this family. The second family, represented by the algorithms described by Covington (2001) and recently explored for classifier-based parsing in Nivre (2007), instead uses open lists for partially processed tokens, which allows arbitrary dependency structures to be processed (in particular, structures with non-projective dependencies). We provide a detailed analysis of four different algorithms, two from each family, and give proofs of correctness and complexity for each algorithm. In addition, we perform an experimental evaluation of accuracy and efficiency for the four algorithms, combined with state-of-the-art classifiers, using data from 13 different languages. Although variants of these algorithms have been partially described in the literature before, this is the first comprehensive analysis and evaluation of the algorithms within a unified framework.
 dependency parsing and Section 3 presents a formal framework for the characterization of deterministic incremental parsing algorithms. Sections 4 and 5 contain the formal analysis of four different algorithms, defined within the formal framework, with proofs of correctness and complexity. Section 6 presents the experimental evaluation; Section 7 reports on related work; and Section 8 contains our main conclusions. 2. Dependency Parsing
Dependency-based syntactic theories are based on the idea that syntactic structure can be analyzed in terms of binary, asymmetric dependency relations holding between the words of a sentence. This basic conception of syntactic structure underlies a variety of 1988), and Word Grammar (Hudson 1990). In computational linguistics, dependency-based syntactic representations have in recent years been used primarily in data-driven models, which learn to produce dependency structures for sentences solely from an annotated corpus, as in the work of Eisner (1996), Yamada and Matsumoto (2003), Nivre, Hall, and Nilsson (2004), and McDonald, Crammer, and Pereira (2005), among others.
One potential advantage of such models is that they are easily ported to any domain or language in which annotated resources exist.
 dency graph , which represents each word and its syntactic dependents through labeled directed arcs. This is exemplified in Figure 1, for a Czech sentence taken from the Prague  X   X 
English sentence taken from the Penn Treebank (Marcus, Santorini, and Marcinkiewicz 1993; Marcus et al. 1994). 1 An artificial word ROOT has been inserted at the beginning of each sentence, serving as the unique root of the graph. This is a standard device that simplifies both theoretical definitions and computational implementations. Definition 1 x = ( w 0 , w 1 , ... , w n ) is a labeled directed graph G = ( V , A ), where 1. V = { 0, 1, ... , n } is a set of nodes, 2. A  X  V  X  L  X  V is a set of labeled directed arcs.

The set V of nodes (or vertices ) is the set of non-negative integers up to and including n , each corresponding to the linear position of a word in the sentence (including are nodes and l is a dependency label. Because arcs are used to represent dependency relations, we will say that i is the head and l is the dependency type of j . Conversely, we say that j is a dependent of i . 516 Definition 2
A dependency graph G = ( V , A )is well-formed if and only if: 1. The node 0 is a root, that is, there is no node i and label l such that 2. Every node has at most one head and one label, that is, if ( i , l , j ) 3. The graph G is acyclic, that is, there is no (non-empty) subset of arcs We will refer to conditions 1 X 3 as R OOT ,S INGLE -H EAD ,andA CYCLICITY , respectively.
Any dependency graph satisfying these conditions is a dependency forest ;ifitisalso noting that any dependency forest can be turned into a dependency tree by adding arcs from the node 0 to all other roots.
 Definition 3
A dependency graph G = ( V , A )is projective if and only if, for every arc ( i , l , j )
A and node k  X  V ,if i &lt; k &lt; j or j &lt; k &lt; i then there is a subset of arcs ( i , l 2 , i 2 ), ... ( i k  X  1 , l k , i k ) } X  A such that i
In a projective dependency graph, every node has a continuous projection, where the projection of a node i is the set of nodes reachable from i in the reflexive and transitive closure of the arc relation. This corresponds to the ban on discontinuous constituents in orthodox phrase structure representations. We call this condition P ROJECTIVITY .
When discussing P ROJECTIVITY , we will often use the notation i is reachable from i in the reflexive and transitive closure of the arc relation. Example 1 For the graphs depicted in Figures 1 and 2, we have:
Both G 1 and G 2 are well-formed dependency forests (dependency trees, to be specific), from node 5 by following dependency arcs. 3. Deterministic Incremental Dependency Parsing
In this section, we introduce a formal framework for the specification of deterministic dependency parsing algorithms in terms of two components: a transition system , which is nondeterministic in the general case, and an oracle , which always picks a single transition out of every parser configuration. The use of transition systems to study computation is a standard technique in theoretical computer science, which is here combined with the notion of oracles in order to characterize parsing algorithms with deterministic search. In data-driven dependency parsing, oracles normally take the form of classifiers, trained on treebank data, but they can also be defined in terms of grammars and heuristic disambiguation rules (Nivre 2003).
 algorithms that have previously been described in different traditions and to compare their formal properties within a single unified framework. In particular, whereas this type of framework has previously been used to characterize algorithms in the stack-based family (Nivre 2003, 2006b; Attardi 2006), it is here being used also for the list-based algorithms first discussed by Covington (2001).
 Definition 4
A transition system for dependency parsing is a quadruple S = ( C , T , c 1. C is a set of configurations , each of which contains a buffer  X  of 2. T is a set of transitions, each of which is a (partial) function t : C 3. c s is an initialization function, mapping a sentence x = ( w 4. C t  X  C is a set of terminal configurations.

A configuration is required to contain at least a buffer  X  , initially containing the nodes [1, ... , n ] corresponding to the real words of a sentence x = ( w
A of dependency arcs, defined on the nodes in V = { 0, 1, ... , n dependency labels L . The specific transition systems defined in Sections 4 and 5 will extend this basic notion of configuration with different data structures, such as stacks a configuration c ;wealsouse |  X  | to refer to the length of  X  (i.e., the number of nodes in the buffer) and we use [ ] to denote an empty buffer.
 Definition 5 ( w , w 1 , ... , w n )in S is a sequence C 0, m = ( c 0 , c 1 1. c 0 = c s ( x ), 2. c m  X  C t , 3. for every i (1  X  i  X  m ), c i = t ( c i  X  1 )forsome t
The parse assigned to x by C 0, m is the dependency graph G where A c m is the set of dependency arcs in c m .

Starting from the initial configuration for the sentence to be parsed, transitions will manipulate  X  and A (and other available data structures) until a terminal configuration is reached. Because the node set V is given by the input sentence itself, the set A dependency arcs in the terminal configuration will determine the output dependency graph G c m = ( V , A c m ). 518 Definition 6 c  X  C and transition t  X  T , it holds that: 1. if  X  c = [ ] then c  X  C t , 3. if a  X  A c then a  X  A t ( c ) .

The first two conditions state that the buffer  X  never grows in size and that parsing terminates as soon as it becomes empty; the third condition states that arcs added to A can never be removed. Note that this is only one of several possible notions of incrementality in parsing. A weaker notion would be to only require that the set of arcs is built monotonically (the third condition); a stronger notion would be to require also that nodes in  X  are processed strictly left to right.
 Definition 7
Let S = ( C , T , c s , C t ) be a transition system for dependency parsing. 1. S is sound for a class G of dependency graphs if and only if, for every 2. S is complete for a class G of dependency graphs if and only if, for every 3. S is correct for a class G of dependency graphs if and only if it is sound
The notions of soundness and completeness, as defined here, can be seen as correspond-ing to the notions of soundness and completeness for grammar parsing algorithms, according to which an algorithm is sound if it only derives parses licensed by the grammar and complete if it derives all such parses (Shieber, Schabes, and Pereira 1995). sequence for every sentence, or there may be more than one such sequence. The systems defined in Sections 4 and 5 will all be such that, for any input sentence more than one).
 Definition 8
An oracle for a transition system S = ( C , T , c s , C t achieved by the following simple algorithm:
It is easy to see that, provided that there is at least one transition sequence in S for every sentence, such a parser constructs exactly one transition sequence C sentence x and returns the parse defined by the terminal configuration c
G ration c to a transition t , from the transition t itself, which maps a configuration c to a new configuration c , is to have a clear separation between the abstract machine defined by the transition system, which determines formal properties such as correctness and complexity, and the search mechanism used when executing the machine.
 of approximating oracles with classifiers trained on treebank data. However, in the formal characterization of different parsing algorithms in Sections 4 and 5, we will concentrate on properties of the underlying transition systems. In particular, assuming is reasonable in most cases, the worst-case time complexity of a deterministic parser based on a transition system S is given by an upper bound on the length of transition sequences in S . And the space complexity is given by an upper bound on the size of a configuration c  X  C , because only one configuration needs to be stored at any given time in a deterministic parser. 4. Stack-Based Algorithms
The stack-based algorithms make use of a stack to store partially processed tokens, that is, tokens that have been removed from the input buffer but which are still considered as potential candidates for dependency links, either as heads or as dependents. A parser configuration is therefore defined as a triple, consisting of a stack, an input buffer, and a set of dependency arcs.
 Definition 9
A stack-based configuration for a sentence x = ( w 0 , w 1 where 1.  X  is a stack of tokens i  X  k (for some k  X  n ), 2.  X  is a buffer of tokens j &gt; k , 3. A is a set of dependency arcs such that G = ( { 0, 1, ... , n
Both the stack and the buffer will be represented as lists, although the stack will have its head (or top) to the right for reasons of perspicuity. Thus,  X  i and tail  X  ,and j |  X  represents a buffer with head j and tail  X  . Definition 10
A stack-based transition system is a quadruple S = ( C , T , c 1. C is the set of all stack-based configurations, 2. c s ( x = ( w 0 , w 1 , ... w n )) = ([0], [1, ... , n ], 520 Transitions Preconditions 3. T is a set of transitions, each of which is a function t : C 4. C t = { c  X  C | c = (  X  ,[], A ) } .

A stack-based parse of a sentence x = ( w 0 , w 1 , ... , w 0 on the stack  X  , all the nodes corresponding to real words in the buffer  X  ,andan empty set A of dependency arcs; it ends as soon as the buffer  X  is empty. The transitions used by stack-based parsers are essentially composed of two types of actions: adding (labeled) arcs to A and manipulating the stack  X  and input buffer  X  . By combining such actions in different ways, we can construct transition systems that implement different parsing strategies. We will now define two such systems, which we call arc-standard and arc-eager , respectively, adopting the terminology of Abney and Johnson (1991). 4.1 Arc-Standard Parsing
The transition set T for the arc-standard, stack-based parser is defined in Figure 3 and contains three types of transitions: 1. Transitions L EFT -A RC l (for any dependency label l ) add a dependency arc 2. Transitions R IGHT -A RC s l (for any dependency label l ) add a dependency 3. The transition S HIFT removes the first node i in the buffer  X  and pushes
The arc-standard parser is the closest correspondent to the familiar shift-reduce parser
A RC s l transitions correspond to reduce actions, replacing a head-dependent structure with its head, whereas the S HIFT transition is exactly the same as the shift action. One peculiarity of the transitions, as defined here, is that the  X  X educe X  transitions apply to one node on the stack and one node in the buffer, rather than two nodes on the stack.
The reason for this formulation is to facilitate comparison with the arc-eager parser described in the next section and to simplify the definition of terminal configurations.
By way of example, Figure 4 shows the transition sequence needed to parse the English sentence in Figure 2.
 Theorem 1
The arc-standard, stack-based algorithm is correct for the class of projective dependency forests.
 Proof 1
To show the soundness of the algorithm, we show that the dependency graph defined every transition preserves this property. We consider each of the relevant conditions in 1. R OOT : The node 0 is a root in G c s ( x ) , and adding an arc of the form ( i , l ,0)is 522 2. S INGLE -H EAD : Every node i  X  V x has in-degree 0 in G 3. A CYCLICITY : G c s ( x ) is acyclic, and adding an arc ( i , l , j ) will create a cycle 4. P ROJECTIVITY : G c s ( x ) is projective, and adding an arc ( i , l , j ) will make the
For completeness, we need to show that for any sentence x and projective dependency forest G x = ( V x , A x )for x , there is a transition sequence C prove this by induction on the length | x | of x = ( w 0 , w Theorem 2
The worst-case time complexity of the arc-standard, stack-based algorithm is O ( n ), where n is the length of the input sentence.
 Proof 2
Assuming that the oracle and transition functions can be computed in some constant time, the worst-case running time is bounded by the maximum number of transitions in a transition sequence C 0, m for a sentence x = ( w 0 , w decreases the length of the buffer  X  by 1, no other transition increases the length of  X  , and any configuration where  X  = [ ] is terminal, the number of S HIFT transitions in C is bounded by n . Moreover, since both L EFT -A RC l and R IGHT -A RC
C 0, m is also bounded by n . Hence, the worst case time complexity is O ( n ). 524 Remark1
The assumption that the oracle function can be computed in constant time will be dis-cussed at the end of Section 6.1, where we approximate oracles with treebank-induced classifiers in order to experimentally evaluate the different algorithms. The assumption that every transition can be performed in constant time can be justified by noting that the only operations involved are those of adding an arc to the graph, removing the first element from the buffer, and pushing or popping the stack.
 Theorem 3
The worst-case space complexity of the arc-standard, stack-based algorithm is O ( n ), where n is the length of the input sentence.
 Proof 3
Given the deterministic parsing algorithm, only one configuration c = (  X  ,  X  , A ) needs to be stored at any given time. Assuming that a single node can be stored in some constant space, the space needed to store  X  and  X  , respectively, is bounded by the number of nodes. The same holds for A , given that a single arc can be stored in constant space, because the number of arcs in a dependency forest is bounded by the number of nodes.
Hence, the worst-case space complexity is O ( n ). 4.2 Arc-Eager Parsing
The transition set T for the arc-eager, stack-based parser is defined in Figure 5 and contains four types of transitions: 1. Transitions L EFT -A RC l (for any dependency label l ) add a dependency arc Transitions Preconditions 2. Transitions R IGHT -A RC e l (for any dependency label l ) add a dependency 3. The transition R EDUCE pops the stack  X  and is subject to the precondition 4. The transition S HIFT removes the first node i in the buffer  X  and pushes it
The arc-eager parser differs from the arc-standard one by attaching right dependents cannot replace the head-dependent structure with the head, as in the arc-standard system, but must store both the head and the dependent on the stack for further processing. The dependent can be popped from the stack at a later time through the
R EDUCE transition, which completes the reduction of this structure. The arc-eager system is illustrated in Figure 6, which shows the transition sequence needed to parse the English sentence in Figure 2 with the same output as the arc-standard sequence in Figure 4.
 Theorem 4
The arc-eager, stack-based algorithm is correct for the class of projective dependency forests.
 526 Proof 4
To show the soundness of the algorithm, we show that the dependency graph defined every transition preserves this property. We consider each of the relevant conditions in 1. R OOT : Same as Proof 1. 2. S INGLE -H EAD : Same as Proof 1 (substitute R IGHT -A RC 3. A CYCLICITY : G c s ( x ) is acyclic, and adding an arc ( i , l , j ) will create a cycle 4. P ROJECTIVITY : To prove that, if c p  X  C 0, m and c p
For completeness, we need to show that for any sentence x and projective depen-dency forest G x = ( V x , A x )for x , there is a transition sequence C
Using the same idea as in Proof 1, we prove this by induction on the length x = ( w 0 , w 1 , ... , w n ).
 Theorem 5
The worst-case time complexity of the arc-eager, stack-based algorithm is O ( n ), where n is the length of the input sentence.
 Proof 5 decrease the length of  X  and increase the height of  X  , while both R EDUCE and L EFT -
A RC l decrease the height of  X  . Hence, the combined number of S HIFT and R IGHT -A RC bounded by n . 528 Theorem 6
The worst-case space complexity of the arc-eager, stack-based algorithm is O ( n ), where n is the length of the input sentence.
 Proof 6
Same as Proof 3. 5. List-Based Algorithms
The list-based algorithms make use of two lists to store partially processed tokens, that is, tokens that have been removed from the input buffer but which are still considered as potential candidates for dependency links, either as heads or as dependents. A parser configuration is therefore defined as a quadruple, consisting of two lists, an input buffer, and a set of dependency arcs.
 Definition 11
A list-based configuration for a sentence x = ( w 0 , w (  X  1 ,  X  2 ,  X  , A ), where 1.  X  1 is a list of tokens i 1  X  k 1 (for some k 1  X  n ), 2.  X  2 is a list of tokens i 2  X  k 2 (for some k 2 , k 1 &lt; k 3.  X  is a buffer of tokens j &gt; k , 4. A is a set of dependency arcs such that G = ( { 0, 1, ... , n
The list  X  1 has its head to the right and stores nodes in descending order, and the list  X  has its head to the left and stores nodes in ascending order. Thus,  X  with head i and tail  X  1 , whereas j |  X  2 represents a list with head j and tail  X  square brackets for enumerated lists as before, and we write  X  tions for the buffer  X  and the set A of dependency arcs are the same as before. Definition 12
A list-based transition system is a quadruple S = ( C , T , c 1. C is the set of all list-based configurations, 2. c s ( x = ( w 0 , w 1 , ... w n )) = ([0], [ ], [1, ... , n ], 3. T is a set of transitions, each of which is a function t : C 4. C t = { c  X  C | c = (  X  1 ,  X  2 ,[], A ) } .

A list-based parse of a sentence x = ( w 0 , w 1 , ... , w the buffer  X  , and an empty set A of dependency arcs; it ends as soon as the buffer  X  is empty. Thus, the only difference compared to the stack-based systems is that we have two lists instead of a single stack. Otherwise, both initialization and termination are Transitions
L EFT -A RC n l (  X  1 | i ,  X  2 , j |  X  , A )  X  (  X  1 , i
R IGHT -A RC n l (  X  1 | i ,  X  2 , j |  X  , A )  X  (  X  1 , i N O -A RC n (  X  1 | i ,  X  2 ,  X  , A )  X  (  X  1 , i |  X  2 ,  X  , A ) S HIFT  X  (  X  1 ,  X  2 , i |  X  , A )  X  (  X  1 . X  2 | i ,[],  X  , A ) Preconditions
L EFT -A RC n l  X  [ i = 0]
R IGHT -A RC n l  X  X  k  X  l [( k , l , j )  X  A ] essentially the same. The transitions used by list-based parsers are again composed of two types of actions: adding (labeled) arcs to A and manipulating the lists  X  the input buffer  X  . By combining such actions in different ways, we can construct transi-tion systems with different properties. We will now define two such systems, which we call non-projective and projective , respectively, after the classes of dependency graphs that they can handle.
 family of algorithms. In fact, most of the transitions to be defined subsequently make no essential use of this added flexibility and could equally well have been formalized using two stacks instead. However, we will sometimes need to append two lists into one, and this would not be a constant-time operation using standard stack operations.
We therefore prefer to define these structures as lists, even though they will mostly be used as stacks. 5.1 Non-Projective Parsing
The transition set T for the non-projective, list-based parser is defined in Figure 7 and contains four types of transitions: 1. Transitions L EFT -A RC n l (for any dependency label l ) add a dependency arc 530 2. Transitions R IGHT -A RC n l (for any dependency label l ) add a dependency 3. The transition N O -A RC removes the head i of the list  X  4. The transition S HIFT removes the first node i in the buffer  X  and inserts it
The non-projective, list-based parser essentially builds a dependency graph by consid-ering every pair of nodes ( i , j )( i &lt; j ) and deciding whether to add a dependency arc between them (in either direction), although the S HIFT transition allows it to skip certain pairs. More precisely, if i is the head of  X  1 and j is the first node in the buffer  X  when that both the head and the dependent are kept in either  X  anodetobepassedfrom  X  1 to  X  2 even if it does not (yet) have a head. However, an arc can only be added between two nodes i and j if the dependent end of the arc is and S INGLE -H EAD , respectively, and if there is no path connecting the dependent to the head, which would cause a violation of A CYCLICITY . As an illustration, Figure 8 shows the transition sequence needed to parse the Czech sentence in Figure 1, which has a non-projective dependency graph.
 Theorem 7 The non-projective, list-based algorithm is correct for the class of dependency forests. Proof 7
To show the soundness of the algorithm, we simply observe that the dependency graph defined by the initial configuration, G c 0 ( x ) = ( { 0, 1, ... , n
H EAD ,andA CYCLICITY , and that none of the four transitions may lead to a violation all, and L EFT -A RC n l and R IGHT -A RC n l have explicit preconditions to prevent this.) est G x = ( V x , A x )for x , there is a transition sequence C the same idea as in Proof 1, we prove this by induction on the length ( w 0 , w 1 , ... , w n ).

R IGHT -A RC n Pred =  X  ( [ ], [0, 1, 2], [3, ... ,8], A
R IGHT -A RC n AuxP =  X  ( [0, 1, 2], [3, 4, 5], [6, 7, 8], A
R IGHT -A RC n Adv =  X  ([0, ... , 5], [6], [7, 8], A 7 = A
R IGHT -A RC n AuxK =  X  ( [ ], [0, ... , 7], [8], A 8 = A Theorem 8
The worst-case time complexity of the non-projective, list-based algorithm is O ( n where n is the length of the input sentence.
 Proof 8
Assuming that the oracle and transition functions can be performed in some constant time, the worst-case running time is bounded by the maximum number of transitions 532 in a transition sequence C 0, m for a sentence x = ( w 0 , w algorithms, there can be at most n S HIFT  X  transitions in C the three other transitions presupposes that  X  1 is non-empty and decreases its length by 1, there can be at most i such transitions between the i  X 
It follows that the total number of transitions in C 0, m O ( n 2 ).
 Remark2
The assumption that transitions can be performed in constant time can be justified by the same kind of considerations as for the stack-based algorithms (cf. Remark 1). The only complication is the S HIFT  X  transition, which involves appending the two lists  X  and  X  2 , but this can be handled with an appropriate choice of data structures. A more
A RC n l , but if we assume that it is the responsibility of the oracle to ensure that the preconditions of any predicted transition are satisfied, we can postpone the discussion of this problem until the end of Section 6.1.
 Theorem 9
The worst-case space complexity of the non-projective, list-based algorithm is O ( n ), where n is the length of the input sentence.
 Proof 9
Given the deterministic parsing algorithm, only one configuration c = (  X  needs to be stored at any given time. Assuming that a single node can be stored in some constant space, the space needed to store  X  1 ,  X  2 ,and  X  , respectively, is bounded by the number of nodes. The same holds for A , given that a single arc can be stored in constant space, because the number of arcs in a dependency forest is bounded by the number of nodes. Hence, the worst-case space complexity is O ( n ). 5.2 Projective Parsing
The transition set T for the projective, list-based parser is defined in Figure 9 and contains four types of transitions: 1. Transitions L EFT -A RC p l (for any dependency label l ) add a dependency arc 2. Transitions R IGHT -A RC p l (for any dependency label l ) add a dependency 3. The transition N O -A RC p removes the head i of the list  X  4. The transition S HIFT  X  removes the first node i in the buffer  X  and inserts it Transitions
L EFT -A RC p l (  X  1 | i ,  X  2 , j |  X  , A )  X  (  X  1 ,[], j
R IGHT -A RC p l (  X  1 | i ,  X  2 , j |  X  , A )  X  (  X  1 | i N O -A RC p (  X  1 | i ,  X  2 ,  X  , A )  X  (  X  1 , i |  X  2 ,  X  , A ) S HIFT  X  (  X  1 ,  X  2 , i |  X  , A )  X  (  X  1 . X  2 | i ,[],  X  , A ) Preconditions
L EFT -A RC p l  X  [ i = 0] R IGHT -A RC p l  X  X  k  X  l [( k , l , j )  X  A ] N O -A RC p  X  k  X  l [( k , l , i )  X  A ]
The projective, list-based parser uses the same basic strategy as its non-projective coun-
The essential differences are the following: 1. While L EFT -A RC n l stores the dependent i in the list  X  2. While R IGHT -A RC n l allows the dependent j to seek dependents to the 3. While N O -A RC n is permissible as long as  X  1 is not empty, N O -A RC
The fact that the projective algorithm skips many node pairs that are considered by the non-projective algorithm makes it more efficient in practice, although the worst-case time complexity remains the same. Figure 10 shows the transition sequence needed to parse the English sentence in Figure 2 with the same output as the stack-based sequences in Figures 4 and 6.
 Theorem 10
The projective, list-based algorithm is correct for the class of projective dependency forests. 534 Proof 10
To show the soundness of the algorithm, we show that the dependency graph defined every transition preserves this property. We consider each of the relevant conditions in 2. S INGLE -H EAD : Same as Proof 1 (substitute L EFT -A RC 3. A CYCLICITY : G c s ( x ) is acyclic, and adding an arc ( i , l , j ) will create a cycle 4. P ROJECTIVITY : G c s ( x ) is projective, and adding an arc ( i , l , j ) will make the
For completeness, we need to show that for any sentence x and dependency forest G ( V , A x )for x , there is a transition sequence C 0, m such that G induction on the length | x | and is essentially the same as Proof 7 up to the point where we assume the existence of a transition sequence C 0, q for the sentence x = ( w c = (  X  c q ,[],[], A  X  p ), but where it can no longer be assumed that  X  536 that j &lt; i in G x . (This is because a R IGHT -A RC p l while a L EFT -A RC p l removes it.) Moreover, for any i  X  dependent of p in G x then any j such that j  X   X  c q , i &lt; j and j is a root in G
G of p in G x or must have a head to the left in both G x and G be inconsistent with the assumption that G x is projective). Therefore, we can construct a transition sequence C 0, m such that G c m = G x ,bystartingin c exactly the same q transitions as in C 0, q , followed by as many L EFT -A RC as there are left dependents of p in G x , interleaving N O -A RC node at the head of  X  1 already has a head, followed by a R IGHT -A RC has a head in G x .OnefinalS HIFT n transition takes us to the terminal configuration c m = (  X  c m ,[],[], A x ).
 Theorem 11
The worst-case time complexity of the projective, list-based algorithm is O ( n is the length of the input sentence.
 Proof 11 Same as Proof 8.
 Theorem 12
The worst-case space complexity of the projective, list-based algorithm is O ( n ), where n is the length of the input sentence.
 Proof 12
Same as Proof 9. 6. Experimental Evaluation
We have defined four different transition systems for incremental dependency parsing, proven their correctness for different classes of dependency graphs, and analyzed their time and space complexity under the assumption that there exists a constant-time oracle for predicting the next transition. In this section, we present an experimental evaluation of the accuracy and efficiency that can be achieved with these systems in deterministic data-driven parsing, that is, when the oracle is approximated by a classifier trained on treebank data. The purpose of the evaluation is to compare the performance of the four algorithms under realistic conditions, thereby complementing the purely formal analysis presented so far. The purpose is not to produce state-of-the-art results for all algorithms on the data sets used, which would require extensive experimentation and optimization going well beyond the limits of this study. 6.1 Experimental Setup
The data sets used are taken from the CoNLL-X shared task on multilingual dependency parsing (Buchholz and Marsi 2006). We have used all the available data sets, taken from treebanks of thirteen different languages with considerable typological variation. Table 1 gives an overview of the training data available for each language. graphs, it can be expected that the non-projective list-based algorithm will achieve higher accuracy than the strictly projective algorithms. In order to make the comparison more fair, we therefore also evaluate pseudo-projective versions of the latter algorithms, making use of graph transformations in pre -and post -processing to recover non -projective dependency arcs, following Nivre and Nilsson (2005). For each language, seven different parsers were therefore trained as follows: 1. For the non-projective list-based algorithm, one parser was trained 2. For the three projective algorithms, two parsers were trained after 538  X   X   X   X 
All parsers were trained using the freely available MaltParser system, implementations of all the algorithms described in Sections 4 and 5. MaltParser also incorporates the LIBSVM library for support vector machines (Chang and Lin 2001), which was used to train classifiers for predicting the next transition. Training data for the classifiers were generated by parsing each sentence in the training set using the gold-standard dependency graph as an oracle. For each transition t ( c ) in the oracle parse, a the parser configuration c . Because the purpose of the experiments was not to optimize parsing accuracy as such, no work was done on feature selection for the different algorithms and languages. Instead, all parsers use a variant of the simple feature model used for parsing English and Swedish in Nivre (2006b), with minor modifications to suit the different algorithms.
 represents a node defined relative to the current parser configuration, where nodes defined relative to the stack  X  are only relevant for stack-based algorithms, whereas nodes defined relative to the lists  X  1 and  X  2 are only relevant for list-based algorithms. We use the notation L [ i ], for arbitrary lists or stacks, to denote the i th element of
L [0] for the first element (top element of a stack) and L [ n ] for the last element. Nodes defined relative to the partially-built dependency graph make use of the operators hd , ld , and rd , which return, respectively, the head, the leftmost dependent, and the rightmost dependent of a node in the dependency graph G c defined by the current configuration c , if such a node exists, and a null value otherwise. The columns in Table 2 represent attributes of nodes (tokens) in the input (word form, lemma, coarse part-of-speech, fine part-of-speech, morphosyntactic features) or in the partially-built dependency graph (dependency label), which can be used to define features. Each cell in the table thus represents a feature f ij = a j ( n i ), defined by selecting the attribute a from the node n i characterized in the i th row. For example, the feature f form of the first input node (token) in the buffer  X  . The symbols occurring in filled cells indicate for which parsing algorithms the feature is active, where S stands for arc-standard stack-based, E for arc-eager stack-based, N for non-projective list-based, and
P for projective list-based. Features that are used for some but not all algorithms are typically not meaningful for all algorithms. For example, a right dependent of the first node in the buffer  X  can only exist (at decision time) when using the arc-standard stack-based algorithm. Hence, this feature is inactive for all other algorithms. and LIBSVM X  X  built-in one-versus-one strategy for multi-class classification, convert-ing symbolic features to numerical ones using the standard technique of binarization.
The parameter settings were  X  = 0 . 2and r = 0 for the kernel parameters, C = 0 . 5for the penalty parameter, and = 1 . 0 for the termination criterion. These settings were extrapolated from many previous experiments under similar conditions, using cross-validation or held-out subsets of the training data for tuning, but in these experiments they were kept fixed for all parsers and languages. In order to reduce training times, the set of training instances derived from a given training set was split into smaller sets, for which separate multi-class classifiers were trained, using FPoS(  X  [0]), that is, the (fine-grained) part of speech of the first node in the buffer, as the defining feature for the split.
 the dedicated test set from the CoNLL-X shared task, which consists of approximately 5,000 tokens for all languages. Because the dependency graphs in the gold standard are always trees, each output graph was converted, if necessary, from a forest to a tree by attaching every root node i ( i &gt; 0) to the special root node 0 with a default label
R OOT . Parsing accuracy was measured by the labeled attachment score (LAS), that is, the percentage of tokens that are assigned the correct head and dependency label, as well as the unlabeled attachment score (UAS), that is, the percentage of tokens with the correct head, and the label accuracy (LA), that is, the percentage of tokens with the correct dependency label. All scores were computed with the scoring software from the CoNLL-X shared task, eval.pl , with default settings. This means that punctuation tokens are excluded in all scores. In addition to parsing accuracy, we evaluated efficiency by measuring the learning time and parsing time in seconds for each data set.
Remarks 1 and 2 to discuss the way in which treebank-induced classifiers approximate oracles and to what extent they satisfy the condition of constant-time operation that was assumed in all the results on time complexity in Sections 4 and 5. When pre-dicting the next transition at run-time, there are two different computations that take 540 place: the first is the classifier returning a transition t as the output class for an input transition (with no preconditions) is performed instead. 8 for the stack-based algorithms and N O -A RC for the list-based algorithms.) The time required to compute the classification t of  X  ( c ) depends on properties of the classifier, such as the number of support vectors and the number of classes for a multi-class SVM classifier, but is independent of the length of the input and can therefore be regarded as a constant as far as the time complexity of the parsing algorithm is concerned.
The check of preconditions is a trivial constant-time operation in all cases except one, and R IGHT -A RC n l transitions of the non-projective list-based algorithm. Maintaining the information needed for this check and updating it with each addition of a new arc to the graph is equivalent to the union-find operations for disjoint set data structures.
Using the techniques of path compression and union by rank, the amortized time per operation is O (  X  ( n )) per operation, where n is the number of elements (nodes in this case) and  X  ( n ) is the inverse of the Ackermann function, which means that  X  ( n )is less than 5 for all remotely practical values of n and is effectively a small constant (Cormen, Leiserson, and Rivest 1990). With this proviso, all the complexity results from
Sections 4 and 5 can be regarded as valid also for the classifier-based implementation of deterministic, incremental dependency parsing. 6.2 Parsing Accuracy
Table 3 shows the parsing accuracy obtained for each of the 7 parsers on each of the 13 languages, as well as the average over all languages, with the top score in each row set in boldface. For comparison, we also include the results of the two top scoring systems in the CoNLL-X shared task, those of McDonald, Lerman, and Pereira (2006) and Nivre et al. (2006). Starting with the LAS, we see that the multilingual average is very similar across the seven parsers, with a difference of only 0.58 percentage points between the best and the worst result, obtained with the non-projective and the strictly projective version of the list-based parser, respectively. However, given the large amount of data, some of the differences are nevertheless statistically significant (according to McNemar X  X  test,  X  = . 05). Broadly speaking, the group consisting of the non-projective, list-based parser and the three pseudo-projective parsers significantly outperforms the group consisting of the three projective parsers, whereas there are no significant differences within the two groups. 10 This shows that the capacity to capture non-projective dependencies does make a significant difference, even though such dependencies are infrequent in most languages.

CoNLL-X shared task, but it must be remembered that the results in this article have 542 been obtained without optimization of feature representations or learning algorithm parameters. The net effect of this can be seen in the result for the pseudo-projective version of the arc-eager, stack-based parser, which is identical to the system used by
Nivre et al. (2006), except for the lack of optimization, and which suffers a loss of 1.12 percentage points overall.
 even less variation between the parsers. Nevertheless, there is still a statistically sig-nificant margin between the non-projective, list-based parser and the three pseudo-projective parsers, on the one hand, and the strictly projective parsers, on the other.
For label accuracy (LA), finally, the most noteworthy result is that the strictly projec-tive parsers consistently outperform their pseudo-projective counterparts, although the difference is statistically significant only for the projective, list-based parser. This can be explained by the fact that the pseudo-projective parsing technique increases the number of distinct dependency labels, using labels to distinguish not only between different syntactic functions but also between  X  X ifted X  and  X  X nlifted X  arcs. It is there-fore understandable that the pseudo-projective parsers suffer a drop in pure labeling accuracy.
 there are interesting differences for individual languages and groups of languages.
These differences concern the impact of non-projective, pseudo-projective, and strictly projective parsing, on the one hand, and the effect of adopting an arc-eager or an arc-standard parsing strategy for the stack-based parsers, on the other. Before we turn to the evaluation of efficiency, we will try to analyze some of these differences in a little more detail, starting with the different techniques for capturing non-projective dependencies.
 strictly projective counterpart for all languages except Chinese. The result for Chinese is expected, given that it is the only data set that does not contain any non-projective dependencies, but the difference in accuracy is very slight (0.19 percentage points).
Thus, it seems that the non-projective parser can also be used without loss in accuracy for languages with very few non-projective structures. The relative improvement in accuracy for the non-projective parser appears to be roughly linear in the percent-age of non-projective dependencies found in the data set, with a highly significant correlation (Pearson X  X  r = 0 . 815, p = 0 . 0007). The only language that clearly diverges from this trend is German, where the relative improvement is much smaller than expected.
 based parsers, we see essentially the same pattern but with a little more variation. For the arc-eager, stack-based parser, the only anomaly is the result for Arabic, which is significantly higher than the result for the non-projective parser, but this seems to be due to a particularly bad performance of the list-based parsers as a group for this language. 12 For the arc-standard, stack-based parser, the data is considerably more noisy, which is related to the fact that the arc-standard parser in itself has a higher variance than the other parsers, an observation that we will return to later on. Still, the correlation between relative improvement in accuracy and percentage of non-projective dependencies is significant for both the arc-eager parser (r = 0 . 766, p = 0 . 001) and the based parser. It therefore seems reasonable to conclude that the non-projective parser in general can be expected to outperform a strictly projective parser with a margin that is directly related to the proportion of non-projective dependencies in the data. parsers, we will now scrutinize the results obtained when coupling the projective parsers with the pseudo-projective parsing technique, as an alternative method for capturing non-projective dependencies. The overall pattern is that pseudo-projective parsing improves the accuracy of a projective parser for languages with more than 1% of non-projective dependencies, as seen from the results for Czech, Dutch, German, and
Portuguese. For these languages, the pseudo-projective parser is never outperformed by its strictly projective counterpart, and usually does considerably better, although the improvements for German are again smaller than expected. For Slovene and Turkish, we find improvement only for two out of three parsers, despite a relatively high share of non-projective dependencies (1.9% for Slovene, 1.5% for Turkish). Given that Slovene and Turkish have the smallest training data sets of all languages, this is consistent with previous studies showing that pseudo-projective parsing is sensitive to data sparseness (Nilsson, Nivre, and Hall 2007). For languages with a lower percentage of non-projective dependencies, the pseudo-projective technique seems to hurt performance more often than not, possibly as a result of decreasing the labeling accuracy, as noted previously.
It is worth noting that Chinese is a special case in this respect. Because there are no non-projective dependencies in this data set, the projectivized training data set will be identical to the original one, which means that the pseudo-projective parser will behave exactly as the projective one.
 both can improve parsing accuracy in the presence of significant amounts of non-projective dependencies, but the former appears to be more stable in that it seldom or never hurts performance, whereas the latter can be expected to have a negative effect on accuracy when the amount of training data or non-projective dependencies (or both) is not high enough. Moreover, the non-projective parser tends to outperform the best pseudo-projective parsers, both on average and for individual languages. In fact, the pseudo-projective technique outperforms the non-projective parser only in combination with the arc-standard, stack-based parsing algorithm, and this seems to be due more to the arc-standard parsing strategy than to the pseudo-projective technique as such. The relevant question here is therefore why arc-standard parsing seems to work particularly well for some languages, with or without pseudo-projective parsing.
 algorithm has a higher variance than the other algorithms. For Bulgarian, Dutch, and
Spanish, the accuracy is considerably lower than for the other algorithms, in most cases by more than one percentage point. But for Arabic, Czech, and Slovene, we find exactly the opposite pattern, with the arc-standard parsers sometimes outperforming the other parsers by more than two percentage points. For the remaining languages, the arc-standard algorithm performs on a par with the other algorithms. 544 explain this pattern we need to consider the way in which properties of the algorithms interact with properties of different languages and the way they have been annotated syntactically.
 is always added at the earliest possible moment, that is, in the first configuration where already been added (i.e., when the dependent j has already found all its dependents).
This explains why the results for the two list-based parsers and the arc-eager stack-based parser are so well correlated, but it does not explain why the arc-standard strategy works better for some languages but not for others.
 to its head i at any time without having to decide whether j itself should have a right dependent. By contrast, with the arc-standard strategy it is necessary to decide not only whether j is a right dependent of i but also whether it should be added now or later, which means that two types of errors are possible even when the decision to attach j to i is correct. Attaching too early means that right dependents can never be attached to j ; postponing the attachment too long means that j will never be added to i .Noneof these errors can occur with the arc-eager strategy, which therefore can be expected to work better for data sets where this kind of  X  X mbiguity X  is commonly found. In order for this to be the case, there must first of all be a significant proportion of left-headed structures in the data. Thus, we find that in all the data sets for which the arc-standard parsers do badly, the percentage of left-headed dependencies is in the 50 X 75% range. However, it must also be pointed out that the highest percentage of all is found in
Arabic (82.9%), which means that a high proportion of left-headed structures may be a necessary but not sufficient condition for the arc-eager strategy to work better than the arc-standard strategy. We conjecture that an additional necessary condition is an annotation style that favors more deeply embedded structures, giving rise to chains of left-headed structures where each node is dependent on the preceding one, which increases the number of points at which an incorrect decision can be made by an arc-standard parser. However, we have not yet fully verified the extent to which this condi-tion holds for all the data sets where the arc-eager parsers outperform their arc-standard counterparts.
 attaching a right dependent are simpler, it has the disadvantage that it has to commit to do so, or fail to add the same arc in a situation where it should have been added, in both cases because the information available at an early point makes the wrong decision look probable. In the first case, the arc-standard parser may still get the analysis right, if it also seems probable that j should have a right dependent (in which case it will postpone the attachment); in the second case, it may get a second chance to add the arc type of structures and annotation will favor the arc-standard parser in this way, but it is likely that having many right dependents attached to (or near) the root could cause problems for the arc-eager algorithms, since these dependencies determine the global structure and often span long distances, which makes it harder to make correct decisions early in the parsing process. This is consistent with earlier studies showing that parsers using the arc-eager, stack-based algorithm tend to predict dependents of the root with lower precision than other algorithms. 14 Interestingly, the three languages for which the arc-standard parser has the highest improvement (Arabic, Czech, Slovene) have a very similar annotation, based on the Prague school tradition of dependency grammar, which not only allows multiple dependents of the root but also uses several different labels for these dependents, which means that they will be analyzed correctly only if a
This is in contrast to annotation schemes that use a default label R OOT , for dependents of the root, where such dependents can often be correctly recovered in post-processing by attaching all remaining roots to the special root node with the default label. We can see the effect of this by comparing the two stack-based parsers (in their pseudo-(predicate), which is the most important label for dependents of the root in the data sets for Arabic, Czech, and Slovene. While the arc-standard parser has 78.02% precision and 70.22% recall, averaged over the three languages, the corresponding figures for the arc-eager parser are as low as 68.93% and 65.93%, respectively, which represents a drop of almost ten percentage points in precision and almost five percentage points in recall. rithms can be used for deterministic, classifier-based parsing with competitive accuracy.
The results presented are close to the state of the art without any optimization of feature representations and learning algorithm parameters. Comparing different algorithms, we have seen that the capacity to capture non-projective dependencies makes a signif-icant difference in general, but with language-specific effects that depend primarily on the frequency of non-projective constructions. We have also seen that the non-projective list-based algorithm is more stable and predictable in this respect, compared to the use of pseudo-projective parsing in combination with an essentially projective parsing algo-rithm. Finally, we have observed quite strong language-specific effects for the difference between arc-standard and arc-eager parsing for the stack-based algorithms, effects that can be tied to differences in linguistic structure and annotation style between different data sets, although a much more detailed error analysis is needed before we can draw precise conclusions about the relative merits of different parsing algorithms for different languages and syntactic representations. 6.3 Efficiency
Before we consider the evaluation of efficiency in both learning and parsing, it is worth pointing out that the results will be heavily dependent on the choice of support vector machines for classification, and cannot be directly generalized to the use of deterministic incremental parsing algorithms together with other kinds of classifiers.
However, because support vector machines constitute the state of the art in classifier-based parsing, it is still worth examining how learning and parsing times vary with the parsing algorithm while parameters of learning and classification are kept constant. it is obvious that learning time depends primarily on the number of training instances, which is why we can observe a difference of several orders of magnitude in learning time between the biggest training set (Czech) and the smallest training set (Slovene) 546 for a given parsing algorithm. Broadly speaking, for any given parsing algorithm, the ranking of languages with respect to learning time follows the ranking with respect to training set size, with a few noticeable exceptions. Thus, learning times are shorter than expected, relative to other languages, for Swedish and Japanese, but longer than expected for Arabic and (except in the case of the arc-standard parsers) for Danish. on the number of tokens in the training set, but also on the number of transitions required to parse a sentence of length n . This explains why the non-projective list-based algorithm, with its quadratic complexity, consistently has longer learning times than the linear stack-based algorithms. However, it can also be noted that the projective, list-based algorithm, despite having the same worst-case complexity as the non-projective algorithm, in practice behaves much more like the arc-eager stack-based algorithm and in fact has a slightly lower learning time than the latter on average. The arc-standard stack-based algorithm, finally, again shows much more variation than the other algo-rithms. On average, it is slower to train than the arc-eager algorithm, and sometimes very substantially so, but for a few languages (Danish, Japanese, Portuguese, Slovene) it is actually faster (and considerably so for Danish). This again shows that learning time depends on other properties of the training sets than sheer size, and that some data sets may be more easily separable for the SVM learner with one parsing algorithm than with another.
 the strictly projective parsers and their pseudo-projective counterparts, despite the fact that the pseudo-projective technique increases the number of distinct classes (because of its augmented arc labels), which in turn increases the number of binary classifiers that need to be trained in order to perform multi-class classification with the one-versus-one method. The number of classifiers is m ( m pseudo-projective technique with the encoding scheme used here can theoretically lead on efficiency indicates that learning time is dominated by other factors, in particular the number of training instances.
 on the size of the training set, through a dependence on the number of support vectors, which tend to grow with the size of the training set. Thus, for any given algorithm, there is a strong tendency that parsing times for different languages follow the same order as training set sizes. The notable exceptions are Arabic, Turkish, and Chinese, which have higher parsing times than expected (relative to other languages), and Japanese, where parsing is surprisingly fast. Because these deviations are the same for all algorithms, it noting that for Arabic and Japanese the deviations are consistent across learning and parsing (slower than expected for Arabic, faster than expected for Japanese), whereas for Chinese there is no consistent trend (faster than expected in learning, slower than expected in parsing).
 than the strictly projective stack-based algorithms, which can be expected from the difference in time complexity. But we also see that the projective list-based algorithm, despite having the same worst-case complexity as the non-projective algorithm, in practice behaves like the linear-time algorithms and is in fact slightly faster on average than the arc-eager stack-based algorithm, which in turn outperforms the arc-standard stack-based algorithm. This is consistent with the results from oracle parsing reported in
Nivre (2006a), which show that, with the constraint of projectivity, the relation between sentence length and number of transitions for the list-based parser can be regarded as linear in practice. Comparing the arc-eager and the arc-standard variants of the stack-based algorithm, we find the same kind of pattern as for learning time in that the arc-eager parser is faster for all except a small set of languages: Chinese, Japanese,
Slovene, and Turkish. Only two of these, Japanese and Slovene, are languages for which learning is also faster with the stack-based algorithm, which again shows that there is no straightforward correspondence between learning time and parsing time.
 found in the often dramatic differences in parsing time between the strictly projective parsers and their pseudo-projective counterparts. Although we did not see any clear 548 quite clear that there is a noticeable effect on parsing time, with the pseudo-projective parsers always being substantially slower. In fact, in some cases the pseudo-projective parsers are also slower than the non-projective list-based parser, despite the difference in time complexity that exists at least for the stack-based parsers. This result holds on average over all languages and for five out of thirteen of the individual languages and shows that the advantage of linear-time parsing complexity (for the stack-based parsers) can be outweighed by the disadvantage of a more complex classification problem in pseudo-projective parsing. In other words, the larger constant associated with a larger cohort of SVM classifiers for the pseudo-projective parser can be more important than the better asymptotic complexity of the linear-time algorithm in the range of sentence lengths typically found in natural language. Looking more closely at the variation in sentence length across languages, we find that the pseudo-projective parsers are faster than the non-projective parser for all data sets with an average sentence length above 18. For data sets with shorter sentences, the non-projective parser is more efficient in all except three cases: Bulgarian, Chinese, and Japanese. For Chinese this is easily explained by the absence of non-projective dependencies, making the performance of the pseudo-projective parsers identical to their strictly projective counterparts. For the other two languages, the low number of distinct dependency labels for Japanese and the low per-centage of non-projective dependencies for Bulgarian are factors that mitigate the effect of enlarging the set of dependency labels in pseudo-projective parsing. We conclude that the relative efficiency of non-projective and pseudo-projective parsing depends on several factors, of which sentence length appears to be the most important, but where the number of distinct dependency labels and the percentage of non-projective dependencies also play a role. 7. Related Work Data-driven dependency parsing using supervised machine learning was pioneered by
Eisner (1996), who showed how traditional chart parsing techniques could be adapted for dependency parsing to give efficient parsing with exact inference over a probabilistic model where the score of a dependency tree is the sum of the scores of individual arcs.
This approach has been further developed in particular by Ryan McDonald and his colleagues (McDonald, Crammer, and Pereira 2005; McDonald et al. 2005; McDonald and Pereira 2006) and is now known as spanning tree parsing , because the problem of finding the most probable tree under this type of model is equivalent to finding an optimum spanning tree in a dense graph containing all possible dependency arcs.
If we assume that the score of an individual arc is independent of all other arcs, this problem can be solved efficiently for arbitrary non-projective dependency trees using the Chu-Liu-Edmonds algorithm, as shown by McDonald et al. (2005). Spanning tree algorithms have so far primarily been combined with online learning methods such as MIRA (McDonald, Crammer, and Pereira 2005).

Japanese by Kudo and Matsumoto (2002) and for English by Yamada and Matsumoto (2003). In contrast to spanning tree parsing, this can be characterized as a greedy inference strategy, trying to construct a globally optimal dependency graph by making a sequence of locally optimal decisions. The first strictly incremental parser of this kind was described in Nivre (2003) and used for classifier-based parsing of Swedish by Nivre,
Hall, and Nilsson (2004) and English by Nivre and Scholz (2004). Altogether it has now been applied to 19 different languages (Nivre et al. 2006, 2007; Hall et al. 2007). Most algorithms in this tradition are restricted to projective dependency graphs, but it is possible to recover non-projective dependencies using pseudo-projective parsing (Nivre and Nilsson 2005). More recently, algorithms for non-projective classifier-based parsing have been proposed by Attardi (2006) and Nivre (2006a). The strictly deter-ministic parsing strategy has been relaxed in favor of n -best parsing by Johansson and Nugues (2006), among others. The dominant learning method in this tradition is support vector machines (Kudo and Matsumoto 2002; Yamada and Matsumoto 2003; Nivre et al. 2006) but memory-based learning has also been used (Nivre, Hall, and Nilsson 2004; Nivre and Scholz 2004; Attardi 2006).
 essentially the algorithm proposed for unlabeled dependency parsing in Nivre (2003), extended to labeled dependency parsing in Nivre, Hall, and Nilsson (2004), and most fully described in Nivre (2006b). The major difference is that the parser is now initialized with the special root node on the stack, whereas earlier formulations had an empty stack at initialization. 15 The arc-standard stack-based algorithm is briefly described in
Nivre (2004) but can also be seen as an incremental version of the algorithm of Yamada and Matsumoto (2003), where incrementality is achieved by only allowing one left-to-right pass over the input, whereas Yamada and Matsumoto perform several iterations in order to construct the dependency graph bottom-up, breadth-first as it were. The list-based algorithms are both inspired by the work of Covington (2001), although the formulations are not equivalent. They have previously been explored for deterministic classifier-based parsing in Nivre (2006a, 2007). A more orthodox implementation of
Covington X  X  algorithms for data-driven dependency parsing is found in Marinov (2007). 8. Conclusion
In this article, we have introduced a formal framework for deterministic incremental dependency parsing, where parsing algorithms can be defined in terms of transition systems that are deterministic only together with an oracle for predicting the next transition. We have used this framework to analyze four different algorithms, proving the correctness of each algorithm relative to a relevant class of dependency graphs, and giving complexity results for each algorithm.
 of accuracy and efficiency, using SVM classifiers to approximate oracles, and using data from 13 languages. The comparison shows that although strictly projective dependency parsing is most efficient both in learning and in parsing, the capacity to produce non-projective dependency graphs leads to better accuracy unless it can be assumed that all structures are strictly projective. The evaluation also shows that using the non-projective, list-based parsing algorithm gives a more stable improvement in this respect than applying the pseudo-projective parsing technique to a strictly projective parsing algorithm. Moreover, despite its quadratic time complexity, the non-projective parser is often as efficient as the pseudo-projective parsers in practice, because the extended set of dependency labels used in pseudo-projective parsing slows down classification. This demonstrates the importance of complementing the theoretical analysis of complexity with practical running time experiments.
 off between accuracy and efficiency when results are averaged over all languages in the sample, we have also observed important language-specific effects. In particular, the 550 arc-eager strategy inherent not only in the arc-eager, stack-based algorithm but also in both versions of the list-based algorithm appears to be suboptimal for some languages and syntactic representations. In such cases, using the arc-standard parsing strategy, with or without pseudo-projective parsing, may lead to significantly higher accuracy.
More research is needed to determine exactly which properties of linguistic structures and their syntactic analysis give rise to these effects.
 similar performance both in terms of accuracy and efficiency, and several previous studies have shown that both the stack-based and the list-based algorithms can achieve state-of-the-art accuracy together with properly trained classifiers (Nivre et al. 2006; Nivre 2007; Hall et al. 2007).
 Acknowledgments References 552
