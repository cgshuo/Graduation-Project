 TALaNa/Lattice, Universit  X  eParis7 with shared nodes (RSN-MCTAG). The analysis of some German scrambling data is sketched scrambling phenomena, but with an arbitrarily large subset. 1. Introduction: LTAG and Scrambling 1.1 Lexicalized Tree-Adjoining Grammars Tree-adjoining grammar (TAG) is a tree-rewriting formalism originally defined by Joshi,
Levy, and Takahashi (1975). A TAG (see Joshi and Schabes 1997 for an introduction) elementary trees, larger trees are derived using composition operations of substitution (replacing a leaf with a new tree) and adjunction (replacing an internal node with a new is marked as the foot node (marked with an asterisk). Such a tree is called an auxiliary node  X  from the old tree is put below the foot node of the new auxiliary tree. Elementary initial tree. In the final derived tree, all leaves must have terminal labels.
John is substituted for the noun phrase (NP) leaf and the tree for always is adjoined at the verb phrase (VP) node.
 substitutions and adjunctions. Each edge in the derivation tree stands for an adjunction or a substitution. The edges are labeled with Gorn addresses of the nodes where the substitutions and adjunctions have taken place: The root has the address ,andthe j th tree indicates that the elementary tree for John is substituted for the node at address 1 and always is adjoined at node address 2.
 ism. For natural languages, TAGs with specific properties are used. These properties natural languages is lexicalized (Schabes 1990), which means that each elementary anchor). Second, the elementary trees of a lexicalized TAG (LTAG) represent extended
Furthermore, elementary trees are minimal in the sense that only the arguments of the anchor are encapsulated; all recursion is factored away. This amounts to the condition on elementary tree minimality (CETM) from Frank (1992) (see also Frank [2002] for further discussions of the linguistic principles underlying TAG). node), and there is no slot for a VP adjunct. The adverb always is added by adjunction at an internal node.
 an argument. The derivation tree then reflects the predicate-argument structure of the sentence. This is why most approaches to semantics in TAG use the derivation tree as an interface between syntax and semantics (see, e.g., Candito and Kahane 1998; Joshi and
Vijay-Shanker 1999; Kallmeyer and Joshi 2003). In this article, we are not particularly concerned with semantics, but one of the goals of the article is to obtain analyses with derivation trees representing the correct predicate-argument dependencies. 188 plications is multicomponent TAG (MCTAG) (Joshi 1987; Weir 1988). Instead of single elementary trees, an MCTAG has sets of elementary trees. In each derivation step, one of these sets is chosen, and all trees from the set are added simultaneously. Depending on the nodes to which the different trees from the set attach, different kinds of MCTAGs are distinguished: If all nodes are required to be part of the same elementary tree, the grammar is set-local ; and otherwise the grammar is nonlocal . 1.2 Scrambling in TAG
Roughly, scrambling can be described as the permutation of elements (arguments and adjuncts) of a sentence (we use the term scrambling in a purely descriptive sense without implying any theory involving actual movement). A special case of scrambling is so-called long-distance scrambling , in which arguments or adjuncts of an embedded infinitive are  X  X oved X  out of the embedded VP. This occurs, for instance, in languages such as German, Hindi, Japanese, and Korean. As an example of long-distance scram-bling in German, consider example (1): it is not part of the embedded VP.
 number of scrambled elements and no bound on the depth of scrambling (i.e., in terms of movement, the number of VP borders crossed by the moved element).
 scrambling respecting the CETM and therefore giving the correct predicate-argument structure (i.e., an analysis with each argument attaching to the verb it depends on) is not possible.
 bling poses a problem for TAG. If we leave aside the complementizer dass ,standard
TAG elementary trees for verspricht and reparieren in the style of the XTAG grammar (XTAG Research Group 1998) might look as shown in Figure 2. In the derivation, the on the right in Figure 2.
 one of its arguments. But at the same time, it should precede der Mechaniker ;thatis, it must be adjoined either to the root or to the NP nom node. The root node belongs to verspricht ,andtheNP nom node belongs to der Mechaniker . Consequently, an adjunction to one of them would not give the desired predicate-argument structure. If one wanted to analyze only example (1), one could add a tree to the grammar for reparieren with a scrambled NP that allows adjunction of verspricht between the NP and the verb. But as soon as there are several scrambled elements that are arguments of different verbs, this no longer works.
 scrambling data: It has been shown (see Joshi, Becker, and Rambow 2000) that TAG can describe scrambling up to depth two (two crossed VP borders). But this is not sufficient. Even though examples of scrambling of depth greater than two are rare, they can occur.
An example is example (2), taken from Kulick (2000):
Consequently, TAG is not powerful enough to account for scrambling. tems (LCFRSs) (Weir 1988) are not powerful enough to describe scrambling. (LCFRSs are weakly equivalent to set-local MCTAGs and therefore more powerful than TAGs.)
Although we think that the language Becker, Rambow, and Niv define as a kind of test language for scrambling is not exactly what one needs (see section 2.3), we still suspect that they are right in claiming that LCFRSs cannot describe scrambling. 1.3 TAG Variants Proposed for Scrambling structure that ordinary TAG generates. The CETM requires that (positions for) all of the arguments of the lexical anchor of an elementary tree be included in that tree. But extensions that have been proposed to accommodate this interleaving involve factoring the elementary structures into multiple components and inserting these components at multiple positions in the course of the derivation.
 nonlocal MCTAG with additional dominance constraints (Becker, Joshi, and Rambow 1991). However, the formal properties of nonlocal MCTAG are not well understood, and 190 it is assumed that the formalism is not polynomially parsable. Therefore this approach is no longer pursued, but it has influenced the different subsequent proposals. a variant of MCTAG. Additionally, there are dominance links among the trees of the same vector. In contrast to MCTAG, the trees of a vector in V-TAG are not required to be added simultaneously. The lexicalized V-TAGs that are of interest for natural languages are polynomially parsable. Rambow (1994a) proposes detailed analyses of a large range of different word order phenomena in German using V-TAG and thereby shows the linguistic usefulness of V-TAG.
 the dominance links are respected, arbitrary nodes can be chosen to attach the single other words, constraints on how far a dominance link can be stretched. V-TAG allows us to put integrity constraints on certain nodes that disallow the occurrence of these nodes between two trees linked by a dominance link. This has the effect of making these nodes act as barriers. With integrity constraints, constructions involving long-distance movements can be correctly analyzed. But the explicit marking of barriers is somewhat against the original appealing TAG idea that such constraints result from imposition of the CETM, according to which the position of the moved element and the verb it depends on must be in the same elementary structure, and from the further combination result from the form of the elementary structures and from the locality of the derivation operation. That is, they follow from general properties of the grammar, and they need not be stated explicitly. This is one of the aspects that make TAG so attractive from a linguistic point of view, and it gets lost in nonlocal TAG variants.
 another TAG variant one could use for scrambling. DSGs are a description-based for-malism; that is, the objects a DSG deals with are tree descriptions. A problem with DSG is that the expressive power of the formalism is probably too limited to deal with all natural language phenomena: According to Rambow, Vijay-Shanker, and Weir (2001) it  X  X oes not appear to be possible for DSG to generate the copy language X  (page 101).
This means that the formalism is probably not able to describe cross-serial dependencies in Swiss German. Furthermore, DSG is nonlocal and therefore, as in the case of V-TAG, the different parts of an elementary structure.
 (TDG) (Kallmeyer 2001). Local TDG can be used for scrambling in a way similar to DSG or V-TAG. The languages generated by local TDGs are semilinear. However, the formal-ism allows one to generate tree descriptions with underspecified dominance relations, and the process of resolving the remaining dominance links is nonlocal. Therefore one may have the same problem as in the case of DSG and V-TAG. Furthermore, so far it whether such parsing is possible without any additional constraint or limitation on the underspecified tree descriptions. adjoining grammar (SegTAG) (Kulick 2000). SegTAG uses an operation on trees called segmented adjunction that consists partly of a standard TAG adjunction and partly of mixed up, the more or less resource-sensitive adjoining operation of standard TAG, in
Perhaps using tree descriptions instead of trees, a more coherent definition of SegTAG can be achieved. But we will not pursue this here.
 are probably in the class of LCFRSs, but there is no actual proof of this. However, if
SegTAG is in LCFRS, the generative power of the formalism is probably too limited to deal with scrambling in a general way. But it seems that the limit imposed by the grammar on the complexity of the scrambling data is fixed but arbitrarily high. (With increasing complexity, the elementary trees, however, get larger and larger.) This means that one can probably define a SegTAG that can analyze scrambling up to some com-it is perhaps the depth of scrambling.) In this sense, a general treatment of scrambling might be possible. We follow a similar approach in this article by proposing a mildly context-sensitive formalism that can deal with scrambling up to some fixed complexity limit n that can be chosen arbitrarily high.
 a great deal of insight into what kind of structures are needed for scrambling. But as
TAG, since this formalism can deal with scrambling, lexicalized V-TAG is polynomially parsable, and the set of languages V-TAG generates contains the set of all tree-adjoining languages (TALs) (in particular, the copy language). Furthermore, a large range of word order phenomena has been treated with V-TAG, and thereby the usefulness of V-TAG for linguistic applications has been shown. But as already mentioned, V-TAG has the desireable to find a local TAG extension for scrambling (as opposed to the nonlocality for movements follow only from the form of the elementary structures and from the local character of derivations. This article proposes a local TAG variant that can deal with scrambling (at least with an arbitrarily large set of scrambling phenomena), that is polynomially parsable, and that properly extends TAG in the sense that the set of all TALs is a proper subset of the languages it generates.
 restricted SN-MCTAG (RSN-MCTAG) are introduced, formalisms that extend TAG in the sense mentioned above. Section 3 shows linguistic applications of RSN-MCTAG, in particular, an analysis of scrambling. In section 4, a relation between RSN-MCTAG and range concatenation grammar (RCG) (Boullier 1999, 2000) is established. This relation allows us to show that certain subclasses of RSN-MCTAG are mildly context-sensitive 192 set, providing scrambling analyses that respect the CETM. This means that the limit they impose on the complexity of the scrambling data one can analyze is variable. Based on empirical studies, it can be chosen sufficiently great such that the grammar covers all scrambling cases that one assumes to occur. 2. The Formalism
An informal introduction of (restricted) tree-local MCTAG with shared nodes can also be found in Kallmeyer and Yoon (2004). 2.1 Motivation: The Idea of Shared Nodes having performed the derivation steps shown in Figure 2, the root node of the reparieren become daughters of the foot node of the verspricht tree. That is, the root node of the at that node is an adjunction at the verspricht tree.
 the root node and the lower S node might as well be considered to belong to reparieren , verspricht and reparieren . In other words, these nodes are shared by the two elementary trees. Consequently, they can be used to add new elementary trees to verspricht and (in contrast to standard TAG) also to reparieren .
 to which the trees of such a set are added must all belong to the same elementary tree.
Standard tree-local MCTAGs are weakly and even strongly equivalent to TAGs, but they allow us to generate a richer set of derivation structures. In combination with shared nodes, tree-local multicomponent derivation extends the weak generative power of the grammar (see Figure 4 for a sample tree-local MCTAG with shared nodes that generates a language that is not a tree-adjoining language). 6 the root of the derived tree for adjunction of the first tree and the NP part of the reparieren tree. and Shieber (1994). For certain auxiliary trees, Schabes and Shieber allow more than one adjunction at the same node. However, the definition of the derived tree in Schabes and the derivation tree there are edges from some  X  to  X  1 and  X  p of the node  X  in  X  ), then first the whole tree derived from  X  and afterwards the whole tree derived from  X  2 is added to position p . In other words, before  X  2 is adjoined, all the trees to be added by adjunction or substitution to  X  be added. This is different in the case of shared nodes: After  X  adjoined, the root node of  X  2 in the derived tree is shared by  X   X  and  X  2 can be adjoined in any order. This is important for obtaining all the possible permutations of scrambled elements. 2.2 Formal Definition of Tree-Local MCTAG with Shared Nodes As already mentioned, the idea of tree-local MCTAG with shared nodes is the following: is added to an elementary tree  X  , and if there is then a sequence of adjunctions at root 194 adjoined trees.
 in the following way. Define the grammar as an MCTAG and then allow only derivation trees that satisfy the following tree-locality condition: For each instance an elementary tree set in the derivation tree, there is a  X  such that each of the  X  or foot nodes.
 derivation is tree-local in the node-sharing sense, since for the tree set specific multicomponent TAG derivations; that is, we define SN-MCTAG as a variant of MCTAG. This avoids formalizing a notion of shared nodes, even though this was the starting motivation for the formalism.
 node labels, respectively (see, for example, Vijay-Shanker [1987] for a formal definition of TAG). Now we formally introduce multicomponent tree-adjoining grammars (Joshi 1987; Weir 1988): Definition 1 A multicomponent tree-adjoining grammar is a tuple G = I , A , N , T , of an elementary tree set in A and there are pairwise different node addresses p such that  X  =  X  [ p 1 ,  X  1 ] ... [ p n ,  X  n ], where  X  [ p  X  (1  X  i  X  n ) at node positions p i in  X  . 9
As in TAG, a derivation starts from an initial tree, and in the end, in the final derived labeled by a terminal or by the empty word.
 nodes, one can just as well add them one after the other; that is, each multicomponent G
TAG : = I , A , N , T . Let us define the TAG derivation tree of such a multicomponent derivation as the corresponding derivation tree in G TAG . We can then define tree-local, set-local, and nonlocal MCTAG and also the different variants of SN-MCTAG this article deals with by putting different constraints on this derivation tree. at some address p in some elementary tree  X  that was already added (  X  and p are unique). In the TAG derivation tree, there will be in this case an edge from  X  to  X  position p .
 derivation. So a derivation tree is a tuple N , E ,with N elementary trees and with E  X  N  X  N  X  IN  X  , where IN  X  is the set of Gorn addresses. We define the parent relation as the relation between mothers and daughters in a derivation tree, the dominance relation as the reflexive transitive closure of the parent relation, and the node-sharing relation as the relation between nodes that either are mother and daughter or are linked first by a substitution/adjunction and then a chain of adjunctions at root or foot nodes: Definition 2 Let D = N , E be a derivation tree in a TAG.
 called a primary node-sharing relation, and  X  2 is called a primary SN-daughter of  X  whereas any other node-sharing relation  X  1 ,  X  2 is called secondary and in this case  X  is called a secondary SN-daughter of  X  1 .
 elementary tree set cannot be substituted or adjoined into another tree from the same set, and, thirdly, two tree sets cannot be interleaved. For nonlocal MCTAG, these are all constraints the TAG derivation tree needs to satisfy. 196 Lemma 1 Let G = I , A , N , T , A be an MCTAG, G TAG : = I , A , N , T .Let D = tree in G TAG with the corresponding derived tree t being in L ( G requirement: The corresponding properties are now captured in the three constraints trees that correspond to derived trees in the tree language, subderivation trees need not satisfy them. In other words,  X  1 and  X  2 from the same elementary tree set can be added at different moments of the derivation as long as the final complete TAG derivation tree satisfies (MC1) X (MC3).
 trees by imposing further conditions. Basically, the difference between the first two and whereas in the second two, it refers to the node-sharing relation.
 Definition 3
Let G = I , A , N , T , A be an MCTAG. Let D = N , E be a TAG derivation tree for some t  X  L ( I , A , N , T ).
 derivation trees. We call these grammars tree-local MCTAGs with shared nodes : Definition 4
Let G be an MCTAG. G is a tree-local MCTAG with shared nodes iff the set of trees SN-tree-local multicomponent TAG derivation tree in G .
 trees in L T ( G ).
 responds to an MCTAG with unary multicomponent sets. For such an MCTAG, each are the same, whether the grammar is considered a TAG, a tree-local MCTAG, or an
SN-MCTAG. 11 In particular, all TAG analyses proposed so far can be maintained, since each TAG is trivially also an instance of SN-MCTAG.
 that there are languages that can be generated by an SN-MCTAG but not by a TAG.
As an example, consider Figure 4, which shows an SN-MCTAG for
Similar to the grammar in Figure 4, for all copy languages an SN-MCTAG can be found. Other languages that can be generated by SN-MCTAG and that are not TALs are the counting languages { a n 1 ... a k  X  4, these languages are tree-adjoining languages).
 TAG, the adjunctions of auxiliary trees from the same set need not be simultaneous.
In this respect, V-TAG differs not only from SN-MCTAG, but from any of the different 198 MCTAGs mentioned above. Secondly, V-TAG is nonlocal in the sense of nonlocal MC-
TAG, whereas SN-MCTAG is local, even though the locality is not based on the parent relation in the derivation tree, as is the case in standard local MCTAG, but on the SN-dominance relation in the derivation tree. As a consequence of the locality, we do not need dominance links (i.e., dominance constraints that have to be satisfied by the de-rived tree) in SN-MCTAG, in contrast to other TAG variants for scrambling. The locality nodes of the same elementary tree. Consequently, the dominance relations among these different nodes determine the dominance relations among the different trees from the
TAG variants such as V-TAG or DSG, in which one can in principle attach the different components of an elementary structure at arbitrary nodes in the derived tree. 2.3 SN-MCTAG and Scrambling: Formal Considerations
Figure 5 shows an SN-MCTAG generating a language that cannot even be generated by linear context-free rewriting systems (see Becker, Rambow, and Niv [1992] for a proof), and therefore not by set-local MCTAG. This example, however, concerns neither weak nor strong generative capacity, but something that Becker, Rambow, and Niv (1992) call come from the same elementary tree set in the grammar.

Then a first instance of the tree set (yielding n 1 and v  X  . For each further instance of the tree set (yielding n at root nodes, and consequently all  X  v are (primary or secondary) SN-daughters of  X  .
The  X  n tree of n i can be adjoined to any of the root or foot nodes of the  X  already been added, since in this way all adjunctions of  X  at root or foot nodes, and therefore all these  X  n are SN-daughters of  X  . This allows us to place n i at any position in the string already containing daughters of  X  , the derivation is SN-tree-local. Note that in the grammar in Figure 5, is crucial for allowing all permutations of the n 1 , ... , n trees differ from what is usually done in TAG.
 language in Figure 5 is not able to analyze scrambling in an adequate way. We think, however, that this language is not exactly what one needs for scrambling. The assump-tion underlying the language in Figure 5 is that n i is an argument of v instead of adding n i and v i at the same time, n i should be added to v the additional assumption that argument NPs are added by substitution, then one can require that the argument NPs have already been substituted (this is what Joshi, Becker, v contain n i . In this case, the language in Figure 5 is an appropriate test language for scrambling. But we do not want to make this assumption.
 ment of v i  X  1 for i  X  2. This is what Joshi, Becker, and Rambow (2000) call the strong co-occurrence constraint. In other words, the dependency tree should be as in Figure 6. as long as they do not permute among themselves. Consequently, for scrambling data (without extraposition), one rather wants to generate the following language: SCR : = { w =  X  ( n 1 ... n k v 1 ... v k ) | k  X  1, n i = n , v i = v , for all 1 n ... n k v 1 ... v k such that n i precedes v i in w for all 1 for all 1 &lt; i  X  k } with the derivation structure in Figure 6. An SN-MCTAG generating this language is shown in Figure 7.
 which case an instance of {  X  n ,  X  n } must be added and nv is obtained with n depending {  X  {  X  200 into the argument slot it fills. So the only condition for adding such a tree set is that the verb it depends on has already been added, since the tree of this verb provides the of the foot node, one obtains that v i precedes v i  X  1 for all 1 &lt; i all 1  X  i  X  k .
 empty node, while the n is adjoined higher at a node that is not yet available in the elementary structure of v i . So the combination of n i and v 2.4 Restricted SN-MCTAG
When the formal properties of SN-MCTAG are examined, it becomes clear that the for-malism is hard to compare to other local TAG-related formalisms, since in the derivation tree, arbitrarily many trees can be secondary SN-daughters of a single elementary tree, such that these secondary links are considered to be adjunctions to that tree. This means example is the grammar in Figure 5, in which in each derivation step, the relevant node-sharing relations are the links between  X  and the two auxiliary trees of the new set.
This means that for a word of length k , there are k SN-daughters of  X  that are relevant for the SN-tree-locality of the derivation. The grammar in Figure 5 indicates that this are not in the class of languages that can be generated by LCFRS). However, it would the following, we define a restricted version, RSN-MCTAG, that limits the number of relevant secondary SN-daughters of an elementary tree. The restriction is obtained as follows: We require that in each derivation step, among the SN-relations between the old  X  and the new set  X  , there be at least one primary SN-relation. The number of primary
SN-daughters of a specific elementary tree is limited, since the primary SN-daughters correspond to substitutions/adjunctions at pairwise different nodes and the number of nodes in an elementary tree is limited. Consequently, the number of relevant secondary SN-daughters for a node is limited as well.
 is a primary SN-daughter of reparieren .
 Definition 5 second condition ensures that at least one of the relevant SN-daughters of  X  is a primary SN-daughter, that is, an actual daughter of  X  .

MCTAGs. The sample grammars in Figures 4 and 5 are not RSN-MCTAGs. We suspect that there is no RSN-MCTAG that generates the language in Figure 5. But the grammar in Figure 7 for the language SCR is an RSN-MCTAG.
 holds: For each instance of an elementary tree set  X  ,the  X  to which all elements of  X  are linked by node-sharing relations with at least one primary link is unique (which is not necessarily the case for general SN-MCTAG). This is formulated in the following lemma: Lemma 2 Let G = I , A , N , T , A be an RSN-MCTAG. Let D = N , in G .
 is exactly one  X  such that  X  ,  X  1 , ... ,  X  ,  X  n  X  SN D  X  ,  X  i  X  P D .
 tree as described in the lemma, all  X  ,  X  i  X  SN D \ P D ,1 adjunction links in D . The proof of the lemma is given in the appendix.
RSN-MCTAG. It consists of D enriched with additional links for the secondary adjunc-tions. These links are equipped with the positions of the first substitutions/adjunctions on the chain that corresponds to the secondary adjunctions.
 Definition 6
Let G = I , A , N , T , A be an RSN-MCTAG. Let D = N tree in G .The SN-derivation structure of D , D SN , is then D with E  X  E .
 edges in D SN .
 the maximal number of secondary adjunctions to an elementary tree that we mentioned at the beginning of this section: Lemma 3 Let G = I , A , N , T , A be an RSN-MCTAG. Then there is a constant c such that for all TAG derivation trees D in G with SN-derivation structure D holds: 202 that for all i ,1  X  i  X  m , there is a p such that sociated with a primary adjunction or substitution into the same tree instance. There maximal number of nodes per elementary tree. Consequently there are at most k secondary adjunctions per node if n + 1 is the maximal number of trees per elementary tree set.
 predicate-argument dependencies of a sentence in the following way: For each tree in then it depends on  X  . Otherwise it depends on its mother node in the TAG derivation structure. 3. Linguistic Applications 3.1 Scrambling with RSN-MCTAG
In this section, we present a small German grammar that allows us to analyze some cases of scrambling. The aim is not an exhaustive treatment of the phenomenon, but just to show that in principle, an analysis of scrambling in German is possible using example (3) without extraposition, that is, under the assumption that the order of the verbs is zu reparieren zu versuchen verspricht : represent all arguments of a verb (including an embedded VP) by substitution nodes.
For those parts that might be scrambled, there is a single elementary tree (for the case tree that can be primarily or secondarily adjoined to some root node and a tree with the empty word that is intended to fill the argument position. In order to avoid spurious ambiguities, we assume that whenever a derivation using the single elementary tree is possible, this is chosen.
 right of the VP node to which it adjoins. Consequently, given the form of the verbal elementary trees in Figure 8, in which the verb is always below or to the right of all VP nodes allowing adjunction, the order xv for an x being a nominal or a verbal argument of v is always respected.
 the following three cases holds: place.
 words, and all lexical material would be adjoined to the root node of the derived tree. nodes argument slots but rather some kind of subcategorization features marking which arguments need to be added, an analysis using only the tree sets makes sense. However, for this article, we keep the single trees.
 single trees is possible. Let us consider the following word orders as examples of how secondary adjunction is used for scrambling: 204 In example (4), the versuchen -VP and er are scrambled. 13 dem Kunden intervening between the two. Therefore, the tree sets are used for reparieren and dem Kunden . For versuchen , the single tree can be used, since the scrambling out of versuchen is of depth one. In example (6), we have the same scrambling as in example (4), reparieren .
 for dem Kunden and the tree set for versuchen (with adjunction of the auxiliary tree at the root) are added. This leads to the first tree in Figure 9. The VP nodes in boldface type in the figure are shared by versuchen and verspricht ; that is, they can be used for further adjunction at the verspricht tree. (Of course, only the root node can be used for adjunction, since the other nodes have NA constraints.) It does not matter in which order adjoined to the root node, and the initial tree is substituted for the NP argument dependencies. The TAG derivation tree is RSN-tree-local.
 of dem Kunden to the verspricht tree. The initial tree is substituted at the NP leads to the second tree. Here, the bold VP node belongs to verspricht , versuchen ,and containing the lexical material does not dominate the tree with the empty word. 206 or secondary) adjunction at the root node of the already derived tree. This root node consequently belongs to all verbs that have already occurred in the derivation and can therefore be used to add arguments to any of them.
 of analysis also works for more than two embeddings.
 they depend on, they cannot attach to the VP of a higher finite verb that embeds the dard TAG and additionally a set of two auxiliary trees, a lower auxiliary tree with an empty word and a higher auxiliary tree with the adjunct. This is shown in Figure 11. lower parts of other adjuncts. Similarly, the elementary trees of verbs need an extra VP node in order to adjoin adverbs.
 position and topicalization, and also for an extension of the analysis presented here to
Korean data, see Kallmeyer and Yoon (2004). 3.2 Raising Verbs and Subject-Auxiliary Inversion
Shanker, and Weir 1995; Kulick 2000; Dras, Chiang, and Schuler 2004) as being problematic for TAG and tree-local MCTAG are sentences with raising verbs and subject-auxiliary inversion, as in examples (7) and (8):
The standard TAG analyses of examples (7) and (8) (see Figure 12 for the analysis of we assume that these trees are in the same elementary tree set, then this last derivation problem seems to be of a similar nature, and formalisms that have been proposed for scrambling have also been used to treat these examples (see Kulick 2000). respectively, the root nodes of the adjoined trees are considered still to be part of the trees. Figure 12 shows the corresponding SN-derivation structure. 4. RSN-MCTAG and Range Concatenation Grammar are even weakly equivalent to linear context-free rewriting systems (Weir 1988). As a consequence, one obtains that the languages generated by simple RSN-MCTAGs are mildly context-sensitive. This last property was introduced in Joshi (1985). It includes number of crossing dependencies. (We do not give formal definitions of mild context-sensitivity and of LCFRS, since we do not need these definitions in this article.) almost sure that they are not mildly context-sensitive. Perhaps they can even generate languages that are not in the class of languages generated by RCGs. 4.1 Range Concatenation Grammars This section defines range concatenation grammars. 14 Definition 7 A range concatenation grammar is a tuple G = N , T , V , S , P such that 208 predicates in the clause are instantiated with substrings of w , more precisely, with the corresponding ranges. A range i , j with 0  X  i &lt; j between positions i and j , that is, to the substring t i + 1 to the empty string .If i &gt; j , then i , j is undefined.
 Definition 8
For a given clause, an instantiation with respect to a string w = t a function f : { t | t is an occurrence of some t  X  T in the clause j  X  IN } such that tiation of this clause with left-hand side A ( i 1 , j 1 , ... , i can be replaced with the right-hand side of this instantiation.
 word, that is, { w | S ( 0, | w | )  X   X  with respect to w arity n is called an RCG of arity n .

T = { a , b } , V = { X , Y , Z } , start predicate S , and clauses S ( XYZ )
A ( aX , aY )  X  A ( X , Y ), B ( bX )  X  B ( X ), A ( , )  X  { a n b k a n | k , n  X  IN } . Consider the reduction of w = aabaa : With this instantiation, S ( 0, 5 )  X  A ( 0, 2 , 3, 5 ) B ( 2, 3 ). Then and B ( )  X  lead to A ( 0, 2 , 3, 5 ) B ( 2, 3 )  X  A ( 0, 2 , 3, 5 ) B ( 3, 3 ) 3, 5 ). Next, leads to A ( 0, 2 , 3, 5 )  X  A ( 1, 2 , 4, 5 ). Then and A ( , )  X  lead to A ( 1, 2 , 4, 5 )  X  A ( 2, 2 , 5, 5 ) than once in the left-hand sides of the clauses and no variable appears more than once It is said to be simple if it is noncombinatorial, linear, and nonerasing. 4.2 Relation between RSN-MCTAG and Simple RCG
MCTAG. In order to be able to perform this construction, in the following we further constrain the formalism of RSN-MCTAG by defining RSN-MCTAG of a specific arity n . For this version of RSN-MCTAG, the construction of an equivalent simple RCG is possible.

Boullier 1998a). The RCG contains predicates  X  ( X )and  X  ( L , R ) for initial and aux-iliary trees, respectively. X covers the yield of  X  and all trees added to  X  ,and L and R of these predicates by identifying those parts that come from the elementary tree  X / X  itself and those parts that come from one of the elementary trees added by substitution or adjunction. A sample TAG with an equivalent RCG is shown in Figure 13. the same ideas while considering a secondary adjunction of  X  at some  X  as adjunction at  X  and not as adjunction at the elementary tree that is the mother node of  X  in the
TAG derivation tree. There are two main differences between RSN-MCTAG and TAG that influence the construction of an equivalent RCG.
 first  X  was added by substitution, and then  X  1 ... X  k (in this order) were secondarily adjoined. The second means that at the node in question (an internal node), first  X  primarily adjoined, and then  X  1 ... X  k were secondarily adjoined. Since the number of secondary adjunctions at a node is limited by some constant depending on the grammar 210 only a finite number of predicates.
 one needs predicates of arbitrary arities, namely,  X ... ( L the root of  X  /  X  that were actually secondarily adjoined at some higher tree such that a dynamic RCG (Boullier 2001), a variant of RCG that is not polynomially parsable and that we therefore want to avoid. For this reason, we need an additional constraint on theRSN-MCTAGsweemploy.
 (see Figure 14). In the derived tree, the VP das Fahrrad zu reparieren zu versuchen (the since reparieren secondarily adjoins at versuchen and das Fahrrad secondarily adjoins at reparieren . there are two crossings of secondary edges inside one group of secondary links. This means that the contribution of versuchen is interrupted twice by arguments of verspricht depending on the maximal number of crossings that are allowed.
 tion/adjunction and subsequent adjunctions at root or foot nodes such that there are crossings of secondary edges inside a single secondary group is then limited: For an that an equivalent RCG of the same arity can be constructed. TAG, for example, is a grammar with 0 crossings, that is, an arity 2(0 + 1) = 2 if the grammar is viewed as an SN-MCTAG, and the corresponding RCG is actually of arity 2.
 Definition 9
Let D SN = N , E be a SN-derivation structure. 1. N , E is a secondary group in D SN iff 2. D SN is of arity n iff for each secondary group N , E in D Definition 10
Let G be an MCTAG, n  X  1. G is a restricted tree-local MCTAG with shared nodes of can be derived in G with an RSN-tree-local multicomponent TAG derivation tree such that the corresponding SN-derivation structure is of arity n . 212
RSN-MCTAG. We choose an RSN-MCTAG of arity four, and we see that the arity
Whether this grammar is considered to be a general RSN-MCTAG or an RSN-MCTAG of arity four does not matter in this case, since even in the general case, all possible
SN-derivation structures are of arity four. However, in the case of other RSN-MCTAGs, the restriction to a certain arity might exclude certain TAG derivation trees and thereby decrease the language generated by the grammar.
 versuchen)  X  verspricht, zu kommen (zu versuchen) + er (zu versuchen) derivation structures corresponding to the different strings are shown in Figure 15. The last one contains one crossing of secondary links; that is, the RSN-MCTAG is of arity four.
 four, the predicates of the corresponding RCG are of arity three (for initial trees) and four (for auxiliary trees).
 arguments of the predicate  X  1 are always . Looking at the SN-derivation structures in Figure 15, we have three different possibilities for  X   X  added to the same node and further adjunctions at the root of  X  is that the part covered by  X  1 and the trees added to it can be separated into different substrings. This leads to  X   X   X  since nothing can be adjoined to  X  2 . Consequently  X   X   X 
If the inner parts are empty, the outer parts are moved:  X 
Furthermore, there is a clause for  X  1 without adjunction at the root:  X 
For elementary trees where nothing needs to be added, simple -clauses are introduced:  X   X  tion for zu kommen zu versuchen er zu versuchen verspricht :  X   X   X   X   X   X   X   X   X   X   X  214
This example should give an idea of how an equivalent RCG for a given RSN-MCTAG of arity n can be constructed.
 (primary or secondary) adjunctions that can occur at each node is limited (see Lemma 3). Therefore, the number of predicates needed in the corresponding RCG is limited as well.
Furthermore, in an RSN-MCTAG of arity n , the contribution of an elementary tree is separated into at most n parts. This still needs to be shown: Lemma 4
Let G be an RSN-MCTAG of arity n . Then for all w in the string language of G and for and everything added to  X  , is separated into at most n parts.
 The proof is given in the appendix.
 Theorem 1
For each RSN-MCTAG G of arity n , a simple RCG G of arity n can be constructed such that L ( G ) = L ( G ).

The construction algorithm and a sketch of the proof are presented in the appendix. As a consequence of this theorem, the following corollary holds: Corollary
For a given n , the string languages generated by RSN-MCTAGs of arity n are mildly context-sensitive, and they are in particular polynomially parsable.
 mars that are LCFRSs, we know that we can even construct a weakly equivalent set-local MCTAG. This set-local MCTAG, however, does not present an alternative to the
RSN-MCTAG with fixed arity: It is very large, containing a large number of elementary trees per tree set (the number depends on the arity of the grammar) and, furthermore, a large number of trees without lexical material and a large number of internal nodes that are needed only to provide adjunction sites.
 provide adjunction sites for the different parts of er and versuchen .The versuchen tree parts.
 ments (including arguments and adjuncts of these arguments, etc.), and all its adjuncts cannot be separated into more than n discontinuous substrings in the whole sentence.
For example, an RSN-MCTAG of arity two with elementary tree sets similar to those proposed above for scrambling would not be able to analyze example (9). However,
RSN-MCTAGs of arity n for some sufficiently large fixed n can perhaps even describe all cases of scrambling: See again the analysis of example (9) in Figure 14. Here, the contribution of versuchen and its arguments is split only by other elements secondarily allowed for further secondary adjunctions at its root or foot node (this still needs to be investigated), then the number of crossings might be limited. We leave this issue for further research.
 on empirical studies, n could be chosen sufficiently great such that the grammar would cover all scrambling cases that one assumes to occur. 16 The important point is that the complexity limit given by the fixed n is variable; that is, an arbitrary n can be chosen. that we desire only analyses respecting the CETM). In this sense one can say that RSN-
MCTAG can analyze scrambling in general. 5. Conclusion and Future Work
This article addresses the problem of scrambling in tree-adjoining grammar, a formalism the advantages of TAG while being able to analyze scrambling, a local TAG variant is proposed that is based on the notion of node sharing, so-called (restricted) tree-local multicomponent TAG with node sharing. RSN-MCTAG is a true extension of TAG in the sense that the formalism can generate all tree-adjoining languages. The analysis of some German scrambling data is sketched in order to show that this TAG extension can treat scrambling.
 RSN-MCTAG of a fixed arity n , an equivalent simple RCG of arity n can be constructed.
Simple RCGs are mildly context-sensitive and in particular polynomially parsable and therefore, this also holds for RSN-MCTAGs of a fixed arity. RSN-MCTAGs of arity n perhaps cannot analyze all scrambling phenomena but, if the n is appropriately chosen, it can analyze an arbitrarily large set. 216 scrambling configurations. As already noted, this article does not present an exhaustive treatment of the phenomenon. Even though the examples we looked at indicate that extraposition. A first proposal in this direction can be found in Kallmeyer and Yoon (2004), but this proposal does not cover all phenomena one needs to take into account. So this is still an important issue for further research.
 SN-MCTAG can generate languages that cannot be generated by set-local MCTAG. tween set-local MCTAG and non-local MCTAG and the different formalisms defined in this article, namely, RSN-MCTAG of fixed arity and RSN-MCTAG and MCTAG with
SN-tree-local and SN-set-local derivations. We plan to address these questions in the future.
 Appendix: Proofs Proof of Lemma 1 Let G = I , A , N , T , A be an MCTAG, G TAG : = I , A , N , T .Let D = tree in G TAG with corresponding derived tree t  X  L ( G TAG immediate that the root of D is an instance of an initial tree and that all other nodes are elements of instances of elementary tree sets.

Consequently, D satisfies (MC1) X (MC3). (MC3). positions on the derived tree be pairs  X  , p ,with  X  being an instance of an elementary tree and p being a position in  X  . Every top-down order read off D (no matter whether tion order in G TAG for the derivation tree D , since in order to perform the derivation step ... [  X  1 , p ,  X  2 ] corresponding to an edge  X  1 ,  X  that  X  1 (i.e., the mother node of  X  2 ) has already been added.
 can be partitioned into pairwise different instances of elementary tree sets. initial tree and then there is always one instance  X  of an elementary set whose members are visited next in any order (i.e., simultaneously).
 that at some point of the traversal, the choice of a new instance of an elementary set to be visited next is not possible.  X  for each set  X  that has not been visited yet, there is at least one  X   X   X  whose mother node has not been visited yet (otherwise  X  could be visited next).

Assume  X  (1) 2  X   X  1 with mother not yet visited. Suppose  X  node dominating  X  (1) 2 . Since  X  (2) 1 =  X  (1) 2 and  X  (2)
 X  .
 (a) either  X  (1) 1 ,  X  (2) 2  X  D D . Contradiction to (MC3) with n = 2. (b) or  X  (1) 1 ,  X  (2) 2 /  X  D D . Because of (MC2),  X  (2) est unvisited node  X  (4) 1  X   X  4 dominating  X  (3) 2 with  X  there is a  X  (4) 2  X   X  4 with unvisited mother node.
  X  1 ,  X  218 for i = n ). Consequently, there is always a new  X  n + 1 highest unvisited node dominating  X  ( n ) 2 and  X  ( n + 1) mother.  X 
Contradiction to the finiteness of the number of nodes in D . traversal of D that corresponds to a multicomponent derivation in G in the sense that it allows us to visit the instances of elementary tree sets one after the other. Proof of Lemma 2 Only the uniqueness needs to be shown.
 in G .
 there are  X  ,  X  with  X  =  X  and  X  ,  X  1 , ... ,  X  ,  X  n ,  X  ,  X  are i , j ,1  X  i , j  X  n with  X  ,  X  i ,  X  ,  X  j  X  P D . and  X  ,  X   X  D D . Furthermore,  X  i ,  X  /  X  D D (otherwise  X  contradict (MC2)) and  X  ,  X  i /  X  D D (otherwise, since  X  quently  X  ,  X  i /  X  D D . Contradiction to assumption.
 Proof of Lemma 4
Let G be an RSN-MCTAG of arity n , w  X  L ( G ), such that the elementary tree  X  was used to derive w . Assume that the contribution of  X  is separated into m &gt; n parts. 1) contradiction to the assumption that the arity of G is n &lt; m .
 Proof of Theorem 1 proof.
 Construction algorithm. Let G be an RSN-MCTAG of arity n .
 grammar.
 k be the maximal number of trees in an elementary tree set. k : = k that a root node  X  has n variables, L  X  1 ... L  X  n
Every other internal node  X  has two variables L  X  and R  X  during the top-down traversal, the terminals and variables of substitution nodes are collected while visiting the leaves, and the right variables are collected during bottom-up traversal.
 and P ( , ... , , x 1 , x 2 , , ... , ) signifies that x argument. 220 For each initial  X  , there is a clause
S ( X )  X   X  ( , ... , , X , , ... , ) For each elementary  X  : lhs : =  X   X  , rhs : = .
 substitution nodes and adjunctions at all internal nodes, with obligatory adjunction that respects the conditions for restricted tree-local multicomponent derivation: For all nodes  X  in  X  :
If there is no adjunction at the root of  X  , there is a clause  X  ( , ... , , lhs , , ... , )  X  rhs
If  X  1 , ... ,  X  m are adjoined in this order at the root of  X  ,andif L are the parts of the root in lhs such that lhs = L clause
Further, for each initial  X  and for all i ,1  X  i  X  n 2  X  2 , there are clauses
And for each auxiliary  X  and for all i ,1  X  i  X  n 2  X  1 , there are clauses For each  X  1  X  2  X  X  X   X  m with m  X  2 occurring in the clauses constructed so far: Define sets of variables
L
R
Define for all x  X  L  X  : R ( x ): = y  X  R  X  such that if L is the ( | x | X  k + 1)th letter of y .

For all w  X  L  X  such that (a) each L  X  L occurs exactly once in w , (b) for all 1  X  i 1 &lt; i 2  X  m , L n (c) for all 1  X  i  X  m and 1  X  j 1 &lt; j 2  X  n 2 , L j and for all x 1 , ... , x n there is the following clause:
If  X  1 is an initial tree, a clause with L n 2 (  X  1 ) eliminated from the x  X   X  X  X   X 
If  X  1 is an auxiliary tree, a clause  X   X  X  X   X 
Sketch of Proof. We do not give the whole proof of the correctness of the construction, but we sketch the principal steps: graph 2 above and under paragraph 3 above, are shown: Lemma 5
For each elementary tree  X  in G with decoration string  X   X  auxiliary tree with w l on the left and w r on the right of the foot node) such that 222 the way described in the construction, with  X  being the decoration string of  X  without the symbols for the nodes to which nothing was attached such that { i , j | 0  X  i  X  j  X | w |} as defined in Definition 8, and the following hold for f : Proof by induction on structure of  X  .
 Lemma 6 For all  X  1 ,  X  2 , ... ,  X  m : order) attach to some node  X  in an elementary tree  X  such that the yield of the trees  X  ,  X  2 , ... ,  X  m is separated into at most n disconnected substrings (ranges) of w .If  X  is an auxiliary tree, it is separated into the substrings l (  X  1 initial), the substrings are l 1 , ... , l n 2  X  1 , x , r such that there is an instantiation f of the clause such that Proof by induction on m .

The whole theorem can then be proven using these two lemmas. 224
