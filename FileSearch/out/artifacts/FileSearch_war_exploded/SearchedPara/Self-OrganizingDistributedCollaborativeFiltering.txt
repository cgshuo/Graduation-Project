 We propose a fully decentralized collaborative filtering ap-proach that is self-organizing and operates in a distributed way. The relevances between downloading files (items) are stored locally at these items in so called item-based buddy tables and are updated each time that the items are down-loaded. We then propose to use the language model to build recommendations for the different users based on the buddy tables of those items a user has downloaded previously. We have tested and compared our distributed collaborative fil-tering approach to centralized collaborative filtering and showed that it has similar performance. It is therefore a promising technique to facilitate recommendations in peer-to-peer networks.
 Categorie san dSubjec tDescriptors H.3.3 [ Information Storage and Retrieval ]: Informa-tion Search and Retrieval -Information Filtering ; C.2.4 [ Computer-Communication Networks ]: Distributed Sys-tems -Distributed applications Genera lTerms : Algorithms ,Ex perime ntation Keywords: Collaborative Filtering, Peer-to-Peer Networks.
To be effective collaborative filtering requires a large cen-tralized database that collects users X  profiles. Within the context of P2P networks ([5]) there is, however, no central-ized rating database so that current dominant centralized collaborative filtering ([1, 2, 3]) cannot be applied. Our distributed collaborative filtering approach tackles this is-sue and differs with the previous methods on the following points. Firstly, the proposed method is fully distributed. To realize this we introduce the concept of item-based buddy tables that are stored locally at the location of the item and captures the similarity of that item to the other items in the P2P network. Recommendation can be generated on the ba-sis of these buddy tables. Consequently, there is no need for a server (or super node). Secondly, to tackle the scale prob-lem in P2P networks, we introduce a novel update scheme so that the buddy table of an item is only updated each time that the item is downloaded. This facilitates that the sim-ilarities between the items are continuously updated by a self-organizing mechanism without causing any communica-tion. Thirdly, the location of the items to be recommended can be easily stored within the buddy tables so that it is not necessary to locate the recommended items within the P2P network which is not a trivial problem. Fourthly, we intro-duce a collaborative filtering formulation that is based on the language models that outperforms the current method-ology. Fifthly, by using the buddy tables, the proposed dis-tributed collaborative filtering approach creates a meta-data free semantic overlay of the resources in the P2P network.
We adopt the relevance model proposed in [4]. We treat a profile of a user as a query and introduce random variables r and  X  r to denote  X  X elevant X  and  X  X ot relevant X  of an item to this query. To avoid estimation of P ( I T , P i ), the relevance rank R I T ,P i of the target item I T , T  X  X  1 , ..., N } for a peer (user) represented by the profile P i , i  X  X  1 , ..., M } can be formulated as the odds of relevance: Following the language model ([4]), we now assume that 1) P i and I T are assumed independent in the irrelevant case both P i and I T , given irrelevances. Then the relevance rank becomes: Here, we use the items that a user previously downloaded to represent a user X  X  profile. Individual items in the profile of peer are denoted as I P i q indicating the q th item of peer P , with: I P i q  X  X  I j | j  X  X  1 , ..., N }} , q  X  X  1 , ..., Q is the number of items downloaded for user P i .

We further assume that these items are conditionally in-dependent from each other. This leads to: By applying the Bayes rule once more we can rewrite the relevance rank into: In order to make a recommendation, we need to estimate the prior relevance probability of an item P ( r | I a ) as well as the relevance probability between two pair items P ( r | I a, b  X  X  1 , ..., N } . Like [3] we use user profiles (binary case) to measure the relevances: P ( r | I a , I b ) = where L i = 0 , 1 is the download-list (or play-list) of user i . L ( I a ) indicates whether I a is in the list or not.
Clearly, the calculations require a whole collection of pro-files (e.g. play-lists). However, in a P2P network, these are not readily available for each peer. We have found the dynamically updating solution by attaching to each item a buddy table . This buddy table stores the information (in-cluding an index to their location) about the top -N relevant items according to their relevances with the buddy table item. It updates each time that the item is downloaded.
At a given time, the relevance between two items is up-dated according to: where  X  P t ( r | I a , I b ) is the update of the relevance between two items from time t  X   X  t to t . The update is only non-zero when there is a user that downloads one of the items I or I b while that user in the past already expressed interest in the opposite item. Hence, relevance updates only occur when files are downloaded or played. We make the assump-tion that the order in which items are being downloaded is arbitrary. This implies that for the increase in the relevance between the two items I a and I b , it does not matter whether I is downloaded by a peer with I b in the play-list, or vice versa.  X  P t ( r | I a , I b ) in equation (6) can then be rewritten as (for details, we refer to [6]):  X  P t ( r | I a , I b ) = where T k is the transaction at time k , and item ( T k ) indicates the item being downloaded in T k and peer ( T k ) indicates the peer that performs the download. Consequently, the buddy tables store the relevance between two items I a and I b lo-cally at both the items. Eq. (7) tells us that we can update only the relevances within the buddy table of that item that is being downloaded (to minimize the communication). In other words, the relevance between items I a and I b is up-dated locally at item I a when I a is downloaded.
Using Eq. (4), (7) and the buddy tables, a recommenda-tion can be generated as follows: where q  X  X  1 , ..Q i } X  I T  X  buddy table of I P i q and | q | is number of the elements belonging to q .
We conducted our experiments in the situation that users exchange music files on a P2P network. This data is gener-ated from a music play-list data set from the Audioscrobbler community (audioscrobbler.com). For computational rea-sons, we randomly sampled the data set to limit the number of users to 1300 and the number of items to 4807.
We compared our distributed collaborative filtering ap-proaches (two different settings) with the T op -N suggest recommendation engine, a well-known centralized collabora-tive filtering approach ([3]). The normalized precision (nor-malized according to the precision of a random recommen-dation) of the five methods are shown in Fig. 1. It shows that the performance of our distributed recommendation is comparable with the centralized methods. Our approach with the item prior outperforms even the centralized top-N user-based recommendation method and approximates the best top-N item-based method.
 Figure 1: Recommendation results. The normalized precision for: (1) our distributed collaborative filter-ing with the prior term of equation (8); (2) without the prior term; (3) the centralized item-based sug-gest method; (4) the centralized user-based suggest method; and (5) a reference method based on an average ranking. [1] J. S. Breese, D. Heckerman, and C. Kadie. Empirical [2] T. Hofmann and J. Puzicha. Latent class models for [3] G. Karypis. Evaluation of item-based top-n [4] J. Lafferty and C. Zhai. Probabilistic relevance models [5] J. Pisson and T. Moors. Survey of research towards [6] J. Wang, M. Reinders, R. Lagendijk, and J. Pouwelse.
