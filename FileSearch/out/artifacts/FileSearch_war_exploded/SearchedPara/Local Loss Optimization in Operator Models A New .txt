 Borja Balle bballe@lsi.upc.edu Ariadna Quattoni aquattoni@lsi.upc.edu Xavier Carreras carreras@lsi.upc.edu Universitat Polit`ecnica de Catalunya, Barcelona Structured latent variable models (e.g. Hidden Markov Models or Hidden Conditional Random fields) have become an essential modelling tool in multiple areas of machine learning such as Computer Vision, Nat-ural Language Processing, and Bioinformatics. The power of these models resides in their ability to ex-plain dependences in observed data using hidden unob-served variables. However, this expressivity comes at a cost: in general inducing the parameters of the model from observed data is computationally hard. In prac-tice, despite the intrinsic difficulty, powerful heuristic methods have been developed. Most of these methods can be interpreted as instances of the Expectation X  Maximization algorithm (Dempster et al., 1977). EM is an iterative algorithm that tries to minimize a non-convex objective function. One of its appeals is that it carries an intuitive interpretation, i.e. it minimizes the empirical error over a set of observed sequences. Its drawback is that since it attempts to minimize a non-convex function it is suceptible to local optima issues.
 Recently a new line of work on learning structured la-tent variable models has emerged. It is the so-called spectral learning method , introduced by (Hsu et al., 2009) in the context of HMM and also applied to many other models such as Reduced Rank HMM (Siddiqi et al., 2010), Kernelized HMM (Song et al., 2010), Predictive State Representations (Boots et al., 2011), Latent Tree Graphical Models (Parikh et al., 2011), Finite States Transducers (Balle et al., 2011), and Quadratic Weighted Automata (Bailly, 2011). This method dodges the two main drawbacks of the EM algorithm: it always finds a global optimum, and its running time is linear in the number of training ex-amples. The key insight of the spectral approach is to represent the distribution computed by the model in terms of observable operators and show that (under certain assumptions) two models with similar opera-tors compute similar functions (under some metric). The learning method then provides a set of equations, involving statistics computed from data, from which operators can be induced by computing approximate regularized solutions. In particular, all the works cited above share a common ingredient: the use of a Singu-lar Value Decompostion for obtaining operators; hence the name spectral method. One of the appeals of this approach is that in general it can be rigorously stud-ied using sensitivity analysis to bound the effect of perturbations on the equations used to recover opera-tors from data. Altogether, it seems fair to assert that some of the theoretical aspects of the spectral method are now well understood. When contrasted with EM, there is little doubt that the spectral method is a very attractive alternative. However, EM seems to have some advantages on the eye of the researchers inter-ested in exploiting latent variable models for a given application. Namely, its generic nature makes it easier to apply to new models and applications.
 We believe some important aspects that can ease the applicability of spectral methods to real world prob-lems have been overlooked in previous analysis. Some of these issues are addressed in the present paper. Our first contribution is to re-visit the problem of learning observable operators from a loss minimization perspective. In particular, we give a formulation of the problem in terms of a regularized local loss minimiza-tion. We emphasize the local aspect of this minimiza-tion  X  which means that, in order to learn a function computed by an operator model, it is enough to ob-serve its behavior on a finite set of elements. This is in contrast to the global loss formulation used in iterative algorithms such as EM.
 To solve the local loss minimization we derive two op-timization algorithms. The first algorithm frames the problem as minimizing a non-convex local loss func-tion. We show that under certain conditions the stan-dard SVD method can be seen as an optimizer for this objective.
 Our second contribution is to propose a regularized convex relaxation of the local loss minimization. A feature of the SVD method is that only one discrete parameter, the number of states , needs to be tuned. In practice, this means that the space of all possi-ble hypothesis can be exhaustively explored in rela-tively short time. However, in many cases, tuning this coarse-grained parameter is not enough for at-taining an optimal trade-off between empirical error and model complexity. In contrast, our convex opti-mization algorithm takes a continuous regularization parameter that can be tuned in order to achieve an optimal trade-off. In practice, our synthetic exper-iments show that our method can be more robust to some spectral properties of the target distribution that represent a challenge for the SVD method.
 In this paper we also address another important prac-tical issue overlooked by previous work. In the gen-eral case, the consistency of both the SVD method and our optimization algorithms depend on a rather strong hypothesis. Namely, that the  X  X orrect X  subset of the domain where the operators must be optimized  X  in our terms, the local loss function  X  is known to the algorithm. Though very convenient in theoretical studies, in practice this assumption does not seem very realistic.
 Our third contribution is to prove that a simple ran-domized strategy can identify a correct local loss func-tion with high probability. More precisely, we give bounds on the number of examples required by our loss-selection algorithm that depend polynomially on some parameters of the target.
 We choose to present our results in the setting of Weighted Automata. This framework encompasses several of the models considered in the literature on the spectral method: HMM, reduced-rank HMM, PNFA, QWA and rational stochastic languages. With some modifications, this framework can also deal with input-output models like FST and PSR. In general, models defined in terms of a finite state machines over some finite alphabet can be formulated using Weighted Au-tomata. 2.1. Preliminaries and Notation Let  X  be a finite alphabet with m symbols. We write  X   X  for the set of all strings over  X  and use  X  to denote the empty string. The Hankel matrix of a function f :  X   X   X  R over strings is a bi-infinite matrix H f  X   X   X   X   X   X  R with its entries indexed by prefixes and suffixes: H f ( u,v ) = f ( uv ). The rank of f is defined as rank( f ) = rank( H f ), which may in principle be infinite. Given sets of prefixes and suffixes U , V  X   X   X  we define the Hankel sub-block H : U  X V  X  R of H f as H ( u,v ) = f ( uv ). Note that when |U| = p , |V| = s we have H  X  R p  X  s . In general, given U and V one has rank( H )  X  rank( H f ). We say that the pair ( U , V ) is a basis for f if rank( H ) = rank( H f ). Note that then it must be the case that p,s  X  rank ( H f ). For any symbol a  X   X , we also define the sub-block H a  X  R p  X  s as H a ( u,v ) = f ( uav ).
 A weighted automata (WA) over  X  with n states is a A a  X  R n  X  n . We write | A | for the number of states of A . The function f A :  X   X   X  R defined by A is given by It is obvious from the definition that if M  X  R n  X  n is an invertible matrix, the WA B =  X  1 M,M Sometimes B is denoted by M  X  1 AM .
 A probability distribution D over  X   X  receives the name of a stochastic languange . We say that D has full sup-port if D ( x ) &gt; 0 for all x  X   X   X  . A stochastic lan-guage is rational if there exists a WA A such that f ( x ) = D ( x ) for all x  X   X   X  .
 By default all vectors are assumed to be columns. The Moore X  X enrose pseudo-inverse of a matrix M is denoted by M + . A rank factorization of a matrix M  X  R m  X  n with rank( M ) = r is a pair Q  X  R m  X  r , R  X  R r  X  n such that M = QR and rank( Q ) = rank( R ) = r . We denote the i th row of M by M ( i, :), and the j th column by M (: ,j ). For Hankel matrices and Hankel sub-blocks, rows and columns are respectively indexed by prefixes and suffixes. The notation k X k is used for the ` 2 norm of vectors and matrices. Similarly, k X k F denotes the Frobenius norm, and k  X  k  X  the nuclear norm. 2.2. Probability Distributions over Strings Throughout the paper it is assumed that some sub-blocks of the Hankel matrix H f are known, either ex-actly or in an approximate form. Obviously, in prac-tice it only makes sense to consider targets for which (approximations of) these sub-blocks can be effectively obtained, say by examples drawn from a probility dis-tribution, say by making queries to some oracle. In general, most spectral methods discussed in Section 1 are used for learning probability distributions defined by some form of finite state machine. In these cases, the entries of H are probabilities and usually a sam-ple drawn from the corresponding distribution is used for obtaining empirical estimates of this probabilities, yielding an approximate Hankel sub-block b H . Though we shall not fix any particular probabilistic model, it is worth noting that our results apply seam-lessly to most of the settings cosidered so far. In par-ticular, we can deal with the following two settings: when f defines probabilities over finite prefixes (like in the HMM formulations) and words are sampled from these distributions conditioned on an externally (fixed or randomly) given length; and, when f is a rational stochastic language. Furthermore, in the latter case our model encompasses the settings where a sample is used to estimate probabilities of words f ( x ), pre-fixes f ( x  X   X  ), or substrings f ( X   X  x  X   X  ), since it is not difficult to see that when f is given by some WA with n states, there exists another WA with n states com-puting prefix and substring probabilities (Luque et al., 2012). 2.3. Duality between WA and Factorizations Let f :  X   X   X  R be a function over strings with Hankel matrix H f . We recall the following result (see (Beimel et al., 2000)): rank( f ) = r &lt;  X  if and only if f = f for some WA A with r states and for any WA A such that f A = f then | A | X  r . If f = f A and | A | = rank( f ) we say that A is minimal for f .
 Our ultimate goal is to learn a function f :  X   X   X  R of finite rank by observing a sub-block of its Hankel ma-trix. Since our hypotheses will be functions computed by weighted automata, a natural question to ask is the relation between (minimal) WA for f and sub-blocks of H f . Our first observation is that any minimal WA for f induces a  X  X ice X  factorization of any sub-block H defined on a  X  X ood X  set of prefixes and suffixes. Let A be a minimal WA for some f of rank r . Then A induces a rank factorization of the Hankel matrix of f of the form H f = P f S f , where P f  X  R  X  X  r and S f  X  R r  X  X  are defined as: P f ( u, :) =  X  &gt; 1 A u , and S ,v ) = A v  X   X  . Actually, for any sets of prefixes U and suffixes V , A also induces a factorization H = PS of the associated sub-block with P  X  R p  X  r and S  X  R r  X  s Furthermore, we can show that if ( U , V ) is a basis of f , then H = PS is a rank factorization. Indeed, the in-equalities r = rank( H )  X  min { rank( P ) , rank( S ) } and p,s  X  r , imply that rank( P ) = rank( S ) = r . Note that from P ( u, :) =  X  1 A u and S (: ,v ) = A v  X   X  one can also derive the following useful factorization: H a = PA a S . Thus, we have seen how a minimal WA for f induces a rank factorization of H provided that U and V form a basis of f . The following lemma shows that this relation can be reversed. Together, these two facts show that minimal WA for f and rank factorizations of H are  X  X ual X  whenever ( U , V ) is a basis. Lemma 1. Suppose ( U , V ) is a basis of f with  X   X  U and  X   X  U . Let h &gt; r, X  = H (  X , :) and h c, X  = H (: , X  ) be the respective row and column of H associated with  X  . For any rank factorization H = QR , let A =  X  1 , X   X  , { A a } be the WA given by:  X   X   X  = Q + h c, X  , and A a = Q + H a R + . Then A is a minimal WA for f .
 Proof. Let B =  X   X  1 , X   X  , { B a } X  be a minimal WA for f inducing a rank factorization H = PS . It suffices to prove that there exists an invertible M such that A = M  X  1 BM . Let M = SR + . Since ( Q + P )( SR + ) = Q + HR + = I , we see that M is in-vertible with inverse M  X  1 = Q + P . Now we check that the operators of A correspond to the operators of B under the change of basis M . First, we see that A observe that by the definitions of S and P we have  X  1 S = h  X  1 =  X  From now on, we assume without loss of generality that any basis ( U , V ) contains the empty string  X  as a prefix and a suffix.
 The spectral algorithm of (Hsu et al., 2009) can be easily derived using Lemma 1. Basically, it accounts to taking the rank factorization H = ( HV ) V &gt; , where H = U  X  V &gt; is a compact SVD. In next section we will derive another algorithm based on loss minimization that yields similar results. In spirit, our algorithm is similar to the spectral method in the sense that in order to learn a function f :  X   X   X  R of finite rank, the algorithm infers a WA using (approximate) information from a sub-block of H f . The sub-block used by the algorithm is defined in terms of a set of prefixes U and suffixes V . Throughout this section we assume that f is fixed and has rank r , and that a basis ( U , V ) of f is given. How to find these sets of prefixes and suffixes given a sample is discussed in Section 4.
 We state our algorithm under the hypothesis that sub-blocks H and { H a } a  X   X  of H f are known exactly. It is trivial to modify the algorithms to work in the case when only approximations b H and { b H a } a  X   X  of the Han-kel sub-blocks are known.
 For 1  X  n  X  s we define the local loss function ` ( X, X   X  , { B a } ) on variables X  X  R s  X  n ,  X   X   X  R n and B a  X  R n  X  n for a  X   X  as: ` The operator learning algorithm is a constrained min-imization of the local loss: Intuitively, this optimization tries to jointly solve the optimizations solved by SVD and pseudo-inverse in the spectral method based on Lemma 1. In particular, likewise for the SVD-based method, it can be shown that (SO) is consistent whenever a large enough guess for n is provided.
 Theorem 2. Suppose n  X  r . Then, for any optimal solution ( X  X  , X   X   X  , { B  X  a } ) to problem (SO) , the weighted The proof of this theorem is sketched in Appendix A.1. Though the proof is relatively simple in the case n = r , it turns out that the case n &gt; r is much more delicate  X  unlike in the SVD-based method, where the same proof applies to all n  X  r .
 Of course, if H and { H a } are not fully known, but ap-proximations b H and { b H a } are given to the algorithm, we can still minimize the empirical local loss b ` n and build a WA from the solution using the same method of Theorem 2.
 Despite its consistency, in general the optimization (SO) is not algorithmically tractable because its ob-jective function is quadratic non-positive semidefinite and the constraint on X is not convex. Nonetheless, the proof of Theorem 2 shows that when H and { H a } are known exactly, the SVD method can be used to effi-ciently compute an optimal solution of (SO). Further-more, the SVD method can be regarded as an approxi-mate solver for (SO) with an empirical loss function b ` n as follows. Find first an b X satisfying the constraints using the SVD of b H , and then compute b  X   X  and { b B a by minimizing the loss (2) with fixed b X  X  note that in this case, the optimization turns out to be convex. From this perspective, the bounds for the distance between operators recovered with full and approxi-mate data given in several papers about the spectral method, can be restated as a sensitivity analysis of the optimization solved by the spectral algorithm. In fact, a similar analysis can be done for (SO), though we shall not pursue this direction here.
 Instead, we shall present a convex relaxation of (SO) that addresses a practical issue in this optimization algorithm. That is, the fact that the only parame-ter a user can adjust in (SO) in order to trade accu-racy and model complexity is the number of states n . Though the discreteness of this parameter allows for a fast model selection scheme through a full exploration of the parameter space, in some applications one may be willing to invest some time in exploring a larger, more fine-grained space of parameters, with the hope of reaching a better trade-off between accuracy and model complexity. The algorithm presented in next section does this by incorporating a continuous regu-larization parameter. 3.1. A Convex Local Loss The main idea in order to obtain a convex optimiza-tion problem similar to (SO) will be to remove X , since we have already seen that it is the only source of non-convexity in the optimization. However, the new convex objective will need to incorporate a term that enforces the optimization to behave in a similar way as (SO).
 First note that the choice of n effectively restricts the maximum rank of the operators B a . Once this max-imal rank is set, X can be interpreted as enforcing a common  X  X emantic space X  between the different oper-ators B a by making sure each of them works on a state space defined by the same projection of H . Further-more, the constraint on X tightly controls its norm and thus ensures that the operators B a will also have its norm tightly controlled to be in the order of k H a k / k H k  X  at least when n = r , see the proof of Theorem 2. Thus, in order to obtain a convex optimization sim-ilar to (SO) we do the following. First, take n = s and fix X = I , thus unrestricting the model class and removing the source of non-convexity. Then penalize the resulting objective with a convex relaxation of the term rank([ B a 1 ,...,B a m ]), which makes sure the op-erators have low rank individually, and enforces them to work on a common low-dimensional state space. More formally, for any regularization parameter  X  &gt; B where we interpret B  X  = [ B a 1 ,...,B a m ] as a concate-nation of the operators, and H  X  = [ H a 1 ,...,H a m Since  X  ` is clearly convex on B  X  , we can learn a set of operators by solving the convex optimization problem Given an optimal solution B  X   X  of (CO), we define a WA B vector with e  X  (  X  ) = 1.
 Some useful facts about this optimization are collected in the following proposition.
 Proposition 3. The following hold: (1) if H has full column rank, then (CO) has a unique solution; (2) for n = s and  X   X  1 , the optimum value `  X  s of (SO) and the optimum value  X  `  X   X  of (CO) satisfy `  X  s  X   X  ` suppose rank( H ) = rank([ H  X  ,H ]) and let [ H  X  ,H ] = U  X [ V &gt;  X  V &gt; ] be a compact SVD. Then, B  X  = ( V &gt; is a closed form solution for (CO) when  X   X  X  X  Proof. Fact (1) follows from the observation that when H has full rank the loss  X  `  X  is strictly convex. For fact (2), suppose B  X   X  achieves the optimal value in (CO) and check that `  X  s  X  ` s ( I,e  X  ,B  X   X  ) = k HB  X   X   X  H  X  ` . Fact (3) follows from Theorem 2.1 in (Liu et al., 2010) and the observation that when  X   X   X  op-timization (CO) is equivalent to min B  X  k B  X  k  X  s.t. HB  X  = H  X  .
 Note that in general approximations b H of H computed from samples will have full rank with high probabil-ity. Thus, fact (1) tells us that either in this case, or when p = n , optimization (CO) has a unique optimum. Furthermore, by fact (2) we see that minimizing the convex loss is also, in a relaxed sense, minimizing the non-convex loss which is known to be consistent. In addition, fact (3) implies that when H has full rank and  X  is very large, we recover the spectral method with n = s . These and other properties of (CO) ap-pear in the experimens described in Section 5. Optimization (CO) can be restated in several ways. In particular, by standard techniques, it can be shown that it is equivalent to a Conic Program on the inter-section of a semi-definite cone (given by the nuclear norm), and a quadratic cone (given by the Frobenius norm). Similarly, the problem can also be fully ex-pressed as a semi-definite program, though in general this conversion is believed to be inefficient. Altogether, the number of variables in (CO) is ms 2 . Formulat-ing the conic program yields O ( m 2 s 2 ) varibles, and constraints in a space of size O ( mps + ms 2 ). When the fully semi-definite program is considered, the con-straint space grows to dimension O ( m 2 p 2 s 2 ). This shows that finding a small basis, in particular, a ba-sis defined over a small set of prefixes, is important in practice. We note here that the complexity of the SVD method scales similarly. We have already discussed why, in practice, it is impor-tant to have methods for finding a basis. In this section we show a fundamental result about basis. Namely, that simple randomized strategies for choosing a basis succeed with high probability. Furthermore, our result gives bounds on the number of examples required for finding a basis that depend polynomially on some pa-rameters of the target function f :  X   X   X  R and the sampling distribution D .
 We begin with a well-known folklore result about the existence of minimal basis. This implies that in prin-ciple all methods for learning WA from sub-blocks of the Hankel matrix can work with a block whose size is only quadratic in the number of states of the target. Proposition 4. For any f :  X   X   X  R of rank r there exists a basis ( U , V ) of f with |U| = |V| = r . A WA A =  X  &gt; 1 , X   X  , { A a } is called strongly bounded if k A a k  X  1 for all a  X   X . Note that this implies the boundeness of f A since | f A ( x ) | = |  X  &gt; 1 A k  X  1 kk  X   X  k . A function over strings f of finite rank is called strongly bounded if there exists a strongly bounded minimal WA for f . Note that, in particu-lar, all models of probabilistic automata discussed in Section 2.2 are strongly bounded.
 Our result states that, under some simple hypothesis, Algorithm 1 Random Basis Input: strings S = ( x 1 ,...,x N ) Output: basis candidate ( U , V )
Initialize U  X   X  , V  X   X  for i = 1 to N do end for with high probability Algorithm 1 will return a correct basis when enough examples are examined.
 Theorem 5. Let f :  X   X   X  R be a strongly bounded function of rank r and D a distribution over  X   X  with full support.Suppose that N strings sampled i.i.d. from D are given to Algorithm 1. Then, if N  X  C X  log(1 / X  ) for some universal constant C and a parameter  X  that depends on f and D , the output ( U , V ) is a basis for f with probability at least 1  X   X  .
 A proof of this result based on random matrix theory is given in Appendix A. We conducted synthetic and real experiments compar-ing the SVD and the Convex Optimization methods. For the synthetic experiments, we created random PN-FAs with alphabet sizes ranging from 2 to 10 symbols and a random number of states in the same range. For each random target model, we then sampled k train-ing sequences and trained models using SVD and CO. Results are reported in terms of L 1 error with respect to the true distribution (all results are averages of 10 sampling rounds). We fixed the set of prefixes and suffixes to be all substrings of length 1, following (Hsu et al., 2009). Table 1 shows learning curves for three target models. Each model was chosen randomly from a set of models that have the smallest singular value of H in the same order of magnitude. For each target and method we show the error of the best model (i.e. optimal n for the SVD method and optimal  X  for the CO method). For the second distribution in Table 1, Figure 1.a shows the L 1 error of the CO method as a function of  X  . It also shows the error of the SVD method for different number of states.
 Figure 1.b summarizes all results for the largest size of training set. For each target model, we show the aver-age error of the two learned models as a function of the smallest singular value of the target. We observe that in general target models with smaller singular values are harder to learn, and it is in those cases that the CO approach obtains the largest gain in accuracy. We also conducted experiments on natural language data, for the task of language modeling of syntactic part-of-speech tags (i.e. noun, verb, adjective, . . . ). This type of language models are a central building block in Natural Language Processing methods for tag-ging the words of a sentence with their syntactic func-tion. We used the English Penn Treebank with a tag set of 12 symbols, and used the standard splits for training (39,832 sentences with avg. length of 23) and validation (1,700 sentences).
 Figure 1.c plots curves on the validation set comparing the SVD method, the CO method, the standard EM algorithm, and two simple baselines based on statis-tics of single symbols (Unigram) and pairs of symbols (Bigram). For each model we plot the word error rate with respect to the nuclear norm of their operators. All hidden state models improve the baselines, while the CO method is able to improve over the SVD method. The EM method obtains the best error rates, though it is much slower to train (a factor of 100 times). Finally, Table 2 shows the peformance of the SVD method using random sets of prefixes and suffixes. In this case, we generated substrings of up to 4 sym-bols, and sampled them according to their frequency on the training data. We used the random substrings to define Hankel sub-blocks of increasing dimension-alities. For each dimensionality, we trained a model using SVD, and chose the number of states that mini-mized error on validation data. Clearly, expanding the Hankel sub-block results in a benefit in terms of the error. For comparison, the table also reports the per-formance of EM with respect to the number of states. In this paper we have attempted to facilitate the un-derstanding and applicability of spectral approaches for learning weighted automata. In particular, we have made the following contributions: (1) formulate weighted automata learning as a local loss minimiza-tion; (2) show that under certain conditions the stan-dard SVD approach is an optimizer of this local loss; (3) propose a convex relaxation that permits fine tun-ing of the complexity X  X ccuracy trade-off; (4) offer a provable correct method for estimating the scope of the local loss function from samples; and (5) show on synthetic experiments that under certain conditions the convex relaxation method is more robust than the SVD approach.
 A.1. Proof Sketch for Theorem 2 The following two lemmas will be used in the proof. Lemma 6. Let A =  X  &gt; 1 , X   X  , { A a } be a WA with n states. Suppose that ( U , V ) is a basis for f A and write H = PS for the factorization induced by A on this Hankel sub-block. For any m and any pair of matrices N  X  R m  X  n and M  X  R n  X  m such that PMN = P , the WA B = NAM =  X  &gt; 1 M,N X   X  , { NA a M } satistifies f Lemma 7. Let f :  X   X   X  R be a function of finite rank r and suppose that ( U , V ) is a basis for f . Then the matrix H  X  = [ H a 1 ,...,H a m ] has rank r . Now the following three facts can be established. To-gether, they imply the result.
 Claim 1: The optimal value of problem (SO) is zero. Let H = U  X  V &gt; be a full SVD of H and write V n  X  R s  X  n for the n left singular vectors corre-sponding first n singular values. Then consider the show that ` n ( V n , ( HV n ) + h c, X  , { ( HV n ) + H a Claim 2: For any n  X  r , A n satisfies f A n = f . Apply Lemma 6 to show that f A n = f A r for n &gt; r , and then Lemma 1 to show f A r = f .
 Claim 3: For any optimal solution B  X  one has f B  X  = f n . Lemma 7 is used to show that HX Then, Lemma 6 with N = ( X  X  ) &gt; V n and M = V &gt; n X implies the claim.
 A.2. Proof of Theorem 5 We use the following result from (Vershynin, 2012). Theorem 8 (Corollary 5.52 in (Vershynin, 2012)) . Consider a probability distribution in R d with full-rank covariance matrix C and supported in a centered Eu-clidean ball of radius R . Also, let  X  1  X  ...  X   X  d &gt; 0 be the singular values of C . Take N i.i.d. examples from the distribution and let b C denote its sample covariance matrix. Then, if N  X  K (  X  1 / X  2 d ) R 2 log(1 / X  ) the ma-trix b C has full rank with probability at least 1  X   X  . Here K is a universal constant.
 Consider the prefixes produced by Algorithm 1 on in-put an i.i.d. random sample S = ( x 1 ,...,x N ) drawn from D . We write U = ( u 1 ,...,u N ) for the tuple of prefixes produced by the algorithm and use U 0 to de-note the set defined by these prefixes. We define V and V 0 similarly. Let p 0 = |U 0 | and s 0 = |V 0 | . Our goal is to show that the random sub-block H 0  X  R p 0  X  s 0 of H f defined by the output of Algorithm 1 has rank r with high probability w.r.t. the choices of input sam-ple and splitting points. Our strategy will be to show that one always has H 0 = P 0 S 0 , where P 0  X  R p 0 and S 0  X  R r  X  s 0 are such that with high probability rank( P 0 ) = rank( S 0 ) = r . The arguments are identi-cal for P 0 and S 0 .
 Fix a strongly bounded minimal WA A =  X  1 , X   X  , { A a } for f , and let H f = P f S f denote the rank factorization induced by A . We write p &gt; u = P ( u, :) for the u th row of P f . Note that since A is strongly bounded we have k p &gt; u k = k  X  &gt; 1 A u k  X  k  X  The desired P 0 will be the sub-block of P f correpond-ing to the prefixes in U 0 . In the following we bound the probability that this matrix is rank deficient. The first step is to characterize the distribution of the elements of U . Since the prefixes u i are all i.i.d., we write D p to denote the distribution from which these prefixes are drawn, and observe that for any u  X   X   X  and any 1  X  i  X  N we have D p ( u ) = P [ u i = u ] = P [  X  v : x i = uv  X  t = | u | ], where x i is drawn from D and t is uniform in [0 , | x i | ]. Thus we see that D p P Now we overload our notation and let D p also denote the following distribution over R r supported on the follows from this definition that the covariance ma-trix of D p satisfies C p = E [ qq &gt; ] = P u D p ( u ) p Observe that this expression can be written in ma-trix form as C p = P &gt; f D p P f , where D p is a bi-infinite diagonal matrix with entries D p ( u,u ) = D p ( u ). We say that the distribution D is pref-adversarial for A if rank( C p ) &lt; r . Note that if D ( x ) &gt; 0 for all x  X   X  then D p has full-rank and consequently rank( C p ) = r . This shows that distributions with full support are never pref-adversarial, and thus we can assume that C p has full rank.
 Next we use the prefixes in U to build a matrix P  X  R
N  X  r whose i th row corresponds to the u i th row of P f that is: P ( i, :) = p &gt; u i . It is immediate to see that P can be obtained from P by possibly removing some re-peated rows and reordering the remaining ones. Thus we have rank( P ) = rank( P 0 ). Furthermore, by con-struction we have that b C p = P &gt; P is the sample covari-ance matrix of N vectors in R r drawn i.i.d. from D p . Therefore, a straightforward application of Theorem 8 then rank( P 0 ) = r with probability at least 1  X   X  . Here K is a universal constant,  X  ( C p ) is the condition num-ber of C p , and  X  ( C p ) is the smallest singular value of C , where these last two terms depend on A and D . The result follows by symmetry from a union bound. Furthermore, we can take  X  =  X  ( f, D ) = inf A max { (  X  ( C p ) / X  ( C p )) k  X  &gt; 1 k 2 , (  X  ( C where the infimum is taken over all minimal strongly bounded WA for f .

