 We present in this paper an approach for XQuery optimization that exploits minimization opportunities raised in composition-style nest-ing of queries. More precisely, we consider the simplification of XQuery queries in which the intermediate result constructed by a subexpression is queried by another subexpression. Based on a large subset of XQuery, we describe a rule-based algorithm that re-cursively prunes query expressions, eliminating useless intermedi-ate results. Our algorithm takes as input an XQuery expression that may have navigation within its subexpressions and outputs a sim-plified, equivalent XQuery expression, and is thus readily usable as an optimization module in any existing XQuery processor. We demonstrate by experiments the impact of our rewriting approach on query evaluation costs and we prove formally its correctness. Categories and Subject Descriptors: H.2 [Information Systems]: Database Management  X  X uery Language General Terms: Algorithms, Language, Performance Keywords: XML, XQuery, query rewriting
XML is by now the de facto standard format for data exchange on the Web. It is also used as a data model for native XML databases and as a common language in systems that integrate data coming from heterogenous sources. It is thus essential to have effective and efficient tools for querying and manipulating XML data. Con-sequently, query languages such as XPath and XQuery have been receiving a great deal of attention from the research community lately. And, unsurprisingly, query optimization, one of the most im-portant (and most studied) topics in relational databases, has seen a revival in the semi-structured context.

The XQuery language plays a key role in XML data management and has many powerful features such as nesting and composition of for-let-where-return (FLWR) query blocks, the construction of hi-erarchical XML results and the navigation in documents by means of XPath expressions. Unfortunately, its expressive power and op-erational semantics make the reasoning about query optimization quite difficult and have been the main obstacles in establishing a comprehensive framework for query optimization, although signif-icant progress has been made in this direction.

We study in this paper a novel aspect of XQuery optimization that exploits minimization opportunities raised in a composition-style nesting of XQuery queries. More precisely, we consider the simplification of XQuery expressions in which the intermediate re-sults constructed by a subexpression is queried by another subex-pression. In other words, given an XQuery expression with navi-gation over some documents, we consider a setting in which some of these documents may in fact be intentional , defined as the result of other XQuery subexpressions. Our approach is similar in spirit to the one of Marian and Simeon [16], of projecting XML doc-uments w.r.t. a given XQuery query. Instead of XML documents, we project XQuery subexpressions with respect to other subexpres-sions querying them.

This kind of composition is common in many scenarios of data exchange, mediation or integration, or in view-based security. Be-fore discussing in more detail these scenarios, and several others, let us first illustrate the problem we study and the main challenges by a data integration example. The example deals with the refor-mulation of queries over heterogenous, interconnected sources.
E XAMPLE 1.1. Our example is based on the XMark benchmark data [20]. Let us consider three interconnected XML sources S S and S 3 , with S 1 being somehow complemented by S 2 and S S integrates data coming from these two sources under a unified schema that can be transparently queried by users. To this end, mappings between the schema of S 1 and the ones of S 2 and S defined by means of transformation XQuery queries, Q 2 and Q follows 1 :
The query Q 2 returns all open_auction , closed_auction and person data from the sites containing a person identified by  X  X  X  . The query Q 3 computes the sequence of the closed_auction elements having
We use doc @ S i as short notation for a document URL at S either a buyer identified by  X  X  X  or an item car, and a seller identi-fied by  X  Y  X  . In both queries, the result is wrapped in a site element.
In this scenario, the role of Q 2 and Q 3 is to define the relation-ship between S 1 , on one hand, and S 2 and S 3 , on the other hand. They formulate a transfer that is only virtual and the data re mains at the sources S 2 and S 3 . Moreover, the source S 1 may also have its own data. Intuitively, S 1 could be defined by a virtual document  X  source 1 : = docC @ S 1  X  Q 2  X  Q 3  X  having an extensional compo-nent (for S 1  X  X  own data) and two intentional ones (for the data re-siding at S 2 and S 3 ).

Let us consider now the following user query Q 1 , specified over source 1 , which returns the open_auction elements that have some person data in common with another document, docD @ S 1 :
S 1  X  X  wrapper module would have no difficulty in executing Q over the extensional part of source 1 . For the intentional ones, there are two possible approaches: (a) Q 2 and Q 3 are executed at S S , their results are transferred to S 1 and then Q 1 is evaluated over them, or (b) Q 1 is  X  X ushed X  to both S 2 and S 3 , which evaluate it locally over their respective transformation queries and s end back to S 1 the result. Unsurprisingly, the latter approach can have si g-nificant advantages, especially when Q 1 uses only a small portion from the output of the transformation queries.

Now, by the second approach, S 2  X  X  wrapper module has to exe-cute Q 1 over Q 2 . This could be done by first evaluating Q evaluating Q 1 over the intermediate result. But since XQuery is compositional, it is more preferable to interpret this step as a sin-gle XQuery expression Q 1 . 2 = Q 1  X  Q 2 , by simply substituting the virtual variable by its XQuery definition. In this way, the qu ery op-timizer module can chose the best execution strategy. For in stance, Q 1 . 2 can be considered as the following XQuery expression:
At this point, instead of the straightforward execution pla n, an efficient query optimizer module should detect that Q 2 is only par-tially useful in Q 1 . 2 , since only open_auction and person elements are queried. Hence the following equivalent yet less expens ive query can be executed instead:
In the case of S 3 , the efficient optimizer would have even greater impact, since the equivalent yet simplified query should in f act re-place the content of Q 3  X  X  site element by the empty sequence, be-cause only closed_auction elements are outputted in the Q element : Our contribution. We study in this paper the simplification of queries that have a composition-style nesting as the one ill ustrated in Example 1.1. We adopt a static-analysis approach, based o n detecting and projecting out the useless parts in subexpres sions, keeping only what is needed in order to compute the end result . This task is made difficult by potentially complex relations hips be-tween the query blocks. We describe a set of rewrite rules tha t apply such pruning steps recursively over the blocks of an XQ uery query, not only at the uppermost level but at any nesting leve l in the query. Each rule application will output a strictly simp ler (i.e., with less navigation steps) yet equivalent XQuery expressi on. Our rule-based algorithm applies to a large subset of XQuery and we formally prove its correctness. Importantly, the algorith m takes as input an XQuery that may have navigation within subexpres -sions and outputs a simplified, equivalent XQuery expressio n. It can be thus easily plugged as an optimization module in any ex ist-ing XQuery processor. We implemented and tested our rewriti ng approach on top of the Galax engine and we demonstrate by expe r-iments its impact on query evaluation costs.

In the remaining of this section we further motivate our work and we discuss related research. Queries with this composit ion-style of nesting are very useful in practice. Transformatio n XQuery queries for mapping between heterogenous XML sources in int e-gration and mediation scenarios are quite common [12, 22, 1] . The Clio project [12] provides a graphical editor for defining sc hema mapping definition, generating complex XSLT or XQuery trans for-mations. In peer-to-peer settings, such as the Piazza PDMS [ 22], a peer can refer to data hold by another peer by means of an XQuer y mapping. In this setting, it is crucial to minimize the amoun t of actual data that is transferred between peers. The Active XM L system [1] introduces a flexible framework for peer-to-peer XML integration, by combining in one active document materialized (ex-tensional) XML parts with intentional parts defined by calls to Web services. Importantly these services can be defined by XQuer y ex-pressions and evaluating a query over an active document amo unts essentially to query pushing and composition.

Another important use is in queries posed on security views. In many applications that rely on sensitive data, like medical or ju-ridic applications, access to XML documents may be granted o nly by querying views over these documents. The views define what data the user can access, and the system may accept only queri es formulated over these views. It can either evaluate the glob al query (i.e., the composition of user query and the views) or can firs t ma-terialize the views and then evaluate the user query. Obviou sly, in the case of a large number of views, materializing and mainta ining these views can be too costly.

It is also common to cache and reuse the definitions of queries but not necessarily their results. This can for instance gui de inexpe-rienced users, allowing them to query XQuery expressions th at are already available and well-understood. Finally, our simpl ification technique can be used to optimize automatically generated q ueries, e.g. for graphical editors in the style of query-by-example .
Related work. Several works on XQuery processing and opti-mization adopt an approach based on rewrite rules. In [15, 18 , 17, 10, 19, 21], the authors discuss various rules for XQuery nor mal-ization or for transformation tasks such as XQuery-to-SQL t rans-lation, elimination of unnecessary ordering operations or introduc-tion of a tree-pattern operator in query plans. These approa ches are orthogonal to the query simplification technique presented here. [3] introduces rewrite rules for reducing the number of nesting levels in XQuery expressions but does not consider the elimination of use-less navigation and result construction. In [5], the author s introduce a logical framework for optimization in the OptXQuery subse t of XQuery, the Nested XML Tableaux. They present a set of rewrit e rules for normalization and grouping of repeated navigatio n steps within a query by means of a group-by operator.

More germane to this work is [16], which introduces XML doc-ument projection for query optimization. It gives a set of re write rules for the following task: starting from an XQuery expres sion Q over a document D , identify and project out the parts of D that are not useful for the evaluation of Q . This is very effective to reduce in-memory computations such as node construction. The tech nique was later refined and extended to take into account the schema of the document in [2]. Although very close in spirit, our appro ach subsumes the idea of [16] of projecting XML documents, as we consider the projection-based simplification of arbitrary XQuery blocks, and not only plain XML documents. In this context, sp e-cial attention has to be paid to preserving query equivalenc e.
In [22, 6], the authors consider the minimization of queries ob-tained by following semantic paths (mappings) in the Piazza sys-tem. To this end, they study the complexity of query containm ent for a restricted XQuery flavor, that of conjunctive XML queri es (c-XQueries). The role of composition in XQuery evaluation was considered in [13]. For an XQuery fragment strictly smaller than the one we consider here, a formal study of the computational com-plexity of XQuery without composition is provided. Moreove r, [13] shows that, under restrictions, composition can be eli minated and describes a set of rewrite rules to this end.

A problem similar to ours was also studied in the context of pu b-lishing relation data in XML format, in projects such as XPer anto [4] and SilkRoute [8]. In Silkroute, the composition of XQuery e xpres-sions represented by so called view forests over relational sources was considered, where a view forest is a mix of XML structure a nd SQL expressions representing XQuery-to-SQL translations . These techniques are specific to the XML-over-relational setting and do not transfer to XQuery minimization.

The paper is organized as follows. In Section 2, we present pr e-liminary notions. Section 3 details our rule-based algorit hm and some extensions of the algorithm are presented in Section 4. In Sec-tion 5 we describe the experimental analysis we have conduct ed. We conclude in Section 6.
We describe in this section the data model and XQuery expres-sions we consider, as well as additional assumptions.

Data model. For the sake of simplicity we present our tech-niques using a slightly simplified version of the XQuery data model. We consider an XML document as an unranked rooted tree t mod-eled by a set of edges EDGES ( t ) , a set of nodes NODES ( t ) , a distinguished root node ROOT ( t ) , a labeling function over nodes  X  assigning to each node a label (or text value) from an infinite alphabet  X  , and a typing function  X  t assigning to each node one of the following kinds: {document, element, text} . The document type can only be given to the root of the XML document and text nodes can only appear as leaves. This simplified model can be extend ed in straightforward manner to other components of the XQuery data model such as attributes.

XQuery fragment. We focus our study on a significant subset of XQuery, described by the grammar of Figure 1.
This grammar captures the main XQuery constructs used in pra c-tice, such as literal values, sequence construction, varia bles, FLWR blocks, conditionals, quantifiers, comparisons operators , logical or arithmetic operations, element constructions. For clarit y and space reasons, we consider in this paper XPath navigation only alo ng the child axis ( / ). Extensions to other navigation axis such as at-tribute ( / @) and descendant ( // ) are presented in an extended ver-sion of this work [11]. We also ignore path qualifiers, which c an always be reformulated away using where clauses.

XQuery normalization. Before applying our technique for query simplification, we assume that some of the standard nor mal-ization steps, usually employed to reduce XQuery expressio ns to equivalent expressions in the simpler language XQuery Core [7], are first applied. This normalization phase will allow us to p resent our inference algorithm based on a uniform syntactic formul ation. We give in Figure 2 the set of normalization rules we consider , each of them being self-explanatory. In short, they either f acilitate the extraction of XPath expressions referencing a variable or refor-mulate nested expressions in order to have one variable per c lause.
Inference rules notation and environment. We present our al-gorithm via a set of inference rules, and we adopt standard pr o-gramming languages notation similar to the one used in [16]. In-ference rules are based on judgements , which denote statements of the form: Env  X  f ( p 1 , . . ., p n )  X  res .

Such a statement reads as follows: the judgement holds iff in the environment Env, by calling the function f with paramete rs p , . . ., p n we obtain the result res.

Inference rules are represented as follows: where each premise is a judgement. Such a rule reads as follow s: the judgement Env  X  f ( p 1 , . . ., p n )  X  res holds if the premises premise premise n hold. The functions we consider in our inference rules will be defined in Section 3.
In XQuery, any variable $ v is associated to a subexpression, by either $ v in exp or $ v : = exp , in this way being bound to the intermediate XML values returned by the subexpression.

E XAMPLE 2.1. For instance, in the query Q 2 of the running example, variable $ i is bound to elements produced by the XPath docA @ S 2 / site. Similarly, in the query Q 3 , variable $ l is bound to some elements produced by variable $ i. This is because the FLWR block to which $ l is bound returns elements over which $ i iterates, those that satisfy certain conditions. In Q 1 , 2 $ j is bound to a constructed site element wrapping some conten t returned by Q 2  X  X  FLWR expression.

For a variable $ v , by the bound expression associated with $ v (in short, exp b ( $ v ) ) we denote the expression exp appearing in the statement declaring $ v , be it f or $ v in exp , let $ v : = exp or some $ v in exp . By the return expression of $ v (in short, exp we denote the associated where , return or satisfies parts.
In the presentation of our rule-based algorithm, we will rel y on a memory space (denoted environment ) that records for each variable the expressions that produce the intermediate results to wh ich it is bound. The environment will contain a set of mappings from va ri-ables to sets of objects. Formally, this is written $ v  X  X  o We distinguish three possible kinds of such objects: (i) res ults of an XPath expression (represented in the environment by the X Path expression itself), (ii) element constructors with some el ement con-tent (can be any XQuery subexpression), (iii) text values (d enoted simply #text ).

Going back to the example, we write $ i  X  X  docA @ S 2 / site } for Q for Q 3 , or $ j  X  X  &lt; site &gt; . . . &lt; / site &gt; } for Q
For the construction of the environment, we determine by a st atic analysis for each variable the objects returned as intermed iate XML values by its bound expression. This is done using the functi on varRes () , which infers the output kind of a subexpression by the following exhaustive and straightforward case analysis:
Since an XPath expression can be relative to a named variable (i.e., starting with a variable name), the environment will also al-low us to keep track of the relationship between variables wi thin the query (for example, the fact that $ l is bound to $ i ). For con-venience, for the manipulation of the environment we also de fine a function called saturate () , which refines the bindings by making explicit all the XPath navigation.

E XAMPLE 2.2. After obtaining by varRes that $ l  X  $ i and $ i  X  information on variable $ l , using the saturate function, as $ l  X  X  $ i ,
Finally, for a variable $ v and its bound expression exp b addition of $ v to the environment is performed in the inference rules by the following statement:
For convenience, the following functions will also be used i n the algorithm to access the pre-computed environment:
Overview. We start by giving an overview of our rule-based al-gorithm, which takes as input an XQuery expression Q and outputs an equivalent simplified XQuery expression Q  X  .

As the various bound expressions in Q compute intermediate re-sults that may only be partially useful to Q  X  X  end result, our algo-rithm identifies and prunes their irrelevant parts. The outp ut is an equivalent query Q  X  obtained from Q by substituting each subex-pression exp b ( $ v ) by a subexpression exp  X  b ( $ v ) that has the advan-tage of computing only the needed intermediate results.

For a given variable $ v , the algorithm retrieves from exp all the XPath expressions that access the result of exp b task is performed by the extractPaths function. The paths are then used to retrieve and project out the useless parts in exp is the role of the projectPaths function. A simpler subexpression exp  X  b ( $ v ) is obtained in this way.
 This process is applied recursively, in bottom-up manner, b y the Prune function over Q . More precisely, for a given variable $ v in Q , the pruning is first applied recursively within its bound and return expressions, then for $ v itself, as described above.

We continue the presentation of the algorithm, starting wit h the rule-based functions for path analysis ( extractPaths ) and query pro-jection ( projectPaths ) (in Section 3.1 and Section 3.2 respectively). We wrap-up the presentation with the Prune function, that applies in bottom-up manner the steps for path extraction and projec tion (in Section 3.3). The section ends with the formal results on cor-rectness (in Section 3.4).
The extractPaths function takes as input a variable $ v and its re-turn expression exp r ( $ v ) , analyses exp r ( $ v ) and extracts the paths that navigate through the variable $ v . These paths start with $ v (ei-ther explicitly, or via other declared variables), and are d enoted the projection paths of $ v .

Similar to [16], in our analysis we will distinguish between two kinds of projection paths: (i) used paths and (ii) returned paths . The former kind denotes paths for which the descendants of re -turned nodes are not necessarily relevant for the end result and no navigation in the subtrees of these nodes is required. These are the paths that simply bind a variable $ v , appearing only in its bound expression exp b ( $ v ) .

The latter kind denotes paths for which descendants of the no des reached by the path may be relevant and must be kept in the end result. Paths are by default considered of the returned kind, unless some conditions for the used kind are verified.
 We now present the inference rules for the extractPaths function. The result of each rule application will be two sets of paths, P and , for the used and returned paths respectively.
 Literal, empty sequence. When the input expression exp r ( $ v ) is a literal (rule ep 1) or an empty sequence (rule ep 2), no paths can be extracted.
 Sequence, conditional, comparison, element construction . In this case (rules ep 3 to ep 6), the analysis of the input expression amounts to analyzing its subexpressions, and the output set s P and # are obtained from the union of the used and returned paths ex-tracted from the subexpressions.
 Variable reference. When the input expression exp r ( $ v ) is a vari-able reference, we have two alternative cases. If exp r ( $ v ) = $ v (rule ep 7), the output result is a returned path $ v (a one step path). sions bound to $ v  X  those that are relative to $ v (i.e., $ v is their first step). These paths constitute the output set of returned paths P (rule ep 8). The output set of used paths P is empty in both cases. XPath expression. Here, due to the normalization process de-scribed in Section 2, we have only three alternatives (rules ep 9 to ep 11). If the input expression exp r ( $ v ) is a path relative to $ v , then this path formes the output set of returned paths P # (rule ep 9). XPath expressions bound to $ v  X  those that are relative to $ v (if any exist). These are used to substitute $ v  X  and create the output set of returned paths P # (rule ep 10). Otherwise (rule ep 11), no paths relative de $ v can be extracted from the input expression and the output set of returned paths is empty. The output set of used paths P is empty in the three cases.
 FLWR expression, quantifier. Here, the input expression exp is a FLWR or quantifier expression: for instance, f or $ v where e 2 return e 3 .

The first three premises (or the first two, in the case of the qua n-tifier expression) in the inference rules ep 12 to ep 14 will simply apply recursively the path analysis process to the subexpre ssions e , e 2 and e 3 .

The role of the remaining premises is to transform some of the returned paths P # 1 from e 1 into used paths for $ v . This would ob-viously allow for more drastic query simplifications in the l ater stages. The transformation happens when certain condition s are verified for the projection paths P # 1 , more precisely when (1) the paths are bound to variable $ v  X  (this can be checked by testing if to $ v (i.e., $ v is their first step). The paths verifying these two con-ditions are moved from the set of returned paths to the one of used paths .
 Consider the following example:
E XAMPLE 3.1. Given the query: the path $ v / A / B is bound to variable $ v  X  . Although $ v / A / B is initially a returned path, the fact that it is relative to $ v enables us to safely consider it a used path . In this case, the descendants of B elements are deemed not necessary to compute the end resu lt (unless some other path overwrites this fact).

E XAMPLE 3.2. We give below the outcome of the extractPaths function on the variable $ j and its return expression in Q prefix indicates the rules that were applied.
In this section, we present the function projectPaths . Recall that for each variable $ v , this function projects out the useless parts of exp b ( $ v ) (the bound expression for $ v ) based on the sets of paths P and P # extracted from exp r ( $ v ) (the return expression for $ v ). projectPaths takes as input a set of used paths , a set of returned paths and an XQuery expression, and returns a new, simplified XQuery expression. The output expression is obtained by pro ject-ing out any subexpression producing an intermediary result that is not in the scope of these paths. For each extracted path p and the given expression e , projectPaths determines if a matching is pos-sible between p and the expected result of e (i.e., if we can expect a non empty result for the evaluation of p on the result of e ).
Next, we detail the inference rules for projectPaths . Literal, comparison, quantifier. When matching a set of paths with a literal value, the only cases that yield a non empty res ult are when there is at least one path p such that p = text () (a final step of a projection path ) or p = $ v (rule pp 1). Otherwise (rule pp 2), the output expression is empty.

We use the same reasoning when the input query is a comparison ( e 1 Op e 2 ) or a quantifier expression ( some $ v in e 1 satisfies e as the result of their evaluation is necessarily a numeric or boolean value. The corresponding rules ( pp 3 to pp 6) are similar to pp 1 and pp 2. They are detailed in [11]. Sequence. Matching an input path p with a sequence ( e 1 amounts to matching p with the subexpressions ( e 2 and e posing the sequence. Then, the output expression is a sequen ce composed of the obtained elementary results (rule pp 7). Variable reference. The evaluation of paths on a variable $ v amounts to their evaluation on the objects to which $ v is bound. Then, if a matching is possible between at least an input path p and one of the objects bound to $ v , the output expression is $ v itself (rule pp 8). Otherwise (rule pp 9), the output expression is empty. XPath expression. Here, the input expression e is an XPath s . . . / s n . Matching an input path p with e depends on the nature of p and on the expected result of e . The necessary information on this expected result can be deduced from the last step s n pp 10).

More precisely, if s n = text () , the result of e will be composed of literal values. So, the only case where a matching is possi ble is when p = text () or p = $ v .

If s n 6 = text () and s n 6 =  X  , hence the nodes returned by e = s / s n are element nodes, it is sufficient to have one input path in P  X  P # that starts with $ v ,  X  (which corresponds to any element test) or s n (i.e., the first step of p matches with the elements returned by e ). Since we do not have enough information about the eventual descendants of s n , we only check if a matching is possible between e and the first step of p .

If s n =  X  , hence the label of the returned element nodes is un-known, the only case where a matching is not possible is when p = text () .

Otherwise (rule pp 11), no matching is possible and the output expression is empty. head(p) is a function that retrieves from a path p its first step. FLWR expression. According to the XQuery semantics, the result of a FLWR expression is computed by its return subexpression. So, matching an input path p with a FLWR expression e amounts to matching p with the return subexpression of e ( e 3 in pp 12). If, for at least one path p  X  P  X  P # , the result expression e  X  the composed output is a new FLWR expression obtained by sub-stituting the initial return expression by e  X  3 (rule pp 12). Otherwise (rule pp 13), the output expression is empty. For space reason, we do not detail the rules for let expressions ( pp 14 and pp 15). These rules are similar to those given here, and can be found in [11] . Conditional. Matching an input path p with a conditional expres-sion ( i f ( e 1 ) then e 2 else e 3 ) amounts to matching p with the subex-pressions of the true and f alse branches. The output expression is then a new conditional expression obtained by substituting in the input expression the initial true and f alse branches by the two po-tentially simplified subexpressions (see rule pp 16).
 Element construction. Here, the input expression is an element construction expression expr = element { QName }{ e } . Matching the input path p with expr depends on the nature of p , as described in the following case analysis. In order to simplify the presen tation, we assume that the application of the rules is attempted acco rding to the order in which they are presented below: Rule pp 17: if the input set P # contains a path p such as p = $ v or p = QName , then a matching is possible between expr and at least one returned path . In this case, nothing can be projected out and the returned expression is identical to the input one.
 Rule pp 18: if there is no input path p = s 1 / . . . with the first step s = $ v or s 1 = QName , then no matching is possible between expr and the input paths. In this case, the output expression is em pty (i.e., the input expression is projected out).
 Rule pp 19: if for all the input paths p = s 1 / s 2 / . . . with a first step s = $ v or s 1 = QName , there is no matching possible between their remaining suffixes s 2 / . . . and the subexpression e , then no matching is possible between expr and the input paths as well. The output expression is empty in this case.
 Rule pp 20: if there is at least one used path p such that p = $ v or p = QName , and no other input path has a first step equal to $ v or QName , then we deduce that the descendent nodes of the expected element QName are useless. In this case, the subexpression e is projected out and the output expression is a new element cons truc-tion QName with an empty content.
 Rule pp 21: if there is at least one input path p = s 1 / s a first step s 1 = $ v or s 1 = QName , and a matching is possible between the remaining part s 2 / . . . of p and the subexpression e , then we deduce that a matching is possible with expr . In this case the output is a new element construction expression for QName with a new subexpression e  X  obtained by the recursive application of projectPaths for these s 2 / . . . path suffixes over e . Empty sequence. If the input expression is empty, then the output expression is also empty.

The pruning process is applied recursively by the Prune func-tion, using extractPaths and projectPaths in bottom-up manner. This function takes as input a query Q and returns a new, simplified query Q  X  . It is defined by the following inference rules. Literal, variable reference, XPath expression and empty se -quence. When the input expression Q is a literal, a variable ref-erence, an XPath expression or an empty sequence, the prunin g has no effect and the output expression is the same as the input on e. Sequence, comparison, element construction. The pruning of a sequence of subexpressions returns as a result the sequenc e of the pruned subexpressions (rule p 5). We use the same approach to prune comparison expressions and element construction e xpres-sions (rules p 6 and p 7).
 Conditional. In this case, the pruning operation is propagated to the condition subexpression, and to the true and f alse branches. The output expression is obtained by substituting the subex pres-sions by their corresponding pruned results.
 FLWR expressions, quantifier. When the input Q is a FLWR ex-pression ( f or $ v in e 1 return e 2 ), the pruning operation is first ap-plied on the bound expression e 1 (with result e  X  1 ). Then, the variable $ v is added to the environment Env with its bound objects com-puted by varRes . The saturate function refines the bindings stored in the environment (as described in Section 2).
 Then, the pruning step is applied on the return subexpressio n e The result is a pruned expression e  X  2 , from which the extractPaths function extracts the paths relative to $ v . Finally, the extracted paths ( P  X  X  $ v } , P # ) are applied on e  X  1 in order to eliminate its useless parts. Here, $ v is added as a used path to ensure that the number of iterations remains the same. The resulting expres sions e and e  X  2 replace e 1 and e 2 in the FLWR expression.

The pruning of a f or expression can lead to the following inter-esting special cases ( p 10 and p 11): Here, the pruning of the bound expression generates an empty re-sult, which means that the number of iterations is equal to 0. So, the pruning result of the entire FLWR expression is empty. This case corresponds to the situation in which the pruning o f the return expression e 2 leads to the empty result. This means that whatever the number of iterations is, the result is always em pty. In such a case, the pruning of the entire f or expression gives an empty result.

When the input f or expression contains a where clause, we fol-low the same reasoning and handle the where clause in the same way we handled the return subexpression (rules p 12 to p 14).
When the f or expression contains a where clause, an additional rule is used each time the pruning of the where gives an empty re-sult (rule p15). In this case, the condition is obviously f alse (empty sequence) and the pruning of the whole f or expression yields an empty result.
The pruning process of let expressions is similar to the pruning of f or expressions (see rules p 16 to p 20). The only notable dif-ference is that we do not have to add the path $ v to the set of used paths P .

For quantifier expressions, we use the same reasoning, with t he notable difference that, in the special cases, instead of re turning an empty result, we return f alse () (since a quantifier returns a boolean value).

We prove that the rule-based algorithm is correct, showing t hat its input and output queries are equivalent (i.e., the evaluation of the output query yields the same result as the evaluation of t he ini-tial query). More precisely, we prove that the algorithm Prune de-scribed in Section 3.3 verifies the following.
 T HEOREM 3.1. [Equivalence] Let q be an XQuery query, let I = { d 1 , . . ., d k } be the set of XML documents used in q, let Env be the environment, and let q  X  be the XQuery query obtained from the pruning of q in Env (i.e., Env  X  Prune ( q )  X  q  X  ). Then, the results of q and q  X  over I are equal: q ( I ) = q  X  ( I ) , where "=" denotes the deep equality defined for XML values in [14].

P ROOF S KETCH . A proof for this theorem can be constructed by induction on the inference rule for each expression. Due t o space limitations, we were not able to include all the details of th e proof in this paper. The detailed proof (including the proof of the two lemmas presented below), can be found in the extended versio n of this work [11].

As it was shown in Section 3.3, when the input query q is a literal value, a variable name, an XPath expression or an empty seque nce (rules p 1 to p 4), the pruning process will produce an output query q identical to its input q .

When the input query q is a conditional expression, a non empty sequence, a comparison expression, an arithmetic or a logic al ex-pression (pruning rules p 5 to p 8), the pruning process is simply applied recursively to the subexpressions of q , replacing them by the obtained pruned expressions.

Assuming that the pruned subexpressions are equivalent to t he initial ones, then according to the semantics of XQuery[7] t he out-put query q  X  is equivalent to q .

For instance, considering a conditional expression the pruning process yields where Env  X  Prune ( e 1 )  X  e  X  1 , Env  X  Prune ( e 2 )  X  e Prune ( e 3 )  X  e  X  3 . Assuming that e 1 is equivalent to e sions q and q  X  are equivalent as well.

FLWR expressions. When the input query q is a FLWR expres-sion (pruning rules p 9 to p 20 in Section 3.3), the pruning process can be summarized in three main steps : (1) the pruning is appl ied recursively to the subexpressions of q , substituting them by the ob-to extract from the return and where subexpressions ( e  X  used and return paths ( P and P # ), and (3) projectPaths is called to apply the extracted paths on the bound subexpression ( e  X  to simplify it.

We argue that the first step preserves the equivalence: assum ing that e 1 is equivalent to e  X  1 , e 2 is equivalent to e  X  lent to e  X  3 , then f or $ v in e 1 [ where e 2 ] return e let $ v : = e 1 [ where e 2 ] return e 3 and let $ v : = e return e  X  3 ).

To prove equivalence between the input query q and the output one q  X  , we need the following result: the projected subexpression e , obtained by applying the used and return paths on the bound subexpression e  X  1 , generates all the nodes necessary in the evalua-tion of e  X  2 and e  X  3 (this is similar to the Return Paths Lemma of [16]). More precisely, we need to prove the following two propertie s.
L EMMA 3.1. [Paths Extraction] Let e be an XQuery expression and $ v be a variable. The sets of paths P and P # extracted from e (Env  X  extractPaths ( $ v , e )  X  P , P # ) satisfy the following:
L EMMA 3.2. [Paths Projection] Let e 1 be an XQuery expres-sion, let P be a set of used paths and P # a set of return paths . The XQuery expression e 2 , obtained by the application of P and # paths on e 1 (Env  X  ProjectPaths ( P , P # , e 1 )  X  e 2 following properties: where the root function retrieves the root nodes of its input XML data, and the eval function is defined as follows: D EFINITION 3.1 ( EVAL ). For an XQuery expression q and an XPath expression p, eval ( p , q ) denotes the following XQuery ex-pression:
Lemmas 3.1 and 3.2 presented above can be proven by induction over each expression. The details can be found in [11].
We discuss in this section extensions on the algorithm prese nted previously, which may further simplify an XQuery expressio n.
Path refinements. Let us illustrate a first improvement by an example. Let q be the following XQuery expression : By applying the pruning rule on q , no simplifications would apply and the query remains unchanged. However, one can easily not ice that the C elements constructed by the inner f or are not necessary for the end result and can thus be projected out.

This kind of pruning is not possible using the bottom-up infe r-ence rules of Section 3.3. This is mainly due to the fact that w hen we prune some inner subexpression, we have no information ab out the outer subexpressions, potentially missing such furthe r refine-ments. For instance, in the query q , when we prune the inner f or subexpression, the projection path $ i suggests to keep all the bound expression of $ i (by rule pp 1). Then, when we apply the path $ j / B on the inner f or , we apply it in fact only on the variable $ i (by rule pp 12), and we conclude that we must keep the variable $ i (by rule pp 8). In this way, we fail to refine the path $ i to $ i / b and to detect that only B elements, children of A s, are needed from $ i  X  X  content.
In order to detect this kind of pruning opportunity, we have t o use information of the entire query during the pruning proce ss.
We are currently extending our algorithm to take into accoun t such simplification opportunities, using a two-step prunin g. In the first step, we apply the pruning as described previously, sta rting with empty sets of used and returned paths for each variable. In addition, when we have situations in which we apply a path p on a variable reference $ v or on a path p  X  starting by a variable name $ v , we keep in a separate structure a mapping from the variable to the projection path that is applied, i.e. ( $ v  X  p ) or ( $ v  X  p with its kind (used or returned). Then, these mappings are us ed to initialize the sets P and P # for a second pruning pass.
Going back to the example, in the first step, q remains unchanged but we extract a mapping $ i  X  X  $ i / B } (as returned path). In the second step, when pruning the inner f or , having this path enables us to prune the C elements as well.
 Elimination of useless XPath expressions. Notice that the query Q 1 . 3 presented in Section 1 contains a path, $ j / open _ auction , whose evaluation is not necessary for the end result. This is becau se it always returns the empty sequence () . Our second improvement addresses this issue, eliminating irrelevant navigation b y directly substituting such paths by the empty sequence () .

The simplified query Q  X  X  1 . 3 would now be the following: Intuitively, we can find these paths during the projectPaths pro-cess, when applying paths over expressions. In the same way w e retrieve the expressions parts that do match some path, we ca n also retrieve the paths that do not match anything in these expres sions. For space reasons, the modified projectPaths rules that take into account such cases are presented in the extended version of t his paper. Further details are omitted.
We implemented our algorithm for XQuery projection as a sepa -rate module on top of the Galax query processor [9] (version 0 .7.2). Our choice was motivated by the robustness of this processor and its conformance with the W3C XQuery specifications.

We describe in this section the impact of our approach, measu r-ing the gain in evaluation time obtained by eliminating the c ompu-tation of irrelevant intermediate results. In our experime nts, we var-ied the nature and complexity of the pruned subexpressions. More precisely, we considered three kinds of subexpressions wid ely used in practice : FLWR blocks, XPath expressions relative to a gi ven document or XPath expressions relative to a variable. For ea ch kind of subexpression, we varied the amount of intermediate resu lts pro-duced by the pruned subexpression: 25%, 50%, 75% or 100% of the total intermediate results. We used in our experiments t he fol-lowing template for test queries: where the question mark indicates optional parts that could be miss-ing from one test query to another. By the first let clause in the template we create a set of intermediate results. The let binds the variable $ q to a personInf element that contains four child ele-ments name , age , gender and email . The four elements have the same content, produced by a test _ exp expression (to be defined for each test query).

The number of children nodes of personInf depends on the size of the sequence to which the variable $ i is bound ( person elements) and varies with the size of the document on which the test is pe r-formed. The percentage of useless intermediate results is s imply tuned by deciding which XPath expressions appear in the quer y, among the four expressions given in the return of the outer f or clause. For example, when testing the gain for 100% of irrele vant intermediate results, we can use the path $ j / names , because it does not follow any child element of the personInf element. When test-ing the gain for 50% of irrelevant intermediate results, we c an use two paths, such as $ j / age and $ j / gender .

Finally, the kind of expression that is pruned along with its wrap-ping element was also varied ( test _ exp ).

We show in Figures 3, 4, and 5 the improvements when test _ exp is a FLWR block, an XPath expression relative to a variable or an XPath expressions relative to a document. The measures were con-ducted on a Pentium 3.2 GHz Linux PC with 2Gb of RAM.

Results &amp; Discussion. The experiments show that our approach ensures a gain of time whatever is the nature of the pruned sub ex-pressions. The gain varies according to the amount of pruned inter-mediate results and the complexity of the irrelevant subexp ression. In Figure 3, where the pruned subexpressions correspond to F L-WR blocks, the savings in evaluation time are determined by t he amount of pruned intermediate results. These savings incre ase sligh-tly when the document size increases. They increase signific antly when the pruned subexpressions correspond to XPath express ions relative to a document (Figure 4). We believe that this is mai nly due to the specificity of the XQuery processor we used. In Figure 5 , the pruned subexpressions correspond to XPath expressions rel ative to a variable. In this case, we measured savings of time less imp ortant than in the two previous cases. It seems that in this kind of sc enar-ios we save only the time needed to retrieve the element retur ned by the path, which is normally done in main memory.

Figure 4: Test results for queries pruning variable XPaths
We present in this paper a rewriting algorithm for XQuery que ries which detects and prunes the computations that are irreleva nt for
Figure 5: Test results for queries pruning document XPaths the overall result. For each input query, our algorithm outp uts an equivalent, simplified query. We show by extensive experime nts important savings in evaluation time, and we prove formally the correctness of our algorithm. An important direction for fu ture re-search is to extend the algorithm by taking into account sche ma information.
