 1. Introduction query interfaces.

With the explosively increasing amount of domain-specific WDBs, it is unrealistic to expect users to explore each WDB domain-specific WDBs; 3) matching schemas across a set of query interfaces of the domain-specific WDBs; 4) constructing an the unified query interface to that of other individual query interfaces of the domain-specific WDBs; and 6) cleaning and integrating the query results from the domain-specific WDBs and then returning the integrated results to the user. is one of the most fundamental and crucial components in the DWDIS. Typically, the organization of attributes within a query interfaces [3,11,22,23,36,39,41,48] .
 here due to space limitation. A comprehensive treatment of the subject can be found in [41] .
Although schema matching across a set of query interfaces on the domain-specific WDBs is a well-studied prob-interface modeling proposed in [11,22,23,41] cannot reflect the rich structural constraint information, e.g., parent integrating methods sets up a problem evaluation model which can measure the quality of the integration, or analyze the time complexity.
To overcome the defects of the existing integration methods, a deep and systematic study on integrating query interfaces has main work of the paper is summarized as follows: 4) The problem evaluation model is proposed, which can measure the integration quality and the time complexity. the model of transforming the integration of query interfaces in domain-specific WDBs into a multi-objective optimization the simulation results. Section 6 makes the comparisons with existing algorithms. The conclusions are made in Section 7 . 2. The schema tree and the attribute constraint matrix of a query interface on the Deep Web query interfaces.
 correspondence between a unique attribute constraint matrix and each query interface has been revealed and proved, which can accurately describe various structural constraints and the strengths between attributes of the query interfaces. 2.1. The schema tree and various structural constrains between attributes of a query interface input boxes labeled ( a )and( b ), eight selection lists labeled ( c ) ordered tree is called the schema tree (or schema) of the query interface and can be defined as follows:
De fi nition 1. [Query interface schema tree]
Given a query interface, its schema tree T is a hierarchically ordered tree of elements, in which each leaf element (node) sequence of their appearance in the query interface.
 tree T represent the attributes in the query interface (labeled a , b , c ,
By investigating and analyzing its schema tree of a domain-specific query interface, the following three types of structural constraint between two attributes x and y , and x appears before y in T from left to right, it will be denoted as x
T . For example, for the schema tree in Fig. 1 (b), the attributes satisfy the precedence constraint: a
It is clear that each attribute's position (or attribute's structure) in its schema tree is mainly dominated by hierarchical tree, there exits the following priority relation on the above three types of constraints shown in Eq. (1): where the notation A&gt;B means that A has the higher priority than B . 2.2. The attribute constraint matrix of a schema tree and its properties tree T , are first given.

De fi nition 2. [Distance between two attributes in a schema tree] depth ( i ). Note that depth ( root ) of root is defined as 0.

De fi nition 3. [Attribute constraint matrix M of a schema tree] if and only if its element in row i and column j is defined by the results of the schema extraction of a query interface.
 Here is an example. The matrix shown in Fig. 2 (b) is the constraint matrix M of the schema tree T shown in Fig. 2 (a). Based on Definition 3 , the following Lemma can be easily obtained.
 describes the hierarchical constraints between a leaf node and root in the schema T , while the sequence of row (or column) constraint) if and only if dis ( i , j )=2. be described by the following theorem.

Theorem. There is a one-to-one correspondence between the constraint matrix M and the schema tree T of a query interface, versa.

Proof. a) Is the temporary matrix M a one-order (1 X 1) matrix? If not, go to b); else, go to g); b) Find all the maximum elements which must be greater than or equal to 2 on the diagonal of the matrix. These elements e) Remove all the rows and columns in each cluster of G from matrix M which are substituted by the parent node with its f) Go to a); g) End.
 completed.
 generate the schema tree T from a given constraint matrix M . Note that the algorithm MatrixToTree employs a bottom-up approach to build its corresponding schema tree T based on a given constraint matrix M . The pseudo code of the algorithm new temporary matrix M , is shown in Fig. 3 .
 constraint and should be in a cluster. A new node n 1 is created as the parent node of the nodes b and c , and the node n temporary constraint matrix M  X  shown in Fig. 4 (b) ( New ={ n
Then, in the second iteration of the algorithm MatrixToTree , the deepest nodes a and n and clustered. With the above steps of the algorithm MatrixToTree ( New ={ n and its constraint matrix M  X  X  are generated and shown in Fig. 5 .

Finally, the remaining nodes n 2 and d in the temporary constraint matrix M form the final schema tree T , which is the same as the tree shown in Fig. 2 (a). 3. Multi-objective optimization model for query interfaces integration 3.1. Merging constraint matrices
According to Definitions 1 and 2 , Lemma and Theorem in Section 2 , it can be observed that: 1) Each query interface can be modeled by a schema tree; 2) each schema tree of a query interface can be represented by an only corresponding constraint merging the constraint matrices of query interfaces.
 domain-specific query interfaces are defined as follows:
De fi nition 4. [Extended constraint matrices]
Suppose that there are n query interfaces' constraint matrices M attributes a 1 , a 2 , ... , and a m . For any given sequence a m -order symmetric matrix, where the rows or columns in M by
Obviously, M k  X  can be obtained by making the same permutation on both rows and columns of M zero columns to M k such that the sequence of rows (columns) of M precedence constraint for M k is usually not satisfied for M to obtain a proper precedence constraint after merging the constraint matrices, the following definition is introduced.
De fi nition 5. [Score vector of attribute sequences for schema trees] any given sequence a 1 , a 2 , ... , a m of these m attributes, suppose the schema tree T sequence in T k is denoted as Attri k .Thenfor T k , define a vector Vec sequence a 1 , a 2 , ... , a m , as follows: where pos ( a i ) is the position number of a i from left to right in sequence Attri reason for this Definition 5 is explained in Definition 7 .

For example, there are three query interfaces which have totally 6 different attributes ( m= 6). For a given sequence a of these 6 attributes, suppose the second schema tree T 2
T and then the index number of a 1 from left in sequence Attri get v 2 =1/3, v 5 =3/3=1, and the other v i =0. Thus, Vec
Obviously, 1  X  pos ( a i )  X  m  X  and 0  X  v i  X  1. The smaller the value v sequence of T k except for v i =0. 3.2. Multi-objective optimization model for integrating query interfaces fixed value Dis , then it is very possible that the distance between i and j should also be close to Dis after integration.
Although there are enormous domain-specific query interfaces in the Web, few hierarchical structures of the query interfaces [3,4,30] . Also, it should be noted that the sequences and group constraints of most attributes in most query interfaces are relatively reasonable because each query interface must be specifically designed. Therefore, the average distance between sequence position can be used as an ideal sequence position of any attribute.
 For a precise description, we introduce the following definitions of the average constraint matrix and average score vector.
De fi nition 6. [The average constraint matrix/score vector]
For given n order m extended constraint matrices M  X  1 , M defined as m -dimensional score vectors Vec 1 , Vec 2 , ... , and Vec
De fi nition 7. [Merging operation of the constraint matrices/vectors]
Given n order m extended constraint matrices M  X  1 , M  X  2 these matrices, see more details in Definition 4 ), a merging operation between M computation on them resulting in an m-order matrix, where the resultant matrix should satisfy the two types of constraints, hierarchical constraints and group constraints, of M  X  i and M of constraints of all M  X  1 , M  X  2 , ... ,and M  X  n as much as possible. Similarly, we can define the merging operation Vec ... , and Vec n. as much as possible.

According to Definition 6 and the above analysis, it can be seen that the average constraint matrix avgM can be seen as an should be as close to avgM and avgVec as possible, respectively. 2) M is generated by merging operation on M
Vec is generated by merging operation on Vec 1  X  Vec 2  X  , minimized, and the error between Vec and avgVec is also minimized; 2) M = M  X 
Vec n ;3) M should satisfy the hierarchical constraint and group constrains, denoted by M follows:
Thus, we can set up a multi-objective optimization problem model for the query interfaces integration problem as follows:
From above Eqs. (5) and (6) , we can see that the first objective f possible.
Note that when we look for an ideal integrated interface which minimized the first objective and satisfied the hierarchical nodes a and b satisfy the precedence constraint such as a conveniently and obtain an approximate solution to it, in this paper, we construct a new algorithm to find the approximate optimal solution to model (7). 4. Multi-objective optimization integration algorithm of query interfaces based on the attribute constraints space can be reduced, that is, the operations (computations) on M operations (computations) on avgM / avgVec .
 designed to get such an approximate optimal solution. To optimize the second objective, algorithms SeqVal and ListSort are designed to get the approximate optimal solution. 4.1. Algorithm GetUni fi edConstraintMatrix objective function f 1 is closely related to hierarchical constraints and group constraints, and to optimize the objective f the group constraint as much as possible, i.e., it should be also an integer which is closest to avgM [ i,j ]( i GetUnifiedConstraintMatrix for obtaining such an approximately optimal M is developed which is shown in Fig. 6 .
BOUND h can be taken as 0.5. If the decimal value of the avgM [ i,i ] is greater than the BOUND those of avgM , but also satisfy the hierarchical constraint.
 and the distance between attributes in one group from the same level Depth ( Depth the noise having been removed.

To efficiently get the non-diagonal elements of M , we can set a proper upper bound, denoted by BOUND or threshold BOUND g =60% X 2+30% X 3+10% X 4=2.5.
 for each i  X  SET , find all possible elements j in the SET such that avgM[i,j] put into the same subset (in the same group). Denote all these subsets as g does not belong to any subset), its parent node is redundant and can be removed, i.e., let M[i,i]=M[i,i] minus 1 and repeat the above process until Depth= 1.

The experiments show that aforementioned two threshold values, the BOUND be seen in Subsection 4.4.

Note that function RoundGroupElements employs a bottom-up approach to determine the every element's value in M based on the query interfaces can be obtained by invoking the algorithm MatrixToTree . 4.2. Attributes' sort algorithms SeqVal and ListSort
Since the initial unified scheme tree T  X  above does not contain any information on the precedence constraints of the tree nodes, it is necessary to sort the nodes to optimize the objective function f n is a leaf node, Seq [ n d ]= avgVec [ n d ]; if n d is an internal node, Seq [ n evaluation values, respectively, as follows. 4.3. Analysis for time complexity the constructing processes of the unified schema tree T are as follows: 1) constructing the constraint matrices/vectors M matrix M by the algorithm GetUnifiedConstraintMatrix ; 4) transforming M into initial unified schema tree T MatrixToTree ; and 5) achieving the final unified schema tree T by the algorithms SeqVal and ListSort . some more complex algorithm.

The main operations in algorithms GetUnifiedConstraintMatrix / MatrixToTree consist of dividing the nodes in the matrix into
O ( k 2 ), and the time complexity for updating a matrix with k nodes is O ( k times, so the time complexity of the two algorithms are O (1 array of size mO ( mlogm ), so the time complexity of algorithm ListSort is O ( m
Therefore, the time complexity of the integration algorithms (i.e., the overall time complexity of the above five processes) proposed in this paper is 2[ O ( nm 2 )+ O ( nm )]+2 O ( m is 18, and the average one is 6 across all domain-specific query interfaces of WDBs, which means that the value range of the n and m are in the same order of magnitude, the time complexity of the algorithm is O ( m 4.4. Case study In order to clearly explain the proposed multi-objective optimization integration algorithm of query interfaces for the Deep Web based on attribute constraints, we use the following example to demonstrate the procedure of the proposed algorithm.
Fig. 10 shows the four schema trees to be integrated and its corresponding constraint matrices. Here, in the trees, the leaf no leaf nodes in the corresponding schema tree.
 According to Definition 6 , the calculated avgM and avgVec are shown in Fig. 11 , respectively.
The algorithm GetUnifiedConstraintMatrix for finding M based on avgM is the key to integration algorithm presented in this paper. Fig. 12 shows its four key steps, where the operation in each step is especially marked with a rectangle.
The key components of algorithm GetUnifiedConstraintMatrix for finding M based on avgM are functions RoundDiagElements and RoundGroupElements , which consist of four key steps. We now describe them for the example as shown in Fig. 12 . the threshold ROUND h ( ROUND h =0.5). The result is shown in Fig. 12 (a).

Step 2: invoking function RoundGroupElements and execute its steps 2 largest disjointed group elements (attributes) in M based on the threshold ROUND group above.

Step 3: execute steps 6  X  10 of function RoundGroupElements with the objective of removing a redundant parent node of a leaf does not belong to any one group as the only child of its parent node, then there comes the fact that there is a redundant Depth -1 (shown in Fig. 12 (c)).

Step 4: execute steps 11  X  17 of function RoundGroupElements to obtain M [ i,j ]( i between them must be an even number between 4 and 2 Depth , such as the distance between leaf nodes a and c being 4, that between a and e being 6 (2 Depth= 2 X 3=6) shown in Fig. 13 (b), and that between a and f being 6 ( elements a and g shown in Fig. 13 (c), their distance is 5 ( Depth +1=4+1=5). Based on the above facts and the execution of steps 11  X  17, M can be obtained by reasonably revising the element values of avg M [ i,j ]( i query interfaces' schema trees T 1  X  T 4 , is shown in Fig. 15 after undergoing two iterations (shown in Fig. 14 ).
InFig. 14 , thefirstiteration isthe operationsofalgorithm MatrixToTree toget temporary constraintmatrixes M constraint matrix M  X  corresponding to an initial unified schema tree T schema tree T . Besides, the nodes n 1 , n 2 ,and n 3 are all internal nodes corresponding to the integrated schema tree T . 4.5. Detecting and fi ltering out noises constraint matrix avgM and average score vector avgVec will be generated. Therefore, when evaluating the average constraint
For a value set ( x 1 , x 2 , x 3 , ... , x n ),its sample mean is x ,anditssampleresidualis e then ( x 1 , x 2 , x 3 , ... ,x n ) will obey a normal distribution whose mean is x ,and( e ( e is no bad value.
 goes to the next iteration. The process can be represented by an algorithm avgRNoise and is shown in Fig. 16 .
The TEST procedure used in avgRNoise is the hypothesis test, and its specific process is a
H 0 :  X  2  X   X  0 2 , H 1 :  X  2 &gt;  X  0 2 . The rejection region of the test is
When H 0 is accepted, TEST procedure returns to  X  true  X  , otherwise, returns to 5. Experiments and analysis 5.1. Dataset dissimilar and unrelated domains, i.e., airfares domain and books, are selected randomly on each domain for the experiments.
Then, in total, 324 query interfaces from aforementioned five domains are selected for the experiments. 5.2. Experimental results
Our query interfaces integrating method is based on the fact that the attributes and the three types of constraints among the method [6].

For simplicity, the schema tree of a query interface is denoted as a list structure defined in Section 4.2. The experimental domain (in which the structure of attributes is relatively simple) are shown in the following tables in detail.
Twelve query interfaces from the airfares domain and books domain are selected randomly. The label names of attributes (or attribute names) are displayed in Tables 1 and 3 . The schema trees' structures are displayed in Tables 2 and 4 . in Figs. 17 and 18 , respectively, where asterisks represent unnamed internal nodes. 5.3. Discussion on experimental results comparison in other ways in algorithms make no sense. In order to make a clear and exact description, we begin with some definitions, followed by a comparison and an explanation of the proposed performance measures.
De fi nition 8. Ordered attributes pair
For any two different attributes i and j in a query interface, query interface by U . Based on these notations, the definition of constraint satisfaction rates can be defined as follows.
De fi nition 9. Constraint satisfaction rate and | U |/| S | is called the satisfaction rate of the hierarchical constraint.
 The results of the three satisfaction rates in the two domains are shown in Tables 5 and 6 , respectively.
After calculations, we get f 1 =0.581343591548 and f 2 =0.1102491 in the airfares domain, while f f =0.1316919 in the books domain by using the proposed integrating algorithm.
 the actual situation.
 algorithm. The average constraint satisfaction rates of the integrated query interface are shown in Fig. 19 . 6. Analysis and comparison with the related work
There is some literature discussing the problem of domain-specific query interfaces integrating [7,11,12,22 focus on the comparison of our work and the closely related works.
 views query interfaces as a visual language, and therefore uses a number of manually pre-defined grammar rules to extract semantically related labels and elements, and then integrates them. However, in the MeterQuerier, the rich semantic/meta integration query interfaces.
 Extensive evaluation of real-world query interfaces data sets showed the effectiveness of their method.
As an optimization problem and holistic integration of domain-specific query interfaces, several aspects of the difference between our work and the work in Wu et al. [7] are discussed as follows. 6.1. Attribute constraint constraint. Moreover, the formal definitions of these two constraints were given. However, the main difference between the constraint, is explicitly introduced in the proposed model. Second, a novel metric called the constraint matrix which can unified schema trees is proposed, which can evaluate its precedence constraint. Fourth, the proposed optimization model is a multi-objective model based on the constraint matrix and a new algorithm is proposed for this model. 6.2. Search space and integration strategy Wu et al. [7] thought the query interface integration as an optimization problem, but they did not give an explicit model. [12] adopted clustering aggregation to integrate query interfaces, in which the search space to be explored is O( nm only use the simple operations on the constraint matrix and the search space to be explored is O( m numbers of query interfaces and their corresponding attributes, respectively. For a large number n of the query interfaces, the proposed algorithm is more efficient.
 6.3. Performance of the integration algorithm algorithm. Therefore, it is not complete and not enough to use PerSC as the performance measure. To measure the performance Their average PreSC score ranges from 75.3%  X  91.2% in structural constraints from five domain query interfaces data sets. is 84.5% with the lower optimization objective values. 7. Conclusion and future work interface. Then we transform the problem of integrating domain-specific query interfaces into a multi-objective optimization of query interfaces.

The future work will be to improve the integration algorithm so as to further decrease its time complexity, and efficiently tackle the problem of reasonable internal nodes naming by using 1 :m/m: 1 and m:n schema matching results. Acknowledgement
This work was supported by the National Natural Science Foundation of China (61272119) and Ph.D. Programs Foundation of the Ministry of Education of China (20090203110005).

References
