 1. Introduction In recent years, Recommender Systems (RS) ( Adomavicius &amp; Tuzhilin, 2005; Li, Myaeng, &amp; Kim, 2007; O X  X ahony, &amp;
Smyth, 2010; Yung-Ming, Tzu-Fong, &amp; Cheng-Yang, 2012 ) have played an important role in reducing the negative impact that when enough information is stored on the system we can make recommendations to each user based on information provided by those users we consider to have the most in common with him.

A key factor in the quality of the recommendations obtained in a CF based RS lies in its capacity to determine which users CF core of this type of RS.
 &amp; Gu, 2006 ), Web ( Pazzani &amp; Billsus, 2007 ).  X 
With the aim of presenting the work carried out to date in a structured way, together with the approach proposed in this ilarity metric, establishing the neighborhood, prediction phase, determination of recommended items.
The white boxes represent processes carried out over one user and the black boxes represent processes carried out over a group of users. The bigest black boxes show key information: they indicate the CF process phase where the unification is performed:  X  X  n users ? 1 group X  X .

The graph shows the four representative cases of tackling the solution to recommendation by groups. In the case (a), the recommendations obtained for each individual user of the group are merged into one recommendation for the group. Baltr-unas, Makcinskas, and Ricci (2010) use rank aggregation of individual lists of recommendations.

In the case (b), the data unification is performed in the prediction phase of the CF process: n individual predictions of n users of the group are combined in one prediction of the group (predictions aggregation). This approach has been used by Berkovsky and Freyne (2010), Garc X a, Sebastia, and Onaindia (2011) and Christensen and Schiaffino (2011) .
In the case (c), the set of neighbors of the group of users are obtained by unifying the sets of neighbors of the individual number ( k ) of neighbors of each user of the group.

The case (d) shows the approach proposed in this paper: design of a similarity metric that acts directly on the set of votes of the group X  X  users. This solution is the only one that directly provides a set of neighbors for the group of users.
The rest of the paper is structured as follows: Section 2 describes the proposed groups similarity method; Section 3 ex-plains the executed experiments and it reports the evaluation results; and Section 4 summarizes this work. 2. Method
Let U denote the set of users and let I denote the set of items of a CF RS. We define V  X f the set of possible ratings that a user can make (no rating is represented by ) and we indicated r The main objective of the proposed method is to recommend a series of items to a group G of users ( G U ) of random size.
The recommendations for the group will be obtained by following the traditional CF philosophy. As we can see in the case (d) of Fig. 1 , a similarity metric will be processed between the group of users and the rest of the users of the RS, and common group recommendations will be obtained as in traditional CF.
 First of all we define a users group similarity metric (UGSM) that aims to quantify the similarity between any user u of the RS and the set of users belonging to group G .
 capable of proposing new items that the majority of the users belonging to group G will like.
 The next step in the CF process is to determine the set of k neighbors of group G , which we will indicate by K for those users who have a higher similarity with the group. Formally:
We can now calculate the predictions to the items not rated by any members of the group: we find the rating average of the k neighbors on these items. Formally, we calculate the prediction on an item i for group G using the weighted average aggregation approach:
The items recommended to the group will be those that have not been rated by any of the group X  X  users and which have received a higher prediction. We define X G as the set of items subject to being recommended to group G , and Z items recommended to group G . The following expressions must be verified: 3. Experiments
In this section we will design the necessary experiments to test the state of the art recommendation to groups strategies, as well as the proposed one. We will test the quality of the recommendations and the necessary processing time to get them. The obtained results show a better relation  X  X  X rocessing time/recommendations quality X  X  when the proposed method is used.
All experiments shown in this section have been implemented using the RecSys API ( http://www.lpsi.eui.upm.es/~forte-ga/recsys_api/ ). 3.1. Description
With the objective of checking the operation of the proposed CF RS for groups of users, we will use the following quality ity of the recommendations. Our experiments will be carried out using the MovieLens and Netflix databases. The main infor-mation about the data of these databases is shown in Table 1 .

In the experiments, the groups of users are generated randomly based on the users of the database. We also establish sets the experiments, as well as the figures and graphs containing the results. Fig. 2 shows the experiments that will be carried out.

The main experiment (experiment 2) compares the method presented in this paper (UGSM) with the current state of the method proposed by Baltrunas, Makcinskas, and Ricci (2010) (from now on RANK); however, method RANK is conceived so-lely to obtain recommendations and not to obtain predictions, therefore, two of the proposed quality measures, accuracy and coverage, cannot be used on it. For the second alternative we will use the method proposed by Berkovsky and Freyne (2010) (from now on PER). For the third alternative we will use the best result obtained with ERRS, Bobadilla, Ortega, Hernando, et al. (2012b) , in experiment 1.
 Before to run experiment 2, we must determine the similarity metric that achieves the best result when applied to the ERRS method. Experiment 1 tests ERRS in combination with: Pearson Correlation (COR), the main reference in the CF field; that provides a good balance between accuracy and coverage.

Finally, experiment 3 runs a system performance (time consuming) comparison. We measure the average time to provide a set of recommendations to a group of users running different group recommendation algorithms. The problem of obtaining recommendations for groups of users is computationally more costly than that of obtaining recommendations for a single user; therefore, as the size of the group increases, the calculation time required to achieve a recommendation for the group using as the rank aggregation Borda count, for the second case we will use PER, for the third case we will use ERRS, and for the fourth case we will use UGSM (the method set out in this paper). 4. Results
Fig. 3 shows the results of experiment 1. We can observe that: ERRS (JMSD) is the method that gives the best results as it obtains good accuracy results. ERRS (COR) offers significantly worse results than the other alternatives. In general, the method that provides the best average quality is ERRS (SING), and therefore, it will be the one we select as the baseline for the following experiments.

Fig. 4 , Graph (a) and Graph (b), shows the results of experiment 2a, in which we compare UGSM, PER, RANK and ERRS (SING) in MovieLens. We can observe that, as regards accuracy/coverage, the proposed method offers the best balance be-tween quality and quantity of recommendations. As regards precision/recall, the results obtained by UGSM are similar to those obtained using PER and RANK, and higher than those obtained when we use ERRS (SING).

Fig. 4 , Graph (c) and Graph (d), shows the results of experiment 2b, in which we compare UGSM, PER, RANK and ERRS (SING) in Netflix. We can observe that, as regards the accuracy/coverage, the proposed method offers lower accuracy in the predictions but much more coverage than the two reference methods. As regards the precision/recall, the proposed method is slightly worse than PER and RANK and significantly better than ERRS (SING).

Fig. 5 shows the results of experiment 3. By placing the results in order of calculation time (from fastest to slowest) we group in early stages of the CF favors the speed in obtaining recommendations. Furthermore, we can observe that the rec-ommendation obtaining time for the group increases lineally with the size of the group, which favors the scalability of the method.

We have performed t -tests which confirm that our method improve the speed in obtaining recommendations. Indeed, for each size of users group, we will compare the speed of our method with the speed of each method proposed by other authors. In our experiments, the null hypothesis considers that the speed of our method is the same than the speed of the method proposed by other authors, while our alternative hypothesis considers that the speed of our method is better than the speed of the method described by other authors. As we will see, our experiments prove that there is statistic evi-dence for rejecting this null hypothesis and accepting the alternative hypothesis. The experiments performed consist of the following steps: (1) for each group size, #G, we have randomly obtained 100 groups of #G users; (2) for each of these groups of users, we calculate the time which both our method and the methods described by other authors take to make the rec-ommendations; (3) for each method described by other authors, we perform a paired t -test comparing its speed with the and 0.01. Consequently, we can conclude that there is statistic evidence for rejecting the null hypothesis and accepting the alternative hypothesis, which means, our method improves significantly the speed of the methods presented by other authors. 5. Conclusions
In collaborative filtering based recommender systems, when we wish to make recommendations to groups of users, there group of users: (a) similarity metric, (b) establishing the neighborhood, (c) prediction phase and (d) determining recom-mended items.

Each of the four previous levels shows an aggregation approach of individual users in a group of users. The experimental results show fairly unrepresentative differences in the quality of the recommendations obtained on applying the different aggregation approaches; however, the system performance notably deteriorates as the moment the aggregation approach is applied is delayed.

The group recommendation system performance is related to the moment at which the aggregation approach is per-orative filtering algorithms as users that belong to the group. From the aggregation, the different collaborative filtering processes associated to each of the users disappear and give rise to a single collaborative filtering process for the group. laborative filtering: the system performance significantly improves and the system accuracy undergoes barely appreciable changes. In the paper we provide a similarity metric that implements this concept.

As future work we encourage the design and validation of group recommendation similarity metrics that improve the current system accuracy levels, whilst maintaining a system performance similar to that obtained by the proposed group recommendation metric.
 Acknowledgements
Our acknowledgement to the Grouplens Research Group and to the FilmAffinity.com company. The authors thankfully acknowledge the computer resources, technical expertise and assistance provided by the Supercomputation and Visualization Center of Madrid (CesViMa ) and to the Spanish supercomputation network .
 References
