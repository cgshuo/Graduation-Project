 Service orchestration approaches are used to model and enact business processes in enterprise environments by combining the benefits of Service Oriented Architecture (SOA) and Business Process Modelling (BPM). However, to capture quick market opportunities and to handle exceptions, servi ce orchestration approaches need to provide the flexibility to change the processes. 
These changes are twofold, i.e., adap ting a process definition and adapting a process instance. The latter is also refers to as ad-hoc adaptations [1]. Ad-hoc adapta-tions are carried out on a specific running pr ocess instance to deviate it from the orig-inal definition due to distinctive and unforeseen reasons [2] . The support for ad-hoc adaptations is crucial for bus iness process support systems to accurately reflect real world business situations, especially fo r long-lived, customer-oriented business processes such as insurance claim handling or medical treatment management. 
In the past many approaches have been proposed to provide process instance level adaptability using techniques such as template-customisation [3-6] and aspect-orientation [7, 8] . While these techniques improve the process adaptability, what might need to be changed needs to be anticipated in advance at design-time. Also approaches based on constraint-satisfaction [9] and case-handling [10, 11] techniques offer flexibility but lack a comprehensible process/control-flow. While some approaches do support unanticipated adaptations in running process instances, limited for the following reasons. Firstly, the imperative nature of the process model makes the process activities rigidly coupled, where the coupling between the activities is represented exclusively as a control and data flow. M odifications to the control-flow of a running process instance therefore become difficult due to lack of proper representation of constraints between activities. Secondly, imperative processes may be over-constrained in that a different ordering of activities is not allowed while may-be possible without violating business constraints. In practice it is difficult to over-come these limitations because the enactment engines are designed to execute such imperative control flows. 
The primary contribution of this paper is in addressing the issue of process instance or ad hoc adaptation by proposing a novel meta-model/language ( Serendip ) and a service orchestration and management middleware ( Serendip Orchestration Runtime, or SOR for short ). They support indirection between the activities/tasks of a process instance to facilitate high adaptability. In particular, we adopt the models@runtime [13] concept as the key enabler whereby ru ntime models corresponding to process While these models are instantiated based on a declarative process definition, they can be individually modified at runtime because they are indirectly related to each other. This indirection is achieved through an event-driven publish-subscribe mechanism. 
The rest of the paper is organised as follows. Section 2 presents a business example to motivate our discussion. We present our approach in Section 3, followed by its implementation details in Section 4. Section 5 presents the evaluation results, while Section 6 discusses the related work. Finally, we conclude the paper in Section 7. RoSAS is a roadside assistance provider that assists registered motorists. Providing roadside assistance is a long-lived process, which involves a number of tasks from the point where the assistance is requested to where the complete assistance is provided and finalised. During this process, RoSAS utilises a number of third party service providers such as Tow-Trucks, Garages, Case-Officers (Call Centres) and Taxi Ser-vices. These service providers expose their offerings via Web services so that RoSAS can invoke them, e.g., a Web service exposed by a Tow-Truck chain may accept or-ders for towing stranded cars. RoSAS also exposes its service as a Web service (through an intuitive Web interface) to registered motorists. 
RoSAS as the service aggregator needs to define the control-flow on how these services are orchestrated (service orchestr ation). However, due to the unpredictable and customer-oriented nature of the business, RoSAS needs to support changes to its long-lived processes. For example, a motorist may demand to delay the towing until a Taxi picks her up. Another motorist may demand to send a new notification once towing has been completed. Both requirements may not be captured in the initial service orchestration definition. However, facilitating such change requests (if possi-ble) is important for RoSAS to satisfy and retain its customers in a competitive busi-ness environment as well as to align real world business process with IT process [1] . 
Nonetheless, such variations can be impossible to predict during design time. Even if possible, the number of possibilities can be large, making it difficult to capture them all in a business process definition. The IT process infrastructure should there-fore support changes to the running process instances. We identify three requirements that need to be satisfied by an IT process support system. Req1. A meta-model and a language to define process coordination supporting the Req2. A service orchestration runtime that is designed to support changes to running Req3. An adaptation management system to systematically manage the process Req1 provides the foundation by having a flexible language whilst Req2 and Req3 are important in providing middleware platform support for changing process coordina-tion in live service orchestration environments. In the following sections, we explain how our Serendip approach fulfils these requirements. We first provide an overview of the Serendip meta-model and language. Then we introduce how the Serendip Orchestration Runtime (SOR) is designed to support runtime process adaptability and explain how the process instance adaptations are managed in SOR. Finally, we present ho w example adaptation scenarios from the abovementioned motivational business example are realised. 3.1 Serendip Meta-model A service orchestration description defines the control-flow of task/activity execution (service invocations). However, tightly coupling tasks leads to over-specification of control-flow [14] . For example, the block-structured task ordering in WS-BPEL over-specifies control-flow [15] . Such tightly coupled structures can cause unneces-already running partially completed process instances. 
To elaborate, consider two tasks tRequestTow and tTow 1 of a roadside assistance process which represent two business activities requesting towing and accepting tow-ing that should be performed by a case-officer service and a tow-truck service respec-requirement can be captured imperatively in a workflow as shown in Fig. 1-a, which specifies tRequestTow is followed by tTow . According to business requirements this looks valid. However, such specification introduces tight-coupling between the two tasks in the design, giving an interpretation that execution of two tasks is adjacent (an over-specification). During the runtime, however, many other tasks may be intro-duced in between these two tasks (or perhaps in parallel to them). For example, the execution of tRequestTow may not be a necessary condition for tTow . Perhaps the com-pletion of another alternative task, e.g., tCheckTowFeasibility , might also cause the execution of task tTow . A tight coupling, as in Fig. 1-a, over-specifies the dependency making such deviations difficult. 
Hence, instead of having such tight-coupling between tasks, it is better to specify the same requirement in a loosely-coupled manner as shown in Fig. 1-b, in terms of pre-and post-conditions captured as properties of tasks themselves. Still the depen-dencies are captured, however, without a direct linkage between tasks. To preserve the dependency, a post-condition of tRequestTow may be used as a pre-condition of be modified during the runtime to add/remove dependencies. 
In the Serendip language we use event-patterns (EP) to specify these pre-and post-conditions of tasks ( Task ) as shown in Fig. 2-a. These event-patterns include pre-events capturing the minimum conditions required to trigger a task, and post-events defining further progression of a process instance. This introduces an indirec-tion between two tasks via event(s), yet sufficiently captures the dependencies (e.g., tRequestTow precedes tTow during process execution due to event dependency) in a loosely-coupled manner (Req1). For the given example, tTow has a dependency ex-pressed by the event eTowReqd , without a direct reference to the task tRequestTow . The event-pattern ( postEP ) of the task tRequestTow . 
We define a task T as tuple T=(Id, preEP, postEP, rOblig) , where Id is the iden-pattern that triggers upon completion of T, and rOblig is the obligated role, which represents or identifies a (Web) service that performs T. 
A logical collection of such tasks is called a behaviour unit , which is a re-usable unit of coordination defined in the service composition. A behaviour unit also cap-tures constraints that should be upheld during adaptations to its tasks. We define a behaviour unit as a tuple B=(Id, TS, CS) , where Id is the identifier, TS is a set of tasks and CS is a set of constraints. 
The sample behaviour unit given in Fig. 2-a captures three tasks and one constraint. The first task CO.tRequestTow specifies that the role CO should perform the tRequestTow when the events eComplaintRcvd AND eWithinTowZone are triggered (where *, |, and ^ stands for AND, OR and XOR respectively). When the task is complete, the event eTowReqd is triggered. The constraint c1 specifies that the event eTowSuccess should eventually be followed by the event eTTPaid in TCTL [16] . 
A service orchestration runtime instantiat es process instances and terminates them according to a process definition. Therefore process definition should specify the condition of start and the condition of termination which naturally have depen-dencies on tasks. We again decouple such dependencies from the activity coordination of the process. Similar to the specification of the pre-/post-conditions of tasks as properties of tasks themselves, the condition-of-start ( CoS ) and the condition-of-termination ( CoT ) are specified as properties of a process definition themselves as shown in Fig. 2-b. In this example, an instance of the process definition pdAssist will be instantiated when the event eComplaintRcvd is triggered, and terminated when the event eMMNotifDone is triggered, indicating that the motorist is notified. In between these two conditions, the process behaves acco rding to the control-flow defined by the referenced behaviour units ( BehaviourRef ) . A single process definition may refer to multiple behaviour units, and the same behaviour unit could be referenced by multiple process definitions improving the re-use. Similar to a behaviour unit, a process may also impose its own constraints on its referenced behaviour units. Moreover, the properties of a process definition, e.g., behaviour references, too are changeable. 
We define a process definition PD=(Id, CoS, CoT, BS, CS) , where Id is the iden-tifier, CoS is the condition of start, CoT is the condition of termination, BS is a set of referenced behaviour units, and CS is a set of constraints. 
The sample process definition shown in Fig. 2-b refers to four behaviour units and specifies one constraint. An instance of this process definition is instantiated when eComplaintRcvd is triggered and terminated when eMMNotifDone is triggered. Based on the event dependencies, the complete process flow can be dynamically constructed for visualisation purposes (Fig. 6). Modifications to the referenced behaviour units are checked against the defined process constraints, e.g., c5, which specifies that every complaint received, should eventually be followed by an acknowledgement. 
Overall , Serendip uses events to decouple the task dependencies declaratively defined within logical units of coordination called behaviour units. A process definition refers to behaviour units to construct its coordination. To ensure the integrity, constraints can be defined both in behaviour units and process definitions. Summarising above concepts, the Serendip meta-model is presented in Fig. 3. 3.2 Orchestration Runtime While the Serendip language support process flexibility at the modelling stage, it is equally important that the design of the Serendip Orchestration Runtime (SOR) han-dles changes to the control-flow of runnin g process instances (Req2) at the enactment stage. In order to support this, we employ the models@runtime [13] concept as the key enabler, where the models corresponding to processes, behaviours and tasks maintained represented in SOR at runtime and can be individually modified. In this section, we describe how the models are maintained supporting the process enactment and its adaptation. 
In order to separate the adaptation management concerns from the process enactment concerns, we divide the SOR into two subsystems, i.e., Functional System (FS) and Adaptation Management System (AMS) as shown in Fig. 4 . The FS consists of a Model Provider Factory (MPF) to maintain runtime models corresponding to processes and an Enactment Engine (EE) to execute them. In contrast, the AMS, which will be described in Section 3.3 in more detail, consists of an Adaptation Engine (AE) to change the models and a Validation Module (VM) to validate the changed models. Process Representation and Instantiation. MPF is designed as an adaptable runtime model repository. A process is instantiated by creating a new set of runtime models conforming to a process definition and they are assigned with a process instance iden-tifier ( pid ). This means, upon instantiation of a process instance there is, 1. A set of task instance models (TiM) corresponding to the tasks included. 2. A single process instance model (PiM) corresponding to the process definition. Fig. 4 also shows a logical view of how PiM and TiM models are maintained in MPF within a scope of a process instance (e.g., p001). At the beginning, all these models have properties (e.g., preEP/postEP of TiMs, and CoS/CoT of PiM) with the original values copied from the originated process definition 2 . Process Enactment. SOR employs an event-driven publish-subscribe mechanism for process enactment where event publishers are decoupled from the subscribers. The Enactment Engine contains a special sub-component called, the Event Cloud (Fig. 5-a), which records all the situa tional events (event records) in an Event Reposi-captures when the event is fired and the expiration captures when the event expires. 
These events are triggered and recorded in the Event Cloud as tasks (TiMs) are ex-ecuted. The messages received from the partner services as part of performing tasks according to the postEP of the corresponding TiM. For example, when the tTow is complete, the response message from the tow-truck service is evaluated to trigger either the event eTowSuccess or eTowFailed . 
The event cloud also maintains a Subscriber List , which is a list of references to the models that are interested in the events generated. The TiMs and PiMs are such sub-scriber models. For example, at the time of instantiating a process instance, pid=p001, 1. TiM ( tTow , p001) will be subscribed to the events in the event-pattern eTowReqd * 2. PiM ( pdAssist , p001) will be subscribed to the event of the event-pattern eMMNo-The process enactment needs to support changes to TiMs and PiMs models. There are two important characteristics of the event cloud that support such changes, i.e., 1. Subscribers can be dynamically enlisted or delisted from the subscriber list. 2. Event-patterns are not maintained by the event cloud, but by the subscribers, who The enactment engine itself is a subscriber to the event cloud on CoSs of all the process definitions to instantiate process instances. To avoid ambiguity, no two process definitions are allowed to have the same CoS. The complete list of subscriber types, the patterns for which they subscribe events and the actions upon pattern satis-factions are given in Table 1. It should be noted that behaviour units are used to group the related tasks together and have no significance in how the processes are enacted. The subscribers, Script Scheduler and Organiser, will be discussed in more detail in Section 3.3. Upon an event pattern being evaluated to true, the model performs the corresponding action. For example, when the event-pattern of a TiM, e.g., tTow , is evaluated true , the bound Tow-Truck service is invoked to initiate towing. Event-pattern Evaluation. An event-pattern is evaluated by constructing a binary pattern, whilst the intermediary nodes are the operators. During event-pattern evalua-tion, the leaf nodes/events are replaced with true/false values depending on whether (depth-first), evaluating each node until th e top-most node is evaluated, which produces the outcome of either true or false (T/F) for the entire pattern. Overall , the models corresponding to differen t process elements are maintained in SOR. The design of SOR supports the loosely coupled process enactment via an event-driven publish-subscribe mechanism. Such a mechanism enables late changes to the runtime models. 3.3 Adaptation Management Modifying properties of runtime models can be error-prone in live environments. The adaptation management system (AMS) is designed to systematically manage the adaptations on runtime models ensuring the process consistency (Req3). 
In the design of SOR, the AMS is clearly separated from the functional system (Fig. 4). Designing an AMS, through which running process instances are adapted in a service orchestration system, presents several challenges. 1. A single logical adaptation can consist of multiple adaptation steps on models, e.g., 2. The decision-making entity (human/software) need to be decentralised so that the 3. The business integrity needs to be validated automatically upon adaptation. 4. Validity of the adaptations also depends on the state of processes and tasks. In order to address the above-mentioned challenges, we introduce an AMS capable of realising declarative change specifications (A daptation Scripts) that can be remotely issued upon SOR. The adaptation steps are car ried out in a single transaction to ensure the ACID (Atomicity, Consistency, Isolation and Durability) properties, similar to a database transaction [18] . We introduce an adaptation script language that allows grouping multiple adaptation steps on runtime models in a single script file. This ad-dresses the challenges 1 and 2. 
A sample script shown in Listing 2 specifies the process instance p124 ( INST: p124 ) as the adaptation scope and consists of two adaptation commands , update-TaskOfProcessInst to update a task and addTaskToProcessInst to insert a new task to a process instance. The properties of the command updateTaskOfProcessInst specify the task id ( tId="tTow" ) used by the AMS to identify the specific TiM, the properties that need to be updated ( prop="preEP" ) and their new values ( val-
Upon receipt, adaptation scripts will be interpreted and realised upon the runtime models in one transaction. A script can be either scheduled or executed immediately. In the case of a scheduled execution, the AMS creates a new Scheduled Script model, which subscribes to the event cloud for ac tivating event/s (Table 1). A special inter-face called Organiser [19] is provided to receive adaptation scripts. 
Prior to realising an adaptation on actual models, the AMS pauses the target process instance and performs all the adaptation steps as specified by the script on a temporary clone of the process instance. Then the AMS X  X  validation module (VM) performs two validations. If both validatio ns succeed, the adaptation is realised upon the actual models. These validations are designed to address the challenges 3 and 4. Val 1. No violations of business constraints defined in process and behaviour units. Val 2. No violations of model (i.e., PiM and TiM) states. For Val 1 , the engine generates a Petri-Net for the process based on event patterns as constraints (i.e., the constraints in the process definition and behaviour units) defined using the TCTL language [16] via the Romeo model-checker [16] . 
For Val 2 , the engine ensures that the proposed adaptations are state-safe. A TiM can be in one of three states, i.e., init (execution has not started) , active (under execu-tion) or completed. Changes to the TiM properties are allowed depending on these states. For example, a change of preEP of a task is only allowed at init stage. Howev-er, a change in postEP is allowed in both init and active stages. 
A PiM can be in one of three states: running , paused or terminated . The CoT prop-erty of a PiM can only be adapted when it is paused. The CoS property of a PiM can-not be modified as it has already been instantiated (but, allowed in process definition models). A summary of the above discussion is presented in Table 2. Overall , it is required to systematically real ise the adaptations on runtime models. The AMS serves this requirement by addressing four challenges associated with adapting running process instances. A scripting language is designed to write and issue the adaptation commands as a d eclarative change specification. 3.4 Case Study In this section, we present two business scenarios to show how the proposed approach is used to support process instance adaptation. Scenario 1 : Due to rainy conditions, a motorist (pid=p123) requests to delay the towing until the taxi picks her up as the car is the only available shelter . 
To support this requirement, a software engineer introduces a new dependency for amended with the event eTaxiProvided (Listing 1), which is triggered by the execution of the task tProvideTaxi . 
In the MPF, the current value of property preEP of TiM (id= tTow , pid= p123 ) is re-placed with the new value. Note that there is no requirement to introduce a linkage between the two tasks tTow and tProvideTaxi as in the case of imperative approaches. The dependency is indirectly specified via the event eTaxiProvided . Only the runtime task model TiM ( tTow,p123 ) is modified. The advantage is that even if the other task tProvideTaxi of p123 has already been completed, the change can still go ahead as there is no need to modify the task tProvideTaxi (state=completed). Scenario 2 : A motorist (pid=p124) requires that she receives a notification from a case-officer if the tow destination is within the metropolitan area . 
Currently this business requirement is not captured in the process definition, but can be supported by updating tTow to trigger event eInMetro and having the new task tSendSpecialNotif subscribe to it, all in one transaction as shown in Listing 2. 
In this scenario, a new task has been in troduced to a process instance via two adap-tation commands/steps. The postEP of existing task tTow has been modified to trigger a new event, to which the newly created task subscribes in a loosely coupled manner. The core SOR largely been implemented in Java, is independent of Web service tech-nology. However, it is integrated with Apache Axis2 [21] , which is a popular web service engine to benefit from its standardised message processing capabilities via the ROAD4WS extension [22] . In return, the adaptive service orchestration capabilities are introduced, which are not currently supported by any Axis2-based orchestration runtimes such as Apache ODE [23] , to the best of our knowledge. The framework uses Drools [17] business rules to interpret messages and to trigger events. In our design we decoupled the decision-making entity from the functional system. An organiser interface allows the issuing of adaptation scripts remotely via two Web service operations executeScript(script) and scheduleScript(script, condition) [19] . The former is used to immediately execute a script whilst the latter is used to schedule until some event(s) (a clock event or a pattern of situational events) happen. This separates the concerns of how and when an adaptation should be carried out. 
The tool support includes the visualisation of individual process instances and a management interface for issuing adaptation commands (Fig. 6). EPC graphs [20] are dynamically constructed [19] by mapping the identical events of the up-to-date preEP and postEP properties of TiMs to provide a better understandability on process flow. These EPC graphs also show the current status of process tasks. We integrate and further improve the visualisation libraries available in the ProM framework [24] for this purpose. Tool support also allows is suing adaptation scripts and receiving the feedback on how the adaptation is realised. Firstly, we evaluate the process instance adaptability of Serendip using the criteria proposed in [25] . Then, we quantify the performance penalty of SOR against an existing service orchestration runtime [23] in achieving the process instance adaptability. 5.1 Adaptation Patterns We have evaluated the Serendip X  X  support fo r adaptability against the change patterns proposed by Weber et al. [25] . Based on the evaluation, Serendip supports all the 13 adaptation patterns (AP) and 4 patterns for predefined changes (PP). However, Seren-dip falls short in supporting three change support features (CF) i.e. Controlled Migra-tion, Traceability and Analysis and Access Control for Changes . We are expecting to further improve the Serendip framework to support these features as future work. A summary of the evaluation is available in Table 3. Due to limited space only the sup-port for a complex adaptation pattern AP9 (Fig. 7-a) is given below (an interested the explanation we use the same notations as in the original article [25] . Support for AP9: Serendip allows modifying properties (e.g., preEP/postEP) of run-time models (e.g., TiM) to deviate the process instances (Section 3.3). To support AP9, as shown in Fig. 7-b the value of postEP of the initial task E is assigned to the preEP of the intermediate tasks G and X (F already has the same preEP, thus omitted). The preEP of H is set as the union (*) of postEPs of F, G and X. 5.2 Performance Evaluation SOR is designed to support runtime adaptations; however this comes with a perfor-mance penalty. We quantify the penalty in comparison to Apache ODE [23] , which is a static runtime without support for the process instance adaptations. Moreover, ODE is also based on Apache Axis2 [21] as is SOR. 
We implemented the business example presented in Section 2 using both BPEL and Serendip, then deployed them on ODE and SOR respectively to compare their response times. The test was set up in a controlled environment, where all the partner was run on a machine with 2.52 GHz Intel Core i-5 CPU and 4 GB RAM. The operat-ing system was 32-bit Windows 7 Home Premium. The servlet container was Apache Tomcat 7.0.8. We then compared the average response time taken (  X  t) to serve re-results are summarised in Table 4. We then calculate the Percentage Performance Lost (PPL), The result shows that the SOR runs the scenario about 5.448% slower than ODE. Such a performance penalty could be considered negligible given SOR X  X  support for process instance adaptability. In this section we categorise and analyse some of the related approaches proposed to improve the adaptability of process instances. 
Template Customisation is a technique used to generate a highly optimised fitting process that suits the running environment. For example, Geebelen et al. [3] use the Model-View-Controller pattern to generate a process according to a pre-defined mas-ter process. Mietzner et al . [4] propose to customise a process template into a custom-er specific solution by defining variation points. Similarly, PAWS [6] annotate process templates to define variation points facilitating runtime process optimisation and healing. While the template customisation technique in general improves the fit of time the environment changes. It is not po ssible to alter a running process instance. 
Aspect-Orientation is one of the dominant adaptation techniques that have been used in the recent past. For example, AO4BPEL [8] uses business rules as aspects to be weaved into a BPEL process. VxBPEL [7] also extends the BPEL language to allow different variations of process instan ces to co-exist. While aspect-orientation helps to separate the adaptability concerns from a core business process (via variation points), it requires the identification of fixed and volatile parts at design time. There-distinguish such fixed and volatile parts. 
Constraint-Satisfaction techniques seek flexibility by allowing the runtime to de-termine the execution order of tasks. For example, in DecSerFlow [9] , the next possi-ble activity is selected based on the defined constraints. Similarly, case-handling ap-albeit with a different paradigm. As such, there is no explicit ordering of activities defined but the next possible activities are only constrained by the state of the case/artifact . While such approaches provide runtime flexibility, their biggest disad-vantage is a lack of a comprehensible representation of control-flow. The main reason behind this problem is there is no explicit representation on what should be done . In contrast the declarative task descriptions in our approach allow explicitly defining what should be done rather than what shouldn X  X  be done . Further these declarative tasks descriptions (based on the most up-to-date values of runtime models, TiM and PiM ) are used to dynamically construct the complete visualisation as an EPC graph [19] . In this way our approach overcomes the overall understandability problem. 
Dynamic Changes on Running Instances have been used to overcome the disadvan-tages of the above-mentioned techniques to adapt long-lived process instances. For ex-ample, Fang et al . [2] propose an approach to adapt enacted BPEL processes. However it is limited to navigational changes such as Skip and Retry . ADEPT2 [12] is another exam-ple and supports plug &amp; play process fragments. Nonetheless, the process definitions still enforce the tight-coupling between tasks limiting runtime adaptability. For example, in ADPET2, the complete schema (original) needs to be loaded from the repository, and adapted to create a new schema before the process instance is migrated to the new schema. This involves modifications to multiple tasks of a process instance due to the tight-coupling between the tasks. Consequently, adaptations like those in Scenario 1 and Scenario 2 (Section 3.4) are unnecessarily constrained by tightly related tasks, whereas modifications. This is a major advantage of combining the models@runtime concept with the event-driven publish-subscribe technique. 
Moreover, many approaches that bring benefits of events have been proposed in the past. For example, the ED-BPM approach uses Complex Event Processing to detect errors in process enactment [26] . An ED-SOA architecture uses events to inte-grate applications/services [27] . While we learn from these, our motivation is differ-ent. As such we use event-patterns as prope rties of runtime process models to achieve the indirection between tasks and thereby improve the process adaptability. 
It should be noted that this work focuses on making business process instances adaptable at runtime, and does not consider their self-adaptation. Self-adaptive sys-tems operate in a closed loop where the system itself is responsible for adaptation decision making and realisation . This work leave the loop open at the point of deci-sion making, which is highly domain specific, so that either a human (software engi-neer) or an automated software agent may act as the decision making entity. However, we provide an API to the underlying change realisation mechanisms that can be used to alter the running process instances follo wing the adaptation decisions that have been made. As such, if the loop is closed with a fully-automated decision making entity, such as a rule-based or control-th eoretic software agent, then the complete system can be considered as a self-a daptive service orchestration system. In this paper, we have presented an appro ach that is capable of adapting process in-stances of a service orchestration at runtime. The approach is described in terms of (a) a flexible process modelling language and meta-model; (b) a design of an adaptation-enabled service orchestration runtime and (c) an adaptation management system. 
The essence of our approach is its use of the models@runtime concept with an event-driven publish-subscribe mechanism in designing the service orchestration runtime. An adaptation management system, which is separated from but interacts with the service orchestration runtime, has also been introduced to manage, check and validate the adaptations addressing a number of specific challenges. The evaluation results have revealed that our approach supports all the adaptation patterns proposed by Weber et al . [25] . We have also quantified the performance penalty of SOR, which can be considered acceptable. 
As future work, we plan to improve the tool support, including the provision of pre-specified script templates so that the engineer can efficiently write adaptation commands/scripts. We also plan to provide support for the omitted change support features [25] . Moreover, we believe that it is necessary to evaluate and quantify the efficiency of using our framework by software engineers (humans) in their respective real world application domains. Acknowledgments. This research was partly supported by the Smart Services Cooperative Research Centre (CRC) through the Australian Government X  X  CRC Programme (Department of Industry, Innovation, Science, Research &amp; Tertiary Education). 
