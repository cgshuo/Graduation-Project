 In today X  X  information technology society, people are increasingly dependent on the spective:
United States e-commerce transactions resulted in 707 million dollars in rev-enue in 1996, increasing to an impressive 2.6 billion dollars in 1997, and to an incredible high of 5.8 billion do llars in 1998. It is estimated that e-com-merce infrastructure will generate, or enable, 34 X 37.5 billion dollars in rev-enue by the year 2002 (Forrester 1998).

As a result, a significant amount of research in the field of e-commerce has been carried out in the past decade, resulting in a variety of algorithms and techniques for merce have mainly arisen from the fact that  X  data can be divulged: some important commercial information, including account between principals may be compromised without effective secure protocols for key-exchange, authentication, and privacy. The refore, secure protocols, including crypto-graphic protocols and secure transaction protocols, have become the prime requisite address the range of circumstances under which these objectives must be met.
These efforts are effective in overcoming weaknesses and reducing redundancies at advocated in (Needam and Schroeder 1978; ITU-T 1998) which have been proved to be vulnerable to attack (Gritzalis 1999). Therefore, it is important to find ways to users of electronic transactions will be at risk.
 egories: constructing possible attacks using algebraic properties of the algorithms in inference-construction approaches).
 Dolev and Yao (1983), the NRL Analyzer (Meadows 1996), and the Interrogator
Model (Millen 1995). This work figures out how t o ensure authentication and security properties, which do not depend on the validity of a designated logic. 1990). The BAN logic abstracts all but the information intended to be conveyed from 1978; Neuman and Ts X  X  1994). There are some extensions of the above three logics.
The BGNY logic (developed by Brackin (1996)) is an extension of the GNY logic, and is used by software that automatically proves authentication properties of crypto-graphic protocols. The AUTLOG logic (an advanced logic of authentication) is based on the BAN logic (Kessler and Wedel 1994). This logic proposes a predicate  X  X ecog-nise X  and extends the meaning of the operator  X  X ee X . Meanwhile, an eavesdropper is also simulated in the logic.
 coin-exchange (Brackin 1997). Meadows and Syverson (1998) have designed a lan-researchers.
 world transactions. There are also many technical issues arising from cryptographic algorithms and network communication protocols (e.g., Birrell 1985; Dierks and
Allen 1999). Two of the limitations in existing v alidating approach es are as follows: 1. Because the attack-construction appro aches suffer from a huge state space, it has low efficiency in detecting attacks on l arge secure trans action protocols. number of assumptions that a secret rema ins secret during the execution of pro-tocols (Gong and Syverson 1995); and the GNY logic contains many rules that have to be considered at each stage.

As we have seen, it is very difficult to dev elop an approach that is suitable for val-idating all related protocols. In this paper, we advocate a logical framework, ENDL, for validating secure transaction protocols. The ENDL is referred to as an inference-random number. ENDL improves the set of deduction rules called postulates by using dynamic actions, which is the common drawback of BAN and GNY. Moreover, the postulates may not always lead from the assumptions, via intermediate formulas, to if any authentication fails. The timestamp has been used for the modelling of fresh-ENDL is effective and promising.

This paper focuses on the design of a logical framework, ENDL. Section 2 presents a computational model. In Sect. 3, a formal description of basic terms and statements of ENDL are provided. Sectio n 4 builds a basic inference framework. In
We conclude this paper in the last section. Figure 1 depicts a computational model for e-commerce.
 protocol. The public environment is an open network that is composed of principals identity, account number, and key, constitute th e communication between principals.
The principal does not only place messages on a link, but also sees or modifies the hosts, and processes) and me ssages. Principals can inte ract with each other according via a communication facility.

The secure transaction protocol is a method used to secure transactions over an several stages by message transmissions, such as a request for certifying authority. In these stages, cryptography is used to provide confidentiality of information to ensure is called a  X  X ession X . For convenience, this paper only considers sessions that appear to end successfully, and the overhead issues are excluded.
 efficient in SET (1997). Figure 2 illustrates the hierarchy of trust. and GCA indicates the Brand Geo-political CA.
 data items, which it had before the session began, or which were extracted from the messages sent to it before or during the current stage. However, the potential set of information is infinite.
 A believes m . This indicates that principal A has enough confidence in message m . Although this confidence may not be very high, A still believes m is true. the inference rule and related axioms. The message and verification form the initial set of received data items and their confide nces for processing next time. During the then the principal believes  X  B does not know m  X .

To explore a flaw-free protocol, a logic, called NDL (non-monotonic dynamic logic), was built by Bai and Chen (2002). The NDL is a natural and practical analy-taken from single-rank logic, dynamic logic, and non-monotonic logic, for efficiently identifying flaws. However, the NDL has been unable to accommodate the actual cir-cumstances of secure trans action protocols such as data integrity. This paper designs root of the certificate issuer. Also, we assume that the cryptographic algorithms and communication protocols are sound during the verification.
This section presents formal definitions for the function word, predicate, and action, which are used for building our ENDL logic, as follows: A principal is some participant who carries out the protocol.
Uppercase X , Y , A , B , C ,and CA (Certificate Authorities) range over particular principals. crypted messages are regarded as messages.)
T denotes a specific timestamp that can be used to authenticate the validity of a message and to assert that the messa ge is created for a current session. decryption, keys.

Generate and Send denote specific actions. (Encryption and digital signature, etc. are some mapping operations on messages, but not actions.)
P and Q denote a formula, based on all the above concepts, on which the in-frastructure of ENDL can be constructed by employing the following components: principals and messages within the period of protocol execution. For instance, Alice and sends m .
 comes into its possession. To consider the possibility that communication keys may be compromised in an open network and the timestamp may prevent replays, we now introduce timestamp T for the freshness of a message. If the clock synchronisation of clock as a reference (Kohl and Neuman 1990; Sherif 2000). Actually, the timestamp
Schroeder protocol for a public key system, but the exposure of a user X  X  private keys cannot be eliminated by the timestamp. Unless compromises are reported to the AS (authentication server) and public keys are obtained from the AS immediately prior and Sacco 1981).
 ing on uniquely distinguishing features, known as identifier ID . This contrasts with ponds to the declared user. Authentication and identification of the sender take place simultaneously, when the recipient proposes to the verifier in private a secret that is under legitimate appearances to pursue unauthorised operations.
 and that the message content is not alerted during transmission between the originator digital signatures.
 of a random number, Rnd , before encryption.
 accessed by the intended recipients. Confide ntiality is ensured by the use of message encryption.
 operations consist of the encryption, signatu re, message digest, and associated map-ping relation of the key: Kpv ( X ) represents the private key-exchange key of X .
 Spb ( X ) represents the public signature key of X .

Spv ( X ) represents the private signature key of X . m 1 ,... , m n represents the combination of messages m
Although Kpv ( X ) and Kpb ( X ) are restricted to exchanging symmetric keys in
When the message digest of a message is encrypted using a sender X  X  private key, and is appended to the original message, the result is known as the digital signature related cryptographic algorithms used to construct the encryption and decryption are basically believed to be robust, but we cannot absolutely exclude the possibility that some intelligent attackers can intercept the message and break down the encryption to demonstrate in this paper is how to apply our approach to verify secure protocols.
Action is applied to describe the communi cation process in which a principal of actions listed below: Generate ( X , m ) : Applied to represent that X generates the message m .
Send ( X , Y , m ) : Applied to represent that X sends the message m to Y after X
Applying the conventional logic operator can derive further actions. Suppose and  X  are basic action sequences, then  X   X   X  denotes the conjunction of in fact, add new actions, but the two actions indicated above are commonly used in a secure protocol.
 cipals. There are four kinds of predicate listed below:
Know ( X , m ) represents that X knows message m . It is possible that X generates
Auth ( X , Y , m ) represents that X authenticates message m sent by Y and m has
Equal ( m , m ) represents that, if message m is equal to message m , then it returns Assertion:
P and Q present a set of formulae and  X  denotes an action sequences. This assertion means that if the premise P is true, then  X  can be executed, and the con-clusion Q will be true if  X  can be performed successfully. Let P the formulae, then the following are still regarded as formulae: notation from set theory. Suppose we have a formula P
P  X  P suppose the formula is P = P 1  X  P 2 ; we can say P P is the union of P 1 and P 2 .
 function words, since these conjunctions repeatedly appear in our logic system. The signature, message digest, and the like:
This section proposes the ENDL framework, including its axioms and inference rules, and the inference format comprising the accumulation property. (1) Encryption e ( exchange key encryption, can be expressed by the following formula: 1-2 Know ( X , m )  X  Know ( X , Kpb ( Y ))  X  X  X  Know ( X , E
This means that, if X knows message m and public key-exchange key Kpb of Y ,then X knows E ( m , Kpb ( Y )) by using Kpb ( Y ) 1-3 Know ( X , m )  X  Know ( X , Spv ( Y ))  X  X  X  Know ( X , S
This means that, if X knows message m and private signature key Spv then X knows S ( m , Spv ( Y )) by using Spv ( Y ) to encrypt message m .
Denning and Sacco (1981). Along with other i nformation, the messages that need to be protected are appended with a timestamp before encryption. Moreover, Gong has proposed a security risk of depending on synchronised clocks (Gong 1992). Accord-ing to Gong, clocks can become unsynchronised due to sabotage on, or faults in, the efficiently in this paper. (2) Key Allocation 2-1 Know ( X , Kpb ( C A Root ))
This means that all principals of the secure protocol know the public key-exchange key of CARoot . 2-2 Know ( X , Spb ( C A Root )) key of CARoot . 2-3 Know ( X , Kpv ( X ))
This means that X knows its own private key-exchange key. It is computationally unfeasible for anyone to deduce it from the public key-exchange key. 2-4 Know ( X , Kpb ( X ))
This means that X must know its own public key-exchange key. 2-5 Know ( X , Spv ( X ))
This means that X knows its own private signature key. It is computationally unfeasible for anyone to deduce it from the public signature key. 2-6 Know ( X , Spb ( X ))
This means that X must know its own public signature key. (3) Decryption 3-1 Know ( X , k )  X  Know ( X , e ( m , k ))  X  X  X  Know ( X ,
This means that, if X knows communication key k and e the plain text of message m by using k to decrypt e 3-2 Know ( X , Kpv ( Y ))  X  Know ( X , E ( m , Kpb ( Y )))  X  X  X  This means that, if X knows private key-exchange key Kpv ( then X knows the plain text of message m by using the private key-exchange key
Kpv ( Y ) to decrypt E ( m , Kpb ( Y )) .

S ( nature key Spb ( Y ) of Y to decrypt S ( m , Spv ( Y )) .
 suffer from a malicious attack (e.g. masquerading, replay, and eavesdropping) when strictly to the requirements of the secure protocol. (4) Signature then X knows the message digest H ( m ) (derived from axiom 4-1) and
S (
H ( m ), Spv ( Y )) by using Spv ( Y ) to encrypt H ( m a user X  X  private key is exposed, all messages sent enciphered under the corresponding private keys and exposure of the private key used by the certificate authority to sign secure protocols. (5) Authentication then X can authenticate that Y sent m ,and m has not been modified by using Spb that a message is not replayed by checking that | Clock  X  is the local time, t 1 is an interval representing the normal discrepancy between the network delay time (Denning and Sacco 1981).
H ( sent m ,and m has not been modified. In this formula, we do not necessarily add the predicate that expresses that X knows the public signature key Spb
X is convinced of the validity of H ( m ) . 5-3 Know ( X , Spb ( Y ))  X  Know ( X , S ( Y , T , Spb ( Y
This means that, if X knows Spb ( Y ) and S ( Y , T , Spb authenticate Spb ( Y ) by using the public signature key of CA to verify the encrypted message and by checking the timestamp and identity included in the message. (6) Separation 6-1 Know ( X , m 1 ,... , m n )  X  X  X  Know ( X , m 1 )  X  ...  X 
This means that, if X knows a compound message m 1 , m 2 ,...... , of them, X can combine them to form a new group of messages. 6-2 Auth ( X , Y , m 1 ,... , m n )  X  X  X  Auth ( X , Y , m 1
This means that, if X authenticates that Y ever sent a compound message m m , ...... , m every element of it and none of it has been modified. The reverse is not true since X may authenticate each message at a different time but the belief in them can change as time passes; thus, X cannot authenticate the compound message m m n even though it could authenticate its every component beforehand. (7) PKI 7-1 Know ( X , CertS ( Y ))  X  Verify ( X , CertS ( Y ), CA
This means that, if the signature certificate of Y , CertS cate authority) is verified successfully by X ,then X can authenticate that the public signature key Spb ( Y ) of Y is valid and issued by CA . 7-2 Know ( X , CertK ( Y ))  X  Verify ( X , CertK ( Y ), CA
This means that, if the key-exchange certificate CertK public key-exchange key Kpb ( Y ) of Y is valid and issued by CA .
These two axioms are used to descr ibe how a principal verifies the CA certificate authenticated, the user will hold a copy of the certificate to use later. of the next set of inference rules.
 Theorem 1. If a principal X knows a message m , the public signature key of Y ,and that the message m was sent by Y and has not been modified:
Proof. (1) Know ( X , m ) [premise] (2) Know ( X , S 0 ( Y , m ) T ) [premise] (3) Know ( X , Spb ( Y )) [premise] (4) Know ( X , S ( ID Y , T , H ( m ) , Spv ( Y ))) (2)[definition] (5) Auth ( X , Y , m ) (1)(3)(4)[5-1] (6) Know ( X , m )  X  Know ( X , S 0 ( Y , m ) T )  X  Know ( the definition of S 0 ( Y , m ) T ) , which is an equivalent expression of S Spv ( Y )) .

Theorem 2. If a principal X knows the public signature key of Y and Y  X  X  digi-message m was sent by Y and has not been modified:
Proof. (1) Know ( X , Sign ( Y , m ) T ) [premise] (2) Know ( X , Spb ( Y )) [premise] (3) Know ( X , m , S ( ID Y , T , H ( m ) , Spv ( Y )) ) (1)[definition] (4) Know ( X , m ) (3)[6-1] (5) Know ( X , S ( ID Y , T , H ( m ) , Spv ( Y ))) (3)[6-1] (6) Know ( X , S 0 ( Y , m ) T ) (5)[definition] (7) Auth ( X , Y , m ) (2)(4)(6)[Theorem 1] (8) Know ( X , Sign ( Y , m ) T )  X  Know ( X , Spb ( Y ))  X  X  X  the definition of Sign ( Y , m ) T , which is an equivalent expression of
T , H ( m ) , Spv ( Y )) &gt; , and the definition of Theorem 1. provide a clear and comprehensive way of d escribing the operation of digital signa-tures in a secure protocol. (R-1) Revelation distributed system and an open network. The rule, in fact, provides a convenient way to simulate the eavesdropper during the communication. (R-2) Generation states that if message m is generated by X ,then X itself must know m . (R-3) Accumulation after action  X  . Actually, this rule cannot accommoda te any secure protocols for two knowledge about the keys is outdated; (2) if the protocols do not provide a memory function, the knowledge about message m can be forgotten. Therefore, the logic sys-tem mentioned in this paper can only be applied to protocols satisfying the following (R-4) Union states that if the conclusion Q of the former action action  X  ,then  X  and  X  can be synthesised by acting the original conclusion R of  X  a kind of algebraic operation with the property of union. (R-5) Non-monotonic says that if we cannot conclude that a principal X successfully au thenticates m after a sequence of action  X  , then we non-monotonically assume that X does not believe the validity of m . Here, non-monotonic means, based on the only knowledge, premise m as P or  X  is extended, so the non-monotonic assumption will be correspondingly and unconditionally which principal X does not know since the message can be intercepted. However, we can accept that X should not know m if the paths are too limited for X to understand m .
In our former work (Bai et al. 2000), we assumed that the key cannot be altered and the principals have the property of memory of message m , but the key, in fact, can be altered and the principal may not possess memory of m . Thus, the accumulation environment.
 (1) Some of k , Spb ( X ), Spv ( X ) ,and Kpb ( X ), Kpv (2) None of k , Spb ( X ), Spv ( X ) ,and Kpb ( X ), Kpv (3) Some of k , Spb ( X ), Spv ( X ) ,and Kpb ( X ), Kpv (4) None of k , Spb ( X ), Spv ( X ) ,and Kpb ( X ), Kpv about the possibilities described above.
 ation. The accumulation rule (R-3) can s till be applied since the principals X and Y have memory of message m , which helps them to recall message m . However, if X alters the cryptographic keys k , Spb ( X ), Spv ( X ) ,or Kpb again.
 be deduced as shown below. (R-I-1) Accumulation 1: and lets the corresponding principal know them, then the conclusion Q that has been proved to be true remains correct after the action consists of Generate () and Send () , and so forth. In this rule, ne any combination of k , Spb ( X ) ,and Kpb ( X ) because the private signature key Spv personal privacy that must be kept secret to other principals. be applied to this special instance. (R-I-2) Accumulation 2: or Kpb ( X ), Kpv ( X ) , and message m , and lets Y know the ne and Send () and so forth. Because the princ ipals have memory of message m , Y can k , Spb ( X ) ,and Kpb ( X ) because the private signature key Spv exchange key Kpv ( X ) cannot be disclosed to Y since they have personal privacy that must be kept secret from other principals. (R-I-3) Accumulation 3:
This means that, if X changes the former cryptographic keys k , Spb or Kpb ( X ), Kpv ( X ) , and message m , and lets Y know the ne equal to m , we can say non-monotonically that conclusion Q that has been proved to be true is not correct after the action  X   X  Generate (R-I-4) Accumulation 4:
This means that, if X alters the cryptographic keys k , Spb true is not correct any more after the action  X   X  Generate of Generate () and Send () , and so forth.

In circumstance (2), the corresponding rules are listed below. (R-II-1) Accumulation 5:
This means that, if X creates a new message m and let Y know m and m ,since as the message m that was formerly produced, the conclusion Q still stays true after the action  X   X  Generate ( X , m ) . Thus, message m represents the combination of m , m 2 ,... ,and m n . (R-II-2) Accumulation 6:
This means that, if X creates a new message m , but does not let Y know what has been changed about m , then we can say non-monotonically that the conclusion
Q does not remain true after the action  X   X  Generate
For circumstance (3), several rules are described as follows. (R-III-1) Accumulation 7:
This means that, if principal X alters the cryptographic keys k , Spb
Spv (
X ) ,or Kpb ( X ), Kpv ( X ) , and the message, and lets Y know the ne and m , then, if the contents of message m produced by X correspondingly remains the same as that of the message m which was created originally, then the conclusion
Q still stays true after the action  X   X  Generate ( X (R-III-2) Accumulation 8: graphic keys k , Spb ( X ), Spv ( X ) ,or Kpb ( X ), Kpv (
Y know the ne w key , m ,and m , then, if the contents of message m that is produced currently by principal X does not remain the same as that of message m ,thenwe  X   X  Generate ( X , ne w key , m ) . (R-III-3) Accumulation 9:
Y know the ne w key , then we can say non-monotonically that the conclusion Q does not stay true after the action  X   X  Generate ( X
Generate () and Send () , and so forth. (R-III-4) Accumulation 10: tographic keys k , Spb ( X ), Spv ( X ) ,or Kpb ( X ), Kpv does not let Y know what has been changed about the message m , then we can  X   X  Generate ( X , ne w key , m ) , which consists of Generate forth. (R-III-5) Accumulation 11: graphic keys k , Spb ( X ), Spv ( X ) ,or Kpb ( X ), Kpv remain true after the action  X   X  Generate ( X , ne w key (R-IV-1) Accumulation 12: the contents of message m that is produced at the same time by principal X remain (R-IV-2) Accumulation 13:
This means that, during the execution of the protocol, if X alters message m ,but the contents of message m that is produced at the same time by principal X does not remain the same as that of message m , then we can say non-monotonically that the conclusion Q does not stay true after action  X   X  Generate have memory of message m .

The accumulation rules synthetically de scribed above take into account the pos-expression of cryptographic keys. It would appear that this notation might never be more accurate, the current notation system n eeds to be improved further. In this pa-original. Exceptions to this will be discussed in our future work.
The above expressions can be compressed b y using an assertion to describe the procedure of deduction. The union of the formulae is derived from the definition of the assertion. For instance, { f 01 , f 02 ... f 0 m 0 } is a formula, so each f derived from inference rules R-3 and R-4. This format can be described by another expression as shown below:
This inference format is based on the accu mulation and dynamic properties of secure transmission, so an eavesdropper can impersonate the sender or receiver and continue concerned about network communication, eavesdropping, hashing, and encryption protocol. use of ENDL when verifying a secure protocol.
 Example 1. Distribution of Public keys in Needham and Schroeder X  X  protocol. systems. This has been proposed by Denning and Sacco (1981). In this instance, we show that our logic detects a known flaw in the protocol. find B  X  X  public key. The exchange can be described in a series of action sequences: where Spv ( AS ) denotes AS  X  X  private signature key and Spb since AS is an authority.

B , Spb ( B ) .Formula P denotes the set of premises,  X  is the combination of a series of actions, and formula Q denotes the object we want to verify:
Proof. (1) Know ( A , Spb ( AS )) [2-2] (2) Generate ( A , A , B ) [action] (3) Know ( A , A , B ) (2)[R-2] (4) Send ( A , AS , A , B ) (3)[1.1] (5) Know ( AS , A , B ) (4)[R-1] (6) Know ( AS , B ) (5)[6-1] (7) Generate ( AS , S ( CK , Spv ( AS ))) (6)[2-4][action] (8) Know ( AS , S ( CK , Spv ( AS ))) (7)[R-2] (9) Send ( AS , A , S ( CK , Spv ( AS ))) (8)[1.2] (10) Know ( A , S ( B , Spb ( B ) , Spv ( AS ))) (9)[R-1] (11) Auth ( A , AS , Spb ( B )) (1)(3)(10)[5-3][R-5]
The final conclusion is that we cannot reach the goal Auth to the non-monotonic rule (R-5), we may conclude non-monotonically that A does the encrypted component from message (10). The weakness that allowed the attack have made the recipient suspect that th e message was a replay (Denning and Sacco 1981).

For the non-monotonic property, the authentication here contains only eleven steps; thus, ENDL is more efficient than other logics.
 Example 2. Case 1 of Cardholder Registration in the SET Protocol.
Based on the SET protocol developed by Visa and MasterCard in May of 1997, on the advice of IBM, Microsoft, Netscape, RSA, and SAIC (SET 1997), we inter-an initial response sent by CA . There are two principals in this instance: cardholder used to describe this particular verification. This cannot be done in NDL. registration form Reg Form Req and encrypts the message with a randomly gener-then encrypted with Spv ( CA ) .Only CA , C , and the Issuer know the PAN, which is effectively obfuscated by using a blinding technique (SET 1997). Then C transmits these messages to CA ; CA decrypts key k and the cardholder X  X  PAN with Kpv
It then decrypts the Reg Form Req using k . Eventually, CA determines the appropri-ate registration form, and digitally signs it by using Spv to C .

We begin the verification from the goal Auth ( C , CA
Auth ( C , CA , Kpv ( CA ), Kpb ( CA ) ) . The definitions of P , meaning as above:
Proof. (1) Know ( C , Spb ( CA )) [2-2] (2) Generate ( CA , InitRes ) [action] (3) Know ( CA , InitRes ) (2)[R-2] (4) Generate ( CA , CertS ( CA ), CertK ( CA ), InitRes , (5) Know ( CA , CertS ( CA ), CertK ( CA ), InitRes , S ( (6) Send ( CA , C , CertS ( CA ), CertK ( CA ), InitRes , (7) Know ( C , CertS ( CA ), CertK ( CA ), InitRes , S ( H (8) Know ( C , CertS ( CA )) (7)[6-1] (9) Know ( C , CertK ( CA )) (7)[6-1] (10) Know ( C , S ( H ( InitRes ), Spv ( CA ))) (7)[6-1] (11) Verify ( C , CertS ( CA ), CA ) [abbreviation] (12) IsVerified ( C , CertS ( CA )) [discriminant] (13) Auth ( C , CA , Spb ( CA ), Spv ( CA ) ) (8)(11)(12)[7-1] (14) Verify ( C , CertK ( CA ), CA ) [abbreviation] (15) IsVerified ( C , CertK ( CA )) [discriminant] (16) Auth ( C , CA , Kpb ( CA ), Kpv ( CA ) ) (9)(14)(15)[7-2] (17) Auth ( C , CA , InitRes ) (1)(7)(10)[6-1][Theorem 1][R-5]
The certificate chain is not applied in NDL, but it is a very important component in too complicated to be described here. Meanwhile, if we cannot ensure that the private should be halted immediately for the non-monotonic rule (R-5), namely fail-negate . for InitRes encrypted by Spv ( CA ) does not include the timestamp and identifier, so the intruder can replay this message in a l ater transaction. This problem is common for the identifier. (1) C  X  Z ( CA ) : InitReq (2) Z ( C )  X  CA: InitReq (3) CA  X  Z ( C ) : CertS ( CA ), CertK ( CA ), InitRes ,( (2 ) Z ( C )  X  CA : InitReq (3 ) CA  X  Z ( C ) : CertS ( CA ), CertK ( CA ), InitRes , (4) Z ( CA )  X  C : CertS ( CA ), CertK ( CA ), InitRes , S
Here, InitReq denotes the initial request sent by C to CA . The intruder Z in-initReq . It then sends the result to CA as message (2). CA replies with message (3). Z impersonates C to produce a new message (2 ) and sends it to CA . CA answers
C with a corresponding message (3 ), and then Z intercepts it. At last, Z imperson-ates CA to send an outdated message (4) that is intercepted by Z from message (3). between C and CA again. The best solution is to include a timestamp and an iden-the protocol designer must be very careful to detect every possible subtle drawback an intruder detects the flaws.
 Example 3. Case 2 of Cardholder Registration.

After receiving the message sent by cardholder C , CA decrypts k and account information AcctInf with Kpv ( CA ) . Then, CA decrypts RegFormReg ,using k ,and
Spv (
CA ) . CA then sends the registration form and CertS ( CA m = CertReq , k
There are two principals, C and CA , in this transaction. After validating the registration form sent by CA , cardholder C creates one pair of signature keys, Spv and Spb ( C ) . Meanwhile, C also creates two new symmetric key, k form. Generally, it assumes that they do not alter the keys and have memory of the message. However, we cannot exclude the possibility that someone might modify eavesdropper, (2) the transaction fails, or (3) the key is too old to use. On the other security flaws. The related keys and the message generated in this process are listed below:
Based on the above keys and message, likely modifications are listed below:  X 
C alters cryptographic keys, and notifies CA promptly before applying the new keys.  X  C alters them, but does not notify CA before applying the new keys.  X  C generates CertReq again, and it stays the same as the old one.  X  C generates CertReq again, but it does not stay the same as the old one.  X  C alters cryptographic keys, and notifies CA before applying the new keys;  X  C alters cryptographic keys, and notifies CA before applying the new keys;  X  C alters cryptographic keys, but does not notify CA before applying the new  X  C alters cryptographic keys, but does not notify CA before applying the new message. In the first instance, if C alters the cryptographic keys, Spv and k 3 , and notifies CA before applying the new keys, CA can make the older keys memory of the message. This has the potential to cause some damage to security in e-commerce. For the other items, verifica tion can be developed according to the cor-responding accumulation rules. The proce dure for verification should be the same as rules.

Proof. (1) Know ( C , Spb ( CA )) [2-2] (2) Generate ( C , Spv ( C ), Spb ( C ) ) [action] (3) Know ( C , Spv ( C ), Spb ( C ) ) (2)[R-2] (4) Generate ( C , CertReq ) (3)[2-4][action] (5) Know ( C , CertReq ) (4)[R-2] (6) Generate ( C , k 2 , k 3 ) [action] (7) Know ( C , k 2 , k 3 ) (6)[R-2] (8) Know ( C , CertReq , k 2 , Spb ( C ) ) (3)(5)(7)[6-1] (9) Know ( C , H ( m )) (8)[4-1] (10) Know ( C , S ( H ( m ), Spv ( C ))) (3)(9)[6-1] (11) Know ( C , e ( m , S ( H ( m ), Spv ( C )) , k 3 )) (7)(8)(10)[6-1][1-1] (12) Know ( C , AcctInf ) [premise] (13) Know ( C , E ( k 3 , AcctInf , Kpb ( CA ))) (7)(12)[6-1][2-1] (14) Send ( C , CA , e ( m , S ( H ( m ), Spv ( C )) , k 3 (15) Send ( C , CA , E ( k 3 , AcctInf , Kpb ( CA ))) [action] (16) Know ( CA , e ( m , S ( H ( m ), Spv ( C )) , k 3 )) (17) Know ( CA , E ( k 3 , AcctInf , Kpb ( CA ))) (15)[R-1] (18) Know ( CA , m ) (16)(17)[2-3][3-2][3-1] (19) Know ( CA , S ( H ( m ), Spv ( C ))) (16)(17)[2-3][3-2][3-1] (20) Auth ( CA , C , m )
The last line, (20), implies two possibilities: one is that the message m does not include a timestamp and an identifier; thus, CA cannot authenticate C on message m for Theorem 1 and R-5; the other is that cardholder C generates new cryptographic message m for (R-I-4), even though CA weakly authenticates C on message m in greatly strengthens the verification and should be a compulsory supplement to NDL.
Compared with other logics, ENDL is more compatible for existing flaws in prac-strict authentication framework of ENDL helps us detect some subtle flaws that can be easily ignored in other logics. With these three instances, we can demonstrate that
ENDL is effective for verifying secure pr otocols. Example 1, derived from Needham during the communication, we have proved it has a flaw. Example 2 is drawn from
In our method, we detect a subtle flaw. The consequences are not serious since it is believes that it is C who thought C was talking to CA . Example 3 also comes from the cardholder registration of the SET protocol. By validating the certificate request cardholder registration.
E-commerce has played a very important role in global economic growth today. At
Gong et al. 1990), BGNY logic (Brackin 1996), and AUTLOG logic (Kessler et al. 1994). However, their abilities are still far from what people expect.
In this paper, we have presented a new logical framework, ENDL, for facilitating on dynamic and non-monotonic properties. ENDL presents more challenges than existing logics used in the analysis of secure transaction protocols. authentication under our framework, and therefore we can detect the defects of secure we can protect information against replays. Our proposed methodology satisfies the requirements of accumulation rules. To mak e it more reasonable and applicable, the terms of corresponding circumstances.
 Therefore, the ENDL framework is effective and promising.

