 Database mining has been a topic of research for quite some time [1-4]. Graph mining Subdue [5] is a mining approach that works directly on graph representation. Subdue identifies interesting and repetitive substructures within the structural data. the substructures. The major drawback of main memory algorithms is their scalability to larger problems. The DBMS version of Subdue is called DB-Subdue [7]. The input relational operations) for mining repetitive substructures. This paper extends the DB-Subdue (termed EDB-Subdue [8]). This paper proposes an approach to handle cycles and overlaps in a graph. This paper also addresses a new technique for evaluating the substructure among substructures of equal size and frequency. 
The rest of this paper is organized as follows. Section 2 discusses the related work been added to DB-Subdue. Section 4 presents performance evaluation including comparison with the Subdue algorithm. Section 5 has conclusions. Related work include AGM (Apriori-based Graph Mining) [9], gSpan (graph-based Substructure pattern mining) [10], FSG (Frequent SubGraph discovery) [11] and Subdue [5]. AGM is a mathematical graph theory based approach which mines a complete set of subgraphs mainly using support measure. gSpan is a depth first search occur frequently over the entire set of graphs. Also the scope of all the above frequent discovering frequent patterns in a large database of graphs. minimum description length principle (MDL) [6]. Although the MDL principle is other hand, DB-Subdue X  X  frequency heuristic scales well for large datasets. DB-Subdue cannot distinguish between substructures that have the same number of plays a vital role in distinguishing between two substructures with the same signature. For example, in the graph shown in Fig. 1, there are two substructures, each appearing twice in the graph.

Fig. 2 (graph1) and Fig. 3 (graph2) show two sub graphs with the same signature they have the same number of vertices and edges. The number of bits needed to encode Fig 1 is less than the bits required to encode Fig 2 . This is because for Fig 2 there is only one row in which there are 1s. But for Fug 3, both the first and second rows have 1s. As a result, two rows have to be represented in the second case whereas only one row has to be graph is compressed using the second substructure the MDL value obtained is 1.12849. Therefore, the MDL principle ranks graph1 higher than graph2 . DL (G|S), the better is the substructure. The DMDL principle uses this representation difference for distinguishing same signature substructures. The DMDL value is signature substructures. substructure S. Value(G) = graph_vertices + graph_edges Value(S) = sub_vertices + uniquesub_edges Value(G|S) = (graph_vertices  X  sub_vertices * count + count) + (graph_edges  X  sub_edges * count) 
Value (G) in the above formula represents the value of the entire graph. Value (S) represents the value of the substructure. Value (G|S) represents the compressed graph uniquesub_edges is calculated as the number of unique extensions in the substructure. connected within a substructure. For the graph in Fig. 2 the extensions are 1, 1, as the from the first vertex. Therefore the uniquesub_edges value is 1. The value 1 indicates for the substructure the same effect is obtained in the DMDL value. The DMDL value for the graph of Fig. 2 is 1.1481 and the value for graph of Fig. 3 is 1.1071. Hence, substructures with vertices having a higher out-degree are better substructures. algorithms. The main problem with the DB-Subdue algorithm is the fact that it loops within a cycle after detecting the same. In DB-Subdue, the substructure in Fig 4 will be extended to the substructure shown in Fig 5. However, this extended substructure does not exist in the input graph. Therefore this extension needs to be detected and avoided. This might also affect the best substructure that is discovered. Cycles are detected by checking if the vertex number of any vertex in the new substructure formed is already follows: appears twice. We need to eliminate expansion from the second occurrence of V j, as it is the repetition of a vertex already present in the substructure. This is done (by modifying the vertex number). This prevents expansion from the second occurrence of V j as its new value is not present in the input graph. The basic idea affected in any manner, as the main objective is to substitute the repeated vertex with a vertex not present in the input graph. For example, in Fig 4 and Fig 5, for the extension from 3  X  3, vertex 3 repeats again and the presence of a cycle can be deduced. As the cycle is now detected, extension from the second occurrence of vertex 3 should be prevented. This is achieved by changing the vertex number vertex in the input graph. already present in the substructure. If so, then the vertex number is changed to prevent future expansions from that vertex. overlap if they have a common substructure between them. 
We will first explain how overlap is avoided in a two-vertex substructure and then generalize it to higher-vertex overlap. An example of a two-edge substructure overlap that are overlapping and the overlapping substructure among them is  X  X D X . Since both the first and second vertex is overlapping, only one of the overlapping instances of the substructure must be considered for counting the number of instances of the substructure  X  X D X . This problem is solved by only counting one instance; the instance with the greatest third vertex value while the count is computed. In the example, the substructure  X  X DE X  will have count of one rather than two, as the substructure  X  X D X  is overlapping. greatest last vertex value is included for computing the count. In case of an overlap on the last vertex, each vertex is checked starting from the vertex previous to the last one overlapping instance that has the greatest non-overlapping vertex value is included for calculating the count. Therefore when overlap is avoided the count of the substructure as computed as follows: No. of instances of the substructure = No. of non-overlapping instances + one overlapping instance. This section discusses the performance comparison between Enhanced DB-Subdue and Subdue main memory algorithm for various datasets. We used Oracle 9i, running on Linux, and Intel Xeon dual processor with 2GB of RAM. The set of experiments only between Enhanced DB-Subdue and Subdue main memory, as DB-Subdue cannot handle cycles. The enhanced DB-Subdue includes all the additional functionality (DMDL, Cycles and overlap). As it can be seen from the comparisons, the Enhanced performed for a beam value of 7 and 10 respec tively. Fig. 9 clearly indicates that after incorporating all the features of Subdue into EDB-Subdue, it still outperforms Subdue. In addition, the main-memory Subdue would not handle data sets larger than 20K vertices and 40K edges (hence there are no performance values beyond 20K data sets) where as the EDB-Subdue could easily handle 800K vertices and 1600K edges. The graph is plotted on a log scale. overlapping substructures. All the enhancements were implemented using SQL. The experiments clearly demonstrate the scalability of the algorithm even after adding all the functionality. 
