 XML has become the de facto standard for information representation and ex-change over the Internet. XML data has hierarchical nesting structures. Al-though XML data is often modeled as a tree, IDREFs within the XML docu-ment represent additional  X  X eferencing X  relationships and are essential in some applications, e.g., to avoid redundancy and anomalies. Such XML data could be naturally modeled as a graph.
  X  One traditional method of processing queries on tree-structured XML data  X  Another query processing methods is based on structural index such as schemes and structural joins, in this paper, we adopt a similar approach deal-ing with query processing tasks for graph-structured XML data. We propose a reachability coding scheme for general digraph, which can be used to assist efficient reachability queries. In this coding scheme, all the strongly connected components of the digraph are contracted to single representative nodes such that the digraph is reduced to a DAG. Then a DAG labeling scheme is applied to the generated the code [15]. Based on the the features of the coding scheme, we design the efficient structural join algorithms, Graph-Merge-Join (GMJ) and its improved version Improved-Graph-Merge-Join (IGMJ). They can be viewed as the natural generalizations of the tree-merge and stack-tree algorithms [2] for the graph-structured XML data.
  X  We generalize the coding scheme in [15] and present an effective coding  X  We present two efficient structural join algorithms, GMJ and IGMJ, based  X  Our experiments show that our coding scheme is efficient for XMark data. background knowledge and notations used in the paper. Section 3 presents the reachability coding scheme. Structural join algorithms based on the coding scheme are given in Section 4. We present our experiment evaluation results and analysis in Section 5. Related work is described in Section 6. We conclude the paper in Section 7. In this section, we briefly introduce graph-structured XML data model as well as terms and notations used in this paper.
 mapped into nodes of graph; directed nesting relationships are mapped into edges in the tree. A feature of XML is that from two elements in XML document, there may be a IDREF representing reference relationships [18]. With this feature, XML data can be modeled as a labeled directed graph (digraph): elements and attributes are mapped into nodes of graph; directed nesting and referencing relationships are mapped into directed edges in the graph. An example XML document is shown in Fig 1(a). It can be modeled as the digraph shown in Figure 1(b). Note that the graph in Figure 1(b) is not a DAG.
 and allow retrieving part of the XML document by the structural constraints. For example, the XPath query b//e will retrieve all e elements nested within b elements ( // represents the ancestor-descendant relationship). In the example XML document in Figure 1(a), the query result is empty. However, when we model XML document as a graph, the ancestor-descendant relationship (as well as parent-child relationship) can be extended based on the notion of reachability. In [12], IDREF edges are represented as  X  and  X  1 for the forward and backward edge 2 , respectively. Two nodes, u and v belong to a graph G satisfy reachability relationship if and only there is a path from u to v in G (denoted as u v ). Each edge in this path can be either an edge representing nesting relationship or referencing relationship. For example, the query b e will return e 1 ,e 2, and e 3 for the example XML data graph in Figure 1(b). Such queries are referred to as reachability queries in the rest of the paper. In this section, we describe the coding scheme of graph-structured XML doc-ument. We extend the coding scheme for directed acyclic graph (DAG) in [15] to support directed cyclic digraph. Therefore, with this coding, the reachability relationship between two nodes in a general digraph can be judged efficiently without accessing any other node. 3.1 The Coding of DAGs In this subsection, we encode DAG using the method introduced in [15]. In this coding scheme, each node is assigned a list of intervals. We briefly summarize the encoding method for a DAG G in the following: First, find an optimal tree-cover T of the DAG D . T is traversed in a depth-first manner. During the traversal, an interval [ x, y ] is assigned each node n of T , where x is the postorder of n in the traversal. y is the smallest postorder number of all n  X  X  descendants in T . Next, examine all the nodes of D in the reverse topological order. At each node n , copy and merge, if possible, all the intervals of its out-going nodes in G to its code .
 to check whether the postorder of b is contained in one of the intervals of a . DAG in Fig 2(a) is the in Fig 2(b). We use postid to denote the postorder number of each nodes, which is also the second value of the first interval of its code. 3.2 The Coding of General Graph We now generalize the above scheme for the case of a directed cyclic graph. We assume that the graph consists of only one connected component with a single root. The root is a node without any incoming edge. Otherwise, we can pick up any root node or add a virtual root node.
 1. Find all Maximal Strongly Connected Components (MSCC) with number 2. Each MSCC of G is contracted to a representative node . As a result G is re-3. G is encoded using the method introduced in Section 3.1. 4. For each node S in G , assuming its code is C s , C s is assigned to every to encode G , the first step is to contract all the maximal strongly connected components. In G , there is only one such MSCC, S = { d 3 ,c 1 ,e 1 ,e 2 ,e 3 } .By contracting this MSCC, a DAG G shown in Figure 1(b) is generated. In G , R is the representative node for MSCC S . The interval codes of G is shown in Figure 2(b). At last, the intervals associated with R , i.e., [0 , 3], is assigned to eachnodein S in G . As a result, d 3, c 1, e 1, e 2, e 3 all have the same interval code [0 , 3]. The interval codes of graph G is shown in Figure 2(c). The postid of each node is the second value of its first interval. For example, d 3 .postid is 3. the interest of space, we don X  X  show the proofs of the theorems.
 Theorem 1. A directed cyclic graph G is converted to a DAG in the way stated above.
 Theorem 2. For two nodes a and b of XML graph encoded in steps stated, sup-the tree cover T of G generated from G by contracting MSCCs, respectively. Then a b if and only if  X  i (0  X  i  X  n ) such that a i .x  X  postid b  X  a i .y . Time Complexity Analysis. The finding of all MSCCs can leverage the DFS-based algorithm in [1], and its time complexity is O ( n ), where n is the number of the nodes of G . The efficiency of contracting step is O ( n c ), where n c is the total number of nodes belonging to the MSCCs. The complex of encoding a DAG is O ( n ) [15], where n is the number of nodes in the DAG. The last step needs O ( n c ) time. Since both n c and n are smaller than n , the time complexity of encoding method is O ( n ). In this section, we design two join-based algorithms to process reachability query on graph-structured XML data using the labeling scheme presented in Section 3. The structural join algorithms compute the result of reachability query a d , where a  X  Alist and d  X  Dlist are element sets. 4.1 Preprocess of the Input One difference of the interval labeling scheme of a graph and that of a tree is that there may be more than one interval assigned to a node. The reachability relationship of two nodes a and b can be judged based on Theorem 2. We choose to preprocess the joining nodes by inverting the nodes and their corresponding interval codes. That is, if a node has k intervals, it is treated as k nodes: for Alist, each element has one interval; for Dlist, each element has a postid and the id of this element. Then both inputs are inverted: for the Alist, the list is sorted on the intervals [ x, y ] by the ascending order of x and then the descending order of y ; for the Dlist, the list is sorted by the ascending order of postid . The intuition is to leverage the order in the intervals and postid s to accelerate join processing.
 Alist, for one of the following two reasons:  X  All the nodes with the same tag in an MSCC have the same codes, hence  X  Even if two nodes does not belong to the same MSCC, there could be some Similar case exists in Dlist as well because all nodes in the same MSCC have the same postid .
 repeated intervals with different node IDs are merged into one interval with multiple node IDs. Repeated postid s in Dlist are also merged in a similar way. the XML document shown in Figure 2(c), Alist is { d 1([0 , 1]) ,d 2([0 , 0] , [0 , 2]) , is in the brackets following the node. After preproocessing, the Alist becomes { processed Alist and Dlist are sorted by the codes (intervals and postid s, re-spectively). The nodes corresponds to an interval i (or postid ) is in the bracket followed the interval (or the postid ). In Alist, the intervals associated to d 2 are separated. In Dlist, since e 1 ,e 2 ,e 3 have the same postid, they are merged into the same postid . 4.2 Two Join Algorithms After preprocessing, a na  X   X ve structural algorithm can be obtained by generalizing the sort-merge based structural join algorithm in [2]. One subtlety is that the intervals in the preprocessing Alist might have the same starting or ending values (i.e., x or y ). The codes shown in Figure 2(c) is such an example. We present the merge based join algorithm on graph, named Graph-Merge Join (GMJ), in Algorithm 1.
 Algorithm 1 GMJ( Alist , Dlist )  X  Alist: a 1([1 , 3]) ,a 2([1 , 1]) ,a 3([3 , 6]) ,a 4([4 , 5]) ,  X  Dlist: d 1(1) ,d 2(4) ,d 3(7) In GMJ, the basic idea is to join intervals and postid s in a sort-merge fashion. Since intervals might be nested, a bookmark is needed to keep track of the current position of intervals while outputting results. In the example, the pointer of Alist, i.e., a , points to a 1. d 1 joins a 1 and a 2. When processing d 2, the pointer of Alist moves to a 3. d 2 join with a 3 and a 4. When processing d 3, the pointer moves to the tail of Alist, so the algorithm terminates. the input might be scanned repeatedly. We note that stack-based structural join algorithm in [2] cannot be directly generalized and work with our coding scheme. This is because that two intervals may be partially overlapped. For an example, a graph and its codes is shown in Figure 3. The intervals assigned to a 2 and a 4 are partially overlapping. As a result, stacks can no longer be used to represent the nesting relationship between intervals in our coding scheme.
 Algorithm 2 IGMJ( Alist , Dlist ) instead. The basic idea of GRJ is to store the intervals that can be joined in a range search tree (RST for brief). In the tree, the intervals indexed and organized according to their y values. When a new interval a of Alist arrives, it is compared with the current node d of Dlist. If a contains the postorder of d , a is inserted to the tree and all elements in the tree with y value smaller than a.x are deleted (via the trim () method). Otherwise, we process current node d in Dlist. All elements in the tree with y value smaller than d.postid are deleted. Then output d with all the a nodes in the tree. The algorithm of IGMJ is shown in Algorithm 2. In this algorithm, brtree is a RST that supports the following methods: insert ( I ) and trim ( v ). insert ( I ) will insert an interval I to the BRST; trim ( v ) will batch delete the intervals in brtree whose y values smaller than v .
 values of a 1 and a 2 are smaller than d 1 .postid . At first, a 1 and a 2 are inserted into the RST. Then, ( d 1 ,a 1) and ( d 1 ,a 2 ) are appended to the result list. a 3 and a 4 are processed before d 2 3 . They are inserted to RST. When a 3 is processed, a 2 is trimmed from the RST because a 2 .y &lt; a 3 .x . a 1 is trimmed from RST appended to the result list. a 3 and a 4 are trimmed from RST based on d 3. In this section, we present results and analyses of part of our extensive experi-ments of the new coding scheme and the structural join algorithms. 5.1 Experimental Setup All our experiments were performed on a PC with Pentium 1GHz CPU, 256M main memory and 30G IDE hard disk. The OS is Windows 2000 Professional. We implemented the encoding of graph, the Graph-Merge-Join ( GMJ ) and Improved-Graph-Merge-Join ( IGMJ ) using the file system as the storage engine. For comparison, we also implemented a na  X   X ve traversal-based query processing algorithm based on the 1-index [14] ( 1-index ).
 quently used dataset and features irregular schema. We measure the performance of different algorithms on the 20M XMark dataset (with scale factor 0.2). It has 351241 nodes and its 1-index has 161679 nodes. We generated other XMark datasets with sizes 10M, 20M, 30M, 40M, and 50M respectively. They are used in the scalability experiment.
 different characteristics in terms of the sizes of Alist, Dlist, and result (based on the 20M XMark dataset).
 5.2 Space Overhead of the Coding We measure the space overhead of our coding scheme with the following two parameters: The former measurement represents the average number of intervals associated to one node. The later measurement represents the average number of intervals associated with one node that will be processed during structural join. This is because some nodes in the interval sets may share the same interval. It can be observed from the result that even though the average number of intervals of a node is larger than one, the average number of intervals after preprocessing are smaller. This shows that the preprocessing of the Alist and Dlist in join is meaningful by exploiting the sharing of intervals and postid s, respectively. 5.3 Execution Time We show in Figure 4(a) the execution time of GMJ, IGMJ, and 1-index for Q1 to Q4 on the 20M XMark dataset. Note that Y-axis is in logarithm scale. Both GMJ and IGMJ outperform 1-index. This is because there are many nodes in 1-index. During processing the query with form  X  X //b X , when a node a 1 with tag a is found, all the nodes in the subgraph formed with nodes that are reachable from a 1 need to be traversed. We also found that IGMJ is always faster than GMJ. It is because with the usage of RST, whenever an interval will not join with any d in the Dlist, it will be trimmed from the RST. 5.4 Scalability Experiment To evaluate the scalability of the new algorithms, We ran Q1 on XMark docu-ments with size ranging from 10M to 50M. The result is shown in Fig 4(b). It can be seen that both algorithms scale linearly with the increase of the data size. There are many reachability labeling schemes for trees. Recent work includes [3, 8, 11]. Reachability labeling schema schemes for directed acyclic graphs (DAGs) includes [15, 22]. [6] is a survey of labeling schemes for DAGs and compares several labeling schemes in the context of semantic web applications. [10] presents a reachability coding for a special kind of graph, which is defined as planar-st in [17]. Based on this coding, [19] presents a twig query processing method. [17] extends this coding scheme to spherical st-graph. Note that both  X  X lanar st X  and  X  X pherical st X  are strong conditions. To the best of our knowledge, there is no direct generalization of the above two labeling schemes to support general digraph. a node could be O ( n ). This might add to much overhead for the query processing for graph-structured XML data.
 based approaches. Structural join is such an operator and its efficient evaluation algorithms have been extensively studied in [2, 21, 13, 8, 5, 9, 20]. They are all based on coding schemes that enable efficient checking of structural relationship of any two nodes in a tree, and thus cannot be applied to the graph-structural XML data directly. In this paper, we present a labeling scheme for graph-structured XML data. With such labelling scheme, the reachability relationship between two nodes in a graph can be judged efficiently. Based on the labeling scheme, we design efficient structural join algorithms for graph-structured XML, GMJ and IGMJ. Our experiments show that the labeling scheme has acceptable size while the proposed structural join algorithms outperform previous algorithms significantly. As one of our future work, we will design efficient index structure based on the labeling scheme to accelerate query processing.
