 1. Introduction
In today X  X  networked society, more and more companies collaborate with each other in a virtual way through the internet. Each partner in such a collaboration network has its own private business process. Coor-dination of these local business processes takes place through the network. However, process-oriented collab-oration in a network can only occur if partners reveal some details of their business processes to the network.
These revealed details can be captured in an external or public view on the private business process [15] .A public view is like a window through which the network can monitor the operation of an underlying private business process of a partner.

Now, for each partner providing a process to the network, there is a trade off in the level of detail shown in which might prevent an effective operation of the network. For example, if some partner responsible for pro-ducing a customer made component does not reveal any details of its internal production process, the main contractor cannot monitor the progress at the partner X  X  site and therefore cannot coordinate the overall networked production process in a proper way. On the other hand, if the process view reveals all private ners might copy then its way of working, turning from collaborators into competitors.

Moreover, other partners in the network might not be interested in every detail of the private provider pro-cess. Some details may be irrelevant for them or simply be noise in the business relationship. In the example of the production network given above, the main contractor is likely not interested in detailed information about the production process, but only in high-level status information. Thus, process views need to be customized to the needs of the partners, called the consumers.

This paper proposes a formal approach to construct a customized process view on a business process. The approach consists of two main phases. In the first phase, to ensure privacy and to protect ownership, a process
Such process views are non-customized, so independent from the requirements of any specific consumer. In the second phase, to filter out unwanted process information, a consumer constructs a customized process view, vider and the second phase from the consumer, the actual construction of the views in both phases is done fully automatically. The two-phase approach supports the interests of both providers and consumers. We now explain these two phases, aggregation and customization, in more detail, using the example in
Fig. 1 . The internal, private process model is shown on the bottom while the customized process view is shown and D , indicated with a double line. Next, the aggregate activity is constructed. This aggregate contains the sistent with the underlying process model. In the non-customized process view in Fig. 1 , activity C has been added to the aggregate BCD . We define the procedure for constructing aggregate activities both declaratively (by construction rules) and operationally (by algorithms) and show the equivalence of both definitions. The declarative definition is useful to explain computed aggregates to end users, while the operational definition is more easy to implement. Finally, an external process view is constructed by replacing the aggregated activ-ities with the aggregate. These steps can be repeatedly applied (not shown in the figure).
In the second phase, a consumer selects a set of activities that it wishes to see from the non-customized pro-tomized process view containing these activities is constructed. All the other activities of the non-customized process view are either hidden or omitted in the customized view. In the customized view in Fig. 1 , unselected activities BCD and E of the non-customized view are hidden by abstract activity BCDE . Fig. 1 illustrates the difference between the two phases. In the first phase, selected activities are aggregated, while in the second phase the unselected activities are hidden or omitted. Though this difference may seem small, it leads to com-pletely different formal definitions, as shown in Sections 3 and 4 .

Consumers can select the activities to be shown in the customized view by referring to organization-inde-pendent activities, which could come for example from industry standards like SCOR [31] or RosettaNet [29] .
Providers can implement their own variant of such standard activities. To capture this, we use an inheritance relation on activities, to indicate that an activity at a company side inherits from (or implements) an abstract activity defined by an industry standard. For example, a consumer can request compound RosettaNet activity The customized process view would then show Request shipping order cancellation instead of Cancel order .
Using this inheritance-based approach, adherence to reference models is easily obtainable. In practice, this approach can be realized using ontologies [4] .

In the remainder of this paper, we focus on block-structured process models [12,20,23] , or structured pro-cess models for short. In such models, each block has a unique entry and a unique exit point, and blocks are gram. Many existing process description languages, including industry standard BPEL [2] and OWL-S [24] , are structured into blocks. We show that the block-structure allows for a simple and efficient (tractable) pro-cedure for constructing customized views. Block-structured process models have the advantage that they do immediately followed by an AND join. However, some error-free processes cannot be easily modelled in a block-structured way. Extending the approach to unstructured, error-free process models is part of future work.

In sum, the main contribution of the paper is the definition of an approach that helps process providers and consumers to construct tailored process views on private processes in an efficient way, taking process stan-dards into account. Providers can construct process views by hiding those parts of their business processes that have to remain secret. Consumers can construct customized process views by hiding or omitting irrelevant parts of process views offered by the providers. This allows an efficient setup of dynamic business-to-business collaborations with a strong process-orientation [13] . Examples of such collaborations are virtual enterprises industrial networks [9] .
 Structure. The remainder of this paper is organized as follows. Section 2 defines structured process models.
Section 3 defines the first phase of the approach: how a non-customized view can be derived from a concep-tual-level process, given a set of nodes to be aggregated. The construction procedure defines which nodes, next to the given nodes, need to be aggregated in order to get a process view that is consistent with the conceptual process. The construction procedure is defined both declaratively (by construction rules) and operationally (by algorithms) and the equivalence of both definitions is shown. Section 4 defines the second phase of the approach: how, given a set of abstract activities that a consumer wants to be visible, a process view can be customized to show only the relevant activities in full detail. The constructed customized view will contain concrete activities that are specializations of the abstract activities. As a case study, Section 5 applies our approach to the CrossWork project [17] . First, the CrossWork architecture is extended to support the approach and next the approach is illustrated with a CrossWork business scenario. Section 6 discusses related work. Section 7 wraps up with conclusions and further work. 2. Preliminaries
We first define structured process models and then present an inheritance relation on activities. We also give some auxiliary definitions that we use in Section 3 .
 2.1. Structured process models
Syntax. A process model specifies how a given set Act of activities (atomic unit of works) are ordered. The used ordering constructs are sequence, choice, parallelism, and structured loop. To simplify the exposition, we abstract from data.
 Let P denote the set of all structured process models. A structured process model P 2 ( A , N , child , type , label ) where  X  A Act is a set of activities.  X  N is a set of nodes. (sub) node of n 0 .  X  type : N ! { SEQ , PAR , XOR , LOOP , BASIC } is a function that assigns to each node its type. Type SEQ indicates that all children of the node execute in sequence, PAR that they execute in parallel, XOR that one of them is executed at a time, and LOOP that the children execute zero or more times. We require that each SEQ , XOR ,and PAR node has more than one child and that each LOOP node has only a single child, which is no LOOP node. A node has type BASIC if and only if it is a leaf node, i.e. it has no children. ferent nodes. The s symbol is used to denote an aggregate activity, i.e., an activity in a process view that aggregates activities from a lower level. 1
We use an auxiliary function children : N ! P N that defines for each node its set of child nodes. For a leaf node, this set is empty. The definition of children makes use of predicate child :
If c 2 children ( n ), node n is parent of c , written parent ( c ). By children transitive closure and reflexive-transitive closure of children , respectively. So children * ( n )= children
If n 2 children * ( n 0 ), we say that n is a descendant of n ancestor and descendant of itself.

To ensure that the child predicate indeed arranges nodes in a hierarchy, we require that each node has one parent, except one node r , which has no parent. Next, we require that r is ancestor of every node in N . These nal nodes have type SEQ , PAR , XOR ,or LOOP .

To indicate the ordering of children of nodes of type SEQ , we use a partial function rank : N ! N . The ranks of two nodes are only compared if the nodes share the same parent that has type SEQ . We require that two different nodes with the same parent have different ranks, and that for a node n with l children, for any to indicate the unique child c of n for which rank ( c )= i .
 In the remainder of this paper, we will show structured process models graphically, using a variant of the
UML activity diagram notation [32] . Fig. 2 shows the business process of a logistics organization that delivers cellular phones (GSM phones) from a warehouse to a customer. We use node containment to indicate hier-archy. The root node is never shown. Sequence nodes have an incoming and outgoing arrow crossing their border, whereas choice and parallel nodes have a diamond and bar, respectively, on their border. Within a sequence node, the ordering relation is specified by means of arrows. Loop nodes have no dedicated symbol, but are indicated by drawing a self edge for the unique child of the loop node. For example, in Fig. 2 node Pick
GSM from stock is child of a loop node. To distinguish nodes from activities, in the remainder nodes are writ-example that the activity has the same name as the corresponding node.
Least common ancestors. To define the construction of process views in Section 3 , we will make use of some auxiliary functions on the syntax of structured process models. The definitions are inspired by formal state-chart semantics [18,28] .
 tor of each node in X , and every other node y that is ancestor of each node in X , is ancestor of x :  X  X children * ( x ), and  X  For every y 2 N such that X children * ( y ), we have that x 2 children * ( y ).
 Since nodes are arranged in a tree, every set of nodes has a unique least common ancestor. For example, in parcel is Deliver parcel . Note that the lca of a single node is the node itself, i.e. lca ({ x }) = x .
Before relation. The before relation &lt; denotes temporal ordering. Given two nodes n , n before n 0 , written n &lt; n 0 , if and only if  X  node l = lca ({ n , n 0 }) has type SEQ , and  X  for the children c n ; c n 0 of l such that n is descendant of c rank  X  c n  X  &lt; rank  X  c n 0  X  .
 For example, in Fig. 2 we have Determine region &lt; Deliver express .

Orthogonal relation. Given two nodes n , n 0 2 N , we have n orthogonal to n child, if n ? n 0 then their lca is either a PAR or a XOR node. For example, in Fig. 2 we have Deliver regu-lar ? Deliver express . 2.2. Inheritance of activities Above we introduced a set Act of activities. Let 6 Act  X  Act be an inheritance relation on activities.
Given a , a 0 2 Act ,if a 6 a 0 than a is more specific than a a . For example, activity Handover parcel from Fig. 2 inherits from SCOR [31] activity Receive and Verify
Product at Customer Site . Relation 6 is a partial order, so if a 6 b and b 6 a then a = b . We allow multiple inheritance, so it might be that a 6 b and a 6 c yet b and c are incomparable, so b i c and c i b . For exam-ple, in SCOR [31] we have that activity Enable return is a specialization of both Enable and Return , but these inherit indirectly from itself. 3. Aggregation
This section defines the first phase of our approach: how process views can be constructed from structured process models using aggregation. First, we define how a given set of nodes from the process model can be aggregated in a correct way into a single node in the process view. Second, we define how, given a computed aggregate and a structured process model, a structured process view can be derived. These two steps can be 3.1. Constructing aggregates
An aggregate is a set of nodes from the process model that is represented in the process view by a single node n , i.e. node n hides the nodes contained in the aggregate. The user must specify which set of nodes has to be aggregated. However, the aggregate might need to contain some additional nodes as well, in order to get a process view that is consistent with the underlying process model. The view and the process model are consistent if the orderings of the process model are respected by the view and no additional orderings are structed aggregated. Next, we define an algorithm for constructing aggregates. We show that both definitions are equivalent. 3.1.1. Construction rules
Let X be the set of conceptual-level nodes that have to be aggregated. Denote by agg ( X ) the set of nodes that the aggregate constructed for X should contain in order to derive a process view consistent with the underlying process model.
 Rule 1 specifies the natural constraint that all nodes of X should be in agg ( X ):
The other rules are defined to ensure that after constructing the aggregate, the resulting process view is con-sistent with the underlying structured process model.

Rule 2 states that if two nodes x , y are aggregated such x is before y , then every intermediary node i ,so the aggregate will not be atomic anymore in the process view. Then the aggregate will be on the one hand and D without aggregating C would result in a view in which the aggregate is before and after C . Thus, a loop
Rule 3 states that if a composite node is included in the aggregate, all its children are included as well. This ensures that in the process view aggregates have no children, i.e. no internal details of the aggregate are revealed. For example, if in Fig. 4 node X is to be aggregated, then B and C must be aggregated as well. Other-wise, the process view would be the same as the original process, with X replaced by s .

Rule 4 requires that if a node is in the aggregate and its parent is a strict descendant of lca ( X ), so cess views. For example, Fig. 5 shows a view constructed by aggregating A and B without aggregating X ,even before X , in the view AB is before X . Since X contains AB , then there is a self loop for X . This loop is not present in the original process model, so the view is not consistent.

To see why the parent node needs to be a strict descendant of lca ( X ), rather than a descendant, consider the in that case the parallel branch Y would be aggregated as well. As the view shows, however, that branch can still be exposed.

Minimal aggregates. Note that for a given set X of nodes to be aggregated in a structured process model P , there can be multiple sets which satisfy the construction rules. We formally define the notion of a minimal aggregate, which is the minimal set satisfying the four construction rules. Given a set X of nodes to be aggre- X  X S  X  if x , y 2 S and i 2 N such that x &lt; i &lt; y then i 2 S  X  if x 2 S then children ( x ) S  X  if x 2 S and parent ( x ) 2 children + ( lca ( X )) then parent ( x ) 2 S
This declarative definition suggests an iterative algorithm for computing the minimal aggregate for a set of rules. Since rule violations can be checked in linear-time and the number of iterations is bounded by the num-computing minimal aggregates. 3.1.2. Algorithm
The algorithm A GGREGATE for constructing an aggregate is listed in Fig. 7 . It expects a structured process model P and a set X of nodes to be aggregated, and returns an aggregate.

The algorithm first computes the least common ancestor l of the set X of nodes to be aggregated. If l 2 X
X are put in set C (l.6). Next, the set of all descendant of nodes in C are put in aggC (l.7). These descendants are to be contained in the aggregate by Rule 3 and Rule 4.

Next, the type of l is tested (l.8): n if and only if there are children c 1 , c 2 2 C such that c put in aggC 0 (l.10). All descendants of these intermediate children of n must be contained in the aggregate by Rule 2 and Rule 3. The aggregate is therefore the union of sets aggC and aggC  X  If l has type PAR or XOR , then the aggregate only contains all descendants of C (l.13). Finally, the constructed aggregate is returned (l.16).

Note that computing the least common ancestor can be done in linear time [19] . Using this observation, it is easy to see that the algorithm runs in O( j N j ) time.

The correctness of the algorithm is shown by the following theorem, which states that the algorithm yields a minimal aggregate that satisfies all four construction rules. The proof is in the Appendix . min agg  X  P ; X  X  X  A ggregate  X  P ; X  X  .
 3.2. Extension
Sometimes, this can lead to process views which are correct, but counter intuitive. For example, aggregating B as well.
 gate, node lca ( X ) itself should be included as well.

The algorithm needs to be modified slightly to take into account this new construction rule. Between lines 14 and 15, the following lines needs to be inserted: if children ( l ) agg then end if
The theorem of the previous subsection can be easily extended to deal with this new construction rule and the modified algorithm. 3.3. Generating process views
Above, we have outlined a declarative and operational approach for constructing an aggregate, which is a set of nodes that have be represented by a single node in the process view. Now we define a function gen :  X  P P N  X ! P that generates from a given structured process model and an aggregate the resulting pro-cess view, which is again a structured process model. If there are multiple aggregates, the function can be repeatedly applied.
 cess model P 0 = gen ( P , agg ) is constructed by replacing agg with a new node n children in the process view P 0 and gets label s .

Now the problem is that the new node n agg needs to be attached as child to some node N n agg , i.e., some node l 2 N n agg has to act as parent of n agg in the process view P ancestor (in P ) of all nodes in agg .So agg children * ( l ) and for every other node l exists and is unique. Therefore, l can be the unique parent of n Formally, P 0 =( A 0 , N 0 , child 0 , type 0 , label 0 ) where  X  A 0 ={ y j ( x , y ) 2 label 0 }  X  N 0 = N n agg [ { n agg }  X  child 0 =( child \ ( N 0  X  N 0 )) [ {( n agg , l )}  X  type 0 = type \ ( N 0  X  { SEQ , PAR , XOR , BASIC }) [ {( n  X  label 0 =( label \ ( N 0  X  A )) [ {( n agg , s )}
Instead of labeling the new aggregate node with s , the user (provider) can also decide to create a new activ-ity. In the examples shown in this section, each aggregate of a consistent process view was labelled with a new activity, rather than s .

Fig. 9 shows the process view for Fig. 2 if Determine region and Deliver express are selected for aggregation. 4. Customization This section defines the second phase of our approach: how constructed process views can be customized.
Input is a process view P 2 P plus a set I of activities which the consumer wishes to be visible for monitoring such that one is descendant of the other. Output is a customized view, which is again a structured process model P 0 2 P .In P 0 irrelevant parts of P with respect to I are omitted or hidden by aggregation. A part is irrelevant if none of the contained nodes executes an activity that implements some activity in I . Not every activity i 2 I needs to be implemented in P 0 . However, the approach can be easily modified and extended to deal with additional constraints on, for example, the presence of activity implementations in the customized view.
 We define the customization algorithm declaratively as a function, customize :  X  transforms a structured process model P and a given set I of activities into a structured process model custom-ize ( P , I )= P 0 . We now define the individual components of P model P =( A , N , child , type , label ).
 in the new labeling function label 0 , which is defined later:
Before we define N 0 , we provide some terminology. A node n is relevant if one of its descendant nodes is la-belled with an activity that implements an activity i 2 I : For example, for Fig. 2 ,if I ={ Determine Transport } then among others node Deliver parcel is relevant.
When customizing a process view, we have to ensure that each relevant node in the process view occurs in the customized view, since the external party wishes to monitor relevant nodes. So all relevant nodes of P should be in P 0 . The set of relevant nodes in the customized view is defined as irrelevant nodes in N . These abstract nodes are needed in P BCDE would result in an invalid process view.

An abstract node only has to be created to hide the irrelevant children of a compound node that also has relevant children. For example, in Fig. 1 the abstract node BCDE is created for compound node root r , which the customized view. If a relevant node has only relevant children, all these children are shown in the custom-ized view. So in these last two cases, an abstract child node is not needed.

The predicate relevant _ compound formally defines for which compound nodes of N an abstract child node needs to be created: Note that relevant _ compound ( n , I ) is true implies n is compound, since only compound nodes have children.
We now define per type t of compound nodes, which concrete nodes of this particular type get a new abstract child in the customized view to hide irrelevant children from the input model. These newly created by n t 2 N 0 t a new (fresh) abstract node, so n t 6 2 N . In the customized view, n n . However, not every relevant compound node n needs such a node n child nodes of a relevant compound node can also be completely omitted, rather than being represented by some abstract node.

Before we define N 0 XOR , we observe that omitting irrelevant children from a relevant XOR node can result in a model with illegal states. For example, suppose for Fig. 2 the external party wishes to monitor node Deliver view, say Other delivery , i.e., non-express delivery. Therefore, for each relevant XOR node n a new abstract node n xor is created, which leads to the following definition of N
The parents of the newly created nodes in N 0 XOR are defined below by the child For a relevant PAR node, in principle both abstraction and omission of irrelevant children are possible. Omission is possible because the execution states are still well defined through the children that are relevant. the customized view. For example, if in Fig. 2 the consumer wishes to monitor activity Determine transport , node Determine region can be safely omitted, because the execution state is well defined through Determine transport . Consequently, each relevant PAR node does not need an abstract child node in the customized view, and therefore set N 0 PAR is empty:
For sequential nodes, the situation is more complex. Given a relevant sequential node, omission of its irrele-cannot be grouped into one node, since there might be an intermediate relevant child. Thus, only irrelevant children which are not interrupted by relevant children can be grouped (see Fig. 10 ). For each SEQ node n , we therefore create for each maximal interval ( i , j ) of irrelevant children an abstract node n last node of n ,so j = j children ( n ) j 1, or rank ( n , j + 1) is relevant.

The set N 0 SEQ of abstract child nodes created to hide irrelevant children of SEQ nodes in the customized view is therefore defined as: the top-level of the process, they can be omitted.

Since a LOOP node n has a single child, we have relevant _ compound ( n , I ). Thus, a LOOP node has does not have an aggregate child in the customized view, and therefore set N We now define N 0 as the union of N 0 rel plus the sets containing all new abstract nodes:
Next, we have to define the remaining three predicates and functions. Predicate child child to relevant nodes in N 0 rel and adding for each XOR and SEQ node the constructed aggregate child nodes:
Function type 0 is defined to be the same as type for relevant nodes. Constructed abstract nodes have no chil-dren, so they are BASIC .
 structed abstract nodes have no visible activity, i.e. they are labelled s . Alternatively, the user (consumer) can create a new activity for a new abstract node.
Finally, we illustrate the customization algorithm by means of an example. If the process view in Fig. 9 is cus-tomized for activities Get GSM and Hand over parcel , the customized view shown in Fig. 11 is obtained. The label HIDDEN stands for s . Note that Get GSM serialnr and Wrap up parcel have been merged into one ab-stract node in the customized view. 5. Case study In this section, we show the feasibility of the approach presented in this paper by applying it to the Cross-Work project [9] , which developed IT support for the dynamic formation and enactment of Networks of
Automotive Excellence. Each network consists of a number of suppliers of moderate size. Together, the sup-pliers form a network (virtual enterprise) that can deliver to an Original Equipment Manufacturer (OEM) like BMW or MAN. First, we show how the approach can be architecturally supported by extending the Cross-
Work architecture [17] . Next, we illustrate the approach on a CrossWork business scenario. 5.1. Architecture Fig. 12 shows the basic CrossWork architecture (solid lines) plus the extension (dashed lines). The basic
CrossWork system starts with the activating goal decomposition module, which takes an order specification from an OEM and decomposes it into a required set of components and services, using a product knowledge base. Next, the team formation module finds for each identified component and service a partner using market and infrastructure knowledge bases [6] . The market knowledge base stores per organization the services and components it delivers and which activities it offers, while the infrastructure knowledge base stores informa-tion about the legacy systems of organizations. The team formation module composes the retrieved partners into a team that can cooperate according to the market and infrastructure knowledge bases. Then the work-flow composition module queries the team members for their local workflow models (not shown) and com-poses these into a global workflow model. The global workflow coordinates the local workflows of the team partners. The ordering constructs used to compose the local workflows are based on workflow patterns [1] . This constructed global workflow model can be verified and validated. Finally, the global workflow model can be enacted using BPEL [2] .

To support the construction of customized views, the CrossWork architecture is extended as follows. The market knowledge base stores for each organization which organization-independent (e.g. SCOR [31] , Roset-private repository and can construct process views using the aggregator module. The constructed views can be stored locally at each provider X  X  site or in a public repository. The workflow composition module can retrieve these constructed views as input by querying the team partners or searching the repository. Before the composition is started, however, the process views can be customized using a list of organization-indepen-dent activities that the team is supposed to implement. This list is provided by the team formation module.
Then, the workflow composition module can compose the customized views into a global workflow. To sup-port the enactment of the local views, also extensions are needed but these are outside the scope of this paper. 5.2. Watertank scenario
We now apply the approach to a real-life business scenario from CrossWork [10] . A truck manufacturer wishes to outsource production of a watertank component to a Network of Automotive Excellence, consisting of suppliers. Each supplier offers a local workflow as a black-box service to the network. The offered services for producing the watertank are composed into a global process using the workflow composition module [12] . Fig. 13 shows the composed global process that coordinates the black-box services of the suppliers.
Since the OEM wishes to track progress of the outsourced production process, a customized process view is constructed using the two-step approach. In the first step, the NoAE decides that the services for assembly and the non-customized process view shown in Fig. 14 . In the second step, the truck manufacturer decides that this 6. Related work
The most relevant work related to ours is that by Liu and Shen [21,22] .In [21] , they focus on deriving a process view from a given structured process definition. They concentrate too on defining for a structured con-activities (called essential). However, these activities must be basic, so they cannot contain other activities.
They define rules on aggregates to ensure consistency between an external process view and a conceptual pro-that appear in the process view. The ordering of these virtual activities in the view can be inferred from the underlying process model. Next, they show that some consistency requirements between the process view and the original process hold. This work is extended in [22] by considering data flow as well.
This paper improves and extends the work of Liu and Shen [21] in several ways. Basically, their work coin-cides with our first phase. However, our formalization of structured process models is much more simple than their consistency rules for models containing loops are quite complex, and their algorithm has a high complex-ity (they do not estimate its complexity, but due to nested loops the time complexity of their algorithm is at least quadratic in the number of nodes). Next, we support the aggregation of composite nodes, while they only focus on aggregation of activities which have no subactivities. In addition to improving their work, we extend their work by allowing views to be customized. Customization involves inheritance of activities and omission of activities, something which is not considered by Liu and Shen. To simplify the exposition, we have ignored data flow, but it can be incorporated along similar lines as described in [22] .

Chiu et al. [8] use process views to support interoperability of multiple workflows across organizations. They present a meta model and an interoperation model for workflow views, consisting of communication scenarios between these views, and a set of interoperation parameters. Consistency constraints are described to ensure that a workflow view is consistent with its underlying workflow, and that the communication between workflow views, as specified by communication scenarios, is consistent. Finally, they show how the approach can be real-ized using web services and XML technology. There are several differences with our work. First, we focus on the actual construction of consistent customized process views from a given business process, while they focus on consistency of a given workflow view and a given workflow. Second, they do not consider customization of views. Third, they consider unstructured process models while we focus on structured ones. Next, there are approaches that use views for enabling inter-organizational workflow cooperation [7,35] .
The approach of Chebbi et al. [7] consists of three main steps: workflow advertisement, workflow interconnec-tion, and workflow cooperation. The main focus of the paper is on the second step. They present reduction rules to derive from an internal process model an abstract process model which only contains tasks that coop-erate with partner workflows outside the organization. On this public process, partner-specific views can be defined that are linked with an access contract. Zhao et al. [35] use visibility constraints on internal process models to derive partner-specific workflow views. Each partner can combine the workflow views of its partner with its internal process into what Zhao et al. call a relative workflow model. Next, they discuss how an orga-nizational can use a relative workflow model to track the progress of its indirect partners, e.g. how a consumer can track the progress of the process of the provider of the provider.

There are several differences between [7,35] and our work. First, they do not consider consistency criteria between a public process and internal one, whereas we have formalized these criteria as construction rules.
Consequently, they do not give any proof of correctness of their approach. Second, they do not consider cus-tomization of views. Third, they consider unstructured process models while we focus on structured ones.
Schulz and Orlowska [30] focus on architectural support for workflow (process) views. They look into pos-sible interactions that can occur between workflow views and between workflow views and private workflows.
Next, they analyze how such interactions can be supported by describing different ways of coupling workflow views and private workflows. Finally, they define a cross-organizational workflow architecture that supports the execution of workflow views. Our work complements their work, since we focus on how customized process can be constructed from a given business process, which is not considered in [30] . The customized process views obtained with our approach can be executed using the technology described by Schulz and Orlowska [30] .
This paper builds on earlier research. In the CrossFlow project [14,33] , which developed technology to sup-port the execution of cross-organizational workflows in dynamic virtual enterprises, already a distinction was made between external and internal level process models. There, an external level process model was specified in a contract, but no support was provided for constructing this external process model, i.e., the CrossFlow approach relies on manual construction of external process views. In follow-up research, Grefen et al. [15] defined a three-level framework for process outsourcing. In this work, also a distinction between external and internal models is made, but only abstract construction rules are presented. This paper complements that work by showing how external process views can be automatically constructed from conceptual process mod-examined how enactment of (non-customized) process views can be supported using web service technology. A similar enactment infrastructure can be used to enact customized process views.

Some existing industrial standards, notably BPEL [2] and BPMN [34] , distinguish between an abstract (public) and a concrete (private) process. The abstract process is a non-deterministic protocol describing pos-sible interactions, whereas a concrete process is actually executable by a process engine. This distinction between abstract and concrete process is similar to the one made in this paper between a process view and its underlying internal process. Unlike our approach, these standards do not define any consistency constraints between these different process levels, nor do they address customization.

On a more general level, there are approaches that tackle the problem of distributed process collaborations by focusing on distributed execution of workflows [5,26] or process compositions [3] . However, these approaches typically do not use different process levels. An exception is Bussler [5] , who advocates the use of public and private processes, but this work does not provide any consistency constraints between them. 7. Conclusion We have presented a two-phase approach for constructing process views from structured process models.
The main contribution of the approach is that it supports both providers and consumers. Providers can hide private details from their internal process models and consumers can remove noise from provider process views. The approach is formally defined, which enables an automated implementation. This allows an efficient way of constructing customized views. Since we consider structured process models, the approach fits well with the industrial process standard BPEL [2] , which is mainly structured.

As a case study, we have applied the approach to the CrossWork project. This shows how the approach can be used in architectures supporting dynamic business-to-business collaborations that are process-oriented rather than function-oriented. In today X  X  business world, such dynamic cooperations between autonomous organizations becomes increasingly important. In the past, organizations cooperated with each other in rather static networks. To comply with current market settings, however, organizations have to shift their priority to flexibility and ability to change if they want to survive [27] . As a consequence, dynamic cooperation between organizations is often required to meet market demands [13] . Our approach can aid in establishing such dynamic collaborations in an efficient way.

There are several directions for further work. First, the approach can be extended to deal with non-structured process models. Another interesting extension is dealing with multilateral views, which span mul-tiple provider and consumer processes. Such views are especially useful in a choreography setting. Finally, the approach can be used to study agent-based negotiation of views between consumers and providers. For example, a provider agent may get a request from a consumer agent to show certain activities from its internal process model. The provider agent can compute a process view fulfilling this request, using the approach of this paper, and then decide on whether or net the offer is profitable enough to accept the pro-cess view.
 Appendix
Proof of Theorem 1. Denote by agg the set returned by A ggregate first we show that agg complies with the construction rules (i), and next we show that agg is minimal (ii). (i) We only show the proof for Rule 2; the proofs for the other rules are by similar reasoning. Let x , y 2 agg such that there is a z 2 N with x &lt; z &lt; y . We will show that z 2 agg .
Since x &lt; z &lt; y , we have l x , y , z = lca ({ x , y , z }) is of type SEQ .If l z 2 agg .If l x , y , z is a strict descendant of l ,so l  X  l is of type PAR or XOR . Let c be the child of l that is ancestor of l  X  l is of type SEQ . Let c z be the child of l such that z is descendant of c claim then follows from l.11. (ii) We prove the claim by contradiction. Suppose there is another set agg X agg 0 and agg 0 does not violate the construction rules 2 X 4.

Let n be a node in agg n agg 0 ,so n is a superfluously added to agg by the algorithm. We now examine the cases where n might have been added to agg by the algorithm: is ancestor of n and parent ( n 0 ) 2 agg 0 . Since n 0 6 2 x is descendant of c (l.6). Since n 2 agg n agg 0 , n 5 x . There are three subcases now
 X  n is strict descendant of x . Let n 0 be the node in agg n agg
 X  n is strict ancestor of x . Let n 0 be the node in agg n agg
 X  n &lt; x or n &lt; x or n ? x . Let l n , x = lca ({ n , x }). Since l  X  l.13. Let x 2 X be a node such that x 2 aggC . By assumption (Rule 1), x 2 agg 0 .So n 5 x . Let c child of l that is ancestor of x .
 X  n is strict descendant of x . Let n 0 2 agg n agg 0 be a descendant of x that is ancestor of n such that par-
 X  n is strict ancestor of x . Let n 0 2 agg n agg 0 be a descendant of n that is ancestor of x such that chil-
 X  n ? x . Let l n , x = lca ({ n , x }). Since l n , x is strict ancestor of x , by the previous case l Thus, in each case agg 0 violates a construction rule, which contradicts the assumption. h
References
