 1. Introduction work fl ow is deployed, is very expensive and time consuming. Therefore, a critical challenge in work design  X  time veri fi cation of work fl ow models [1,5,6,11,15,19,24,32,33,36] . unstructured: splits and joins of type AND or XOR are used in arbitrary ways, leading to work and parallelism. Consequently, it is hard to detect errors in work
Several authors have recognized this problem, and, starting with Sadiq and Orlowska [33] , have de analysis in terms of matched  X  unmatched pairs and nested rather minimal. To illustrate this point consider the example in Fig. 1 which contains a split node C3S will eventually result in deadlock at C2J  X  such errors. They de fi ne a set of rules to reduce a work causing the error.

To offer more detailed diagnosis of work fl ow errors, we present a work
Programming (IP) [34] . Appendix A gives a short introduction to Integer Programming. Each work set of 0/1 linear constraints to which a solution can be found by an IP solver.
The approach consists of three consecutive phases:  X  [7] , i.e. that each node is covered by a correct execution.  X  incorrect execution of the work fl ow graph, since the execution gets stuck at the join.  X 
Third, the relaxed IP formulation is used to diagnose the complete work behavior is found, it would mean that there is an error in the work
AND join node is re fl ected in an execution instance where only one incoming branch is activated. The work incorrectly, then each execution of the work fl ow graph is correct, and therefore the entire work
By applying this approach to the example in Fig. 1 , we get the following outcomes for each phase:  X   X 
C2J  X  ;  X  the work fl ow graph is not correct, since AND join C2J  X  Fig. 2 ).

Feedback from the tool is presented graphically to the work work fl ow graph itself. More details on the tool can be found in Section 6 .
The IP approach to work fl ow veri fi cation makes several contributions compared to existing work various con fl icting diagnostics, as we show in Section 7 . Second, the approach is correctness and producing detailed diagnosis, it can perform additional user-de approaches, which use heuristics to either reduce a work fl graph [38] . In a combined approach, fi rst heuristics can be used to obtain a reduced work comparison with related work can be found in Section 7 .

This paper is organized as follows. Section 2 introduces work to check existence of an incorrect execution. Section 4 presents the third phase of the approach by de
DiagFlow outperforms the state of the art veri fi cation Wo with conclusions. 2. Basic IP model
In this section we develop the fi rst phase of our formal approach for verifying work work fl ow graphs from Sadiq and Orlowska [33] . Based on the syntax, we de subgraph that represents a correct execution of the work fl from the literature. Finally, we present an algorithm for checking relaxed soundness [7] of a work formulation.

A short introduction to integer programming is presented in Appendix A . 2.1. Work fl ow graphs
A work fl ow graph like shown in Fig. 1 consists of nodes and edges. An edge from node A to B speci unique start and a unique end node. This description constitutes a semantic basis for a work work on work fl ow veri fi cation [21,33] .

De fi nition 1. A work fl ow graph or work fl ow schema is a tuple P =( N , E ) where:  X  N is a set of nodes, partitioned into disjoints sets of XOR splits S and { start, end } where start is the unique begin node and end the unique  X 
E p N  X  N is a precedence relation.

Next, each work fl ow graph should satisfy the following structural constraints: 1. the start node has no incoming edge and one outgoing edge; 2. the end node has one incoming edge and no outgoing edge; 3. each activity node has one incoming and one outgoing edge; 4. each split node has one incoming and two outgoing edges; 5. each join node has two incoming edges and one outgoing edge; 6. each node is on a path from the start to the end node (connectedness); 7. the precedence relation is acyclic.

Formalizations of these constraints are presented in an accompanying technical report [10] . The explanatory. Constraints 1 and 2 are also put by Sadiq and Orlowska [33] . A work with more than one end point can be modeled by using a join before the end node. Constraints 3 because such work fl ow graphs contain unreachable parts and therefore are
The last constraint is also placed by other works on work suf fi
In the sequel, we also use auxiliary functions inedge, outedge: N if inedge( n )={e 1 ,e 2 }, then inedge 1 ( n )=e 1 and inedge a work fl ow graph. 1 An instance subgraph represents a subset of work start node, using the following rules:  X  if an XOR split node is visited, one of its outgoing edge is visited at random;  X  if an AND split node is visited, then all outgoing edges are visited;  X  incoming edges have not been visited;  X  subgraphs, the correctness of a work fl ow graph can be checked.

De fi nition 2. An instance subgraph is correct if and only if for each node n in the subgraph:  X  if n is an AND join, then the subgraph contains all incoming nodes of n (no deadlock)  X  if n is an XOR join, then the subgraph contains one incoming node of n (no lack of synchronization) A work fl ow graph is correct if and only if each generated instance subgraph is correct. instance subgraph, the work fl ow graph is not correct.

In the next subsection, we will formalize correct instance subgraphs as Integer Programming problems. 2.2. Basic integer programming (IP) formulation
The IP formulation consists of a set of constraints for a given work work fl ow graph, an IP variable is created. A solution to the IP formulation assigns a 0 in the IP formulation. For a node n , inedge 1 ( n ) and inedge incoming edges of node n . Similarly, outedge 1 ( n ) and outedge (joins) with more than two outgoing (incoming) edges is presented in Appendix B .
De constraints at each node in the work fl ow graph. For each node and edge x of ( N , E ), so x constraints are: (IP4)and has no lack of synchronization (IP6). Thus, a solution to the Basic IP formulation speci subgraph.
 generalization was actually realized in the veri fi cation tool we developed (see Section 6 ). 2.3. Examples lines. The dashed lines belong to the work fl ow graph but not to the subgraph. et al. [23] , this correct work fl ow graph cannot be veri formulation, i.e., a correct instance subgraph, is shown in the 2.4. Relaxed soundness
Above we showed how to check for the existence of one correct instance subgraph in the work it is also possible to check for a stronger notion of correctness called relaxed soundness. Our de derived from [7] , and is stated as follows.

De solution exists for the Basic IP formulation. Initially, all nodes of the work to the Basic IP formulation (l. 7). If a solution does not exist, then the work also be removed in line 13. If each node has been processed and no error has been found, the work The next theorem asserts the correctness of the algorithm.
 Theorem 1. Let ( N , E ) be a work fl ow graph.
 Algorithm Relaxed-Soundness-Check fi nds no error if and only if ( N , E ) is relaxed sound. contains the node. Thus, ( N , E ) is relaxed sound by De subgraph which contains n ,so( N , E ) is not relaxed sound. 3. Relaxed IP model for diagnosis formulation is elegant, it can only tell us if a correct instance subgraph exists for the work that leads to the error. This makes it dif fi cult for a work diagnose work fl ow graphs (by testing each join for errors) and to do correctness checking. 3.1. AND joins
At every AND join n a J A , we relax constraint IP4 to: we need to add two more constraints for the AND join: more than two incoming edges; see Appendix B . 3.2. XOR joins auxiliary variable, this latter constraint cannot be enforced.
 variable like a. The next constraint, XORJ5, forces n to be 0 if both incoming edges are 0 to re join node. 3.3. Example
To illustrate the IPRelax formulation in this section, we give an example of an incorrect work containing an incorrect instance subgraph (see Fig. 7 ). The IPRelax formulation for this example work are satis fi ed by the solution that corresponds to Fig. 7 . Next we will show how such erroneous work 4. Diagnosis algorithm and results
In this section, we discuss the third phase of our approach in which we do detailed diagnosis of work and Section 4.3 provides a discussion to highlight a few speci 4.1. Algorithm description notify the user. The algorithm in Fig. 8 performs this procedure.

This algorithm fi rst creates an IPRelax formulation for the work corresponds to only one incoming edge being activated, resulting in deadlock. The constraint inedge instances. Constraint inedge 1 (n)+inedge 2 (n)  X  2 at line 14 re diagnosis, and the error fl ag is raised (l. 8  X  10 and l. 17 execution path that leads to the error. Finally, if the error found, and that the work fl ow graph is correct.
 The theorem below asserts the correctness of the algorithm for the correctness check.
Theorem 2. Let ( N , E ) be a work fl ow graph. Algorithm Diagnosis incorrectly, so the conditions in l. 7 and l. 16 never become true. Thus, ( N , E ) is correct by De is an AND join, the case where j is an XOR join is treated by similar reasoning. The solution found satis not correct by De fi nition 2 .
 results of applying this algorithm. 4.2. Results
We ran algorithm Diagnosis for the two examples discussed above in Section 2.3 . For the shown in Table 1 . These results show that there are fi ve AND joins (C2J
The subsequent join nodes lie on a path from C2J  X  to end. By inspecting the solution found for C2J (right) branch from C3S to C2S  X  . At the XOR joins, no problems were found. other edge is dead. 4.3. Discussion revisiting the diagnosis of the example of Section 1 , as listed in Table 1 . AND join C2J cascading effect resulting in the subsequent problems. The work work fl ow model again.
 reduction rules can be applied to the work fl ow graph, and next the reduced work
This way, a reduced IP model is obtained which can be veri approach complements the approach of Sadiq and Orlowska.
 very fast for two reasons. First, most IP software algorithms the IP solution. 5. Extensions fl exibility than the other ones such as the one discussed in [33] . The checking of the work fl ow graph. The second extension shows how to apply our approach to work do not lend themselves so easily to such extensions. 5.1. Semantic checking and analysis before the claim can be reviewed. Therefore, the activity  X  then one of two activities  X  application accepted  X  or  X  application rejected can be checked easily using our approach. Such constraints fall into generic categories [17] :  X   X  execution instances?  X  (C3) Dependency relationships between activities: does one task always depend upon another?
The general idea is that to check for each rule or constraint we can have the same value by the IP constraints. A type C2 constraint checks if a group of n activities { a together. We can add an IP constraint to the formulation IPRelax as follows: relationships by adding simple IP constraints. Thus, one can analyze the work can help to make corrections to the work fl ow process. 5.2. Adding new modeling constructs
The IP formulations in Sections 2.2 and 3 assume that work the IP formulations can also be extended for veri fi cation of work our idea with three patterns. 5.2.1. Inclusive-OR pattern join node (n2), the new constraints are: of an OR join. 5.2.2. Discriminator (DIS) pattern identical. 5.2.3. M-of-N AND split pattern
Fig. 9 c). Similarly, the m -of-n AND join pattern speci
These patterns can be modeled with constraints like:
Note that these constraints generalize IP3 and IP4, respectively, of De feasible solution is found then it would mean that the constraint is never violated. 5.3. Example: diagnosis of processes containing OR joins previously were used. Table 2 summarizes the results of the experiments. which the OR joins or splits are activated improperly. Example 2 is a modi
AND2, AND3 andAND4. Finally, example 3 is a further modi fi again a correct solution is found, but incorrect solutions are also found at nodes AND2, XOR3 and XOR4. constructs like AND and XOR joins, fl exibility in the process found. Of course, the overarching goal in process design is not world process as accurately as possible. The constructs that are best suited to achieve it should be used. 5.4. Discussion
We showed in this section that it is possible to create IP formulations to check correctness of work additional patterns. In a similar manner even more control approach in previous sections for graphs without these patterns.
 6. Implementation and performance results tool. 6.1. XPDL DiagFlow tool fl
Management Coalition for exchanging work fl ow de fi nitions among work fl ow, XPDL also supports modeling of the data fl ow.

The DiagFlow tool reads XPDL 1.0/2.0 models and translates them into an internal work can deal with splits with more than two outgoing edges and joins with more than two incoming edges, as de optimal solution is obtained or whether the model is infeasible. In the
Section 2.2 ), which is shown to the user by highlighting corresponding parts of the work
DiagFlow analyzes XPDL models by providing three options for analysis in a menu. The easily see what causes the problem at the join and correct the XPDL model. highlighted in the XPDL model shown in Fig. 11 . 6.2. Performance results from Sadiq and Orlowska [33] shown in Fig. 1 with multiple copies of itself in different con generate successively larger models. The models we considered were as follows: Sadiq1: model of Fig. 1 from Sadiq and Orlowska [33] Sadiq2: model Sadiq1 in parallel with itself Sadiq3: models Sadiq2 and Sadiq1 in sequence Sadiq4: model Sadiq2 in sequence with itself Sadiq8: model Sadiq4 in sequence with itself
Wo was terminated after 4.50 h).
 computation of the state space of the Petri net that underlies the work the net. Note that DiagFlow does not compute the state space of the work space. Still, however, feedback provided by DiagFlow is at least as useful as the feedback provided by Wo next section. 7. Discussion and related work [33] and the Wo fl an-based approach of [1] . Next, we discuss other process veri can be integrated with our approach: fi rst the reduction rules can be applied to the work complements that of [33] .
 net-based analysis techniques to diagnose work fl ows. These techniques have been implemented in the Wo actual error as we show next. The three main types of Wo fl different types. Such pairs can be detected from the syntax of the work the work fl ow which is correct.
 this does not indicate that C2J  X  is causing the problem. Finally, Wo covered by a thread of control, i.e. a sequential state machine. Wo error, but in addition provides an incorrect instance subgraph that illustrates the provided by the IP approach gives exact feedback to the work
Several alternative approaches for the veri fi cation of graph-based work research has looked at veri fi cation in the context of non-graph-based methods of work veri fi cation approaches are most closely related to our work, we discuss these in more detail. The veri structural con fl icts, but do not give details on the causes of found con that are not decomposable. Kiepuszewski et al. [22] address the possibility that an unstructured work generality. Logic-based approaches for work fl ow veri fi can also be represented as an integer program, the latter offers greater ease of representation for veri work fl ow designs that use model checking [11,19] , but there only one error trace (corresponding to one
Work by Vanhatalo et al. [38] describes faster algorithms for process veri graphs. However, there is still a large percentage of graphs (about 30% in the authors to such complex graphs and their fragments. A related paper [39] shows how to decompose a work single end node. This completion approach can be used as preprocessing step for the IP approach: a work process trees [37] as techniques for work fl ow analysis, decomposition and transformation. veri fi cation task. Work on metrics for process models also has implications for veri reduced by ensuring that the process model performs well on the process model metrics. Still, veri process model is free of errors. 8. Conclusions
Recognizing the importance and continuing need for effective and ef and tested an IP based approach for veri fi cation of work
DiagFlow tool that diagnoses XPDL work fl ow models, and provides the veri that complement the other approaches very well.

In particular, the proposed approach gives precise diagnostic information that helps a work work fl ows containing block structured loops, i.e. loops that contain single-entry work fl ow graph. However, many common work fl ow processes can be designed to satisfy this restriction. well as make it fl exible by giving users the ability to add their own new patterns in a convenient manner. Acknowledgment His research was funded in part by the Smeal College of Business.
 Appendix A. Introduction to integer programming function de fi ned in terms of variables so as to represent a quantity of interest such as pro
The setup cost of the production facilities and the unit pro 480 and 720 h of production time available for the production of these widgets. introduce 0  X  1 decision variables to formulate the above problem as an integer program as follows:  X  f ij =1 if factory i ( i =1, 2) is setup to produce widgets of type j ( j =1, 2), f  X  x ij is the number of widgets of type j ( j =1, 2) produced in factory i ( i =1, 2), where x
We can next write the objective function in terms of these variables and the pro Next we describe the constraints. There are two types of constraints: constraints, one for each factory, as: Constraint 1: x 11 /52+ x 12 /38  X  480 Constraint 2: x 21 /42+ x 22 /23  X  720
Type 2 constraints. We cannot produce a widget j at a factory i unless that factory is setup to do so, so f because there are two possible setups at each factory. Thus: Constraint 3: x 11  X  52 X 480 X  f 11 Constraint 4: x 12  X  38 X 480  X  f 12 Constraint 5: x 21  X  42 X 720 X  f 21 Constraint 6: x 22  X  23 X 720 X  f 22 we can store the objective function and the constraints in a like LPsolve or CPLEX. The solution for this problem is: Objective value: 572400 Variable x 11 : 24960 Variable x 21 : 30240 Variable f 11 :1 Variable f 21 :1 is 24,960 and in factory 2 is 30,240. After subtracting the setup cost the total pro Appendix B. Generalization of IP formulation to polyadic splits and joins two outgoing edges and each join has two incoming edges. In this section, we generalize the de (incoming) edges, where k  X  2.

We fi rst present the revised version of the Basic IP formulation ( De constraints IP3, IP4, IP5, and IP6, so we present generalizations for these four constraints: Next, we discuss how the constraints for polyadic AND and XOR joins can be relaxed(cf. Section 3 ).
For each AND join n  X  J A , generalized constraint IP4 is relaxed into
AND joins do not change, so for each i : 1.. k , n  X  inedge For each XOR join nJ X , generalized constraint IP6 is relaxed into the following constraints where as before k =|inedge( n )|.
 allows n to be either 0 or 1. Note that XORJ4 also allows that both a and n are 0: if a =0 then XORJ2, and consequently n =0 by XORJ3.
 two or more incoming edges are 1 to re fl ect that there is a problem at the XOR join node.
References
