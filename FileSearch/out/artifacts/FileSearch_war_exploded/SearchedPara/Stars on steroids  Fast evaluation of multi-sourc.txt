 1. Introduction common data source. For instance, in Q 1 UNIPROT is joined with INTERPRO, PDB, and EMBL. Similarly, in Q relational environment.
 legal restrictions, this processor is anonymously identified as XDB in the sequel.) limitation. 1 In particular, we show that the above queries can be evaluated in less than a minute . 1.1. Overview the subtrees.
 the underlying data is relational in nature. We elaborate on the differences further in Section 2 . primarily for read-mostly workloads. Based on the encoding scheme of SUCXENT++, we demonstrate the use of XQuery processor (MONETDB/XQuery [3]) for several queries (highest observed factor being 46 times)! 2. Related work 2.1. XPath and XQuery processing and optimization (i.e., return clause, join expressions, non-join expressions) of the star XQueries. the tree-unaware approaches are orthogonal to the proposed technique presented here. 2.2. Query translation in XML publishing environment  X  instead of a single SQL query.
 what subset of XML-QL is handled by the current solution.
 an exhaustive performance study to demonstrate the superiority of our approach. 3. Multi-source star twig pattern multi-source twig pattern. 3.1. Multi-source twig pattern such twig queries as multi-source twig patterns .
 A multi-source twig pattern Q is a graph with three types of nodes: location step query node ( ( ANode ), and return node ( RNode ). Each Q has a single node of type former represents parent  X  child or attribute relationship connects two nodes from two different sources. Specifically, a join edge ( q distinguish the RNode by underlined tag; and axes and join edges as direct and dashed edges, respectively. Observe that a multi-source twig query can be represented by an XQuery query Q =( items, L is a set of expressions defined using the let clause, expression specified in the t return clause. Specifically, the syntax of Q is as follows. clause simply declares a variable and gives it a value. We categorize the where-expressions in which can always be reformulated away using where clause. Finally, each output expression r type RNode .

De fi  X  over which exp is valid. Then, an XQuery query Q =( F , L  X  F is a set of for clause items such that | F |  X  2. An item f
Furthermore,  X  f i  X  F  X  f j  X  F such that f i . dsName  X   X  L is a set of let clause items where l  X  L is a 2-tuple ( var , exp ).  X 
Let S and T be path expressions containing var = f . var or var = l.var where f predicates in the where clause where W = J  X  C and J  X  C = of the form SopT . C is a set of non-join expressions where c var = l. var , f  X  F ,and l  X  L .  X 
Example 1. The query Q 3 in Fig. 2 consists of the following.  X  F ={ f 1 , f 2 } where f 2 .var =  X  $entry  X  , f 1 .var = entry  X  , and f 2 . exp =  X  /interprodb/interpro  X  .  X  L ={ l 1 } where l 1 . var =  X  $id  X  and l 1 . exp =  X  $entry/dbReference/@id  X 
In the where clause, J ={ b 1 }and C ={c 1 ,c 2 ,c 3 ,c 4  X  =  X  ,  X  HUMAN  X  ), c 2 =(  X  $entry/@created  X  ,  X  =  X  ,  X  and c 4 =(  X  $ip/pub_list/publication/year  X  ,  X  =  X  ,  X  2002  X  R ={ r 1, r 2 } where r 1 =(  X  $entry  X  ,  X  /name  X  ) and r 3.2. Star twig pattern query graph of an SQL query, an XQuery graph is an undirected graph with nodes D document sources D i and D j , we add an edge between D i with corresponding non-join expressions.
 Formally, it is defined as follows.

De fi nition 2. [ Multi-Source Star Twig Query] Let Q =( F , L , twig query if any one of the following conditions is true: (a) |  X  i  X  j source ( b i . S )= source (b j . S )and j source ( b 4. Star twig query evaluation various subroutines in the algorithm can be realized on a specific PM approach. elaborate on these phases in turn. In the sequel, we shall use the query Q discussion. 4.1 . Phase 1: XQuery parsing any). The output of this phase is a set of for clause items addition, we also determine the absolute path expressions of r denoted by r.absExp . For example, consider r 1 =( $entry , is bound to the expression  X  /uniprot/entry  X  . 4.2 . Phase 2: OutputExp2SQL translation
In this phase, the algorithm analyzes each output expression r number-based labeling schemes, respectively [8]. table) is generated by exploiting the Paths , Attributes ,and PathsContent relations. 4.3. Phase 3: Where Exp2SQL translation the
The whereExp2SQL algorithm is depicted in Algorithm 3. For each r algorithms later. The generated SQL query is stored in a variable called SQL .Next,an 4.3.1. The translateWhereNonJoin algorithm on an attribute then these expressions are added to the where query returns the identifiers of nodes satisfying r that satisfy expressions in 4.3.2. The translateWhereJoin algorithm processExpression function and are same as the ones in Lines 03 fragment for the join expressions (Lines 04  X  11). First, the algorithm creates two subsets of sets of join expressions involving the sources of f and r , respectively (Lines 04 processes each of the join expressions by invoking the processJoinExp algorithm twice (Lines 07 scenario with an example. Consider a query Q that contains f . var
S and f 1 . var ,respectively.Let R ={ r }where r.var = f 3
J ={  X  S 1 = T  X  }and J r ={  X  S 1 = T  X  }. Since ( J f  X  J the join between S 1 and T first followed by the join between S
S  X  pair ( r , f 1 ) in the context of the above example. Here Note that this procedure is similar to the one discussed in the context of TranslateWhereNonJoin algorithm.
Example 2. Consider the query Q 3 in Example 1 . Consider the scenario when r the set of non-join expressions are C f ={ $entry/organism/name = invokes the translateWhereNonJoin algorithm. When f 2 =  X  $ip/pub_list/publication/year =  X  2002  X  }. As the data sources of r
Similarly, the above steps are repeated for r 2 =  X  $ip/name needed using the join expression b . As a result, the algorithm invokes translateWhereJoin . Lastly, for f identical. Consequently, translateWhereNonJoin is invoked. 4.4. Phase 4: fi nal results generator joining the PathUFinal and PathsContent tables. The results are sorted in document order. expressions in R that do not contain attribute nodes. Let q be the number of output expressions in the total number of SQL queries generated from Q is ( n +3) p +( n +4) q . Proof. In Phase 2, the algorithm generates ( p + q ) SQL queries. Note that | ( p +q)+( np + nq )+(2 p +3 q )=( n +3) p +( n +4) q .  X  5. Implementing star twig query evaluation on SUCXENT++ 5.1. SUCXENT++ require a relational back-end to support SQL/XML standard or XML data type. Consider Fig. 4 .Eachlevel
BranchOrder , DeweyOrderSum ,and SiblingSum . Each non-leaf element node n descendant leaf node for reasons discussed later. Each attribute node (denoted as a
The schema of SUCXENT++ [2,19] is as follows.  X 
Document ( Docid , Name )  X 
Path ( PathId , PathExp )  X 
PathValue ( Docld , DeweyOrderSum , PathId , Branchorder , LeafOrder , SiblingSum , LeafValue)  X 
Attribute ( Docld , LeafOrder , PathId , LeafOrder , LeafValue )  X 
DocumentRValue ( DocId , Level , RValue ). table containing the root-to-leaf paths of Fig. 1 (b) is shown in Fig. 6 . Note that we use instead of  X  /  X  for reasons described in [23].

Given two element leaf nodes n 1 and n 2 , n 1 . LeafOrder leaf node in D is 1 and n 2 . LeafOrder = n 1 . LeafOrder +1 iff n superscript of each leaf element node in Fig. 1 denotes its LeafOrder value. Given two element leaf nodes n n . LeafOrder +1= n 2 . LeafOrder , n 2 . BranchOrder is the level of the nearest common ancestor (NCA) of n the BranchOrder of the first leaf node is 0 ( Fig. 5 ).

The BranchOrder has an interesting property. Let s be a non-leaf node at level
Then, except for n 1 , BranchOrder values of all the descendant leaf nodes of s are at least to implicitly encode the non-leaf nodes.

Each level  X  of an XML tree is associated with an attribute called RValue (denoted as R D . Let k  X  [1, L max ] where L max is the largest level of D . Then, n . BranchOrder  X  k . S is called a maximal k -consecutive leaf-node list, denoted as M leaf-node list S  X  such that | S | b | S  X  |. For example, M
The RValue of level  X  , denoted as R  X  , is defined as follows: (i) If 2 R  X  +1  X | M  X  +1 | + 1. For example, consider Fig. 1 (b). Here L respectively. Then, R 4 =1, R 3 =2 X 1 X | M 4 |+1=3, R 2 =2 X 3 X | M order to facilitate evaluation of XPath queries, the RValue attribute in DocumentRValue stores For instance, in Fig. 6 the RValue of level 1 is stored as 77 instead of 153.
Let parent ( w ) denote the parent of an node w . Consider a leaf node n at level of the root. Similarly, Ord ( d ,3) = 2.

Then DeweyOrderSum of n , n . DeweyOrderSum ,isdefinedas  X   X 
DeweyOrderSum of this node is: n . DeweyOrderSum =( Ord ( n ,2) with name tests. We do not elaborate further as it is beyond the scope of the paper. 5.1.1. Comparison of ordering of non-leaf nodes (resp. follows) another node n 1 , then descendants of n 0 DeweyOrderSum of representative leaf nodes.
 nodes n 1 and n 2 , n 1 . AttrOrder b n 2 . AttrOrder iff n
AttrOrder = n 1 . AttrOrder +1 iff n 1 is an attribute node immediately preceding n called TextContent that has same schema as PathValue . 5.1.2. Computation of NCA theorem.

Lemma 1. Let n 1 and n 2 be two distinct leaf nodes in an XML tree. If | n level of the NCA is greater than  X  .  X 
Theorem 2. Let n 1 and n 2 be two distinct leaf nodes in an XML tree and n . DeweyOrderSum | b R  X   X  1  X  1 2  X  1 then the level of the NCA of n range: ( R 4  X  1) / 2 + 1  X  | X  X  482| b ( R 3  X  1) / 2 + 1 is 481). Similarly, when the NCA is at level 3 the 15th and 16th nodes are returned as they satisfy ( R each internal node with its first descendant leaf node.

Corollary 1. Let n 1 and n 2 be two distinct leaf nodes in an XML tree. If | n the NCA of n 1 and n 2 is the root node.  X  respectively. Since 153  X  19 &gt; 77, the NCA is the root node ( the level of the NCA of n 1 and n 2 is MIN (level( n 1 ), level ( n the representative leaf element of n 1 is identical to n 2 are identical leaf elements then the NCA level is the level of n 5.2. Translation to A list of SQL joins in the translated SQL queries. 5.2.1. Phase 2: OutputExp2SQL translation
Recall that in this phase, the algorithm analyzes each output expression r using the following query template QT 1 : Note that [ param ]in QT 1 is replaced by the value of param from the algorithm.
Example 3. Reconsider Q 3 and Algorithm 2. We have two output expressions r
Consider r 1 . The algorithm sets PathExp to  X  /uniprot/entry/name materializing nodes satisfying r 1 is shown in Lines 01  X  r evaluated as typically the size of the Path table is relatively small. 5.2.2. Phase 3: WhereExp2SQL translation and translateWhereJoin procedures. We now elaborate on how these two procedures are implemented on SUCXENT++. then it will add SQL statements to the where and from clauses of the translated SQL query (Lines 06 two SQL expressions are added to the where clause (Lines 11 to star query processing, we do not elaborate on this (see [2] for details). [9,19] .
Algorithm 7) and corresponding SQL fragments are added to sourcesisspecifiedinLine16.

Example 4. For example, reconsider Example 2 . Consider the scenario when r translateWhereJoin function is invoked which returns the SQL query in Fig. 7 (c). Similarly, for r 5.2.3. Phase 4: fi nal results generator structure. Fig. 9 depicts the final SQL queries generated by Phase 4 for Q our approach is (2 + 3)  X  2 = 10. 6. Experimental results processor and 3.25 GB RAM. The operating system was Windows XP Professional SP3. they were not sent to output.

XQuery (denoted as MX) downloaded from http://monetdb.cwi.nl/XQue ry/Download/index.html our study. 6.1. Query evaluation times on real datasets to four data sources, and have between three to nine expressions in the data.
 6.2. Query evaluation times on synthetic datasets
GDKmallocmax error in MX for some queries, we rewrote all queries in MX into sequential ones. expressions are specified as qualifiers in path expressions of the sequel, we denote the MX system with the rewritten queries as MX-R. can be controlled. We set UNIPROT as the output data source. 6.2.1. Varying intermediate results of UNIPROT size of the highlighted predicates in the where clause. For instance, in Z following non-join twig condition: $entry/keyword =  X  Keyword evaluate queries that previously cannot be evaluated by MX. 6.2.2. Varying intermediate results of INTERPRO sequential ones in MX-R may not always be a beneficial strategy. 6.2.3. Varying number of data sources memory fragmentation problem. Also, the results of MX and MX-R in Figs. 16 (b) and 17(a) 14.51 times slower (without considering DNF queries). 6.2.4. Varying number of output expressions vary the values of p and q . Recall that p and q are the numbers of output expressions in that contain attribute nodes, respectively. We use the query templates QT
Note that QT 2 and QT 3 join three and four data sources, respectively. The return clauses shown in Fig. 18 (c).

Fig. 19 depicts the evaluation times of the queries using query templates QT queries (highest observed factor being 7.5 times). 6.2.5. Evaluation times of sub-queries and Y 2 asourtest queries. The translated SQLquery of Z 2 fetch the identifiers of the output nodes (Phase 1). SQ 2 in Fig. 20 . Observe that relatively the most expensive query is SQ
References
