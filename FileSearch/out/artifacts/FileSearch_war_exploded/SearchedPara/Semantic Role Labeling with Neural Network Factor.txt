 Semantic role labeling (SRL) is the task of iden-tifying the semantic arguments of a predicate and labeling them with their semantic roles. A key chal-lenge in this task is sparsity of labeled data: a given predicate-role instance may only occur a handful of times in the training set. Most existing SRL systems model each semantic role as an atomic unit of meaning, ignoring finer-grained semantic similarity between roles that can be leveraged to share context between similar labels, both within and across annotation conventions.

Low-dimensional embedding representations have been shown to be successful in overcoming sparsity and representing label similarity across a wide range of tasks (Weston et al., 2011; Sriku-mar and Manning, 2014; Hermann et al., 2014; Lei et al., 2015). In this paper, we present a new model for SRL that embeds candidate arguments and semantic roles (in context of a predicate frame) in a shared vector space. A feed-forward neural network is learned to capture correlations of the re-spective embedding dimensions to create argument and role representations. The similarity of these two representations, as measured by their dot prod-uct, is used to score possible roles for candidate arguments within a graphical model. This graphical model jointly models the assignment of semantic roles to all arguments of a predicate, subject to structural linguistic constraints.

Our model has several advantages. Compared to linear multiclass classifiers used in prior work, vector embeddings of the predictions overcome the assumption of modeling each semantic role as a discrete label, thus capturing fine-grained label sim-ilarity. Moreover, since predictions and inputs are embedded in the same vector space, and features extracted from inputs and outputs are decoupled, our approach is amenable to joint learning of multi-ple annotation conventions, such as PropBank and FrameNet, in a single model. Finally, as with other neural network approaches, our model obviates the need to manually engineer feature conjunctions.
Our underlying inference algorithm for SRL follows T X ckstr X m et al. (2015), who presented a dynamic program for structured SRL; it is tar-geted towards the prediction of full argument spans. Hence, we present empirical results on three span-based SRL datasets: CoNLL 2005 and 2012 data annotated with PropBank conventions, as well as FrameNet 1.5 data. We also evaluate our system on the dependency-based CoNLL 2009 shared task by assuming single word argument spans, that rep-resent semantic dependencies, and limit our ex-periments to English. On all datasets, our model performs on par with a strong linear model base-line that uses hand-engineered conjunctive features. Due to random parameter initialization and stochas-ticity in the online learning algorithm used to train our models, we observed considerable variance in performance across datasets. To resolve this vari-ance, we adopt a product-of-experts model that Figure 1: FrameNet (a) and PropBank (b) annota-tions for two sentences. combines multiple randomly-initialized instances of our model to achieve state-of-the-art results on the CoNLL 2009 and FrameNet datasets, while coming close to the previous best published results on the other two. Finally, we present even stronger results for FrameNet data (which is scarce) by jointly training the model with PropBank-annotated data. In this section, we briefly describe the SRL task and discuss relevant prior work. 2.1 Semantic Role Labeling SRL annotations rely on a frame lexicon containing frames that could be evoked by one or more lexical units . A lexical unit consists of a word lemma con-Each frame is further associated with a set of pos-sible core and non-core semantic roles which are used to label its arguments. This description of a frame lexicon covers both PropBank and FrameNet conventions, but there are some differences out-lined below. See Figure 1 for example annotations.
PropBank defines frames that are essentially sense distinctions of a given lexical unit. The set of PropBank roles consists of seven generic core roles (labeled A0-A5 and AA ) that assume different se-mantics for different frames, each associating with a subset of the core roles. In addition, there are 21 non-core roles that encapsulate further arguments of a frame, such as temporal ( AM-TMP ) and locative (
AM-LOC ) adjuncts. The non-core roles are shared between all frames and assume similar meaning. In contrast, a FrameNet frame often associates with multiple lexical units and the frame lexicon contains several hundred core and non-core roles that are shared across frames. For example, the FrameNet frame Theft could be evoked by the verbs steal , pickpocket , or lift , while PropBank has dis-tinct frames for each of them. The Theft frame also contains the core roles Goods and Perpetrator that additionally belong to the Commercial_transaction and Committing_crime frames respectively.

A typical SRL dataset consists of sentence-level annotations that identify (possibly multiple) target predicates in each sentence, a disambiguated frame for each predicate, and the associated argument spans (or single word argument heads) labeled with their respective semantic roles. 2.2 Related Work SRL using PropBank conventions (Palmer et al., 2005) has been widely studied. There have been two shared tasks at CoNLL 2004-2005 to identify the phrasal arguments of verbal predicates (Car-reras and M X rquez, 2004; Carreras and M X rquez, 2005). The CoNLL 2008-2009 shared tasks in-troduced a variant where semantic dependencies are annotated rather than phrasal arguments (Sur-deanu et al., 2008; Haji  X  c et al., 2009). Similar approaches (Das et al., 2014; Hermann et al., 2014) have been applied to frame-semantic parsing us-ing FrameNet conventions (Baker et al., 1998). We treat PropBank and FrameNet annotations in a com-mon framework, similar to Hermann et al. (2014).
Most prior work on SRL rely on syntactic parses provided as input and use locally estimated classi-fiers for each span-role pair that are only combined highest scoring role for each span, subject to a set of structural constraints, such as avoiding overlap-ping arguments and repeated core roles. Typically, these constraints have been enforced by integer lin-ear programming (ILP), as in Punyakanok et al. (2008). T X ckstr X m et al. (2015) interpreted this as a graphical model with local factors for each span-role pair, and global factors that encode the structural constraints. They derived a dynamic pro-gram (DP) that enforces most of the constraints proposed by Punyakanok et al. and showed how the DP can be used to take these constraints into account during learning. Here, we use an identical graphical model, but extend the model of T X ck-str X m et al. by replacing its linear potential func-tions with a multi-layer neural network. A similar use of non-linear potential functions in a structured model was proposed by Do and Arti X res (2010) for speech recognition, and by Durrett and Klein (2015) for syntactic phrase-structure parsing.
Feature-based approaches to SRL employ hand-engineered linguistically-motivated feature tem-plates to represent the semantic structure. Some recent work has focused on low-dimensional repre-sentations that reduce the need for intensive feature engineering and lead to better generalization in the face of data sparsity. Lei et al. (2015) employ low-rank tensor factorization to induce a compact representation of the full cross-product of atomic features; akin to this work, they represent seman-tic roles as real-valued vectors, but use a different scoring formulation for modeling potential argu-ments. Moreover, they restrict their experiments to CoNLL 2009 semantic dependencies. Roth and Woodsend (2014) improve on the state-of-the-art feature-based system of Bj X rkelund et al. (2010) by adding distributional word representations trained on large unlabeled corpora as features.

Collobert and Weston (2007) use a neural net-work and do not rely on syntactic parses as input. While they use non-standard evaluation, they report accuracy similar to the ASSERT system (Pradhan et al., 2005), to which we compare in Table 4. Very recently, Zhou and Xu (2015) proposed a deep bidi-rectional LSTM model for SRL that does not rely on syntax trees as input; their approach achieves the best results on CoNLL 2005 and 2012 corpora to date, but unlike this work, they do not report re-sults on FrameNet and CoNLL 2009 dependencies and do not investigate joint learning approaches involving multiple annotation conventions.

For FrameNet-style SRL, Kshirsagar et al. (2015) recently proposed the use of PropBank-based features, but their system performance falls short of the state of the art. Roth and Lapata (2015) proposed another approach exploring linguistically motivated features tuned towards the FrameNet lex-icon, but their performance metrics are significantly worse than our best results.

The inspiration behind our approach stems from recent work on bilinear models (Mnih and Hin-ton, 2007). There have been several recent studies representing input observations and output labels with distributed representations, for example, in the W
SABIE model for image annotation (Weston et al., 2011), in models for embedding labels in struc-tured graphical models (Srikumar and Manning, 2014), and in techniques to learn joint embeddings of predicate words and their semantic frames in a vector space (Hermann et al., 2014). Our model for SRL performs inference separately for each marked predicate in a sentence. It assumes that the predicate has been automatically disam-biguated to a semantic frame drawn from a frame lexicon, and the semantic roles of the frame are used for labeling the candidate arguments in the sentence. Formally, we are given a sentence x in which a predicate t , with lexical unit ` , has been marked. Assuming that the semantic frame f of the predicate has already been identified (see  X 4.2 for this step), we seek to predict the set of spans that correspond to its overt semantic arguments and to label each argument with its semantic role. Specif-ically, we model the problem as that of assigning each span s  X  X  , from an over-generated set of can-didate argument spans S , to a semantic role r  X  X  . The set of semantic roles R includes the special null role  X  , which is used to represent non-overt arguments. Thus, our algorithm performs the SRL task in one step for a single predicate frame. For the span-based SRL task, in a sentence of n words, there could be O ( n 2 ) potential arguments. For sta-tistical and computational reasons we prune the set of spans S using a set of syntactically-informed heuristics from prior work (see  X 4.2). 3.1 Graphical Model We make use of a graphical model that represents global assignment of arguments to their semantic roles, subject to linguistic constraints (Punyakanok et al., 2008; T X ckstr X m et al., 2015). Under this graphical model, we assume a parameterized po-tential function that assigns a real-valued com-patibility score g ( s, r ;  X  ) to each span-role pair ( s, r )  X  X  X R , where  X  denotes the model param-eters. Below, we consider two types of potential functions. As a baseline, similar to most prior work, one could use a simple linear function of discrete where  X  (  X  ) denotes a feature function. In this work, we instead propose a multi-layer feed-forward neu-ral network potential function, specified in  X 3.2. Given these local factors, we employ the dynamic program of T X ckstr X m et al. to enforce global con-straints on the inferred output.
Let R |S| denote the set of all possible assign-ments of semantic roles to argument spans ( s i , r i ) for s i  X  S that satisfy the constraints. Given a potential function g ( s, r ) , g ( s, r ;  X  ) , the proba-bility of a joint assignment r  X  X  |S| , subject to the constraints, is given by p ( r | x, t, `, f ) = exp where the log-partition function A ( S ) sums over all satisfying joint role assignments: A ( S ) = log 3.2 Neural Network Potentials Our approach replaces the standard linear poten-tial function g L ( s, r ;  X  ) with the real-valued output of a feed forward neural network with non-linear hidden units. The network structure is outlined in Figure 2. The frame f and role r are initially en-coded using a one-hot encoding as i f and i r . In other words, i f and i r have all zeros except for one position at f and r respectively. These are passed through fully connected linear layers to give e f and e r . We call these linear layers the embedding layers since i f selects the embedding of the frame f and i r for r . Next, e f and e r are passed through a fully connected rectified linear layer (Nair and Hinton, 2010), to obtain the final frame-role repre-sentation v ( f,r ) . For the candidate span, the process is similar. Atomic features  X  ( s, x, t, ` ) for the ar-gument span s are extracted first. (These features are the non-conjoined features used in the linear
Table 1: Span features  X  ( s, x, t, ` ) in Figure 2. model of T X ckstr X m et al.; see Table 1 for the list). These are next passed through a fully-connected linear embedding layer to get the span embedding e , which is subsequently passed through a fully connected rectified linear layer to obtain v s , the final span representation. The final output is the dot product of v s and v ( f,r ) : The weights of all the layers constitute the param-eters  X  of the neural network. We initialize  X  ran-domly, with the exception of embedding parame-ters corresponding to words, which are initialized from pre-trained word embeddings (see  X 4.4 for
Note that unlike typical linear models, the atomic span features are not explicitly conjoined with each other, the frame or the role. Instead the hidden layers learn to emulate span feature conjunctions and frame and role feature conjunctions in paral-lel. 4 Moreover, note that span v s and frame-role v ( f,r ) representations are decoupled in this model. This decoupling is important as it allows us to train a single model in a multitask setting. We demon-strate this by successfully combining PropBank and FrameNet training data, as described in  X 5. 3.3 Parameter Estimation We consider two methods for parameter estimation. Local Estimation In local estimation, we treat each span-role assignment pair ( s, r )  X  X  X R as an individual binary decision problem and maximize the corresponding log-likelihood of the training set. 5 Denote by z s,r  X  { 0 , 1 } the decision vari-able, such that z s,r = 1 iff span s is assigned role r . By passing the potential g NN ( s, r ;  X  ) through the logistic function, we obtain the log-likelihood l ( z s,r ;  X  ) , log p ( z s,r | x, t, `, f ) of an individual training example. Here, p ( z s,r | x, t, `, f ) = Thus, the gold role for a given span according to the training data serves as the positive example, while all the other potential roles serve as negatives. To maximize the log-likelihood, we use Adagrad (Duchi et al., 2011). This requires the gradient of the log-likelihood with respect to the parameters  X  , which can be derived using the chain rule.
 Structured Estimation In structured estimation, we instead learn a globally normalized probabilis-tic model that takes the structural constraints into account during training. This method is closely related to the linear approach of T X ckstr X m et al. (2015), as well as to the fine-tuning of a neural CRF described by Do and Arti X res (2010).

We train the model by maximizing the log-likelihood of the training data, again using Adagrad. From Equation (1), we have that the log-likelihood l ( r ;  X  ) , log p ( r | x, t, `, f ) of a single (struc-tured) training example ( r , S , x ) is given by By application of the chain rule, the gradient of the log-likelihood factorizes as where we have used the shorthand g NN for brevity. It is easy to show that the first term  X  X  ( r ;  X  ) / X  X  NN factors into the marginals over edges in the DP lattice, which can be computed with the forward-backward algorithm (recall that the potentials are in simple correspondence with the edge scores in the DP lattice, see T X ckstr X m et al. (2015,  X 4) for de-tails). Again, the chain rule can be used to compute the gradient  X  X  NN / X   X  with respect to the parame-ters of each layer in the network. 3.4 Product of Experts As we will observe in Tables 2 to 5, random initial-ization of the neural network parameters  X  causes variance in the performance over different runs. We found that using a straightforward product-of-experts (PoE) model (Hinton, 2002) at inference time reduces this variance and results in signifi-cantly higher performance. This PoE model is a very simple ensemble, being the factor-wise sum of the potential functions from K independently trained neural networks: In this section we describe the datasets used, the re-quired preprocessing steps, the baselines compared to and the details of our experimental setup. 4.1 Datasets and Significance Testing We evaluate our approach on four standard datasets. For span-based SRL using PropBank conventions (Palmer et al., 2005), we evaluate on both the CoNLL 2005 shared task dataset (Carreras and M X rquez, 2005), and the larger CoNLL 2012 dataset derived from the OntoNotes 5.0 corpus (Weischedel et al., 2011). We also evaluate our model on the CoNLL 2009 shared task dataset (Ha-ji  X  c et al., 2009), that annotates roles for semantic dependencies, rather than full argument spans. For the CoNLL datasets, we use the standard training, development and test sets. For frame-semantic parsing using FrameNet conventions (Baker et al., 1998), we follow Das et al. (2014) and Hermann et al. (2014) in using the full-text annotations of the FrameNet 1.5 release and follow their data splits.
We use the standard evaluation scripts for each task and use a paired bootstrap test (Efron and Tib-shirani, 1994) to assess the statistical significance of the results. For brevity, we only give the p -values for the observed differences between our best and second best models on each of the test sets. 4.2 Preprocessing and Frame Identification All datasets are preprocessed with a part-of-speech tagger and a syntactic dependency parser, both trained on the CoNLL 2012 training split, after converting the constituency trees to Stanford-style dependencies (De Marneffe and Manning, 2013). The tagger is based on a second-order conditional random field (Lafferty et al., 2001) with standard emission and transition features; for parsing, we use a graph-based parser with structural diversity and cube-pruning (Zhang and McDonald, 2014).
On the WSJ development set (section 22), the la-beled attachment score of the parser is 90.9% while the part-of-speech tagger achieves an accuracy of 97.2%. On the CoNLL 2012 development set, the corresponding scores are 90.2% and 97.3%. Both the tagger and the parser, as well as the SRL mod-els use word cluster features (see Table 1). Specif-ically, we use the clusters with 1000 classes from Turian et al. (2010), which are induced with the Brown algorithm (Brown et al., 1992). To gener-ate the candidate arguments S (see  X 3.2) for the CoNLL 2005 and 2012 span-based datasets, we follow T X ckstr X m et al. (2015) and adapt the algo-rithm of Xue and Palmer (2004) to use dependency syntax. For the dependency-based CoNLL 2009 experiments, we modify our approach to assume single length spans and treat every word of the sen-tence as a candidate argument. For FrameNet, we follow the heuristic of Hermann et al. (2014).
As mentioned in  X 3, we automatically disam-biguate the predicate frames. For FrameNet, we use an embedding-based model described by Her-mann et al. (2014). For PropBank, we use a multi-class log-linear model, since Hermann et al. did not observe better results with the embedding model.
To ensure a fair comparison with the closest lin-ear model baseline, we ensured that the prepro-cessing steps, the argument candidate generation algorithm for the span-based datasets and the frame identification methods are identical to T X ckstr X m et al. (2015,  X 3.2,  X 6.2- X 6.3). 4.3 Baseline Systems In addition to comparing to T X ckstr X m et al. (2015), whose setup is closest to ours, we also compare to prior state-of-the-art systems from the literature.
For CoNLL 2005, we compare to the best non-ensemble and ensemble systems of Surdeanu et al. (2007), Punyakanok et al. (2008) and Toutanova et al. (2008). The ensemble variants of these systems use multiple parses and multiple SRL systems to leverage diversity. In contrast to these ensemble systems, our product-of-experts model uses only a single architecture and one syntactic parse; the con-stituent models differ only in random initialization. We also compare with the recent deep bidirectional LSTM model of Zhou and Xu (2015).

For CoNLL 2012, we compare to Pradhan et al. (2013), who report results with the (non-ensemble) A
SSERT system (Pradhan et al., 2005), and to the model of Zhou and Xu (2015).

For CoNLL 2009, we compare to the top system from the shared task (Zhao et al., 2009), two state-of-the-art systems that employ a reranker (Bj X rkelund et al., 2010; Roth and Wood-send, 2014), and the recent tensor-based model of Lei et al. (2015). We also trained the linear model of T X ckstr X m et al. on this dataset (their work omitted this experiment), as a baseline.
Finally, for the FrameNet experiments, we com-pare to the state-of-the-art system of Hermann et al. (2014), which combines a frame-identification model based on W SABIE (Weston et al., 2011) with a log-linear role labeling model. 4.4 Hyperparameters and Initialization There are several hyperparameters in our model ( X 3.2). First, the span embedding dimension of e s was fixed to 300 to match the dimension of the pre-trained GloVe word embeddings from Pennington et al. (2014) that we use to initialize the embed-dings of the word-based features in  X  ( s, x, t, ` ) . Preliminary experiments showed random initial-ization of the word-based embeddings to be in-ferior to pre-trained embeddings. The remain-ing model parameters were randomly initialized. The frame embedding dimension was chosen from { 100 , 200 , 300 , 500 } , while the hidden layer di-mension was chosen from { 300 , 500 } . For Prop-Bank, we fixed the role embedding dimension to 27, which is the number of semantic roles in PropBank datasets (ignoring the AA role, that ap-pears with negligible frequency). For FrameNet, the role embedding dimension was chosen from { 100 , 200 , 300 , 500 } . In the Adagrad algorithm, the mini-batch size was fixed to 100 for local esti-mation ( X 3.3). For structured estimation ( X 3.3), a batch size of one was used, since each structured in-stance contains multiple local factors. The learning rate was chosen from { 0 . 1 , 0 . 2 , 0 . 5 , 1 . 0 } for local p &lt; 0 . 01 (  X  ) and p &lt; 0 . 05 (  X  X  X  ). on the respective development sets for each dataset with a straightforward grid-search procedure. In the product-of-experts setup, we train K = 10 models, each with a different random seed, and combine them at inference time (see Equation (6)). Table 2 shows results on the CoNLL 2005 devel-opment set and the WSJ and Brown test sets. Our individual neural network models are on par with the best linear single-system baselines that use care-fully chosen feature combinations, but has variance across reruns. On the WSJ test set, the product-of-experts model featuring neural networks trained with structured learning achieves higher F 1 -score than all non-ensemble baselines, except the LSTM model of Zhou and Xu. It is on par and at times better than ensemble baselines that use diverse syn-tactic parses. The PoE model outperforms all base-lines on the Brown test set, exhibiting its gener-alization power on out-of-domain text. Overall, using structured learning improves recall at a slight expense of precision when compared to local learn-ing, leading to an increase in the complete argu-ment structure accuracy ( Comp. in the tables). Table 3 shows results on the CoNLL 2009 task. Following Lei et al. (2015), we present results us-ing the official evaluation script, along with addi-tional metrics that do not count frame predictions. Note that the linear baseline of T X ckstr X m et al. Table 4: PropBank-style SRL results on the CoNLL 2012 development and test sets. Results from prior work are taken from the respective pa-pers, and  X  X  X  indicates performance metrics miss-ing in the original publication. Significance was assessed for F1 and Comp. on the test set with p &lt; 0 . 01 (  X  ). outperforms most prior work, including ones that employs rerankers, except on the Brown test set. Our neural network model performs even better, achieving state-of-the-art results on all metrics. Table 4 shows the results on the span-based CoNLL 2012 data. The trends observed on the CoNLL 2005 data hold here as well, with struc-tured training yielding an increase in precision at the cost of a small drop in recall. This leads to im-provements in both F 1 score and complete structure accuracy. The product-of-experts model trained with structured learning here yields results better than the ASSERT system (Pradhan et al., 2013), but akin to CoNLL 2005, our system falls short in comparison to Zhou and Xu X  X  F 1 -score. In contrast to the smaller CoNLL 2005 data, even our sin-gle (non-PoE) model outperforms the linear model of T X ckstr X m et al. (2015) on the CoNLL 2012 data. We hypothesize that the relative abundance of the latter counteracts the risk for overfitting of the larger number of parameters in our model.
Finally, Table 5 shows the results on FrameNet data, which is very small in size. Here, structured learning does not help and in fact leads to a small Table 5: Joint frame and argument identification results for FrameNet. Statistical significance was assessed for F1 and Comp. on the test set with p &lt; 0 . 01 (  X  ) and p &lt; 0 . 05 (  X  X  X  ). drop in performance. Our locally-trained neural network model performs comparably to the linear model of T X ckstr X m et al. (2015). However we achieve significant improvements in both F 1 -score and full structure accuracy by training our model with a dataset composed of both FrameNet and titask setting is a unique capability of our approach, and yields state-of-the-art results for FrameNet.
Figure 4 shows the effect of adding increasing amount of CoNLL 2005 data to supplement the FrameNet training corpus in this multitask setting. The Y -axis plots F 1 -score on the development data averaged across runs for the local non-PoE model. With increasing amount of PropBank data, perfor-mance increases in small steps, and peaks when all the data is added. This shows that with more PropBank data we could further improve perfor-mance on the FrameNet task; we leave further ex-ploration of multitask learning of predicate argu-ment structures, including multilingual settings, to future work. Figure 4: F 1 score on the FrameNet development data averaged over runs versus the percentage of CoNLL 2005 data used to append the FrameNet training corpus. For this plot, we used the locally trained non-PoE model. 5.1 Qualitative Analysis of Embeddings Figure 3 shows example embeddings from the model trained jointly on FrameNet and PropBank annotations. Figure 3a shows the proximity of the learned embeddings e f of frames from both FrameNet and PropBank. Figure 3b shows the em-beddings for frame-role pairs v ( f,r ) (the output of the hidden rectified linear layer). Here, we fix the FrameNet frame Travel and the similar PropBank ized along with their semantic roles. We observe that the model learns very similar embeddings for the semantically related roles across both datasets. Note that there is a clear separation of the agentive roles from the others for both conventions and how the FrameNet and PropBank counterparts of each type of role are proximate in vector space. We presented a neural network model for seman-tic role labeling that learns to embed both inputs and outputs in the same vector space. We consid-ered both local and structured training methods for the network parameters from supervised SRL data. Empirically, our approach achieves state-of-the-art results on two standard datasets with a product of experts model, while approaching the performance of a recent deep recurrent neural network model on two other datasets. By training the model jointly on both FrameNet and PropBank data, we achieve the best result to date on the FrameNet test set. Fi-nally, qualitative analysis indicates that the model represents semantically similar annotations with proximate vector-space embeddings.
 We thank Tom Kwiatkowski, Slav Petrov and Fer-nando Pereira for comments on early drafts. We are also thankful to Mike Lewis, Mark Yatskar and Luke Zettlemoyer for valuable feedback. Finally, we thank the three anonymous reviewers for sug-gestions that enriched the final version of the paper.
