 1. Introduction
In the Artificial Intelligence (AI) field, the construction of systems with intelligent agents, also known as MASs, has solved numerous problems, like in Gao and Xu (2009) . The construction of these systems can be facilitated with a variety of Agent Oriented Software Engineering (AOSE) ( Cernuzzi et al., 2005 ) methodologies.
The AOSE community indicates that each methodology can cope with specific needs ( Henderson-Sellers, 2005 ).
 In this line of research, the FIPA Methodology Technical
Committee (TC) ( FIPA, 2012 ) recommends the integration of the method engineering approach in the MAS development, and consequently the definition of new method fragments for AOSE.
The method fragments are portions of designing processes that can be reused to build processes that are expressly tailored for realizing systems for particular problems. In the definition of the method fragments, their inputs and outputs are established, so that method fragments can be assembled to define customized development processes. The work in Cossentino et al. (2007) provides specific guidelines for defining method fragments in AOSE.
The current work presents a collection of novel method fragments that have been experimented by composing two processes that have been used for developing two MASs in two different AOSE meth-odologies, which are Ingenias ( Pavo  X  nandGo  X  mez-Sanz, 2003 )and Adelfe ( Rougemaille et al., 2009 ). These method fragments use agent-oriented concepts that are common in some AOSE methodologies. In the proposed approach, these method fragments are partially auto-mated by means of Model Transformations (MTs) ( Sendall and Kozaczynski, 2003 ). This automation is possible thanks to the fact that most AOSE methodologies uses the principles of the Model-driven Engineering (MDE) approach, in which the main product are models. In fact, a MT transforms a source model into a target model transferring some information, and most inputs and outputs of the proposed method fragments are models. In this work, the MTs are created by means of the Model Transformation Generator (MTGenera-tor) ( Garc X   X  a-Magarin  X  oetal.,2009b ) tool, which generates MTs from pairs of model prototypes. In addition, some of the presented method fragments include explicit reco mmendations for facilitating the inclusion of AI in the development of MASs.
 There are several works that present method fragments for AOSE. In particular, Seidita et al. (2009) define some method fragments for Passi, Rougemaille et al. (2009) determine some method fragments for Adelfe, and Henderson-Sellers et al. (2004) express Tropos with a collection of method fragments as a particularization of an object-oriented framework. However, none of these works presents a set of method fragments that have been successfully experimented to determine processes in more than one AOSE methodology. In fact, one of the main contributions of the current work is a novel collection of method fragments that have composed processes for two different AOSE methodologies, and these processes have been experimented to rebuild two known MASs (i.e. Delphi MAS and Timetable MAS). Moreover, in the literature, none of the mentioned works attaches explicit recommendations to method fragments for including AI in the development of MASs, as the current work does.

Some works use MTs in AOSE. For instance, Rougemaille et al. (2008) use MTs for transforming models of Adaptive MASs (AMASs) designed by users to models that are specific of the platform. In addition, Perini and Susi (2006) present a Computer-aided Software Engineering (CASE) tool for MTs in Tropos, showing some isolated examples of MTs. Nevertheless, none of these works uses these MTs to automate some formalized method fragments, and consequently none of these works uses MTs for improving the method engineering approach in AOSE. In fact, another contribution of the current work is to use MTs for partially automating formalized method fragments in AOSE. In other words, this work is the first one that improves the method engineering approach in AOSE by means of MTs.

The work in Cossentino et al. (2007) introduced the method engineering approach for AOSE, and other works practiced this approach for respectively Passi ( Seidita et al., 2009 ), Adelfe ( Rougemaille et al., 2009 ) and Tropos ( Henderson-Sellers et al., 2004 ) AOSE methodologies. However, none of these works has measured their experiments with a group of developers to determine whether the use of their method fragments reduces the designing time of MASs. The last main contribution of the current work is the experimentation of the novel method frag-ments with 24 developers that were randomly divided into two groups. Each developer designed a different MAS satisfying the same common requirements, measuring the time. The difference is that the first group applied the presented novel method fragments, while the second one did not. The results showed that the time for designing MASs is reduced 63.3% in average when using processes with the presented method fragments.

The proposed collection of method fragments and the current approach were previously introduced in our previous work ( Garc X   X  a-Magarin  X  o, 2011 ), as well as the MTGenerator tool was introduced by Garc X   X  a-Magarin  X  o et al. (2009b) , and some MTs were defined by Garc X   X  a-Magarin  X  o et al. (2009a) . However, our previous work has been improved in several ways in this paper.
Firstly, the proposed method fragments have been used to form two complete processes in two different AOSE methodologies.
This work now shows how two known MASs are developed following these processes. For all the fragments of these pro-cesses, now either some MTs are associated with these for their partial automation or some reasons are mentioned for being manually performed. The MTGenerator tool and the previous
MTs are not used only for isolated automation cases, but also for an integrated approach for developing MASs with formalized fragments that follow the recommendation of the FIPA Metho-dology TC. Moreover, the current paper now includes experiments that show the reduction of designing time in MASs with the current approach. Finally, some of the proposed fragments now explicitly indicate advices for incorporating AI in the development of MASs.

The remaining paper is structured as follows. The next section briefly introduces the background in which the collection of fragments have been defined and experimented, and compares the current work with the existing related works. Section 3 presents the collection of novel method fragments with some recommendations for including AI in the development of MASs, and Section 4 introduces the automation of the method fragments with a specific example. Section 5 describes the experiments of this approach covering two complete processes constituted with the method fragments respectively in the Ingenias and Adelfe methodologies. This section also indicates the MTs that assist the method fragments in these experiments, and each process is practiced with the development of a different known example.
This section also presents the experience of a group of developers that shows the reduction of designing time in the development of
MASs with the current approach. Section 6 collects the lessons that are learned from the definition and application of the presented method fragments. Finally, Section 7 mentions the conclusions and future work. 2. Background
This section presents the most relevant works that use method engineering in AOSE in Section 2.1 . This subsection highlights the improvement of the current work in terms of the composed processes practiced in different methodologies, the experiments that show the reduction of time for designing MASs, and the explicit recommendations attached to fragments for incorporat-ing AI. Then, Section 2.2 shows that most AOSE methodologies incorporate the MDE principles. In these methodologies, engi-neers mainly design MASs, and their programming code is automatically generated from their design models. Hence, most parts of their development processes consist in defining models. Finally, Section 2.3 presents the most relevant works that apply
MTs in AOSE, showing that the current work is actually the first one that uses MTs for partially automating formalized method fragments in AOSE. 2.1. Method engineering in AOSE
There are several works that apply the method engineering approach for developing MASs. To begin with, the Open Process
Framework (OPF) is a framework that follows the method engi-neering approach for creating tailored processes for developing object-oriented frameworks. This framework was adapted for supporting the concepts of the Tropos AOSE methodology ( Henderson-Sellers et al., 2004 ). In this manner, OPF benefited from Tropos by incorporating new concepts and fragment details, and Tropos methodology was able to be expressed in terms of method fragments. Moreover, there are some works that specifi-cally present method fragments for the existing AOSE methodol-ogies. For instance, Cossentino et al. (2007) present some basic guidelines for defining method fragments for the development of
MASs. Following these guidelines, several AOSE method frag-ments have been defined specifically for Passi ( Seidita et al., 2009 ). The Agile Passi process ( Cossentino and Seidita, 2005 ) was created as a composition of some method fragments of Passi. Some method fragments were also specifically designed for
Adelfe ( Rougemaille et al., 2009 ). Each of these works presents method fragments that were specifically practiced for developing
MASs in at most one AOSE methodology. In fact, these works define method fragments that are practiced for developing MASs respectively in Tropos, Passi, Agile Passi and Adelfe. By contrast, the current work presents a collection of novel method fragments that have been used for composing two different processes that were experimented for developing two known MASs in two different AOSE methodologies (i.e. Ingenias and Adelfe). In addi-tion, none of these works explicitly mentions recommendations attached to method fragments for including AI in the develop-ment of MASs. Hence, the current work is the first one that applies method engineering for constructing MASs and explicitly associates method fragments with ways of incorporating AI in their development.

All the works previously mentioned in this section propose certain method fragments for developing MASs, but none of these works measures the experiments with their method fragments to determine whether these reduce the designing time of MASs. In addition, in general software engineering, the method engineer-ing has been evaluated for the creation of Work Products (WPs) with agile processes. In particular, Qumer and Henderson-Sellers (2008) evaluate some agile processes for informing developers of which method fragments can better benefit their developments. However, these processes have not been used for developing
MASs. Therefore, the current work is the first one that presents some experiments with a group of developers that show that some method fragments reduce the designing time of MASs specifically. 2.2. MDE in AOSE
Developers of MASs have been acquiring the techniques of software engineering in the last decade, to produce these intel-ligent systems in an effective way, in a field that was introduced as AOSE ( Jennings, 1999 ). The particular needs of different MASs, the varied features of developers and processes and the absence of a global standard implied that a variety of AOSE methodologies ( Cernuzzi et al., 2005 ) were created. This variety implied the urge of unifying the efforts to allow the interoperability between these methodologies. In this line of unification, the metamodels of the modeling languages of these methodologies were defined ( Bernon et al., 2005b ).

Most AOSE methodologies use MDE, in which models are the main product. To begin with, the Ingenias methodology followed a MDE approach from the beginning ( Pavo  X  n et al., 2006 ). In this methodology there is a metamodel for defining the modeling language, and an editor is generated from this metamodel.
Developers create models of MASs and the code is generated from these models through a mechanism that involves certain templates for some modeling concepts. In addition, Gascuea et al. (2012) present a MDE approach for developing MASs with the
Prometheus methodology. This work defines the metamodel of an agent-oriented modeling language, and generates a graphical editor from that metamodel by means of the Graphical Modeling
Framework (GMF). Developers design models of MASs, and the programming code is generated from these models. Further-more, Adelfe methodology has also incorporated MDE principles, including metamodels and MTs, as discussed in Rougemaille et al. (2008) . Finally, a CASE tool has been presented for open MASs, called Regulated Open Multi-Agent Systems (ROMAS) ( Garcia et al., in press ). This tool includes MDE technologies for defining and generating complex open MASs. In particular, this tool follows the
Model-driven Architecture (MDA) standards with the Eclipse fra-mework. It uses the ECore language for defining the metamodel that determines its modeling language. Then, it applies transfor-mation rules for generating the executable code.

In conclusion, these AOSE methodologies and tools use most of the MDE basis, such as the definition of metamodels for deter-mining modeling languages and the creation of graphical editors from these. In addition, these methodologies include the code generation of the systems from models. Therefore, in all these methodologies, the models are the main product and the most of the development of MASs consists in defining these models. 2.3. MTs in AOSE
As a consequence of applying MDE principles in some AOSE methodologies, some works have applied some MTs in these
AOSE methodologies. For instance, in Adelfe ( Rougemaille et al., 2008 ), a metamodel is used for defining a language that can describe the architecture and functionality of AMASs. Then, MTs are used for transforming the models defined with this language to another modeling language specific of the platform, and finally code is generated from these models. In addition, Xiao (2009) presents another method for building AMASs with MDE princi-ples. In particular, this method uses MDA standards and guaran-tees certain security features in these MASs. This method uses MTs for generating platform-specific models from platform-independent models. Moreover, Castro et al. (2012) introduce an approach for defining requirements of MASs with goals. Then, these goals are derived to architectural designs with MTs. This work uses the i n (iStar) and Acme languages for representing respectively the requirements with goals and the architectural designs. Furthermore, there is a work that explicitly focuses on the automation of MTs in the Tropos methodology ( Perini and Susi, 2006 ). That work proposes a CASE tool, in which the Unified Modeling Language (UML) is used as an intermediate language for automating MTs in agent-oriented modeling. Nevertheless, none of these works present MTs to explicitly automate formalized method fragments. In fact, one of the main contributions of the current work is the definition of MTs to partially automate method fragments specifically in AOSE.

On the whole, in the development processes of AOSE meth-odologies with MDE principles, there are usually several steps, and most of these steps departs from some previous defined model parts and includes the creation of some new model parts. Hence, most method fragments consist in obtaining models from other models. The current work proposes to assist designers by means of formalized method fragments that are automated with MTs, which is a novel approach. These MTs may not completely perform the method fragments as these usually require new information, but these method fragments can be partially auto-mated saving time of designers, which is valuable. 3. A collection of method fragments
This paper presents a collection of novel method fragments for the development of MASs incorporating AI. These fragments are independent parts from each other, and can be assembled in many ways depending on developer needs. This work classifies the fragments in certain phases according to their nature to facilitate their understanding and presentation, but these phases do not restrict the use of these independent fragments. The System Requirements phase presents the fragments that formalize the requirements of MASs with use cases and the existence of certain agent roles. The Agent Society phase describes the social behavior in MASs. In particular, this phase specifies the interac-tions between agents, and if possible the workflow that guides these interactions. The Implementation phase collects all the fragments that specify the implementation of agents or their environments. For instance, the tasks, goals and mental states of agents are usually determined in this phase. This phase can also produce the code components of agents and environments. The Deployment phase determines the features of deployments, for instance indicating the number of running agents of each type. The Testing phase includes a method fragment for creating test cases for deployments. These phases are suggested to be arranged in the iterative way that is shown in Fig. 1 for facilitating the use of the method fragments. However, this is only a suggestion and this work gives room to assemble the fragments in the order that best suits to the specific needs of developers. In addition, Fig. 1 indicates the WPs that are usually produced in each phase.
Tables 1 X 4 identify the collection of method fragments classi-fied according to the mentioned phases. In these tables, the first column indicates the phase or group into which each method fragment is classified. The second column includes the identifier of each fragment in order to be referenced from the text. The third column indicates the name of each fragment. The fourth column contains the specific goals of each method fragment in the
MAS development. The fifth column determines the inputs of each fragment, which can be either requirements of the system or outputs of other fragments. The sixth column mentions the outputs of each fragment, which are usually the diagram or diagrams that are obtained after its application. The last column refers to the MAS Meta-modeling Elements (MMMEs) that are used in the outputs. A MMME is a type of elements in the MAS models, and this type is represented with an element in the metamodel that defines the corresponding agent-oriented modeling lan-guage. Examples of MMMEs are agent, role, goal and interaction.
This column also determines whether these MMMEs are defined, refined, related or quoted in the corresponding method fragment, indicated respectively with the terms Define, Refine, Relate or
Quote . A method fragment defines a MMME when this is designed for the first time. In other words, the fragment creates the MMME. A method fragment refines a MMME, when it changes an existing
MMME, altering its properties. When a method fragment defines or refines a MMME and then it establishes a relationship between this MMME and another existing MMME, then the second MMME is considered to be related to the fragment. A method fragment quotes a MMME when the fragment includes an existing MMME in the WP without altering it. This way of organizing method fragments follows the recommendations of FIPA Methodology TC ( FIPA, 2012 ). In this manner, the proposed method fragments share the same rationale and definition, and consequently these fragments are coherent with each other and can be easily assembled.

Besides the inputs, outputs and MMMEs, a sequence of activ-ities is defined for each fragment. As an example, Fig. 2 shows the activities of Fragment 1.1 called Definition of Use Cases .However, the activities of the remaining fragments are not included in this paper for the sake of brevity.

As one can observe in Table 1 , three method fragments are proposed for the System Requirements phase. Fragment 1.1 and
Fragment 1.2 are related to the definition of use cases. Designers are recommended to choose one of these two fragments and perform it. This decision depends on whether designers want to associate interactions with use cases at this phase. If so, designers are recommended to choose Fragment 1.2; otherwise they should choose Fragment 1.1. Both fragments need to be manually done as the input information is the requirements of customers in natural language and MTs only receive input from models. In addition, use cases are completely different in each MAS, and proposing initial use cases is probably useless. Moreover, the goal of
Fragment 1.3 is to define agent roles and their goals. The agent roles are usually already related to goals through the use cases previously defined. For this reason, Fragment 1.3 can be auto-mated with a MT, as described in the example of Section 4.3 . The agent roles are also recommended to be related to goals taking into account the cooperation among agents that allows intelligent emergent behaviors. For this purpose, designers may need to manually add some new goals, besides the ones automatically included.
 The fragments of the Agent Society phase are defined in Table 2 .
In the fragments of this phase, designers are recommended to define autonomous and cooperative agents with the necessary social capabilities so that intelligent emergent behaviors can be achieved. These fragments are divided into two groups, which are the Organization fragments and the Communication fragments.
The Organization fragments are aimed at constituting intelligent social structures in which the cooperative emergent behaviors can take place. After applying these fragments, a workflow is expected to be designed considering these intelligent cooperative behaviors, in a diagram of low-level organization. Workflows determine the temporal organization of tasks that are performed by agents. In
MASs, workflows can be organized according to different workflow patterns such as the ones presented in vanDerAalstetal.(2003) .In particular, the workflows of the M AS examples of the current paper use the sequence and arbitrary cycle patterns. There are two levels of organization diagrams, because it is useful to gather agents and roles into organization groups in MASs with a high number of agents and roles. This step of grouping is referred as the definition of the high-level organization, and is only recommended for this kind of
MASs. The low-level organization is the definition of the workflow, and is based on the high-level organization if this has been defined.
In MASs with a high number of agents and roles, the high-level organization facilitates the definition of separate workflows for each group in the low-level organization and their later composition. Designers have two options for defining the MAS organization.
The first option is to assemble Fragment 2.1 and Fragment 2.2, and is recommended when developing MASs with a high number of roles and agents. In this manner, in Fragment 2.1 designers define a high-level organization from use cases. In this step the organization groups are defined so that roles and agents of the same group interchange more messages between each other than with roles and agents of other groups. This grouping influences the workflow of a MAS. In fact, in Fragment 2.2 designers define the low-level organization based on this high-level organization.
One or several workflows are defined for each organization group, and then the workflows of all the groups are assembled to constitute the workflow of the whole MAS. The second option is to only apply Fragment 2.3, in which the workflow is designed directly from the WPs of the previous phase, in the low-level organization, without defining a high-level organization. This option is only recommended for MASs that do not have a high number of agents and roles. In the Organization fragments, it is worth indicating that the resulting workflows of MASs depend on the ways designers want to solve problems. This group of fragments is not automated since it depends on the expertise of designers and the specific features of problems.

The goal of the Communication fragments is to establish the necessary communications between agents, so these are coordi-nated for realizing the intelligent emergent behaviors. In fact, these fragments define interactions between agents and the protocols of these interactions. To reach this objective, designers can either apply Fragment 2.4 or assemble Fragment 2.5 and
Fragment 2.6. In Fragment 2.4, interaction definitions and inter-actions protocols are directly defined from the workflow. This fragment can be partially automated as further described in the experiments in Section 5.1.3 . In Fragment 2.5, interaction defini-tions can be defined from use cases, observing which agents share a use case; then in Fragment 2.6, a protocol can be defined for each interaction, considering the necessary messages.
Moreover, Table 3 presents the fragments for the Implementa-tion phase. In this phase, several components need to be defined to precisely determine how the MAS is constituted, and in some AOSE methodologies such as Ingenias, Adelfe and Prometheus, most of the programmingcodewillbeabletobeautomaticallygenerated.Each fragment defines some kinds of these components in a particular type of diagram. For instance, Fragment 3.1 creates the tasks and goals diagram and Fragment 3.3 creates the environment diagram; and both fragments receive input from the workflow created in the previous phase. Fragment 3.1 als o needs as input the definition of interaction and agents. These fragments can be partially automated, since in Fragment 3.1 probably two consecutive tasks of the work-flowusuallyshareagoalandinterchangesomedata,represented with the frame facts, and the corresponding modeling elements can be created by a MT. In addition, the first task of a workflow is frequently triggered by an event generated in an internal applica-tion, which can be automated for Fr agment 3.3. In Fragment 3.1, the tasks are recommended to be defined considering the inclusion of AI techniques such as case-based reas oning, natural language proces-sing and neuronal networks if these are suitable. In Fragment 3.3, some external and internal appli cations are defined, and these applications are recommended to inc lude AI techniques if necessary. This is especially useful for including genetic algorithms or other
AI techniques with enough computational complexity to be kept separated by means of the interfaces of external and internal applications.

Optionally, Fragment 3.2 can be applied to define the agent mental states from the tasks and goals diagram if necessary. This is necessary for complex tasks that require further designs by means of mental states. In this fragment, the mental states can be defined as bases of knowledge with facts that change according to certain rules, obtaining rule-based behaviors, which are generally useful for expert systems with AI.

Fragment 3.4 defines a code component for each task and each application, which are respectively represented in the tasks and goals diagram and the environment diagram. The definition of the new modeling elements for code compon ents can be directly performed with MTs. Section 5.1.4 presents examples of the mentioned auto-mation of fragments in the Implementation phase with MTs. Then, each modeling element of code component can be fulfilled by programmers in order to call the necessary libraries or make the necessary computing operations. In particular, this programming code and the corresponding libraries can implement the AI techni-ques that were determined in Fragment 3.1 and Fragment 3.3.
Some fragments are defined for the Deployment and Testing phases in Table 4 . In the Deployment phase, there are two alter-natives for defining the Deployment diagram. The difference is that the first alternative (Fragment 4 .1) receives input from the agent diagram, and the second alternativ e (Fragment 4.2) receives input from the high-level organization diagram. Both alternatives can be automated with MTs for creatin g a deployment configuration by default with a number of agents by default for each type. Designers can change this number if necessary according to the specific needs.
In the Testing phase, Fragment 5.1 is proposed for defining the tests diagram from the use cases and deployments. Since a test is usually defined for each deployment, a MT can automatically generate a test for each deployment with a simple condition by default. Then, designers can complete each test with other conditions according to the established use cases.

As one can observe in the fragments presented in Tables 1 X 4 , designers can compose different development processes. Further-more, these fragments can be combined with other fragments for tailored uses. 4. Automation of method fragments with MTs
Some of the presented fragments are partially automated by means of MTs, which are created with the MTGenerator tool with a Model transformation By-Example (MTBE) approach, and are further described in Section 5 . In the current section, Section 4.1 introduces the principles of MTBE, and Section 4.2 describes the tool that is used for creating MTs to automate method fragments. Finally, Section 4.3 presents an example of a MT for the automa-tion of a method fragment. 4.1. Principles of MTBE
The MTBE ( Varro, 2006 ) approach is defined as the automatic generation of transformations from source and target model pairs. The common steps of MTBE are the following: 1. Manual set-up of prototype mapping models : The transformation designer assembles an initial set of interrelated source and target model prototype pairs. 2. Automated derivation of rules : Based upon the available proto-type mapping models, the transformation framework should synthesize the set of MT rules (see Fig. 3 (a)). These rules must correctly transform at least the prototypical source models into their target equivalents (see Fig. 3 (b)). 3. Manual refinement of rules : The transformation designer can refine the rules manually at any time. However, these modifica-tions are recommended to be included in the pairs of models, so the alterations are not overwritten the next time the transfor-mation is generated. 4. Automated execution of transformation rules : The transforma-tion designer validates the correctness of the synthesized rules by executing them on additional source-target model pairs as test cases.

The MTBE approach avoids the hard-coding of transforma-tions, which frequently hinders the principles of MDE. MTBE follows MDE principles because its main products are models and transformations. In addition, in MTBE transformation designers do not need to learn any model transformation language; instead they only use the concepts of the source and target modeling languages. 4.2. MTGenerator: a tool for MTBE in MASs
The MTGenerator tool was firstly introduced in our previous define their own customized MTs, which can automate some fragments of certain customized processes. This tool receives input from model prototypes and generates MTs, according to the MTBE principles. The tool can generate MTs with many-to-many rules, and contains a mechanism for attribute matching that allows designers to create MTs that combine information from source models to create new attribute values in target models. This tool is implemented for generating transformations with the Atlas Trans-formation Language (ATL) ( Jouault and Kurtev, 2005 ) and using the Object Constraint Language (OCL) for constraints and expressions.
The tool provides a Graphical User Interface (GUI) (see Fig. 4 )in which the user can select the input and output metamodels of
MTs. The user must use metamodels defined with the ECore language and select the corresponding location paths in the top-left area of the GUI. The user can add the pairs of model prototypes with the top-right area of the generator tool, by selecting the corresponding location paths and adding them. After the automatic generation, the tool shows some logs in the Logs text area, confirming that the generation has finished success-fully. The generated MTs are shown in the bottom text area of the GUI. In this manner, the user can examine the generated MTs.
In brief, the presented MTGenerator tool can automatically generate MTs. Even if the user wants to manually improve the generated MTs, the tool saves time for the user because it provides the generated MTs as a basis for the final MTs. 4.3. Example of a method fragment automation
As an example of automation of a method fragment, this section presents the automation of Fragment 1.3, called Definition of Agents and Roles . This fragment receives input from a use case diagram and provides an agent diagram as output.

In the automation of method fragments, the first step is to determine which elements of the fragment output can usually be extracted from the information of its input. In this example, in the agent diagram, each role is usually played by one agent type, and each role usually pursues one or several goals. The association between roles and goals can usually be extracted from use cases, since roles participate in use cases that pursue goals. Further-more, an agent type can be created in the output for each input role, using an alteration of the role name for the agent type name.
In the output, a relationship can be created to associate each new agent type with the corresponding role.

In this approach, the creation of the MT begins by specifying the proper model prototypes. In the spe cification of an input prototype, the identifiers of elements are considered as input variables. The identifiers and attributes of the output are expressions that can contain the input variables. For example, Fig. 5 shows the model prototypes that can automate the F ragment 1.3 with the Ingenias notation. From this point forward, in the graphical representation of
MTs, the input model prototypes are at the left side, while the output model prototypes are at th e right side. As one can observe in the input, a role is connected to a goal through a use case. The identifiers of these elements are th e variables RoleX, UseCaseX and
GoalX, and the application of the generated MT will not be restricted to the particular names of the variables. In fact, any role that is connected to any goal through any use case will trigger the generated MT regardless the names of the input elements. However, the variables will be associated with the input elements, and in the output expressions these variable s are treated as the corresponding input elements. For instance, the output role and goal are connected and contain the expressions RoleX.id and GoalX.id respectively.
These expressions refer to the ide ntifiers of the input elements. In other words, the identifiers of roles and goals are copied to the output in the generated MT. The identifier of the new agent type is created as an alteration of the identifier of the input role, and this new agent type is connected to the c orresponding output role. In particular, roles can be identified with names with the -R suffix, and agents with names with the -A suffix. The expression of the output agent reflects this chan ge of suffix with OCL.

Finally, the MT is generated from pairs of model prototypes with the MTGenerator. For the generation, the model prototypes can be divided in several pairs of model prototypes, each of which reflects a rule within the generated MT. Each of these pairs is visually represented with a numbered arrow. This division facil-itates the presentation of the model prototypes and the generated
MT. The language of the generated MT is ATL, which is textual. In order to briefly and graphically represent MTs, this work repre-sents these with their model prototypes instead of using their actual textual notation. Specifically, the MT specified in Fig. 5 creates an agent diagram associating roles with their goals, and creates a new agent type for each role connecting these two elements in the output diagram. 5. Experiments
This section presents the experimentation of the proposed collection of method fragments including MTs that partially auto-mate these in several AOSE methodologies, specifically Ingenias ( Pavo  X  nandGo  X  mez-Sanz, 2003 ) and Adelfe ( Bernon et al., 2005a ).
Sections 5.1 and 5.2 introduce respectively Ingenias and Adelfe methodologies and present the experiments of the current approach in each of these methodologies, indicating the incorpora-tion of AI in the developments. Section 5.3 evaluates the designing time of the current approach with a group of developers, and
Section 5.4 provides a brief synthesis of all the experiments. 5.1. An Ingenias process composed of method fragments assisted with MTs
The Ingenias methodology ( Pavo  X  n and Go  X  mez-Sanz, 2003 )is founded on the use of meta-modeling techniques for the devel-opment of MASs. It covers the whole development cycle, from analysis to implementation. The basis of an Ingenias development is the specification of the MAS. For this purpose, Ingenias provides tool support with the Ingenias Development Kit (IDK) . The main component of the IDK is the specification editor used to create specifications. Fig. 6 shows some relevant elements of the Ingenias notation from this editor. The editor works as a host for plugins that format documentation, verify specifications and generate code. The key plugin for code generation is the Ingenias Agent Framework (IAF) ( Go  X  mez-Sanz and Pavo  X  n, 2006 ). The IAF produces code for the Java Agent DEvelopment Framework (JADE) ( Bellifemine et al., 2001 ) according to an architecture designed in Ingenias. This architecture supports, among several features, deliberative and reactive agents, and a simplified management of protocols. Therefore, the IDK provides a way to develop MASs following the principles of MDE ( Pavo  X  n et al., 2006 ).
This section describes a possible process for Ingenias modeling that is the concatenation of some of the proposed method fragments, assisted with MTs. These MTs assist designers through modeling by generating parts of specifications. Designers also add some information at some steps of the development.
 This section mainly exemplifies the method fragments and MTs in the Delphi MAS ( Garc X   X  a-Magarin  X  o et al., 2008 ), but the same process was also applied in the Crisis-management MAS ( Garc X   X  a-Magarin  X  o et al., 2009a ).

In this section, firstly Section 5.1.1 presents the chain of method fragments that has been selected for conforming the process, and the remaining subsections present the experiments respectively in each phase of the process. 5.1.1. Selection of the method fragments for composing the process
This section presents a development process that is consti-tuted by concatenating some of the proposed method fragments, in the Ingenias methodology. In this approach, engineers are recommended to specify some source models in some initial method fragments; then, some MTs can be applied for partially performing the remaining fragments of the process. In this process, engineers need to define the initial information in use case diagrams and workflow models. Engineers specify their early requirements with use cases. Workflow models describe the organization of MASs at a low level of abstraction. Figs. 7 and 9 respectively show the use cases and the workflow of the Delphi MAS. In particular, the method fragments of the process are the following: System Requirements phase Agent Society phase Implementation Phase
J A MT defines the inputs and outputs of the Tasks
J A MT generates the Internal/Extarnal Applications and Events
J For each Task , a MT creates its Code Component Deployment and Testing phases J A MT creates the agent deployments (Fragment 4.1).
 J A MT generates the tests (Fragment 5.1).

All the proposed MTs for the aforementioned fragments are created by means of the MTGenerator tool. The following sub-sections explain how to specify and generate these MTs with pairs of source and target prototype models. 5.1.2. System requirements phase
In the System Requirements phase of the process of these experiments, the first step is the definition of use cases of
Fragment 1.1. These use cases are defined manually instead of being generated for two reasons. First, the input information is the requirements established by customers in natural language and MTs can only receive input from models. Second, the use cases define the problem to solve and this can be completely different for each MAS; thus, the existence of some auto-generated use cases by default is not actually useful.
Afterwards, Fragment 1.3 is applied to create the definition of roles and agents from the use cases. The definition of roles usually implies their association with their goals. These relations can be obtained from the input, since in Ingenias use case diagrams usually include roles and goals linked through use cases (see an example in Fig. 7 ). Moreover, in the output of the fragment, an agent type usually needs to be created for each role with a similar identifier. For these reasons, a MT is defined to create the association between roles and goals according to the use cases, and to generate a new agent type for each role with a similar identifier, altering its suffix. This MT is specified with the model prototypes in Fig. 5 , as further described in Section 4.3 for the same MT.

In particular, this MT generates the definitions of roles and agents of Fig. 8 from the use cases of Fig. 7 . As one can observe, the Rule 1 of the MT is applied three times, one for each role. Consequently, the three new agent types with identifiers ClientA,
MonitorA and ExpertA are generated in the output and related to their corresponding roles. These identifiers are obtained with the change of suffix from -R to -A, which are common suffixes in the role and agent identifiers respectively. Moreover the Rule 2 of the MT is applied four times, since there are four associations between role and goals through use cases. Thus, in the output there are four associations that indicate that certain roles pursue certain goals. It is worth mentioning that this rule is applied twice for a role, since it was related to two goals (i.e. the MonitorR role to the EvaluateG and QuestG goals). In fact, two different patterns concerning the same role triggered the Rule 2 of the MT. This case shows how the generated MT can create the roles definitions considering all the goals that are pursued by each role.
In Fig. 8 , the QuestG goal is to perform rounds of question-naires, which is necessary in the Delphi process for reaching a consensus in an intelligent emergent behavior. In addition, the
EvaluateG goal pursues that each expert evaluates the document and fill a questionnaire when required. Thus, the mentioned goals are suitable for achieving an intelligent cooperative behavior as recommended for Fragment 1.3 in the current approach. 5.1.3. Agent Society phase
In this phase of the process, engineers initially define a work-flow as a sequence of tasks carried out by roles or agents, as indicated by Fragment 2.3 belonging to the group of Organization fragments. Fig. 9 shows the workflow for the Delphi MAS. This workflow is designed for obtaining an intelligent cooperative behavior in which successive rounds of questionnaires allow expert agents to reach a consensus about the evaluation of a document.

In the process of these experiments, the workflow is manually designed, so that engineers can establish the global behavior of the MAS. From this workflow, other parts of the model are automatically generated following the proposed method frag-ments by means of MTs, as described in this subsection and the following one.

In Ingenias, two consecutive tasks in the workflow that are responsibility of different agents or roles have to be connected with an interaction unit. Interaction units transfer frame facts. Tasks produce and consume these frame facts. The MT specified in Fig. 10 receives a workflow model as input and generates the corresponding interaction units, partially automating Fragment 2.4. Each interaction unit transfers the necessary frame fact as its Info slot indicates. The names of both the interaction unit and the transferred frame fact are the result of concatenating the two involved tasks and a suffix. This concatenation uses the concat function of OCL, as it is necessary in the MTGenerator tool.
The generated MT from the specification of Fig. 10 is triggered even if the two agents/roles responsible for the two tasks are the same. However, if they are the same agent/role, it is not necessary to create an interaction unit. For this reason, the following constraint specifying that the two agents/roles must be different needs to be added to the MT: not  X  RoleA : id  X  RoleB : id  X 
Once interaction units are defined, engineers can group them to define interactions. 5.1.4. Implementation phase
In Ingenias, tasks are refined by defining their inputs and outputs. This work proposes again to use MTs to create the necessary modeling elements. In the general case, each task of a workflow usually consumes a frame fact that the previous task produces, and it produces a frame fact that the following task consumes. Fig. 11 presents the MT that creates the frame facts and the connections of these frame facts with the tasks, auto-mating Fragment 3.1. The first rule creates the WFConsumes relation, whereas the second rule creates the WFProduces relation.
By means of the matching mechanism, the names in the source models are propagated to the target models. The name of each new frame fact is the concatenation of the names of the producer and consumer tasks with the same suffix that was used before for frame facts.

Two remarks must be done about the aforementioned MT. The first one is that the first rule of the MT is not applied to the initial task because it is not preceded by any other task. The second one is that any of the two rules can be applied several times to the same task if it participates in several sequences of tasks. For instance, in the presented example (see Fig. 9 ), the EndOfTheR-ound task precedes two different tasks, so the second rule is applied twice for this task.

In Fragment 3.1, it is worth mentioning that the AnswerQues-tionnaire task is designed to include natural language processing for evaluating a document and filling a questionnaire, and con-sequently the task uses an AI technique as recommended by the current approach for this fragment.

Usually, users trigger an event in an internal application that initiates the first task of the workflow. Fig. 12 has the pair of models for generating the MT for the first task of the workflow. It has a task in the source model, and this task consumes an event and uses an internal application in the target model. Therefore, this MT partially automates Fragment 3.3. Identifying that a task is the start of the workflow means that there is not any other task that precedes it. However, this kind of negative constraints cannot be specified within the source model of the pair. Hence, transfor-mation designers need to manually add this constraint to the resulting MT. The definition of this constraint according to the Ingenias metamodel with OCL uses the following expression: MMA!WFConnects : allInstances  X  X  4 select  X  e 9 WFConnectstarget : WFConnectstargettask : id  X  cin : id  X  : isEmpty  X  X  This constraint selects the available instances of the relation
WFConnects . In each of these, it navigates the reference WFCon-nectstarget to the entity that represent the relation end of the target task; the reference WFConnectstargettask points out to the target task, whose name is compared with the identifier of the analyzed task. The analyzed task is an initial one if there is not any relationship WFConnects that satisfies this navigation path.
Designers would not need to define manually this constraint if the MTGenerator tool included negative examples. A negative example would indicate this situation with a model for the generation of the MT. As future work, it is planned to include this feature in the MTGenerator tool.

Finally, in Fragment 3.4, a new code component is defined for each task, and this code component is associated with the task. This fragment is partially automated with the MT specified in Fig. 13 , which defines a new code component for each task and associates it with the task. Then, MAS developers include programming code in these code components if necessary. In particular, the developers implemented the natural language processing code necessary for performing the AnswerQuestionnaire task, as recommended in the current approach for incorporating AI in the development of the MAS. 5.1.5. Deployment and testing phases
At the deployment phase of the proposed process, in Fragment 4.1 designers specify the number of agents to instantiate by means of deployment elements, considering the agent diagram. Fig. 14 defines a MT for creating a deployment by default with one instance of each agent type. This MT partially automates Frag-ment 4.1, and then designers only need to increment the number of instances of each agent type without creating new modeling elements, for the agent types whose number of instances is higher than one.

In the testing phase, Fragment 5.1 defines a test for each possible deployment. The MT specified in Fig. 15 generates a test for each deployment, partially automating Fragment 5.1.
After that, engineers only need to indicate the conditions that are checked at the end of each test, without having to create the corresponding modeling elements. 5.2. An Adelfe process composed of method fragments assisted with MTs
Adelfe ( Bernon et al., 2005a ) is an AOSE methodology for designing AMASs ( Capera et al., 2003 ). Adelfe is mainly concerned with the specification of systems intended to deal with complex environment dynamics and self-adaptation. Adelfe uses several modeling languages in its development. It considers UML-2.0 ( Object Management Group (OMG), 2005a , 2005b ) for require-ments elicitation and analysis. For instance, it specifies interac-tions with UML sequence diagrams ( Bauer and Odell, 2005 ). The
AMAS Modeling Language (AMAS-ML) is used in several steps of the process, for example in the detailed design of the agent structure and the definition of its cooperative behavior. The result-ing models are used as an input for the generation of programm-ing code. In this generation, Adelfe uses the micro-Architecture Description Language ( m ADL), which is a modeling language focused on a specific architecture for AMASs. By means of several MTs, the programming code is generated for both the agent behavior and the specific interfaces supporting them ( Rougemaille et al., 2008 ). Therefore, Adelfe provides a MDE approach that generates the application code from an abstract model defined with AMAS-ML.
It is worth mentioning that, although Ingenias and Adelfe use different graphical notations for some concepts regarding the used tools, the generated MTs transform the concepts regardless the graphical notations used by tools. For this reason, some MTs generated for the previous case study for Ingenias are reused for this case study for Adelfe.
 The process indicated in this section was used to rebuild the Timetable MAS that is described in Bernon et al. (2003) . In this MAS, teachers, group of students, course managers and room managers interact for determining the timetable of lectures.
In this section, firstly Section 5.2.1 mentions the selection of certain method fragments for composing a process, and the remaining subsections present the experimentation in the differ-ent phases of this process. 5.2.1. Selection of the method fragments for composing the process
This section selects the methods fragments for composing a process within the Adelfe methodology and metamodel. The process is described as follows: System Requirements phase Agent Society phase Implementation phase Deployment and Testing phases 5.2.2. System requirements phase
The first step of the process is the definition of use cases in Fragment 1.1, and this is performed manually for the same reasons that were mentioned for the previous case study. In Adelfe, the use cases are usually defined in detail initially, considering all the possible actors. For example, Fig. 16 shows the definition of use cases for the Timetable MAS.

The use cases of the Timetable MAS were redefined in a new diagram, focusing on the agent roles and their goals. For this purpose, some actors with the same functionality were gathered in a unique agent role. In particular, the Teacher and Student
Group actors were represented by the Representative role. Some use cases with similar meaning were also joined into other ones. In fact, each pair of use cases that initialize and change the same aspect was considered as one use case, for simplifying the development process. In addition, each use case was linked with a particular goal. This diagram of use cases is presented in Fig. 17 and is the output of Fragment 1.1.

For performing Fragment 1.3, the MT specified for the previous case study in Fig. 5 was also applied in this case study. This MT transformed the use cases defined in Fig. 17 into the definition of roles and agents presented in Fig. 18 , which is the output of Fragment 1.3.
 As one can observe in Fig. 18 , in Fragment 3.1 the CourseG and
RoomG goals are shared by several agent roles, allowing that the corresponding agents can produce an intelligent cooperative behavior as recommended in the current approach. This intelli-gent behavior consists in agents cooperating to schedule the timetable of lectures satisfying as much constraints and prefer-ences as possible. 5.2.3. Agent society phase
In this phase, firstly in Fragment 2.3, the workflow is estab-lished manually in Adelfe from use cases, so designers can design the global behavior of the MAS. Fig. 19 shows the workflow of the
Timetable MAS. This workflow pursues to achieve an intelligent cooperative behavior. In this workflow, firstly an agent playing the course manager role establishes the courses. Then, an agent playing the representative role determines the constraints of the course. Afterwards, an agent playing the role of room manager associates the lectures to the rooms satisfying all the constraints if possible, and visualizes the results. After this, an agent playing any of the three roles can change respectively the courses, their constraints, or the rooms, implying to come back in the workflow and repeat it from the corresponding task until the visualization of the current results.

Afterwards, this process contains a fragment defined originally in Adelfe. In this manner, this fragment is assembled with the new proposed fragments of the current approach. This shows that the proposed fragments can be assembled with previously exist-ing fragments. In particular, this process uses the existing method fragment called Study Interactions between Entities proposed for the Adelfe methodology ( Rougemaille et al., 2009 ). This fragment is related to the analysis and specification of agent interaction definitions, i.e. for direct communication between agents, depart-ing from uses cases. As mentioned before, Adelfe makes the initial definition of interactions with UML sequence diagrams, which are automatically translated into AMAS-ML models.

Then, the proposed Fragment 2.6 is assembled to the previous method fragment. Fragment 2.6 defines an Interaction Protocol diagram from each interaction definition, declaring the sent and received messages in the agents involved in this interaction.
The proposed Fragment 2.6 is partially automated in Adelfe by means of the MT specified in Fig. 20 . For each message specified in the AMAS-ML interaction definition, it creates communication actions and perceptions in their respective modules for detailing the corresponding interaction protocol. The first generated rule of the MT adds the action module (i.e. actions ) to the source agent (i.e. agent1 ). The second rule adds the perception module (i.e. percep-tions ) of the target agent (i.e. agent2 ). The third rule integrates the communication action (i.e. cAm1 ) and perception (i.e. cPm1 )to their respective modules, and links them to the message (i.e. m1 ).
After applying this MT, engineers can alter the generated interac-tion protocol if necessary. 5.2.4. Implementation, deployment and testing phases
In the implementation phase, firstly Fragment 3.1 defines the inputs and outputs of tasks from the workflow. In Adelfe, this fragment is also partially automated with the MT that was specified in Fig. 11 for the previous case study.

Then, Fragment 3.3 generates the applications and the events that are from these applications from the workflow. In Adelfe, this fragment is also partially performed by means of the MT pre-sented in Fig. 12 . However, in the Timetable MAS, all the tasks can be triggered by an application and event, because at any moment, the courses, the constraints or the rooms can change. In addition, the current timetable results can also be visualized at any moment.
For this reason, in this MAS, the MT presented in Fig. 12 was used but without adding the constraint for restricting its application to tasks without precedent tasks. Moreover, an internal application was manually added to encapsulate a genetic algorithm that schedules the timetable of lectures according to certain constraints and preferences, as recommended in the current approach for this kind of AI technique. This internal application was related to the IndicateRoom task.

After this, in Fragment 3.4, a new code component is created for each task, with the MT that was previously defined in Fig. 13 .In addition, a new code component was manually defined and imple-mented for the internal application that encapsulates the genetic algorithm for scheduling and was mentioned for Fragment 3.3.
In the deployment phase of the proposed process, Fragment 4.1 was partially automated with the MT specified in Fig. 14 .In the Timetable MAS, this MT created a deployment by default with one course manager agent, one representative agent, and one room manager agent. For the first used deployment, only the number of representative agents needed to be increased.
In the testing phase, Fragment 5.1 defines a test for each possible deployment. The MT previously specified in Fig. 15 generates a test for each deployment. In the generated tests for the Timetable MAS, designers included basic courses, constraints and rooms, where all the constraints can be satisfied. These tests check that the time-tables established by the MAS satisfy all the constraints. 5.3. Evaluation of the designing time with a group of developers
The proposed approach was tested in a group of developers in order to determine whether it saves time. The group of developers were 24 students belonging to the Computer Science Engineering grade of the Open Madrid University (i.e. Universidad a Distancia de Madrid in Spanish). These developers were randomly divided into two groups of 12 developers each one. All developers of both groups were asked to design a MAS that simulates a game concerning a kidnapped rabbit with the same specific require-ments. These requirements determine the types of agents, the features of each agent type, the interactions between agents, and the environment events. Each developer designed its own MAS satisfying the established requirements. The developers of the first group were requested to design their MASs following processes composed of the proposed fragments and applying the corresponding MTs. On the contrary, the developers of the second group were free to design their MASs following any existing process that is not composed of the proposed fragments.
All the developers were asked to measure their time of design-ing the MAS specifications from which the MASs can be generated in Ingenias or Adelfe. These measured times are collected in Table 5 . In both groups, 11 developers completed the designing activity and one developer abandoned it. In the first group, seven developers used the Ingenias methodology, while four developers used Adelfe. Similarly, in the second group, seven and four devel-opers used Ingenias and Adelfe respectively. As one can observe, the average designing time in the group with the presented approach (i.e. 3 h and 47 min) is considerable less than the average time of the group without the presented approach (i.e. 10 h and 19 min). In particular, the designing time is reduced 63.3% in average with the presented approach in these experiments.
Furthermore, most developers of the first group obtained an inferior time than most students of the second group. In fact, the only exception was Developer 4 whose designing process took more time than the one of Developer 14. 5.4. Synthesis of the experiments
The process defined in Section 5.1 for Ingenias was used to rebuild two known MASs, which are the Delphi MAS and the
Crisis-management MAS that is described in Garc X   X  a-Magarin  X  o et al. (2009a) . Thus, this work has applied the method fragments and MTs proposed in this section in two different MAS develop-ments. This paper mainly exemplifies the method fragments and
MTs in the Delphi MAS, but the same MTs were also successfully applied in the creation of the Crisis-management MAS as shown in our previous work ( Garc X   X  a-Magarin  X  o et al., 2009a ).
Furthermore, another process is composed of the proposed fragments for Adelfe in Section 5.2 , and is applied to rebuild the known Timetable MAS. Thus, on the whole the presented approach is used to rebuild several known MASs of different
AOSE methodologies. Furthermore, this process reused some MTs that were defined for the previous process, while another MT was defined for using a fragment that was not used in the previous process. Hence, these experiments show that some MTs of method fragments can be used for different AOSE methodologies.
This process also integrates a previously existing method frag-ment, showing that the new proposed method fragments can be assembled with some existing fragments, which is a feature recommended by the FIPA Methodology TC.

Finally, the presented approa ch is evaluated with a group of 24 developers for determining whether the proposed fragments reduce the designing time of MASs. This evaluation shows that the percentage of reduction of this designing time is 63.3% in average. 6. Lessons learned from the collection of method fragments
This work allows one to better understand and know how to develop MASs with the proposed collection of method fragments assisted with MTs, learning some lessons.

The first lesson is that there is not only a unique way of developing MASs with the proposed collection of method frag-ments. For instance, in the Systems Requirements phase, the use case diagrams can be defined either with interactions or not, using different method fragments. This decision can influence the selection of the next method fragments. Furthermore, in the
Communication group of fragments within the Agent Society phase, the interactions can be defined wi th two different method frag-ments that receive input respectively from the workflow and the use cases. Even if MASs are develo ped with different processes, these different processes can be formalized as a sequence of method fragments such as the ones presented in this paper. Method frag-ments and the processes composed of these transfer the knowledge, allowing unexperienced developers to follow the same processes that expert developers use.

The second lesson is that the formalization of fragments has allowed engineers to identify some parts of MAS development processes that can be automated by means of MTs. These MTs can be generated from model prototypes with the MTGenerator tool, as exemplified in the experiments of this work.

Moreover, the proposed method fragments can be applied to different AOSE methodologies based in MDE principles, because these fragments allow designers to create new models from other models as necessary in MDE developments, and also because these fragments mainly refer to concepts that are common in most AOSE methodologies such as interactions and agents .Furthermore,the proposed method fragments can be assembled to other existing method fragments, as shown in the experiments of this work. An advantage of including some of the proposed method fragments in
MAS developments is that the proposed method fragments can be partially automated by means of MTs saving a valuable time of
MAS developers. Another advantage is that some of the presented method fragments include explicit recommendations for facilitat-ing the inclusion of AI in the development.

Furthermore, most of the proposed MTs for automating the proposed method fragments can be used in different AOSE meth-odologies, as the experiments show. Although AOSE methodologies usually utilize different modeling languages and tools, these MTs can be used in several methodologies because these MTs only use concepts that are common in most AOSE methodologies.

The last lesson learned is that method fragments can include explicit recommendations for facilitating the inclusion of AI in the development of MASs. In particular, this approach has formalized and experienced certain ways of achieving intelligent emergent behaviors in MASs and including other AI techniques such as natural language processing and genetic algorithms in their development. 7. Conclusions and future work
This work has presented a collection of novel method frag-ments assisted with MTs for developing MASs, allowing devel-opers to use independent parts of it when these are relevant for specific needs. In this manner, practitioners can benefit from the foundational ideas of these method fragments and their partial automation by means of MTs. The fragments provide recommen-dations for including AI in the development of MASs. This approach uses the MTGenerator tool, which generates MTs from pairs of model prototypes. This work has experienced the devel-opment of two known MASs with two processes composed of some of the proposed method fragments in two different AOSE methodologies, which are Ingenias and Adelfe, showing that the proposed method fragments are applicable in different AOSE methodologies that follow MDE principles. A group of 24 devel-opers experienced the method fragments, showing that their application reduces the 63.3% of the designing time in average in the development of MASs.

As future work, the presented method fragments can be combined with more existing fragments in more methodologies, such as Passi. In this manner, new development processes can be obtained. For instance, some fragments of the Passi methodology can define use cases, from which the part of the remaining design can be created with some of the proposed fragments. In this way, requirements can be treated in Passi considering ontologies, and the whole MASs can be generated in Ingenias with IDK for the JADE platform by means of the definition of interactions, tasks, code components, deployments and so on.

In addition, new method fragments can be added to the proposed collection, in order to allow designers to compose processes for more specific needs. These new fragments can also be partially automated by means of MTs and include advices for including AI in the development. Moreover, the proposed MTs can be refined in order to automate even more the proposed method fragments. Furthermore, new recommendations can be added to the proposed fragments for facilitating more the incorporation of AI in the development of MASs.

Finally, the presented method fragments are planned to be compared with other AOSE method fragments in order to study the differences and analyze which fragments are best suited for some needs.
 Acknowledgments This work has been done in the context of the project Social Ambient Assisting Living  X  Methods (SociAAL), supported by Spanish Ministry for Economy and Competitiveness, with grant TIN2011-28335-C02-01. In addition, we acknowledge support from the Programa de Creacio  X  n y Consolidacio  X  n de Grupos de Investigacio  X  n de la Universidad a Distancia de Madrid, with grant UI2011-3.
 References
