 1. Introduction
In a traditional surveillance system, a human operator monitors multiple environments simultaneously to detect, and possibly prevent, a dangerous situation. Human perception and reasoning, however, are limited in their ability to process the amount of spatial data perceived by the senses. These limits may vary, depending on the complexity of the events and their time instances. In recent years, the acceleration in capabilities of communication equipment and in automatic video-processing techniques, combined with the decreasing cost of technical devices, has resulted in increased interest in video surveillance applications. In turn, these applications have augmented the capabilities of the human operators.

An automated video surveillance system should support both real-time alarm generation and offline inspection components to satisfy the requirements of the operators ( Regazzoni et al., 2001 ). In either side, the input video stream should be processed appropriately so that the actions are correctly analyzed. The primary challenges are the large input size and the high variability of the audio-visual features, hence it still remains a challenging issue to access the semantic content of the videos automatically. stages: modeling the environment, detecting moving objects (also called regions), classifying objects, tracking objects, and understanding behavior ( Hu et al., 2004 ). Background/foreground subtraction ( Collins et al., 2000; Kim et al., 2005; Gutchess et al., 2001; Li et al., 2003; Paschos and Valavanis, 1999; Duque et al., 2006 ) or temporal template-based methods ( Haritao  X  glu et al., 2000; Bobick and Davis, 2001 ) are widely used to detect moving objects. One of the basic aims in understanding the objects X  behavior is detecting the anomalies in the objects X  actions (Duque et al., 2006; Xiang and Gong, 2006, 2008; Zhong et al., 2004; Hamid et al., 2005; Duong et al., 2005 ). Abnormal situations and anomalies are reported to the operator and/or stored in a database for later inspection ( Durak et al., 2007; S -aykol et al., 2005a ). One of the basic tasks in offline inspection is the content-based retrieval of surveillance videos from the database. In the literature, the researchers generally assume simple data struc-tures for the semantic content: events and objects. The event descriptors contain time information and the objects acting in the event. Object indexing is not as frequent as event indexing and lacks low-level (or object-based) features.
 sequence of events, and the existence of the whole sequence is of interest. We propose scenario-based query processing to detect such sequences in video-surveillance archives, and hence to reduce the gap between low-level features and high-level semantic content. Our system provides support for querying by event-based and object-based features. The supported query types can be ordered to form a scenario-based query, where the temporal information among the (sub)queries is also included in the query expression.

In our earlier work ( S -aykol et al., 2005a ), we provided the preliminaries of a system architecture along with a brief introduc-tion on the meta-data extraction process. The architecture of our system is shown in Fig. 1 . The focus and contributions of this paper are on the query-processing component, which provides support for scenario-based, event-based, and object-based queries, where the low-level object features and directional predicates can be used to improve expressiveness and effectiveness. Our query model also supports inverse querying as well as some statistical view-based query types that can be used as tools for activity analysis in various domains, e.g., video forensics. Our Video Surveillance Query
Language (VSQL) has been designed specifically for scenario-based querying purposes. A query-specification interface has also been developed, which can be considered as the visual counterpart of VSQL. The query-specification interface is as generic and flexible as our query model.
 The main contributions of our work can be listed as follows: The query-processing system we propose provides support for a wide range of query types valuable for video surveillance. The supported query types include event and object queries enriched with the low-level feature descriptors (e.g., color, shape) and directional predicates. The system allows scenario-based query-ing , where a scenario is a sequence of events ordered temporally. This type of querying increases the retrieval quality of offline inspection, and to the best of our knowledge, no video surveillance system has been introduced in the literature that supports scenario-based querying enhanced with object-based low-level features and directional predicates. Our observations have shown that scenario-based querying provides an effective medium for after-the-fact activity analysis, since the abnormal-ities can be expressed in an effective form while preserving the temporal relations among events with a wide set of low-level subqueries.

In our data model, we introduce a new data representation scheme for region tracking, which we call inverted tracking . The main benefit of this scheme is that it addresses the scene in a view-based manner with respect to the human operators X  points of view. Since the operators inspect the scene to determine abnormalities performed by the moving objects, fixed view-based addressing is employed as a part of our data model to enhance its expressive power. For example, the most popular paths of the moving objects and the number of objects entering the scene from the left/right side can be queried.
We present a rule-based query-processing module devised to provide efficient processing for scenario-based querying. We use Prolog as our inference engine. The meta-data that we extract are generic in the sense that the predicates are valid and valuable in almost every type of video-surveillance application.
Our rule-based query-processing module provides a flexible mechanism for external predicate definition (i.e., simply by rule injection) so that the system can be tailored to various domains.
We provide a textual query language (VSQL) and its visual counterpart to provide complete querying and retrieval cap-ability. These components are designed in a generic and flexible manner so that they can be used in a variety of video-surveillance domains.
 The rest of the paper is devoted to the detailed description of the approaches we propose for data modeling and querying in video surveillance. Section 2 provides a discussion of the related work. Section 3 presents the data model proposed to achieve querying and retrieval of video surveillance archives. The query-processing capabilities of our work are described in Section 4. Section 5 discusses the visual query-specification interface designed to express scenario-based queries. The results of the performance experiments are presented in Section 6. Section 7 provides a discussion of the unique features of our approach as compared to the state of the art. Section 8 concludes the paper and provides future research directions. 2. Related work
Although there are a significant number of approaches to dynamic scene segmentation ( Collins et al., 2000; Kim et al., 2005; Gutchess et al., 2001; Li et al., 2003; Paschos and Valavanis, 1999; Haritao  X  glu et al., 2000; Bobick and Davis, 2001; Thirde et al., 2006 ) and abnormal action detection ( Duque et al., 2006; Xiang and Gong, 2006, 2008; Zhong et al., 2004; Hamid et al., 2005; Duong et al., 2005 ), the offline query-processing capabil-ities are rather limited in most of the existing video-surveillance systems. Retrieving video sequences related to a previously generated alarm is the basic way of querying the semantic content of surveillance videos (e.g., Lyons et al., 2000; Shet et al., 2005 ). In the following we provide a brief description of the existing video-surveillance systems.

Collins et al. X  X  (2000) video surveillance and monitoring (VSAM) system is one of the complete prototypes for object detection, tracking, and classification as well as for calibrating a network of sensors for a surveillance environment. The hybrid algorithm developed in that work is based on adaptive background subtraction by three-frame differencing. The back-ground maintenance scheme is based on a classification of pixels Meta-Data Storage Video Archive (either moving or non-moving) performed by a simple threshold test. A model is provided on temporal layers for pixels and pixel regions in order to better detect stop-and-go movements.
Stringa and Regazzoni (2000, 1998) and Regazzoni et al. (1998) propose a real-time surveillance system employing semantic video-shot detection and indexing. In their system, lost objects are detected with the help of temporal rank-order filtering. The interesting video shots are detected by a hybrid approach using low-level (color) and semantic features. Re-trieving all the clips related to an alarm is the basic way of querying the system.

Kim and Huang (2002a,b) present an object-based video abstraction model, where a moving-edge detection scheme is used for video frames. The edge map of a frame is extracted and compared with the background edge map to detect the moving edges and regions. A semantic shot-detection scheme is employed to select object-based key-frames. When a change occurs in the number of moving regions, the current frame is declared as a key-frame, indicating that an important event has occurred. If the number of moving objects remains the same in the next frame, a shape-based change detector is applied to the following frames.

Rivlin et al. (2002) propose a real-time system for moving object detection, tracking, and classification where the video stream originates from a static camera. Effective background initialization and background adaptation techniques are em-ployed for better change detection. The target detection phase also benefits from a color table representing object data. The detected moving objects are classified as human , animal ,and vehicle with the help of an expressive set of feature vectors. The authors initiate their feature-vector selection process with a wide set of object-appearance and temporal features. A reduced set, which leads to the best classification accuracy in their experiments, is used for classification. The authors also present a classification approach that combines appearance and mo-tion-based features to increase the accuracy ( Bogomolov et al., 2003 ).

IBM X  X  MILS (MIddleware for Large Scale Surveillance) ( Ham-papur et al., 2005 ) system provides a complete solution for video surveillance, including data-management services that can be used for building large-scale systems. MILS also provides query services for surveillance data, including time, object size, object class, object motion, context-based object content similarity queries, and any combination of these. The system employs relevance feedback and data-mining facilities to increase its effectiveness.
Lyons et al. (2000) developed a system called video content analyzer (VCA), the main components of which are background subtraction, object tracking, event reasoning, graphical user interface, indexing, and retrieving. They adapt a non-parametric background-subtraction approach based on Elgammal et al. (1999). VCA differentiates between people and objects and the merging , and depositing/picking-up . Users are able to retrieve video sequences based on event queries whose categories are similar to those we use.

Brodsky et al. (2001) designed a system for indoor visual surveillance, specifically for use in retail stores and homes. They assume a stationary camera and use background subtraction. A list of events that the object participates in is stored for each object, simply, entering, leaving, merging , and splitting . Shet et al. (2005) presented a visual surveillance system, VidMAP, that combines real-time video-processing algorithms with logic programming to represent and recognize activities. They used Prolog for the high-level rules that correspond to their supported query set. Entry violation , thef t , and possess are examples of rules they use to answer specific queries. 3. Data model at the lowest level; e.g., pixel-data for moving regions and motion orientation. At the next level, object-level information is extracted; e.g., class type (e.g., human, non-human, object group) and color and shape feature vectors. At the third level, primitive object actions are annotated; e.g., stop, move, and enter. At the highest level, conceptual event predicates are detected to identify activities, e.g., crossover, deposit, approach. This information-extraction scheme, shown in Fig. 2, is explained in the following subsections. Annotated actions and conceptual predicates are the primary aspects of our meta-data and used directly in the query model. 3.1. Extraction of moving regions extract the moving regions (or moving objects) in a video frame, similar to the one proposed in Collins et al. (2000) . This technique is combined with three-frame differencing to detect the moving pixels. These pixels are then passed through region grouping methods and morphological operations to identify the moving regions. This technique can be formulated as follows: is a vector holding moving pixels. A threshold vector T f  X  x ; y  X  for a frame f is needed for detecting pixel motions. The basic test condition to detect moving pixels with respect to T f  X  x ; y  X  can be formulated as
The (moving) pixel intensities that are greater than the back-ground intensities  X  B f  X  x ; y  X  X  are used to fill in the region of a moving object. This step requires a background maintenance task based on the previous intensity values of the pixels. Similarly, the threshold is updated based on the observed moving-pixel information in the current frame. A statistical background and threshold maintenance scheme is employed, as presented in the following equations: B 0  X  x ; y  X  X  0 ;  X  2  X 
B f  X  x ; y  X  X  T 0  X  x ; y  X  X  1 ;  X  4  X  where a is the learning constant, and the constant k is set to 5 in intensities, and T f  X  x ; y  X  is analogous to k times the local temporal standard deviation of pixel intensities computed with an infinite impulse (IIR) filter ( Collins et al., 2000 ). 3.2. Tracking moving regions the motion history image (MHI) technique proposed in Bobick and
Davis (2001) . MHI detects and tracks the parameters (structure and orientation) of the moving regions. In an MHI, the pixel intensity is encoded as a function of the temporal history of the motion at that pixel, where the pixels that moved more recently are brighter. This technique enables us to track the trajectories of regions. Here, the MHI  X  MHI f  X  x ; y  X  X  of a frame f is constructed by the update rule in Eq. (6):
MHI  X  x ; y  X  X  where t denotes the temporal extent of a motion. Dynamic schemes are available for selecting a better value for t (e.g., backward-looking algorithm in Bobick and Davis, 2001 ).
We also provide a scheme to store the object appearance history on a video frame, which we call inverted tracking . The name inverted is generally used to imply that a mapping from the content is stored along with the actual content. Here, the actual content is the extracted moving regions, and a view-based mapping is hold along with the content. Fig. 3 illustrates the inverted-tracking technique that we employ on a sample video frame. The video frame I  X  x ; y  X  is divided into 16 cells corresponding to four subdivisions in x and y directions. The number 16 is selected not only to decrease the computational and storage costs of the system, but also to provide effective positional object-history tracking. We validated the selection of 16 cells by also experimenting with values 4 and 64. If we use four subdivisions, the effectiveness of the tracking is lower. When we use 64 subdivisions, the effectiveness of the tracking is higher but the computational complexity and storage costs are higher. The inverted-tracking technique improves region-tracking capability because object locations are tracked with respect to a fixed view-based reference  X  the cell in which the object appeared. Since more than one object might appear in a cell, the technique holds object lists for each cell.

While computing a region X  X  appearance in a cell, we consider its center of mass ( c m ). The c m  X  X  x c m ; y c m  X  is computed as x  X  where n is the total number of pixels in a region.
 Definition 1 ( Region appearance within a cell ). The region r has appeared in a cell i if c m of r is inside the boundaries of i inclusively. To break ties, the boundaries are assumed to belong to the cell on the left and down.

If an object is moving in a cell i ,itiskeptintheobject-appearance list of the cell i until it leaves the boundaries of the cell. If the object stops, it is not dropped from the list until a pre-specified time duration passes. A specific type of motion where an object enters the scene, stops for a certain time, and then leaves the scene is called loitering (Tenth IEEE International Workshop on Performance Evaluation of Tracking and Surveillance (PETS), 2007 ); this activity is considered as a potential abnormal situation. Hence, our inverted tracking scheme does not drop objects until the pre-specified amount of time (generally taken as 60s) passes in order to detect loitering, simply by tracing the object appearance lists. However, if the object stops and then starts moving before loitering happened, we can detect that the previously stopped region is moving again by tracing back the object list belonging to that cell. Based on the assumption that the objects will be seen after occlusion before loitering, this delayed dropping of objects from appearance lists also helps to handle the occlusion problem of tracking, and to cope with object tracking errors.

The object-appearance lists are updated under two conditions: the first one is when a new region r is detected. Based on the value of the c m of r ,thecell i that r has appeared in is found and r is appended to that cell X  X  list with a time stamp. The second update condition is when a region r has passed through the boundary between two cells. In this case, r is moved from the list of the cell in which it previously appeared to the list of the newly entered cell.
This scheme helps to address the scene in a view-based manner. Since operators look at a fixed scene and inspect moving objects while trying to figure out the abnormal situations, a fixed view-based addressing provides a medium for view-based query-ing of the scene content. Examples of the types of queries supported include: the most popular path of the moving objects, the number of objects entering the scene from the left/right side, and the cell in which a specific event happened most frequently. 3.3. Classification of objects
To keep our system generic, we categorize the (moving) regions into three classes: human , non-human , and object-group . The low-level color and shape features and the aspect-ratio of the regions X  MBRs are used for classification. The low-level features are stored in normalized color and shape feature vectors, as described in S -aykol et al. (2005b) . The color vector stores the distance-weighted intensity values in order to take the color distribution around a pixel into account. This type of color-feature encoding is different from traditional color vectors, and aids the object-classification process. The shape vector is a composition of a region X  X  angular and distance spans, which are computed based on the region X  X  center of mass ( c m )(S -aykol et al., 2004 ). These encoding schemes are invariant under scale, rotation, and translation, and effective for object classification.
The color and shape features, as being the most frequent descriptors, are used in most of the existing systems in a combined way. The main reason for this combined usage is to improve the retrieval effectiveness. In our k nearest neighbors based classification scheme, the color and shape information can be linearly combined with proper weights, and we use the temporal averages of these vectors computed during tracking. A global distance value can be obtained by linear combination of three partial distances with appropriate weights during the classification process ( Jain and Vailaya, 1996 ). A possible set of weights can be determined by performing similarity calculations A for each of the two feature vectors separately. The average-case retrieval accuracies as a result of these two similarity calculations are normalized and used as feature weights in the linear combination. This pre-computed weight assignment provides more effective results since this approach reflects the character-istics of the datasets.

For the similarity calculations between test objects and trained objects, we used the histogram intersection technique ( Swain and Ballard, 1991 ). In this technique, two normalized histograms (i.e., combined feature vectors) are intersected as a whole to determine a distance value. Both of the histograms must be of the same size, and the distance between the histograms is a floating point number between 0 and 1. Equivalence is designated with similarity value 1, and the similarity between the two histograms decreases in parallel with the similarity value approaches to 0.
Let H 1  X  1 ... n and H 2  X  1 ... n denote two normalized histograms .
 Then, S H 1 ; H 2 can be expressed as S where j H j denotes the L 1 -norm (i.e., length) of an histogram H .
We used the PETS 2006 and PETS 2007 benchmark datasets for the training phases. A fivefold cross-validation method is employed and k is chosen as 10. The preprocessing steps include the extraction of the moving regions and their corresponding color and shape vectors. The weights of the color feature vectors are found to be lower than the weights of the other two feature vectors (i.e., distance span and angular span) as expected, since the color values of the objects are less discriminative in video surveillance domain. The classification algorithm outputs the percentages for the class values (e.g., 47% human, 34% non-human, 19% object-group), and the moving region is classified by the highest percentage value. To improve our classification scheme, we are planning to embed more effective clustering techniques to further split the object groups. 3.4. Annotation of events
Having classified the moving objects in a video sequence, we annotated the actions of objects automatically. Counting the number of moving objects gives an important clue about the annotation of an event, since the number of moving objects changes at the time of an event. Hence, we utilized a keyframe-based annotation process, where a keyframe is identified when the total number of moving objects changes or the cell-id of an object changes. This keyframe-based processing provides an easier way for detecting conceptual abnormalities. This type of annotation and meta-data usage reduces the search space and enables efficient querying when the video archives are large (D  X  onderler et al., 2004 ). 3.4.1. Single object annotation
Our system detects the following basic single-object actions: enter , leave , stop , stop-and-go , and eight directional forms of move coupled with the directional predicates (see o direction 4 in Appendix A). The orientation of a moving region, as suggested by our tracking algorithm, is used to directly annotate move actions. When an object stops and moves again later, we annotate the action as a stop-and-go type after detecting the object X  X  next move within a certain time interval. If this type of action takes more time than allowed, then we annotate the action as loitering. The other types of single-object actions are rather easier to detect using the inverted tracking algorithm. 3.4.2. Multi-object annotation
These actions are approach , depart , deposit , pick-up , crossover , and move-together . The first two can be identified by tracking the
Euclidean distance between two objects with respect to the center of mass of the objects in consecutive frames. If the distance between two objects in a previous frame is greater/smaller than the distance in the current frame, these two objects are approaching/departing to/from each other. The remaining four types of multi-object actions are the primary sources for anomalous situations. They are relatively harder to detect and require complex mechanisms. The directional relations between the moving objects are also handled by the help of the tracking scheme. Fig. 4 illustrates the methods that we used to detect these events.
 object actions (predicates) are extracted for all of the object pairs.
Single-object predicates are also extracted throughout the appearance of the objects in the scene. The following sequence of operations illustrates the event-based meta-data extraction for two moving objects: 3.5. Meta-data extraction predicates appear in almost any type of video-surveillance application. The set of rules used in querying can be tailored to specific applications by defining domain-specific predicates in terms of these basic ones. The extracted meta-data includes both object-based facts (i.e., class value, color, shape) and event-based facts (event-label, acting objects, frame number), which are stored at keyframes in a video. The cell-id suggested by the inverted-tracking scheme is also stored with the object-based and event-based meta-data facts to provide view-based querying support. We inserted a video-id descriptor to each of the facts to discriminate the meta-data with respect to different video files in an archive.
 object-based and event-based . The object-based facts contain the class value of the object as well as high-level color and shape descriptors (see o classdesc 4 , o colordesc 4 , and o shapedesc 4 in Appendix A). The class value is determined by the classification algorithm. High-level feature descriptors are determined by performing similarity calculations between the object feature vectors and the pre-defined vectors. For the color descriptor, the primary colors are encoded in a color vector that we use in object classification. The primary color vectors and the object color vectors are intersected (using the histogram inter-section technique), and the most similar primary color label is chosen as the high-level color descriptor for the object. Similar computations are performed for the high-level shape descriptors.
Since our feature vectors are scale and rotation invariant, sample figures for box , cone , cylinder , and sphere are used to encode shape vectors. The most similar pre-defined shape label is chosen as the high-level shape descriptor for the object. Since the color and shape feature vectors of the objects may change in time (especially color), this object information is stored along with the keyframe number and cell-id. The object information fact is specified as follows: object-info(video-id, object-id, object-class-desc, object-color-desc, object-shape-desc, keyframe-number, cell-id).

Event-based meta-data is composed of facts for both single-object and multi-object events. Since an event occurs at a specific keyframe, the meta-data for event-based facts are stored at keyframes. The event labels for both single and multi object event types are also stored separately with the video-ids and keyframe number to be used within the inverse querying support. These event facts are specified as follows: event-info(video-id, event-label, keyframe-number, cell-id). single-object-event-label(video-id, object-id, keyframe-number, cell-id). multi-object-event-label(video-id, first-object-id, second-object-id, direction, keyframe-number, cell-id).

We used an interval-based extension scheme to utilize the fact storage mechanism. If the same event is triggered for at least two consecutive keyframes, a keyframe interval is stored with the event fact instead of separate facts with consecutive keyframe numbers. This interval extension is applied for all facts where it is applicable. This type of fact storage reduces the storage costs of the system significantly. Query processing mechanism is also capable of processing interval based fact storage. A sample listing for the facts-base to clarify the meta-data storage mechanism that we use is given in Appendix C. 4. Query model
One of the most important tasks in automated video surveillance is query processing. Existing systems generally support textual searches for event queries ( Shet et al., 2005; Stringa and Regazzoni, 2000 ). Some systems also support object queries to some extent ( Hampapur et al., 2005 ). However, not every abnormal situation can be queried by keywords, predicates, etc. Some situations can be treated as a sequence of events and the whole sequence is of interest. One of the main contributions of our work is the scenario-based querying capability to detect such sequences, which is not easy to handle in real time. By ordering the events in a scenario, the temporal information about the events is included in the query specification.

Scenario-based querying by an effective set of semantic and low-level features improves the retrieval effectiveness of the framework and decreases the time needed for offline inspection. These gains are more meaningful when the number of events to be searched is relatively large and hard to identify as suspicious in real time, as in after-the-fact analysis in video forensics.
We observe that there is a need for enhancing object queries with low-level feature descriptors. When suspicious events occur, directional specifications about objects give valuable information. Our approach provides support for a wide range of event and object queries, including low-level features and directional predicates, to be posed as a part of the scenario. We also include some specialized query types to provide coherent support for after-the-fact activity analysis. Inverse querying , most popular path , and most abnormal region query types are currently supported. Due to the flexible nature of our data and query models, more complex queries can be formulated. 4.1. Query expression and processing
There are two types of queries: simple and complex . Simple queries have 12 single-object and six multi-object query types. Single-object queries are enter/leave scene , st op/stop-and-go , and move in eight directions. Multi-object queries include approach/ depart , deposit/pick-up , and crossover/move-together . Simple query types can be ordered semantically to form a scenario query, and a timegap value can be specified between simple subqueries. Complex queries are high-level queries that enable scene analysis and statistical offline inspection. Inverse querying , most popular path , and most abnormal region are specific complex query types currently supported in our model.

Our video surveillance query language (VSQL) provides support for integrated querying of video surveillance archives by semantic and low-level features. Semantic subqueries contain 12 single-object event types and six multi-object event types, which can be combined to form more complex queries. Descriptive keywords can be supplied for the color and shape features of objects. Instead of a detailed expression of these low-level features, an intuitive way of query specification is chosen in our model, since it is more realistic that the human operators inspecting (i.e., querying) the videos would choose these features themselves from a set of pre-specified labels corresponding to primary colors. VSQL also provides support for inverse querying. The grammar for VSQL is given in Appendix A. We are also planning to include query-by-example and query-by-sketch types of strategies in the later stages of our work.

Rule-based modeling is effective for querying video databases (D  X  onderler et al., 2004 ). Hence, a rule-based model has been designed for querying video surveillance archives. Fig. 5 shows the flow of execution in our query processing scheme. A VSQL query is sent to our inference engine, Prolog, which processes the meta-data (i.e., fact-base) by using a set of rules (i.e., rule-base). Our rule-base is customizable to specific applications since external predicates can be defined in terms of the existing events. Prior to this rule-based processing, the submitted query string is parsed using a lexical analyzer. Variables (objects unbounded to a value prior to querying) can be specified as part of the query that is to be bound to meta-data after query processing. Scenario with bounded atoms/variables is processed by the inference engine to produce the result set. The following examples show the formulation of scenario-based queries in VSQL.

Query 1. A person enters a lobby with a bag, deposits his bag, and leaves the lobby. conditions. Object conditions are expressed by o objcondition 4 , and event conditions are expressed by o event condition 4 , as stated in the grammar for VSQL in
Appendix A. Based on the fact-base in Appendix C, the result of the scenario-based query is segment [12,17] .

Query 2. Two people enter a lobby, they meet, shake hands, and then leave. surveillance domains. The extracted semantic predicates are the basic ones that can happen in almost every video-surveillance application, and since a rule-based model is chosen for query processing, different context models for different domains can be generated by extending the predicate specifications. This exten-sible nature of our system makes it more expressive and more practical compared to most of the existing systems. 4.2. Scenario-based querying and/or multi-object event subqueries ordered temporally. Satisfy-ing a scenario-based query means that all subqueries in the scenario have to occur in a specific temporal interval. Hence, the result of a scenario-based query is a set of intervals, where each subquery is satisfied in an interval element in the result set.
Definition 2 ( Result of a scenario-based query in a video ). The result R S ; i of a scenario-based query S in a video v i is a set of intervals specified as follows:
Definition 3 ( Result of a scenario-based query ). The result R S of a scenario-based query S for all the videos in the archive is a set of pairs specified as follows: types: non-atomic and atomic . Non-atomicity implies that the condition holds for every frame within the interval. Thus, the condition holds for any subinterval of a non-atomic interval.
Conversely, the condition associated with an atomic interval does not hold for all its subintervals. The intervals in the results of scenario-based queries are atomic, hence they cannot be broken into parts. With this fact in mind, logical conjunction and disjunction operations can be applied to the results.

Assume two scenario-based queries and their results R 1 and R 2 , that contain atomic intervals. Figs. 6 and 7 present the pseudo-codes for obtaining the conjunction R C  X  R 1 4 R 2 and the disjunction R  X  R 1 3 R 2 of the query results, respectively. An example is provided in Appendix B to elaborate on these operations. 4.3. Event-based querying Our query model provides support for event-based querying.
For example, users may want to query all the occurrences of a single event of any single-object or multi-object type in the archive. The result of an event-based query is a set of frames where the event specified in the query has occurred, rather than a set of intervals. Query 3 is an example of event-based querying.
Since the result of an event-based query is a set of frames, the logical conjunction, and disjunction operations can be applied directly on the results.
 Definition 4 ( Result of an event-based query in a video ). The result R
E ; i of an event-based query E in a video v i is a set of frame numbers, specified as follows: R E ; i  X f f E j event E occurs in f E g : Definition 5 ( Result of an event-based query ). The result R E of an event-based query E for all the videos in the archive is a set of pairs, specified as follows: R  X f X  i ; R E ; i  X j i denotes the index of video v i in the archive g : Query 3. Where have all the crossovers happened in videos 1 and 4? select frames from 1,4 where objectA = objdata(class=human), 4.4. External predicate definition
Our query model allows for defining external predicates in terms of the existing ones. The following is a simple example of external predicate definition following the Prolog conventions. The 16-cell grid is ordered row-wise, starting from the top-left corner, with cells 1, 5, 9, and 13 on the left. Thus, enter-left specifies a predicate of entrances from the left of the scene. enter-left(X, F, G) :-enter(X, F, 1);
Once the enter-left predicate has been specified, it can be used as the existing predicate in scenario-based and event-based querying, as shown in Query 4. It should be noted that move-any is another external predicate defined to query the move action in any of the eight directions.
 Query 4. List all the loitering intervals caused by the entrances from the left in video 3. select frames from 3 where objectA = objdata(class=human) and 4.5. Object-based querying
Our query model supports object-based queries in various ways. First, the existence or appearance of an object can be queried. The result of an object-based query is a set of frames where the object has appeared. The low-level features (color, shape) and class values (human, non-human, object-group) of the objects can be used to enrich the query. As in event-based querying, logical conjunction and disjunction operations can be applied directly since the result of an object-based query is a simple set.
 Query 5. List the frames where a black object has appeared. select frames from all where objectA = objdata(class=non-human,
Another type of object-query specification uses the unification concept in Prolog, a mechanism that binds variables to atoms. The query processor returns all the objects satisfying some pre-specified conditions, such as color, shape and class. The result of this type of querying is a list of object labels bound to the variables in the query. This type of querying is more meaningful when the video archive is well annotated, which means that the objects in videos have been assigned labels (e.g., domain-specific names) a priori .
 Query 6. List the names of all the persons with a black coat. select OBJECTX from all where OBJECTX = objdata(class=human, 4.6. Complex querying
In addition to simple queries, we provide a set of complex queries to provide coherent support for after-the-fact activity analysis. Inverse querying , most popular path , and most abnormal region query types are currently supported. Due to the flexible nature of our data and query models, more specific types of complex queries can be introduced at any time; we are planning to add more queries in the later stages of our work. 4.6.1. Inverse querying
Inverse querying means retrieving the list of events (see Query 7) or objects (see Query 8) appearing within a certain time interval in a video. This inverse querying is very valuable for offline inspection and is most effective when domain-specific activity analysis is of concern.
 Query 7. Which events occurred between frames 100 and 1000 in video 1? select events from 1 where inverse(100, 1000)
Query 8. Which objects appear between frames 100 and 1000 in videos 3 and 4? 4.6.2. View-based querying cells to enhance the expressive power of our query model. Queries 9 and 10 are examples of the most popular path and the most abnormal region query types. The results of these queries are based on the row-wise indexing of the 16 cells, where the first cell is in the top-left corner. The most abnormal region is determined by inspecting the high-level events (i.e., deposit, pick-up, crossover, move-together). The cell-id that these events occur most is selected as the most abnormal region. This might be a set of regions since the event occurrences are counted.
 under lying data model for inverted tracking. The cell through which the objects enter the scene most is identified as the most frequently entered region , which is the initial point for the most popular path. The end of this path is traced among the remaining three sides of the scene. If the most frequently entered region is a corner cell, the tracing is carried out among the remaining two sides. The tracing operation to find the end of the path includes determining the cell-id that objects leave the scene most. Having determined the start, end, and the direction of the path, the cells between the start and end cells are traversed such that the cells visited by the objects most are selected.

Query 9. What is the most popular path in video 1?
Query 10. What is the most abnormal region in videos 3 and 4? is found to be 5 and the end cell is determined as 12. All the in-between cells (i.e., 6 ; 9 ; 10 ; 7 ; 11 ; 8 in traversing order) are inspected and the most popular path is obtained. The result for
Query 10 is f X  3 ; f 7 g X  ;  X  4 ; f 14 g X g . 5. Visual query specification an intuitive way of VSQL query specification. This interface is easy to use and devised in a flexible manner, which makes it easily adaptable to various domains. The event predicate labels are manageable through XML-based configuration files; hence, do-main-specific or user-dependent event predicates can be used to express queries.

XML-based repository to make the specified objects available for later use. The scenarios are expressed as a sequence of events and the order of events can be changed to obtain various scenario combinations. The query results are presented in a separate window where the user can browse the results. The specification of Query 11 through the interface is illustrated in Fig. 8 .
Query 11. List the segments from video 1 where two persons, one with a bag , meet ; then the person carrying a bag leaves the bag ; the other person takes the bag ; and then both persons leave. select segment from 1 where objectA = objdata(class=human),
Having specified the events by choosing the objects acting in the event, the scenario is defined based on these events. The scenario drawing panel can be considered a timeline, a widely used query-specification technique for sequence-based data to model temporal relations among events. In this panel, the events can be reordered and time gap between events can be adjusted, which brings more flexibility to scenario-based query specifications. 6. Performance experiments
We tested the retrieval performance of our scenario-based query-processing system by evaluating the methods used in the meta-data extraction process. First, we evaluated the performance of the pixel-level algorithms. Next, we evaluated the object-classification algorithms. The last set of experiments evaluated our semantic annotation process. Since we utilize an SQL-based querying language and use Prolog as our inference engine, the accuracy of our system strictly depends on the peak performance of the above three components.

The evaluation of these algorithms is non-trivial and sub-jective. In Nascimento and Marques (2006) , a discussion on the performance evaluation of object-detection algorithms is given. Among the standard measures, receiver operating characteristics (ROC) analysis ( Fawcett, 2006 ) is used to inspect the effect of a single parameter to the classifier by plotting the true-positive-rate (TPR) and false-positive-rate (FPR) values that are calculated while keeping all the other parameters fixed. Since the algorithms in our keyframe labeling technique yield binary outputs, a set of points is plotted on ROC curves. To elaborate on this, our keyframe labeling algorithm yields exact labels instead of label percentages for keyframes. Hence, a set of points is plotted on ROC curves for the rest of the tests. The points over the x  X  y line are considered as good classification results, whereas the ones below are bad. The best classifier is considered to be at point  X  0 ; 1  X  , which is the farthest point to the x  X  y line.

The benchmark data sets provided by PETS 2006 and PETS 2007 were used as our ground truth for the performance experiments, along with annotations that we performed manually from a set of indoor monitoring videos captured by a static camera at our university. We employed a fivefold cross-validation method for the experimental evaluation. 6.1. Performance of the pixel-level processing
We employ motion-detection, color-feature, and shape-feature extraction algorithms for the pixel-level processing techni-ques. We adapted widely used background subtraction and maintenance schemes for motion detection. For motion tracking, we employed our inverted tracking scheme using motion-history images. For color and shape features, we adapted distance-weighted color and shape vectors, which are composed of angular spans and distance span. Regarding representation and classification, these two feature vectors are shown to be effective through a wide range of performance experiments.

Since ROC analysis requires ground truth evaluation for each parameter setting, we focused on two parameters: a (the learning constant, in Eqs. (3) and (5)) and t (the temporal duration of the movement, in Eq. (6)). Two sets of experiments were carried out for this analysis. In both of the experiments, the learning constant a varies from 0.6 to 0.8 in increments of 0.05, yielding five points in the ROC curve. The temporal duration constant t is set to 2 and 3. The extracted regions are annotated manually, and correctly detected pixels are considered as true ( Nascimento and Marques, 2006 ). As shown in Fig. 9 , the optimal values for the two crucial pixel-level parameters are found to be 2 for t ,and0.7for a ,since the points corresponding to t  X  2 are closer to the  X  0 ; 1  X  point. The 6.2. Performance of object classification
The object-classification algorithm that we used takes region data as the input and yields classification values as percentages. The maximum of these values is chosen as the class value for the input region. Hence, our classification algorithm outputs three classes: human, non-human, and object-group.

In this evaluation, we computed two types of classification accuracies: standard classification accuracy ( SCA ) and frame-based classification accuracy ( FCA ). The former is the percentage of correctly classified objects for each class type, and the latter is the frame-weighted percentage of classification accuracy for each object classified correctly. To elaborate on these definitions, Eqs. (9) and (10) are given for the human class type as follows: denote its cardinality. The SCA for the human class type is formulated as
SCA H  X  j CC H j where H is the set of objects of human class type.
 present, and FCC H denote the set of frames where at least one human is classified correctly. The FCA for the human class type is formulated as
FCA H  X  j FCC H j
Since the number of frames (i.e., keyframes) that an object is classified correctly was taken into consideration, the frame-based accuracy analysis gives better results. The lowest accuracy improvement in the frame-based analysis is for the human class type; many people enter and leave the scene, and in most cases, they are classified correctly. Frame-based classification accuracies for the other two object classes improved significantly when compared to standard accuracies. 6.3. Performance of semantic annotation the detection of each manually annotated event type is inspected.
Since both scenario-based and inverse queries are processed by our inference engine, the retrieval accuracy can be evaluated by the performance of the event-detection mechanism. To be more realistic, the percentage of the frames in which the events are correctly identified is used to judge the accuracy of the event annotation instead of just counting the correctly identified event types. This analysis is similar to the frame-weighted classification accuracy above, and the results are presented in Fig. 11 .
 simplify the analysis. The accuracy is very high for enter/leave, move, and approach/depart events because they can be detected directly from region extraction. Since we incorporate the number of frames in which an event is identified into the accuracy value, multi-object event types have lower accuracy values than the other event types. This is simply because regions detected as 0 0.2 0.4 0.6 0.8 1 0.793 object-groups cannot be split into single objects in the frames they are detected.

If an event is detected in at least one frame during its occurrence period, the scenario-based querying and retrieval process is still be effective. This observation is also true for inverse querying because the event is retrieved if it is detected in even a single frame within the querying interval. Since we utilize Prolog as the inference engine in the querying process, the query processor will retrieve what is extracted as meta-data. However, depending on the accuracy of the meta-data extraction process, there might be events that cannot be retrieved since they are not extracted as meta-data either (see Fig. 11 ). It can be concluded that the performance of scenario-based querying and retrieval is at least as high as the performance of the semantic annotation process.
Our meta-data extraction scheme supports a wide range of event predicates, and provides external predicate definition in terms of the existing predicates. This capability is provided not only to increase the expressive power of the query language but also to make the querying mechanism tailorable for specific video surveillance applications.
Undoubtedly, there can be events that cannot be specified using our event predicates, but in our opinion, we have covered an adequate set of events that can be considered as abnormal situations in most of the video surveillance applications. 7. Comparison to related work Query effectiveness relies on the meta-data extraction process.
The background maintenance scheme we employ is similar to that of VSAM ( Collins et al., 2000 ) with an improvement that the extracted background is also used for object tracking. We employ a strategy of moving-object counting similar to the one presented in Kim and Hwang (2002a) , extended with a keyframe detection scheme to provide an effective storage for predicates.
The event predicates extracted in our data model are generic in the video-surveillance domain and generally supported by existing systems (e.g., Lyons et al., 2000; Stringa and Regazzoni, 1998; Brodsky et al., 2001 ). Object-based querying is also implemented in most of the existing systems (e.g., Kim and
Hwang, 2002a; Hampapur et al., 2005 ) to some extent. The queries based on color are considered in some systems (e.g., Stringa and Regazzoni, 2000, 1998; Regazzoni et al., 1998 ); however, the existing query models are not rich enough to support low-level features about the objects. We extract object-based low-level features and provide a scenario-based querying scheme for complex querying, also including color and shape descriptors of the objects (e.g., Queries 5 and 6).

Our query model supports scenario-based querying, which allows temporal ordering of event predicates, as well as of object information, based on low-level feature descriptors and direc-tional predicates. An inverse-querying scheme is also provided to help the offline inspection process. In addition, view-based querying is available, which augments the query expressiveness of our model. Hence, one of the main differences between our querying mechanism and that of MILS ( Hampapur et al., 2005 )is that we provide mechanisms for defining specialized queries in a more expressive manner (e.g., Queries 7 X 10).

Our query-specification scheme is based on VSQL, which provides an intuitive way of expressing logical predicates. In VidMAP ( Shet et al., 2005 ), the authors provide high-level rules for a couple of query types. In contrast, we provide low-level feature descriptions and directional predicates, as well as temporal information about events to enrich the supported query types. Our query-processing system also supports view-based querying. Compared to the existing systems, the proposed scenario-based query-processing approach provides support for a wide range of query types and facilitates after-the-fact analysis. 8. Conclusion
We propose a scenario-based query-processing system for video surveillance archives, which provides a mechanism for effective offline inspection. A scenario-based query is specified as a sequence of event-based subqueries that can be enriched with object-based low-level features and directional predicates. With the help of the proposed inverted tracking technique, the system provides support for view-based query handling using a fixed view-based representation of the content. Our system also provides support for inverse querying as a specialized tool for after-the-fact activity analysis. We developed Video Surveillance Query Language, which is specialized for scenario-based querying. We present a rule-based query-processing module to provide not only an efficient processing mechanism for scenario-based querying, but also a flexible medium for external predicate definition, which allows the system to be tailored to various domains. We also present a visual query interface to facilitate the query specification process.

The performance of our scenario-based querying system was evaluated through a set of experiments. Since the performance of the overall querying scheme strictly depends on the meta-data extraction process, we also carried out experiments on these pixel-level and region-level methods. It was shown through these experiments that the querying support of our system is highly effective and has expressive power in offline inspection. our query-processing system, we are planning to implement the negation operator for scenario-based query results and for variables in the query-specification process. There might be specific uses for this negation operator for the inspectors. In the query-specification interface, we are planning to include a natural language parser that can learn domain-specific keywords a priori .
This will simplify the query-specification process and enrich the semantic quality of the results.
 Appendix A. Grammar for Video Surveillance Querying Language (VSQL) /* main query string */ o query 4 :  X  select o target 4 from o range 4  X  where o query condition 4  X ; X  o target 4 :  X  segments j /* retrieve video sequences/intervals */ o objectlist 4 :  X  X  o objectlist 4  X , X  o objlabel 4 o range 4 :  X  all j o videolist 4 o videolist 4 :  X  X  o videolist 4  X , X  o vid 4 o objectassignm ent 4 :  X  o objlabel 4 o objoperator 4 o objcondition 4 o scenario 4 :  X  X  o scenario 4  X  o timegap 4 o event condition 4 o inverse condition 4 :  X  inverse  X ( X  o intvalue 4  X , X  o intvalue 4  X ) X  /* event query conditions */ o multi object event condition 4 :  X  o multi object event label 4 o multi object condition 4 :  X  o objlabel 4  X , X  o objlabel 4  X   X , X  o direction 4 /* object conditions */ o objcondition 4 :  X  objdata  X ( X  o objdesclist 4  X ) X  o objdesclist 4 :  X  X  o objdesclist 4  X , X  o objdesc 4 o objdesc 4 :  X  o classdesc 4 j o colordesc 4 j o shapedesc 4 o classdesc 4 :  X  class  X   X   X  o classvalue 4 o colordesc 4 :  X  color  X   X   X  o colorlabel 4 o shapedesc 4 :  X  shape  X   X   X  o shapelabel 4 o shapelabel 4 :  X  box j cone j cylinder j sphere o classvalue 4 :  X  human j non human j object group /* primitive types */ o intvalue 4 :  X  X  1 9  X  X  0 9  X  o vid 4 :  X  o intvalue 4 o timegap 4 :  X  o intvalue 4 o objlabel 4 :  X  X  a z  X  X  A Za z0 9  X  o objoperator 4 :  X   X   X   X  j  X  X != X  X  Appendix B. Conjunction and disjunction examples Assume the results of two scenario-based queries are as follows:
R and
R  X f X  1 ; f X  200 ; 475 ;  X  520 ; 700 g X  ;  X  2 ; f X  120 ; 340 g X g : R Since  X  447 ; 740  X  520 ; 700 ,
R 4 R 2 ; 1  X f X  447 ; 740 g : Hence, R  X f X  1 ; f X  447 ; 740 g X g and R Appendix C. Sample facts-base stopped. 1 object-info(1, obj001, human, blue, box, 12, 5). 2 object-info(1, obj001, human, blue, box, 13, 6). 3 object-info(1, obj001, human, blue, box, 14, 6). 4 object-info(1, obj002, non-human, white, box, [14,17], 6). 5 object-info(1, obj001, human, blue, box, 15, 7). 6 object-info(1, obj001, human, blue, box, 16, 8). 7 event-info(1, enter, 12, 5). 8 event-info(1, enter, 14, 6). 9 event-info(1, deposit, 15, 7). 10 event-info(1, stop, 16, 6). 11 event-info(1, leave, 17, 8). 12 enter(1, obj001, 12, 5). 13 move-east(1, obj001, 13, 6). 14 enter(1, obj002, 14, 6). 15 move-east(1, obj001, 15, 7). 16 deposit(1, obj001, obj002, west, 15, 6). 17 move-east(1, obj001, 16, 8). 18 stop(1, obj002, 16, 6). 19 leave(1, obj001, 17, 8). ...
 References
