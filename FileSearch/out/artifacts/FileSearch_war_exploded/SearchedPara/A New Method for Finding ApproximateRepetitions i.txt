
Di Wang 1 ,GuorenWang 1 ,QingquanWu 1 , 2 , Baichen Chen 1 ,andYiZhao 1 In the human, coding sequences comprise less than 5% of the genome, whereas re-peat sequences account for at least 50% or much more [1] [2].They embody a large amount of information concerning key clue of human evolution and abundant information of antiquated life [2]. Nowadays the repeat sequence as a heretical mark is widely applied in the fields of tumor biochemistry, forensic medicine in-dividual recognition, parent-child appraisal, population genetics and so on [3] [4]. For example, the recent research shows that CCG trinucleotide repetitions have important effect on pre-mutation of X chromosome [5].

Finding repetitions is a difficult task and the first obstacle in the way is how to give a formal definition of repetitions as was once pointed out by G. Benson [6]. The search of the repetitions can be classi fied into two kinds, perfect repetitions and approximate repetitions, the patterns of one perfect repetition being all the same. We have proposed a new definition LPR for prefect repetitions and designed an index SUA for finding LPRs [14]. However, events such as mutations, translocations and reversal events will often render the copies imperfect over time, so the approximate repetitions are present, whose patterns are not all the same. Finding approximate repetitions is harder work than finding perfect repeats and has been studied by many researchers during recent years. In this paper, we will focus on the search for approximate repetitions, whose copies of a repetition are tandemly.

The approximate repetitions search methods can be classified into two kinds according to the search result: the exact method by which all the repetitions can be found according to the given definition and the heuristic method with which we cannot be sure to find all the repetitions. In the exact methods, Landau and Schmidt [7] proposed the algorithm for finding the tandem repeats where the hamming or edit distance of the two patterns of the repeat has some given value. Kurtz proposed the algorithm for finding all the maximal repeat pairs under the given hamming distance. Sagot and Myers designed the algorithm for finding approximate tandem array [8], but the algorithm requires the length of a pattern be less than 40 and the continuous occurrence of the pattern be given in advance. Compared with exact methods, heuristic methods are not so good in that we cannot with those methods find all the approximate repetitions according to the definitions of the repetitions that we are able to find with exact methods, but the definitions are more acceptable to the biologist. Most of the methods are based on statistic, with which we find possible approximate repetitions according to the statistics information, and then discover the approximate repetitions from them [9] [10]. One of the most popular algorithms is Tandem Repeat Finder [10].
In this paper we X  X l present a new approach to detect approximate repetitions in DNA sequence. Similar to [10] and [11], we use a two-phased algorithm, which consist of candidate phase and verification phase. Our main contributions are i) we use a new criterion to express the percentage differences between patterns even though the lengths of the copies may not be equal; ii)in candidate phase we employ frequency distance and Pearson correlation as filter to find the candi-dates; iii) our method requires no priori knowledge such as the pattern, pattern size or the number of copies; iv) we use SUA index instead of sliding window to find patterns which has no limitation on the size of copies in a repetition.
The remainder of this paper is organized as follows. In section 2, we import a new criterion for approximate repetitions. We design the filters for detection of candidates of approximate repetitions in section 3. In section 4, we first use SUA to attain copies of repetitions and then use the two-phased method to find the approximate repetitions. In section 5 the algorithm is tested thoroughly. Finally, in Section 6 we draw our conclusion. To process approximate matching, one common and simple approximation met-ric is called edit distance.
 Definition 1. Edit distance The edit distance between two sequences is defined as the minimum number of edit operations (i.e. insertions, deletions and substitutions) of single characters needed to transform the first string into the second. Ed(S, P) is used to denote the edit distance between sequence S and P. Given the two sequences S1 and S2, the similarity between them is the fixed number of differences in traditional methods, i.e. Edit distance. But Edit distance suitable for short patterns would be unreasonably restrictive for long patterns in the repetitions comparison. Conversely, Edit distance suitable for long patterns would be not strict enough for short patterns. Another criterion of similarity is percentage difference proposed in [10], which takes the Edit distance and the lengths of patterns into account. But the lengths of copies in an approximate repetition are different so that we cannot use this percentage difference directly. Take S1=ACCT ACG ACGTA for instance, the Edit distances between every two copies are the same but the lengths of copies are different. In this case we cannot evaluate the similarity of copies by percentage difference. But it is obvious that in the process of the comparison between two copies of chars, in which we change one copy into the other copy with the minimum number of deletions, insertion or replacements, the number of chars which remain unchanged in their original positions is fixed.
 Definition 2. ReservedChar Let S1, S2 be two sequences from the alphabet namic programming. If c j is a char of S1 with index j ( 0  X  j &lt; | S 1 | ), and c j still occurred (not been deleted or replaced) in S X  with index j X ,we call c j is a ReservedChar of S1 to S2. In the same way, if c k is a char of S2 with index k( 0  X  k&lt; | S 2 | ), and c k still occurred in S X  with index k X , we define c k is a ReservedChar of S2 to S1.
 Definition 3. ReservedChar Pair Let S X  be an alignment result sequence of S1, S2 by dynamic programming, c j is a ReservedChar of S1 to S2 occurring in S X  with index j X  , and c k is a ReservedChar of S2 to S1 occurring in S X  with index k X ,ifj X ==k X ,thenwedefine( c j , c k ) a ReservedChar Pair of S1, S2.
 For example, given S1 = ACATTA and S2 = AATG, we denote X i as char X occurred at index j in a given sequence, if S X  = AATG, then A 1 , A 3 , T 4 are reserved chars of S1 to S2 ( T 5 is deleted ); all chars of S2 are reserved chars of if S X = ACATTA, then all chars of S1 are reserved chars of S1 to S2; A 1 , A 2 , T 3 pairs of S1, S2.
 Evidently, we have Property 1 as follows: Property 1. If c j is a ReservedChar of S1(to S2) or S2(to S1), then c j belongs to at most one ReservedChar Pair of S1 and S2.
 Definition 4. Reserved Number Let S1, S2 be two sequences from the alphabet number of ReservedChar Pairs of S1 and S2, abbreviate as ResNum (S1, S2). As is known, Edit Distance (ED) expresses the difference between two sequences S1, S2, and here we describe the meaning of ResNum (S1, S2). According to the definition of ReservedChar pair , c j and c k in ReservedChar Pair ( c j , c k ) can be looked upon as a char pair which are matched with no need of insertion, replacement or deletion operation. So the Reserved Number of S1, S2 expresses the sameness between S1 and S2.
 Property 2. Let S1, S2 be two sequences from the alphabet = { a 1 ,a 2 ,  X  X  X  ,a n } ; then ResNum (S1, S2) is a definite value, which is determined by ED(S1, S2). We define a new function based on ED and ResNum to find similarity of two sequences.
 Definition 5. Similar(S1, S2) . Let S1, S2 be two sequences from the alpha-bet = { a 1 ,a 2 ,  X  X  X  ,a n } . We define Similar(S1, S2) as: Similar(S1, S2) = ResNum(S1, S2)/ED(S1, S2).
 Forexample,ifS1=ACATTAandS2=AATG,thenResNum(S1,S2)=3, ED(S1,S2)=3, so Similar(S1,S2)=3/3=1.

In fact, Similar(S1, S2) expresses the ratio of the sameness to the difference between S1 and S2. So, it is reasonable to take Similar(S1, S2) as the criterion to the similarity between sequences. Obviously, Similar(S1, S2) has the following properties.
 Property 3. The more similar S1 and S2 are, the bigger the value of Similar(S1, S2) is.
 According to the property 3, given a lower bound of similarity value  X  ,allthese-quence pairs (Si, Sj) that meet Similar(Si, Sj)  X   X  are the results of the similarity search. If we improve  X  , the more similar pairs could be found.
 Note that, given two sequences S1 and S2, ED(S1, S2) and the ResNum(S1, S2) is got by DP, then Similar(S1, S2) can be computed. Because of the time and space complexity of ED computation, we will propose two appropriate filters in order to produce the smaller candidate set to compute edit distance. Let m and n be the lengths of sequences S1 and S2, then the edit distance, ED(S1, S2), and the corresponding edit operations can be determined in O(mn) time and space [12]. In the search of approximate repetitions in DNA sequences, firstly, the sequences are usually large, even as long as tens of giga bps; secondly, given a sequence of length n, the number of its substring is as large as O( n 2 ). If we directly compute edit distance to abtain the value of the function Similar between sequences, the time and space complexity is unacceptable. So we design two kinds of filters, and we compute only the function Similar of the sequences chosen by the filters. We will introduce some background about the filters. 3.1 Proposed Techniques Frequency Distance Definition 6. Frequency Vector . Let S be a string over the alphabet = { a =[ f 1 ,  X  X  X  ,f n ],where each f i (  X  0) corresponds to the occurrences of a i in S. For example, if S=ACTAT is a genomic sequence (i.e. from alphabet = { A, C, G , T } ), then f(S) = [2, 1, 0, 2].
 Definition 7. Frequency Distance . Let u and v be integer points in dimensional space. The frequency distance, FD(u, v), between u and v is defined as the min-imum number of steps in order to go from u to v (or equivalently from v to u) by moving to a neighbor point at each step.
 Let u and v be vectors in the same dimension, let Pos = Neg = computation of FD is linear, so the time and space complexity of FD is much lower than that of ED. The detail about FD is in [13]. An important property of frequency distance is that, given two sequences S1 and S2, FD(f (S1), f(S2))  X  ED(S1, S2) [13].
 Pearson Correlation Pearson Correlation, i.e. linear correlation, measures the strength of a linear relationship between two variables. It ranges from -1 to 1. A correlation of +1 means that there is a perfect positive linear relationship between variables and a correlation of -1 means the perfect negative linear relationship between variables. And 0 means there isn X  X  a clear linear relationship between variables.
For two vector X=[ x 1 ,x 2 ,  X  X  X  ,x n ]andY=[ y 1 ,y 2 ,  X  X  X  ,y n ], their Pearson cor-relation is expressed as follows:
In the section of filter design, we will describe how to construct the vectors X and Y according to the sequences, and tak e Pearson correlation as the criterion for sequences similarity. 3.2 Filters Design FD Based Filter Frequency distance is widely used as a simple and efficient filter in search of similar sequences. We propose a FD based filter Similar FD for the function Similar. As mentioned above, given the sequences S1 and S2, FD(S1, S2) can be seen as a filter for ED(S1, S2), so the key problem is to define the filter for ResNum(S1, S2). Definition 8. ResNum FV . Let S1, S2 be two sequences from the alphabet  X  X  X  ,fn fined as: Definition 9. Similar FD . Let S1, S2 be two sequences from the alphabet = { a (S1, S2) / FD(S1, S2).
 Lemma 1. Let S1, S2 be two sequences from the alphabet = { a 1 ,a 2 ,  X  X  X  ,a n } , ResN u m FV ( S 1 ,S 2)  X  ResN u m ( S 1 ,S 2) .
 Theorem 1. Let S1, S2 be two sequences from the alphabet = { a 1 ,a 2 ,  X  X  X  ,a n } , Si m ilar F D ( S 1 ,S 2)  X  Si m ilar ( S 1 ,S 2) .
 In the interest of space, we omit the proofs of the properties, lemma and theorem in this paper.

Given the two sequences S1 and S2 and the valve value of Similar()  X  ,wecan prune S1 and S2 without computing Similar(S1, S2) if Si m ilar F D ( S 1 ,S 2) &lt; X  . So we take Similar FD() as the filter for Similar().

We give the performance of the FD based filter in the experiments. Similar to other methods based on FD, the performance of Similar FD() is quite sat-isfactory when the sequences are short, however, it descends rapidly when the sequences are long. So, regarding the lon ger sequences, we give the following PC based filter.
 PC Based Filter Experiments show that the performance of the filter based on frequency function descended with the increasing of the lengths of sequences. We can come to the same conclusion by theoretical analysis. Let X  X  take the frequency distance func-tion FD for example. It uses the occurrence frequency of a char in the compared sequences as the similarity filter feature. If the sequences are short, it is really done. However, with the sequence length increasing, the occurrence frequency of a char will approach some statistical values, which is independent of the se-quences. For example, in a genetic sequence of length more than 1M, there will be about 1/4M  X  X  X  char. That means, when the sequences are long enough, they will have almost the same frequency vectors. So the FD filter will not function.
So, when the compared sequences are long, the statistical feature of a char frequency will cover up their every local difference. To solve the problem we propose a new filter method based on Pearson correlation coefficient.
The new method is sourced from the following idea directly: 1. According to the analysis above, when the compared sequences are short, the 2. If two long sequences S1 and S2 have high similarity, their subsequences in
So, given two long sequences S1, S2 to be compared, we propose the filter method as the following, which includes two step-operation: Step1: Divide two genomic sequences S1, S2 both into n subsequences and we C C ( T Pearson X  X  correlation. Take  X  X  X  as example, we get vector X A =[ A 11 ,  X  X  X  , A 1 n ] from S1 and vector Y A =[ A 21 ,  X  X  X  , A 2 n ]fromS2.
 Step2: Compute Pearson( X A , Y A ), Pearson( X C , Y C ), Pearson( X G , Y G ), and Pearson( X T , Y T ). And set a valve r, if the four coefficient value above are all probably and add them into the candidate set.

Here are some explanations. The method presumes if the two sequences to be compared are similar; the frequency vector got from their subsequences will have high correlation. In most cases, it is the fact. However, there also are some exceptional cases. So the filter method will probably filter out some sequence pairs which are really similar. Fortunately, the lost pairs are very few, but the filter method can filter long sequences efficiently. In the last part of the paper, we will show the efficiency of the filter method through thorough experiments. Hybrid of the Two Filters In the previous section, we proposed two filters to construct candidate set. The Similar FD filter will function well if the compared sequences are short while the PC based filter is efficient for long sequences. So, we integrated the two methods in practice according to the lengths of s equences and we perform experiments to determine the borderline value of the two methods. In the experiment section we will give a detailed discussion about it. 4.1 Sequence Partition Here we design efficient filters for the similar sequences search in database based on Similar. A key phase for the search of approximate repetitions is to partition the query sequence into fragments and filter the adjacent fragments by the func-tions discussed above. A general method of partitioning the sequence is sliding window method and its fatal shortcoming is that only the tandem fragments with the same length can be found. To avoid this shortcoming we use SUA [15]. SUA is an index structure that we design for finding perfect repetitions [14]. In repetitions finding, the copy of a repetition is generally called pattern. For example, in repetition ACGACGACG, ACG is the pattern. Through further analysis of the patterns in the repetitions, we find that a pattern comprises some units with the same characteristics.
 Definition 10. pattern unit . Let S be a sequence and substr be a substring start-ing with symbol X (it is A, C, G, T or $ in DNA sequence) of S. If the successor of substr is X or $ and there is no X in substr except for the first symbol, we call substr a pattern unit of X in S.
 For example, in the sequence ACGAGATC$, the substring ACG, AG and ATC are pattern units of A but ACGAC and AT are not. For the purpose of conve-nience,  X $ X  is seen as a pattern unit although it cannot be a part of any pattern. Definition 11. Succeeding Unit Array (SUA) .LetSbeaDNAsequenceof length n . We sort all the pattern units in ascending order (the regulation of the sorting is the same as the regulation of string sorting. If two pattern units are equal, we sort them according to their succeeding string) and get n pattern units. Every pattern unit and the position of its succeeding pattern unit (succeeding pattern unit of a pattern unit pu is the pattern unit of the succeeding symbol of pu ) after sorting (the position of $  X  s succeeding pattern unit is marked as -1) compose a new array  X  Succeeding Unit Array.
 For example, in the sequence ACACACTAT$, there are four pattern units of A (one is ACT , one is AT, and the other two are AC), three pattern units of C (one is CTAT and the other two are CA) and two pattern units of T (one is T and the other is TA). The SUA is illuminated in figure 1.
The construction and the performan ce of SUA has been discussed in [15]. For the purpose of convenience, given a sequence S, we call the substring of S a compound pattern unit which comprises some pattern units of the same symbol. 4.2 Candidate Phase In candidate phase, we first take all the pattern units as the copies of repetitions and then add every pattern unit and its successor pattern unit which is gained according to the succeeding information in SUA as a pair to candidate set if they meet the filter function. Secondly, similar to perfect repetitions search in [14], compound pattern units are produced according to the succeeding information of pattern units. And then we push the compound pattern units and its successor into candidate set if they meet the filter function. The details are shown in [14]. Algorithm 1. candidate set 4.3 Verification Phase Given a list of candidates, the verification phase will work out the real the approximate repetitions.

The researchers have defined the types of repetitions, the simple, neighboring and pairwise approximate repetitions [14]. Clearly, different types of approxi-mate repetitions lead to different verification procedures. Here, for neighboring approximate repetitions a two-phased verification procedure is performed.
Firstly, the Similar() of every pair in the candidate set is computed by DP to determine whether the pair meets the query.

Secondly, these two-copy approximate repetitions are connected into repeti-tions which contain more repeats if the last copy LC of the former repetition is the first copy FC of the latter repetition. The information of connection can be got by the succeeding information provided by SUA (the details can be found in [16]). We also found the pairwise approximate repetitions in [16].
In the search for approximate repetitions, we avoid two kinds of redundant results:(1) For a repetitions P 1 P 2  X  X  X  P k ,which have k copies and P i is one copy (1  X  i  X  k ), we only produce the repetitions P i  X  X  X  P j (1  X  j  X  k )with i = 1 and j = k. (2) For the repetitions which have the same start position and end position but different expressions, we on ly output the expression which has the most copies. In this section, we X  X l evaluate performance of filters and compare the repeti-tions we found with the result of Tandem Repeat Finder. The test data is DNA fragments from Human chr18 and chr22.

We implement the algorithms in C++ under Windows XP. All the experi-ments are run on a Dell PC with 2.6GHZ Intel Pentium processor with 512M memory. And we set the valve value of Similar=3.

We have mentioned the performance of FD based filter will drop rapidly with the increment of lengths of copies. Let frag short be the shorter one of every two adjacent fragments, let candidate Num[ l ] be the number of the candidates with frag short = l and result Num [ l ] be the number of correct results with frag short = l .WeusePerformance FD( l ) = candidate Num [ l ]/result Num [ l ] to evaluate the performance of FD base d filter, and in the experiment we set 12  X  l  X  34. When the length of frag short is larger than 18, the curve tendency of Performance FD increases rapidly. For the efficiency of the method, we use PC based filter when the copies are longer and our method becomes a heuristic method because some results will be lost. According to Fig.2, we decide to use the PC based filter when lengths of the two adjacent fragments are both bigger than 18. Otherwise, we use FD based filter.
Before using PC based filter to produce candidate set, we need to decide two parameters, the valve value of the correlation and the value of partitions that we divide the copies into. We choose these two values according to the proportion of results and candidates found with PC based filter to those found with FD based filter in experiments. We use 2 to 5 as the number of partitions and 0.3 to 0.6 as the valve value of the correlation. We take two fragments with the size of 60K from human chr18 and chr22 as test data. The (A) and (C) of Fig.3 shows that there is quite a rapid decrease of the proportion of right results found with PC based filter when valve value of correlation is bigger than 0.4 on different partitions. But the proportion of candidates decreases smoothly from 0.3 to 0.6 in (B) and (D) of Fig.3. So we choose 0.4 as the valve value of correlation. We choose partition=3 through the experiments for similar reason for choosing valve value of correlation. And we use partition=3 and valve value=0.4 to accomplish following experiments.
We compare the efficiency of FD based filter and the hybrid method by ex-ecution time and the number of right results and candidates. Fig.4 shows that the right results we lost is smaller than 3% but we cut down more than 35% on candidates and the saving of execution time is satisfactory.
In order to prove the validity of our method, we compare approximate rep-etitions found with our methods with the results found with Tandem Repeat Finder under the same condition in Fig.5. Our results always cover almost 95% of the results found with Tandem Repeat Finder and our results are much more than that of TRF using TRF X  X  definition as shown in Fig.5, which proves the efficiency of our methods. The detailed analysis of the results can be found in http://mitt.neu.edu.cn. In this paper, we have considered the problem of finding approximate repetitions in a DNA sequence. We have proposed a new method, which expresses the ratio of sameness to difference between two sequences, to efficiently judge the similarity between any two copies in a repetition. We have also provided two new filter methods to sort out candidate set of approximate repetitions: the Similar FD filter function based on FD worked efficiently for short sequences; the PC based filter method worked well for long sequences. When sorting out candidate set, by using SUA instead of sliding window, we can get patterns of different lengths. And in this paper, we have given some theoretical analysis and experimental results to validate the efficiency of our method.

However, the PC based filter method has its limitation in not being able to work out the complete candidate set. So, the next step for us to take is to search for some more efficient filter methods for long sequences and to try to apply our method to looking for dispersed repetitions in DNA sequences to see if it is efficient enough.
 Acknowledgment. This research was supported by the National Natural Sci-ence Foundation of China (Grant No. 60273079 and 60573089).

