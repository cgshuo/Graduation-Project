 With the emergence of social networks and computational biology, more data are in the forms of multi-labeled graphs, where a vertex has multiple labels. Since most algorithms focus only on single la-beled graphs, these algorithms perform inefficiently when applied to multi-labeled graphs. In this paper, we investigate the problem of subgraph indexing and matching in the multi-labeled graphs. The label set on a vertex is transformed into a high dimensional box. The R-tree is employed to store and index these boxes. The vertex matching problem can be transformed into spatial range queries on the high dimensional space. In addition, we study two types of queries: location and existence queries. In this paper, detailed al-gorithms are provided to process these two types of queries. Real and synthetic data sets are employed to demonstrate the efficiency and effectiveness of our subgraph indexing and query processing methods.
 CATEGORIES H.3.1 Content Analysis and Indexing GENERAL TERMS Algorithms, Theory KEYWORDS Multiple labeled graphs, R-Tree, Subgraph query
With the emergence of bioinformatics and social sciences, a large amount of data can be represented as graphs. There is an increas-ing interest in developing fast indexing and querying algorithms that operate on graphs. Most algorithms can only work on single labeled graphs, e.g., a vertex has only one label, while many real world graphs are multi-labeled. The following are some examples.
In protein interaction networks, vertices representing proteins, an edge is added between two proteins if an interaction exists between them. The label of the vertex is the protein X  X  function annotations, e.g., gene ontology terms. The ontology consists of three domains: (1) cellular component, the parts of a cell or its extracellular envi-ronment; (2) molecular function, the elemental activities of a gene product at the molecular level, such as binding or catalysis; and (3) biological process, operations or sets of molecular events with a de-fined beginning and end, pertinent to the functioning of integrated living units: cells, tissues, organs, and organisms. Thus, protein in-teraction networks are better to be modeled as multi-labeled graphs than single labeled graphs.

Another challenging problem in computational biology is to search for a well-characterized pathway in a less studied model organism. One approach to identify pathways across multiple species would be the utilization of protein domains and familial information based on domains. A protein domain is a part of protein sequence and structure that has the functional component of the protein sequence. The domain information can be used to classify known proteins into familial relationships. In other words, these domains and the familial information can be used as labels to annotate the protein. One application is to query for pathways from well studied model organisms. Such an approach would be quite useful since during evolution, many of the domains remain intact, with alterations in various other parts of the protein sequences.

In software engineering, system dependence graphs [7] that model the dependency among statements of a program generally have multiple attributes. A node representing a statement containing an expression, such as an assignment statement or a conditional branch point, may have multiple attributes such as, an attribute rep-resenting the abstract syntax tree (AST) of the expression and the source code location. A subgraph may represent a code defect (bug) [13]. By locating the bug in the code, the software engineer can find possible bugs in a program.

In a typical online social network, users being vertices, an edge is added between two users if they are friends, relatives, colleagues, etc. A vertex may have multiple labels describing the user X  X  per-sonal information, e.g., age, gender, occupation, hometown, mar-tial status, etc. A subgraph in this context may represent a group of people with special relationships or connections.

In the above applications, the database graph can be character-ized as a multi-labeled graph. There are a set of gval categories of labels associated with each vertex. For each category C i may have a specified label or a non-specified label. Figure 1 shows an example of a multi-labeled graph where each vertex has three specified labels and two query graphs where each vertex has one or two specified labels. The goal is to find match(es) of the query graph in the database graph.

Indexing has been a popular method in subgraph matching. In most of these work [12, 21, 20, 18], the neighborhood information is used to find mapping from a query vertex v to a database vertex u . The main idea is that if u is a match of v , the neighborhood of u has to contain that of v . For example, let NH G ( u, k ) be the set of vertices that are k hops/edges away from u in G . In order to qualify u a match of v , the labels of vertices in NH G ( u, k ) have to be a superset of the labels of vertices in NH Q ( v, k ) . In the context of single vertex label graphs, the subset/superset relationship can be easily computed. Even when the set is very large, some probabilis-tic data structure, e.g., bloom filter [20] can be used to compute the subset relationship efficiently and accurately.

The multi-labeled graph presents a unique challenge: how to find one neighborhood contains another.One method is to take the union of all labels in a neighborhood. For example, if there are two vertices in NH G ( u, k ) and their labels are { a 1 ,b { a 2 ,b 2 ,c 2 } . Then the overall label set in NH G ( u, k ) is { a 1 ,a 2 ,b 1 ,b 2 ,c 1 ,c 2 } . By taking the union, the problem becomes the superset/subset computation again, for which existing methods could be applied. However, this would introduce a large amount of false positives. For instance, let X  X  assume that NH Q ( v, k ) has one vertex with labels { a 1 ,b 2 } . u would be considered a match for v under the union label scheme. However, it should not be since { a 1 ,b 2 } is not a subset of either vertex label set in NH The union approach does not work because in the multi-label graphs, what we want to find is not whether a set of labels is a subset of another set, but is really a containment problem, which could be stated as following. For two given sets of sets A and B ,forev-ery set B in B , whether there exists a set A in A such that A is a superset of B .

A novel method is proposed in this paper to address the neigh-borhood containment problem. The label set of every vertex in G is transformed into a gvl dimension box in the R gvl space, where each dimension corresponds to a category of labels. If a vertex has a specified label at category C i , then in the corresponding dimen-sion, the label set is mapped to a specific value. On the other hand, for an unspecified category C i , the label set is mapped into a range [ min, max ] on the corresponding dimension where min and max are the minimum and maximum mapped values for any label in category C i . Under this transformation scheme, if a label set X is a superset of another label set Y , then the box corresponding to X should be contained within the box corresponding to Y .Now the problem of neighborhood containment becomes the problem of range queries at a high dimension space. Thus, the R-tree [6] is used to store and index these transformed boxes in the high dimen-sion space. As a result, the neighborhood containment problem can be solved efficiently, which leads to an efficient vertex matching procedure.

The neighborhood containment only considers set relationship, but not the matches. For example, NH G ( u, k ) has two vertices labels { ( a 1 ) , ( b 1 ) } . In this case, the label sets in NH tain those in NH Q ( v, k ) , but there could not exist a mapping from all vertices in NH Q ( v, k ) to vertices in NH G ( u, k ) since a col-lision occurs, e.g., both vertices in NH Q ( v, k ) are mapped to the same vertex in NH G ( u, k ) . In a single labeled graph, a collision may occur only if the label of two query vertices are the same and thus, collisions do not occur often. However, in a multi-label graph, a graph vertex may have a large number of labels. It is much more common that multiple query vertices (even with different sets of la-bels) may be mapped into the same database vertex, which leads to more collisions as shown in the example. In this paper, a bipartite matching pruning process is devised to remove the false contain-ment due to collisions. The vertices in NH G ( u, k ) are put in the group of vertices L while the vertices in NH Q ( v, k ) are put in the group of vertices R . There is a directed edge from a vertex u in L to a vertex v in R if the label set of u is a superset of that of v .Ifthe maximum flow mf in the bipartite graph is the same as the number of vertices in R , then there exists a set of true disjoint matches from all vertices in NH Q ( v, k ) to vertices in NH G ( u, k ) . On the other hand, if mf &lt; | R | , then it is a false positive containment due to label set collisions.

Among many graph based applications, one of the most impor-tant query task is to check whether a given query graph is a sub-graph of the database graph or not. For example, a software en-gineer may want to find whether a program contains a bug and a biologist may want to find whether a protein interaction network contains a special pathway motif. After it has been determined that a graph contains a particular subgraph pattern, a user may further wish to locate all matches of the pattern. These are two related, but different types of queries:
Existence Query : Checking whether a query graph is subgraph isomorphic to a database graph.

Location Query : Finding all matches of a query graph in a database graph.

Most recent research in subgraph matching has been focused on location queries [12, 21, 20, 18]. Little attention has been paid on processing the existence queries in a large graph. Although these two types of queries are highly related, there are some fundamental differences. Since all matches need to be identified, it is unnec-essary to develop an order to search the candidate matches in the location queries. On the other hand, for the existence queries, it is beneficial to first search the candidate partial matches that have a high possibility to become a true complete match. Therefore, a breadth-first search style algorithm is developed for the process of location queries while a depth-first style search is used for the pro-cess of existence queries. Furthermore, due to the different natures of these two types of queries, specific query vertex and graph vertex search orders are designed to accelerate the matching process.
The DELTA, for ind exing and que ryinginmult i-labeled gra phs, is provided in this paper. DELTA constructs an index structure for multiple-labeled graphs and provide a query processing method to answer both location and existence queries. The main contributions of this paper are as follows: (1) The multi-label graph matching problem is first proposed in this paper. (2) The wild card label (i.e. don X  X  care) can be used as either query or database graph vertex label, which could not be used in previous work. (3) Based on the nature of vertex label set, a novel approach that transforms each vertex label set into a high dimension box is proposed. The R-tree data structure is employed to store and index these boxes. (4) A bipartite matching pruning technique is proposed to detect the false positive matches due to label set collisions. (5) Two types of queries: location and existence queries are investigated. Different search orders are developed for these two types of queries. (6) By applying DELTA to real applications and synthetic data sets, we show the efficiency and scalability of the DELTA method over existing alternative approaches.

The remainder of this paper is organized as follows. Section 2 discusses the related work. Section 3 defines the preliminary con-cepts and presents the problem statement. Section 4 and 5 describe our indexing mechanism, and the query processing algorithms, re-spectively. Experimental results are presented in Section 6. The final conclusions are drawn in Section 7.
The existence query is more common in the context of graph indexing instead of subgraph indexing. In the graph indexing prob-lem, there are a set of database graphs and a query graph. The goal is to identify the set of graphs which are the supergraphs of the query graph. Usually, the database graph is small, e.g., with hun-dreds of vertices. Many pruning strategies have been proposed. The most common method is the frequent discriminative substructure based filtering. The approaches in this category apply data mining techniques to extract some discriminating substructures, then build an inverted index for each feature. Query graph q is denoted as a set of features, the pruning power of which depends on the set of se-lected indexed features. With the inverted indices, the complete set of candidates can be discovered. Many algorithms have been pro-posed to improve the effectiveness of the selected features, using features as frequent graphs, frequent trees and their combinations, such as Closure-tree[8], gIndex[16], TreePi[17], FG-Index[3] and Tree+  X  [22]. Closure-tree uses the graph closure concept to orga-nize the database graphs into a tree, where each node is a database graph. Database graphs with similar topologies are put as siblings. A pseudo subgraph isomorphism test is performed by checking the existence of a semi-perfect match from vertices in the query graph to vertices in a data graph (or graph closure). In gIndex, the authors propose a  X  X iscriminative ratio X  X or features. Only frequent and dis-criminative subgraphs are chosen as indexed features. In TreePi, due to the manipulation efficiency of trees, frequent and discrim-inate subtrees are chosen as feature set. The frequent sub-graphs and edges are used as indexed features in FG-Index. In Tree+  X  ,the author use frequent free trees and a small number of discriminative subgraphs as indexed features.

The location query problem commonly exists in the subgraph matching domain, which is to find all occurrences of a given query graph in the database graph. In this problem domain, database graphs are usually large, e.g., tens of thousands or more vertices. In GraphGrep [12, 5], the authors propose to use all paths up to maxL length as indexed features. It also builds inverted index for each path. In TALE [14], an approximate matching method is proposed for large query graphs based on neighborhood units. In Graphs-at-a-time [9], the authors introduce a pattern matching method based on a combination of techniques: use of neighborhood subgraphs and profiles, joint reduction of the search space, and optimization of the search order. In GADDI [18] and SUMMA [19], a distance index based method is developed to process location queries. The authors in [19] and [20] propose to build a set of neighborhood in-dices for each database vertex. The index contains the labels of vertices in the neighborhood. The bloom filter is used in [20] to represent the vertex labels in a neighborhood. These neighborhood indices can be used to generate matches between query vertices and database vertices. In [23, 2, 15], algorithms are presented on how to process pattern match queries, which are similar to location queries.

In all the above work (existence queries or location queries), the graphs are assumed to be single-labeled graphs and these methods could not be directly applicable to the multi-labeled graphs. There-fore, it is necessary to develop a novel method for multi-labeled graphs.
In this section, we introduce the fundamental definitions used in this paper and give the formal problem statement. This paper inves-tigates the subgraph indexing and querying methods for undirected and unweighted multi-labeled graphs. Without a loss of generality, it is easy to extend our methods to directed and weighted multi-labeled graphs.
 D EFINITION 1. A multi-labeled graph G is a five element tuple G = { V, E,  X  V ,  X  E ,L G } where V is a set of vertices and E V  X  V is a set of edges.  X  V and  X  E are the sets of vertex and edge labels, respectively. Each vertex label is composed of gvl categories of labels, while any edge label is composed of only one label. Vertex label can be absent for any vertex in any category. The labeling function L G defines the mappings v  X  X  l v | l v and e  X  X  l e | l e  X   X  E } .

Figure 1 (a) shows an example multi-labeled graph. In this ex-ample, each vertex has three labels. Therefore, gvl =3 in this graph. In the paper, we assume that any vertex label in category C cannot be the same as any vertex label in another category C all graphs studied in this paper are multi-labeled graphs.
D EFINITION 2. Given a database graph G , a connected query graph Q =( V q ,E q ,  X  V q ,  X  E q ,L q ) , a subgraph of Gm =( V  X 
V m ,  X  E m ,L m ) is a match of Q in G if and only if there exists a bijection f : V q  X  V m , s.t.,
If at least one match of Q can be found in G , Q is subgraph isomorphic to G .

Since labels from different categories can not be the same, in or-der for the labels of a query vertex v to be a subset of those of a database vertex u , the following has to be true. If v has a specified label l i in category C i , then the C i category label of u has to be l also. As an example, query graph q 1 in Figure 1 (b) is not sub-graph isomorphic to graph G in Figure 1 (a), because the vertex in the bottom with label { a 2 ,c 3 } cannot be a subset of the labels of any vertex in G . Query graph q 2 is subgraph isomorphic to G .In these query graphs, an empty box means the vertex label is absent (unspecified) for this vertex in this category.
 Problem Statement: Given a large database graph G ,asetof query graphs, we aim to construct an index, and efficiently pro-cess two types of queries with the help of the indexed informa-tion. These two types of queries are (1) existence query :whether a query graph is subgraph isomorphic to the database graph, i.e., there is at least one match of the query graph exists in the database graph; and (2) location query: find all matches of the query graph in G .

Suppose the database graph G has | V | vertices and | E | we assign each vertex a unique integer from 1 to | V | as its vertex ID , and each edge a unique integer from 1 to | E | as its edge ID .In Figure 1 (a), the vertex ID is illustrated near each vertex.
For example, suppose the database graph is G in Figure 1, the result of existence query of q 1 is false, while it is true for q match will be outputted when processing location query for q while two different matches will be outputted for q 2 .

One of the pruning techniques used by many existing methods [20, 21, 14] is the neighborhood set relationship. We define the k neighborhood of a vertex in the following manner.

D EFINITION 3. Given a database graph G , a vertex v in G , and a non-negative integer k , k -neighborhood of v in G (denoted as NH G ( v, k ) ) is a set of vertices u such that there exists a k edge path between u and v . For instance, in Figure 1 (a), NH G (1 , 0) = { 1 } while NH { 1 , 4 } . Furthermore, we denote NL G ( v, k ) to be the set of la-bel sets of vertices in NH G ( v, k ) . NL G (2 , 1)= {{ a { a 1 ,b 3 ,c 2 }} . Intuitively, in order for a query vertex v to be matched to a database graph vertex u , for every non-negative integer k ,the k -neighborhood of v in Q should be contained in that of u in G . In a single labeled graph, both NL G ( u, k ) and NL Q ( v, k ) are sets of labels. To determine whether NL Q ( v, k ) is contained in NL G ( u, k ) , we only need know whether NL Q ( v, k )  X  which can be determined efficiently. Even with very large size of NL G ( u, k ) , by employing a bloom filter [20], the set relationship can be determined with O ( | NL Q ( v, k ) | ) complexity at a very high accuracy. However, determining containment relationship becomes a complicated process in multi-label graphs since both NL and NL Q ( v, k ) are sets of label sets. The containment relation-ship between sets of sets is defined as follows.

D EFINITION 4. Given two sets of sets A = { A 1 ,A 2 ,...,A and B = { B 1 ,B 2 ,...,B m } where A i ( 1  X  i  X  n ) and B j  X  m ) are sets of elements in the form of { l 1 ,l 2 ,... B if for every B j  X  X  , there exists a A i  X  X  such that B j
For instance, {{ 1 , 3 } , { 2 , 4 }} is contained in {{ 1 , 2 { 2 , 4 }} , but is not contained in {{ 1 , 2 , 3 } , { 1 , 4 definition, the computation of set containment becomes a compli-cated process. In addition, the bloom filter no longer could be ap-plied. We will present an efficient computing the set containment in the next section.

Furthermore, some database graphs and query graphs may have edge labels. Thus, edge labels can be used as a pruning or search tool for indexing and query processing. Since the edge label in-formation can be easily adapted in the index and query process-ing without significant modification of the algorithms, we will omit how to handel and utilize the edge label information in the remain-der of this paper. The focus of this paper is to deal with multiple labeled vertices and the method to process the existence and loca-tion queries.
Our index structure is essentially for finding the matches be-tween query vertices and database vertices. As in much existing work, the neighborhood containment is one of the most popular methods. Due to the nature of multi-label vertices, the existing methods could not be directly applied in computing the neighbor-hood containment. A novel method of transforming labels of a vertex into a high dimensional box is introduced.
Let gval be the number of categories of labels for each ver-tex. The most straight forward method to find whether a set of sets NL G ( u, k ) contains another set of sets NL Q ( v, k ) is the fol-lowing. For every set Y in NL Q ( v, k ) , we compare Y with every set in NL G ( u, k ) . If there exists a set X in NL G ( u, k ) such that Y  X  X ,then NL G ( u, k ) contains NL Q ( u, k ) . The complexity of this step is O ( gval  X | NL G ( u, k ) | X | NL Q ( v, k ) dinality of NL G ( u, k ) is approximately equal to ( d G is the degree of G . In most applications, d G ranges from less than 10 to over 100. Thus, when k is small, e.g., 1, the running time of the straight forward method is tolerable. To effectively find an accurate candidate match set for a query vertex v , it is beneficial to compare the neighborhood vertex label sets for multiple k . Some of the k values could be more than 1. In this case, the straight forward method may be too costly, especially the candidate vertex generation process needs to be invoked many times. (It has to be invoked for every query vertex.) As a result, in the DELTA frame-work, we propose a novel method for efficiently computing the set containment.

The set of labels of a vertex ( l 1 ,l 2 ,...,l gval ) is mapped into a box in a gval dimensional space R gval in the following manner. Let f i be a function that maps an i th category label into an integer. Also denote max i and min i be the largest and smallest mapped integers for i th category labels. The label set ( l 1 ,l mapped to a box in the form of (( L 1 ,M 1 ) , ( L 2 ,M 2 M gval )) where L i = M i = f i ( l i ) if l i is specified. Otherwise, L = min i and M i = max i . For instance, the label set ( a where  X  represents an unspecified label, is transformed into a box of three dimension ((1 , 1) , (3 , 3) , (1 , 1000)) assuming f f ( b 3 )=3 , min 3 =1 ,and max 3 = 1000 .

The vertex labels of a particular neighborhood of a database ver-tex u ( NL G ( u, k ) ) can be considered as a set of boxes in the space. To find whether NL Q ( v, k ) is contained in NL G we need to determine for each vertex label set L i in NL Q whether there exists a set in NL G ( u, k ) that is a superset of L achieve this, each label set in NL Q ( v, k ) is also transformed into a box in the same manner as the label sets in NL G ( u, k ) .Fortwo label vertex sets X and Y with gval categories of labels, X is a superset of Y if and only if the transformed box of X is within the transformed box of Y . The following is the formal description of the property.

P ROPERTY 1. For two vertex label sets X =( x 1 ,x 2 ,...,x and Y =( y 1 ,y 2 ,...,y gval ) . The transformed gval dimension boxes of X and Y are X box =(( x low 1 ,x up 1 ) ,..., ( x a superset of Y if and only if X box is within Y box , i.e., for each i ( 1 Proof: First we prove that if X is a superset of Y ,then X within Y box .Since X is a superset of Y , for each category i that Y has a specified label y i , X also has the same specified label, i.e., x Y does not have a specified label ( y i =  X  ), X either has a specified label or a null label. In either case, it is within ( min is the transformed range of y i .

Now we prove that if X box is within Y box ,then X is a superset of Y . Based on the transformation, for each dimension i , there two situations for x low i and x up i , either (1) x low i = x or (2) x low i = min i and x up i = max i ( x i is unspecified). In order for X box is within Y box , for every unspecified category i , y to be unspecified either so that y low i = min i and y up For every specified x i , y i is either unspecified or y i y i  X  x low i  X  x up i  X  y up i . Therefore, X is a superset of Y . For every transformed box X from NL Q ( v, k ) , if we can find X encompasses some box from NL G ( u, k ) ,then NL G ( u, k ) con-tains NL Q ( v, k ) . This essentially is the problem of range queries in a high dimension space. To efficiently perform these operations, an index structure is discussed in the next subsection.
The index consists of two parts. The first part is the vertex label index and the second is the neighborhood index .
We index the vertex label information by using a fully inverted index for all labels. For every possible vertex label l a of vertices which has l a as one of their labels is kept. To accelerate the query process, the vertices in the list are sorted in the ascending order according to the vertex IDs.

For every specified label l a of a query vertex v , the list of vertices that have the label l a is retrieved. Since v may have several speci-fied labels, multiple vertex lists are retrieved. A database vertex u has the superset labels as v only if u appears in all these retrieved lists. Thus, we need join these lists, i.e., finding vertices that exist in all retrieved lists. Since the vertices are sorted according to the ascending order of the vertex IDs, the join process can be done by a linear scan through all the retrieved lists. These vertices are put into S ( v ) as the candidate matches for v . The neighbor index is constructed for each database vertex u . For each u , there are multiple neighborhoods, each of which cor-responds to a particular k .Foragivenvertex u and k , the neigh-borhood index contains two parts: (1) the number of vertices in NH G ( u, k ) and (2) the label sets of vertices in NH G ( u, k ) .
Since the vertex label sets in a neighborhood is essentially a set of high-dimension boxes, the R-tree [6] is chosen as the index struc-ture. For each vertex u and k , an R-tree is built to index the trans-formed boxes in label sets of vertices in NH G ( u, k ) . Since the R-tree is a very well known spatial indexing structure, we omit the procedures on how to construct and use the R-tree in this paper. With the R-tree index structure, the complexity of finding whether a box contains any box in NH G ( u, k ) is O ( log | NH G Since | NH G ( u, k ) | = O ( d k G ) , the complexity is O ( k log d Therefore, the total complexity for computing the set containment of NL Q ( v, k ) in NL G ( u, k ) is O ( k  X  d G  X | NL Q ( v, k ) is much lower than the straight forward containment computation especially with k&gt; 1 .
 With small k , e.g., k =1 , the number of label sets in NH is small. Although the complexity of the R-tree method is lower, it may not be worthwhile to use this method due to overheads. Based on our experiments, we found that when the cardinality of NL G ( u, k ) is less than 50, comparing to the straight-forward set containment computation, the R -tree index is not cost effective. Since d G is usually between 10 and 100 in many real applications, the straight forward set containment computation is more efficient with k =1 in most cases. Thus, with k =1 , the label sets of NH G ( u, k ) are stored as a linked list. On the other hand, with k  X  2 , the label sets of vertices in NH G ( u, k ) are transformed into a set of high-dimension boxes and stored in an R-tree.
With more neighborhoods for each database vertex, the pruning power is greater. However, this comes at a price of larger index size since more neighborhoods need to be stored. In addition, the cardinality of NH G ( u, k ) grows exponentially with respect to k . We have performed experiments on the pruning effects with differ-ent values of k and found that the pruning is the most cost effective with k =2 . Thus, in this paper, we choose the maximum value of k to be 2.
In this paper, we investigate two types of queries: the location queries and existence queries. These two types of queries are highly related, but with some important differences. In the existence queries, we only need find one match while in the location queries, we need find all matches. Thus, for the location queries, a breath-first search order is devised to find all matches. On the other hand, the depth-first search order is employed for the existence queries since this is more efficient to find one match.
 The graph matching process consists of the following steps. (1) For each query vertex v , we find the candidate set of graph vertices that are possible matches to v based on the index described in the previous section. (This step is the same for both types queries.) (2) Next, the match(es) of the query graph Q is discovered. For the location queries, the matches of Q are discovered in a breadth-first manner. We first find all candidate matches M 1 of one query vertex v . Next, we add another vertex v to v , then all matches M pattern with these two query vertices are discovered based on M This process continues until the query pattern consists of all query vertices or no match could be found.

On the other hand, for the existence query, the match is discov-ered in a depth-first manner. We also start from one query vertex, at this procedure only one match of the single vertex pattern is discov-ered and the match grows until one complete match of Q is located. If a partial match could not grow any more, we trace back and start to grow from another partial match. These steps are presented in details in the remainder of this section.
The inverted index presented in the previous section is used to find candidate vertex matches for each vertex in the query graph Q . First the vertex label index is used. Secondly, the neighborhood in-dex is used for further pruning. This formal algorithm is described in Algorithm 1.
 Algorithm 1 Build_Candidate( q, G ) Input: query graph q , database graph G
Output: candidate vertex match sets S , vertex matching order orderQueue of q 1: for each vertex v i in q do 2: for each label l j in v i do 3: retrieve the vertex list containing l j by the inverted index 4: end for S ( i )  X  intersectionof allthevertexlists 5: end for 6: for each vertex u k in S ( i ) do 7: if ! u k  X  X  one-hop neighborhood contains v i  X  X  then 8: remove u k 9: else if ! u k  X  X  two-hop neighborhood contains v i  X  X  by u 10: remove u k 11: else if the two-hop neighborhoods fail to pass Bipartite 12: remove u k 13: end if 14: end for 15: build orderQueue by the size of each set in S 16: return S and orderQueue For each query vertex v , we first find the set database vertices S ( v ) that have the vertex labels as a superset of those of v by the Vertex Label Index.

To refine S ( v ) , the neighborhood indices of v is used. For k =1 , the straight-forward containment computation method is used: For each vertex label set Y in NH Q ( v, k ) , we scan through the list for NH G ( u, k ) to see whether Y is a subset of some label sets in NH G ( u, k ) . On the other hand, for k  X  2 , the R-tree is used to store vertex label sets in NH G ( u, k ) . For each label set Y NL Q ( v, k ) , Y is transformed to a high dimension box and find whether there exists a vertex label set in NH G ( u, k ) contained in Y .If Y does not contain any vertex label set, then u could not be a match to v and is removed from S ( v ) .Ifforevery k , NH contains NH Q ( v, k ) ,then u remains in S ( v ) . In a multi-labeled database graph, a database vertex may have up to gval specified labels. On the other hand, a query vertex usually has much less number of specified labels. It is possible that the label set of one database vertex is a superset of the label sets of multiple query vertices. For instance, assume that the label set of vertices tices in NH Q ( v, k ) are { (2 , 3) , (3 , 5) } . In this case, NH is contained in NH G ( u, k ) .However, u cannot be matched to v since the two vertices in NH Q ( v, k ) can only be mapped into a single vertex in NH G ( u, k ) . To further prune the false matches, the bipartite matching process is introduced.

When determining NH G ( v, k ) containing NH G ( u, k ) , for each vertex Y i  X  NH G ( u, k ) , the label sets of vertices in NH that are a superset of Y i are identified. Thus, a bipartite graph B is constructed. B consists of two types of vertices L and R . Each ver-tex in NH G ( u, k ) is a vertex in L while every vertex in NH is a vertex in R . There is an edge from a vertex ( l )in L to a ver-tex ( r )in R if the labels of l is a superset of those of r . B can be considered as a flow network while each edge has a capacity of 1. The maximum number of disjoint matches in B (from vertices in L to vertices in R ) is equal to the maximum flow of B , which can be easily solved by the Ford-Fulkerson algorithm [4]. If the maxi-mum flow is equal to | R | , then every vertex in NH Q ( v, k ) can be mapped into a different vertex in NH G ( u, k ) so that u could be a candidate match to v and remain in S ( v ) . Otherwise, u could not be a match to v and it is removed S ( v ) .

Figure 2 shows an example of this pruning. The vertices in L are these from NH G ( u, k ) while vertices in R are from NH Q The maximum flow is 2. Since there are three vertices in R ,it means that there could not exist a one to one mapping from vertices in NH Q ( v, k ) to vertices in NH G ( u, k ) . As a result, u could not be a match to v .
 The complexity of the Ford-Fulkerson algorithm is O ( | NL  X |
NL Q ( v, k ) | ) . Although the bipartite matching can reduce false positive matches for a query vertex, it also could incur extra com-putation. In the empirical studies, we will show the effects of this pruning method.
After the matches for each query vertex are discovered, the next step is to assemble the vertex matches to form the complete matches of Q . As mentioned before, a breadth-first search style method is adapted for the processing of location queries. The formal location query algorithm is presented in Algorithm 2.

In general, a partial query pattern P is maintained. Denote P an i -vertex subgraph of the query pattern Q . Initially, P a single vertex. After discovering all matches M 1 of P 1 vertex v is added into P 1 to obtain a new partial query pattern P Next, the matches of P 2 are generated based on M 1 . The process Algorithm 2 Query_Locations( q, G, orderQueue, S )
Input: query graph q , database graph G , vertex matching order orderQueue of q , candidate vertex match sets S
Output: All matches of q in G . 1: v  X  orderQueue.remove () , P  X  P + v 2: for each vertex v i in S ( v ) do 3: matchesQueue.push ( v i ) 4: end for 5: while !matchesQueue.empty() do 6: if orderQueue.size()==0 then 7: return matchesQueue 8: end if 9: v  X  orderQueue.remove () 10: P  X  P + v 11: n  X  matchesQueue.size () 12: for i =0; i&lt;n ;++ i do 13: m  X  matchesQueue.remove () 14: for each vertex v i in S ( v ) do 15: if v i matches m then 16: matchesQueue.push ( m + v i ) 17: end if 18: end for 19: end for 20: end while continues until either (1) P i includes all vertices in Q or (2) there does not exist any match for P i .

There are two challenges for this algorithm: (1) which vertex should be added into P i and (2) how to obtain the matches M P +1 based on M i . We start by explaining how to choose a vertex to be added into P i , i.e., the growth order of the query pattern. It is beneficial to add a vertex that is adjacent to some vertex in P since the relationship (edges) between the newly added vertex and vertices in P i can be used to prune the matches. This means that P is always connected. There may be multiple adjacent vertices to vertices in P i . So which vertex should be chosen?
During the matching process, after generating a partial match m with i vertices, we try to add one more database vertex (match of query vertex v )to m i . However, no match could be found. This means that m i could not grow to the complete match of Q .As a result, the computation on generating the partial match m wasted. To minimize the wasted partial matches, it is beneficial to first match these vertices with low likelihood to be matched so that these wasted partial matches would not be generated at the first place.

For each vertex v in Q , the matched vertices set S ( v ) is obtained in the previous step. The number of vertices in S ( v ) is used to approximate how likely a partial match involving v can be matched during the matching process. Therefore, the query vertex v with the smallest S ( v ) that is adjacent to some vertex in P i will be chosen first.

For example, for vertices in query graph q 2 in Figure 1 (b), the upper vertex has one candidate vertex in the database graph in Fig-ure 1 (a), while the bottom vertex has two. Thus, we will select the upper vertex first and put into P 1 , as it has the least number of matching vertices. Since the bottom vertex is adjacent to the up-per vertex and the only vertex left, it will be selected next to form P . The query vertex order determination algorithm is described in Algorithm 3.

After adding v into P i , we need find matches for M i +1 of matches of P i +1 . Assume query vertex v is the newly added vertex. For each u  X  S ( v ) ( S ( v ) is generated in the vertex match Algorithm 3 Vertex Matching Order Input: query graph q , database graph G .

Output: Vertex Matching Order of vertices in q , orderQueue . 1: Queue orderQueue =  X  2: V  X  vertices in q 3: orderQueue  X  orderQueue + v , v has the least number of 4: V  X  V  X  v 5: while V is not empty do 6: TempV  X   X  7: for each vertex w in V do 8: if w adjacent to at least one vertex in orderQueue then 9: TempV  X  TempV + w 10: end if 11: end for 12: orderQueue  X  orderQueue + v , v has the least number 13: V  X  V  X  v 14: end while 15: return orderQueue step) and a match m  X  M i , we check whether u and m can form a match for P i +1 . For every edge e in Q such that one end of e is v while the other end is a vertex in P i , we verify whether there is a corresponding edge in G between u and corresponding matching vertices. If so, u and m form a match in M i +1 . Otherwise, u and m does not form a new match.
The existence query processing procedure is similar to that of location queries with one significant difference: the query is pro-cessed in a depth-first manner. The goal of the existence query is either to (1) generate a match for Q or (2) determine that there does not exist a match for Q as efficient as possible. In the case that Q does not have a match in G , the most efficient way is to match these vertices that could not grow to a full match of Q . Thus, it is ben-eficial to first match these query vertices v with small S ( v ) since small S ( v ) indicates few matches involving v exist. By matching v first, it can reduce the time to determine that there is no match for Q . On the other hand, in the case that there exists a match of Q in G , the match should involve all vertices in Q . Therefore, any query vertex order will perform the same since all query vertices need to be matched. Based on these two cases, we choose the same query vertex growth order as that in the location query.
 For the existence query, we also maintain a partial query pattern P i as in the location query. Initially, P 1 contains one query ver-tex. One match m 1 of P 1 is obtained. (In the location queries, all matches of P 1 are obtained.) Next one query vertex is added to P to obtain P 2 . The query vertex insertion order is the same as in the location queries. It is possible that after adding a vertex to P we could not find any match of P i +1 . In this case, a new match of P i ( m i ) would be generated based on m i  X  1 and we try to find a match of P i +1 based on the new m i . The algorithm terminates when one of the following two conditions occur. (1) One match of Q is discovered. (2) It is determined that no match of Q exists.
In the case of no match of Q existing, all matches of P 1 ... , P i have to be searched. ( P i +1 is the partial query pattern that we could not find any match.) Therefore, the order of generating database matches is not important at all. On the other hand, if there exists a match of Q , our aim is to generate a partial match of P that could successfully grow to the complete match of Q .Since it is impossible to know which partial match can grow to the final complete match, we only can make some "guess". Let X  X  assume that we have found a match for P i and v is added to P i to form P +1 . Since we know the next vertex v that will be added into P to form P i +2 , we "look-ahead" one step. We choose the match that might grow to the most possible matches for P i +2 . Thus, among all vertices in S ( v +1) ,thevertex u is chosen if u has the most adjacent vertices in S ( v +2) . u is added to the current match for P to obtain a match for P i +1 . In this case, the resulting match for P +1 has the highest probability to grow to most matches for P
For example, for query graph q 2 in Figure 1 (b) and database graph G 2 in figure 3, we first match the query graph vertex v bottom, as it has fewer matches than the upper query graph vertex v . v b has two matched vertices in the database graph, v 1 ( v i is the database vertex with vertex ID i ). We select v 1 because v 1 is adjacent to three matches of v u ( v 2 ,v 3 is adjacent to only two matches of v u ( v 2 ,v 3 ). The existence query processing algorithm is shown in Algorithm 4.
 Algorithm 4 Query_Exist( q, G, orderQueue, S )
Input: query graph q , database graph G , vertex matching order orderQueue of q , candidate vertex match sets S
Output: Whether q is subgraph isomorphic to G 1: v  X  orderQueue.remove () , P  X  P + v 2: n  X  S ( v ) .size () 3: for i =0; i&lt;n ;++ i do 4: remove v i in S ( v ) that has the most adjacent vertices in 5: matchesStack.push ( v i ) 6: while !matchesStack.empty() do 7: if orderQueue.size()==0 then 8: return true 9: end if 10: v  X  orderQueue.remove () 11: P  X  P + v 12: m  X  matchesStack.top () 13: remove v i in S ( v ) that has the most adjacent vertices in 14: matchesStack.push ( m + v i ) 15: if cannot find a v i in S ( v ) then 16: matchesStack.pop () 17: P  X  P  X  v 18: end if 19: end while 20: end for 21: return false
The DELTA framework consists of several innovations. To fairly analyze these innovations, the experimental results consist of three parts: neighborhood label set containment computation, the loca-tion query process, and the existence query process. We will eval-uate each innovation independently. To characterize the effects of the neighborhood index structure, three versions of DELTA index-ing structures are implemented: DELTA-basic, DELTA-bloom, and DELTA-R. In the DELTA-basic method, the straightforward neigh-borhood containment computing method is used. With the DELTA-bloom approach, we treat NL G ( u, k ) as the union of all labels and a bloom filter as in [20] is constructed for NL G ( u, k ) . The method of transforming vertex labels into a high dimension box is used in DELTA-R (DELTA with R-tree). All programs used in this section are implemented in C++ and all tests are run on a PC with the Intel Core2 CPU 2.6GHz and 4GB memory.
One real data set is a protein interaction network of homo sapi-ens. Each vertex represents a protein with three labels which corre-sponds to the gene ontology terms of cellular component, molecu-lar function, and biological process. Each edge represents that there is an interaction between the two proteins. There are 6410 vertices, 53844 edges, 1896 distinct labels and the average degree is 16.8. Four known different size of signal transduction pathways from the KEGG database [10] are used as the query graph Q . The pathways are from species other than homo sapiens, e.g., yeast, fly.
It takes 26 second to build a 37MB R-Tree based index and 17 second to build a 6MB Bloom filter based index. Figures 4(a) and 4(b) show the location and existence query performance of differ-ent versions of DELTA. For all methods, the query time increases with the size of the query graph, while the query time of DELTA-R and DELTA-BM grow much slower than the alternatives. The gap between DELTA-BM and DELTA-bloom is more evident with the larger size of the query graph due to the false positives intro-duced by the bloom filter at the pruning step. It is interesting to observe that the query time of DELTA-BM and DELTA-R is very similar. There are three labels in the database graph and one spec-ified label for each query vertex. In this case, the label set col-lision is not frequent, and thus the benefit of the bipartite match pruning is not significant. However, as shown with the synthetic data sets, when gval/ | L | ratio is larger, DELTA-BM would out-perform DELTA-R. The query time of both DELTA-Q-random and DELTA-G-random is slightly higher than that of DELTA-R, show-ing that the designed vertex matching order can improve the query performance up to 20% .

Another biological network is also used. The network consists of 7496 vertices and 25408 edges. Each vertex represents a fly gene and is labeled with multiple proteins. An edge exists if there is a functional relationship between two endpoint genes.We observed the similar trends of each algorithm and thus do not show the fig-ures due to the space limitation.
The synthetic database graphs are generated by the GenGraph_win tool [24] according to the following set of parameters: the number of vertices, the average degree, and the number of labels gval .The query graphs Q are also generated by the GenGraph_win tool ac-cording to three parameters: number of vertices, average degree, and the average number of specified labels. The default parame-ter values are shown in Table 1. We vary one parameter at a time. Biological graphs and system dependency graphs usually have be-tween tens of thousands vertices and several million edges, which fall into these parameter value settings.

First we show the index size and construction time with various parameters of the database graph in Figure 5. When the average degree is fixed, both the size and time of the R tree index and the bloom filter index grow linearly with respect to | V | or gval ,which is reflected in the first and third rows of subfigures, indicating these two indices scale well in terms of the size of the graphs and the label categories. The second row of subfigures shows that the costs of both indices grow exponentially with respect to the average degree of graphs. However, the index size and construction time is well within the tolerable range on a modern computer. The cost of the bloom filter index is consistently smaller (around 20% of size and 70% of construction time) than the cost of the R-tree based index. However, the index is only built once and our goal is to improve the query time, which is performed many times after the index is built.
Next, we show the query time with these different indexing struc-tures. The location queries are chosen for this experiment since location queries are more widely used and it takes longer time to process.
The first parameter we vary is the number of vertices in G , rang-ing from 10 K to 1 M vertices. With the growth of the database graph size, the query time increases. DELTA-basic could not termi-nate within a reasonable amount of time when G is large. DELTA-R outperforms DELTA-bloom and the acceleration is more evident when the size of the database graph is large since the bloom filter may falsely report many vertex matches due to the union approach.
The second parameter is the average degree of G and the result is shown in Figure 6(b). Without any pruning technique, DELTA-basic grows exponentially. DELTA-R outperforms DELTA-bloom with a wide margin especially in denser graphs because more ver-tices are in the neighborhood, which increases the chance of false positives for the bloom filter based index.

In Figure 6(c), with various gval , the query time of all versions of DELTA does not vary significantly. This is due to the fact that the average number of specified labels in the query graph is fixed, thus the computation of identifying candidate matches does not change too much.

Next we vary parameters concerning the query graph. The fourth parameter is the number of vertices in Q . In Figure 6(d), the loca-tion query time of all methods increases linearly with the size of the query graph because when the size of the query graph increases, it needs to match more vertices.

In Figure 6(e), when the average degree of Q is varied, the lo-cation query time follows the same trend as in Figure 6(e), but the curves grow at a sub-linear pace because higher degree means more edges to match, where each one is in fact a constraint for a match. Although more edges need to be matched, with more constraints, the number of matches is reduced.

The last parameter is the average number of specified labels ( L ) of each vertex in the query graph. The query time is shown in Figure 6(f). With more labels specified, fewer candidate vertex matches can be retrieved and thus it takes less time to grow these vertex matches to graph matches. This leads to a smaller query time. From this set of experiments, it is clear that the R-tree method can achieve a much faster query time at a price of 30% larger index structure comparing to the bloom filter approach. To evaluate the effects of the Bipartite pruning method, the Delta-R is compared with Delta-BM. Delta-BM is the same as Delta-R except that Delta-BM employs the bipartite pruning during the query processing time. As we shown above, the query time does not vary significantly with different gval and deg ( Q ) values. Thus, the query time with respect to these two parameters is not shown in the remainder of this section.
 Figure 7 (a), (b) and (c) show that the processing time of DELTA-BM is around 10% less than that of DELTA-R. However, in Fig-ure 7(d), when the number of average specified labels in a vertex in Q is 3 or larger, DELTA-BM takes a longer query time DELTA-R. This may be due to the fact that that with more labels in a query vertex, the possibility of label set collision becomes less frequent. Thus, the extra work on bipartite pruning may not be worthwhile. To demonstrate the effects of the query vertex insertion order, DELTA-Q-random is used as a baseline method, which employs a random query pattern growth order, i.e., with a pattern P that is adjacent to any vertex in P i is randomly selected to form P +1 . The specified pattern growth order, i.e. choosing a vertex based on S ( a ) , can provide up to 15% improvement over the ran-dom order, which is reflected by the gap between DELTA-R and DELTA-Q-random in Figure 7. This demonstrates the benefits of the particular query pattern generation order in the DELTA scheme.
For the existence query, the baseline method is DELTA-G-random which is the same as DELTA-BM with one modification. When choosing a match for the partial query pattern P , the pattern grows in a breadth-first style and any vertex has the same probability to be chosen.

In Figure 8, both methods grow with respect to the corresponding parameters, but at a much slower pace comparing with the location query. In this type of query, our goal is to discover the first match as fast as possible. The size and density of the database graph do not affect the query performance as much as they do in the location query. The query time is approximately linear to the size of the query graph. Moreover, in the existence queries, the order is more important than the location query, and DELTA-BM is around 20% faster than DELTA-G-random, which demonstrates the benefits of match generation order.
Due to the prevalence of multi-labeled graphs and lack of algo-rithms for such graphs, we investigate the subgraph indexing and query processing methods for multi-labeled graphs. To adapt to the nature of multiple labels in a vertex, the vertex match pruning problem is transformed into a high dimension spatial query prob-lem and the R-tree index is used to store and index the label sets on vertices. After introducing how to find candidate vertices, we provide detailed algorithms for processing existence queries and location queries. To the best of our knowledge, this is the first at-tempt to index multi-labeled graphs and process the location and existence queries on these graphs. [1] D. Abadi, A. Marcus, S. Madden, K. Hollenbach. Scalable [2] J. Cheng, J. X. Yu, B. Ding, P. S. Yu, and H. Wang. Fast [3] J. Cheng, Y. Ke, W. Ng, and A. Lu. FG-Index: Towards [4] T. Corman, C. Leiserson, R. Rivest, and C. Stein.
 [5] R. Giugno and D. Shasha, GraphGrep: A Fast and Universal [6] A. Guttman, R-Tree: A dynamic index structure for spatial [7] S. Horwitz, T. Reps, and D. Binkley. Interprocedural slicing [8] H. He and A. K. Singh. Closure-Tree: An Index Structure for [9] H. He and A. K. Singh. Graphs-at-a-time: Query Language [10] M. Kanehisa and S. Goto, KEGG: Kyoto encyclopedia of [11] M. Mitzenmacher, A brief history of generative models for [12] D. Shasha, J. Wang, and R. Giugno. Algorithmic and [13] B. Sun, R. Y. Chang, X. Chen, and A. Podgurski. Automated [14] Y. Tian and J. Patel. TALE: A Tool for Approximate Large [15] H. Tong, C. Faloutsos, B. Gallagher, and T. Eliassi-Rad. Fast [16] X. Yan, P. Yu, and J. Han. Graph Indexing, a Frequent [17] S. Zhang, M. Hu, and J. Yang. Treepi: a Novel Graph [18] S. Zhang, S. Li, and J. Yang. GADDI: distance index based [19] S. Zhang, S. Li, and J. Yang. SUMMA: subgraph matching [20] S. Zhang, J. Yang, and J. Wei. SAPPER: subgraph indexing [21] P. Zhao, J. Han. On Graph Query Optimization in Large [22] P. Zhao, J. X. Yu, and P. S. Yu. Graph indexing: Tree + delta [23] L. Zou, L. Chen, and M. T.  X  Ozsu, Distance-Join: Pattern [24] gengraph_win.
