 Recent studies show that billions of daily searches are made by web users. Instead of formulating natural language queries, the vast majority of users are submitting short queries with little or no context, which are often ambiguous and/or under-specified. For example, the query Harry Potter could refer to a book or a movie . For the movie , a user may be interested in the main character or the reviews .In view of the above-mentioned facts, the technique of search result diversification (e.g., [1, 13]) has been proposed and attracted significant attention. It provides a diversified search result, wh ich features a trade-off between relevance (rank-ing more relevant web pages in higher positions) and diversity (satisfying users with different information needs). For a be tter diversified search result, an accu-rate estimation of the information needs or subtopics underlying a given topic, which is referred to as subtopic mining [17, 19], becomes an important problem. Since the query log records the historical search behaviors performed by massive users (e.g., clicked web pages in response to a query, subsequently reformulated queries, etc), many researchers [10, 14, 16] performed subtopic mining via query log mining and have shown that the click information (e.g., page co-click and ses-sion co-occurrence) are valuable for determ ining the topical relevance of queries. However, as shown by Bonchi et al. [5], many methods have been proposed for and tested on head queries, which work poorly for unseen queries or queries with sparse click information. As query frequency is known to obey the power-law, these methods leave a large r atio of queries uncovered.

In this paper, we propose an effective approach that performs subtopic mining at the term level, which outperforms bas eline methods that work at the query-level. Subsequently, Section 2 discusses the related work. Section 3 formalizes the target problem. Section 4 details the proposed approach. Section 5 discusses the experimental results. We c onclude our work in section 6. To capture the underlying subtopics encoded within user queries, considerable studies [6, 7, 15, 21, 22, 23] have been conducted from various aspects. For example, Beeferman and Berger [2] vie wed the query log as a bipartite graph, and the obtained clusters were interpreted as subtopics covering diverse queries. The research by Jones and Klinkner [11] showed that users X  search tasks are interleaved or hierarchically organized . They studied how to segment sequences of user queries into a hierarchical structure. Sadikov et al. [16] and Radlinski et al. [14] tried to infer the underlying subtopics of a query by clustering its refinements. The web page co-click and session co-occurrence information were viewed as indicators of topical relevan ce. Hu et al. [10] interpreted a subtopic as a set of keywords and URLs, their key intuition was that: many users add one or more additional keywords to expand the query to clarify their search intents.
Different from the above methods that have treated a whole query as the minimum analysis unit. A number of studies (e.g., [20, 21]) performed intent analysis at a term-level. For example, Wang et al. [21] studied how to extract broad aspects from query reformulations, each broad aspect is represented by a set of keywords. Rather than raw terms based subtopic analysis, we perform subtopic mining by encapsulating intent roles [24]. We believe that our approach achieves a robust subtopic mining, especially for tail or unseen queries. The Intent tasks [17, 19] of NTCIR-9 1 and NTCIR-10 2 are the prototypes on which our formalization builds. The core notations are: (1) Topic (  X  T ) :it refers to an input instance for testing; (2) Subtopic (  X  t ) : it refers to a possible information need or an intent underlying a topic; (3) Subtopic string ( tStr ) : it is viewed as an expression of a subtopic. For example, for the topic Harry Potter , Harry Potter fiction and Harry Potter reading are two subtopic strings about the subtopic book . A topic and a subtopic string can either be a real query or a query-like string derived from other resources, e.g., query suggestions.
Formally, for a given topic  X  T , suppose there are k possible subtopics X = {  X  t 1 ,...,  X  t k spect to X . The problem of subtopic mining is formalized as: finding a ranked list of subtopic strings L that ranks subtopic strings representing more popular subtopics at higher positions and includes as many subtopics as possible. The quality of L depends on its consistency with the ideal ranked list L  X  (e.g., a ranked list created by human assessors). 4.1 Intent Role Oriented Modifier Graph Let  X  , Q , s , q , t , d denote the query log, query s et, a session, a query, a term and a web page respectively, D ( q )= { d } denote the clicked web pages of q , t q denote that t is a composing term of q , q  X  s denote that q occurred in s . Fig. 1 shows some click behaviors, where q 1 and q 2 occur in session s k , d 1 , d 2 and d 3 are the clicked web pages. Some query log oriented notations are given as: (1) Co-Session :For q i = q j ,iff  X  s that meets q i  X  s and q j  X  s , q i and q j are co-q e.g., q 1 and q 2 in Fig. 1; (3) Co-Query :For t i = t j ,iff  X  q that meets t i q Fig. 1; (4) Term-Level Co-Session :For t i = t j ,iff  X  q m  X  Q and  X  q n  X  Q that meet CoSession ( q m ,q n )  X  t i q m  X  t j q n , t i and t j are co-session terms, i.e., TCoSession ( t i ,t j ), e.g., t 1 and t 2 in Fig. 1; (5) Term-Level Co-Click :For t = t j ,iff  X  q m  X  Q and  X  q n  X  Q that meet CoClick ( q m ,q n )  X  t i q m  X  t j q n , t paper, the statistics of co-session and co-click of a query log that are defined at a query level, are called query-level knowledge in query log (QKQL). In contrast, the statistics of co-query, term-level co -session and term-level co-click that are defined at a term level are called term-level knowledge in query log (TKQL).
Rather than raw terms based analysis, we encapsulate the terms with intent roles ( Kernel-object &amp; modifier ) by Yu and Ren [24]. Kernel-object ( ko ) refers to the term that abstracts the core object of the underlying subtopic encoded in a query. Modifier ( mo ) refers to the co-appearing te rms with kernel-object, which explicitly specify user X  X  interested asp ects. A query that can be represented with kernel-object and modifier is defined as a role-explicit query. Otherwise, a role-implicit query. Because topic and subtopic string are query-like strings, thus, they can be analogously classified as role-explicit ones and role-implicit ones. Table 1 shows 3 role-explicit subtopic strings, the 1st column ( In/Out ) implies whether they are included in query log SogouQ(Section 5.1). For convenience, we directly use kernel-object and modifier to refer to the terms annotated as kernel-object and modifier respectively. Moreover, when deter mining the kernel-object and modifier for a given role-exp licit query, topic or subtopic string, the method by Yu and Ren [24] is used as a black box in our study, which selects the annotation with the maximum likelihood as the optimal annotation using a generative model.
 Definition 1 (Co-kernel-object Elements). Given a kernel-object ko, co-kernel-object elements refer to a set of role-explicit subtopic strings that share the same kernel-object, denoted as CoKO(ko)= { tStr } . Definition 2 (Modifier Graph). Modifier graph G ko = { V,E } is an undi-rected weighted graph derived from co-kernel-object elements CoKO ( ko ) ,(i)The node set consists of modifiers, i.e., V = { mo | tStr  X  CoKO ( ko ) ,mo tStr } ; (ii) The edge set is given as: E = { e =( mo i ,mo j ) |  X  TKQL ( mo i ,mo j ) &gt; 0 } ,  X  the maximum ones ( max V CoQuery , max V TCoSession and max V TCoClick ) respectively, and the edge weight is a linear combination of the normalized values .

Assuming that CoKO ( ko =  X  X  X  X  ( HarryPotter )) merely consists of the three subtopic strings in Table 1, Fig. 2 shows the corresponding mod-ifier graph based on the TKQL of SogouQ in Table 2(given as Co-Query:TCoSession:TCoClick ). Obviously,  X  X  X  (fiction) and  X  X  X  (reading) are strongly interacted (a weight of 0.9991);  X  X  (game) and  X  X  X  (fiction) (a weight of 0.0313),  X  X  (game) and  X  X  X  (reading) (a weight of 0.0049) are weakly inter-acted. If we perform graph clustering over this modifier graph,  X  X  (game) is likely to be grouped into a cluster.  X  X  X  (fiction) and  X  X  X  (reading) are likely to be grouped into another cluster. Many studies (e.g., [4, 5, 14, 22]) have shown that the QKQL helps to determine the topical relevance among queries. Anal-ogously, the TKQL derived from QKQL manifests the topical relevance among terms. Put another way, the larger value of  X  TKQL ( mo i ,mo j ), the more rele-vant subtopics indicated by mo i and mo j .Thus,  X  X  X  (fiction) and  X  X  X  (reading) express a relevant subtopic,  X   X  (game) expresses a different subtopic. Because the subtopics underlying the co-kernel-object elements depend on the composing modifiers, we can further deduce that  X  X  X  X  X  X  X  (Harry Potter reading) and  X  X  X  X  X  X  X  (Harry Potter fiction) express the same or similar subtopic, while  X  X  X  X  X  X  (Harry Potter game) express a different subtopic. Not surpris-ingly, the partition of a modifier graph uncovers the prior unknown subtopics of a set of co-kernel-object elements. 4.2 Modifier Graph Construction and Clustering Given the kernel-object ko with respect to a topic  X  T ,weconstructthemod-ifier graph G ko through the following two steps: Step-1 : Obtaining sufficient co-kernel-object elements CoKO ( ko ). We first manage to obtain a set of candi-date subtopic strings, say, { ctStr } , which is further used as the base for generat-ing CoKO ( ko ). Here recall is the key point, it ensures the coverage of different subtopics. The adopted resources are: (1) Query log ;(2) Query suggestions for topic  X  T ;(3) Noun phrase (NP) and verb phrase (VP) segments extracted from the result snippets for topic  X  T by a search engine. Specifically, all the queries or segments that include ko as a substring are selected as candidate subtopic strings. The query suggestions are directly selected as candidate subtopic strings. According to Definition 1, the co-kernel-o bject elements are all role-explicit ones that can be represented with kernel-o bject and modifiers. When deriving the CoKO ( ko ) based on a set of candidate subtopic strings, we relax the restriction as: regardless of whether a candidate subtopic string is role-explicit or role-implicit, once it includes ko as a substring, we intuitively assume that it is a co-kernel-object element. The substring ko is directly regarded as its kernel-object, the remaining parts are directly segmented into modifiers (stop-words are discarded). Step-2 : Adding weighted edges. Given the co-kernel-object ele-ments CoKO ( ko ), the modifier graph G ko can be obtained by adding an edge for each pair of distinct modifiers mo i and mo j iff  X  TKQL ( mo i ,mo j ) &gt; 0.
Suppose  X  denotes a parameter-free graph clustering algorithm, given an modifier graph G ko , a group of modifier cluste rs are generated, say, MC = { mc k } ,where mc k = { mo i } denotes a cluster of modifiers. Corresponding to each which is used to represent a subtopic, e.g.,  X  t k . Thus, a set of subtopic string clusters SC = { sc } can be obtained based on the set of modifier clusters MC . Specifically, for each modifier mo i  X  mc k , we select the subtopic string tStr m that meets mo i tStr m ,andadd tStr m into the corresponding subtopic string cluster sc k . For example, given the two modifier clusters by clustering the modifier graph in Fig. 2 (Section 4.1), i.e., mc 1 = {  X  X  X  ( game ) } and mc 2 = {  X  X  X  ( fiction ) ,  X  X  X  ( reading ) } ,for mc 1 , sc 1 = {  X  X  X  X  X  X  X  X  ( HarryPottergame ) } will be gener-ated due to  X  X  X  ( game )  X  X  X  X  X  X  X  X  ( HarryPottergame ), and so does sc 2 = {  X  X  X  X  X  X  X  X  ( HarryPotterreading ) ,  X  X  X  X  X  X  X  X  ( HarryPotterfiction ) } .

When allocating the subtopic string of which the composing modifiers belong to different modifier clusters, we obey the following priority rules: (1) Add this subtopic string into the subtopic string cluster, of which the corresponding modi-fier cluster encloses more composing modifi ers; (2) If two modifier clusters enclose the same number of modifiers of a particular subtopic string, add this subtopic string into the subtopic string cluster, of which the corresponding modifier clus-ter encloses the most frequent modifier. The idea of the above rules are straight-forward, i.e., a larger number of modifiers means a larger expressive power, and a more frequency modifier carries a larger expressive power than a rare modifier. 4.3 Generating the Ranked List Definition 3 (Expression Power). Expression power of a subtopic string is defined as the generating probability of its composing modifiers, which measures its effectiveness of describing the subtopic represented by the subtopic string clus-ter it belongs to. It is given as: EP ( tStr )= mo V and | V | + denotes the number of distinct modifiers, we assume that there is a probability distribution for modifiers, which is sampled repeatedly by users to form mutually-independent modifiers to specify kernel-object oriented subtopics. Definition 4 (Subtopic Popularity). Subtopic popularity is defined as the likelihood of a particular subtopic. Formally, it is given as SP (  X  t k )= SP ( sc k )= cluster sc k , | sc k | = tStr tStr m in CoKO ( ko ).

Based on Definition 4, the gain value of putting a subtopic string tStr r at builds upon the subtopic popularity of the subtopic string cluster that tStr k belongs to. The discounted cumulative gain of L with a cutoff r is given as: of distinct clusters that the top-r subtopic strings cover. If we view the cluster subtopic diversity. r j =1 G ( j ) aims to rank subtopic strings that indicate popular subtopics at higher positions. Analogous to the metric of D#-nDCG [18], we let  X  =0 . 5. Inspired by the Maximum Marginal Relevance (MMR) [8] criterion that combines relevance and novelty in the context of text retrieval, Algorithm 1 generates the target ranked list L by iteratively selectin g the subtopic string that achieves the maximum margin.

In particular, by Steps 1-6, from the subtopic string cluster that achieves the maximum subtopic popularity, the subtopic string that has the maximum expression power is selected as the first element of L .BySteps7-12,giventhe top-( j  X  1) subtopic strings, the subtopic string that achieves the maximum margin (i.e., DCG ( j )  X  DCG ( j  X  1)) when being selected as the j -th element of L is put at the j -th slot of L . Because the discounted cumulative gain value ( DCG ) combines both subtopic diversity and relevance, the obtained L thus captures a trade-off between subtopic diversity and popularity.
 Algorithm 1. The algorithm for generating the ranked list L 5.1 Experimental Setup The publicly available topic set and resources (e.g., Chinese query log SogouQ, query suggestions and the ideal ranked list for each topic) from the Intent task of NTCIR-10 [17] are adopted, the top-100 result snippets of Google are used. Yu and Ren [24] have shown that the role-implicit queries are often question queries or verbose queries that merely r equire a specific answer. In this paper, we focus on role-explicit topics that generally have multiple subtopics, 6 role-implicit topics (i.e., 0244, 0245, 0249, 0256, 0270, 0283) are excluded, e.g., 0256:  X  X  X  RTF (what is RTF). The remaining 92 topics are used as Topic-Set-A .
Fig. 3 (in Section 5.2) shows to what extent we can rely on the QKQL. The x-axes denote the count of instances that appeared in SogouQ. The y-axes denote the count of topics. The asterisk corresp onds to co-session queries, the circle corresponds to candidate subtopic strings. We found that: 46 topics have co-session queries less than 10, 38 topics have candidate subtopic strings in SogouQ less than 10. For topics of this kind, the so called sparseness problem is a big trouble. By excluding the 38 topics from Topic-Set-A, of which the count of candidate subtopic strings in SogouQ is less than 10, we built the Topic-Set-B .
Two typical methods [9, 16] for query intent inference are compared. Deng et al. [9] proposed the Click Frequency Inverse Query Frequency model for query clustering (denoted as CFIQF ). Under CFIQF, each query is represented by a vector of clicked documents. Sadikov et al. [16] performed intent inference by clustering the refinements of a given query (denoted as RC ). A Markov graph is built based on the document click and session co-occurrence of the refine-ments. Finally, the problem of refinement clustering is reduced to the problem of Euclidean-vector clustering. As did by Sadikov et al. [16], the complete-linkage clustering algorithm is used for the two baselines.

The metric D#-nDCG [18] suggested by NTCIR-10 [17] is used as the test metric, which is a linear combination of I-rec and D-nDCG . I-rec indicates the proportion of subtopics covered by the top subtopic strings and measures di-versity. D-nDCG measures overall relevance across subtopics. In our study, we evaluate I-rec, D-nDCG, D#-nDCG with cutoff values of 10 and 20.

When quantifying the edges of a modifier graph, we let  X  1 =  X  2 =  X  3 = 1 3 , i.e. co-query, term-level co-session and t erm-level co-click were treated equally. For modifier graph clustering, two parameter-free graph clustering algorithms Louvain [3] and LinLog [12] have been tested, the corresponding modifier graph based approaches are denoted as MG-Lou and MG-Lin respectively. 5.2 Experimental Results Based on Topic-Set-B, Table 3 shows the results with cutoff values of l = 10&amp;20.
As the complete-linkage clustering algorithm requires a predefined cluster number, different values (e.g., 5 is mark ed as (5)) were tested for the baselines. As shown in Table 3, the baseline methods exhibit different performances due to different cluster numbers. For example, the D#-nDCG@10 value of CFIQF is 0.2904 (4th column) with a cluster number of 15, which is better than the values generated with cluster numbers of 5 and 10. However, the number of subtopics indeed varies from topic to topic. A pred efined cluster number can X  X  guarantee a natural subtopic mining. RC operates by clustering the query refinements (es-sentially co-session queries) of a given topic, its low performance implies that the clustered refinements greatly deviates from the ranked list by human asses-sors. By clustering the subtopic strings via co-click information, CFIQF shows a better performance than RC.

Different from the baseline methods that rely on QKQL, the modifier graph based approaches make use of TKQL. The results show that both MG-Lou and MG-Lin outperform the baselines in terms of I-rec, D-nDCG and D#-nDCG. The reasons are: The proposed approaches work at a term level instead of a whole query level. Based on the TKQL, they ca n determine the subtopics of subtopic strings from different resou rces rather than merely the queries of a query log. For example, though  X  X  X  X  X  X  X  (Harry Potter reading) (Table 1) is not included in SogouQ, we can determine its underlyi ng subtopic based on its composing modifier  X  X  X  (reading). On the contrary, the baseline methods will fail due to no click information. Leveraging on the two ad-hoc graph clustering algorithms, our modifier graph based approaches can determine the possible subtopics per topic instead of a uniform cluster number.
 Based on Topic-Set-A, Table 4 shows the results with cutoffs of l = 10&amp;20. Compared with Topic-Set-B, Topic-Set-A contains 38 topics that have sparse QKQL. This is the very reason why the performances of the baseline methods are greatly impacted. For example, the best performance of CFIQF (D#-nDCG@20 at the 7th column) is decreased from 0.3116 (Table 3) to 0.1692 (Table 4). In contrast, our modifier graph based approaches exhibit stable performances. For example, the best performances (resul ts in bold) in Tables 3 and 4 do not differ a lot, which demonstrates that the modifier graph based approaches are robust to the sparseness problem.

To understand the impact that different graph clustering algorithms may have on modifier graph clustering, Fig. 4 illustrates the cluster number (i.e., the num-ber of subtopic string clusters) distribution based on Topic-Set-A. The asterisk represents the official number of subtopics per topic. The circle and triangle rep-resent the cluster number per topic under the Louvain algorithm and the LinLog algorithm respectively.
From Fig. 4, we found that: The two algorithms group the same modifier graph into different number of clusters due to different optimization criteria, and the LinLog algorithm generally outputs smaller numbers of clusters. Unfortunately, both of the two algorithms commonly gen erate different cluster numbers com-pared with the official subtopic number. If we directly regard the cluster number as the subtopic number (as we did in this paper), the approximated subtopic recall value would not be accurate enough. A particular algorithm should be devised for better clustering the modifier graph. In this paper, we performed subtopic mining via modifier graph clustering, which makes use of TKQL rather than QKQL. Compared with the baselines that treat a whole subtopic string or query as the minimum analysis unit, our modifier graph based approaches achieve a better performance in terms of I-rec, D-nDCG and D#-nDCG. A limitation of our current study is that the proposed approach is tested against Chinese topics. Whether it works effectively against English topics is planned as the future work. Moreover, devising a specific algorithm for modifier graph clustering would be an interesting future research direction. Acknowledgements. This research has been partially supported by the Min-istry of Education, Science, Sports and Culture, Grant-in-Aid for Scientific Re-search (A), 22240021.

