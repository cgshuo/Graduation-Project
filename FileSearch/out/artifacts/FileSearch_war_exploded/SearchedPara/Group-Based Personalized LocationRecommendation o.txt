 The rapid development of Mobile Internet enables users to share their infor-mation on mobile phones. As modern smartphones are equipped with GPS, we can easily obtain users X  locations. Thanks to modern smartphones and Mobile Internet, location-based social networks (LBSNs) are becoming more and more popular and widely accepted by mobile-pho ne users [3,14]. There are many real LBSN systems, e.g., Foursquare (foursquare.com) and Jiepang (jiepang.com). Moreover, there are many studies on identifying users X  locations from traditional social networks, e.g., Twitter (twitter.com) [10,11]. Thus we have many ways to obtain real-world LBSNs.

LBSNs generate large amount of user generated content (UGC), including both location histories and social relationships, and provide us with opportunities to enable location-aware recommendation, which has many real applications [2,15]. For example, a new tourist visits a city and we want to recommend her some inter-ested scenic spots.

To build a personalized lo cation recommendation system on LBSNs, we should consider both the recommenda tion quality and efficiency. Existing methods fo-cus either on recommendation efficiency at the expense of low quality or on recommendation quality at the cost of low efficiency [1,17]. To achieve high per-formance, it requires to devise effective s tructures and efficient algorithms. To achieve high quality, it needs to consider the following factors. First, user pref-erences are very important. For exampl e, if a user often goes to cinemas, she may like movies, and thus we can recommend her locations related to movies. It is worth noting that a user may have multiple interests, and we should ana-lyze the importance of these interests. Second, it is important to consider users X  comments on locations, e.g., user rating s or visited times. Third, social connec-tions are also important. A user may be more interested in the locations their friends are also interested in. [9] solves the location-aware influence maximiza-tion problem, which reflects the importan ce of social connections for location recommendation.

To utilize these information, we need to address the following challenges. The first one is the data-sparseness problem. A user X  X  location histories are limited, which leads to the user-location matrix very large but sparse. The second one is the cold-start problem. For a new user, we do not know her preferences and it is hard to recommend relevant locations.

To address these limitations, in this paper we propose a group-based per-sonalized location recommendation system, which can provide users with most interested locations, based on their pers onal preferences and s ocial connections.
The main contribution of this paper is as follows.  X  We develop a group-based personalized location recommendation system to  X  We propose a hierarchical clustering method to cluster locations and build  X  We devise a two-step method to recommend users with interested locations.  X  We have implemented our method and compared with existing approaches.
The rest of the paper is organized as follows. Section 2 gives the problem formulation and the system overview. We introduce how to generate the groups in Section 3 and discuss how to do per sonalized location recommendation in Section 4. Section 5 shows the experime nt results. We review related works in Section 6. Finally, Section 7 concludes the paper. In this section, we first introduce the problem formulation, and then present the overview of our proposed loc ation recommendation system. 2.1 Problem Formulation We use a graph to model an LBSN where nodes are all users and edges are relationships between users (e.g., follower/followee relationships). In addition, for each node, it includes a set of locations that the use has visited (e.g., checked in). For each user, when she comes to a new place, denoted by a minimum bounding rectangle (MBR) r , we want to recommend her n new locations within the region r that the user has never visited. Next we use an example to illustrate our problem, as shown in Fig 1.

Assuming locations L A , L B and L C are within search range r , the possible recommended results are: L C is recommended to user U 1 , L A is recommended to user U 3 , L A and L B are recommended to user U 4 (since U 3 and U 4 are friends, L
B may have higher rating than L A ). 2.2 System Architecture As shown in Fig.2, the system can be divided into two parts: offline clustering and online recommendation.
 Location-Aware and Preference-Aware Clustering. The lower part of Fig. 2 is the clustering part. First, we extract locations users have visited. From existing POIs or knowledge base [13], we can obtain the categories of locations (e.g., KFC belongs to  X  X ast Food X  which in turn belongs to  X  X ood X ) and build a category hierarchy, where nodes on the hierarchy are categories and the parent-child edges denote the category-subcategory relationships. Then, for each user, we can get her category hierarchy based o n her locations, which is a subtree of the category tree. In addition, we evalu ate the user preferences by her visited locations and the number of visited ti mes using the term frequency * inverse document frequency (TF*IDF) method, and incorporate the weight into her lo-cation hierarchy, called weighted category hierarchy (WCH) [1]. Next we cluster users into different groups according to their WCHs using the K-Means algo-rithm. Finally for each group, we use all locations that the users in the group have visited and some popular locations as the candidate locations. Section 3 gives the details of offline clustering.
 Personalized Location Recommendation. The upper part of Fig.2 is the recommendation part. First, we find the group that the user belongs to (or most relevant group if the user is a new user) and get the members of the group. Sec-ond, we get candidate locations in a specified geospatial range using the group X  X  R-tree index. Third, we calculate the similarity between the user and candi-date locations. Finally, we devise recommendation algorithms to recommend the top-k locations to the user.
 System Features. The proposed system is designed to provide real-time lo-cation recommendation for the users, an d we focus on improving the efficiency while achieving high quality. The system has the following characteristics. First, we can address the data-sparseness problem using the group-based method since we use the locations in the group to support recommendation. Second, we can address the cold-start problem as we use the users in the relevant group to recom-mend locations. Third, our method has high performance, since the user-location matrix (user-user matrix ) is replaced by the user-ca tegory (user-group) matrix and the computation overhead is significiantly reduced.
 Research Challenges. Generating high-quality groups is very important and challenging in our method since it affects the recommendation quality. We devise effective techniques to address this issue i n Section 3. Second, identifying relevant groups and locations for each user is also very challenging and we propose some similarity functions to calculate the user-group and user-location similarities and devise efficient recommendati on algorithms in Section 4. In this section we first discuss how to ana lyze user preferences (Section 3.1) and then utilize the preferences to group the users (Section 3.2). Finally we present how to select candidate location s for each group (Section 3.3). 3.1 Analyzing User Preferences We study how to capture user X  X  preference, which is very important to do person-alized recommendation . First, to describe the locations, we propose a location category hierarchy (e.g., KFC, fast food, food), where each node is a location cat-egory and each parent-child edge is a category-subcategory relationship. There are many ways to build the location hierarchy. The first method is to use existing knowledge bases to obtain the hierarchy, which is adopted in our experiments. The second method is to extract the cate gories from Points of Interest (POIs) as POIs contain the categories. The third method is to use existing hierarchical clustering algorithms to generate the categories [7].

Then based on the category hierarchy, we construct a weighted category hi-erarchy (WCH) for each user. WCH is a subtree of the category tree. For each user, we insert her locations to the leaf nodes if the locations belong to the corre-sponding categories. Then the minimum subtree that contains all the locations is the WCH of the user. To capture user preference, for each category, we add the user X  X  preference on the category (i.e., whether the user likes the category). To this end, we use the term frequency * inverse document frequency (TF*IDF) method to calculate the value using Eq. 1. of the u  X  X  location histories, |{ u j : c  X  u j .C }| is the number of users who have visited c ,and | U | is the number of users.

WCH in our system has the following advantages. First, it can help to solve the data-sparseness problem, because the WCH can effectively reduce the dimen-sions of the user-location matrix by replacing it with the user-category matrix, and the data is not sparse any more. Second, it can solve the cold-start problem. Although a user may not visit any location in a new city, we can infer her pref-erences from her WCH and recommend intere sting locations to her. Third, two categories may not exact match and WCH can tolerate the category mismatching problem using the hierarchy. 3.2 Constructing User Groups To group the users into different groups based on their preferences, we use the K-means algorithm to do user clustering, based on the following four steps.  X  Data Preparation. We utilize all users X  WCHs to group the users. In some  X  Feature Selection and Extraction. Therearemanypossiblewaysto  X  Similarity Computing. For each user, we create a vector for her, and the  X  Clustering. We apply the K-Means algorithm to cluster users, and all users 3.3 Generating Group Candidate Locations For each group, we use locations the group members have visited and some highly rated locations as the candidate locations. The following part describes how to generate the highly rated locations.

We use an iterative method to rate locations, where a location X  X  rating is called the authority score, represented by l.a , and a user X  X  rating is called the hub score, represented by u.h . Through iterative computing we can pick out high-quality locations and users. Eq. 2 is used to calculate the authority and hub score, while l.a is initialized as the times that l is visited, and u.h is initialized as the size of u  X  X  location histories:
In order to get the candidate locations efficiently within a geospatial range, we use the R-tree to index all locations, which is proposed by Guttman [4] as a spatial index structure. Searching on the R-tree is quite efficient, and we construct an R-tree for each group to f urther accelerate the search speed. In this section, we introduce how to support online personalized location rec-ommendation. After a user submits a location recommendation request, we first find which group the user belongs to by calculating the user-group similarity (Section 4.1). Then, we sea rch candidate locations within the query search re-gion. We use the R-tree to index candidate locations, and thus we only need to search on the corresponding group X  X  R-tree nodes and efficiently get the can-didate locations. Next we calculate the user-location similarity and recommend high rating locations to the user (Section 4.2). 4.1 Identifying User X  X  Group Consider a user submits a recommendation request. It is rather important to determine the group that the user belongs to because a user group reflects the preferences of users in the group. If the user belongs to a group, we can easily get the corresponding group. On the contrary, we need to find the most relevant group to the user. Since we use the K-Means algorithm to cluster users, each group has a virtual center user. Given a group, we use the similarity between the user and the center to compute the similarity between the user and the group. In this way, we can calculate the similarity between the user and all groups, and select the highest one as the user X  X  group. 4.2 Recommending Locations From the identified group, we find the candidate locations using the R-tree. Here we introduce how to recommend top-k locations from the candidate locations. One big challenge is to calculate the user-location similarity. We can use Eq. 3 or Eq. 4 to measure the user-location similarity.
 where u is the user in the same group with u , Sim ( u,u ) is the similarity between users u and u ,and v ( u ,l ) represents the times that u visits location l . where l is the location that user u has visited, Sim ( l,l ) indicates the similarity between locations l and l ,and l ( l ,u ) indicates the times that the user u has visited location l .

To efficiently compute the user-location s imilarity, we can convert calculating the user-location similarity to computing user-user (Eq. 3) and location-location (Eq. 4) similarity. We propose several metrics to measure the similarity between users: user relationship similarity ( Sim 1 ), location histories similarity ( Sim 2 ), common words similarity ( Sim 3 ), and WCH similarity ( Sim 4 ). Our method uses a weighted sum combination of the above similarity scores as the final similarity. Sim 1 between two users is the ratio of the intersection size of their friends to the union size of their friends. Similarly Sim 2 ( Sim 3 )istheratioof the intersection size of their visited locations (rating words) to the union size of their visited locations (rating words). For Sim 4 , we use the cosine similarity on the categories of the first level to evaluate the WCH similarity, similar to the feature selection step in Section 3.3.

Computing the similarity between two locations is simple, we only need to get the user vector and calculate the cosine similarity of the vectors, where user vector is a vector that stores the users wh o have ever visited the location, e.g., in Fig.1, L A  X  X  user vector is [ U 1 ,U 2 ] .

To identify the relevant group, we use the user-group similarity. To rate a location, user-location similarity is calculated, and the similarity can reflect the user X  X  preference on the loc ation. User-user and location-location similarity are used to calculate user-location similarity using Eq.3 and Eq.4, while the former one measures how close two users are in te rms of user preferences, and the later one reflects two locations attract how many same users, and the more same users, the higher similarity. Based on the user-user and location-location similarity we can use the CF algorithm to r ecommend locations for users.

To sum up, our proposed system enables high quality personalized location recommendation through calculating the similarity between the user and candi-date locations online, while using group to prune the candidate locations offline and improve the computing efficiency. We conduct experiments to evaluate our proposed method. Our experimental goal is to evaluate the recommendation efficiency and quality. 5.1 Experiment Settings Dataset. We use a large-scale real-world dat aset collected from Foursquare [1]. The users are mostly from two main cities in the United States: New York (NYC) and Los Angeles (LA). Table 1 shows the statistics of the dataset. As we can see from the table, the dataset is large-scale but sparse.
 We selected users with home city of N ew Jersey (NJ) as our test dataset. In order to ensure the accuracy of the exp erimental results, w e further selected users whose number of tips is greater than 7, and tips around LA and NYC. Hence we select 992 test users and 7,242 tips as the test dataset.
 Comparison Algorithms. We implemented two algorithms of our method: group-based personalized location-b ased recommendation (GPLR) and user-based recommendation (GPUR). We compared with three existing algorithms. (1) Location-based collaborative filtering (LCF) [5], which is based on the item-based CF. It utilizes all of the users X  location histories to build a user-location matrix, and applies location-based CF on the matrix (Eq.4). The similarity of two locations is computed by cosine similarity, and higher rating locations are recommended to the user [12]; (2) User-bas ed collaborative filtering (UCF) [5], which is based on the user-based CF, and applies user-based CF on the ma-trix (Eq.3); (3) Preference-aware (PA) [1] , which uses location classification and user preferences extraction method in the offline part, and employs candidate selection algorithm and CF algorithms for online recommendation.
 Evaluation. To evaluate a recommendation method, we used cross validations. We divided the location histories of a user into two parts. One is the training set, which is used to learn user preferences and the other is the test set. Fig.3 explains our evaluation method.
In Fig.3, the black filled circles indicate the test set, and we draw a minimum boundary rectangle (MBR, the dotted line in the figure) as the recommenda-tion range; the slash circles present the recommended locations. Through the evaluation method we can calculate the quality of the recommendation. Experiment Environment. All of our experiments ran on an HP server with a 3.47GHz 6-core Intel Xeon CPU, and gcc-4.3.4. 5.2 Recommendation Quality We compare quality with existing algorithms, by varying the number of recom-mended answers N (default 20), the average size of location histories of users (default 7), and the density (the number of locations per square mile). Fig.4 shows the results by varying the number of recommended answers (the size of location histories is set to 7).
Fig.4 shows that our proposed GPLR achieves the best precision, while LCF and GPLR have the best recall. This is because LCF is based on all locations, and GPLR is based on the candidate locations of the group, and thus LCF has slightly advantages in recall. Our propo sed GPUR, outperformed UCF in terms of both precision and recall, proving our us er-user similarity method is effective. LCF and GPLR are better in quality than UCF and GPUR, which indicates location-based method is better than user-based method for the dataset, for location-based reco mmendation. Finally, PA performs better than the user-based method but worse than location-based method. Fig.5 shows the results by varying the number of location histories with N=20. With the size of location histories grows, the precision of the five methods in-creases. Particularly, GPLR and LCF hav e a significant increase. This is because the five methods are all based on the user loc ation histories. The recall decreases as the size of location histories grows in all five methods. This seems unreason-able because the size of the dataset is fixed, and as the size of training set grows, the size of test set decreases, the recall should increase. However in fact, since the number of correct reco mmendations decreases faster than the size of test set decreases, the recall decreases.

Fig.6 shows the result by varying the location density, with N=10. In general, the precision decreases as the location de nsity grows, while the recall increases. Intuitively, while there are more locations in the same range, the probability to recommend correct loca tions is lower, and the result proves the intuitive inference. 5.3 Efficiency The main factors affecting the effici ency are the recommendation number and query range. We compare the five methods X  average recommendation performance. Fig.7(a) shows the elapsed time, and Fig.7(b) shows the recom-mendation time as the recommendation range changes.

The proposed GPLR and GPUR achieved the highest efficiency and UCF al-gorithm had the worst perforamnce. The main reason is as follows. Our proposed recommendation algorithms are based on groups and can effectively filter out ir-relevant locations for personalized recommendation part, while LCF and UCF algorithm are not based on groups. As a result, the candidate location set is very large. PA algorithm adopts a candidate selection algorithm, and uses local experts to filter candidate locations, but the efficiency is not as good as ours.
From Fig.7(b), we can see the larger the recommendation range, the more candidate locations, causin g worse efficiency. Moreove r, although the time that GPLR and GPUR algorithm consume increases with the range, the average growth rate is slower than the other th ree methods, reflecting the proposed methods have better scalability. Most existing location recommendation systems are based on distance and rat-ings [2,15,18]. These methods typically do not consider the user X  X  preferences and for every user the recommended locations are almost the same.

There are some personalized methods [1,6,16]. Personalized methods typically use tags to identify the user X  X  interests , and they allow users to manually specify their own tags. The disadvantage of such systems is that they do not consider the location histories of other users. Some systems take the location histories into account, such as [8,17], but the efficiency is a big challenge. Another type of personalized location recommendation systems are based on the CF model by considering other users X  lo cation histories and can infer the rating of a location that the user has not visited. However, the disadvantage of such systems is all locations are computed independently, resulting in the user-location matrix too large to be computed efficiently.
 This paper presents a group-based personalized location recommendation sys-tem with the following characteristics. First it can address the data-sparseness and cold-start problems. Second, it achieves high efficiency and scalability by utilizing group-based information. Third, it achieves high quality by utilizing user preferences, social rel ations, user ratings and distances. The experiment re-sults on a real-world dataset show that the proposed methods have significant advantages in quality and efficiency than baselines.
 Acknowledgements. This work was partly supported by the National Nat-ural Science Foundation of Ch ina under Grant No. 61272090 and 61373024, National Grand Fundamental Research 973 Program of China under Grant No. 2011CB302206, Beijing Hig her Education Young Elite Teacher Project under grant No. YETP0105, Tsinghua-Tencent Joint Laboratory for Internet Innova-tion Technology, the  X  X ExT Research Center X  funded by MDA, Singapore, under Grant No. WBS:R-252-300-001-490, and the FDCT/106/2012/A3.

