 Keyword search, the major means for Internet search en-gines, has recently been explored in structured and semi-structured data. What is yet to be explored thoroughly is how optional and negative keywords can be expressed, what the results should be and how such search queries can be evaluated efficiently. In this paper, we formally define a new type of keyword search query, ROU-query, which takes as in-put keywords in three categories: required , optional and un-wanted , and returns as output sets of nodes in the data graph whose neighborhood satisfies the keyword requirements. We define multiple semantics, including maximal coverage and minimal footprint , to ensure the meaningfulness of results. We propose query induced partite graph (QuIP), that can capture the constraints on neighborhood size and unwanted keywords, and propose a family of algorithms for evaluation of ROU-queries. We conducted extensive experimental eval-uations to show our approaches are able to generate results for ROU-queries efficiently.
 H.3.3 [ Information Storage and Retrieval ]: Information Search and Retrieval X  Query formulation Keyword Search; Graph Data; Negative; Optional; Clique Enumeration
Keyword search has been proven as an effective method for information retrieval, most notably used in search en-gines such as Google and Bing. While traditionally key-word search was focusing on finding particular entities (doc-uments, images, videos, etc.) [8], recently we witnessed sig-nificant efforts on applying keyword search to structured and semi-structured data, including relational data [7], XML data [2] or general graphs [4], to find sets of data entries, in the form of Steiner trees [3, 4] and connected sub-graphs, such as r-radius Steiner graphs [6], keyword community [9] and r-cliques [5], that satisfy keyword and connectivity con-straints. The common themes of most of these works are: (1) one set of keywords are given as input and the AND se-mantics is enforced (all keywords are required in each result); and (2) scoring functions based on node and edge weights are used to identify the top-k results.
Fi gure 1: Example Graph component in Boolean queries [8], has not been studied in the landscape of keyword search queries on graphs.
The issues listed above strictly limit what a traditional keyword search query can express. For example, consider the example graph shown in Figure 1 and the contents of the nodes shown in the table. All the content words can potentially be keywords for different queries; keywords used in our example queries throughout the paper are in Bold and the abbreviation marked in the figure. It is reasonable to ask questions such as: Q.1 What correlated works by Molenaar and Jacobsen cover Q.2 How is the concept of artificial intelligence presented However, Existing works, even with ranking functions, can-not easily specify these queries.
Mo reover, frequently users desire highly related results that bear just the right amount of information , which means: RQ.1 the result does not include non-relevant information; RQ.2 the result carries as rich information as possible; RQ.3 the result does not include redundant information.
These requirements are not fully reflected by the ranking functions as proposed in [5 X 7,9].

We take a different stand to address the open problems in both query specification and result definition as identified above. In this paper:  X 
We propose the ROU query on graph data, which al-lows users to specify three different keyword sets: R e quired , O pti onal , and U nwan ted to integrate AND, OR and NOT semantics.  X 
We propose the maximal coverage and minimal footprint semantics for ROU queries, which are also well suited to be applied to other keyword search queries on graph data.  X 
We propose a novel data structure, called query induced partite graph, and two algorithms inspired by the Bron-Kerbosch algorithm [1] for efficient ROU query evaluation.
The data graphs we study in this paper are node-labeled undirected graphs G = ( V G ; E G ; G ), where V G is the set of nodes, E G  X  V G  X  V G is the set of edges, and G : V G  X  is a labeling function that maps each node in V G to a set of keyword terms in L . A node v contains a keyword k if k  X  G ( v ). We overload the mapping function G () so when it is applied to a set of nodes V  X  V G , it returns the union of the keyword sets of the nodes in V , i.e. G ( V ) =
Given a set of nodes V in G , we measure the size of V by the distance among the nodes in G .

Definition 2.1. [Bypass Distance &amp; Diameter] Given a keyword set K , for any nodes u; v  X  V G , the distance be-tween u and v , dis ( u; v ) , is the length of the shortest path between u and v in G ; the K -bypass distance between u and v , dis K ( u; v ) , is the length of the shortest path between u and v that does not pass through any node that contains a keyword in K . The K -bypass diameter of V  X  V G is
Please note that dis K ( u; v ) =  X  if at least one keyword in K appears on each path between u and v . Also observe that dis  X  ( u; v ) = dis ( u; v ).

Consider a set of nodes that are close to each other and do not involve the unwanted keyword terms. We now con-sider how to identify whether the set provides just the right amount of information , given positive keyword constraints. Definition 2.2. [Cover &amp; h -cover] Given a set of nodes V  X  V G , a set of keyword terms K ( K  X  =  X  ), and a threshold h , 0  X  h  X  1 , we say V h -cover K (denoted V  X  h K ), if V  X  1 K stands, we say V cover K (denoted V  X  K ).

Example 2.1. Consider the sample data graph in Fig-word set K = { A; I; L; M } , then, { v 3 ; v 4 ; v 5 } X  K , K , and { v 1 ; v 5 } X  3 4 K , { v 1 ; v 3 } 3 4 K .
Th e X  for every v  X  V , G ( v )  X  K  X  =  X   X  X lause in Def. 2.2 en-sures the satisfaction of RQ.1. RQ.3 is fulfilled automatically when | G ( v ) | = 1 holds for all nodes in G . However, when the label of a node contains multiple keyword terms, the sit-uation becomes much more delicate. Existing works [5, 9], under such circumstances, chose to take a vague stand on how each node in the result represents the keywords. Here, we will define the search results of the ROU queries in a more precise manner.
In the ROU query we introduce, users can specify key-word constraints in three different categories: the R e quired set of keywords which they want to all appear in each re-sult; the O pti onal set of keywords which they want to at least partially appear in each result; and the U nwante d set of key-words which should not be associated with the results. We use K r , K o and K u to represent them, respectively. In addi-tion, associated with the optional keyword set is a threshold h , a real number between 0 and 1. And a constraint dis MAX needs to be specified to regulate the size of each result mea-sured in terms of node set diameter.

Definition 2.3. [ROU Keyword Search Query] Given a data graph G = ( V G ; E G ; G ) , an ROU query is speci-K r  X  K o  X  =  X  ; 0  X  h  X  1 when K o  X  =  X  ; and dis MAX  X  0 .
The result of evaluating q on G is a set of node sets, i.e. q ( G )  X  2 V G . Each V  X  q ( G ) must satisfy: 1. if K r  X  =  X  , there exists V r  X  V , such that V r  X  K 2. if K o  X  =  X  , there exists V o  X  V , such that V o  X  h 3. V = V r  X  V o ; 4. d K u ( V )  X  dis M AX .

Example 2.2. Consider Q.1-2 presented in Introduction, they can be specified as ROU queries: Q.1: q 1 = ( { M o; Ja } ; { I; L; M } ;  X  ; 2 3 ; 3) Q.2 : q 2 = ( { A; I } ; { L; M } ; { T } ; 1 2 ; 2)
A pplying q 2 to the data graph shown in Figure 1, we have q 2 ( G ) = {{ v 1 ; v 2 ; v 4 } ; { v 1 ; v 2 } ; { v 2 ; v
We would like to bring readers X  attention to two types of subset relationships among node sets in q 2 ( G ): Case 1. { v 1 ; v 2 }  X  { v 1 ; v 2 ; v 4 } , { v 1 ; v 2 { v 1 ; v 2 ; v 4 } X  X  A; I; L; M } .
 Case 2. { v 2 ; v 4 }  X  { v 1 ; v 2 ; v 4 } , { v 1 ; v 2 and { v 2 ; v 4 } X  X  A; I; L; M } .

As can be seen from the example above, some resultant node sets are consumed by others: (1) a node set is by itself a node set contains redundant information, as { v 1 ; v 2 Case 2, violating RQ. 3.

Intuitively, when a set of keywords are partially covered ( h -cover), the result that covers more keywords is considered to carry richer information comparing to the one that covers less, hence should be favored over the latter.

Definition 2.4. [Coverage Comparison] Given a set of keywords K , consider two node sets V; V  X   X  V G . We say that V X  X  coverage of K is consumed by V  X   X  X  coverage of K , denoted V &lt; K cv V  X  , if V  X  V  X  and G ( V )  X  K  X  G ( V
Defi nition 2.5. [Maximal Coverage Semantics] Given a data graph G = ( V G ; E G ; G ) , an ROU query q = ( K K u ; h; dis MAX ) , the maximal coverage of the query result q ( G ) is a subset of q ( G ) , defined as
The maximal coverage semantics introduced above does not guarantee that each resultant node set is the minimal needed to cover the positive keywords ( K r  X  K o ) in query q . As a remedy, we introduce the minimal footprint seman-tics, which ensures smallest resultant node set by favoring a smaller node set over a bigger one, when the two sets cover exactly the same sets of positive keyword terms. Formally,
Definition 2.6. [Footprint Comparison] Given a set of keywords K , consider two node sets V; V  X   X  V G which cover the same subset of K , i.e. G ( V  X  )  X  K = G ( V ) If V  X  V  X  , we say that V has a smaller footprint than V covering K , denoted V &lt; K fp V  X  .

Definition 2.7. [Minimal Footprint Semantics] Given a data graph G = ( V G ; E G ; G ) , an ROU query q = ( K K u ; h; dis MAX ) , the minimal footprint of the query result q ( G ) is a subset of q ( G ) , defined as
Taking the concepts defined above all into consideration, we define the condensed semantics of ROU query, which satisfy RQ. 1, RQ. 2 and RQ. 3, as follows:
Definition 2.8. [Condensed Semantics] Given a data graph G , an ROU query q = ( K r ; K o , K u ; h; dis MAX condensed semantics computes [ q ( G ) =
Exa mple 2.3. Consider again query q 2 on G , then z }| { Note that a node set does not have to cover all the keywords in K r F igure 2: QuIP of q 2 on G These copies are the nodes in QuIP. (We refer to the nodes and edges in QuIP as t-nodes and t-edges.) Two t-nodes are adjacent in QuIP if their labels are different and (1) they are copies of the same original data node; or (2) the K u -bypass distance between the two original data nodes they represent are within the size constraint (i.e. dis MAX ) in G . Formally,
Definition 3.1. [Query Induced Partite Graph] Given a data graph G = ( V G ; E G ; G ) and an ROU query q = ( K r ; K o , K u ; h; dis MAX ) , the Query Induced Partite Graph as follows: Given a node v in data graph G , we call all t-nodes v k  X  V
T the shadows of v . And for each such v k  X  V T , we say that v is its base . We define the base () and shadow () functions to represent the mapping: shadow ( v ) = { v k | k  X  ( K r  X  K o )  X  G ( v ) } base ( V  X  T ) = base ( G  X  T ) = base ( V  X  T ) where G  X  T is a subgraph of G
In a QuIP, given a keyword k , we call the set of all t-nodes labeled k the k -cluster, denoted V k T = { v k | v k  X  V Example 3.1. Again consider query q 2 and sample graph G . G T ( q 2 ; G ) is shown in Figure 2. There are two shadow nodes of v 3 : v 3 A and v 3 I , i.e. shadow ( v 3 ) = { v There are four k -clusters, shown in dotted circles.
The following properties of query induced partite graph can be established naturally from its definition. Observation 3.1. Given a QuIP G T ( q; G ) = ( V T ; E T ; of ROU query q on G , the following statements hold:
We now show how to take advantage of the information represented in a QuIP to efficiently answer an ROU query.
Example 3.2. From Example 2.3, we know v are both bases of maximal cliques, with base ( { v 5 A ; v = { v 3 ; v 5 } and base ( { v 2 A ; v 2 I ; v 2 L ; v 4 M }
Note that different sets of t-nodes can be mapped to the same base. For example, consider V  X  T = { v 5 A ; v 3 I ; v V
However, not all the maximal cliques in G T ( q 2 ; G ) cor-respond to members of \ q 2 ( G ) . For instance, { v 3 A a maximal clique, but it does not contain enough keywords example is { v 2 A ; v 1 I ; v 2 L ; v 4 M } . Its base is satisfies maximal coverage semantics, but it does not sat-isfy the minimal footprint semantics as it covers no more keywords than { v 2 ; v 4 } does.

Observation 3.2. Given G T ( q; G ) = ( V T ; E T ; T ) :
We can see that finding all maximal cliques in QuIP is not enough for answering an ROU query. We introduce the h -cover clique to address these issues.

Definition 3.2. [ h -cover clique] Given G T ( q; G ) , G ( V
T ; E We say that G  X  T is a h -cover clique of q if
Given a QuIP G T ( q; G ), we use hcClq ( G T ) 1 to represent the set of all h -cover cliques in G T .

Theorem 3.1. Given G T ( q; G ) , which is the QuIP of q on G , the following holds:
Theorem 3.1 establishes QuIP as a suitable vehicle for an-swering ROU queries. We are interested in following subsets of hcClq ( G T ): is a subset of hcClq ( G T ) that guarantees maximal coverage. hcClq ( G T ) = is a subset of
Corollary 3.1. Given G T ( q; G ) , the following holds: Example 3.3. Consider query q 2 and four sets of t-nodes: V v
M } , and V T in G T ( q 2 ; G ) , we call them c 1 : : : c 4 , respectively. c 1 =  X  hcClq ( G T ( q 2 ; G )) as V T 1 does not cover adequate keywords, and base ( V  X  T ) = { v 1 ; v 3 } =  X  q ( G ) . c 2  X  hcClq ( G T ( q 2 ; G )) , however c 2 =  X  as c 2 is a sub-graph of c 3 , which covers more keywords. as c 3 and c 4 covers the same set of keywords, and base ( c base ( c 3 ) . c 4  X  \ hcClq ( G T ( q 2 ; G )) , and base ( c 4 )  X  [ q ( G ) .
Based on Theorem 3.1 and Corollary 3.1, we can use QuIP to answer an ROU query in two steps: (1) constructing QuIP based on an incoming query; and (2) identifying \ hcClq ( G whose base is member of [ q ( G ).

Neighborhood index is often used to answer whether two nodes are connected within a distance threshold [5]. The technique can be extended to include labels to deduce whether two nodes are connected, bypassing K u . Such extension works for small K u , but is not practical when | K u | is large. Designing better data structures and algorithms for QuIP construction is left for future work, and we consider cases where | K u |  X  1 in our experiments. Here we focus on step (2), using QuIP to compute [ q ( G ).
Enumerating maximal cliques in a graph is a well stud-ied problem in discrete mathematics [1, 11]. We adapt the Bron-Kerbosch algorithm [1] to find maximal cliques in QuIP. The details of the recursive algorithm is shown in by triggering the cdsCliqueEnum() function, with P initial-ized to be V T , and R and X empty set, is shown in Algo. 1. A lgorithm 1: [ q ( G ) Generation Da ta : G T ( q; G )
Result : [ q ( G ) 1 R  X  X  X  ; P  X  V T ; X  X  X  X  ; 2 cdsCliqueEnum ( R , P , X ) ; c dsCliqueEnum() , whose details are presented in Algo. 2, is amended with two pruning functions:  X  satisfyQ() handles positive keyword constraints. Given a set of t-nodes V  X  V T , satisfyQ(V)=TRUE if for some V r  X  V , V r  X  K r (if K r  X  =  X  ) and for some V o  X  V , V K o (if K o  X  =  X  ). It guarantees that all the maximal cliques enumerated by the algorithms are h -cover cliques.  X  notMnfp() checks if there exists a node v  X  base ( R ) such that G ( base ( R ))  X  ( K r  X  K o ) = G (( base ( R )  X  X  K ). If so, the base of R cannot possibly be a subset of any results that satisfy the minimal footprint requirement as we can always remove v for a more  X  X oncise X  result.

In Algo. 2, P is a set holding potential t-nodes that can be added to the current partial clique R . In the recursion process, t-nodes in P will always be neighbors to all the t-nodes in R . Thus whenever P is not empty, we can always pick a t-node from it to add to R to make a bigger clique. A t-node v is added to X only after all the maximal cliques containing R  X  X  v } are explored (line 12). Thus when P is empty and X is not, it implies that a clique that contains t-nodes in R  X  X has already been considered before. So a clique that contains only t-nodes in R is not maximal, and
Using Algo 2 our algorithm needs to backtrack. When both P and X are empty, a maximal clique in G T ( q; G ) has been formed; and it belongs to \ hcClq ( G T ) because of notMnfp() . So we can execution example of the algorithm can be found in Table 1. Al gorithm 2: cdsCliqueEnum(R,P,X) Data : R ; P; X
Result : bases of cliques that contain all t-nodes in R, 1 if notMnfp ( R ) then 2 return 3 end 4 if P is empty and X is empty then 5 o utput base (R) as a result; return 6 end 7 for each t-node v in P do 8 R  X   X  R  X  { v } ; P  X   X  P  X  N ( v ); X  X   X  X  X  N ( v ); 9 if satisfyQ ( R  X   X  P  X  ) then 10 c dsCliqueEnum ( R  X  ; P  X  ; X  X  ) 11 end 12 P  X  P  X  X  v } ; X  X  X  X  X  v } ; 13 end
Though cdsCliqueEnum generates exactly [ q ( G ), it may consider cliques that consist of different t-nodes but share the same base, generating duplicated results. For example, { v 3 ; v 5 } twice, one from clique { v 5 A ; v 3 I ; v 5 L } { v
Al gorithm 3: cdsCliqueEnumGreedy(R,P,X) // L ines 1-6 same as Lines 1-6 in cdsCliqueEnum 7 for each t-node v in P do 8 R  X   X  R ; P  X   X  P ; X  X   X  X ; 9 for each t-node v  X  in P  X  shadow ( base ( v )) do 10 R  X   X  R  X   X  { v  X  } ; P  X   X  P  X   X  N ( v  X  ); 11 end 12 if satisfyQ ( R  X   X  P  X  ) then 13 c dsCliqueEnum ( R  X  ; P  X  ; X  X  ) 14 end 15 for each t-node v  X  in P  X  shadow ( base ( v )) do 16 P  X  P  X  { v  X  } ; X  X  X  X  X  v  X  } ; 17 end 18 end
T o address this issue, we introduce cdsCliqueEnumGreedy , presented in Algo. 3, which can generate [ q ( G ) without con-sidering duplicated cliques. The basic idea is that when a t-node v is picked from P and put into R , we also put all shad-into R (lines 9-11), and adjust P and X accordingly. When the search is done on the current level, all these t-nodes will be moved to X to prevent cliques with same base from being considered in the future (lines 15-17). Thus if we apply cdsCliqueEnumGreedy , assuming at the beginning in Table 1 that we pick v 3 A from P at level 0, then both v and v 3 I will be added to R . When the execution terminates, { v 5 A ; v 3 I ; v 5 L } will be skipped.
Theoretically the complexity of enumerating maximal cliques in a graph with n nodes is O (3 n 3 ), as stated in [10]. How-ever, the complexity of our algorithms is much lower. In the worst case, the complexity is O (( max where | V k T |  X  | V G | and | K r case that in G T ( q; G ) each node is adjacent to only a few nodes. Under such circumstance, the recursion tree is shal-low and subtrees are small below the first level of recursion. Hence, the average complexity is very close to O ( | V T | We conduct our experimental evaluation on the Proximity DBLP database, which is based on data from the DBLPs. The data contain 1.1M nodes and 1.8M edges, and the total number of node pairs ( u; v ) that satisfies dis ( u; v ) 111M. Based on term closeness and keyword frequency, we organize keywords in groups to form queries that are repre-sentative enough to better interpret the impact of various of input parameters. We will present results of ROU queries whose keywords are picked from those in the table below.
Ou r algorithms are written in Java and our experiments are run on a laptop running Windows 7 with Intel r Core TM i5-2450M CPU @ 2.50GHz and 8GB memory, in which a maximum of 4GB memory are dedicated to the JVM.
 QuIP Size. The QuIP sizes of some example queries are shown in Figure 3 (with dis MAX = 3). In general, QuIP is significantly smaller than the data graph, both in terms of node number and edge number. In addition, the presence of negative keyword constraint, even when the size of the key-word set is 1, can reduce the size of QuIP (and subsequently lead to decrease of enumeration time). In the following, we are presenting results on a variety of graphs that are of dif-ferent size, i.e. graphs generated by Q 1 to Q 5 . Algorithm Performance Comparisons. We compare the performance of algorithm cdsCliqueEnum and algorithm cdsCliqueEnumGreedy , with the baseline algorithm, which uses the Bron-Kerbosch algorithm to generate all maximal cliques on the QuIP, then verifies the keyword constraints and the condensed semantics. The performance comparison of a selected set of queries is shown in Figure 4. Please note that log-scale is used for y-axis. For Query 3-5, we cut off the computation at 100K results as the potential result size can be huge.

As can be seen, the cdsCliqueEnumGreedy algorithm gen-erally outperforms the baseline algorithm, cutting execu-tion time by half, while the cdsCliqueEnum algorithm has comparable performance as the baseline. In cases, such as Q 4 , where very few among large number of maximal cliques in the QuIP satisfy the keyword constraints and con-densed semantics, the pruning in both our algorithms are ef-fective, and cdsCliqueEnumGreedy particularly outperforms the baseline algorithm by two orders of magnitude. Theo-retically, cdsCliqueEnum algorithm may outperform cdsCliqueEnumGreedy when the overhead of the additional pruning employed by the latter overshadow the benefit of such pruning, however, such cases are extremely rare ac-cording to our experimental study.
 Impact of Positive Keyword Constraints. To measure the impact of the distribution of the keywords among K r and K o on result size and query performance, we introduce the notion of valid keyword combinations count , which is a func-tion of K o and h , i.e. Ct ( K o ; h ) = We randomly pick sets of keyword terms, and for each set, vary the distribution of these keywords among K r and K o and the h value, then, compare the result sizes and query evaluation time among the queries that share the same K r K . Figure 5 shows the results on a set of 6 keywords picked from group 2.

Please note that when the valid keyword combinations count increases, the evaluation time increases at a much slower pace than the result size. This is due to the fact that the cliques exploited in the evaluation process share com-mon sub-clique, and the recursive nature of our algorithms are able to absorb the extra computational cost.
In this paper we initialized a research topic by introduc-ing ROU, a new type of keyword search queries on graph data, which allows user to specify both positive and nega-tive keyword constraints. We formally defined the seman-tics in terms of maximal coverage and minimal footprint. We proposed Query Induced Partite Graph (QuIP) for rep-resenting candidate data entries and their relationships, and algorithms that take advantage of information collected in QuIP to efficiently answer ROU queries efficiently. However, the problem of ROU is far from solved. Natural extension to the work presented in this paper may include: (1) inventing new summary data structures and indexing techniques to handle negative keyword conditions; (2) introducing rank-ing schemes to identify results that are most interesting and develop approximation semantics and algorithms for iden-tifying top-k results; (3) exploring parallel implementations for scalability; and (4) extending query semantics for other types of interesting keyword queries.
