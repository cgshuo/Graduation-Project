 schemas, i.e., Global As View (GAV for short) and Local As View (LAV for short). In the GAV approach a mediated schema is defined over data source schemas, while from/to system without making major changes in the mediated schema. V ,...,V n as its operands. answers to a query. Many rewriting algorithms have been proposed, e.g., the inverse few papers that consider this problem in the bucket based framework. The following examples show the influences of FDs on query rewriting, i.e., (1) sometimes we need variables through FDs, resulting in more valid buckets to be formed. schedule(Airline, Flight_no, Date, Pilot, airCraft). work for only one airline, and that any aircraft is used in one airline only. 
Hereafter, we use X  X  Y to represent an FD, X  X  m Y to represent a mapping, and Suppose that the following data source is available: V(P, C) :-schedule(a 1 , n 1 , d, P, C). Assume a user asks for pilots that work for the same airline as  X  X ike X : have a rewriting of Q as follows: Q  X  V(P,C n ),n=1,2,..... recursive rewriting is needed and then how to generate the recursive rewriting. C follows: V 1 (A, C) :-R 1 (A, b 1 ), R 2 (A, b 2 ), S(C, b 1 , b 2 , b 3 ). V 2 (E, F, G) :-S(E, F, G, b 4 ). Assume that a query is given as follows. 
Q(X) :-R 1 (X, y), R 2 (X, y) 
Any previous bucket-based algorithms cannot generate any rewritings of Q because: b V . However, we can get the following rewriting of Q through the given FDs: Q  X  (X) :-V 1 (X, C), V 2 (C, y, y). on existential variables through FDs. 
From now on we assume: 1. We only consider the influence of functional dependencies alone. schema, which follows from the papers [2,4,5]. Moreover, we do not consider how to systems. 3. We consider only queries without comparisons. to FDs under certain assumptions. Finally, we conclude the paper. A conjunctive query without any arithmetic comparisons has the form: where ) ( ),..., ( mediated schema. We require that the query be safe, i.e., is a named query. We denote the set of variables in Q and a view V by Vars(Q) and Vars(V) respectively. mapping from Q 2 to Q 1 [6,7]. definition are replaced by fresh variables. (1) Q  X  is a contained rewriting of Q, i.e., Q  X  EXP  X  Q, every two tuples t and u in R with t.A i =u.A i for i=1,...,n, also t.B=u.B. of query containment as query containment relative to  X  . Definition 3 (Query Containment in the Context of FDs). database instance D satisfying FDs in  X  , Q 1 (D)  X  Q 2 (D). Definition 4 (Maximally-Contained Rewriting in the Context of FDs). Q  X  to a query language L relative to  X  , if (1) Q  X  is a contained rewriting of Q relative to  X  , i.e., Q  X  EXP  X   X  Q, 3.1 Algorithms Based on Use of Buckets condition is satisfied (In this case we say V can cover the subgoal R in Q.). (C distinguished variables or constants in V. 
When a shared variable in Q is mapped to an existential variable in V, it needs to form a bucket containing multiple subgoals based on the following condition. (C single view. In the second step, rewritings are generated by combining a view from each bucket. Example 3. We here show the MiniCon algorithm. Suppose that there are three views as follows. V (A, C) :-r(A,C), s(W 1 ,C). V (B) :-s(B,U 2 ). V (A) :-r(A,W 3 ), s(W 3 ,U 3 ). A query is made as follows: Q(X) :-r(X,K), s(K,J). containing multiple subgoals as shown in Table 1. h C V  X  C G C A  X  m A, C  X  m C V 1 (X, K) X  X  m A, K  X  m C r(X,K) B  X  m B V 2 (K) K  X  m B, J  X  m U 2 s(K,J) A  X  m A V 3 (X) X  X  m A, K  X  m W 3 , J  X  m U 3 , r(X,K), s(K,J) 
After all the MCDs are created, the MiniCon algorithm generates all possible query rewritings by combining views from the MCDs as follows. =  X  , and (2) G C Thus, we can generate two rewritings as follows: Q  X  (X) :-V 1 (X, K), V 2 (K). Q  X  X  (X) :-V 3 (X). 3.2 Algorithms Based on Use of Inverse Rules method [10], or the resolution method [4]. following rule can be used to represent it. e(Y,Y  X  ) :-R(X,Y), R(X  X  ,Y  X  ), e(X,X  X  ). 
If a query Q contains the subgoals over wh ich some FDs hold, we need to rectify Q inverse rules of views and the rectified query. over a subgoal R(X, Y). The following rule is used to represent it: Y=Y  X  X  X  R(X  X  , Y), R(X  X  , Y  X  ). to generate query rewritings. queries containment. We now discuss the influences of FDs on these two conditions. 4.1 Influences of FDs on the Condition (C 1 ) only give a brief review on the algorithm in [1]. 
Assume that a query Q is given in the form of the formula (1) and a set of FDs is V  X  V 1 , if the condition (C Some conditions are given to transform an MCD with h(X)=Z into an MCD with h=  X  views in the MCDs with h=  X  in the same way as in the MiniCon algorithm. 4.2 Influences of FDs on the Condition (C 2 ) (C present our bucket-based algorithm. C  X  C Q Q  X  (X) :-V 1 (X, C), V 2 (C, y, y). In fact, we can get the expansion of Q  X  as follows: Q  X  EXP (X) :-R guarantee that there is a containment mapping from Q(X) to Q  X  EXP (X). the set of subgoals. pseudo-MCD and a general-MCD to store information of unification between Q and a view V. over a view V is a tuple of the form (V, h, G C , CG C , U), where: --V is a view containing the set of subgoals R 1 ,..., R n . --G C is a set of subgoals R 1 ,..., R n in Q which needs to be all covered by V. R to different existential variables in V. --CG C is a set of subgoals in V which contain other shared variables with G C . --U is a view or set of views so that the conjunction of U and V can cover G C . Q over a view V is called a general-MCD if U in a pseudo-MCD has been decided. A pseudo-MCD containing R 1 ,..., R n over a view V is formed as follows. MCD becomes a general-MCD because no violation of (C 1 ) or (C 2 ) occurs. ensure a pseudo-MCD to be a general-MCD are given as follows. variables. If CG C is empty, we do not need to proceed further. in V, and {S 4.3 Our Bucket-Based Algorithm In fact, we can also use the pseudo-MCDs and general-MCDs in Section 4.1 because Algorithm BFD: Bucket-Based Query Rewriting in the Presence of FDs Input: A set of FDs  X  , a set of the views V and a conjunctive query Q. Output: Q  X  , a maximally-contained rewritings of Q relative to FDs  X  . Step 1: FormPseudoMCDs(Q, V ) 
Form a pseudo-MCD for each subgoal of Q over each view containing at least one subgoal in Q if (1) the condition (C 1 ) is satisfied, or in Q is mapped to an existential variable in a view, or (3) the condition (C 2 ) is satisfied, or different existential variables in a view. Step 2: FormGeneralMCDs( C ,  X  , MCD ) 
For each pseudo-MCD whose h is not empty, form a general-MCD by checking the conditions (p-C 1 ) and (p-C 2 ) or the conditions in [1] respectively. Step 3: CombineGeneralMCDs( MCD ) 
Generate all the possible query rewritings using the general-MCDs in the same way as the MiniCon algorithm. 
End. 4.4 The Need of Recursive Rewritings As shown in Example 1, due to the presence of FDs, even though a given query is not the need of recursive rewritings. right hand sides are Zs, i.e., FDs={X1  X  Z,..., Xk  X  Z}.
 variables, but Z is an existential variable in V. framework as follows. {X1,...,Xk} in V. W will contain the following conjunction: R(X1,....,Xi,....,Xk, Z,...) ^ R(X1  X  ,...,Xi,...,Xk  X  , Z  X  ,...). construct the following conjunction CONJ: For n=1,2,..., we can construct a recursive query Q 1 as follows: Q (...) = CONJ 1 ^...^ CONJ n .  X  CONJ n with  X  (X1),  X  (X2),  X  (X3),  X  (X4),....,  X  (Xk), respectively. CONJ = V(P 1 ,C 1 ) ^ V(P 2 ,C 1 ) ^ V(P 2 ,C 2 ). // k=2 We first construct the following recursive query Q 1 : For n=1,2,... Q V(P,C n ). 5.1 Computational Complexity of the BFD Algorithm algorithm does not involve a significant increase in computational complexity. 5.2 Correctness of the BFD Algorithm are either contained in or equivalent to the maximally-contained rewriting. schema, the BFD algorithm produces a set of contained rewritings of Q, whose union is a maximally-contained rewriting of Q using V relative to  X  . Proof: The BFD algorithm solves the following violations: constant in Q is mapped to an existential variable in a view, or different existential variables in a view, or 
Note that we do not consider forming a pseudo-MCD over a view V if: (1) V does not contain any subgoals of Q, or (2) The condition (C 2 ) is not satisfied, but (Vio2) does not occur. same view. 1. Proof of Soundness Case 1 (Vio1): The proof of soundness in this case can be referred to that in [1]. Case 2 (Vio2): expansion of the conjunction of U and V, (U^V) EXP , to Q, i.e., (U^V) EXP  X   X  Q. Z {S 1 ,...,S p }. From the conditions (p-C 1 ) and (p-C 2 ), we have: V(X 1 ,..., X n ,...) :-R 1 (...),..., R n (...),S 1 (...),...,S p (...),.... U(X 1 ,..., X n , Z 1 ,..., Z n ,...) :-S 1 (...),...,S p (...),.... Then the expansion of (U^V) EXP is: R solved. It means that there is a containment mapping from Q to (U^V) EXP . 2. Proof of Completeness h  X  X  X  . In the former case V can cover G G . Any view appearing in a general-MCD should be in the filed V or the field U in the general-MCD. conjunctive query equivalent to S  X  . There are two cases: any general-MCDs. Clearly, V(X) is not a redundant subgoal, since S is a minimized subgoal of Q. least one subgoal of Q, which is a contradiction to our assumption above. (2) We now consider the case where a subgoal in S occurs in at least one general-MCD formed by our algorithm. When generating rewritings, we generate all possible combinations of the views from the general-MCDs, which is in the same way as that in the SVB and the MiniCon algorithm. Thus, the proof in the SVB algorithm is still assumption above. dependencies in the bucket-based framework. The novelty of our approach is that we dependencies. Specifically, we used conditions weaker than the ones in the MiniCon algorithm when forming buckets. As a resu lt, more valid buckets, named as general-MCDs can be formed. The difference between a general-MCD and an MCD is that in views, while in an MCD the subgoals are covered by a single view only. We can then experimental results which are omitted here due to the limitation of spaces. subgoals cannot be maximally-contained rewriting of a query in this case. 
