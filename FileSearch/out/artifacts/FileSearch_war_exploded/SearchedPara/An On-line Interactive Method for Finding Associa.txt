 In order to trace the changes of association rules over an online data stream efficiently, this pa per proposes two different methods of generating all association rules directly over the changing set of currently frequent itemsets. While all of the currently frequent itemsets are monitored by the estDec method, all the association rules of every frequent itemset in the prefix tree of the estDec method are generated. For this purpose, a traversal stack is introduced to efficiently enumerate all association rules. These online methods can avoid the drawbacks of the conventional two-step approach. In an on-line environment, a user may be interested in finding those association rules whose antecedents or consequents are fixed to be a sp ecific itemset. Since generating all the association rules may take too long to produce them timely, two additional methods, namely Assoc-X and Assoc-Y , are introduced. Finally, the proposed methods are compared by a series of experiments to identify their various characteristics. H.2.8 [ Database Applications ]: Data mining Keywords: Data streams, Data mining, Association Rules, Frequent itemsets Given a minimum support S min and a minimum confidence C association rule mining is a tw o-step process: finding frequent itemsets and generating all association rules. The major bottleneck of this association rule mining is the first step. Because of this, most researches concentrate on devising an efficient method of finding frequent itemsets in a data set. Apriori [1] is a well-known algorithm fo r finding frequent itemsets. Various algorithms [2, 3] are proposed to find a more efficient way to obtain the set of frequent itemsets. Recently, various algorithms [4,5] have been actively proposed for finding frequent itemsets over a da ta stream. To minimize the number of itemsets to be monito red for finding frequent itemsets over a data stream, the estDec method [6] is proposed. The two major operations: delayed-insertion and pruning operations guarantee that all of currently significant itemsets are maintained. For the second step of association rule mining, an online mining algorithm is proposed in [8]. Those association rules that do not have any redundancy are called as essential rules . In [9], a simplified form of an association rule between two items over a data stream of items is introduced for fraud detection in web advertising networks. However, considering the requirements of on-line data stream processing, they are not suitable for finding frequent itemsets over an online da ta stream.To the best of our knowledge, an on-line method of generating association rules over a data stream has not been addressed before. This paper proposes an on-line approach for the generation of association rules. A t_stack is introduced to efficiently enumerate all possible association rules. This on-line approach can avoid the drawbacks of the conventional two-step approach. Furthermore, a prefix tree itself plays a role of an index structure. Actually, two proposed. Furthermore, in on-line environment, a user may be interested in finding those association rules whose antecedents or consequents are fixed to be a speci fic itemsets. For this purpose, two additional methods, namely Assoc-X and Assoc-Y , are introduced. The rest of this paper is organi zed as follows: Section 2 describes how all possible association rules of a particular frequent itemset are enumerated in a prefix tree in detail. Section 3 describes two different methods of finding all the association rules over an on-line data stream. Section 4 describes the Assoc-X and Assoc-Y methods in detail. In Section 5, the performance of the proposed methods is evaluated by a series of experiments to identify their various characteristics. Finally, S ection 6 concludes this paper. In this paper, association rules can be categorized by two different types, namely ordered and unordered rules [7]. For example, according to the lexicographical order of items, a rule ac  X  de is an ordered rule while ad  X  ce is an unordered rule. In order to find out whether a currently frequent itemset in the prefix tree can generate any association rule, the current supports of all the non-empty proper subsets of the itemset are required to compute the on-going confidence of all possible rules. A traversal stack defined in [7] is employed to enumerate all the ordered and unordered rules of a frequent itemset. When the information of the path from the root to a node corresponding to a frequent n -itemset e = i 1 i pushed into the t_stack, all rules are enumerated as follows: Ordered rules: The current confidence of the first ordered rule i  X  i 2 ... i n is examined by computing t_stack [ top ]. c / t_stack [1]. c = C ( e ) / C k ( i 1 ). Similarly, the j th ordered rule, i examined by t_stack [ top ]. c / t_stack [ j ]. c= C such a way, all of the n -1 ordered rules are examined. Unordered rules: The unordered rules of the itemset are divided into two disjoint sets: One is the set A1 of those rules that contain the first item i 1 in their antecedents and the other is the set A2. For efficient enumeration, the antecedent of an unordered rule is divided into three mutually exclusive parts, namely predecessors , alternatives and combinators while its consequent is the remaining items of the itemset e . For the first set A1, starting from the ( top -1) t_stack, the items of the t_stack are examined to be categorized into the three parts. When the j th element of the t_stack is examined (1  X  j  X  top -1), all those unordered rules that satisfy the following two conditions t ogether are enumerated. i ) The j th item of the itemset e is in the consequent and ii ) All the items t_stack [ k ]. i (2  X  k  X  j -1) before to the j in the antecedent. The items t_stack [ k ]. i (2  X  k  X  j -1) are before the j t_stack. All these predecessors s hould be in the antecedent to satisfy the second condition. In contrast, the items after the j element of the t_stack become th e alternative. Each node of the subtree rooted at the node corre sponding to the itemset composed of the predecessors and one of the alternatives can produce a rule for the above conditions. For each a lternative item, its combinator items are those items that are lexicographically after the alternatives. When the j th element of the t_stack is examined, its these predecessors in their antecedents and contain the j their consequent are enumerated. For one of the alternatives i ... i n , say i k ( j +1  X  k  X  n ), all the items t_stack [ l ] ( k +1 after the alternative i k become the combinators. After examining the first set A1, the elements of the t_stack are processed once more in reverse order to examine the rules in the second set A2. For the j th element (2  X  j  X  n ) of the t_stack, all the nodes of the subtree S( i j ) rooted at the 1-item i the same manner as in the first set. In this case, the item of i becomes the predecessor while the items before the j t_stack [ k ] (1  X  k  X  j-1 ) are in the consequents. To examine all the nodes of this subtree, the remaining items t_stack [ l ] ( j +1 are combinators while there is no alternative. Figure 3 illustrates how to examine all the rules of a 3-frequent current information of those nodes in the path into the t_stack . The complete set of all the rules that can be generated by the itemset abc are listed in Figure 3-(b) and Figure 3-(c) association rules of every frequent itemset traced by the prefix tree of the estDec method. It can be the fifth phase of the estDec method. To find all the rules of every frequent itemset, the prefix tree is traversed in a pre-order depth-first manner. At first, starting from the root node, among the nodes whose itemsets are currently frequent, the deepest left-most node is visited. Upon visiting a child node, its item and current count are pushed into the t_stack . When reaching the deepest left-most node, its ordered and unor dered rules are generated as described in Section 2. As soon as all the rules of the node are examined, the top entry of the t_stack is popped. Subsequently, the information into the t_stack . If there is no unvisited sibling node, return to its parent node and the ru les of its parent node are generated by the same way. This procedure is terminated when all the nodes whose itemsets are currently frequent are traversed. The search space of the Assoc-all-na X ve method can be reduced by the well-known anti-monotone property of the support of an whose antecedent is a non-empty proper subset of the itemset v can be generated by Theorem 1. Therefore, the search space of the Assoc-all-na  X  ve method in the prefix tree can be reduced. Theorem 1. Given a minimum confidence C min and two frequent itemsets X and Y ( X  X  I , Y  X  I , X  X  Y ) if the rule X  X  Y  X  X is not generated, no rule whose anteced ent is a non-empty proper subset of X can be generated. proof.) Since X  X  Y  X  X is not a valid rule, S ( Y ) / S ( X ) &lt; C Z be a non-empty proper subset of X ( Z  X  X ). By the anti-When the information of a path from the root to a node corresponding to a frequent n -itemset e = i 1 i pushed into the t_stack, all rules are enumerated as follows: Ordered rules: The current confidence of the first ordered rule i ... i n-1  X  i n is examined by computing t_stack [ top ]. c / t_stack [ top -1]. c = C k ( e ) / C k ( i n-1 ). The next ordered rule i examined. The sequence of examining the subsets of the itemset e in the t_stack is exactly reverse to that in the Assoc-all -na X ve method. Unordered rules: This process is divided into two different parts. In the first part, the nodes of the prefix tree P k are visited by post-order traversal in order to reach a node with the following two conditions; 1) its corresponding itemset is a subset of the itemset e and, 2) it contains an item which is lexicographically succeeding to In each visited node in the path , the above two conditions are examined. If one of the above two conditions is not satisfied, none of its descendant nodes needs to be traversed. This is because there is no chance to encounter a node corresponding to a non-empty proper subset of the itemset e . When a node corresponding to an itemset e 1 satisfies the two conditi ons, the second part is started by computing the confidence of a rule e 1 Therefore, none of them should be examined. Otherwise, by traversing the prefix tree, the current support of every non-empty proper subset e 2 of the itemset e 1 is looked up to see whether e e  X  e 2 can be generated. The evaluation of these two parts is repeated until no node satisfies the above two conditions. To generate all the rules whose antecedents are the same as a specific itemset X , the current supports of all the supersets of the itemset X should be searched in the prefix tree. For a superset e of when the current supports of the itemsets X , e and e -X are frequent. Furthermore, the performance of this process can be further enhanced by reducing the number of visited nodes by Theorem 2. Theorem 2. Given a minimum confidence C min , if a rule X  X  Y is not generated for two itemsets X and Y ( X  X  I and Y X  X  Y for any superset Y ( Y  X  Y ) of the itemset Y is not also generated. proof.) If the rule X  X  Y is not generated, S ( X should be true. Since Y  X  Y, S ( X  X  Y )  X  S ( X  X  Y ) should be hold. the rule X  X  Y cannot be generated.  X  For a given n -itemset X = i 1 i 2 ... i n X  X  I , the paths of a prefix tree P are searched by pre-order traversal to reach a node corresponding to a superset of the itemset X . However, upon visiting a node w corresponding to a v -itemset  X  =  X  1  X  2 ...  X  nodes needs to be visited if one of the following three conditions is met. i) S (  X  ) &lt; S min ii)  X  an item i j such that i j  X  X , i j  X   X  and i iii) S (  X  ) / S ( X ) &lt; C min (by Theorem 2). To generate all the rules whose consequents are the same as a itemset Y should be found. Unlike the Assoc-X method, those itemsets that are the antecedents of the rule X  X  Y should be enumerated. For a fixed n -itemset Y = i 1 i 2 ... i prefix tree P k are searched by pre-order traversal to find a node corresponding to a superset of the itemset Y . However, upon visiting a node w corresponding to a v -itemset  X  =  X  descendant node needs to be visited if one of the following conditions is met. In this section, the performan ce of the proposed methods is analyzed by several data sets. Except for the data set Weblog , the data sets are generated by the sa me method as described in [1]. The data set WebLog is a real web-page access log data. In all experiments, the transactions of each data set are looked up one by one in sequence to simulate the environment of an online data stream. All experiments ar e performed on a 3.0GHz Pentium PC machine with 1GB main memory running on Ubuntu Linux 5.1 and all programs are implemented in C. In Figure 11, the performance of the Assoc-all-naive method is compared with that of the Assoc-all-anti method. The effects of S min on average processing time are illustrated in Figure 11-(a). As expected, the number of generated association rules is inversely post-order traversal, this strategy is very sensitively affected by the height of a prefix tree. To measure the accuracy of the proposed methods, a term average association rules } ) ( | )) ( , {( min the relative accuracy of R 2 over R 1 is defined by ACE ( R follows: As shown in Figure 12-(a), the ACE ( R proposed method becomes small enough after the processing of the estDec method is stabilized. As shown in Figure12-(b), the ACE is mostly not affected by the value of C min . Figure 13 shows the performance of the Assoc-X and Assoc-Y methods. In the figure, a term assoc-x-thm2 denotes the method that employs the pruning strategy in Theorem 2. As the length of a specified item is increased, the search space becomes smaller as shown in Figure 13-(a). Due to the same reason, the average processing time in Figure 13-(b) is inversely proportional to the length of a specified item. Figure 13-(c) illustrates the mining accuracy of these methods. Considering the continuity of a data stream, the conventional two-step approach for generating th e association rules of a finite data set is not efficient in a data stream any longer. By monitoring the current counts of all frequent itemsets in a data stream by the prefix tree of the estDec method, this paper proposes a method of generati ng all the association rules directly over the changing set of currently frequent itemsets continuously. All the association rules of every frequent itemset in the prefix tree are efficiently enumerated by the t_stack . Furthermore, to cope with an interactive request of generating all association rules of an itemset specified by an user, the Assoc-X and Assoc-Y methods are introduced. This work was supported by the Korea Science and Engineering Foundation(KOSEF) through the Nati onal Research Lab. Program funded by the Ministry of Sc ience and Technology (No.R0A-2006-000-10225-0). [1] R. Agrawal, R. Srikant, Fast algorithms for mining association [2] S. Brin, R. Motwani, J.D. Ullman, and S. Tsur. Dynamic Itemset [3] V. Ganti, J. Gehrke, and R. Ramakrishnan. DEMON: Mining [4] Yun Chi, Haixun Wang, Philip S. Yu, and Richard R. Muntz. [5] G.S. Manku and R. Motwani. Approximate Frequency Counts [6] J.H. Chang and W.S. Lee. Finding recent frequent itemsets [7] S.J. Shin and W.S. Lee. Enumer ating Association Rules of an [8] Charu C. Aggarwal, Philip S. Yu: A New Approach to Online [9] Ahmed Metwally, Divyakant Agra wal, Amr El Abbadi. Using 
