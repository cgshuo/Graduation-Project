 XQuery is a standard query language proposed by W3C [9], and has reached a widespread recognition as a mapping language for many modern XML-based data sharing architectures such as data integration, data exchange and peer-data man-agement systems. However, constructing such semantic mappings is a labor-intensive and mapping discovery [5, 6] has made exciting progress towards semi-automating such mappings, i.e., the naive yet troublesome XQuery expressions. 
In this paper we propose a framework for constructing and representing XQuery mapping from source schemas to target schema. In our framework, a global mapping is represented by the combination of atomic mappings and binary operators that re-cursively combine simpler mappings into more complex mappings. Different from the naive expressions, the combined mappings obtained in this way are extensible and maintainable, which gives flexibility and reusability in the process of mapping con-struction and maintenance, and alleviates the burden on the user in general cases. 
We present the Nest , Join and Product combination operators to connect two mapping (say M 1, 2 ) is extensible, which means that M 1, 2 can be combined again with combination operator of M 1, 2 , or recover M 1 and M 2 from it. Thus, the global schema mappings can be incrementally constructed by continuously applying the combination operators. Further, to maintain such combined mappings, it only needs to adjust the corresponding parts, e.g., the submappings affected by schema evolving, while other parts are reused to the new context. 
On the other hand, automated support for constructing the combined mappings can be provided based on the previous works on schema matching (e.g., [7, 3, 2]) and mapping discovery [5, 6]. For example, atomic mappings may be generated in terms of the results of schema matching, and combined mappings may be derived from the schema elements. Due to limited space, we omit the discussion from this paper. 
The paper is organized as follows. Section 2 uses a running example to illustrate our framework of mapping combination. Section 3 presents the combination operators in detail. Finally, Section 4 concludes. Suppose there is an online bookshop that wants to collect data from other sources. Figure 1 shows the nested target schema T of the bookshop and S1 and S2 of its two data sources. We model XML schema as usual with a tree. The nodes correspond to XML elements. The edges represent the parent-child relationships, and have a multi-plicity label that takes a value from {?, *, +,  X  }, which indicates the cardinality con-straint. Every referential relationship is represented as a non-tree edge (e.g., the edge r in S1 ). 
Figure 2 shows a XQuery mapping that defines the data translation from the sources into the target. Note that the target schema element review is optional (con-strained by  X * X ), so even if the novel instance in S1 has no corresponding reviews in the element review with  X + X . Accordingly, the above mapping has to be modified to keep it consistent. Yet directly editing the naive XQuery expression is difficult. 
To address this problem, we propose to construct and represent the global mapping by the combination of atomic mappings. In our framework, we consider the usual FLWR expression of the XQuery syntax, which is composed of FOR , LET , WHERE and RETURN clauses [9]. The function of the FOR and LET clause is to bind vari-ables, respectively called F-variables and L-variables . Each F-variable may be speci-fied by an absolute or a relative path expression. For example, in the outermost FOR clause of the above mapping, the F-variable $bs is specified by an absolute path (of $bs is a prefix F-variable of $n , and $n is a suffix F-variable of $bs . 
Given a mapping, let $v be one of the F-variables of the outmost FOR clauses. If variable ( PFV ) of the mapping. An atomic mapping satisfies the following constraints: containing no submappings, having only one PFV, and its result pattern (declared by the RETURN clause) being one single element. Samples of atomic map-pings are given below. 
We denote the atomic mappings by symbol M , which has a subscript in terms of target T , so the first atomic mapping above is denoted by M book() . More specially, an atomic mapping also allows the prefix F-variables and WHERE clause, and functions are also permitted in defining the PFV. 
Atomic mappings specify local views of single target schema element. By applying combination operators given in next section, we connect them to form combined map-pings, which formulate more complete views. For example, using the Nest or Join M
When there is no confusion, from now on we also use M book(...) to uniformly de-M the one in Figure 2, but now it is extensible and maintainable. For example, the above requirement can be easily satisfied with resetting the combination operator applied As shown in the above section, mapping combination is to connect two mappings through a set of combination operators. Driven by the target schema, a combination operator merges the results of two mappi ngs according to the relationship between them. Following from the XQuery standard [6] and the experiences in relational data-mappings. Accordingly, we define them respectively as Nest , Join and Product com-bination operators. M follows. 
As will be seen, the cardinality constraints in the target are satisfied with the opera-tor types, and the source elements (bindings of the F-variables) are related by con , the resulting combined mapping M e(a1, ..., ai-1, ai) always nests the instances of a i within those of e . Nest Operator. Consider again the mapping in Figure 2. It indicates that for each $n binding, there will be a book instance returned to the target. However, if there are no corresponding reviews in the source S2 , the book instance will be with no review attributes. In other words, there is an outerjoin that connects the outer and inner sub-mappings (i.e., $n and $b bindings). 
We use the Nest operator to capture such meanings. Here the resulting combined M ment novel and title . To relate $n and $t bindings, we assign $n/title=$t to con . The result of Nest ( M book() , M title , $n/title=$t ) is as follows. 
Other combined mappings can be constructed in the same way. In our running ex-ample, title is mandatory in source S1 , so the returned book instances always contain the attribute. Otherwise, for each $n binding, for example, if there was no $t bindings satisfying the connection condition, the book instance returned would con-tain no title attribute. view) . However, when the cardinality cons traint  X * X  of review in the shop schema is replaced with  X + X , the mapping should filter out those books with no reviews. The Nest operator no more satisfies such requirement. Instead, here a join rela-tionship is needed. 
We use the Join operator to capture such meanings. To specify the combined map-$v ) to the associated sequence (e.g., the results of evaluating M ai ) as a whole. Then the filter count($v)&gt;0 is used to guarantee that only when the connection condi-tion con is satisfied, can a new instance of e be returned. We use the following exam-connect them to filter those books with no reviews. possible to connect the mappings such as M book() and M title , yet the result is same as the Nest operator because of the cardinality constraints of the source schema. Product Operator. The third way to connect mappings is by the product relation. In XML database, it is usual to nest relating author elements within the same book ele-ment, whereas in normal relational table one book tuple has one author value. When the target schema is a default XML view over relational database [8], the mappings may need to express product relationship. 
We use the Product operator to satisfy such requirement. For example, suppose book-author is a relational table in target, and title and author are its two attributes. A book-author tuple is determined both by the novel and writer of S1 , so two separate atomic mappings are constructed as follows. Using the Nest operator, we combine them with M title and M author , respectively. then connected again by the Product operator and the following mapping is obtained. 
The above mapping indicates that for each pair of $n and $w bindings, as long as there exists a wid that equals the corresponding i d, a flattening book-author bined mapping M e(a1, ..., ai-1, ai) is obtained by merging the FOR , LET , WHERE and Mapping maintenance is an usual task for the Web-based application. To avoid deal-ing with the naive yet troublesome mapping expression, this paper described the map-ping combination framework for constructing extensible XQuery mappings. In terms presented. Our approach gives the flexibility and reusability in the process of mapping construction and maintenance. We believe that our work is also useful to the problem of managing and visualizing XQuery mappings (or views). 
