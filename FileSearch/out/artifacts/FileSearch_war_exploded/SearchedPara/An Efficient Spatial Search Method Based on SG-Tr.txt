 For objects in a spatial database, existing Access Methods impliedly assume that their spatial sizes are approximately similar. In real applications the region size of objects are often much different, and the size and position of regions are dynamic changeable, which make the efficiency of access methods based on MBR (such as the most its extension) decrease largely, for the high cost of node splitting and entity rectangle modifying caused by the insert, delete, and update operation. To solve above problem, this paper proposes a novel index structure called Space Grid Tree (SG-Tree). The main ideas are: (c) Executing overlapping search operation on SG-Tree to retrieve the objects Section 3 introduces the concept of spatial hypercube grid and proposes the structure objects. Section 5 introduces the search operations of SG-Tree. Section 6 presents the performance study. Section 7 gives the conclusion and future work. (PAMs) and spatial access methods (SAMs). To the SAMs, many classical index overview of multidimensional access methods [1]. The most popular SAMs include The first is that the region of each entity in node must be included for the use of node CPU resource. We want to find index structure satisfying the two conditions: the node splitting cost is negligible and the range of entities can be ignored. 3.1 Space Hypercube Grid A spatial database consists of a collection of spatial objects. Each object has a unique overcast region or bounding box of an object in n -dimensional space can be described space recursively. A SFC with order k passes through n-dimensional space and maps described with a k -bitstring. A point with coordinate V on a dimension can be mapped mapping formula: the SFC is Peano curve, the derived key of the grid can be gained by simply shuffling the k -bitstring of its n edges. shaped grids. Each of these grids is called a Hypercube Grid Unit with granularity k 214 Y. Liu et al. constructing this hypercube unit. 1, 2, 3 respectively. We can find that the hypercube unit passed by Peano SFC has the following characters: 3.2 Structure of Space Grid Tree these 2 n child hypercube grids X  z-value share the same prefix corresponding to the z-Space Grid Tree. Definition 2. The Space Grid Tree (SG-Tree) of n -dimensional space partitioned by Peano SFC with order k is a tree structure where: (3) Each node has an oid_bucket recording objects overcastting relative grid. 
On each level of a full SG-Tree, the nodes mutually disjoint and the union of their should be unevenly and there are many subspaces without any object overcastting them. These empty subspaces can be ignored for the construction of SG-Tree. from a first level node to the target node according to the z-value of given hypercube node to the target node. The target node is enclosed by all the nodes on Path(g) . The target node encloses all the nodes on SubT(g) . 2. pointer  X  the node with node_mark equalling to order on level 1 4. order  X  substring(z-value, i , n) 5. finding child node x of pointer with node_mark equaling to order 7. pointer  X  x 8. i ++ 11. return pointer 4.1 Linearization of Spatial Objects To index the overcast region of spatial objects with SG-Tree, the bounding box of an object need to be transformed into a union of hypercube grid with variant granularity. linearization method presents the overcast region of object: 
Figure 2 illustrates the three linearization strategies to present the bounding box of of r 3 is the result of simple linearization strategy. 216 Y. Liu et al. 
According to Figure 2, we can find the characters of each strategy. Exact occurrence of false-negative. Simple linearization strategy conquers the false-negative will cause the occurrence of false-positive. 4.2 Index of Spatial Objects The bounding box of a spatial object can be presented as a set of hypercube grids with variant granularity. The overcast region of object then can be mapped into the relative nodes of SG-Tree. Algorithm 2 illustrates the insert operation of spatial object. Algorithm 2. Insert( o ) 3. i  X  0, L  X  length(g), tempnode  X  root 4. while I &lt; L do 5. temporder  X  substr( g , i , n) 6. find the child node n X  of tempnode with node_mark value temporder 8. tempnode  X  n X  , i ++ 10. create new node n X  and make tempnode as it parent 11. tempnode  X  n X  , i ++ 12. add object X  X  oid into the oid_bucket of tempnode the left. We can find that an object need register many times on different level nodes with core linearization strategy (the shady path). To find all spatial objects having at least one point in common with a given object, i.e. linearization strategy. For each hypercube grid we execute search on SG-Tree. Algorithm 3 gives Intersection Query operation. Algorithm 3. IQ( o X  ) 1. Result  X   X  4. Path(g) , SubT(g)  X  Grid_find(g) 5. for each node on Path(g) and SubT(g) , add data in oid_bucket into Result The other common search operations includes Exact Match Query (EMQ), Point Query (PQ), Range Query (RQ), Enclosure Query (EQ), Containment Query (CQ), Adjacency Query (AQ), k-NN Query (NQ), Top-k Query (TQ), and Spatial Join. The locating on the same or different level, which make these common search operations objects. granularity of SG-Tree should be at least multidimensional space. We compare our method with directly matching method i.e. the overlapping judgment is implemented by comparing with each object X  X  bounding box storing in main memory. 
Figure 3 illustrates the time consumption of Intersection Query over SG-Tree in 3-dimensional space under different granularity. Each time we select 100 objects 218 Y. Liu et al. randomly and for each object we find out all the objects it intersecting. We count the time and are more efficient than memory match method. Simple Linearization Strategy is relatively inefficient but usually better than memory match method. Strategy and k -NN query with Core Linearization Strategy. The result shows that the SG-Tree to avoid False-positive . 
For a spatial database, an object intersects with many objects. The best method for top-k and k -NN query is to construct SG-Tree with Core linearization Strategy for we can always find out k objects even though the marginal region is ignored. search operations. This structure can efficiently implement the common spatial database operations, including Dynamic Insert/Update/Delete of spatial object, EMQ, Tree, we suppose that each node contains just an entry denoting a grid, i.e. the fanout structure. While taking paging of secondary memory into account, SG-Tree would disadvantage is the future work we should solve. 
