 In this paper, our focus is on the problem of estimating the number of substring matches in long string database. For a given query pattern, we would like to return the estimated count, and the lower and upper bounds like the followings.  X  Query :  X  X nswer : Among research endeavors that have focused on estimating substring selectivity those by Krishnan et al. [9] and Jagadish et al. [7], both of which have interested in the one-dimensional estimation problem to handle one pattern having wild-cards like the above query. The basic framework commonly used in both of them for indexing substrings in a database in a way that stores strings and their all suffixes together. In addition to store strings and their suffixes, the CS-tree has a count at each node for keeping the number of occurrences of each substring; nodes having small count would be pruned due to memory restriction.
 short strings such as name or title, the CS-tree has two drawbacks: one is that some count values that the CS-tree keeps may be incorrect, which is caused by frequent pruning. The other is that it is almost impossible to build the CS-tree over long strings such as biological sequences, because the CS-tree must handle long suffixes within the given memory size.
 propose a CQ-tree (Count Q-gram Tree) 1 that keeps the exact count values of all substrings whose lengths are q or below q found in the long strings, and can be constructed in one scan of data strings and in O ( q  X  N ) cpu cost. Furthermore, based on the CQ-tree, we return the estimated count of a query pattern as well as the lower and upper bounds that the number of occurrences of the query can reach to. These bounds are mathematically proved.
 ground and the related work. Section 3 presents a CQ-tree and properties that the CQ-tree has. In Section 4, we present the lower and upper bound that the number of occurrences of a query pattern can reach to, and prove them mathe-matically. The results from our experimental study are presented in Section 5. Finally, in Section 6, we deliver the conclusions of this work. In this section, we introduce a CS-tree [9, 7] with an example, and MO estimation strategy proposed by Jagadish et al. [7]. 2.1 CS-Tree A CS-tree is a trie-based data structure as a variation of a suffix tree [10] widely used for data compression [3], pattern matching [14], and other applications. For string  X  , a CS-tree is obtained by inserting both string  X  and its suffixes into the tree, and counting the numbers of occurrences of inserted substrings at the corresponding nodes. babba ,  X  X  X  , a are put into the CS-tree with sharing a common prefix between a pair of suffixes. In the tree, each edge has a label, and each node keeps a count for a concatenation of labels from the root to the node. The count value 6 of the root node means that six suffixes are inserted to the tree, and the count value 2for ab traversed from the root implies that two suffixes begin with ab ,andin other words, substring ab occurs twice in string ababba .
 other selectivity estimation applications, nodes having small count are occasion-ally pruned out in the CS-tree, while the tree is being built and when the number of nodes in the tree is likely to exceed the given maximum memory size. In Fig. 1, nodes having count value 1 would be pruned, and could not be utilized in time of selectivity estimation.
 a case that at first a node having the small count of aba is pruned out, but after that a lot of aba appear, and finally another node for aba survives in the tree. In the case, the count of aba is incorrect because the final count does not include the number of aba that has appeared before the first pruning.
 is hard to handle so long suffixes that cannot fit in the memory because the CS-tree building process compares a suffix with another, and prunes only nodes, not labels. As a result, the CS-tree is not suited for long strings. 2.2 Count Estimation with CS-Tree MO (Maximal Overlap) that Jagadish et al. [7] have suggested parses a given pattern into all maximal substrings that can be found in the CS-tree. For ex-ample, pattern aba is divided into ab and ba with overlapping b ,and C aba representing the count of aba is obtained from the ones of ab and ba as shown in the next formula. where N is the total size of strings inserted in the CS-tree, pr ( aba ) is the prob-a given that the preceding string aba has been observed. In this section, we propose a CQ-tree, and present a compact data structure for the CQ-tree. 3.1 Target Database and Notation where  X  k is a string over an alphabet  X  . The alphabet size |  X  | denotes the number of distinct single characters in the database. For a string  X  ,  X  [ i : j ] When the length of string  X  is represented by |  X  | , the sum of the lengths of all is biological sequences such as DNA and protein, which are now available in the web [13]. A DNA sequence is a very long string over a four-letter alphabet of A, C, G and T. So, |  X  | of a DNA sequence database is 4. 3.2 Definition and Properties of CQ-Tree The definition of a CQ-tree is formally stated as follows.
 Definition 1. A CQ-tree for a database  X  containing strings  X  1 ,  X  2 , ... ,  X  n is a trie, such that is built by sharing common prefixes between a pair of substrings that are among all the pieces of length q (called q-grams ) and all suffixes of the last q-gram present in  X  . In the tree, every edge has a label obtained from the common prefixes, and every node has a count value for keeping the number of occurrences of a string created by concatenating labels from the root to the node. For a string ababba , for example, Fig. 3 shows its q-grams and CQ-tree, where q is 3. The CQ-tree consists of q-grams aba , bab , abb , bba and suffixes ba , a of the last q-gram.
 CQ-tree implies that the counts of all prefixes of the substring increase by 1, which is extended to Theorem 1.
 Theorem 1. For a given string  X  , the CQ-tree keeps the exact count values of all substrings whose lengths are equal to or less than q , and which exist in  X  . This can be simply applied to more than one string.
 Proof. When a q-gram  X  [ i : i + q  X  1] is inserted into a CQ-tree, the count values With inserting q-grams of string  X  into the tree one by one, i varies from 1 to the length of  X  , thus all substrings that are length q or below q are counted. CS-tree follows node-pruning and post-pruning . In Fig. 1, a node having count 1 and label abba to be the tail of ababba would be pruned later due to its small count. In short, the node is pruned later . In contrast, the first q-gram aba can be thought of being created by cutting the tail of string ababba to length q string before inserted into the CQ-tree, as can be seen in Fig. 3. These ideas allow the CQ-tree to be quickly constructed.
 extracted with scanning strings in a database character by character, the q-gram traverses the CQ-tree for comparing labels with itself at most q times. So, the tree can be built in one scan of the database and with the maximum number of comparisons q  X  N .
 edges because the maximum height of the tree is q , and the maximum edges that a node can have is the alphabet size |  X  | . At the moment, the CQ-tree becomes a D is the size of a node, and the rest is the number of nodes. Due to the limit of memory space, the size of the tree must be no more than the given memory space M as shown in (5).
 By rearranging (5) in terms of q , is obtained.
 and numbers of strings in a database. In other words, although strings in the database get more and longer, the maximum size of the tree does not change. Only q-gram length q and the alphabet size |  X  | as characteristics of strings affect the maximum size of the tree. Also, it should be noted that an appropriate q can be decided by (6) before building the CQ-tree. 3.3 Mapping CQ-Tree to Full n -ary Tree Even though a CQ-tree can be implemented in various ways [9, 10, 4, 2], there is a more compact data structure for the CQ-tree under a condition that the alphabet size of a database is small ( e.g. DNA sequences): an array representing a full n -ary tree. That is, the CQ-tree is mapped to a full n -ary tree, and is stored in an array [5].
 then stored in an array. During the change, 5 number of nodes having 0 count are newly created in the full binary tree, and a node is added by splitting two nodes on the path bba to three ones.
 n -ary tree can be expressed in a one-dimensional array without wasting space because of any labels and pointers that link a parent node with child nodes. In this section, we present how to get the count estimation and the lower and upper bounds. Suppose that length-n pattern  X  is given against a CQ-tree, which provides all the counts of length-q or below length-q substrings ( n&gt;q ). The count is simply estimated by MO [7]. By adjusting Equation (4) to the CQ-tree, we can get If the denominator of (7) is 0, C  X  [1: n ] must be 0, because the count of a string is 0 if its any substring has 0 as the count.
 Lemma 1. For two strings  X  and  X  ,  X  X  denotes the concatenation of  X  and  X  , and  X   X  denotes the set of all strings except for  X  . Then, the next formulae are satisfied. Lemma 1(a) implies that the string  X  has, as its following string,  X  or any other strings except for  X  . Lemma 1(b) is easily obtained from Lemma 1(a), because all the counts are positive or zero in Lemma 1(a).
 extending Lemma 1(b). The count of pattern  X  must be equal to or below the counts of all q-grams present in  X  as follows: Thus the upper bound of C  X  is Lemma 2. For three strings  X  ,  X  ,and  X  , C  X  X  X   X  C  X  X  + C  X  X   X  C  X  is satisfied. Proof. From Lemma 1(a), are obtained. From Lemma 1(b), is also done. By substituting the left and right terms of (iii) with (i) and (ii), we can get Consequently, Lemma 2 is proved by rearranging (iv).
 Lemma 2 implies that the lower bound of C  X  X  X  is C  X  X  + C  X  X   X  C  X  . Theorem 2. For a string  X  of length n , the count of  X  can be bounded by all the counts of its q-grams and (q-1)-grams as follows: Proof. We will prove Theorem 2 by the mathematical induction. When n is q + 1 as the initial condition, the theorem is satisfied by replacing  X  ,  X  ,and  X  Then, we assume that when n is k (in here, k&gt;q + 1), the theorem is true, that is, From now on, on the basis of the above assumption and Lemma 2, we will try to show that the theorem is satisfied, when n is k + 1. First, when Lemma 2 has  X  =  X  [1 : k  X  q ],  X  =  X  [ k  X  q +1: k ], and  X  =  X  [ k +1: k + 1], Then, applying Formula (12) to Formula (13) yields Once again, by Lemma 2, is obtained, hence Formula (14) is changed into Finally, by rearranging Formula (16), we can get
C which is the theorem on the time that n is k + 1. In summary, we first showed that the theorem is true, when n is q + 1. Then, it was also shown that if when n is k , the theorem is true, so is it when n is k + 1. Consequently, Theorem 2 is proved.
 because the count cannot be negative. It should be noted that the CQ-tree has all the exact counts used in the lower and upper bounds. Namely, the CQ-tree supports both of the bounds well.
 Example 1. Given C bcd = 40, C abcd = 20, and C bcde = 30, estimate C abcde together with the lower and upper bounds.
 Solution 1. In this section, we experimentally show the building time and space of a CQ-tree, and examine if the CQ-tree supports MO estimation technique well. All the experiments were performed on a 1 GHz Pentium 3 processor with 768 MBytes of main memory and 40 GBytes hard disk. The operating system was Linux Release 7.1. 5.1 Data Sets We conducted experiments with two data sets: Data set 1 (the first and second human chromosomes) that was provided by NCBI (National Center for Biotech-nology Information) on the website [13], and Data set 2 that was created by changing Data set 1. The descriptions of the data sets are as follows. Data set 1. The sizes of the first and second human chromosomes are about Data set 2. Data set 2 is created by removing N in Data set 1. So, the alphabet 5.2 Building CQ-Tree We built 5 number of CQ-trees expressed in arrays with varying the q-gram length from 6 to 10. Table 2 shows the occupied spaces of the CQ-trees when the node size is 4 bytes. The building times of the CQ-trees that we generated are shown in Table 3. The building time of a CQ-tree is in O ( q  X  N ), where N is fixed in our experiments, hence the building times were roughly linear to q . 5.3 Count Estimation For looking into the accuracy of a CQ-tree, we randomly generated 1000 number of length-11 queries, and then measured the error rate Table 4 shows the experimental results.
 In the recent years, the problem of estimating substring selectivity has been focused on with the popularity of web, LDAP directories, XML, and so on. For the problem, a CS-tree has been usually used as the meta data that keeps statistical information. However, the CS-tree has two drawbacks: One is that some counts in the CS-tree may be incorrect, which results from occasional prunings. The other is that it is almost impossible to construct the CS-tree over long strings.
 in a database. The CQ-tree retains the exact counts of all substrings whose lengths are q or below q , and can be built in one scan of strings in the database. Moreover, in the case that the alphabet size is small like DNA sequences, the CQ-tree can be compactly expressed in an array without storing any labels or pointers by mapped into a full n -ary tree. As a result, more information can be maintained in the limited space.
 the number of occurrences of a query can reach to, together with the estimated count of the query pattern. The bounds are mathematically proved. We believe that the bounds presented are helpful to a user or a query optimizer.
