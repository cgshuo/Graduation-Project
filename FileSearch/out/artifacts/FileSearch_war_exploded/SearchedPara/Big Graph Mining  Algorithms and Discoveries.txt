 } How do we find patterns and anomalies in very large graphs with billions of nodes and edges? How to mine such big graphs efficiently? Big graphs are everywhere, ranging from social networks and mobile call networks to biological net-works and the World Wide Web. Mining big graphs leads to many interesting applications including cyber security, fraud detection, Web search, recommendation, and many more. In this paper we describe Pegasus , a big graph mining sys-tem built on top of MapReduce , a modern distributed data processing platform. We introduce GIM-V , an important primitive that Pegasus uses for its algorithms to analyze structures of large graphs. We also introduce HEigen large scale eigensolver which is also a part of Pegasus . Both GIM-V and HEigen are highly optimized, achieving linear scale up on the number of machines and edges, and pro-viding 9.2  X  and 76  X  faster performance than their naive counterparts, respectively.
 Using Pegasus , we analyze very large, real world graphs with billions of nodes and edges. Our findings include anoma-lous spikes in the connected component size distribution, the 7 degrees of separation in a Web graph, and anomalous adult advertisers in the who-follows-whom Twitter social network. Graphs are ubiquitous: computer networks [15], social net-works [14], mobile call networks [48], biological networks [6], citation networks [18], and the World Wide Web [9], to name a few. Spurred by the lower cost of disk storage, the suc-cess of social networking sites (e.g. Facebook, Twitter, and Google+) and Web 2.0 applications, and the high availabil-ity of data sources, graph data are being generated at an unparalleled rate. They are now measured in terabytes and heading toward petabytes, with more than billions of nodes and edges. For example, Facebook loads 60 terabytes of new data every day [44]; Yahoo had a 1.4 billion nodes Web graphs at 2002 [26]; Microsoft had 1.15 billion query-URL pairs at 2009 [33]; and Google processes 20 petabytes per day [11]. Mining such big graphs helps us find patterns and anomalies which lead to many interesting applications in-cluding fraud detection, cyber security, social network anal-ysis, etc.
 Traditional graph algorithms assume the input graph fits in the memory or disks of a single machine. However, the recent growth of the sizes in graphs break this assump-tion. Since single machine algorithms are not tractable for handling big graphs, we naturally turn to distributed algo-rithms. Among many candidates, we use Hadoop , the open source version of MapReduce , for its scalability, fault tol-erance, and ease of accessibility. On top of Hadoop built the Pegasus graph mining software, available as an open source in http://www.cs.cmu.edu/ ~ pegasus , which includes various graph mining algorithms including PageR-ank [39], Random Walk with Restart (RWR) [40], diame-ter/radius estimation [27], connected components [21], and eigensolver [22].
 This paper has two focuses. The first is the design of scal-able graph mining algorithms in MapReduce . We will see several useful techniques including approximation to make linear algorithms (Section 3.1), compression and clustering to decrease the amount of disk accesses (Section 3.2), and handling skewed data distribution (Section 4.2). The second is the discoveries of patterns and anomalies from real world graphs, using Pegasus . We present results from several big graphs including the Twitter social network and the Web graph snapshot at 2002 from Yahoo!.
 The rest of the paper is organized as follows. Section 2 describes the related works. In Section 3 we describe the algorithm for structure analysis, and in Section 4 we de-scribe the algorithm for spectral analysis of large graphs. In Section 5 we present the discoveries in real world, large scale graphs. After discussing future research directions in Section 6, we conclude in Section 7. In this section, we review related works on MapReduce and distributed big graph mining. MapReduce is a programming framework [11] for process-ing massive amount of data in a distributed fashion. MapRe-duce provides users a simple interface for programming dis-tributed algorithm, and it handles all the details of data dis-tribution, replication, fault tolerance, and load balancing. A typical MapReduce job consists of three stages: map, shuf-fle, and reduce. At the map stage, the raw data is read and processed to output (key, value) pairs. At the shuffle stage, the output of the map stage is sent to reducers via network so that the pairs with the same key are grouped together. At the reduce stage, the (key, value) pairs with the same key are processed to output another (key, value) pair. An itera-tive MapReduce program runs several MapReduce jobs, by feeding the output of the current job as the input of the next job.
 Hadoop [1] is the open source implementation of MapRe-duce . Hadoop uses the Hadoop Distributed File System (HDFS) for its file system. There are several packages that runs on top of Hadoop , including PIG [38], a high level language for Hadoop , and HBASE [2], a column-oriented data storage on top of Hadoop . Due to the simplicity, scal-ability, and fault tolerance, big graph mining using Hadoop attracted significant attentions in research community [41; 3; 23; 17]. There are several works on distributed big graph mining which can be grouped into two: (1) one not based on MapRe-duce / Hadoop , and (2) the other on top of it.
 The works not based on MapReduce / Hadoop include GraphLab, Pregel, and Trinity. GraphLab [34] provides a framework for parallel machine learning and data mining, in a shared mem-ory setting. Recently, they provide the distributed GraphLab [35] for shared nothing machines. Pregel [36] is a system for large scale graph processing where vertices exchange mes-sages and change their states in memory. Trinity [43] is a memory-based distributed database and computation plat-form. In general, those systems do not match the MapRe-duce / Hadoop  X  X  high degree of fault tolerance capabilities including 3-way replication and speculative execution. On the MapReduce / Hadoop side, Apache Mahout [3], a scalable machine learning library on Hadoop , provides a different set of operations compared to Pegasus . How can we analyze many structural properties (e.g. PageR-ank, connected component, diameter, radius, etc.) of big graphs efficiently with a simple and general primitive? In this section, we describe algorithms for mining the structure of big graphs. We first introduce GIM-V , a general prim-itive for big graph mining, and describe efficient algorithm in
MapReduce . How can we unify many graph mining algorithms, includ-ing connected components, diameter, PageRank, and node proximities? We introduce G eneralized I terative M atrix-V ector multiplication ( GIM-V ) to answer the question. The main intuition of GIM-V is that many graph mining algorithms can be formulated by iterative message exchanges with adja-cent nodes. We observe that the message exchange is equiv-alent to performing matrix vector multiplication on the ad-jacency matrix of the graph and the vector containing cur-rent states of nodes. Based on the intuition and the ob-servation, our approach is to formulate many graph mining algorithms using a generalized form of matrix vector multi-plication where the three internal operations (multiply, sum, and assign) are redefined based on the specific instantiation of the matrix vector multiplication.
 Consider multiplying an n by n matrix M and a length n -vector v to produce an output vector v 0 . The i th element v of the vector v 0 is determined by where M i,j is the (i,j)th element of M . The above equation contains the following three internal operations: (1) multiply M i,j and v j , (2) sum n multiplication results, and (3) write the new result to v 0 i . GIM-V generalizes the three operations as follows: 1. combine2 ( M i,j ,v j ) : combine M i,j and v j . 2. combineAll ( x 1 ,...,x n ) : combine all the results from 3. assign ( v i ,v new ) : decide how to update v i with v In terms of the generalized operation, the v 0 i is expressed by GIM-V is run iteratively; i.e., the output of the current iter-ation is fed as the input of the next iteration. The iteration is continued until algorithm-specific termination condition is satisfied. In the following we will see how the new definitions of the three operations leads to many different algorithms. The termination conditions for each algorithm are also de-scribed. PageRank is a well-known algorithm for ranking Web pages [39]. Given a graph, PageRank outputs a ranking vector which denotes the stationary probability that a random surfer would end up on specific nodes. The PageRank vector p satisfies the eigenvector equation p = ( cE T + (1  X  c ) U ) p where E is the row-normalized adjacency matrix of the graph, c is a damping factor typically set to 0.85, and U is a matrix all of whose elements are 1 n where n is the number of nodes in the graph. PageRank is a special case of GIM-V . Let M = E T Then the next PageRank vector p next is computed from the current vector p cur by p next = M  X  p cur where the three operations are defined as follows: 1. combine2 ( M i,j ,v j ) = c  X  M i,j  X  v j . 3. assign ( v i ,v new ) = v new .
 The termination condition is when the PageRank vector does not change up to a threshold. Random Walk with Restart (RWR) [40; 45] is used to com-pute the personalized PageRank. The RWR vector p k , spec-ifying the proximities of nodes from the query node k , satis-fies the eigenvector equation p k = cE T p k + (1  X  c ) e c and E are defined as in Section 3.1.1 , and e k is an n -vector whose k th element is 1, and all other elements are 0. As in Section 3.1.1 , let M = E T . Then the next RWR vector p next k is computed from the current vector p p k = M  X  p cur k where the three operations are defined as follows (  X  ik is the Kronecker delta :  X  ik = 1 if i = k . and 0 otherwise): 1. combine2 ( m i,j ,v j ) = c  X  M i,j  X  v j .
 2. combineAll ( x 1 ,...,x n ) = (1  X  c )  X  ik + P n j =1 3. assign ( v i ,v new ) = v new .
 As in the case of PageRank, the termination condition is when the RWR vector does not change up to a threshold. Computing the weakly connected component is also a spe-cial case of GIM-V . The main idea is to propagate the min-imum node id in each component until all the nodes in each component see the message with the minimum node id in the component. Let M be the adjacency matrix of a graph. The next connected component vector p next is computed from the current vector p cur by p next = M  X  p cur where the three operations are defined as follows: 1. combine2 ( M i,j ,v j ) = M i,j  X  v j . 2. combineAll ( x 1 ,...,x n ) = MIN { x j | j = 1 ..n } . 3. assign ( v i ,v new ) = MIN( v i ,v new ). where MIN () is a function that returns the minimum of its arguments. The iteration is continued until the connected component vector does not change. The maximum num-ber of iteration is bound by the graph X  X  diameter which is surprisingly small in many real world graphs [5; 31; 27]. The radius of a node v is the maximum of the shortest dis-tances to other nodes in a graph. The diameter of a graph is the maximum radius over all the nodes. Exactly comput-ing the diameter and the radius is prohibitively expensive ( O ( n 2 )); however, fortunately we can use GIM-V for ap-proximating the diameter and radius in a time linear to the number of edges.
 The main idea is to use a small, probabilistic bitstring to store the information on the neighborhood of each node [27]. Let b h i denote the probabilistic bitstring containing the neigh-borhood information reachable from node i within h hops, and M be the adjacency matrix of a graph. The ( h + 1) hop neighborhood b h +1 i from node i is computed from the h hop neighborhood b h i by b h +1 i = M  X  b h i where the three operations are defined as follows: 1. combine2 ( M i,j ,v j ) = M i,j  X  v j . 2. combineAll ( x 1 ,...,x n ) = BITWISE-OR { x j | j = 1 ..n } . 3. assign ( v i ,v new ) = BITWISE-OR( v i ,v new ). The termination condition is when the bitstrings of all nodes do not change. The next question is, how to design fast algorithms for GIM-V in MapReduce ? Our main idea is to cluster the nonzero elements of the adjacency matrix, encode it using blocks, and compress it to decrease the amount of data traf-fic in MapReduce computation. We describe our proposed method in a progressive way; i.e., we first describe the naive implementation of GIM-V in MapReduce , and propose several ideas to make it more efficient. The input data is the matrix and the vector stored in disks. We assume that each of the matrix and the vector is too large to fit in the memory of a single machine. Each non-zero element of the matrix is stored in one line as a tuple (source, destination, value); similarly, each non-zero element of the vector is stored in one line as a tuple (row, value). The naive algorithm of GIM-V on MapReduce comprises two stages. In the first stage, the matrix elements and the vector elements are joined to make partial results, where the column id of the matrix elements and the row id (index) of the vector elements are used as keys. In the second stage, the partial results are aggregated to make an output vector. Note that this algorithm takes the original matrix as it is; we will see reorganizing and compressing the matrix greatly helps for improving the efficiency in the following. The first idea to improve the performance of GIM-V RAW is to perform block multiplication instead of element wise multiplication. We first group matrix elements into w by w square blocks; similarly, vector elements are grouped into length w vectors. It can be easily verified that the origi-nal matrix vector multiplication can be expressed by block-based multiplication [26]. This GIM-V NNB method, if combined with the compression idea described in the next section, decrease the size of the data significantly. The advantage of the block encoding introduced in GIM-V NNB is that it opens the possibility to exploit the local-ity of nonzero elements inside blocks. GIM-V NCB com-presses the nonzero elements of each block using standard compression algorithms like Gzip or Elias- X  , and store the compressed data into disks. The compressed block is read from disks, and uncompressed in run-time. Despite the ad-ditional time for the uncompression, GIM-V NCB help de-crease the overall running time since the disk space decreases significantly, and disk access time dominates the running time. The numerical performance gain is described in the next section. GIM-V NCB can be further improved by clustering nonzero elements of the matrix. The average bits required to encode an element in the matrix decrease as the density of each block increases. The implication of the fact is that few dense blocks require smaller disk space than many sparse blocks. To get few dense blocks, we can cluster the nonzero elements of the adjacency matrix. GIM-V CCB uses graph clustering algorithm to achieve this. There are many graph cluster-ing algorithms available to be used as a plug-in for GIM-V CCB, including METIS [28], co-clustering [41], Shingle or-dering [10], and SlashBurn [20].
 The effect of applying these three techniques is significant. In our experiment [25], GIM-V CCB achieved 43  X  smaller storage, as well as 9.2  X  faster running time for matrix-vector multiplication compared to GIM-V RAW. In addi-tion, GIM-V CCB scales linearly on the number of machines and edges, thanks to the matrix-vector formulation. How can we perform the spectral analysis (e.g. Singular Value Decomposition (SVD), triangles, etc.) on very large graphs? In this section we describe HEigen , our proposed distributed algorithm for spectral graph analysis. Spectral analysis on graphs using top k eigenvalues and eigenvectors is a crucial technique with many applications including SVD, dimensionality reduction, triangle counting [47], and community detection [42].
 Despite the importance of the task, existing eigensolvers do not scale well, handling up to millions of nodes and edges at most. To address the problem we developed HEigen , a dis-tributed eigensolver on MapReduce for very large graphs with more than billions of nodes and edges. There are sev-eral candidates of the serial eigensolver algorithms that we considered for HEigen ; we list them and discuss their ad-vantages and disadvantages. An improvement of the basic Lanczos algorithm is to selec-tively choose previous output vectors to be orthogonalized against the new basis vector; this Lanczos-SO (Selective Or-thogonalization) [12] requires much fewer orthogonalizations than the basic Lanczos, and thus much more efficient than the basic Lanczos. For the reason HEigen uses Lanczos-SO as the basis for the eigensolver. How can we design a fast algorithm for HEigen in MapRe-duce ? There are two main operations in HEigen : matrix-vector multiplication for main iterations, and skewed matrix-matrix multiplication for post-processing the results of main iterations to compute the eigenvectors (see [22] for details). The matrix-vector multiplication is performed efficiently in HEigen using the block encoding idea as described in Sec-tion 3.2. The challenging part is the skewed matrix-matrix multiplication where the first matrix A n  X  m is much larger than the second matrix B m  X  k , where n m &gt; k . A naive algorithm of multiplying the two matrices is to use two stages of MapReduce jobs. In the first stage, partial multiplication results are generated using the column ids of the first matrix and the row ids of the second matrix as keys. That is, for each column i of A , the cross product from the elements of A having i as column id, and the elements of B having i as row id, is computed. In the second stage, the partial results from the first stage are summed together. The problem of this naive algorithm is that it requires many disk I/Os. Let | X | denote the number of nonzero elements in a matrix or a vector. For example, | A | is the number of nonzero elements of the matrix A , | A : ,i | is the number of nonzero elements in the i th column of A , and | B the number of nonzero elements in the i th row of B . Let T = P m i =1 | A : ,i | X | B i, : | be the number of intermediate ele-ments to be written to and read from disk after the first stage. Then, the naive algorithm requires the following disk accesses and network transfer: HEigen uses the distributed cache based algorithm where the second, small matrix is broadcasted all the mappers. Then, mappers themselves join the first matrix with the small matrix, and the intermediate results are aggregated in reducers, finishing the task using one MapReduce job. This CBMM (Cache-Based Matrix-Matrix multiplication) algorithm has smaller disk and network costs: The effect of this smaller disk accesses and network transfers is that the running time of CBMM is about 76  X  smaller than the naive algorithm [22]. As in the GIM-V , HEigen also enjoys linear running time on the number of machines and edges, since the major operation is the matrix-vector multiplication. In this section, we present interesting discoveries on large, real world graphs, that we found using Pegasus . We mainly focus on the following two data. The experiments were performed in Yahoo! X  X  M45 Hadoop cluster (now OCC-Y [4]), one of the largest Hadoop clus-ters available to academia with 480 machines, 1.5 petabyte storage and 3.5 Terabyte memory in total.
 The discoveries include the patterns and anomalies in con-nected components, diameter/radius, near cliques, and tri-angles. What are the patterns and anomalies in the connected com-ponents of real world graphs? We report interesting discov-eries in the connected component of real world graphs. thereby creating cliques containing triangles.
 Power Laws in Component Sizes. In real world graphs, the giant connected component (GCC) contains the major-ity of the nodes. However, most graphs also contain many small disconnected components which are separated from the GCC. Moreover, the sizes of these small disconnected components follow the power law [37], as we see in the red line in Figure 1 (a), implying that  X  X ich-gets-richer X  phe-nomenon [13] happens in the connected component forma-tion process. Another interesting observation is that the slope of the fitting line of the small disconnected compo-nents sizes is constant over time [26].
 Anomalous Connected Components. The power law pattern in connected component sizes can be used to de-tect anomalous connected components which deviate signif-icantly from the pattern. The size distribution of connected components in YahooWeb graph, shown in Figure 1 (a), con-tains two outstanding spikes (circled in red) deviating sig-nificantly from the patterns in neighbors. These spikes come from anomalous activities. In the first spike (component size 300), more than half of the components are isomorphic, and they were made from a domain selling company where each component represents a domain in sale. The spike happened because the domain selling company replicated sites using a template; this process of creating web pages is different from the typical evolution process of the Web (e.g. prefer-ential attachment [7]). In the second spike (component size 1101), more than 80 % of the components are adult sites disconnected from the GCC, and they are generated from a template, as in the first spike. As we see in both of the spikes, the distribution plot of connected component sizes reveals interesting communities with special purposes which are disconnected from the rest of the Internet. What do real world graphs look like? We present discoveries on the diameter and the radius in real world graphs. Small Web. How close are the two randomly sampled nodes in a graph? The study of diameter in real networks have attracted many attentions from researchers in diverse backgrounds including social science [31], physics [5], and computer science [31]. With Pegasus , we analyzed the di-ameter of real world graphs. It turns out many real world graphs have small diameter (e.g. YahooWeb X  X  diameter is 7.62) [27].
 Structure of Large Networks. What is the structure of large, real world graphs? What do they look like? The analysis of the radius, combined with the analysis of the connected components, reveals that many real world graphs are composed of three areas [27]. The first area is the  X  X ore X  which contains nodes belonging to the giant connected com-ponent (GCC) of the graph, and having small radii. Ma-jority of high degree nodes belong to the  X  X ore X  area. The second area is the  X  X hiskers X  which contains nodes still be-longing to GCC, but have large radii and loosely connected to the  X  X ore X . The third area is the  X  X utsiders X  which contains nodes belonging to non-GCC. Nodes in  X  X utsiders X  typically have small radii, since the sizes of disconnected components are small in many real world graphs.
 Multi Modality of Web Graph. The three areas  X  X ore X ,  X  X hiskers X , and  X  X utsiders X  create bi-modal structures [27] in the radius plot (distribution plot of radius) of many real world graphs. That is, it creates a mode in the beginning (radius 1), and another mode right after the dip near the  X  X ore X  area. However, the radius plot of the YahooWeb graph shows an interesting pattern: it has a multi-modal structure, creating many modes, as shown in Figure 1 (b). Our con-jecture is that they possibly come from the characteristic of the Web graph which contains several communities (e.g. English-speaking community, Spanish-speaking community, etc.) which are loosely connected to each other.
 Expansion and Contraction. How do graphs evolve over time? We studied the radius plots over time to answer the question. Contrary to the intuition, the radius plot does not change in a monotonic way. In the early stage of the evolu-tion, the radius plot expands to the right; however, after a point we call the  X  X elling point X , the radius plot shrinks to the left [27]. This  X  X xpansion-contraction X  pattern happens because many disconnected components in the early stage are joined together to form the strong  X  X ore X  after the gelling point. What are the patterns and anomalies from the spectral anal-ysis of real world graphs? We present interesting discoveries on the tightly connected communities and anomalous nodes. Near-Clique Detection. The spectral analysis of graphs can reveal near cliques, or tightly connected nodes. For this task we analyze the eigenspoke [42] pattern in real world graphs. Eigenspoke is a set of clear lines in the EE-plot which is the scatter plot of the two eigenvectors of the ad-jacency matrix of the graph. Many real world graphs have clear eigenspokes; moreover, nodes having high scores in the EE-plot often forms near-cliques or bipartite cores [22]. Anomalous Triangles vs. Degree Ratio. Figure 1 (c) shows the degree and the number of participating triangles of accounts in the Twitter  X  X ho follows whom X  graph at year 2009 [22]. The triangles are computed from eigenvalues and eigenvectors, using the close connection between them [47]. In the figure, some U.S. politicians (Sarah Palin, John Mc-Cain, and Barack Obama) have mildly connected followers compared to their degrees, while adult accounts have ex-tremely well connected followers, generating a lot of trian-gles. The reason is that an adult content provider often creates many Twitter accounts, and make them follow each other so that they look more popular. For the reason they belong to cliques, and they generate many triangles which are spotted in the triangle vs. degree plot. This analysis can be used to spot and eliminate harmful accounts such as those of adult advertisers and spammers, from social networks. Forecasting the future, the ever-growing sizes of graphs and diverse application needs will open many new opportunities for interesting researches in big graph mining. We list five of the important research directions. 1. Big Graph Analysis Platform. The first area is 2. Algorithm Redesign. The second area is to trans-3. Graph Compression. An effective way to tackle the 4. Time Evolving Graphs. Many real world graphs 5. Visualization and Understanding of Graphs. A In this paper we describe Pegasus , an open source graph mining library available in http://www.cs.cmu.edu/ ~ pegasus , for finding patterns and anomalies in massive, real-world graphs. Pegasus provides algorithms for connected compo-nent, diameter/radius, PageRank, RWR, and spectral anal-ysis. At the heart of Pegasus , there is a general primitive called GIM-V (Generalized iterative Matrix-Vector multi-plication) which includes many graph mining algorithms as special cases. GIM-V is highly optimized, achieving 43  X  smaller disk space and 9.2  X  faster running time.
 Using Pegasus , we analyze large, real world graphs. Our findings include (a) anomalous spikes in the connected com-ponent size distribution, (b) the 7-degrees of separation in a snapshot of the Web graph, and (c) anomalous advertisers in the Twitter who-follows-whom graph.
 Overall, many interesting research challenges are waiting ahead of us, and we just started to address them.
 Funding was provided by the U.S. ARO and DARPA un-der Contract Number W911NF-11-C-0088, by DTRA un-der contract No. HDTRA1-10-1-0120, and by ARL under Cooperative Agreement Number W911NF-09-2-0053. The views and conclusions are those of the authors and should not be interpreted as representing the official policies, of the U.S. Government, or other funding parties, and no official endorsement should be inferred. The U.S. Government is authorized to reproduce and distribute reprints for Govern-ment purposes notwithstanding any copyright notation here on. [1] Hadoop information. http://hadoop.apache.org/. [2] Hbase information. http://hbase.apache.org/. [3] Mahout information. http://lucene.apache.org/mahout/. [4] The open cloud consortium. [5] R. Albert, H. Jeong, and A.-L. Barabasi. Diameter of [6] D. A. Bader and K. Madduri. A graph-theoretic analy-[7] A.-L. Barabasi and R. Albert. Emergence of scaling in [8] J. K. Bradley, A. Kyrola, D. Bickson, and C. Guestrin. [9] A. Broder, R. Kumar, F. Maghoul, P. Raghavan, S. Ra-[10] F. Chierichetti, R. Kumar, S. Lattanzi, M. Mitzen-[11] J. Dean and S. Ghemawat. Mapreduce: simplified [12] J. W. Demmel. Applied numerical linear algebra. [13] D. A. Easley and J. M. Kleinberg. Networks, Crowds, [14] N. B. Ellison, C. Steinfield, and C. Lampe. The benefits [15] M. Faloutsos, P. Faloutsos, and C. Faloutsos. On power-[16] R. Gemulla, E. Nijkamp, P. Haas, and Y. Sisma-[17] A. Ghoting, R. Krishnamurthy, E. P. D. Pednault, [18] C. L. Giles, K. D. Bollacker, and S. Lawrence. Citeseer: [19] G. H. Golub and C. F. Van Loan. Matrix computations. [20] U. Kang and C. Faloutsos. Beyond  X  X aveman commu-[21] U. Kang, M. McGlohon, L. Akoglu, and C. Faloutsos. [22] U. Kang, B. Meeder, and C. Faloutsos. Spectral analy-[23] U. Kang, S. Papadimitriou, J. Sun, and H. Tong. Cen-[24] U. Kang, E. E. Papalexakis, A. Harpale, and C. Falout-[25] U. Kang, H. Tong, J. Sun, C.-Y. Lin, and C. Faloutsos. [26] U. Kang, C. Tsourakakis, and C. Faloutsos. Pegasus: A [27] U. Kang, C. E. Tsourakakis, A. P. Appel, C. Faloutsos, [28] G. Karypis and V. Kumar. Multilevel -way hypergraph [29] T. G. Kolda and J. Sun. Scalable tensor decompositions [30] C. Lanczos. An iteration method for the solution of [31] J. Leskovec, J. M. Kleinberg, and C. Faloutsos. Graphs [32] J. Leskovec, K. J. Lang, A. Dasgupta, and M. W. Ma-[33] C. Liu, F. Guo, and C. Faloutsos. Bbm: bayesian [34] Y. Low, J. Gonzalez, A. Kyrola, D. Bickson, [35] Y. Low, J. Gonzalez, A. Kyrola, D. Bickson, [36] G. Malewicz, M. H. Austern, A. J. C. Bik, J. C. Dehn-[37] M. E. J. Newman. Power laws, pareto distributions and [38] C. Olston, B. Reed, U. Srivastava, R. Kumar, and [39] L. Page, S. Brin, R. Motwani, and T. Winograd. The [40] J.-Y. Pan, H.-J. Yang, C. Faloutsos, and P. Duygulu. [41] S. Papadimitriou and J. Sun. Disco: Distributed co-[42] B. A. Prakash, M. Seshadri, A. Sridharan, S. Machi-[43] B. Shao, H. Wang, and Y. Li. The trinity graph engine. [44] A. Thusoo, Z. Shao, S. Anthony, D. Borthakur, N. Jain, [45] H. Tong, C. Faloutsos, and J.-Y. Pan. Fast random walk [46] L. N. Trefethen and D. Bau III. Numerical linear alge-[47] C. Tsourakakis. Fast counting of triangles in large real [48] D. Wang, D. Pedreschi, C. Song, F. Giannotti, and A.-[49] M. Zaharia, N. M. M. Chowdhury, M. Franklin,
