 1. Introduction
In many applications processing strings, a trie search is useful because the trie enables fast retrieval and longest prefix matching with a small dictionary ( Fredkin, 1960 ). For example, the trie is used in information form. The retrieval speed of the matrix form is very fast but wastes large space because the array becomes resents the trie more compact than the matrix form but the retrieval speed of the list form is not so fast.
A double-array ( Aoe, 1989 ) uses a one-dimensional array to represent trie nodes. The double-array has both advantages of the matrix and list forms. The drawbacks of the original double-array are that an insertion takes long time and a deletion produces empty elements. To resolve these drawbacks, Morita et al. presented a fast insertion method and Oono et al. presented an efficient elimination method of empty elements ( Morita,
Fuketa, Yamakawa, &amp; Aoe, 2001; Oono, Atlam, Fuketa, Morita, &amp; Aoe, 2003 ). Owing to these methods, the double-array has become applicable to fields which require dynamic updates.

However, a compact dictionary could be more important than dynamic updates on the platform that has poor resources, like a mobile device. This paper presents a compact structure for a static double-array. In our new structure, each node of the trie keeps an arc label instead of parent X  X  index. This modification reduces space usage for each node because arc labels require less space than indices. In addition, the new structure removes some leaf nodes from the trie and unifies common suffixes of the key set. Experimental results for
English keys show that the new structure reduces space usage for the double-array up to 40% and enables fast retrieval as well as the original one.
 Section 2 describes the outline of the double-array, its structure, retrieval algorithm, and space usage. In
Section 3 ,an element compaction which reduces space usage for each node is proposed. Section 4 proposes a trie compaction which reduces the number of trie nodes and unifies common suffixes. Experimental results are shown in Section 5 , and the proposed method is evaluated. Section 6 concludes this paper and indicates the future study. 2. A double-array 2.1. A structure of the double-array
A double-array is generally applied to a reduced trie ( Aoe, Morimoto, &amp; Sato, 1992; Dundas, 1991 ). The reduced trie keeps just nodes necessary to select an unique key in searches. In other words, only nodes corre-to the number of nodes which correspond to suffixes and an element (label) of strings is smaller than a node. reduced trie for key set K . A special endmarker symbol  X # X  indicates the end of a string. Each member of key stores suffixes as strings. Leaf nodes of the reduced trie are linked to suffixes by their own pointers.
A double-array uses two one-dimensional arrays, named BC and TAIL, to represent a reduced trie. The array BC represents trie nodes and the array TAIL stores suffix strings. BC X  X  element consists of two integers, called BASE and CHECK. Except empty elements, every element corresponds to a node. The member BASE distinguish leaf nodes from others, BASE includes a flag called LEAF. The member CHECK normally stores the index of the parent node but CHECK of the empty element stores an invalid index.

The n th element of BC is indicated by BC[ n ] which also means the node numbered n (node n ). The members of BC[ n ] are indicated by BC[ n ].BASE and BC[ n ].CHECK. As for the flag LEAF, BC[ n ].LEAF shows whether node n is a leaf node or not. TRUE means that node n is a leaf node, FALSE means that node n is not a leaf node. TAIL[ p ] indicates the character code of the p th label in TAIL. The following Function Goto checks destination, else Function Goto returns 0. [ Function Goto ( src,c )] Line (g-1) calculates the destination index dest by the sum of src  X  X  BASE and the character code of label c . returns dest 6  X  0, else line (g-3) returns 0.
 shows the arc from node src to node dest with label c on the double-array. 2.2. A retrieval algorithm by the double-array
A retrieval algorithm by the double-array consists of two steps. The first step picks out a key candidate by searching BC for a leaf node which corresponds to the prefix of an input string. The second step checks that searches the double-array for an input string str and returns TRUE or FALSE. In the following description, the root node is numbered root ,and str [ n ] means the character code of str  X  X  n th label. [ Function Retrieval ( str )] the result TRUE or FALSE. Line (r-5) gets the start position pos of the suffix on TAIL and line (r-6) compares str  X  X  suffix with TAIL X  X  suffix. If the suffixes are the same, Function Retrieval will return TRUE.
Example 2. Fig. 4 shows a double-array for key set K . The array labeled BASE and CHECK indicates BC, and the array labeled CODE indicates character codes. An underline of BASE indicates LEAF = TRUE, so that underlined BASE means the link to TAIL and another BASE means the offset to child nodes.
Goto(1, X  b  X ), BC[1].BASE +  X  b  X  = 1 + 1 = 2 and BC[2]CHECK] = 1. Similarly, the arc from node 2 with label str [2] =  X  e  X  is checked by BC[2].BASE +  X  e  X  = 3 + 3 = 6 and BC[6].CHECK = 2. Here BC[6].LEAF = TRUE TAIL[BC[6].BASE] = TAIL[6]. In this case, str  X  X  suffix is equal to TAIL X  X  suffix and str gets found. Finally,
Function Retrieval returns TRUE. ( End ) 2.3. Space usage for the double-array
A double-array consists of BC, TAIL, and a code table. Space usage for BC and TAIL depends on the number of nodes and the total length of suffix strings, respectively. On the other hand, space usage for the fore, space usage for the code table could be ignored for a large key set. Where the lengths of BC and TAIL are indicated by bclen and tlen respectively, space usage for the double-array is calculated as follows: The coefficient of bclen is the size of BC X  X  element X  X he double-array uses 4 bytes integers for BASE and CHECK, i.e. 8 bytes = 4 bytes  X  2 (BASE and CHECK).
 Eq. (1) shows that reductions in the coefficient, bclen , and tlen are valid for the double-array compaction.
This paper presents two compaction methods to reduce these parameters. One compaction method named an element compaction reduces the size of BC X  X  element. Another compaction method is named a trie compaction .
The trie compaction modifies the trie structure to reduce the lengths of BC and TAIL. The modification removes rear nodes having the light worth to pick out the key candidate from the reduced trie. In addition, the modification unifies common suffixes and links some leaf nodes to the same suffix. The modified trie structure which keeps fewer nodes is called a descended trie and unified common suffixes are called unified suffixes . 3. An element compaction
In the double-array, CHECK stores the index of the parent node. The parent index is necessary for dynamic updates, such as insertion and deletion. If dynamic updates are not required, CHECK is used only for checking the arc in Function Goto . Therefore, a static double-array can store the arc label into CHECK on condition that each and every node has an unique offset as BASE. The unique offsets are for the reason that more than one arc must not have the same destination. To distinguish two kinds of CHECK, the following description uses LCHECK to indicate CHECK with the arc label.

The retrieval algorithm is a little modified by the element compaction. The difference is only that the mod-ified algorithm calls the following Function LGoto instead of Function Goto . Function LGoto uses LCHECK to check whether the arc from node src with label c exists or not. [ Function LGoto ( src,c )]
Compared with Function Goto , line (l X 2) uses LCHECK different from line (g-2) which uses CHECK. Func-tion LGoto is as fast as Function Goto because the difference does not affect time complexity.
An element compaction uses LCHECK instead of CHECK and allocates only 1 byte to each LCHECK because any keys are represented by byte strings. In addition, the element compaction allocates 3 bytes to each
BASE because BC X  X  elements should have 4 bytes alignment. The element compaction reduces the size of BC X  X  element from 8 bytes to 4 bytes but gives two restrictions on BASE and LCHECK.

An empty element e has such LCHECK as each node n of the trie does not satisfy BC[ n ].LEAF = FALSE and BC[ n ].BASE + BC[ e ].LCHECK = e .
 Except leaf nodes, every node has different BASE.

These restrictions prevent searches from following invalid arcs. The former restriction removes arcs to ghost nodes which correspond to empty elements. The latter restriction removes arcs to wrong nodes which have another path to the root node.

Example 3. Fig. 5 shows a static double-array using the element compaction for key set K . Compared with the original double-array of Fig. 4 , BC X  X  element has LCHECK instead of CHECK and the double-array of Fig. 5 gives different indices to some nodes. Fig. 5 has two empty elements while Fig. 4 has no empty element, so that compaction. However, the new static double-array allocates only half space to each element of BC, compared with the original double-array. As a result of the element compaction, space usage for the double-array is reduced from 8 bytes (BASE and CHECK)  X  7 (the length of BC) + 8 (the length of TAIL) = 64 bytes to 4 bytes (BASE and LCHECK)  X  9 + 8 = 44 bytes. ( End ) 4. A trie compaction 4.1. Outline of the trie compaction
A double-array using a trie compaction consists of a descended trie and unified suffixes . The descended trie keeps fewer nodes than the reduced trie. Common suffixes are unified and only unique suffixes are kept as uni-fied suffixes. 4.2. A descended trie
The descended trie removes leaf nodes following 2-way arcs from the reduced trie and turns the source of 2-way arcs into the new leaf node. After that, leaf nodes having no sibling are removed recursively. In the reduced trie, nodes removed in the descended trie have the light worth because these nodes are used in the selection of the correct key from two key candidates. Therefore, these nodes are not important to the retrieval speed and the removal does not degrade the retrieval speed so much.

A pair of suffixes corresponding to the new leaf node is divided into three parts and those parts are stored suffix except the common prefix (the first part). The third part consists of the two suffixes except the common prefix.

Example 4. Fig. 6 shows a descended trie for key set K . Leaf nodes corresponding to the keys  X  X  bad  X  X  and of the two suffixes  X  X  dg  X  X . ( End )
A double-array for the descended trie allocates 1 bit of leaf node X  X  BASE to a flag called SPLIT, which indi-cates the number of suffixes corresponding to that leaf node. SPLIT = TRUE indicates that the leaf node has two suffixes and SPLIT = FALSE indicates that the leaf node has only one suffix. BASE except SPLIT is named LINK and used for the link to suffixes. If node n is the leaf node, BC[ n ].SPLIT indicates SPLIT of from TAIL[BC[ n ].LINK].
 Function Retrieval is modified for the descended trie. Similar to Function Retrieval , a search by the new
Function MRetrieval starts at root and finds the leaf node corresponding to the prefix of str . The difference between Function Retrieval and Function MRetrieval is the action after finding the leaf node, Function Com-pare is called by Function MRetrieval to compare str  X  X  suffix with TAIL X  X  suffixes. [ Function MRetrieval ( str )]
Function MRetrieval uses Function LGoto instead of Function Goto in line (m-2). Except the difference of (m-5) compares the suffix of str with the suffixes on TAIL and returns the result TRUE or FALSE. In the following description of Function Compare , TAIL[ pos ].STR[0] and TAIL[ pos ].STR[1] indicate the first and second suffixes starting from TAIL[ pos ], respectively. [ Function Compare ( index,sfx )] with TAIL X  X  suffix. If the comparison of lines (c-3) or (c-4) succeeds, Function Compare returns TRUE. 4.3. Unified suffixes
A reduced trie generally has many common suffixes which should be unified for the reduction of space usage. Some methods to unify common suffixes, a DAWG (Directed Acyclic Word-Graph) ( Aho &amp; Corasick, suffixes. However, the application of the DAWG is limited to the fields which does not need to specify matched keys, such as a spelling correction and keyword filtering. The double-trie and two-trie require many nodes, and these methods can not make use of the descended trie.

Therefore, this paper adopts a simple new method to unify common suffixes. The method keeps only unique suffixes and links each leaf node to the start position of its suffix.

Example 5. Fig. 7 shows unified suffixes for key set K . Leaf nodes 4 and 5 have the same suffix  X  X  X  X , and leaf only one unique suffix  X  X  at  X  X  and all leaf nodes are linked to this suffix. ( End ) For unified suffixes, the internal structure of TAIL is modified but the retrieval algorithm is not modified. Example 6. Fig. 8 shows a double-array using the element and trie compactions for key set K . About BASE or LINK in Fig. 8 , an underlined value is LINK and another value is BASE. LINK with the symbol  X + X  means SPLIT = TRUE. TAIL[3] is shared by suffixes corresponding to leaf nodes 3, 4, and 6.

Table 1 shows the comparison of the original double-array ( Fig. 4 ) and the new double-array ( Fig. 8 ). The element compaction has reduced the size of each element from 8 bytes to 4 bytes. The descended trie has reduced the length of BC from 7 to 6, and unified suffixes has reduced the length of TAIL from 8 to 7. As a result, space usage for the double-array has been reduced from 64 bytes to 31 bytes. ( End ) Similarly, the arc from node 2 with label  X  a  X  is checked by BC[2].BASE +  X  a  X =3+0=3 and
BC[3].CHECK =  X  a  X . BC[3].LEAF = TRUE and BC[3].SPLIT = TRUE indicate that node 3 is a leaf node which has only one suffix. The suffix starting from TAIL[BC[1].LINK] = TAIL[1] is  X  X  at  X  X , and it is equal to str  X  X  suffix. Therefore, the search succeeds and returns TRUE. ( End ) 5. Evaluation
The original and the new double-arrays were implemented with C language. Experiments for space usage and retrieval speed were executed on Windows 2000 (CPU:Mobile Pentium3 800 MHz). Experiments used key sets which consist of English keys extracted from the dictionary of WordNet ( WordNet 2.1, 2005 ). Table 2 shows information about the key sets.
 Tables 3 and 4 show information about the original and the new double-arrays for the key sets of Table 2 .
Space usage is calculated by Eq. (1) but the new double-array allocates 4 bytes to each element of BC. In other iments for retrieval speed searched the double-array for all registered keys in random order.
From Tables 3 and 4 , it turns out that the element compaction and the trie compaction are valid to reduce space usage for the double-array. The element compaction reduces the size of each element from 8 bytes to 4 bytes. The trie compaction removes about 1/3 elements from BC and 30 X 50% from TAIL. As a result, the compaction methods reduce space usage for the double-array up to 40%.

From details of Table 4 , the compaction methods prevent TAIL from being expanded by key increase. For
However, retrieval speed is degraded by key increase, and the new double-array holds the decline of retrieval speed lower than the original double-array. As for the key sets which consist of over 40000 keys, retrieval speed of the new double-array is faster than the original X  X .

Experimental results show that the compaction methods are useful to make the double-array compact. The methods keep retrieval speed of the double-array over 80%. In addition, the methods are more valid for large key sets. 6. Conclusion
This paper has presented two compaction methods, an element compaction and a trie compaction, for a static double-array. The element compaction reduces the size of each element. The trie compaction reduces the number of nodes (a descended trie) and the length of the array keeping suffixes (unified suffixes). From
In addition, the compaction methods little degrade the retrieval speed of the double-array. The new double-array is valid for the static dictionary of various applications processing strings.

The compaction methods remove extra space from a dynamic double-array. The new double-array is not suitable for dynamic updates, but the techniques used in the compaction methods might be applicable to the dynamic double-array. Therefore, the future study will focus on the compact dynamic double-array. References
