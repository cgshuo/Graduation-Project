 Counting the number of triangles in a graph is a beautiful algo-rithmic problem which has gained importance over the last years due to its significant role in complex network analysis. Metrics frequently computed such as the clustering coefficient and the tran-sitivity ratio involve the execution of a triangle counting algorithm. Furthermore, several interesting graph mining applications rely on computing the number of triangles in the graph of interest.
In this paper, we focus on the problem of counting triangles in a graph. We propose a practical method, out of which all trian-gle counting algorithms can potentially benefit. Using a straight-forward triangle counting algorithm as a black box, we performed 166 experiments on real-world networks and on synthetic datasets as well, where we show that our method works with high accuracy, typically more than 99% and gives significant speedups, resulting in even  X  130 times faster performance.
 Categories and Subject Descriptors: F.2.2 Analysis of Algorithms and Problem Complexity: Nonnumerical Algorithms and Problems General Terms: Algorithms; Experimentation.
 Keywords: Graphs, Triangles, Hadoop Abundant data nowadays are modeled as graphs: the World Wide Web, social networks (e.g. LinkedIn, Facebook, Flickr) , P2P net-works, co-authorship networks, biological networks, computer net-works and physical connections just to name a few. Nowadays, due to the recent technology explosion, graphs reaching the planetary scale are available to us for analysis [21]. Triangles play an im-portant role in complex network analysis. For example in social networks, triangles is a well studied subgraph. In particular, two prominent theories according to which triangles are generated in social networks are the homophily and the transitivity. According to the former, people tend to choose friends that are similar to them-selves, which is also known as  X  X irds of a feather flock together X  [22]. and according to the latter, people who have common friends tend to become friends themselves [31].
 The significance of the existence of triangles in networks moti-vates the definition of metrics that quantify the triangle density in a graph. Two such metrics are the clustering coefficient and the transitivity ratio [24].

Furthermore, it has been shown that triangles can play a signif-icant role in graph mining applications as well. Recently, in [6] it was shown that triangles can be used to detect spamming activ-ity. Eckman and Moses in [13] showed how triangles can be used to uncover the hidden thematic structure of the web. Moreover, according to [5], triangle counting can benefit the query plan opti-mization in databases. For the aforementioned reasons fast triangle counting algorithms are of high practical value.

In this paper we propose a simple, practical, yet effective algo-rithm for counting triangles in graphs. Our algorithm D OULION can be used in any graph. In our experiments we focus on real-world networks that exhibit a skewed degree distribution and in Erd  X  os-R X nyi graphs ([7]). D OULION is not a competitor of other triangle-counting algorithms. It is rather a  X  X riend X  since it can be used as a first step before applying any triangle counting algorithm, streaming or not. We verify the effectiveness of our method in a wide range of experiments on real-world networks and provide a basic mathematical analysis of our algorithm and some connections to the spectral analysis of matrices.

In figure 1 we see the results of running D OULION on one snap-shot of the Wikipedia Web graph. As we see, even when keeping 10% of the edges accuracy is almost the ideal 100%. For the range of the  X  X dge-keeping X  percentages that we used, 10% to 90% with a step of 10% we received speedups 113.1, 28.9, 12.8, 7.1, 4.5, 3.1 2.2, 1.6, 1.3 correspondingly. The mean accuracy is 99.7% and the standard deviation 0.0023. D OULION has the advantage of being  X  X mbarassingly X  parallel as well, therefore allowing us to easily implement it in any parallel programming framework. For our purposes, we used H ADOOP the open source implementation of M AP R EDUCE [11].

The outline of the paper is as follows: Section 2 presents an overview of the related work and Section 3 the proposed algorithm. Section 4 shows the experimental results and we conclude in sec-tion 5.
In this section, we present the related work on the problem of counting triangles in a graph and briefly give some information on the M AP R EDUCE framework and H ADOOP .
Let G ( V, E ) , n= | V | , m= | E | be an undirected, unweighted, sim-ple graph. A triangle is a three-node subgraph of G which is fully connected. Figure 1: Speedup vs. Accuracy for the Wikipedia Graph snap-shot on 2005 Nov. The graph has  X  1,7M nodes and 20M edges. As we see, even when keeping 10% of the edges of the initial graph accuracy is 99.5%. For p  X  X  ranging from 10% to 90% the mean accuracy is 99.7%, the accuracy standard deviation 0.0023 and the mean speedup 19.4.

One obvious way to count the number of triangles in a graph is to enumerate all possible ` n 3  X  combinations of vertices and count how many of them are fully connected. This results in the naive algorithm with O ( n 3 ) time complexity.

A simple algorithm, known as N ODE I TERATOR , computes for each node its neighborhood and then sees how many edges ex-ist among its neighbors. This algorithm runs asymptotically in P an upper bound of O ( d 2 max n ) , where d max is the maximum de-gree in G . Another simple algorithm that works in a similar way is the E DGE I TERATOR . Rather than checking each node at the time, E
DGE I TERATOR checks each edge ( u, v )  X  E and computes the common neighbors of the nodes u and v . Asymptotically E DGE ERATOR runs in the the same time with the N ODE I TERATOR algorithm can be improved through a simple hashing argument so that it runs in O ( m 3 2 ) [26]. This version of E DGE I also called E DGE I TERATOR -hashed. The f orward algorithm is another refinement of the E DGE I TERATOR . The key idea of this al-gorithm is that there is no need to compare the full neighborhoods of two adjacent nodes. Finally the compact  X  f orward iterator ([20]) further improves the f orward algorithm. Itai and Rodeh in [16] gave an algorithm that finds a triangle if it exists in O ( m Their algorithm can easily be extended in a triangle counting al-gorithm with the same time complexity. Their algorithm relies on computing spanning trees of the graph G and removing edges while making sure that each triangle is listed exactly once. In [26] one can find the analysis and an extensive description of these algorithms.
The fastest methods for triangle counting in terms of time com-plexity are based on fast matrix multiplication. Alon et al. gave in [4] an algorithm of time complexity O ( m 2  X   X  +1 )  X  O ( m at the time of this write-up  X  is 2 . 37 , the exponent of the state-of-the-art algorithm for matrix multiplication ([10]). Exact counting methods however may be slow, even not applicable when the size of the graph fairly large due to high memory requirements. In those cases an approximating algorithm is preferred in the cost of losing the exact number of triangles.

The goal of streaming algorithms is to perform one or at most a constant number of passes over the graph stream (e.g. edges ar-riving one at a time { e 1 , e 2 , .., e m } ) and make provably accurate estimates of the number of triangles. Yossef et al. in their semi-nal paper [5] gave the first streaming algorithm for counting trian-gles. They first define all possible different triples that can show up and then reduce the problem of triangle counting to estimating moments for a stream of node triples. Then they use the Alon-Matias-Szegedy algorithms (also known as AMS algorithms) pre-sented in the G X del awarded work [3]. The space complexity of their algorithms depend on the structure of the graph, and specifi-cally on the cardinalities of the sets of the different types of triples. In [17] three streaming algorithms were presented. Two of them use one pass over the graph stream and the third one three passes. The one-pass algorithms use again the AMS algorithms [3] and the later algorithm uses sampling to reduce the usage of space. The bi-ased sampling is done according to the degree of the vertex chosen. In [8] two random sampling algorithms are proposed to estimate the number of triangles one for the edge stream representation and one for the incidence stream representation of the undirected graph of interest. The sampling procedures are simple. E.g., for the case of the edge stream representation, they sample randomly an edge and a node in the stream and check if they form a triangle.
Bechetti et al. presented in [6] a semi-streaming algorithm for computing triangles in a graph. Their model relaxes the strict con-straint of constant number of passes to obtain an algorithm that performs log ( n ) passes over the edge file. Their main idea relies on locality sensitivity hashing and the observation that the local tri-angle counting reduces to estimating the size of the intersection of two sets, namely the neighborhoods of two nodes connected by an edge. In [27] a spectral counting algorithm was introduced. The idea of this algorithm is to take advantage of the properties of the skewed spectra of power-law networks and make a fast approxi-mation of the number of triangles based on a few, top eigenval-ues. This algorithm can be viewed both as a semi-streaming al-gorithm in the sense that it performs a number of passes at worst O ( log ( n )) ([15]) over the non-zero elements of the adjacency ma-trix (edges) or even as a streaming algorithm by using a linear time algorithm for the SVD ([25]). The performance of the algorithm depends strongly on the spectrum of the graph of interest. Empir-ically the algorithm works well in many real-world graphs but has no guarantees, mainly due to the limited knowledge on the spectra of real-world graphs. We rather have theoretical knowledge on the few top eigenvalues ([23],[9]) or our knowledge is just empirical ([27],[14]).
M AP R EDUCE is a parallel distributed programming framework introduced in [12], which can process huge amounts of data in a massively parallel way using simple commodity machines. It is in-spired by the functional programmming concepts of mapping and reducing. H ADOOP -rougly speaking -is the open source imple-mentation of M AP R EDUCE . It is an emerging technology, which except its reportedly spread-out commercial use, that has already become popular in academia as well. H ADOOP provides a power-ful programming framework, since the programming concepts are simple and the programmer is freed from all the tedious tasks that one should take care of if he/she would write a distributed piece of code. More details about M AP R EDUCE and H ADOOP can be found in [19]. Require: Unweighted Graph G ( V, E ) Require: Sparsification parameter p
Output:  X   X  ( G ) global triangle estimation Require: Unweighted Graph G ( V, E ) Require: Sparsification parameter p
Output:  X   X  ( G ) global triangle estimation
Algorithm 2 : The D OULION -N ODE I TERATOR algorithm
In this section we present the proposed method, analyze it and provide the reader with several interesting -at least in our opinion-observations.
Our algorithm D OULION is a  X  X riend X  rather than a competitor of the other triangle counting algorithms. Furthermore, it is very use-ful and applicable in all possible scenarios: a) the graph fits in the main memory, b) the size of the graph exceeds slightly the available memory, c) the size of the graph exceeds the available memory sig-nificantly. The general framework of the proposed method is shown in algorithm 1. D OULION tosses a coin for each edge. It keeps the edge with probability p and with probability 1  X  p it deletes it. Then each triangle in the resulting graph G  X  counts as 1 p 3 triangles. An equivalent way of viewing this procedure is the following:
After the tossing-coin stage, any triangle counting algorithm can be applied to the obtained graph G  X  . Algorithm 2 shows the in-stantiation of the D OULION triangle counting framework using the N
ODE I TERATOR as the triangle counting black box, which was described in section 2. However, in case that even after the spar-sification the resulting graph cannot fit into the main memory, a streaming or a semi-streaming algorithm should be preferred in-stead as the black box.

Observe that since we assume that the input graph G is un-weighted all edges in G  X  will have the same weight. Therefore we can still store efficiently G  X  just as if it were unweighted plus the parameter p .
We first show that the expected number of triangles in G  X  is the number of triangles  X  in the initial graph G . For each triangle in the initial graph, we attach an indicator variable  X  i Therefore  X  i = 1 if the i -th triangle 1 exists in G  X  , otherwise  X  Let X be the random variable that denotes D OULION  X  X  triangles X  estimate.

T HEOREM 1 (D OULION E XPECTED V ALUE ). The expected num-ber of triangles in G  X  is equal to the actual number of triangles in G : E[X]=  X 
P ROOF . We have that the random variable X is the sum of the indicator variables multiplied by 1 p 3 . By simple properties of the expectation we get the following: E[X]=E[ P  X  i =1 1 p 3  X  P
T HEOREM 2 (D OULION V ARIANCE ). Let  X  be the total num-ber of triangles in G . The variance is equal to: where k is the number of pairs of triangles that are not edge dis-joint.

P ROOF . We have that our estimate is a sum of identically dis-tributed but not independently random indicator variables of whether a triangle in the initial graph  X  X urvives X . The reason that the indi-cator variables are not independent is shown in figure 3.2.1. The indicator variables  X  i and  X  j for the i -th and j -th triangle are not independent because when the edge that they share does not  X  X ur-vive X  then both of them become 0. On the other hand the indicator variables  X  k and  X  p are independent.

Now, by the definition of the variance of a random variable and its basic properties:
Now we break up the above summation. There are  X  2 terms in this sum.  X  of them are the variances of the indicator variables, therefore we get  X ( p 3  X  p 6 ) . The rest 2 `  X  2  X  terms correspond to
There is no ordering of triangles. The i -th term refers to the i -th triangle of any random ordering of the triangles in graph G . Figure 2: The cases should be considered when estimating the variance of D OULION . These are determined by whether the triangles are edge-disjoint or not. the pairs of indicator variables. Let k out of `  X  2  X  pairs of indicator variables correspond to triangles that share one edge. In that case Cov (  X  i ,  X  j ) = p 5  X  p 6 . For the rest `  X  2  X   X  k , terms Cov (  X  p  X  p 6 = 0 .
 Therefore, we get:
Using the second moment method ([2]) we get the following the-orem.

P ROOF . By applying Chebyshev X  X  inequality, we get: P r ( | X  X   X  |  X   X   X )  X  V ar ( X )  X  2  X  2 and by substituting the formula for the vari-ance from theorem 2 we get the bound.
 This theorem gives a first insight in the performance of D The probability that our estimate is away from the real number of triangles by some factor  X  depends on the number of triangles in the graph as well as the structure of the graph and of course on the sparsification value p in the following way: the larger the number of triangles in the graph, the probability to obtain a good estimate increases. Also, the more edge-disjoint triangles exist in the graph, the better the estimate is. Finally, as p  X  0 the quality of the estimate gets worse, as expected.
Consider now a simple triangle listing algorithm, namely the node iterator which was described in Section 2. If R is its run-ning time after the removal of edges then R = P k v =1 D ( v ) D ( v ) = degree of vertex v after coin-tossing, hence Hence the expected speedup is 1 p 2 .
 Figure 3: Real Inverse Epidemic Threshold (  X  1 ) vs. our esti-mate for 14 different datasets . As we see, the estimates are al-most ideal, in most cases differing in the second decimal digit. Similar results hold for other graphs as well.
Let X  X  consider the interesting case of a graph that is so large that exceeds the available main memory significantly. A well-known technique to select k random records sequentially from a file that resides in a hard disk is the rejection method [29]. More sampling algorithms can be found in the same work [29] and in [18]. Observe that the number of disk pages fetched may in the worst case be equivalent to performing a sequential scan over the file. However, if k is significantly smaller than the size of the file then we expect to have significant savings with the sampling approach. In our case, where we assume that the graph is represented as a stream of edges or equivalently resides in an edge file, e.g. a file whose each line is of the form (endpoint 1 , endpoint 2 ), k  X  mp .
As shown in [27] the number of triangles is equal to the sum of the cubes of the eigenvalues divided by six. Given the spectra prop-erties observed in many real-world networks one can approximate the number of triangles in the graph just by using few eigenvalues. Achlioptas and McSherry showed in [1] that one can  X  X hrow  X  away many of the elements of a matrix and still keep the top eigenvalues the same. This is an observation used in [28] where a faster version of the algorithm in [27] is presented.

Given the aforementioned observation, the top adjacency eigen-value of G  X  will be very close to the top one of G . This is an interesting approach since the top eigenvalue of the adjacency ma-trix representation of any graph is closely related to the epidemic threshold [30]. Therefore, D OULION has the effect of not only pre-serving in expectation the number of triangles but also approxi-mately the epidemic threshold.

Just for the sake of illustration, figure 3 plots the real epidemic threshold of graph G vs. the estimate, i.e., the epidemic threshold of graph G  X  for 14 different datasets (Flickr, Epinions, AS New-man, EAT RS, Lederberg, Patents (main), Patents, Internet, HEP-th (new), Journals, AS Oregon, AS CAIDA (3 timestamps) ). As we see from the plot, the results are almost ideal, differing in the first or second decimal digit. speedups are important, ranging from  X  80 to  X  130.
 We implemented in H ADOOP a prototype for the D OULION -N
ODE I TERATOR . As one can easily observe, the sparsification step is trivially parallel. Each mapper receives a subset of edges of the initial graph and tosses a coin for each edge. If the edge survives, the mapper emits the corresponding edge. The JAVA and H ADOOP code of our implementations will be open-sourced. 2 We implemented D OULION -N ODE I TERATOR in J AVA and in H
ADOOP . The H ADOOP code ran on Erd  X  os-R X nyi graphs and on the real-world networks we ran the J AVA piece of code. The ex-periments ran on a 4GB RAM, Intel(R) Core(TM)2 Duo CPU at 2.4GHz Windows Vista machine (J AVA code) and in M45 (H ADOOP code), one of the fifty most powerful supercomputers in the world ( 480 hosts, each with 2 quad-core Intel Xeon 1.86 GHz, running RHEL5, with 3Tb aggregate RAM, and over 1.5 PetaByte aggre-gate disk capacity.) after allocating two commodity machines. The graphs we used in our experiments are described in the table 1. The directed ones were made undirected by removing the arcs of the edges and the self-loops -if any-were removed. Most of the datasets we used are publicly available 3 . http://www.cs.cmu.edu/ ctsourak/projects/triangles.htm. http://www.cise.ufl.edu/research/sparse/ matrices/
We divide and present the experiments into four different cate-gories: D OULION on large-, medium-and small-sized real world graphs and on Erd  X  os-R X nyi. We run D OULION -N ODE I TERATOR using nine different values for p , ranging from 0.1 to 0.9 with a step of 0.1. All the figures presented in the following refer to a single, random run of D OULION on the graphs.

Figures 1 and 4 show the experimental results for the largest real-world graphs we used: the four different snapshots of the Wikipedia Web graph and Flickr. All these networks have size greater than 2M edges. The behavior of D OULION in these graphs is the ideal. The accuracy is always greater than 99% and speedups are significant, ranging from  X  80 to  X  130 times faster. As expected, the maxi-mum speedups are obtained for p = 0 . 1 . Also observe how more significant the speedups become when moving from p = 0 . 2 to p = 0 . 1 . As already mentioned before, observe that the speedup refers to the running time of a straight-forward exact triangle count-ing method vs. itself using D OULION , i.e., N ODE I TERATOR D
OULION -N ODE I TERATOR . This verifies the fact D OULION friend of triangle counting algorithms.

We conducted 158 experiments on medium-sized graphs, whose sized ranged from  X  40K to  X  400K edges. Figure 6 shows the though still small. Speedup can be even  X  100 (Journals). performance of D OULION on these graphs. For the 150 omitted timestamps/graphs of AS CAIDA, similar results hold as in fig-ure 6(h).

Edinburgh Thesaurus and AS Newman graphs ( figures 6(c),(g) exhibit the almost ideal behavior of the large graphs: accuracy al-ways greater than 99% and important speedups. Very close to this behavior, is also behavior of the Epinions (who-trusts-whom), the Reuters X  graph and the HEP-TH graph, shown in figures 6(a), (b) and (e). Speedups are still important and accuracy is again high, al-ways more than 97%. In the rest of the graphs (figures 6(d),(f),(h )) results are still satisfactory. However we observe that there is larger variance around the real number of triangles in the graph. Still though, the accuracy is always greater than 96%. The maximum speedup in the case of medium sized graphs can reach 100 times. We used three small graphs to experiment with, AS Oregon, Journals and Zewail. Journals graph exhibits an ideal behavior, just like the large graphs. D OULION gives more than 99% accuracy for all values of p we tried and a speedup of almost 100 times. Ore-gon and Zewail exhibit larger variance than Journals graph over our single random run. Accuracy is almost always greater than 95% , with the single exception of using p = 0 . 5 in the Oregon graph. However, running D OULION three times, moves these  X  X utlier X -like points closer to 1, just like in all other plots. This was the worst case behavior of D OULION that we saw during our experiments.
To sum up, the following observations hold for all the experi-ments we conducted on real graphs with size ranging from  X  6 K edges (Journals graph) to  X  42 M (Wikipedia 2007): Using our H ADOOP implementation we run D OULION on large Erd  X  os-R X nyi G n,p graphs. As expected in the case large of random Erd  X  os-R X nyi the results are excellent in terms of accuracy for the sparsification values we tested. The reason is the following: after applying D OULION to a G n,p graph with the sparsification param-eter equal to 0 . 1 the result is an Erd  X  os-R X nyi G n,p  X  Therefore, as long as p  X  is a constant and does not cause any thresh-old phenomena in the number of cycles in the graph (e.g. p  X  = see [7] ) we have a concentrated estimate around the real number of triangles. The results of running D OULION -N ODE I TERATOR p = 0 . 1 on two Erd  X  os-R X nyi graphs with 80M and 100M nodes are shown in Table 2. As we see, the speedups are 13.1 and 19.8 respectively for the two graphs and the accuracy in both cases is greater than 99%. Table 2: Results of D OULION on G n, 1 equal to 1 2 .
In this paper we presented D OULION , an algorithm which tosses a coin in order to obtain a smaller, weighted graph in which the number of triangles is very close to the true value. Our contribu-tions can be summarized in the following points:
Finally, as a topic of future research, we propose a tighter the-oretical analysis that will yield the optimal p , namely the smallest possible one which yields an exponential concentration around the real number of triangles.
The authors would like to thank M.N. Kolountzakis, Tom Bohman and Ioannis Koutis for helpful discussions on the paper. The au-thors would would like to thank the anonymous reviewers for valu-able feedback. This material is based upon work supported by the National Science Foundation under Grants No. CCF-0635257, Also, under the auspices of the U.S. Department of Energy, by the University of California Lawrence Livermore National Laboratory under contract DE-AC52-07NA27344 (LLNL-CONF-404625), sub -contracts B579447, B580840. Any opinions, findings, and conclu-sions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the Na-tional Science Foundation, or other funding parties. [1] D. Achlioptas and F. McSherry. Fast computation of low [2] N. Alon and S. Joel. The Probabilistic Method . Wiley [3] N. Alon, Y. Matias, and M. Szegedy. The space complexity [4] N. Alon, R. Yuster, and U. Zwick. Finding and counting [5] Z. Bar-Yosseff, R. Kumar, and D. Sivakumar. Reductions in [6] L. Becchetti, P. Boldi, C. Castillo, and A. Gionis. Efficient [7] B. Bollobas. Random Graphs . Cambridge University Press, [8] L. S. Buriol, G. Frahling, S. Leonardi, [9] F. Chung, L. Lu, and V. Vu. Eigenvalues of random power [10] D. Coppersmith and S. Winograd. Matrix multiplication via [11] J. Dean and S. Ghemawat. Mapreduce: Simplified data [12] J. Dean and S. Ghemawat. Mapreduce: Simplified data [13] J.-P. Eckmann and E. Moses. Curvature of co-links uncovers [14] I. J. Farkas, I. Derenyi, A.-L. Barabasi, and T. Vicsek. [15] G. Golub and C. Van Loan. Matrix Computations .
 [16] A. Itai and M. Rodeh. Finding a minimum circuit in a graph. [17] H. Jowhari and M. Ghodsi. New streaming algorithms for [18] D. E. Knuth. Seminumerical Algorithms , volume 2 of The [19] R. L X mmel. Google X  X  mapreduce programming model  X  [20] M. Latapy. Main-memory triangle computations for very [21] J. Leskovec and E. Horvitz. Planetary-scale views on an [22] M. Mcpherson, L. S. Lovin, and J. M. Cook. Birds of a [23] M. Mihail and C. Papadimitriou. the eigenvalue power law, [24] M. E. J. Newman. The structure and function of complex [25] T. Sarlos. Improved approximation algorithms for large [26] T. Schank. Algorithmic Aspects of Triangle-Based Network [27] C. Tsourakakis. Fast counting of triangles in large real [28] C. Tsourakakis, P. Drineas, E. Michelakis, I. Koutis, and [29] J. S. Vitter. Faster methods for random sampling. Commun. [30] Y. Wang, D. Chakrabarti, C. Faloutsos, C. Wang, and [31] S. Wasserman and K. Faust. Social network analysis .
