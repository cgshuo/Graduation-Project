 1. Introduction
A Radio Frequency Identification (RFID) system is a set of automated identification technologies in which a small transpon-der (tag), attached to an object (i.e. a human, animal or product), receives and responds to radio-frequency queries from a trans-ceiver (reader). Barcodes are currently the most extended identi-fication systems, but this technology may be replaced by RFID in the near future. RFID has two main advantages over barcodes.
First, the technological advantages: data can be read automati-cally, without line of sight and through a non-conducting material such as cardboard or paper, at a rate of hundreds of times per second and at a distance of several meters. Secondly, the unequivocal identification provided by RFID technology: an RFID tag assigns a unique identifier to each tagged item, while a barcode only specifies the type of the labeled product. Despite these benefits, security and privacy concerns are holding up the rapid and widespread adoption of this promising technology.
Due to the heterogeneity of RFID systems, there is a great number of interconnected standards. ISO and EPCglobal have played an important role in harmonization. In 2004, the Electronic Product
Code Class-1 Generation-2 specification (EPC-C1G2 in short) was adopted by EPCGlobal ( Class-1 generation 2 UHF, 2008 ). A few months later, it was ratified by ISO and published as an amendment to its ISO/IEC 18000-6 ( Information technology  X  Radio, 2005 ). This standard is an important milestone for the standardization of low-cost RFID tags. However, the di fferent security analysis carried out on the EPC-C1G2 specification have revealed important security flaws ( Bailey and Juels, 2006 ; Peris-Lopez et al., 2008 ). Some researchers have later proposed EPC-friendly schemes trying to correct these weaknesses. One of the most recent proposals follow-ing this approach is Chen and Deng X  X  scheme , which is our concern in this paper.
 is reviewed in Section 2. In Section 3, we present Chen and Deng X  X  protocol. The properties of CRC functions are studied in Section 4.
We present our attacks and the non-conformity with the standard in Section 5. In Section 6, we introduce a new protocol compliant with EPC-C1G2 standard and highly inspired by ISO/IEC 9798.
Finally, we extract some conclusions in Section 7. 2. Related work some recent proposals have attempted to rectify its deficiencies whilst still conforming to the standard. We now summarizes the most important proposals in this area.

Bailey and Juels (2006) examined various ways for RFID tags to perform cryptographic functions while remaining EPC-C1G2 compliant. Their main idea is to take an expansive view of EPC tag memory. Instead of considering memory merely as a storage medium, they use it as an input/output way of interfacing with a cryptographic module within the tag. Read/write commands may, therefore, involve cryptographic values, such as messages in a challenge-response protocol. Their work clearly shows the need for mutual authentication between readers and tags. However, the assumption that a low-cost tag might support on-board crypto-graphic modules is unrealistic, at least at present time.
Karthikeyan and Nesterenko (2005) proposed an efficient tag identification and reader authentication protocol based on a simple XOR and matrix operations. Two matrices and a key are stored in both the tag ( K , M 1 , M 2 1 ) and the back-end database ( K , M 1 1 , M 2 ). Once the tag is identified, the reader sends to the tag messages Y , Z . The first is used to authenticate the tag and the second to update the key. However, an attacker can substitute the original Z by a random Z 0 . Upon receiving Y , Z 0 , the tag will be authenticated and will wrongly update the key. So the legitimate reader and the tag will not be able to authenticate each other any more. Additionally, the protocol is vulnerable to replay attacks, and privacy location is not guaranteed ( Chien and Chen, 2007 ).
Nguyen Duc et al. (2006) later proposed a tag-to-back-end database authentication protocol. The security of Nguyen Duc et al. X  X  protocol is based on key synchronization between tags and the back-end database. The last message of the protocol consists of an EndSession command, which is sent to both tags and readers.
Interception of one of these messages will cause a synchroniza-tion loss between the tag and the server. The tag and the reader will then be no longer able to authenticate, which is an extremely serious problem. The protocol also presents backward secrecy problems, as compromise of the EPC allows an attacker to trace back all previous communications.

Chien et al. pointed out certain weaknesses in the schemes ( Karthikeyan and Nesterenko, 2005 ) and ( Nguyen Duc et al., 2006 ), and then proposed a new EPC-C1G2 compliant mutual authentication protocol ( Chien and Chen, 2007 ). However, Peris-
Lopez et al. (2009) showed how none of the objectives are met, as it is vulnerable to attacks including identity impersonation, non-forward security and tracking. Execution of the protocol itself even produces desynchronization between the tags and the back-end database.

Konidala and Kim (2007) produced an interesting paper which tried to correct some of the security shortcomings of the
EPC-C1G2 specification. The authors hold that the proposed scheme frustrates the access password acquisition using a simple XOR operation, in contrast to what happens in the specification.
However, Lim and Li (2007) showed how a passive attacker can recover the tag X  X  password by eavesdropping over a single run of the protocol and performing correlation analysis on the captured information. Konidala and Kim then proposed a new version of the TRMA scheme (TRMA  X  ) in which the tag access and kill passwords are used for authentication. This new version still contains important security flaws, as the key and access password can be acquired by an adversary, with non-negligible probability ( Peris-Lopez et al., 2008 ).

We summarize here some of the most relevant works in which artificial intelligence (AI) techniques were successfully used to solve cryptographic problems. We urge the interesting reader to consult the original papers for details. Spillman et al. (1993) showed that simple substitution ciphers and knapsack ciphers ( Spillman, 1993 ) could be solved using genetic algorithms. Giddy and Safavi-Naini (1994) used simulated annealing for the automatic cryptanalysis of transposition ciphers. Clark (1994) summarized the use of simulated annealing, gene tic algorithms and tabu search in the cryptanalysis of simple substi tution and transposition ciphers. Knudsen and Meier (1999) introduced an improved simulated annealing search to attack an identification scheme based on the permuted perceptron problem (PPP). Hernandez Castro and Isasi Viuela (2005) introduced a technique capable of breaking reduced-round versions of the block cipher TEA and XTEA with the aid of genetic algorithms. A particle swarm optimization method and a genetic algorithm were able to cryptanalyze a four-round version of recently, and in the context of RFID, a quite efficient simulated annealing-based traceability attack against an ultralightweight authentication protocol was presented in Hernandez-Castro et al. (2009) . 3. Chen and Deng X  X  protocol
Chen and Deng (2009) proposed an EPC-friendly scheme (CD-EPC in short) based on the use of a ps eudo-random number generator (PRNG) and a cyclic redundancy code (CRC), as recommended by the EPC-C1G2 standard. We will outline the CD-EPC protocol in brief, which consists of two phases: a registration and an initialization. The following notation is used thorough the paper: x
T i  X  j  X  value x of tag T i registered in j th database  X  N T i  X  j  X  , K T i  X  j  X  X  N T i  X  j  X  is nonce word and K CRC() a Cyclic Redundancy Code (CRC) function EPC T i EPC identification number of tag T i ID R i identification number of the i th reader
RND random number M req reader X  X  request message
M resp reader X  X  response message 3.1. Registration phase
Tags and readers must register in the database separately in a secure environment. Tags send their unique EPCs to the database. ask for registering. Each N T i  X  j  X  corresponds to only one K Generally, each tag may register in several databases obtaining a under their unique identification ID R i . After registration, the tags that can be accessed by reader ID R i . The authors also believe that readers may be registered in several databases at the same time. A common scenario depicting tags and readers registration is illustrated in Fig. 1 . 3.2. Communication phase
Through the registration phase, tags and readers can commu-nicate mutually. Only random numbers, exclusive-OR operations and the lightweight CRC operation are employed to compose the exchanged messages, as required by the EPC-C1G2 standard. The proposed scheme is split into five steps (see Fig. 2 ):
Step 1: When the reader wants to access a tag, it sends a request message M req , CRC  X  N T i  X  j  X  RND 1  X  and RND
Step 2: Upon receiving CRC  X  N T i  X  j  X  RND 1  X  and RND 1 uses the stored N 0 T tag can authenticate the reader via the following verification: CRC  X  N 0 T
If this equality does not hold, the tag will not perform any further calculations or responses; the request is assumed to be sent from an attacker or from a forbidden list. If it holds, a tag will generate a new random number RND 2 and compute:
X  X  K 0 T
Y  X  CRC  X  RND 2 N 0 T Step 3: Tag sends f RND 2 , X , Y g to the reader.

Step 4: Upon receiving the tag X  X  response message, the reader computes its local version of Y  X  CRC  X  RND 2 N T i  X  j  X  X  X  , using
RND 2 and X as obtained from the tag. If the equality does not hold, the response may have been sent by an attacker, and the reader will not perform any further calculations or responses. If it holds, the reader uses K T i  X  j  X  (linked to N T i  X  j  X  ), and  X  RND static identifier of tag T i : EPC T i  X  K i RND 2 X  X  4  X 
Step 5: When a reader obtains a tag X  X  EPC T i and the authen-ticity of the tag has been confirmed, the reader sends a response
M resp to the tag. 4. Cyclic redundancy codes  X  CRCs
A cyclic redundancy code (CRC) is a checksum algorithm that can be used to detect transmission errors (typically one or two bit flips, or bursts) in a very efficient way. CRCs operate by interpreting input binary sequences as polynomial coefficients that they divide over a prefixed polynomial in order to obtain a remainder, which, in its binary expression, constitutes the crc value.
 or security related applications as they cannot detect malicious changes by a knowledgeable attacker ( Anarchriz, 1999 ; Ranasinghe, 2007 ; Stigge et al., 2006 ; Westerbaan, 2005 ). To illustrate this property, the hamming distance ( HD ) can be used. The HD of a
CRC polynomial is the minimum number of error bits that can pass undetected by the CRC. For example, if a CRC has a HD of 3, any combinations of 1 or 2 error bits will be detected, but there is at least one combination of three error bits that will pass unnoticed. Cryptographic hash functions, that have very high HD values, should, therefore, be used for any security related purpose instead. 4.1. Definitions and notations define A 5 n as the m  X  n bit string A 0 resulting from left-shift of A by n-bits: , , , Back-end Database (2)
Let B be an n-bit string in f 0 , 1 g n , where n r m . We define the exclusive-OR operation A B  X  B A as follows:  X  A B  X  i  X  The set of bit strings f 0 , 1 g 1 forms a group under the exclusive-
OR operation. F 2 and F 2  X  x symbolize the binary field and the ring of polynomials over F 2 , respectively. For a m-bit string A ,wedefinea map f : f 0 , 1 g 1 -F 2  X  x : f  X  A  X  X 
As f is an group isomorphic, the inverse exists  X  c  X  . That is, 4.2. CRC properties
CRC functions are based on polynomial arithmetic in F 2 .Comput-ing a crc value for a given binary s tream is essentially performed by dividing the polynomial associated with this stream by another fixed polynomial (generator polynomial) and obtaining a remainder.
Let G be the generator polynomial used for calculating CRC. The CRC for any bit-string A is then computed by CRC  X  A  X  X  c  X  f  X  A  X  mod G  X  X  9  X 
Due to the linearity, CRCs have the following properties ( Han and Kwon, 2009 ; Peris-Lopez et al., 2009 ):
Theorem 1. For any CRC ( independent of its generator polynomial ), and for any A n-bit and B m-bit string , it holds that CRC  X  A B  X  X  CRC  X  A  X  CRC  X  B  X  X  10  X  CRC  X  A J B  X  X  CRC  X  A 5 n  X  CRC  X  B  X  X  11  X  Proof. From the definition in Eq. (9), one can write CRC  X  A B  X  X  c  X  f  X  A B  X  mod G  X  X  12  X 
Since modular operations, c ,and f are homomorphic, the above equation can be rewritten c  X  f  X  A B  X  mod G  X  X  c  X  X  f  X  A  X  mod G  X  X  f  X  B  X  mod G  X  X 
The concatenation of any two bit strings  X  A J B  X  , can be viewed as the exclusive-OR between the n-bit shift of the left variable ( A and the right value ( B ). Thus, applying Eq. (13)
CRC  X  A jj B  X  X  CRC  X  A 5 n B  X  X  CRC  X  A 5 n  X  CRC  X  B  X  &amp;  X  14  X  5. Vulnerabilities of Chen and Deng X  X  protocol In this section we analyze the most relevant weaknesses of the
CD-EPC protocol. 5.1. Reader impersonation Each tag shares some private information with the reader: N  X  j  X  and K T i  X  j  X  . This information is used to build the exchanged messages between these two devices in order to proof their authenticity. Specifically, the reader is authenticated by checking the following equation: CRC  X  N 0 T Theorem 2. In the CD-EPC protocol , a passive attacker is able to supplant a legitimate reader after eavesdropping one authentica-tion session by sending message M req , CRC  X  N T i  X  j  X  RND RND 0 1 , where D  X  RND 1 RND 0 1 .
 Proof. Step 1: The attacker eavesdrops an authentication session between the reader and the tag.  X  1  X  R -T : M req , CRC  X  N T i  X  j  X  RND 1  X  , RND 1  X  2  X  T -R : RND 2 , X , Y  X  3  X  R -T : M resp ,
Step 2: The attacker can supplant the reader by sending the following message:  X  1  X  A -T : M req , CRC  X  N T i  X  j  X  RND 1  X  CRC  X  D  X  , RND  X  2  X  ...

On receiving CRC  X  N T i  X  j  X  RND 1  X  CRC  X  D  X  and RND 1 received value.
 CRC  X  N T i  X  j  X  RND 1  X  CRC  X  D  X  X  ? CRC  X  N 0 T From Eq. (10), it holds that CRC  X  N T i  X  j  X  RND 1  X  CRC  X  D  X  X  CRC  X  N 0 T The message sent by the attacker is, therefore, accepted as valid. The attack described is quite harmful because once an authentica-tion session is eavesdropped, the attacker is able to supplant the reader indefinitely. This issue could be mitigated by refreshing choose to do this in their protocol design. 5.2. Tracking or private location
Untraceability can be viewed as a game G played between an adversary  X  A  X  and a collection of readers  X  R i  X  and tags instances  X  T
 X  . The success of A winning G , therefore, translates to its success in breaking untraceability ( Phan, 2009 ): Adv  X  UNT  X  A  X j Pr  X  A wins  X  1 2 j X  17  X  where k is a security parameter (i.e. bit length of secret values). An RFID protocol achieves untraceability if Adv  X  UNT  X  A o e some negligible function.
 Theorem 3. The CD-EPC protocol does not protect against privacy location ; an adversary wins the untraceability  X  G  X  gain with a significant probability : Adv  X  UNT  X  A C 0 : 499985.

Two different approaches can be used by the adversary. First, the reader impersonation attack presented in the Section 5.1 may be employed (Proof-A). A passive attacker can trace any given RFID after observing one single authentication session because the secret N T i  X  i  X  is kept constant and the CRC function does not disguise it well enough. Secondly, the attacker may focus on the responses provided by tags (Proof-B). In this case, we take advantage of the authors X  misuse of bitwise operations which result in the inclusion of a constant value in tag responses. Proof-A. Specifically, the adversary A performs the following steps:
Learning : Eavesdrops on an authentication session between the reader and the tag T 0 .

Challenge : Some time later, the adversary chooses two fresh tags T 0 and T 1 . Then, one of these tags is randomly selected  X  T i A f T 0 , T 1 g X  and presented to the adversary. The adversary tries to impersonate it by the procedure described in Section 5.1.
Guessing : If an answer message is obtained, A conjectures it is probability that by chance the procedure described in Section 5.1 will work for tag T 1 . As EPC-compliant tags support 16-bit CRC function on-board ( Class-1 generation 2 UHF, 2008 ), and assum-ing independence and uniformity in the random number genera-tion and in the CRC output, this probability has a value of 2
So, the Adv  X  UNT  X  A  X  k  X  is non-negligible and the proposed protocol does not achieve untraceability:
Secondly, the attacker may analyze tag responses. These answers would have to be anonymized to protect privacy location. However, the use of fresh random numbers is not enough to guarantee this required and important property. Messages have to be carefully designed when they are constructed, using modular operations ( Alomair and Poovendran, 2008 ). As in the above case, we can show how privacy location is compromised by means of a game G .
Proof B. We start observing a bad property of tag responses, which is expressed by the following Lemma.
 Lemma 1. In CD-EPC protocol , tags respond with a constant Y  X 
CRC  X  N 0 T each authentication session.

The verification of the above Lemma is straightforward. After reader authentication , the tag answers the reader by sending values RND and Y :
X  X  K 0 T
Y  X  CRC  X  RND 2 N 0 T Combining the above equations, a constant value is obtained:
Y  X  CRC  X  RND 2 N 0 T  X  CRC  X  N 0 T i  X  j  X  k 0 T i  X  j  X  EPC T i  X  X  21  X 
Lemma 1 is used in the untraceability  X  G  X  game. Specifically, the adversary A performs the following steps:
Learning : Eavesdrops on an authentication session between the reader and tag T 0 and stores value Y .

Challenge : Some time later, the adversary chooses two fresh tags T 0 and T 1 . Then, one of these tags is randomly selected  X  T i A f T 0 , T 1 g X  and presented to the adversary. The adversary eavesdrops on an authentication session between this unknown tag and a legitimate reader.

Guessing : If the same Y value is captured, A conjectures that the unknown tag is in fact T 0 . Otherwise, it supposes it to be T that the probability that tag T 1 and T 0 lead to the same value for Y  X  CRC (.) value is very low: 1/2 16 .

So, the proposed protocol does not offer protection against traceability because the Adv  X  UNT  X  A  X  k  X  is significant:
Summarizing, we have shown in this section, by means of two different (but related) passive attacks, how privacy location is not protected in the CD-EPC protocol. An attacker may exploit this vulnerability to associate a tag with its holder, and track him or her as he/she passes through different readers in, for example, different places in a city. 5.3. Tag impersonation a legitimate tag just by eavesdropping one authentication session between the reader and the tag. The exploitation of this attack can extend for an indefinite period of time, as the internal values of proof is not included.

Theorem 4. In the CD-EPC protocol , on eavesdropping one authentic session , an adversary is able to respond to the reader X  X  queries correctly  X  with the consequence of tag impersonation  X  by sending RND 2 0 , X 0  X  X D , Y 0  X  Y message , where D  X  RND 2 0 RND 2.
Proof. Step 1: The attacker eavesdrops one authentication session between the reader and the tag.  X  1  X  R -T : M req , CRC  X  N T i  X  j  X  RND 1  X  , RND 1  X  2  X  T -R : RND 2 , X , Y  X  3  X  R -T : M resp , following message:  X  1  X  R -T : M req , CRC  X  N T i  X  j  X  RND 1 0  X  , RND 1  X  2  X  T -R : RND 2 0 , X 0 , Y 0 its local Y 0 value and compare this with the received value:
Y 0  X  CRC  X  RND 0 2 N T i  X  j  X  X 0  X  and authenticates the adversary. Finally, the reader obtains the static identifier of the impersonated tag: 5.4. Denial of service perform a denial of service (DoS) attack. This exploits the linearity of the CRC function and its lack of resistance against active attacks due to the use of the exclusive-OR operation ( Alomair and Poovendran, 2008 ).
 operation. Suppose a tag and a reader share an unique identifier as RND . Let P be the following simple authentication protocol:
R -T : m 1 J m 2 where MAC symbolizes a message authenticate code.

Upon receiving message m 1 and its MAC m 2 , the reader performs a bitwise XOR between m 1 and the tag X  X  EPC to extract
RND 0 . Then, the result of computing a bitwise XOR between the obtained RND 0 value and its version of the secret key is compared with m 2 . If this comparison holds, authentication process is successful.

Attack : Considering modifying m 1 to m 0 1  X  m 1 b , b being any non-zero bit string. Upon receiving m 1 , the extracted RND 0 is
RND b . The attacker will have to modify m 2 to m 0 2  X  m b  X  K
T i  X  RND b  X  in order to pass unnoticed. Therefore, all the adversary has to do is to disturb both messages m 1 and m same non-zero string.

Theorem 5. In the CD-EPC protocol , after eavesdropping one authentic session , an adversary is able to respond to the reader X  X  queries correctly and lead the reader to an incorrect EPC value  X  EPC i 00  X  EPC T i d  X  by sending X 0  X  X RND 3 , Y 0  X  Y CRC  X  RND
CRC  X  D  X  message , where D  X  RND 2 0 RND 2 and d  X  D RND
Proof. Step 1: The attacker eavesdrops one authentication session and blocks or alters the tag X  X  response.  X  1  X  R -T : M req , CRC  X  N 0 T i  X  j  X  RND 1  X  , RND 1  X  2  X  T -R :  X  blocked  X  RND 2 , X , Y
Step 2: The attacker can supplant the tag by sending the following message:  X  2
 X  A -R : RND 2 0 , X 0 , Y 0
Upon receiving X 0 , Y 0 and RND 2 0 , the reader uses N T its local Y 00 value and compare this with the received value:
Y 00  X  CRC  X  RND 0 2 N T i  X  j  X  X 0  X   X  CRC  X  RND 0 2 N T i  X  j  X  X RND 3  X  X  25  X  As b b  X  0,
Y 00  X  CRC  X  RND 0 2 N T i  X  j  X  X RND 3 RND 2 RND 2  X   X  CRC  X  D N T i  X  j  X  X RND 2 RND 3  X  X  26  X  Applying Eq. (10),
Y 00  X  CRC  X  D  X  CRC  X  N T i  X  j  X  X RND 2  X  CRC  X  RND 3  X   X  CRC  X  D  X  Y CRC  X  RND 3  X  X  Y 0  X  27  X 
The tag is authenticated and the reader obtains the static identifier by computing the following equation: EPC Applying Eq. (2), EPC
An incorrect EPC T i is obtained, but the reader is not able to detect the trick. The reader will associate an incorrect identifier ( EPC T i 00  X  EPC T i d , where d  X  D RND 3 ) with the tuple  X  N K  X  j  X  X  . So, the proposed protocol is vulnerable to a DoS through a man-in-the middle attack. 5.5. Standard compatibility
The authors claim that the protocol conforms to the EPC-C1G2 specification. However, important technical aspects necessary to its successful implementation were ignored. We now summarize the most important properties of tags that comply with this standard:
Tags are passive, so they receive all their operating energy from the readers X  RF waveform.

Tags operate on the UHF band (860 X 960 MHz). Generally, their effectiveness will be poor around metals and water. Their read range is up to 9 m.

Their very constrained resources and storage capabilities dictate that EPC-C1G2 tags cannot afford traditional crypto-graphic primitives.
 Tags include a 16-bit PRNG and 16-bit CRC function on-chip. Tags have two 32-bit PINs:
J Kill PIN: The kill password is a 32-bit value stored in
J Access PIN: The access password is a 32-bit value stored in
The CD-EPC protocol is described by the following three equations:  X  1  X  CRC  X  N T i  X  j  X  RND 1  X  X  30  X   X  2  X  X  X  K T i  X  j  X  EPC T i RND 2  X  31  X   X  3  X  Y  X  CRC  X  RND 2 N T i  X  j  X  X  X  X  32  X  RND 1 is forced to the same length by Eq. (30). Summarizing, all the variables must have the same length to run the CD-EPC protocol. As the EPC unique identifier must have a length of 96 or 198 bits for compatibility with all encoding schemes (i.e. GID, SGTIN, SSCC) defined by EPCGlobal ( EPC Tag, 2008 ), the value l would have to be fixed to one of these two values. However, EPC-C1G2 standard. Although it is not explicitly mentioned by the the access and kill passwords as proposed in the standard. A comparison between the length of the variables defined in the standard and the variables used in the proposed protocol is shown in the following table: Variable EPC-C1G2 standard CD-EPC scheme EPC T i 96 or 198 bits 96 or 198 bits RND i 16 bits 96 or 198 bits N T i  X  j  X  32 bits 96 or 198 bits K T i  X  j  X  32 bits 96 or 198 bits
So, CD-EPC protocols triples or sextuples the memory require-ments ( password length  X  32 m ), where m  X  3 or 6) compared with the standard. Additionally, the 16-bit PRNG has to be invoked 12 or 6 times each time a new nonce is necessary, which results in a significant reduction in the number of answers/s that the tags can provide.
 6. Azumi: a mutual authentication protocol compliant with the EPC-C1G2 standard
Gen-2 tags are very limited devices, specially regarding its computing and storage capabilities. Only very simple operations (i.e. bitwise operations), a 16-bit CRC function and a 16-bit PRNG are supported on-board on these transponders. Many previous proposals attempted to increase the security offered by the
EPC-C1G2 standard, but none of these were successful. More precisely, the security of these schemes heavily relied on the abuse of the CRC function, in many cases asking the CRC proper-ties only to be found on a cryptographic hash function. However,
CRC functions are linear (see Section 4.2) and should not be used for any cryptographic purpose  X  only for detection of random errors in the channel. Our proposed protocol, named Azumi not make the same mistake, and will only use the PRNG supported on-chip, and the two passwords that each tag owns.
In some scenarios only tags are authenticated (unilateral authen-tication), but mutual authentication (reader and tag) is the most commonly adopted solution. We roughly base our proposal on the
ISO/IEC 9798 standard, instead of starting from scratch, with some modifications that are needed for the intended environments. In this standard, three different mechani sms for entity authentication are described: (1) entity authentication using symmetric techniques; (2) entity authentication using public key; (3) entity authentication using a cryptographic check function. We opted for the last option due to the severe computational restrictions of Gen-2 tags, and the fact that this is the most easily implementable. Generally, in these schemes, the two entities (prover/verifier) share a secret authentica-tion key. An entity corroborates its identity by demonstrating knowl-edge of the shared key. This is accomplished by using a secret key with a cryptographic check function applied to specific data to obtain a cryptographic check value. This value can be recalculated by the verifier and compared with the received value. As Gen-2 tags are passive and have to be energized by readers, a three-pass mutual authentication protocol seems the mostadvisableoption.Themes-sages exchanged between the entities A and B are described below.
Each entity has an identifier ( ID A and ID B , respectively) and these where J is concatenation. Finally, RND x represents a random number generated by entity x and Text i denotes any optional message field. B -A : RND B J Text 1 A -B : RND A J Text 3 J f K B -A : Text 5 J f K AB  X  RND B J RND A J ID A J Text 4  X  protocol. We emphasize that the bit length of all variables is defined in conformity with the standard.

The back-end database has to store the old and the new values of the updated variables to combat desynchronization attacks. More precisely, in each row of the database, the tuple f EPC 16 ducted in the same way as in CD-EPC, but there are two main differences. We operate with a 16-bit version of variables and in the back-end database the old and new variables are initially set to the same value ( N 16 old T cate. The mutual authentication process is depicted in Fig. 3 . The details of the messages exchanged are presented below: request message M req  X  the reader can be easily identified (with ID 16 R i ) by this message  X  which includes the random number RND R i which is also sent to the tag.
 random numbers  X  RND T i , RND 0 T tion token A , an anonymous version B of its static identifier, and an encrypted value C of the second random number generated by the tag: A  X  PRNG  X  N T i RND T i RND R i ID 16 R i  X 
B  X  PRNG  X  EPC 16 T i RND 0 T
C  X  RND 0 T Finally, the tag sends f RND T i , A , B , C g to the reader. followings operations:
Tag identification : The reader initiates a search process in the database. For each row, it picks up K 16 T
EPC 16 T i . Then, RND 0 T a local version of B is computed. If the received and computed values match, the tag is successfully identified. If not, the reader repeats the procedure with the data of the next row. The protocol is aborted in case the end of the database is reached.
Tag authentication : Once the tag is identified, the reader has access to all the private information linked with the tag. The reader computes a local version A * of A .If A *  X  A , the tag is authenticated. Otherwise, the protocol is aborted. We emphasize here that the old/new value of N T i is used depending on wether the old/new value of K 16 T i was used in the tag identification phase. Upon a successful authentication of the tag, the reader calculates its authentication token D :
D  X  PRNG  X  N T i RND R i RND T i EPC 16 T i RND 0 T
Updating phase : The updating of internal values is a crucial step to stop attacks and to provide forward security. The updating phase is determined by the usage of old ( p  X  0) or new values ( p  X  1) in the identification/authentication phases. Specifically, the following equations define the updating phase: If p  X  0 If p  X  1 Finally, the reader sends D to the tag.

Step 4: After receiving D , the tag computes a local version D * of the authentication token. If D *  X  D , the reader is authenticated and the mutual authentication process is completed. Moreover, the tag has confirmation that the reader received and correctly deciphered the second nonce  X  used in the updating phase. That is, the reader and the tag have confirmation of being in a synchronized state and share the same fresh updating material  X  RND T i  X  . Finally, the tag updates its internal values:
N 16 T i  X  PRNG  X  N 16 T i RND 0 T
K 16 T i  X  PRNG  X  K 16 T i RND 0 T (
Summarizing, in this Section we have introduced a new protocol compliant with the EPC-C1G2 standard, inspired in the time-tested
ISO/IEC 9798. Nevertheless, some minor changes were introduced to ensure the privacy of tag X  X  holders. The static identifier of a tag is anonymized and securely transmitted in an identification token ( B ).
In fact, three random numbers are linked to each session and at least one of these nonces is used in each message computation guaranteeing the freshness and u nlinkability of the transmitted messages. The key updating phase p rovides forward security and makes the cryptanalysis of Azumi much harder. Finally, and as a countermeasure against DoS attacks, the old and potential new values of N 16 T i and K 16 T i are both stored in the reader.
We emphasize here that the security of Azumi resides in the primitive used as checking function. We use here a 16-bit PRNG because it is the only cryptographic primitive supported on Gen-2 compliant tags  X  standard cryptographic is far above the capabil-ities of this kind of tags. So the tokens exchanged in the protocol are of length 16 bits. In a brute force attack or exhaustive key search, the attacker repeatedly checks all possible keys until a success is detected (i.e. the correct key is found). The resources required for a brute force attack scale exponentially with increas-16-bits, so the security level offered by a token  X  considering that the attacker does not know any weaknesses in the checking function and uses a brute force attack  X  is upper bounded by (1 = 2 16 ). In Azumi , the tag sends an authentication token ( A ) and an anonymized version of its static identifier ( B ). Assuming independence between the authentication and the identification token, and taking into account that the bit length of both tokens is 16, the security level against tag impersonation is thus upper nation, the scheme offers a lower security of (1 = 2 16 ) because the reader only sends D as an authentication token.

The reader should note here that the security of the Azumi protocol is inherently limited by the conformity with the standard and not by the design proposed. We are aware that using a 16-bit key length  X  as in the tokens  X  is far away from the requirements of standard cryptography ( ECRYPT, 2010 ), where a key length greater than 80-bits is generally demanded. Nevertheless, in this protocol the compliance with EPC-C1G2 standard is an essential requirement. 7. Conclusions EPC-C1G2 is one of the most important standards related to RFID technology. In fact, it seems to have become the de facto standard for low-cost RFID tags. Because of its weak security, many authors have proposed enhanced schemes within the EPC framework. However, all these schemes have proven to be as insecure as the standard ( Chien and Chen, 2007 ; Han and Kwon, 2009 ; Lim and Li, 2007 ; Peris-Lopez et al., 2009 , 2008 ). In 2009, a new mutual authentication protocol was proposed by Chen and Deng that claimed to offer better security margins. In this paper, the security of this scheme is scrutinized and we show how an attacker is able to impersonate a tag or a reader, to trace a tag, and even to launch a DoS attack. These security vulnerabilities are all due to the use of the CRC function and take advantage of its linearity. Furthermore, the DoS attack is possible due to the lack of resistance against active attacks of the exclusive-OR operation. Finally, we additionally show how the protocol has non-trivial implementation difficulties because of the length of the involved variables, which is not compliant with that of the standard.
After the analysis of CD-EPC, we propose a new scheme attempt-ing to avoid the security deficiencies of its predecessors. The protocol is based on well-known cryptographic techniques (ISO/IEC 9798). Moreover, the compatibility with the standard is guaranteed as only the 16-bit PRNG and XOR operations are involved. Therefore, Azumi offers a better security level and may be integrated in any EPC-C1G2 compliant tag without any modification.
 Acknowledgments
We want to thank the anonymous reviewers that helped a lot on improving the quality of this paper.
 References
