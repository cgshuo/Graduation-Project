
In this paper, we propose that various keyword-based queries be processed over XML streams in a multi-query processing way. Our algorithms rely on parsing stacks designed for simultaneously matching terms from several distinct queries and use new query in-dexes to speed up search operations when processing a large number of queries. Besides defining a new problem and novel solutions, we perform experiments in which aspects related to performance and scalability are examined.
 H.2 [ Database Management ]: Miscellaneous Algorithms, Performance, Experimentation
Keyword-based Queries, XML Streams
As the Web continues to grow in size and complexity, users tend to focus their attention to on-the-fly updates (such as news and RSS feeds) rather than on archived information. In this context, XML is the standard for many of such applications, which usually employ XML dissemination techniques. Such techniques involve two distinct tasks: filtering of documents according to the users X  information needs [2, 7], and routing matched documents to those users [4, 12]. Instead of evaluating queries over stored data, the system must evaluate queries over streams of documents.

In such a context, users describe their needs in profiles composed of one or more queries. Without loss of generality, in this paper, we abstract the concept of profile and refer to each query individually. Queries are usually specified with XML query languages, such as XQuery and XPath, which allow querying on both the data structure and data values using predicates with exact semantics. Therefore, users formulating queries must have some knowledge of the XML documents that compose the stream.
 Copyright 2011 ACM 978-1-4503-0717-8/11/10 ... $ 5.00.
 However, within the Web environment, it is common to have XML documents storing values in a textual format. This makes the retrieval of (text) values based on predicates with exact semantics extremely difficult, aggravated by the existence of many disparate data sources. Even for applications with few sources, given the lively nature of the Web, new sources can come and go anytime. Hence, in order to retrieve the desired information, users have to know (1) the exact structure of the documents provided by each data source and (2) the exact values represented on the textual contents.
An alternative approach to using XML query languages is to employ more intuitive keyword-based queries [5, 6, 10]. The main advantage of this approach is to allow users with disparate interests posing queries in an informal way, without caring about document structure or schema anymore. However, only very recently, this approach was adapted to the context of XML streams, where there is no document storage, pre-processing, statistics, or indexes avail-able [11].

Using keyword-based queries can solve the problems of knowing the structure and using exact predicates, but a third problem arises in the stream context: there is a large number of users and documents flowing on the Web. Here, processing one query per document traversal or one query per stream (as in [11]) is not efficient. Ideally, we would like to process multiple queries over one single traversal of each document on the stream. Finally, even though such an idea is employed for XPath-based queries over streams [12], there is no work on multiple query processing over XML streams with keyword-based semantics .

Thus, in this paper we tackle a novel and very relevant problem: processing multiple keyword-based queries over XML streams . We propose two new algorithms for simultaneously processing several keyword-based queries over XML streams. They rely on parsing stacks and query indexes specially designed to allow the simultane-ous matching of terms from different queries. We present experi-ments in which aspects concerning performance and scalability are examined and discussed. The results show that our algorithms are effective on processing thousands of queries in a single pass over XML streams.

Next, we discuss related work (Section 2), introduce our multi-query procedure (Section 3), describe our two new algorithms (Sec-tion 4) and our experiments (Section 5), and then present our con-clusions (Section 6).
XML Keyword Search . Using keywords to query XML databases has been extensively studied. XSEarch [3] adopts an intu-itive concept of meaningfully related sets of nodes based on the rela-tionship of the nodes with its ancestors (on the graph). XRANK [5] presents an adaptation of Google X  X  PageRank to XML documents for computing a ranking score for the answer trees. XSeek [6] pro-poses a query processing strategy over the notion of entities inferred from DTDs. The aforementioned approaches work on stored XML databases. The work in [11] and [1] took the first steps towards processing keyword-based queries over XML streams . Specifically, [11] adapts two traditional algorithms for keyword-based queries over streams and [1] performs their experimental analysis. However, those algorithms evaluate queries in a single-query fashion (i.e., one query per time over the stream).

XML Streams . Recent research on XML streams (dissemination, filtering and routing) has aimed at building large-scale, distributed systems [2, 4, 7, 12]. Most of those are concerned with performance aspects and optimize the filtering process [2, 7], the message deliv-ering and the routing network [4, 12]. We focus on two different facets: (1) improving the flexibility of query specification and (2) alleviating users dependency on possible schema details of multiple document providers. Both facets are guaranteed by using keyword-based queries to express the user X  X  intentions. In order to deal with multiple XML schemas, two approaches are very common: to apply query rewriting [13] and to use global schemas [8]. Using keyword-based queries over XML streams frees the user from knowing the (possible multiple) source schemas. As a consequence, there is no need for mediators, rewritings or global schemas.
This section details the types of query considered in this work and gives an overview of our multi-query procedure as well as of the data structures used.
 Current approaches for processing keyword-based queries over XML data consider queries that specify constraints on the textual content or on both the textual and the labels of each XML element. Thus, we assume a simple keyword-based query language, with syntax borrowed from [3] and [11], defined as follows.

A keyword-based query q over an XML document stream is a list of query terms (also denoted search terms)  X  t 1 , . . . , t query term is of the form: ` ::k , ` :: , ::k , or k , where ` is an element label and k a keyword. A node n within a document d satisfies a query term of the form: ` ::k , if n  X  X  label is equal to ` and the textual content of n contains the keyword k ; ` :: , if n  X  X  label is equal to ` ; ::k , if the textual content of n contains the keyword k ; k , if n  X  X  label is equal to k or the textual content of n contains the keyword k . We also assume that the keyword-based queries are evaluated against documents using the well-known SLCA semantics 1 .

To illustrate our query language, consider the following query specifications:
Table 1 presents possible keyword-based query formulations that fulfill these query specifications 2 . These keyword queries were intentionally built to illustrate our algorithms and are targeted to streams containing book releases. Moreover, they illustrate different scenarios regarding the user X  X  knowledge about the XML labels. In
Actually, any other LCA-based semantics could also be used. Attributes can be easily handled with no significant overhead. queries q 1 and q 5 the user knows the labels and employs query terms of the form ` ::k , where each keyword k is qualified with a node label ` . In queries q 2 , q 3 and q 6 the user knows only some labels while in query q 4 the user has no knowledge at all (no labels are used). Notice that q 3 and q 4 are ambiguous, i.e., they may represent both requirements s a and s b . This is an inherent collateral effect of using keyword-based queries. Also notice that in query q term MP3 :: is an example of a pure structural condition where XML subtrees must contain an element with label MP3 .

Figure 1 describes our general multi-query procedure. A set of queries Q (from users X  profiles) are processed against a stream D of documents. Upon its arrival, each document d j in D is individually processed (Lines 3 to 6). The results found within this document are collected and returned (Lines 5 and 6). This is accomplished at the same time for all queries q i and results are individually collected in each r i . A result includes the full path and the Dewey Code [9] of the SLCA resulting node of d j , if any.

Each document d j in D is processed by a SAX parser, which generates five types of event for a document: startDocument() , startElement(tag) , characters(text) , endElement(tag) and endDoc-ument() . Our algorithms then work by means of SAX Callback Functions for those events. The parser is called to action in Line 5 of the procedure.
 Parsing Stack. As the SAX parser traverses the document in an in-order fashion, each visited node is associated with an entry in a stack S , which we call the Parsing Stack . Each entry is popped from the stack when its corresponding node and all its descendants have been visited. To support the recursive processing of a document, each entry in the parsing stack handles the following information: (1) the label of the element corresponding to the entry; (2) a bitmap called CAN BE SLCA , which contains one bit for each query q being evaluated (3) a set used queries containing the IDs of the queries whose terms include keywords present in the element (or its descendants), either as labels or as in values; (4) which keywords from these queries have occurred in the corresponding document node and its descendants.

Notice that, without loss of generality, we assume that labels are unique per type of element in each document. For instance, in one single document, the label Author is always used to represent a book author and not a paper author.
 Query Index. During the traversal of a document, it is necessary to look for keywords that occur in text elements or labels. As we expect to process a large number of queries, our algorithms rely on query indexes in order to avoid looking up each query individually. The indexing structures we use are adaptations of inverted lists. Each index entry represents a query term and refers to queries in which this term occurs, making a distinction between structural (label) and non-structural (value) query terms.

Notice that, as in any inverted list, query indexes are generated beforehand from the set of queries posed by users. Tackling new queries requires the query indexes to be rebuilt. This is a simple task that does not require any effort from users or developers. Moreover, it is reasonable to expect that the set of queries posed by users is stable, while documents keep arriving through streams.
Our proposed algorithms run as SAX callback functions on the general procedure described in Figure 1. The first one, KStream , employs one single bitmap for representing all queries being pro-cessed. The second one, CKStream , optimizes space consumption by compacting the bitmap representation. These algorithms are described next. 4.1 KStream Algorithm
Before describing KStream , we present the main data structures it uses. Information about which keywords from each query have occurred in an XML node (and its descendants) is kept using a bitmap stored on the stack entry corresponding to such a node. This bitmap is called query bitmap and each of its bits is associated with one search term from each query q i . When the corresponding term occurs in the current node (or in its descendants), this bit is set to true . For example, considering the queries in Table 1, Figure 2 illustrates the query bitmap used by KStream when processing those queries. In this figure, each cell q i,j refers to the j -th term of query q i . The size of the query bitmap is equal to the number of terms in all queries.

While processing a node, the query bitmap is built based on information of which queries mention keywords occurring in labels or values present on such a node. This information is kept on a query index . In KStream , this index comprises inverted lists, in which entries refer to bitmaps. As illustrated in Figure 3, for each keyword entry in this index, two bitmaps with the same size of query bitmap are used. The first, labels bitmap , keeps track of terms related only to labels ` , (i.e., ` :: and ` ), while the second, values bitmap , handles occurrences of terms related only to values k (i.e., ::k and k ). Each bit associated with an occurrence of a term is set to true (these bits are grayed in the figure). Search terms of the form ` :: k are treated differently, and their inverted lists use a single bitmap for the same purpose. An auxiliary indexing structure is used to speed up the search for queries that contain a certain term.

KStream consists of three callback functions, each one for a distinct event. Function KStream.Start handles starElement events, KStream.Text handles characters events and KStream.End han-dles endElement events. These functions are presented in Figure 4. In function KStream.Start , a new stack entry is created to han-dle the current XML node. For this entry, the CAN BE SLCA bitmap (Line 5) and the query bitmap are initialized (Line 8). While CAN BE SLCA bits are set to true , bits in query bitmaps are set to false . Then, the algorithm searches the query index for queries in which the label of the node being processed occurs in search terms of types ` :: and ` (Line 11), to retrieve from the query index the bitmap that tracks the occurrences of the label ` in queries, if any. The matching queries are marked by a bitwise or operation between the labels bitmap ( m bitmap ) from the inverted list and the query bitmap in the stack entry (Line 14). Notice that all queries used in this step have their references added to the used queries set. This way, the callback function KStream.End only needs to check these queries, instead of the whole set of submitted queries.
In function KStream.Text , for each keyword found in the text (Line 3), it searches the query index for queries that contain any of these keywords (Line 7). Next, a bitwise or operation is performed between m.values bitmap from the inverted list and query bitmap in the stack entry (Line 10). However, this time, the function looks in the index for search terms of types ` ::k , ::k and k .
Finally, function KStream.End pops the current entry sn out of the stack and creates a reference to the new top entry on the stack tn (Lines 1 and 2). Notice that this new top entry tn corresponds to the parent of the XML node whose entry stack sn was just popped out. Moreover, this function needs to propagate the information stored in sn to tn . Specifically, this propagation involves: performing an and operation between sn and tn CAN BE SLCA bitmaps (Line 3), adding all queries from the sn used queries set to the tn used queries set (Line 4), and updating the query bitmaps from tn according to query bitmaps from sn to keep track of which queries match with its corresponding XML node (and its descendants), which is done by an or between the bitmaps of the used queries on the popped entry and the corresponding bitmaps (i.e., relative to the same queries) in the top entry (Line 5).
Function KStream.End is also responsible for checking whether the node corresponding to the popped entry sn is to be added to the set of results of some query q ( q .results ). For this, two conditions must be satisfied (Line 10). First, all terms in the query must be present in this node, or in some of its descendant nodes. In this case, we say that the query is complete . This is verified by computing an and over the bits in sn.query bitmap that correspond to each specific query (Line 9). Second, the document subtree rooted at the node corresponding to sn must satisfy the SLCA semantic for the query. This is verified by using the bit associated to this query in the CAN BE SLCA bitmap. Recall that this bitmap is also recursively constructed considering the CAN BE SLCA bitmap of the descendant nodes (Line 3). If these conditions are satisfied, the node is added to the set of results of the query q . Also, tn.CAN BE SLCA[ q ] is set to false to indicate that none of its ancestors can be an SLCA result, since this node already is (because it is lower than any of its ancestors). 4.2 CKStream Algorithm
CKStream was designed for condensing redundant information on search terms occurring in more than one query. In KStream , we use N bits to represent the same search term in N different queries. Instead, CKStream uses only one bit for each distinct search term in all queries. Thus, each stack entry includes a different configuration for the query bitmap , in which a bit is associated with each distinct query term. Figure 5 illustrates the query bitmap used by CKStream when processing the queries in Table 1.
As a consequence, in the query index the entry corresponding to a term t needs only to store the position of the bit corresponding to this term in the query bitmap , as illustrated in Figure 5.
Like KStream , CKStream also uses an auxiliary index to speed up the search for queries that contain a certain term.
 Functions CKStream.Start , CKStream.Text and CK-Stream.End are presented in Figure 6. CKStream.Start searches the query index for the current node X  X  label ` , obtaining the positions associated with the entry corresponding to this label (Line 9). Then, it sets to true the bit position associated with this occurrence in the query bitmap of the new stack entry (Line 13). Similarly, CKStream.Text searches the query index and sets true to the corresponding bits. Notice that terms of the form ` :: k are handled in this function and receive a specific treatment.
Finally, CKStream.End looks for complete queries, i.e., those in which all search terms are satisfied by the node being processed (or by its decedents). The main distinction from KStream.End is that the bits corresponding to query terms are not necessarily contiguous in sn.query bitmap . Hence, it requires the position of the bits corresponding to search terms used in each query to be known. This is accomplished by using an auxiliary structure, which is built with a single pass over all queries. Building the auxiliary structure happens simultaneously with the construction of the query index .
We now report experiments that consist in processing streams of XML documents against all posed queries simultaneously and measuring the time spent and the memory consumption. In the first experiment, we analyze how the algorithms handle an increasing number of keyword-based queries. In the second one, we observe the behavior of the algorithms as the number of search terms in each query increases. 5.1 Setup
The algorithms were implemented using Java and the SAX API from Xerces Java Parser. The query indexes and other data structures are kept entirely in memory. All experiments were performed in an Intel Dual Core 2.0Ghz computer with 3 GB of memory on Linux.
Three distinct datasets were used: (1) ICDE  X  metadata from papers published in the proceedings of the ICDE conference, ex-tracted from DBLP; (2) ISFDB 3  X  bibliographic data from fiction books available on the ISFDB Web site; (3) SIGMODR  X  data from http://www.isfdb.org the table of contents of SIGMOD Record issues. We organized the data on ICDE papers by year of publication into a stream of 14 different XML documents, from 1995 to 2008. Similarly, in ISFDB, we separated books published between 2000 and 2009 into a stream of 10 different XML documents. Finally, we organized SIGMODR into as stream of 18 XML documents, each containing data from a single issue. Details on the three datasets are presented next in Table 2.

SIGMODR has the deepest documents. In ISFDB and ICDE, most book and paper elements are flat. Regarding the number of distinct elements, notice that elements that have different full paths from the root node are considered distinct. ISFDB dataset has the largest XML documents. Hence, this stream has much more objects and elements than the other two. Furthermore, although ICDE has, on average, more elements than SIGMODR, the latter has more sub-trees that characterize objects.

We randomly generated sets of queries using data from each dataset. For example, using data from ISFDB, the following query could be generated:  X  Author :: jose :: saramago Title :: blindness  X . De-pending on the experiment, we generate different sets of queries by varying the number and the type of terms to appear in the queries.
We measured, for each dataset, the time spent for processing all XML documents on a given stream. This excludes the time spent to create the query indexes, which is done only once when the operations start. Similarly, we measured the average memory usage while processing each XML document. 5.2 Varying the Number of Queries
We here analize how the algorithms handle an increasing number of queries. We use as a baseline a simple multi-query extension of the algorithm proposed in [11], which processes a single query over XML streams. Like in the original proposal, in this baseline, each element of the stack has one bitmap for each query. However, in order to allow multi-query processing, a query index is used to speed up the search.

We submitted up to 40 , 000 queries, each with up to 4 terms. We observed (in preliminary experiments) that searching for keywords in node values (e.g., ` ::k , ::k or k ) presents no performance impact when using one type of query over the other. Hence, this experiment includes only query terms as ::k . Figure 7 presents the comparison of time and memory spent by the algorithms over each of the datasets. The time curves show a clear advantage of KStream and CK-Stream over the baseline. Both use a single bitmap for simultane-ously matching terms of several queries against data on the nodes, whereas the baseline algorithm represents each query by an spe-cific bitmap. Comparing the three datasets, the time performance in ISFDB is uniformly worse. This is explained because the documents in this dataset are larger, i.e., there are more nodes that need to be processed. Also, the performance of the algorithms over the ICDE dataset is slightly better than their performance over the SIGMODR dataset. This is due to the number of nodes that satisfy the queries, which is larger in SIGMODR than in ICDE.
 Regarding memory consumption, the better performance of KStream pays the price of poor memory usage in comparison with the baseline and CKStream . This is due to the large bitmap structures allocated for each entry in the query index. Indeed, due to such a structure, KStream memory usage increases quadratically to the number of query terms. On the other hand, the baseline and CKStream have similar memory performance. 5.3 Varying the Number of Terms
Here, we aim to verify how our algorithms scale with the number of distinct terms, since this is an important factor in both time and space consumption. The experiment compares the impact of using queries with 2 , 4 and 6 terms. We argue that 6 is a reasonable limit for the number of terms one typically uses when specifying a query. For each algorithm, we submitted an increasing number of up to 40 , 000 queries. In here, queries use only terms of the form ::k . Figures 8 and 9 present, respectively, the comparison of time and memory spent by each algorithm over each of the datasets.
As expected, the performance is affected by the increase in the number of terms. This effect is even bigger in the ISFDB dataset, whose documents have more nodes. Nonetheless, both KStream and CKStream scale well with the number of queries and the num-ber of query terms, even considering that their space and time per-formances have some degradation. Specifically regarding memory usage, again as expected, KStream suffers a larger impact than CKStream due to the increasing of the number of terms.
In this paper, we introduced the problem of processing multi-ple keyword-based queries over XML streams and proposed two new algorithms for addressing it. We performed comprehensive experiments to demonstrate their behavior regarding memory usage and processing time. The results show that both algorithms have a similar behavior in terms of processing time, although KStream performs slightly faster than CKStream . Regarding memory con-sumption, KStream excessive costs may be an impediment for its use in some cases. On the other hand, CKStream offers a good compromise between performance and memory usage, which makes it the best choice in real world scenarios.
 Acknowledgments. This work was partially funded by CNPq, CAPES and FAPEMIG, Brazil.
