 Search engines can improve their efficiency by selecting only few promising shards for each query. State-of-the-art shard selection algorithms first query a central index of sampled documents, and their effectiveness is similar to searching all shards. However, the search in the central index also hurts efficiency. Additionally, we show that the effective-ness of these approaches varies substantially with the sam-pled documents. This paper proposes Taily, a novel shard selection algorithm that models a query X  X  score distribution in each shard as a Gamma distribution and selects shards with highly scored documents in the tail of the distribution. Taily estimates the parameters of score distributions based on the mean and variance of the score function X  X  features in the collections and shards. Because Taily operates on term statistics instead of document samples, it is efficient and has deterministic effectiveness. Experiments on large web col-lections (Gov2, CluewebA and CluewebB) show that Taily achieves similar effectiveness to sample-based approaches, and improves upon their efficiency by roughly 20% in terms of used resources and response time.
 H.3.3 [ Information Storage and Retrieval ]: Search pro-cess Distributed Retrieval, Database Selection
For large collections, search engines have to shard their index to distribute it over multiple machines. Search effi-ciency can be further increased by shard selection, that is, by querying a small number of promising shards for each query [5]. An important research challenge in this domain is the definition of shard selection algorithms that have to ad-dress the following two issues. First, selective shard search should be more efficient than searching all shards, and sec-ond, selective shard search should be as effective as searching all shards. In this paper, we investigate the tradeoff between efficiency and effectiveness of sharded search. We propose Taily, a new shard selection algorithm that represents shards by using parametric distributions of the document scores for a query. Taily is much more efficient while showing similar effectiveness, as compared to an exhaustive search.
State-of-the-art shard selection algorithms use a central sample index (CSI) that contains randomly selected docu-ments from each shard [21, 22, 14]. The algorithms use the results of an initial search against the CSI to select the shards to be used in a second, sharded search. In the liter-ature, the efficiency of shard selection algorithms is usually measured by resources used in the sharded search. In this paper, we argue that efficiency measures should also con-sider the resources spent during the initial search on the CSI, which can be substantial. For example, a common sample size in the literature is four percent [14], which results in a CSI that is bigger than an average shard once there are more than 25 shards. Searching a CSI that is as large as the average shard uses a considerable percentage of the re-sources required. For the common case that the algorithm selects two shards, the initial search uses roughly one third of the resources required for answering a query. In our ex-periments we show that our algorithm is more efficient than current sample-based methods, especially when also consid-ering the resources of the initial search, while maintaining similar effectiveness.

Although the query response time is seldom investigated in the shard selection literature, it is often considered more important than the used resources, which are relatively cheap nowadays [9]. Whereas the search in a CSI can use a substan-tial amount of the total resources, the influence of its execu-tion time on the total query response time can be more se-vere. In the above example, the initial search would roughly double the response time, assuming the parallel execution of the sharded search. We show that Taily X  X  improvement over the query response time of current shard selection algo-rithms is particularly strong.

One aspect of sample-based methods that has not been studied so far is the effect of the particular random sample in the CSI on the search effectiveness. One might expect that, if samples are truly random and sufficiently large, different random samples would produce stable effectiveness of the search system in terms of precision or nDCG. We show in this paper that this expectation does not hold in practice. As we show in Section 5, different sample sizes of up to 4% of each shard, lead to substantially different effectiveness of the sharded search system. We believe that this variation in effectiveness is a drawback of the sample-based methods tested in this paper.

Like Kulkarni et al. [14] and Arguello et al. [3], Taily is used on clusters of machines in a cooperative search envi-ronment. Taily selects one or more shards by estimating the number of documents of a shard that are highly scored in the collection, which we model by the right tail of the score distributions in the collection and the shards. The basic idea of this approach has been proposed by Markov [15]. To estimate these score distributions, we follow the approach by Kanoulas et al. [12], who derive score distribu-tions from statistics of features related to a query X  X  terms (e.g. a term X  X  language model score). Being based on statis-tics for each term in a vocabulary, Taily belongs to the class of vocabulary-based selection algorithms, which are often biased to larger shards and often show weaker performance than sample-based methods. Our contribution to the shard selection literature are threefold: first, experiments show that its effectiveness is similar or stronger than the effec-tiveness of sample-based methods, second, compared to a search in a CSI, its processing of feature statistics is more efficient, and results in a lower number of resources used in total and a faster query response time, and finally, compared to sample-based methods, the efficiency and effectiveness do not depend on the size or the sampled documents in a CSI.
The remainder of this paper is structured as follows. Sec-tion 2 describes related work on shard selection. Section 3 elaborates on Taily X  X  shard selection algorithm. Section 4 defines the measures that we used to compare our method to state-of-the-art algorithms. Section 5 describes the exper-iments that we conducted to explore the performance of our search method. Section 6 concludes this paper.
In this section, we present shard selection algorithms from two classes that are most related to this work. Note that there is also a significant number of works on other ap-proaches to shard selection. Because of space limitations, we refer the interested reader to Kulkarni et al. [14] where a more exhaustive list of related work is presented.
Most of the early shard selection algorithms are vocabulary-based: they represent shards by collection statistics about the terms in the search engine X  X  vocabulary. The popular CORI algorithm by Callan et al. [6] represents a shard by the number of its documents that contain the terms of a vocabulary. The shards are ranked using the INDRI version of the tf  X  idf score function using the mentioned number as the frequency of each query term. CORI selects a fixed number of shards from the top of this ranking. Xu and Croft [23] build upon this approach by representing them by topical language models. The shards are ranked by the Kullback-Leibner divergence between the language models of the query and the topics. CORI and the algorithm by Xu and Croft characterize a shard by statistics over all its documents. We propose that shard selection algorithms should focus on documents with high scores because they contribute most to the system X  X  effectiveness. The gGloss algorithm by Gravano and Garcia-Molina [10] selects shards based on the distribution of the vector space weights, which we refer to as features values. They assume that the dis-tribution of the features is uniform. The algorithm ranks a shard by its expected score value calculated from the expec-tation of all feature values for a query. In this paper, we also consider the expected score, which we also infer through the expected feature values of the query terms. However, un-like the gGloss algorithm, we assume a gamma distribution of the score instead of a uniform distribution, and focus on the tail of the distribution, which contains the highly scored documents.

Algorithms from the second main class of are called sample-based algorithms because they use a central sample index (CSI) of documents from each shard for shard selection. The REDDE algorithm [21] ranks shards according to the num-ber of the highest ranked documents that belong to this shard, weighted by the ratio between the shard X  X  size and the size of the shard X  X  documents in the CSI. The SUSHI algorithm [22] determine the best fitting function from a set of possible functions that between the estimated ranks of a shard X  X  documents in the central index and their observed scores from the initial search. Using this function, the al-gorithm estimates the scores of the top-ranked documents of each shard. SUSHI selects shards based on their esti-mated number of documents among a number of top-ranked documents in the global ranking. REDDE and SUSHI as-sume that a shard X  X  documents in the CSI are at equidistant ranks in the ranking of the shard. We believe that this as-sumption may be too strong because the actual ranks vary widely depending on the randomly sampled documents in the CSI, as we found in preliminary experiments. Kulkarni et al. [14] present a family of three algorithms that model shard selection as a process of the CSI documents voting for the shards that they represent. The vote of a shard is the sum of the votes of its documents. The algorithms select shards that have an accumulated vote higher than 0 . 0001. The three algorithms differ in how they model the strength of a document X  X  vote. In the most effective method Rank-S, the strength of the votes is based on the score from the ini-tial search and decays exponentially according to the rank of the document in this ranking. The base of the exponential decay function is a tuning parameter of the model.
The shard selection algorithm proposed in this paper is vocabulary-based. However, instead of considering all docu-ments in a shard for ranking, it selects shards based on the highly scored documents of a shard similar to the described sample-based methods.
Before formally introducing our shard selection algorithm in this section, we will explain our reasoning and the intu-ition behind it.
Abstracting from sharded search, a search engine uses a score function that assigns each document in the collection a score. The documents are then ranked based on that score, and for most effectiveness measures, the top-ranked docu-ments are the most influential. Now, a shard selection al-gorithm has to identify those shards whose documents can be left out from the complete ranking without hurting the effectiveness. We therefore design our shard selection algo-rithm to leave out shards with no or only few documents in the top of the complete document ranking. The number of considered top-ranked documents can vary depending on the search scenario. Our algorithm therefore considers a number of n c highly scored documents. Expressed differently, these documents are the right tail of the collection X  X  score distribu-tion in response to the given query, and hence we name our shard selection algorithm Taily. Figure 1a shows the score frequency distribution of the query 843 pol pot in the Gov2 collection using language model scores. A search engine may want to preserve, e.g., n c = 100 top-ranked documents. For our example, this corresponds to the documents that are as-signed a language model score of  X  14 . 6 or higher for this query.

The more accurate our model is in the right tail of the score distribution, the more accurate we can expect our shard selection to be. Score distributions are typically dom-inated by low scores of documents that contain no or only few of the query terms. We do not expect that the tail of these score distributions can be accurately modeled. Instead, we model the score distribution of documents that contain all query terms, which include the top-ranked documents for most queries and empirically leads to a better fit of the right tail, see Figure 1b.

Taily selects shards based on the number of documents with a score above the cut-off score of the top-n c documents. To estimate this number, Taily fits the score distribution in each of the shards, from which the probability of a document in this shard with a score above that cut-off point can be readily calculated. Because shards differ in size and abso-lute numbers of high-scoring documents, a shard with a low right-tail probability might still have a reasonable number of documents with scores above cut-off. We therefore also estimate the total number of documents that participate in the considered score distribution and select shards based on the expected number of documents that are above the cut-off score. For example, Figure 1c shows the empirical and fitted score distribution 1 of the shards 19 and 41 of topical shards
Note that Fig. 1 displays histograms with absolute frequen-cies. The fitted lines are the estimated density functions (based on the Gamma distribution), rescaled by the total number of documents included and its bin width, in order to allow visual comparison with the histograms. generated by Kulkarni and Callan [13]. Most documents in the selected tail of the collection X  X  score distribution belong to shard 41. Therefore, Taily prefers shard 41 over shard 19 forthisquery.

A popular way to estimate score distributions is to use scores of document samples from the top of the ranking [1]. However, because we avoid the use of a central sample in-dex, this type of methods is not applicable here. Instead, following Kanoulas et al. [12], we infer the query dependent score distribution from query independent feature distribu-tions that are summed in the score function. The parameters of the feature distributions form Taily X  X  shard representation, which can be calculated offline.

In the following, we develop the Taily algorithm more for-mally. Section 3.2 introduces the used score function and Section 3.3 describes the statistics that form Taily X  X  shard representation. Section 3.4 shows how these statistics are used to estimate the parameters of the score distributions for the shards, and for the whole collection. Section 3.5 de-scribes how the number of documents with all query terms in the whole collection and per shard can be estimated. Us-ing the estimates for the score distribution and the number of documents, we define Taily X  X  shard selection criterion in Section 3.6.
We use the following notation throughout this paper. Quer-ies and documents are denoted by lower case q and d respec-tively. Sets of documents are denoted by D , and particular set is indicated by a subscript. In particular, let D c be the set of documents in the total considered collection, and let D , ..., D N be the sets of documents of the N shards of this collection. We often refer to either the set of documents in the collection or the shards, for which we use the subscript i . Terms are denoted by lower case t , the query terms of aquery q are denoted by q . The length of document d is denoted by dl ( d ), the frequency of term t in document d is written c ( t, d ), and the number of documents from set D that contain term t at least once is given by c ( t, D i ).
Taily infers a query X  X  score distribution from the distribu-tions of the features that constitute the query X  X  score func-tion. In general, our algorithm can be used with any score function that is a weighted sum of term-related feature val-ues. Note that we consider score functions independently from their theoretical motivation. To facilitate experiments, which require a particular score function, we focus in this paper on the query likelihood model, as implemented in the Indri search engine 2 . The query likelihood model uses for a term t in a document d a term feature f t ( d ), which is defined as follows:  X  is the Dirichlet smoothing parameter. Note that the term features in (1) are query independent. The score function s ( d )ofadocument d for a query q is a sum of the features for the query terms: In this paper we focus on score functions based on features that are related to a single query term. In future work, we plan to extend Taily to capture multi-term features such as ones used in the full dependency model [16], priors such as PageRank or spam scores, see [19] for a possible integration of these features into score functions.
In order to infer the score distributions in shards and the collection, we represent each of them by the distribution parameters of term features. The main statistics of a feature f for term t in document set D i are the expected value E [ f t ] and the variance var i [ f t ] of the feature, which can be calculated as follows: where E i [ f 2 t ] is the expected squared feature value. These quantities can be calculated by a single scan through the collection.

The language model score function used in this paper pro-duces negative values. However, the Gamma distribution that we use for the score function is defined for positive val-ues. To be able to shift the score distribution in the next section, we also store for each feature f its minimum value in the collection c :
The expected feature values from (3), the feature vari-ances in (4), and the above minimum values, form the rep-resentation used to calculate the score distribution in the shards and the total collection.
Given the shard representation described in the previous section, we derive the distribution parameters of the query specific score distribution. Because the score function used http://www.lemurproject.org/indri/ in this paper produces negative scores, we instead consider a score distribution that is shifted by its minimum value, similar to Arampatzis et al. [2]: To keep our notation lean, we continue using s instead of s for the score function, keeping in mind that it is now positive defined. For a document set i , the expected score E i [ s ]and the score variance var i [ s ] can be derived from the definition of the score function in (2) where f q is the feature vector of the query terms in (2), and f j is the j th feature in this vector. Equation 6 uses the simplifying assumption that the sum of covariances is zero. Note that we verified the validity of this assumption by repeating our experiment taking covariances into account, which did not result in a significant increase in effectiveness.
According to Kanoulas et al. [12], the distribution of lan-guage model scores is gamma distributed. The parameters of the distribution in document set i can be derived from the expected score and the variance by using the method of moments: where we used the definition of these parameters. Having the parameters k i and  X  i for a document set i , we can define its cumulative score distribution function, which yields the probability of documents having a score greater than a score s in a document set i : 3 where X istheGammafunction,  X  is the incomplete Gamma function, and k i and  X  i are the distribution parameters de-fined above. For the case of the whole collection and the example introduced previously, the values of the cumulative distribution function can be visualized as the percentage of documents with a higher score than  X  14 . 6inFigure1c.
To make the probabilities from the cumulative density functions comparable, Taily uses the number of documents with all query terms in this set. To reduce the strength of assuming independence between the occurrence of query terms [7], we first estimate the number of documents that contain at least one any query term Any i in a document
Note that cumulative distributions are usually defined in terms of the probability in the left tail. We differ from this practice because it simplifies the mathematical formalism used to describe Taily. set i : documents in document set i that have none of the query terms. Among the Any i documents that contain at least one query term, we estimate the number of documents that contain all query terms All i by assuming independence of the term occurrences: where c ( t j , D i ) /Any i is the probability that a document with term t j appears in the documents in D i that have at least one of the query term.

Our experiments show that this estimate produces strong and stable results. Important to note here, is that we want an efficient and lightweight algorithm, also during the pre-processing stage. Therefore, even for two-term queries, in-stead of counting the mutual term occurrences, quadratic in the vocabulary size, we estimate these based on the single-term occurrences.
Given the cumulative score distribution cdf i and estimated number of documents that contain all query terms All i for both the whole collection and each shard separately, we de-fine Taily X  X  shard selection criteria. Based on our intuition in Figure 1, we first estimate the cut-off score of a fixed num-ber of top-ranked documents in the collection that at least should be in the sharded ranking. Let this number be n c , which is a parameter of Taily. The probability of a document in the collection to be among the top-ranked documents can be calculated as: where All c is the estimated number of documents in the collection with all query terms. The cut-off score s c of the top-n c documents can be estimated using the inverse of the cumulative density function: s c = cdf  X  1 c ( p c )where p probability defined above.

Using the score distribution in a shard i , we can calculate the probability that a document in this shard has a score higher than the cut-off score s c : p i = cdf i ( s c ). The number of documents in shard i that have a score above s c , written n , can then be readily estimated 4 by n i = All i p i .Thenum-ber of documents in shard i with all query terms is a mere estimation (see (10)), and the sum of estimates All i for all shards not necessarily equals the overall estimate All c .Ex-perimentally, this appeared to introduce inaccuracies in the results. As the improvement of score distribution estimates is an ongoing research topic [1], we limit ourselves here to a simple solution. We assume that the estimation of the ex-pected number of documents in the collection n c is accurate
In fact, we estimate the number of documents that have ascoreabove s c and contain all query terms . This means that we assume that for the shards to be selected, most documents above cut-off contain all query terms. Experi-mentally, this appears to hold if s c is reasonably high, see e.g. Figure 1b. such that (11) holds. A suitably normalized estimate of n is hence where the term All i p i is the unnormalized number of doc-uments in D i above score s c and the right term is a nor-malization constant ensuring that the estimated number of documents above s c from each shard j add up to the cor-responding number of documents in the whole collection, which is n c .

We are now able to define Taily X  X  shard selection criterion sel ( q )foraquery q that selects shards with an estimated number of documents in the top-m above a threshold: where i is a shard index, and v is the selection threshold. Note that it can be beneficial for v to be higher than 0 because of the computational costs for including a shard with only very few estimated documents in the top ranks.
Before we can evaluate Taily, we have to define measures that quantify the efficiency of shard selection algorithms in terms of used resources and response time. To be compara-ble to related work, we base our measure on the measure by Kulkarni et al. [14], which calculates the resources used by a shard selection algorithm for a query q by the number of documents that the sharded search has to access: where sel ( q ) are the shards selected by the algorithm and D ( q ) is the number of documents in shard i that match at least one of the query terms q . As discussed in Sec-tion 1, the selection algorithm itself can require substantial resources, which should be reflected in the efficiency mea-sure. We therefore extend the above efficiency measure by a component that reflects the costs of executing the selec-tion algorithm. We arrive at our resource efficiency measure C RES ( q ) of a query q : where C R ( q ) is measure by Kulkarni et al. from (14), and C
SEL ( q ) are the costs for executing the selection algorithm for query q . The selection costs C SEL depend on the type of selection algorithm. For sample-based methods, we set the selection costs C SEL ( q )= CSI ( q ), where CSI ( q )isthe number of documents in the CSI that have at least one query term. For vocabulary based algorithms, we set C SEL ( q )= N ,where N is the number of shards in the collection, which is the upper bound of the number of entries in the shard representation for any query term.

Additional to the resource usage, the query response time is another important efficiency aspect to consider [18]. In contrast to the used resources, measures for the response time have to take into account that the selected shards are usually processed in parallel, once the selection algorithm has finished. For the search in the selected shards, the costs therefore mainly depend on the shard with the most match-ing documents. Similar to the methodology in the evaluation of database systems, we measure the response time by the and Y is the standard deviation. TB=terrabyte track, WT=web track.). number of accessed data items on the longest execution path (ignoring implementation dependent aspects): where 1 , ..., | sel ( q ) | are the selected shards and the other sym-bols carry the same definition as in (15). We report average values C RES and C TIME over a considered query set, similar to reporting the mean average precision instead of individ-ual average precision values. Note that the measures in this section consider the number of accessed items, which are doc-uments in shards or CSIs, and shards in vocabulary-based methods. Another choice would have been to consider the number of accessed postings for these items in the inverted files of the query terms.
In this section, we describe the experiments that we con-ducted to evaluate our shard selection algorithm Taily. We aligned our experiments to the ones from the recent publica-tion by Kulkarni et al. [14], to ensure comparability of our work to the state-of-the-art in shard selection. We proceed as follows: first, we describe the experimental setup, second, we describe each experiment and its results, and finally, we discuss the findings.
Table 1 describes the collections and query sets that we used. The collections represent modern retrieval collections of a medium to large size. We used the shards defined by the topical clustering algorithm by Kulkarni and Callan [13]. Due to spam, the effectiveness of the search on the full CluewebA collection of 500 M documents was weak. We therefore removed the documents whose spam scores were among the 50% highest scores according to the fusion method by Cormack et al. [8].

We implemented the experiments using the hadoop map-reduce framework, directly answering queries and generating statistics from the full text of the collection; similarly to the approach described in [11]. We used the Krovetz stemmer for both the document text and the queries. We did not use stopwording. For the exhaustive search and the searches in the central sample index (CSI), we used the full dependency model [16] with the parameter setting (0 . 8 , 0 . 1 , 0 . 1) for single term features, unordered term features and ordered term features respectively as recommended by Metzler et al. [17] and used in Kulkarni et al. [14]. The Dirichlet smoothing parameter was set to  X  = 2500.

We chose one baseline from each of the two classes of se-lection algorithms presented in Section 2. As a vocabulary-based algorithm, we used the popular CORI algorithm [6]. As a sample-based algorithm we chose Rank-S by Kulkarni et al. [14], which showed significantly stronger performance than REDDE [21] and SUSHI [22], two other state-of-the-art shard selection algorithms. Note that we added for Rank-S Figure 2: Sensitivity of Taily with n c =400 according to the threshold parameter v (as indicated in the plot). the minimum score of the score of the full dependency to make the scores positive. This was not reported by Kulkarni et al. [14] but it was important to achieve results compara-ble to the ones in the original publication. The documents for the central sample index used by Rank-S were uniformly sampled without replacement from each shard until a per-centage P of the shard X  X  size was reached. We ensured that each shard was represented by at least 100 documents. To rule out random effects, we repeated the runs with Rank-S 50 times, producing 50 CSIs with potentially different shards selections. Unless stated otherwise, the reported perfor-mance measures are the averages of the 50 repetitions. The average approximates the expected performance for a ran-dom CSI of this size. Note that performing statistical sig-nificance tests using these expected performance values is mathematically speaking problematic. We still report the results of these tests as an indication of the strength of the performance change. Note that Kulkarni et al. [14] use only a single CSI in their results. Therefore, their numerical re-sults do not necessarily correspond to ours.
 The size of the CSI can influence the performance of Rank-S. Unless stated otherwise, we used P =0 . 02 , 0 . 01 and 0 . 01 for Gov2, CluewebB and for CluewebA respectively. For Gov2 and CluewebB these settings resulted in a CSI that was roughly as big as an average shard in the respective collection. For CluewebA we chose P =0 . 01 because us-ing P =0 . 001, which corresponds to the size of an average shard, caused poor effectiveness.

We used the effectiveness measures precision at ten, thirty and hundred ( P @10, P @30, P @100), mean average preci-sion ( map ), and ndcg at ten ( ndcg @10). When we focused on a single effectiveness measure, we chose P @30 because it was more stable than P @10 for all selection algorithms but still reflected a precision oriented search task. To mea-tings of each method were used. CORI: n  X  X  2 , 3 } (higher values were always outside the limits of the x-axis), Rank-S: B  X  X  2 , 5 , 10 , 30 , 50 , 70 , 100 , 200 , 500 (lower values caused lower efficiency), Taily: n c  X  { 200 , 250 , 300 , 350 , 400 , 600 , 800 , 1000 , 1500 , 2000 sure efficiency, we used the resource efficiency C RES and the response time C TIME described in Section 4.
The threshold parameter v , defined in Section 3.6, speci-fies the minimum number of documents in the right tail of the collection X  X  score distribution that a shard should have to be selected. Figure 2 shows a sensitivity analysis of Taily towards changes of v by displaying the resulting P @30 and C
RES measures (here, we used a fixed tradeoff parameter of n c = 400 but the results were similar for other values of n ). The effectiveness of Taily was robust against changes of v , and increased slightly for Gov2. The parameter setting v = 50 caused efficiency and effectiveness around the me-dian of the tested values. We chose this parameter setting for the rest of our experiments.
An important characteristic of a shard selection algorithm is the tradeoff it provides between efficiency and effective-ness. A search engine operator may want to invest more resources to ensure high effectiveness, or to make more effi-cient use of resources and accept worse effectiveness. CORI, Rank-S and Taily each have a parameter that determines the tradeoff between efficiency and effectiveness. For CORI the parameter n states a fixed number of the highest ranked shards that are selected, second, Rank-S uses the parameter B that determines the influence of a CSI document on the selection of the shard it belongs to (see Section 2), finally, Taily uses the parameter n c that determines the number of top-ranked documents that should be included in the results of the sharded search.
 Figure 3 compares the tradeoff that CORI, Rank-S, and Taily provided in the indicated parameter range. The x-axes show the resource usage C RES or the response time C
TIME . The y-axes show the effectiveness in terms of preci-sion P @30.
 Figure 3a-Figure 3c show the tradeoff between C RES and P @30. For Gov2 the tradeoff is similar for CORI, Rank-S and Taily at low efficiency values. Rank-S and Taily pro-vide a similar tradeoff between effectiveness and efficiency over all parameter settings. For CluewebB the efficiency of CORI was always lower than the one of Rank-S and Taily. The effectiveness of Rank-S was lower than the one of Taily for a resource usage of C RES &lt; 60 , 000. With higher re-source usage, both methods had similar effectiveness. For CluewebA Taily showed a higher effectiveness than Rank-S until C RES =90 , 000.
 Figure 3d-Figure 3f show the tradeoff between C TIME and P @30. For Gov2 CORI performed similar to Taily. All pa-rameter settings of Rank-S had a larger response time than the ones of Taily. To achieve comparable effectiveness, the response time of Rank-S was roughly 15% larger than the one from Taily. For CluewebB CORI X  X  performance was low. Taily showed higher effectiveness than Rank-S until Method P @10 P @30 P @100 map ndcg @10 Shards C RES C TIME CORI (n=3) 0 . 57 0 . 48 0 . 36 0 . 25 0 . 48 3 . 00 . 71M 0 . 33M Method P @10 P @30 P @100 map ndcg @10 Shards C RES C TIME CORI (n=3) 0 . 25 0 . 24 0 . 16 0 . 13 0 . 21 3 . 00 . 90M 0 . 45M Method P @10 P @30 P @100 map ndcg @10 Shards C RES C TIME CORI (n=3) 0 . 20 0 . 17 0 . 11 0 . 06 0 . 14 3 . 01 . 46M 0 . 78M roughly C TIME =40 , 0000. For CluewebA CORI X  X  perfor-mance is again low. Compared with CluewebB the difference of Rank-S and Taily in terms of C TIME is larger. The results in Figure 3 show that the effectiveness of Rank-S varies with different settings of B , unlike the results by Kulkarni et al. [14] (their Figures 2 and 3) that suggest that the effectiveness of Rank-S is almost unaffected by the parameter. Because the particular sampled documents in the central indices used by Kulkarni et al. were not avail-able, we did not further investigate these differences. They might be explained by two important differences in the ex-perimental setup: first, we use a smaller CSI size ( P =0 . 02 and P =0 . 01 vs. P =0 . 04 by Kulkarni et al.), and second, we report the average performance over random samples, in-stead of results on a single sample.
We also investigated the effectiveness in terms of multi-ple measures at a fixed parameter settings. For CORI we chose a shard cut-off value of n = 3. Although larger values sometimes produced better effectiveness, the efficiency was too low to be comparable to Rank-S and Taily. We set the Rank-S parameter B = 50 for all three collections because Kulkarni et al. also used this value for CluewebB. For Taily we set n c = 400 and v = 50. The efficiency and effectiveness for these parameters is shown as larger points in Figure 3. We also display the performance for the exhaustive search, as a reference. For the displayed efficiency of the exhaustive search, we assumed a parallel search of all shards with zero costs for the selection (C SEL = 0 in (15) and (16)).
Table 2a shows the results for the Gov2 collection. CORI shows similar performance than Rank-S and Taily in terms of P @10. The resource efficiency was the lowest among the three methods. The response time C TIME was comparable to the one of Taily. Rank-S showed comparable effectiveness to Taily with only map being lower. The resource usage of Rank-S was the lowest among the three runs. The response time was the largest. On average, Taily and Rank-S selected 2 . 6and1 . 5 shards on average respectively.
 Table 2b shows the results for the CluewebB collection. CORI showed weaker efficiency and effectiveness than Rank-S and Taily. Taily X  X  effectiveness was stronger for all efficiency measures. In terms of C RES , Taily used 26 . 1% more re-sources than Rank-S, while the response time improved by 6 . 5%. Note that Rank-S and Taily improved significantly upon exhaustive search for ndcg @10. This is possible if top-ranked non-relevant documents in the exhaustive ranking are from shards, which are ignored by the shard selection al-gorithm. We consider this phenomenon as a property of the data and therefore did not make any further investigations. Table 2c shows the results for the CluewebA collection. CORI showed weak effectiveness and efficiency. Rank-S per-formed significantly worse than exhaustive search for P @30, P @100 and map . Taily showed similar or better effectiveness compared to Rank-S. Compared to Rank-S, the efficiency improved 47 . 6% and 57 . 3% upon Rank-S in terms of C RES and C TIME respectively.
 Note that although Taily used more resources in Gov2 and CluewebB than Rank-S for the indicated parameter settings, there exist other parameter settings where this was not the case, see Figure 3. Furthermore, the used effectiveness mea-sures depend on a high coverage of judgments in the top-ranked documents. For CluewebA only roughly 50% of the top-30 documents were judged. This coverage was similar for all investigated shard selection algorithms. As a result, the absolute effectiveness values are not exact. However, we believe that the relative effectiveness comparison among the shard selection algorithms would be similar under complete coverage because the selective rankings are derived from the exhaustive ranking and only differ by few added or removed shards per query, which is likely to average out.
The performance of Rank-S depends on the CSI it uses CSI and his parameters were n c = 400 and v = 50). for the initial search in two ways: first, the number of doc-uments, assuming that a larger CSI also causes a more ac-curate selection, and second, exactly which documents are sampled. Variation in performance can influence the com-parison of Rank-S and Taily. Therefore, we investigated the performance variability of Rank-S along these axes.
Figure 4 summarizes the results of this experiment, us-ing the P @30 measure. As a reference, we also plot the effectiveness of Taily. Figure 4a shows the results for Gov2. The median effectiveness increased by roughly 5% between P =0 . 01 and P =0 . 04. The lowest achieved performance was roughly 8% weaker than the median performance. Taily showed similar effectiveness as the median performance of Rank-S with P =0 . 04.

Figure 4b shows the results for CluewebB. The median effectiveness was more stable when changing the CSI size than with Gov2. The lowest achieved search performance was roughly 10% lower than the median performance. Taily showed better effectiveness than all measurements for Rank-S.
Figure 4c shows the results for CluewebA. The median search performance increases by roughly 18% between P = 0 . 001 and P =0 . 04. The lowest achieved performance was roughly 15% lower than the median performance. Taily X  X  effectiveness was en par with the best-measured effectiveness of Rank-S with P =0 . 02 and P =0 . 04.
We discuss the results presented in this section. Taily depends on the following two parameters: the tradeoff pa-rameter n c that determines the number of high scored docu-ments of the collection, and the threshold parameter v that determines minimum of this estimate for are a shard to be selected, which was introduced to suppress estimation errors. Section 5.2 and Section 5.3 showed that both parameters can be set reliably within a range of values, resulting in strong performance. Nevertheless, the parameter values are unin-tuitive. For example, the setting of n c = 400 and v = 50, used in Section 5.4, means according to the definition of the parameters that shards with 50 documents in the top 400 documents should not be selected. A likely reason for these unintuitive estimates is the crude normalization of the expected values in (12). Therefore, for future work we pro-pose the research of more accurate normalization methods, which possibly improves the performance of Taily further.
The results of the comparison of CORI, Rank-S and Taily yielded a number of findings. First, the performance of the vocabulary-based algorithms shows opposite trends depend-ing on the collection size. While CORI X  X  effectiveness de-creases, Taily effectiveness increases. A likely explanation for CORI X  X  performance decrease is its known bias towards bigger shards, which do not necessarily contain many rele-vant documents, which causes efficiency and effectiveness to drop. Therefore, Taily X  X  approach to model the tail of the score distribution in each shard selects substantially smaller shards with more relevant documents than CORI X  X  approach to model all documents. Second, for each parameter setting of Rank-S there was a parameter setting of Taily with higher efficiency and similar or higher effectiveness compared to the former X  X  expected performance. This was in particular true for the response time. This shows that the selection costs C
SEL for executing Taily were substantially lower than the ones for Rank-S and Taily X  X  vocabulary-based approach can select shards with a comparable number of relevant doc-uments as Rank-S. Finally, because of the shape of the achieved efficiency -effectiveness tradeoff combinations, we propose that finding tradeoff settings for a given efficiency is easier to achieve for Taily than for Rank-S. An exception is the response time of Taily in Gov2, which increases at a high rate, causing small differences in efficiency to cause large changes in effectiveness.

The effectiveness of Rank-S is strongly correlated with the CSI size. For example, for CluewebA an increase of the CSI size from P =0 . 001 to P =0 . 01 improved the median effectiveness by 16%. At the same time, larger CSI sizes consume more storage space, which also makes them less efficient. Therefore, it is likely that Rank-S does not scale to collections lager than CluewebA.
We introduced Taily, a novel shard selection algorithm that is based on highly scored documents in the tail of the collection X  X  score distribution. The scores are assumed to be Gamma distributed and estimated from statistics about features related to the query terms of the language model score function. Taily is therefore a member of vocabulary-based shard selection algorithms that represent shards by statistics of terms in the vocabulary.

We evaluated Taily on three large web collections (Gov2, CluewebB and CluewebA) using topically clustered shards defined by Kulkarni and Callan [13]. Compared to the pop-ular vocabulary-based method CORI [6], Taily showed bet-ter efficiency and effectiveness. Compared to Rank-S [14], a state-of-the-art, sample-based shard selection algorithm, Taily achieved similar or better effectiveness using less re-sources. Especially for larger collections and CSIs, the vocab-ulary-based Taily used less resources than the sample-based Rank-S although it selected on average more shards. The improvement of the response time compared to Rank-S was larger than the improvement of the resource usage. Taily showed his highest effectiveness with a shorter response time than the shortest response time measured for Rank-S over a wide range of parameters. For CluewebA, Taily achieved its best performance in roughly 50% of the response time of Rank-S.

Taily does not use document samples and therefore does not need to answer some of the questions that sample-based methods need to answer, such as what samples to take, and what would be a reasonable size of the central sample index (CSI). We investigated possible answers to these questions for Rank-S, and found that the effectiveness of Rank-S de-creases with the CSI size. For example, the effectiveness de-creased by 20% between using a commonly used CSI size of 4% and 0 . 1% for the CluewebA collection, where 0.1% corre-sponded to the size of an average shard. We also found that, for a given CSI size, the lowest effectiveness of Rank-S in 50 CSIs consisting of different document samples was roughly 10% lower than the median performance. The dependence of effectiveness on CSI size and CSI sample is a weakness of sample-based methods. This weakness can also be seen as an advantage of vocabulary-based methods, like Taily, which do not depend on a CSI.

This work focused on shard selection in a cooperative en-vironment using topically clustered shards. We believe that the basic ideas behind Taily can also be applied to database selection in a uncooperative, federated search scenario [4, 20]. In future work we plan to investigate methods to gather the statistics required by Taily in a federal search scenario, to evaluate whether its performance also applies to this setting. The work reported in this paper was funded by the EU Project AXES (FP7-269980), the Netherlands Organisation for Scientifc Research (NWO) under project 639.022.809, the University of Twente in The Netherlands, Ghent University in Belgium, and iMinds (Interdisciplinary institute for Tech-nology), a research institute founded by the Flemish Govern-ment. This work is part of the programme of BiG Grid, the Dutch e-Science Grid, which is financially supported by the Nederlandse Organisatie voor Wetenschappelijk Onderzoek (Netherlands Organisation for Scientific Research, NWO). The authors want to thank the Big Grid team for their out-standing technical support, as well as Jamie Callan and the anonymous reviewers for their fruitful input.

