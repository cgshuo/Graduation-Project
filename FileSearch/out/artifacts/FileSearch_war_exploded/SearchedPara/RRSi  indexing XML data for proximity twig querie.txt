 PatrickK.L.Ng  X  Vincent T. Y. Ng Abstract Twig query pattern matching is a core operation in XML query processing. Indexing XML documents for twig query processing is of fundamental importance to sup-porting effective information retrieval. In practice, many XML documents on the web are heterogeneous and have their own formats; documents describing relevant information can possess different structures. Therefore some  X  X ser-interesting X  documents having similar but non-exact structures against a user query are often missed out. In this paper, we propose the RRSi , a novel structural index designed for structure-based query lookup on heteroge-neous sources of XML documents supporting proximate query answers. The index avoids the unnecessary processing of structurally irrelevant candidates that might show good content relevance. An optimized version of the index, oRRSi , is also developed to further reduce both space requirements and computational complexity. To our knowledge, these structural indexes are the first to support proximity twig queries on XML documents. The results of our preliminary experiments show that RRSi and oRRSi based query processing significantly outperform previously proposed techniques in XML repositories with structural heteroge-neity.
 Keywords XML indexing  X  Proximity query  X  Twig query  X  XML structural similarity 1 Introduction Numerous data have been stored in the XML model as a result of the wide acceptance of XML as the standard for data representation over the Internet. XML query languages [ 2 , 3 ] are emerging as some of the most effective paradigms for information discovery. Twig (tree structure) queries represent the building blocks of XML query languages; hence, twig query pattern matching is a core operation for XML query processing. To support effective information retrieval, indexing XML documents for twig query processing is of fundamental importance. As a result, a number of XML indexes [ 6 , 11  X  14 , 26 ] have been proposed. As XML documents on the web are heterogeneous and have more than one format, documents describing relevant information can possess different structures. Assuming that the user has the knowledge of the underlying document structures to pose well-formed queries is unrea-listic. Therefore, some  X  X ser-interesting X  documents having similar but non-exact structures when compared to a user query are missed in the retrieved answers, and this greatly reduces the usefulness of query results.

In order to have structurally similar documents returned as query answers, it is necessary to incorporate proximity support in XML indexing and query processing. XML indexing strate-gies can be categorized into two main approaches: content-based and structure-based indexes. Content-based approaches in classical information retrieval, using the term frequency (tf) and the inverse document frequency (idf), have been extended to include structural information [ 15 , 23 , 27 ] for calculating ranks for content matched intermediate results. However, many intermediateresultsturnouttobestructurallyirrelevant,especiallyinXMLdocumentsources tage over the content-based approach in locating structurally relevant documents. This avoids a potentially very large intermediate result set. However, none of the proposed structure-based indexes support proximity lookup.

Query relaxation [ 1 , 7 , 22 ] is another way to achieve proximate query answers. Twig sco-ring is introduced in [ 1 ] to rank the relevance of XML documents matched against the the problem of producing approximate structural twig query answers in a timely way. Howe-ver, none of them suggest any indexing scheme which would facilitate fast query evaluation in order to support the proposed proximate query answers.

In this paper, we propose the RRSi , a novel structural index designed for twig query lookup supporting proximate query answers. For many heterogeneous sources of XML documents, it is particularly important to eliminate the structurally irrelevant answers which could be returned from content-based matching. This can take up significant processing time and space before these answers can be pruned. In our design, the RRSi is a hierarchical index on the rrs, relaxed representative structure, which captures the key characteristics of the document structures representing the underlying structurally similar documents. It returns structurally similar documents for the submitted queries. Query searching involving the complete index branch of documents with significant structural differences is avoided and determined at the branch root. After analyzing the RRSi structure, we propose an optimized version of the RRSi , oRRSi , which improves significantly in terms of both space and computational complexities. To the best of our knowledge, ours is the first work to propose the structural indexes on XML documents supporting proximity twig queries.

To summarize, the paper makes the following contributions: (1) We have developed the RRSi , a structural index to support XML query that can quickly locate structurally relevant documents from heterogeneous sources of XML data. This avoids the redundant processing of structurally irrelevant candidates that might show good content relevance. The rrs , the summary structure of XML documents, is used as the index nodes in the RRSi , representing the underlying structurally similar documents. (2) We propose an emSim() score to capture the structural similarity among XML documents and queries. The metric successfully considers the level of importance and assigns higher similarity scores to higher level query nodes matched against the querying documents. This score is used in the filtering step of the proximate query processing associated with the RRSi . (3) We propose an optimized index version of the RRSi, oRRSi , which stores index nodes more efficiently with the trade-off of the accuracy of query results. The RRSi and oRRSi are analyzed and the oRRSi attains a significant space and performance advantage. (4) We implement all the proposed structure indexes and lookup strategies. We run extensive experiments with real and synthetic datasets and queries. The results show that the RRSi and oRRSi consistently outperform previously proposed techniques, in terms of result accuracy and query processing efficiency.

The rest of this paper is organized as follows. Section 2 describes related work. Sect. 3 describesamotivatingexample.InSection 4 ,wedefine rrs and emSim() ,embeddingstructural we demonstrate the effectiveness of the RRSi and oRRSi in supporting proximity search through twig query patterns. Section 7 reports our experimental results. Section 8 offers our conclusion. 2 Related work Indexing and querying XML documents using twig patterns has recently been the object of a have been proposed to speed up the twig query processing of XML documents. In [ 4 ], the proposed TwigStackXB algorithm is a stack-based pattern matching algorithm. It makes use of XB-trees to speed up twig query processing. In [ 21 ], the system PRIX for indexing XML documents is introduced to support twig query processing. It indexes XML documents using transformed Prufer sequences to allow twig pattern matching. Both of these methods, however, and most of the others that have been developed, support only exact query answers.
Previous studies of proximate query answers have focused on querying both structure and content by ranking results to indicate relevance. In classical information retrieval methods, term frequency and inverse document frequency are used to calculate the ranks of query results based on content matching. This approach has been extended to include the structu-large intermediate result set of which many results can turn out to be structurally irrelevant, especially when there are heterogeneous sources for XML documents. Although recent pro-posals attempt to incorporate structural information into content-based indexing and ranking structurally irrelevant data from proximity query processing.

DataGuide [ 16 ] is a structural index summarizing all absolute paths. While it supports absolute path queries well, it fails to effectively process general cases with relative path queries. In [ 18 ], the TreeSketch synopsis has been proposed to capture the tree structure of underlying XML documents in order to produce approximate twig query answers. The idea is our work, the RRSi facilitates fast proximate results with the aim of returning more complete  X  X nteresting X  documents without sacrificing result quality. 3 Motivating example 3.1 Structural heterogeneity of XML XML documents generated from heterogeneous sources often have different focuses; hence, they will have data contents with different structures. As a result, documents describing similar information do not necessarily follow the same document structure. In Fig. 1 ,the labeled trees represent two XML documents that store music album information, including the album name, album singer/artist, and album song information. In Doc2 , &lt; song &gt; nodes the &lt; singer &gt; node in Doc2 . We can see that although Doc1 and Doc2 do display minor document structural differences they nonetheless describe essentially the same information about the music albums.
 In another case, Fig. 2 shows an XML document describing a photo album ( Doc3 ). Compared with Doc1 and Doc2 in Fig. 1 , it displays a number of interesting structural differences and similarities. They are clearly different in that Doc1 contains the nodes &lt; as the former provides the album publication date whereas the latter provides the date a photo was taken. All three documents also display some structural similarity as they all contain the music albums, we would want to accept documents with minor structural variations while avoiding false positive returns of documents with major structural differences. 3.2 Proximate twig query answers The twig query is an important part of many XML query processing systems. It can be modeled as a labeled tree whose edges represent either parent X  X hild  X / X  (a single line edge) or ancestor X  X escendant  X // X  (a double line edge) hierarchical relationships.

Figure 3 shows an example of twig query Q 1 that searches for music albums by the &lt; issued and compared against the document set { Doc 1 , Doc 2 , Doc 3 } , one would intuitively expect Doc1 and Doc2 to be returned but not Doc3 . Obviously, Doc1 is correctly returned with a perfect match against Q 1 . This simulates the optimal scenario when a query writer fully knows the structure of an album document. However, Doc2 will not be returned if only perfectly matched documents are returned. This motivates the need for the use of proximity searching in twig queries while we need to avoid the return of false positive documents like Doc3 .

Oneobservationwhichshouldbemadewhen Q 1ismatchedagainst Doc1 istheimportance of the existence of node labels and their hierarchical relationships within the document; the number of occurrences of the same labeled nodes and the node ordering amongst the siblings are not much of a concern. Therefore, we can summarize the document structure of Doc1 as shown in Fig. 4 and compare this against every node from Q 1.
 Figure 5 shows the query matching results when comparing Q 1against Doc1 , Doc2 and Doc3 . A node is partially matched when only some of its child nodes are matched. In the case of Q 1versus Doc1 , we see that all query nodes are matched and hence we conclude that Q 1 matches Doc1 . When we compare Q 1against Doc2 and Doc3 , they do not match perfectly as Doc1 does. Doc2 shows a better matching result than Doc3 ,as Doc2 has the nodes &lt; This result is expected because Doc2 is more structurally similar to Q 1than Doc3 .This observation motivates the idea to quantify the twig node level, embedding similarity scores, and aggregating them into the twig query level to determine the document X  X  relevance. 4 Structural similarity In this section we introduce the rrs for XML documents. We define the embedding structural similarity constituting the metric used in the structure index, which will be introduced below. 4.1 Relaxed representative structure We model an XML document as an ordered labeled tree; a tree node represents a document element while a tree edge corresponds to a hierarchical relationship between elements. Definition 1 An XML document tree can be represented as an ordered pair ( N , E ) where n , points to n 2 and n 1 , n 2  X  N . The function label() returns the node label of an element, ( n the number of edges starting from n .
 For example, Fig. 6 shows an XML document and its corresponding representative tree.
Next,wedefine Relaxed Representative Structure ( rrs ), which summarizes the element label and hierarchical relationships of an XML tree. Definition 2 The Relaxed Representative Structure , rrs , of an XML document ( N , E ) is the ordered pair ( M , F ) where M is a set of nodes corresponding to the distinct set of node labels label(N) with a surjection n  X  N  X  m  X  M such that label(n) = label(m) label ( n b ) for some ( n a , n b )  X  E }
Intuitively, it is more useful to know the category of an XML document by, for example, the fact that it is describing a book with author information, rather than the exact number of authors. The rrs captures the key characteristics of the XML document structure; it includes the existence of element labels and their hierarchical relationships while dropping other structural information such as the number of occurrences of element labels and element ordering. Cyclic links can occur in the rrs when two nodes n 1 and n 2 in the original document separate paths. This is allowed in rrs and does not affect the subsequent definitions because we only consider the relative ancestor-descendent and parent-child hierarchical relationships between node labels. The rrs can be much smaller than the original document. Another key advantage of rrs is its ability to summarize not only a single document but a set of documents, as shown in a revised definition in Definition 3 .
 Definition 3 We define the rrs of a set of XML documents { ( N i , E i ) } as the ordered pair (
M , F ) where M is a set of nodes corresponding to the distinct union set of node labels { label ( n ) : n  X  N i  X  i } with surjections n  X  N i  X  m  X  M such that label ( n ) = ( n a , n b )  X  E i and i } Lemma 1 Fo r t w o r r s R 1 and R 2 generated from two sets of XML documents S 1  X  S 2 , R 1 is a subgraph of R 2 .
 some l and hence ( m a , m b )  X  F 2 . This shows that F 1  X  F 2 and Lemma 1 follows.
Figure 7 shows two XML documents of similar structures that are summarized into an rrs representing the summarized document structure. The rrs consists of the set of labels and the associated edges from the generating documents. We can see rrs as the definition of labels l = label ( m  X  M ) with the structural hierarchical relationships of labels (l, label(m X )) where ( m , m )  X  F . With the rrs, we can compare the structure of an XML document against a set of documents using this  X  X ummarized X  structure, which is much more efficient than one-by-one comparison. This leads us to propose the structural similarity of an XML document against the rrs . 4.2 Embedding Similarity Suppose we have an XML document X as ( N , E ) and an rrs R as ( M , F ) ,for n  X  N .The child nodes of n in X which also appear as child nodes of m 1 in R . Here we map a node in X into a node in R when they refer to the same label. We define the node-level embedding similarity as follows.
 Definition 4 The embedding similarity of n against R , em Si m ( n , R ) is emCard(n, R)/ fanout(n) . For simplicity, we also denote as emCard(n) and emSim(n) respectively if R does not change. emSim(n, R) measures the ratio of child nodes of n also appearing as child nodes of a corresponding node in R over the total number of child nodes of n . Again, we map nodes in X into nodes in R when they refer to the same label. When all the child nodes of n appear in R , it has a similarity value one and the node is embedded in the rrs . At the other This embedding similarity is not sufficient because we are interested in the document-level similarity. Therefore, we proceed to define a weighting scheme to aggregate and promote the node-level embedding similarity to the document-level.
 Lemma 2 Fo r n  X  N and two rrs R 1  X  R 2 ,wehaveemSim ( n , R 1 )  X  em Si m ( n , R 2 ). F label ( m 2 ) = label ( n ) forsome ( n , n ) inE }| and that implies em Si m ( n , R 1 ) = em Si m ( n , R 1 ) . w( n ) = 1. The weight percentage of n ,w p ( n ) ,isdefinedas w( n )/ ni  X  N w( n i ).
The weighting scheme in Definition 5 is to assign higher weightings, in terms of structural semantics, to elements holding larger sub-trees. Following from this, we define the document-level embedding similarity as follows.
 Definition 6 The document-level embedding similarity of an XML document X against an also denote it as emSim(X) if R does not change.

The document-level embedding similarity quantifies to what extent a document is embedded in the structure specified in the rrs . We will show in a later section that this constitutes the key metric in supporting both exact and proximity index searching. From Definition 6 , we can separate the definition of emSim() into components with different dependencies. The document-level embedding similarity of X against R can be re-written wp(n) / fanout(n) depends on X but not on R . Given a document X, we can pre-compute this component and cache it, and this allows quicker computation as only the emCard() needs to achieved.
 For an XML document X , we have the following lemmas implied from the definitions. Lemma 3 If rrs R is generated from a document set S, we have em Si m ( X , R ) = 1 for all X  X  S.
 in X ,since R is generated from S and X  X  S , it follows from the definition of rrs that there emCar d ( n , R )/ fanout ( n ) = 1.
 Lemma 4 Fo r t w o r r s R 1 and R 2 generated from two sets of XML documents S 1  X  S 2 ,we have em Si m ( X , R 1 )  X  em Si m ( X , R 2 ).
 Proof For every n in X , Lemmas 1 and 2 together imply that emCar d ( X , R 1 )  X  emCar d ( X , R 2 ) .Givenafixed X ,wehaveseenpreviouslythat emSim(X, R) is an arithmetic
Lemma 3 simply verifies that the generated rrs actually captures the structural semantics of the original document. In Lemma 4 ,wenoticethatif X is not similar enough to R 2 ,it will never be more similar against R 1 which represents a document subset. This monotonic property helps to demonstrate that our development of the hierarchical index structure and query processing is working, as demonstrated in later sections. 5 RRSi In this section, we present the RRSi , a structural index designed to support both exact and proximity searches by structure. We first give the basic and conceptual structure, followed by an optimized implementation. Finally, we examine the index construction as well as updating considerations. 5.1 Structure of the RRSi Let DOC be an XML document set to be indexed.
 Definition 8 An RRSi for DOC is a balanced bi-level tree with each node n associated with an rrs. The rrs of node nis denoted as n.rrs , which is generated by a document subset, denoted by n . docs  X  DOC , such that (1) An internal node n is associated a local B+-tree indexed on M with n.rrs = ( M , F ), while each m  X  M points to the set of edges { ( m , m 1 )  X  F : m 1  X  M } .  X  (3) Any two leaf nodes n 1 and n 2 have disjoint underlying document subsets, i.e. n 1 . docs  X  n . docs =  X . Moreover,  X   X  leaf nodes n ( n . docs ) = DOC . (4) A leaf node n is associated with a pointer n.docp pointing to the document subset n.docs .

Note that n.docs is not part of the index structure but represents the underlying document subsets.

An RRSi is essentially a B+-tree for the indexing of structurally similar documents with second level B+-trees associated with every node indexing on the nodes X  rrs .
 Lemma 5 If n a is the ancestor node of another node n d ,wehaven a . docs  X  n d . docs . n  X  = 1 ... k ( n i . docs )  X  n i . docs for i = 1 ,..., k .
 We see that the root node n r oot has n r oot . docs = DOC , as followed by Properties 2 and 3.
In Fig. 8 ,weseethatthe RRSi forms a hierarchy of structural semantics represented by the rrs . The generating document subsets for the rrs also form a nice hierarchy starting from the DOC at the root node and splitting at each level into disjoint subsets of structurally similar documents until reaching the leaf nodes. The further lower level nodes would represent more specific structural semantics. On the one hand, this can be extended so that each leaf node contains a single document. However, this increases the index size significantly while it does not take advantage of the opportunity to group documents of highly similar or identical structure. On the other hand, if the leaf nodes X  document sets are too rough to hold less structurally similar documents, we lose the capacity to locate relevant documents efficiently in query processing.
 5.2 RRSi construction and updating Constructing an RRSi is similar to building a B+-tree; starting from a single document index, we insert documents into the leaf node n which points to the n.docs of most similar structures. If | using the emSim() metric. In addition, a new intermediate node is inserted to hold the split leaf nodes. For all the ancestor nodes, the rrs are extended by merging the additional label nodes and label edges contributed from the inserted document. The insertion algorithm is presented below.
 RRSi Insertion Algorithm Input: new XML document (X), RRSi (R) , splitting threshold (  X  ) Output: Revised RRSi with X inserted InsertNode ( X, R ,  X ) { } Input: RRS ( R ) , XML document set ( X i )
Output: Generated RRS rrsGen ( R , { X i } ) { } Input: a set of XML documents ( X i )
Output: 2 document clusters { C 1 , C 2 } such that X i = C 1  X  C 2 rrsClust2 ( X i ) { } Input: a collection of XML document sets { C i } Output: I 1 , I 2 /* C I 1 and C I 2 are nearest clusters */ Find_nearest_clusters ( { C i } ) { }
The insertion algorithm consists of two main steps. Firstly, it searches for the input document X through the constructing RRSi R to locate the nearest leaf node. The second step is appending X to the leaf node. If this leaf node exceeds the splitting threshold  X  , the indexing documents in the leaf node are clustered and two new leaf nodes are created under it with X attached to nearest one. In term of time complexity, we first examine the clustering step. In a clustering iteration, there are W intermediate clusters W i and there are { ( W  X  1 )  X  X  W i |} and hence pair-wise computations which is bounded by  X  2 .Asthereareat This shows that the time is dominated by the first searching step that has a time complexity of O ( | X | X  log ( D )  X  log ( P )) where P is the number of indexing XML documents and D is the maximal number of nodes of the largest document among all the indexed documents in R . As this searching step follows the same arguments as that of querying the RRSi index (to be discussed in Sect. 6 ), the associated proof of time complexity shares that of Theorem 5 in Sect. 6.2 .

Deleting a node in the RRSi is also similar to deleting a B+-tree; deleting a document from a leaf node n will update the n.docs and n.rrs for n and all its ancestors accordingly. There choice of threshold  X  affects the size of clusters which hold structurally similar documents. If the value  X  is high, less structurally similar documents can be merged into same clusters that requires more disk accesses before getting to the leaf nodes. Hence, an optimal choice should be a tradeoff that is related to the number of keys and pointers that can be stored in a disk block. 5.3 Optimized implementation of the RRSi An RRSi is basically a master B+-tree with many secondary B+-trees associated with each tree node in the master tree. From the discussion in the previous section, it is clear that the root index node represents the whole document population DOC , while a parent/ancestor node X  X  representing document set is always a superset of that of its child/descendant nodes. Hence, an rrs edge that appears in a leaf node also appears in all its ancestors. This would introduce a space complexity issue, resulting in an efficiency problem in the implementation. is to store only the occurrences of rrs edges from the leaf nodes while working out the cor-responding ancestors X  occurrences on the fly. The approach requires a convenient numbering scheme, defined as follows.
 Definition 11 We introduce a node numbering scheme on the RRSi . For each index node n , order from left to right of the ancestor nodes at level i .

Take the document in Fig. 6 as example. We have a.nid = 1, b.nid =1.1, c.nid = 1.2 and have m as an ancestor of n from the definition of nid . Then it follows from Lemma 5 that n . docs  X  m . docs and this gives the expected capability to work out the ancestor node id from the descendent node id. Now, we are ready to give the definition of an optimized RRSi . Definition 12 Given an RRSi I indexing a set of documents DOC ,let R = ( M , F ) be the rrs generated from DOC . An Optimized RRSi , denoted as oRRSi , is a bi-level B+-tree indexed on F . Each leaf node from the index tree represents an edge f  X  F and is associated with a set of node ids f . nids ={ n . nid : finn . rrs f or some n  X  I } referring to the RRSi I (see Fig. 9 ).
 Theorem 1 The original RRSi can be constructed from the oRRSi.
 Proof For a root node n r in an RRSi R , both the n r . rrs and its node X  X  B+-tree are the same as the only B+-tree in the optimized RRSi denoted as oR . For an internal node n in R ,we can obtain the n.rrs from oR by retrieving the rrs edges from oR while filtering out the edges without the n.nid as prefix nid .

In terms of space requirements, the oRRSi requires much less space than the RRSi as a result of its structure. The oRRSi indexes each node label from the document population only once while the RRSi can index the same node label many times in different local document clusters. Theorem 2 demonstrates that the oRRSi achieves space efficiency of one order less than that required by the RRSi .
 Theorem 2 The space complexity of the RRSi and oRRSi are O ( D  X  P 2 ) and O ( D  X  P ) respectively where P is the number of indexing XML documents and D is the maximal number of nodes of the largest document among all the indexed documents.
 Proof In general, a B+-tree has a space complexity of O () where is the number is the indexing leaf nodes. In the RRSi , each node contains a local B+-tree on an rrs generated by a subset of indexing documents. Therefore, its size is locally bounded by the maximal size of the rrs , which is in turn bounded by the total number of edges among all the indexed documents, i.e. D  X  P . At the index tree level, the leaf nodes point to disjoint subsets of documents and hence the total number of leaf nodes is always less than P . Therefore, the overall space complexity of the RRSi is O (D*P*P) , i.e. O ( D  X  P 2 ) . On the other hand, the oRRSi is a B+-tree with leaf nodes holding pointers to the lists of document subset numbering. For similar reasons as we outlined for the RRSi , the size of the former is bounded to the document structures, it is realistic to assume that each indexing edge can appear in at most c document subsets for some constant c . In this case, the overall space complexity of the oRRSi is O ( D  X  P  X  c ) , i.e. O ( D  X  P ) . 6 Twig query processing This section describes twig query processing. We extend the embedding similarity measure emSim() and the RRSi to handle general twig queries with both parent-child and ancestor-descendant edges. We demonstrate an efficient algorithm for searching the RRSi index for effective proximity twig query evaluation, with comparative advantage in huge XML repo-sitories with structural heterogeneity. We show that the RRSi can quickly locate document subsets with embedded and proximity twig queries. Moreover, it can reject false positive documents of irrelevant query topics, which cannot be efficiently rejected using common content-based querying techniques. 6.1 Proximity twig query match Querying XML documents by twig pattern matching is an important part of XML query ancestor-descendant  X // X  relationship. For example, the twig query  X  album[/artist/lastname child node. Moreover, a  X  X itle X  child node of  X  song  X  X nda  X  X astname X  child node of  X  X rtist X  node are expected respectively. Figure 10 shows the tree representation of the twig query example. In general cases, we model a twig query as follows. Definition 13 A twig query Q is an unordered labeled tree denoted as an ordered pair ( N
Q , E Q ) of nodes and edges respectively. n q  X  N Q represents the twig node with the node A parent-child relationship flag e q . pc is associated with each edge, indicating whether it ( e . pc = true , denoted  X / X ).
 The following provides a definition of twig query matching against an XML document. Definition 14 A twig query Q = ( N Q , E Q ) is said to s-match a document X = ( N X , E X ) if label ( X  ( n b )) and (1) ( X  ( n a ),  X  ( n b ))  X  E X if ( n a , n b )  X  E Q for ( n a , n b ). pc = true or false .

Intuitively, Q s-matches X if Q can be embedded as a sub-tree in X following the parent-child and ancestor-descendant hierarchical relationships. In other words, X contains the exact are parent-child edges: then we can regard Q as a small XML document structure and the emSim() can apply to calculating the embedding similarity against the rrs . It is easy to see that this s-match definition of twig queries can be regarded as a special case of the emSim() function.
 Lemma 6 Suppose Q is a twig query with only parent-child edges. If Q s-matches X and R is the rrs generated by X , we have em Si m ( Q , R ) = 1 .
 Proof Similar to Lemma 3 , it is sufficient to prove that emSim(n, R) =1forall n in Q .For an edge ( m , m ) in X such that label(n) = label(m) and label(n X ) = label(m X ) . Also, since R in R such the label(q) = label(m) and label(q X ) = label(m X ) .Wehave emCar d ( n , R ) = |{ all edges ( n , n ) in Q }| = fanout ( n ) . Hence emSim(n, R) = emCard(n, R) / fanout(n) = 1.
As in Lemma 6 , the definition of the emSim() function can be extended to handle general twig queries with ancestor-descendent edges.
 Definition 15 Let Q = ( N , E ) be a twig query and R be an rrs = ( M , F ) .For n  X  N ,the E [ ( n , n ). pc = true and ( m 1 , m 2 ) in F ]or[ ( n , n ). pc = falseandm 2 is a descendant node same way as emCard(n, R)/fanout(n) . For simplicity, we also denote as emCard(n) and emSim(n) respectively if R does not change.

The extended version of the emSim() function counts the embedding cardinality of child nodes  X / X  and descendant nodes  X // X  separately and adds their corresponding contributions. The backward compatibility of emSim() is obvious when we have a twig query with no ancestor-descendant edge. Now, the emSim() on a twig query is defined in Definition 16 , which extends the previous definition in Definition 6 .
 Definition 16 The query-level embedding similarity of a twig query Q = ( N , E ) against also denoted as emSim(Q) when R is clear in the discussion.

Our primary objective is to support proximity twig query processing. Due to the hete-rogeneity of many XML schemas and documents, returning only documents that exactly match a twig query would miss many useful documents with only minor structural diffe-rences. However, users often expect structurally close documents to be returned as well. In the example in Sect. 3 , the twig query Q 1 looks for music album(s) among Doc1 , Doc2 and Doc3 in Figs. 1 and 2 . It is expecting Doc1 and Doc2 to be returned but not Doc3 .Now, this relevance can be quantified by using the embedding similarity function emSim() and the where R 1 , R 2and R 3arethe rrs generated by Doc1, Doc2 and Doc3 , respectively. The proximate query results can be controlled or filtered by setting a similarity threshold, say 0.7. The similarity threshold should be chosen in a way which includes only the structurally relevant or interesting documents. Setting the threshold too low or too high leads to many their needs. 6.2 Query lookup algorithm Structurally similar documents have been grouped into index nodes in the RRSi .Givena twig query, we present an index lookup algorithm for the RRSi which can quickly locate structurally similar documents. Note that the algorithm also applies to the oRRSi index, as we have shown in Theorem 1 that it shares a conceptual indexing structure with the RRSi .
Input: a twig query ( Q ), an RRSi node ( n c )  X  initially set as the root node, a similarity threshold (  X  ) Output: Document subsets as query result QueryRRSi ( Q , n c , X ) {
The algorithm first checks the twig query against the root rrs of the RRSi and navigates down the index tree only if the embedding similarity is greater than the preset threshold. Similarly, a decision is made about each child node based on its embedding similarity. The procedures are repeated towards the leaf level as shown in Fig. 11 .

The pruning approach works because the index supports n parent . docs  X  n child . docs and hence Lemma 4 follows. This property allows fast pruning of structurally irrelevant documents at the early stages of lookup. In other words, this effectively eliminates false positive results. Traditional content-based searching techniques fail to detect documents which contain the query keywords but describe unrelated topics, as reflected in the differences in their document structures. This delays the elimination of these false positive results until the later steps and substantially increases the query processing time. The pruning approach does this more quickly than traditional content-based techniques. 6.3 Analysis of lookup algorithm Next, we show the accuracy of the query lookup algorithm using the RRSi ,aswellasits complexity.
 Theorem 3 All documents with embedding similarity  X   X  are returned in the RRSiquery lookup.
 Proof Let X be a document with embedding similarity  X   X  , i.e. em Si m ( Q , R X )  X   X  where R X is the rrs generated from X .Then X  X  n . docs for some leaf node n . Hence { X } X  n . docs node.
 Definition 17 For a twig query Q , the query result is complete if every queried XML docu-ment X where Qs-matchesX is returned.
 Theorem 4 The twig query result returned from the RRSi lookup is complete.
 Proof Let Q be a twig query and X be a queried XML document such that Qs-matchesX . Let R be the rrs generated by X , Lemma 6 implies that em Si m ( Q , R ) = 1 which is greater than or equal to any similarity threshold set for a lookup. Therefore, the completeness follows from Theorem 3 .

While the correctness holds for both the RRSi and oRRSi , we show that the IO complexity for the oRRSi is much better than that of the RRSi in Theorem 5 .
 Theorem 5 The IO complexity of the RRSi and oRRSi are O(Q*log(D)*log(P)) and O(Q*(log(D)+log(P))) respectively where P is the number of indexing XML documents, D is the maximal number of nodes of the largest document among all the indexed documents, and Q is the number of nodes in the twig query.
 Proof For a twig query of size Q , every query node is matched against the index. In the RRSi , a query node is searched through the bi-level B+-tree, such that a local B+-tree has the number of contributing XML documents bounded by the fixed index threshold C in the query lookup algorithm. The number of leaf nodes in the local B+-tree is bounded by C * D , and hence it has a local IO complexity of O ( log ( D )) ,as C is a constant. In a similar way, the outer B+-tree has the number of leaf nodes bounded by P / C ; hence, the corresponding O ( Q * log ( D ) * log ( P )) . On the other hand, a query node is only searched in the oRRSi , a single level B+-tree, to obtain all the node ids in the conceptual RRSi index for further memory lookup. As the number of leaf nodes in the B+-tree is bounded by the maximal number of different document labels D * P in the document population, the IO complexity of searching the oRRSi is bounded such that O ( Q * ( log ( D ) + log ( P ))) .
In the worst case scenario, we can still come up with a full lookup of the RRSi if either the query structure or terms are too general to appear in all the indexed documents or all the indexed documents have the same structure. In the former case, we argue that most indexing methods cannot return meaningful results to users when users X  queries are too general. The latter case can happen when all documents are generated from the same schema. Note that, firstly, documents generated even from the same schema often result in different structures. Secondly, it is unlikely that this scenario will occur when heterogeneous XML data sources are being queried. Although both the IO and space complexities increase with the number of different document labels in the population, a relatively small increment ratio to the document population is often attained in large XML repositories. This is because documents generated from the same sources or describing closely related information can have many common document labels, making the RRSi and oRRSi scalable in practice. 7 Experimental evaluation In this section, we present the experimental results of our novel structural similarity mea-sure and indexing schemes on real and synthetic datasets. The results have verified the effectiveness and efficiency of the RRSi and oRRSi as XML indexes for fast and accurate proximity query processing, and demonstrated the advantages over previous techniques. 7.1 Experimental framework As we could not find any other structural index supporting proximity twig queries on XML documents for comparison purposes, we select previously proposed indexes supporting exact query processing and apply the query relaxation technique [ 1 ] to generate proximate query answers. Note that there is no modification to the indexes, as only the queries are modified. We follow from [ 1 ] to generate a set of relaxed queries from the original query using the three relaxation techniques: edge generalization , leaf deletion and sub-tree promotion .Query relaxation captures approximate answers as the set of exact query answers returned from the relaxed queries, and the exact query answers to the original query also match the relaxed queries.

In our experiments, we compared the effectiveness and efficiency of XML indexes using the RRSi , oRRSi , TwigStackXB [ 4 ]and PRIX [ 21 ]. We implemented all the algorithms using Java 1.5 . TwigStackXB and PRIX have been proposed as XML indexing techniques to support twig querying. TwigStackXB uses XB-trees to skip nodes on input lists in order to speed up the processing. PRIX transforms twig patterns into Prufer sequences for holistic twig matching. Since the original proposals focused on exact query answers, we have revised the algorithms for proximity query processing using query relaxation [ 1 ]. We ran experiments on a computer with a 2.6GHz Pentium IV processor with 4GB memory, running Solaris 8. For each of the compared algorithms, there are parameters to be configured including the similarity thresholds and index node thresholds. Preliminary experiments have been conducted on each index independently to identify the optimal parameters to be used for comparisons in the subsequent experiments.

The splitting threshold controls the size of index nodes and also the size of index. The aim is to cluster the input documents into the index nodes in a way that avoids memory paging. Starting with a small initial threshold value, it scans the input documents and constructs the index. If it runs out of memory before finishing the index construction, it then increases the threshold value and re-constructing a new, smaller index. The optimal splitting threshold value is the smallest value that the index can fit into the memory. In proximity querying, the goal is to allow relevant results to be matched while filtering the irrelevant results. We form a few test queries and lookup the indexes with different choices of similarity thresholds ranging from 0.95 to 0.5. By manually examining the accuracy of the query results with different threshold values, we select the value that produces the optimal result. Hence, for the RRSi and the oRRSi indexes, the splitting threshold of 8 and the similarity threshold of 75% are adopted respectively in the experiments. 7.1.1 Data sets and queries We selected four real world (1) X (4) and one synthetic (5) XML datasets in our experiment: (1) TPC-H  X  X ecision support benchmark, (2) SwissProt  X  X rotein sequences, (3) TreeBank  X  English sentences tagged with parts of speech, (4) DBLP  X  X ibliographic information on major computer science journals and proceedings, (5) XMark [ 24 ] X  X ynthetic data set that models auction site data. The real-life data was retrieved from the UW XML Repository [ 25 ]. All five data sets were grouped into a large single XML repository, simulating the hetero-geneous scenario. For each underlying dataset, we randomly selected sample documents to generate twig queries in a controlled manner. One hundred queries were generated from each dataset containing both parent-child and ancestor-descendant edges with five to twelve twig nodes. Hence, in total there were five sets of each one hundred queries which were called QTPCH , QSPROT , QTBANK , QDBLP and QXMARK respectively. 7.1.2 Evaluation metrics We evaluated the indexes from several perspectives: accuracy, computational performance and scalability. The accuracy of proximate twig query answers is measured by the precision as the ratio of correct answers to the total number of query answers returned. Given a twig query Q and the corresponding set of proximate documents returned, the individual returned answers are examined against the submitting query to identify the correctness. In general, the higher the precision, the higher the accuracy of proximity twig query results. Secondly, for computational performance evaluation, we adopt the metrics of the number of elements scanned and the query execution time to compare the performance of twig query processing. Lastly, the scalability is measured as the growth in index sizes and query execution times over the growth of indexing document sizes. 7.2 Experimental results and analysis In the first set of experiments, we compared our RRSi and oRRSi against the TwigStackXB and PRIX indexes. For each of five twig query sets, we examined the correctness of the returned document sets and calculated the average precision to compare the accuracy of the indexes. In Fig. 12 a, we see that both the RRSi and oRRSi attain a high degree of precision, greater than 80%, because the structural differences of irrelevant documents are accurately pruned by our novel structural similarity measure emSim() . In comparison, the degree of precision for TwigStackXB and PRIX is consistently lower than 80%. This demonstrates the accuracy and effectiveness of our novel similarity measure function. Meanwhile, the RRSi/oRRSi and TwigStackXB/PRIX respectively always attain the same precision because they adopt the same similarity measures emSim() and twig scoring in the index structure while their difference lies in the way in which the index is structured and queried. This difference is reflected in the computational performance and scalability evaluations in the following paragraphs.
With respect to the number of elements scanned, Fig. 12 b shows that both the RRSi and oRRSi successfully identify irrelevant documents at an early stage of query lookup, avoiding the processing overheads of TwigStackXB and PRIX .The RRSi can save the I/O by 11 to 53%. As the oRRSi adopts an optimized structure to further speed up the index lookup, it can attain I/O savings from 43 to 72%. To verify the overall performance gain of our proposed indexes, the average query execution times for different indexes are compared using the 5 query sets. Figure 12 c shows that the RRSi and oRRSi consistently process queries faster than TwigStackXB and PRIX .The RRSi can attain a 7 to 39% improvement in efficiency in terms of running time. The oRRSi can further improve the running time from 47 to 77% compared to TwigStackXB and PRIX .
 Finally, we tested the scalability of the indexes utilizing synthetic datasets generated using XMarks of different sizes in the ratio of 1:2:4:8:16, namely XMARK1 , XMARK2 , XMARK4 , XMARK8 and XMARK16 . The twig query set QXMARK was run against the indexes built on each dataset to compare the corresponding index sizes and execution times. Figs. 13 and 14 show that scalability is achieved for all the indexes while the RRSi and oRRSi achieve better space efficiency with smaller indexes. 8Conclusion In this paper, we have proposed the RRSi , an index intended to support XML queries for the rapid location of structurally relevant documents. This reduces the redundant processing of structurally irrelevant candidates that might show good content relevance. We have also introduced the rrs as the relaxed representative structure of XML documents and used this for index nodes in the RRSi . We have also developed a novel structural similarity measure, emSim() , among twig queries and rrs , allowing proximity query processing using RRSi .After careful analysis of the RRSi index structure, an optimized index version, oRRSi which further achieves significant space and performance improvements while maintaining the quality of the query results, is proposed. The experimental results show that our RRSi and oRRSi significantly outperform previous techniques, in terms of the accuracy of proximate query answers and the processing efficiency, while maintaining the index scalability. This advantage early stage of index lookup so as to avoid the overheads required in unnecessarily scanning irrelevant documents.
 References Author Biographies
