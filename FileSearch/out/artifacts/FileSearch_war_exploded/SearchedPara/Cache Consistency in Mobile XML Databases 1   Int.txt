 XML has become a widely accepted standard for data exchange in the Web, and XPath [16] is most widely used in query languages accessing Web data and XML databases. Whenever an XML database is used by multiple clients in mobile ad-hoc networks, database technologies face new challenges. For example, transaction man-agement has to consider unpredictable disconnections of clients for applications that require transactional guarantees like serial izability of histories of concurrent transac-tions. Similarly, limited bandwidth and limited energy supply require new approaches to query processing which includes data exchange, replication, and caching of query results. Within a multi-hop mobile network, it appears to be promising to interchange data between mobile participants that cache different XML data fragments. However, the identification of outdated data and an integration of caching with transaction syn-chronization become even more challenging than in traditional client-server systems. 
In this paper, we present an integrated approach to XML query processing, transac-tion synchronization and caching in multi-hop mobile networks that guarantees trans-action serializability and that is optimized towards minimal data exchange. By minimizing the data exchange required for correct transaction processing, our ap-proach saves the consumption of limited resources like bandwidth and also of energy supply, whenever the energy required for sending and receiving data significantly our paper addresses and solves the following four problems. First, how we can reuse cached XML fragments of multiple mobile clients for query processing in multi-hop networks instead of retrieving all the data from the XML database. Second, how can we efficiently identify which XML fragments are missing in the cache of a network node. Third, how can we identify outdated data without additional communication overhead. Forth, how can we guarantee transaction serializability with a minimum of data exchange. 
In order to solve the problems mentioned, our paper presents the following new contributions. First, we show how cached query results can be reused. Second, we provide a fast detection technique for missing XML data fragments. Third, we reuse the serializability check results of validation for cache consistency checking and maintenance. Finally, we provide a variety of techniques to minimize XML data ex-change. Therefore, we consider our approach to be useful to almost all applications which need transactional guarantees during their work on XML fragments and for which access to an XML database from single-hop and multi-hop mobile networks is a major bottleneck, i.e. is most energy or time consuming. 
The related works to our research involve approaches based on data replication [8,9,11], works that discuss caching but do not take advantage of transaction synchro-chronization of mobile transactions (e.g. [15]). A previous approach to the combina-most one client, i.e. it does neither synchronize transactions that involve multiple clients, nor does it optimize cache access in multi-hop environments. As a conse-quence, it does neither propagate nor re-compute forwarded queries or partial an-swers. In addition to propagation and computation of forwarded queries and partial answers, our approach includes a bit-vector based test for reusing cached results. Therefore, to the best of the author X  X  knowledge, our integration of XML data caching and transaction synchronization in multi-hop ad-hoc networks has not been proposed anywhere before. We apply a variety of techniques to reduce the bandwidth consumed for the transport of XML fragments from one node of the network to another node. These techniques include XPath query translation, XML fragment caching, pipelined reuse of cached XML fragments, and computation of forwarded queries. In order to preserve correct-ness of transactions, transactions are separated into the following phases: a read phase where they are allowed to read cached and possibly outdated data, followed by a vali-dation phase where cache consistency is checked and repaired, and an optional write phase for successfully validated writing transactions. 2.1 XPath Query Translation In order to answer an application X  X  XPath database query AQ, it is sometimes neces-sary to access more data than we get as the query result of AQ. This occurs especially in the cases, where we have to access data in order to evaluate the filter expressions of AQ that would reduce the selected answer fragment. In order to retrieve the relevant data, we use the technique of projecting XPath expressions as described in [13]. We we assume that the translation of AQ into S has been performed and we discuss how to treat the queries Qi  X  S within our approach. 2.2 Fragment Caching and Reuse are outdated or incomplete. Note that errors are detected and repaired within the fol-lowing validation phase. The whole process of transferring an XML fragment to the client can be considered as a pipelined process where sub-fragments of the queried Figure 1). Whenever these sub-fragments are sufficient to answer the query, we do not need to retrieve the queried fragment from the server. In other words, our goal is that the server transfers only those sub-fragments which are not cached in a node on the shortest path from the requesting client to the server. 
Of course, a query only has to be forwarded, if there is still data missing to answer the query. That is the reason why the set of queries forwarded to the next node on the consisting of a forwarded XPath query set Qsi and the XPath string PAi that describes the partial answer to Qs(i-1) collected so far. In the opposite direction XML frag-ments are sent to the clients, however we only send XML difference fragments, i.e. data that are not contained in any cache on the path to the client. 2.3 Reusing Old Data During the Read Phase During the read phase, cached data is reused regardless of the time-stamps associated with the data. This may result in the use of outdated data. The motivation behind this is that usually XML databases contain a lot of data that very rarely changes. For ex-ample, let us look at changes in a commercial XML database that contains customer and product descriptions: the name or the address of a given customer or the name or the description of an ordered product will change very rarely. Even if that data changes from time to time, no error occurs because each transaction is validated. Only if the data has been changed since the last time when it was validated, it is outdated, i.e. only in this case outdated data has been used by a query. But even then, it is quite common that only a small portion of the data has changed, e.g. a phone number in the customer X  X  contact data. Because we can compute outdated data from the global write set (defined in Section 3.1), within our approach, only this changed XML difference their query to the XML database server. 2.4 Using Incomplete Data and Data Integration During the Read Phase When a query can be partially answered by a fragment that is cached on a client, it is not necessary to retrieve the whole fragment from the server. Instead, the query result can be combined from both, the cached fragment and the remaining part that is not found in the cache but has to be retrieved from the server. We use a unique document numbering scheme outlined in [2] for the server-side XML document and all partial copies on a client. This numbering scheme allows each node to integrate XML frag-ments received over the network into its locally stored XML fragments at the correct position. 
Within the next subsections, we outline how we identify which data is contained in a cache and which is missing and whether the query set Qsi must be forwarded. 2.5 Forwarding Queries and Returning Partial Answer Fragments The computation of partial answers is based on asynchronous messages that are sent back and forth on the shortest path from the requesting client to the server. There are two kinds of incoming messages to a client and two kinds of outgoing message calls from a client. The first incoming message, Query , is querying for an XML fragment which is required to answer a query on the requesting client. The first outgoing mes-same or for a smaller XML fragment. 
A second outgoing message Answer contains a partial answer fragment to a query incoming message receives such a partial answer fragment that is contained in an Answer message that has been sent by the next client on the path to the server. While the Query messages are forwarded from each client to the next node on the shortest path to the server, the Answer messages are forwarded in the opposite direction, i.e. towards the requesting client. 
When Query messages are forwarded from one client to the next on the shortest path to the server, they contain not only a set of queries, but also a set of XPath ex-pressions describing partial answers found in the caches of previous clients on the answer XPath expressions: the set Qs2 of queries to be forwarded and the set PAs2 of partial answer XPath expressions. The implementation of the Query message is outlined in Algorithm 1 below. (1) Query(in:Qs1,PAs1) (2) // used in asynchr. output messages: Qs2, PAs2 (3) { Qs2 =  X  ; PAs2 = empty ; (4) for each Qi in Qs1 (5) { computeXPathExpr( Qi, XPA, QF ) ; (6) if ( QF!=empty ) Qs2 = Qs2  X  {QF} ; (7) if ( XPA!=empty) PAs2 = PAs2 | XPA ; (8) } (9) send( NextClientOnPathToRequestingClient, (10) Answer( computeLocalAnswer(PAs2-PAs1) ) ) ; (11) if ( Qs2 !=  X  ) (12) send( NextClientOnPathToServer, (13) Query(Qs2, (PAs1|PAs2) ); (14) } 
The input parameters of the Query message (line (1)) are a set Qs1 of given que-ries and a set PAs1 of XPath expressions describing partial answers to Qs1 that have already been found. In (line(3)), two local variables, i.e. Qs2 and PAs2 are initialized to the empty set and to the empty XPath query string respectively. Qs2 describes the actual client node that are relevant to the queries in Qs2 . 
Then (within lines (4)-(8)), the set Qs2 of queries and the XPath expression PAs2 are computed. Qs2 simply collects the queries QF to be forwarded (line (6)) and PAs2 collects the XPath expressions XPA describing reusable cached query results (line (7)) from each call of the procedure computeXPathExpr . The procedure computeXPathExpr (given in Section 2.6) computes a query QF to be forwarded and a partial answer XPath expression XPA for a single query Qi contained in Qs . Within line (10), the partial answer fragment Ans1 is computed from the difference XPath expression (PAs2-PAs1) , and it is sent back to the next client on the path to the requesting client. We use the difference (PAs2-PAs1) here, because it is not necessary to include a fragment described by PAs1 in the answer as this fragment of the answer has already been found. Finally, if the XPath query string Qs2 to be forwarded is non-empty (line (11)), a Query message is sent to the next client on the shortest path to the server (lines (12)-(13)). The parameters are the computed set Qs2 of queries to be forwarded and the XPath expression (PAs1|PAs2) , which is the union of the XPath expression PAs1 of previously found partial answer fragments and the XPath expression PAs2 describ-ing the partial answer fragment found on the actual client. 
To answer a query, that partial answer PAs2 of the locally cached fragment F that the message Answer simply forwards each partial answer XML fragment to the requesting client by sending the message Answer again. The server simply answers an incoming query by accessing the XML database and returns the answer fragment within a separate Answer message. The Answer message contains also the actual time-stamp generated for the purpose of transaction synchronization and cache con-sistency checking. 2.6 Conditions for Query Forwarding and Using a Containment Test As we can see from lines (11)-(13) of Algorithm1, queries are forwarded only if the set Qs2 contains at least one non-empty query QF . Given Query Qi , the computation of a query QF to be forwarded is done by a procedure computeXPathExpr (out-lined in Figure 2 below), which additionally computes an XPath expression XPA describing the partial answer found in a local cache. A call to computeXPathExpr query Qold . This could be tested by checking query containment (c.f. line (9) of every answer to Qi is also an answer to Qold -independently of the database state. When the test yields that Qi is subsumed by Qold , this is sufficient to guarantee that every node selected by Qi is also selected by Qold . Therefore, Qold is sufficient to search for the fragment F that answers Qi . 
However, the execution time needed for a complete XPath containment test would exhaust the mobile devices X  power and time resources (e.g. [12]). Therefore, we have compute XPA and QF from Qi without performing an XPath containment test at all. Instead, wherever possible, we substitute an XPath containment test with a more effi-Furthermore, we simplify the remaining XPath containment tests by using a fast but incomplete tester [5]. 2.7 Mapping of Queries to DTD Node Bit-Vectors Qi as an approximation to decide whether or not a cached result of a query Qold can be reused for answering Qi . The idea behind DTD node bit-vectors is that Qold can such a case, we call Qold relevant to Qi . A DTD node bit-vector contains one bit for each element or attribute defined in a DTD. Basically a query Qi is translated into its bit-vector by setting a bit for each leaf element and for each attribute selected by Qi or accessed by a filter of Qi . Within a query Qi = /E1[./E2[E3]/E4]/E5/E6, the elements E3, E4 and E6 are the leaf elements of Qi whereas E1, E2 and E5 are not. Note that an element can be a leaf element of a query, although all elements in an XML database with the same name represent inner XML element nodes. 
Note however that the DTD node bit-vector is changed for a query Qold , the re-sult of which is cached. Qold is translated into its bit-vector by setting a bit only for each leaf element and for each attribute selected by Qold , i.e. the elements or attrib-ute occurring only in a filter are ignored. For example, the bit for E6 is the only bit set in the bit-vector of a query Qold =/E1[./E2[E3]/E4]/E5/E6. 
Whenever a query result of an old query Qold is cached, the query string and the bit-vector of Qold are cached too. The bit-vectors are used to restrict the number of XPath containment tests as follows. Only if each bit set in the bit-vector of Qi is also set in the bit-vector of Qold (line (6) of Figure 2), we perform the fast containment test for XPath queries described in [5]. Otherwise, Qi can not be answered com-pletely by Qold , i.e. we do not need an XPath containment test. Now, we can explain the remaining parts of the procedure computeXPathExpr . This procedure processes one cached query Qold after the other (line (3)) and stops lowing cases for reducing the number of containment tests. ment that is both selected by Qold and required to answer Qi . In other words, we are warded to answer Qi is simply the same as Qi (line (14)), i.e. Qi is forwarded to the next client on the path to the server. tribute that is not selected by Qold , there is at least one bit in set in the bit-vector of Qi that is not set in the bit-vector of Qold (i.e. the test in line (6) fails). As the query result Qold may partially contribute to the answer of Qi, the XPath query expression of Qold is added to XPA , the XPath query expression of partial answers to Qi . Note two fast tests on bit-vectors. exactly what we need to answer Qi . Therefore, forwarding of Qi is stopped. 
Finally, only if none the above three conditions applies, the fast but incomplete containment test described in [5] is performed. If the containment test yields the result that Qi is subsumed by Qold , Qold can be searched for the fragment F that answers Qi . Therefore again, the forwarding of Qi is stopped. To summarize the contributions of Section 2: After translating an application query cached results and outdated data, and to ask only for missing data fragments. Fur-thermore, we have shown how to compute XPath queries for missing data fragments and how to check whether or a cached result can be reused and whether or not a query has to be forwarded. The advantages of these techniques are that queries are sent only that the size of transferred answer fragments is reduced to a minimum. 3.1 Overview of Our Validation Based Approach to Synchronization As mobile clients have a higher chance to loose their connection to the database mobile clients. Instead, we use a server-side scheduler that combines time-stamps and use XML databases and want to minimize data exchange within multi-hop environ-ment, both of which lead to new requirements -to be discussed later. 
As within the traditional validation protocols ([10]), our transactions are divided into phases. A read phase is followed by a validation phase, which in case of success-ful validation is eventually followed by a write phase. Transactions are ordered ac-cording to the end of their read phase, i.e. transaction Told is defined to be older than before T ends its read phase. Younger transactions T are validated against older trans-actions Told . As the scheduler X  X  decision on commit or abort during the validation phase of a T depends on timestamps and data read or written by T , each transaction T data fragments that have been read or shall be written by T . The scheduler combines conflicts with the write operations of previous transactions Told . Inspired by the idea of [14] that uses queries in predicative validation, we use XPath expressions instead of XML fragments within the read set and, wherever pos-exchanged for the purpose of validation as the XPath expressions are usually much smaller than the XML fragments read by a transaction. 
Within the read phase , transactions query the XML database itself or the cached copies of XML fragments in the network which may contain outdated data. Further-more, write operations during the read phase of a transaction are performed on the client X  X  local copy of an XML database fragment, and both the operations and the new nally, at the end of the read phase, a writing transaction transfers its private write set to the server. Note however that the private write set is not applied to the server-side XML database as long as the transaction has not been validated successfully. 
During the validation phase , the transactions X  queries together with the time-stamps computed for the query results are compared with the write operations per-formed by concurrent transactions as described below. As a result of the validation phase, an XML difference fragment is returned from the database server to all the mobile clients participating in the transaction. This XML difference fragment contains dated data and the information which data has been inserted or deleted on the server server. If this XML difference fragment is empty, the transaction has only used actual data; therefore the clients know that the transaction has been completed successfully. Otherwise, the clients use the XML difference fragment to refresh their cached data and assign a new time-stamp to the refreshed data before they restart the transaction. By using XML difference fragments to refresh cached data, we avoid the conflicts date without reading all the data used by the client again. operations contained in the private write set of a successfully validated transaction to the XML database. Then the scheduler generates a time-stamp for the write operations further concurrent transactions. 3.2 Time Stamp Generation As mentioned earlier, the scheduler generates a new timestamp during the write phase of each transaction after the transaction X  X  changes have been made permanent to the that has to be done in a critical section. Furthermore, the actual time-stamp is assigned XML database. The resulting answer XML fragment is associated with this timestamp and reflects the time at which data collection for this fragment started. This time-stamp will be used in the validation phase. Finally, a new time-stamp is generated before the data collection for an XML difference fragment is started. 
Time-stamps are assigned to the query results and XML difference fragments be-fore the data collection for the query and the XML difference fragment starts, whereas XML database. This is required for the following reason. When a query (or an XML difference fragment computation) of transaction T with a time-stamp t conflicts with write operations of a transaction Told with an older time-stamp told , we are then sure that the write operations performed by Told on the XML database are com-pleted before the read operations of the query or the XML difference computation for T start. This allows us to conclude that no transaction dependency  X  X  reads dirty data that has been changed by Told  X  can result from this particular query and this particu-lar write phase. 
Whenever a cached XML fragment is transferred to another client, the original time-stamp set by the database server for this fragment is associated with the copy too. 3.3 Details of the Validation Phase Within the validation phase, each transaction T is validated against older writing transactions Told . As we allow for parallel validation of transactions, we have to check for read-write conflicts and for write-write conflicts. Note however that it is not necessary to validate a transaction T against older reading transactions, as they did not chance the XML database and therefore did not change the data read by T.

In comparison to node-based locking or validation approaches, we use the XPath validation phase. These XPath expressions are applied to the XML difference frag-deleted fragments and to the new values of updated and inserted fragments. A read operation read(Q) that uses an XPath expression Q and a write operation write(F) that modifies a fragment F are defined to be in conflict if Q(F), i.e. Q applied to F, is non-empty. Whenever read(Q) and write(F) are in conflict, the time-stamps associated to Q and to F are used to check whether or not read(Q) was a dirty read. Whenever, the Therefore, Q(F) is added to the XML difference fragment only if the time-stamp of Q is older than the time-stamp of F. 
Some write-write conflicts have to be checked because at validation time, we can not be sure whether the older transaction writes conflicting data first. Similarly as for stored as operations in the validating transaction X  X  private write set. A write operation stamp for T  X  X  validation phase begins. If however, we have a write-write conflict and the time-stamp of the write phase of Told either is not older than the time-stamp for T  X  X  validation begins or has not yet been created, we can not be sure whether write-write conflicts between Told and T yield lost updates. In this case, we have to prevent that T writes before Told writes. Told  X  X  write phase is completed. Which option is the best choice, depends on the server X  X  stability considerations, i.e. we decided for a stable server to suspend the start restarts than in the standard parallel validation protocol is that we reduce the amount of data that has to be exchanged between server and client, which is essential in mo-bile environments. 4.1 Reduced Data Exchange at the End of the Read Phase Data exchange at the end of the read phase is minimized because the data needed for validation is restricted to a minimum as follows. The largest reduction is to exchange XPath expressions or IDs for XPath expressions instead of exchanging read XML fragments. A second reduction applies to delete operations, for which the client sends only paths to the deleted fragments instead of sending the deleted fragment to the the path to it. A third reduction applies to update operations. We use the path to each updated fragment for both, deleting the old fragment and inserting the new fragment, i.e. we avoid sending the old fragment back to the server. Finally, whenever the XPath expressions are stored on the server-side and associated with IDs, the system when an XPath expression is transmitted. 4.2 XML Difference Fragment Computation in the Validation Phase In the validation phase, the scheduler computes which data is missing or outdated but required on the clients to correctly answer all its computed queries Qi. The scheduler compiles an XML difference fragment containing this required data. The XML differ-transaction minus those fragments that have been transferred or validated before and have not been changed since the last transfer or validation. In order to check whether or not a fragment has been changed since the last transfer or validation, the time-stamps are used as described in Section 3.2. After all the fragments have been sub-tracted from X which, according to the time-stamps, may contain outdated data, the remaining XML difference fragment is transferred to the client. 4.3 XML Difference Fragment Propagation to the Client Once computed, the XML difference fragment is transferred hop by hop on the short-est path from the server to the requesting client. This fragment can be used to actual-ize the cache content of the inner network nodes. Whenever the cache of a requesting client or of an inner network node caches an XML fragment that is actualized by applying the updates of an XML difference fragment, the actualized fragment inherits the time-stamp of the XML difference fragment. 
Note that this cache actualization of intermediate network clients results in a more actual state of is their cached data without extra bandwidth consumption. The advan-quired data exchange steps of further queries or it may lead to fewer failing validation difference fragment is empty. Then, all the clients on the shortest path from the server to the requesting client know the following. All the data that is needed for the queries of the actual transaction and that these clients have in their cache is up to date. There-their time-stamps without exchanging additional data. When queries are partially answered by cached query results, there are in principle two options for computing the time-stamp of the query. First, the query result can combine the data and take the oldest time-stamp as the time-stamp of the combined result. Second, the query can be split, i.e. it can be replaced with two or more queries, each representing one cached fragment. Both approaches have their pros and the cons. The first approach is easy to implement and does not require to communicate and to manage extra query strings. In comparison, the second approach, in general, attaches newer time-stamps which may lead to fewer failing validations. As mobile clients may lose their connection to a database server, we do not grant locks to resources accessed by mobile clients. Instead, we use an optimistic approach that allows unprepared disc onnections of clients at any ti me without blocking the server. Additionally, our approach allows repairing lost connections, i.e. continuing interrupted transactions after link failures have been repaired without restarting a use cached and outdated data of previous transactions, and it allows using cached data of other clients. 
Data exchange during the read phase is further reduced by a pipelined data ex-change technique that considers partial answers that have already been found and transports only missing XML difference fragments. Furthermore, missing XML dif-ference fragments are taken from the first client found in order to keep the transporta-tion distance as short as possible. Data exchange in the validation phase is reduced to an absolute minimum as the XML difference fragments contain only the required information about outdated fragments and fragments not yet cached at the client. Furthermore, the difference fragments can be used by the inner mobile network nodes to update their caches. 
Cache consistency is checked and guaranteed within our approach as a result of the validation step during the transactions X  commit-request and does not require any addi-tional data exchange. We regard this as a significant contribution as validation-based synchronization appears to be appropriate for mobile transactions, and our approach reduces the major bottle-neck and most energy consuming process in mobile net-works, i.e. the size of exchanged data fragments. 
Although, we have used a validation based approach on the server, our approach of validating clients, that perform a cache consistency check without extra XML frag-ment exchange, is not restricted to client-server architectures that use validation as a server-side synchronization protocol. [3] shows that that client-side cache-consistency checking integrates well with centralized or distributed servers in wired networks that use a lock-based protocol. Finally, although we have described our approach for a single stable XML database server, we consider the approach to be applicable also to transactions running on multiple databases located on different MANET nodes, if it is appropriately combined with an atomic commit protocol for MANETs as e.g. [1]. [3] Stefan B X ttcher, Adelhard T X rling. Transaction Synchronisation for XML Data [6]  X etintemel, Ugur, Peter J. Keleher, Bobby Bhattacharjee and Michael J. Frank-[12] Frank Neven, Thomas Schwentick: XPath Containment in the Presence of Dis-
