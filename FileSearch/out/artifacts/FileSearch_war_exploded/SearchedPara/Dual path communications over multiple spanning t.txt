 1. Introduction
The modern plant architectures implement communication networks to control and to monitor their remote and distributed applications. The major interest facing the point to point archi-tectures is to mitigate the wire costs and to enable easier information sharing. In the framework of embedded systems and industrial systems, the communication requirements are to guarantee bounded end-to-end delays and to maintain the con-nectivity between all network nodes. In the 1980s, many net-works named fieldbuses were developed to respect these strong constraints. More recently, the trend in fieldbuses was to use Ethernet protocol (IEC 61784 gathers the different fieldbuses standards). The advantages are that Ethernet is a well known protocol, widely implemented (ensuring its timelessness), and its performance is continually increasing with technology evolution (especially its bandwidth). Consequently, Ethernet is not a determinist network since it implements the carrier-sense multi-ple access with collision detection (CSMA/CD) mechanism to resolve the problem of contention in case of simultaneous data transmission ( Lian et al., 2002 ). However, the fully switched architectures allow inhibiting the collisions and making possible delay estimations in the worst cases ( Georges et al., 2002 ).
Moreover, the IEEE 802.1d introduces algorithms to face loops X  issues when redundant links are used. In such cases, the Spanning
Tree Protocol (STP) defines a hierarchical logical tree topology by inhibiting some switch ports. STP is then able to react to a link failure by activating inhibited ports. Nevertheless, the standard STP reconfiguration time period (in seconds) is too long and is not compatible with the industry requirements (often less than 1 s). This is especially the case for Networked
Control System where a network is used in feedback control loops. In this field, several research works ( Zampieri, 2008 ) focus on the way to reconfigure the network when failures occur, by proposing either new protocols than STP (such that native devices are not anymore supported) or specific/dedicated physical net-work organizations. The goal of this paper is both to retain only native protocols (like STP) and to significantly increase the net-work dependability by reducing the reconfiguration time, even to zero in particular cases. This dependability is evaluated in terms of probability of disconnection between nodes. The practical approach is to duplicate the message s with real-time properties and to send them to the remote nodes by several paths. If one path fails, the STP reconfiguration time period on the trouble path.
This paper is organized in the following way: Section 3 describes the Spanning Tree Protocol standards and the related works. Section 4 formalizes the fitness value to be optimized.
Section 5 presents the approach based on genetic algorithms to increase the dependability of switched network architectures. Finally, Section 6 illustrates the interest of this study in the Networked Control Systems framework.
 2. Networked control systems through a real-time network are called Networked Control Sys-tems (NCSs) ( Zhang et al., 2001 ). Many examples of NCSs can be found in several areas: teleoperation systems ( Anderson and
Spong, 2002 ; Hannaford, 2002 ; Goktas et al., 2002 ), automotive industry ( Ozguner et al., 1992 ) and in automated manufacturing systems ( Lian and Moyne, 2000 ). Hespanha et al. (2007) gives an overview and addresses some key issues of the NCS framework, such as limitations in terms of packet-rate, sampling, network delay, and packet dropout. Profibus, CAN, Ethernet, EtherCat,
Powerlink are candidate networks for NCS implementations. The characteristics of time delays can be constant, bounded or ran-dom according to the network protocol adopted. Consequently, the overall performance of the networked-based control system can be significantly affected by network delays. Fig. 1 depicts the NCS synoptic.
 controller, sensor and actuator are performed through a network, is to ensure the quality of service. Indeed, the performance quality of the whole network system is very sensitive to delays, jitters and packet losses. As previously stated, this paper focuses on implementing Ethernet protocol into NCSs. Real-time control via Ethernet is a practical and feasible solution to NCS design ( Ji and
Kim, 2005 ; Lai and Hsu, 2010 ; Vatanski et al., 2009 ) and has been the subject of many researches lately ( Lee and Lee, 2003 ; Daoud and Elsayed, 2004 ; Addad and Amari, 2008 ). Although several results have been proposed to manage the delays induced by the network, few papers have studied the availability issue to the best of our knowledge. In a network, the robustness of the architecture is increased by adding redundancy. In Ethernet, it corresponds to switched networks as presented in the following sections. 3. Spanning tree 3.1. Introduction
Basically, the dependability of network wires is achieved by implementing redundant links and/or network devices. In Ether-net, the redundancy may generate infinite loops in the physical architecture which can lead to infinite retransmissions needlessly consuming bandwidth. Fig. 2 (a) illustrates this problem and describes the behavior of a broadcast frame sent by the switch S1 to the switch S4.

This frame is sent to all the output ports of S1. S2 and S3 receive it and forward it to all their output ports. S2 and S3 receive the frame again in another port and forward it to all their output ports, and so on. Thus, the switch S1 twice receives the same frame that it had initially sent. The Spanning Tree Protocol implemented in the switches aims at breaking the loops in order to form a tree by disabling some ports. STP has also to maintain the network connectivity. Then, STP continually monitors the physical links, and dynamically adjusts their states (enable, disable) according to the link failure occurrences. In Fig. 2 (b), the link between S2 and S3 is disabled by STP, and the broadcast frame sent by S1 is forwarded only one time to all the enabled links. If the link S2 X  X 1 fails, STP automatically reactivates the link
S2 X  X 3. One of the tree architecture drawbacks is that some redundant links are not used to transmit application frames and that communications along the tree are not necessarily following the shortest path.

It is also important to note that the basic spanning tree is defined independently of traffic origins and destinations. Fig. 3 shows how such an optimization may be achieved. Indeed, in Fig. 3 (a) S4 and S5 send frames to S1 and S3, respectively. The link S1 X  X 2 supports all the communications, and the disabled link
S2 X  X 3 does not transmit any messages. One way to balance the traffic on two links on switched Ethernet is to implement either
MSTP (Multiple STP, IEEE 802.1s) or PVST (Per-Vlan STP, Cisco proprietary protocol). The aim of these protocols is to offer the possibility of defining as many trees as possible as Virtual
Networks (VLAN, IEEE 802.1q). In Fig. 3 (b), S1 and S4 are defined in the VLAN 1, S3 and S5 are in the VLAN 2. The MSTP is activated
S 4 S 5
S 4 S 5 and disables the link S2 X  X 3 from the tree used by the VLAN 1. In the same way, MSTP disables the link S1 X  X 3 from the tree associated with the VLAN 2. The interest of these two stacked trees (at it is shown in Fig. 3 (b)) is to balance the traffic load between links S1 X  X 2 and S2 X  X 3. 3.2. Reconfiguration time
As described previously, the STP issue is the reconfiguration time period to propose a new fit tree. This time period is between 30 s and 50 s. It corresponds to the addition of three times. Firstly, the waiting time to receive BPDU (Bridge Protocol Data Units), of about 20 s. Secondly, the listening time for each interface sub-jected to change of state of 15 s. Thirdly, let us note the interface reconfiguration time of about 15 s. The new Rapid STP (RSTP, IEEE 802.1w) mitigates this reconfiguration time and enables the proposed new physical architecture in less than 5 s. However, these times may still not be adapted to real-time environments. The MOXA company has then designed a new mechanism named Turbo-ring , which ensures an Ethernet reconfiguration time per-iod around 20 ms. But this solution is not standardized and it is suitable only for a particular topology (a ring). The objective of this paper is to define a method to avoid this discontinuity of service by eliminating it. 3.3. Related works
In Jayavelu et al. (2009) , an on-line method is defined in packet-switched networks. It consists of a new disjoint multipath routing algorithm ( SimCT ) based on the Colored Graph Tree Theory and takes into account node failures to maintain the communication continuity between a node and a sink. The interest of Jayavelu et al. (2009) is to decrease the path length compared with other proposals and to reduce the number of protocol frame exchanges. Another approach consists of antici-pating off-line, the path failure. The PRP solution (IEC 62439) proposed by ABB ( Kirrmann et al., 2009 ) consists in using both independent Ethernet networks on which end nodes replicate frames. Duplicated frames are discarded by the receiving nodes. Limal et al. (2007) propose a similar method based on industrial Ethernet (Powerlink) without switches (hub architecture) and consist of duplicating the medium and sending the messages twice, respectively, to both mediums. However, a mechanism, called link selector in Limal et al. (2007) and link redundancy entity (LRE) in the PRP solution, is implemented inside each node to ensure incoming information consistency and to duplicate sent messages. Another field of research, similar to Imtiaz et al. (2010) , deals with 2-layer based auto-configuration of topologically addressed redundant network structures. In Imtiaz et al. (2010) an inherent dynamic redundancy management technique is defined for loop prevention. Lee et al. (2011) propose a design scheme for cost-effective and reliable Ethernet ring protection networking. However, this solution is dedicated for carrier-grade optical Ethernet networking and relies on a specific network architecture. Qiu et al. (2009) develop a solution named Fast
Spanning Tree Reconnection (FSTR) to reconnect the spanning tree when a failure occurs, but this solution causes a network service interruption. The same authors define in Qiu et al. (2008) a local restoration based on multiple spanning trees. Upon failure of a single link, the upstream switch locally restores traffic to preconfigured backup spanning trees. Two approaches are stu-died, one based on an integer linear programming model and another on heuristic algorithms. Fencl et al. (2011) propose a genetic algorithm which aims at designing independent paths between the nodes to satisfy the demands regarding the maximal delay in each communication path, the minimal acquisition costs, while preserving the reliability (e.g. redundant communication path). Finally, the reader could also refer to Huynh et al. (2010) which provides a survey on a large range of networking applica-tions ranging from the minimal constraint to the rigorous demands of industrial Ethernet networks.

These are related works, but our approach differs from the network technology. Firstly, we study switched Ethernet archi-tectures not considered in Jayavelu et al. (2009) and Limal et al. (2007) . Secondly, our main objective is to maintain the continuity of service in respect of the standards defined for switched
Ethernet, without defining additional STP mechanisms ( Qiu et al., 2008 ). The work developed by Fencl et al. (2011) is quiet similar to our proposition, but their fitness function is expressed according to time constrained and not on a reliable criterion.
Moreover, our chromosome modeling avoids the generation of unviable solutions in opposition to Fencl et al. (2011) . In our approach, we rely on the MSTP protocol to define several trees for interconnecting NCS equipment. This strategy consists of imple-menting a static procedure of forwarding as many frames as defined trees. Thus, if a path is down, the sink node receives the information by at least one of the others paths. 4. Formalization 4.1. Introduction
The first work is to define an expression formalizing the problem of the redundant paths between a source generating traffic and its destination node. A path consists of a series of network components. A network component represents either a network node (switch) or a link. The failure probability of a path depends on the number of network components constituting the path. The more the network components that are used, higher the path failure probability. Moreover, the failure probability of redundant paths can be correlated when a same network compo-nent is used in several paths. Failure of this network component affects the behavior of not only one path but of several paths.
Hence, network dependability evaluation depends on the path length (Section 4.2 ) and on the number of common network components implemented in several paths (Section 4.3 ). In the present paper, each network component is assumed to have the same failure probability. 4.2. Network dependability with independent paths
We define a i as being the number network components composing the path i . A network component is a link or a device network (switch). Let l be the failure probability per hour of any network component and m  X  1 l as being the non-failure prob-S 4 S 5
The failure probability of the network ( P Net j ) composed of j independent paths is given then by (2).
 tions (Safety Integrity Level, IEC 61508 standard). Table 1 pro-vides the values used in the continuous mode. Our research focuses on Networked Control Systems where the SIL 3 and SIL 4 are the levels generally required, especially in avionics and nuclear power plants. The analysis is based on the choice of network components with SIL 4 (with l  X  10 8 ). The aim is to observe whether the whole network (constituted of SIL 4 network components) respects the SIL 4 constraint according to both the number of paths and the number of network components used inside a path.
 network with one path is quickly degraded and the scores are upper SIL 4. The second is that a network with two independent paths gives a good result since the SIL 4 constraint is guaranteed up to 10 000 network components. Finally, the multiplication of paths considerably increases the cost of the network in terms of maintenance and complexity without necessarily improving the solution relative to SIL constraints. In conclusion, a network architecture implementing two paths is a good arrangement between dependability and cost. Consequently the next section is the study of the analysis redundancy of two paths by consider-ing overlapping effects. 4.3. Overlapping paths In this section, a network consists of two overlapping paths.
Let a i be the number of exclusive network components compos-ing the path i . An exclusive network component belongs only to one path. Let b be the number of common network components used in both paths. As a matter of course, the total length of a path i equals a i  X  b .

Consider the illustrative network shown in Fig. 5 . Two paths are sharing a common sub path. We note, on the one hand, that b  X  3. Path 1 consists of 11 components and path 2 consists of nine components.

By relying on Eq. (2), the whole network failure probability can be determined by (3) which is defined as our fitness value: Fitness  X  1  X  1  X  1 m a 1  X  X  1 m a 2  X  X  m b  X  3  X 
Let us note that the fitness function parameters a 1 , a 2 computed thereafter with the help of a function named Path (detailed in Section 5.2 ). Fig. 6 gives the failure probabilities defined in (3) according to the path length and the rate of the common network components used in the both paths: components fails, the whole network is strongly affected. As a result, performances are immediately under the SIL 4 constraint.
Eq. (3) will act as the expression formalizing the problem of the redundant paths between a source generating traffic and its destination node. In the following, the issue will be to search for pair of trees such that the paths between two nodes minimize the fitness value. Let L be the number of links and N be the number of nodes in a graph. Firstly, consider a cyclic graph (where L  X  N for N
Z 3) which is a simple case. The search space for one tree is equal to N . As a result, the search space of our problem which Failure probability of the network consists by exploring all pair of trees among the total number of trees might be limited to C 2 N . Secondly, consider the complex case of a complete graph (where L  X  N  X  N 1  X  = 2 for N Z 3). This time, the search space for one tree is equal to N N 2 as detailed in Ali and Narasimhan (1993) . As a result, the search space of our problem might be equal to C 2 N N 2  X  N N 2  X  N N 2 1  X  = 2. That is clearly a combinatory problem. Moreover, this issue is a subclass of problem studied in Jayavelu et al. (2009) which is described with complexity order O  X  9 L 99 N 9  X  . 4.4. Conclusion
The expression (3) is a general expression of (2) with two paths. As stated previously, (3) will be used as fitness value in our heuristic (described in the rolling section) to find optimized pair of trees. The network consists of many links, and many nodes such that the search for pair of trees quickly meets an explosion combinatory problem. Thereby, we propose as suggested in Jayavelu et al. (2009) to use heuristic algorithms. 5. Optimization algorithms 5.1. Choice of heuristic
There are three main classes of heuristics: the constructive methods (greedy algorithm, pilot method), the local research methods (simulated annealing, taboo search) and the evolution-ary methods (genetic algorithm, ant colony optimization). It is not easy to compare these methods, but an analysis in Dre  X  o et al. (2006) between the simulated annealing, the taboo search, the ant colony optimization and the genetic algorithms (GA) provides diagrams giving the probability that one method is better than another. In these works, we notice that for a similar problem, the GA gives the best results. Moreover, GAs are used for network optimization in many research works ( Addad et al., 2011 ; Georges et al., 2006 ). 5.2. Coding of the component networks
The network architecture is defined by a graph G  X  X  S , M  X  (a digraph or undirected graph) where S is the set of nodes, i.e. the vertices of the graph and where M is the incident matrix and which defines the network links. The matrix M stands for the  X  X  X ncident-vertex-edge matrix X  X  of dimension m n where m is the number of vertices and n is the number of edges. This matrix corresponds to the network architecture which remains fixed. Each edge from the graph is numbered such that considering an edge i interconnecting two vertices k and l , we have M  X  j , i  X  X  might be summarized in a vector where each row corresponds to one edge of G and where the columns give the edges of a given vertex.

Let us focus on the coding of spanning trees. There are several methods of spanning tree representation of graph ( Enacheanu et al., 2006 ; Nara et al., 1992 ; Zhu and Tomsovic, 2002 ; Radha et al., 2004 ; Ramos et al., 2005 ; Lin et al., 2000 ; Hong and Ho, 2005 ). Enacheanu et al. (2008) explain the coding method based on the representation in the co-tree (i.e. digital coding of open branches designed in Radha et al., 2004 ). Indeed, to build a tree, it is necessary to reject several links between nodes such that potential loops are eliminated. The interest of coding the open branches is to limit the size of the coding compared to the elementary coding in which each branch is identified with  X 0 X  or  X 1 X  if it is opened or not. The remaining issue deals with the selection of the branches to open. Since a tree aims here at eliminating potential loops, the solution consists in analyzing each fundamental loops ( Lin et al., 2000 ). A fundamental loop is defined such that it does not contain other loops. For each fundamental loop, the principle is then to open one of the edges of the loop. However, it is necessary to check whether a given branch is not opened in two distinct fundamental loops (since otherwise, it will not guarantee a fitted tree). Each branch is identified by a digit. The  X  X  X igital coding of opened branches X  X  in each fundamental loop consists finally in a vector composed by the digit of the opened branches. Accordingly, the digital coding of open branches in each fundamental loop is implemented in our algorithm which serves as basis for the coding of the population members. It will avoid the determination of fundamental loops allowing the validity of the resultant topologies after crossover and mutation processes in the genetic algorithms to be tested.
Considering the initial graph shown in Fig. 8 . First, the fundamental loops in this graph are L 1 :0-1-2-3 (where 0 stands for the branch 0), L 2 :3-4-5-6-7-8 and L 3 :8-9-10-11. Note here that the loop 3-4-5-6-7-9-10-11 is not fundamental. Secondly,
Fig. 8 shows two choices of opened branches. For individual 1, branches 1, 6 and 8 are respectively opened for loops L 1 whereas for individual 2, the opened branches are 0, 3 and 10. 11 3 4 10 8 5 2 67
Finally, it gives two possible spanning trees (i.e. population members) modeled by the sequence 1, 8, 6 (Individual 1) and 0, 3, 10 (Individual 2).
 algorithms aimed at checking if the graph is connected and identifying the nodes along a path. There are two types of algorithms for going through a graph, the Depth First Search to the analysis sequence of the vertices. The DFS explores  X  X  X eeply X  X  the paths one by one, whereas the BFS generates a research tree being made layer by layer. However, the BFS requires a lot of memory to store all the alternatives for each layer. Therefore, the DFS algorithm is implemented in our work. from the graph G is able to access any vertices of S .Running of the accessible vertices from s .Henceif V  X  S , it means that a graph is connected. This algorithm will then be used to check that the proposed trees are respectful from the spanning tree definition.
Algorithm 1. Accessible _ Nodes( G , i , V ) proposed to compute the path length. Indeed, running the graph G 0  X  X  S , M 0  X  along the path between s and e the path length is given by P . This function is useful for determining the fitness function parameters ( a 1 , a 2 and b ) established in Section 4.3 , i.e. the number of exclusive and common network components composing both paths. Thus, the Path function is a part of the fitness one.

Algorithm 2. Path( G , i , e , V , P ) output : the list P of the nodes along the path from e to i begin 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 4 5.3. Genetic algorithm
Based on observations expressed in Charles Darwin X  X   X  X  X rigin of overview of the GA used in this paper. It illustrates the natural selection principle where a set of individuals will pass through different stages. Each individual corresponds to a candidate spanning tree solution and is represented by a sequence number of the opened branches, the so-called  X  X  X hromosome X  X . The gray boxes in Fig. 9 stand for the genetic algorithm stages. Each stage consists in processing rise to new set of individuals. Information flux between stages is hence set of individuals (i.e. spanning tree solutions).
According to the type of coding previously cited, the crossover and mutation operators might generate more or less invalid individuals compared to the topological constraints. Enacheanu et al. (2008) develop a crossover and mutation strategy based on the graph theory approach. The mutation technique consists of randomly picking a gene from a chromosome (representative of an opened branch) and then determining the formed loop result-ing in the closure of this branch. Finally GA randomly selects within this loop one branch to open. This principle is illustrated in Fig. 10 .
The crossover technique illustrated in Fig. 11 consists in randomly picking a reference point in the chromosome of the individual I1, and then determining the loop to be formed after the closure of this branch. GA looks for branches which might be exchanged between the two co-trees. Moreover, it is necessary to analyze the chromosome of the individual I2. If there are genes belonging to the loop, GA has to make the crossing with one of them. It is necessary to repeat this step until reaching the last gene. Let us notice that the crossover and mutation processes do not give 100% of fitted individuals. However, Enacheanu et al. (2008) bring into play the co-cycle notion in order to identify quickly and certainly the good branch for swapping, although it does not guarantee that resulting individuals will be in line with the topology constraints. In this paper, the co-cycle approach is not implemented and not conformed individuals are excluded. 5.4. Adjustments of GA parameters
Goldberg (1989) defines conventional GA parameters such as population size t pop , crossover p c and mutation p m probabilities. These parameters have an influence on the GA performance. It is then necessary to study the impact of each probability on GA behavior to determine their optimal values. Georges et al. (2006) propose an approach allowing to achieve these adjustments. This method is applied in our research.

As a rough guide, note that a too small population would likely converge toward a minimum local. Conversely, a too large population increases the GA processing time and thereby it slows down the convergence time. In conclusion, it is necessary to find a good balance between GA processing time and result quality.
The population density depends on the coding, the used methods and the computing power. Four t pop sizes are considered in our study (5, 10, 20 and 100). Two different views related to the t influence are given in Fig. 12 . The first one (i.e. Fig. 12 (a)) depicts the behavior of GA when considering a unique run of a graph consisting of 100 nodes and 240 links. For each size, the evolution of the optimal value of the cost function according to the number of generations is drawn. The time spent to reach the same optimum is also given in Fig. 12 (a). A population size of 100 enables to obtain in a few generations the optimal solution, however its processing time is very long (24 min) since GA performs a large number of crossover and mutation operations (due to the significant population size). A population of 5 shows that GA converges in 8 min but it needs a large number of iterations (approximately 140) due to the little population density/diversity. A population of 20 tends to reduce the proces-sing time at 10 min after 50 iterations. Nevertheless, the best arrangement for this specific graph is obtained with a population size of 10, since it finds the optimal solution in 6 min after 60 iterations.

In addition, we synthesize the influence of t pop in a box-and-whisker diagram (shown in Fig. 12 (b)) based on the 30 runs of a graph constituted of 81 nodes and 180 links. Fig. 12 (b) depicts the evolution of the optimal value of the cost function according to the processing time (and not the number of iterations). It is notable now that the convergence of GAs is not as pronounced as in Fig. 12 (a), the multiple runs tend to smooth the result curves.
Indeed, the difference in time spent to reach a same optimum is not so significant. In the previous figure (Fig. 12 (a)), there were a optimum between the population size of 10 and 100. Now, in
Fig. 12 (b) there is a difference of 5 min (20 0 15 0 ) in average between the best solution (i.e. population size of 10) and the 10 8 5 Step 1 : Random choice of one gene (branch) to mute
Step 2 : Random choice of one branch resulting from the formed loop next the closure of the branch 6. Loop: [3,4,5,6,7,9,10,11] 10 8 5 10 8 5 I1 : I2 : 0.2 e  X 14 0.4 e  X 14 0.6 e  X 14 0.8 e  X 14 1.0 e  X 14 1.2 e  X 14 1.4 e  X 14 Fitness value 0.2 e  X 14 0.4 e  X 14 0.6 e  X 14 0.8 e  X 14 1.0 e  X 14 1.2 e  X 14 1.4 e  X 14 Fitness value three others population sizes. Moreover, it is noticeable that the variation of the solutions (i.e. between the 1st and the 3th quartiles) is getting smaller and smaller when the population size increases. If we look at each interval between the 1st and the 3th quartiles for each population size, we observe that this interval is smaller the population, the less new individuals will be generated by iteration and therefore, the less the probability to have a new best solution. Let us note that according to the termination criterion, the population size could be tuned. Indeed, in case of time constrained applications, it may be sensible to choose a big population size (as 100) to get quickly a solution close to the optimal one. For instance, in Fig. 12 (b) a suitable solution for t pop  X  100 is reached in 2 min. In our case, we privilege the solution quality and Fig. 12 (b) shows that the GA converges faster toward this one for t pop  X  10 than the other population sizes, since the optimum is reached after approximatively 15 min versus 20 min for the other sizes.
 .

This operator aims at avoiding convergence to local minima. In order to fix the mutation rate, GA is tested based on a panel of 100 graphs (with 150 iterations) for p m varying from 10% to 90%, with t pop  X  10 and p c  X  80 % . We have chosen at random p c  X  80 % knowing that usually, through the literature, the p c value is upper to 60%. Fig. 13 (a) shows the fitness value relatively to the mutation rate. According to the diagram, the best mutation rate is around p m  X  40 % since the five indicators given from the wisker-diagram (namely: the minimum, the 1st and 3th quartile, the mean and the maximum values) are lower for this probability than any other mutation rate.
 diversity. The more the crossover rate p c is high, the more there are new individuals in the population tested. In order to fix the crossover rate, GA is executed for the same panel of graphs and the same number of iterations, for p c varying from 10% to 90%, with t pop  X  10 and p m  X  40 % . Fig. 13 (b) shows the fitness values relatively to the crossover rates synthesized in a box-and-whisker diagram based on the graph panel. It suggests that a crossover rate around 70% gives the best results. Indeed, the lowest average fitness value is found for p c  X  70 % which is equal to 1 : 3 e comparison between the efficiency of the crossover probabilities is larger considering that 75% of results (3 th quartile) for p are inferior to 1 : 5 e 14 contrary to the other p c rates which vary approximatively from 1 : 8 e 14 to 2 : 1 e 14 .

In resume, for the GA X  X  parameters after a series of experi-ments are fixed to: t pop  X  10, p c  X  70 % and p m  X  40 % , since the fitness function converges relatively quickly with a mutation probability lesser than the crossover one in order not to hinder effectiveness of the crossover exploration. 6. Case study 6.1. Introduction
Firstly, specific nodes were developed in the OPNET network simulation tool, to implement the behavior of NCS devices: Fig. 14 illustrates the graphic interface of these new nodes tuning to the
PLC cycle time, the communication cycle time, and the types of devices.

To give numerical results, the approach presented in this paper will be applied on a sample system with controller and process transfer functions P  X  s  X  and C  X  s  X  respectively such as:
P  X  s  X  X  2
Secondly, the topology relies on a switched Ethernet architec-ture consisting of 31 switches and 56 links as depicted in Fig. 15 .
The NCS devices (controller, sensor, actuator) are respectively connected to switches 20, 5 and 11. The control sampling time is fixed at 2 ms whereas the measurements and control values (packets of 74 bytes) are exchanged each 1 ms.

Two cases are considered in this study. The first one uses the classic solution with the Spanning Tree Protocol (STP). The second one applies the method proposed in the present paper by implementing two paths obtained from GA. Rapid STP is activated on the simulation tool for defining both trees. To improve the understanding of the figures, only the links belonging to the paths between the NCS devices are highlighted (bold for the first tree and dashed bold lines for the second tree) and not the global tree. 6.2. NCS analysis with RSTP
Fig. 15 shows the path used by the controller to communicate both with its sensor and actuator. This path is a part of one tree that can be defined by RSTP for a particular set of switches and ports X  identifiers. During the simulation, the link 8, belonging to process output according to the reference. Before the link failure, the process reaches the reference with an acceptable overshot.
When the link 8 fails, the actuator is disconnected to the network and consequently to the controller during 5 s corresponding to the RSTP reconfiguration time period. Thus, between t  X  115 s and t  X  120 s, the new references are not taken into account by the process. After t  X  120 s, the controller is able to send to the actuator the new control through a new path (resulting from the RSTP process), but an instability period is observed before this new control again reaches the reference. This instability step may be due to the reception of old messages (by the actuator) buffered in the network. 6.3. NCS analysis with two redundant paths relying on MSTP
The redundant paths is estimated by using GA with the tuning stops when an individual (pair of trees) reaches the SIL 4 level (i.e. the termination criterion, cf. Fig. 9 ). Solutions for a small network as depicted in Fig. 15 were obtained in average after 2 min.
Fig. 16 shows the result with two independent paths for interconnecting the controller and the process. Two VLANs are defined and two trees are created respectively for each VLAN by using MSTP. In practice, spanning trees will be configured by adapting the switches X  ports priorities and the link costs. In this approach, the controller duplicates the control messages on both trees and it receives twice the sensor state.

The sequence of link failures defined in the simulation is given by the following: sequence no. 1: the link 6 fails at t  X  115 s and is recovered at t  X  125 s , sequence no. 2: the link 33 fails at t  X  135 s and is recovered at t  X  145 s , sequence no . 3: the two links 6 and 33 fail at t  X  160 s.
In sequence no. 1, when the link 6 fails at t  X  120 s, Fig. 17 (c) shows that the process continues to work because only the path associated to VLAN 1 is broken, and the connectivity is maintained by the second path associated to VLAN 2. The behavior is similar in sequence no. 2 (i.e. when link 33 fails), but the paths are inverted (i.e. VLAN 2 is broken and not VLAN 1).
For these two steps, the failure occurrences have no impact on the process control, as highlighted in Fig. 17 (c). In the last sequence (no. 3), when both links 6 and 33 fail at t  X  160 s, the system becomes unstable. Indeed, no message reaches the destinations anymore until a new path is recomputed by the STP algorithm (i.e. 5 s after the failure, namely 160  X  5 s). However, this failure occurrence at t  X  160 s appears with a probability at SIL 4 if all the network components are SIL 4 as it is explained in Section 4 .In fact, we launched 30 runs (stopped when the fitness value stands for a SIL 4 solution) in order to obtain different pairs of trees to interconnect the controller and the process. Note that no matter what the pair, the same behavior than in Fig. 17 (c) was observed.
This shows that for this case study, GA enables to match a network performance level compatible with the NCS require-ments. However, when failures occur simultaneously on both paths, performances of the communication will correspond to those provided by RSTP protocol. 6.4. Temporal validity of messages consistency control of the information system. The duplication generates desynchronizations since the duplicated messages do not arrive at the same time at the destination nodes. Fig. 17 (b) illustrates this problem by adding load traffic at t  X  130 s on the link 42 (path VLAN 2). This overload generates congestion and some delays on messages which are forwarded across the path of VLAN 2. Consequently, the messages sent on path VLAN 1 arrive before the ones using the path VLAN 2. Fig. 17 (b) shows instabilities since the controller processes received messages in FIFO order, without managing their temporal validity. This trouble can be suppressed either by numbering or timing the messages. The numbering of messages is implemented in our
OPNET simulations and the reception nodes discard all messages containing  X  X  X ld X  X  numbers. This method is applied to eliminate the instabilities issues and the results are similar to the Fig. 17 (c). 7. Conclusion
The paper presents both a strategy to face the high depend-ability constraints and an off-line method to define, in practice the pair of paths for each traffic based on a local configuration (without modifying Ethernet standards). This method is based on two redundant paths determined and defined by a genetic algorithm and relies on message duplication incorporated in the
MSTP technique. The main aim is to reduce the probability of communication disconnection in particular in an NCS framework.
However, this method has to be applied only for specific nodes which are strongly timed constrained. It cannot be generalized for all the nodes of the network, since the duplication of messages induces overload. Finally, current works are related to the application of this contribution for defining robust hybrid net-work infrastructures based on wireless access points. Acknowledgments
This work was supported by OPNET Technologies, Inc. Thanks to  X  X  X eaching with OPNET X  X  program.
 References
