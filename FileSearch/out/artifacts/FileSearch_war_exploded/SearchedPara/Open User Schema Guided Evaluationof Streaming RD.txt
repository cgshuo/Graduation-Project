  X  Performance and scalability are two issues that are becom-ing increasingly pressing as RDF data model is applied to real-world applications. Because neither vertical nor flat structures of RDF storage can handle frequent schema up-dates and meanwhile avoid possible long-chain joins, there is no clear winner between these two typical structures. In this paper, we propose an alternative storage schema called open user schema. The open user schema consists of flat tables automatically extracted from RDF query streams. A query is divided into two parts and conquered, respectively, on the flat tables in the open user schema and on the vertical table stored in a backend storage. At the core of this divide and conquer architecture with open user schema, an efficient isomorphism decision algorithm is given to guide a query to related flat tables in the open user schema. Our proposal in essence departs from existing methods in that it can accom-modate schema updates without possible long-chain joins. We implement our approach and provide empirical evalua-tions to demonstrate both efficiency and effectiveness of our approach in evaluating complex RDF queries.
 Categories and Subject Descriptors: H.2.4 [Database Management]: Query processing General Terms: Algorithms.
 Keywords: Query Processing, RDF Query, RDF Indexing.  X  This work is supported by the National Natural Science Foundation of China under grant No. 60973023.  X  This author is the corresponding author.

By exploring database techniques, we study approaches to improving the performance and scalability of RDF data querywhicharenowthebottleneckoftheSemanticWeb vision. Data in RDF model can be directly stored in a rela-tional table, a triple table [10, 13, 1] for example. An iden-tified resource with semantic meaning can be constructed by recursively joining the triple table. Besides employing index or optimization techniques to speed up joins [12, 13, 11], the proliferation of expensive joins can be controlled by exploring schema information of RDF data. RDFS or OWL, visioned as the schema of RDF data, can be used to encode the formal semantics of RDF data, where triples can be fixedly combined into a flat table based on RDFS or OWL [5, 14]. However, the prior fixed flat tables can not accommodate the variety of or updates on flexible RDF schema which is definitely necessary in the open world of the World Wide Web.
 To conquer the dilemma of either vertical or flat tables, Open User Schema (OU-Schema for short), is proposed. Semantically, an OU-Schema is a relational schema consist-ing of a set of flat tables. Operationally, an OU-Schema is continuously extracted from users X  query patterns. For ex-ample, frequent query patterns are extracted by streaming algorithms [9, 15] and transformed to flat tables. The auto-matically extracted schema, rather than prior fixed, is there-fore open to schema updates. Consequently, RDF storage is divided into two parts, materialized query pattern matches and a triple table of RDF triples at the backend storage, rdf-3x [10] for example. The two components of storage is called Divide and Conquer architecture (DC-Arc for short).
The key point of DC-Arc with OU-Schema is how to effi-ciently guide a query evaluation to related tables in an OU-Schema. Therefore, DC-Arc with OU-Schema faces two key problems: efficiency problem of query evaluation guided by OU-Schema and effectiveness problem of OU-Schema main-tenance for incoming queries.

The killer of problems in DC-Arc with OU-Schema is an efficient isomorphism decision algorithm. With the isomor-phism decision algorithm at hand, query patterns with the same semantics can be related although they are in differ-ent forms. Hence, a query is efficiently divided into pieces of sub-queries which semantically equal to query patterns in the OU-Schema. As a result, the query is guided to re-lated flat tables in the OU-Schema and a triple table at the backend storage.
Our work distinguishes itself from most existing works in the following aspects. Firstly, query optimization with ma-terialized views in relational database [3] is considered in the case of prior fixed relational data schema while RDF data model is schema-relax/free. In XML data model, the compact storage of materialized XML views is focused [6, 4]. Secondly, the prior fixed schema is helpful to binding queries with materialized views while no schema information can be explored to guide a query pattern to related tables automat-ically extracted. Thirdly, besides enabling open user schema to be automatically configured over query streams, it is not trivial to guide a query to related tables in an OU-Schema as it involves isomorphism decision between graphs as shown in later sections.
Following the semantics in [2], we provide an algebraic formalization of the core fragment of SPARQL over RDF. The two sets of U and V are pairwise disjoint infinite sets, where U represents the set of URIs and V the set of vari-ables. Let triple space G =( U  X  U  X  U ) and triple pattern space P =( U  X  V )  X  ( U  X  V )  X  ( U  X  V ). An RDF triple is atriple( s, p, o )  X  G ,where s represents subject, p predicate and o object. An RDF graph G is a subset of G , containing RDF triples.

Definition 1. RDF pattern/query pattern: A triple pat-tern is a triple q  X  P .Theset Q of triple patterns is called an RDF pattern or a query pattern.

Let var ( Q ) denote the set of variables occurring in a query pattern Q . M is the family of all one-to-one partial functions from V to U . For a map  X   X  M , its domain is dom (  X  ). In this paper, a map  X  can be expressed as a set of { ? x  X  u | ? x V, u  X  U } , denoting a variable ? x in V is mapped to a URI in U . Hence, given ? x  X  dom (  X  ),  X  (? x )= u iff ? x  X  Therefore, given an RDF pattern Q ,if dom (  X  )= var ( Q ),  X  ( Q ) is an RDF graph which is obtained by replacing each variable in var ( Q ) according  X  .

Definition 2. Pattern match: Given a query pattern Q on RDF graph G ,thematch [ Q ] G of Q on G is the set of {  X  ( Q ) | dom (  X  )= var ( Q ) ,  X  ( Q )  X  G } .

In fact, [ Q ] G contains pieces of graph G which match the query pattern Q .
Since pattern match is the core of the current RDF query standard SPARQL, we focus our effort on improving the scalability of pattern match which is currently the bottleneck of RDF query process. A query pattern Q i and its var ( Q forms a relational table Q i ( var ( Q i )), where Q i acts as the relation name, each variable in var ( Q i ) plays the role of an attribute name in the relational table. And, [ Q i ]isthe instance of the schema Q i .

Definition 3. Open user schema: An open user schema (OU-Schema for short) is a relational schema which consists of a set  X  of query patterns Q i
Given two query patterns Q i and Q i , if there is an one to one map  X  from var ( Q i )to var ( Q i ), we can replace each variable ? x i in Q i with  X  (? x i )in var ( Q i )andobtain  X  ( Q If  X  ( Q i )= Q i , they share the same instance by renaming attribute name ? x i with  X  (? x i ).

Definition 4. Isomorphic query patterns: Two query pat-terns Q i and Q i are called isomorphic, denoted as Q i  X  iffthereisaonetoonemap  X  from var ( Q i ) to var ( Q i ) so that  X  ( Q i )= Q i .

We also give the following definitions extended from the definition of isomorphic query patterns.

Definition 5. Given a set  X  of query patterns, a query pattern Q is isomorphically contained in  X  , denoted as Q iff  X  Q  X   X  , Q  X  Q .

Definition 6. A query pattern Q i is semantically included by query pattern Q j , denoted as Q i Q j iff there is a subset Q j of Q j so that Q j With the definition of isomorphic query patterns, given OU-Schema  X  = { Q i } , a query pattern Q can be divided into ( We call Q/  X  the residency of Q with respect to  X . Each [ Q can be conquered from [ Q i ] by renaming the attribute name ? x i in [ Q i ] with attribute name ? x i in [ Q i ] because Q Q i are isomorphic and  X  (? x i )=? x i . The residency [ Q/  X ] is returned by evaluating Q/  X  on a triple table using Rdf-3x query engine [10]. At last [ Q ] is obtained by natural joins of [ Q i ]and[ Q/  X ]. That is [ Q ]=[ Q 1 ] [ Q 2 ]  X  X  X  [ Q n ] [ Q/  X ].
The goal of our DC-Arc with OU-Schema is that instead of directly applying Q on G , we apply one small piece Q/  X of Q on G while the others are obtained from  X  without expen-sive long-chain join or union operations. Consequently, the performance, as well as scalability, of RDF query is achieved.
Definition 7. Total order set (  X  ,U  X  V ) :1)  X  x, y  X  U , x&lt;y iff x precedes y in terms of lexical order. 2)  X  x U, y  X  V , x&lt;y .3)twovariables ? x , ? y  X  V are always in the same rank.
 The total order on U  X  V can be extended to triple pattern space P .

Definition 8. Total order set (  X  , P ) : Each triple pattern is ordered by ( s, p, o ) order where each component of a triple pattern is ordered by  X  in Definition 7. q 1  X  q 2 means two triple patterns are in the same rank.

It is not always possible to serialize triple patterns in a query pattern. To simplify our problem, we define a special case where triple patterns in a query can be strictly serial-ized.

Definition 9. Strict query pattern: A query pattern Q is strict if  X  X  q 1 ,q 2  X  Q , q 1  X  q 2 .
In the special case of strict query patterns, two strict query patterns are sorted in terms of the order defined in Defini-tion 8, respectively, and the pairs of variables in the same rank are checked. In order to speed up checking, we first normalize each strict query pattern. Given a strict query pattern Q , sN orm ( Q ) works as follows. For each variable ? x  X  var ( Q ), if ? x is the i th variable appearing in the sorted Q ,wereplace? x with ? i . After normalization, two isomor-phic query patterns become the same. Therefore, a function sIsom ( Q, Q ) for deciding isomorphic strict query patterns can return true iif sN orm ( Q )= sN orm ( Q ).
 Theorem 1. Given two strict query patterns Q and Q , Q  X  Q iff sN orm ( Q )= sN orm ( Q ) .
To deal with general query patterns, we can divide a non-strict query pattern Q into the union of strict query patterns Q . That is, we transform Q [ i ]to Q j , where set Q [ i ] contains the triple patterns in the i th rank while Q j is strict.
In this paper, a query graph is used as the basic tool to generate strict query patterns. A query pattern Q is consid-ered as a query graph, where each triple pattern is a node and an edge exists between two triple patterns when they share the same variable. The goal is to divide the query graph into semantic clusters where each cluster is a strict query pattern. Triple patterns in a semantic cluster are highly coupled, while two semantic clusters are highly de-coupled. We propose a greedy approach to dividing a query graph into strict sub-graphs with the aim of minimizing the maximum number of edges between two sub-graphs.

Initially, one of the hottest nodes with the maximum de-gree in the query graph is selected into Q i as the seed. Re-peat choosing one of the nodes with maximum number of edges incident with triple in Q i if Q i is still strict after the selected node is inserted. Until no node can be inserted into Q , Q i forms a semantic cluster. Then, on Q  X  Q i , repeat the above precess to form new semantic clusters.
To divide a query pattern Q into ( Q the first choice, index techniques can be used to control the exponential number of function calls. With the order on P in Definition 8, we can serialize triple patterns in a query pattern by sorting them. After the serialization, a strict query pattern is viewed as an interval with two end points min Q and max Q . Hence, the OU-Schema  X  consisting of strict query patterns is considered as a set of intervals. Given a query pattern Q , we need to search all intervals in  X  which correspond to the sub-intervals included by Q . However, it is not easy to design an efficient index structure to speed up such a search, which is demonstrated in [8, 7] due to the nature of the partial order on  X .

To surmount the problem of indexing a partial order set, we transform the problem of searching included intervals into the problem of computing the semantical intersections between a query pattern and a set of query patterns. First, we give the definition of semantical intersection between two query patterns as follows.

Definition 10. Semantical intersection: Give two query patterns Q and Q , Q
After Q lemma says that we can filter out unnecessary function calls to decide whether Q i Q .
 Lemma 1. Given two query patterns Q and Q , Q  X   X  Q  X  Q iff Q Q .
 In the following subsections, we first consider the problem of computing Q help of index techniques. We then consider the problem of dividing Q with respect to  X . We design a B + -tree like structure to speed up computing Q  X   X  Figure 1: OU-Schema Storage and Pattern Division sort all triple patterns in it based on the order defined in Definition 8. In Figure 1, each line segment represents a triple pattern and triple patterns in the same rank are placed at one column. We use the pair ( q i ,ID q i )todenotethe triple patterns in the same rank, where ID q i contains all ids of query patterns which include a triple pattern in the same rank with q i . Therefore, in Figure 1, each column corresponds to a pair of ( q i ,ID q i ).

In Figure 1, given a query pattern Q , in the sorted list of ( q q in Q corresponds to ( q i ,ID q i )if q j  X  q i . We handle triple patterns in Q one by one according to their order. For a triple pattern q j in Q , we first locate its corresponding pair ( q ,ID q i ). Then for each id in ID q i , if the set Q id does not exist, we create it and insert q j into it, otherwise we directly insert q j into it. Clearly, we have Q id = Q All semantical intersections between Q and  X  are obtained in a batch.

Theorem 2. Given a query pattern Q and a set  X  of query patterns, in terms of the number of triple patterns in Q , there is a linear complexity algorithm which computes each Q
In order to maintain the sorted list of ( q 1 ,ID q 1 )  X  X  X  ordered by q i shown in Figure 1, the B + -tree like structure B  X  -tree is used so that it admits insertion and deletion. Another B + -tree like structure B  X  -tree is used to store the OU-Schema  X . Both trees are the augmented structure of B + -tree. Given a strict pattern Q and its identification id , Algorithm 1 presents a sketch of their storage procedure. In this subsection, we present Algorithm 2 for dividing Q with respect to a given  X . First, each Q id is obtained Algorithm 1 sStore ( Q , id ) 4: else 6: end if 8: end for with the help of index B  X  -tree(line1). Given Q id and Q are strict query patterns, if | Q id | = | Q id | then it is possi-ble that Q id  X  Q id (line 3). Function sISorm ( Q id , Q called to decide whether Q id  X  Q id (line 4-6). At last, the algorithm can output all marked Q id as Q id  X   X . Therefore, Q =( Q Algorithm 2 isoDivide ( Q , X ) 6: end if 7: end if 8: end for 9: output all marked Q id ;
Theorem 3. Given a query pattern Q with respect to  X  , each query pattern Q i  X   X  is output by Algorithm 2, where Q i  X  Q .

The complexity of computing all Q id  X   X  is linear. So is the complexity of deciding isomorphism between two strict query patterns. The number of Q id  X   X  is no more than the query patterns in  X .
We use random walk to generate query patterns with pa-rameters in Table 1. Two triples with common components are neighboring. The set n ( p ) contains triples neighboring to p . Given the set P of triples, n ( P )= p  X  P n ( p ). The degree of a triple p is | n ( p ) | . The frequency of a URI is the number of triples in the data set which contain the URI. A query pattern Q is generated in two phases. In the first phase, we randomly select one of the tripes from data sets into Q as the seed. Repeat adding a triple from n ( Q )into Q in either a random way or a skewed way until the required properties of Q are met. In the second phase, we replace some components of triples with variables to obtain query patterns also in either a random way or a skewed way.
We observe that query patterns generated in a way skewed by high degree can lead to a large size of intermediate results while by high frequency a large number of joins. Further, in the case of query patterns generated in a skewed way, OU-Schema is more effective to raising the coverage of a query pattern.

Except for the length of query patterns, the number of matches, as well as the intermediate partial matches, makes a significant impact on query time. DC is more effective in the cases of long query patterns or large sizes of matches/partial matches. Our method of extracting frequent query patterns is memory-efficient and our greedy division for non-strict query patterns is effective.
In this paper, we proposed the DC-Arc with OU-Schema where a query pattern is divided into two parts and con-quered on flat tables in the OU-Schema and vertical struc-tures in the backend storage, respectively. We presented an lightweight approach to deciding isomorphic query pat-terns to guide a query to related flat tables and to extract frequent common patterns semantically included in query streams, and an approach to speeding up the query process. [1] D. J. Abadi, A. Marcus, S. R. Madden, and [2] M. Arenas, C. Gutierrez, and J. P  X  erez. Foundations of [3] S. Chaudhuri, R. Krishnamurthy, S. Potamianos, and [4] D. Chen and C.-Y. Chan. Viewjoin: Efficient [5] E. I. Chong, S. Das, G. Eadon, and J. Srinivasan. An [6] P. Godfrey, J. Gryz, A. Hoppe, W. Ma, and [7] J. M. Hellerstein, E. Koutsoupias, and C. H.
 [8] E. G. Hoel and H. Samet. A qualitative comparison [9] G. S. Manku and R. Motwani. Approximate frequency [10] T. Neumann and G. Weikum. Rdf-3x: a risc-style [11] T. Neumann and G. Weikum. Scalable join processing [12] T. Neumann and G. Weikum. The rdf-3x engine for [13] C. Weiss, P. Karras, and A. Bernstein. Hexastore: [14] K. Wilkinson, C. Sayers, H. A. Kuno, and [15] J. X. Yu, Z. Chong, H. Lu, and A. Zhou. False positive
