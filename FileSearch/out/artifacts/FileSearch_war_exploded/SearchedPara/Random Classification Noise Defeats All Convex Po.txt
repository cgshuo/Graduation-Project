 Philip M. Long plong@google.com Google, 1600 Amphitheatre Parkway, Mountain View, CA 94043 Rocco A. Servedio rocco@cs.columbia.edu 1.1. Background Much work has been done on viewing boosting algo-rithms as greedy iterative algorithms that perform a coordinate-wise gradient descent to minimize a poten-tial function of the margin of the examples, see e.g. [3, 12, 19, 7, 18, 2]. In this framework every poten-tial function  X  defines an algorithm that may possi-bly be a boosting algorithm; we denote the algorithm corresponding to  X  by B  X  . For example, AdaBoost [11] and its confidence-rated generalization [20] may be viewed as the algorithm B  X  corresponding to the potential function  X  ( z ) = e  X  z . The MadaBoost algo-rithm of Domingo and Watanabe [5] may be viewed as the algorithm B  X  corresponding to (We give a more detailed description of exactly what the algorithm B  X  is for a given potential function  X  in Section 2.2.) 1.2. Motivation: noise-tolerant boosters? It has been widely observed that AdaBoost can suf-fer poor performance when run on noisy data, see e.g. [10, 17, 4]. The most commonly given explanation for this is that the exponential reweighting of examples which it performs (a consequence of the exponential potential function) can cause the algorithm to invest too much  X  X ffort X  on correctly classifying noisy exam-ples. Boosting algorithms such as MadaBoost [5] and LogitBoost [12] based on a range of other potential functions have subsequently been provided, sometimes with an explicitly stated motivation of rectifying Ad-aBoost X  X  poor noise tolerance. However, we are not aware of rigorous results establishing provable noise tolerance for any boosting algorithms that fit into the potential functions framework, even for mild forms of noise such as random classification noise (henceforth abbreviated RCN) at low noise rates. This motivates the following question: are Adaboost X  X  difficulties in dealing with noise due solely to its exponential weight-ing scheme, or are these difficulties inherent in the po-tential function approach to boosting? 1.3. Our results: convex potential boosters This paper shows that the potential function boosting approach provably cannot yield learning algorithms that tolerate even low levels of random classification noise when convex potential functions are used. More precisely, we exhibit a fixed natural set of base classi-fiers h 1 , . . . , h n and show that for every convex func-tion  X  satisfying some very mild conditions and every noise rate  X  &gt; 0, there is a multiset S of labeled ex-amples such that the following holds:  X  There is a linear separator sgn(  X  1 h 1 + +  X  n h n )  X  When the algorithm B  X  is run on the distribu-This result shows that random classification noise can cause convex potential function boosters to fail in a rather strong sense. We note that as discussed in Section 7, there do exist known boosting algorithms [13, 16] that can tolerate random classification noise, and in particular can efficiently achieve perfect accu-racy on S , after at most poly(1 / X  ) stages of boosting, when run on D  X ,S in the scenario described above. Recently Bartlett and Traskin proved that the Ad-aBoost algorithm is consistent if it is stopped after a suitable number of iterations, given certain conditions on a random source generating the data [1]. Our anal-ysis does not contradict theirs because the source in our construction does not satisfy Condition 1 of their paper. To see why this is the case it is useful, as has become customary, to think of the contribution that a given example makes to the potential as a  X  X oss X  paid by the learning algorithm. Informally, Condi-tion 1 from [1] requires linear combinations of base classifier predictions to have total loss arbitrarily close to the best possible loss for any measurable function. Our analysis takes advantage of the fact that, for lin-ear combinations of base classifiers with a convex loss function, large-margin errors are especially egregious: we present the learner with a choice between a lot of cheap errors and relatively few expensive errors. If optimization were to be performed over all measur-able functions, roughly speaking, it would be possible to make all errors cheap.
 Though the analysis required to establish our main result is somewhat delicate, the actual construction is quite simple and admits an intuitive explanation (see Section 4.2). For every convex potential function  X  we use the same set of only n = 2 base classifiers (these are confidence-rated base classifiers which out-put real values in the range [  X  1 , 1]), and the multi-set S contains only three distinct labeled examples; one of these occurs twice in S , for a total multiset size of four. We expect that many other construc-tions which similarly show the brittleness of convex potential boosters to random classification noise can be given. We describe experiments with one such construction that uses Boolean-valued weak classifiers rather than confidence-rated ones in Section 6. Throughout the paper X will denote the instance space. H = { h 1 , . . . , h n } will denote a fixed finite collection of base classifiers over X , where each base classifier is a function h i : X  X  [  X  1 , 1]; i.e. we shall work with confidence-rated base classifiers. S = ( x multiset of m examples with binary labels. 2.1. Convex potential functions We adopt the following natural definition which, as we discuss in Section 5, captures a broad range of different potential functions that have been studied.
 Definition 1 We say that  X  : R  X  R is a convex po-tential function if  X  satisfies the following properties: 1.  X  is convex and nonincreasing and  X   X  C 1 (i.e.  X  2.  X   X  (0) &lt; 0 and lim x  X  +  X   X  ( x ) = 0 . 2.2. Convex potential boosters Let  X  be a convex potential function, H = { h 1 , . . . , h n } a fixed set of base classifiers, and S = ( x 1 , y 1 ) , . . . , ( x m , y m ) a multiset of labeled examples. Similarly to Duffy and Helmbold [6, 7], we consider an iterative algorithm which we denote B  X  . The al-gorithm performs a coordinatewise gradient descent through the space of all possible coefficient vectors for the weak hypotheses, in an attempt to minimize the convex potential function of the margins of the exam-ples. We now give a more precise description of how B  X  works when run with H on S .
 Algorithm B  X  maintains a vector (  X  1 , ...,  X  n ) of voting weights for the base classifiers h 1 , ..., h n . The weights are initialized to 0. In a given round T , the algorithm chooses an index i T of a base classifier, and modifies the value of  X  i can be thought of as adding base classifier number i T to a pool of voters, and choosing a voting weight. pothesis that the algorithm has constructed prior to stage T (so at stage T = 1 the hypothesis F is iden-tically zero.) We write P  X ,S to denote the  X  X lobal X  potential function over S which represents the overall potential of a hypothesis vector (  X  1 , . . . ,  X  n ) on the sample S. It is easy to check that this is a convex function from R n (the space of all possible (  X  1 , . . . ,  X  n ) coefficient vectors for F ) to R . In stage T the algorithm B  X  first chooses a base clas-sifier by choosing i T to be the index i  X  [ n ] which maximizes and then choosing a new value of  X  i mize P  X ,S (  X  1 , ...,  X  n ) for the resulting  X  1 , ...,  X  in the terminology of [6] we consider  X  X n-normalized X  algorithms which preserve the original weighting fac-tors  X  1 ,  X  2 , etc. The AdaBoost algorithm is an exam-ple of an algorithm that falls into this framework, as are the other algorithms we discuss in Section 5. Note that the fact that B  X  can determine the exactly opti-mal weak classifier to add in each round errs on the side of pessimism in our analysis.
 In our analysis, we will consider the case in which B  X  as being run on a distribution D  X ,S obtained by starting with a finite multiset of examples, and adding indepen-dent misclassification noise. One can naturally extend the definition of B  X  to apply to probability distribu-tions over X  X { X  1 , 1 } by extending the definition of potential in (2) as follows For rational values of  X  , running B  X  on (3) for D = D  X ,S is equivalent to running B  X  over a finite multiset in which each element of S occurs a number of times proportional to its weight under D . 2.3. Boosting Fix a classifier c : X  X  { X  1 , 1 } and a multiset S = ( x 1 , y 1 ) , . . . , ( x m , y m ) of labeled examples. We say that a set of base classifiers H = { h 1 , . . . , h n boostable with respect to c and S if there is a vector  X   X  R n such that for all i = 1 , . . . , m , we have If  X  &gt; 0 is such that for all i , we say that H is boostable w.r.t. c and S with margin  X .
 It is well known that if H is boostable w.r.t. c and S with margin  X  , then a range of different boosting algo-rithms (such as AdaBoost) can be run on the noise-free data set S to efficiently construct a final classifier that correctly labels every example in S. As one concrete ex-ample, after O ( log m  X  2 ) stages of boosting AdaBoost will construct a linear combination F ( x ) = P n i =1  X  i h i of the base classifiers such that sgn( F ( x i )) = y i for all i = 1 , . . . , m ; see [11, 20] for details. 2.4. Random classification noise and Random classification noise is a simple, natural, and well-studied model of how benign (nonadversarial) noise can affect data. Given a multiset S of labeled examples and a value 0 &lt;  X  &lt; 1 2 , we write D  X ,S to denote the distribution corresponding to S corrupted with random classification noise at rate  X . A draw from D  X ,S is obtained by drawing ( x, y ) uniformly at ran-dom from S and independently flipping the binary la-bel y with probability  X .
 We say that an algorithm B is a boosting algorithm which tolerates RCN at rate  X  if B has the following property. Let c be a target classifier, S be a multiset of m examples, and H be a set of base classifiers such that H is boostable w.r.t. c and S . Then for any  X  &gt; 0, if B is run with H as the set of base classifiers on D  X ,S , at some stage of boosting B constructs a classifier g which has accuracy The accuracy rate above is in some sense optimal, since known results [13] show that no  X  X lack-box X  boosting algorithm can be guaranteed to construct a classifier g whose accuracy exceeds 1  X   X  in the presence of RCN at rate  X . As we discuss in Section 7, there are known boosting algorithms [13, 16] which can tolerate RCN at rate  X  for any 0 &lt;  X  &lt; 1 / 2. These algorithms, which do not follow the convex potential function approach but instead build a branching program over the base classifiers, use poly(1 / X , log(1 / X  )) stages to achieve ac-curacy 1  X   X   X   X  in the presence of RCN at rate  X  if H is boostable w.r.t. c and S with margin  X .
 As was just noted, there do exist boosting algorithms (based on branching programs) that can tolerate RCN. Our main result is that no convex potential function booster can have this property: Theorem 2 Fix any convex potential function  X  . For any noise rate 0 &lt;  X  &lt; 1 / 2 , the algorithm B  X  does not tolerate RCN at rate  X .
 We obtain Theorem 2 as a direct consequence of the following stronger result, which shows that there is a simple RCN learning problem for which B  X  will in fact misclassify half the examples in S .
 Theorem 3 Fix the instance space X = [  X  1 , 1] 2  X  R 2 and the set H = { h 1 ( x ) = x 1 , h 2 ( x ) = x 2 } of confidence-rated base classifiers over X.
 For any noise rate 0 &lt;  X  &lt; 1 / 2 and any convex po-tential function  X  , there is a target classifier c , a value  X  &gt; 0 , and a multiset S of four labeled examples (three of which are distinct) such that (a) H is boostable w.r.t. c and S with margin  X  , but (b) when B  X  is run on the distribution D  X ,S , it constructs a classifier which mis-classifies two of the four examples in S . We are given an RCN noise rate 0 &lt;  X  &lt; 1 / 2 and a convex potential function  X . 4.1. The basic idea Before specifying the sample S we explain the high-level structure of our argument. Recall from (3) that P  X , D is defined as
P As noted in Section 2.2 the function P  X , D (  X  1 ,  X  2 ) is convex. It follows immediately from the definition of a convex potential function that P  X , D (  X  1 ,  X  2 )  X  0 for all (  X  1 ,  X  2 )  X  R 2 .
 The high-level idea of our proof is as follows. We shall construct a multiset S of four labeled examples in [  X  1 , 1] 2 (actually in the unit disc { x : k x k X  1 } X  R such that there is a global minimum (  X   X  1 ,  X   X  2 ) of the cor-responding P  X , D (  X  1 ,  X  2 ) which has the following two properties: 1. ( X  X igh error X ) The corresponding classifier 2. ( X  X teep slope X ) At the point (0 , 0), the direc-We now show that it suffices to establish these two properties to prove part (b) of Theorem 3. 1 Suppose we have such an S . Since P  X , D (  X  1 ,  X  2 ) depends only on the inner product between (  X  1 ,  X  2 ) and the (nor-malized) example vectors ( yx 1 , yx 2 ), it follows that ro-tating the set S around the origin by any fixed angle induces a corresponding rotation of the function P  X , D , and in particular of its minima. (Note that we have used here the fact that every example point in S lies within the unit disc; this ensures that for any rotation of S each weak hypothesis x i will always give outputs in [  X  1 , 1] as required.) Consequently a suitable rota-tion of S to S  X  will result in the corresponding rotated function P  X , D having a global minimum at a vector which lies on one of the two coordinate axes (say a vector of the form (0 ,  X  )). If this is the case, then the  X  X teep slope X  property (2) ensures that the directional derivative at (0 , 0) in this direction will be steepest, so the convex potential booster B  X  will pick a base clas-sifier corresponding to this direction (in this case h 2 ). Since a globally optimal weight vector is available in this direction (the vector of length p (  X   X  1 ) 2 + (  X   X  such a vector), B  X  will select such a vector. Once it has achieved such a global optimum it will not change its hypothesis in any subsequent stage, and thus B  X   X  X  hypothesis will have error rate 1 / 2 on the points in the rotated set S  X  by the  X  X igh error X  property (1). 4.2. The sample S Now let us define the multiset S of examples. S con-sists of three distinct examples, one of which is re-peated twice. (We shall specify the value of  X  later and show that 0 &lt;  X  &lt; 1 6 . )  X  S contains one copy of the example x = (1 , 0) with  X  S contains two copies of the example x = (  X ,  X   X  )  X  S contains one copy of the example x = (  X , 5  X  ) Thus all examples in S are positive. It is immediately clear that the classifier c ( x ) = sgn( x 1 ) correctly clas-sifies all examples in S with margin  X  &gt; 0, so the set H = { h 1 ( x ) = x 1 , h 2 ( x ) = x 2 } of base classifiers is boostable w.r.t. c and S with margin  X . We further note that since  X  &lt; 1 6 , each example in S does indeed lie in the unit disc { x : k x k X  1 } .
 Let us give some intuition for why this set S has the  X  X igh error X  property. The halfspace whose nor-mal vector is (1 , 0) classifies all examples correctly, but the noisy (negative labeled) version of the  X  X arge margin X  example causes a convex potential function to incur a very large cost for this hypothesis vec-tor. Consequently a lower cost hypothesis can be ob-tained with a vector that points rather far away from (1 , 0). The  X  X uller X  example (whose y -coordinate is 5  X  ) outweights the two  X  X enalizer X  examples (whose y -coordinates are  X   X  ), so it  X  X ulls X  the minimum cost hypothesis vector to point up into the first quadrant  X  in fact, so far up that the two  X  X enalizer X  examples are misclassified by the optimal hypothesis vector for the potential function  X .
 In Section 4.3 below we make this intuition precise and for which  X   X  1 &lt;  X   X  2 . This immediately implies that the corresponding classifier g ( x ) = sgn(  X   X  1 x 1 +  X   X  misclassifies the two copies of (  X ,  X   X  ) in S and gives us the  X  X igh error X  property (1). In Section 4.4 we show that this (  X   X  1 ,  X   X  2 ) moreover has the  X  X teep slope X  property (2). 4.3. The  X  X igh error X  property: analyzing a Let 1 &lt; N &lt;  X  be such that  X  = 1 N +1 , so 1  X   X  = N We have that
P It is clear that minimizing 4( N + 1) P  X , D is the same as minimizing P  X , D so we shall henceforth work with 4( N + 1) P  X , D since it gives rise to cleaner expressions. We have that 4( N + 1) P  X , D (  X  1 ,  X  2 ) equals Let L 1 (  X  1 ,  X  2 ) and L 2 (  X  1 ,  X  2 ) be defined as follows: For B &gt; 1 to be fixed later, let us write L 1 (  X  ) to denote L 1 (  X , B X  ) and similarly write L 2 (  X  ) to denote L (  X , B X  ) . It is easy to verify that we have
L 1 (  X  ) = N  X   X  (  X  )  X   X   X  (  X   X  ) + 2  X N  X   X  (  X  ( B  X  1)  X  X  ) and L (  X  ) =  X  2  X N  X   X  (  X  ( B  X  1)  X  X  ) + 2  X  X   X  (( B  X  1)  X  X  ) We introduce the following function to help in the anal-ysis of L 1 (  X  ) and L 2 (  X  ): Let us establish some basic properties of this function. Since  X  is differentiable and convex, we have that  X   X  is a non-decreasing function. This is easily seen to imply that Z ( ) is a non-decreasing function. We moreover have Z (0) =  X   X  (0)( N  X  1) &lt; 0 . The definition of a convex potential function implies that as  X   X  +  X  we have  X   X  (  X  )  X  0  X  , and consequently we have where the inequality holds since  X   X  (  X  ) is a nonincreas-ing function and  X   X  (0) &lt; 0 . Since  X   X  and hence Z is continuous, we have that over the interval [0 , +  X  ) the function Z (  X  ) assumes every value in the range [  X   X  (0)( N  X  1) ,  X   X   X  (0)) .
 Next observe that we may rewrite L 1 (  X  ) and L 2 (  X  ) as L (  X  ) = Z (  X  ) + 2  X Z (  X  ( B  X  1)  X  X  ) +  X Z ((5 B + 1)  X  X  ) and
L 2 (  X  ) =  X  2  X Z (  X  ( B  X  1)  X  X  )+5  X Z ((5 B +1)  X  X  ) . (7) In the rest of this section we shall show that there are values  X  &gt; 0, 0 &lt;  X  &lt; 1 / 6, B &gt; 1 such that L (  X  ) = L 2 (  X  ) = 0 . Since P  X , D is convex, this will imply that (  X   X  1 ,  X   X  2 ) def = (  X , B X  ) is a global minimum for the dataset constructed using this  X  , as required. Let us begin with the following claim which will be useful in establishing L 2 (  X  ) = 0.
 Claim 4 For any B  X  1 there is a finite value  X  ( B ) &gt; 0 such that Proof: Fix any value B  X  1. Recalling that Z (0) =  X   X  (0)( N  X  1) &lt; 0, at  X  = 0 the quantity 2 Z (  X  ( B  X  1)  X  ) equals 2  X   X  (0)( N  X  1) &lt; 0, and as  X  increases this quantity does not increase. On the other hand, at  X  = 0 the quantity 5 Z ((5 B + 1)  X  ) equals 5  X   X  (0)( N  X  1) &lt; 2  X   X  (0)( N  X  1), and as  X  increases this quantity increases to a limit, as  X   X  +  X  , which is at least 5(  X   X   X  (0)). Since Z is continuous, there must be some  X  &gt; 0 at which the two quantities are equal and are each at most 2  X   X  (0)( N  X  1) &lt; 0 .
 Observation 5 The function  X  ( B ) is a continuous and nonincreasing function of B for B  X  [0 ,  X  ) . Proof: The larger B  X  1 is, the faster  X  ( B  X  1)  X  ) decreases as a function of  X  and the faster (5 B + 1)  X  increases as a function of  X . Continuity of  X  ( ) follows from continuity of Z ( ) .
 We now fix the value of B to be B def = 1 +  X  , where the parameter  X  will be fixed later. We shall only consider settings of  X ,  X  &gt; 0 such that  X  X  =  X  ( B ) =  X  (1 +  X  ); i.e. given a setting of  X  , we shall take  X  =  X  (1+  X  )  X  any such  X ,  X  we have
L 2 (  X  ) = (7) =  X  [  X  2 Z (  X  ( B  X  1)  X  (1 +  X  )) where the last equality is by Claim 4. Now let us consider (6); our goal is to show that for some  X  &gt; 0 it is also 0. For any (  X ,  X  ) pair with  X  X  =  X  (1 +  X  ), we have by Claim 4 that 2  X Z (  X  ( B  X  1)  X  X  ) +  X Z ((5 B + 1)  X  X  ) = 2  X Z (  X  ( B  X  1)  X  (1 +  X  )) +  X Z ((5 B + 1)  X  (1 +  X  )) = 6  X Z ((5 B + 1)  X  (1 +  X  )) where the second equality is by Claim 4. Plugging this into (6), we have that for  X  =  X  (1+  X  )  X  , the quantity L (  X  ) equals 0 if and only if
Z Let us analyze (9). We first note that Observation 5 implies that  X  (1 +  X  ) is a nonincreasing function of  X  for  X   X  [0 ,  X  ) . Consequently  X  (1+  X  )  X  is a decreasing function of  X  , and since Z is a nonincreasing function, the LHS is a nonincreasing function of  X . Recall that at  X  = 0 we have  X  (1+  X  ) =  X  (1) which is some fixed finite positive value by Claim 4. So we have lim  X   X  0 + LHS = lim x  X  +  X  Z ( x )  X   X   X   X  (0) . On the other extreme, since  X  ( ) is nonincreasing, we have lim So as  X  varies through (0 ,  X  ), the LHS decreases through all values between  X   X   X  (0) and 0.
 On the other hand, at  X  = 0 the RHS of (9) is clearly 0. Moreover the RHS is always positive for  X  &gt; 0 by Claim 4. Since the RHS is continuous (by continu-ity of Z ( ) and  X  ( )), this together with the previous paragraph implies that there must be some  X  &gt; 0 for which the LHS and RHS of (9) are the same positive value. So we have shown that there are values  X  &gt; 0,  X  &gt; 0, B = 1 +  X  such that L 1 (  X  ) = L 2 (  X  ) = 0 . This concludes the proof of the  X  X igh error X  property (1). We close this section by showing that the value of  X  &gt; 0 obtained above is indeed at most 1 / 6 (and hence every example in S lies in the unit disc as required). To see this, note that we have shown that for this  X  , we Z is a nondecreasing function this implies 6 + 5  X  &lt; 1 which clearly implies  X  &lt; 1 / 6 as desired. 4.4. The  X  X teep slope X  property: analyzing Now we turn to proving that the directional derivative in the orthogonal direction is less steep than in the direction of the global minimum (  X   X  1 ,  X   X  2 ) . We have just established that (  X , B X  ) = (  X , (1 +  X  )  X  ) is a global minimum for the data set as constructed above. The directional derivative at (0 , 0) in the direction of this Since  X   X  (0) &lt; 0, by (6) and (7) we have This implies that L 1 (0) &lt; L 2 (0) &lt; 0, which, since B &gt; 1, implies BL 1 (0)  X  L 2 (0) &lt; 0. This means that ( B,  X  1) rather than (  X  B, 1) is the direction orthogonal to the optimal (1 , B ) which has negative slope. Recalling that B = 1 +  X  , we have the following in-equalities: B (  X  L 1 (0) + L 2 (0)) &lt;  X  L 1 (0)  X  L 2 (0) (11) where (11) follows from (10) using L 1 (0) &lt; L 2 (0) &lt; 0 . So the directional derivative in the optimal direction (1 , B ) is steeper than in ( B,  X  1), and the proof of the  X  X teep slope X  property, and with it Theorem 3, is com-plete. A wide range of well-studied boosting algorithms are based on potential functions  X  that satisfy our Def-inition 1. Theorem 2 thus implies that each of the corresponding convex potential function boosters as defined in Section 2.2 cannot tolerate random classi-fication noise at any noise rate 0 &lt;  X  &lt; 1 2 . (In some cases the original versions of the algorithms discussed below are not exactly the same as the B  X  algorithm as described in Section 2.2 because of small differences such as the way the step size is chosen at each update. Thus we do not claim that Theorem 2 applies directly to each of the original boosting algorithms; however we feel that our analysis strongly suggests that the original boosters may, like the corresponding B  X  algo-rithms, be highly susceptible to random classification noise.) AdaBoost and MadaBoost . As discussed in the Introduction and in [6, 18] the Adaboost algorithm [11] is the algorithm B  X  obtained by taking the convex potential function to be  X  ( x ) = exp(  X  x ) . Similarly the MadaBoost algorithm [5] is based on the potential function  X  ( x ) defined in Equation (1). Each of these functions clearly satisfies Definition 1.
 LogitBoost and FilterBoost. As described in [6, 18, 2], the LogitBoost algorithm of [12] is based on the logistic potential function ln(1 + exp(  X  x )), which is easily seen to fit our Definition 1. Roughly, Filter-Boost [2] combines a variation on the rejection sam-pling of MadaBoost with the reweighting scheme, and therefore the potential function, of LogitBoost. The analysis of this paper leaves open the possibil-ity that a convex potential booster could still tolerate noise if the base classifiers were restricted to be binary-valued. In this section we describe empirical evidence that this is not the case. We generated 100 datasets, applied three convex potential boosters to each, and calculated the training error.
 Data. Each dataset consisted of 4000 examples, di-vided into three groups, 1000 large margin examples, 1000 pullers, and 2000 penalizers. The large margin examples corresponded to the example (1 , 0) in Sec-tion 4.2, the pullers play the role of (  X , 5  X  ), and the penalizers collectively play the role of (  X ,  X   X  ). Each labeled example ( x, y ) in our dataset is gen-erated as follows. First the label y is chosen ran-domly from { X  1 , 1 } . There are 21 features x 1 , . . . , x that take values in { X  1 , 1 } . Each large margin ex-ample sets x 1 = = x 21 = y. Each puller assigns x 1 = = x 11 = y and x 12 = = x 21 =  X  y .
 Each penalizer is chosen at random in three stages: (1) the values of a random subset of five of the first eleven features x 1 , . . . , x 11 are set equal to y , (2) the values of a random subset of six of the last ten features x 12 , . . . , x 21 are set equal to y , and (3) the remaining ten features are set to  X  y.
 At this stage, if we associate a base classifier with each feature x i , then each of the 4000 examples is classified correctly by a majority vote over these 21 base classi-fiers. Intuitively, when an algorithm responds to the pressure exerted by the noisy large margin examples and the pullers to move toward a hypothesis that is a majority vote over the first 11 features only, then it tends to incorrectly classify the penalizers, because in the penalizers only 5 of those first 11 features agree with the class.
 Finally, each class designation y is corrupted with clas-sification noise with probability 0.1.
 Boosters. We experimented with three boosters: Ad-aBoost, MadaBoost (which is arguably, loosely speak-ing, the least convex of the convex potential boosters), and LogitBoost. Each booster was run for 100 rounds. Results. The average training error of AdaBoost over the 100 datasets was 33%. The average for LogitBoost was 30%, and for MadaBoost, 27%.
 We have shown that any boosting algorithm based on coordinate-wise gradient descent to optimize a con-vex potential function satisfying mild conditions can-not tolerate random classification noise. While our results imply strong limits on the noise-tolerance of al-gorithms that fit this framework, they do not apply to other boosting algorithms such as Freund X  X  Boost-By-Majority algorithm [8] and BrownBoost [9] for which the corresponding potential function is non-convex. An interesting direction for future work is to extend our negative results to a broader class of potential functions, or to other types of boosters such as  X  X egu-larized X  boosters [19, 14].
 We close by observing that there do exist efficient boosting algorithms (which do not follow the poten-tial function approach) that can provably tolerate ran-dom classification noise [13, 16]. These noise-tolerant boosters work by constructing a branching program over the weak classifiers; the original algorithms of [13, 16] were presented only for binary-valued weak classifiers, but recent work [15] extends the algorithm from [16] to work with confidence-rated base classi-fiers. A standard analysis (omitted because of space constraints) shows that this boosting algorithm for confidence-rated base classifiers can tolerate random classification noise at any rate 0 &lt;  X  &lt; 1 / 2 according to our definition from Section 2.4. In particular, for any noise rate  X  bounded below 1 / 4, if this booster is run on the data sets considered in this paper, it can construct a final classifier with accuracy 1  X   X   X   X  &gt; 3 / 4 after O ( log 1 / X   X  2 ) stages of boosting. Since our set of ex-amples S is of size four, though, this means that the booster X  X  final hypothesis will in fact have perfect accu-racy on these data sets which thwart convex potential boosters.
 [1] P. L. Bartlett and M. Traskin. Adaboost is con-[2] J. Bradley and R. Schapire. Filterboost: Regres-[3] L. Breiman. Arcing the edge. Technical report [4] T.G. Dietterich. An experimental comparison of [5] C. Domingo and O. Watanabe. Madaboost: a [6] N. Duffy and D. Helmbold. Potential boosters? [7] N. Duffy and D. Helmbold. A geometric approach [8] Y. Freund. Boosting a weak learning algo-[9] Y. Freund. An adaptive version of the boost-[10] Y. Freund and R. Schapire. Experiments with a [11] Y. Freund and R. Schapire. A decision-theoretic [12] J. Friedman, T. Hastie, and R. Tibshirani. Addi-[13] A. Kalai and R. Servedio. Boosting in the pres-[14] G. Lebanon and J. Lafferty. Boosting and max-[15] P. Long and R. Servedio. Adaptive martingale [16] P. Long and R. Servedio. Martingale boosting. In [17] Richard Maclin and David Opitz. An empir-[18] L. Mason, J. Baxter, P. Bartlett, and M. Frean. [19] G. R atsch, T. Onoda, and K.-R. M uller. Soft [20] R. Schapire and Y. Singer. Improved boosting al-
