 The Query Network [12] is a model for query-based social networks automation features, motivated by the rise of so-cial networks as a central internet application. This work generalizes the model to consist of a proposal query and an acceptance query for each participant. As a result, addi-tion of edges is done by coordination between participants, simulating interactions between participants. We designed, implemented and experimented with evaluation algorithms for this new model. Experiments with both synthetic and real datasets show the high effectiveness of our methods. H.2.1 [ Information Systems ]: Logical Design X  Data Mod-els Algorithms, Experimentation
Social networks have become a prime destination for web users. This popularity has brought very large amount of data into social networks [2], to the point that even the data available to a single user is difficult and error-prone to man-age manually. Automation features are therefore necessary in order to take advantage of the abundance of opportunities in social networks. Some examples for automation in social networks are [7], [12] and [13] and [15]. However, these do not automate interactions between users.
 This work examines the interaction of proposing/accepting a connection to/from other participants in a network. Partici-pants have proposal and acceptance rules, defined as queries. These react to developments in the network by interacting with each other and adding connections. From an algorith-mic point of view, rule evaluation is done on a large scale, a problem which we address in this work.
 As in [12], the social network is modeled as a directed graph.  X  The authors were funded in part by ISF grant 1104/05. Proposal and acceptance rules are conjunctive queries. The union of all proposal and acceptance queries constitutes a very large, recursive, Datalog query [16], whose size is in the order of magnitude of the data being queried. This is in sharp contradiction to the traditional query process-ing assumption, that queries are small and data are large. Therefore, methods which build on this assumption (e.g., compilers or optimization methods such as [3], [11]) will be hard pressed to handle such queries.
 The main contributions of this work are:  X  We present a model of query networks with acceptance queries, with four algorithms: Simple (as a baseline for com-parison), Propose-Accept , Propose-Accept with Backward-Radius and Network Partitioning which takes advantage of the clustered nature of social networks.  X  We present an implementation and experimentations with synthetic and real datasets. The results show the effective-ness of our methods, and in particular of network partition-ing, for which we also simulate parallel computation.
Network. A Query Network with Acceptance Queries is a directed graph ( N,F 0 ) where N (for Nodes ) is a set of par-ticipants. F 0 (for Friends ) is a set of directed edges between pairs of distinct elements of N , F 0  X  ( N  X  N ) \{ ( n 0 s.t. n 0  X  N } . Every node n  X  N has two queries associated with it, one proposal query and one acceptance query . Nodes also have attributes which contain information related to the node. The limit of one proposal and one acceptance query is only for the sake of discussion simplicity. In general, mul-tiple queries can be used.
 The proposal query defines edges of the form ( n,  X  ), which are edges such that user n would like to propose as can-didates for addition to the graph. The acceptance query defines edges of the form (  X  ,n ), which are edges such that user n would like to accept, if proposed as candidates by other nodes. An edge (u,v) proposed by u and accepted by v is added to the initial set of edges, F 0 , as defined below. Conjunctive Queries and Datalog. We use Conjunc-tive Queries (CQs) [16] for formalizing proposal and accep-tance rules. The choice of the CQ formalism is motivated by several considerations. The CQ formalization has been successfully used in analyzing many query languages (for both structured and unstructured data) such as SQL [4] and XPath [8]. The CQ formalization has been extensively stud-ied and is well understood. Theoretical and practical issues (e.g., optimization methods) have been addressed [16]. We use the Datalog [16] formalism to model recursion in the network (see [12] for an example of induced recursion). Proposal and Acceptance Queries. A proposal query alog rule whose head is F p ( n,X ), where X is a variable. An acceptance query q a ( n ) is a Datalog rule whose head is F ( X,n ). We define another Datalog rule, called the con-sensus rule , which is not associated with any of the nodes. The consensus rule is:
F + (Z,W)  X  F p (Z,W),F a (Z,W) F a and F p are IDB relations which contain edges that are candidates to be added to the network. F + is an IDB rela-tion which contains the additions to F 0 , which is an EDB relation. We define another relation, F , as F = F +  X  F Refer to [16] for formal definitions of IDB and EDB. Queries Structure. The body of an acceptance query is composed of predicates corresponding to the relation F and to nodes X  attributes, and of the inequality predicate (exam-ples follow). In a proposal query at node n , we require that one of the body predicates be of the form F ( n,Y ), and that X , the variable in the rule head, appear in one of the F body predicates. The latter requirement is added to ensure safety (see [16]). Acceptance queries are only required to be safe. Further requirements follow the next example. Examples. (1) The following is n  X  X  proposal query, propos-ing a connection to every participant who is a friend of two distinct friends.

F p (n,X)  X  F(n,Y),F(Y,X),F(n,Z),F(Z,X),Y 6 = Z, We henceforth assume that unless otherwise specified, two distinct variables imply an inequality predicate between them. (2) The following is an acceptance query in which n accepts friends of friends who have a mutual connection with an-other friend (see Figure 1):
F a (X,n)  X  F(Y,n),F(X,Y),F(Y,Z),F(Z,Y).
 constant in the query which represents a node (that is, all the other arguments which represent nodes are variables). Constants may appear in the context of attributes. Query Graph. Figure 1 illustrates the graphs correspond-ing to the queries in the previous example.
 Radius. The Radius of a proposal query q p is the num-ber of edges in the longest path, that never traverses a node more than once, in the query graph corresponding to q p . We assume that the radius is usually very small as compared to the size of the network.
 Rewriting of Acceptance Queries. Unlike proposal queries, the acceptance query graph need not have a pattern struc-ture with a radius. Therefore, an acceptance query can be satisfied by a large number of nodes. However, in the context of a network in which the maximal proposal query radius is k , a proposal to node v comes only from nodes distant at most k edges from v . In order to avoid large intermediate results in our algorithms, we add to every acceptance query a condition which requires accepted nodes to be distant at most k edges from the accepting node.
 Single Evaluation of a Node. We call the process of evaluating the two queries of a given network node and sub-sequently adding a (possibly empty) set of edges to F a and F , a single evaluation of a node .
 Round of Network Evaluation. A round of network eval-uation is the process of considering all the nodes of a query network in a certain order, and evaluating each node once, in that order. Then, evaluating the consensus rule. A Fully Evaluated Network. A network such that a Figure 1: (1) n  X  X  proposal query graph. (2) n  X  X  ac-ceptance query graph. round of evaluation applied to it will not add any edge to F is called fully evaluated . We say that a network is a minimal fully evaluated network of the original network if it (1) has the same nodes as the original network; (2) contains all the edges in F 0 ; (3) is fully evaluated; (4) is such that there is no proper subset of its edges (and implied nodes) that sat-isfies (1)-(3) . Note that for a given query network ( N,F there exists exactly one minimal fully evaluated network. This follows from basic Datalog properties [16].
 The Problem. The problem for which we propose algo-rithms is to construct, given a query network ( N,F 0 ) in the input, the (unique) minimal fully evaluated network ( N,F ).
Simple Evaluation Algorithm. The Simple Algorithm is a naive algorithm that serves as baseline for comparison. In every iteration, Simple performs a single node evaluation for each network nodes. Edges corresponding to accepted proposals are added. The algorithm stops when a round is completed without adding any edge. Pseudo-code is omitted due to lack of space.
 Propose-Accept Evaluation Algorithm. The Propose-Accept (PA) Algorithm reduces the number of evaluated acceptance queries. In an evaluation round, all proposal queries are evaluated. Acceptance queries are then evalu-ated only for the proposed nodes. We shall use the pseudo-code of the next algorithm to further explain this algorithm. Propose-Accept with Backward-Radius The PA with Backward Radius algorithm (PABRT) also reduces the num-ber of proposal queries evaluations. PABRT typically evalu-ates a significantly smaller number of proposal queries than PA. Intuitively, the Backward Radius (BR) of a network node n is the maximal distance from another node m such isfied by edges emanating from n . Formally, we define, B ( n,k ) = { m  X  N | there exists a path of length k from m to n } , and L ( n,k ) = { b | b  X  B ( n,k ) and the radius of q ( b ) is at least k } . The backward radius of node n is the maximal k such that L ( n,k ) 6 =  X  . So, if an edge from n to some edge is added, only proposal queries in nodes within distance BR may  X  X ense X  it. The BR of any node is bounded by the maximal radius of a propose query in the network. PABRT takes k , the maximal radius of a proposal query, as input. k is used as a uniform bound on the BR of all the nodes. In PABRT, when an edge ( u,v ) is added, only nodes whose proposal queries can potentially  X  X ense X  the addition are considered for another evaluation. These nodes are such that there exists a (directed) path, whose length is less than the BR, between them and u . Note that we use the model feature that k is small relative to the network. Passing k as a parameter is not essential for the algorithm, since k can be ascertained in the first round of PABRT, which does not use k . For simplicity, we pass k explicitly as a parameter. Pseudo-code for PABRT appears as Algorithm 1. First, all the nodes are put in the set R , and the proposal query of each node is evaluated. As in PA, relevant acceptance queries are evaluated, and new connections are added to F . For every node n which is a source of such an added edge (or multiple edges), the set { m  X  B ( n,l ) | l &lt; k } is computed and added to P . P replaces R . The evaluation stops when R is empty. In PA, there are no considerations of radius, and all proposal queries are evaluated in every round, not only those of the  X  X ensing X  nodes, until no new proposals are made.
 Algorithm 1 Propose-Accept with Backward Radius Input: ( N,F 0 ), a query network; k , maximal proposal query radius.
 Output: ( N,F ), a fully evaluated query network; Method: 1 : R  X  N 2 : while R 6 =  X  3 : P  X   X  4 : Q p (  X  ,  X  )  X   X  ; 5 : Q a (  X  ,  X  )  X   X  ; 6 : for each n  X  R 7 : evaluate q p ( n ) once, add the result to Q p ; 8 : end for each 9 : for each m s.t. (  X  ,m ) in Q p 10 : evaluate q a ( m ) once, add the result to Q a ; 11: end for each 12: Q  X  Q a  X  Q p ; 13: if Q \ F 6 =  X  14: P  X  P  X  X  m  X  B ( f,l ) | l &lt; k  X  f  X  ( Q \ F ) } 15: F  X  F  X  Q ;// F initialized to F 0 16: end if 17: R  X  P 18: end while Algorithm 2 Network Partitioning Evaluation Algorithm Input: ( N,F 0 ), a query network; k , maximal query radius; A , a graph-partitioning algorithm; p , number of partitions; A , a network evaluation algorithm.
 A , a partition-matching algorithm.
 Output: ( N,F ), a fully evaluated query network.
 Method: 1 : invoke A 1 to partition ( N,F 0 ) into p subnetworks (s.n.), -: let R be the set of s.n., { ( N i ,F 0 i ) s.t. 1  X  i  X  p } ; 2 : invoke A 2 evaluation on each r  X  R ; 3 : while  X  ( u,v )  X  F 0 s.t. u and v are in different s.n. 4 : P  X  A 3 ( R ); //see for example matchPairs 5 : for each ( r i ,...,r j )  X  P //matched merge 6 : R  X  R \{ r i ,...,r j } ; 7 : R  X  R  X  merge ( r i ,...,r j );//see explanation 8 : end for each 9 : end while Network Partitioning Evaluation Algorithm. The Network Partitioning Evaluation Algorithm (NWP) takes advantage of the clustered nature of social networks [9], by evaluating relatively dense subnetworks first.
 A graph partitioning algorithm takes a graph ( V,E ) as in-put and outputs a number of graphs. V is partitioned into (non-overlapping) sets of nodes. Each such set V i , and the edges in E between the nodes in V i form one graph in the output. Crossing edges are edges in E that are in none of the graphs (subnetworks).
 Pseudo code for NWP appears as Algorithm 2. Beside k , NWP takes as input a graph partitioning algorithm ( A the number of partitions ( p ), a network evaluation algorithm ( A 2 ), and a partition-matching algorithm, A 3 , which takes a set of subnetworks as input and outputs a set of sets of sub-networks. First, A 1 is invoked and produces p subnetworks. A 2 evaluates each of them separately. Then, sets of subnet-works are matched using A 3 . An example for a partition-matching algorithm is the Pair Matching algorithm shown as Algorithm 3, which outputs sets of up to two subnetworks as follows. The two partitions with the largest number of crossing edges between them are matched. Another such In general, an A 3 algorithm can produce any subset, not necessarily doubletons (as Algorithm 3 does). Each set of subnetworks is merged into one fully evaluated network, us-ing a process resembling PABRT (pseudo-code omitted due to lack of space). It is also possible to recursively call NWP on the subnetworks and further partition the graph. NWP continues to match and merge these merged networks, until one fully evaluated network is reached.
 Algorithm 3 Pair Matching -An example for A 3 procedure matchPairs( R ) // R is a set of networks 1 : for each crossing edge ( u,v ) w.r.t. the s.n. X  X  in R 2 : let r u (respectively, r v ) be u  X  X  (respectively, v  X  X ) -: network; 3 : initialize a counter c r u ,r v to 0, if not exists; 5 : end for each 6 : P  X   X  ; 7 : while there is more than one network in R 8 : add to P a set { r v ,r u } s.t. c r u ,r v + c r v ,r 9 : delete r v and r u from R ; 10: end while 11: Add unmatched singleton, if exists, to P ; return P ; end procedure
Figure 2: Results of Experiments 1 through 4.
We have implemented the evaluation algorithms in a sys-tem, programmed in Java and using the MySQL 5.0 DBMS. The experiments were carried out on a machine with a Pen-tium CPU of 1.5GHZ and 1GB of RAM, running the Win-dows XP operating system.
 Synthetic Datasets. The first set of experiments is per-formed on synthetic datasets, synthesized as in [12]. Experiment 1. In this experiment, we create 5 datasets. The i -th dataset has 5  X  i clusters. Each cluster has 180 nodes.  X  = 1 / 190,  X  = 4 (see [12]). One of the following three proposal queries is associated, with equal probability, with each node: (1) The proposal query from Figure 1; (2) A proposal query proposing to participants connected through two distinct paths, one of length 2 edges, the other of 3; (3) A query defining an empty set. One of the following two ac-ceptance queries is associated, with equal probability, with each node: (1) The acceptance query from Figure 1; (2) A query accepting all nodes (implemented to include only nodes within the maximal backward radius of the accepting node, 3 in this case; others can not propose to it). Figure 2 (exp. 1) shows running times for Simple, PA and PABRT. Experiment 2. Figure 2 (exp. 2) shows running times for PA, PABRT and NWP on the datasets of experiment 1. NWP is significantly faster than the other algorithms. Experiment 3. Here, set size is changed to 160 nodes,  X  = 1 / 200,  X  = 2. Figure 2 (exp. 3) shows results for PA, PABRT and NWP. NWP1 values correspond to partitioning according to synthesized clusters. NWP2 values correspond to graph partitioning using Metis [10].
 Datasets derived from DBLP. We also conducted exper-iments on data derived from the DBLP dataset [5], which capture social patterns. The datasets are prepared as in [12]. Experiment 4. Here, the graph consists of 1800 nodes, par-titioned into 10 parts (using Metis). We create five datasets by gradually lowering  X  from 55% to 35% in 5% decrements (increasing the EDB). Proposal queries are as in Experi-ment 1-3. Acceptance queries are the query of Figure 1 and a query that accepts nodes whose id is even. Figure 2 (exp. 4) shows the running times of the four algorithms. Experiment 5. Here, the graph consists of 2000 nodes partitioned into 16 parts using Metis. We gradually lower  X  from 65% to 55% in 2.5% decrements. Figure 3 (exp. 5) shows results for PA, PABRT and NWP.
 Experiment 6. Here, the graph consists of 2200 nodes, partitioned into 16 parts using Metis.  X  runs from 65% to 45% in 5% decrements. Figure 3 (exp. 6) shows results for PA, PABRT and NWP.
 Experiment 7. Here, we take the dataset from Experi-ment 6 in which  X  =50%, partitioned to 6, 12, 18, 24, 30, 36 and 42 partitions. Figure 3 (exp. 7) shows the running time results. For this dataset, the optimal balance between NWP overheads and benefits occurs between 15 and 20 partitions. Experiment 8. This experiment examines the maximum potential benefit NWP from parallelizing the evaluation of partitions. For every dataset from Experiment 6, we sim-ulate parallelization to 16 processors. We measured the longest sequence of partition evaluation, taking into account that evaluating the merge of partitions p and q can only be done after p and q were evaluated. Figure 3 (exp. 8) shows a comparison of simulated parallel and regular running times.
The query network model without interaction between queries is presented in [12]. SoQL [13] is an SQL-like lan-guage particularly designed for social networks . SoQL could be a more expressive alternative to CQs. Related work in the area of Datalog evaluation and optimization is thor-oughly covered in [16] and [1]. We are unaware of any work other than [12] which considers very large queries or Datalog programs with a massive number of rules, or of algorithms aimed at reducing the number of single rule evaluations. [1] S. Abiteboul, R. Hull, V. Vianu. Foundations of [2] R. Agrawal et. al. The Claremont Report on Database [3] F. Bancilhon, D. Maier,Y. Sagiv, J.D. Ullman. Magic [4] A. Chandra, P. Merlin, Optimal implementation of [5] The DBLP Computer Science Bibliography, 2008. [6] Facebook. http://www.facebook.com, 2008. [7] Facebook Query Language. [8] G. Gottlob and K. Schulz: Conjunctive queries over [9] E. M. Jin, M. Girvan, M. E. J. Newman: Structure of [10] Metis Partitioning Algorithms. University of [11] S. Naqvi and S. Tsur: A Logical Language for Data [12] R. Ronen and O. Shmueli. Evaluating Very Large [13] R. Ronen and O. Shmueli. SoQL: A Language for [14] Twitter. http://twitter.com/, 2010. [15] Twollow. http://twollow.com/, 2010. [16] J.D. Ullman. Principles of Database and Knowledge
