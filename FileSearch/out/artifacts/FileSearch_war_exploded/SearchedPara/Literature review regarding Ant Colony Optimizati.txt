 1. Introduction
Ant Colony Optimization (ACO) is a meta-heuristic approach proposed by Colorni et al. (1991) and improved in later research (e.g., see Dorigo et al., 1996 for the Ant Colony System and St  X  utzle and Hoos, 2000 for the Max X  X in Ant System). The behavior common to all approaches involving ant-based algorithms lies in the mimicry of the behavior used by  X  X  X eal X  X  ants to find the optimal path between their nest and a food source.
 The earlier application of ACO was to solve the well-known NP-Hard Traveling Salesman Problem ( Colorni et al., 1991 ; Dorigo et al., 1996 ; Dorigo and Gambardella, 1997 ). In this problem, there is a graph in which each node corresponds to a city, and the arcs correspond to the distances between cities. The problem consists of obtaining a minimal tour (sequence of cities) length that contains all the nodes.

Several studies have applied ACO to solve different discrete and continuous optimization problems, such as vehicle routing, quadratic assignment problems and graph coloring. Dorigo and St  X  utzle (2004) reported more than 30 problems where ACO-based algorithms have been used successfully.

One of these applications involves scheduling problems. With the significance of these problems recognized because of their impact on real environments and their academic relevance (e.g., Pinedo, 2009 ),  X  X  X cheduling problems X  X  are a huge set of problems, and are mostly NP-Hard, that try to deal with a simple question: given a set of jobs, a set of resources, a set of constraints, and an objective function, how should the jobs be allocated to the resources?
Answering this question, however, usually requires complex and/or time-costly procedures. The great advantage in using a meta-heuristic such as ACO to obtain near-optimal solutions is that the time required to solve the problem is usually acceptable even though the 100% optimal solution may not be achieved.
This paper aims at reviewing and classifying published studies that use ACO to solve scheduling problems, and it focuses on the four classical manufacturing environments (single machine, par-allel machine, flowshop and jobshop). Different scheduling pro-blems, such as service scheduling (e.g., see Gutjahr and Rauner, 2007 for an ACO approach to the nurse-scheduling problem) are not included in the revision. In addition, this paper concentrates only on uses of the ACO meta-heuristic on its own: any  X  X  X ybrid approach X  X  is disregarded.

This paper contribution is twofold. In the first instance, it aims to help researchers apply this technique in production scheduling, demonstrating how research is being carried out in the literature. Therefore, some guidelines relating to the characteristics of the
ACO algorithm applied to scheduling problems are derived. In the second instance, certain directions for future research in the field are highlighted.
 To present the results, this paper is divided into six sections:
Section 2 deals with the basics of scheduling problems; Section 3 is concerned with the ACO; Section 4 has to do with the classification method proposed and the papers reviewed;
Section 5 presents an overview of the ACO application to schedul-ing problems; Section 6 shows a quantitative analysis of the literature; and Section 7 presents the final remarks. 2. Scheduling problems resources ( Baker, 1943 ). Scheduling theory contains an almost unlimited set of problems ( Brucker, 2007 ). In this paper, accord-ing to the current literature, scheduling problems are character-ized by three main attributes: (i) the manufacturing environment, (ii) the constraints, and (iii) the objective function. By under-standing these three attributes, it is possible to use the scheduling problem classification scheme proposed by Graham et al. (1979) .
The authors state that it is possible to represent a scheduling problem using the notation a = b = g , where a represents the manufacturing environment, b represents the constraints and g represents the objective function. This section is devoted to presenting certain values of these three components that will be used in the following sections. 2.1. Manufacturing environments problem has to do with production flow. Graham et al. (1979) described four main categories of scheduling problems as follows: (iii) A flowshop environment ( a  X  F m ), where each task contains a (iv) A job shop environment ( a  X  J m ), where each task contains a this notation is used to indicate a manufacturing environment with parallel machines that allow the execution of batches. 2.2. Constraints acteristics of the target scheduling problem. These constraints can be, for example, related to the sequence (e.g., when b  X  prmu, the job assignment sequence of a flowshop environment is the same throughout the production flow), or to a maximum budget that can be used to outsource some jobs (when b  X  Budget). Table 1 shows the constraints adopted by this paper. 2.3. Common objective functions scheduling problems. Although a description of all of these performance measures is beyond the scope of this paper, some must be defined. Hence, let us use a set of n jobs J i , i at r i with processing time p i and due date d i . For any sequence, it is straightforward to calculate certain indicators, as follows: (iii) The earliness of a job J i ( E i  X  max f d i C i , 0 g ); (iv) The tardiness of a job J i ( T i  X  max f C i d i , 0 g ); (v) The makespan of the sequenced jobs ( M  X  max f C i g ).
Table 1 shows all the terms used to describe the objective functions of the scheduling problems presented in this paper. 2.4. A simple example This section shows a simple example of a scheduling problem.
Let S 0 be a set of four jobs to be sequenced in a single machine environment. These four jobs are described in Table 2 . In this table, column i indicates the job index; column p i indicates the processing time of the job; and d i indicates the due dates. These tasks can be sequenced according a large number of rules, generating different values for the performance measures. For example, Table 3 presents the completion time C i and the tardiness T i for each job, using the First In First Out (FIFO) rule.
Table 4 presents the same performance measure ordering the jobs by their due dates (rule EDD  X  Earliest Due Date).

The goal of scheduling algorithms is to enhance (by maximiz-ing or minimizing) the value of a certain performance measure.
One notes in the presented example that the maximum tardiness of the jobs ordered by EDD is smaller than the maximum tardiness obtained by the FIFO rule.

To achieve this goal with small-size problems, the solution is straightforward: simply test all possibilities relating to each possible job sequence. However, when the problem size increases, different strategies must be used, due to the prohibitive compu-tational time involved.
 In the following section, the ACO algorithm will be presented.
This algorithm has been used to solve scheduling problems, generating satisfactory results in a affordable computational time. 3. Ant Colony Optimization
Ant Colony Optimization (ACO) is a class of metaheuristics proposed by Marco Dorigo in the early 1990s (e.g., Colorni et al., 1991 ). It has been used in dealing with several classes of problems, and has considerable practical appeal, such as in vehicle routing (e.g., Bullnheimer et al., 1997 ), examination scheduling problem (e.g., Dowsland and Thompson, 2005 ) and scheduling (e.g., Zhou et al., 2007 ). The concept behind ACO is based on the  X  X  X atural X  X  algorithm used by real ants to generate a near-optimal trail between their nest and the food source, as shown in Fig. 1 . One of the main concepts with regard to this mechanism is the effect of pheromones on ants. In nature, it was found that real ants, when seeking food, are highly influenced by pheromones. This influence is mathematically modeled as a weighted, ponderated, random function, where the weight is calculated using existing pheromones.

As shown in Fig. 1 , the behavior displayed by real ants to generate a near optimal trail can be explained in four steps: (a) At an initial moment, the environment is  X  X  X lean X  X , and both ants can choose any of the paths with the same probability; (b) Both ants choose a path, and in this case, one ant chooses a shorter path and the other a longer one. When they move, they deposit chemical substances called pheromones. (c) When the cycle repeats, the shorter path will have a stronger pheromone trail more quickly (since the corresponding ant arrives sooner). To choose the next move, an ant uses a probability function weighted according to the amount of pheromones on the trail. Thus, more ants will choose the shorter trail. (d) After a certain time, the first pheromones that were dropped evaporate, and the pheromone trail on the shorter path becomes dominant. In this case, all the ants will choose the shorter trail.

The idea of the ACO algorithm is to mimic this behavior. This mimicry is performed by generating a pheromone matrix n m , used by two main operations: the pheromone level adjustment (also known as pheromone deposit and pheromone evaporation rules) and a probabilistic rule that chooses a destination based on the pheromone level (the state transition rule ).
 The full pseudo-code of the ACO algorithm is shown in
Algorithm 1 . In this algorithm, m ants are used, in each cycle, to build a full solution. To perform this task, the solution is divided into steps (e.g., in scheduling problems a step is usually the assignment of one job into one position of the final sequence).
To determine each step, two rules are used, as shown in Eqs. (1) and (2). s  X  8 &lt; :  X  1  X  p  X  8 &gt; &gt; &lt; &gt; &gt; : where k represents the index of the ant, i and j are two nodes on the graph that represents the search space, ij represents the probability of ant k choose node j after node i , s is an arc that connects i and j , q is a random value between 0 and 1, 0 r a r 1, 0 r b r 10 r q 0 r 1 are parameters chosen during the implementation of the algorithm, S is a trail chosen according to the probability given by (2) ,  X  i , j  X  is the pheromone intensity between nodes i and j ,  X  i , j  X  is a problem-specific value, referred to by some authors as visibility from node i to node j .

The update rules consists of two terms: the first, is the evaporation of the existing pheromone; the second, is the amount of added pheromone on the trail. This rule is shown in
Eqs. (3) and (4)  X  t  X  1  X  X  r t ij  X  t  X  X  where
Algorithm 1. The ACO pseudo-code. of ACO. The first ant-based algorithm found in our research is the Ant System (AS). This algorithm is modified, generating the
ASElite (that only allows the pheromone of the best solution to be updated) and ASRank (where the pheromone update is performed only to a subset of the solutions found, according a rank). The Ant Colony System (ACS) incorporates an exploration X  exploitation mechanism. The Max X  X in Ant System (MMAS) fixes the pheromone bounds. The Best X  X orst Ant System (BWAS) allows the pheromone update to the best and the worst solutions found. Table 5 presents the aforementioned ACO algorithms and the first implementation of each one in the literature. For this paper, three main algorithms are important: (i) the ACO algo-rithm; (ii) the ACS algorithm, based on ACO, using an exploita-tion/exploration mechanism with an elitist strategy; and (iii) the
MMAS algorithm, which is an evolution of the ACS with minimal and maximal bounds of pheromone levels. 4. Review and classification of the application of the ACO algorithm to scheduling problems neeringvillage.com ) and Scopus ( http://www.scopus.com ) was made, and 47 papers were found. On the basis of this literature review, a classification scheme was proposed, and is shown in
Section 4.1 . Section 4.2 presents the papers classified according to the scheme. 4.1. Classification scheme for understanding ACO approaches to scheduling problems
To better understand results found in the literature, a classi-fication scheme is proposed and applied to the review performed in this paper. This classification scheme consists of seven attri-butes, as follows: Attribute 1 The scheduling problem addressed by the paper. Attribute 2 Base algorithm used, according to Table 5 .
Attribute 3 Indicates whether the algorithm presented in the
Attribute 4 Indicates whether the algorithm presented uses a job-
Attribute 5 Indicates whether the algorithm presented uses some
Attribute 6 Indicates the pheromone initialization of the trails,
Attribute 7 Indicates how the algorithm builds the visibility 4.2. Classification of the literature survey Table 6 presents the papers found in the literature review.
These papers are classified according to the seven attributes of the classification scheme proposed. 5. An overview of the literature
An overview of the literature is presented in this section, which is divided as follows: Sections 5.1 X 5.4 present papers related to the four main scheduling environments (single machine, parallel machines, flowshop, and job shop). Within each section, the papers are presented according to the objective function addressed. 5.1. ACO applied to single machine scheduling problems
Scheduling problems in manufacturing environments contain-ing a single machine consist of finding a sequence where a set of n tasks must be accomplished to improve the value of an objective function. To solve this problem, a common approach is to generate a fully interconnected graph (e.g., Merkle and
Middendorf, 2000 ). Fig. 2 shows an example of a graph generated for a 4 jobs scheduling problem.
 5.1.1. Tardiness-related scheduling problems
We found 10 papers dealing with single machine environment scheduling seeking to minimize the total tardiness or total weighted tardiness ( P T i and P w i T respectively).

Bauer et al. (1999) designed an algorithm for both approaches (1 J T i and 1 J P w i T i ),usingwell-knowndispatchrulessuchas
Earliest Due Date (EDD) to determine the visibility values. The authors used the Adjacent Pairwise Interchange (API) and a 2-opt heuristic as a local search.
 .

Their results showed that the ACO algorithm was able to obtain the best solution for all test instances. The local search algorithms used were an insert X  X nterchange and an interchange X  X nsert.
Middendorf (2003) proposed improvements to the work of Bauer et al. (1999) relating to the problem 1 J P w i T i .Theauthorsdev-eloped a new visibility rule that constrained a deterministic criterion to restrict the search space and avoid generating poor solutions.
Rajendran (2005) used the Fast Ant Colony Optimization (FACO), which initializes the pheromone levels using a constructive heuristic. In this case, the problem characteristics were embedded in the pheromone matrix, allowing the visibility rule to have a constant value of Z  X  1. In this case, because the visibility rule did not need be calculated, the algorithm is faster to execute. 1 J P T i problem, based on results presented by Bauer et al. (1999) . According to Cheng et al. (2009) , the algorithm proposed contained a set of elimination rules that, inserted into the algorithm proposed by Bauer et al. (1999) , simplified the search space and improved the quality of the final solution. different problem, 1 = s ij = P T i (minimize total tardiness in a single machine environment with setup-dependent times). This algorithm reduced the search space using a candidate list. The visibility rule consisted of information related to (i) the setup time of the job and (ii) the slack of the job. The transition rule, which the authors named as look-ahead information , used the visibility values and added information regarding the others non-processed tasks. Juan (2007) . In this approach, which used the Apparent Tardiness
Cost with Setup rule to calculate the value of the visibility, the authors used the job-to-position approach. Thus, in this case, the ant does not use the graph shown in Fig. 2 ; instead, it uses a graph that makes it possible to verify the likelihood of a job belonging to a position in the final sequence.
 incompatible , s ij = P w i T i (minimize total weighted tardiness on a single machine environment with formation of processing batches where some tasks cannot be processed in the same batch as others with sequence-dependent setup times). In this paper, the authors proposed two ACO algorithms, each one having different visibility functions. 5.1.2. Applications related to job completion time problems can easily be obtained by calculating the sum of all processing times (for example, the 1 J P T i problem has a constant makespan for any built sequence), for certain problems the determination of the makespan of the optimal sequence is less straightforward. One example is the problem 1 = s ij = M , addressed by Thiruvady et al. (2009) . To solve this problem, the authors used a hybrid algorithm composed of two heuristics: a MMAS and a
Beam Search. In this case, the Beam Search was combined with a third heuristic and then used to reduce the search space for the MMAS.

Chen et al. (2008) presented an algorithm to solve the single machine scheduling problem using batches (1 = batch = C max this paper, the Chaotic Ant Colony Optimization (CACO), a varia-tion on the original ACO with a chaos local search algorithm embedded, was used. To group the jobs, the authors used the heuristic Batch First Fit (BFF).

The problem 1 = r j , s j , batch = C max  X  minimize makespan of a set of jobs executed by a single machine with setup-dependent times and different release times  X  is approached by Xu et al. (2012) .In this paper, the authors embed concepts found in the FFLPT-ERT heuristic to allow the ACO algorithm to form batches and compare it with a mixed-integer programming approach, two heuristics and a GA-based approach. The paper shows that ACO returns better results than the other strategies, when comparing the final value of the objective function and required computational time. 5.2. ACO approaches to parallel machine scheduling
The definition of a typical parallel machine scheduling pro-blem is similar to a single machine problem: a set of jobs, each with one operation, must be allocated to a resource to accomplish a goal. In the parallel machine environment, the main difference is that a set of machines process the job operations.
As shown in Section 2.1 , this set of machines can be identical, uniform, or unrelated. In the following sections, two sets of approaches are presented: those that use ACO algorithms to solve scheduling problems with identical machines and those that deal with an unrelated machine environment. 5.2.1. Applications in identical parallel machine environments
Sankar et al. (2005) used an n -dimensional TSP approach to solve the problem P m = s ij = C max (a scheduling problem involving identical parallel machines with sequence-dependent setups to minimize makespan). The same problem was addressed by
Behnamian et al. (2009) . The authors used the ACO to generate an initial solution, which was then improved by Simulated Annealing and Variable Neighborhood Search techniques.
Behnamian et al. (2009) also presented three local search algo-rithms: (i) the first consisted of swapping the positions of two jobs in the sequence of the same machine; (ii) the second consisted of swapping the positions of two jobs in the sequence of different machines; and (iii) the third transferred jobs from the machine with a higher makespan to the machine with a lower makespan. Raghavan and Venkataramana (2006) approached the problem
P = Batch, incompatible = minimizing the sum of weighted tardiness in a parallel machine environment that allows the formation of batches. The proposed algorithm consists of two phases: (i) generation of allowed batches using the dispatch rule Apparent Tardiness Cost (ATC) and (ii) an ACO based algorithm to schedule those batches on different machines.
 A similar scheduling problem, P m = A ij , Batch, incompatible =
P w i T i , was studied by Li et al. (2008) . The authors claimed that this problem was important in semiconductor manufacturing environments, and they showed that implementation of the ACO algorithm yielded better results than the sequence based only on the ATC dispatch rule.
 The problem P m = A ij , Q i , Batch, incompatible = P w i extension of the problem P m = A ij , Batch, incompatible = now considering different release dates. The presented algorithm also produced better results than the ATC dispatch rule.
Finally, the problem P m J T max was approached by Gatica et al. (2010) . The authors compared usage of four dispatch rules as a visibility rule (Earliest Due Date, EDD; Shortest Processing Time, SPT; Largest Processing Time, LPT; Least Slack, SLACK). These visibility rules were compared with each other and then with a genetic algorithm. To perform the comparison, four performance variables were used: (i) best percentage error of the best found solution; (ii) mean percentage error of the best found solution; (iii) mean objective value; and (iv) percentage of runs where the ACO found the best known value (named  X  X  X it ratio X  X ). 5.2.2. Applications in an unrelated parallel machine environment
Zhuo et al. (2007) extended the algorithm proposed by Liao and Juan (2007) and created an algorithm to solve the problem R implemented. (i) The authors used two types of pheromones: the first indi-(ii) A heuristic rule was used to obtain the initial pheromone (iii) Visibility was defined using the dispatch rule VMDD.
Monch (2008) also addressed this problem using several approaches, including ACO. In this case, the ATC rule was used as a visibility function.

Again addressing unrelated parallel machine scheduling pro-blems, Arnaout et al. (2008) and Arnaout et al. (2009) proposed and implemented an ACO algorithm for the R m = s ijk = C max (allocate jobs in an unrelated parallel machine manufacturing environment considering dependent setup). To solve this pro-blem, a two-stage algorithm was proposed and implemented: in the first stage, jobs are allocated to the machines, while in the second stage, jobs were sequenced on each machine. 5.3. ACO approaches to flowshop scheduling problems
The scheduling problem using a flowshop manufacturing environment consists of jobs, each containing a set of operations o , where i is the job index, and j is the index of the resource that must be used to perform this operation. In a flowshop environ-ment, all resources must be allocated in the same sequence in all jobs. If the job sequence needs to be maintained during all production stages, the problem is referred to as a permutational flowshop scheduling problem. If the job sequence can vary during each operation, the problem is referred to as non-permutational flowshop scheduling problem ( Baker, 1943 ; Pinedo, 2008 ). 5.3.1. Applications in minimizing makespan
A well-known permutational flowshop problem is to minimize the makespan ( F m = prmu = M ). This problem was addressed by ACO in eight studies: Ying and Liao (2003) , Rajendran and Ziegler (2004) , Ahmadizar et al. (2007) , Chen et al. (2008) , Zhou and Qingshan (2009) , Ying and Lin (2007) , Shyu et al. (2004) and Yan-hai et al. (2005) .

Ying and Liao (2003) solved this problem using a graph similar to that shown in Fig. 2 , using a specific visibility function. The two algorithms proposed by Rajendran and Ziegler (2004) also pro-posed specific visibility functions.

The approach by Ahmadizar et al. (2007) to this problem generated the visibility value based on two priority rules: the first involved an extension of Johnson X  X  rule ( Johnson, 1953 ) and the second involved an extension of the SPT dispatch rule.
The visibility function was discarded in the algorithm pro-posed by Chen et al. (2008) . In their approach, characteristics of the problem influenced the solution only by the application of the pheromone update rule and by the local search algorithm used.
A solution to large problems (100 X 200 jobs being processed on 10 X 20 machines) of the F m = prmu = M was proposed by Zhou and Qingshan (2009) . Their solution consisted of a hybrid algorithm of
ACO and a tabu search. Similar to the algorithm proposed by Chen et al. (2008) and Zhou and Qingshan (2009) this paper set Z  X  1.
Ying and Lin (2007) proposed an approach to the non-permu-tational flowshop problem F m J M . The choice of the value of the visibility Z was based on a random function chosen from a set of 20 constructive heuristics (such as SPT, LPT, and others). Shyu et al. (2004) used the ACS algorithm to solve the
F = nwt , setup = M problem (minimize makespan in a 2-machine non-permutational flowshop with sequence-dependent setups, in an environment that does not allow a wait between operations).
In this algorithm, the visibility was defined using the job X  X  setup and processing times.

To solve the problem of minimizing makespan in a non-permutational flowshop with rush orders, Yan-hai et al. (2005) used an ACO to generate an initial solution. When rush orders arise, the algorithm continues its execution, adjusting the solution to the new problem specification. 5.3.2. Other applications with single criteria objective functions Discarding the makespan criterion, we found four papers using
ACO to solve flowshop scheduling problems with a single criter-ion present in the objective function.

The first, by T X  X indt et al. (2002) , presented an MMAS algo-rithm to solve the problem of minimizing the total completion time of n tasks in a two-machine flowshop environment ( F
P C with Z  X  1. The local search algorithm was based on the Adjacent Pairwise Interchange algorithm.
 Rajendran and Ziegler (2004 , 2005) approached the
F = prmu = change that allowed the author X  X  results to be improved had to do with research using the NEH algorithm, proposed by Nawaz et al. (1983) , to initialize the pheromone levels.

The problem of minimizing the completion time variance in a permutational flowshop environment was addressed by Gajpal and Rajendran (2006) , who used a modified MMAS algorithm. In their approach, the NEH algorithm was used to build an initial solution. The local search used is called random-job-insertion, based on the random change of a random job.

The work of Li et al. (2011) dealt with the minimization of the sum of completion time in a permutational flowshop environ-ment with sequence-dependent setups. In this paper, the authors used a time-limited dynamic programming algorithm to perform a post-optimization strategy. The authors undertook a compar-ison between two different approaches: ACO and mathematical programming. According to the authors, mathematical program-ming is a viable strategy for small-size problems. When the size of the problems increases, the computational time becomes unac-ceptable, making usage of the ACO a preferable strategy. Similar comparisons between mathematical programming and ACO approaches were also performed by Tavares Neto and
Godinho Filho (2011) . This paper deals with the problem of minimizing the weighted sum of makespan and outsourcing cost in a permutational flowshop environment with a budget restriction, namely F m = prmu , budget =  X  1 d  X  M  X  d OC . The paper presents a two-stage ACO algorithm that demonstrates a good performance, even for large-size problems. 5.3.3. Applications in problems with objective functions having more than one performance measure
T X  X indt et al. (2002) also applied ACO to the F 2 J Lex  X  C
 X  problem. In one, it was necessary to schedule a set of jobs in a 2-machine permutational flowshop environment to minimize the total tardiness problem with minimum makespan.
 the weighted sum of total completion time and makespan in a two-machine flowshop environment ( F 2 J a C i  X  X  1 a  X  M ). The authors used the following modifications: (i) the rules API and
NAP were used to set the pheromone values; (ii) the generation of pheromone trails reinforced the desirability of a job being posi-tioned after a job (job-to-job position), in a fixed position (job-to-position); and (iii) some dominance criteria were applied to avoid the construction of non-promising solutions.
 makespan in a m-machine flowshop environment) was addressed by Pasia et al. (2006) . The authors used the Pareto Ant Colony
Optimization (PACO), establishing a set of pheromones for each problem objective.
 tional flowshop problem with four objectives: minimize total tardiness, makespan, total flowtime and idle time ing modifications were made to the original algorithm: (i) the visibility values were defined in the initialization phase, based on a heuristic executed at the beginning of the algorithm; (ii) a candidate list was used to restrict the search space; and (iii) a local search algorithm was composed by removing a random job and inserting it into another random position.
 makespan and mean completion time in a 2-machine permuta-tional flowshop environment ( F 2 = prmu = u M  X  v P C i n ), Al-Anzi and Allahverdi (2009) use, as a parameter to update the pher-omone levels, the number of interactions already executed, allowing a higher influence of the later executions of the algo-rithm (this behavior is named algorithm maturity ).
 weighted sum of makespan and total completion time in a permuta-tional flowshop manufacturing environment ( F m = prmu = u M  X  v
P C based on: (i) a set of pheromones representing the relative position-ing between each pair of jobs; (ii) a set of pheromones that represented the occupation of a position in the final sequence by a job; and (iii) a visibility function. The authors also proposed a further modification composed of two domina nce criteria, shown as efficient strategies to improve the final result of the implemented algorithm. (2009) considered batches in a flowshop environment. The authors proposed solutions for two problems: the first to mini-mize makespan and the second to minimize total flowtime ( F m , lot J M and F m , lot J P F i ). For both problems, the authors developed an ACO algorithm that used only the information generated by the pheromone matrix and a local search to determine the best solution. This local search consisted in relocating each job on the sequence in order to improve the value of the objective function.
 shop manufacturing environment with jobs having different release times and sequence-dependent setup time is considered.
The objective function minimized the weighted sum of the following: (i) total machine idle time; (ii) total waiting time of all jobs on all machines; and (iii) total tardiness. In their ACO approach, the authors developed a heuristic to determine the visibility function and used no local search. 5.4. ACO approaches to jobshop scheduling problems
As with the previous one, this section initially presents studies that proposed ACO approaches to minimize the makespan in a job shop manufacturing environment ( Section 5.4.1 ) and then, in
Section 5.4.2 , present jobshop problems with more than one performance indicator. 5.4.1. Applications in minimizing makespan
Most of the papers found in this bibliographic survey that deal with the use of ACO in a jobshop environment sought minimization of the makespan ( J n , m J M ). The first study to address this problem was by Colorni et al. (1994) . In addition to being the first applica-tion of ACO to the job shop problem, this paper also presents an interesting analysis: according to the authors, the parameter sensitivity was very low when the problem size was changed.
Yoshikawa and Terai (2006) also worked with the same problem. In this case, the authors presented an ACO algorithm, in which each graph node represented the execution of one job operation on one machine. A constructive heuristic indicated a set of operations to be executed immediately. The ACO is then used to sequence those operations.

Udomsakdigool and Kachitvichyanukul (2008) approached the problem J n , m J M by developing a set of ACO algorithms with visibility rules defined according to a set of 10 different dispatch rules (EDD, SPT, LDT, and others). They also use a candidate list based on one of the following directives: (i) all pending jobs can be executed; (ii) all jobs that can be per-formed without adding waiting time are considered; and (iii) a random set of jobs is considered. The authors tested all 10 dispatch rules with the three candidate list generation direc-tives, generating a set of 30 ACO algorithms. The author concluded that the best combination depends on characteris-tics such as the problem size.

The same problem was addressed by Zhang et al. (2010) . The proposed algorithm presented a priority rule adapted to the job shop problem and a specific local search, allowing the alteration of unimportant pheromone information and the simplification of further ACO algorithms.

Heinonen and Pettersson (2007) also used the ACO algorithm to solve the problem J 10 ; 10 J M . In their approach, an MMAS algorithm was implemented and hybridized with a tabu search local search. The same problem was solved by Zhou et al. (2007) , using an ACO with a visibility function proportional to the time left to accomplish a job.
 Mirabi (2011) add a sequence-dependent setup to the J n , m approaching the problem J n , m = s ij = M . The proposed algorithm contained a new pheromone initialization procedure and a local search, both allowing execution of the algorithms on large-scale real problems. 5.4.2. Applications in problems with multiple objectives
Huang and Yang (2008) proposed an ACO approach to solve the problem of minimizing the sum of earliness and tardiness in a jobshop environment with time windows. In their research, the authors used only the relative positioning of a job.
 6. Quantitative analysis of the literature
The bibliographic review performed in this paper made it possible to derive quantitative analyses.

The first analysis could be performed on the basis of the article publication date ( Fig. 3 ). Examining this characteristic, we observed that in the first stage of studies (1994 X 2000), the majority of papers dealt with single-machine scheduling pro-blems. In the second period (after 2002), researchers began to apply ACO in flowshop environments. Parallel-machine environ-ments and ACO were studied in the third stage (after 2005). From 2006 to the present, we find most job shop scheduling uses ACO.
Another possible analysis could address the number of com-ponents of the objective function. As presented in Fig. 4 , only one jobshop and eight flowshop scheduling problems studied dealt with more than one component in the objective function. Other-wise, objective functions with a single component were applied in all manufacturing environments, which did not happen with the multi-criteria objective function.

Fig. 5 summarizes the base algorithm used in the researched papers. One can observe that most of the papers (36) used the first version of ACO (or a specific variation of it). ACS is the second most used ant-based algorithm (used in 10 articles), followed by MMAS (used by eight articles). It is noteworthy that some of the articles involving ACO implement some features from ACS or MMAS (such as the pheromone bounds of MMAS). The three algorithms were used to solve scheduling problems in the parallel machine and flowshop environments. Job-shop and single machine scheduling problems were solved only by ACO and ACS. This observation indicates that the three algorithms have all proven to be useful in the solution of scheduling problems ( Fig. 6 ).

Another analysis relates to how the job sequence is repre-sented by the algorithms. The job-to-position strategy has been used more often to solve flowshop scheduling problems (nine articles). This strategy is less used to solve single machine, parallel machines and jobshop scheduling problems (1, 2 and 5 articles). The job-to-job strategy is used more often, in all manufacturing environments. This finding may indicate that the job-to-job strategy can be an efficient approach to mostly sche-duling problems.

One important observation relates to the algorithms presented by Liao and Juan (2007) , Li and Zhang (2006) and Lin et al. (2008) .
In these algorithms, both strategies (job-to-job and job-to-posi-tion) were used. One may infer that the use of both strategies generates more useful information for the algorithm.

Regarding the adoption of dominance criteria, one may note that, as shown in Fig. 7 , only problems dealing with single machine and flowshop problems adopt this strategy. In the case of single machine scheduling problems, the number of articles that adopt dominance criteria is the same as the number that do not use it.

The literature analysis also allows certain conclusions to be draw about the pheromone initialization scheme. Although, as shown in Fig. 8 , most of the applications use a static initial value for the pheromone levels, some researchers chose to initialize it based on the results of some constructive heuristic. This strategy was used in most of the articles that addressed flowshop scheduling problems.
 Finally, one can analyze how the visibility function is defined.
As presented in Fig. 9 , three different strategies were found in the related literature: 1. Visibility was defined in the initialization phase of the algo-2. Visibility was defined according to a function that used the 3. Visibility was not used. In this case, the specific characteristics addressed a single machine scheduling problem and in six articles that solved flowshop scheduling problems. 7. Conclusion This paper presents a literature review concerning the use of the
ACO metaheuristic in scheduling problems. The scope of this survey covers four manufacturing environments: single machine, parallel machine, flowshop, and job shop. Through the analysis, it was possible to verify that ant-based algorithms (ACO, ACS, and MMAS) are valid strategies for solving scheduling problems. Although the
ACO algorithm is straightforward, the possibility to easily incorpo-rate scheduling-specific heuristics and other metaheuristics increases the complexity and the research opportunities involving the use of this metaheuristic for this category of problems.
The analysis presented in this paper indicates that this field of research is a relatively new one, and only the initial results have been published. One can easily note that the first studies had to do with single-machine scheduling problems. Only later were flowshop, parallel-machine, and job shop environments addressed. The evolution of knowledge in this research area can also be observed in terms of the new features added to address certain problems (e.g., dominance criteria involving single-machine and flowshop scheduling problems).

From the quantitative analysis p erformed, we can derive certain guidelines for the application of ACO algorithms to scheduling problems. The first concerns the job-position scheme. Our research shows that the job-to-job position scheme is used more often than the job-to-position. This may indicate that the job-to-job scheme is usually a straightforward strategy to begin new applications of ACO to scheduling problems. As regards the job-to-position scheme, an interesting strategy is a hybrid approach, which uses both job-to-job and job-to-position, indicating that, when necessary, it is possible to combine both strategies. Another conclusion to be drawn from this paper is that the definition of visibility as a function of the partial solution being built by a single ant is a promising strategy for scheduling applications, since it was used in almost 20 papers in our review. In addition, our literature review highlights the benefits of incorporating scheduling-specific information into ACO implementa-tions. This can be observed from: (i) The adoption of dominance criteria in some papers; (ii) The use of problem-specific pheromone initialization meth-
Potential topics for future research also emerged. We observed that a single-criterion objective function was used in the four manufacturing environments studied in this paper. This was not the case for multi-criteria objective functions. Therefore, one can con-clude that using ACO for scheduling problems aimed at optimizing multi-criteria objective functions is a relatively new research field (no paper with this characteristic was found for single and parallel environments, and only one paper with regard to job shop), and can be addressed. In addition, our re view indicates that the general evolution of ACO applications relating to scheduling problems basi-cally followed an expected path: single machine, parallel machine, flowshop, and job shop. Other promising areas for future research involve:
Setup-dependent times . Although some of the approached problems address setup-dependent times, we note that there is no application of ACO to solve job shop problems with this constraint. A similar remark can be made regarding the possibility of generating production batches, which is still not considered in job shop problems.

Makespan . Still observing the job shop problems addressed, it is possible to note that makespan is the most frequent criterion, showing that a research opportunity exists to use other objective functions in job shop scheduling. The other three studied environments present a wider range of objective functions.

Time-window constraint . Of all the papers examined, only one deals with scheduling with a time-window constraint ( Huang and Yang, 2008 ). This constraint is common in real scheduling problems, and can therefore represent an opportunity for research regarding application of the ACO metaheuristic. Acknowledgements
The authors would like to acknowledge the support received by Fapesp Brazilian Agency in this research.
 References
