 A dependency tree represents syntactic relationships between words using directed arcs (Me  X  l  X  cuk, 1987). Each token in the sentence is a node in the tree, and each arc connects a head to its modifier . There are two dominant approaches to dependency pars-ing: graph-based and transition-based, where graph-based parsing is understood to be slower, but often more accurate (McDonald and Nivre, 2007).

In the graph-based setting, a complete search finds the highest-scoring tree under a model that de-composes over one or two arcs at a time. Much of the time for parsing is spent scoring each poten-tial arc in the complete dependency graph (John-son, 2007), one for each ordered word-pair in the sentence. Potential arcs are scored using rich linear models that are discriminatively trained to maximize parsing accuracy (McDonald et al., 2005). The vast majority of these arcs are bad; in an n -word sen-tence, only n of the n 2 potential arcs are correct. If many arcs can be filtered before parsing begins, then the entire process can be sped up substantially.
Previously, we proposed a cascade of filters to prune potential arcs (Bergsma and Cherry, 2010). One stage of this cascade operates one token at a time, labeling each token t according to various roles in the tree:  X  Not-a-head ( NaH ): t is not the head of any arc  X  Head-to-left ( HtL { 1/5/* } ): t  X  X  head is to its  X  Head-to-right ( HtR { 1/5/* } ): as head-to-left  X  Root ( Root ): t is the root node, which elimi-Similar to Roark and Hollingshead (2008), each role has a corresponding binary classifier. These token-role classifiers were shown to be more effective than vine parsing (Eisner and Smith, 2005; Dreyer et al., 2006), a competing filtering scheme that filters arcs based on their length (leveraging the observa-tion that most dependencies are short).

In this work, we propose a novel filtering frame-work that integrates all the information used in token-role classification and vine parsing, but of-fers a number of advantages. In our previous work, classifier decisions would often overlap: different token-role classifiers would agree to filter the same arc. Based on this observation, we propose a joint training framework where only the most confident classifier is given credit for eliminating an arc. The identity of the responsible classifier is modeled as a latent variable, which is filled in during training using a latent SVM (LSVM) formulation. Our use of an LSVM to assign credit during joint training differs substantially from previous LSVM applica-tions, which have induced latent linguistic structures (Cherry and Quirk, 2008; Chang et al., 2010) or sen-tence labels (Yessenalina et al., 2010).

In our framework, each classifier learns to fo-cus on the cases where the other classifiers are less confident. Furthermore, the integrated approach di-rectly optimizes for arc-filtering accuracy (rather than token-labeling fidelity). We trade-off filtering precision/recall using two hyperparameters, while the previous approach trained classifiers for eight different tasks resulting in sixteen hyperparameters. Ultimately, the biggest gains in filter quality are achieved when we jointly train the token-role classi-fiers together with a dynamic threshold that is based on arc length and shared across all classifiers. In our previous system, filtering is conducted by training a separate SVM classifier for each of the eight token-roles described in Section 1. Each clas-sifier uses a training set with one example per tree-bank token, where each token is assigned a binary label derived from the gold-standard tree. Figure 1 depicts five of the eight token roles, along with their truth values. The role labelers can be tuned for high precision with label-specific cost parameters; these are tuned separately for each classifier. At test time, each of the eight classifiers assigns a binary label to each of the n tokens in the sentence. Potential arcs are then filtered from the complete dependency graph according to these token labels. In Figure 1, a positive assignment to any of the indicated token-roles is sufficient to filter the dotted arc.
In the current work, we maintain almost the same test-time framework, but we alter training substan-tially, so that the various token-role classifiers are trained jointly. To do so, we propose a classifica-tion scheme focused on arcs . 1 During training, each arc is assigned a filtering event as a latent variable. Events generalize the token-roles from our previous system (e.g. NaH 3 , HtR  X  6 ). Events are assigned bi-nary labels during filtering; positive events are said to be detected . In general, events can correspond to any phenomenon, so long as the following holds: For each arc a , we must be able to deterministically construct the set Z a of all events that would filter a if detected. 2 Figure 1 shows that Z the { NaH 3 , HtR  X  6 , HtR 5 6 , HtR 1 6 , HtL 1 6 } .
To detect events, we maintain the eight token-role classifiers from the previous system, but they be-come subclassifiers of our joint system. For no-tational convenience, we pack them into a single weight vector  X  w . Thus, the event z = NaH 3 is de-feature vector. Given this notation, we can cast the filtering decision for an arc a as a maximum. We filter a only if: We have reformulated our problem, which previ-ously involved a number of independent token clas-sifiers, as a single arc classifier f() with an inner max over latent events. Note the asymmetry inherent in (1). To filter an arc,  X  w  X   X   X ( z ) &gt; 0 must hold for at least one z  X  Z a ; but to keep an arc,  X  w  X   X   X ( z )  X  0 must hold for all z  X  Z a . Also note that tokens have completely disappeared from our formalism: the classifier is framed only in terms of events and arcs; token-roles are encapsulated inside events.
To provide a large-margin training objective for our joint classifier, we adapt the latent SVM (Felzen-szwalb et al., 2010; Yu and Joachims, 2009) to our problem. Given a training set A of ( a,y ) pairs, where a is an arc in context and y is the correct filter label for a (1 to filter, 0 otherwise), LSVM training selects  X  w to minimize: 1 2 ||  X  w || 2 + X where C y is a label-specific regularization parame-ter, and the event set Z is now conditioned on the label y : Z a | 1 = Z a , and Z a | 0 = { None a } . None is a rejection event , which indicates that a is not filtered. The rejection event slightly alters our de-cision rule; rather than thresholding at 0, we now  X   X ( None a )  X  X  X  for all a to fix the threshold at 0.
Though not convex, (2) can be solved to a lo-cal minimum with an EM-like alternating minimiza-tion procedure (Felzenszwalb et al., 2010; Yu and Joachims, 2009). The learner alternates between picking the highest-scoring latent event  X  z a  X  Z a | y for each example ( a,y ) , and training a multiclass SVM to solve an approximation to (2) where Z a | y is replaced with {  X  z a } . Intuitively, the first step assigns the event  X  z a to a , making  X  z a responsible for a  X  X  ob-served label. The second step optimizes the model to ensure that each  X  z a is detected, leading to the desired arc-filtering decisions. As the process iterates, event assignment becomes increasingly refined, leading to a more accurate joint filter.

The resulting joint filter has only two hyper-parameters: the label-specific cost parameters C 1 and C o . These allow us to tune our system for high precision by increasing the cost of misclassifying an arc that should not be filtered ( C 1 C o ).
Joint training also implicitly affects the relative costs of subclassifier decisions. By minimizing an arc-level hinge loss with latent events (which in turn correspond to token-roles), we assign costs to token-roles based on arc accuracy. Consequently, 1) A token-level decision that affects multiple arcs im-pacts multiple instances of hinge loss, and 2) No extra credit (penalty) is given for multiple decisions that (in)correctly filter the same arc. Therefore, an NaH decision that filters thirty arcs is given more weight than an HtL 5 decision that filters only one (Item 1), unless those thirty arcs are already filtered by higher-scoring subclassifiers (Item 2). We can extend our system by expanding our event set Z . By adding an arc-level event Vine a to each Z , we can introduce a vine filter to prune long arcs. Similarly, we have already introduced another arc-level event, the rejection event None a . By assign-ing features to None a , we learn a dynamic thresh-old on all filters, which considers properties of the arc before acting on any other event. We parameter-ize both Vine a and None a with the same two fea-tures, inspired by tag-specific vine parsing (Eisner and Smith, 2005): where HeadTag ModTag Dir( a ) concatenates the part-of-speech tags of a  X  X  head and modifier tokens to its direction (left or right), and Len( a ) gives the unsigned distance between a  X  X  head and modifier.
In the context of Vine a , these two features al-low the system to learn tag-pair-specific limits on arc length. In the context of None a , these features protect short arcs and arcs that connect frequently-linked tag-pairs, allowing our token-role filters to be more aggressive on arcs that do not have these char-acteristics. The dynamic threshold also alters our interpretation of filtering events: where before they were either active or inactive, events are now as-signed scores, which are compared with the thresh-old to make final filtering decisions (Figure 2). 3 We extract dependency structures from the Penn Treebank using the head rules of Yamada and Mat-sumoto (2003). 4 We divide the Treebank into train (sections 2 X 21), development (22) and test (23). We part-of-speech tag our data using a perceptron tagger similar to the one described by Collins (2002). The training set is tagged with jack-knifing: the data is split into 10 folds and each fold is tagged by a sys-tem trained on the other 9 folds. Development and test sets are tagged using the entire training set. We train our joint filter using an in-house latent SVM framework, which repeatedly calls a multi-class exponentiated gradient SVM (Collins et al., 2008). LSVM training was stopped after 4 itera-tions, as determined during development. 5 For the token-role classifiers, we re-implement the Bergsma and Cherry (2010) feature set, initializing  X  w with high-precision subclassifiers trained independently for each token-role. Vine and None subclassifiers are initialized with a zero vector. At test time, we extract subclassifiers from the joint weight vector, and use them as parameters in the filtering tools of Bergsma and Cherry (2010). 6 Parsing experiments are carried out using the MST parser (McDonald et al., 2005), 7 which we have modified to filter arcs before carrying out fea-ture extraction. It is trained using 5-best MIRA (Crammer and Singer, 2003).

Following Bergsma and Cherry (2010), we mea-sure intrinsic filter quality with reduction , the pro-portion of total arcs removed, and coverage , the pro-portion of true arcs retained. For parsing results, we present dependency accuracy , the percentage of to-kens that are assigned the correct head. 4.1 Impact of Joint Training Our technical contribution consists of our proposed joint training scheme for token-role filters, along with two extensions: the addition of vine filters ( Vine ) and a dynamic threshold ( None ). Using pa-rameters determined to perform well during devel-opment, 8 we examine test-set performance as we in-corporate each of these components. For the token-role and vine subclassifiers, we compare against an independently-trained ensemble of the same classi-fiers. 9 Note that None cannot be trained indepen-dently, as its shared dynamic threshold considers arc and token views of the data simultaneously. Results are shown in Table 1.

Our complete system outperforms all variants in terms of both coverage and reduction. However, one can see that neither joint system is able to outper-form its independently-trained counter-part without the dynamic threshold provided by None . This is because the desirable credit-assignment properties of our joint training procedure are achieved through duplication (Zadrozny et al., 2003). That is, the LSVM knows that a specific event is important be-cause it appears in event sets Z a for many arcs from the same sentence. Without None , the filtering deci-sions implied by each copy of an event are identical. Because these replicated events are associated with arcs that are presented to the LSVM as independent examples, they appear to be not only important, but also low-variance, and therefore easy. This leads to overfitting. We had hoped that the benefits of joint training would outweigh this drawback, but our re-sults show that they do not. However, in addition to its other desirable properties (protecting short arcs), the dynamic threshold imposed by None restores in-dependence between arcs that share a common event (Figure 2). This alleviates overfitting and enables strong performance. 4.2 Comparison to the state of the art We directly compare our filters to those of Bergsma and Cherry (2010) in terms of both intrinsic fil-ter quality and impact on the MST parser. The B&amp;C system consists of three stages: rules (R), lin-ear token-role filters (L) and quadratic arc filters (Q). The Q stage uses rich arc-level features simi-lar to those of the MST parser. We compare against independently-trained token-role filters (R+L), as well as the complete cascade (R+L+Q), using the models provided online. 10 Our comparison points, Joint P1 and P2 were built by tuning our complete joint system to roughly match the coverage values of R+L and R+L+Q on development data. 11 Results are shown in Table 2.

Comparing Joint P1 to R+L, we can see that for a fixed set of pointwise filters, joint training with a dynamic threshold outperforms independent train-ing substantially. We achieve a 32% improvement in reduction with no impact on coverage and no in-crease in filtering overhead (time).
 Comparing Joint P2 to R+L+Q, we see that Joint P2 achieves similar levels of reduction with far less filtering overhead; our filters take only 7 seconds to apply instead of 19. This increases the speed of the (already fast) filtered MST-1 parser from 35 sen-tences per second to 44, resulting in a total speed-up of 2.75 with respect to the unfiltered parser. The improvement is less impressive for MST-2, where the overhead for filter application is a less substan-tial fraction of parsing time; however, our training framework also has other benefits with respect to R+L+Q, including a single unified training algo-rithm, fewer hyper-parameters and a smaller test-time memory footprint. Finally, the jointly trained filters have no impact on parsing accuracy, where both B&amp;C filters have a small negative effect.
The performance of Joint-P2+MST-2 is compa-rable to the system of Huang and Sagae (2010), who report a parsing speed of 25 sentences per second and an accuracy of 92.1 on the same test set, using a transition-based parser enhanced with dynamic-programming state combination. 12 Graph-based and transition-based systems tend to make dif-ferent types of errors (McDonald and Nivre, 2007). Therefore, having fast, accurate parsers for both ap-proaches presents an opportunity for large-scale, ro-bust parser combination. We have presented a novel use of latent SVM technology to train a number of filters jointly, with a shared dynamic threshold. By training a family of dependency filters in this manner, each subclassifier focuses on the examples where it is most needed, with our dynamic threshold adjust-ing filter sensitivity based on arc length. This al-lows us to outperform a 3-stage filter cascade in terms of speed-up, while also reducing the im-pact of filtering on parsing accuracy. Our filter-ing code and trained models are available online at http://code.google.com/p/arcfilter . In the future, we plan to apply our joint training tech-nique to other rich filtering regimes (Zhang et al., 2010), and to other NLP problems that combine the predictions of overlapping classifiers.
