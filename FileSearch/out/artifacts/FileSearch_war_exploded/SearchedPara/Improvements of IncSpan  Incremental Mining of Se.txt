 Discovering sequential patterns from databases is of great importance in many appli-sequence databases. 
In reality, a database is often dynamic. With the evolution of databases, some exist-becomes essential for sequential pattern mining. lem of pattern maintenance can be described as follows. Given a sequence database D of sequential patterns in D X  ? algorithm A on D X  to re-compute the sequential patterns. Obviously, it wastes compu-while maximizing the use of a previous mining result FS. Various incremental update algorithms [7, 8, 9] have been designed to improve efficiency by reducing the number of scans on D X . conditions. proposed incremental algorithm [7]. 
However, in this paper, we argue that in general, the algorithm IncSpan cannot find 
The remainder of the paper is organised as follows. Section 2 first gives the formal patterns in the updated database. Based on IncSpan, our solution is proposed in Sec-tion 4. Finally, we conclude this paper in Section 5. mally define the problem of incremental sequential patterns mining. 2.1 Incremental Sequential Pattern Mining an itemset. A sequence s = &lt; t 1 , t 2 , ..., t m &gt; (t i we also call  X  is supersequence of  X  and  X  contains  X  . = |{s | s denoted as FS, includes all the frequent sequences in D. quence database D and min_sup are given. processing. 
The Insert scenario (Figure 2.1) means that the new sequences are inserted into the quences are appended with new sequences. And the total number of the sequences in D X  is unchanged. If we consider Insert scenario is a special case of Append scenario formulate the problem as follows. 
Given a sequence s = &lt; t 1 , t 2 ,..., t m &gt; t X  &gt; LDB = {s X  | s X  s denoted as FS X . As a result, we have the following formula. D X  = D + db = (ODB + NDB) + db = (ODB + db) + NDB = LDB + NDB. Given min_sup = 3, we have: ODB = {SeqID: 0-2 in D}; NDB = {SeqID:3-5 in D}; LDB = {SeqID: 0-2 in D X  X ; FS={&lt;(a)&gt;:4, &lt;(b)&gt;:3, &lt;(d)&gt;:4, &lt;(b)(d)&gt;:3}; from scratch. 2.2 IncSpan Approach approach. PrefixSpan Approach: PrefixSpan approach [3] is one of the most efficient methods prototype of PrefixSpan algorithm which is used in the following sections is Prefix-base of D. This routine is called recursively to mine the complete FS, SFS in D|p.
It is assumed in [1] that the sequences in SFS are  X  X lmost frequent X  in D, most of FS X  in D X  are derived from the following cases: number and project D X  to find all frequent / semi-frequent sequences which are gener-ated from FS and SFS. Case (4). Property 2.1: An item which does not appear in D and is brought by db has sequences recursively by PrefixSpan approach. Case (5). Property 2.2: An infrequent sequence p X  in D becomes frequent in D X , all projected database on D X , use PrefixSpan approach, IncSpan will discover p X . IncSpan provides the pruning technique based on the following theorem. D to frequent in D X . 
This theorem provides an effective bound to decide whether it is necessary to pro-ject the whole database D X , which can reduce the number of projections. IncSpan will discover p X . sequences FS X  in D X  [1]. The basic idea of algorithm are described as follows. Step 1: Scan LDB for single items, as show in case (4). Step 2: Check every pattern in FS and SFS in LDB to adjust the support. Algorithm Outline: IncSpan(D X , min_sup,  X  , FS, SFS) Input: An appended database D X , min_sup, FS and SFS in D Output: FS X  in D X  Method: 1: FS X  = O / ; SFS X  = O / ; 2: Scan the LDB for new single items 3: Add new frequent items into FS X  4: Add new semi-frequent items into SFS X  5: For each new item i in FS X  do 6: PrefixSpan (i, D X  X i,  X  * min_sup, FS X , SFS X ) 7: For every pattern p in FS or SFS do 8: Check  X  sup(p) = sup db (p) 9: If sup D X  (p) = sup D (p) +  X  sup(p)  X  min_sup 10: Insert (FS X , p) 11: If supLDB(p)  X  (1 - X  ) * min_sup 13: Else 14: Insert (SFS X , p) 15: Return; in IncSpan for Case 4-6 are incorrect by giving counter examples. the complete set of new single frequent / semi-frequent items in D X . D X , Solution 2.1 fails to discover them. The following example illustrates the incom-created by following the same idea. change in appended part: item (f) is appended in SeqID 0-1. Remember that min_sup which have (f) as a prefix. quence p is in FS.
 Proof: A counter example is illustrated as follows.
 change in original part (SeqID 3-5 are deleted). Given min_sup = 3;  X  = 0.6 subsequence p is in FS or SFS. Proof: A counter example is illustrated as follows. Counter example 3.3 : This example generates from Example 2.1 with a small change in original part, and appended part. Given min_sup = 3;  X  = 0.6 &lt;(e)&gt;:2}. based on Theorem 2.1 for any pattern p in FS or SFS. Theorem 2.1 can be extended as can apply for not only frequent pattern p in D, but also any other pattern p in D. D to frequent in D X . Proof: p X  was infrequent in D, so sup D (p X ) &lt;  X  * min_sup (i) 
If sup LDB (p) &lt; (1 - X  ) * min_sup then 
Since sup LDB (p X ) = sup ODB (p X ) + sup db (p X ) because LDB = ODB + db, then cannot be frequent in D X . provement of IncSpan, denoted as IncSpan+. 
Given an original database D, an appended database D X , a minimum support semi-frequent sequences SFS X  in D X . Algorithm Outline: IncSpan+(D X , min_sup,  X  , FS, SFS) Input: An appended database D X , min_sup, FS and SFS in D Output: FS X , SFS X  in D X  
Method: 1: FS X  = O / ; SFS X  = O / ; 2: Determine LDB; Total number of sequences in D X , adjust the min_sup if it is 3: Scan the whole D X  for new single items 4: Add new frequent items into FS X  5: Add new semi-frequent items into SFS X  6: For each new item i in FS X  do 7: PrefixSpan (i, D X  X i,  X  * min_sup, FS X , SFS X ) 8: For each new item i in SFS X  do 9: PrefixSpan (i, D X  X i,  X  * min_sup, FS X , SFS X ) 10: For every pattern p in FS or SFS do 11: Check  X  sup(p) = sup db (p) 12: If sup D X  (p) = sup D (p) +  X  sup(p)  X  min_sup 13: Insert (FS X , p) 14: If supLDB(p)  X  (1 - X  ) * min_sup 16: ElseIf sup D X  (p)  X   X  * min_sup 17: Insert (SFS X , p) 18: PrefixSpan (p, D X  X p,  X  * min_sup, FS X , SFS X ) 19: Return; ness of mining result in the updated database, as is proven in Claim 4.1. database D X . Proof: The complete FS X  and SFS X  sets come exactly from two sources: quent sequences and semi-frequent sequences in D X  corresponding to case (4.1). That quent / semi-frequent items are not included in FS and SFS. 
Line 10-18 in IncSpan+ will discover all frequent / semi-frequent sequences which have their prefix in FS or SFS, and a ll of them correspond to case (4.2). original approach, IncSpan+ has the following improvements: maintains the complete set of semi-frequent sequences for future updates. 
