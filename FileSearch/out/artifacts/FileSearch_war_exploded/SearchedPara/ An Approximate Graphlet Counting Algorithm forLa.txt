 Graphlet frequency distribution (GFD) is an analysis tool for understanding the variance of local structure in a graph. Many recent works use GFD for comparing, and character-izing real-life networks. However, the main bottleneck for graph analysis using GFD is the excessive computation cost for obtaining the frequency of each of the graphlets in a large network. To overcome this, we propose a simple, yet powerful algorithm, called Graft , that obtains the approx-imate graphlet frequency for all graphlets that have upto 5 vertices. Comparing to an exact counting algorithm, our al-gorithm achieves a speedup factor between 10 and 100 for a negligible counting error, which is, on average, less than 5%; For example, exact graphlet counting for ca-AstroPh takes approximately 3 days; but, Graft runs for 45 minutes to perform the same task with a counting accuracy of 95.6%. I [ Computing Methodologies ]: Miscellaneous; J [ Computer Applications ]: Miscellaneous approximate graphlet counting, graph analysis, graphlet fre-quency distribution
Structural analysis of networks is an important research task that has received the due attention by researchers in various disciplines, such as social sciences [2], system sci-ences [4], and bioinformatics [8]. Such analyses lead to the discovery of various non-random properties in large, real-life networks; examples include scale-free-ness [1], small diame-ter [10], and graph densification with shrinking diameter [6]. Various graph generation models are also discovered for gen-erating synthetic graphs having properties alike to the real- X 
T his research is supported by an NSF CAREER Award (IIS-1149851) life graphs. Though these discoveries enhance our under-standing of network structure in general, they are hardly useful in solving practical problems related to graphs and networks. The reason behind this is that the properties dis-cussed in the above existing works are agnostic to the details and effects that arise when dealing with real networks. Fur-ther, they exhibit the global behaviors of a network, whereas the detailed sketch of the local structure around a node (or an edge) is required when answering questions that are too specific to that node (or edge). Existing network models are unable to provide such detailed information.

In a large network, a sketch of the local structure can be obtained by collecting the topological context in which each of the nodes resides. N. Przulj X  X  group [8, 7] has done some interesting research works along this direction; in these works, the authors find the position of each vertex in a that are related to biological networks. Some of these tasks are: compare structures of different biological networks [8], characterize biological networks using graphlet degree dis-tribution [8], and obtain a structural to functional mapping for biological networks [7]. All these works require count-ing the graphlet frequencies, which is computationally ex-pensive. There exists a software, called GraphCrunch [5], which counts the frequencies of all graphlets that have upto five vertices; however, we find that it is practically infeasible to use this software for counting graphlets in large networks that are available in the domains of social and information networks. For example, we ran GraphCrunch on Enronemail data set (38,692 vertices, 367,664 edges) and slashdot data set (77,357 vertices, 516,675 edges); neither of the counting processes finish after 5 days of running on a typical desktop computer.

An alternative to exact graphlet counting is to adopt algo-rithms for approximate counting that offer significant speedup with a negligible counting error; this direction has become popular in some of the recent researches for counting tri-angles [9, 3]. Since, the cost of graphlet counting is much higher than the cost of triangle counting, an approximate counting algorithm for the former will be more useful from a practical standpoint. Also for many practical usages of graphlets, such as for the construction of graphlet frequency distribution (GFD), approximate graphlet counting can be used in places of exact counting without any visible loss; although counting errors prevails by adopting an approxi-mate counting, the effect of this error on GFD is negligible, subgraph of the given network. We provide a formal def-inition of graphlet in subsequent section. because the latter compares the relative counts of various g raphlets in a logarithm scale. Unfortunately, no algorithm exists that performs approximate counting of graphlets.
In this research, we propose a method called Graft 2 to perform the task of approximate counting of graphlets that have upto five vertices; in Figure 1 we show all such graphlets (modulo isomorphism). Graft samples a small number of edges uniformly and for each of the sampled edges it obtains a partial count for a graphlet such that the graphlet uses that edge in one of its induced embedding; Graft then uses the partial count associated with the sampled edges for approximating the total count of that graphlet. Experiments show that by sampling between 5% and 10% of the edges, we can easily obtain more than 95% of accuracy in graphlet counting for a speedup factor between 20 and 10; for larger graphs, the sampling factor can be reduced to 1% (or less) to achieve similar accuracy and even higher speedup.
Assume, G ( V, E ) is a graph, then V is the set of vertices and E is the set of edges. Each edge e  X  E can be rep-resented by a pair of vertices ( v i , v j ) where, v i , v graph is called simple, if it does not contain a self loop, and at most one edge exists between two of its vertices. In this work, we consider simple, connected, and undirected graphs.
A graph G  X  = ( V  X  , E  X  ) is a subgraph of G if V  X   X  V and E  X   X  E . A graph G  X  = ( V  X  , E  X  ) is a vertex-induced subgraph of G if V  X   X  V and E  X   X  E and { e = ( v a , v b v , v b  X  V  X  , e  X  E, e /  X  E  X  } =  X  . A vertex-induced subgraph is a subset of the vertices of a graph G together with any edges whose both endpoints are in this subset. In this paper we will refer to vertex-induced subgraph as  X  X nduced sub-graph X . Two graphs G and G  X  are isomorphic , denoted by G  X  = G  X  , if there exists a structure-preserving (both adja-cency and non-adjacency preserving) bijection f : V  X  V  X  ; such a function f is called an isomorphism from G to G  X  . An embedding of a graph G  X  in another graph G is a sub-graph S of G , such that S and G  X  are isomorphic; when the subgraph S is a vertex-induced subgraph of G , the embed-ding is called an induced embedding . In Figure 1, g 5 is a subgraph, but not an induced subgraph, of g 19 ; On the other hand, g 7 is an induced subgraph of g 19 .

Graphlets can be defined as small, non-isomorphic, con-nected, induced subgraphs of a large network. In this study, we work with all possible graphlets having k vertices; where, Note that, 1-Graphlet is simply a vertex, and 2-Graphlet is an edge. A k -Graphlet is called a tree graphlet if it is a tree, i.e., it has k  X  1 edges. A graphlet that is not a tree graphlet is called a cyclic graphlet . Figure 1 shows all the graphlets that have between 3 and 5 vertices; there are 29 graphlets in this set. They are referred as g i , for i from 1 to 29. Among them, g 1 , g 3 , g 4 , g 9 , g 10 , and g tree graphlets, and the remaining are cyclic graphlets. For each graphlet, we identify each of its vertices by an English small letter, such as, a , b , c , etc. as shown in Figure 1. The task of Graphlets counting over an input graph G is to find the counts of all distinct induced embedding of each of the graphlets having upto k vertices. To distin-guish an embedding, we assign integer identifiers to each of the vertices in G , starting from 1 to | V | . Then an induced G raft is an anagram of the bold letters in A pproximate GR aphlet F requency coun T ing embedding of a k -Graphlet is denoted simply by a set of k vertex identifiers in the graph G , such that the subgraph in-duced by those vertices is isomorphic to that graphlet. Due to the  X  X nduced X  constraint, at most one k -Graphlet is em-bedded in a given set of vertices of size k . In Figure 1, the induced-subgraph consisting with the vertices { a, b, c, e } of g 19 is an induced embedding of g 7 ; no other graphlet of size 4 is embedded in the above set of vertices of g 19 .
An isomorphism from a graph G ( V, E ) to itself is called an automorphism . Thus, an automorphism  X  of a graph G is a structure-preserving permutation  X  V on V along with a consistent permutation  X  E on E . The total number of au-tomorphism of a graph is defined as | Aut ( G ) | . Also, any permutation can be represented as a product of disjoint cy-cles, the vertices that belong to the same cycle under an automorphism form an equivalence class, which is called a vertex-orbit. Similarly the equivalence classes of the edges are called edge-orbits. In Figure 1, each vertex-orbit of a graphlet is represented by drawing the vertices of the or-bit by same color. For example, graphlet g 14  X  X  automor-and three edge-orbits ( ab ) , ( ac, bc ) , ( cd, ce ).
Graft works as an EdgeIterator algorithm; in such an algorithm, the counting process iterates over the edges of the input graph, G ( V, E ). For an edge e  X  E , it finds the count of all induced embeddings of a graphlet g with the constraint that the edge e is part of the embedding; we call this count a partial count of the graphlet with respect to the edge e . The partial count can be summed over all the edges to obtain a total count of the graphlet g in the input graph. However, in the above process, a distinct graphlet will be counted multi-ple times, by being accounted in different partial counts, so the above count needs to be corrected by dividing it with an appropriate normalization factor. Such a method yields an exact graphlet counting algorithm. Graft obtains an ap-proximate graphlet counting algorithm by iterating over a random subset of edges instead of all the edges of the input graph. The fraction of edges in the random subset with re-spect to all the edges is called the sampling factor of Graft . The lower the sampling factor, the faster Graft runs. On the other hand, the higher the sampling factor, the better the accuracy of Graft . For a sampling factor of 1, Graft returns an exact count. In Figure 2, we show a pseudo-code of Graft .
We first discuss, how to obtain the partial count of a graphlet g that is associated with an edge e of the input graph (Line 5-6 in Figure 2). The first step for this task is to choose an specific edge e g in the graphlet g , which will be aligned with the edge e in the large graph G . We will call the edge e g the first aligned edge (FAE). Though, the choice of FAE can be arbitrary for exact counting, it is not the same for approximate counting; for the latter, a poor choice can drop the counting accuracy significantly. We will discuss more on this in Section 4.

Once the FAE is chosen, the next task is to enumerate all the embeddings of a graphlet g with the constraint that in those embeddings, e g is aligned with the edge e (Line 6 in Figure 2). The size of the set containing all the embeddings is the partial count of the graphlet g associated with the edge e . The enumeration process of the embeddings differs based on whether g is a tree graphlet or a cyclic graphlet. Enumeration process is simpler for a tree graphlet. From Figure 1, there are one ( g 1 ), two ( g 3 , g 4 ), and three ( g and g 11 ) tree graphlets with 3, 4, and 5 vertices, respectively.
We first explain the enumeration of g 3 . Suppose, we are given the graph G shown in Figure 3( a ) and we want to enumerate the embedding of graphlet g 3 in G . For this, Graft chooses the edge ( b, c ) of graphlet g 3 as FAE, and aligns it with the edge ( id 1 , id 2 ) of graph G (Figure 3( b )). Then step by step, it embeds the graphlet g 3 on the graph to 3( d )). At the end, we get an induced embedding of g 3 consisting with the vertices { id 1 , id 2 , id 3 and id ure 3( d )). By iterating over the adjacency lists of id 1 id 2 , Graft enumerates all possible embeddings of a and d . Note that, Graft only enumerates (counts) the induced embedding for g 3 . For example, the embedding for g 3 con-is not an induced embedding, and Graft will not enumerate it while counting the graphlet g 3 .

It is easy to see that | Aut ( g 3 ) | is 2, as a chain ( g can be embedded at most in two ways (forward and back-ward) over the same set of vertices in G ; so, the normal-ization factor for g 3 is 2. However, by applying the con-straint that the edge ( b, c ) is mapped to edge ( id i , id if id i &lt; id j , we can ensure that g 3 is mapped to an embed-ding only once, and then the normalization factor for this enumeration becomes 1.
Another exam-ple of tree graphlet enumeration, may be, the enumer-ation of g 11 . Ini-tially, Graft em-beds the edge ( a, c ) of this graphlet with an edge ( id 1 , id 2 ) of the large graph (Fig-ure 4). Then, it scans the ad-jacency list of vertex id 2 to find all possi-ble mappings of vertices b, d and e of g 11 to ver-tices id 4 , id 5 and id 6 of the large graph. Thus, we get an embedding (not necessarily induced) of g 11 in the large graph. Finally, Graft checks whether the embedding is induced or not. It only enumerates (counts) the induced embedding for g 11 . Now, by applying the con-straint that, mapping of vertices b, d and e of g 11 to vertices id 4 , id 5 and id 6 of the large graph is valid if and only if id of an embedding. Therefore, the normalization factor for g enumerated by following a similar mechanism.
For enumerating an embedding of a cyclic graphlet g , we can use one of the spanning trees of g ; the specific spanning tree that is used for the generation is called a generation tree graphlet . A tree graphlet is it X  X  own generation tree graphlet. Multiple graphlets can have the same generation tree graphlet (e.g., g 5 and g 6 both have g 3 as their genera-tion tree graphlet). Also, for a cyclic graphlet, there can be multiple generation tree graphlets (e.g., g 22 can have g and g 11 as its generation tree graphlet).

To enumerate a cyclic graphlet, Graft initially embeds the generation tree graphlet (which is not induced) as we explain in Section 3.1.1. Then it checks explicitly whether the desired graphlet is induced in the embedding of it X  X  gen-eration tree graphlet.

For example, the generation tree graphlet of g 5 is g 3 . So, in order to embed the graphlet g 5 in a large graph, g 3 must be embedded at the beginning. Figure 3( e ) shows an em-bedding (not induced) of g 3 (consisting with the vertices ding of g 5 since the edge ( a, d ) is induced by the existence of the edge ( id 3 , id 5 ), and no other edge (excluding the edges of tree graphlet) exists between a pair of vertices from the as Section 3.1.1 applies here. If we apply the restriction to induce the edge ( b, c ) to edge ( id i , id j ) when the condition id i &lt; idj satisfies, then we will have 4 duplications (using 4 left-rotations to align the edge ( b, c ) to different edges of the rectangle) of an embedding ( normalization f actor i s equal to 4). Figure 5: Three ways for finding g 22 . ( b ) Using g 11 Using g 9 and ( d ) Using g 10
Graft uses various optimization schemes which are cru-cial for its counting accuracy and running time. We discuss each of them in this section in the order of their significance.
From Figure 1, we can observe that some of the graphlets have multiple generation tree graphlets. For example, g 22 has three generation tree graphlets: g 9 , g 10 and g 11 . For the task of exact graphlet counting, we will obtain correct result, irrespective of the specific generation tree graphlet that we use for counting. But, complexity arises when Graft is used for approximate counting, which samples only a fraction of the edges.

If we embed g 22 using g 11 (Figure 5( b )), the first step is to embed g 11 by mapping the chosen FAE ( b, c ) to the edge ( id 3 , id 2 ); and, the second step is to check if this embed-ding contributes to an induced embedding of g 22 . Here, the mapped edge ( b, c )(of g 22 ) belongs to an edge-orbit of size 1. Therefore, for approximate graphlet counting, if we map missing an embedding of g 22 .

On the other hand, if we embed g 22 using g 9 or g 10 (Fig-ure 5( c ) and 5( d )), the edge ( b, c ) of g 22 cannot be the FAE; rather, the FAE is the edge ( b, e ), which is mapped edge-orbit of size 6. Therefore, for approximate graphlet counting, if the edge ( b, e ) is used as FAE and is mapped to the edge ( id 2 , id 5 ) , the probability of missing an embed-ding of g 22 is small. Hence, g 9 and g 10 are more suitable generation tree graphlets for enumerating g 22 . For instance, on ca-CondMat graph, using p = 0 . 1, the average count-ing error (in %) of approximate g 22 using tree graphlet g and g 11 are 3.68 and 39.54. To summarize, the criteria for optimizing the accuracy of approximate graphlet counting is choosing the generation tree graphlet for which the FAE belongs to the largest edge-orbit.
As explained in Section 3.1.2, for counting a cyclic graphlet (say, g x ), Graft embeds the corresponding generation tree graphlet g t followed by a validation to ensure that this em-bedding contributes to an induced embedding of g x . If the validation step fails to find an induced embedding of g x then this specific embedding (not induced) of g t does not contribute to the enumeration of the graphlet g x . How-ever, the embedding of g t contributes to the induced embed-ding of some other graphlets, whose count should be incre-mented with this discovery. Therefore, if we count multiple graphlets (having the same generation tree graphlet) simul-taneously, we will be able to share the workload of enumer-ation. Therefore, Graft  X  X  process of embedding graphlets having the same generation tree graphlet g t is that after em-bedding the generation tree graphlet g t , it finds the graphlet g whose induced embedding corresponds to this embedding of g t . The above optimization improves the execution time significantly, as every embedding of g t contributes to the enumeration (count) of exactly one induced embedding of the graphlets.
We perform several experiments to observe the perfor-mance of Graft . These experiments are performed on real-name and statistics of these graphs are available from Ta-ble 1. Speedup factor and counting error(%) are two perfor-mance metrics that we use. We obtain the speedup factor by computing the ratio of execution times of Graft with some p less than 1 and Graft with p = 1; former is an approximate, and the latter is the exact graphlet counting. Apparently, Graft has a predictable value for the speedup factor; for an edge selection probability equal to p , its av-erage speedup is close to 1 p . This is so because we perform p fraction of work by randomly selecting p fraction of total edges for approximating the graphlet count. To obtain the counting error of Graft we first find the percentage of error in the count of each of the graphlets; then we average the error over all different graphlets.
In this experiment, we show how the count-ing error (averaged over all the graphlets) of Graft varies with the sampling factor.
 Figure 6 shows our findings. As the sam-pling factor increases, the error of our algo-rithm diminishes. We show these results for three real world col-laboration networks of different sizes. An im-portant observation is that for the same sampling factor, the larger graph have smaller percentage error. So, as the graph grows, we can afford to decrease the sampling factor (thus increase the speedup factor), while keeping the counting error at the same level. For example, 5% sampling factor obtains a 12% error on ca-GrQc graph, but almost identical error percent-age is achieved with a sampling factor of 1% on ca-CondMat, as the second graph is much larger.
While counting with Graft , the counting error of vari-ous graphlets varies based on the complexity and the size of the graphlet. To compare the relative counting error among different graphlets, we use the ca -CondM at graph dataset with the edge selection probability of 0 . 1. We repeat the counting process for 10 times and report the average count-ing errors in Figure 7. Each column in this graph represents http://snap.stanford.edu/data /index.html and http: //www-personal.umich.edu/~mejn/netdata Figure 7: Box-plot for approximation errors of different g raphlets in graph ca -CondM at Table 1: Speedup and Error trade-off on five real-life n etworks.(  X  marked graph X  X  approximate graphlet counting was done with p =0.01.) a distinct graphlet (which is shown as labels on the x -axis). The y -axis shows the percentage errors in counting. To show the variance of percentage error among different iterations, we show the results in a box-plot. From Figure 7 we ob-serve that, the counting error increases with the number of vertices in the graphlets. Also, complex graphlets that have more cycles are more error-prone than tree graphlets.
In this experiment, we compare the speedup and percent-age counting error of five real-world networks from collab-oration, blog, and web domains that are shown in Table 1. For this we use p = 0.1, which gives us about 1 /p = 10 times speedup (except the case of ca-AstroPh, for which we use p = 0.01). The percentage error values are between 2.81% and 5.93%. Our method generally performs better as the graph becomes larger and denser. In case of network ca-AstroPh (which is much bigger than other networks), we use p = 0.01 which gives a much higher speed-up while maintaining the same level of accuracy.
In this experiment, we justify the utility of approximate graphlet counting algorithm( Graft ). One of the main ob-Figure 8: GFD of 29 graphlets for different sampling factor o n ca-HepTh jectives for graphlet counting is to obtain the graphlet fre-quency distribution (GFD) for large graph analysis. We like to show that, although counting errors prevails by adopt-ing sampling in Graft , the effect of this error on GFD is negligible, because the latter compares the relative counts in a logarithm scale (log scale is used for GFD because the frequencies of different graphlets vary in exponential propor-tion). For this, we obtain graphlet count by running Graft for different sampling factors (10% , 7 . 5% , 5% and 1%) on various networks that we used in experiments discussed in Section 5.1. For these networks, We also obtain the exact graphlet count using Graft algorithm with p =1. We then find GFD from each of the results, and compare the GFD plots of a graph for different sampling factors. In Figure 8, we show this comparison for one network because the trend is similar for all the other networks. It is easy to see that the GFD histogram preserves its shape across different sampling factors, even for a sampling factor of 1% (which provides a 100-fold speedup).
In this paper, we present Graft , an effective method for approximate graphlet counting from large graphs. The al-gorithm offers significant speedup with a negligible counting error. For the same speedup factor, the counting accuracy of the algorithm improves with the size of the graph, so it is particularly suitable for counting graphlets in large real-life networks. [1] A.-L. Barabasi and R. Albert. Emergence of Scaling In [2] S. P. Borgatti, A. Mehra, D. J. Brass, and [3] E. C. E. Tsourakakis. Counting triangles in real-world [4] M. Faloutsos, P. Faloutsos, and C. Faloutsos. On [5] O. Kuchaiev, A. Stevanovic, W. Hayes, and N. Przulj. [6] J. Leskovec, J. Kleinberg, and C. Faloutsos. Graphs [7] T. Milenkovic and N. Przulj. Uncovering biological [8] N. Przulj. Biological network comparison using [9] C. E. Tsourakakis, U. Kang, G. L. Miller, and [10] D. J. Watts and S. H. Strogatz. Collective dynamics of
