 REGULAR PAPER Eamonn Keogh  X  Jessica Lin  X  Sang-Hee Lee  X  Helga Van Herle Abstract In this work we introduce the new problem of finding time series dis-cords . Time series discords are subsequences of longer time series that are max-imally different to all the rest of the time series subsequences. They thus capture the sense of the most unusual subsequence within a time series. While discords have many uses for data mining, they are particularly attractive as anomaly de-tectors because they only require one intuitive parameter (the length of the sub-sequence) unlike most anomaly detection algorithms that typically require many parameters. While the brute force algorithm to discover time series discords is quadratic in the length of the time series, we show a simple algorithm that is three to four orders of magnitude faster than brute force, while guaranteed to produce identical results. We evaluate our work with a comprehensive set of experiments on diverse data sources including electrocardiograms, space telemetry, respiration physiology, anthropological and video datasets.
 Keywords Time series data mining  X  Anomaly detection  X  Clustering 1 Introduction The previous decade has seen hundreds of papers on time series similarity search, which is the task of finding a time series that is most similar to a particular query sequence [ 10 , 11 , 26 ]. In this work, we pose the new problem of finding the se-quence that is least similar to all other sequences. We call such sequences time series discords. Figure 1 gives a visual intuition of a time series discord found in a human electrocardiogram.
 a cardiologist as containing an anomalous heartbeat hints at one possible use of discords. As we shall show, time series discords are superlative anomaly detectors, able to detect subtle anomalies in diverse domains.
 problem of anomaly detection is that they only require a single intuitive parame-ter, the length of the subsequences to consider. In contrast, many other anomaly detection algorithms require three to seven unintuitive parameters [ 11 ]. With so many parameters to set, we need access to huge amounts of training data, even then, avoiding overfitting remains a challenge.
 from removing a handful of tricky cases, which can be removed from the dataset before the clustering algorithm is run [ 2 ]. We could attempt to define these  X  X ricky cases X  as ones that do not belong to any cluster; however, this opens the possibility of a chicken and egg paradox. This effect has been noted in clustering points in k -dimensional space, but it is also true for time series, and the removal of discords offers a solution.
 series subsequences. First, while the idea of the  X  X ost unusual subsequence X  is intuitive, great care must be taken in creating a workable definition, otherwise we will be plagued with uninteresting pathological solutions. We introduce such a def-inition here and validate it in diverse domains. Second, the brute-force algorithm to discover the most unusual subsequence requires a quadratic  X  X ll to all X  com-parison, which is untenable for large real-world datasets. We introduce a simple algorithm that can achieve three to four orders of magnitude speedup on real prob-lems. Our algorithm works by admissibly pruning off some fruitless calculations, and using heuristics to reorder the search such that as many fruitless calculations are pruned as possible.
 work and discuss some background material before introducing our formal defini-tion of time series discords. In Sect. 3, we consider the brute-force algorithm for finding discords, and introduce a general framework for speeding up the search based on admissible pruning and reordering the order in which the search exam-ines the subsequences. Section 4 introduces a particular reordering strategy based on examining a symbolic version of the data. We perform an extensive empirical evaluation in Sect. 5 to demonstrate both the utility of discords and our ability to find them quickly. Finally, Sect. 6 offers some conclusions and suggestions for future work. 2 Related work and background Our review of related work is exceptionally brief because we are considering a new problem. Most real-valued time series problems such as motif discovery [ 1 , 3 , 12 ], longest common subsequence matching, sequence averaging, segmentation [ 8 ], indexing [ 10 ], etc. have approximate or exact analogues in the discrete world, and have been addressed by the text processing or bioinformatics communities. How-ever, time series discords do not appear to have a discrete version. Note that the superficially similar sounding Furthest (Sub)String Problem requires us to build a string, not to find one in the data [ 15 ]. As we shall see below, one major use of discords is in anomaly detection. This topic has been area of extensive research in recent years, we refer the reader to Keogh et al. [ 11 ], which gives a detailed survey. 2.1 Notation series.
 Definition 1 Time series : A time series T = t 1 , ... ,t m is an ordered set of m real-valued variables.
 properties of a time series [ 6 , 11 , 24 ]; rather, we are interested in local subsections of the time series, which are called subsequences.
 Definition 2 Subsequence : Given a time series T of length m, a subsequence C of T is a sampling of length n  X  m of contiguous position from T, that is, C = t ,..., t tually have to extract all of them; this can be achieved by use of a sliding window. Definition 3 Sliding window : Given a time series T of length m, and a user-defined subsequence length of n, all possible subsequences can be extracted by sliding a window of size n across T and considering each subsequence C p . measure Dist ( C , M ), we will take the time to define distance.
 Definition 4 Distance : Dist is a function that has C and M as inputs and returns a nonnegative value R, which is said to be the distance from M to C. For subsequent definitions to work we require that the function D be symmetric, that is, Dist(C, M) = Dist(M,C). We also assume that the two subsequences are of equal length. trivial matches . In general, the best matches to a subsequence (apart from itself) tend to be located one or two points to the left or the right of the subsequence in question. Such matches have previously been called trivial matches [ 1 , 3 , 12 ]. As we shall see, it is critical when finding discords to exclude trivial matches; otherwise, almost all real datasets have degenerate and unintuitive solutions. We will therefore take the time to formally define a non-self match.
 Definition 5 Non-self match : Given a time series T, containing a subsequence C of length n beginning at position p and a matching subsequence M beginning at q, we say that M is a non-self match to C at distance of Di st ( M , C ) if | p  X  q | X  n. hand if we consider the analogy of the problem in the discrete world. Consider the following string: the discord here. However, if we assume a sliding window length of 3, and that our distance measure is the hamming distance, then the subsequence that is farthest from its nearest neighbor subsequence is  X  bac . X  Below, the string is annotated by subscripts that give the distance to the nearest neighbor for each subsequence of length 3: This unexpected and unintuitive result is caused by allowing trivial matches. While the subsequence XXX may appear unusual, it is only 1 unit distance from the subsequence XXa , which shares two elements simply shifted by one place. We can see the difference this makes by annotating the string with the non-self match distance to its nearest neighbor subsequence: example on discrete data, as we shall see, identical remarks apply to real world, real-valued data. Note that the idea that one must exclude  X  X artial self X  compar-isons in order to create meaningful definitions is well known in the bioinformatics community [ 22 ] and increasingly understood in the time series data mining com-munity [ 1 , 3 , 12 , 21 , 24 ]. We will therefore use the definition of non-self matches to define time series discords: Definition 6 Time series discord : Given a time series T, the subsequence D of length n beginning at position l is said to be the discord of T if D has the largest distance to its nearest non-self match. That is,  X   X  subsequence C of T, X  non-self match M D of D, and non-self match M C of C, min(Dist(D, M D )) &gt; min(Dist(C, M C )) non-self matching neighbor as D . Dist . We denote the length of the discord as D n . follows.
 Definition 7 Kth time series discord : Given a time series T, the subsequence D of length n beginning at position p is the Kth-discord of T if D has the Kth largest distance to its nearest non-self match, with no overlapping region to the ith discord beginning at position p i , for all 1  X  i &lt; K . That is, | p  X  p i | X  n. generality. For concreteness, we will use the ubiquitous Euclidean distance mea-sure throughout the rest of this paper [ 3 , 11 ].
 Definition 8 Euclidean distance : Given two time series Q and C of length n, the Euclidean distance between them is defined as deviation of one before calling the distance function, because it is well understood that in virtually all settings, it is meaningless to compare time series with different offsets and amplitudes [ 11 ]. 2.2 Some properties of time series discords Here, we discuss some properties of time series discords to enhance the readers X  understanding of them and to discount some possible research directions for find-ing algorithms for quickly locating them. 2.2.1 Discords are not necessary found in sparse space The idea of considering time series subsequences as points in space has long been exploited by dozens of indexing techniques [ 10 ], so one might imagine that such a representation would be useful for the task at hand. We could simply project our time series into n -dimensional space and use existing outlier detection methods [ 2 , 13 ]. The problem with this idea is the unintuitive fact that discords do not nec-essarily live in sparse areas of n -dimensional space (conversely, repeated patterns do not necessarily live in dense parts of the n -dimensional space [ 1 , 3 , 12 ]). The full explanation has consequences for other problems and is perhaps deserving of a separate paper; however, here, we content ourselves with a visual example and a brief explanation. In Fig. 2, we consider a simple time series consisting of a slightly noisy sine wave. We introduce an  X  X nomaly X  of length 50 by shifting the entire second half of the time series.
 dimensional space and measure the local density around each subsequence. Sur-prisingly, the anomaly is not in the sparsest (or in any other way remarkable) region of space. However, note that the definition of non-self match that is at the heart of time series discords clearly identifies the anomalous region.
 matches. Consider a subsequence C located at t p that is  X  X imple, X  that is to say it has only one or two features such as peaks or valleys. This simple subsequence is very close in n -dimensional space to the subsequences beginning at t p + 1 , t p  X  1 , t + 2 , etc. In contrast, consider a subsequence M located at t q that is  X  X omplex, X  that is to say it has many features such as peaks or valleys. This complex subse-quence is relatively far from subsequences beginning at t q + 1 , t q  X  1 , t q + 2 ,etc.In other words, simple (and smooth) shapes appear to be in dense neighborhoods be-cause we over-count shifted versions of them. This problem prevents us for using existing density based algorithms to find time series discords. Note that even if current-density-based algorithms could be adapted to consider non-self distance, most of them degrade to quadratic time complexity for high dimensionality data. 2.2.2 Discords results are non-combinable Several generic paradigms for solving problems rely on the ability to decompose a problem into smaller sub-problems, which can be solved and admissibly recom-bined. Depending on the exact definitions, such techniques are variously called dynamic programming, divide and conquer, bottom-up, etc. [ 4 ]. Unfortunately, as we show below, such ideas are unlikely to help us efficiently find discords. find the discords for both sections, recording their locations as A.l , B.l and values as A.dist and B.dist , respectively. Furthermore, imagine that we now concatenate A and B to reproduce the original time series T (for simplicity, let us assume that when the discord for T is discovered, it will not span the end of A and the beginning of B ). What can we now say about the discord for T ? Surprisingly, the answer is very little. We cannot assume that it will be either in location A.l or in location |
A |+ B . l , because both of the two previously discovered discords may have good matches in the other section. All we can do is give weak bounds. The value of T.dist is at most max( A.dist , B.dist ). The lower bound of T.dist is a trivial zero (to see this, imagine A = B ). As to the location of T.l , we can say nothing. formation T.l and T.dist for T , and we split into two new time series A and B ,we are similarly frustrated. Assume that the discord from T happened to fall into A . We can lower bound A.dist as being greater than or equal to T.dist, but we cannot provide an upper bound. In addition, we can say nothing about the location of A.l . As for B.dist and B.l , we can say nothing.
 sliding window algorithm, since ingesting and egressing a single point can change the location and value of the discords by an arbitrary amount.
 for finding discords. This motivates the introduction of an original algorithm in the next section. 3 Finding time series discords The brute force algorithm for finding discords is simple and obvious. We simply take each possible subsequence and find the distance to the nearest non-self match. The subsequence that has the greatest such value is the discord. This is achieved with nested loops, where the outer loop considers each possible candidate sub-sequence, and the inner loop is a linear scan to identify the candidate X  X  nearest non-self match. The pseudo-code is shown in Table 1.
 sequences to consider. The algorithm is easy to implement and produces exact results. However, it has one fatal flaw for data mining. It has O( m 2 ) time complex-ity which is simply untenable for even moderately large datasets.
 time.
 Observation 1 In the inner loop, we do not actually need to find the true near-est neighbor to the current candidate. As soon as we find any subsequence that is closer to the current candidate than the best so far dist, we can abandon that instance of the inner loop, safe in the knowledge that the current candidate could not be the time series discord.
 Observation 2 The utility of the above optimization depends on the order which the outer loop considers the candidates for the discord, and the order which the inner loop visits the other subsequences in its attempt to find a sequence that will allow an early abandon of the inner loop.
 gorithm, for concreteness, we will make them clear. The pseudo-code is shown in Ta b l e 2 .
 the order in which the outer loop visits the subsequences, and one to determine the order in which the inner loop visits the subsequences. Note that the heuristic for the outer loop is used once, but the heuristic for the inner loop takes the current candidate into account, and is thus invoked to produce a new ordering for every iteration of the outer loop.
 where all one needs to do is to specify the heuristics. Note that we should not at-tempt to  X  X heat X  the algorithm. We could provide very good heuristic orderings if we are allowed to completely solve the brute force problem each time the heuristic functions are invoked! However, this is simply hiding the time complexity in a dif-ferent part of the implementation. We must therefore insist that the Outer heuristic (invoked only once) takes at most O( m ) to calculate and the Inner heuristic (in-voked m  X  n times) takes O(1). Note that this requirement precludes the possibility of using R-trees, K-d trees or other classic indexing algorithms [ 10 , 19 ]. up the search for discords, the results of the algorithm are exact , and completely independent of heuristics used. The heuristics change only the speed of the algo-rithm.
 solution to this problem, let us consider three possible heuristic strategies:  X  Random : We could simply have both the Outer and Inner heuristics randomly  X  Magic : In this hypothetical situation, we imagine that a friendly oracle gives us  X  Perverse : In this hypothetical situation, we imagine that a less than friendly time algorithm is possible, but only with the aid of some very wishful thinking. The Magic heuristic requires a perfect ordering of subsequences in the inner loop, and any perfect ordering (i.e., sorting) requires at least O( m log m ), but we are only allowed O(1). Furthermore, the only known way to produce the perfect ordering of subsequences in the outer loop requires O( m 2 ) work, but we are only allowed O( m ) time. The following two observations, however, offer us some hope for a fast algorithm.
 Observation 3 In the outer loop, we do not actually need to achieve a perfect ordering to achieve dramatic speedup. All we really require is that among the first few subsequences being examined, we have at least one that has a large distance to its nearest neighbor. This will give the best so far dist variable a large value early on, which will make the conditional test on line 9 of Table 2 be true more often, thus allowing more early terminations of the inner loop. Observation 4 In the inner loop, we also do not actually need to achieve a perfect ordering to achieve dramatic speedup. All we really require is that among the first few subsequences being examined we have at least one that has a distance to the candidate sequence being considered that is less than the current value of the best so far dist variable. This is a sufficient condition to allow early termination of the inner loop.
 they order subsequences relative to the Magic ordering. This spectrum spans {
Perverse ... Random ... Magic } . Our goal then is to find the best possible ap-proximation to the Magic ordering, which is the topic of the next section. quires a specialized solution, and we cannot leverage off the huge literature on time series similarity search [ 11 ]. Kd-Trees, R-trees and their many variants re-quire O(log( m )) time per lookup, but we can spare only O(1) time. In any case, these search algorithms support nearest neighbor search, whereas all we require here is  X  near-enough  X  neighbor search, as noted in observation 4. 4 Approximating the magic heuristic Before we introduce our techniques for approximating the perfect ordering re-turned by the hypothetical Magic heuristics, we must briefly review the Symbolic Aggregate Approximation (SAX) representation of time series introduced by Lin et al. [ 16 ]. While there are at least 200 different symbolic approximation of time series in the literature, SAX is unique in that it is the only one that allows both dimensionality reduction and lower bounding of L p norms. Since its relatively recent introduction, SAX has become an important tool in the time series data mining toolbox. It has been used to find time series motifs [ 3 , 21 ], to mine rules in health data [ 1 ], for anomaly detection [ 11 ], to extract features from a hepatitis database [ 12 ], for visualization [ 14 , 17 ], and a host of other data mining tasks. 4.1 A brief review of SAX A time series C of length n can be represented in a w -dimensional space by a vec-sions, the data is divided into w equal sized  X  X rames. X  The mean value of the data falling within a frame is calculated and a vector of these values becomes the dimensionality-reduced representation. This simple representation is known as Piecewise Aggregate Approximation (PAA) [ 16 ].
 further transformation to obtain a discrete representation. It is desirable to have a discretization technique that will produce symbols with equiprobability [ 3 , 11 ]. In empirical tests on more than 50 datasets, we noted that normalized subsequences have highly Gaussian distribution [ 16 ], so we can simply determine the  X  X reak-points X  that will produce equal-sized areas under Gaussian curve.
 Definition 9 Breakpoints : Breakpoints are a sorted list of numbers B =  X  , ... ,  X  a  X  1 such that the area under a N(0,1) Gaussian curve from  X  i to  X  i + 1 = 1 / a(  X  0 and  X  a are defined as  X  X  X  and  X  , respectively).
 For example, Table 3 gives the breakpoints for values of a from 3 to 5. following manner. We first obtain a PAA of the time series. All PAA coefficients that are below the smallest breakpoint are mapped to the symbol  X  a , X  all coef-ficients greater than or equal to the smallest breakpoint and less than the second smallest breakpoint are mapped to the symbol  X  b , X  X tc. Figure 3 illustrates the idea. imately equiprobable as we desired. We call the concatenation of symbols that represent a subsequence a word .
 Definition 10 Wo r d : A subsequence C of length n can be represented as a word  X  C = X  c 1 ,...,  X  c w as follows. Let a i denote the i th element of the alphabet, i.e., a is obtained as follows: tion that normalized subsequences have highly Gaussian distribution [ 16 ] is not critical to correctness of any of the algorithms that use SAX, including the ones in this work. A pathological dataset that violates this assumption will only affect the efficiency of the algorithms. 4.2 Approximating the Magic Outer loop We begin by creating two data structures to support our heuristics. We are given n , the length of the discords in advance, and we must choose two parameters, the cardinality of the SAX alphabet size a , and the SAX word size w . We defer a discussion of how to set these parameters until later in this section, but note that the values of  X  and w only affect the efficiency of our algorithm, not the final result, which depends only on the user supplied length of the discord.
 a window of length n across time series T , extracting subsequences, converting them to SAX words, and placing them in an array where the index refers back to the original sequence. Figure 4 gives a visual intuition of this, where both a and w are set to 3. of n -length sliding window  X  X umps X  against the end of the m -length time series.
 augmented trie where the leaf nodes contain a linked list index of all word occur-rences that map there. The count of the number of occurrences of each word can be mapped back to the rightmost column of the array. For example, in Fig. 4, if we are interested in the word caa, we visit the trie to discover that it occurs in locations 1, 3, and 731. If we are interested in the word that occurs at a particular location, let us say ( m  X  n )  X  1, we can visit that index in the array and discover that the word cbb is mapped there. Furthermore, we can see by examining the rightmost column that there are a total of two occurrences of that particular word (including the one we are currently visiting). However, if we want to know the location of the other occurrence, we must visit the trie.
 the length of T [ 1 , 23 ]. In fact, if we take advantage of the fact that we only need log 2 ( a ) bits for each SAX symbol, then both data structures are significantly smaller than the raw time series data they were derived from.
 the array to find the smallest count mincount (its value is virtually always 1). The indices of all SAX words that occur mincount times are recorded, and order.
 very likely to map to unique or rare SAX words. By considering the candidate sequences that map to unique or rare SAX words early in the outer loop, we have an excellent chance of giving a large value to the best so far dist variable early on, which (as noted in observation 3) will make the conditional test on line 9 of Table 2 be true more often, thus allowing more early terminations of the inner loop. 4.3 Approximating the Magic Inner loop Our Inner heuristic also leverages off the two data structures shown in Fig. 4. When candidate i is first considered in the outer loop, we look up the SAX word linked list index found at the terminal nodes. For example, imagine we are work-ing on the problem shown in Fig. 4. If we were examining the candidate C 731 in the outer loop, we would visit the array at location 731. Here we would find the SAX word caa . We could use the SAX values to traverse the trie to dis-cover that subsequences 1, 3, 731 map here. These three subsequences are visited first in the inner loop (note that line 8 of Table 1 prevents 731 from being com-pared to itself). After this step, the rest of the subsequences are visited in random order.
 have the same SAX encoding as the candidate subsequence are very likely to be highly similar (this fact is at the heart of more than 20 research efforts [ 1 , 3 , 11 , 12 , 17 , 24 ]). As noted in observation 4, we just need to find one such subsequence that is similar enough (has a distance to the candidate than the current value of the best so far dist variable) in order to terminate the inner loop. Because our algorithm works by using heuristics to order SAX sequences, we call it HOT SAX, short for Heuristically Ordered Time series using Symbolic Aggregate Ap-proximation. 4.4 Minor optimizations and parameter setting There are several minor optimizations we can apply to the heuristic search algo-rithm. For example, imagine we are considering candidate C i in the outer loop, and as we traverse through the inner loop, we find that subsequence C j is close enough to it to allow early abandonment. In addition to saving time with the early termination, we can also delete C j from the list of candidates in outer loop (if it has not already been visited). The key observation is that since we are assuming a symmetric distance measure, if nearness to C j disqualifies candidate C i from being the discord, then the same nearness to C i would also disqualify candidate C j from being the discord. Empirically, this simple optimization gives a speed-up factor of approximately 2. In addition, there are several well-known optimizations to the Euclidean distance that we can use [ 13 ].
 alphabet size a and the SAX word size w . Recall what it is we want to opti-mize. We would like the distribution of the SAX words to be highly skewed, so that the discord will map to a SAX word that is unique or rare, and all the other subsequences will map to SAX words that are very frequent. This is the best situ-ation for both our heuristics. If we choose very large values of a and/or w ,almost all subsequences will map to unique words; if we choose very small values of a and/or w , all subsequences will map to just a small handful of words. Either of these situations is bad for our heuristics.
 experiments carried out by the current authors [ 3 , 11 , 14 , 16 , 17 ] and dozens of other researchers worldwide [ 1 , 12 , 24 , 21 ] suggest that a value of either 3 or 4 is best for virtually any task on any dataset. After empirically confirming this on the current problem with experiments on more than 50 datasets, we will simply hardcode a = 3 for the rest of this work. Having fixed a , we performed an exhaus-tive empirical examination of the role of the w parameter. The best value for this parameter depends on the data. In general, relatively smooth and slowly changing datasets favor a smaller value of w , whereas more complex time series favor a larger value of w . The following observations mitigate the problem of parameter setting: ing the best value on a particular data we found we could vary the value of w in the range of 60 X 150% with less than a 12% decrease in speedup.
 will also work well on other datasets of the same type (assuming the sampling rate is the same).
 5 Empirical evaluation We begin by showing the utility of time series discords for a several medical do-mains, then go on to show that our algorithm is able to find discords very effi-ciently. 5.1 The utility of time series discords In this paper, we will only demonstrate the utility of discords as anomaly detectors. We have done extensive successful experiments in other tasks, such as improving the quality of clustering and summarization; however, anomaly detection is unique in that it allows immediate and intuitive visual confirmation. The additional exper-iments for other tasks, together with many extra anomaly detection experiments can be found here [ 9 ]. We encourage the interested reader to consult this site for additional examples and larger and more detailed figures of the experiments shown below.
 approaches here. There are two reasons for this. Firstly, it is very difficult to make meaningful comparisons between our method, which requires only one intuitive parameter, and some of the rival methods that require three to seven parameters (see [ 11 ] for a detailed discussion of this), including some parameters for which we may have poor intuition, such as Embedding dimension [ 5 ], Kernel function [ 18 ] , SOM topology or number of Parzen windows .
 algorithms require a separate training dataset (in order to learn the parameters), whereas our approach finds anomalies while only examining the test dataset. One could easily imagine generalizing the discord discovery algorithm to examine only the test data in the outer loop and only training data in the inner loop. However, we wish to concentrate on first proving our simple intuitive definitions before creating generalizations. 5.2 Anomaly detection in electrocardiograms Electrocardiograms (ECGs) are a time series of the electrical potential between two points on the surface of the body caused by a beating heart. They are arguably the most important time series, and as such, there are many annotated test datasets we can consider. We have already considered the utility of discords in one ECG in Fig. 1. That was a very simple and  X  X lean X  example for clarity; however, it is remarkable how varied and complex normal healthy ECGs can be. For example, Fig. 5 shows a very complicated signal with remarkable variability. Surprisingly, this ECG contains only one small anomaly, which is easily discovered by a discord detection algorithm.
 Here, the first three discords exactly line up with the cardiologist X  X  annotations. In this figure we could perhaps spot the anomalies by eye; however, the full time series is much longer, and impossible to scrutinize without a scrollbar and much patience. one full heartbeat (note that the two datasets have different sampling rates). Al-though we found that we could double or half the parameters without affecting the quality of results, on just a handful of the dozens of ECG datasets we examined, the discords had a harder time finding the anomalous heartbeats. One of the au-thors of the current work, Helga Van Herle, M.D., is a cardiologist. She informed us that heart irregularities can sometimes manifest themselves at scales signifi-cantly shorter than a single heartbeat. Armed with this knowledge, we searched for discords at approximately one-fourth the length of a single heartbeat. In Fig. 7, we show the results of a search with the shorter length discords.
 is not obvious from the figure that the discord is actually different for the other heartbeats. In Fig. 8 ( left ) we see a zoom-in of the subsequence surrounding the discord, and we can see that the discord falls over the ST wave. In Fig. 8 ( right ), we manually extracted four ST waves from the subsequence in Fig. 7 and clustered them together with the discord. This makes the source of the anomaly apparent. Note that in the four normal ST waves, after the brief descending section, the signal rises monotonically. However, the anomalous ST wave has an additional local peak caused by a premature beat, thus justifying the cardiologist X  X  diagnosis of premature ventricular contraction. 5.3 Change detection in patient monitoring The problem of change detection is fundamentally different from anomaly detec-tion. In anomaly detection, the task is to find one or more  X  X ifferent X  subsequences that exist in the background of a normal data. In the problem of change detection, we assume that the underlying model that produces the signal changes in some (possibly very subtle) way at various points. The task is to identify the locations of these change points.
 tion, since they look at local patterns, whereas most change detection algorithms consider global (or at least much larger  X  X ocal X ) information. However, we be-lieve that in some situations, the change in underlying global model may produce some unusual local shapes because the local pattern must straddle two different models.
 tion (measured by thorax extension), as they wake up. A medical expert, Dr. J. Rittweger of the Institute for Physiology, Free University of Berlin, manu-ally segmented the data. We choose a discord length corresponding to 32 s be-cause we want to span several breaths. In Fig. 9, we see the outcome of the first experiment.
 their eyes. In contrast, the second discord is much more subtle and difficult to see at this scale. A zoom-in suggests that Dr. Rittweger noticed a few shallow breaths that indicated the transition of sleeping states. In both cases the discords straddle the change in sleeping cycle. We tested many such datasets with equally positive results. Figure 10 shows another representative example. 5.4 Power demand data exploration The experiments above were performed in domains where objective answers are readily available. In this section, we perform an experiment where the only evalu-ation is the intuitiveness of the discords discovered.
 search facility for the entire year of 1997. We wanted to find the three most usual weeks. Note that we did not specify that week should begin at certain day or time. We initially guessed that a length of 750 would cover an entire week; this turns out to be a little long, but we show this experiment to avoid  X  X olishing X  the results. Figure 11 shows the result of finding the top three discords in this dataset. all unusual in that they are from weeks in which two weekdays are holidays. 5.5 Shape database exploration In this experiment we consider a primatological dataset. In particular, we are work-ing with noted physical anthropologist, Dr. Sang-Hee Lee, on various problems in indexing, classifying and clustering large collections of skulls and bones. The following two observations allow us to mine this data resource with our discord discovery tool.  X  The idea of converting shapes to time series is at least two decades old. There  X  All our experiments thus far have assumed that the time series subsequences mate skulls [ 7 ]. In one experiment we found a strong discord in the Orangutan ( Pongo ) database, a database that contains a diverse collection of Orangutan im-ages, including males/females, adults/juveniles, Borneo/Sumatran, etc. Figure 13 shows the discord discovered.
 unlike the others, but what is the significance of this? To answer this question we retrieved the original image and showed it to our domain expert. Dr. Lee had an immediate explanation of our finding. The skull in question was not an Orangutan, but a Howler monkey misfiled by a graduate student! Figure 14 shows the original image corresponding to the discord.
 clidean difference between the discord and the mean of all other time series. Note that the major differences all have obvious anatomical meaning [ 7 , 25 ]. The two largest peaks correspond to most distinctive and unusual feature of the Howler monkey, its massive jaw (corpus and gonion) which is used to produce its epony-mous sound (it is believed to be the loudest land mammal). The Howler monkey also has a highly angular inion, the ectocranial midline point at the base of the external occipital protuberance, whereas the Orangutan has the more rounded in-ion, which is typical of all the great apes. Finally, the Orangutans do not have an extruding rhinion (informally  X  X ose, X  or more correctly the midline point at the inferior free end of the internasal suture), whereas the Howler monkey has a pronounced one [ 7 ]. 5.6 Video data exploration For our final experiment on the usefulness discords, we examined a video dataset. For concreteness, we will briefly discus how the data was extracted.
 pixels, and frame rate of 30 frames/s, was used to record the actions of a female actor. Only the actor X  X  right hand was tracked, to facilitate this she wore a red glove on that hand only. A frame that has good color visibility was selected from the video sequence. The selected frame is then used to calculate Hue, Saturation, and Value from each pixel. A region of the color to be tracked (red in this case) is also selected and this forms the region of interest (ROI). The HSV from each pixel of the selected frame, along with the mean and covariance from the ROI of the selected frame form the input to find probability distribution for the ROI over the whole image. The probability distribution uses a multivariate Gaussian and results in a probability matrix of the size of the image. This resultant matrix is converted to a binary image by thresholding, and then the resultant binary image is used to compute the centroid position of the hand. The overall dataset is of very high quality, however there is some noise and dropouts due to occlusion, etc. The entire dataset consists of just over 200,000 datapoints.
 a short pause in-between. The actions consisted of two classes,  X  Innocuous , X  for example, pointing to photograph on the wall, and  X  Threatening , X  for example, drawing a replicate firearm from a holster and aiming it.
 tions with and without a replica gun. The time series measures the Y -coordinate of the actor X  X  right hand.
 problem, and has been used for that task many times [ 19 ]. We ran our algorithm to find the discord of length 150 (equivalent to 3 s of video), the result is shown in Fig. 15. showing a 10% excerpt. The discord does appear to be intuitive, in that the shape of the discord appears to be different from that of its neighbors. However, it is not obvious as to what this discord means, if anything. In Fig. 16 we show a zoom-in of the discord augmented by screen captures from the original video.
 grabs the gun from the holster and aims it at a target. The sequence concludes with the actor retuning the gun to the holster and her hand to her side. For the first two events (from time 1 to 300), the actor makes two successful gun draws. However, at time 300, when returning the gun to the holster, the actor misses. She looks at the video technician, who has made a remark, she smiles and attempts to continue, but she is not looking at the target. She briefly convulses with laughter, at one point she is literally bent double with laughter, and then quickly regains composure. 5.7 The utility of HOT SAX search It is increasingly recognized that comparing algorithm performance by examining wall clock or CPU time invites the possibility of implementation bias [ 10 ], which in turn invites the possibility of irreproducible  X  X mprovements. X  Instead, we mea-sure here the number of times that the distance function is called on line 9 in Tables 1 and 2. A simple analysis of the pseudo-code (confirmed with a profiler) tells us that this single line of code accounts for more than 99% of the running time for both algorithms. In addition to fairness and reproducibility, there is another prag-matic reason for this metric. For brute force search, this number depends only on n and m and can simply be computed (recall m is the length of the time series and n is the length of the subsequence). If we had to actually measure the wall clock time for brute force search for all the experiments in this work, it would take several years.
 discussed in Sect. 4.2; however, we note that this is a O( m ), one time cost. For datasets of a reasonable size (i.e., the datasets shown in Figs. 11 or 12), this over-head takes much less than 0.1% of the total time. Furthermore, as the datasets get larger, it takes an even smaller percentage of time.
 gorithm in terms of the number of times the Euclidean distance function on line 9 is called. For the heuristic search we averaged the results for each setting of dataset/length over 100 runs on different subsets of the data.
 of length 64,000, the heuristic algorithm is almost 3000 times faster than brute force for all datasets. This experiment is actually pessimistic in that we made sure that the test data did not have any obvious anomalies or unusual patterns. In general, if there are truly unusual patterns in the time series, the heuristic algorithm is even faster.
 three orders of magnitude of a speedup for most problems. To concretely ground these numbers, consider the following. While our current implementation is in rel-atively lethargic Matlab, the experiments shown in Figs. 10 X 12 take a few seconds using heuristic search, but several hours using brute force search.
 of  X  X asy X  datasets and the right setting of the single parameter, we repeated the experiment for every dataset in the UCR Time Series Data Mining Archive over a range of values for n . We tested all datasets that have a length of at least 16,000; there are currently 82 such datasets from a diverse set of domains. Figure 18 shows the results.
 averaged over are exceptionally noisy. In addition, the maximum size of the data (16 k) was relatively small to allow us to average over many datasets. Neverthe-less, the results support the contention that a minimum speedup of two orders of magnitude can be expected for any combination of dataset and value for n ,and even greater speedup can be expected as the datasets get larger.
 As one might expect, perverse has exactly same performance as brute force search. The Random heuristic typically produces an approximately 10-fold speedup over completely dwarfed by the Magic heuristic. 6 Conclusions and future work In this work, we have defined time series discords, a new primitive for time series data mining. We introduced a novel algorithm called HOT SAX to efficiently find discords and demonstrated their utility on a host of domains.
 tensions to multidimensional time series, to streaming data, and to other distance measures. In addition, for truly massive datasets, even the large speedups obtained may be insufficient for real time interaction. We therefore plan to investigate an anytime version of our algorithm. Finally, the tentative experiment in Sect. 5.5 suggests that discord discovery may be useful for image datasets, this is an area of research we are actively pursuing.
 References Author Biographies
