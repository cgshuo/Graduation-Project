 Smart meters are being deployed by utility companies to monitor water and energy use in real-time. Hourly consumption data is recorded and wirelessly reported to a central server by smart meters. This real-time consumption data is useful for better understanding water and energy consumption behaviours. How-ever, one challenge is to efficiently analyse these time series data to characterize consumption behaviours. Manually inspecting and analysing is time-consuming and labour intensive. Data mining techniques are needed to automatically extract information and knowledge about consumption behaviours from smart meter time series [ 1 ].
 In this paper, we introduce recurrent routine behaviours to characterize reg-ular water and energy use activities, and propose a novel algorithm to efficiently discover recurrent routines in smart meter time series. A recurrent routine is a group of similar subsequences that occurs frequently within its parent sequence. Figure 1 shows an example routine (marked in the red dotted-line boxes) in a hourly observation smart water meter data, which records 350 hours water con-sumption for a household in the area of Kalgoorlie-Boulder in Western Australia. This recurrent routine corresponds to a 2-hour water use activity, occurring 5 times during the 350 hours. This routine uses about 880 litres water in the first hour and approximately 1000 litres water in the second hour.
 various lengths in a smart meter time series, which is similar to motif discovery in previous work [ 2  X  6 ]. The work in [ 2 ][ 3 ] defined motifs as previous unknown pat-terns that frequently occur in a time series. Efficient motif detection algorithms were proposed by encoding subsequences as symbolic representation. Exact motif discovery was computationally intractable until the work in [ 4 ][ 5 ]proposedan efficient way to early terminate searching. Later, Mueen [ 6 ] proposed a novel algo-rithm to efficiently enumerate motifs of all possible lengths. However, instead of finding the most frequently occurring patterns, the work in [ 4  X  6 ] defined the motif as the most similar subsequence pair in a time series.
 aspects. First, we are not only interested in segment shapes but also raw val-ues of segments, since the segment shapes reflect water and energy use trend while the raw values provide exact water and energy consumption. Second, the subsequence length is much shorter than that in previous work, since routines normally last for only a few hours. Finally, since we do not have prior knowledge about the length of routines, we need to detect all repeated subsequences with variable length.
 smart meter time series. Then, we propose a novel subsequence growing algo-rithm to efficiently discover all routines with various lengths in smart meter time series. The contribution of the paper is three-fold. First, we formally formulate the problem of discovering routines in smart meter time series. Second, a novel algorithm is proposed to efficiently detect routines by growing subsequences. Third, we demonstrate the application of the proposed algorithm on a real-world dataset and evaluate the proposed algorithm using a synthetic dataset. 2.1 Notation This subsection gives the notation in this paper.
 Definition 1 . Smart Meter Time Series : A time series T =( t is a sequence of n real valued numbers ordered in time.
 In this paper, the smart meter time series are hourly observations of water or energy consumption by individual households, i.e., each point of a smart meter time series records the water or energy consumption during one hour. Definition 2 . Subsequence : Given a smart meter time series T with length n , a subsequence S of T is a subset of m consecutive observations from T , i.e., S =( t p ,  X  X  X  ,t p + m  X  1 ), where 1  X  p  X  n  X  m +1, and m&lt;n .
 In the context of smart meter time series, a subsequence with length m represents a consumption activity over m consecutive hours.
 Definition 3 . Magnitude : Given a subsequence S m p with length of m ,the magnitude of S m p is the maximum of all the elements in the subsequence i.e., Mag ( S m p )= max ( t k ), where t k is the k th element of S Definition 4 . Match : Given two subsequences, S m i and S length of m from a smart meter time series T , if the distance between the two subsequences is less than a threshold R , i.e., Dist ( S m subsequences are matched . If two subsequences are matched, they are also called similar with each other.
 Definition 5 . Trivial Match : Given a subsequence S m i and its matched sub-sequence S m j ( i&lt;j ), if for all k between i and j , Dist ( S is a trivial match of S m i .
 Trivial match rarely occurs in smart meter time series because smart meter time series are always spiky.
 The distance function Dist ( ., . ) is critical to the definition of match . We define the distance measurement based on Euclidean distance.
 Definition 6 . Distance : Given two subsequences, S m i and S length of m , the distance between S m i and S m j is defined based on the Euclidean distance between S m i and S m j , i.e., Dist ( S m i ,S m We incorporate the subsequence length m into the distance metric to fairly compare distances of subsequence pairs with different lengths, since longer sub-sequence pair has larger standard Euclidean distance than their corresponding shorter subsequence pair.
 Definition 7 . Motif : Given a smart meter time series T , a subsequence length m , and a distance threshold R , the most significant motif is the subse-quence with length m that has most number of matched occurrences under the distance threshold, i.e.,  X  i, j : Dist ( S m i ,S m j ) &lt;R .The K T is the motif that has the K th most number of matched occurrences. Definition 8 . Recurrent Routine : Given a frequency threshold C and a mag-nitude threshold G , a recurrent routine in a smart meter time series is a motif that has at least C matched occurrences in the time series, each of which has at least G magnitude.
 that water or energy used by the routines is significant enough to be interesting and these behaviours occur regularly. These parameters are determined in terms of domain application requirement. 2.2 Why the Problem is Difficult One big challenge of our problem is that it is difficult to represent smart meter segments (behaviours) using low dimensional representations (e.g., symbolic con-version) without losing exact consumption information. Representing segments into a low dimension in previous motif discovery work [ 2 ][ 3 ] requires to dis-cretize and normalize the segments, which only keeps the consumption trend but removes exact consumption information. Furthermore, encoding a short smart meter segment that only consists of several data points into a low dimensional representation (such as symbolic string [ 2 ][ 3 ]) does not save computation cost, as the dimension of the segment is already very low. Therefore, the previous approximate motif discovery algorithms are not well suited to the problem of routine discovery in smart meter time series.
 which is thought to be intractable until the work in [ 4 ] shows a representa-tional trick to efficiently estimate lower bound of subsequence distance. Unlike approximation motif discovery algorithms that convert subsequences into a low dimension, exact algorithms [ 4  X  6 ] calculate distance based on raw values of sub-sequences, which is able to keep exact consumption information in smart meter time series. However, instead of finding the most frequent patterns, the existing exact algorithms define the motif as the most similar subsequence pair in a time series, i.e., the exact algorithms only find the most similar pair in a time series [ 4  X  6 ]. Although it is argued that the exact algorithms can be extended to find the most frequent subsequence patterns by finding other occurrences of the most similar pair within a distance threshold, the extension is not easy and efficient. 3.1 Discovering Routines with Fixed Length The algorithm to discover routines with fixed length (DRFL) is illustrated in algorithm 1 . The output of algorithm 1 is a set of m -length routines B of which comprises a cluster centre (motif) and its corresponding subsequence instances. Functions Cent( B i ) and Inst( B i ) in the following algorithms return the cluster centre of B i and the list of corresponding subsequence instances, respectively. First, a sub-window with length m is slid along the time series to extract a group of candidate subsequences (line 1-2). Then, these candidate subsequences are input into a sequential cluster algorithm for grouping (line 3), which is given in algorithm 2 . Since the sub-window is slid point by point, multiple clusters may actually correspond to the same routine. If two clusters Algorithm 1. Discovering routine with fixed length (DRFL) correspond to the same routine, their instance occurrences will overlap with each other. Therefore, an overlap testing algorithm is introduced to determine if two clusters correspond to the same routine (line 4-6), the detail of this step is given in algorithm 3 .
 Algorithm 2 gives the detail of sequential clustering of a set of subsequences. First, we initialize the first cluster centre (potential routine) Cent( B first subsequence S 1 . When a new subsequence S i arrives, if the magnitude of S is not larger than the magnitude threshold G , this subsequence will be dis-carded. Otherwise, if it is larger than the magnitude threshold G , the distance between the new subsequence with each of cluster centres Cent( B (line 4-5). The cluster centre  X  j that has minimum distance to the new subse-quence is selected (line 6). If the minimum distance is smaller than the given distance threshold R and S i is not a trivial match with any of the instances of B (function NTM() ), the new subsequence S i is grouped into the 7-9). Otherwise, a new cluster centre is created by inserting the new subsequence S (line 11-12). Finally, the cluster centres that have small number of instances are removed (line 13-14), since only the behaviours that occur multiple (regular) times are routines.
 Algorithm 3 gives the detail of overlap testing for two lists of subsequences (i.e., instances from two clusters). Suppose a p -length subsequence S point at i ,a q -length subsequence S q j with start point at j in a time series, and p&lt;q , if the inequality equation, (( i + p ) &lt;j )  X  two subsequences are not overlapped with each other.
 Since subsequences are extracted by sliding a sub-window along the time series, the subsequences in a cluster are temporally ordered. Suppose that we are trying to insert a subsequence in the first list into the second list according to its temporal order (line 3-4, I m i is the temporal start point of subsequence S the inserted subsequence in the first list can only be overlapped with its adjacent subsequences in the second list. Therefore, we test if the inserted subsequence Algorithm 2. Subsequence grouping (SubGroup) is overlapped with its adjacent subsequences. If it is overlapped, the number of overlapped instance will increase by 1 (line 5). This process is repeated for all the subsequences in the first list. Finally, if the number of overlapped subsequences is larger than the frequency threshold, then the two lists of subsequences are determined duplicated (line 7), and only the subsequence list that is longer or has larger magnitude will be kept (line 8-12). 3.2 Discovering Routines with Various Lengths Extending the routine discovery algorithm with fixed length to find all routines with variable length between L min and L max is straightforward. We can repeat the DRFL algorithm by incrementally increasing the subsequence length from L min to L max to enumerate all the possible routines. 4.1 The Intuition Behind Subsequence Growing Algorithm The motivation of the proposed algorithm is to make use of shorter motif infor-mation to simplify the length enumeration. Figure 2 illustrates the intuition behind the proposed algorithm. The three 4-point length subsequences in the time series are matched with each other. Our target is to find these three simi-lar subsequences and their corresponding motif (cluster) without the knowledge Algorithm 3. Efficient overlap testing (OverlapTest) of subsequence length. Three shorter segments that only contains 2 points can be extracted from each of the longer subsequences. For the shorter segments extracted from the longer subsequences with the same location offset (such as the red segments), they are also similar to each other as well, i.e., they belong to a motif with length of 2. Three motifs with length of 2 can be detected by grouping the shorter segments. The key insight of our algorithm is that shorter motifs and their subsequence instances contain the location information of all potential longer motifs and their subsequences, which are interesting routines. The observation is that if two longer subsequences are similar with each other, then segments extracted from the two subsequences, respectively, must also be similar.
 This observation leads to incrementally grow short segments to longer subse-quences and only group the candidate longer subsequences into clusters (motifs). This subsequence growing method avoids repeatedly sliding different size sub-windows along a time series to extract candidate subsequences with different lengths, which has a high computational cost. In another words, instead of slid-ing a sub-window to extract longer subsequences, the segment growing method grows candidate longer subsequences from shorter motifs, which can be detected with a minimum length parameter. 4.2 Formal Statement of Subsequence Growing Algorithm The proposed subsequence growing algorithm consists of three steps: detecting routines with minimum length; clustering candidate subsequences grown from shorter subsequences; and overlap testing to remove duplicate routines. Algo-rithm 4 describes the detail of discovering routines by growing subsequences. The algorithm discovers all routines with lengths between L a smart meter time series.
 which extracts all the routines that have the minimum length L incrementally increase the subsequence length from L min +1 to L For a certain longer subsequence length i , there are i  X  to grow an i -length subsequence from a L min -length subsequence. Therefore, for each of the i  X  L min + 1 possible growing ways (line 3), we grow the instances ( L min -length subsequences) of a routine B L min k to extract candidate longer sub-sequences S i,j,k (Line 4-5). Each set of the longer subsequences S input into the subsequence grouping algorithm (algorithm 2 ) so that similar longer subsequences are grouped into a cluster. The subsequence grouping algo-rithm guarantees that the discovered longer routines have a large number of instances and correspond to high consumption. Once the routines are discov-ered for each subsequence length and growing way, all of the discovered routines are concatenated with the routines with shortest length to form a final routine list B .
 subsequence instances of the same shortest routine, there maybe duplicated rou-tines in B that actually correspond to the same routine. In order to remove the duplicated routines from B , the overlap test algorithm (algorithm 3 ) is per-formed to identify duplicate routines that should be removed. Similar to the overlap test step in algorithm 1 , each routine in B is compared with the other routines to determine if they are duplicated or if it will be kept. Finally, only one copy of duplicated routines that is most interesting in terms of longer length and higher magnitude will be kept and the remaining duplicated copies will be removed (line 8-12). Algorithm 4. Discovering routines by growing subsequences 5.1 Case Study on Real Dataset Real Dataset. The dataset compromises one year of hourly smart water meter readings from 500 households in the city of Kalgoorlie-Boulder, 600 km inland from the capital Perth in Western Australia.
 Discovered Routine Behaviours. Figure 3 shows five routine behaviours dis-covered by the proposed algorithm for one household in the Kalgoorlie data set. These routines occur over 367 days with an average of 24 recurrences per routine. The black, red, and blue routines occur only on Wednesdays and Saturdays at the same hour of the day: either 4am or 8pm, with a few occurrences at 5pm. These routines are most likely associated with an automated garden watering system. The green and cyan routines have less regular timing, occurring on any day of the week except Sunday and at different times of day between 7am and 11pm. The total water use of these routines is 184 kL which is 34% of all water use for this household. These results demonstrate that identifying routines pro-vides useful information for water providers and users. They capture different types of regularity, different length patterns, and identify patterns with potential for significant water savings. 5.2 Evaluation on Synthetic Dataset Synthetic Dataset. A synthetic dataset with ground truth is generated to fairly evaluate the performance of the proposed algorithm. Four groups of primi-tive subsequences with random small variations (within 30) are randomly planted onto a long base sequence with different number of instances. The four groups of primitive subsequences are as below.
 magnitude G and they occur from 2 . 5 to 5 times of C (frequency threshold). The primitive subsequences in this group are 824 , 726 , 580 , 691 , 472 , 575 , 1242 , 1985 , 1058 , 886 , 2422 , 2380 , 2465 , 1718 and 1272 , 1607 , 1182 , 794 . group are not large enough but their instance number is from 1 to 2 times of the frequency threshold C . The primitive subsequences in this group are 123 , 305 , 233 , 246 , 289 and 324 , 56 , 152 , 203 .
 magnitude but their instance number is less than the frequency threshold C . The primitive subsequences in this group are 612 , 212 , 165 , 854 , 328 and 1422 , 132 , 68 , 534 .
 ing primitive subsequences. Their instance number is below the frequency thresh-old C . The primitive subsequences in this group are 233 , 246 , 289 , 1242 , 1985 , 1058 and 824 , 726 , 123 , 305 .
 tines that need to be detected. The ground truth of the synthetic dataset is the location of the planted primitive subsequences in the group of frequent and interesting .
 Correctness on Synthetic Dataset. Precision, recall and F-measure [ 7 ]are used to quantitatively evaluate the performance of the proposed algorithm. Let P be a set of planted subsequence instances (patterns) and D be the set of detected motif instances, the precision, recall and F-measure are defined as: performance of the subsequence growing algorithm. Table 1 gives the precision, recall, F-measure and running time of the subsequence growing algorithm and the brute-force algorithm with different distance thresholds on the synthetic dataset. Since the small variations added to the primitive subsequences are within 30, the optimal distance threshold should be approximate 60. We intentionally varied the distance threshold to test the sensitivity of the algorithm to the distance threshold.
 It can be seen that both the subsequence growing algorithm and brute-force algorithm achieve very high accuracy (F-measure over 95%) when the distance threshold is between 50 and 200. The accuracies obtained by the subse-quence growing algorithm and the brute-force algorithm are comparable. How-ever, the subsequence growing algorithm takes significantly lower computation time than the brute-force algorithm. This is mainly because the subsequence growing algorithm avoids repeatedly sliding a sub-window with variable size to extract candidate subsequences.
 Scalability Experiment. A scalability experiment is conducted to compare the computational cost of the subsequence growing algorithm and brute-force algorithm. All the experiments are implemented in R on a computer with an Intel I7-4700 2.4 GHz processor with 8 GB RAM. First, we produce 11 sets of synthetic datasets with different lengths from 5000 to 100,000. We ran the algorithms for 10 times. The average execution time on a time series with respect to time series length is shown in Figure 4a . Second, we fix the length of base sequences to 80,000 and planted different number of subsequence primitives onto the base sequences. Five sets of time series are generated with different number of subsequence instances from 50 to 100 (2.5 to 5 times of frequency threshold C ), from 400 to 500, from 800 to 1000, from 1300 to 1500, and from 1800 to 2000, respectively. The average execution time of the two algorithms on a time series with respect to the number of subsequence instances are shown in Figure 4b . From the figure, it can be seen that the average execution time of the subsequence growing algorithm is much less than that of the brute-force algorithm, which demonstrates that the subsequence growing scales better than the brute-force algorithm with respect to the length of time series and number of instances. In this paper recurrent routine behaviours were introduced to characterize reg-ular consumption behaviours from smart meter time series. we proposed a novel algorithm to efficiently discover recurrent routine behaviours in smart meter time series by growing subsequences. The proposed algorithm incrementally grows longer subsequences from shorter subsequences to avoid enumerating all possi-ble subsequence lengths. We demonstrated the discovered routine behaviours in a real-world dataset, and evaluated the performance of the proposed algorithm on a synthetic dataset.

