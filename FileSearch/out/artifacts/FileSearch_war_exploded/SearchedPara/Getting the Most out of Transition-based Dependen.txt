 Dependency parsing has recently gained consider-able interest because it is simple and fast, yet pro-vides useful information for many NLP tasks (Shen et al., 2008; Councill et al., 2010). There are two main dependency parsing approaches (Nivre and McDonald, 2008). One is a transition-based ap-proach that greedily searches for local optima (high-est scoring transitions) and uses parse history as fea-tures to predict the next transition (Nivre, 2003). The other is a graph-based approach that searches for a global optimum (highest scoring tree) from a complete graph in which vertices represent word tokens and edges (directed and weighted) represent dependency relations (McDonald et al., 2005).
Lately, the usefulness of the transition-based ap-proach has drawn more attention because it gener-ally performs noticeably faster than the graph-based approach (Cer et al., 2010). The transition-based ap-proach has a worst-case parsing complexity of O ( n ) for projective, and O ( n 2 ) for non-projective pars-ing (Nivre, 2008). The complexity is lower for pro-jective parsing because it can deterministically drop certain tokens from the search space whereas that is not advisable for non-projective parsing. Despite this fact, it is possible to perform non-projective parsing in linear time in practice (Nivre, 2009). This is because the amount of non-projective dependen-cies is much smaller than the amount of projective dependencies, so a parser can perform projective parsing for most cases and perform non-projective parsing only when it is needed. One other advan-tage of the transition-based approach is that it can use parse history as features to make the next pre-diction. This parse information helps to improve parsing accuracy without hurting parsing complex-ity (Nivre, 2006). Most current transition-based ap-proaches use gold-standard parses as features dur-ing training; however, this is not necessarily what parsers encounter during decoding. Thus, it is desir-able to minimize the gap between gold-standard and automatic parses for the best results.

This paper improves the engineering of different aspects of transition-based, non-projective depen-dency parsing. To reduce the search space, we add a transition to an existing non-projective parsing algo-rithm. To narrow down the discrepancies between gold-standard and automatic parses, we present a bootstrapping technique. The new addition to the algorithm shows a clear advantage in parsing speed. The bootstrapping technique gives a significant im-provement to parsing accuracy. Our algorithm is based on Choi-Nicolov X  X  approach to Nivre X  X  list-based algorithm (Nivre, 2008). The main difference between these two approaches is in their implementation of the S HIFT transition. Choi-Nicolov X  X  approach divides the S HIFT transition into two, deterministic and non-deterministic S HIFT  X  X , and trains the non-deterministic S HIFT with a classi-fier so it can be predicted during decoding. Choi and Nicolov (2009) showed that this implementation re-duces the parsing complexity from O ( n 2 ) to linear time in practice (a worst-case complexity is O ( n 2 ) ).
We suggest another transition-based parsing ap-proach that reduces the search space even more. The idea is to merge transitions in Choi-Nicolov X  X  non-projective algorithm with transitions in Nivre X  X  projective algorithm (Nivre, 2003). Nivre X  X  projec-tive algorithm has a worst-case complexity of O ( n ) , which is faster than any non-projective parsing al-gorithm. Since the number of non-projective depen-dencies is much smaller than the number of projec-tive dependencies (Nivre and Nilsson, 2005), it is not efficient to perform non-projective parsing for all cases. Ideally, it is better to perform projective parsing for most cases and perform non-projective parsing only when it is needed. In this algorithm, we add another transition to Choi-Nicolov X  X  approach, L EFT -P OP , similar to the L EFT -A RC transition in Nivre X  X  projective algorithm. By adding this tran-sition, an oracle can now choose either projective or non-projective parsing depending on parsing states. 1 Note that Nivre (2009) has a similar idea of per-forming projective and non-projective parsing selec-tively. That algorithm uses a S WAP transition to reorder tokens related to non-projective dependen-cies, and runs in linear time in practice (a worst-case complexity is still O ( n 2 ) ). Our algorithm is distin-guished in that it does not require such reordering. Table 1 shows transitions used in our algorithm. All parsing states are represented as tuples (  X  1 ,  X  2 ,  X  , E ), where  X  1 ,  X  2 , and  X  are lists of word tokens. E is a set of labeled edges representing previously identified dependencies. L is a dependency label and i , j , k represent indices of their corresponding word tokens. The initial state is ([0], [ ], [1,. . . , n ],  X  ). The 0 identifier corresponds to an initial token, w 0 , intro-duced as the root of the sentence. The final state is (  X  1 ,  X  2 , [ ], E ), i.e., the algorithm terminates when all tokens in  X  are consumed.

The algorithm uses five kinds of transitions. All transitions are performed by comparing the last to-ken in  X  1 , w i , and the first token in  X  , w j . Both L
EFT -P OP L and L EFT -A RC L are performed when w j is the head of w i with a dependency relation L . The difference is that L EFT -P OP removes w i from  X  1 after the transition, assuming that the token is no longer needed in later parsing states, whereas L EFT -A
RC keeps the token so it can be the head of some token w j&lt;k  X  n in  X  . This w i  X  w k relation causes a non-projective dependency. R IGHT -A RC L is per-formed when w i is the head of w j with a dependency relation L . S HIFT is performed when  X  1 is empty (
DT ) or there is no token in  X  1 that is either the head or a dependent of w j ( NT ). N O -A RC is there to move tokens around so each token in  X  can be compared to all (or some) tokens prior to it. my 4 interest 5 to 6 Root 0 see 7 you 8 During training, the algorithm checks for the pre-conditions of all transitions and generates training instances with corresponding labels. During decod-ing, the oracle decides which transition to perform based on the parsing states. With the addition of L
EFT -P OP , the oracle can choose either projective or non-projective parsing by selecting L EFT -P OP or L
EFT -A RC , respectively. Our experiments show that this additional transition improves both parsing ac-curacy and speed. The advantage derives from im-proving the efficiency of the choice mechanism; it is now simply a transition choice and requires no addi-tional processing. Transition-based parsing has the advantage of using parse history as features to make the next prediction. In our algorithm, when w i and w j are compared, subtree and head information of these tokens is par-tially provided by previous parsing states. Graph-based parsing can also take advantage of using parse information. This is done by performing  X  X igher-order parsing X , which is shown to improve parsing accuracy but also increase parsing complexity (Car-reras, 2007; Koo and Collins, 2010). 2 Transition-based parsing is attractive because it can use parse information without increasing complexity (Nivre, 2006). The qualification is that parse information provided by gold-standard trees during training is not necessarily the same kind of information pro-vided by automatically parsed trees during decod-ing. This can confuse a statistical model trained only on the gold-standard trees.

To reduce the gap between gold-standard and au-tomatic parses, we use bootstrapping on automatic parses. First, we train a statistical model using gold-standard trees. Then, we parse the training data us-ing the statistical model. During parsing, we ex-tract features for each parsing state, consisting of automatic parse information, and generate a train-ing instance by joining the features with the gold-standard label. The gold-standard label is achieved by comparing the dependency relation between w i and w j in the gold-standard tree. When the parsing is done, we train a different model using the training instances induced by the previous model. We repeat the procedure until a stopping criteria is met.
The stopping criteria is determined by performing cross-validation. For each stage, we perform cross-validation to check if the average parsing accuracy on the current cross-validation set is higher than the one from the previous stage. We stop the procedure when the parsing accuracy on cross-validation sets starts decreasing. Our experiments show that this simple bootstrapping technique gives a significant improvement to parsing accuracy. Daum  X  e et al. (2009) presented an algorithm, called S
EARN , for integrating search and learning to solve complex structured prediction problems. Our boot-strapping technique can be viewed as a simplified version of S EARN . During training, S EARN itera-tively creates a set of new cost-sensitive examples using a known policy. In our case, the new examples are instances containing automatic parses induced by the previous model. Our technique is simpli-fied because the new examples are not cost-sensitive. Furthermore, S EARN interpolates the current policy with the previous policy whereas we do not per-form such interpolation. During decoding, S EARN generates a sequence of decisions and makes a fi-nal prediction. In our case, the decisions are pre-dicted dependency relations and the final prediction is a dependency tree. S EARN has been successfully adapted to several NLP tasks such as named entity recognition, syntactic chunking, and POS tagging. To the best of our knowledge, this is the first time that this idea has been applied to transition-based parsing and shown promising results.

Zhang and Clark (2008) suggested a transition-based projective parsing algorithm that keeps B dif-ferent sequences of parsing states and chooses the one with the best score. They use beam search and show a worst-case parsing complexity of O ( n ) given a fixed beam size. Similarly to ours, their learn-ing mechanism using the structured perceptron al-gorithm involves training on automatically derived parsing states that closely resemble potential states encountered during decoding. 5.1 Corpora and learning algorithm All models are trained and tested on English and Czech data using automatic lemmas, POS tags, and feats, as distributed by the CoNLL X 09 shared task (Haji  X  c et al., 2009). We use Liblinear L2-L1 S
VM for learning (L2 regularization, L1 loss; Hsieh et al. (2008)). For our experiments, we use the fol-lowing learning parameters: c = 0 . 1 (cost), e = 0 . 1 (termination criterion), B = 0 (bias). 5.2 Accuracy comparisons First, we evaluate the impact of the L EFT -P OP tran-sition we add to Choi-Nicolov X  X  approach. To make a fair comparison, we implemented both approaches and built models using the exact same feature set. The  X  X N X  and  X  X ur X  rows in Table 3 show accuracies achieved by Choi-Nicolov X  X  and our approaches, re-spectively. Our approach shows higher accuracies for all categories. Next, we evaluate the impact of our bootstrapping technique. The  X  X ur+ X  row shows accuracies achieved by our algorithm using the boot-strapping technique. The improvement from  X  X ur X  to  X  X ur+ X  is statistically significant for all categories (McNemar, p &lt; . 0001 ). The improvment is even more significant in a language like Czech for which parsers generally perform more poorly.
 Finally, we compare our work against other state-of-the-art systems. For the CoNLL X 09 shared task, Ges-mundo et al. (2009) introduced the best transition-based system using synchronous syntactic-semantic parsing ( X  X erlo X ), and Bohnet (2009) introduced the best graph-based system using a maximum span-ning tree algorithm ( X  X ohnet X ). Our approach shows quite comparable results with these systems. 3 5.3 Speed comparisons Figure 1 shows average parsing speeds for each sentence group in both English and Czech eval-uation sets (Table 4).  X  X ivre X  is Nivre X  X  swap algorithm (Nivre, 2009), of which we use the implementation from MaltParser ( maltparser. org ). The other approaches are implemented in our open source project, called ClearParser ( code. google.com/p/clearparser ). Note that fea-tures used in MaltParser have not been optimized for these evaluation sets. All experiments are tested on an Intel Xeon 2.57GHz machine. For general-ization, we run five trials for each parser, cut off the top and bottom speeds, and average the middle three. The loading times for machine learning mod-els are excluded because they are independent from the parsing algorithms. The average parsing speeds are 2.86, 2.69, and 2.29 (in milliseconds) for Nivre, CN, and Our+ , respectively. Our approach shows linear growth all along, even for the sentence groups where some approaches start showing curves. We also measured average parsing speeds for  X  X ur X , which showed a very similar growth to  X  X ur+ X . The average parsing speed of  X  X ur X  was 2.20 ms ; it per-formed slightly faster than  X  X ur+ X  because it skipped more nodes by performing more non-deterministic S
HIFT  X  X , which may or may not have been correct decisions for the corresponding parsing states.
It is worth mentioning that the curve shown by  X  X ivre X  might be caused by implementation details regarding feature extraction, which we included as part of parsing. To abstract away from these im-plementation details and focus purely on the algo-rithms, we would need to compare the actual num-ber of transitions performed by each parser, which will be explored in future work. We present two ways of improving transition-based, non-projective dependency parsing. The additional transition gives improvements to both parsing speed and accuracy, showing a linear time parsing speed with respect to sentence length. The bootstrapping technique gives a significant improvement to parsing accuracy, showing near state-of-the-art performance with respect to other parsing approaches. In the fu-ture, we will test the robustness of these approaches in more languages.

