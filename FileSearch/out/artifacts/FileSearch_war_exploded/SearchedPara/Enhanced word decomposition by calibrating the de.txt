 Words are often considered as the smallest unit of a language when examining the grammatical structure or the meaning of sentences, referred to as syntax and semantics, however, words them-selves possess an internal structure denominated by the term word morphology . It is worthwhile studying this internal structure since a language description using its morphological formation is more compact and complete than listing all pos-sible words. This study is called morpholog-ical analysis . According to Goldsmith (2009) four tasks are assigned to morphological analy-sis: word decomposition into morphemes, build-ing morpheme dictionaries , defining morphosyn-tactical rules which state how morphemes can be combined to valid words and defining mor-phophonological rules that specify phonological changes morphemes undergo when they are com-bined to words. Results of morphological analy-sis are applied in speech synthesis (Sproat, 1996) and recognition (Hirsimaki et al., 2006), machine translation (Amtrup, 2003) and information re-trieval (Kettunen, 2009). 1.1 Background In the past years, there has been a lot of inter-est and activity in the development of algorithms for morphological analysis. All these approaches have in common that they build a morphologi-cal model which is then applied to analyse words. Models are constructed using rule-based meth-ods (Mooney and Califf, 1996; Muggleton and Bain, 1999), connectionist methods (Rumelhart and McClelland, 1986; Gasser, 1994) or statisti-cal or probabilistic methods (Harris, 1955; Hafer and Weiss, 1974). Another way of classifying ap-proaches is based on the learning aspect during the construction of the morphological model. If the data for training the model has the same struc-ture as the desired output of the morphological analysis, in other words, if a morphological model is learnt from labelled data, the algorithm is clas-sified under supervised learning . An example for a supervised algorithm is given by Oflazer et al. (2001). If the input data has no information to-wards the desired output of the analysis, the algo-rithm uses unsupervised learning . Unsupervised algorithms for morphological analysis are Lin-guistica (Goldsmith, 2001), Morfessor (Creutz, 2006) and Paramor (Monson, 2008). Minimally or semi-supervised algorithms are provided with par-tial information during the learning process. This has been done, for instance, by Shalonova et al. (2009) who provided stems in addition to a word list in order to find multiple pre-and suffixes. A comparison of different levels of supervision for morphology learning on Zulu has been carried out by Spiegler et al. (2008).
 Our two algorithms, P ROMODES and P
ROMODES -H, perform word decomposi-tion and are based on probabilistic methods by incorporating a probabilistic generative model. 1 Their parameters can be estimated from either labelled data, using maximum like-lihood estimates, or from unlabelled data by expectation maximization 2 which makes them either supervised or unsupervised algorithms.
The purpose of this paper is an analysis of the underlying probabilistic models and the types of errors committed by each one. Furthermore, it is investigated how the decision threshold can be cal-ibrated and a model ensemble is tested.

The remainder is structured as follows. In Sec-tion 2 we introduce the probabilistic generative process and show in Sections 2.1 and 2.2 how we incorporate this process in P ROMODES and P
ROMODES -H. We start our experiments with ex-amining the learning behaviour of the algorithms in 3.1. Subsequently, we perform a position-wise comparison of predictions in 3.2, show how we find a better decision threshold for placing mor-pheme boundaries in 3.3 and combine both algo-rithms using a model ensemble to leverage indi-vidual strengths in 3.4. In 3.5 we examine how the single algorithms contribute to the result of the ensemble. In Section 4 we will compare our ap-proaches to related work and in Section 5 we will draw our conclusions. Intuitively, we could say that our models describe the process of word generation from the left to the right by alternately using two dice, the first for de-ciding whether to place a morpheme boundary in the current word position and the second to get a corresponding letter transition. We are trying to reverse this process in order to find the underlying sequence of tosses which determine the morpheme boundaries. We are applying the notion of a prob-abilistic generative process consisting of words as observed variables X and their hidden segmenta-tion as latent variables Y . If a generative model is fully parameterised it can be reversed to find the underlying word decomposition by forming the conditional probability distribution Pr ( Y | X ) .
Let us first define the model-independent com-ponents. A given word w j  X  W with 1  X  j  X | W | consists of n letters and has m = n  X  1 positions for inserting boundaries. A word X  X  segmentation is depicted as a boundary vector b j = ( b j 1 ,..., b jm ) consisting of boundary values b ji  X  X  0 , 1 } with 1  X  i  X  m which disclose whether or not a bound-ary is placed in position i . A letter l j , i -1 precedes the position i in w j and a letter l ji follows it. Both letters l j , i -1 and l ji are part of an alphabet. Fur-thermore, we introduce a letter transition t ji which P
ROMODES is based on a zero-order model for boundaries b ji and on a first-order model for letter transitions t ji . It describes a word X  X  segmentation by its morpheme boundaries and resulting letter transitions within morphemes. A boundary vector b j is found by evaluating each position i with
The first component of the equation above is the probability distribution over non-/boundaries Pr ( b ji ) . We assume that a boundary in i is in-serted independently from other boundaries (zero-order) and the graphemic representation of the word, however, is conditioned on the length of the word m j which means that the probability distribution is in fact Pr ( b ji | m j ) . We guarantee  X  r = 0 Pr ( b ji = r | m j ) = 1. To simplify the notation in later explanations, we will refer to Pr ( b ji | m j ) as Pr ( b ji ) .

The second component is the letter transition probability distribution Pr ( t ji | b ji ) . We suppose a first-order Markov chain consisting of transitions t ji from letter l j , i -1  X  A B to letter l ji  X  A where A is a regular letter alphabet and A B = A  X  X  B } in-cludes B as an abstract morpheme start symbol which can occur in l j , i -1 . For instance, the suf-fix  X  s  X  of the verb form gets , marking 3 rd person singular , would be modelled as B  X  s whereas a morpheme internal transition could be g  X  e . We guarantee  X  l sition from a certain l j , i  X  1  X  A B to l ji . The ad-vantage of the model is that instead of evaluating an exponential number of possible segmentations (2 m ), the best segmentation b  X  found with 2 m position-wise evaluations using
The simplifying assumptions made, however, reduce the expressive power of the model by not allowing any dependencies on preceding bound-aries or letters. This can lead to over-segmentation and therefore influences the performance of P RO -MODES . For this reason, we have extended the model which led to P ROMODES -H, a higher-order probabilistic model. In contrast to the original P ROMODES model, we also consider the boundary value b j , i -1 and mod-ify our transition assumptions for P ROMODES -H in such a way that the new algorithm applies a first-order boundary model and a second-order transition model. A transition t ji is now defined as a transition from an abstract symbol in l j , i -1  X  {
N , B } to a letter in l bol is N or B depending on whether b ji is 0 or 1. This holds equivalently for letter transitions t j , i -1 The suffix of our previous example gets would be modelled N  X  t  X  B  X  s .

Our boundary vector b j is then constructed from The first component, the probability distribution  X  As for P ROMODES , Pr ( b ji | b j , i -1 ) is short-hand for Pr ( b ji | b j , i -1 , m j ) . The second component, the letter transition proba-bility distribution Pr ( t ji | b ji , b j , i -1 ) , fulfils  X  a transition from a certain l j , i  X  1  X  A B to l ji . Once again, we find the word X  X  best segmentation b  X  j in 2 m evaluations with b ji = arg max  X   X   X   X   X  1, if Pr ( b ji = 1 | b j , i -1 ) Pr ( t ji | b ji = 1 , t 0, otherwise .
 We will show in the experimental results that in-creasing the memory of the algorithm by looking at b j , i  X  1 leads to a better performance. In the Morpho Challenge 2009, P ROMODES achieved competitive results on Finnish, Turkish, English and German  X  and scored highest on non-vowelized and vowelized Arabic compared to 9 other algorithms (Kurimo et al., 2009). For the experiments described below, we chose the South African language Zulu since our research work mainly aims at creating morphological resources for under-resourced indigenous languages. Zulu is an agglutinative language with a complex mor-phology where multiple prefixes and suffixes con-tribute to a word X  X  meaning. Nevertheless, it seems that segment boundaries are more likely in certain word positions. The P ROMODES family harnesses this characteristic in combination with describing morphemes by letter transitions. From the Ukwabelana corpus (Spiegler et al., 2010b) we sampled 2500 Zulu words with a single segmenta-tion each. 3.1 Learning with increasing experience In our first experiment we applied 10-fold cross-validation on datasets ranging from 500 to 2500 words with the goal of measuring how the learning improves with increasing experience in terms of training set size. We want to remind the reader that our two algorithms are aimed at small datasets.
We randomly split each dataset into 10 subsets where each subset was a test set and the corre-sponding 9 remaining sets were merged to a train-ing set. We kept the labels of the training set to determine model parameters through maximum likelihood estimates and applied each model to the test set from which we had removed the an-swer keys. We compared results on the test set against the ground truth by counting true positive (TP), false positive (FP), true negative (TN) and false negative (FN) morpheme boundary predic-tions. Counts were summarised using precision 3 , recall 4 and f-measure 5 , as shown in Table 1.
For P ROMODES we can see in Table 1a that the precision increases slightly from 0 . 7127 to 0 . 7557 whereas the recall decreases from 0 . 3500 to 0 . 3045 going from dataset size 500 to 2500. This suggests that to some extent fewer morpheme boundaries are discovered but the ones which are found are more likely to be correct. We believe that this effect is caused by the limited memory of the model which uses order zero for the occur-rence of a boundary and order one for letter tran-sitions. It seems that the model gets quickly sat-urated in terms of incorporating new information and therefore precision and recall do not drasti-cally change for increasing dataset sizes. In Ta-ble 1b we show results for P ROMODES -H. Across the datasets precision stays comparatively con-stant around a mean of 0 . 6949 whereas the recall increases from 0 . 4938 to 0 . 5396. Compared to P
ROMODES we observe an increase in recall be-tween 0 . 1438 and 0 . 2351 at a cost of a decrease in precision between 0 . 0144 and 0 . 0616.

Since both algorithms show different behaviour with increasing experience and P ROMODES -H yields a higher f-measure across all datasets, we will investigate in the next experiments how these differences manifest themselves at the boundary level. Figure 1: Contingency table for P ROMODES [grey with subscript P ] and P ROMODES -H [black with subscript PH ] results including gross and net changes of P ROMODES -H. 3.2 Position-wise comparison of algorithmic In the second experiment, we investigated which aspects of P ROMODES -H in comparison to P RO -MODES led to the above described differences in performance. For this reason we broke down the summary measures of precision and recall into their original components: true/false positive (TP/FP) and negative (TN/FN) counts presented in the 2  X  2 contingency table of Figure 1. For gen-eral evidence, we averaged across all experiments using relative frequencies. Note that the relative frequencies of positives (TP + FN) and negatives (TN + FP) each sum to one.

The goal was to find out how predictions in each word position changed when applying P
ROMODES -H instead of P ROMODES . This would show where the algorithms agree and where they disagree. P ROMODES classifies non-boundaries in 0 . 9472 of the times correctly as TN and in 0 . 0528 of the times falsely as boundaries (FP). The algorithm correctly labels 0 . 3045 of the positions as boundaries (TP) and 0 . 6955 falsely as non-boundaries (FN). We can see that P ROMODES follows a rather conservative approach.

When applying P ROMODES -H, the majority of the FP X  X  are turned into non-boundaries, how-ever, a slightly higher number of previously cor-rectly labelled non-boundaries are turned into false boundaries. The net change is a 0 . 0486 in-crease in FP X  X  which is the reason for the decrease in precision. On the other side, more false non-boundaries (FN) are turned into boundaries than in the opposite direction with a net increase of 0 . 0819 of correct boundaries which led to the in-creased recall. Since the deduction of precision is less than the increase of recall, a better over-all performance of P ROMODES -H is achieved.

In summary, P ROMODES predicts more accu-rately non-boundaries whereas P ROMODES -H is better at finding morpheme boundaries. So far we have based our decision for placing a boundary in a certain word position on Equation 2 and 4 as-suming that P ( b ji =1 | ... ) &gt; P ( b ji =0 | ... ) 6 best result. However, if the underlying distribu-tion for boundaries given the evidence is skewed, it might be possible to improve results by introduc-ing a certain decision threshold for inserting mor-pheme boundaries. We will put this idea to the test in the following section. 3.3 Calibration of the decision threshold For the third experiment we slightly changed our experimental setup. Instead of dividing datasets during 10-fold cross-validation into training and test subsets with the ratio of 9:1 we randomly split the data into training, validation and test sets with the ratio of 8:1:1. We then run our experiments and measured contingency table counts.
 Rather than placing a boundary if P ( b ji =1 | ... ) &gt; P ( b ji =0 | ... ) which corresponds to P ( b ji =1 | ... ) &gt; 0 . 50 we introduced a decision threshold P ( b ji =1 | ... ) &gt; h with 0  X  h  X  1. This is based on the assumption that the underlying distribution P ( b ji | ... ) might be skewed and an optimal decision can be achieved at a different threshold. The optimal threshold was sought on the validation set and evaluated on the test set. An overview over the validation and test results is given in Table 2. We want to point out that the threshold which yields the best f-measure result on the validation set returns almost the same result on the separate test set for both algorithms which suggests the existence of a general optimal threshold.

Since this experiment provided us with a set of data points where the recall varied monotonically with the threshold and the precision changed ac-cordingly, we reverted to precision-recall curves (PR curves) from machine learning. Following Davis and Goadrich (2006) the algorithmic perfor-mance can be analysed more informatively using these kinds of curves. The PR curve is plotted with recall on the x -axis and precision on the y -axis for increasing thresholds h . The PR curves for P RO -MODES and P ROMODES -H are shown in Figure 2 on the validation set from which we learnt our optimal thresholds h  X  . Points were connected for readability only  X  points on the PR curve cannot be interpolated linearly.

In addition to the PR curves, we plotted isomet-rics for corresponding f-measure values which are perboles. For increasing f-measure values the iso-metrics are moving further to the top-right corner of the plot. For a threshold of h = 0 . 50 (marked by  X  3  X ) P ROMODES -H has a better performance than P ROMODES . Nevertheless, across the entire PR curve none of the algorithms dominates. One curve would dominate another if all data points of the dominated curve were beneath or equal to the dominating one. P ROMODES has its opti-mal threshold at h  X  = 0 . 36 and P ROMODES -H at h  X  = 0 . 37 where P ROMODES has a slightly higher f-measure than P ROMODES -H. The points of op-timal f-measure performance are marked with  X  4  X  on the PR curve.
 Table 2: P ROMODES and P ROMODES -H on vali-dation and test set.

Summarizing, we have shown that both algo-rithms commit different errors at the word posi-tion level whereas P ROMODES is better in pre-dicting non-boundaries and P ROMODES -H gives better results for morpheme boundaries at the de-fault threshold of h = 0 . 50. In this section, we demonstrated that across different decision thresh-olds h for P ( b ji =1 | ... ) &gt; h none of algorithms dominates the other one, and at the optimal thresh-old P ROMODES achieves a slightly higher perfor-mance than P ROMODES -H. The question which arises is whether we can combine P ROMODES and P
ROMODES -H in an ensemble that leverages indi-vidual strengths of both. 3.4 A model ensemble to leverage individual A model ensemble is a set of individually trained classifiers whose predictions are combined when classifying new instances (Opitz and Maclin, 1999). The idea is that by combining P ROMODES and P ROMODES -H, we would be able to avoid cer-tain errors each model commits by consulting the other model as well. We introduce P ROMODES -E as the ensemble of P ROMODES and P ROMODES -H. P ROMODES -E accesses the individual proba-bilities Pr ( b ji = 1 | ... ) and simply averages them:
Pr ( b ji =1 | t ji )+ Pr ( b ji =1 | t ji , b j , i -1 , t
As before, we used the default threshold h = 0 . 50 and found the calibrated threshold h  X  = 0 . 38, marked with  X  3  X  and  X  4  X  in Figure 2 and shown in Table 3. The calibrated threshold improves the f-measure over both P ROMODES and P Table 3: P ROMODES -E on validation and test set.
The optimal solution applying h  X  = 0 . 38 is more balanced between precision and recall and boosted the original result by 0 . 1185 on the test set. Compared to its components P ROMODES and P
ROMODES -H the f-measure increased by 0 . 0228 and 0 . 0353 on the test set.
 In short, we have shown that by combining P
ROMODES and P ROMODES -H and finding the optimal threshold, the ensemble P ROMODES -E gives better results than the individual models themselves and therefore manages to leverage the individual strengths of both to a certain extend. However, can we pinpoint the exact contribution of each individual algorithm to the improved re-sult? We try to find an answer to this question in the analysis of the subsequent section. 3.5 Analysis of calibrated algorithms and For the entire dataset of 2500 words, we have examined boundary predictions dependent on the relative word position. In Figure 3 and 4 we have plotted the absolute counts of correct boundaries (TP) and non-boundaries (TN) which P ROMODES predicted but not P ROMODES -H, and vice versa, as continuous lines. We furthermore provided the number of individual predictions which were ulti-mately adopted by P ROMODES -E in the ensemble as dashed lines.

In Figure 3a we can see for the default thresh-old that P ROMODES performs better in predicting non-boundaries in the middle and the end of the word in comparison to P ROMODES -H. Figure 3b shows the statistics for correctly predicted bound-aries. Here, P ROMODES -H outperforms P RO -MODES in predicting correct boundaries across the entire word length. After the calibration, shown in Figure 4a, P ROMODES -H improves the correct prediction of non-boundaries at the beginning of the word whereas P ROMODES performs better at the end . For the boundary prediction in Figure 4b the signal disappears after calibration.
 Concluding, it appears that our test language Zulu has certain features which are modelled best with either a lower or higher-order model. There-fore, the ensemble leveraged strengths of both al-gorithms which led to a better overall performance with a calibrated threshold. We have presented two probabilistic genera-tive models for word decomposition, P ROMODES and P ROMODES -H. Another generative model for morphological analysis has been described by Snover and Brent (2001) and Snover et al. (2002), however, they were interested in finding paradigms as sets of mutual exclusive operations on a word form whereas we are describing a gener-ative process using morpheme boundaries and re-sulting letter transitions.

Moreover, our probabilistic models seem to re-semble Hidden Markov Models (HMMs) by hav-ing certain states and transitions. The main differ-ence is that we have dependencies between states as well as between emissions whereas in HMMs emissions only depend on the underlying state.
Combining different morphological analysers has been performed, for example, by Atwell and Roberts (2006) and Spiegler et al. (2009). Their approaches, though, used majority vote to decide whether a morpheme boundary is inserted in a cer-tain word position or not. The algorithms them-selves were treated as black-boxes .

Monson et al. (2009) described an indirect approach to probabilistically combine ParaMor (Monson, 2008) and Morfessor (Creutz, 2006). They used a natural language tagger which was trained on the output of ParaMor and Morfes-sor. The goal was to mimic each algorithm since ParaMor is rule-based and there is no access to Morfessor X  X  internally used probabilities. The tag-ger would then return a probability for starting a new morpheme in a certain position based on the original algorithm. These probabilities in com-bination with a threshold, learnt on a different dataset, were used to merge word analyses. In contrast, our ensemble algorithm P ROMODES -E directly accesses the probabilistic framework of each algorithm and combines them based on an optimal threshold learnt on a validation set. We have presented a method to learn a cali-brated decision threshold from a validation set and demonstrated that ensemble methods in connec-tion with calibrated decision thresholds can give better results than the individual models them-selves. We introduced two algorithms for word de-composition which are based on generative prob-abilistic models. The models consider segment boundaries as hidden variables and include prob-abilities for letter transitions within segments. P ROMODES contains a lower order model whereas P ROMODES -H is a novel development of P RO -MODES with a higher order model. For both algorithms, we defined the mathematical model and performed experiments on language data of the morphologically complex language Zulu . We compared the performance on increasing train-ing set sizes and analysed for each word position whether their boundary prediction agreed or dis-agreed. We found out that P ROMODES was bet-ter in predicting non-boundaries and P ROMODES -H gave better results for morpheme boundaries at a default decision threshold. At an optimal de-cision threshold, however, both yielded a simi-lar f-measure result. We then performed a fur-ther analysis based on relative word positions and found out that the calibrated P ROMODES -H pre-dicted non-boundaries better for initial word posi-tions whereas the calibrated P ROMODES for mid-and final word positions. For boundaries, the cali-brated algorithms had a similar behaviour. Subse-quently, we showed that a model ensemble of both algorithms in conjunction with finding an optimal threshold exceeded the performance of the single algorithms at their individually optimal threshold. We would like to thank Narayanan Edakunni and Bruno Gol  X  enia for discussions concerning this pa-per as well as the anonymous reviewers for their comments. The research described was sponsored by EPSRC grant EP/E010857/1 Learning the mor-phology of complex synthetic languages .
