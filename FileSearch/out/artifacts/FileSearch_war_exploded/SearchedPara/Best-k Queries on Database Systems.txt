 H.2.1 [ Database Management ]: Logical Design Theory, Algorithms
When database applications involve exploratory queries and im-precise database information such as multimedia and text databases, it is necessary to study how to assist a user in expressing a query with various kinds of preferences [1]. A major line of work in this direction is the top-k queries. However, a major limitation of top-k queries is that the k tuples are selected based on a ranking of tuples according to scores that are computed for each tuple in-dependently . This limitation makes top-k queries inadequate for expressing more complex selection preferences which may involve some global measure defined on multiple tuples. One such mea-sure is semantic redundancy or novelty [3]; it is clearly impossible to use a top-k query to express a user X  X  desire for minimizing the redundancy among the returned results (by whatever redundancy measure appropriate for the application).

In this poster, we generalize the top-k queries to best-k queries to accommodate expression of complex selection preferences that may involve global measures. We propose a decision-theoretic framework to model database search in a general way. In this framework, we assume that a database system would respond to a database query by selecting a subset of tuples that optimize a cer-tain utility function defined on the tuples. We show that such an optimization framework covers the boolean query search, the top-k query search, and the best-k query search all as special cases, cor-responding to differen t utility functions . Moreover, we show that the best-k queries can be regarded as a natural generalization of the top-k queries by allowing a user to specify an arbitrary utility func-tion. The framework provides a roadmap for exploring complex database queries with different levels of complexity.

Due to the space limit, we only present high level concepts in the rest of this poster and leave all details and proofs in [2].
Without loss of generality, we represent a database abstractly as a single table, which, in reality, can be a view generated from several different tables or even one computed on the fly. Formally, we define our data set as D = { d 1 , ..., d n } , and each tuple d an m degree vector representing its m attribute values. Let T = { t 1 , ..., t | T | } X  D be any subset of D and Q be any user query.
We define the query-based utility function U : T  X  Q  X  R +  X  { 0 } , which maps any subset of data tuples T and the query Q to a non-negative real (utility) value . According to the decision theory, the optimal choice of a subset is the one that maximizes its utility function value. We thus can define a best-k query generally as a decision problem: A best-k query is to find the best tuple set T which maximizes the user utility function U . Formally, Equation 1 provides a unified decision-theoretic view of database queries. It is easy to show that Both boolean queries and top-k queries can be modeled in this way with appropriate utility func-tions. Indeed, it is easy to prove the following propositions [2]. Proposition 1 A Boolean query Q returns the same results as the best-k query with the following utility function: where where  X  ( t i ,Q ) is an indicator function defined as follows: Proposition 2 A top-k query Q with a preference function r : T R +  X  X  0 } returns the same results as the best-k query with the following utility function where  X  ( T,Q ) is an indicator function that takes the value 1 if T satisfies the constraint specified in Q and 0 otherwise. Note that we ignore the ranking of the top-k results, which is mostly a way of presenting results.

In general, the value of U ( T, Q ) indicates the usefulness of re-turning the subset T in response to the query Q from the user X  X  perspective. When judging the usefulness of selected tuples, one would generally consider multiple factors and have some prefer-ence function for each of them. The total utility of T is thus a combination (or more precisely often a tradeoff) of all these fac-tors. To model these intuitions formally, we first define the space of user preference functions,  X  , as the set of all the s preference functions that a user may be interested in, i.e.,  X = {  X  1 A function  X   X   X  measures the utility of T on some utility aspect and gives a mapping from T to a preference value in R +  X  X  a larger preference value indicating a better utility. Thus the utility function can now be written as where u is a composition function to combine all preference func-tion together.

We now take a further look at the individual preference functions  X   X  X . Intuitively, the total preference value of all the tuples in T is some aggregation of the values of individual tuples. The simplest case is when the aggregated value is just a sum of the values of each individual tuple. where m ( t i ,Q )  X  R +  X  X  0 } is a measure function defined on an individual tuple, which we refer to as a 1st-degree measure func-tion .

While many preference functions can be decomposed as a simple summation, there are cases when we need to consider the interac-tions of the individual tuples when aggregating their values. For instance, the redundancy among a set of selected text documents must be defined based on some of their interactions. One possibil-ity is the following definition, which involves a 2nd-degree measure function m ( t i , t j ,Q ) . where m ( t i , t j ,Q )  X  R +  X  X  0 } is a measure function defined on a pair of individual tuples.

An attribute that normally can be captured through a first-degree measure function may need higher-degree functions in special cases. Consider the price attribute of a book. When a user wants to find a set of books with a total price no more than $100, a first-degree measure function would be sufficient. However, if a discount can be obtained when buying multip le books together, we may need higher-degree measure functions.

Clearly, higher-degree measure functions can be incorporated similarly.
In general, a utility function for database selection may involve a combination of multiple prefer ence functions corresponding to different aspects of utility. While each preference function alone can usually uniquely suggest an optimal subset, we will have to impose some trade-off between different preference aspects when we combine multiple preference functions. A simple strategy that a user often follows in resolving potential conflicts between different utility aspects is to c hoose one single prima ry utility as pect to op-timize and impose some thresholds for all other ( seconda ry) utility aspects. We refer to the preference function for the primary utility aspect as the primary preference function and all other secondary preference functions constraint preference functions . In general, a constraint preference function simply imposes a constraint on the selected tuples X , so it is an indicator function whose value is 1 when X satisfies the constraint and 0 otherwise. A typical form of such a function is  X  ( X )=  X  ( m ( X ) &gt;c ) ,where c is some constant threshold for some utility measure m ( X ) . For example,  X  ( X )=  X  ( total price of the selected tuples must be below $100.

When the utility function is a combination of a primary pref-erence function and a number of constraint preference functions, we have U ( X )= u ( X ) preference function and u ( X ) is the primary preference function that we want to maximize. Clearly, the optimal subset X chosen according to such a utility function must satisfy all the constraints as well as maximize u ( X ) .

In some case, a constraint function can be further written as a product of constraints over individual tuples:  X  i ( X )= Suppose we have l such local constraint functions,  X  i , i =1 , ..., l , and thus r  X  l = m global constraint functions, which we denote as  X  ( X )=  X  l + j , j =1 , ..., r  X  l . A best-k query to express such a utility function can be specified as follows, assuming that the user is interested in the attributes a 1 , ..., a n of the selected tuples. SELECT a 1 , ...a n FROM Table t WHERE  X  1 ( t ) , ...,  X  l ( t ) MAXIMIZE u(X) SUBJECTTO  X  1 ( X ) , ...,  X  r ( X )
When the preference functions u and  X  1 ,...,  X  m are missing, our best-k query would degenerate to a standard Boolean query. If l + 1= r (i.e., only one global constraint) and  X  1 ( X )=  X  ( and our function u ( X ) is u ( X )= would be a regular top-k query without the ranking part.
The proposed query language naturally suggests a constrained optimization approach for executing best-k queries, where all  X  ( X )( i =1 , ..., r ) functions serve as the constraint part and the u ( X ) works as an objective function. This optimization problem can be further cast as a 0-1 integer programming problem. Un-fortunately, this problem is a classic NP-hard problem. Below, we propose a strategy for answering a best-k query efficiently.
In general, a database query may involve both local and global constraints. The processing of global constraints is more complex than that of local constraints. We thus address them separately in two steps: First, we construct a working set mostly based on local constraints. Second, we obtain a best-k solution from the working set by considering the global constraints as well.

We introduce additional SELECT attributes b 1 , ..., b s to ensure  X  and  X  1 , ...,  X  m , since some of them are needed by  X   X  X  in the next step.

Once the working set is constructed, our task is to solve the best-k query by enumerating all the subsets in the working set and checking the optimality of each subset. This is usually quite expen-sive, but for monotonic preference functions, it is possible to devise efficient algorithms based on ordered set enumeration trees. This and a few other efficient algorithms are discussed in [2].
In this paper, we propose and study the best-k query, which gen-eralizes the existing top-k query by relaxing its independence as-sumption on scoring each selected tuple. We unify different types of database queries, and model the database selection problem gen-erally as a decision problem. We sketch a possible best-k query language and a possible approach to execute best-k queries. The proposed framework provides a roadmap for exploring complex database queries with different levels of complexity. [1] R. Fagin. Combining fuzzy information from multiple [2] T. Tao and C. Zhai. Best-k queries on database systems. In [3] C. Zhai, W. W. Cohen, and J. Lafferty. Beyond independent
