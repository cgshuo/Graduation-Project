 CourseRank is a course planning tool aimed at helping stu-dents at Stanford. Recommendations comprise an integral part of it. However, implementing existing recommendation methods leads to fixed recommendations that cannot adapt to each particular student X  X  changing requirements and do not help exploit the full extent of the available learning op-portunities at the university. In this paper, we describe the concept of a flexible recommendation workflow, i.e., a high-level description of a parameterized process for com-puting recommendations. The input parameters of a flexible recommendation process comprise the  X  X nobs X  that control the final output and hence generate flexible recommenda-tions. We describe how flexible recommendations can be expressed over a relational database and we present our pro-totype system that allows defining and executing different, fully-parameterized, recommendation workflows over rela-tional data. Finally, we describe a user interface in Cours-eRank that allows students customize recommendations. H.3.3 [ Information Systems ]: Information Search and Re-trieval; H.3.4 [ Information Storage and Retrieval ]: Sys-tems and Software; H.5.2 [ Information Interfaces and Representation ]: Graphical user interfaces (GUI) Design, Algorithms, Human Factors flexible recommendations, workflows, CourseRank
Recommendation systems, such as Google News [11], Ama-zon [16] and MovieLens [18], are popping up everywhere, to provide advice on movies, travel, and leisure activities. The systems help users sort through the huge amounts of available data, and receive content and services that are of interest to them. Since the appearance of the first rec-ommendation systems [12, 20, 22], many approaches have been proposed both by the industry and academia. How-ever, most recommendation methods perform on the ba-sis of assumptions  X  X ard-wired X  into the system and they support only a predefined and fixed set of recommendations which may not always capture the real-time user informa-tion needs [5]. Giving the end-user the ability to customize their recommendations may be very important in order to provide more accurate, personalized recommendations. For example, CourseRank is a course planning tool for Stan-ford University students that helps students choose courses. Recommendations comprise an integral part of the system. Providing only fixed recommendations does not help build personalized plans that are customized to each particular student X  X  changing requirements and exploit the full extent of the available learning opportunities the university offers.
Traditionally, university students base their schedules on word-of-mouth knowledge and the brief course descriptions found in bulletins or academic guides, rather than on more comprehensive assessments. CourseRank [1], under develop-ment in Stanford X  X  Infolab, is a social tool for course plan-ning that helps students make informed choices and take advantage of the available learning options. It displays of-ficial university information and statistics, such as bulletin course descriptions, grade distributions, and results of offi-cial course evaluations. Furthermore, students can anony-mously rank courses they X  X e taken, add comments, and rank the accuracy of each others X  comments. They can also shop for classes, get personalized recommendations, and organize their classes into a quarterly schedule or devise a four year plan. CourseRank also functions as a feedback tool for fac-ulty and administrators, ensuring that information is as ac-curate as possible. Faculty can also modify or add comments to their own courses, and can see how their class compares to other classes. To support this functionality, CourseR-ank maintains a database that stores rich information, such as the courses offered, the instructors, the students, com-ments and ratings given by the students to courses and in-structors, course material, and so forth. Figure 2 provides a small snapshot of the database schema.

A little over a year after its launch, CourseRank is al-ready used by more than 6,200 Stanford students, out of a total of about 14,000 students. The vast majority of Cours-eRank users are undergraduates, and there are only about
Figure 2: Extract from CourseRank  X  X  database 7,000 undergraduates at Stanford. Thus, it is safe to say that CourseRank is already used by a very large fraction of Stanford undergraduates.

Supporting Recommendations . Existing recommen-dation approaches can be categorized on the basis of how recommendations are generated: (a) content-based methods recommend to the user items similar to the ones the user preferred in the past, and (b) collaborative filtering recom-mend to the user items that people with similar preferences liked in the past.

Following a content-based approach in CourseRank , we could consider that each course is represented by the set of topics that it covers ( Courses.Description ), and each student is represented by a list of the topics from the courses she has at-tended. When a student, say Alice, logs into the system, the system matches courses, based on their topics, to the top-ics that interest this student. The result would be a list of courses, each one with a score showing how closely the course matches Alice X  X  interests and the top courses would comprise the system X  X  recommendations. Standard functions for com-puting such scores include the cosine similarity, the Jaccard metric, and so forth. A high-level representation of this rec-ommendation process is illustrated in Figure 1(a).
Adopting a collaborative approach , we could take into ac-count the ratings students assign to courses ( Comments.Rating ). In order to recommend courses to Alice, the system will first find students that are similar to Alice, i.e., with similar rat-ings for the same courses. The output of this first step is a list of (top N) users ordered on their similarity scores. A typical function for computing user similarity is the Pearson correlation [20]. Then, these users collectively determine the ratings for the courses not taken by Alice. For example, course ratings could be computed as the weighted average of the students X  ratings for this course. Figure 1(b) illustrates this recommendation process, which has been implemented in CourseRank . Figure 3 shows a screen from CourseR-ank that displays recommendations based on this approach.
Limitations . Current recommendation methods operate on a set of fixed assumptions that shape the desired rec-ommendations but the user cannot specify or modify any of them. Below, we highlight these assumptions and give examples from CourseRank of how they may generate inac-curate or inflexible recommendations for the students.  X  The system always assumes that the target of the recom- X  The system always assumes a fixed pool of courses, from  X  In collaborative filtering, recommendations are based on  X  The system always assumes a fixed set of attributes for
Consequently, supporting recommendations following one of the classical approaches allows CourseRank to offer only fixed,  X  X anned X  recommendations that are generated on the basis of a number of assumptions hard-coded in the system. Little (if any) control is given to the users. The recommen-dations offered comprise standard advice, which cannot ac-curately capture a student X  X  evolving information needs, and they may change when there is a significant change in the information the system keeps for the users or the courses of-fered. Furthermore, traditional recommendation approaches model the world as having two types of entities, users (e.g., students) and items (e.g., courses), represented as sets of rat-ings or features. Many systems rely on richer data models. For example, CourseRank stores structured data in a rela-tional database. Providing recommendations for different entities (e.g., courses, instructors, etc) taking into consider-ation different attributes (e.g., grades, ratings, major, etc) is not straightforward. As a consequence of these limitations, although the initial version of CourseRank has been very popular with students (see editorial in the Stanford student paper [2]), we received many requests, from students and administrators, for more flexible recommendations.
In this paper, we propose flexible recommendations , i.e., recommendations that have a set of X  X nobs X  X hat can be used to specify or  X  X une X  the desired output of the recommenda-tion process, and can be dynamically defined over structured data . To illustrate, in the same sense that a system can of-fer advanced search, where users can customize their queries by combining different parameters, conditions, and entities, a system should provide advanced recommendations, where users can tweak a number of  X  X omponents X  in order to ex-plore different recommendations.
In brief, the contributions of this paper are the following:  X  We define the concept of a flexible recommendation work- X  We describe how flexible recommendations can be ex- X  We describe a preliminary user interface in CourseR-
We define a flexible recommendation workflow RW ( I, P ) as a high-level description of a process for computing recom-mendations for a set of objects I (e.g., courses, books, etc) based on a set of input parameters P . A recommendation workflow comprises a series of interconnected operators that describe how a recommendation is computed. In a workflow, sets of objects flow from one operator to the next, and are filtered, ranked, etc. in the process. The workflow is a X  X igh-level X  X escription in the sense that it does not contain actual code, but rather, it describes what code (operators) to call upon. The input parameters P of a workflow are essen-tially operator inputs that are exposed outside the workflow in order to allow one to control externally the final output of the recommendation process, and hence, generate flexible recommendations .

There are several possible types of operators that one could define and combine in a recommendation workflow. For example, one could use filters in order to exclude ob-jects, blend operators for combining sets of objects or rec-ommendations, and top-k operators that output only the top k objects based on some attribute of them. The core operator of any recommendation workflow is a recommend operator that rates the objects of a set by comparing them to the objects of another set.

Figures 1(a) and 1(b) could actually be seen as two rec-ommendation workflows, except that the inputs and param-eters are hardwired by the system. Furthermore, in classical recommendation systems there is usually no high-level de-scription; the recommendation processing is implemented in
Figure 4: Flexible recommendation workflows. low-level code that is hard to change. Below we illustrate some flexible recommendation workflows.

Example . Assume that we define two operators: (a) a filter operator  X  ( X, c ) that takes as input a set of ob-jects X and outputs only objects that meet the condition c , and (b) a recommend operator  X  ( X, Y, f, A ) that rates the objects in X by comparing them to the objects in Y on some common attribute A with the help of a function f . These operators can be combined in several ways to build different flexible recommendation workflows. Figure 4 illustrates three example workflows. The workflow de-picted in Figure 4(a) generates flexible recommendations for a set of objects I , which may be filtered based on some cri-terion c 0 , by comparing its objects with the objects of a set T on some common attribute A . Objects in T may be also filtered on some criterion. Consequently, this workflow represents a flexible content-based recommendation process with several parameters to shape the recommendations, i.e., RW cont ( I, c 0 , T, c, A, f ). By dynamically changing its in-puts, this process can provide different recommendations. For example, a student (i.e., T : students) with id  X 1432 X  ( c : id= X 1432 X ) could ask for recommendations for courses ( I : courses) on programming ( c 0 : X  X n programming X ) whose top-ics match her topics of interest ( A : topics). In similar way, she could ask for course recommendations for her friend ( c or for dance ( c ) classes ( I ). Going one step further, T could be a set of objects, such as a group of friends and function f could compute the average score for each course over all students. In this way, the system could provide recommen-dations for courses that would match the interests of a group of students that want to take a class all together.
Figure 4(b) shows a workflow that provides flexible recom-mendations for a set of objects I in a collaborative-filtering fashion. For this purpose, the objects in I are rated w.r.t. the objects of a set R , which have been already rated w.r.t. a set T . Consequently, this workflow represents a flexible rec-ommendation process RW coll ( I, c 4 , R, c 3 , B, g, c 2 Different recommendations can be obtained by changing the process inputs. For example, a student ( T ) named Alice ( c may want to see books ( I ) recommended based on the rat-ings ( B ) of students ( R ) with a CS major ( c 3 ) that match with her on course ratings ( A ). Similarly, Alice could ask for sociology ( c 4 ) courses ( I ) recommended based on the ratings ( B ) of sociology ( c 3 ) students ( R ) that have similar grades ( A ) with a friend student in this department ( c 1 ).
It is also possible to define workflows that represent new types of recommendations, which can be tested using the same infrastructure. To illustrate, Figure 4(c) shows a se-quence of interconnected recommend operators that com-pute friends-of-friends that have up to three degrees of sep-aration. The first recommend operator computes the set of similar students to an individual based on a st of attributes A (e.g., ratings, grades, GPAs, etc). We call these students  X  X riends X  of the student. The second recommend operator takes as input the  X  X riends X  found by the first recommend operator and computes  X  X riends X  of them, and so on. Conse-quently, this workflow represents a different flexible recom-mendation process RW friend ( I, c 0 , T, c, A, f ).
As illustrated in Figure 5, a flexible recommendation sys-tem contains a set of recommendation workflows, RW 1 , RW ..., RW N . These are defined by an administrator or de-signer using the set of operators that are supported by the system. At run time, users can invoke any of these work-flows (through some user interface) with the set of objects, for which recommendations are sought, and the rest of the parameters that are required by the process in order to gen-erate customized recommendations. The system then exe-cutes the process over the underlying data and returns a set of recommendations.
Since most structured data used by production systems (including CourseRank ) is stored in relational databases, it is desirable to have a workflow data model that is X  X lose X  X o a relational model. If the objects that flow between operators are relations (i.e., sets of tuples), then we can use classical relational operators like joins, selections and projections to operate on the data. Reading and storing objects would be straightforward, since we would only need to read and write relations into the database. We would need to define new operators like recommend and blend, but they would also be defined over relations.

Unfortunately, relying on a  X  X ure X  relational data model for recommendation workflows is restrictive. The problem is that information about a single entity (e.g., student, course) may be dispersed over different relations due to database structuring and normalization. For example, we may want to compare students to the current user based on their rat-ings for the courses that they have in common. In CourseR-ank , as Figure 2 shows, there is a relation Students , where Figure 6: Relation Students extended with courses. each tuple corresponds to a single student while informa-tion about the courses each student has taken is stored in a different relation, StudentHistory . A recommend operator that compares students to the current user would need to join together multiple relations, making it cumbersome to define the operator. Ideally, we would like to represent our application entities with a single  X  X xtended X  relation. For instance, a tuple in an extended relation could contain base information on a student (e.g., name, GPA), plus the set of courses a student has taken. In this way, our recommend operator would operate on attributes of entities, irrespec-tive of whether these are base attributes, such the GPA, or extended attributes, such as the sets of ratings.
On the basis of the above observations, we consider an extended relational model , that lets us represent our appli-cation entities with a single relation.

Extended relations . A relational database comprises a set of stored relations. A stored relation has a set of stored tuples described by a set of attributes. An attribute can be instantiated to a single, numerical or categorical, value. We define an extended relation , which has a set of extended tuples described by a set of stored attributes and a set of ex-tended attributes. An extended attribute is instantiated to a relation derived from another stored relation. Consequently, under our semantics, an attribute value can be scalar or a relation. Note that only stored (flat) relations can be part of a tuple, allowing only one level of nesting. We think that one level of nesting is sufficient to capture the needs of most recommendation operators, so we avoid the complexities of a full-fledged nested relational model.

Extended relations can be therefore thought of as  X  X iews X  that collect and group together information related to an individual entity and represent it as a single tuple that can be easily handled by other operators. For example, in a workflow, students may be extended with their courses, so that the set of courses for each student can be X  X iewed X  X s an additional attribute of the student by subsequent operators in the workflow irrespective of the database structure.
Extend operator . Since extended relations are not stored in the database, we define an extend operator that can be used in a recommendation workflow. This operator allows  X  X xtending X  X ach tuple from one relation with the set of join-ing tuples from a different relation. In other words, for each tuple t in the first relation, the operator creates an extended attribute. The t attribute is instantiated to a relation con-taining tuples from another relation that join with t . For example, each student can be extended with an attribute that describes the courses she has taken. Similarly, a de-partment can be extended with the courses it offers, etc. Figure 6 shows an instance of the Students relation and Figure 7: Prototype flexible recommendation engine an example of an extended relation, where the set of courses for each student is  X  X iewed X  as an additional attribute of the student. A recommend operator can now take as input this extended relation, and for each tuple generate a score indicating how well the student matches the target user (as discussed in the example of Section 2).

In the following section, we present our prototype flexible recommendation engine that allows defining and executing relational recommendation workflows.
Our goal is to build an engine for flexible recommenda-tion processing and optimization over relational databases. There are generally two options: (i) build a middleware layer, i.e., implement the processing outside the core of the database system or (ii) extend the database query engine with the processing capabilities required for flexible recom-mendations. We chose the middleware solution for porta-bility and implementation ease. Figure 7 shows the archi-tecture of our current CourseRank working system. It is implemented in Java on top of MySQL.

Workflow Manager . This component allows an admin-istrator to define different recommendation workflows and end-users (through the user interface, see Section 5) to in-voke any of the defined workflows with different inputs and receive customized recommendations. This component hides the details of how flexible recommendations are generated, such as the details of the algorithms and structures used to implement the functionality of the operators that comprise a recommendation workflow, the execution order of opera-tors, which can be different from the workflow definition in order to optimize the process, and so forth.

Operator Manager . The Operator Manager implements the operators used for defining relational recommendation workflows. It exposes the classical relational operators, i.e., selections, projections and joins, and it implements addi-tional operators: the extend operator, as described in the previous section, and the recommend and top-k operators described in Section 2. We plan to add a blend operator that will unify recommendations generated from different workflows or different instantiations of the same workflow.
The extend operator allows  X  X xtending X  in a transparent way any tuple from one relation with its set of joining tuples from a different relation. For example, students can be ex-tended with their courses. In this way, the set of courses for each student can be  X  X iewed X  as an additional attribute of the student that can be handled by the recommend operator irrespective of the database structure. Note that the extend operator does not materialize a new relation. The joins im-plied by the extended relation are only executed only when tuples are actually requested by some downstream operator.
The recommend operator comes with a library of func-tions for performing correlations (e.g., Pearson), similarity comparisons (e.g., Jaccard), and aggregations, such as the weighted average. The library is extensible, so new types of recommendations can always be supported.

Flow Execution . The Flow Execution component is re-sponsible for the execution of a recommendation workflow and it contains the code for implementing the recommend, the extend and the top-k operators. This component con-structs the SQL queries that are required in order to: (i) bring into memory tuples that need to be processed, (ii) realize the extension of tuples required by the extend oper-ator, and (iii) materialize any results that are shared in a particular recommendation workflow. The SQL queries are executed by the underlying DB engine. The Flow Execu-tion component assembles results in memory and performs any extra processing required, such as applying any library function used by a recommend operator.

In the current CourseRank version, a workflow is executed exactly as defined. We are currently working on workflow optimization, where operators can be reordered and exe-cuted using different run-time strategies (e.g., exploiting an index). Such optimization is analogous to what a query en-gine does in a traditional database system, except that now we have to handle new operators and extended relations.
There are several challenges in creating such a flexible recommendation interface. Flexible recommendations are a new concept, so a user interface that provides this customiz-ability could lead to confusion. The interface should make clear that a single workflow is active at a time, and given a particular workflow, the user should be able to set the relevant parameters and understand how recommendations can be tailored. Furthermore, supporting flexible recom-mendations may be performed through a separate  X  X dvice X  interface, but we anticipate that the integration of advice with search will reveal interesting challenges. For example, we may want to order search results in a manner consistent with the user X  X  preferences.

Taking into consideration the above, we have designed an advice panel that allows a single workflow to be active at a time, and given a particular workflow, the user can set the relevant parameters. We currently offer two recom-mendation workflows: a collaborative and a content-based workflow described below.

Overview of Current Prototype . To receive recom-mendations the user clicks a top-level (tab) link Advice . Af-ter clicking the link, the user is shown recommendations cre-ated with the collaborative recommendation workflow using some default parameter values. Along with the recommen-dations, the system presents the advice panel as shown in Figure 8. The user experience thus far is consistent with the typical user experience in most recommendation systems. The user can use the advice panel to customize the recom-mendations. In the advice panel, there is an icon of two people and explanatory text reading:
This indicates that the collaborative workflow is currently active. To switch between recommendation workflows, the user can simply click the change link. Now, the icon will display a stack of books (Figure 9). The text under this icon will also change to read: Figure 9: Panel for content-based recommendations.
In both workflows, the user can control recommendations through the advice panel, which has two sets of parame-ters: a set for  X  X ure X  recommendation operations and a set for filtering returned recommendations. The first set allows currently the user to specify for the collaborative workflow:  X  how similarity between two students should be calcu- X  how to filter the set of similar students. For example,
In the content-based workflow, the advice panel allows the user to specify:  X  how similarity between courses should be calculated: us- X  the part of the user X  X  course history that should be con-
The second set of parameters in the advice panel allows the user to filter the recommendations (generated either by the content-based or the collaborative filtering workflow) by term offered and by department.

Evolving Interface . Designing the interface is an ongo-ing operation. There are many parameters that we would like the user to be able to control in order to customize recommendations. However, we did not want to confuse the user or overwhelm him with complexity. Thus, we have only chosen a subset of the possible parameters to include in our advice panel.

As users work with the system, we will track the usage of the advice panel to see which parameters are most popular and which could be replaced by others we have been consid-ering. To improve recommendations, we need some way to measure the quality of our suggestions. A user can implic-itly indicate that a recommended course is good by adding it to her CourseRank schedule or even by simply clicking the recommending item. We save for future work exploring different evidence of recommendation quality.
Since the appearance of the first papers on collaborative filtering [12, 20, 22], a lot of work has been done from im-proving and evaluating recommendation methods [3, 14, 19, 23] to designing trustworthy recommender systems [7, 17].
Recommendation approaches are broadly classified into the following categories [6]:  X  Content-based recommendations : The user is recommended  X  Collaborative recommendations : The user is recommended  X  Hybrid approaches : These methods combine collabora-
Traditionally, recommendation systems deal with applica-tions that have two types of entities, users and items (e.g., movies, Web pages) and they recommend top N items to a user following a content-based or a collaborative filtering paradigm. For example, the content-based component of the Fab system [6], which recommends Web pages to users, represents Web page content with the 100 most important words. Similarly, the Syskill &amp; Webert system represents documents with the 128 most informative words [19]. This is a very restrictive view of the world. Many applications use much richer data with large amounts residing in databases. Different types of entities may co-exist in a single database, such as authors, books, customers, publishers, represented by rich sets of attributes. Therefore, being able to ask rec-ommendations that can dynamically incorporate different parts of a database and be targeted to different entities is very useful. However, existing methods do not allow such flexibility and they provide canned recommendations.
Furthermore, using a fixed approach to recommendations can also be restrictive, since a single approach may not be appropriate for every occasion. For example, in content-based methods, the user is limited to see items that are similar to those already rated. Methods to address this problem include the use of genetic algorithms [23] or fil-tering out items if they are too similar to those seen before [9]. On the other hand, collaborative methods, grouped in memory-based [10, 13, 20] and model-based ones [8, 15], provide serendipitous recommendations. However, collabo-rative filtering has its own problems, such as the inability to recommend new items [6]. Several recommendation sys-tems use a hybrid approach by combining collaborative and content-based methods, which helps to avoid certain limita-tions of content-based and collaborative systems [6, 8, 21]. Still, these methods may not provide a complete solution, since in many cases, different recommendations may be re-quired under different circumstances.

The inherent limitations of recommendation systems have been acknowledged [5] and some extensions have been re-cently proposed, such as incorporating multi-criteria ratings into recommendation methods. In order to give to users the ability to shape their recommendations, the language RQL has been the first proposal that allows the end-users to formulate recommendations of interest in a flexible man-ner [4]. However, RQL queries follow a data warehouse ap-proach and they are formulated on a pre-specified multi-dimensional cube of ratings. Our flexible recommendation workflows are more expressive as they can be defined over relational data using combinations of various traditional re-lational operators as well as new operators and do not as-sume any pre-specified setting or data structure, such as a cube of ratings. Entities, attributes for comparing enti-ties, attributes to be used for predicting recommendations, even the functions used in the computations may vary on demand. It is possible to dynamically define different rec-ommendation strategies that move away from the typical content-based and collaborative filtering processes of com-puting recommendations and then allow the users to shape them through a set of knobs.
In this paper, we have seen through our course planning tool, CourseRank , how existing recommendation methods lead to fixed, pre-specified recommendations that cannot adapt to each particular student X  X  changing requirements and do not help exploit the full extent of the available op-tions. These observations have shown the need to support flexible recommendations. We have defined the concept of a flexible recommendation workflow, i.e., a high-level de-scription of a parameterized process for computing recom-mendations. The input parameters of a workflow allow one to generate flexible recommendations. We have seen how flexible recommendations can be expressed over a relational database and we have presented our prototype system that allows defining and executing recommendation workflows over relational data. We built a user interface in Cours-eRank that allows students to make use of two workflows defined and executed with the help of this system. We plan to expose students to other kinds of recommendation work-flows as well, such as the friends of friends workflow briefly sketched in this paper.

Building a flexible recommendation engine over relational data presents many challenges. We are currently working on adding a blend operator and on workflow optimization, where operators can be reordered and executed using dif-ferent run-time strategies. We are interested in making an extensible platform that will allow expressing and experi-menting with different types of flexible recommendations. Furthermore, building user interfaces for flexible recommen-dations is an ongoing operation. Finally, expressing flexible recommendations in a declarative language would be an-other interesting research direction.

Acknowledgements We would like to thank the other members of the CourseRank team, Filip Kaliszan and Henry Liou, who have worked hard on other parts of the system. [1] CourseRank: url:http://courserank.stanford.edu. [2] The Stanford Daily: url: [3] G. Adomavicius and Y. Kwon. New recommendation [4] G. Adomavicius and A. Tuzhilin. Multidimensional [5] G. Adomavicius and A. Tuzhilin. Toward the next [6] M. Balabanovic and Y. Shoham. Fab: Content-based, [7] R. B. Bamshad Mobasher, Robin Burke and [8] D. Billsus and M. Pazzani. Learning collaborative [9] D. Billsus and M. Pazzani. User modeling for adaptive [10] J. Breese, D. Heckerman, and C. Kadie. Empirical [11] A. Das, M. Datar, A. Garg, and S. Rajaram. Google [12] D. Goldberg, D. Nichols, B. Oki, and D. Terry. Using [13] J. Herlocker, J. Konstan, A. Borchers, and J. Riedl. [14] J. Herlocker, J. Konstan, L. Terveen, and J. Riedl. [15] T. Hofmann. Collaborative filtering via gaussian [16] G. Linden, B. Smith, and J. York. Amazon.com [17] M. O. Mahony, N. Hurley, N. Kushmerick, and [18] B. Miller, I. Albert, S. Lam, J. Konstan, and J. Riedl. [19] M. Pazzani and D. Billsus. Learning and revising user [20] P. Resnick, N. Iakovou, M. Sushak, P. Bergstrom, and [21] A. Schein, A. Popescul, L. Ungar, and D. Pennock. [22] U. Shardanand and P. Maes. Social information [23] B. Sheth and P. Maes. Evolving agents for
