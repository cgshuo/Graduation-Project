 Semantic parsing is the task of mapping natural lan-guage sentences to a formal representation of mean-ing. Typically, a system is trained on pairs of natural language sentences (NLs) and their meaning repre-sentation expressions (MRs), as in figure 1(a), and the system must generalize to novel sentences.
Most semantic parsing models rely on an assump-tion of structural similarity between MR and NL. Since strict isomorphism is overly restrictive, this assumption is often relaxed by applying transforma-tions. Several approaches assume a tree structure to the NL, MR, or both (Ge and Mooney, 2005; Kate and Mooney, 2006; Wong and Mooney, 2006; Lu et al., 2008; B  X  orschinger et al., 2011), and often in-volve tree transformations either between two trees or a tree and a string.

The tree transducer, a formalism from automata theory which has seen interest in machine transla-tion (Yamada and Knight, 2001; Graehl et al., 2008) and has potential applications in many other areas, is well suited to formalizing such tree transforma-tion based models. Yet, while many semantic pars-ing systems resemble the formalism, each was pro-posed as an independent model requiring custom al-gorithms, leaving it unclear how developments in one line of inquiry relate to others. We argue for a unifying theory of tree transformation based seman-tic parsing by presenting a tree transducer model and drawing connections to other similar systems.
We make a further contribution by bringing to tree transducers the benefits of the Bayesian frame-work for principled handling of data sparsity and prior knowledge. Graehl et al. (2008) present an EM training procedure for top down tree transducers, but while there are Bayesian approaches to string trans-ducers (Chiang et al., 2010) and PCFGs (Kurihara and Sato, 2006), there has yet to be a proposal for Bayesian inference in tree transducers. Our vari-ational algorithm produces better semantic parses than EM while remaining general to a broad class of transducers appropriate for other domains.
In short, our contributions are three-fold: we present a new state-of-the-art semantic parsing model, propose a broader theory for tree transforma-tion based semantic parsing, and present a general inference algorithm for the tree transducer frame-work. We recommend the last of these as just one benefit of working within a general theory: contri-butions are more broadly applicable. In semantic parsing, an MR is typically an expres-sion from a machine interpretable language (e.g., a database query language or a logical language like Prolog). In this paper we assume MRs can be rep-resented as trees, either by pre-parsing or because they are already trees (often the case for functional the MR language is a regular tree language.

A regular tree grammar (RTG) closely resembles a context free grammar (CFG), and is a way of de-scribing a language of trees. Formally, define T the set of trees with symbols from alphabet  X  , and T
 X  ( A ) from A only occur at the leaves. Then an RTG is a tuple ( Q ,  X  , q is an alphabet, q is a set of grammar rules of the form q  X  t , where q is a state from Q and t is a tree from T
A rule typically consists of a parent state (left) and its child states and output symbol (right). We indi-cate states using all capital letters:
Intuitively, an RTG is a CFG where the yield of every parse is itself a tree. In fact, for any CFG G , it is straightforward to produce a corresponding RTG that generates the set of parses of G . Consequently, while we assume we have an RTG for the MR lan-guage, there is no loss of generality if the MR lan-guage is actually context free. Tree transducers (Rounds, 1970; Thatcher, 1970) are generalizations of finite state machines that operate on trees. Mirroring the branching nature of its in-put, the transducer may simultaneously transition to several successor states, assigning a separate state to each subtree.

There are many classes of transducer with dif-ferent formal properties (Knight and Greahl, 2005; Maletti et al., 2009). Figure 1(c) is an example of a root-to-frontier, linear, non-deleting tree-to-string transducer. It is defined using rules where the left hand side identifies a state of the transducer and a fragment of the input tree, and the right hand side describes a portion of the output string. Variables x q .x i stand for strings produced by applying the transducer starting at state q ure 1(b) illustrates an application of the transducer, taking the tree on the left as input and outputting the string on the right.

Formally, a weighted root-to-frontier, tree-to-string transducer is a 5-tuple ( Q ,  X  ,  X  , q is a finite set of states,  X  and  X  are the input and out-put alphabets, q set of rules. Denote a pair of symbols, a and b by a.b , the cross product of two sets A and B by A . B , and let X be the set of variables { x each rule r  X  R is of the form [ q.t  X  u ] .v , where u is a string in ( X   X  Q . X )  X  such that every x  X  X in u also occurs in t .

We say q.t is the left hand side of rule r and u its right hand side. The transducer is linear iff no vari-able appears more than once on the right hand side. It is non-deleting iff all variables on the left hand side also occur on the right hand side. In this paper we assume that every tree t on the left hand side is ei-ther a single variable x where  X   X   X  (i.e., it is a tree of depth  X  1 ).
A weighted tree transducer may define a probabil-ity distribution, either a joint distribution over input and output pairs or a conditional distribution of the output given the input. Here, we will use joint dis-tributions, which can be defined by ensuring that the weights of all rules with the same state on the left-hand side sum to one. In this case, it can be help-ful to view the transducer as simultaneously gener-ating both the input and output, rather than the usual view of mapping input trees into output strings. A joint distribution allows us to model with a single machine both the input and output languages, which is important during decoding when we want to infer the input given the output. Like the hybrid tree semantic parser (Lu et al., 2008) and the synchronous grammar based WASP (Wong and Mooney, 2006), our model simultaneously gen-erates the input MR tree and the output NL string. The MR tree is built up according to the provided MR grammar, one grammar rule at a time. Coupled with the application of the MR rule, similar CFG-like productions are applied to the NL side, repeated until both the MR and NL are fully generated. In each step, we select an MR rule and then build the NL by first choosing a pattern with which to expand it and then filling out that pattern with words drawn from a unigram distribution.

This kind of coupled generative process can be naturally formalized with tree transducer rules, where the input tree fragment on the left side of each rule describes the derivation of the MR and the right describes the corresponding NL derivation.

For a simple example of a tree-to-string trans-ducer rule consider which simultaneously generates tree fragment population( x tion of q.x an MR subtree under population , and, on the right, state-variable pair q.x generated while processing subtree x q . While this rule can serve as a single step of an MR-to-NL map such as the example transducer shown in Figure 1(c), such rules do not model the q NL m . population ( w 1 , x 1 , w 2 )  X  grammaticality of the MR and lack flexibility since sub-strings corresponding to a given tree fragment must be completely pre-specified. Instead, we break transductions down into a three stage process of choosing the (i) MR grammar rule, (ii) NL expan-sion pattern, and (iii) individual words according to a unigram distribution. Such a decomposition in-corporates independence assumptions that improve generalizability. See Figure 2 for example rules from our transducer and Figure 3 for a derivation.
To ensure that only grammatical MRs are gener-ated, each state of our transducer encodes the iden-tity of exactly one MR grammar rule. Transitions bedded rule. For instance, rule 2 in Figure 2 selects MR grammar rule r to expand the i th child of the parent produced by rule m . Aside from ensuring the grammaticality of the generated MR, rules of this type also model the probability of the MR, con-ditioning the probability of a rule both on the par-ent rule and the index of the child being expanded. Thus, parent state q MR of rule m , but also the child index, 1 in this case.
Once the MR rule is selected, q NL states are ap-plied to select among rules such as 3 and 4 to gen-erate the MR entity and choose the NL expansion pattern. These rules determine the word order of the language by deciding (i) whether or not to generate words in a given location and (ii) where to insert the result of processing each MR subtree. Decision (i) is made by either transitioning to state q W cision (ii) is made with the order of x hand side. Rule 4 illustrates the case where port-land and maine in cityid(portland, maine) would be realized in reverse order as  X  X aine ... portland X .
The particular set of patterns that appear on the right of rules such as 3 embodies the binary word at-tachment decisions and the particular permutation of x beginning and end of each pattern and between the x s. Thus, rule 4 is just one of 16 such possible pat-terns (3 binary decisions and 2 permutations), while rule 3 is one of 4. We instantiate all such rules and allow the system to learn weights for them according to the language of the training data.

Finally, the NL is filled out with words chosen ac-cording to a unigram distribution, implemented in a PCFG-like fashion, using a different rule for each word which recursively chooses the next word un-word sequence  X  X opulation of X  entails first choosing rule 5 in Figure 2. State q W plied to choose rule 6, generating  X  X f X  at the same time as deciding to terminate the string by transi-tioning to a new state q END which deterministically concludes by writing the empty string  X  .

On the MR side, rules 5-7 do very little: the tree on the left side of rules 5 and 6 consists entirely of a subtree variable w ated in the MR. Rule 7 subsequently generates these subtrees as W symbols, marking corresponding lo-cations where words might be produced in the NL,
Figure 3(b) illustrates the coupled generative pro-cess. At each step of the derivation, an MR rule is chosen to expand a node of the MR tree, and then a corresponding part of the NL is expanded. Step 1.1 of the example chooses MR rule m , NUM  X  population ( PLACE ) . Transducer rule 3 then gener-ates population in the MR (shown in the left column) at the same time as choosing an NL expansion pat-tern (Step 1.2) which is subsequently filled out with specific words  X  X opulation X  (1.3) and  X  X f X  (1.4).
This coupled derivation can be represented by a tree, shown in Figure 3(c), which explicitly repre-sents the dependency structure of the coupled MR and NL (a simplified version is shown in (d) for clar-ity). In our transducer, which defines a joint distri-bution over both the MR and NL, the probability of a rule is conditioned on the parent state. Since each state encodes an MR rule, MR rule specific distribu-tions are learned for both the words and their order. The tree transducer model can be viewed either as a generative procedure for building up two separate structures or as a transformative machine that takes one as input and produces another as output. Dif-ferent semantic parsing approaches have taken one or the other view, and both can be captured in this single framework.

WASP (Wong and Mooney, 2006) is an exam-ple of the former perspective, coupling the genera-tion of the MR and NL with a synchronous gram-mar, a formalism closely related to tree transducers. The most significant difference from our approach is that they use machine translation techniques for automatically extracting rules from parallel corpora; similar techniques can be applied to tree transduc-ers (Galley et al., 2004). In fact, synchronous gram-mars and tree transducers can be seen as instances of the same more general class of automata (Shieber, 2004). Rather than argue for one or the other, we suggest that other approaches could also be inter-preted in terms of general model classes, grounding them in a broader base of theory.

The hybrid tree model (Lu et al., 2008) takes a transformative perspective that is in some ways more similar to our model. In fact, there is a one-to-one relationship between the multinomial param-eters of the two models. However, they represent the MR and NL with a single tree and apply tree walk-ing algorithms to extract them. Furthermore, they implement a custom training procedure for search-ing over the potential MR transformations. The tree transducer, on the other hand, naturally captures the same probabilistic dependencies while maintaining the separation between MR and NL, and further al-lows us to build upon a larger body of theory.
KRISP (Kate and Mooney, 2006) uses string clas-sifiers to label substrings of the NL with entities from the MR. To focus search, they impose an or-dering constraint based on the structure of the MR tree, which they relax by allowing the re-ordering of sibling nodes and devise a procedure for recover-ing the MR from the permuted tree. This procedure corresponds to backward-application in tree trans-ducers, identifying the most likely input tree given a particular output string.

SCISSOR (Ge and Mooney, 2005) takes syntactic parses rather than NL strings and attempts to trans-late them into MR expressions. While few seman-tic parsers attempt to exploit syntactic information, there are techniques from machine translation for using tree transducers to map between parsed par-allel corpora, and these techniques could likely be applied to semantic parsing.

B  X  orschinger et al. (2011) argue for the PCFG as an alternative model class, permitting conventional grammar induction techniques, and tree transducers are similar enough that many techniques are applica-ble to both. However, the PCFG is less amenable to conceptualizing correspondences between parallel structures, and their model is more restrictive, only applicable to domains with finite MR languages, since their non-terminals encode entire MRs. The tree transducer framework, on the other hand, allows us to condition on individual MR rules. As seen in the example in Figure 3(c), tree trans-ducers not only operate on trees, their derivations are themselves trees, making them amenable to dy-namic programming and an EM training procedure resembling inside-outside (Graehl et al., 2008). EM assigns zero probability to events not seen in the training data, however, limiting the ability to gen-eralize to novel items. The Bayesian framework of-fers an elegant solution to this problem, introducing a prior over rule weights which simultaneously en-sures that all rules receive non-zero probability and allows the incorporation of prior knowledge and in-tuitions. Unfortunately, the introduction of a prior makes exact inference intractable, so we use an ap-proximate method, variational Bayesian inference (Bishop, 2006), deriving an algorithm similar to that for PCFGs (Kurihara and Sato, 2006).

The tree transducer defines a joint distribution over the input y , output w , and their derivation x as the product of the weights of the rules appearing in x . That is, where  X  is the set of multinomial parameters, r is a transducer rule,  X  ( r ) is its weight, and c number of times r appears in x . In EM, we are in-terested in the point estimate for  X  that maximizes p ( Y , W|  X  ) , where Y and W are the N input-output pairs in the training data. In the Bayesian setting, however, we place a symmetric Dirichlet prior over  X  and estimate a posterior distribution over both X and  X  . p (  X , X|Y , W ) =
Since the integral in the denominator is in-tractable, we look for an appropriate approximation q (  X , X )  X  p (  X , X|Y , W ) . In particular, we assume the rule weights and the derivations are independent, define a lower bound F  X  ln p ( Y , W ) in terms of q and then apply the calculus of variations to find a q that maximizes F . Applying our independence assumption, we arrive at the following expression for F , where  X  ticular parameter vector corresponding to the rules with parent state t :
F = X +
We find the q (  X  taking derivatives of the Lagrangian, setting them to zero, and solving, which yields: where
The parameters of q (  X  to q ( x to the parameters of q (  X  efficiently using inside-outside. Thus, we can per-form an EM-like alternation between calculating  X   X  and  X   X  . 4
It is also possible to estimate the hyper-parameters  X  from data, a practice known as em-pirical Bayes , by optimizing F . We explore learn-ing separate hyper-parameters  X  ing a fixed point update described by Minka (2000), where k We implement our VB training algorithm inside the tree transducer package Tiburon (May and Knight, 2006), and experiment with both manually set and automatically estimated priors. For our manually set priors, we explore different hyper-parameter set-tings for three different priors, one for each of the main decision types: MR rule, NL pattern, and word generation. For the automatic priors, we estimate separate hyper-parameters for each multinomial (of which there are hundreds). As is standard, we ini-tialize the word distributions using a variant of IBM model 1, and make use of NP lists (a manually cre-ated list of the constants in the MR language paired with the words that refer to them in the corpus).
At test time, since finding the most probable MR for a sentence involves summing over all possible derivations, we instead find the MR associated with the most probable derivation . We evaluate the system on GeoQuery (Wong and Mooney, 2006), a parallel corpus of 880 English questions and database queries about United States geography, 250 of which were translated into Span-ish, Japanese, and Turkish. We present here ad-ditional translations of the full 880 sentences into German, Greek, and Thai. For evaluation, follow-ing from Kwiatkowski et al. (2010), we reserve 280 sentences for test and train on the remaining 600. During development, we use cross-validation on the 600 sentence training set. At test, we run once on the remaining 280 and perform 10 fold cross-validation on the 250 sentence sets.

To judge correctness, we follow standard prac-tice and submit each parse as a GeoQuery database query, and say the parse is correct only if the answer matches the gold standard. We report raw accuracy (the percentage of sentences with correct answers), as well as F1: the harmonic mean of precision (the proportion of correct answers out of sentences with a parse) and recall (the proportion of correct answers
We run three other state-of-the-art systems for comparison. WASP (Wong and Mooney, 2006) and the hybrid tree (Lu et al., 2008) are chosen to rep-resent tree transformation based approaches, and, while this comparison is our primary focus, we also report UBL-S (Kwiatkowski et al., 2010) as a non-is notable as the only other system based on a gen-erative model, and uni-hybrid , a version that uses a unigram distribution over words, is very similar to our own model. We also report the best performing version, re-hybrid , which incorporates a discrimina-tive re-ranking step.

We report transducer performance under three dif-ferent training conditions: tsEM using EM, tsVB-auto using VB with empirical Bayes, and tsVB-hand using hyper-parameters manually tuned on the Ger-man training data (  X  of 0.3, 0.8, and 0.25 for MR rule, NL pattern, and word choices, respectively).
Table 1 shows results for 10 fold cross-validation on the training set. The results highlight the benefit of the Dirichlet prior, whether manually or automat-ically set. VB improves over EM considerably, most likely because (1) the handling of unknown words and MR entities allows it to return an analysis for all sentences, and (2) the sparse Dirichlet prior favors fewer rules, reasonable in this setting where only a few words are likely to share the same meaning. UBL-S 76.7 76.9 76.2 76.5
WASP 66.3 75.0 71.2 79.7 uni-hybrid 61.7 66.1 71.0 75.4 re-hybrid 62.3 69.5 70.2 76.8 tsEM 61.7 67.9 67.3 73.2 tsVB-auto 74.0 74.0  X  79 . 8  X  79 . 8 tsVB-hand  X  78 . 0  X  78 . 0 79.0 79.0 UBL-S 85 . 3 85 . 4 74.0 74.1
WASP 73.5 79.4 69.8 73.9 uni-hybrid 76.3 79.0 71.3 73.7 re-hybrid 77.0 82.2 71.7 76.0 tsEM 73.5 78.1 69.8 72.9 tsVB-auto 81.2 81.2 74.7 74.7 tsVB-hand  X  83.7  X  83.7  X  76 . 7  X  76 . 7
On the test set (Table 2), we only run the model variants that perform best on the training set. Test set accuracy is consistently higher for the VB trained tree transducer than the other tree transformation based models (and often highest overall), while f-We have argued that tree transformation based se-mantic parsing can benefit from the literature on for-mal language theory and tree automata, and have taken a step in this direction by presenting a tree transducer based semantic parser. Drawing this con-nection facilitates a greater flow of ideas in the research community, allowing semantic parsing to leverage ideas from other work with tree automata, while making clearer how seemingly isolated ef-forts might relate to one another. We demonstrate this by both building on previous work in train-ing tree transducers using EM (Graehl et al., 2008), UBL-S 75 . 0 75 . 0 73.6 73.7
WASP 65.7  X  74.9 70.7  X  78 . 6 re-hybrid 62.1 68.5 69.3 74.6 tsVB-hand  X  74.6 74.6  X  75 . 4 75.4 UBL-S 82 . 1 82 . 1 66.4 66.4
WASP 71.1 77.7 71.4 75.0 re-hybrid 76.8  X  81.0 73.6 76.7 tsVB-hand  X  79.3 79.3  X  78 . 2  X  78 . 2 UBL-S 80.4 80.6 79.7 80.1
WASP 70.0 80.8 72.4 81.0 re-hybrid 74.8 82.6 78.8  X  86 . 2 tsVB-hand  X  83 . 2  X  83 . 2  X  80 . 0 80.0 UBL-S 80 . 5 80.6 74.2 74.9
WASP 74.4  X  82 . 9 62.4 75.9 re-hybrid 76.8 82.4 66.8  X  77 . 5 tsVB-hand  X  78.0 78.0  X  75 . 6 75.6 and describing a general purpose variational infer-ence algorithm for adapting tree transducers to the Bayesian framework. The new VB algorithm re-sults in an overall performance improvement for the transducer over EM training, and the general effec-tiveness of the approach is further demonstrated by the Bayesian transducer achieving highest accuracy among other tree transformation based approaches. We thank Joel Lang, Michael Auli, Stella Frank, Prachya Boonkwan, Christos Christodoulopoulos, Ioannis Konstas, and Tom Kwiatkowski for provid-ing the new translations of GeoQuery. This research was supported in part under the Australian Re-search Council X  X  Discovery Projects funding scheme (project number DP110102506).
