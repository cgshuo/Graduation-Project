 Given a set of d input time series, by aggregating the d values at each time position, we obtain an aggregated time series A .Atop-k query is to determine the top k time positions on A , namely, the time positions with the k greatest aggregated values. The well-known threshold algorithm (TA) [2] may be used to answer this type of query.

Recently, there has been active research on data aggregation in sensor net-works [5, 6, 7, 1] and the top-k query can be very useful. For example, in an environmental monitoring system, multiple sensors may be used in an interested area to measure the temperature, humility, etc., at every minute. The measured data are stored in these sensors, and the system may need to find, within a spe-cific time period, the time positions with the k highest average temperatures [3].
Assume the aggregated time series contains the average temperature for each minute during the past week and k = 3. If Friday is the warmest day during the week and the highest temperature during the week is at 1:30pm on Friday, we may very likely get the following three time positions as the answer to our top-3 query: 1:29pm on Friday, 1:30pm on Friday, and 1:31pm on Friday.

We believe that a more interesting query is to find the plateau over the ag-gregated time series. The plateau is defined as the maximum interval such that all the values on the time positions in the interval are no less than all the values at the time positions outside of the interval. Compared to the top-k time posi-tions, the plateau may give us more information. The plateau definition becomes more interesting and useful when we add another constraint: all the values in the plateau should be  X  X lose enough X  to the top-1 value of the whole sequence. How close is  X  X lose enough X  can be a value specified by the user.

In the example above, assume that the user considers two degrees as close enough, and asks for the plateau. The answer will be the interval [1:10pm on Friday, 1:45pm on Friday] if the temperature at each time position in this interval is at most two degrees lower than the highest temperature observed at 1:30pm on Friday, and all the time positions outside of this interval have temperature values no higher than the value of each time position in the interval. Obviously, the plateau carries more information about high-temperature time positions than that of the k time positions we get from a traditional top-k query.
In this paper, we formally define the plateau over time series and present effi-cient algorithms to find the plateau in both centralized and distributed settings. We show that the plateau can be found in linear time with respect to the length of time series in the centralized setting. For the distributed setting, we develop a distributed search algorithm and through experiments we show that it signif-icantly outperforms a direct extension of the TA algorithm in terms of number of accesses to the distributed sources.

The rest of the paper is organized as follows. In the next section, we introduce some basic notions and formally define the key concept of plateau . Sections 3 and 4 describe our algorithms for finding the plateau in an aggregated time series in a centralized setting and a distributed setting, respectively. We present our experimental results in Section 5 and draw conclusions in Section 6. We first define time series. A time series is a finite sequence of real numbers and the number of values in the sequence is its length .Weassumealltimeseriesare as s , possibly with subscripts, and its value at time t is denoted s ( t ).
An aggregated time series is a time series whose value at time position t is from aggregating the values from multiple input time series . Specifically, given s ,...,s d and an aggregation function f , the aggregated time series is s f with s series, and omit the mentioning of function f when it is understood. A  X  X ormal X  time series can be considered as a degenerated aggregated time series, and hence we shall use A to denote both  X  X ormal X  time series and aggregated ones. Definition 1. Given a time series A and a real value  X  , a time interval [ t l ,t r ] is said to be an  X  -plateau of A if for each time position t  X  [ t l ,t r ] , we have Intuitively, an  X  -plateau in a time series is the largest time interval that has values no less than the value of any time position outside of the interval, and the difference between the values within the time interval is at most  X  .An  X  -plateau must contain a time position with the greatest value in the time series.
We abbreviate  X  -plateau to simply plateau when  X  is implicit or irrelevant. A maximum  X  -plateau is an  X  -plateau that is not a proper subinterval of another  X  -plateau. In the sequel, when not explicit ly stated and clear from the context, we will use the term plateau to mean the maximum plateau.

When there are more than one top-1 time position in the aggregated time series, two cases arise: all the top-1 time positions are either contiguous or not. In the former case, we will have only one maximum plateau. For the latter, the only (maximum) plateaux we will find are formed by top-1 time positions, to finding all top-1 time positions (and possibly combine these positions that are contiguous with each other). We do not pursue this case any further. Since the former case is equivalent to having a unique top-1 position, we will in the sequel assume that the top-1 position is unique in each aggregated time series, and hence we will have a unique maximum plateau for each  X  value.
 Example. Consider the maximum plateau in the (aggregated) time series shown in Fig. 1. The top-1 time position is t d = t 10 with value 12. If  X  = 2, then the plateau is [ t 9 ,t 10 ]. If  X  = 10, then the plateau is [ t 8 ,t 11 ]. An equivalent way of defining a plateau is by a minimum value threshold  X  . That is, instead of condition (1) in the definition, we would insist that A ( t )  X   X  for all t  X  [ t l ,t r ]. Obviously, this is equivalent to the original definition if we take  X  = A ( t m )  X   X  ,where t m is a time position with the great-est value. In the sequel, we may use plateau to mean an  X  -plateau or equivalently a plateau with a mini-mum value threshold.

We may also define the  X  -plateau via the notion of rank as follows.
 Definition 2. Given a time series, the top-rank ,orsimply rank ,ofatime position t ,denoted R ( t ) , is defined as 1 plus the number of time positions that have greater values, that is, R ( t )=1+ |{ t | A ( t ) &gt;A ( t ) }| . If R ( t )  X  k , we will also say that t is a top-k time position . Hence, a top-1 time position has a value that is no less than that of any other time positions.

Given a time series and real value  X  ,if[ t l ,t r ]isan  X  -plateau ,thenforeach smaller) than R ( t )mustbein[ t l ,t r ]. For example, if the plateau includes a rank 3 time position then all the rank 1 and rank 2 time positions must also be in the plateau.
Much has appeared in the literature for algorithms that look for top-k items from multiple data sources (e.g., [4]). Many algorithms use a variant of Fagin et al. X  X  threshold algorithm (TA), which has been shown to be optimal [2]. In TA, the aggregation function f is assumed to be monotonic , i.e., x 1  X  y 1 ,..., x d  X  y d sum, average, maximum, are monotonic.

We now briefly review TA, as applied to look for top-k time positions in the aggregated time series. Assume we have d input time series s 1 , ..., s d .We sort each time series based on the value s (from large to small), and keep the time position information with the values. Thus, we have d such sorted lists: L ,...,L d . In TA, we proceed as follows. 1. Do sorted access in parallel (or using a round-robin schedule) to each of the d 2. For each list L i ,let v i be the last value returned under the sorted access. De-In this section, we discuss how to find the plateau for an aggregated time series when all the input time series are available at a central point. For example, we can imagine each sensor in a sensor netw ork sends its measurement data to the control center every hour. In such a setting, the central point can calculate the aggregated time series A based on the input time series and the given aggregation function. We present a linear time algorithm for finding the plateau on A .
We first define a left  X  -plateau of the time series A to be an  X  -plateau when we only consider the time series on the left of (and including) the top-1 time the top-1 time position. Right  X  -plateaux are defined analogously. We define the maximum left and right  X  -plateaux in a similar way as we defined the maximum  X  -plateau, and use the term left and right plateau to mean the maximum left and right plateau, respectively, when the context is clear. Note, however, the union of a left and a right  X  -plateaux does not necessarily form an  X  -plateau as will be shown in the example at the end of this section.
 The following result directly follows the definitions.
 Theorem 1. Denote min right ( i )= m in A ( t j ) i  X  j  X  m ,andmax left ( i )= time position.
 In the above theorem, we assume max left ( 1 )=  X  X  X  . We have an analogous the-orem for the right  X  -plateaux. These theorems give the basis for our linear time algorithm in finding the maximum left and right  X  -plateaux. It is obvi-ous that min right and max left for the time positions before t m (and min left and max right for the positions after t m ) can be computed in an incremen-tal fashion with two sequential scans, using for example the recurrence relation and assume  X  = A ( t m )  X   X  . Then we can easily design the procedure: The input parameters are [ t L ,t m ]and  X  ,where t L is the left boundary of the time series to be considered, t m is the right boundary of the time series to be imum value threshold. The output parameters are [ t l ,t m ]and  X  l ,where[ t l ,t m ] is the maximum left plateau and  X  l = m ax  X , A ( t i ) i = l,...,l  X  1 .The procedure simply scans from t L towards t m and finds the first time position t l such that min right ( l )  X  max left ( l )and min right ( l )  X   X  .

The correctness of this procedure follows Theorem 1 directly. It is also clear that the time complexity of the procedure is O ( l  X  L +1).

The question now is how to get the global  X  -plateau. Assume find left plateau positions in [ t 1 ,t l ) have values no greater than  X  l . We have similar conclusions for [ t m ,t r ]and  X  r .If  X  l =  X  r ,wecanmergetheleftandright  X  -plateaux to obtain the maximum  X  -plateau. Otherwise, we should shrink the side with the smaller  X  using the greater  X  . This shrinking process is repeated until  X  l =  X  r and we then merge the left and right  X  -plateaux into the  X  -plateau. The whole process is summarized in Fig. 2. The algorithm finds the maximum  X  -plateau [ t l ,t r ]of no smaller than  X  while all the values not in [ t l ,t r ] are no greater than  X  . Theorem 2. Algorithm Find Plateau correctly finds the  X  -plateau of time series A in linear time and space.
 Proof. The space complexity of the algorithm is obvious since we only need to store two numbers for each time position. Now we analyze its time complexity. Steps 1-3 take linear time as mentioned earlier. The nontrivial part of the proof is that find left plateau and find right plateau may be called multiple times due to Steps 5 and 6. However, each repeated call to find left plateau will start the scan from the stopping position of the previous call. That is, even in the worst case, the multiple calls to find left plateau willscanupto m positions and thus the complexity of all calls is O ( m ). Similarly, the complexity of all possible multiple calls to find right plateau is O ( n  X  m + 1). Hence, the time complexity of Algorithm Find Plateau is O ( n ).

The correctness follows the correctness of the procedures find left plateau and find right plateau . Indeed, with Steps 2 and 3, we find the respective maximum plateaux with A ( t m )  X   X  as the minimum value threshold for the plateaux. It is clear that Steps 5 and 6 will both still return  X  -plateaux. The question is whether the final result is the maximum  X  -plateau. The answer is positive since each time we used smallest  X  l and  X  r value that is necessarily to maintain the combined interval to be a plateau.
 Example. We want to find the 10-plateau in the time series shown in Fig. 1. The top-1 time position is t m = t 10 with value 12. Given  X  = 10, we have threshold returns with the maximum right plateau [ t 10 ,t 12 ]and  X  r =2.Notethatwe cannot combine the left and right plateaux into one yet since  X  l =  X  r (actually, [ t This time, it returns a new right plateau [ t 10 ,t 11 ]andanew  X  r =7.Nowwecan combine the left and right plateaux into P =[ t 8 ,t 11 ]. We also output  X  =7. In this section, we discuss how to find the plateau for an aggregated time series without bringing all the data into a centralized server. The reason for this may include the large size of the time series from the data sources, and the high communication costs. In this setting, we would like to calculate the  X  -plateau with a minimum amount of communication. To do this, we assume that data sources have some computation power to support the local processing as required by the Threshold Algorithm (TA) of [2].

In the distributed setting, as required by the TA, we assume the aggregation functions are monotonic . 4.1 A Naive Algorithm A straightforward way of finding the plateau in a distributed setting is to find the top-1 time position t m in the aggregated time series, and then to find all the time positions whose aggregated values are no smaller than A ( t m )  X   X  .
The top-1 time position t m and its aggregated value A ( t m ) can be found by a direct use of TA. We may trivially extend the TA algorithm to proceed, after finding top-1 time position, to repeatedly find the next top time positions and In this way, we find all the time positions with values no smaller than A ( t m )  X   X  . With these time positions, we can use our linear algorithm to find the maximum  X  -plateau. Indeed, a little deeper analysis of the linear algorithm indicates that if we change all the values smaller than A ( t m )  X   X  to a very small number (smaller than all possible values), then the plateau found by the linear algorithm is the same as the one found with all the data available. 4.2 A Distributed Search Algorithm In some situations, the above naive algorithm performs very poorly. Indeed, con-sider the following aggregated time series of length n : and consider 1-plateau (i.e.,  X  = 1). Clearly, the top-1 time position is t n ,and the 1-plateau is [ t n ,t n ]. However, the above naive algorithm will need to retrieve all the time positions t 1 through t n  X  2 , in addition to t n . The run time and the communication cost will be proportional to n . A simple observation will yield that if we find out that the time position t n  X  1 has a value 1 that is lower than A ( t n )  X   X  =3  X  1 = 2 and the greatest value between t 1 and t n  X  1 is 2, then we can safely conclude that [ t n ,t n ] is the plateau we are seeking.
Similar to the linear centralized algorithm in Section 3, we first concentrate on finding the left and right plateaux, separately, and then combine them into a single plateau. The above example is for the left plateau. Let us examine it a little closer with the help of the diagram in Fig. 3. In this diagram, the current (not necessarily maximum) left plateau is the one we have already found (e.g., [ t m ,t m ]where t m is the top-1 point in the whole series), and we would like to see if we can extend the current left plateau towards the left in order to find the maximum left plateau. For this purpose, we find the top-1 time position (called  X  X eft top-1 X  in the digram) on the left of the current left plateau, and then we find the bottom-1 time position (called  X  X ocal bottom-1 X  in the diagram) between the left top-1 and the current left plateau.

Three cases arise based on the  X  value as depicted in Fig. 3. (Recall that  X  gives the restriction that all the values in the plateau must be no less than  X  ). Consider Case 2 first as this is the case for the above example. In this case, the  X  valueisbetweenthelefttop-1valueandthelocalbottom-1value.Thefollowing are two useful observations for this case: (1) Any value in the maximum plateau must be no less than the value of this (2) The left plateau cannot be extended to the time position of the local bottom-By using these observations, we can extend the left plateau by using the new  X  value and the boundary. This can be done with a recursive call to the extending procedure itself. One condition for the recursion to stop is if the new boundary is actually the current plateau. Going back to the above example, the proce-dure stops after we find the local bottom-1 is at position t n  X  1 ,whichisatthe immediate left of the current left plateau (i.e., [ t n ,t n ]).

Now consider Case 1. Since the left top-1 value is below  X  ,weknownotime positions on the left of the current left plateau can be in the maximum left plateau. In this case, the current left plateau is the maximum left plateau.
Finally consider Case 3. In this case, we may be tempted to conclude that the left plateau can be extended to the time position of left top-1. However, this would be wrong if going to further left (left of the left top-1), we would meet a time position with a value lower than  X  and then another time position with a value higher than the value of the local bottom-1. See Fig. 3 for this situation. What we need to do in this case is to find out if such a situation actually occurs. To do this, we recursively consider the time series on the left of (and including) the time position for the left top-1. Now local top-1 forms a left plateau by itself since it is a top-1 value in this subseries, and we try to extend the  X  X ocal X  plateau to the left. This (recursive) procedure will return a  X  X ocal X  left plateau starting from left top-1, and returns the actual  X  value used by this  X  X ocal X  left plateau. If this returned  X  value is still lower than the value of the local bottom-1, then we can conclude that all the positions on the right of the left top-1 are indeed in the left plateau (together with all the time positions in the  X  X ocal X  left plateau). Otherwise (i.e., the returned  X  value is greater than the value of the local bottom-1), then we can conclude that the left plateau cannot be extended to the time position of left top-1, and the new  X  value to use is the returned  X  value from the  X  X ocal X  left plateau procedure.

We can now summarize our search algorithm in Fig. 4. In this algorithm, we refine the TA algorithm to look for top-1 and bottom-1 time positions (in terms of aggregated values) in an interval of [ left , right ] of the time series. We assume TA will return the aggregated values associated with the top-1 and bottom-1 time positions. This extension can be obtained straightforwardly without requiring the data sources maintain separate sorted lists for each different time interval. are time positions, to denote the top-1 and bottom-1 time positions found by TA within the interval [ left , right ], respectively.
 Theorem 3. The algorithm in Fig. 4 correctly finds the maximum left plateau. The procedure to find the right plateau is similar. The complete algorithm that finds the plateau is the same as for the centralized algorithm, but will use TA to find the top-1 time position (Step 1, without computing the four arrays) and the search algorithms to find the left/right plateaux (Steps 2-6). It is easily seen that this complete procedure will find the correct plateau.
 Example. Consider the time series in Fig. 5. We will only show how to find the we find left top-1 is at t t = t 4 ,and local bottom-1 is at t b = t 5 .Since A ( t b )= A ( t 5 )=3 &gt; X  =2,weare in Case 3 (Step 2.3), and we make a recursive call ( C-2 )withinterval [ t ,t 4 ]and  X  =2.In C-2 ,wehave t t = t 2 and t b = t 3 ,andweare looking at Case 2. Since b =3= m  X  1=4  X  1 in this case, we return to C-1 with [ t 4 ,t 4 ]andanew  X  = A ( t 2 )=5.In C-1 ,wewereinCase3with returned  X  = 5, and since  X  =5 &gt;A ( t b )= A ( t 5 )=3,weset  X  =5and go back to Step 2. Now we are looking at Case 2 since A ( t t )= A ( t 4 )=7 &gt;  X  =5 &gt;A ( t b )= A ( t 5 ) = 3. Since 5 = b = m  X  1=6  X  1, we return [ t 6 ,t 6 ]. Hence, we have found the maximum left 8-plateau to be [ t 6 ,t 6 ] and the return  X  = A ( t t )= A ( t 4 )=7. 4.3 Optimizing the Distributed Search Algorithm There are many optimization techniques to add to the search algorithm. Here we only mention three of them that are used in our implementation. Other opportunities are abundant but are not pursued in this paper.

To start with, for Step 1, we may want to find the leftmost top [ t l ,t r  X  1 ]and most and rightmost time positions, respectively, generally gives us the advantage in obtaining the plateau faster.

For Step 2.3, if t t = t b , then we know that all the time positions between [ t ,t m ] have values no less than A ( t t ) (also no less than  X  ), then we may im-mediately extend the left plateau to [ t b ,t m ] without any recursion (although recursion will eventually find this extension as well).
 to reuse of the results across the different runs. For example, we may need to case, we have already obtained the top [ t l ,t r  X  k ]. In this section, we report the experimental evaluation of our distributed search algorithm. For the purpose of comparison, we also implemented the naive algo-rithm as mentioned in Section 4.1.

In order to control the experiments, we used synthetically generated data sets. We are interested in the situation that all the distributed data sources are monitoring the same phenomenon and hence the data should be somewhat correlated. In order to simulate this, to generate one data set, we first use a random walk to generate a core time series s c , and then generate each input time series by (1) adding to the core with a fixed  X  X hift X  value, and then (2) randomly where shift is a fixed (randomly picked) value for the entire time series s ,and randpert is a random number at each time position. The parameters we used in our experiments are as follows: each step of the random walk takes a random is a random value between [  X  5 , 5] and the randpert is a random number between [  X  2 . 5 , 2 . 5]. We used the sum as our aggregation function.

To give a  X  X rend X  to the random walk data, we modified the above generation of s c with a slight bias. For the first half of the core time series, we add a small in the second half of the core time series, we subtract the same small bias. This way, it X  X  more likely that the time series will peak when reaching the middle of the time series. Since the bias is rather small, the trend is not prominent in our data sets.

Basically, three parameters affect the performance: the length of time series, the number of time series, and the  X  valueusedfortheplateau.Therefore,we tested our distributed search algorithm in three different ways, each varying one parameter while keeping the other two constant. The performance of our algorithm is measured on the number of accesses needed to the data sources (i.e., the number of sorted and random accesses required by the TA). For each fixed set of parameters, we generated 10 different data sets as described above and report the average number of accesses.

The result of the first experiment is reported in Fig. 6. In this experiment, we fixed number of series to 30, and  X  to 90. As can be seen, the length of the series do not affect the performance too much on both algorithms, al-though our distributed algorithm performs better with one scale of magnitude. Intuitively, the naive algorithm would be affected by the series length be-cause there may be more time po-sitions with aggregated value above A ( t m )  X   X  . However, in our particular setting, due to the one  X  X eak X  nature of our time series, the performance of the naive algorithm does not degen-erate as series length increases. As we observed (but not reported here), if we use a larger  X  value, the performance of the naive algorithm generally goes poorer as the series length increases.
 In general, however, the performance of our distributed algorithm scales well with series length even in multiple-peak situations.

The result of the second experiment is reported in Fig. 7. In this experiment, we fixed the time series length to 3 , 000, but varied the number of input time series from 1 to 100. Since we used sum as our aggregation, we varied the  X  value in proportion to the number of time series. Specifically,  X  is three times the number of time series (thus, if we have 30 time series,  X  = 90). As can be seen that our distributed algorithm performs much better than the naive algorithm, with one scale of magnitude, consistently.

The result of the third experiment is reported in Fig. 8. In this experiment, we fixed the time series length to 3 , 000 and the number of time series to 30. In-terestingly, when  X  value is very small, the naive algorithm performs better than our distributed algorithm. In such cases, the naive algorithm retrieves almost exactly all the time positions in the plateau. In general, if the plateau consists of all (or most of) the points that is above A ( t m )  X   X  , then the naive algorithm works very well. However, such cases should be rare in practice. In this paper, we introduced the notion of the plateau in time series and presented two algorithms to find the plateau in aggregated time series. The first algorithm deals with the situation when all the data are available at a central location. In such a setting, we showed how the plateau can be found in linear time with respect to the length of the time series. The second algorithm is for distributed data sources in which we would like to reduce the communication cost. We presented a search algorithm that gives one scale of magnitude reduction in terms of communication cost over a straightforward use of the Threshold Algorithm [2].
As we observed, in some very special situations, the naive algorithm actually performs better than our more sophisticated search algorithm. It will be inter-esting to see how to merge the naive strategy into the search algorithm to take advantage of the special situations.

