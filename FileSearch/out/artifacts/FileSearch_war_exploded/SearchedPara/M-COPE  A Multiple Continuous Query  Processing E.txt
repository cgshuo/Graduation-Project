 A data stream mana gement system (DSMS) should support an efficient evaluation scheme fo r long-running continuous queries over infinite data streams. This demonstration presents a scalable query processing engine, M-COPE (M ultiple Co ntinuous Query P rocessing E ngine) developed to evaluate multiple continuous queries efficiently. A multiple query optimization scheme implemented in the system ge nerates a single network of operations as an execution plan for registered queries in order to maximize the reuse of the intermediate results of common sub-expressions in the queries adaptive ly. In this paper, we describe the overall architecture of M-COPE along with its special features. Network traffic flow streams are used to demonstrate the main features of M-COPE . H.2.4 [ DATABASE MANAGEMENT ]: Systems -Query processing Algorithms, Design DSMS, Data stream , Multiple Query Optimization Recently emerging applications such as web click monitoring, network traffic analysis and sens or data monito ring essentially need to deal with a data st ream which is a massive unbounded sequence of data elements contin uously generated at a rapid rate. Several data stream management system s (DSMS) such as TelegraphCQ [6], Borealis [7], STREAM [4] and Nile [5] have been developed for these applications. A DSMS should be scalable and extensible to handle the rapid arrival rate of data streams for a large numbers of long-running continuous queries. For this purpose, STREAM [4] focused on adaptive query optimization and operator scheduling while TelegraphCQ [6] investigated a new dynamic tuple routing scheme for multiple query processing without any fixed query plan. On the other hand, M-COPE focuses on reusing the results of common sub-expressions in a set of continuous queries. Monitoring a specific event over data streams is the basic sharing common sub-expressions as much as possible. The priority of an operation is measur ed by the number of queries that contain the operation. A high priority operation is placed near to base data streams. On the other hand, A-SEGO [2] is a cost-based multiple query optimization scheme which is an extension of the k-Extended Greedy Algorithm (k-EGA) [3]. The k-EGA algorithm is an adaptive query optimization scheme for a single multi-way join query and it represents the cost of each operation as a range [  X  - X  x ,  X  x +  X  x ] where  X  x denotes the average of the past evaluation costs of x and  X  x denotes its standard deviation. Unlike a general greedy-based optimization, k-EGA simultaneously examines several promising part ial plans whose estimated costs are within the range of a predefined parameter k in the optimization process. As a result, it can produce a more optimized query plan without any backtracking mechanism. The number of examined partial plans can be flexibly controlled by the value of k , which means that it can examine the entire search space when k=  X  or it can merely simulate a typical greedy search when k=0 . In the A-SEGO scheme , the evaluation cost of an operation is defined by a relative cost which is obtained by dividing the cost of the operation by the number of querie s that contains the operation. Consequently, an operation that is shared by more queries can be placed near to base data streams. A user can define a set of related queries as a single task. The Plan Generator module generates an optimized execution plan for the queries of a task. It places selection operators ( X  BS  X  in Figure 2) below the join operators ( X  BJ  X  in Figure 2). Each operati on is implemented by a single thread and an inter-queue connects a parent operation to one of its child operation, i.e. the result tuples of a parent operation are appended to the input queue of its child operator. In the Query Executor module , every intermediate tuple generated by an operation node of a query network is associated with a bitmap as in [6] to indicate those queries that are satisfied by the tuple. One selection operation node is allocated to an input base data stream and all the selection predicates of the stream are evaluated collectively for each attribute of the stream by the Attribute Selecti on Construct(ASC) method [1]. This method divides the domain of each attri bute into a number of disjoint intervals with respect to those constants that are expressed in the selection predicates of the queries. For each interval, the pre-computed result of the queries is indicated by a bitmap. On the other hand, one join node is al located to a join predicate regardless of the size of a slid ing window. A symmetric hash-join method is used to process a jo in operator. Like a selection operation, every result of a join operation is associated with a 
