 estimating the travel time of any path (represented as a sequence of connected road segments) in real time in a city, based on the GPS trajectories of vehicles received in current time slots and over a period important task in many traffic monitoring and routing systems, the problem has not been well solved yet given the following three challenges. The first is the data sparsity problem, i.e., many road segments may not be traveled by any GPS-equipped vehicles in present time slot. In most cases, we cannot find a trajectory exactly traversing a query path either. Second, for the fragment of a path with trajectories, they are multiple wa ys of using (or combining) the trajectories to estimate the corresponding travel time. Finding an optimal combination is a challenging problem, subject to a tradeoff between the length of a path and th e number of trajectories traversing the path (i.e., support). Third, we need to instantly answer users X  queries which may occur in any part of a given city. This calls for an efficient, scalable and effective solu tion that can enable a citywide and real-time travel time estimation. To address these challenges, we model different drivers X  travel time s on different road segments in different time slots with a three dimension tensor. Combined with geospatial, temporal and historical contexts learned from trajectories and map data, we fill in the tensor X  X  missing values through a context-aware tensor decomposition approach. We then devise and prove an object function to model the aforem entioned tradeoff, with which we find the most optimal concatenation of trajectories for an estimate through a dynamic programming solu tion. In addition, we propose using frequent trajectory patterns (m ined from historical trajectories) to scale down the candidates of concatenation and a suffix-tree-based index to manage the trajectories received in the present time slot. We evaluate our method based on extensive experiments, using GPS trajectories generated by more than 32,000 taxis over a period of two months. The results demonstrate the effectiveness, efficiency and scalability of our method beyond baseline approaches. H.2.8 [Database Management]: Da tabase Applications -data mining, Spatial da tabases and GIS; Travel time estimation; tensor; trajectories; urban computing; Real-time estimation of the travel time of a path, which is represented by a sequence of connected road segments, is of great importance for traffic monitoring [1], finding driving directions [20], ridesharing [13] and taxi dispatching [22]. Existing solutions, e.g., using loop sensors, usually tell people the travel speed of an individual road segment rather than the travel time of an entire path. The latter X  X  value is not a simple summation of the travel time of each individual road segment, as a path also contains road intersections (sometimes with traffic lights) where a driver needs to slow down or wait for a while. Explicitly modeling the time delay at an intersection is not easy [8]. In addition, these methods have limited coverage, as many streets do not have a loop sensor embedded. An alternative method is to use floa ting car data (e.g., GPS trajectories of vehicles) to estimate the travel time of a path. For example, as shown in Figure 1, we estimate the travel time of path  X   X   X  X   X  , using four trajectories  X  X   X  ,  X  X   X  ,  X  X   X  , and  X  X  there are three major issues remaining unsolved in existing methods. They are as follows: 1) Data sparsity : For example,  X   X  is not traversed by any trajectory in the previous 30 minutes. Using an average of  X   X  times is not accurate enough (since its traffic conditions change over time of day and day of the week). Sometimes, the road may never be traversed by any trajectories (even in history) in our dataset, as in practice we only have the data of a sample of vehicles. 2) Trajectory concatenation : For the sub-path (e.g.,  X  with trajectories, how to combine these trajectories effectively to achieve an accurate estimate is still a challenging problem. Clearly, there are multiple ways of using the four trajectories shown in Figure 1. For instance, we can calculate the travel time of  X  solely based on  X  X   X  . Or, we can compute the travel time for  X  on  X  X   X  and  X  X   X  ),  X   X  (based on  X  X   X  ,  X  X   X  and  X  X   X  X   X  and  X  X   X  ), separately. Later, the travel time of  X  be obtained by summing the travel times of each road segment. We can also use  X  X   X  and  X  X   X  to estimate the travel time of  X  concatenating it with that of  X   X  ; or, do  X   X   X  X   X  first based on  X  X   X  X   X  , then concatenating it with  X   X  . Different concatenations have their own advantages and disadvantages, subject to a trad e-off between their support and length. The ideal situation is to estimate the travel time of  X   X  X   X   X  X   X  using many trajectories like  X  X   X  covering the entire path. Such trajectories reflect the traffic conditions of an entire path, including intersections, traffic lights and direction turns, hence, no need to model these complex factors separately and explicitly. However, as the length of a path increases, the number of trajectories (i.e., the support) traveling on the path decreases (refer to Figure 10 A) for details). Consequently, the confidence of the travel time (derived from few drivers) decreases. For example, what if  X  X   X  is generated by an uncommon driver or in an unusual situation like pedestrians crossing a street? Furthermore, in many cases, we cannot even fi nd a trajectory passing an entire path. On the other hand, using the concatenation of shorter sub-paths can have more occurrences of trajectories on each sub-path (i.e., having a high confidence in the derived travel time for each sub-path). But this results in more fragments, across which the aforementioned complex factors are difficult to model. The more fragments a concatenation contains, the more inaccuracy a path X  X  travel time could involve. 3) Tradeoff among Scalability, effectiveness and efficiency : As users can query any path in a city, we need to model the traffic conditions with a city scale, wh ich usually contains tens of thousands of road segments. In th e meantime, we have to answer users X  query instantly. So, a good solution should be scalable, effective and efficient, all simultaneously. This requirement fails some complex models that work well on a particular road. In this paper, we propose a mode l for instant Path Travel Time Estimation (PTTE), based on sparse trajectories generated by a sample of vehicles (e.g., some GPS equipped taxicabs) in the recent time slots as well as in history. Our model is comprised of two major components. One is to estimate the travel time for road segments without being traver sed by trajectories through a context-aware tensor decomposition (CATD) approach. The second is to find the most optimal concatenation (OC) of trajectories to estimate a path X  X  travel time using a dynamic programing solution. Our work ha s three primary contributions:  X  Dealing with the missing values : We model different drivers X   X  Optimal concatenation : We devise and prove an object  X  Evaluation : We evaluate our model with the real trajectories The rest of the paper is organized as follows: Section 2 overviews our model. Section 3 elaborates on the method for inferring the travel time of road segments without trajectories. Section 3 introduces the method that searches for the most optimal concatenation. Section 4 presents the experiments and Section 5 summarizes related work. We conclude the paper in Section 6. Definition 1: Road Network . A road network  X  X  is comprised of a set of road segments  X  X  X  X  connected among each other in a graph format. Each road segment  X  is a directed edge with two terminal points, a list of intermediate points describing the segment, a length  X  X  X . X  , a level  X  X  X . X  (e.g. a highway or a street), a direction  X  X  X . X  (e.g. one-way or bi-directional) and the number of lanes  X . X  . Definition 2: Trajectory . A spatial trajectory  X  X  is a sequence of time-ordered points,  X : X  X   X   X  X   X   X  X  X  X   X  , where each point has a geospatial coordina te set and a timestamp,  X  X , X , X  X  X  X  X  . Definition 3: Path . A path  X  is represented by a sequence of connected road segments, e.g.,  X : X   X   X  X   X   X  X  X  X   X  , in an  X  X  . Definition 4: Trajectory pattern. A trajectory pattern  X  X  is a sequential pattern of road se gments with a support over a threshold, calculated by the number of trajectories traversing these road segments. If we set support as 2,  X   X   X  X   X  and  X  Figure 1 are trajectory patterns, while  X   X   X  X   X   X  X   X  is not eligible. Definition 5: Concatenation. A path  X  can be decomposed into different concatenations ( || ) of its sub-paths,  X  X  X  X   X   X ||... ||  X   X ||...  X   X  ||...  X  ,  X  X  X , X 1 X  X  ,  X  X  X  ,  X  For instance,  X   X   X  X   X   X  X   X   X  X   X  can be formed by  X  X   X   X || X   X  , or  X  X   X   X  X   X   X  X  X | X   X   X  X   X   X  , or  X   X   X  X  X |  X  travel time of  X  can be obtained via the summation of different concatenations, e.g.,  X   X   X  X   X  or  X   X   X  X   X  Definition 6: Travel Time. A driver  X   X  X  travel time on a road segment  X  in time slot  X  is defined as  X   X , X , X  denotes  X   X  X  travel time on path  X  in time slot  X  . Figure 2 presents the framework of our model which is comprised of two major parts. In the above part, we project each trajectory received in a current time slot onto a road network, using a map-matching algorithm [21]. The trajectories (combined with road network data) are then used to construct a 3D tensor  X   X  where the three dimensions stand for road segments, time slots and drivers, respectively. Each entry is the travel time of a partic ular driver on a particular road segment in a specific time slot. We partition a day into several time time slots with 30 minutes each in the experiments). Clearly, the tensor is very sparse (i.e., having many entries without values), as a driver can only travel a few road segments in a time slot. To deal with the data sparsity problem, we ex tract three categories of features, consisting of geospatial, temporal, and historical contexts, from the road network data and trajectories. The first two feature sets are stored in two matrices, respectively, and the historical context is represented by another tensor  X   X  . The two matrices and  X   X  with  X   X  collaboratively, helping fill  X   X   X  X  missing entries in a current time slot (i.e., inferring the travel time of road segments without being that road segments with similar contexts could have a similar travel time. The context matrices and tensor reveal the similarity and with a more proportion of non-zero entries than  X   X  , thereby reducing the factorization error and improving the inference accuracy. After filling any road segment in current time slot (stored in  X   X  X  X  X  ). In the bottom part, given a query path  X  , we estimate its travel time in time slot and trajectory patterns. Specifically, we devise and prove an objective function that can represent the tradeoff between the length and support of a trajectory pattern. Based on the objective function, we find the most optimal concatenation of trajectories for a path, using a dynamic programing approach. In practice, it is not necessary to try every possible concatenation of a path, as some sub-paths have never been traversed by any trajectory. So, we mine frequent trajectory patterns from historical trajectories in advance and study the concatenation of these existing patterns to estimate the travel time of a path. This reduces the online computational loads significantly, while guaranteeing accuracy in travel time estimation. Note that we are not using the historical travel time of a trajectory pattern. The patterns just provide us with candidate schemes of subpaths for finding an optimal concatenation of a path. Each trajecto ry pattern X  X  travel time in current time slot is mainly calculated based on the trajectories received in the time slot. If a pattern contains road segments without being traversed from  X   X  X  X  X  , according to the driver, road segment and time slot. For instance, two drivers (  X   X  ,  X   X  ) travelled  X   X   X  X   X   X  trajectory data, while  X   X  we retrieve the latter two from  X   X  X  X  X  , calculating With  X   X  X  X  X  , we can estimate a driver X  X  travel time on a trajectory pattern even if the recently received data is incomplete. The dimension of drivers in  X   X  X  X  X  enables us to calculate the variance among different drivers X  travel times on a road segment or a sub-path. Intrinsically, different drivers travel the same road segment with different times, majorly de pending on the different traffic conditions they experience. Thus, the variance implies the complexity of traffic conditions on a road segment or a sub-path, helping estimate a more accurate travel time of a path (elaborated in Section 4.1). Finally, the travel time of a path is calculated as: Where  X  is the concatenation of path  X  , represented by a set of trajectory pattern  X  X  s;  X  is a collection of drivers traversing (or partially traversing) a  X  X  ;  X  is the current time slot. To model the traffic conditions of the current time slot, we construct a tensor  X   X   X  X   X  X  X  X  X  X  X  , with the three dimensions standing for road segments, driver s and time slots, respectively, based on the GPS trajectories received in the most recent  X  time slots and the road network data. As shown in Figure 3, an entry  X   X   X   X , X , X   X   X  X  denotes the  X  th road segment is traveled by the  X  th time slot denotes the present time slot, combined with the  X  -1 time slots right before it to formulate the tensor. Clearly, the tensor is very sparse as a driver can only travel a few road segments in a short time period. If we were able to fill in the missing entries in terms of the values of non-zero entries, we can know the travel time of any driver on any road segment in the present time slot. A common approach to this problem is to decompose a tensor into the multiplication of a few (low-rank) matrices and a core tensor (or just a few vectors), based on the tensor X  X  non-zero entries. For example, we can decompose  X   X  into the multiplication of a core tensor  X  X  X   X   X   X  X  X   X   X  X  X   X  and three matrices,  X  X  X   X   X  X  X  X   X  ,  X  X  X   X  X  X  X   X  , if using a tucker decomposition model. An objective function is defined as E quation 2 to control the errors. where  X   X   X   X  denotes the  X   X  norm and  X  is a regularization of pena lties to avoid over-fitting;  X   X  are usually very small, denoting the number of latent factors.  X  is a parameter controlling the cont ributions of the regularization. Afterwards, we can recove r the missing values in  X  multiplying decomposed factors as  X   X  X  X  X   X  X  X  X   X   X  X   X   X  X   X   X  . In our problem, however, the tensor is over sparse. For example, if setting 30 minutes as a time slot, only 0.03% entries of  X  values. Decomposing  X   X  solely based on its own non-zero entries is not accurate enough. To this end, we build another tensor  X  based on the historical trajectories over a long period of time (e.g. one month). As shown in Figure 3,  X   X  has the same structure as  X   X  , while an entry  X   X   X   X , X , X   X   X  X  X  denotes the  X  th driver X  X  average Intrinsically,  X   X  is much denser than  X   X  , denoting the historical traffic patterns and drivers X  behavior on an entire road network. For instance, using one-month trajectories and setting 30 minutes as a time slot, the non-zero entries of  X   X  is about 0.4%. Decomposing  X   X  and  X   X  together reduces the error of supplementing  X  Besides  X   X  , we also construct another two matrices  X  and  X  to help the decomposition of  X   X  . Specifically, as illustrated in Figure 4 A),  X  X  X . X  ,  X  X  X . X  ,  X  X  X . X  ,  X . X  , the number of neighbors (e.g.,  X  and 3 neighbors) at its terminals, and a tortuosity ratio  X  (e.g.  X   X  X  X .  X   X   X  X  X .  X   X  ), as well as the distribution of Point of Interests (POIs)  X   X  around  X   X  X  terminals. While  X  captures the similarity between different road segments in geographic spaces, matrix  X  (consisting of  X   X  and  X   X  ) represents the correlation between different time slots in terms of the coarse-grained traffic conditions. More specifically, we partition a city into disjoint and uniform grids (e.g., 4  X  4 in Figure 4 B), each of which is comprised of many road segments.  X   X  is built based on the recent trajectory data received from  X   X  to  X   X  (e.g., 1pm-3pm), reflecting the present traffic conditions on a road network. An entry of  X   X  denotes the number of vehicles traversing a particular grid in a particular time slot. A row of  X   X  represents coarse-grained traf fic conditions in a city of a particular time slot. Consequently, the similarity of two different rows indicates the correlation of traffic flows between two time slots. Additionally, in contrast to using the traffic flow on each individual road segment in  X   X  ,  X   X  can be filled densely, therefore can help reduce the error of decomposing  X   X  .  X  structure as  X   X  , storing the historical average number of vehicles traversing a grid from  X   X  to  X   X  . In other words,  X  respectively correspond to the coarse-grained current and historical traffic conditions in the same span of time of day. In the implementation, we build  X   X  and  X   X  of an entire day in advance and retrieve the entries according to current time (and the number of time slots  X  needed) when constructing  X  and  X  . For example, as shown in Figure 4 C), the rows from  X   X  to  X   X  the prebuilt  X   X  to construct  X  with  X   X  . To achieve a high accuracy of decomposition, we put together  X  and  X   X  (i.e.,  X  X  X  X   X  ||  X   X  , as shown in Figure 3), decomposing  X  with context matrices  X  and  X  collaboratively. The objective function is defined as Equation 3, where  X  X  X   X  X  X  X  X  X  X  X  X  and  X  X  X   X  X  X  X  X  X  ,  X  denotes the number of grids;  X  X  X   X  X  X  X  ,  X  denotes the dimension of geographical features;  X  X   X   X  X  X  X  X  X   X  ,  X  X  X   X   X   X  X  X  ,  X  X  X   X  X  X  X   X  and  X  X  X  are low rank latent factor matrices for time slots, grids, roads and geographical features. Later, we can recover  X  according to  X   X  X  X  X   X  X  X  X   X   X  X   X   X  X   X   X  .  X   X  ,  X   X  , and  X   X  are parameters controlling the contribution of different parts. In our model,  X  and  X  shares matrix  X  , and  X  and  X  share matrix  X  . The dense representation of  X  and  X  helps generate a relatively accurate  X  and  X  , which reduce the decomposition error of  X  in turn. Additionally, the combination of  X   X  and  X   X  current coarse-grained traffic condition deviates from its historical patterns. The information of the deviation is then propagated to  X  , helping figure out the fine-grained deviation between current traffic conditions and historical traffic patterns on each road segment. So, our model considers both geospatial and temporal correlations. It also incorporates the knowledge fr om present and historical traffic data. As there is no closed-form solution for finding the most optimal result of Equation 3, we use a numeric method, gradient descent, to find a local optimizatio n, as presented in Figure 5. The Symbol  X   X   X  denotes the matrix multiplication;  X   X  stands for the tensor-matrix multiplication, where the subscript  X  stands for the direction, e.g.,  X  X  X  X  X   X   X  is  X   X  X  X  X   X   X   X   X  X  X  X   X  X  tensor outer product (also called Kronecker product); t he entries of the  X  th row of matrix  X  are represented as  X  specifically, we use an element-wise optimization algorithm (instead of batch decomposition) [10], which updates the factors independently (meaning they ca n be performed in parallel). In reality, tensor  X  is very large, given hundreds of thousands of road segments and tens of thou sands of drivers. Decomposing such a big tensor is very time consuming, therefore reducing the feasibility of our method in pr oviding online services. To address this issue, as illustrated in Figure 6, we partition a city into several disjoint regions, building a tensor for each region based on the data of the region. The matrices  X  and  X  are built in each smaller region accordingly. By setting a proper splitting boundary, we try to keep these small tensors a similar size. As a result,  X  is replaced by a few small tensors, which will be factorized in parallel and more efficiently. We validate (in later experiments) that the partition does not compromise the accuracy of the original decomposition when choosing a proper number of partitions. Given a path  X  covered by trajectories, we need to find the best concatenation that results in an accurate travel time estimation. Intuitively, the best decomposition is the one that achieves the lowest empirical risk between the estimate and true travel time  X  Suppose  X  is decomposed as  X   X   X ||  X   X || X ||  X  , where the estimated travel time is  X   X   X  then wrote as, Hence, our problem is to search for the best concatenation which yields the least empirical risk, formally defined as, To come up with a computable form of  X  X  X   X , X  time of sub-path  X   X  . It is fair to assume if  X  X  X  X  then  X   X   X  X   X   X  X  X  X   X   X  X  X   X   X  X   X   X   X   X  X  X   X  If assuming  X   X   X   X   X   X  X  X  X   X  Further,  X  X  X   X  where  X   X  the  X  th driver X  X  travel time on  X   X  ;  X  X  X  X  X   X  these drivers X  travel times. Then, Equation 5 can be represented as: Equation 8 well reflects the aforementioned tradeoff between the support and length of a concatenatio n. On one hand, it is easier to find more drivers traveling a shorter sub-path. The more the drivers pass a sub-path (i.e. support is higher,  X  smaller the error of the inferred travel time is. On the other hand, the shorter a sub-path is, the bigger the variance in travel time would be. There are a lot of uncertainties of traveling a short path. E.g., if only traveling one road segment, the travel time will be significantly influenced by a tra ffic light. As a result, different drivers X  travel times could be dramatically different. To solve the optimization problem shown in Equation 8, we propose a dynamic programing solution. Suppose a path  X : X   X   X  X  X  X   X  ,  X  X  X  X   X   X  X   X   X  X  X  X   X  ,  X  X  X  , denote  X   X   X   X   X  X  X  X  X   X  represented as Equation 9. Let  X  X  X   X  be the minimal value of  X  X  to the above problem, then the minimal value of the squared empirical risk function of  X  is  X  X  X  Additionally, we have a state tr ansition function as Equation 10. Using Algorithm 2 shown in Figure 7, we solve this problem with a complexity of  X  X  X   X   X  X  X  X  , where  X  is the number of road segments in  X  and  X  is the number of drivers passing a segment. In practice, it is not necessary to check every concatenation of a path, as many sub-paths may not be traversed by any trajectory in the current time slot. To further improve the efficiency of our solution, we mine frequent trajectory patterns from historical trajectories in advance. Then, we just need to check the concatenation of the trajectories patterns. Specifically, we can stop the iteration at Line 4 in algorithm 2 if  X   X  is not a trajectory pattern. We use a suffix-tree-based algorithm [18] to find the frequent trajectory patterns. Specifically, after being map-matched, a trajectory can be regarded as a string of road segment IDs. By building a suffix tree, where a node denotes a road segment ID, a trajectory is then represented as a path on the tree. For example, the four trajectories shown in Fi gure 1 can be represented as the tree depicted in Figure 8 A), where  X   X   X  X   X   X  X   X  path of the tree.  X   X   X  X   X  and  X   X  are suffixes of  X  number associated with each link stands for the number of the trajectories passing the path (i.e., the support). If setting 2 as a the suffix-tree is built based on hist orical trajectories over a long period of time. As long trajectory pa tterns are very rare, we set the maximum length of a pattern to 20 road segments. Note that a query path may have some road segments that are not traversed by any trajectory in the current time slot, though these segments may belong to a trajectory pattern (in history). Following the example shown in Figure 1, we demonstrate in Figure 8 B) how  X   X  X  X  X  is used with trajectory pattern s to help the decomposition of a query path. To estimate the travel time of a query path  X : X   X   X  X   X  in time slot  X  , we first search the suffix tree, which was built based on the trajectory data over a long history (not the one shown in the left part of Figure 8 A), for the trajectory patterns that  X  contains, e.g.,  X   X   X  X   X  and  X   X   X  X   X  . To calculate  X   X   X  defined in Equation 9, we need to know the travel time of each trajectory in time slot  X  . That is  X   X  driver, though  X   X  received trajectories, i.e.  X  X   X  ,  X  X   X  and  X  X   X  . To address this issue, we retrieve  X   X   X   X  X   X  , X , X  for  X  X  X  X  X   X   X ,  X   X ,  X   X  , respectively, by Equation 11. Having  X   X  according to Equation 9, 10 and Algorithm 2. When the supplement of an entry is negative, we resort to the historical average travel time. The dimension of users in tensor  X   X  enables us to retrieve a more accurate travel time for a particular driver, resulting in a better estimate of the variance of travel times (as Equation 8). We validate that this is more accurate than just using a historical average of travel times. After finding the most optimal concatenation, we calculate the travel time of path  X  by Equation 1, setting  X  In the implementation, if not building an effective indexing structure, we need to scan a tr ajectory when calculating the travel time of a path based on the trajectory (i.e., Line 11 of Algorithm 2). This becomes very time consuming if we need to repeat the process many times. To address this issue, we propose an indexing structure to maintain the trajectories received in the current time slot, as shown in Figure 9. The structure l ooks like the suffix tree we build for mining trajectory patterns. Howe ver, each node in the tree stores node and the corresponding travel time. For example,  X  X  shown in Figure 1 are stored in the index demonstrated in Figure 9, where  X   X  In this section, we evaluate the effectiveness and efficiency of the two major parts of PTTE, i.e., CATD and OC, respectively. Taxi Trajectories. We use a GPS trajectory dataset generated by 32,670 over 26,218,407km. The average sampling rate is 96 seconds per point. Road networks : We use the road network of Beijing, which is comprised of 148,110 nodes and 196,307 edges. The road network covers a 40  X  50km spatial range, with a total length (of road segments) of 21,985km. POIs : The dataset consists of 273,165 POIs of Beijing, which are classified into 195 tier two categories. We only chose the top 10 categories that occur around road segments most frequently. After projecting the trajectories onto the road network, we build  X   X  and  X   X  to model the recent and hi storical traffic conditions, respectively. We set four time slots (each time slot is 30 minutes) in the two tensors, as we find 4 have a good tradeoff between effectiveness and efficiency (see Figure 12 A). In the implementation, we remove the road segments that are traveled less than 50 times in two months (i.e., less than 1 time per entire day). The GPS points on such road segments may be noises, or due to the imperfect map-matching algorithm or such places cannot be traveled by vehicles (s uch as pedestrian streets), and therefore may not be really queried by drivers. Finally, 118,401 road segments are used in our models. We also build geographic and temporal contexts  X  and  X  based on the above mentioned datasets. Table 1 shows the statisti cs of these tensors and matrices, where the third row means  X   X  is partitioned into 25 sub-tensors. As shown in Figure 10 A), the maximum number of trajectories traversing a path (per day) decreases quickly as the length of the path increases. For instance, a path with 10 road segments is traversed by less than 245 trajectories per day. Figure 10 B) presents the number road segments traveled by taxis with different times. For example, from 8am to 9am, about 25,000 roads segments are traversed by taxis 1-2 times and 8,000 segments (about 4% of Beijing road network) are traveled 3-4 times. We compare PTTE with the following four baseline methods. 1) Speed-Constraint-based (SC) method. The travel time of each road segment is computed by the length of a road segment and its speed constraint. The travel time of a path is then a summation of that of each road segment. 2) Trajectory-based Simple Concatenation (TSC) method. TSC estimates the travel time of each road segment individually based on the trajectories passing the road segment in the most recent time slot. If a road segment is not covered by any recent trajectory, TSC uses the average historical travel time instead. The travel time of a path is then a summation of that of each road segment. 3) Optimal Concatenation with Historical Travel Time (OC+H) method. OC+H uses Algorithm 2 proposed in this paper to find the most optimal concatenation of trajectories to estimate the travel time of a path. For a road segment not covered by any trajectories, this method uses an av erage historical travel time of the road segment. 4) Optimal Concatenation with N onnegative Matrix Factorization (OC+MF). This method is simila r to OC+H, except for using MF (rather than historical average) to infer the travel time of segments without trajectories. MF is applie d to the road-time matrix, which is degraded from tensor  X  by averaging the driver dimensions. Comparing PTTE with the first baseline, we can demonstrate the advantages of using the trajec tory data. The second baseline method can reveal the contribution of the proposed optimal concatenation algorithm. Through comparing it with the third and fourth baselines, we can justify why a tensor with the driver dimension is needed in PTTE. Regarding CATD, the first step of PTTE, we study the contribution of using context matrices and historical data, respectively, in filling the missing values of  X  We randomly pick out 50 paths, each of which has been fully traversed by at least two drivers, in each hour of a day, from the taxi trajectory data. We then us e these paths as queries and the average travel time of these traj ectories as the ground truth. Once a trajectory is selected as a gr ound truth, we remove them from the training data. In total, we generate 12,384 queries, whose length ranges from 2KM to 16KM following the distribution as shown in Figure 11 B) and time span follows the distribution depicted in Figure 11 C). The total length of these query paths is 76,412.6km with an effective total time span of 2733.9hours. The queries selected in this way co ver different times of day (from 6am to 11pm) and follow the distance distribution of people X  X  true travel patterns in a city X  X  road ne twork. In the experiments, we do not study the query after 11pm and earlier than 6am, as there is almost no traffic at those times. In other words, people can travel as fast as the speed constraint of a road. According to Figure 11 A), these query paths (denoted as blue road segments) also cover the majority of the Beijing road network. We study the mean absolute error (MAE) and mean relative error (MRE) of an estimate according to Equation 12 and 13, respectively, where  X   X  is an estimate and  X   X   X  is the ground truth. To test the accuracy of estimating the travel time of road segments absent of trajectories, we randomly remove 30% of non-zero entries from the last time slice of tensor  X   X  . We then infer these entries with our method, using th eir original values as a ground truth to calculate MAE and RMSE, as shown in Table 2 (  X  =  X   X  =  X   X  = 0.01). RMSE is widely used to measure the error of a tensor decomposition, defi ned as Equation 14. Adding historical tr ajectories (i.e..,  X   X  ) and context matrices gradually into the tensor decomposition, denoted as TD+H and TD+H+C, respectively, we achieve a clear increase of performance in estimating the missing values. We further study the effectiveness and efficiency of CATD changing over the number of time slices in Figure 12 A). Adding more time slices into  X   X  and  X   X  achieves a more accurate estimate of missing values (i.e., the travel time of road segments without trajectories), as we have richer in formation of previous traffic conditions. On the other ha nd, more time sl ices consume a longer time. We find that formulating a tensor with 4 time slices is a relatively strong tradeoff between effectiveness and efficiency. However, the time cost for d ecomposing such big tensors and matrices (see Table 1) make s our method impractical for answering instant queries. As a consequence, we partition a city into disjointed regions, building individual tensors and matrices, separately and in parallel. Fi gure 12 B) shows the performance changing over the number of par titions. When dividing Beijing into 5  X  5 regions, we can finish CATD for each region in 6 minutes. The partition does not compromise the accuracy (only a 0.1min gap) as compared to d ecomposing the original tensors. Additionally, the tensor decomposition method we adopt can be performed in parallel, further reducing the time cost of CATD. Table 3 presents the overall performance of our model PTTE (i.e., CATD+OC) and baseline methods. Besides MAE and MRE, we also present the average error of travel time per km (MAE/L). For example, the average error of PTTE in estimating the travel time of a path is about 0.412min (25 seconds) per kilometer. Clearly, PTTE outperforms all the baselines in terms of the three metrics. Given the queries introduced in Section 5.1.3, on average, the absolute error of the estimated travel time is about 2 minutes per path, which is about 19% of the tr ue travel time. From the results, we can draw the following conclusions . First, using trajectory data (TSC) is much better than that only based on speed constraints of roads. But, simply concatenating the travel time of each individual road segment (TSC) is not an optimal solution. As we mentioned before, the more fragments involved in a concatenation, the more uncertain of travel time for crossing two consecutive fragments occurs is. Second, regarding estimating the travel time of road segments without covered by trajectories, using the historical average travel time (OC+H) is significantly better than using its speed constraint. Using a collaborative filtering model (OC+MF) is slightly better than using an historical average. The PTTE considering the driver dimension is even better than OC+MF. Figures 13 and 14 present the performance of SC, TSC, and PTTE changing over time of day, on weekdays and weekends. We do not show that of OC+H and OC+MF, as they almost follow the same trend as (but worse than) PTTE. As depicted in Figure 11, the error of SC increases tremen dously during peak traffic hours, around 8-9am and 6-7pm. The complex traffic conditions on roads at these moments deviate the true travel speed far from their speed constraints. When time goes to late night (i.e., no complex traffic conditions anymore), the error decreases and approaches our PTTE method. This is also the reason that we do not need to perform PTTE on late night time sets, especially after 12am and before 6am. Simply estimating the travel time for each individual road segment and then doing a su mmation (TSC) is not accurate enough. When there are not enough taxis traveling on Beijing X  X  road network, e.g., after 9pm a nd before 8am, MAE of TSC is higher than other time slots. With the help of CATD, the MAE of our method only increases slightly after 9am. This demonstrates the value of inferring the missing values. As most people do not drive to work on weekends, we observe different trends of the performance in Figure 14, in contrast to Figure 13. SC X  X  MAE reaches its peak around 6pm which is the weekend rush hour. The reason why PTTE has the biggest error around 9am on weekends is a tradeoff between the number of taxis and the complexity of traffic conditions in a road network. On weekends, the number of taxis traveling in Beijing X  X  road network is still very small at 9am, while the traffic conditions start becoming complex. As time goes by, more taxis are present on Beijing X  X  road network, alleviating the data sparsity problem and decreasing the MAE. Conversely, before 8am, the traffic condition is still very simple to predict on roads. The travel speed is almost close to the speed limit. Figure 15 shows the performance of PTTE changing over the length of a query path. As the length increases, both MAE and MRE decrease. A longer path is more likely to contain more trajectory patterns, which provide more choices for an optimal concatenation. This also echoe s the assumption we proposed in the introduction. The shorter a sub-path is the more unstable its travel time could be. In an extreme case, the travel time of a single road segment is terrifically impacted by traffic lights and pedestrians crossing it. So, the travel time varies in time quickly and tremendously, becoming hard to predict. Table 4 presents the time and space cost of PTTE X  X  two major components for processing the trajectories received in recent 30 minutes. The first component CATD is only performed once for the entire dataset, while OC is conducted for each query path. All numbers are obtained by only using a single core of a server with 2.80GHz Xeon CPU and 24GB RAM. For example, if we partition a city into 25 regions, building  X   X  and  X   X  for an individual region needs 44 and 233 seconds, respectively, costing 4.4MB and 14.6 MB of memory, respectively (each te nsor contains 4 time slices). Using Algorithm 1 to decompose these tensors with context matrices  X  and  X  needs about 6.31min for each region. We do not offline. In total, we can infer the travel time on each road segment for each particular driver within 6.4min if using 25 cores in a server. Note that Algorithm 1 is based on an entry-wised decomposition approach, which can be performed in parallel further. If using six 25-core servers, we can finish CATD in about 1 minute. In the optimal concatenation, we can pr ocess a query path in 2.3ms. However, the time is much longer if the trajectory patterns and the real-time indexing structure proposed in Figure 9 are not used. Figure 16 A) shows the tradeoff between effectiveness (measured by MAE) and efficiency (by time cost) of using trajectory patterns in optimal concatenations, where the horizontal axis denotes the threshold of support. For example, if setting 400 as a threshold, we regard a path as a trajectory pattern if the path has been covered by over 400 trajectories in the two-mont h dataset. The bigger threshold is the smaller number of trajectory patterns we can obtain. So, the time cost decreases and the MAE increases, as the support increases. Additionally, as depicted in Figure 16 B), setting a smaller support threshold leads to a bigger size of the suffix-tree-based index for trajectory pattern mi ning. In the implementation, we find 500 is a good tradeoff among MAE, time cost, and index size. Note that without using the indexing structure proposed in Section 4.3, we need about 12 seconds to find the most optimal concatenation for a query path (see Table 4). The recovered tensor  X   X  X  X  X  helps the optimal concatenation significantly. In the experiments, we test our model with 12,384 query paths, which are comprised of 217,326 road segments in total. When processing the query paths, we access tensor  X   X  X  X  X  1,706,648 times (i.e., 137.8 times per query) to retrieve the missing travel time of a road segment in a trajectory pattern. The travel times of 58,223 road segments (about 26.8% of the road segments in the query paths) are finally retrieved from  X   X  X  X  X  for constructing the most optimal concatenation, i.e., 4.7 road segments per path. We study the performance of PTTE changing over different number of vehicles in Figure 17, aiming to figure out how many GPS equipped vehicles are needed to have accurate results. For example, using 30,000 GPS-equi pped vehicles in Beijing is enough to achieving a MRE smaller than 0.23. In other words, if having 1.36 vehicles on every kilometer road in a city, we can achieve a relative error of estimation smaller than 0.23. Besides using GPS trajectories from taxi drivers, we also send two drivers carrying a GPS logger to test the accuracy of our method from Sept. 1 to Oct. 30. Finally, we collect 114 driving paths with a total length of 999.4km and an effective total time period of 61.6hours. The sampling rate of these GPS trajectories is 5 seconds per point. Table 5 show s the performance of the study, where we observe a better MRE than using taxi drivers X  trajectories as a ground truth. The major reason is the length of a path collected in the study is usually long (on average 8.78KM each), where our model has a better accuracy than a shorter path. Additionally, the map-matching for high sampling rate trajectories is more accurate than low sampling rate taxi trajectories, resulting in a more accurate estimation of the ground truth. Approaches using Loop Detectors: Estimating travel time based on loop detectors installed on both endpoints of a road segment has been studied intensively over the past few decades. When a vehicle passes through, the time interval for crossing two adjacent loop detectors is recorded, based on which the speed of the vehicle is inferred. [9, 14, 16] use various models to estimate the travel speed on an individual road segment based on the sensor readings from loop detectors, and then convert the speed into a travel time. [19] predicts the travel time of a road segment by applying support vector regression to its historical travel times. As many roads do not have a loop detector buried, this category of research mainly focuses on individual road segments, and therefore is difficult to scale up to an entire city. Floating-Car-Data Approaches: Learning city transportation using floating car data has gained more attention recently [1, 5, 17, 23, 24]. In these approaches, cars driven in a city serve as dynamic sensors to probe traffic conditions, and their GPS trajectories are used to compute the speed and travel time on road segments. Most methods infer the travel time of an individual road segment without considering the correlation betw een the traffic conditions on different roads. This reduces the accuracy of an inference in an urban environment where traffic conditions are inter-related. Some models [2] predict the travel speed of a road segment by considering the traffic patterns of other road segments connected to it. Unfortunately, when scaling up to an entire city, these methods often result in a m odel with high complexities. Additionally, they do not tackle th e data sparsity problem, i.e. many road segments are not traveled by trajectories in the current time slot, which is quite comm on in reality. The neighboring segments X  traffic patterns can be regarded as the local correlation between road segments. However, the correlation between road segments that are not geospatially connected is not considered in these modes. [8] aims to estimate the travel time between two points on a road network using low sampling rate trajectory data. It considers the correlation between different road segments in terms of their historical traffic patterns to infer the travel time on a road segment and the delay at intersections. The model is trained using a Maximum Likelihood Estimation over the collected data in an urban road network. However, these methods still follo w the idea of first estimating the travel time of individual road segments and then summing up the travel times of the road segm ents belonging to a path. As we mentioned before, it is difficult to explicitly model the complex factors for crossing two road segments, e.g., intersections, direction turns, and traffic lights. Though we also infer the travel time for individual segments, the time is combined with trajectory patterns to formulate a sub-path rather than simply concatenating them one by one. The variance of different users X  travel times also captures the complexity of traffic conditions on a road segment or a sub-path. In the meantime, when inferring the travel time of a road segment, we incorporate both spatial correlation between different road segments and the temporal correlation between the traffic conditions of different time slots, as well as the deviation between current traffic conditions and historical traffic patterns. A possible approach to deal with the weakness of the individual road segment-based methods is to estimate the travel time of a path as a whole based on frequent trajectory patterns. For example, we can mine frequent patterns from hist orical trajectories [6, 7, 12] in advance, and then use the average travel time of a pattern to represent the travel of the path corresponding to the pattern. Some models can also be built based on the historical data of a path [15] to estimate the future travel time of the path. This approach needs a balance between the coverage of queries that it can answer and the accuracy of the inferred travel time. To be able to answer various query paths, these methods need to select more trajectory patterns by using a small support. However, the travel time derived from a small support is not accurate. Additionally, a path X  X  travel time of current time slot may deviate from its historical average significantly, depending on the real-time traffic conditions. Moreover, many query paths may not be traversed by any trajectories in current time slot as well in the history. Recent research has started finding more optimal concatenations of road segments to estimate the travel time of a path. A series of research attempts to explicitly calculate the time spent on intersections using an interpolation method [11], or a joint probability model [3], or a dynamic Bayesian network [4]. This could result in a more accura te summation of individual road segments X  travel times. However, these methods do not study how to leverage sub-trajectories to co nstruct an optimal estimation of a path. As we mentioned before, th e accuracy of estimating a sub-path X  X  travel time is subject to the tradeoff between its length and the number of trajectories passing the sub-path. In our model, we propose and prove an objective function that can represent the tradeoff. We also consider the variance of different drivers X  travel times, resulting in a more accurate travel time estimation of a path. Based on the trajectories generated by a large number of taxis, [20] builds a landmark graph, where a node (entitled a landmark) is a road segment frequently traveled by taxis and an edge denotes the aggregation of taxis X  commutes between two landmarks. The travel time of a path is then approximated by the summation of the travel times between landmarks . Though the proposed landmark graph can also deal with the data sparsity problem, the main goal of [20] is to find the quickest driving path between an origin and a destination; this is different from our problem. Knowing the shortest time for traveling betw een two points does not mean we can obtain the travel time of any path traversing the two points. In this paper, we propose a real-time and citywide model, called PTTE, to estimate the travel time of a path in current time slot in a city X  X  road network, using the GP S trajectories from a sample of vehicles (e.g. taxicabs). Though this is a very important foundation for many traffic monitoring and routing systems, the problem has not been well solved given three challenges: 1) data sparsity, 2) finding an optimal combination of trajectories (i.e., the tradeoff between the length of a sub-path and the number of trajectories passing the sub-path), and 3) the tradeoff between scalability, effectiveness and efficiency. PTTE is comprised of two major components, CATD and OC. The form er infers the travel time of a road segment without being traversed by trajectories in the current time slot through a context-awar e tensor decomposition approach. The latter searches for the most optimal concatenation of trajectories for a query path using a dynamic programing solution. We evaluate PTTE with extensive experiments based on GPS trajectories generated by over 32,000 taxicabs over a period of two months in Beijing. We test the effectiveness and efficiency of CATD and OC, respectively. First, the results demonstrate the advantages of CATD in accurately filling in the missing values beyond baseline methods, such as using speed constraints, or using a historical average travel time, or using a matrix factorization-based approach. The driver dimension in tensor  X  calculate the variance of different drivers X  travel times on a road segment. The variance indicates the complexity of a road X  X  traffic condition, helping us find the most optimal concatenation for a path. In addition, the geospatial/temporal contexts and historical traffic patterns increase the accuracy of estimating the missing values. Regarding the most optimal concatenation, we devise an objective function which has been proved to be able to model the tradeoff between a sub-path X  X  length and th e number of trajectories passing it. Tested by 12,384 query paths, PTTE achieves a mean absolute error of 0.4min per km, which is about 19% of the truth travel time. The results of the in-the-field study have an even smaller estimation error (11.6%). Using the suffix-tree-based indexing structure to manage the trajectories received currently and the trajectory patterns (mined in advance) to scale down the concatenation candidates, on average, we are able to infer the travel time of a path in 2.3ms. The codes and a sample of the data used here have been released at [25]. In the future, we plan to infer the travel time of a path for a particular driver. In addition, we would like to study the impact of other factors, such as weather conditions and air quality, on the travel time estimation of a path. 
