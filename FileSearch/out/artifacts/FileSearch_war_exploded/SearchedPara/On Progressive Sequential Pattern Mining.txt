 When sequential patterns are generated, the newly arriving patterns may not be identified as frequent sequential patterns due to the ex-istence of old data and sequences. In practice, users are usually more interested in the recent data than the old ones. To capture the dynamic nature of data addition and deletion, we propose a general model of sequential pattern mining with a progressive database. In addition, we present a progressive concept to progressively dis-cover sequential patterns in recent time period of interest . Categories and Subject Descriptors: H.2.8 [Database Applica-tions]: Data mining General Terms: Algorithms, Management Keywords: Sequential patterns, Progressive
Sequential pattern mining was first addressed in [1]. Depend-ing on the management of the corresponding database, we propose a general model of the sequential pattern mining, defined as "pro-gressive sequential pattern mining" in this paper. The sequential pattern mining with a static database finds the sequential patterns in the database in which data do not change over time [1] [2]. On the other hand, the sequential pattern mining with an incremental database corresponds to the mining process where there are new data arriving over time (i.e., the transaction database is incremen-tal) [3] [4]. As for our proposed model, the progressive sequential pattern mining deals with a progressive database, which not only adds new data to the original database, but also removes obsolete data from the database simultaneously. Therefore, one can find the most up-to-date sequential patterns without being influenced by obsolete data. It is noted that the sequential pattern mining with a static databaseandwithanincremental database are both special cases of the progressive sequential pattern mining.

The assumption of having a static database may not hold in prac-tice. The data in real world change on the fly. Moreover, finding sequential patterns in an incremental database may lack of interest to the users. The incremental mining algorithms do not consider the deletion of the obsolete data from the sequence database. It is noted that users are usually more interested in the recent data than the old ones. Therefore, when new sequential patterns are generated, the new patterns which appear frequently in the recent sequences may not be considered as frequent sequential patterns because never reduced. In view of this, the infrequent sequential patterns whose timestamps are obsolete should be removed. To remedy this, we propose in this paper the concept of period of interest . The period of interest can be defined as follows.
 Definition 1: Period of interest (abbreviated as POI )isaslid-ing window, whose length is a user-specified time interval, con-tinuously advancing as the time goes by. The sequences having elements whose timestamps fall into t his period, POI, contribute to the | Ge | for current sequential patterns. On the other hand, the sequences having only elements with timestamps older than POI should be pruned away from the sequence database immediately and will not contribute to the | Ge | thereafter.
 Example 1: Consider the progressive database in Figure 1 for ex-ample. V 01 , V 02 , === , Vq represent different sequence IDs. D , E , F and G are different items in the database and w 1 , w 2 sent timestamps. As the time advances, there will be more elements arriving into the progressive database. Every sequence contains a series of elements appearing at different timestamps. Each element consists of a single or multiple items. For instance, sequence V has element D at timestamp w 1 ,element E at timestamp w 2 ment F at timestamp w 4 and element ( DG ) at timestamp w the bottom of Figure 1, Ge s&gt;t represents a subset of the database containing the elements from timestamp s to timestamp t .Letthe minimum support threshold, plq _ vxs ,be 0 = 5 and the POI be time intervals in this example. As shown in the left side of Figure 1, the shadowed field indicates the first POI, Ge 1 &gt; 5 sequences having elements in this period. Therefore, the minimum frequency for a frequent sequential pattern is | Ge 1 &gt; 5
W 0 = 5=2 = 5 . We can find a frequent sequential pattern DE , whose occurrence frequency is 3 (in V 01 , V 02 and V 03 ) in the first POI. However, after this POI, DE is no longer a frequent sequential pat-tern in any POI of 5 time intervals.  X 
In order to cope with a progressive database efficiently, we de-sign an algorithm to progressively read elements at the same timestamp, update the information of each sequence, and generate frequent se-quential patterns. The basic idea is to maintain a PS-tree ,which stands for Progressive Sequential tree , to keep the information from one POI to another. In PS-tree , we progressively update the nodes, which represent elements in the sequence, based on the sequence IDs and timestamps recorded in the nodes and the newly arriving data of the progressive database at each timestamp. PS-tree not only stores the elements and timestamps of sequences in each POI, but also efficiently accumulates the occurrence fre-quency of every candidate sequential pattern at the same time. Un-like the conventional static sequential pattern algorithms, which have to re-mine sequential patterns separately when the sequences in a progressive database changes, our proposed algorithm outper-forms companion methods in execution time by orders of magni-tude with the help of PS-tree .
The input of the progressive sequential pattern mining problem is the user-specified length of POI and an user-defined minimum support threshold. An element h \ I is a set of items appearing in a sequence at the time, wlphvwdps . A sequence in a sequence database Ge is a set of elements ordered by wlphvwdps ascen-dantly. To address those issues mentioned in the previous section, we introduce a time interval, denoted by [ s&gt;t ] , to represent the pe-riod between timestamp s and timestamp t . Therefore, Ge s&gt;t defined as a subset of database Ge containing the elements of se-quences from timestamp s to timestamp t . Furthermore, as defined in the previous section, the period of interest (abbreviated as POI) is a sliding window, whose length is a user-specified time interval, continuously advancing as the time goes by. The sequences having elements with timestamps falling into this period contribute to the |
Ge | of current sequential patterns. The problem we address can be described as follows.
 Definition 2: Progressive sequential pattern mining problem is "Given a user-specified length of period of interest and a user-defined minimum support threshold, find the complete set of fre-quent subsequences whose occurrence frequencies are greater than or equal to the minimum support times the number of sequences in the recent period of interest of a progressive database." The nodes in PS-tree can be divided into two different types. They are Root node and common nodes. Root node is the root of PS-tree containing nothing but a list of common nodes as its chil-dren. Each common node stores two information, say node label and a sequence list. The label is the same as one of the element in a sequence of the progressive database. The sequence list stores a list of sequence IDs to represent the sequences containing this element. Each sequence ID in the sequence list is marked by a corresponding timestamp. Whenever there are a series of elements appearing in the same sequence, there will be a series of nodes labeled by each element respectively with the same sequence IDs in their sequence lists. Then, the first node will be connected to the Root node and the second node representing the first element will be connected to the first node. The other nodes will be connected analogously. Note that in such a way, the path from Root node to any other node will represent the candidate sequential pattern appearing in this se-quence. The appearing timestamp for each candidate sequential pattern will be marked in the node labeled by the last element. If there is another sequence having the same pattern, the sequence ID will be inserted into the sequence lists of the nodes labeled by these elements on the path. On the other hand, if an element appearing in a sequence is obsolete, the corresponding sequence ID will be re-moved from the sequence list of the node. In addition, if a node has no sequence in the sequence list, it will be pruned away from PS-tree . Thus we can ensure that there are only up-to-date candidate sequential patterns in PS-tree .

The main idea of progressive sequential pattern mining is to uti-lize PS-tree to store all sequences from one POI to another. When receiving the elements at the arriving timestamp, say w +1 gorithm traverses the original PS-tree of timestamp w in post order (children first, then the node itself) to (1) delete the obsolete ele-ments from, (2) update current sequences in, and (3) insert newly arriving elements into the PS-tree of timestamp w . Then, the al-gorithm moves forward to the next timestamp until there is no newly arriving element in a progressive database. After process-ing the current timestamp, we have already generated all candidate sequential patterns of all sequences by appending elements to the nodes appearing at the previous timestamps. Then, if the number of sequence IDs in the sequence list is larger than the minimum support wlphv number of sequences in the current POI, the path from Root to this node will be outputted as a frequent sequential pattern. In this way, we can easily generate all frequent sequential patterns of timestamp w +1 . After the traverse, the original PS-tree of timestamp w becomes a new PS-tree of timestamp w +1 and all information needed for the following timestamps is updated. Be-cause the PS-tree combines the same candidate patterns together and all patterns do not have to store their prefix elements, PS-tree consumes smaller space. While traversing at a node in PS-tree , the algorithm copes with all sequences having this pattern together. Only the sequential patterns that are not in PS-tree have to be cre-ated. Therefore, our proposed model is time and space ef ficient.
We addressed the problem of progressive sequential pattern min-ing and proposed a progressive sequential tree, PS-tree ,tohandle the progressive sequential pattern mining problem, which is a gen-eral model of the sequential pattern mining considering the man-agement of the corresponding database. PS-tree is very time effi-cient in that we need only one scan of the candidate structure main-tained by PS-tree at each timestamp rather than quadratic scans. Therefore, our proposed model shows great superiority over the al-gorithms that do not have progressive mining ability.
 Acknowled ge men ts
The work was supported in part by the National Science Council of Taiwan, R.O.C., under Contracts NSC93-2752-E-002-006-PAE. [1] R. Agrawal and R. Srikant. M ining sequential patterns. Proc. of [2] J. Ayres, J. Gehrke, T. Yiu, and J. Flannick. Sequential pattern mining [3] H. Cheng, X. Yan, and J. Han. Incspan: Incremental mining of [4] S. Parthasarathy, M. J. Zaki, M. Ogihara, and S. Dwarkadas.
