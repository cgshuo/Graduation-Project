 We propose a novel conception language for exploring the re-sults retrieved by several internet search services (like search engines) that cluster retrieved documents. The goal is to offer users a tool to discover relevant hidden relationships between clustered documents.
 The proposal is motivated by the observation that visualiza-tion paradigms, based on either the ranked list or clustered results, do not allow users to fully exploit the combined use of several search services to answer a request.
 When the same query is submitted to distinct search ser-vices, they may produce partially overlapped clustered re-sults, where clusters identified by distinct labels collect some common documents. Moreover, clusters with similar labels, but containing distinct documents, may be produced as well. In such a situation, it may be useful to compare, combine and rank the cluster contents, to filter out relevant docu-ments. In the proposed language, we define several oper-ators (inspired by relational algebra) that work on groups of clusters. New clusters (and groups) can be generated by combining (i.e., overlapping, refining and intersecting) clus-ters (and groups), in a set oriented fashion. Furthermore, several ranking functions are also proposed, to model dis-tinct semantics of the combination.
 H.2.3 [ DATABASE MANAGEMENT ]: Languages; H.2.1 [ DATABASE MANAGEMENT ]: Logical Design -Data Models; H.3.3 [ INFORMATION STORAGE AND RE-TRIEVAL ]: Information Search and Retrieval Languages, Theory, Algorithms Search Service, Web Documents, Exploratory Search, Query Languages
One main deficiency with current web search services, is the inadequacy of the list of ranked documents which they offer to access documents retrieved by a query. It is known that users usually do not analyze documents ranked in the low positions of the ordered list, even when the search engine has retrieved only hundreds of documents. Thus, if users do not find what they are looking for in the first one or two result pages, they are more keen to reformulate a new query or to try with another search service, than to analyze successive pages.
 The motivation of using meta search engines, such as mamma , dogpile , Metacrawler etc., is the claimed or assumed greater effectiveness of these systems, w.r.t. single search engines, in retrieving relevant web documents in the first results to augment the number of retrieved documents, which will be hardly analyzed by users; thus, this makes useless much of the meta search engine X  X  effort. To overcome this prob-lem, some search services such as vivisimo , clusty , Snaket , Ask.com 1 , MS AdCenter Labs Search Result Clustering etc., have shifted from the usual ranked list to the clustered re-sults paradigm. This consists in organizing the documents retrieved by a query into containers (i.e., clusters), seman-tically homogeneous w.r.t their contents, and in presenting them labelled, so as to synthesize their main content focus.
Clustering is often proposed as a viable way of narrowing a search into a more specific query, like in Ask.com . Besides search engines, also several news services provide overviews of incoming news streams clustered into news stories, as an alternative to the ranking of news depending on their date.
W.r.t. the ranked list, the clustered results paradigm has the advantage of offering users an overview of the main top-ics dealt with in the whole set of retrieved documents, that would be missed in the first few pages of the traditional ranked list [2, 15, 6]. On the other side, one problem users encounter with such clustered results, is the inability of fully appreciating the contents of the clusters. This is mainly due to the short and sometimes bad quality of the labels of the clusters, which generally consist of a few terms, or
At www.ask.com/reference/dictionary/49514/cluster individual short phrases, which are automatically extracted from the documents of the cluster based on statistic and co-occurrence analysis. Often, several clusters have similar la-bels which differ just for a single term. To effectively explore the cluster contents, users have no other means than clicking on the cluster labels and browsing the clusters themselves. This problem is much more apparent when submitting the same request to distinct search engines, each one producing a group of clustered results reflecting distinct criteria. For example, the Gigabits search engine clusters retrieved docu-ments by their freshness dating (Last Day, Last Week, Last Month, Last Year, etc.), the Dmoz search service presents classified documents. In such a situation, one may want to explore if a given category contains documents that are fresh or not; this necessity may occur quite frequently in analyzing news streams (RSS) to find out the frequency of a given news story reported by media as a function of time. When the groups of clusters are generated by distinct search services, users may be faced with distinct clusters possibly with same labels. In this situation, it becomes necessary to explore the relationships between the contents of these clusters to identify common and distinct documents. But the task so far described is, in effect, an exploratory task, that may last for a long time, and may require to reuse the intermediate results several times. For this reason, we can conceive the storing of the intermediate results into a database as an essential phase for successive manipulation. Furthermore, the local manipulation of results avoids useless network and search services overloading; in fact, in current practices, several modified queries are submitted to the s.e., trying to capture relevant documents in the first positions of the ranked list, documents that were already retrieved by the previous queries, although hidden to the user since they did not occurred in the first position.

In this contribution we propose a novel conception lan-guage for aiding users in flexibly exploring groups of clus-tered results retrieved by one or several search services (ba-sically s.e.) over the internet, so as to make them able to reveal implicit relationships. In our view, the usual ranked list produced by search engines, is regarded as a single clus-ter X  X  group that has the query itself as label. Thus, our language can be used to compare the results of any search service producing ranked lists too. The language is novel for several reasons: first of all, for the scope for which it is defined; second, for the objects on which it operates, i.e., groups of clusters of web documents; third, for the types of operators defined in it.
 In the literature, no similar approach has been proposed till now. We think that users, by manipulating groups of clustered results through the operators of this language, can fully benefit of the results of search engines. The language can be particularly useful when one needs to explore and analyze the results produced by several search services to identify and then select relevant documents. Furthermore, our language can be used to realize a database support for a multi-service document retrieval system: its operators are closed w.r.t. the data model, and allow to write com-plex analysis and transformation expressions, whose results are stored and retrieved for further needs. In this paper we introduce and formalize a first set of operators whose completeness, actual utility and effectiveness for exploratory analysis, will be the subject of future users X  evaluations.
The paper is organized as follows. In Section 2 the con-cepts of the data model are defined. In Section 3, an example of possible use of this language is discussed in the context of tourism. In Section 4, the basic operations between clusters are introduced, while in Section 5 and 6 the group operators and the functions on groups are formalized, respectively. In Section 7 the related works are reviewed and, the conclusions summarize the main contents. In this section we define the data model of our language. Consider a query q submitted to a search engine; the query result is a ranked list of documents, named ranked items . Definition 1 : Ranked Item A ranked item r represents a document retrieved by a web search. It is defined as a tuple where: uri is the Uniform Resource Identifier of the ranked web document; title and snippet are the document title and snippet 2 ; irank is a score (in [0 , 1]) proportional to the rele-vance of the retrieved document w.r.t. the query. 2
The same document is represented by distinct items in distinct results lists. In facts, we assume that a document is uniquely identified by its uri [4] (near duplicates are not de-tected), while it may have distinct snippets and irank when retrieved by different search services. We assume that irank is a function of the position of the item in the query result list.
 Definition 2 : Cluster A cluster representative c is a set of ranked items, having itself a rank. It is defined as a tuple where: label is a set of terms that semantically synthesizes the cluster X  X  content; crank is a score (in [0 , 1]) depending on the ranks of the items belonging to the cluster; items is the set of ranked items belonging to the cluster. With | c | X | c.items | we denote the cardinality of the cluster.
A cluster label c. label is automatically generated by a function SynthLabel ( c. items ) 3 .

A cluster has initially a natural rank. When a cluster be-longs to a group generated by one operators of the language, its rank can have a different semantics corresponding to the ranking method that the operator support.
 Definition 3 : Group A group g is a non empty and ordered set of clusters representatives. It is the main element of the data model and it is defined as a pair: in which l is the label of the group, automatically gener-ated by a function SynthLabel , and  X  c 1 ,...,c n  X  is the list of clusters representatives.
 A special kind of group is the empty group g 0 := ( l,  X   X  ). This group can be explicitly generated by the user through the function CreateQuery (see Section 6). 2
The snippet is an excerpt of the document, made by a set of sentences that contain the keywords of the query
Function SynthLabel ( R ) generates a representative label from the set of ranked items R (or ranked clusters C in the case of a group), by extracting the most meaningful non-stopwords terms from within titles and snippets associated with items in R (from the clusters X  labels in the case of a group). The significance of a term is determined based on the occurrences of the terms.
A group g can contain a single cluster. Observe that a particular kind of cluster representative is the one that rep-resents the ranked list obtained as the result of a query q ; in this case, c. label = q .

For the sake of simplicity, in the remainder of the paper, we use the term cluster to intend cluster representative .
Let us suppose we want to visit Napa Valley; to plan the trip, we need to collect information about wineries, sites, close cities to reach, e.g., by car, as well as hotels and restau-rants. The search services provide a large set of documents concerning Napa Valley, so it becomes a hard task to find, among them, the most relevant ones for our goal. Conse-quently, it can be convenient to semantically characterize them, by organizing them in groups of semantically homo-geneous documents (clusters), and then to perform a kind of exploratory task , in which we try to combine the results of queries submitted to search services, in order to filter out the useful documents. This novel practice can be carried out lo-cally, thus minimizing the need of new remote searches, as it generally happens with current search services. The results obtained by analyzing and combining previously submitted queries can also inspire new more focused queries.

We start now a running example that we will use through-out the paper to clarify our approach and to explain the proposed language.
 Example 1: To start our search for information on Napa Valley, we submit the query "Napa Valley" to the s.e. Google , Yahoo! and MSN Live Search . To have a rapid glance at the main topics retrieved, the first N 4 top documents returned by each service are clustered. This is done on the basis of the documents X  snippets shown in the results pages. The labels of the obtained clusters are represented in Figure 1. 2
On the basis of these results, it could be interesting to apply some manipulations on the resulting groups, in order to filter out results more and more satisfying our needs.
For example, it may be interesting to keep in the groups only the most interesting clusters concerning some particu-lar contents (identified by the clusters X  label): in this way we reduce the whole set of documents to only those that really cover the desired aspects, thus saving time for their inspection.

Alternatively, it may be interesting to obtain new groups in which clusters are composed of: only the most reliable documents concerning the desired topics, such as Hotel or Hotel and Travel Guide ; all the retrieved documents which concern more general topics than the retrieved clusters; or only the documents regarding specific topics, even not ex-plicitly expressed by the labels of the clusters.

In the first case we can assume that documents recom-mended by all the search services are the most reliable ones.; thus we want to obtain highly specific clusters containing documents retrieved by all the search services. In the sec-ond case, we want to expand the resulting clusters of the previous operation, by grouping more documents concern-
N is a parameter specific for each search service
For the sake of readability, we show only a subset of the results useful to better explain our work. To cluster the results of each search service and to label the clusters, we applied the Lingo algorithm [10] ing the desired and related topics. Finally, in the last case, we want to obtain filtered sets of documents based on a more specific request.
 Notice that these manipulations should be carried out on the groups of clusters regardless of the positions of the items in the original retrieved list. It may happen that a cluster con-tains items retrieved in high and low rank positions, just because they are about the same topic.
 We may also be interested to have a re-ordering of the new clusters in the resulting group, based on some characteris-tics that may differ from the default one (initial ranking). To this aim the user can choose a different rank function w.r.t. the desired operator (see Section 5).

In the following sections, we will discuss the application of operators in the context of the running example.
In order to define the operators and functions that con-stitute the proposed language (introduced in Sections 5 and 6), it is necessary to define some basic operations on sets of ranked items and on cluster labels.

The basic operations that we are going to define work on two input sets of ranked items ( R 1 and R 2 ) and generate a new set of ranked items ( R 0 ).
 Definition 4 : Ranked Intersection: The operation RIntersect , denoted by  X  R , performs the intersection of two sets of ranked items. R 0 contains all ranked items r such that there are two ranked items r 1  X  R 1 and r 2  X  R which refer to the same uri . The irank of r 0 is defined as the minimum irank value of r 1 and r 2 .
 Formally: r 0  X  R 0 , if and only if there exists r 1  X  R r  X  R 2 such that: r .uri = r 1 .uri = r 2 .uri then r .title = Comb ( r 1 .title,r 2 .title,r 1 .irank,r 2 .irank,  X  ) r .snippet = = Comb ( r 1 .snippet,r 2 .snippet,r 1 .irank,r 2 .irank,  X  ); r . irank = min ( r 1 . irank ,r 2 . irank ). 2 r 0 . irank = min ( r 1 . irank ,r 2 . irank ) because it is the com-mon level of relevance of both the retrieved items in the web searches from which R 1 and R 2 are obtained. This definition is consistent with the definition of the intersection operation between fuzzy sets [14], where we regard R 1 and R 2 as fuzzy sets, and r 1 .irank and r 2 .irank as the membership degrees. Definition 5 : Ranked Union: The operation RUnion , denoted by  X  R , performs the union of two sets of ranked items.
 R 0 contains all ranked items r 0 such that there is a ranked item r 1  X  c 1 (resp. r 2  X  c 2 ) such that r 1 (resp. r 2 the same uri .
 Formally: r 0  X  R 0 , if and only if one of the following situa-tions occurs. 1) If there exists r 1  X  R 1 (respectively exists r 2 ist r 2  X  R 2 (respectively it does not exist r 1  X  R c . uri = c 2 . uri ( c 1 . uri ), then r 0 = r 1 ( r 0 = r case). 2) If there exist r 1  X  R 1 and r 2  X  R 2 such that: r .uri = r 1 .uri = r 2 .uri then
Function Comb in case of  X  select among the two input sting, the one with lower irank value; in case of  X  the one with the higher irank value. r .title = Comb ( r 1 .title,r 2 .title,r 1 .irank,r 2 .irank,  X  ); r .snippet = = Comb ( r 1 .snippet,r 2 .snippet,r 1 .irank,r 2 .irank,  X  ); r . irank = max ( r 1 . irank ,r 2 . irank ). 2
Differently from the case of  X  R , the irank of a ranked item r 0 in the result of  X  R is the maximum of irank values of items r 1  X  R 1 and items r 2  X  R 2 , because it represents the best level of relevance obtained by the retrieved items in both the web searches. This is also consistent with the definition of union of fuzzy sets by interpreting the irank as the membership degree.

The operations so far described can be implemented in documents in a cluster ordered by document uri , ranked intersection and ranked union can be implemented on the basis of a merge operation, whose complexity is O ( | c 1 Properties. The associative property and the commutative property hold for ranked intersection and union, as the reader can easily see.
 Clusters Labels. A cluster label is generated by function SynthLabel ( c.items ).
In this section we define an algebra for groups of clusters, by defining a set of operators.
A first operator we consider is the CQuery operator, that allows to submit a query to a given search service and cluster the results. It allows the start up of the process supported by the proposed language. It is defined as
CQuery : G  X  S  X { 0 , 1 } X  G + CQuery ( g,s,b )  X  g 0 where G is the set of groups, S is the set of names of available services, s is the service that evaluates the query q = g.l , b is a Boolean, while g 0 is the resulting group of clusters whose label g 0 .l = g.l . When the user wants to submit a query to a service for the first time (when no groups are available), the input group is an empty group generated by the function CreateQuery . We assume that a search service retrieves a maximum of N documents. On this basis, for each retrieved document, the operator builds a ranked item r , whose irank value depends on the position of the document in the result list: r. irank = ( N  X  Pos ( d ) + 1) /N (where Pos ( d ) is the position of the document in the query result list). In this way, a document in the first positions has a rank r. irank very close to 1.

In order to allow the user to submit a query to a search ser-vice without clustering the ranked list of document, he/she can specify b = 0 in input. In this case the resulting group g contains one single cluster, i.e., the trivial cluster that contains an item for each document retrieved by the search service. When b = 1 the results are clustered and labelled by function SynthLabel .
 Definition 6 : Natural Rank Each set of items R (and consequently, each cluster c ) has a Natural Rank (denoted as NRank ( R )) that is the average of ranks of items in the set. Formally The natural rank of a cluster c , that we denote simply by 2
This ranking method is the default one that reflects the ordering of the items retrieved by the search services.
Several simple manipulation operators on groups are ba-sically useful. The Cluster Selection operator  X  allows to select the clusters in a group.

It is defined as  X  ( g,P )  X  g 0 where g is the group whose clusters must be selected, and P is a predicate on positions of clusters in the group, or on cluster labels; the selected clusters maintain the original order.

Similarly, the Cluster Deletion operator  X  ( g,P )  X  g 0 deletes clusters that satisfies predicate P . (thus, g 0 all clusters in g that do not satisfy P ).
 Example 2: By observing the labels of the clusters in Fig-ure 1, we can easily identify which of them are most closely related to our needs. To this aim, we may want to select a subset of clusters. Assuming that we are planning a wine-tour, the clusters about gastronomy, wine and tourists topics are the most interesting ones; the reduced set of clusters on which we focus is depicted in Figure 2. In Figure 3 we show the selected clusters with their contents. 2
Since a group is an ordered list of clusters, group sorting operators must be provided. Shortly, operator S ( g,L )  X  g sorts clusters in g based on the ordered list of positions L ; operator S ( g )  X  g 0 sorts clusters in g w.r.t. their crank in decreasing order 7 .
The list of simple operators might be longer; however, they in the corresponding column.
The first complex operator we introduce is the Group In-tersection . Intuitively, it is a quite straightforward wish of users to intersect clusters in two groups, to find more specific clusters. The assumption is that the more search services re-trieve a document, the more the document content is worth analyzing.
 Definition 7: The Group Intersection operator  X  is defined as: where g 1 and g 2 are the groups of clusters to intersect, g is the resulting group, t is the ranking method adopted to evaluate the crank of clusters in g 0 . t  X  T  X  = { Natural , Cardinality , Weighted } .
 For each pair of clusters c 1  X  g 1 ,c 2  X  g 2 ,such that their there is a cluster c 0  X  g 0 . c 0 is defined as follows: c .items = c 1 .items  X  R c 2 .items , c . label = SynthLabel ( c 0 .items ).
 If t is Natural , the crank value is obtained as: c crank = NRank ( c 0 . items ).
 If t is Cardinality , the crank value of each resulting cluster is defined as: c 0 crank = CardRank ( c 0 ,g 0 ).
 If t is Weighted , the crank value is obtained as: c crank =
WMinRank ( c 1 . items ,c 1 . crank ,c 2 . items ,c 2 . crank ,c g .l = SynthLabel(C) with C set of ranked clusters in g 0 .
The operator provides three distinct methods to compute the ranking of resulting clusters. If t is Natural , the crank value of a cluster is obtained by computing its Natural Rank . In this way, the relevance of a cluster uniquely depends on items common to both intersected clusters. are not essential in this paper, and for the sake of space we do not further discuss this topic.

Instead, if t is Cardinality , the crank value of each re-sulting cluster is obtained by means of function CardRank , defined by the following definition.
 Definition 8 : Cardinality Rank Given the group g 0 obtained by intersecting two groups, the Cardinality Rank of each cluster c 0 is the ratio between the cardinality of c and the maximum cardinality of the clusters in g 0 :
CardRank ( c 0 ,g 0 ) = | c 0 . items | / max c  X  g 0 | c | .
The cardinality rank determines the relevance of clusters locally within the group: the largest cluster has crank equals to 1, while the others have a smaller value.

Finally, if t is Weighted , the crank value is obtained by means of function WMinRank , defined as follows.
 Definition 9 : Weighted Minimum Rank Given a set of items R 0 , obtained combining sets R 1 ( R 2 ) of ranked items belonging to the same cluster c 1 ( c 2 ) with a crank C 1 its Weighted Minimum Rank (denoted as WMinRank ) is the average of ranks of items in R 0 , weighted w.r.t. the crank of R 1 and R 2 . Formally:
WMinRank ( R 1 ,C 1 ,R 2 ,C 2 ,R 0 ) = where r 1  X  R 1 and r 2  X  R 2 are the original items describ-ing the same document represented by r 0 ( r 0 . uri = r 1 r an item r 1  X  R 1 ( r 2  X  R 2 ) with r 0 .uri = r 1 .uri ( r r .uri ). 2
By choosing a given ranking method, it is possible to rep-resent different properties of the intersection. Natural ap-plies the natural rank, so that the ranking of a resulting cluster is uniquely determined on the ranks of its items (see Definition 6). On the contrary, Weighted determines the rank not only based on the ranks of items, but also on the basis of the ranks of the incoming clusters.

The reader can notice that the irank value of the two input items is weighted with the crank value of the cluster. Consequently, the irank of items in the lowest ranked cluster (cluster in the last position of the group) are more likely to contribute to the weighted rank of the intersection. This definition is in accordance with the goal of being cautious in determining the rank of an item common to the original clusters.

As far as the cardinality rank is concerned, it determines the rank of the cluster in the group based on its cardinality, i.e., the number of items it contains. This can be useful when one is interested in analyzing first big sets of documents about a relevant topics, giving higher importance to clusters that are larger w.r.t. the others in the same group. Properties. The associative property holds for the Group In-tersection Operator , provided that the same ranking method is chosen for all the occurrences of the group join operator in the expression.
 The commutative property holds as well, since, it holds for ranked intersection.
 Example 3: In order to filter the most reliable documents, we could identify the common documents retrieved by all the three search engines. In the headings of groups depicted in Figure 4, the expressions applied to obtain the groups are reported. Consider groups g 4 and g 5 : first of all, we intersect g and g 2 , obtaining group g 4 ; then, we further intersect g with g 3 , obtaining group g 5 . The obtained clusters in g the intersection of c 1 = Wine Wineries and c 4 = Travel Guide from g 1 , of c 1 = Wine Tasting and Wineries and c 3 your Travel Vacation from g 2 , of c 1 = Wine Wineries and c = Napa Valley Hotel from g 3 .

Since the intersection is an associative operation, we can write the expression to obtain g 5 in a different way. This is done to obtain groups g 6 and g 7 , depicted in Figure 4. Looking at groups g 5 and g 7 , the reader can see that they are identical, apart from the expressions that generated them. For this reason, cluster cl.1 in g 5 and cluster cl.1 in g the same label label 5 , 1 . 2 The second complex operator we introduce is the Group Join operator.
 Definition 10: The Group Join operator ./ is defined as: where g 1 and g 2 are the groups of clusters to join, g 0 resulting group. t is the ranking method adopted to evaluate the crank of clusters in g 0 . t  X  T ./ = { Natural , Cardinality , Weighted , Correlation , Expansion , Weighted-Correlation , Weighted-Expansion } . there is a cluster c 0  X  g 0 defined as follows: c .items = c 1 .items  X  R c 2 .items , c . label = SynthLabel ( c 0 .items ).

If t is Natural , or Weighted , or Correlation , or Expansion , or Weighted-Correlation , or Weighted-Expansion , it is resp. obtained as: c crank = NRank ( c 0 . items ), c crank =
WMaxRank ( c 1 . items ,c 1 . crank ,c 2 . items ,c 2 . crank ,c c crank = CRank ( c 1 . items ,c 2 . items ) c crank = ERank ( c 1 . items ,c 2 . items ) c crank =
WCRank ( c 1 . items ,c 1 . crank ,c 2 . items ,c 2 . crank ) c crank =
WERank ( c 1 . items ,c 1 . crank ,c 2 . items ,c 2 . crank ). g .l = SynthLabel(C) with C set of ranked clusters in g 0 .
The Group Join operator can be used to explicit indirect correlations between the topics represented by the clusters in the two groups. The basic idea underlying its definition is that if two clusters overlap, i.e., have some common items, it means that the contents of these items are related with both topics represented by the clusters. This may hint the existence of an implicit relationship between the two topics. By assuming that topics can be organized into a hierarchy, by grouping the two overlapping clusters into a single one we may reveal the most general topic representing the whole content of the new cluster which subsumes as most specific topics those of the original clusters.

As for group intersection, the natural rank is the basic rank value of a cluster. An alternative is to compute the rank in a weighted way; in this case we define the WMaxRank , since we want to give more chance in determining the final rank to the items belonging to the highest weighted cluster. Definition 11 : Weighted Maximum Rank Given a cluster c 0 , obtained combining clusters c 1 and c 2 , its Weighted Maximum Rank is defined as
WMaxRank ( R 1 ,C 1 ,R 2 ,C 2 ,R 0 ) = (see Definition 9 for the meaning of symbols). 2
A third alternative to compute the ranking of cluster after a join is the Correlation Rank , that estimates the degree of correlation of the two incoming clusters. Indeed, this degree of correlation is computed by a measure of overlapping of the clusters. The greater they are overlapped, the more their topics are related one another.
 Definition 12 : Correlation Rank Given two sets of doc-uments R 1 and R 2 , their Correlation Rank (shortly, CRank ) is the overlapping value between R 1 and R 2 . Formally: 2
A fourth alternative to compute the ranking of a cluster after a join, is the Expansion Rank , that evaluates the degree of novelty w.r.t. the overlapped parts of the two incoming clusters. The greater the novelty, the less the two topics represented by the original clusters are related. This hints to the fact that the cluster with high novelty rank can represent a very general topic.
 Definition 13 : Expansion Rank Given two sets of items R 1 and R 2 , their Expansion Rank (shortly, ERank ) is the complementary value of overlapping between R 1 and R 2 Formally: 2
Another alternative to compute the ranking of clusters after a join is to weight the correlation rank. With this ranking criterion we want to enhance the contribution of the items belonging to the lowest ranked cluster so as to model a cautious attitude.
 Definition 14 : Weighted Correlation Rank Given two sets of items R 1 and R 2 , their Weighted-Correlation Rank (shortly, WCRank ) is their weighted overlapping value. For-mally: WCRank ( R 1 ,C 1 ,R 2 ,C 2 ) = = CRank ( R 1 ,R 2 ) where I = R 1  X  R R 2 and U = R 1  X  R R 2 ; r 1  X  R 1 and r are the original items describing the document having uri u ( u = r 1 . uri = r 2 . uri ), while C 1 and C 2 we denote the crank of R 1 and R 2 , respectively. We assume r 1 . irank = 0 ( r . irank = 0) if there is not an item r 1  X  R 1 ( r 2  X  R 2 u = r 1 .uri ( u = r 2 .uri ). 2
Note that the weight of the intersection R 1  X  R R 2 is the minimum rank associated with the document and the clus-ter of belonging, while that of the union R 1  X  R R maximum.
 Finally, it is possible to choose the Weighted Expansion Rank .
 Definition 15 : Weighted Expansion Rank Given two sets of items R 1 and R 2 , their Weighted Expansion Rank (shortly WERank ) is the complement of the weighted cor-relation rank.

WERank ( R 1 ,C 1 ,R 2 ,C 2 ) = = 1  X  WCRank ( R 1 ,C 1 ,R 2 ,C 2 ) = = 1  X  (see Definition 14 for the meaning of symbols). 2 Properties. The associative property holds for the Group Join Operator , provided that the same ranking method is chosen for all the occurrences of the group join operator in the expression.
 The commutative property holds as well, since, it holds for ranked union.
 Example 4: The application of this operator on our run-ning example is shown in Figure 5. The unified clusters that group documents common to the original clusters are about both topics (such as Wine Wineries and Wine Tasting and Wineries ), and at the same time, include also non com-mon documents, which are apparently unrelated. This is the case of clusters Plan your Travel vacation and Wine Winer-ies which both contain some documents, such as Featured Wineries in Napa Valley -Plan your Wine Tasting Room Tour . By joining these two clusters together, we generate a more populous cluster in which information about wineries and travel vacations are included. At this point, we could also order the resulting clusters w.r.t. the degree of corre-lation (i.e., overlapping) between the two original clusters, to identify the most correlated topics. In this example, in the same result cluster there are documents concerning only Wineries or Travel Vacation, but also both. We can so ex-pand the intersection between the two original clusters with documents correlated with it. 2 Discussion. Observing the various ranks reported in Fig-ing methods give a different relevance to clusters. For ex-ample, in group g 8 , the weighted rank is similar for both the clusters, but the correlation rank is quite different: in fact, cluster cl.1 has CRank = 0 . 333, while cluster cl.2 has CRank = 0 . 143; this means that clusters joined together to obtain cl.2 were less correlated than the ones joined to form cl.1. This result is coherent with the expansion rank: ER-expansion rank for cluster cl.1.

If we observe the basic weighted rank ( WMaxRank ), it is evident that its values are coherent w.r.t. the correlation rank; however, the distance between the two values is much smaller than the distance between the values of the corre-lation rank; this is due to the fact that the crank values of original clusters influence the final rank.

Finally, we can notice that sorting clusters in g 8 on cardinality ranking and (weighted) expansion ranking, clusters are sorted in a different order than the one depicted in the figure.
After group intersection and group join, it is possible to introduce the group refinement operator: it is aimed at re-fining clusters in a group, based on clusters in another group. Definition 16: The Group Refinement operator is de-fined as: where g 1 is the group to refine on the basis of g 2 , g 0 resulting group. t is the ranking method adopted to evaluate Figure 5: Group Join. In the expressions, t denotes a generic ranking method. the crank of clusters in g 0 . t  X  T = { Natural , Cardinality , Refinement } .
 Consider a cluster c 1  X  g 1 ; for each cluster c i  X  g c . items  X  R c i . items .
 If at least one I i 6 =  X  , there is a cluster c 0  X  g 0 follows: c .items = I 1  X  R  X  X  X  X  R I n , c . label = SynthLabel ( c 0 .items ).

If t is Natural , the crank value is obtained as: c crank = NRank ( c 0 . items ).
 If t is Refinement , the crank value (called ( Refinement Ranking ) is obtained as : c crank = | c 0 . items | / | c 1 . items | .

If t is Cardinality , the crank value of each resulting cluster is defined as c 0 crank = | c 0 . items | / max c  X  g 0 nality Rank ). g .l = SynthLabel(C) with C set of ranked clusters in g 0 .
While the group join operator generates a cluster repre-senting a more general topic than the topics in both the original clusters, the refinement operator can be regarded as generating clusters specializing the topics of the clusters in the first group on the basis of the topics of any cluster in the second group. The idea underlying this operator is that we want to collect, in a unique cluster, the items which belong to both a cluster c 1 of the first group g 1 and any of the clusters in the second group g 2 . This way, by eliminat-ing some items from c 1 we generate a cluster representing a more specific topic with respect to c 1 but not necessarily more specific w.r.t. the clusters of the second group. Example 5: Suppose that by analyzing the results in Figure 5, we discover that no cluster has been retrieved con-cerning restaurants (i.e., with the word restaurant in the label). We could take a remedy by submitting the new query "Napa Valley Restaurants" to Yahoo! ; the resulting clusters shown in Figure 6 (strongly focused on restaurants) are used to filter out sub-clusters of documents concerning restaurants from within clusters in the previous lists (we refine clusters in the first list). 2
The operators so far introduced constitute the core of our proposal, but other less critical operators can be figured out. Here, we briefly sketch the ones we think necessary. Group Union. The user should be provided with an opera-tor to unite together two groups. The group union operator g  X  g 2 = g 0 generates g 0 in such a way it contains all clusters in g 1 and all clusters in g 2 and g 0 .l = SynthLabel(C) with C set of ranked clusters in g 0 .
 Group Coalescing. Complex processing of retrieved doc-uments may need to be performed by fusing all clusters in a group into one global cluster. The group coalescing operator  X  ( g ) = g 0 generates g 0 in such a way that g 0 contains only one cluster, obtained by applying the ranked union operation Reclustering. After complex transformations, it might be necessary to reapply the clustering method to a group. In fact, re-clustering documents in a group may let new and unexpected semantic information emerge.
 The Reclustering Operator Cluster ( g ) = g 0 performs the tanked union of all clusters in g , and generates g 0 in such a way that it contains all the clusters obtained by clustering all ranked documents, and g 0 .l = SynthLabel(C) with C set of ranked clusters in g 0 .
 Closure Property of Group Operators The data model and the group operators were designed in such a way the Clo-sure Property holds: operators are defined on groups and generate groups.

As far as the ranking methods is concerned, we defined a rich set of them, each one highlighting a characteristics of either the operator itself (e.g. Natural and Refinement ), the input groups (e.g. Correlation and Weighted ranking meth-ods) or the output group (e.g. Cardinality ). User evaluation will provide the evidence of the most useful ranking method for each operator.
The group operators so far described, allow to conduct a powerful exploratory activity: by combining groups, the user can discover useful information and may be inspired for new searches; the results of these new searches might be combined with previously computed groups, and so on. The first function that we need to define is the Create-Query function that makes it possible to generate an empty group with a desired label l . It is defined as:
This function is necessary to generate the input group for the CQuery operator when the user wants to submit a query for the first time. This allows to achieve the closure of the all the set of group operators. However, being an ex-ploratory activity, it might be useful to estimate the results of group operations without actually building and storing a Figure 6: Group Refinement. In the expression la-belling the group on the right, t denotes a generic ranking method. new group. If users were provided with functions that re-turn a quantitative summary of what would be obtained by applying an operator on already computed groups, the user could decide whether to actually apply a group operator to obtain a new group or not.
 For this reason, the proposed language provides some useful evaluation functions, that we introduce in this section. Selection. Selection function,  X  E , evaluates the effect of a cluster selection. It is defined as:  X  E ( g,P )  X  ( nc , mincard , maxcard , mincrank , maxcrank ) where g is the group that applies the selection, and P is the selection predicate (see Section 5.1). The function pro-duces a 5-tuple with the following fields: nc is the number of clusters that would be selected, min and max are, respec-tively, the minimum and maximum cardinality of clusters that would be selected, while mincrank and maxcrank are, respectively, their minimum and maximum values.
 Intersection, Join and Refinement. Three functions are defined, corresponding to the main group operators:  X  evaluates intersection, ./ E evaluates join, E evaluates re-finement.  X  ( g 1 ,g 2 ,t )  X  ( nc , mincard , maxcard , mincrank , maxcrank ) ./ E ( g 1 ,g 2 ,t )  X  ( nc , mincard , maxcard , mincrank , maxcrank )
E ( g 1 ,g 2 ,t )  X  ( nc , mincard , maxcard , mincrank , maxcrank ) where g 1 and g 2 are the groups of clusters to intersect (resp. join or refine). t is the ranking method adopted to evaluate the crank of clusters that would be produced: for  X  E t  X  T (see Definition 7); for ./ E t  X  T ./ see Definition 10); for E t  X  T (see Definition 16).

As for selection evaluation, these functions produce a 5-tuple with the previously defined fields.
 Example 6: As an example of application we discuss the case of the group intersection, whose results are rep-resented in Figure 4. We may want to know if it is con-venient (in terms of obtained results) to execute the oper-ation g 4 := g 1  X  g 2 . To this aim we apply the function  X  ( g 1 ,g 2 ,Weighted ) that will return, as a result, ( nc = 2, mincard = 1, maxcard = 2, mincrank = 0 . 8723, maxcrank = that only two clusters are retrieved containing a total of three documents with high minimum and maximum rank (in the range [0,1]). Thus it can be worth executing the intersection operator. 2
In this section we review works that have some relation to our proposal, although they have been conceived either with different scopes than the analysis of web documents retrieved by search services, or with distinct functionalities. In fact, we did not find any language similar to our proposal. A motivation of the utility of our proposal can be found in [8]. In this work, the authors advocate the need of tools for giving the user more immediate control over the clusters of retrieved web documents; such tools should serve as means for exploring the similarity among documents and clusters. They also consider giving the user some means to correct, or change, the classification structure. To support the manip-ulation of clusters, they suggest the development of graphic user interfaces. Indeed, the literature on visual paradigms for the presentation of textual search results is too exten-sive to review; for a survey, the reader can see [1] and [12]. One goal of these approaches is to perform some kind of text mining based on conceptual maps visualization [3, 7]. Nev-ertheless, our proposal is different, since we do not exploit a graphical representation of relationships between documents at this level, but we provide a language for flexibly exploring the hidden relationships. In the NIRVE prototype, Cugini and Laskowski [11] evaluate and compare several graphical interfaces for showing the retrieved results of NIST  X  X  PRISE search engine. In their conclusions, they state that  X  X  good visualization of search results depends on a good structure and what often happens is that developers perform a deeper this respect, we envisage that our proposed language could be employed for exploring and finding a good structure of results that can then be presented by taking advantages of the proposed graphic visualization techniques.
 An approach that shares some similarity of intent to our pro-posal, in that it allows to do dynamic clustering and refine-ment of search results, is the Scatter/Gather algorithm [6]. Its distinctive feature is the way it allows clusters to be se-lected, recombined (gathered) and re-clustered (scattered). However, the user has to decide which clusters have a rele-vant theme based solely on keywords and titles. No function-ality is available to detect the degree of share between clus-ters. Furthermore, since new clusters are generated based on re-clustering, the generation criteria remain implicit and unknown to the user. On the contrary, in our approach, the user is perfectly aware of the criteria that generated the new clusters, since they depend on the applied group opera-tor.Moreover, the intersection and union operations between clusters generate the label of the resulting cluster through the processing of its items (titles and snippets), so as to reveal its hidden semantics. In facts, the label gives new in-formation previously unknown on the common documents X  contents in the cluster. We can also find some similarity of our approach w.r.t clustering ensemble techniques, defined to compare either the results obtained by the application of distinct clustering algorithms on the same set of items, or to compare distinct partitions of the same set of items ob-tained based on distinct views (representations) of the items [5, 13, 9]. The main goal of these techniques is to achieve a robust and consensual clustering of the items. Robust clus-tering is achieved by combining data partitions produced by multiple clusterings. The approaches are defined within an information-theoretical framework; in fact, mutual informa-tion is the underlying concept used in the definition of quan-titative measures of agreement or consistency between data partitions.The group intersection operator of our language takes inspiration from these ideas, since its goal is, given two distinct partitions, (i.e., clusters X  groups), to identify the common partitions, i.e., those sharing the same sets of documents. If we iteratively apply the intersection operator to a set of groups, we thus find the consensual partitions among these groups. As far as the join operator is con-cerned, it can be regarded as the generation of a new group containing only the unions of the original clusters which have a non empty intersection. Its meaning is that of expanding the result of the intersection operator between groups, so as to consider indirect correlations among the items of the original clusters.
In this paper, we addressed the problem of defining a language for manipulating the results provided by internet search services. The work is motivated by the need to better exploit the results obtained by different search services like, e.g., web search engines. The large number of documents retrieved by such services constitute a serious obstacle for users, that are unable to extract a semantic summarization of the results. The proposed language provides operators to manipulate, in a complex and controlled way, groups of clustered retrieved documents. The richness of the proposed language allows users to integrate the results of different search services in several ways, then revealing more gen-eral or more specific topics than those carried by the single documents. We are developing a software prototype that supports the proposed language. Based on a Service Ori-ented Architecture, it will provide a web service interface, that will be exploited to develop multi-channel applications. We envisage that this manipulation language can be em-ployed for exploratory analysis in other contexts than the one presented in this paper, ex. in databases. [1] S. K. Card, J. D. Mackinlay, and B. Shneiderman. [2] H. Chen and S. Dumais. Bringing order to the web: [3] W. Chung, H. Chen, and J. J. Nunamaker. Business [4] T. Coates, D. Connolly, D. Dack, L. Daigle, [5] A. L. N. Fred and A. K. Jain. Robust data clustering. [6] M. A. Hearst and J. O. Pederson. Reexamining the [7] N. Kampanya, R. Shen, S. Kim, C. North, and E. A. [8] A. V. Leouski and W. B. Croft. An evaluation of [9] M. V. M. Pagani, G. Bordogna. Mining [10] S. Osinski. An algorithm for clustering of web search [11] M. M. Sebrechts, J. Vasilakis, M. S. Miller, and [12] E. Staley and M. Twidale. Graphical interfaces to [13] A. Strehl and J. Ghosh. Cluster ensembles  X  U a [14] L. Zadeh. Fuzzy sets. Information and control , [15] O. Zamir and O. Etzioni. Grouper: a dynamic
