 Frequent coherent subgraphs can provide valuable knowledge about the underlying internal structure of a graph database, and mining frequently occurring coherent subgraphs from large dense graph databases has been witnessed several applications and received con-siderable attention in the graph mining community recently. In this paper, we study how to efficiently mine the complete set of coher-ent closed quasi-cliques from large dense graph databases, which is an especially challenging task due to the downward-closure prop-erty no longer holds. By fully exploring some properties of quasi-cliques, we propose several novel optimization techniques, which can prune the unpromising and redundant sub-search spaces effec-tively. Meanwhile, we devise an efficient closure checking scheme to facilitate the discovery of only closed quasi-cliques. We also de-velop a coherent closed quasi-clique mining algorithm, Cocain Thorough performance study shows that Cocain is very efficient and scalable for large dense graph databases.
 Categories and Subject Descriptors: H.2.8 [Database Manage-ment]: Data Mining General Terms: Algorithms Keywords: Graph mining, Quasi-clique, Coherent subgraph.
Recently several studies have shown that mining frequent coher-ent subgraphs is especially useful, where a coherent subgraph can be informally defined as a subgraph that satisfies a minimum cut bound (and the formal definition can be found in Section 2.1), as the set of frequent coherent subgraphs mined from a graph database usually reflects the density distribution of the relationships among the objects in the database, and can provide valuable knowledge about the internal structure of the graph database. Coherent sub-graph mining has also been witnessed several applications such as
This work was supported by National Natural Science Foundation of China (NSFC) under Grant No. 60573061 and Basic Research Foundation of Tsinghua National Laboratory for Information Sci-ence and Technology(TNList). Cocain stands for Co herent c losed qu a si-cl i que mi n ing. Copyright 2006 ACM 1-59593-339-5/06/0008 ... $ 5.00. highly correlated stock discovery[5], gene function annotation and functional module discovery[3].

Several coherent subgraph discovery algorithms have been re-cently developed [3, 4, 6, 5]. However, each of the previously pro-posed algorithms has its own limitations. For example, the algo-rithm proposed in [4] can only mine quasi-cliques with exact 100 support threshold; the algorithms proposed in [6] can only work on relational subgraphs, where vertex labels are distinct in each graph; similarly, the CLAN algorithm [5] mines fully connected frequent subgraphs (i.e., frequent cliques). In this paper, we study a more general problem formulation: mining frequent quasi-cliques from large dense graph databases, that is, we neither limit the minimum support to be 100 % nor require the input graphs to be relational. While the problem becomes more general, it gets more tough. As we will see later, the downward-closure property[1] no longer holds, devising some effective search space pruning techniques is especially challenging. By fully exploring some properties of quasi-cliques, we propose several novel optimization techniques, mean-while, we devise an efficient closure checking scheme to facilitate the discovery of only closed quasi-cliques. We also develop an ef-ficient coherent closed quasi-clique mining algorithm, Cocain .
The remaining of this paper is organized as follows. Section 2 introduces the problem formulation. In Section 3, we present algo-rithm Cocain by focusing on several optimization techniques. The empirical results are examined in Section 4. Finally, we conclude our study in Section 5.
In this section, we introduce some preliminary concepts, nota-tions, and terms in order to simplify our discussion. We also for-mulate the problem we study. Table 1 summarizes the notations we use in this paper and their meanings.

In this paper, we consider simple graph only, which does not contain self-loops, multi-e dges, and edge labels. An undirected vertex-labeled graph transaction , G , can be represented by a 4-tuple, G =( V, E,L, F ) .An induced subgraph of a graph G is a subset of the vertices of V ( G ) together with any edges whose end-points are all in this subset. In the following discussions, the term  X  X raph X  means the undirected vertex-labeled graph, unless other-wise stated.

D EFINITION 2.1. (  X  -Quasi-clique) A k -graph ( k  X  1) G is a  X  -quasi-clique (0  X   X   X  1) if  X  v  X  V ( G ) , deg G ( v )  X 
From the definition we can see that quasi-cliques are subgraphs that satisfy a user-specified minimum vertex degree bound,  X  Apparently, a  X  -quasi-clique must be a fully connected graph when  X  =1 , and singleton graphs are considered as  X  -quasi-cliques. If  X  v  X  V ( G ) such that deg G ( v )=  X   X  ( k  X  1) and  X   X  ( k v is called a critical vertex of G w.r.t  X  .

Most of the existing frequent subgraph mining algorithms are based on the downward-closure property. Unfortunately, this prop-erty does not hold for quasi-clique patterns. An induced subgraph of a  X  -quasi-clique may not be a  X  -quasi-clique. For instance, in
D EFINITION 2.2. (Edge Cut and Edge Connectivity) Given a connected graph G =( V, E ) , an edge cut is a set of edges E that G =( V , E  X  E c ) is disconnected. A minimum cut is the small-est set among all edge cuts. The edge connectivity of G , denoted by  X  ( G ) , is the size of the minimum cut.

As shown in [6], the minimum vertex degree can reflect the level of connectivity to some extent in a graph, but they cannot guaran-tee the graph is connected in a balanced way. However, the follow-ing lemma gives a lower bound on the minimum cut when  X   X  0 which guarantees the coherency of  X  -quasi-cliques.

L EMMA 2.1. (Minimum Edge Connectivity) Let n -graph Q = (
V, E ) be a  X  -quasi-clique (0 . 5  X   X   X  1 , n  X  2) . The edge connectiv-ity of Q must be no smaller than n 2 , i.e.,  X  ( Q )  X  n P ROOF . Let us divide V into two sets, V 1 and V 2 , and suppose V  X  V 2 and | V 1 | = k , 1  X  k  X  n 2 must hold.

Since Q is a  X  -quasi-clique,  X  v  X  V 1 , deg Q ( v )  X   X  ever, v is at most adjacent to other k  X  1 vertices in V 1 1 &lt; X  ( n  X  1) . Therefore, v must be adjacent to vertices belonging to V 2 , and the number of edges which connect v and vertices in V must be no smaller than  X   X  ( n  X  1)  X  ( k  X  1) .Thereare k vertices in V 1 , so there exist at least k  X  (  X   X  ( n  X  1)  X  ( k V and V 2 .Let f ( k )= k  X  (  X   X  ( n  X  1)  X  ( k  X  1)) ,then
The second-order derivative of f ( k ) (i.e., d 2 f ( k ) ative, f ( k ) achieves the maximum at its sole stationary point k polynomial function f ( k ) and 1  X  k  X  n 2 , f ( k ) must get its mini-mum either at k =1 or at k = n 2 .When k =1 , f (1)=  X   X  ( jacent to at least one vertices in V 2 , thus f ( n 2 )  X  n above result, we can get that  X  k  X  [1 , n 2 ] , f ( k )  X  n to the definition of edge connectivity,  X  ( Q )  X  n 2 .
Because we are more interested in mining tightly connected sub-graphs, we do not expect that the edge connectivity of a subgraph is too small in comparison with the minimum vertex degree. From Lemma 2.1, if  X   X  0 . 5 the vertices in the  X  -quasi-clique are con-nected tightly and relatively evenly. In this paper, a  X  -quasi-clique is said to be coherent if  X   X  0 . 5 , and if not explicitly stated  X  by default has a value no smaller than 0 . 5 .

D EFINITION 2.3. (  X  -Isomorphism) A graph G 1 = { V 1 , E is  X  -isomorphic to another graph G 2 = { V 2 ,E 2 ,L 2 ,F of them are  X  -quasi-cliques, | G 1 | = | G 2 | , and there exists a bijec-tion f : V 1  X  V 2 such that  X  v  X  V 1 , F 1 ( v )= F 2 (
According to the above definition, we know that the  X  -isomorphism is quite different from the graph isomorphism in graph theory, which is defined as a bijection f : V ( G 1 )  X  V ( G 2 ) from a graph G other graph G 2 , such that ( u, v )  X  E ( G 1 ) iff ( f ( While the  X  -isomorphism between two  X  -quasi-cliques does not imply an exact bijection edge mapping.

A multiset is defined as a bag of vertex labels in which the or-der is ignored, but multiplicity is explicitly significant. Let M indicate the multiset of G .Fromthe  X  -isomorphism definition, we can derive the following lemma directly: two  X  -quasi-cliques, G and G 2 ,are  X  -isomorphic to each other iff M ( G 1 )= M
For two  X  -quasi-clique Q and Q ,if M ( Q )  X  M ( Q ) , Q is called a subquasi-clique of Q , while Q is called a superquasi-clique of Q .Weuse Q Q or Q Q (i.e. Q Q but Q = Q ) to denote the subquasi-clique or proper subquasi-clique relationship.
A graph transaction database , D , consists of a set of input graphs, and the cardinality of D is denoted by | D | . Figure 1 shows an example of graph transaction database D , which consists of two input graphs, G 1 and G 2 . For two graphs G and G ,let g be an induced subgraph of G ,if M ( g )= M ( G ) , we call g an instance of G in G . If there exists at least one instance of G in G , we say that graph G roughly supports G . Meanwhile, if g is  X  -isomorphic to another  X  -quasi-clique Q , we call g an embedding of Q in G . If there exists at least one embedding of Q in G , G is said to strictly support Q .
The number of input graphs in graph database D that strictly (or roughly) support a  X  -quasi-clique Q (or a graph G ) is called the ab-solute strict-support (or absolute rough-support) of Q (or G )in support rsup D s ( Q ) (or relative rough-support rsup D r fined as rsup D s ( Q )= sup D s ( Q ) / | D | (and rsup D
Given an absolute support threshold min sup and a graph trans-action database D , a quasi-clique Q (or a subgraph g ) is called a frequent quasi-clique (or a vice-frequent graph) if sup min sup (or sup D r ( g )  X  min sup ). If there does not exist any an-other quasi-clique Q such that Q Q and sup D s ( Q )  X  sup Q is called a closed quasi-clique in D 2 .
Here the definition of a  X  X losed X  pattern is a little different from the traditional one, due to the absence of the downward-closure property for quasi-clique patterns, and it is possible that a quasi-clique X  X  strict-support is greater than that of its subquasi-cliques. Also, in the case that Q Q and sup D s ( Q )  X  sup D s ( Q can subsume Q .

In this paper, given D and min sup , we study the problem of mining the complete set of  X  -quasi-cliques in D that are frequent, closed, and also coherent (i.e.,  X   X  0 . 5 ).
In this section, we describe our comprehensive solution to fre-quent closed coherent quasi-clique mining, including an efficient canonical representation of a coherent quasi-clique, a subgraph enu-meration framework, several search space pruning techniques, and a quasi-clique closure checking scheme. We also present the inte-grated algorithm, Cocain.
One of the key issues in graph mining is how to choose an ef-ficient canonical form that can uniquely represent a graph and has low computational complexity in order to facilitate the graph iso-morphism testing. Some previously proposed solutions to this prob-lem are designed for a general graph and may not be the most efficient representation for a quasi-clique. According to the Sec-tion 2.1, we can see that a multiset preserves much information for a quasi-clique. Given a k -graph g , we call any sequence of all elements in M ( g ) agraph string . Assume there is a total or-der on the vertex labels, we define the following total order of any two strings p and q with size | p | and | q | respectively. Let p note the i -th vertex label in string p ,wedefine p&lt;q if either of the following two conditions holds: (1)  X  t ( 0 &lt;t  X  min such that  X  i  X  [1 ,t  X  1] , p i = q i and p t &lt;q t ,(2)(  X  [1 , | p | ] , p i = q i ;otherwise p  X  q .Astring S a = substring of another string S b = b 1 b 2 ...b m , denoted by S S a S b if m&gt;n ), if there exist n integers 1  X  i 1 &lt;i
D EFINITION 3.1. The canonical form of a graph G is defined as the minimum string among all its strings and denoted by CF
As we ignore the exact topology of a quasi-clique, it is evi-dent that the above definition is a unique representation of a quasi-clique. However, we note that it does not hold for a general graph. After giving the definition of the canonical form of a graph and the substring relationship, we can derive the following two lemmas to facilitate  X  -isomorphism checking and subquasi-clique relationship checking.

L EMMA 3.1. Tw o  X  -quasi-cliques Q 1 and Q 2 are  X  -isomorphic to each other iff CF ( Q 1 )= CF ( Q 2 ) .

L EMMA 3.2. Given two  X  -quasi-cliques Q 1 and Q 2 , Q 1 Q (or Q 1 Q 2 )iff CF ( Q 1 ) CF ( Q 2 ) (or CF ( Q 1 ) CF (
The above two lemmas can be derived easily from the definition of  X  -isomorphism and subquasi-clique relationship respectively, here we omit the proof.
According to the definition of a vice-frequent graph, it is evi-dent that any induced subgraph of a vice-frequent graph must be also vice-frequent. Thus, the downward-closure property can be exploited for vice-freque nt subgraph enumeration.

Based on the definition o f embedding and instance of a subgraph, we can see that the embedding is a special type of the instance, an embedding of a quasi-clique q must be an instance of q .Given a  X  -quasi-clique Q ,as sup D s ( Q )  X  sup D r ( Q ) holds, if Q is fre-quent, Q must be vice-frequent. Consequently, we can discover the complete set of frequent  X  -quasi-cliques from the set of vice-frequent subgraphs. By conceptua lly organizing the vice-frequent subgraphs into a lattice-like struc ture in the way we used in [5], the problem of mining frequent quasi-cliques becomes how to traverse the lattice-like structure to enum erate vice-frequent subgraphs and discover frequent  X  -quasi-cliques.

In our running example in Figure 1, assume the total order among vertex labels is a  X  b  X  c  X  d  X  e , all the vice-frequent subgraphs are organized into a structure as shown in Figure 2. Note that here we use  X  X anonical form:rough-support:strict-support X  to represent a subgraph. In addition, all node s with yellow color are vice-frequent subgraphs but not frequent quasi-cliques, nodes with blue color are non-closed frequent quasi-cliques, and nodes with orange color are closed quasi-cliques. Figure 2 shows that among all the vice-frequent subgraphs , only abd:2:2 and bcd: 2:2 are closed quasi-cliques. We also adopt the DFS search strategy as we used in [5] to traverse the lattice-like structure. In this way, we can get a rudimen-tary algorithm to discover frequent closed  X  -quasi-cliques. How-ever, due to a great deal of redundancy during the enumeration, this rudimentary algorithm is too expensive and costs too much space and runtime. Figure 2: A lattice-like structu re built from the vice-frequent subgraphs of our running example Structural Redundancy Pruning . As shown in [5], much re-dundancy exists if we just simply use the DFS search strategy. In order to eliminate the structural redundancy while maintaining the completeness of the result set, we propose an efficient vice-frequent subgraph enumeration method. Given an m -graph G and CF ( G )= a 0 a 1 ...a m , we require G can only be generated by grow-ing the subgraph g with canonical form CF ( g )= a 0 a 1 ...a this way, except the node  X  , each node in the lattice-like structure has only one parent, and this lattice-like structure would turn to atreestructure. Let LAS ( g ) be the last element in CF ( LAS ( g )= a m ), obviously, in the enumeration tree structure all de-scendants of the node g would be in the form of CF ( g ) b where b 0  X  LAS ( g ) and  X  i  X  [1 ,k ] , b i  X  1  X  b i .
In this subsection, we propose several novel optimization tech-niques to prune futile search subspaces based on some nice proper-ties of quasi-cliques.
Before we elaborate on the pruning techniques, let us first intro-duce the following two important lemmas which form the founda-tion of several pruning techniques.

L EMMA 3.3. If m + u&lt;  X   X  ( k + u ) (where m, u, k  X  0 0 . 5  X   X   X  1 ), then m&lt;  X   X  k and  X  i  X  [0 ,u ] , m + i&lt;  X 
P ROOF . First, we assume m  X   X   X  k ,then m + u  X   X   X  k + u  X   X   X  k +  X   X  u  X   X   X  ( k + u ) , which contradicts with the fact m + u&lt;  X   X  ( k + u ) . Thus, m&lt;  X   X  k holds. Second, let t = u  X  i ,then m + i = m + u  X  t&lt;  X   X  ( k + u )  X  u )  X   X   X  t  X   X   X  (( k + u )  X  t ) =  X   X  ( k + i ) .

L EMMA 3.4. (Maximal Diameter) If a graph Q is a  X  -quasi-clique, then  X  u, v  X  V ( Q ) , dis Q ( u, v )  X  2 .

P ROOF .Let | Q | = n ( n  X  2) .  X  u, v  X  V ( Q ) ,if u and v are ad-jacent to each other, then dis Q ( u, v )=1 . While if u and v are not adjacent, then | N Q ( u )  X  N Q ( v ) | X  ( n  X  2) .Furthermore,as Q is a  X  -quasi-clique, | N Q ( u ) | X   X   X  ( n  X  1) and | N Q ( v hold. Therefore, N Q ( u )  X  N Q ( v ) =  X  ,otherwise | N | N
Q ( u ) | + | N Q ( v ) | X  2  X   X  ( n  X  1) . Also, since  X  2  X   X  ( n  X  1)  X  ( n  X  1) . Thus, | N Q ( u )  X  N Q ( v ) | X  ( which contradicts with the fact | N Q ( u )  X  N Q ( v ) | X  ( result, there must exist at least one vertex which is adjacent to both u and v ,and dis Q ( u, v )=2 must hold. Therefore, from the above analysis, we can get  X  u, v  X  V ( Q ) , dis Q ( u, v )  X  2
From Lemma 3.4, we can derive the following lemma to help us prune some futile branches.
 L EMMA 3.5. (Diameter Pruning) Let G be a graph and S  X  V ( G ) ,if G ( S ) is a  X  -quasi-clique, then  X  u , v  X  S , dis
P ROOF .As G ( S ) is a subgraph of G , dis G ( S ) ( u, v holds. In addition, according to Lemma 3.4, we have dis G  X  2 . Therefore, dis G ( u, v )  X  2 must hold.

Given a graph G ,let S  X  V ( G ) and v  X  V ( G )  X  S , from Lemma 3.5 we know that if G ( S ) and v can form a  X  X igger X  quasi-clique,  X  u  X  S, dis G ( v, u )  X  2 must hold. Accordingly, a straightfor-ward and reasonable application of Lemma 3.5 is to discover the extensible vertices of a subgraph which can be used to form quasi-cliques later. First, we calculate the extensible vertex set E each vertex u in G ( S ) , then conjoin all E ( u )  X  X  to obtain the global extensible vertex set. Obviously, E ( u ) can be divided into two sub-sets. One is denoted by D ( u ) , which consists of the vertices that are adjacent to u , i.e., D ( u )= { v | dis G ( u, v )=1 } ; another subset is denoted by I ( u ) ,where I ( u )= { v | X  u  X  D ( u ) ,dis and v/  X  D ( u ) } .Theset D ( u ) can be obtained easily, and I be computed from D ( u ) in the way of discovering vertices which are adjacent to at least one vertex in D ( u ) . In this way, we can discover extensible vertex set for an instance of a subgraph G and can prune some unpromising vertices.
 Combination Pruning . We can combine the structural redun-dancy pruning with Diameter Pruning to further shrink the the ex-tensible vertex set. As stated in structural redundancy pruning , only those vertices whose labels are no smaller than LAS ( be used to grow g ,where g is the current prefix subgraph. There-fore, when calculating E ( u ) we can remove the vertices whose la-bels are smaller than LAS ( g ) , and the removal of some vertices in E ( u ) may make some vertices left in E ( u ) violate the condition of an extensible vertex introduced in Lemma 3.4. For example, suppose  X  v 0  X  I ( u ) and there exists only one vertex v such that v  X  D ( u ) and dis G ( v 0 ,v )=1 ,if v /  X  V ( g ) and the label of v is smaller than LAS ( g ) ,then v will never appear in all descendants of g , thus the descendant g of g which contains vertex v be a quasi-clique, as dis g ( u, v 0 ) &gt; 2 must hold. Therefore, we can remove the vertex v 0 from E ( u ) safely. In order to eliminate these vertices efficiently, after getting D ( u ) , we remove the vertices in D ( u ) whose labels are smaller than LAS ( g ) and in the meantime do not belong to V ( g ) . After we compute the final set of extensible vertices, E ( u ) , for each vertex u in subgraph g , we can then con-join all the E ( u )  X  X  to get the global extensible vertex set w.r.t. g . We call an element in the global extensible vertex set an extensible candidate w.r.t. g , and use V G cad ( g ) to denote the set of extensible candidates w.r.t. g in G .

In the following, we propose other three optimization techniques based on Lemma 3.3 which can be used to prune the unpromising search space effectively.

For v  X  V G cad ( g ) , we define the internal set V g in and external set V g ex ( v )= N G ( v )  X  V G cad ( g ) .Let indeg be the inner degree of v ,and exdeg g ( v )= | V g ex | be the extern de-gree of v . Take Figure 1 for an example, assume g = G V nation Pruning ), indeg g ( v 3 ) =0, exdeg g ( v 3 ) =1.
L EMMA 3.6. (Vertex Connectivity Pruning) Suppose g is a k -subgraph of G ,if  X  v  X  V G cad ( g ) such that indeg ( and indeg g ( v )+ exdeg g ( v ) &lt;  X   X  ( k + exdeg g ( not exist a quasi-clique Q in G such that V ( Q )  X  V ( g
P ROOF . Assume there exists a quasi-clique Q such that V  X 
V ( g )  X  X  v } ,andlet | Q | = l .Since Q is a quasi-clique, V  X 
V ( g )  X  V G cad ( g ) .Wedefine R = V ( Q )  X  V g ex ( v by m ,then l  X  k  X  1  X  m and m  X | V g ex ( v ) | = exdeg g ( indeg g ( v ) &lt;  X   X  k and indeg g ( v )+ exdeg g ( v ) exdeg g ( v )) , according to the Lemma 3.3, we can get that  X  [0 ,exdeg g ( v )] , indeg g ( v )+ i&lt;  X   X  ( k + i ) indeg g ( v )+ m&lt;  X   X  ( k + m )  X   X   X  ( l  X  1) ,i.e. deg  X   X  ( | Q | X  1) . This contradicts with the assumption that Q is a quasi-clique.

In the case of indeg g ( v )+ exdeg g ( v ) &lt;  X   X  ( k + v is called an invalid extensible candidate , otherwise it is called a valid extensible candidate . Obviously, the invalid extensible can-didates do not make any contribution to the generation of  X  X igger X  quasi-cliques. Therefore, after getting the extensible candidate set V V extensible candidates may turn to be invalid, so we can do this prun-ing iteratively until no vertex can be removed from V G cad denote the remaining set by V G vad ( g ) . Hence, if G ( clique in G and S  X  V ( g ) , S  X  V ( g )  X  V G vad ( g ) only need to use the vertices in V G vad ( g ) to grow g , which can fur-ther improve the algorithm X  X  efficiency.

Assume g is a subgraph of a graph G ,foravertex u  X  V ( cardinality of V g ext ( u ) , i.e., extdeg g ( u )= | V g a critical vertex v in g such that extdeg g ( v )=0 , we call v a failed-vertex of g .

L EMMA 3.7. (Critical Connectivity Pruning) If there exists a failed-vertex v in a k -subgraph g of G , there will be no such an induced subgraph Q of G that V ( Q )  X  V ( g ) and Q is a quasi-clique.

P ROOF . We prove this by contradiction. Let Q be such an in-duced subgraph of G and | Q | = m . Obviously m&gt;k and V (
Q )  X  V ( g )  X  V G vad ( g ) .Since v is a critical vertex in g , deg  X   X  ( k  X  1) and  X   X  ( k  X  1) &lt;  X   X  k . Furthermore, be-cause deg Q ( v )  X  deg g ( v )+ extdeg g ( v ) and extdeg deg Q ( v ) &lt;  X   X  k  X   X   X  ( m  X  1) , which contradicts with the as-sumption. Thus, there must exist no such an induced subgraph.
Given a k -subgraph g of a graph G ,if  X  u  X  V ( g ) such that deg g ( u ) &lt;  X   X  ( k  X  1) and deg g ( u )+ extdeg g ( 1+ extdeg g ( u )) , we call u an unpromising vertex in g .
L EMMA 3.8. (Subgraph Connectivity Pruning) If a k -subgraph g of G contains an unpromising vertex u , there will be no induced subgraph Q of G such that V ( Q )  X  V ( g ) and Q is a quasi-clique. P ROOF .Let Q be such an induced subgraph and | Q | = l .Since Q is a  X  -quasi-clique, V ( Q )  X  V ( g )  X  V G vad ( g ) V (
Q )  X  V g ext ( u ) and | V | = m ,then l  X  m + | V ( g ) | = cause deg g ( u ) &lt;  X   X  ( k  X  1) and deg g ( u )+ extdeg  X   X  ( k  X  1+ exdeg g ( u )) , from Lemma 3.3 we can get that  X  i  X  [0 ,exdeg g ( u )] ,deg g ( u )+ i&lt;  X   X  ( k  X  1+ i deg Q ( u )= deg g ( u )+ | V | = deg g ( u )+ m&lt;  X   X  (  X   X  ( l  X  1) ,thatis, deg Q ( u ) &lt;  X   X  ( | Q | X  1) . This contradicts with the assumption that Q is a  X  -quasi-clique.

According to Lemma 3.7 and Lemma 3.8, if a subgraph contains a failed-vertex or an unpromising vertex, it does not make any con-tribution to the generation of quasi-cliques. Thereby, after getting the valid extensible candidate set V G vad ( g ) , once we inspect the ex-istence of failed-vertices or unpromising vertices in g , then there is no hope to grow instance g to generate quasi-cliques, and thus we can stop growing g .
By integrating the pruning techniques proposed in this paper with the vice-frequent subgraph enumeration framework, we can discover the complete set of frequent quasi-cliques. How do we discover the closed quasi-cliques? A straightforward approach is to store all the frequent quasi-cliques that we have found, and when inserting a quasi-clique q to the result, we do super-clique-detecting which checks whether there already exists an element q such that can subsume the current q and sub-clique-detecting which checks if there exists any already mined quasi-clique q that can be sub-sumed by q . Obviously, this na  X   X ve approach is very costly, we will introduce a more efficient closure checking scheme.

Given two subgraphs, G 1 and G 2 , with canonical forms CF = a 1 a 2 ...a n and CF ( G 2 )= b 1 b 2 ...b m (where n&lt;m ) respectively, if CF ( G 1 ) CF ( G 2 ) ,theremustexist n integers 1  X  i i  X  m such that a 1 = b i 1 , a 2 = b i 2 , ..., a n = b i tionship of CF ( G 1 ) and CF ( G 2 ) in the enumeration tree can be il-lustrated in Figure 3(a), that is, the node corresponding to CF is an ancestor of the node corresponding to CF ( G 2 ) .Otherwise, let k = min { j | i j = j } ,then CF ( G 1 ) and CF ( G 2 prefix a 1 a 2 ...a k  X  1 (if k =1 , the prefix is empty) and a a = b i and this relationship in the enumeration tree is shown in Figure 3(b). Figure 3: Two Cases of CF ( G 1 ) CF ( G 2 ) in Vice-Frequent Subgraph Enumeration Tree
One strategy to speed up the pattern closure checking is that we postpone the closure checking for G 1 until all its descendants have been processed. In this way, G 2 must be discovered before G the first case shown in Figure 3(a), as the node CF ( G 2 dant of CF ( G 1 ) . In the second case as shown in Figure 3(b), it is evident that G 2 is also discovered before G 1 according to the DFS traverse strategy. In summary, if the current quasi-clique G be subsumed by another frequent closed  X  -quasi-clique G CF ( G 1 ) CF ( G 2 ) and sup D s ( G 1 )  X  sup D s ( G 2 of G 2 into the result set will occur before the closure checking of G . Accordingly, when we check if a frequent quasi-clique q is closed or not, there is no need to perform sub-clique-detecting ,as there does not exist any quasi-clique q in the result set such that CF ( q ) CF ( q ) and sup D s ( q )  X  sup D s ( q ) .

Although there is no need for sub-clique-detecting , we still have to perform super-clique-detecting . As shown in Figure 3, there are two cases for super-clique-detecting . In the first case, we need to check if there exists a descendant quasi-clique G 2 rent quasi-clique G 1 that can subsume G 1 in the enumeration tree. According to our strategy described above, we know G 1 must be mined after all its descendants, the super-clique-detecting in this case becomes relatively simple. After the processing of all de-scendants of G 1 , we let the recursive mining procedure return the maximum strict-support (denoted by r ) of all frequent quasi-clique nodes under the subtree rooted with CF ( G 1 ) (if there does not ex-ist any frequent quasi-clique, then it returns value zero). If sup  X  r , we know G 1 is non-closed and will not insert G 1 into the re-exists any non-descendant super-clique of G 1 that can subsume G (i.e., the second case shown in Figure 3(b)).

In order to accelerate the non-descendant super-clique-detecting process, we divide the elements in the result set into different groups according to their absolute strict-support. In each group, we first or-der them by the size of the quasi-cliques in descending order, and among the quasi-cliques with the same size in the same group, we then order them by their canonical form in descending order. This processing can accelerate the comparison steps.
In the following we describe the Cocain algorithm by integrating various techniques discussed earlier. Let us first introduce the S A
LGORITHM 1: Valid , which is called by Cocain in order to com-pute the valid extensible candidates for an instance subgraph. For each vertex u in current instance g ,wescanthegraph G in which g resides to find the set D ( u ) (line 06), and refine D ( combination pruning technique (line 07). Then we generate the set I ( u ) from D ( u ) , obtain the extensible candidate set T of u (lines 08-10), and conjoin each discovered extensible candidate set to get the global extensible candidates rs (line 11). Finally, we apply the vertex connectivity pruning (line 12), critical connectivity pruning, and subgraph connectivity pruning (lines 13-14) to rs to generate the final set of valid extensible candidates w.r.t. g .

Before running Cocain as shown in A LGORITHM 1, we first compute the set of vice-frequent vertex labels and their correspond-ing instances by scanning the original database, and remove from the graph database the vertices with non-vice-frequent vertex la-bels. This procedure can reduce the size of input graphs signifi-cantly, especially when min sup is high. After this preprocessing, we use Cocain to mine the complete set of frequent closed coher-ent quasi-cliques. For the curre nt prefix vice-frequent subgraph g , we first use procedure Valid to get the set of valid extensible candidates V vad for each instance of g (lines 17-18), from which we can further calculate the vice frequent extensible labels (line 19). For each vice-frequent extensible label, we invoke Cocain to discover descendants of g (lines 21-23). After all recursive invo-cations have returned, we can use the closure checking scheme to determine whether or not to insert g to the final result set according to the strict-support of g and the returned values of the recursive invocations (lines 24-25).

We conducted an extensive performance study to evaluate var-ious aspects of the algorithm. We implemented the algorithm in C++, and all experiments were performed on a PC running FC 4 Linux and with 1.8GHz AMD Sempron CPU and 1GB memory. In the experiments, we used the US stock market series database [2], which was converted to a set of graphs based on the same method of [5]. Due to limited space, here we only report the results w.r.t. a correlation coefficient of 0.99.
 Efficiency Test . We implemented one baseline algorithm, Raw, which excludes three pruning techniques, combination pruning , crit-ical connectivity pruning ,and subgraph connectivity pruning .By comparing the runtime efficiency between Cocain and Raw, we can get an idea about the effectiveness of the pruning techniques pro-posed in this paper. Figure 4 shows the runtime comparison be-tween Cocain and Raw by fixing  X  at 1.0 and varying min sup ,and fixing min sup at 40% and varying  X  respectively. We see that Cocain is always faster than Raw. The high performance of Co-cain in comparison with Raw also demonstrates that the pruning techniques proposed for Cocain are extremely effective. Scalability Test . Meanwhile, a comprehensive scalability study was conducted in terms of the base size. The results show that Cocain has linear scalability in run time against the number of input graphs in database.
In this paper we proposed a novel algorithm, Cocain, to mine fre-quent closed coherent quasi-cliques from large dense graph databases. By focusing on vertex labels, we first introduced a simple canoni-cal form to uniquely represent a quasi-clique pattern. By exploring some nice properties of quasi-clique patterns, we proposed several effective search space pruning techniques, diameter pruning, com-bination pruning, vertex connectivity pruning, critical connectiv-ity pruning, and subgraph connectivity pruning , which could be used to accelerate the mining process. We also introduced an ef-ficient pattern closure checking scheme to speed up the discovery of closed quasi-cliques. An extensive performance study with both real and synthetic databases has demonstrated that Cocain is very efficient and scalable.
The authors are grateful to Vladimir L. Boginski, Panos M. Parda-los, and Sergiy Butenko for providing us the US stock market database. We thank Jasmine Zhou and Haiyan Hu for sending us the yeast microarray database and Michihiro Kuramochi for sending us the KEGG database. Thanks also go to Beng Chin Ooi, Anthony K. H. Tung and Xifeng Yan for their kind help. [1] R. Agrawal, R. Srikant. Fast Algorithms for Mining [2] V. Boginski, S. Butenko, P.M. Pardalos. On structural [3] H. Hu, X. Yan, Y. Hang, J. Han, X. Zhou. Mining coherent [4] J. Pei, D. Jiang, A. Zhang. On mining cross-graph [5] J. Wang, Z. Zeng, L. Zhou. CLAN:An Algorithm for Mining [6] X. Yan, X. Zhou, J. Han. Mining closed relational graphs
