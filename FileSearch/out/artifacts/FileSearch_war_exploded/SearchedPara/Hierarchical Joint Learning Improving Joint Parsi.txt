 Joint learning of multiple types of linguistic struc-ture results in models which produce more consis-tent outputs, and for which performance improves across all aspects of the joint structure. Joint models can be particularly useful for producing analyses of sentences which are used as input for higher-level, more semantically-oriented systems, such as question answering and machine trans-lation. These high-level systems typically com-bine the outputs from many low-level systems, such as parsing, named entity recognition (NER) and coreference resolution. When trained sepa-rately, these single-task models can produce out-puts which are inconsistent with one another, such as named entities which do not correspond to any nodes in the parse tree (see Figure 1 for an ex-ample). Moreover, one expects that the different types of annotations should provide useful infor-mation to one another, and that modeling them jointly should improve performance. Because a named entity should correspond to a node in the parse tree, strong evidence about either aspect of the model should positively impact the other as-pect.

However, designing joint models which actu-ally improve performance has proven challeng-ing. The CoNLL 2008 shared task (Surdeanu et al., 2008) was on joint parsing and semantic role labeling, but the best systems (Johansson and Nugues, 2008) were the ones which completely decoupled the tasks. While negative results are rarely published, this was not the first failed at-tempt at joint parsing and semantic role label-ing (Sutton and McCallum, 2005). There have been some recent successes with joint modeling. Zhang and Clark (2008) built a perceptron-based joint segmenter and part-of-speech (POS) tagger for Chinese, and Toutanova and Cherry (2009) learned a joint model of lemmatization and POS tagging which outperformed a pipelined model. Adler and Elhadad (2006) presented an HMM-based approach for unsupervised joint morpho-logical segmentation and tagging of Hebrew, and Goldberg and Tsarfaty (2008) developed a joint model of segmentation, tagging and parsing of He-brew, based on lattice parsing. No discussion of joint modeling would be complete without men-tion of (Miller et al., 2000), who trained a Collins-style generative parser (Collins, 1997) over a syn-tactic structure augmented with the template entity and template relations annotations for the MUC-7 shared task.

One significant limitation for many joint mod-els is the lack of jointly annotated data. We built a joint model of parsing and named entity recog-nition (Finkel and Manning, 2009b), which had small gains on parse performance and moderate gains on named entity performance, when com-pared with single-task models trained on the same data. However, the performance of our model, trained using the OntoNotes corpus (Hovy et al., 2006), fell short of separate parsing and named NP
CD entity models trained on larger corpora, annotated with only one type of information.

This paper addresses the problem of how to learn high-quality joint models with smaller quan-tities of jointly-annotated data that has been aug-mented with larger amounts of single-task an-notated data. To our knowledge this work is the first attempt at such a task. We use a hi-erarchical prior to link a joint model trained on jointly-annotated data with other single-task mod-els trained on single-task annotated data. The key to making this work is for the joint model to share some features with each of the single-task models. Then, the singly-annotated data can be used to in-fluence the feature weights for the shared features in the joint model. This is an important contribu-tion, because it provides all the benefits of joint modeling, but without the high cost of jointly an-notating large corpora. We applied our hierarchi-cal joint model to parsing and named entity recog-nition, and it reduced errors by over 20% on both tasks when compared to a joint model trained on only the jointly annotated data. Our task can be viewed as an instance of multi-task learning , a machine learning paradigm in which the objective is to simultaneously solve multiple, related tasks for which you have separate labeled training data. Many schemes for multitask learn-ing, including the one we use here, are instances of hierarchical models. There has not been much work on multi-task learning in the NLP com-munity; Daum  X e III (2007) and Finkel and Man-ning (2009a) both build models for multi-domain learning, a variant on domain adaptation where there exists labeled training data for all domains and the goal is to improve performance on all of them. Ando and Zhang (2005) utilized a multi-task learner within their semi-supervised algo-rithm to learn feature representations which were useful across a large number of related tasks. Out-side of the NLP community, Elidan et al. (2008) used an undirected Bayesian transfer hierarchy to jointly model the shapes of multiple mammal species. Evgeniou et al. (2005) applied a hier-archical prior to modeling exam scores of stu-dents. Other instances of multi-task learning in-clude (Baxter, 1997; Caruana, 1997; Yu et al., 2005; Xue et al., 2007). For a more general discus-sion of hierarchical models, we direct the reader to Chapter 5 of (Gelman et al., 2003) and Chapter 12 of (Gelman and Hill, 2006). In this section we will discuss the main con-tribution of this paper, our hierarchical joint model which improves joint modeling perfor-mance through the use of single-task models which can be trained on singly-annotated data . Our experiments are on a joint parsing and named entity task, but the technique is more general and only requires that the base models (the joint model and single-task models) share some features. This section covers the general technique, and we will cover the details of the parsing, named entity, and joint models that we use in Section 4. 3.1 Intuitive Overview As discussed, we have a joint model which re-quires jointly-annotated data, and several single-task models which only require singly-annotated data. The key to our hierarchical model is that the joint model must have features in common with each of the single models, though it can also have features which are only present in the joint model. Figure 2: A graphical representation of our hierar-chical joint model. There are separate base models for just parsing, just NER, and joint parsing and NER. The parameters for these models are linked via a hierarchical prior.
 Each model has its own set of parameters (feature weights). However, parameters for the features which are shared between the single-task models and the joint model are able to influence one an-other via a hierarchical prior. This prior encour-ages the learned weights for the different models to be similar to one another. After training has been completed, we retain only the joint model X  X  parameters. Our resulting joint model is of higher quality than a comparable joint model trained on only the jointly-annotated data, due to all of the ev-idence provided by the additional single-task data. 3.2 Formal Model We have a set M of three base models: a parse-only model, an NER-only model and a joint model. These have corresponding log-likelihood functions L L ( D j ;  X  j ) , where the D s are the training data for each model, and the  X  s are the model-specific pa-rameter (feature weight) vectors. These likelihood functions do not include priors over the  X  s. For representational simplicity, we assume that each of these vectors is the same size and corresponds to the same ordering of features. Features which don X  X  apply to a particular model type (e.g., parse features in the named entity model) will always be zero, so their weights have no impact on that model X  X  likelihood function. Conversely, allowing the presence of those features in models for which they do not apply will not influence their weights in the other models because there will be no evi-dence about them in the data. These three models are linked by a hierarchical prior, and their fea-ture weight vectors are all drawn from this prior. The parameters  X  mensionality as the model-specific parameters  X  and are drawn from another, top-level prior. In our
The graphical representation of our hierarchical model is shown in Figure 2. The log-likelihood of this model is The first summation in this equation computes the log-likelihood of each model, using the data and parameters which correspond to that model, and the prior likelihood of that model X  X  parameters, based on a Gaussian prior centered around the top-level, non-model-specific parameters  X  with model-specific variance  X  mation in the equation computes the prior likeli-hood of the top-level parameters  X  Gaussian prior with variance  X  ically zero). This formulation encourages each base model to have feature weights similar to the top-level parameters (and hence one another).
The effects of the variances  X  some discussion.  X  of dictating how much the model  X  X ares X  about feature weights diverging from zero (or  X  ). The model-specific variances,  X  ferent interpretation. They dictate how how strong the penalty is for the domain-specific parameters to diverge from one another (via their similarity to  X  ). When  X  aged to be very similar, and taken to the extreme this is equivalent to completely tying the parame-ters between the tasks. When  X  then there is less encouragement for the parame-ters to be similar, and taken to the extreme this is equivalent to completely decoupling the tasks.
We need to compute partial derivatives in or-der to optimize the model parameters. The partial derivatives for the parameters for each base model m are given by: where the first term is the partial derivative ac-cording to the base model, and the second term is the prior centered around the top-level parameters. The partial derivatives for the top level parameters  X  where the first term relates to how far each model-specific weight vector is from the top-level param-eter values, and the second term relates how far each top-level parameter is from zero.

When a model has strong evidence for a feature, effectively what happens is that it pulls the value of the top-level parameter for that feature closer to the model-specific value for it. When it has little or no evidence for a feature then it will be pulled in the direction of the top-level parameter for that feature, whose value was influenced by the models which have evidence for that feature. 3.3 Optimization with Stochastic Gradient Inference in joint models tends to be slow, and of-ten requires the use of stochastic optimization in order for the optimization to be tractable. L-BFGS and gradient descent, two frequently used numer-ical optimization algorithms, require computing the value and partial derivatives of the objective function using the entire training set. Instead, we use stochastic gradient descent. It requires a stochastic objective function, which is meant to be a low computational cost estimate of the real ob-jective function. In most NLP models, such as lo-gistic regression with a Gaussian prior, computing the stochastic objective function is fairly straight-forward: you compute the model likelihood and partial derivatives for a randomly sampled subset of the training data. When computing the term for the prior, it must be rescaled by multiplying its value and derivatives by the proportion of the training data used. The stochastic objective func-tion, where b D X  X  is a randomly drawn subset of the full training set, is given by
L stoch ( D ;  X  ) = L orig ( b D ;  X  )  X  This is a stochastic function, and multiple calls to it with the same D and  X  will produce different values because b D is resampled each time. When designing a stochastic objective function, the crit-ical fact to keep in mind is that the summed values and partial derivatives for any split of the data need to be equal to that of the full dataset. In practice, stochastic gradient descent only makes use of the partial derivatives and not the function value, so we will focus the remainder of the discussion on how to rescale the partial derivatives.

We now describe the more complicated case of stochastic optimization with a hierarchical ob-jective function. For the sake of simplicity, let us assume that we are using a batch size of one, meaning | b D| = 1 in the above equation. Note that in the hierarchical model, each datum (sen-tence) in each base model should be weighted equally, so whichever dataset is the largest should be proportionally more likely to have one of its data sampled. For the sampled datum d , we then compute the function value and partial derivatives with respect to the correct base model for that da-tum. When we rescale the model-specific prior, we rescale based on the number of data in that model X  X  training set, not the total number of data in all the models combined. Having uniformly randomly drawn datum d  X  S tell us to which model X  X  training data the datum belongs. The stochastic partial derivatives will equal zero for all model parameters  X  m 6 = m ( d ) , and for  X  m ( d ) it becomes: Now we will discuss the stochastic partial deriva-tives with respect to the top-level parameters  X  which requires modifying Equation 3. The first term in that equation is a summation over all the models. In the stochastic derivative we only perform this computation for the datum X  X  model m ( d ) , and then we rescale that value based on the number of data in that datum X  X  model |D second term in that equation is rescaled by the to-tal number of data in all models combined. The stochastic partial derivatives with respect to  X  come: where for conciseness we omit  X  under the as-sumption that it equals zero.

An equally correct formulation for the partial derivative of  X  by the total number of data in all models. Early experiments found that both versions gave simi-lar performance, but the latter was significantly Hilary Figure 3: A linear-chain CRF (a) labels each word, whereas a semi-CRF (b) labels entire entities. A semi-CRF can be represented as a tree (c) , where i indicates an internal node for an entity. slower to compute because it required summing over the parameter vectors for all base models in-stead of just the vector for the datum X  X  model.
When using a batch size larger than one, you compute the given functions for each datum in the batch and then add them together. Our hierarchical joint model is composed of three separate models, one for just named entity recog-nition, one for just parsing, and one for joint pars-ing and named entity recognition. In this section we will review each of these models individually. 4.1 Semi-CRF for Named Entity Recognition For our named entity recognition model we use a semi-CRF (Sarawagi and Cohen, 2004; Andrew, 2006). Semi-CRFs are very similar to the more popular linear-chain CRFs, but with several key advantages. Semi-CRFs segment and label the text simultaneously, whereas a linear-chain CRF will only label each word, and segmentation is im-plied by the labels assigned to the words. When doing named entity recognition, a semi-CRF will have one node for each entity, unlike a regular See Figure 3a-b for an example of a semi-CRF and a linear-chain CRF over the same sentence. Note that the entity Hilary Clinton has one node in the semi-CRF representation, but two nodes in the linear-chain CRF. Because different segmen-tations have different model structures in a semi-CRF, one has to consider all possible structures (segmentations) as well as all possible labelings. It is common practice to limit segment length in order to speed up inference, as this allows for the use of a modified version of the forward-backward algorithm. When segment length is not restricted, the inference procedure is the same as that used work we do not enforce a length restriction, and directly utilize the fact that the model can be trans-formed into a parsing model. Figure 3c shows a parse tree representation of a semi-CRF.

While a linear-chain CRF allows features over adjacent words, a semi-CRF allows them over ad-jacent segments. This means that a semi-CRF can utilize all features used by a linear-chain CRF, and can also utilize features over entire segments, such as First National Bank of New York City , instead of just adjacent words like First National and Bank of . Let y be a vector representing the labeling for an entire sentence. y segment, along with the span of words the seg-ment encompasses. Let  X  be the feature weights, and f ( s, y cent segments y likelihood of a semi-CRF for a single sentence s is given by:
L ( y | s ;  X  ) = The partition function Z It requires summing over the set y segmentations and labelings for the sentence s : -i billion tion.

Because we use a tree representation, it is easy to ensure that the features used in the NER model are identical to those in the joint parsing and named entity model, because the joint model (which we will discuss in Section 4.3) is also based on a tree representation where each entity corresponds to a single node in the tree. 4.2 CRF-CFG for Parsing Our parsing model is the discriminatively trained, conditional random field-based context-free gram-mar parser (CRF-CFG) of (Finkel et al., 2008). The relationship between a CRF-CFG and a PCFG is analogous to the relationship between a linear-chain CRF and a hidden Markov model (HMM) for modeling sequence data. Let t be a com-plete parse tree for sentence s , and each lo-cal subtree r  X  t encodes both the rule from the grammar, and the span and split informa-tion (e.g NP the last two words in Figure 1). The feature func-tion f ( r, s ) computes the features, which are de-fined over a local subtree r and the words of the sentence. Let  X  be the vector of feature weights. The log-likelihood of tree t over sentence s is: To compute the partition function Z serves to normalize the function, we must sum over  X  ( s ) , the set of all possible parse trees for sentence s . The partition function is given by: We also need to compute the partial derivatives which are used during optimization. Let f be the value of feature i for subtree r over sen-tence s , and let E feature i in sentence s , based on the current model parameters  X  . The partial derivatives of  X  are then given by Just like with a linear-chain CRF, this equation will be zero when the feature expectations in the model equal the feature values in the training data.
A variant of the inside-outside algorithm is used to efficiently compute the likelihood and partial derivatives. See (Finkel et al., 2008) for details. 4.3 Joint Model of Parsing and Named Entity Our base joint model for parsing and named entity recognition is the same as (Finkel and Manning, 2009b), which is also based on the discriminative parser discussed in the previous section. The parse tree structure is augmented with named entity in-formation; see Figure 4 for an example. The fea-tures in the joint model are designed in a man-ner that fits well with the hierarchical joint model: some are over just the parse structure, some are over just the named entities, and some are over the joint structure. The joint model shares the NER and parse features with the respective single-task models. Features over the joint structure only ap-pear in the joint model, and their weights are only indirectly influenced by the singly-annotated data.
In the parsing model, the grammar consists of only the rules observed in the training data. In the joint model, the grammar is augmented with ad-Table 1: Training and test set sizes for the five datasets in sentences. The file ranges refer to the numbers within the names of the original OntoNotes files. ditional joint rules which are composed by adding named entity information to existing parse rules. Because the grammars are based on the observed data, and the two models have different data, they will have somewhat different grammars. In our hi-erarchical joint model, we added all observed rules from the joint data (stripped of named entity infor-mation) to the parse-only grammar, and we added all observed rules from the parse-only data to the grammar for the joint model, and augmented them with named entity information in the same manner as the rules observed in the joint data.

Earlier we said that the NER-only model uses identical named entity features as the joint model (and similarly for the parse-only model), but this is not quite true. They use identical feature tem-plates , such as word , but different realizations of those features will occur with the different datasets. For instance, the NER-only model may have word=Nigel as a feature, but because Nigel never occurs in the joint data, that feature is never manifested and no weight is learned for it. We deal with this similarly to how we dealt with the gram-mar: if a named entity feature occurs in either the joint data or the NER-only data, then both mod-els will learn a weight for that feature. We do the same thing for the parse features. This modeling decision gives the joint model access to potentially useful features to which it would not have had ac-We compared our hierarchical joint model to a reg-ular (non-hierarchical) joint model, and to parse-only and NER-only models. Our baseline ex-periments were modeled after those in (Finkel and Manning, 2009b), and while our results were not identical (we updated to a newer release of the data), we had similar results and found the same general trends with respect to how the joint model improved on the single models. We used OntoNotes 3.0 (Hovy et al., 2006), and made the same data modifications as (Finkel and Manning, 2009b) to ensure consistency between the parsing and named entity annotations. Table 2 has our complete set of results, and Table 1 gives the num-ber of training and test sentences. For each sec-tion of the data (ABC, MNB, NBC, PRI, VOA) we ran experiments training a linear-chain CRF on only the named entity information, a CRF-CFG parser on only the parse information, a joint parser and named entity recognizer, and our hierarchi-cal model. For the hierarchical model, we used the CNN portion of the data ( 5093 sentences) for the extra named entity data (and ignored the parse trees) and the remaining portions combined for the extra parse data (and ignored the named entity an-notations). We used  X  which were chosen based on early experiments on development data. Small changes to  X  appear to have much influence, but larger changes do. We similarly decided how many iterations to run stochastic gradient descent for ( 20 ) based on early development data experiments. We did not run this experiment on the CNN portion of the data, because the CNN data was already being used as the extra NER data.

As Table 2 shows, the hierarchical model did substantially better than the joint model overall, which is not surprising given the extra data to which it had access. Looking at the smaller cor-pora (NBC and MNB) we see the largest gains, with both parse and NER performance improving by about 8% F1. ABC saw about a 6% gain on both tasks, and VOA saw a 1% gain on both. Our one negative result is in the PRI portion: parsing improves slightly, but NER performance decreases by almost 2% . The same experiment on develop-ment data resulted in a performance increase, so we are not sure why we saw a decrease here. One general trend, which is not surprising, is that the hierarchical model helps the smaller datasets more than the large ones. The source of this is two-fold: lower baselines are generally easier to im-prove upon, and the larger corpora had less singly-annotated data to provide improvements, because it was composed of the remaining, smaller, sec-tions of OntoNotes. We found it interesting that the gains tended to be similar on both tasks for all datasets, and believe this fact is due to our use of roughly the same amount of singly-annotated data for both parsing and NER.

One possible conflating factor in these experi-ments is that of domain drift. While we tried to ABC Just Parse 69.8% 69.9% 69.8%  X  MNB Just Parse 61.7% 65.5% 63.6%  X  NBC Just Parse 59.9% 63.9% 61.8%  X  PRI Just Parse 78.6% 77.0% 76.9%  X  VOA Just Parse 77.5% 76.5% 77.0%  X  get the most similar annotated data available  X  data which was annotated by the same annotators, and all of which is broadcast news  X  these are still dif-ferent domains. While this is likely to have a nega-tive effect on results, we also believe this scenario to be a more realistic than if it were to also be data drawn from the exact same distribution. In this paper we presented a novel method for improving joint modeling using additional data which has not been labeled with the entire joint structure. While conventional wisdom says that adding more training data should always improve performance, this work is the first to our knowl-edge to incorporate singly-annotated data into a joint model, thereby providing a method for this additional data, which cannot be directly used by the non-hierarchical joint model, to help improve joint modeling performance. We built single-task models for the non-jointly labeled data, designing those single-task models so that they have features in common with the joint model, and then linked all of the different single-task and joint models via a hierarchical prior. We performed experi-ments on joint parsing and named entity recogni-tion, and found that our hierarchical joint model substantially outperformed a joint model which was trained on only the jointly annotated data.
Future directions for this work include automat-ically learning the variances,  X  erarchical model, so that the degree of information sharing between the models is optimized based on the training data available. We are also interested in ways to modify the objective function to place more emphasis on learning a good joint model, in-stead of equally weighting the learning of the joint and single-task models.
 Many thanks to Daphne Koller for discussions which led to this work, and to Richard Socher for his assistance and input. Thanks also to our anonymous reviewers and Yoav Goldberg for use-ful feedback on an earlier draft of this paper.
This material is based upon work supported by the Air Force Research Laboratory (AFRL) un-der prime contract no. FA8750-09-C-0181. Any opinions, findings, and conclusion or recommen-dations expressed in this material are those of the author(s) and do not necessarily reflect the view of the Air Force Research Laboratory (AFRL). The first author is additionally supported by a Stanford Graduate Fellowship.
