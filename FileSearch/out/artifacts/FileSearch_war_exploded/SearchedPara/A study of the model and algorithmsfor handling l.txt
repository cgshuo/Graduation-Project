 REGULAR PAPER Manish Gupta  X  Manghui Tu  X  Latifur Khan  X  Farokh Bastani  X  I-Ling Yen Abstract Advances in wireless and mobile computing environments allow a mobile user to access a wide range of applications. For example, mobile users may want to retrieve data about unfamiliar places or local life styles related to their location. These queries are called location-dependent queries. Furthermore, a mo-bile user may be interested in getting the query results repeatedly, which is called location-dependent continuous querying. This continuous query emanating from a mobile user may retrieve information from a single-zone (single-ZQ) or from multiple neighbouring zones (multiple-ZQ). We consider the problem of handling location-dependent continuous queries with the main emphasis on reducing com-munication costs and making sure that the user gets correct current-query result. The key contributions of this paper include: (1) Proposing a hierarchical database framework (tree architecture and supporting continuous query algorithm) for handling location-dependent continuous queries. (2) Analysing the flexibility of this framework for handling queries related to single-ZQ or multiple-ZQ and propose intelligent selective placement of location-dependent databases. (3) Proposing an intelligent selective replication algorithm to facilitate time-and space-efficient processing of location-dependent continuous queries retrieving single-ZQ information. (4) Demonstrating, using simulation, the significance of our intelligent selective placement and selective replication model in terms of communication cost and storage constraints, considering various types of queries. Keywords Mobile computing  X  Location-dependent queries  X  Location-dependent continuous querying  X  Multiple-ZQ  X  Single-ZQ  X  Hierarchical database framework 1 Introduction In a mobile computing environment, mobile users are located in system-defined zones that correspond to bounded geographical areas. Advances in wireless and mobile computing environments allow a mobile user to retrieve data about unfa-miliar places or local life styles related to their current zone.
 verse [ 22 , 27 ]. A mobile user may want to retrieve data about unfamiliar places or local life styles related to his current location. The data, the value of which dent data ( LDD ) [5, 18 X 20]. Accordingly, we define the fixed LDD-based user location-dependent query ( FULDQ ) as a query issued by a mobile user ,where the LDD involved is fixed . For example, a mobile user, while driving a car, might be interested in finding nearest hotels and issues a query:  X  X ist all hotels within 1 mile radius of my current location. X  Besides this, a user may ask,  X  X ow much sales tax did I pay? X  This query is fully location independent. Also, a user may ask,  X  X hat is the room rate at Denver X  X  Holiday Inn?. X  This query retrieves LDD, but is not a FULDQ because it is not dependent on the user X  X  current location. Furthermore, in the query  X  X ind all neighbouring cars within 100 feet of my car, X  the LDDs involved in the query are not fixed and are not considered in this paper.
 For example, the user may ask,  X  X ist all hotels within 1-km radius of my current location in intervals of 15 minutes. X  Because the user is moving, with the progres-sion of time, the results of the query must be updated to reflect the user X  X  changing location. We define a fixed LDD-based user location-dependent continuous query ( FULDCQ ) as a continuous FULDQ, which gets re-activated after every fixed time interval.
 example, if the user requests a list of all hotels within a 1-mile radius of his current location in intervals of 15 min, then the LDD may correspond to the user X  X  current base station or zone only, assuming that a single base station covers a 1-mile ra-dius. But if the user request is to list all hotels within a 3-mile radius of his current location in intervals of 15 min, the LDD may correspond to multiple neighbour-ing zones, extrapolating from the above and assuming that a 3-mile radius is now covered by more than one base station.
 FULDCQ in a mobile environment. This approach relies on a tree structure that is flexible enough to handle queries of either single-ZQ or multiple-ZQ. The primary contributions in this paper are: 1. Proposing a hierarchical framework for handling location-dependent contin-uous queries. The system maintains two types of databases, user location database (ULDB) that stores mobile users X  current location information and location-dependent database (LDDB) that stores LDD for specific base stations (zones), maintained at some nodes in the tree. We propose a hybrid scheme for storing users X  location information in ULDB and propose a continuous-query algorithm that can efficiently handle FULDCQ in our hierarchical framework by reducing communication costs. 2. Analysing the flexibility of our framework for handling FULDCQ related to single-ZQ or multiple-ZQ. For handling multiple-ZQ (excluding all-zone queries that access information related to all zones), selective placement (SP) of more than one LDDB at some intermediate level nodes in the tree yields the best performance. For handling single-ZQ, base station placement (BP) with multiple LDDB at the base stations is the optimum LDDB-placement strategy.
This intelligent selective LDDB placement strives to reduce network message hops (NMH, i.e. communication cost). 3. Proposing a selective replication algorithm in the context of FULDCQ of type single-ZQ that is complementary to [ 15 ]. Our replication algorithm is based on the users X  query pattern. If a particular type of single-ZQ frequently emanates from a particular zone, then we only replicate its corresponding
LDD in that zone. This selective replication will serve to reduce NMH and, at the same time, the degree of replication would be limited by the storage constraint. 4. Demonstrate using simulation that, with queries of multiple-ZQ or mixed types, intelligent selective LDDB placement incurs less communication cost than base station placement (BP) or root placement (RP) (both BP and RP will be defined later). And when the queries are only of single-ZQ types, intelligent selective
LDD replication will incur less communication cost for different degrees of replication and storage constraints than having no replication.
 ground about the basic architectures for managing mobile users X  current loca-tion and some of the assumptions that we made about the problem and the net-work chosen. Section 3 presents our proposed framework for handling FULDCQ. Section 4 presents selective replication in detail. Section 5 describes the simula-tion of our system, including details about the performance of various approaches. Section 6 briefly describes some related work. Finally, Sect. 7 presents the con-clusion and future work. 2 Background The location of a mobile user plays a significant role in processing FULDCQ. The basic database architectures for storing the location of the mobile users are distributed and centralised databases. The two most common approaches for [ 4 , 17 , 23 , 31 ].
 is associated with each mobile user. The HLR is located at the zone prespecified for each user. It maintains the current location of the user as a part of the users X  VLR at a zone stores copies of the profiles of a user not at their home location and currently located inside that zone. One major drawback of the two-tier approach is that it does not scale well with highly distributed systems where sites or zones are geographically widely dispersed. To track a mobile user, the possibly distant home location must be contacted first. Similarly, even a move to a nearby location must be registered at a potentially distant home location.
 archy of location databases. In this hierarchy, a location database at a higher level contains location information for users located at levels below it. Usually, the hi-erarchy is tree structured. A location database at a leaf serves a single zone (base station) and contains entries of all users registered in this zone. A database at an internal node maintains information about users registered in the set of zones in its subtree. When hierarchical location databases are used, there is no need for bind-ing a user to a specific HLR. The user can be tracked by querying the databases in the hierarchy. In the worst case, an entry for the user will be found in the database at the root. Thus, the hierarchical scheme leads to a reduction in communication cost when most moves of the users are geographically localised. In such cases, instead of contacting the HLR of the user that may be located far away from the user X  X  current location, a small number of location databases in the user X  X  neigh-bourhood are accessed.
 single centralised database management system ( DBMS ). All location queries and updates are directed to the central DBMS. Using an existing DBMS is not suffi-cient because existing DBMS does not handle continuously changing data well, such as the location of the moving objects. Also, while processing FULDCQ, the centralised approach will not scale up well when the number of mobile users in-architecture for processing FULDCQ. This is because location databases in a tree architecture are physically structured based on location. Also, the mobile user can be tracked efficiently by querying in a tree. 3 Framework We propose a hierarchical database framework (tree architecture and supporting CQ algorithm) for handling location-dependent continuous queries that provide present the basic assumptions made about our tree framework and the problem. We also analyse the flexibility of this framework for handling queries related to single-ZQ or multiple-ZQ.
 asshowninFig. 1 . The geographical coverage area is partitioned into wireless zones. Each zone is serviced by a base station (BS), which is represented by a leaf node in the tree. In Fig. 1 , the leaf nodes 7, 8, 9, 10, 11 and 12 are the base stations.
 database (ULDB) that stores a mobile users X  current location information. The other is the location-dependent database (LDDB) that stores LDD for specific base stations.
 nodes), but ULDBs are maintained at every node. The LDDB at an internal node maintains LDD for all base stations within its subtree. For example, in Fig. 1 ,the LDDB nodes are 1 and 2. Node 1 will contain LDD for BS 7, 8 and 9; node 2 will contain LDD for BS 10, 11 and 12. Also, in Fig. 1 , ULDBs are placed at each node of the tree. The ULDB at a leaf node serves a single base station and contains location information for all users currently in this base station. The ULDB at an internal node maintains location information about all users currently in the set of the base stations in its subtree. 3.1 Assumptions Some of the assumptions that we make about our tree framework and the problem are discussed below. The assumptions about our tree framework are as follows:  X 
Databases at the leaf nodes (base stations) and internal nodes have storage and query processing capabilities, but leaf node storage is relatively limited.  X 
Databases are usually interconnected through links of the intelligent signaling network [ 1 , 31 ].  X  All nodes maintain information about each BS X  X  LDDB node, e.g. if BS x X  X 
LDDB node is y, then LDD of BS x can be found in node y and all nodes know about this information.  X 
All the leaf nodes (base stations) might not be geographically located in a linear order from left to right as shown in Fig. 1 , but could be geographically located in a nonlinear fashion. At the same time, the base stations within the network only correspond to local regions, like nearby cities, nearby counties and not re-gions that are geographically far apart, like different countries or even different states. Thus, a mobile user is able to move between any two base stations in the network.
  X 
We consider FULDQ types where the user requesting a query is moving and the objects related to the query are fixed.  X 
We consider continuous queries where the answer is automatically updated by the system as opposed to instantaneous queries, for which only a one-time an-swer is obtained.
  X 
We consider all the queries as equally important and do not give any preferences to a particular query. 3.2 Database updates We consider LDDB to be a static database, which can only be queried, and rarely needs to be updated because we consider only those types of the FULDQ swhere the objects involved are fixed and not moving. Thus, the database containing LDD for a particular base station is always fixed. For example, information about local restaurants in a particular base station is usually fixed. On the other hand, ULDB is considered to be a dynamic database, which has to be continuously updated. This is because the database stores the users X  current location information. der to keep track of a mobile user, his or her location entry is deleted at some ULDB, updated at some ULDB, and inserted at some ULDB, as discussed in Sect. 3.3. For example in Fig. 1 , consider all ULDBs maintain users X  actual loca-tions. Now a move by a user x from base station 7 to base station 9 causes deletion of his location information from ULDB 7 and ULDB 3, update of his informa-tion at ULDB 1 and ULDB 0, and insertion of his information at ULDB 4 and ULDB 9. 3.3 Hybrid scheme for storing information in ULDB specific ULDBs within the tree. For storing mobile user location information in ULDB, two alternative approaches can be used [ 3 , 12 , 23 ]. In one approach, all ULDBs maintain the actual location of each user. In this approach, a move by a user x from zone i to j causes an update of all its ULDB entries along the paths from j to the root and from the root to i . In this approach, the update cost is quite high, but the lookup cost is comparatively low. In another approach, a pointer is maintained for x  X  X  location that points to lower level ULDBs. In this approach, a move by user x from zone i to j causes update of all its ULDB entries along the paths from j to the LCA ( i , j ) (i.e. the least common ancestor of nodes i and j ) and from the LCA ( i , j )to i . The advantage of maintaining this type of location high. For finding x  X  X  actual location, we need to continually follow the chain of forwarding pointers until we reach the actual location.
 at a certain node where LDDB resides (called LDDB nodes) maintains the users X  actual locations. The rationale behind this is to process FULDCQ at LDDB nodes effectively. The ULDB at nodes that are above the LDDB nodes maintain a pointer to the lower level ULDBs. The ULDB at nodes that are below the LDDB nodes maintain the actual location of the users. For example, in Fig. 2 , consider LDDB nodes 1 and 2 and a mobile user x who is currently in BS 12. Now, there will be an entry in ULDB 0 for user x pointing to the entry for user x in ULDB 2. This entry for user x in ULDB 2 will contain the actual current location of user x ,i.e. location 12. In addition, ULDB 6 and ULDB 12 will contain the actual location of the user x ,i.e.location12. 3.4 Placement of LDDB Different strategies can be used to place LDDB in the tree. We discuss three of these strategies and analyse their performance for query types single-ZQ or multiple-ZQ. 3.4.1 LDDB placed at the root node (RP) A single LDDB can be placed at the root node. In Fig. 2 , a single LDDB placed at root node 0 will contain LDD for all the base stations (7 X 12). RP incurs maximum communication cost when the query type is single-ZQ. For multiple-ZQ, RP may still incur higher communication cost than other strategies because the query will be pushed from the leaf node up toward the root node and the query results will traverse a longer path back to the leaf node (see Sects. 3.6 and 5). But we need to take into consideration the number of zones the queries cover. In an extreme case, if all the queries access information related to all the zones in the system, then RP becomes the best LDDB-placement strategy. 3.4.2 LDDB placed at the base stations (BP) LDDB can be placed at every base station. Thus, LDD of each base station is stored at its respective LDDB. In Fig. 2 , LDD for base station 7 is stored only at node 7. This placement strategy incurs a minimum lookup latency and communi-cation cost when query type is only single-ZQ because it will be handled by the leaf node itself. But this strategy will incur high communication cost when the query type is multiple-ZQ or mixed (see Sects. 3.6 and 5). However, this approach is not realistic due to storage limitations at the base stations and also because, in a real environment, base stations should not be burdened with data-management activities [ 23 ]. This is because, during performance evaluation of our proposed framework, other than communication cost, storage cost will also play an impor-tant role because, in the near future, mobile users might be interested in LDD, which include multimedia information, as a combination of text, graphics, anima-tion, images, sound, speech and still or moving video. This will happen due to the increase of network bandwidth in mobile environments. For example, Universal Mobile Telecommunications System and its new technology will allow increased transmission rates up to 10 Mbps by 2010. It is important to note that this multime-dia data demands huge storage capacity. For example, 3000 colour pictures require 3 Gb storage (640  X  480  X  24 bits = 1 Mb/picture). Furthermore, with the current but may provide a limited filtering mechanism with limited buffering at the packet level. 3.4.3 LDDB placed at selected nodes (SP) Here, LDDBs are placed at selected nodes, leaf or nonleaf nodes or a combination of both. This approach is more realistic. If a base station has a storage limitation, an ancestor node will contain the missing data. In Fig. 2 , if LDDB are placed at nodes 1 and 2, then the LDD of base stations 7, 8, 9 are stored at the LDDB of node 1, the LDD of base stations 10, 11 and 12 are stored at the LDDB of node 2. Detailed discussion on placement policies is given in Sect. 3.6. 3.5 FULDCQ algorithm The LDDB at an internal node maintains the LDD for all base stations within its subtree. We define the valid scope of an LDDB node as the set of base stations within the subtree of this LDDB node. Whenever a mobile user x , currently in the BS D (as shown in Fig. 3 ), issues a continuous query ( CQ ), then D  X  X  LDDB node (let it be node B ) becomes x  X  X  current LDDB node (CLDDBN). CQ is then forwarded to CLDDBN B. The LDDB of CLDDBN B generates a continuous query result (CQR) for the user x at BS D. CLDDBN B after generating CQR checks whether x is still within its scope by checking x  X  X  location in its ULDB. When x changes zone, the new zone may or may not be within the scope of x  X  X  previous CLDDBN B. The two possible cases are shown in Fig. 3 . Case 1 The user x remains within the valid scope of its CLDDBN B. In this case, CLDDBN B checks whether x  X  X  current BS ( XCBS ) is still the same as its LDDB queried BS. If yes, then CLDDBN B forwards the CQR to x . If not, then the LDDB of CLDDBN B regenerates CQR for the user x at base station XCBS.
 Case 2 The user x moves out of the scope of its PLDDBN B (CLDDBN B be-comes x  X  X  previous LDDB node, i.e. PLDDBN). In this case, a user x moves out of the scope of its PLDDBN B. PLDDBN B then redirects the CQ to its par-is found in ULDB. CQ is then redirected to its descendent nodes using x  X  X  en-try in the ULDB till CQ reaches x  X  X  current LDDB node (let it be node C of Fig. 3 ), i.e. following the chain of forwarding pointers for x  X  X  location (see Sect. 3.3). The LDDB of CLDDBN C generates CQR for the user x at base station XCBS.
 x  X  X  current LDDB node finds that XCBS is the same as its LDDB queried BS (as seen in Case 1).
 FULDCQ, is shown in Fig. 4 . The symbols used in the FULDCQ algorithm are summarised in Table 1 . Lines (10 X 17) of the algorithm represent Case 1 , while lines (19 X 28) of the algorithm represent Case 2 . 3.6 Flexibility of hierarchical framework A FULDCQ issued by a mobile user x may be related to a single-ZQ or may be related to multiple-ZQ. For example, if the user requests a list of all hotels within a 1-mile radius of his current location in intervals of 15 min, then the LDD may be related to the user X  X  current base station only, assuming that a single base station will cover a 1-mile radius. But if the user X  X  query requests a list of all hotels within a 3-mile radius of his or her current location in intervals of 15 min, the LDD may be related to multiple neighbouring zones. It is likely that coverage of a 3-mile radius will entail the use of multiple base stations.
 single-ZQ or multiple-ZQ. The framework also facilitates better placement strate-gies because multiple LDDBs can be placed at any level in the hierarchy, depend-ing on the query types.
 3.6.1 Selective placement for multiple-ZQ In our architecture, each LDDB node maintains LDD for all base stations within its subtree. This suggests that, for multiple-ZQ, the selective placement ( SP )of more than one LDDB at some intermediate level in a tree may be a better LDDB-placement strategy. This is because the number of network hop traversals for mes-sages, called network message hops ( NMH ), a key cost in message transmission time, will be reduced. On the other hand, for BP and RP, NMH will be substan-tially high. This is because, in the BP case, the base station receiving a request will not only retrieve results from its own LDDB but will also need to send requests to neighbouring base stations. And in the RP case, the requesting base station will send requests all the way to the root node with results being sent back from the root to the requesting base station. For example, in Fig. 1, a user at base station 7 issues a continuous query asking for a list of all hotels within a 3-mile radius of his or her current location in intervals of 15 min. Let us assume that the area within a 3-mile radius of the users current location will be covered by base stations 7, 8 and 9. With BP, we observe that NMH is equal to 12. This is because base station 7 sends a request to base station 8 and gets back a reply. Thus, a total of 4 NMH (7 to 3, 3 to 8, 8 to 3 and 3 to 7) accumulates. Similarly, if base station 7 sends a request to base station 9 and gets back the reply, the total NMH is 8. Thus, the total NMH for BP 7 is 12 (4 + 8). With RP, we observe that NMH is equal to 6. This is because base station 7 sends a request to root node 0 and gets back a reply. Thus, a total of 6 NMH (7 to 3, 3 to 1, 1 to 0, 0 to 1, 1 to 3 and 3 to 7) accumulates. With selective placement of LDDB at node 1 for base stations 7, 8 and 9, we observe that NMH is equal to 4. This is because base station 7 sends a request to node 1 and gets back a reply from it. Thus, a total of 4 NMH (7 to 3, 3 to 1, 1 to 3 and 3 to 7) accumulates. Therefore, NMH is lowest for SP. multiple-ZQ. The hierarchy level at which the LDDB should be placed depends on the zones the queries access. For example, if all the queries are multiple-ZQ and involve only two zones, then placing the LDDB at the nodes one level above the leaf nodes incurs minimum NMH. Furthermore, if all the queries access all the zones in the system, then placing the LDDB at the root node incurs minimal NMH (discussed in Sect. 3.4.1). Because the actual query types can be highly mixed, we use experimental data to determine the best placements for specific access patterns. 3.6.2 Base station placement for single-ZQ For queries of type single-ZQ, the placement of an LDDB at each base station is the best LDDB-placement strategy to reduce NMH, assuming base stations can handle queries and have enough storage. This is because, while handling single-ZQ in BP, the query does not require being pushed to upper level nodes and the query results are available at the BS itself.
 node is the better choice to store LDD compared with RP and BP. On the other hand, for query type only single-ZQ type queries, BP is the best choice to store LDD. However, BP placement is not a realistic approach (see Sect. 3.4.2). 4 Replication Due to storage limitations of the base stations and because base stations should never be burdened with data-management activities [ 23 ], LDDB placement at the base stations is not a realistic strategy. Hence, we propose a selective replication algorithm in the context of FULDCQ of type single-ZQ, which depends on the user X  X  query pattern.
 tion, it would be judicious to replicate corresponding LDD at that base station hand, if multiple-ZQ type is frequently asked from a particular base station, there are several possible alternatives. One alternative is replicating relevant LDD ing LDD that corresponds to multiple base stations and, indeed, storage require-ments will be higher as compared with storing LDD that corresponds to a single base station (i.e. single-ZQ). The other alternative would be selective placement at an intermediate node (discussed in Sect. 3.6.1), which is a more realistic ap-proach. Therefore, in this paper, replication is considered only for single-ZQ type queries.
 of finding the LDD locally [ 6 , 9 , 24 , 25 ]. Replication of LDD at selected nodes does not increase the update cost assuming it is always fixed for a particular base station as discussed in Sect. 3.2. 4.1 Replication based on user query pattern In the tree architecture, the LDD can be replicated both at the leaf node (i.e. base station) as well as the internal nodes of the hierarchy. If a particular type of query Q i is mostly requested from base station j , then the LDD corresponding to query Q i should be replicated locally at base station j . For analysing LDD replication, we define the following parameters: tion j over a given time period, T .Let S i , j be the total size (in megabytes) of the LDD corresponding to query Q i for base station j . The local query-to-size ratio, LQSR i , j , for leaf node j is the ratio of N i , j to S i , j ,i.e.
 For internal node j where k is a child of j . That is, local query-to-size ratio for a query Q i and an internal node j is the ratio of the total number of FULDCQs of type Q i requested from any of the base stations of j  X  X  subtree to the total size of the LDD of query Q i for all of the base stations of j  X  X  subtree. 4.2 Parameters in replication We define four parameters: N , C min , C max and L ,where N is the maximum num-ber of replicas of LDD for each query type (excluding the LDD at the LDDB node); C min and C max together determine when a node may be selected for an LDD replica, and L denotes the node level at which the LDDB is placed inside the tree. Within the tree, leaf nodes are at level 0, and level increases as we move toward the root node. 4.2.1 Number of replicas (N ) for each query To satisfy the storage constraint, the number of replicas of LDD needs to be bounded. For this, we introduce the parameter N , which will be the same for each query and it can be calculated, based on the system X  X  average storage capacity for each query. Let S avg be the average size of the LDD per query type. For m base stations and n query types, Let S max be the maximum memory available for storing replicas for each query, which is given to the system. Then the maximum number of replicas per query, N , will be calculated by 4.2.2 Replication selectivity The LDD corresponding to query Q i should not be replicated at site j if the cost of replication exceeds the benefit of replication. Based on the cost model to min-imise communication cost, we compute the local query-to-size ratio, LQSR i , j .If LQSR i , j is smaller than some minimum threshold C min , then never replicate the LDD for query Q i at database j .IfLQSR i , j exceeds some maximum threshold C max , then always choose to replicate the LDD for query Q i at database j , if con-straints on N and L are satisfied. If C min  X  LQSR i , j  X  C max , then the replication of the corresponding LDD will depend on the replication algorithm discussed in Sect. 4.3.
 tial sites of replication in a tree-structured database, which could minimise NMH communication cost. Let b l be the communication cost/delay of a lookup message that traverses one hop in the path from a leaf node j to the node hosting the LDDB for node j . Let bs be the communication cost of storing one megabyte of LDD. During replication, two possible cases may arise: 1. If Q i  X  X  LDD is replicated at database j , then communication cost incurred due 2. If Q i  X  X  profile is not replicated at database j , then communication cost incurred replicating if 4.2.3 Maximum level of replication The maximum level of replication should be lower than level L at which the LDDB node is placed. This is because the LDDB node can process all continuous queries. Therefore, LDD replicated at any node at a level higher than L will not help to reduce communication cost. 4.3 Selection of nodes for replication The replica allocation algorithm is performed over our proposed database model with estimated local query-to-size ratio (LQSR) information. We proceed in two phases.
 showninFig. 5a and b. In the first phase, it replicates the relevant LDD to all nodes j with LQSR i , j  X  C max . This replication is performed as long as the number of allocated replicas of LDD n  X  N . The replication in the first phase is done in leaf-level nodes as possible to reduce the lookup latency assuming that leaf-level nodes have storage and query-processing capacity. As soon as node j is assigned areplicaofLDDforquery Q i , j  X  X  parent X  X  LQSR value for Q i is updated in the following way: This is because query Q i requested from nodes below j will be processed by node j .
 largest nonnegative LQSR i , j  X  C max are chosen as the nodes for replication. The replication in Phase 2 proceeds in a top-down fashion (from level L ). This way, we maximise the coverage area of replication. The Phase 1 and Phase 2 algorithms are shown in Fig. 5 aandb.
 that should contain replicas of LDD corresponding to query Q i .Let T ( Q i )bethe temporary set of databases used in the second phase for query Q i . 5 Performance evaluation We conducted a simulation experiment to obtain the NMH of the SP technique with respect to the other two placement techniques (RP and BP) when queries are single-ZQ and multiple-ZQ types. We also obtained NMH and average memory requirements for selective replication for different degrees of replication, when queries are only of single-ZQ type. 5.1 Simulation model We performed a simulation on the tree architecture as discussed in Sect. 3. We developed a simulation program in Java to generate a realistic user query profile with most of the FULDCQs requested between the 6th and 20th hour of a 24-hour period as established by [ 15 ].
 following:  X 
Most of the FULDCQs requested by mobile users are between the 6th and 20th hour of a 24-hour period because most users use their mobile phones during working hours.  X 
Mobile users X  FULDCQs exhibit some temporal and spatial locality. In other words, a user tends to ask the same query over a period of time (e.g. finding hotels as he is driving), and different users tend to query the same objects (e.g. location attraction in the city, nearest restaurants), i.e. users follow certain query patterns.  X 
Mobile users make random moves based on an exponential distribution to sim-ulate realistic user movement [ 15 ].  X 
During selective replication, we considered replication selectivity C min = C opt min , and C max = C opt max .Weset b s / b l = 1, assuming that the communication cost of storing one megabyte of LDD and communication cost/delay of a lookup message are equal.
 and n base stations, we created a dynamic input matrix, M . Each element M [ i , j ] represents the number of FULDCQs of type Q i requested from base station j over a given time period, T . We divided the 24-hour period into 12 time zones with every time zone being 2 hours. For each of these time zones, we recorded the input matrix M . Thus, we had 12 such input matri-ces, i.e. M k for k = 1 , 2 ,..., 12. To determine NMH, we considered Q i of either type single-ZQ or multiple-ZQ. Furthermore, while obtaining NMH and storage cost for selective replication, we considered Q i of single-ZQ type only.
 niques (RP and BP), where the queries are of single-ZQ or multiple-ZQ type, we defined a set NZ j (using deterministic distribution), where each element of the set corresponds to the neighbouring zones covered by the query Q j of type multiple-ZQ. For a given set NZ j , we computed NMH for the three placement techniques: RP, BP and SP.
 gree of replications, when queries are only of single-ZQ type, we compute an input matrix, S , where each element S [ i , j ] represents the total size of the LDD corresponding to query Q i for base station j .
 users from base station j over a given 24-hour period, we need to add up all the 12 input matrices M k for k = 1 , 2 ,..., 12. The output matrix T represents this. Each element T [ i , j ] is represented as: given 24-hour period. The output matrix L represents this. Each element L [ i , j ]is using Eq. (2).
 two phases 1 and 2 (see Sect. 4.3) based on the LQSR information obtained earlier and replicating each query Q i at the appropriate node j . 5.2 Experimental observation Based on the assumptions underlying the design of the simulation model, we are proposing the following hypotheses: in the simulation model and are validated in the following experimental result section. 5.3 Experimental results In Fig. 6 , we compare the NMH for the three placement techniques RP, BP and SP. Distribution of query multiple-ZQ (single-ZQ) types is 100% (0%), 50% (50%) and 0% (100%) in Fig. 6 a, b and c, respectively. In Fig. 6 a and b, as we can see, RP and BP incur the higher NMH in a 24-hour duration while SP incurs the least NMH in this period. This confirms the superiority of selective placement (SP) technique over the other two placement techniques when the queries are mixed or only multiple-ZQ types, thus validating Hypothesis 1 .
 and SP will be in the middle. This is because, for the BP case, the query result will be retrieved from the corresponding BP X  X  LDDB. Thus, in BP for single-ZQ types, NMH will always be zero.
 24-hoour duration. We can see that R 3 , 2 ,inwhich N , the number of replications, is 3, and L , the level of replication, is 2, has least NMH in this period as compared validating Hypothesis 2 .
 From Figs. 7 and 8 , we observe that, as the degree of replication increases, the number of NMH decreases, but at the same time, the storage requirement for LDD replicas increases. Thus, R 3 , 2 incurs the minimum communication costs but requires the maximum memory, thus validating Hypothesis 3 .
 tree will be a suitable LDDB-placement strategy because the number of NMH will be reduced. When the queries are only of single-ZQ types, by exploiting dif-ferent degrees of replication and query patterns, we replicate corresponding LDD in the context of SP to reduce the NMH. With this replication, SP causes the LDD replicas to be placed closer to the leaf nodes, i.e. near the base station, but at the same time the degree of replication in our tree architecture would be limited by the storage constraint.
 presents the results in terms of NMH for various placement strategies with query types multiple-ZQ and single-ZQ. Table 3 presents the results in terms of NMH and average memory requirement for various degrees of replication in the context of SP with query type single-ZQ. 6 Related work Most of the research in querying location-dependent information focuses on the data management issues of the mobile users and tracking the location of these users. We present related work in the context of centralised databases domain first and then the distributed databases domain.
 for managing the locations of mobile users and for the prediction of their future locations. According to the MOST model, the attributes of the moving data item or dynamic , that is, changes over time according to a certain function. Also generated to refresh the location of an object and redefine its location function whenever the deviation of its current location is greater than the last update by information of mobile users in a centralised database with the goal of processing spatial and temporal queries in an efficient way. In our proposed tree framework, the location information of mobile users is not centralised but distributed across the nodes of the tree. Here each node manages location information of mobile users within the set of the base stations in its subtree. Compared with the centralised approach, our distributed framework will scale up better when the number of mobile users increases.
 chitecture, between the mobile user and the location-dependent services ( LDS ), to service location-dependent applications that access location-dependent data. The proposed middleware does location translation, adjusts the location granularities and gets query results with the help of LDS. In this approach, LDSM acquires lo-cation information of mobile users from location services or a global positioning system ( GPS )-based solution. In our approach, the LDDB node, which maintains a LDDB and processes FULDCQ for mobile users X  within the set of the base sta-tions in its subtree acts as LDSM, which acquires the location information of mo-bile users from the ULDB present within that node. Unlike centralised LDSM ar-chitecture, our framework that places LDDB nodes intelligently at selective places in the tree will scale up better when the number of mobile users increases. ing problem in which location information of mobile users is distributed across several base stations; each base station manages location information about mo-bile users under its coverage area. But in this approach, mobile agents are used to support distributed query processing, track interesting mobile users and optimise wireless communication transmissions. In this approach, all the query processing is performed at the base station, which might burden the base station with data-management activities, and also this approach will not scale up well for FULDCQ related to multiple-ZQ. In contrast, in our approach, the LDDB node, which main-tains a LDDB and processes FULDCQ for mobile users X  within the set of the base stations in its subtree, can be located in the tree either at root node, internal nodes or leaf nodes (base stations). Also, our framework is flexible enough to efficiently handle FULDCQ related to single-ZQ or multiple-ZQ, as discussed in Sect. 3.6. tinuous queries but had assumptions that FULDCQ are only of single-ZQ types by ignoring multiple-ZQ types. 7 Conclusion and future work We have proposed a potentially powerful and novel approach for handling FULDCQ in a mobile environment. This approach relies on a tree architecture that is flexible enough to handle queries of either single-ZQ or multiple-ZQ types. We have discussed various placement strategies to store LDD in the tree struc-ture and showed that selective placement outperformed other strategies for queries of multiple-ZQ or mixed types. In addition, when queries are only of single-ZQ types, by exploiting different degrees of replication and query patterns with spec-ified storage constraint, we replicate corresponding LDD in the context of SP to reduce the network message hops. With this replication, SP causes the LDD repli-constraint at the same time.
 perimental results need to be further verified under Real-life scenarios with mo-bile users X  query profiles being obtained from the real mobile network. This is because our experimental results are only guaranteed to be valid in conditions matching those stated in the simulation model. Second, we would also like to con-sider FULDQ types, where the objects related to the query are moving. Third, we would like to include users X  mobility pattern [ 4 , 30 , 32 , 34 ] and caching tech-niques [ 2 , 8 , 14 ] in LDD replication. Fourth, we would also like to investigate partitioning techniques to split LDDBs at higher level nodes into small databases at the lower level nodes [ 30 ]. Finally, we want to investigate various techniques to manage ULDB based on the location management techniques as discussed in [ 33 , 35 ].
 References
