 Man y applications rely on sequence databases and use exten-sively pattern-matc hing queries to retriev e data of interest. This pap er extends the traditional pattern-matc hing expres-sions to parameterize d patterns, featuring variables. Param-eterized patterns are more expressiv e and allo w to de ne concisely regular expressions that would be very complex to describ e without variables. They can also be used to express additional constrain ts on patterns' variables.

We sho w that they can be evaluated without additional cost with resp ect to traditional techniques (e.g., the Knuth-Morris-Pratt algorithm). We describ e an algorithm that en-joys low memory and CPU time requiremen ts, and pro vide exp erimen tal results whic h illustrate the gain of the opti-mized solution.
 I.5.2 [ Computing Metho dologies ]: Pattern Recognition| Design Metho dolo gy ; H.2.3 [ Database Managemen t ]: Lan-guages Performance, Languages Parameterized patterns, Query evaluation
The detection of patterns in sequence databases is a com-mon problem in man y applications suc h as detection of com-mon beha viors, analysis of stock mark et prices, searc h for sequences of DNA, stream mining, etc. Motiv ated by these applications, sev eral mo dels have been recen tly prop osed to express pattern-based queries and to retriev e ecien tly se-quences that matc h them [1, 21, 20, 23]. Man y languages prop osed in these works extend in some way (querying, ag-gregation, data mining) the functionalities of SQL with some varian t of regular expressions, and man y query evaluation techniques build on well-kno wn pattern matc hing algorithms.
In this pap er, we prop ose an extension of traditional pat-terns with variables whic h can be bound to any value of the underlying discrete domain during query evaluation. For instance, if a is a value and x is a variable, the parame-terized pattern @x.a.@x denotes all the subsequences where a is preceded and follo wed by the same value. This exten-sion pro vides a much more expressiv e and exible querying framew ork because the presence of variables o ers man y op-portunities to matc h a pattern with a sequence by simply changing the variables bindings. Moreo ver the introduction of variables promote patterns to rst-class query objects, since variables can be used in other parts of a query for ex-pressing constrain ts (e.g., @x != c ), joins ( @x = @y , where x and y app ear in di eren t patterns), output of variable val-ues, etc.

A poten tial problem asso ciated to any extension of pattern-matc hing queries is the cost of the query evaluation al-gorithms. In the traditional setting (pattern-matc hing on strings) sev eral well-kno wn algorithms have been prop osed to ecien tly achiev e this searc h [4, 12, 6]. Our main con tri-bution is to presen t an extension of the KMP algorithm [12] to parameterized pattern matc hing whic h preserv es its linear time complexit y and enjo ys low space requiremen ts. More speci cally , it satis es the two follo wing prop erties: 1. eac h sym bol of the input sequence is chec ked only once; 2. the memory space requiremen t of a query q is prop or-
We implemen ted our algorithm and made evaluations that con rm our exp ected results. The exp erimen tal evaluation sho ws that our algorithm saves of large amoun t of compu-tations and therefore decreases the query evaluation time. Sev eral studies on sequence databases aim at extending SQL with pattern-matc hing operators. In [21], the authors presen t a language called SEQUIN based on SQL in order to query sequences. In [18] sequences are considered as sorted rela-tions where eac h tuple is assigned to a num ber that repre-sen ts its position in the sequence. A shift operator using this num ber is de ned in order to join tuples of the same sequence. The SQL-TS language of [20, 19] allo ws to ex-press sequences of predicates, and covers rep etitiv e patterns, arbitrary aggregates and disjunctiv e patterns. The pap er describ es an extension of the KMP algorithms to evaluate matc hing queries over suc h sequences of predicates. Some other pap ers [11, 10, 14] presen t algorithms for querying and mining similar subsequences, as well as event detection from time series data (i.e., sequences of real num bers). [14] for instance describ es the necessary restrictions of the SQL language when dealing with streams, focusing on the aggre-gation problem. In [16] the authors describ e a fast mining algorithm for retrieving spatio-temp oral perio dic patterns for objects moving on a partitioned map. It supp orts the \unde ned" sym bol inside a pattern. All these approac hes are signi can tly di eren t from ours. In particular there is nothing similar to the concept of parameterized pattern, fea-turing variables, prop osed in our data mo del.

Other represen tativ e pap ers about string-searc h are [2, 5, 22]. Some works also deal with the problem of searc hing appro ximate patterns [24, 13]. None of these algorithms handle variables in patterns. To the best of our kno wledge, the only work that considers patterns with parameters is [3], but the goal is to matc h two parameterized strings together by nding a renaming of the parameters. In [8] we inves-tigated regular expressions with variables, and describ ed a class of expressions with limited space requiremen ts. The mo del was applied to mobile objects trac king, where trajec-tories are seen as sequences over a partitioned map. The presen t pap er can be seen as a further impro vemen t of these techniques.

In the follo wing we describ e rst (Section 2) some motiv at-ing applications with sample queries. Section 3 introduces the data mo del and Section 4 is dev oted to query evalua-tion algorithms, including our optimized solution. We pro-vide exp erimen tal results in Section 5. Some conclusions are dra wn in Section 6.
We pro vide in this section an illustration of our motiv a-tion with some represen tativ e applications. Their common feature is to store as sequenc es the evolution of values over a discrete domain for some information of interest, and to perform querying and analysis tasks on these sequences. Applications that deal with DNA or proteins rely on a database that stores millions of sequences [17]. Consider for instance a protein sequence database. Basically a protein is com-posed of between 100 and 200 amino acids. There are 20 distinct amino acids that are commonly denoted by a lab el with one letter. Here is the example of lysozyme, comp osed of 130 amino acids: K V F E R C E L A R T L K R L G M D G Y R G I S L A N W M C L A K W E S G Y N T R A T N Y N A G D R S T D Y G I F Q I N S R Y W C N D G K T P G A V N A C H L S C S A L L Q D N I A D A V A C A K R V V R D P Q G I R A W V A W R N R C Q N R D V R Q where for instance N is the standard lab el to denotes the amino acid named Asparagine. Bey ond classical pattern matc hing on suc h sequences, our language allo ws to perform adv anced parameterized searc h. For instance the parameter-ized pattern Q.@x.L. " .Q.@x.L matc hes the sequences where the substring Q.@x.L is found twice, @x being bound to the same value in both occurrences ( " denotes any subsequence). Although an equiv alen t pattern can be expressed with a reg-ular expression that enumerates all the possible bindings, its size is likely to discourage any user.

Another feature of our language is its abilit y to express additional constrain ts on variables. For instance the pat-tern Y.A.@x can be com bined with the constrain t Polar(@x) where Polar is a predicate whic h chec ks whether the in-stan tiation of @x belongs to the Polar class of amino acids. Along with a fast algorithm for pattern detection, these functionalities are unmatc hed by existing sequence query languages.
 Next, consider another application that aims at analyzing the beha vior of web users on a site in order either to im-pro ve the ergonom y of the site, or to kno w where are the best places for adv ertisemen ts. Assume that eac h page is uniquely referred by an url . The database can thus store the sequences of page urls { or histories { successiv ely crawled by a user [9, 15]. A simple query of interest in suc h a con text is for instance to searc h for users that came bac k to page A after visiting another page. This can be expressed by the pattern A.@x.A . The value of @x can be output if required when a matc h is found (and thus when a value is bound to @x ).

The pattern A.@x. " .B.@x matc hes all the sequences where a page @x is accessed successiv ely from two distinct pages, resp ectiv ely A and B . Note that we can com bine our pattern expressions in powerful constructs. If we do not wish to men-tion explicitely A and B in the previous example, we can relax the pattern as @y.@x. " .@z.@x , along with the constrain ts @x != @y and @y != @z . This matc hes all the sequences where page @x is accessed successiv ely from two distinct pages, whatev er their urls.
 Finally , let us tak e a spatio-temp oral application that will serv e as a supp ort to our examples in the rest of the pap er. As in [16], we consider a partition of a 2D embedding space suc h that eac h zone is uniquely iden ti ed with a lab el from an alphab et . This partition is the reference map M sup-porting queries. Figure 1 sho ws a simpli ed map of Paris, divided in arrondissements , with = f a; b; c; d; e; f; g g .
Assume that eac h object is equipp ed with a location-a ware device that perio dically sends its position. Since eac h object moving in the partitioned area crosses a sequence of distinct zones (we assume at least one event per zone), our patterns can be used to query suc h sequences. Here is a sample of suc h queries (they will be referred to by Q i ; i = 1 ; ; 4 in the follo wing)
In summary our approac h aims at pro viding a exible, powerful and ecien t pattern-based query language. The exibilit y is brough t by the presence of variables. The larger the num ber of variables in a pattern, the larger the num ber of matc hes whic h can be found. Variables can also be seen as references to some sym bols of the sequences, on whic h additional constrain ts can be expressed. Finally we sho w in the follo wing that, in spite of this enhanced expressiv eness, we can still rely on ecien t pattern matc hing operations to evaluate our parameterized patterns.
In our mo del, an object o (e.g., a protein, a web user, a moving object) is represen ted by an iden ti er together with a sequence of sym bols. All sym bols belong to a discrete and nite domain .

Definition 1 (Represent ation of an object.). An obje ct o 2 O is a pair ( oid; seq ) wher e oid denotes the iden-ti er of the obje ct and seq = &lt; z 1 :z 2 : :z n &gt; is a wor d in .

Example 1. Figur e 1 shows two moving obje cts on the partitione d map, o 1 and o 2 .

These obje cts are then represente d as follows:
Let V be a set of variables suc h that \ V = ; . In the follo wing, letters a , b , c , . . . denote sym bols from , and @x , @y , @z , . . . variables.

Definition 2 (Pattern) . A pattern is a wor d t 1 :t 2 : : : t in ( [ V ) .

In their simplest form, patterns are words in suc h as, for instance, Q 1 = a.d.c and Q 2 = b.c.e.f . The interpre-tation of a pattern P without variable is natural: a sequence T matches a pattern P if P is a subsequence of T . For in-stance, since o 1 :seq = f. a.d.c = f :Q 1 then o 1 belongs to the result of query Q 1 whereas neither Q 1 nor Q 2 are sub-sequences of o 2 :seq . Variables are useful to capture more general sequences where sym bols are not explicitly assigned to speci c sym bols. Q 3 in the moving objects application for instance refers to another zone and Q 4 to one departur e zone . The patterns for these queries are as follo ws.
The interpretation of patterns (with variables) is an ex-tension of the subsequence matc hing seman tics previously given: a sequence T matc hes a pattern P if one can substi-tute eac h variable in P by a sym bol from , suc h that the resulting pattern is a subsequence of T . More formally:
Definition 3 (Substitution and valua tion) . A sub-stitution is a nite set of the form f x 1 =t 1 ; x 2 =t 2 wher e x i 2 V ; i = 1 ; : : : ; n , and each t i is either a variable in V or a symb ol in . is a valuation if t i 2 , for all i 2 [1 ; n ] for eac h x i =t i 2 , eac h occurrence of x i in P by t i elemen t x i =t i is called a binding for x i and the set of variables f x 1 ; x 2 ; : : : ; x n g is denoted by bound ( ). Sometimes, if x is bound to t , for brevit y t will be referred to as ( x ).
If P = a.b.@x.@y.b.@z.b and = f @x/c, @z/@x g , then ( P ) = a.b.c.@y.b.@x.b . In the follo wing var ( P ) denotes the set of variables in P .

Note that if is a valuation and var ( P ) bound ( ), then ( P ) is a word in . Hence the de nition:
Definition 4 (Interpret ation of a pattern) . A se-quenc e T matches a pattern P i ther e exists a valuation such that ( P ) is a subse quenc e of T .

Let us now turn our atten tion to queries. A query is built from patterns and predicates over the patterns' variables. We commonly wish to allo w some \holes" into our patterns. For instance we could try to retriev e all the mobile objects that went through zone a , then crossed zone d and moved to zone c , and later went from f to d crossing another zone. In this example we want to kno w the objects that satis ed Q , then Q 2 , without any restriction about the di eren t visited zones during these two subsequences. Consequen tly we adopt the follo wing de nition for a query .

Definition 5 (Quer y). A query q is a pair ( P ; C ) such that 1. P is of the form P 1 :":P 2 :": :":P k , wher e k &gt; 0 , 2. C = f c 1 ; c 2 ; ; c m g ; m 0 , is a (possibly empty) set
Since the successiv e patterns of P must be matc hed in order, the seman tics of a query is straigh tly deduced from that of a pattern: a sequence satis es a query i there exists a valuation of var ( P ) whic h satis es successively the di er-ent patterns of the query and the predicates in C . In the follo wing we focus on the evaluation of patterns. Note that the predicates are application-dep enden t i.e., we migh t have spatial predicates in a mobile application, or specialized con-dition on proteins, or url comparisons.
We presen t now two algorithms for an evaluation of pa-rameterized patterns. The rst one follo ws a na X ve approac h whic h rep eatedly chec ks the new read sym bols and bac k-trac ks on the sequence whenev er a mismatc h occurs. The second one is our optimized technique. All the sym bols used throughout the pap er are listed in Table 1.
The rst algorithm is a simple extension of well-kno wn pattern-matc hing techniques to patterns with variables and relies on the follo wing operations: 1. a matching attempt between a pattern P and a se-2. a shift of P whenev er a mismatc h occurs.
 A matc hing attempt compares, one by one, from left to righ t, the sym bols P [0] ; P [1] ; : : : ; P [ m 1] of the pattern to the ing the matc hing attempt, the variables in var ( P ) are pro-gressiv ely bound to sym bols in , and these bindings de ne a valuation , called the runtime valuation whic h is initially empt y. If P [ j ] is a variable @x , the follo wing binding rules apply: 1. if @x 62 bound ( ), the comparison is alw ays successful 2. else, if @x 2 bound ( ) the comparison is successful if Consider the matc hing attempt for P = a.@x.b.@x and T = a.c.b . The comparisons are successful for j = 0 ; 1 ; 2. When P [1] = @x is compared to T [1] = c , variable @x is bound to lab el c . The valuation is, at this point, f @x/c g . The follo wing comparison P [4] = T [4] can then be successful only if the next lab el read in the sequence's represen tation is c , the curren t instan tiation of @x . It follo ws that we have to main tain, for eac h object, the curren t substitution, i.e. a list of the curren t bindings of the query variables.
If all the comparisons are successful, then so is the matc h-ing attempt, else there is a failure. In both cases the Shift operation is performed.
 A Comp are operation is performed eac h time a new lab el is read. Whenev er a failure occurs (say, at position l , with 0 l m 1), Shift shifts the pattern by one position and a comparison with the l 1 last lab els of the sequence has to be done. If the matc hing is successful, one reads the next lab el of the sequence, else a new shift is necessary . Figure 2 sho ws an example.

When the pattern con tains variables the algorithm is quite similar except for the binding of the variables. Whenev er a Figure 2: Matc hing attempt for a pattern without variable Figure 3: Matc hing attempt for a pattern with vari-ables failure occurs, the curren t substitution is deleted: all the bindings are discarded. The pattern is shifted one sym bol to the righ t. Figure 3 illustrates this algorithm.
This technique is simple but costly since the algorithm to test the whole sequence runs in O ( m j T j ). Eac h lab el of the sequence is poten tially chec ked sev eral times against the pattern.
We prop ose an optimization relying on an extension of the string-matc hing algorithm from Knuth, Morris and Pratt (KMP) [12, 6]. We rst brie y sketch the KMP algorithm before describing its extension.
 The KMP algorithm relies on the observ ation that, in the case of a failure, sev eral sym bols can be skipp ed. Moreo ver the pattern con tains all the information needed for determin-ing the num ber of sym bols to be skipp ed. This is illustrated in Figure 4 with the pattern P = a.b.c.a.b.c.b and the subsequence T = a.b.c.a.b.c.a .

A failure occurs at position 6 of the pattern. We success-fully sup erp osed P [0] : :P [5] on the lastly read six sym bols of T . A shift of one or two sym bols to the righ t always leads to a failure. Indeed after a shift of one sym bol, P [0] = a is compared to T [ i + 1] = b . Similarly a shift of two sym bols attempts to sup erp ose P [0] = a on T [ i + 2] = c .
Nonetheless a shift of three sym bols to the righ t is possible since P [0] : :P [2] = T [ i + 3] : :T [ i + 5] (Figure 4(b)). It turns out that this shift is allo wed because P [0] : :P [2] = P [3] : :P [5]. Therefore it can be determined by examin-ing the pattern, at compile-time, indep enden tly from any speci c sequence.

More generally , for eac h substring s l = P [0] : :P [ l 1], Figure 4: Example of a shift determined by the KMP algorithm Figure 5: Using an edge for determining the appro-priate shift Figure 6: A shift for a pattern con taining variables l &lt; m of P , we need to kno w the longest pre x e l of s is also a sux of s l . Suc h a string e l is called an edge . If the failure occurs at position l in the pattern, then the shift is of length l 1 j e l j . Figure 5 illustrates this.
Note that taking the longest sux means that the shift is minimal, and guaran tees that the algorithm does not miss any solution. The edges are precomputed and stored in a table called the table of edges .

The KMP algorithm can be decomp osed into two steps:
Using the table of edges when performing a matc hing at-tempt, avoids to chec k sev eral times an input sym bol, and the num ber of comparisons is therefore linear in the size of the sequence. In the follo wing we extend this algorithm for our patterns with variables and describ e an ecien t evalua-tion pro cess.
 Consider the pattern P = a.b.@x.a.b.a.b with a single variable @x and the example of gure 6.
 When the failure occurs at position 6, @x is bound to c . If we consider the string a.b.c.a.b.a , the longest pre x whic h is also a sux is a.b . However this shift remo ves the binding of @x and we can bind this variable to another sym bol. Actually it is now possible to matc h the rst three sym bols of P [0] : :P [5] with the last three, pro viding that @x is bound to a after the shift.

Next, consider a more complex case where the bindings after the shift dep end on the bindings befor e the failure (Fig-ure 7). A failure occurs at position 6, @x being bound to c , @y to a and @z to a . The best shift sup erp oses the last three sym bols of the sequence on the rst three of the pattern, with a new binding of @x to a whereas @y and @z are no longer instan tiated. Note that in that case the new binding of @x is the former binding of @z . Here again, an analysis of the pattern at compile-time gives all the needed information to perform the substitution of values at run time. Figure 8: A shift that dep ends on the run time val-uation
Finally a last example (Figure 8) sho ws that the edge sometimes dep ends on the binding of variables befor e the shift. In Figure 8.a, a failure occurs at position 6. If we consider an edge of length 4, the sux a.c.@y.@x may be sup erp osed on the pre x a.@x.a.c if @x is bound to c prior to the shift. This is not the case in Figure 8 since @x is bound to b . If we consider an edge of length 2, the sux @y.@x must be sup erp osed on the pre x a.@x . This is only possible if @y is bound to a . Hence the applicabilit y of an edge migh t dep end on the curren t run time valuation. As sho wn by the previous examples, the computation of edges is strongly related to the variable bindings. Moreo ver a shift migh t determine a substitution of variables values whic h dep ends, partially or totally , on the run time valua-tion. We now de ne the notion of edge for patterns with variables.

Definition 6 (Edge of a pattern) . Let P be a pat-tern of length m . An edge of P is a triple ( leng th; min wher e min is a valuation and shif t a substitution, which satis es the following properties:
An edge e = ( leng th; min ; shif t ) describ es a shift of size m leng th 1. The valuation min expresses a necessary and sucien t condition for applying the shift: given the run time substitution , the edge e is applicable i min (we sometimes say that is comp atible with min ). Finally shif t is the substitution used to bind the edge's variables after the shift. Both min and shif t are computed at compile time.
Assume that the sup erp osition of a pattern P on a se-quence T fails at position l of P . If ( leng th; min ; is an edge of P [0] : :P [ l 1] and min is a subset of the run time valuation , then we can shift P of l leng th 1 sym bols to the righ t and restart the matc hing pro cess at position leng th + 1 for P . The new run time valuation is example. Example 2. Consider the subp attern @x.b.@y.c.@z.@x.a . Ther e exists an edge e (3 ; min ; shif t ) of length 3 with: This is interpr eted as follows. During a shift of size 3, the subp attern @x.b.@y must be superposed on @z.@x.a . Henc e @x replac es @z , b replac es @x and @y replac es a . This su-perposition is possible i the runtime valuation of @x is b , ther efor e the minimal valuation is min = f @x/b g .
Next, sinc e @x replac es @z , it takes the value assigne d to @z by the runtime valuation. Variable @y takes always the value a . Ther efor e the substitution is shif t = f @x/@z ; @y/a g . One easily veri es that:
Final ly, let the last read labels of a sequenc e be c.b.a when the failur e occurs. The curr ent runtime valuation is = f @x/b ; @z/c g . Sinc e min , the edge is applic able and the shift of size 3 can be performe d. The valuation after the shift obtaine d from the substitution: @x = ( shif t ( @x )) = ( @z ) = c , and @y = ( shif t ( @y )) = a .

The matc hing attempt is performed by the follo wing Ma tch algorithm. Ma tch is invoked when a new lab el s is read from a sequence T . It tak es as inputs s , the run time valu-ation and the curren t position l in P . Ma tch attempts the matc hing between T and the sux of pattern P starting at l . It returns the new run time valuation 0 and the new position l 0 in P .

If l 0 is the size of P , then the pattern has been fully rec-ognized and the sequence is added to the query result. Oth-erwise, Ma tch returns a new position l 0 &lt; m in P . Up on reception of a new sym bol from T , a matc hing attempt will resume between the sux of pattern P starting at position l 0 and sequence T .

Ma tch calls the pro cedure EdgeShift whic h tak es the longest edge e suc h that the min valuation is a subset of . Once e has been found, the shift is performed as follo ws: EdgeShift tak es as inputs, the run time valuation and the curren t position in pattern P and returns the new run time valuation and a new position in P .
 Consider for instance the pattern P = a.@x.b.a.@x.@y.c.d . Whenev er a failure occurs at position l = 6, we need to con-sider the follo wing edges for the sub-pattern P [0] : :P [5] = a.@x.b.a.@x.@y : We cannot nd any edge whose length is either 4 or 5.
Now consider a matc hing attempt and a failure occurring at position 5, with = f @x/a ; @y/c g . The valuation is not compatible with min of the edge (3 ; f @y = b g ; f @x = @x g ). Consequen tly, using this edge, one shifts two sym bols to the righ t and initializes a matc hing attempt at the third position of the pattern with the new run time valuation. We have implemen ted and compared two algorithms in Java on a Pentium PIV pro cessor (3GHz) with 1GB of mem-ory . The rst algorithm, Na  X  ve , is the naiv e one describ ed in Section 4.1, and the other one is the extended KMP algo-rithm whic h uses the table of edges. A sim ulator generates syn thetic trajectories and parameterized patterns, and the evaluation of queries is performed and analyzed over this syn thetic dataset. The chosen territory for vehicle trajectories is a map of France. We consider sev eral sub divisions of France whose nest is a partition into 21 administrativ e regions. Trajec-tories of a given vehicle are sim ulated as follo ws. The depar-ture region of a vehicle is chosen at random. To sim ulate the receipt of GPS positions, time is mo deled as a sequence of time instan ts. At eac h time instan t, with probabilit y p vehicle enters region i or stays (with probabilit y 1 P p in its curren t region. If it leaves a region for a con tiguous region i , then the lab el corresp onding to region i is added to its trajectory , and this event triggers a next step in the matc hing algorithms. The probabilit y of entering (lea ving) a region dep ends on the region imp ortance (e.g. big cities are regions with high trac). The set of the whole trajectories ( i.e. , sequences of crossed zones) is stored in the database.
Mobilit y patterns (queries) are generated as follo ws. Se-quences of regions with xed size are dra wn at random. The regions are chosen con tiguous on the map. With a given probabilit y p v a region sym bol in the pattern is replaced by a variable v dra wn with rep etitions from a xed set of vari-ables. For example if p v = 0 : 25, one sym bol out of 4 in the pattern on the average is replaced by a variable. Figure 9: Evolution of the num ber of comparisons for di eren t pattern lengths and ratios of variables
The evaluation of the two algorithms is based on the total num ber of comparisons between a sym bol of the pattern and a sym bol of the trajectory . In the follo wing, the num ber of vehicles is 100,000, and the average performance was tak en over a set of 500 queries. We observ e the cost and resource consumption of both algorithms, assuming that the vehicles moved during 20 time units, and evaluate their performance with resp ect to the length of the patterns and the average ratio of variables in eac h pattern.

Figure 9 illustrates the impact of the ratio of variables on the total num ber of comparisons, when the num ber of administrativ e regions (the size of the lab els vocabulary) is equal to 21. Shorter (resp. longer) patterns capture too man y (resp. too few) vehicles and are therefore not mean-ingful. The two graphs in Figure 9 displa y resp ectiv ely the results for pattern lengths 4 and 6.

As exp ected, our extended KPM algorithm alw ays out-performs the nav e one. An interesting feature is that the ratio of variables has an opp osite in uence on the perfor-mance of the algorithms. Whereas the num ber of compar-isons decreases in Ma tch when the ratio of variables gro ws, it increases for Na  X  ve . Moreo ver, the larger the ratio of variables and the smaller the pattern length, the higher the saving with Ma tch . For instance, with 25% of variables and a 4-sym bols pattern, the saving is 13%. When the pattern is only comp osed of variables (ratio = 1) the saving reac hes 85%.

The Na  X  ve algorithm blindly shifts the pattern one posi-tion ahead when a failure occurs, without trying to deter-mine whether the shift can possibly be successful or not. When the pattern is highly selectiv e (i.e., has low chances to matc h with a trajectory), a failure is likely to occur on the rst or second sym bol, and the beha vior of Na  X  ve re-mains close to that of Ma tch because in that case the edges information does not bring much added value.

The di erence evolves with the num ber of variables be-cause variables mak e the pattern more generic, and therefore more complian t to matc h, at least partially , with trajecto-ries. This is where the supp ort of the table of edges brings much, and where the beha viors of the two algorithms di-verge. In the case of Na  X  ve , the num ber of comparisons is prop ortional to the size of the partial matc hing. Indeed, when a failure occurs at position l , all the possible shifts be-tween 0 and l must be successiv ely investigated by Na  X  ve , and eac h shift rep eatedly compares the same trajectory sym-bols with di eren t parts of the pattern.

On the other hand, Ma tch tak es adv antage of the table of edges to limit the num ber of comparisons. When a failure occurs at position l , the densit y of variables in the pattern favors the existence of one or sev eral edges, and thus mak es it possible to perform the appropriate shift without any ad-ditional comparison.

Finally , Figure 10 sho ws that, as exp ected, the num ber of comparisons gro ws linearly wrt the duration of the obser-vations (thus, the length of the sequences of moves). The num ber of regions is set to 21 and the ratios of variables are 25%. At eac h time instan t, the system receiv es on the average the same num ber of events for the vehicles, with the same probabilit y to encoun ter a failure during the matc hing attempt. This justi es the limitation of the duration to 20 time units for our exp erimen t.
This pap er prop oses an extension of the standard pattern matc hing KMP algorithm [12] to parameterized patterns. This extended algorithm is suited to query answ ering in set-tings where the datasets of sequences is large. As sho wn Figure 10: Num ber of comparisons with time for a 6-length pattern and di eren t ratios of variables by our evaluation, our technique pro vides a signi can t im-pro vemen t over the na X ve approac h whic h merely shifts one position at-a-time. Indeed, the extended KMP algorithm avoids the burden of rep eated comparisons of the same part of a sequence.
 Poten tial for other optimizations remains to be explored. In particular, we aim at taking into accoun t richer relation-ships among the di eren t sym bols of the alphab et to impro ve the selectivit y of the query evaluation. By considering the adjacency of regions in the trac king application for instance, we can detect unsatis able patterns, eliminate some incon-sisten t edges, or remo ve from consideration objects that do move in a region \co vered" by a given pattern.
