 Contemporary software systems, such as service-based mobile applications that are in-creasingly immersed in users X  everyday life, must continuously adapt their behavior to changes in users X  requirements, operating conditions, and resource availability [5]. For instance, a music download a pplication may need to behave differently when the user X  X  device is connected through the mobile phone to the Internet, than when it is connected via Wi-Fi, when the device is plugged to a docki ng station rather than on battery power, when the user X  X  preferred music delivery service is not available, and another needs to be selected, and so on. Such software has to cope with such problems as incomplete specifications of its operating conditions, unanticipated events, variable quality of ser-vice from third-party services.

The vision for self-adaptive systems (SAS) is that they should continuously adapt their behavior at runtime in response to changing user X  X  requirements, operating con-texts, and resource availability. Realizing this vision requires that we understand pre-cisely how the various steps in the engineering of SAS depart from the established body of knowledge in information systems engineering. Research agendas for SAS have been proposed in various communities. Fo r instance, the Software Engineering for Self-Adaptive Systems (SEAMS) community focuses on issues pertaining to system architectures 1 , while the Requirements Engineering community has proposed methods for analyzing requirements for self-adapt ivity and suggested that requirements should become artifacts used, processed, and changed at runtime [2,11,18,21]. This led to pro-posals for various methods to engineer requirements for SAS. However, there has been limited consensus among the research communities on two issues: (i) what main con-cepts and relations are needed to define the requirements for SAS, and (ii) how does the requirements problem (i.e., the problem to solve during requirements engineering) differ for SAS, compared to systems that are not self-adaptive.

Taking the perspective of requirements engineering (RE) for SAS, we envision SAS to have an internal representation of their user X  X  requirements, and of their operational environment, by being equipped with automated reasoning capabilities for monitoring, analyzing changes that occur dynamically at runtime and finding solutions (i.e. set of tasks that can satisfy the requirements using an available services or otherwise) to meet them, thus ensuring the consistency with the intended system X  X  requirements.
The aim of this paper is to identify concepts and relations, which are necessary to deal with while eliciting and analyzing requirements for SAS and are important to take adaptation decision at runtime by the system itself. This leads us to formulate the run-time requirements adaptation problem that a SAS should be engineered to solve.
Section 2 presents the conceptual tools used in the rest of the paper. We introduce the runtime requirements adaptation problem in Section 3. In Section 4, we present how adaptation problem is connected to RE by extending the core ontology for RE and proposing concepts and relationships needed to determine the runtime requirements adaptation problem using examples related to travel planning software. Related work and discussion are presented in Section 5 and 6. The paper ends with conclusions and a summary of directions for future work. 2.1 General Requirements Problem The overall aim of RE is to identify the purpose of the system-to-be and to describe as precisely and completely as possible the properties and behaviors that the system-to-be should exhibit in order to satisfy that purpose. This is also a rough statement of the requirements problem that should be solved when engineering requirements.

Zave &amp; Jackson [24] formalized the requirements problem as finding a specification (S) in order to satisfy requirements (R) and not violate domain assumptions (K), to ensure that K, S R . This formulation highlights the importance of the specification to be consistent with domain assumptions, and that requirements should be derivable from K and S . It was subsequently argued that there is more to the requirements problem than this formulation states [7]. Namely, a new core ontology for requirements (CORE) was suggested along with a new formulation of the requirements problem to recognize that in addition to goals and tasks, different stakeholders have different preferences over requirements, that they are interested in choosing among candidate solutions to the requirements problem, that potentially many candidate solutions exist (as in the case of service-/agent-oriented systems, whe re different services/agents may compete in offering the same functions), and that r equirements are not fixed, but change with new information from the stakeholders or the operational environment. In absence of preferences, it is (i) not clear how candidate solutions to the requirements problem can be compared, (ii) what criteria (should) serv e for comparison, and (iii) how these criteria are represented in requirements models.

Techne [8], an abstract requirements modeling language was recently introduced as a starting point for the development of n ew requirements modeling languages that can be used to represent information and perform reasoning needed to solve the require-ments problem. Techne is abstract in that it assumes no particular visual syntax (e.g., diagrammatic notation such as present in Tr opos [14]), and it includes only the min-imum concepts and relations needed to formalize the requirements problem and the properties of its solutions. Techne is a convenient formalism for the formulation of the runtime requirements adaptation problem, a s it is adapted to the concepts, such as goal, task, domain assumption, and relations (e.g. C onsequence, Preference, Is-mandatory, Is-optional) that remain relevant for the RE of SAS. To keep the discussion simple in this paper, we assume that require ments and other information i s available in propositional form, so that every proposition is nothing bu t a natural language sentence. We overview below the requirements problem formulation using parts of Techne that we need in the rest of the paper. In [15], we provide definitions of the consequence relation |  X  used in the definition of the candidate solution below.
 Definition 1. Requirements problem: Given the elicited or otherwise acquired: do-main assumptions (in the set K ),tasks in T ,goals in G , quality constraints in Q , softgoals in S , and preference, is-mandatory and is-optional relations in A , find all candidate so-lutions to the requirements problem and compare them using preference and is-optional relations from A to identify the most desirable candidate solution.
 Definition 2. Candidate solution: Asetoftasks T  X  and a set of domain assumptions K  X  are a candidate solution to the requirements problem if and only if: 1. K  X  and T  X  are not inconsistent, 2. K  X  , T  X  |  X  G  X  , Q  X  ,where G  X   X  G and Q  X   X  Q , 3. G  X  and Q  X  include, respectivel y, all mandatory goals and quality constraints, and 4. all mandatory softgoals are approximated by the consequences of K  X   X  T  X  , so that We start below from the CORE ontology and problem formulation in Techne, and add concepts specific to the RE for SAS, which leads us to an ontology for requirements in SAS and the formulation of the requirements problem in context for SAS. We sub-sequently show how to formulate the runtime requirements adaptation problem as a dynamic RE problem of changing (e.g. switching, re-configuring, optimizing) the SAS from one requirements problem to another r equirements problem, whereby the chang-ing is due to change in requirements, context conditions, and/or resource availability. 2.2 Adaptive Requirements and Cont inuous Adaptive RE (CARE) Framework To support the analysis at design-time, we proposed adaptive (functional or non-functional) requirements . They have some degree of flexibility in their achievement conditions, which in turn requires the monitoring of the specification, while taking into account the changes in the operating context, evaluation criteria and alternative software behaviors [16].

More recently, we have proposed a Continuous Adaptive Requirements Engineering (CARE) framework [17,18,19] that views adaptive requirements as runtime artifact that reflect the system X  X  monitoring and adaptation capabilities. RE is performed at runtime by updating initial requirements with ne w ones, or by removi ng requirements.
We proposed a classification of adaptation types in the CARE framework, that can be performed by the system itself or by involving the user (both the end-user or the de-signer) [19]. Mainly, type 1 and 2 adaptations are performed by the system itself, type 1 corresponds to system exploiting existin g available solutions when needed, where type 2 is related to monitored information i.e. exploiting it to evaluate changes and se-lect alternative solution. Type 3 and 4 adaptations involves users. In type 3 end-users may express new requirements or change existing ones at any given time, by giving input information correspondingly system analyzes it by finding solutions (adapts) for new/refined needs of the end-users. In type 4, requirements for which there are no possi-ble solutions available analyst/designers are involved for offline evolution of the system. Various definitions of SAS have been offered in the literature. We remain aligned with the usual conception, namely, that a SAS is a software system that can alter its behavior in response to the changes that occur dyna mically in its operating environment. The operating environment can include anything that is observable by the software itself including operational setting in a context, end-user X  X  input, profile and resources.
SAS must be  X  X ware X  at runtime of the changes in requirements, its operating con-text, and in the availability of resources. SAS at runtime need the ability to sense changes. We interpret this as a sort of RE that we call  X  X E@runtime X , where SAS plays  X  to the feasible extent  X  the role of an analyst. It has a representation of requirements, of the conditions in its operating contexts (acquired through sensors, for instance), and of the resources it uses. It can add, remove, or otherwise change these, depending on the changes detected through interfaces with th e users, environment, and resources. New information thereby acquired can affect the  X  X equirements problem X  leading the SAS to query the user for new requirements, or ot herwise adapt following the adaptation types [19]. E.g., (a) select a predefined available behavior or look for an alternative behavior the SAS has been designed and implemented for, by exercising its internal monitor-eval-adapt loop (i.e., adaptation types 1 and 2); (b) compose a new solution by exploiting knowledge on available servi ces or explicitly acquired through user X  X  input or change in context (i.e., adaptation type 3); (c) if no solution can be found for the new information, SAS must inform the user for further instructions (adaptation type 4).
We see runtime adaptation as a dynamic RE problem , where changes in requirements, context, and resources lead to a new requirements problem, and this in turn requires the resolution of that new problem. The dynamic aspect is that move from one requirements problem formulation to another due to the changes that the SAS can detect. The problem of reformulating the requirements problem when changes occur, and then solving the changed problem is what we call the Runtime requirements adaptation problem .To resolve this problem, we argue that it is necessary to know what kinds of information and which relations are crucial for the system to capture. We therefore make explicit the dynamic parts in the requirements problem formulation based on the CORE ontology. Building upon the above considerations, we argue that concepts such as user X  X  context and resources must be considered as first cl ass citizens on top of the existing CORE ontology to engineer requirements for SAS. We add two new concepts, Context and Resource on top of the CORE ontology to accommoda te the changes that might occur at runtime, which not only demands adaptation (i.e. dynamically changing from one requirements problem to another) but also r equires an update to the specification (i.e. refinement of requirements).

The revised ontology of the concepts is proposed taking into account the concepts proposed in Techne [8] to support the definition of runtime requirements adaptation problem .InFig.1,concepts( Context and Resource ) and relations ( Relegation and Influence ) are presented, relating them to the concepts of the CORE ontology. Below, we start by introducing the concept of a requirements database. Definition 3. Requirements database: A requirements database, denoted  X  is the set of all information elicited or otherwise acquired during the RE of a system-to-be. Remark 1. Since  X  should include all information elicited or otherwise acquired in , it should include all instances of domain assumptions (i.e. invariants in the appli-cation domain), goals, softgoals, quality c onstraints, and tasks that we elicited, found through refinement or otherwise identified during RE . One can view  X  as a repository of information that is usually found in what is informally referred to as a  X  X equire-ments model X . The notation used in the definition of the requirements problem, note that  X  = K  X  T  X  G  X  Q  X  S .
 Remark 2. Below, we will use the term requirement to abbreviate  X  X ember of the re-quirements database  X   X . I.e., we will call every member of  X  a requirement. To get to the definition of the runtime requirements adaptation problem , we start intro-ducing the Context concept. In [15], we discussed how this definition relates to existing conceptions and use of Context in the AI and RE literatures (e.g., [12,6,20,1]). Definition 4. Context: An instance C of the Context concept is a set of information that is presupposed by the stakeholders to hold when they communicate particular require-ments. We say that every requirement depends on one or more contexts to say that the requirement would not be retracted by the stakeholders in every one of these contexts. Firstly, we need a language to write this information that is presupposed, and is thereby in the set of information that we call a particular context. We develop that language be-low. Secondly, the dependence of a require ment on a context means that every require-ment is specific to one or more contexts, and thus, requirements need to be annotated by contexts, which begs additional questions on how the engineer comes to determine con-texts. At this point, we revise the Techne la nguage to allow information that is included in contexts. This results in adding one more sort.
 Definition 5. Techne for SAS: The language L SAS is a finite set of expressions, in which every expression  X   X  X  SAS satisfies the following BNF specification 2 : Remark 3. We used (indexed/primed p, q, r) as an arbitrary atomic statement, every  X  an arbitrary complex statem ent, and every x an arbitrary label to represent Techne labeled propositions i.e. domain assumption ( k (p)), a goal ( g (p)), etc., to distinguish from these basic labeled propositions the c ontext propositions (i .e., propositions about context), c (p) is added separately in the BNF speci fication, via q, and every w can either be x or q. Every y represents a complex statement as a formula with conjunction and implication such that y can be either w or  X  , where w is some requirement in a context propositions and  X  refers to logical inconsistency. We can then rewrite  X  as a complex statement consists of either w or k ( y ) or c ( y ) .
 Definition 6. Consequence relation of Techne in context: Let  X   X  X  SAS ,  X   X  X  SAS , and z  X  X   X ,  X } , then: 1.  X  | c X   X  if  X   X   X  ,or 2.  X  | c X  z if  X  1  X  i  X  n ,  X  | c X   X  i and k ( n i =1  X  i  X  z )  X   X  .
 The consequence relation | c X  is sound w.r.t. standard entailment in propositional logic. It deduces only positive statement by being paraconsistent, thus all admissible candi-date solutions are found via paraconsistent and non-monotonic reasoning. Reasoning is paraconsistent because an inconsistent  X  or C should not allow us to conclude the satisfaction of all requirements therein; i t is non-monotonic in that prior conclusions drawn from a  X  or a C may be retracted after new re quirements are introduced. We also need a function that tells us which contexts a requirement applies to. Definition 7. Contextualization function: Let C be the set of all contexts. C :  X  ( L SAS )  X  X  X   X  ( C ) (where  X  returns the powerset) is called the contextualization function that for a given set of formulas returns the set of contexts to which these formulas apply to. By  X  X pply to X , we mean that C  X  X  (  X  ) iff the following conditions are satisfied: 1. C,  X  |  X   X  , i.e.,  X  is not inconsistent with context C , 2. C is such that  X  X  X   X  such that C, X |  X   X  , i.e., the context C together with some Several remarks are in order. Firstly, with L SAS , we now have a new sort for expressions that are members of a set that defines a context. Recall that we defined an instance C of Context as a set of information, so that now L SAS tells us that one member of that set can either be a proposition p , denoted c ( p ) , or can be a formula with implication, denoted c ( y ) in the BNF specification. E.g., if the engineer assumes that the stakeholders wants that her goal g ( p ) for  X  X rrive at destination X  be satisfied both in the context C 1 in which the context proposition  X  c ( q ) : flight is on time X  holds (i.e., c ( q )  X  C 1 ), and in the context C 2 in which the context proposition  X  c ( r ) : flight is delayed but not more than 5 hours X  holds (i.e., c ( r )  X  C 2 ), then C 1  X  X  ( g ( p )) and C 1  X  X  ( g ( p )) .
Secondly, observe that the BNF specification lets us write formulas in which we com-bine context propositions an d requirements, e.g.: k ( p )  X  c ( q )  X  X  X  , which the require-ments engineer can use to state that the domain assumption k ( p ) that was communicated by the stakeholder does not hold in cont exts in which the context proposition c ( q ) holds.
Since we can combine context formulas and requirements, we can state very useful relations, such as that some requirements c onflict with some contexts, by saying that these requirements are inconsistent with some of the context formulas in these contexts. As an aside, rules that connect requirements and context formulas need not be specified in a definite way by the requirements engineer. It is also possible to learn them by asking feedback to the user i.e. a SAS at runtime can perform this task. For example, if the system asks the user a question of the form: Your flight is delayed by 5 hours or more. Do you wish to rebook a flight for the next day? This question can be reformulated as a question on which of these two formulas to add to the current context of the user (i.e. the context in which we asked the user that question): where c ( p ) is for  X  X light delayed by more than 5 hours X , g ( q 1 ) is for the goal  X  X eep the booked flight X , and g ( q 2 ) is for the goal  X  X ebook the same flight for the next day X . If the user answers  X  X es X , then add formula c ( c ( p )  X  g ( q 1 ))  X  X  X  to the context in which we asked the user that question; if the user answers  X  X o X , then we add c ( c ( p )  X  g ( q 2 ))  X  X  X  to the current context.

We now add the Resource concept. Since the formal language that we use in this paper is propositional, we will keep the resource concept out of it.
 Definition 8. Resource: An instance R of the Resource concept is an entity referred to by one or more instances of Communicated information .
 In order to introduce resources in the definitio n of the runtime requirements adaptation problem, we need a function that tells us which resources are referred to by a task, domain assumption, or a context proposition, as these resources will need to be available and used in some way in order to ensure that the relevant domain assumptions and context propositions hold, and t hat the tasks can be executed.
 Definition 9. Resource selector function: Let C be the set of all contexts. Given a set of tasks, domain assumptions, and/ or context propositions, the re source selector function returns the identifiers of resources necessary for the domain assumptions and/or context propositions to hold, and/or tasks to be executed: The domain of R are domain assumptions, context p ropositions, and tasks. The reason that goals, softgoals, and quality constraints are absent is that the resources will be mobilized to realize a candidate solution to t he requirements problem, and the candidate solution includes only domain assumptions and tasks. Since these domain assumptions and tasks are contextualized, we need to ensure the availability of resources that are needed in the context on which these domain assumptions and tasks depend on. Note also that we have C because C is a set of sets, so that we need to get the union of all of the sets in C .
 We can now formulate the runtime requirements adaptation problem for SAS .
 Definition 10. Runtime requirements adaptation problem: Given a candidate solu-tion CS ( C 1 ) in the context C 1  X  C to the requirements problem RP ( C 1 ) in context C RP ( C 2 ) in context C 2  X  C and choose among candidate solutions to RP ( C 2 ) a solution CS ( C 2 ) in the context C 2 to the requirements problem RP ( C 2 ) in the context C 2  X  C . The definition of the runtime requirements adaptation problem reflects the intuition that by changing the context, the requirement s problem may change  X  as requirements can change  X  and from there, a new solution needs to be found to the requirements problem in the new context.

We now reformulate the requirements problem so as to highlight the role of context in it, as well as of the resources.
 Definition 11. Requirements problem RP ( C ) in context C :Given the elicited or oth-erwise acquired: domain assumptions in the set K ,tasksin T , goals in G , quality con-straints in Q , softgoals in S , preference, is-mandatory and is-optional relations in A ,a context C on which K  X  T  X  G  X  Q  X  S and A depend on, find all candidate solutions in context C to RP ( C ) and compare them using preference and is-optional relations from A to identify the most desirable candidate solution.
 Definition 12. Candidate solution CS in the context C : Asetoftasks T  X  and a set of domain assumptions K  X  are a candidate solution in the context C to the requirements problem RP ( C ) in context C if and only if: 1. K  X  and T  X  are not inconsistent, 2. C, K  X  , T  X  | c X  G  X  , Q  X  ,where G  X   X  G and Q  X   X  Q , 3. G  X  and Q  X  include, respectively, all mandat ory goals and quality constraints, 4. all mandatory softgoals are approximated by the consequences of C, K  X   X  T  X  ,so 5. resources R ( C  X  K  X   X  T  X  ) needed to realize this candidate solution are available. As discussed earlier, we view runtime requirements adaptation problem as a dynamic RE problem. To support the analysis, we add two relations in the CORE ontology. We now define the relegation relation via the inference and preference relations in Techne. Definition 13. Relegation relation: A relegation relation is an ( n +1 )-ary relation that stands between a requirement  X   X   X  and n other sets of requirements  X  1 , X  2 ,..., X  n  X 
 X  if and only if there is an inference relation from every  X  i to  X  and there is a binary relation:  X   X  X   X  i | 1  X  i  X  n } X {  X  i | 1  X  i  X  n } whereby  X  i  X   X  j if it is strictly more desirable to satisfy  X  by ensuring that  X  i holds, than to satisfy  X  by ensuring that  X  j holds.
 The inference relations required by a relegation relations indicate that a relegation rela-tion can only be defined for requirements that we know how to satisfy in different ways. For example, if we have a goal g ( p ) , and we have two ways to satisfy that goal, e.g.: then we have satisfied the first condition from the definition of the relegation relation, since  X  1 | c X  g ( p ) and  X  2 | c X  g ( p ) .

The second condition in the definition of the relegation relation says that we need to define a preference relation g ( p ) between different ways of satisfying g ( p ) .Observe that we define g ( p ) between sets of information, not pieces of information. The Techne preference relation defines preference bet ween individual pieces of information, so we can use preference relations between members of  X  1 and  X  2 to define g ( p ) .
Suppose that t ( q 1 ) t ( q 2 ) , i.e., that we prefer to execute task t ( q 1 ) to executing the task t ( q 2 ) . We can define g ( p ) as a function of the Techne preference relation, i.e., g ( p ) def = f ( ) , that is, from the information that the preference relation already includes. Namely, in this example it is appropriate to say that, if t ( q 1 ) t ( q 2 ) ,then  X  1 g ( p )  X  2 . Since we have only  X  1 and  X  2 , it is enough to know that  X  1 g ( p )  X  2 to know everything we need to define the relegation relation.

Namely, the relegation relation ( g ( p ) , X  1 , X  2 , g ( p ) ) tells us that, if we cannot sat-isfy g ( p ) through  X  1 then we will relegate to  X  2 , i.e., satisfy g ( p ) through  X  2 .
Finally, we define the influence relation .Notethatitissimplehere,sincewehaveno numerical values, so we cannot speak about influence as correlation. We can only say that some information influences some other information if the absence of the former makes it impossible for us to satisfy the latter.
 Definition 14. Influence relation: An influence relation is a binary relation from  X   X  L 1.  X   X   X   X   X  C s.t.  X  | c X   X  and  X  \  X  | c X   X  ,or 2.  X   X   X   X   X  C s.t.  X  | c X   X  and  X  \  X  | c X   X  .
 In the first case above, we say that  X  weakly influences  X  , denoted  X  wi  X  X  X   X  .Inthe second case above, we say that  X  strongly influences  X  , denoted  X  si  X  X  X   X  . Remark 4. If  X  si  X  X  X   X  , then we have no way to satisfy  X  if  X  is not satisfied. If  X  wi  X  X  X   X  , then some ways of satisfying  X  cannot be used to do so if  X  is not satisfied. 4.1 Runtime Requirements Adaptation Problem Illustration We now revisit the above definitions and use scenarios from travel exemplar case study to illustrate how SAS, instantiating CARE and running on user X  X  mobile phone, resolves the  X  X untime requirements adaptation problem X  at runtime.
 For example, user arrives at the airport to avail her flight from Italy to Canada via Paris for a business meeting. While at the airport after the boarding, user want to connect to the Internet using her mobile phone to check emails and flight details before checking in for the plane. Moreover, user wants to be informed about any flight delay.
Taking the above example, we now present SAS adaptation sequence at runtime in case of change in context C along the time T = t 1 , ....t n as shown in the Fig.2. Let CS be a set of candidate solution, thereby determining the runtime requirements adaptation problem as a combination of instances of the tasks T  X  ) and domain assumptions K  X  such that G  X  , Q  X  and S M are satisfied. In case of changes in the context C = C 1 , ....C n overtime for which CS needs to be re-evaluated by the system and R is required to be used or identified in a given context C to realize CS . By re-evaluation we mean that system at runtime exploits its monitored information, evaluate all the possible alterna-tive CS or search for new ones (i.e. exploiting available services) that can satisfy the runtime adaptation problem in response to changes in the C therefore adapting to the candidate solution CS . At this SAS may perform at sub-optimal level and can exploit automated reasoning techniques such as pla nning or decision making techniques such as analytic hierarchy process (AHP) 3 .
 Before Adaptation: Assume that at time t 1 , the user X  X  goals G  X  are to connect to the Internet for checking details of itinerary and inform about the flight delays with the quality constraint Q to have the Internet connectivity not less than 256Kbps . To satisfy these requirements, SAS is running according to its candidate solution CS i.e., using the set of tasks T  X  ,e.g. search for available connection , enable Wi-Fi , get itinerary details and show flight itinerary , in the current context i.e. C 1 is at the airport ,andthe domain assumption K  X  t 1 Internet must be available at the airport , is not violated. This implies that, CS ( C 1 ) = ( K  X  C 1 ,T  X  C 1 ) and CS ( C 1 ) satisfies the runtime requirements adaptation problem i.e. RP ( C 1 ) . We can rewrite this as: where R ( C 1  X  K  X  C hotspot, Mobile Phone of the user) to perform T  X  C During Adaptation: SAS while executing CS ( C 1 ) , observes a change in context i.e. the airport Wi-Fi connection becomes unavailable at time t 2 . Due to this change in context from C 1 to C 2 , the existing candidate solution CS ( C 1 ) might be valid but is not adequate to satisfy the current context C 2 . As a consequence, the SAS needs to re-evaluate its candidate solutions CS by searching in its solution base i.e.  X  or looking for solutions that can be realized through available services. For instance, a new candi-date solution CS ( C 2 ) could be, e.g. connect to the Internet using data services either 3G or Edge on mobile phone R ;or recommending user to move to the area where the signal strength is stronger ;or avail the Internet on the free booths . At this stage, SAS may use relegation relation to infer, if the G  X  with a Q is to have the Internet connec-tivity not less than 256Kbps can be relegated. After re-evaluating the possibilities, SAS finds CS ( C 2 ) i.e. set of tasks T  X  ,e.g. enable 3G or Edge service and connect to the Internet with a refined Q i.e. Internet connectivity greater than 256Kbps for the user. At this stage the influence relation is also used to ascertain the influence of CS ( C 2 ) on user X  X  goals and preference, e.g. Hi-speed Internet is preferred than no Internet connec-tion . SAS can derive conclusions that adapting to CS ( C 2 ) will not affect K  X  C 2 i.e. Any flight information must be communicated to the customer and goal G  X  i.e. to connect to the Internet to view itinerary and inform about the flight delays will be satisfied. There-fore, CS ( C 2 ) = ( K  X  C 2 ,T  X  C 2 ) ; satisfying the runtime requirements adaptation problem i.e. RP ( C 2 ) . We can rewrite this as: where R ( C 2  X  K  X  C or Edge data services, Mobile Phone of the user) to perform T  X  C After Adaptation: At time t 3 , SAS adapts to the candidate solution CS ( C 2 ) taking into account the context C 2 and available resources R i.e. Access 3G or Edge data services, Mobile Phone of the user, thus not violating the K  X  C 2 . Adaptation is performed dynamically at runtime by changing (e.g. switching, re-configuring, optimizing) SAS from one requirements problem to another i.e. RP ( C 1 ) to RP ( C 2 ) , in response to changes in the context, user X  X  needs or resource variability. Requirements engineering is carried out at the outset of the whole development pro-cess, but in the context of SAS, RE activities are also needed at runtime thus enabling a seamless adaptation. Research on SAS has recently received atten tion from variety of research communities mainly targeting the software engineering of SAS from require-ments, design and implementation perspectives. Focusing on requirements engineering for SAS, research agenda from SEAMS [5] a nd RE community has identified key chal-lenges that must be addressed while developing such systems.

For instance, in [23], a declarative language (RELAX) is proposed to capture uncer-tainty, using temporal operators (such as eventually, until) by formalizing the semantics in Fuzzy Branching Temporal logic, to specify requirements for SAS. Similarly, adopt-ing goal-oriented analysis for adaptive s ystems, mitigation strategies are proposed to accommodate uncertainty and failures by using obstacle analysis in [ 4]. Requirements reflection is another aspect, where ideas from computational reflection has been bor-rowed to provide SAS the capability to be aware of its own requirements [21]. Similarly, online goal refinement [9] is of prime importance considering the underline architecture of the intended SAS. Taking the engineering perspective, making the role of feedback loops more explicit in the design of SAS has been recognized as a key requirement for developing SAS in [3].

In our previous work, we proposed similar ideas to engineer adaptive requirements using goal models and ontologies by making e xplicit the requirements for feedback loop (i.e. monitoring, evaluation criteria, and adaptation alternative) more explicit in [16]. We extend this work in [17,18,19] by proposing a Continuous Adaptive RE (CARE) frame-work for continuous online refinement of requirements at runtime by the system itself involving the end-user. We proposed an architecture of an application that instantiate CARE. We proposed a classification of adapt ation at runtime by exploiting incremental reasoning over adaptive requirements represented as runtime artifact. Similar ideas has been proposed treating goals as fuzzy goals formalized using fuzzy logic representing strategies for adaptation and operationaliz ing them as BPEL processes in [2]. Another variation of this idea has been advocated in [22] as  X  X wareness Requirements X , as a way to express constraints on requirements as meta requirements to deal with uncer-tainty while developing SAS.

In goal-oriented modeling, Tropos has been extended to capture the contextual vari-ability (mainly location) [1] by leveraging the concept of variation points [10] exploiting the decomposition rules in a goal tree. Mainly, it helps in linking the alternative in the goal model to the corresponding context (location) that helps in monitoring facts and reasoning for adaptation in case of change in the context (location). Extended design ab-stractions, including environment models, explicit goal types, and conditions for build-ing adaptive agents have been proposed as an extension of Tropos , in Tropos4AS [13]. It is worth to further discuss assumptions underlying the suggested problem formula-tion, its generality as well as its practical im pact. The problem formulation suggested in this paper makes no assumptions and imposes no constraints on how the information that is used and acquired. We thereby recognize that not all information can be col-lected during requirements engineering, or at design time, but that this will depend on the technologies used to implement the system. For example, the information about the context, the formulas in C may  X  if the implementation technology allows  X  be obtained by recognizing patterns in the data that arrives through sensors, then matching patterns of data to templates of proposition or implications. We stayed in the propositional case, since this was enough to define the main concep ts and relations, and subsequently use them to formulate the runtime requirements adaptation problem. The actual system will operate using perhaps more elaborate, first-order formalisms to represent information, so as to make that information useful for planning algorithms applied to identify can-didate solutions. However, regardless of the formalism used, the system still needs to be designed to ensure the general conditions and relations that the problem formulation states: e.g., that the system needs an internal representation of information pertaining to contexts, domain assumptions, tasks, goals, and so on, that goals and quality constraints are satisfied through consistent combinations of C , K and T , among others.
Concerning generality of the proposed probl em formulation and practical implica-tion, our aim in this work was first to understand the general problem, and then focus on developing particular requirements mode ling languages to handle it. In this regards we believe that recently proposed frameworks f or engineering re quirements for SAS can be reconnected to our problem formulation. Consider, for example RELAX [23], which proposes a formalism for the specification of requirements and a particular way to relax them at runtime: if a requirement cannot be satisfied to the desired extent, then alternative requirements can be specified in RELAX, stating thereby how achievement conditions for the original requirement can be relaxed. This mechanism can be consid-ered a particular way to implement the Rel egate relation, that is the RELAX mecha-nism obtains a straightforward interpretation in the language we used here. There can be other ways to handle uncertainty and relaxation of requirements, and our aim in this paper was to remain independent of particular approaches. We argued in this paper for a general formulation of the runtime requirements adapta-tion problem, using recent work on the revi sed general requirements problem and its core ontology. Taking into account our work on continuous adaptive RE in CARE, and the types of adaptation defined in CARE, in this paper, we proposed to make explicit the dynamic parts in requirements represent ation and formulated the runtime require-ments adaptation problem. In particular, two key concepts help managing runtime re-quirements changes, namely the concept of context and resource , while the relegation and influence relations capture changes at runtime. The proposed runtime requirements adaptation problem is envisioned as dynamic RE problem for adaptive systems i.e. re-formulating the requirements problem when changes occur that a SAS can detect, and then solving the changed problem at runtime.

Ongoing work aims at exploiting these form al definitions of concepts and relations into a more concrete modeling and analysis language. The concept of requirements database  X  introduced in this paper provides pre mise to define operations (e.g. adding, removing, substituting requirements) that a SAS may perform over  X  to update its own specification at runtime thus help realizing continuous adaptive RE (see CARE [17,18]). Moreover, the application at runtime of automated reasoning (such as in AI planning) and decision-making techniques (e.g., Analy tic Hierarchy Process) may be relevant for the engineering and running of SAS. They require further investigation.

