 Services have become the standard way of exposing applications, beyond tech-nology and organisational boundaries, to allow functional capabilities to be accessed and composed, based on loosely coupled collaborations. Web Services Description Language (WSDL), REST and proprietary application programming interfaces (API) are rapidly growing, especially with the rise of Internet-based applications, software-as-a-service and cloud computing, in turn leading to larger vendors providing openly available interfaces for large and otherwise  X  X n-house X  software installations, notably in the enterprise systems segment (e.g. ERP and CRM systems). Consequently, the number, range of types, size, and overall com-plexity of services are progressively increasing, compounding the challenges of integrating services and vastly outpacing the conventional means to adapt ser-vices to support application interoperability in diffuse network settings. Consider, for example, SAP X  X  Enterprise (Web) services, as analysed in [ 1 ], where the input message of the goods movement service operation has 104 parameters, out of which only 12 are mandatory for the correct invocation of the service, with the other 92 data types and properties factoring in different usages of the service across different industries. As another example, FedEx provides 12 Web services 1 with the open shipping service demonstrating the highest com-plexity. It has 22 operations with the average number of input parameters of 307; 111 of them are nested types on average; an average number of hierarchical levels is 6. The operation which has the largest number of input parameters is createOpenShipment, with 1335 parameters, 442 of which are complex and the total levels of hierarchy are 9. More contemporary services from Internet players, too, have non-trivial operations as seen in the e-commerce services provided by Amazon, requiring comprehension of large and technically intricate documenta-tion . From a service consumer X  X  perspective, several problems arise from this level of service complexity: (1) It is difficult to comprehend what each parameter means as the number is very large (2) It is challenging to know which parameter should go along with which for a particular purpose, as a large number of these parameters are optional and there are certain dependencies between them which consumers often do not have sufficient comprehension. For example, parameter B may become compulsory because parameter A is used in a specific invocation (3) How are operations related to each other? In other words, are there any sequence constraints to invoke these operations? (4) How are operations in one service related to ones in other services? In general, integration of heterogeneous applications requires adapters to mediate across data types of operations (structural aspects) and the permissible orders in which operations are invoked (behavioural aspects). Despite advances in automated support for service adaptation, complex interfaces such as those from SAP, FedEx, Amazon and many others require manual effort and reliance vendors, do not disclose structural and behavioural interfaces needed for service adaptation, but instead publish interface signatures such as WSDL specifications [ 3 ]. Thus, service adaptation incurs significant lead times and costly maintenance to yield service adapters, and their productivity in the context of dynamic service growth on the scale of the Internet is restricted.
 This paper extends upon a recent and complementary strategy to conven-tional service adaptation, whereby the details of service interfaces and knowledge required to interact with them can be unilaterally synthesised by service con-sumers. Existing interface synthesis techniques build on type elicitation and data for identifying the focal artefacts of applications, namely the business entities , which forms the basis for the creation of a simplified and fine-grained interface layer, allowing access (create, read, update and delete) operations against indi-vidual business entities. We extend upon these techniques to derive key relation-ships between business entities, which then provides a refined understanding of derived business entities and their dependencies, allowing invocation dependen-cies across their operations to be derived. For example, if one business entity such as a purchase order strictly contains another business entities such as line items, the container business entity should be created before the contained entities. In all, we develop heuristics for three relationship categories: strong containment, weak containment, and association. These, in turn, result in different business entity operation invocation dependencies, providing indispensable knowledge for generating behavioural aspects of service interfaces.
 of the art and this is followed by the elaboration on the key components of our interface synthesis framework and the development of detailed insights into its most novel features in Section 3 . Section 4 evaluates the framework by experimenting the implemented prototype with a variety of services and reveals some open issues. Finally, Section 5 concludes the paper and outlines the future work. Service analysis techniques have been proposed over many years to address chal-lenges of service integration concerning structural and behavioural aspects of interfaces. Different approaches have been proposed including the utilisation of semantic ontologies to annotate interfaces to facilitate discovery, use, and com-position of services. As an example, Falk et al. [ 6 ] adapted automata learning to the problem of service interaction analysis. This proposal usefully combines automated analysis with semantic ontologies in that it needs semantically anno-tated interface descriptions showing preconditions and effects as the prerequisite to learn interaction protocols. These semantically annotated descriptions are usually not provided by service providers in practice, and the development and maintenance of semantic ontologies requires significant lead times and adoption. Complementary to semantic techniques, log mining algorithms [ 7 ] have been proposed for matching data type of target services for service requests, which can also be used at design-time to develop adapters. These incur overheads for aggregating logs and can suffer from missing information for derivation of associ-ation dependencies. As we discussed above, our approach concerns static analysis of service interfaces in order to derive the structure and behaviour of services, complementary to semantic and mining approaches.
 entities in operations, noting that operations of especially larger systems can have more than one entity, with potential overloading arising from bad service interface design. Identification of business entities is a complex problem requir-ing an insight into the clustering of different attributes which imply structural type cohesion of an entity. Proposals for static interface analysis proceed from assumptions of attribute to entity type associations based on the use of prior matching techniques (ontology or mining based). The approach of Kumaran et al. [ 5 ] proposes heuristics for understanding basic business entity relation-ships based on the domination theory of business entities, however the derived relationship type is strict containment, which leads to a limited understanding of operation invocation dependencies across services. A more advanced proposal for behavioural interface synthesis has been proposed by [ 4 ] based on data depen-dencies between service operations X  input and output parameters, but the study has not been exposed to overloaded service interfaces such as the aforementioned examples from enterprise and Internet players.
 Service composition approaches have also been used in the context of service adaptation, the common problem being addressed is  X  X ow to automatically gen-erate a new target service protocol by reusing some existing ones X  [ 8 ]. However, this technique assumes that the interfaces of individual services involved in a composition are available. To address the aforementioned problems, this section presents the details of a service interface synthesis framework. It consists of two main modules: Service interface analysis and Service interface refining.
 The service interface analysis module is comprised of two components (Fig. 1 ): BE data model derivation and Service operation refactoring . They analyse service structural interfaces and determine the order of invoking operations provided by a service. Services essentially focus on addressing and transferring states of resources and business entities are the primary resource manipulated by services in the context of global business networks. Therefore, our service analysis is car-ried out based on the notion of business entity (i.e., entity types) -a concept widely adopted in Object Role Modelling [ 9 ]. The BE data model derivation component analyses the input and output parameters of operations on a service and map them to a business entity-based service data model (BE data model). The Service operation refactoring component categorises operations provided by a service according to what each operation does to a business entity (i.e, to CREATE, READ, UPDATE or DELETE (CRUD) a business entity). This component also generates behavioural interfaces for each CRUD operation of a business entity.
 As a result of structural and behavioural interface analysis, a complex service interface is mapped onto a BE data model and a behavioural interface model. The former presents business entities and the relations among them inherent in the service, and the later depicts the behavioural constraints that service con-sumers are required to follow. These models form the refactored service inter-faces, which encapsulate and simplify complex and overloaded service interfaces. Having these structured service interfaces, valid combinations of input param-eter sets can be easily derived. The Service interface refining component then utilises a Monte Carlo statistic approach [ 10 ] to search for possible valid com-binations and then invoke services using these combinations with sample data values in order to determine and test their validity. An Interface Layer is formed in the end, and it exhibits much simpler service interface with possible valid combinations and behavioural specifications so that service consumers can eas-ily consume services. Due to space limit, this paper only addresses the first module: service interface analysis, which simplifies service structural interfaces and generates service behavioural interfaces.
 3.1 BE Data Model Derivation Definition 1 (Operation and Parameter). Let s be a service, OP of operations of s . For each operation op  X  OP s , N ( op is the set of input parameters and O ( op ) is the set of output parameters of  X  ( p )  X  X  primitive , complex } indicates whether p is of a primitive or a complex LineItem ) carried by p .
  X  P  X  P C  X  P specifies the (direct) nesting relation between two parameters. transitive and irreflexive.  X  P :  X  P  X  X  true , false } indicates for each ( whether p is a compulsory ( true ) or optional ( false ) element of Definition 2 (Business Entity). E is a set of business entities. For each E , N ( e ) is the name of e , key ( e ) is the unique identifier of of attributes associated with e . For each attribute a  X  X  of a and type ( a ) is the type of data carried by a . Definition 3 (Parameter and Business Entity Mapping). Let P set of complex parameters,  X  P the nesting relation between parameters, and a set of business entities. There exists a surjective mapping mapped to the same business entity.
 Definition 4 (Business Entity Nesting Relation). Let P C be a set of com-plex parameters,  X  P the nesting relation between parameters, entities, and f the mapping from P C to E . The nesting relation between two business entities can be defined as  X  E  X  E  X  E where  X  ( sitive, i.e., if e X  E e and e  X  E e , then e X  E e .  X  E : each ( e, e )  X   X  E whether e is a compulsory ( true ) or optional ( false ) element of e . ( e, e )=  X  P ( p, p )if f ( p )= e and f ( p )= e .
 Definition 5 (Domination, adapted from [ 5 ]). Let s be a service and OP the set of operations of s . Given two business entities e, e p, p s.t. e = f ( p )and e = f ( p ), e dominates e in service iff: (1)  X  op  X  OP s ,if p  X  I ( op ), then p  X  I ( op ) (2) then p  X  O ( op ) (3)  X  op  X  OP s , s.t. p  X  I ( op )  X  O ( op In other words, p  X  X  corresponding business entity is e and nates e , if and only if (1) for every operation that uses p as an input parameter, p is also used as an input parameter, (2) for every operation that uses output parameter, p is also used as an output parameter, and (3) at least one operation (as its input or output parameter) that does not use Definition 6 (Strong Containment). Given two business entities e is strongly contained in e iff e X  E e , e  X  e ,and e  X  E \{ e } captures the set of strong containment relations between business entities. Definition 7 (Weak Containment). Given two business entities e is weakly contained in e iff e X  E e and e  X  e .  X  captures the set of weak containment relations between business entities.
 Definition 8 (Association). Given two business entities e  X   X  , e and e are associated with each other if there exist two parameters such that e = f ( p )and e = f ( p ), and there exist an operation p  X 
I ( op )and p  X  O ( op ).  X  captures the set of association relations between business entities.
 Definition 9 (Business Entity Data Model). A business entity data model M is a tuple ( E , X  E , X , X , X  ) which consists of a set business entities E and their nesting relations  X  E , strong containment relations  X  , weak containment relations  X  , and association relations  X  .
 Given a service specification such as a WSDL file, the BE model derivation derives the BE data model for each operation provided by the service. This can Algorithm 1. IdentifyBEandRelation be achieved through algorithm 1 and 2 . The first algorithm generates E and and the second refines the relation  X  E to derive  X  ,  X  ,and For each service, we iterate its operations and then loop through each complex input and output parameter of each operation to identify the BE data model. There is an overview algorithm which calls algorithm 1 to do so and the details of the algorithm can be found in our report [ 11 ].
 OntologyCheck which takes name ( N ( p )) and type ( type ( parameter p  X  P C , and the business entity repository ( E returns an entity e s.t. e = f ( p ). It will return nothing if there is no match found. For each complex parameter p , we check if there is a business entity that maps onto p . To do this, the service synthesis framework allows users to des-ignate business entities for a particular context at design time. These business entities are stored in a repository E ,and p is checked against it to determine if there is a matching business entity in it. To semantically match a parameter with a business object, we assure the existence of an ontology that allows users to designate business objects for a particular context at design time. Semantic matching techniques have been well studied and this research adopts S-Match [ 12 ], a widely used semantic matching algorithm. The second step keeps the business entity and its nesting relation. If there is a mapping business entity parameters that are nested in p are converted and added to A ( e ). The conversion involves interpreting these nested parameters as attributes of e and skipping parameters that should not be attributes. Then op  X  X  entity set E op , which stores all business entities discovered in Algorithm 2. RefineBERelation a business entity e containing e , this relation is recorded as nesting, which is a part of op  X  X  BE data model  X  E op . e is an input parameter of algorithm 1 and it refers to the parent entity of current entity e . The final step takes every complex parameter p that is nested in p and recursively calls the algorithm itself to pro-cess each p . The current e is passed on to next invocation to form the nesting relation because it is the parent of each f ( p ). Essentially, algorithm 1 incremen-tally updates op  X  X  BE data model until all entities and nesting relationships are processed.
 and derive the other three types of relations for op : strong containment ( weak containment (  X  op ), and association (  X  op ) to complete the BE data model for op . Algorithm 2 iterates each business entity e in op then assesses the relationship between e and every business entity nested in e . This assessment is carried out according to the definitions of strong containment (Definition 6 ), weak containment (Definition 7 ), and association (Definition 8 ). 3.2 Service Operation Refactoring The above algorithms show how a BE model for an operation (i.e., generated. A BE data model for a service M s is an aggregation of BE data models of all operations provided by s . Based on the service BE data model the service operation refactoring component derives the behavioural interface for s . For any business entity e derived, there are a number of operations that manipulate e and these operations can be categorised into four groups: C U ,and D e , which denote the set of operations for creating, reading, updating, and deleting an instance of e respectively. To categorise operations provided by a service into the four modular operations of a business entity, we identified the following mapping rules.
 which are actually attributes of e and returns a reference to a business entity (i.e., key ( e )), the operation is for creating an instance of operation that is designed to create a business entity e usually requires its users to pass in values for some parameters which are attributes of create a shipment order, a create operation often needs to know details of ship-ment order such as what goods are to be shipped, where these goods are shipped from and to. As a result, the create operation should return a reference (i.e., id ) of the shipment order created. There may be multiple operations designed for creating a business entity, and the set C e is used to keep these operations. it returns the values of parameters that are attributes of the business entity the operation is for reading an instance of e . The set (i.e., R operations is singleton because there is usually only one operation to read an instance of e .
 and some input parameters which are actually attributes of for updating an instance of e . DELETE If the invocation of an operation requires information of key ( and returns nothing related to e but just a status, the operation is for deleting an instance of e .
 We propose an algorithm that invokes each operation op that manipulates a business entity e and then analyses the input and output parameters according to the aforementioned mapping rules to determine the category of op is to create, read, update or delete e . As a result, the algorithm groups each op and adds it into one of the following sets: C e , R e , U of this algorithm can be found in our report [ 11 ]. At this stage, there could be many operations in C e , U e ,and D e . For example, to create a shipping order, there are a number of operations and a service consumer needs to follow certain sequence constraints, so the next step is to generate these sequences for each modular operation.
 Service behavioural interfaces (i.e., protocols) depict a set of sequencing con-straints and they define legal order of messages. In this paper, a behavioural interface is formalised as business entity-based behavioural model (BE model). A ify service operations, Q a set of places that specify the pre-and post-conditions of service operations, and F  X  ( Q  X  T  X  T  X  Q ) a set of flow relations that connect a (pre-)condition to an operation or an operation to a (post-)condition. For each e  X  E s , we generate BE models for its CRUD operations. For example, the model for CREATE operation defines the operations and their invocation order for creating an instance of a business entity. To derive such a model for e , we firstly retrieve entities that are strongly contained in, weakly contained in, and associated with e . When a business entity in or associated with business entity e , an instance of e can be created in any order if  X  ( e, e )= false , otherwise if (i.e. an instance of e must be created before the creation of an instance of business entity e is strongly contained in another business entity of e cannot be created unless an e is instantiated. The second step is to retrieve all operations in C e and identify their sequence through trial/error invocation. Each op is called and the response is analysed. If it is positive, the invocation is in sequence. Otherwise, other operations in C e are called. This process proceeds until either all operations are in order or all operations have been checked. Fig. 2 ( b 1 ) and Fig. 2 ( b 2 ) present the BE behavioural model derived based on the e 1 focused data model shown in Fig. 2 (a). Specifically, Fig. 2 ( the model for the situation when the compulsory factor  X  the entities that are related is true. As e 3 is associated with created before e 1  X  X  creation, the same can be said for e C = { op 1 ,op 2 ,op 3 } and we assume the sequence of creating so the invocations of these three operations can create an instance of is strongly contained in e 1 , it can only be created after e is created after e 2  X  X  creation. Fig. 2 ( b 2 ), on the other hand, depicts the sequence derived for the situation when the compulsory factor is false. created concurrently with e 1  X  X  creation and e 4 can be created in parallel with e  X  X  creation. The detailed algorithm for BE Behavioural model derivation can be found in our report [ 11 ]. To validate the service interface synthesis framework, we have developed a pro-totype that analyses service interfaces and generates BE data models for CRUD of a business entity. This prototype is called Service Integration Accelerator and it implements the algorithms presented in the previous section. This section presents the details of the experiments we conducted on service interface analysis and evaluates the framework using their results.
 Hypotheses. We define three hypotheses to assess the effectiveness of the ser-vice interface synthesis framework. The first one is simplification -the service interface analysis mechanism simplifies overloaded and complicated service inter-faces, so service consumers are able to utilise the structural analysis results as a guidance to facilitate their comprehension of service interfaces. As a result, this reduces the amount of time that they need in order to comprehend and then invoke services correctly. Another criteria to be examined is accuracy -the ser-vice interface analysis mechanism derives all possible business entities, however a rate of 25% of false positives is allowed as some entities may not be busi-ness entities in one specific context, but are possibly business entities in another context. Therefore, we allow service consumers to filter out those which should not be entities in a specific context. Finally, we presume that the performance fulfils our requirement -the implemented algorithms complete service interface analysis on a service within ten seconds.
 Objects. Thirteen popular services (shown in Table 1 ) drawn from xmeth-ods.net 3 , Amazon.com, and FedEx were chosen as the experiment objects. These experiment samples were from three categories: Internet Services (IS), i.e., ser-vices from the Internet, Software-as-a-Service (SaaS), and Enterprise Services (ES) and the complexity of services increases from IS to ES. Services in the IS category are highlighted in light grey (i.e, the first three services); Services in the SaaS category are darkgray (i.e., the four Amazon services); Services in the ES category are in dimgray (i.e., the six FedEx services).
 Validation Process. We applied the Service Integration Accelerator to the interfaces of the aforementioned 13 services, and a total set of 272 operations, 12962 input parameters, and 29700 output parameters were analysed. Then, we asked the domain experts to examine the analysis results, identify false positives, and do some adjustments if necessary.
 Results. Table 1 presents the detailed structural analysis results and it reports the following details: (1) the number of operations each service provides, (2) the mean number (per operation) of input parameters (IPs), output parameters (OPs), business entities (BE) derived, strong containment pairs (SCP), weak containment pairs (WCP), and association pairs (Asso Pairs), (3) The mean (per operation) of false positive rate (FPR).
 According to the results, Internet services usually do not involve business entities, because they often only have a few operations with a handful of param-eters. For example, the Weather Forecast service only has two operations  X  X etC-itiesByCountry(Country) X  and  X  X etForecastByCity(City, Country) X . Therefore, although the Service Integration Accelerator can pick up and present the Inter-net services X  parameters, which provides guidance on the structural interface of these services, Internet service consumers will not benefit significantly from the analysis results because the interface is not complex.
 As for services in the SaaS category, their interfaces present intermediate complexity. The number of operations provided in the four Amazon web services ranges from 9 to 157 and the average number of input parameters is between 4 and 24. There are around 3 business entities derived per operation. It may seem that service consumers can cope with this type of services as the number of input parameters for some operations is not very large, but the number of operations is quite significant and service users may find it difficult to know the sequential constraints among these operations. Having a proper structural analysis is essential to derive such constraints.
 a large of number of input and output parameters. Therefore, it is worthwhile to reduce complexity so that service consumers can understand the interfaces. The result shows that the Service Integration Accelerator works effectively for enter-prise services. The six FedEx services in Table 1 show how these complex services are simplified. For example, the Open Shipping service has 22 operations and the average number of input parameters is 309 and the output parameter is 575. After the structural analysis, on average, we derived 11 entities per operation, which dramatically reduce the complexity as users can more easily understand the interface by looking at these business entities and their relationships. Taking the FedEx Open Shipping service as an example, the operation - X  X reateOpen-Shipment X  has 1336 input parameters and 596 output parameters, by analysing these parameters, we derived 14 key business entities and their relationships as shown in Fig. 3 (b).
 all complex parameters as business entities, it sometimes generates entities that should not be. For example, in the generated Amazon S3 service structural anal-ysis result in Fig. 3 (a),  X  X opyObject X  and  X  X utObject X  should be combined as one entity, which is  X  X bject X , and  X  X etBucketLoggingStatus X  should not be an entity. These false positives are 12% of total entities (32) derived. Overall, the results for majority of services experimented fulfil the hypothesis, which is 25% false positive rate, plus we allow domain experts to manually revise the busi-ness entity model and to correct these false positives. These false positives can cause the Service Integration Accelerator to derive incorrect behavioural models, but they are assessed by domain experts prior to the derivation of behavioural interfaces, so invalid ones will be prevented.
 quick to complete the analysis, even the most complicated service -FedEx Open Shipping -took only 7 seconds, indicating the hypothesis about performance has been met.
 Open issues. Having examined the experiment results, we find that another two types of relationships between entities: inclusive and exclusive specialization. The former refers to subtypes of business entities, i.e., a set of attributes of a business entity be may form a new business entity be sub , which is a subtype of For example, in Fig. 3 (a),  X  X ucketAccessControlPolicy X  should be an inclusive specialization of  X  X ccessControlPolicy X . However, this relationship is currently considered weak containment. Inclusive specialization can also be derived using our Monte Carlo statistic based Service operation refining mechanism. That is to say, if a valid combination is a sub set of a business entity ( this combination may become a new business entity, which is a specialization of be . Exclusive specialization denotes different versions of a business entity. As a business entity evolves, some parameters (i.e., features) may be added or removed, but service providers usually still support the older version of interface because of compatibility. Therefore, our interface analysis should be able to cope with the analysis of different version of business entities. We will examine these two types of specializations in our future work. This paper presented a service interface synthesis framework for addressing the service interoperability challenges in the context of open and diffuse setting of global business networks. Specifically, it described a few key components of the framework, detailing service interface analysis. We also validated the framework using a variety of services. The study has demonstrated that the business entity based service interface analysis technique is an effective solution to simplify ser-vices with large, overloaded operations in interfaces. Future work will complete the framework by composing different service invocations and then validate them using a Monte Carlo statistic approach. We will also extend the prototype to support service operation refactoring to derive service behavioural interfaces and validate them.
 This volume includes a collection of extended abstracts of the tutorials presented at the Conference on Advanced Information Systems Engineering (CAiSE 2015), in Stockholm, Sweden. A total of 17 proposals were considered, from researchers coming from Australia, Austria, Belgium, Canada, Israel, Romania, Spain, South Africa, Switzerland, UK, and the USA. These proposals were carefully reviewed by the tutorial chairs. After this process, 5 tutorials were accepted. We would like to thank the authors who considered CAiSE as a forum for the presentation of their highquality work. In the sequel, we elaborate on these selected tutorials. IT views of Systems  X , Steven Alter presents the main concepts and ideas of the Work Systems Theory (WST) and its applications to various issues that are relevant for Information Systems engineering.
 between Change and Non-change  X , Gil Regev raises challenges that stem from resistance to change, which accompanies the introduction of new IT systems. He indicates that in anticipation of such resistance, IS researchers and practitioners need to alleviate it for the success of the system.
 Yu show how Means-Ends diagrams, well known in Requirements Engineering, can be used for mapping practical knowledge, referred to as  X  X now-how X . Such maps can be used for visualizing existing knowledge in a domain, identifying gaps, and setting grounds for new research and for evaluating the impact of research outcomes.
 Gal provide an overview of a body of research and the state of the art in the area of process model matching. They further indicate possible generalizations of these results to conceptual models in general, in support of model reuse, similarity assessment, and variability management.
 Design Science Research (v. 2)  X  John Venable describe a practical approach for conducting design science research, with an emphasis on the evaluation phase. As the paradigm of design science is central in IS engineering, this tutorial provides valuable guidance to researchers in this area.
 April 2015 Ilia Bider
