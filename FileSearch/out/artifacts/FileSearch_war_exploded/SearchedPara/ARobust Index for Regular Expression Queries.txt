 The like regular expression predicate has been part of the SQL standard since at least 1989. However, despite its pop-ularity and wide usage, database vendors provide only lim-ited indexing support for regular expression queries which almost always require a full table scan.

In this paper we propose a rigorous and robust approach for providing indexing support for regular expression queries. Our approach consists of formulating the indexing problem as a combinatorial optimization problem. We begin with a database, abstracted as a collection of strings. From this data set we generate a query workload. The input to the op-timization problem is the database and the workload. The output is a set of multigrams (substrings) which can be used as keys to records which satisfy the query workload. The multigrams can then be integrated with the data structure (like B+ trees) to provide indexing support for the queries. We provide a deterministic and a randomized approximation algorithm (with provable guarantees) to solve the optimiza-tion problem. Extensive experiments on synthetic data sets demonstrate that our approach is accurate and efficient.
We also present a case study on PROSITE patterns -which are complex regular expression signatures for classes of proteins. Again, we are able to demonstrate the utility of our indexing approach in terms of accuracy and efficiency. Thus, perhaps for the first time, there is a robust and prac-tical indexing mechanism for an important class of database queries.
 H.2.4 [ Database Management ]: Query processing; D.2.10 [ Software ]: Methodologies Design, Performance Consider a simple database query: SELECT doc.id FROM doc where doc.text LIKE  X %har% X 
Current database systems have to carry out a full table scan to answer the above query. For large databases (like collections of documents) this can be extremely time con-suming rendering the use of regular expression queries al-most infeasible.

In the above query, the query poser may be searching for documents which contain the text share or shard or some-thing else. To speed up query processing, the database de-signer could potentially create an index where the keys are multigrams (substrings) which point to all records that con-tain that multigram themselves (the posting list of the multigram). In this instance, there are several choices that could be made. For example, the index algorithm may de-cide to select the multigram har or ha or ar or nothing at all.

To process the query, the query engine will determine if there is any of the text fragments in the regular expression query belong to the key set of the index. If so, then the index will be scanned to retrieve the posting list for that multigram. The query engine then will apply the regular expression template on each record of the posting list and select those that are matched. The query processing frame-work is shown in Figure 1.

The key challenge is in deciding what to index. For exam-ple, the advantage of indexing har over ha is efficiency: the database records which contain the text har is a subset of those which contain ha resulting in lower IO cost for queries which contain har . The disadvantage is that fewer queries are likely to use this key compared to ha . Thus the index de-signer has to (i) control the size of the index by bounding the maximum number of multigrams that can be indexed, (ii) balance the trade-off between the likelihood of a multigram being used by a query and the size of its posting list.
The paper makes four significant contributions. (1) We present a novel integer program algorithm to select the multi-grams to index. (2) Using the above algorithm, we have im-plemented a fully functional regular expression query frame-work on top of a commercial database. (3) We have carried out extensive experiments to test for the accuracy, efficiency and robustness. (4) We present a novel case study using protein data where regular expression patterns are used rou-tinely to classify families of proteins.

The rest of the paper is organized as follows. In Section 2 Fi gure 1: A generic indexed query framework con-sists of 7 steps. Whereas, if no indexes are employed, steps 2 to 5 will be skipped we report on related work. Section 3 formalizes the index se-lection problem. Section 4 presents the Linear Programming Multigram Selection (LPMS) algorithm and the related the-ory. In Section 5 we present our experiments and case study. We conclude in Section 6 with a summary and directions for future research.
Traditionally a regular expression query is processed by constructing a non-deterministic finite automata (NFA) which recognizes the language defined by the regular expression pattern [3]. The entire database needs to be processed.
More recently, a relatively different research strand has been developed to support regular expression querying. The initial work in this area was carried out by Cho and Ra-jgopalan -the authors who denote their index as FREE multigram[2].

The objective of the Free model is to select the minimal useful multigram set. A multigrams is considered useful as long as the number of data records containing the multi-grams that are smaller than a threshold (namely selectivity or support). The FREE algorithm is designed so that the set of useful multigrams selected are prefix-free .
The key insight of the FREE prefix-free algorithm is that the size multigram index is always bounded above by the database size. This is an important property that all regu-lar expression indexes should enforce. Since FREE selects low support multigrams, queries which use FREE always take less time than queries which employ a full table scan. However the disadvantage of FREE is that it does not take any query workload into account and thus many queries are unlikely to utilize the index.

To overcome the weakness of FREE , Hore et. al. in [4] proposed a multigram selection algorithm called BEST which takes both the database and query workload into con-sideration. In the BEST algorithm, each multigram is asso-ciated with a cost factor c (equivalent to the support) and at the same time associated with the query set by a benefit fac-tor, b . The main advantage of BEST is select multigrams which increase the cost factor and also the benefit factor at the same time. However, a major weakness of the BEST algorithm is that it neither scales to large datasets nor large query workloads because it uses a cartesian product of query workload and database as the search space.

Our approach is inspired by both FREE and BEST . Like the BEST algorithm we take both the database and query workload into consideration but unlike BEST we generate a representative workload from the database. The advan-tage of having both a database and workload is that we can formalize the problem in a combinatorial optimization framework . We also formalize the problem in a way which ensures that the set of multigrams selected are prefix-free. Thus we are able to bound the size of the index and guar-antee that the running time of a query using the index will be less than the full database scan.
In this section we will use the integer programming frame-work to formalize the index selection problem. To recall we are given a database, abstracted as a collection of strings, and a set of regular expression queries Q . Our objective is to select a set of multigrams which will be used as keys of an index for efficiently answering the queries Q .
The index will be used to retrieve a set of candidate records from the database which may satisfy the query. After the candidate records are selected, the actual regular expression matching is done in memory to select the exact set of records which satisfy the query.

For the purpose of indexing we will treat each query q as a set of multigrams M q . Let  X  M q be the set M q and all the substrings of length at least one which appear within each multigram in M q .
 Let G = grams. It is from G that we will select a subset G I which will form the index. For example, suppose the set Q consists of a single query q = ( ex ) . { 1 , 3 } ( ess ). Then M q and  X  M q = { ex, es, ss, ess } .

To formalize the index selection problem as an integer program (IP) we need to define (i) integer variables ( x ), (ii) the constraints ( A, b ) and (iii) the objective function ( c ) and set up the problem as follows: For each multigram g in G we associate an integer binary variable x g  X  X  0 , 1 } . The variable x g will be set to one if the multigram g is selected to be part of the index. To formalize the constraints we will construct a | Q | X | G | matrix A such that Here s ( g ) is the support or the number of rows in the database in which the multigram g appears at least once. It is through the definition of A that the integer program captures the characteristics of the underlying database. We also need to define the | Q | dimensional vector b which defines the right hand side of the system Ax  X  b . Here we define The definition of b i can be interpreted as follows. Each row of A represents a query. The row constraint captures the smallest number of database records that must be returned if the query will use the index. This is captured with multi-gram g with the smallest support contained in the expanded query  X  M q . index. The details are reported in [6]
W e now define the objective function which is typically of the form :
The objective should capture the trade-off between the coverage of a multigram and it is support in a database. By coverage we mean that one multigram can be used by several queries. On the other hand if the support of this multigram is high (relative to the size of the database) then the index is not necessarily useful as a full table scan may only be slightly less efficient.

Since we want to cast the IP as a minimization problem we want to select multigrams which have low support and at the same time we want the selected multigram to be used by as many queries as possible. Thus we define where  X  ( g  X   X  M q ) is an indicator function. Thus the numer-ator of c g is the support of the multigram g and we want multigrams with small support (making the index more ef-ficient) and at the same time we want to select multigrams with high coverage so fewer multigrams need to selected to form the index.

Theorem 1. The solution vector x returned by the in-teger program represents a set of multigrams which form a prefix-free set. We presented the proof in [6] for interested readers.

The importance of having a prefix-free index set has been noted (and proved) before by Cho and Rajgoplan [2]. Es-sentially the prefix-freeness guarantees that the size of the index is bounded by the size of the database. More formally (and in our notation):
Theorem 2. If x is the vector returned by the integer program and | R | is the size of the underlying database then
The importance of Theorem 1 and 2 cannot be under-estimated. For the first time we have a principled way of selecting a set of multigrams to index. The definition of the problem gives us prefix-freeness . As a result the constraint on the size of the index is now endogenous to the problem as opposed to providing an exogenous (budget) constraint as in the BEST method [4].
In the previous section we have presented a model for the multigram selection problem based on integer programming. We proved that the the resulting multigrams form a prefix-free set.

However theoretically the general integer program prob-lem is NP-Hard and even in practice algorithms for IP pro-grams require exponential time for most instances. This is because unlike linear programming problems where convex-ity of the problem can be exploited (local optima are global optima), for integer programming the full lattice of feasible points has to be explored.

A common approach to get around the complexity of in-teger programs is to relax them to linear programs which can then be solved efficiently (in polynomial time). The so-lution of the linear program provides a natural lower bound (for minimization problems) for the integer program. There are two approaches for carrying out the conversion. The first approach is to select a deterministic threshold and use that to round the solutions. The second approach is to in-terpret the solution vector (typically between 0 and 1) as probabilities and carry out a randomized rounding.
Theorem 3. Let s max and s min be the multigram in G with the largest and smallest non-zero support respectively. Furthermore let m  X  = max q  X  Q |  X  M q | . If x l is the solution of the relaxed linear program and we convert it to an integer solution by rounding up all elements in x l which are greater of the integer program and achieves a constant approxima-tion to the original integer program. We presented the proof in [6] for interested readers.

The above theorem simplify states that x D l = 1 if x l &gt; s as a basis for designing a deterministic rounding algorithm LPMS-D.

While LP relaxation and rounding mechanism allows us to overcome the exponential runtime complexity of integer programs, it does not guarantee that the resulting multigram set is a prefix-free. The resulting size of the index may not be bounded by the database size. In order to overcome this shortcoming, we enforce the prefix-free constraint by proposing an iterative algorithm-LPMS.

Algorithm 1 outlines the LPMS multigram prefix-free se-lection process. Firstly, the expandSet starts with an ele-ment  X . X . Secondly, each element in it is expanded by ap-p ending one element from the alphabet set,  X , which will form the childrenSet. Thirdly, all query keys contained in the query set, Q, are consolidated to generate the  X  M k,q Fourthly, any multigrams in the childrenSet that are not present in the  X  M k,q set will be removed. Fifthly, the re-fined childrenSet and set Q will be applied to the LP solver to produce the linear programming solution, x. Finally, x is relaxed by applying either LPMS-D or LPMS-R. Those multigrams with its associated x value equals to  X 1 X  will be selected as the multigram and save in set G. All unselected multigrams will then replace the current expandSet. The process will be repeated continuously until all the multi-grams are being selected.

For the rest of the paper, the solution of multigram se-lection problem obtained using the integer program will be referred as IPMS (Integer Program Multigram Selection). Similarly those obtained from deterministic and randomized rounding of the linear program will form the basis of the LPMS-D and LPMS-R algorithms respectively.
We have carried out four extensive experiments and one case study to evaluate the LPMS multigram. The experi-ment road map is shown in Table 1. For each of the four experiments we generate a different synthetic data set to vary conditions appropriate for that particular experiment. The details of the experiments are reported in [6].
The result in experiment 1, 3 and 4 showed that the recall and precision of LPMS multigram is consistently high. This allows us to conclude that LPMS multigram is highly accu-rate, efficient and robust. In experiment 2, the result showed that the LPMS build time scales nearly linearly with both database size and query workload size thus making LPMS feasible and practical.

The case study is to apply the LPMS multigram on a real data and contemporary application. Figure 2 shows the data flow of the LPMS-D multigram index Prosite-Protein application. The test data is protein sequences which are downloaded from the PFAM-A protein database [1]. Each sequence is composed of 20 distinct amino acids (alphabet) with length ranging from 4 to 2750. The query workload is the Prosite signatures [5]. Each Prosite signature defining a protein class represents a classic regular expression.
One hundred Prosite queries were tested with 100k protein sequences with and without the LPMS-D index. The recall of this test was equal to 1, which demonstrates that the LPMS-D index is 100% accurate.
 Fig ure 2: Case study: In the Full POSIX Prosite-Protein application, Step 1 to 5 and step A to E represents the LPMS-D Multigram index construc-tion and query process respectively.
While modern database management systems support forms of regular expression querying, they do not provide any in-dexing support for such queries. Thus, a regular expression query requires a full database scan to find the matching records. This is a severe limitation as the database size will continue to increase and applications for such queries (e.g., bioinformatics) proliferate.

In this paper, we have proposed a robust, scalable and efficient approach to design an index for such queries. The heart of our approach is to model the multigram selection problem as an integer program (IP) and show that the ap-proximate solutions of the IP have many of the properties we desire: accuracy robustness and efficiency. Extensive set of experiments on both synthetic and real datasets demon-strate our claimed contributions.

For future work we will replace the current linear program-ming solver by using a primal-dual approach which will make the approach handle very large query workloads. Further-more we will test our approach in other application domains including intrusion detection systems. [1] Pfam-a database. http://pfam.sanger.ac.uk , [2] J. Cho and S. Rajagopalan. A fast regular expression [3] J. E. Hopcroft, R. Motwani, and J. D. Ullman. [4] B. Hore, H. Hacigumus, and B. Lyer. Indexing text [5] C. J. A. Sigrist, L. Cerutti, N. Hulo, A. Gattiker, and [6] D. Tsang and S. Chawla. An index for regular
