 Operational transformation (OT) is a responsive and non-blocking concurrency control method widely-accepted in group editors. Correctness and performance are the basis of use-fulness and usability of OT-based group editors. However, the correctness of previous OT algorithms depends on con-ditions that are very dicult to verify. In this paper we propose a novel landmark-based transformation (LBT) ap-proach, its correctness no longer depending on those con-ditions and thus easy to prove. In addition, we give an example algorithm that signi cantly outperforms a state-of-the-art OT algorithm. This work reveals a more practical approach to developing OT algorithms.
 H.5.3 [ Information Systems ]: Group and Organization Interfaces| Synchronous Interaction,Theory and Models ; G.2 [ Mathematics of Computing ]: Discrete Mathematics Algorithms, Theory, Veri cation Concurrency Control, Data Consistency, Groupware, Group Editor, Operational Transformation
Group editing is a classic groupware topic that has been actively researched in the computer-supported cooperative work eld over the past two decades. A group editor allows a group of geographically separated human users to edit a shared document over a computer network. To hide the communication latencies and achieve fast local responsive-ness, the shared document is often replicated at cooperating sites. A group editor allows the users to work on the local replicas of the document, consistency among which is main-tained by a concurrency control algorithm.

A special concurrency control method called operational transformation (OT) [2, 13] has been well established in this context. OT allows for responsive and nonblocking interac-tion as local operations are always executed immediately once generated. Remote operations are transformed before execution to repair inconsistencies. Every OT algorithm has two parts: a set of (inclusion and exclusion) transformation functions, which address how to transform two operations, and a control procedure, which addresses how to call these functions to integrate remote operations [13].

A large number of OT algorithms have been proposed over the past 15 years, e.g., [1, 2, 9, 10, 11, 14, 15]. The correct-ness of these algorithms is generally subject to the criteria given in [11, 14], which include a condition (intention preser-vation) that is dicult to verify in practice. In addition, mainly under the in uence of [9], the inclusion transforma-tion functions in these algorithms are generally required to satisfy two properties that are also extremely dicult to verify. As a temporary resort, several approaches are pro-posed to avoid veri cation of these properties, e.g., [8, 10, 14, 15]. Nonetheless, their correctness still must verify inten-tion preservation. These problems call for a more practical approach to developing and proving OT algorithms.

In this paper, we propose a novel approach called landmark-based transformation (LBT). The approach rst formally establishes a set of sucient conditions of transformation functions and then nds a control algorithm that can ensure these sucient conditions. These conditions are based on a concept of landmark that is derived from the correctness criteria given in [6]. Consequently OT algorithms developed in this approach are easy to prove and no longer need to verify properties in [9] and the intention preservation con-dition in [11, 14]. As a by-product, the example control algorithm given in this paper signi cantly outperforms the state-of-the-art algorithm in [6]. This improvement is im-portant for cooperative work because it directly a ects the responsiveness and ultimately the usability of group editors that implement OT for concurrency control.

The rest of this paper is organized as follows. First we give a background of OT in Section 2. Then Section 3 explains the correctness criteria, Sections 4 establishes sucient con-ditions of transformation functions, and Section 5 gives a control algorithm. Section 6 shows an example of the al-gorithm. After that, Section 7 compares related work and Section 8 summarizes contributions of this paper.
As a con vention in group editors [2], we mo del the shared documen t as a string s . To distinguish di eren t states at and n is the state num ber. The sup erscript or subscript is often omitted if it is not interesting. Supp ose the rst character of any nonempt y string is indexed as zero. Also as a con vention we use the follo wing two primitiv e operations: whic h deletes the character at position p .

Apparen tly the position parameter p of any operation o is de ned relativ e to some state s . Hence we often annotate o s is called its gener ation state . If o s is to be executed in then s is called its execution state . An operation's execution state is not necessarily equiv alen t to its generation state if the operation is executed at a remote site [13].

Giv en operation o , function p( o ) returns its position value, e ect character to be inserted or deleted, id( o ) returns the id of the site that generates o , gst( o ) denotes its generation state, and est( o ) denotes its execution state. The fact that = s 0 . We use the follo wing two relations, ! and k , without further de nition as they have long been established [2]. For o , and o 1 k o 2 i o 1 is concurren t with o 2 .

The basic idea of OT is to execute any local operation as soon as it is generated but transform a remote opera-tion against concurren t operations that have been executed locally before its execution. Hence a history bu er HB is main tained at eac h site to keep trac k of all executed (local and remote) operations in their order of execution. Figure 1: OT transforms o 2 and then executes o 0 2 . As a simple example, consider the scenario in Figure 1. Supp ose two sites start from the same initial state s 0 1 Site 1 performs o 1 =ins(1,x) to insert character `x' before `b', yielding s 1 1 =\axb", while site 2 concurren tly performs o =del(1) to delete character `b', yielding s 1 2 =\a". When o 2 =del(1) arriv es at site 1, if it is executed as it is, then the wrong character `x' will be deleted. This is because o is generated in s 0 2 without the kno wledge of o 1 , but its ex-ecution state s 1 1 has been changed by the execution of o whic h invalidates its position parameter. Hence we must shift the position of o s 0 2 2 to incorporate the e ect of o that the result o s 1 1 2 can be correctly executed in state s 1 This pro cess is called inclusion transformation (IT) [14] (or forw ard transp osition [11]).

Because a character has been inserted by o s 0 1 1 on the left of its intended position, o 2 should delete the character cur-ren tly at position 2 instead of 1, i.e., o s 1 1 2 = IT( o s =\ax", whic h is iden tical to the nal state at site 2 after o and o 1 are executed in a tandem. As a result, OT seems able to achiev e con vergence and operation inten tions despite the di eren t orders of execution at di eren t sites.
Another type of transformation function in the literature is called exclusion transformation (ET) [14] (or bac kward that the result o s 1 2 is de ned and can be executed in s 1 . In the above example, we have o s 0 1 2 =ET( o s 1 1 2 ; o s
It has been generally accepted [13] that eac h OT algo-rithm consists of two parts: a set of transformation functions (suc h as IT and ET) that determine how one operation is transformed against another, and a contr ol algorithm that determines how an operation is transformed against a given operation sequence (e.g., the history bu er).
The consistency mo del on whic h this work is based has been presen ted in [4, 6]. It is not to be claimed as a con-tribution in this pap er. For this pap er to be self-con tained, however, we will explain the main concepts and argue that our notion of operation e ects relation is a necessary con-strain t on group editors. A new concept of landmark char-acter set will be introduced, whic h will be used later.
Observ e that characters in any string can be uniquely iden ti ed by their positions. As a con vention in group ed-itors [2, 13], we assume that every character in a string is an unique object, possibly with di eren t attributes suc h as color and boldness. The ASCI I code of a character may only be one of the object's attributes. Due to this assumption, any two app earances of the same character have di eren t ids and no two insertions insert the same character. Giv en any non-empt y string s and character c is the i th elemen t in use s to denote the set of characters in s .

We rst de ne the concept of character relation as follo ws: Assume that two special invisible characters c b mark the beginning and end of any string s , resp ectiv ely. For any string s and two character c 1 ; c 2 2 s , we say c When a new character c is inserted into position p of s , the insertion establishes relation between c and the two existing characters s [ p 1] and s [ p ] suc h that s [ p 1] c s [ p ]. When a character is deleted from position p of s , it does not change the established relation .

Assuming that all sites in a group editing session start from the same initial state s 0 and the same relation de-ned on s 0 . Relation evolves as operations are executed in their generation and execution states. When an operation o is executed locally in gst( o ), we can safely assume that its execution is correct and the relation resulted from its ex-ecution re ects the inten tion of o . When o is executed at a remote site, the characters in est( o ) may not be the same as those in gst( o ), due to concurren t execution of other opera-tions. However, the execution of o must not violate the rela-tion that has been established as it was executed in gst( o ). That is, if o is an insertion, its execution must preserv e the relation on all characters that app ear in both est( o ) and gst( o ). If o is a deletion, it must delete the same character in est( o ) as in gst( o ).

In addition, the execution of o must not violate the par-tial relations that have been resp ectiv ely established when o and its concurren t operations are executed in their gener-ation states. Therefore we need a sort of \global" view that can com bine these pieces into a whole relation. To achiev e so, we must introduce two tie-breaking policies: First, when two insertions o 1 ; o 2 concurren tly insert between the same two characters c x ; c y in their generation states, i.e., c a smaller site id precedes the other. That is, if id( o 1 the resulted relation will be c x c ( o 1 ) c ( o 2 ) c y ondly , when an operation o 1 inserts a character in gst( o at the same position as a character that was deleted by o i.e., 9 c x ; c y 2 gst ( o 1 ) : c x c ( o 1 ) c y and c we enforce that the inserted character precedes the deleted character in relation . That is, c x c ( o 1 ) c ( o 2 ) c
Due to these two policies, when any operation o is to be executed in est( o ), all relations that have been established by o in gst( o ) and operations executed so far at this site can be merged as a total order. More generally , if we use C t to denote the set of characters that ever app ear in a group editing session, relation de ned over this set is a total order. We state this total order in the follo wing lemma with its pro of omitted.

Lemma 1. Relation is a total order over C t , i.e., 8 c 1 C t : either c 1 c 2 or c 2 c 1 .

The operation e ects relation can be considered a sub-set of the above explained character relation, with the part involving characters in the initial state remo ved. Hence we use the same notation for operation e ects relation. Note there are two cases in whic h the e ect characters of two given operations o 1 ; o 2 are equiv alen t or c( o 1 ) c( o 2 ): o concurren tly delete the same character, and o 1 deletes the same character inserted by o 2 .

Definition. 1. A group editor is correct if it always main-tains the following two properties: 1. Causalit y preserv ation: For any two operations o 1 and 2. Op eration e ects relation preserv ation: The execution
It is sho wn in [4, 6] that preserv ation of operation e ects relation implies con vergence. Hence the above-de ned cor-rectness criteria no longer include con vergence as do previ-ous criteria [2, 9, 11, 14]. In previous work, causalit y preser-vation, con vergence, and inten tion preserv ation are prop osed as correctness criteria of group editors, including [11, 13, 14, 15]. However, due to the under-formalization of the inten-tion preserv ation condition, no previous OT algorithms have been pro ved to preserv e inten tions to our kno wledge. Coun-terexamples given in [4, 6] have sho wn that no previous OT algorithms addressed the the operation e ects relation vi-olation (ER V) problem, including SOCT2 [11], GOT [14], GOTO [13], SOCT3/4 [15], and IMOR [3], and that this problem does not dep end on the tie-breaking policies.
It is worth noting that relation is not an arti cial con-strain t that group editors do not have to satisfy . The rela-tion is mostly determined as operations are generated and executed in their generation states. The only \arti cial" part is the two policies that are used to break ties, as ex-plained above. Policies as suc h are widely used in distributed computing systems and OT algorithms, including dOPT [2], SOCT2/3/4 [11, 15], and GOT/GOTO [13, 14]. Compared to the inten tion preserv ation condition in previous work, our notion of operation e ects relation preserv ation is easier to formalize and verify . Hence it is a more plausible correctness condition for group editors and OT algorithms.

To determine the relation between any two given char-acters, if we kno w whether or not there exists at least one character between them, the problem becomes easier.
Definition. 2. [Landmark Character] For any three tween c 1 and c 2 , i either c 1 c 3 c 2 or c 2 c 3 c 1 .
We denote the set of landmark characters between c 1 and c as C ld ( c 1 ; c 2 ) = f c 3 2 C t j c 1 c 3 c 2 _ c 2 c It is abbreviated as C ld when there is no confusion in the con text. Since it is the existence of C ld that matters, we do not really need to compute C ld .
In this section, we de ne the IT/ET functions based on relation and discuss their sucien t conditions under whic h relation can be correctly determined by only using the basic operation parameters p( o ), id( o ), and t( o ). We assume there is a hash table ER at eac h site whic h is used to save the locally deriv ed e ects relation.
The purp ose of o s 0 1 = IT( o s 1 , o s 2 ), where s = est( o state s 0 . As de ned in Algorithm 1, we rst call Algorithm 2 (get it er) to determine the e ect relation of o 1 and o 2 then use this relation to decide how to compute o s 0 1 . 1: get it er( o 1 ; o 2 ) 2: if c ( o 1 ) c ( o 2 ) then 3: return o 0 1 4: else 6: if c ( o 2 ) c ( o 1 ) then 7: if t( o 2 ) = ins then 8: p( o 0 1 ) p( o 1 )+1 9: else f t( o 2 )=del g 10: p( o 0 1 ) p( o 1 )-1 11: end if 12: end if 13: return o 0 1 14: end if
Assuming that every insertion introduces a new charac-ter, it is imp ossible that o 1 has the same e ect character as another operation o 2 . However, two concurren t deletions may intend to delete the same existing character. To han-dle this situation, we adopt a policy in whic h this character is only deleted once. The deletion receiv ed later is trans-formed into a null operation , whic h will not be executed. This corresp onds to lines 1-2 in Algorithm 1 and lines 8-9 in Algorithm 2.
 c( o 1 ) and the execution of o 2 does not a ect o 1 . Hence o inserted a character on the left of c( o 1 ), the position of o should be increased by one; or if o 2 deleted a character on the left, the position of o 1 should be decreased by one. Algorithm 2 get it er( o 1 ; o 2 ): relation of c( o 1 ) and c( o 1: return the relation if it is found in ER 2: er c( o 2 ) c( o 1 ) 3: if p( o 1 ) &lt; p( o 2 ) then 4: er c( o 1 ) c( o 2 ) 5: else if p( o 1 )=p( o 2 ) then 6: if t( o 1 )=t( o 2 )=ins ^ id( o 1 ) &lt; id( o 2 ) then 7: er c( o 1 ) c( o 2 ) 8: else if t( o 1 )=t( o 2 )=del then 9: er c( o 1 ) c( o 2 ) 10: else if t( o 1 )=ins ^ t( o 2 )=del then 11: er c( o 1 ) c( o 2 ) 12: end if 13: end if 14: record er in ER 15: return er
It is required that the two operations in IT be de ned rel-it does not mak e sense to compare their position parame-ters [13, 14]. However, condition est( o 1 )=est( o 2 ) alone is not sucien t for correctly determining the relation between c( o 1 ) and c( o 2 ) in IT. There are well-kno wn scenarios in whic h this condition is satis ed but the relation cannot be correctly determined by only using position parameters [6, 11, 14]. We de ne a set of rules in Algorithm 2 for determin-ing the e ect relation between any two given operations. In the follo wing lemmas, we study the sucien t conditions of get it er by cases and then dra w conclusions in Corollary 1 The preconditions of IT are exactly the same.

Lemma 2. get it er( o 1 ; o 2 ) is correct if (1) t( o 1 ) = t( o = ins, (2) s = est ( o 1 ) = est ( o 2 ) , (3) C ld (c( o
Pro of: Condition C ld (c( o 1 ), c( o 2 )) s means that the landmark characters between c( o 1 ) and c( o 2 ), if any, must one character c 2 C ld between p( o 1 ) and p( o 2 ) in s . By de nition 2, we have either c( o 1 ) c c( o 2 ) or c( o 2 c( o 1 ). Without loss of generalit y, supp ose c( o 1 ) c c( o 2 ). By transitivit y we have c( o 1 ) c( o 2 ). Since c( o and c are already in s and c( o 1 ) is to be inserted before c , we have p( o 1 ) s [c] &lt; p( o 2 ), whic h implies p( o In get it er, if p( o 1 ) &lt; p( o 2 ), we get c( o 1 ) c( o
If j C ld j = 0, by De nition 2, there is no landmark charac-ter between c( o 1 ) and c( o 2 ) whatso ever. Hence p( o in state s . In this case, we break the tie by comparing their Then we have c( o 1 ) c( o 2 ) by de nition of relation . In get it er, we get the same result. 2
Lemma 3. get it er( o 1 ; o 2 ) is correct if (1) t( o 1 ) = t( o = del and (2) s = est ( o 1 ) = est ( o 2 ) .

Pro of: Since o 1 and o 2 are to delete characters c( o 1 tion between s [ c ( o 1 )] and s [ c ( o 2 )], or p( o 1 correctly determine the relation between c( o 1 ) and c( o Therefore, if p( o 1 ) &lt; p( o 2 ), we have c( o 1 ) c( o &gt; p( o 2 ), we have c( o 2 ) c( o 1 ); and if p( o 1 ) = p( o have c( o 1 ) c( o 2 ). In get it er, we get the same results. 2
Lemma 4. get it er( o 1 ; o 2 ) is correct if (1) t( o 1 )=ins ^ t( o 2 )=del and (2) s = est ( o 1 ) = est ( o 2 ) . The case of t( o ^ t( o 2 )=ins is symmetric.

Pro of: Similar to that of Lemma 3. The condition of t( o 1 )=ins ^ t( o 2 )=del means that o 1 is to insert a new char-acter c( o 1 ) into s and o 2 is to delete an existing character c( o 2 ) in s . Hence the relation of p( o 1 ) and s [ c ( o determines the relation between c( o 1 ) and c( o 2 ). 2
Cor ollar y 1. The sucient condition of IT( o s 1 ; o s 2 gener ally s = est( o 1 ) = est( o 2 ). However, if t( o 1 and p( o 1 )=p( o 2 ), it additional ly requir es C ld ( c ( o s , meaning that the landmark char acters betwe en c( o 1 c( o 2 ), if any, must be present in s .
The purp ose of ET( o s 2 2 ; o s 1 1 ), where s 1 = est ( o in s 1 , as if o s 1 1 had not been executed earlier. As in Algo-rithm 3, we rst call Algorithm 4 (get et er) to determine relation to compute o s 1 2 .
 Algorithm 3 ET( o s 2 2 , o s 1 1 ): o s 1 2 1: get et er( o 1 ; o 2 ) 2: if c ( o 2 ) c ( o 1 ) then 3: raise exception 4: else 6: if c ( o 1 ) c ( o 2 ) then 7: if t( o 1 ) = ins then 8: p( o 0 2 ) p( o 2 )-1 9: else f t( o 1 )=del g 10: p( o 0 2 ) p( o 2 )+1 11: end if 12: end if 13: return o 0 2 14: end if
If c( o 1 ) and c( o 2 ) are the same, meaning that o 2 is to delete the character inserted by o 1 , or o 1 ! o 2 and c( o it does not mak e sense to pretend that o 1 had not been ex-ecuted before o 2 due to causalit y. In this case we raise an exception. This corresp onds to lines 13-14 in Algorithm 4 and lines 2-3 in Algorithm 3.

If c( o 2 ) c( o 1 ), meaning that c( o 1 ) is on the righ t side of c( o 2 ), then excluding the e ect of o 1 does not have any impact on o 2 . Hence o 2 is returned as it is. If c( o 1 however, the position parameter of o 2 should be decreased by one had o 1 not inserted c( o 1 ) on its left; or the posi-tion parameter of o 2 should be increased by one had o 1 not deleted c( o 1 ) on its left.
 Algorithm 4 get et er( o 1 ; o 2 ): relation of c( o 1 ) and c( o 1: return the relation if it is found in ER 2: if p( o 1 ) &lt; p( o 2 ) then 3: er c( o 1 ) c( o 2 ) 4: else if p( o 1 ) &gt; p( o 2 ) then 5: er c( o 2 ) c( o 1 ) 6: else f p( o 1 )=p( o 2 ) g 7: if t( o 1 )=t( o 2 )=ins then 8: er c( o 2 ) c( o 1 ) 9: else if t( o 1 )=t( o 2 )=del then 10: er c( o 1 ) c( o 2 ) 11: else if t( o 1 )=del ^ t( o 2 )=ins then 12: er c( o 2 ) c( o 1 ) 13: else f t( o 1 )=ins ^ t( o 2 )=del g 14: er c( o 1 ) c( o 2 ) 15: end if 16: end if 17: record er in ER 18: return er
In Algorithm 4, we de ne rules for determining the rela-ters. Previous work [13, 14] prop osed that the precondition not sucien t for determining the relation of c( o 1 ) and c( o in ET. There are coun terexamples that sho w the relation can not be correctly determined even though this condition is satis ed [6]. In the follo wing lemmas we examine the suf-cien t conditions of get et er by cases and then based on these cases we dra w conclusions in Corollary 2. The suf-cien t conditions of ET are exactly the same as those of get et er. Hence the same conclusions hold.

Lemma 5. get et er( o 1 ; o 2 ) is correct if (1) o 1 k o (2) s 2 = exec( s 1 ; o 1 ).

Pro of: If o 1 k o 2 , then o 2 must have included the e ect Then relation between c( o 1 ) and c( o 2 ) has been correctly determined in get it er or IT. If relation is recorded and retriev ed, get et er can be correctly pro cessed. 2
Lemma 6. get et er( o 1 ; o 2 ) is correct if (1) t( o 1 ) = t( o = ins, (2) o 1 ! o 2 , and (3) s 2 = exec( s 1 ; o 1 ).
Pro of: By the given conditions, we kno w that c( o 1 ) 2 s 2 must be true. Since two insertions cannot insert the same character, it is imp ossible to have c( o 1 ) c( o 2 ). If o serts on the righ t of c( o 1 ) in s 2 , it must be p( o and c( o 1 ) c( o 2 ). If o 2 inserts on the left of c( o or p( o 2 ) p( o 1 ) by the seman tics of insertion, it must be c( o 2 ) c( o 1 ). &gt;From get et er, we get the same results. 2
Lemma 7. get et er( o 1 ; o 2 ) is correct if (1) t( o 1 ) = t( o = del, (2) o 1 ! o 2 , and (3) s 2 = exec( s 1 ; o 1 ).
Pro of: By the given conditions, c( o 1 ) must app ear in s 1 s character as o 1 , it is imp ossible to have c( o 1 ) c( o Assume to the con trary c( o 2 ) c( o 1 ). Then s 1 [ c ( o s c ( o 1 )] = p( o 1 ) and s 2 [ c ( o 2 )] = s 1 [ c ( o 2
On the other hand, if p( o 2 ) &lt; p( o 1 ), we have c( o by get et er. Assume to the con trary c( o 1 ) c( o 2 ). Then s p( o 1 ) p( o 2 ), whic h con tradicts p( o 2 ) &lt; p( o t( o 2 )=del, (2) o 1 ! o 2 , and (3) s 2 = exec( s 1 ; o 1 ).
Pro of: Similar to that of Lemma 6. By the given condi-tions, c( o 1 ) must app ear in s 2 and p( o 1 ) = s 2 [c( o o 2 is to delete a character in s 2 , it must be that p( o 2 s 2 [c( o 2 )]. Hence by comparing p( o 1 ) and p( o 2 ) we can un-ambiguously determine the e ect relation of o 1 and o 2 . 2
Lemma 9. get et er( o 1 ; o 2 ) is correct if (1) t( o 1 ) = del ^ t( o 2 )=ins, (2) o 1 ! o 2 , (3) s 2 = exec( s 1 ; o 1 C ld ( c ( o 1 ) ; c ( o 2 )) s 2 .

Pro of: Since o 2 inserts a new character in s 2 after o 1 deletes an existing one from s 1 , it is imp ossible to have c( o 1 ) c( o 2 ). If p( o 1 )=p( o 2 ) and C ld ( c ( o kno w that c( o 1 ) 62 est( o 2 ) and there is no landmark char-acter between p( o 1 ) and p( o 2 ) in s 2 . Hence we mandate c( o 2 ) c( o 1 ) by the tie-breaking policy in the de nition of c( o 1 ) c( o 2 ) if p( o 1 ) &lt; p( o 2 ), and c( o 2 ) c( o We dra w the same conclusions from get et er(). 2
However, if (1) t( o 1 ) = del and t( o 2 )=ins, (2) o 1 ! o it has been sho wn in [6] that the rules in get et er cannot correctly determine the e ect relation of o 1 and o 2 . We call this condition the unsafe condition of ET.

Cor ollar y 2. The sucient condition of ET( o s 2 1 ; o s gener ally s 2 = est( o 2 ) = exec( s 1 ; o 1 ). However, if o mark char acters betwe en c( o 1 ) and c( o 2 ), if any, must be present in s 2 .
To integrate a remote operation o , we often have to trans-form o against a sequence of operations sq . We denote the The above-de ned preconditions of IT and ET may not al-ways hold at eac h step. This section discusses how to solv e this problem. We rst discuss ETSQ in Section 5.1 and then ITSQ in Section 5.2. The con trol pro cedure is explained in Section 5.3. Finally Section 5.4 pro ves correctness.
Tw o operations o 1 and o 2 are con textually serialized i exec(est( o 1 ), o 1 ) = est( o 2 ). A sequence of operations o ..., o n is con textually serialized i for any i , 1 i n 1, a con textually serialized sequence as a sequence.
We generalize function s 0 = exec( s; o ) to sequences: Giv en s is, executing a sequence sq in state s 0 is equiv alen t to exe-executing sq [1] in s 1 = exec( s 1 ; sq [1]), and so forth.
Giv en two operation sequences sq 1 and sq 2 , if est( sq = exec(est( sq 1 [0]), sq 1 ), we also say that sq 1 and sq textually serialized. For the same reason, operation sq 1 1] and sequence sq 2 , sequence sq 1 and operation sq 2 [0], are also con textually serialized. Notation sq 1 + sq 2 concatenates two sequences sq 1 ; sq 2 into one sequence.
ETSQ( o; sq ) requires that sq and o be con textually seri-ETSQ( o; sq ), in principle we should exclusiv ely transform o is how to ensure the correctness of eac h step under the unsafe condition of ET. We address this problem by constructing an e ects-equiv alen t special ET-safe sequence etsos out of sq suc h that exec(est( sq [0]), sq ) exec(est( sq [0]), etsos ), and then perform ETSQ( o; etsos ) instead.

Definition. 3. A given sequenc e sq is an ET-Safe Op-eration Sequenc e (ETSOS) if for any i; j , wher e 0 i &lt;
An ETSOS sq is interesting due to the follo wing two prop-erties stated in Lemmas 10 and 11. In particular, we can infer the relation between c( o ) and e ects of all operations is kno wn, where 0 i j sq j 1.

Lemma 10. Given operation o and an ETSOS sq , if ther e then c( sq [ j ] ) c( o ) for all j : 0 j i 1 .

The above lemma actually assumes the correctness of ET( o , der whic h conditions this can be assumed. We introduce notation C sq to denote the set of characters that app ear in
Lemma 11. Given operation o and sequenc e sq , wher e C sq for all sq [ i ] ! o .

Pro of: We only need to pro ve the correctness of ET( o , sq [ i ]) for any sq [ i ] under the unsafe conditions. That is, pro ve this by induction.
 Basis case: consider ET( o , sq [ n 1]). By de nition of ET SOS , we kno w c ( sq [ k ]) c( sq [ n 1]) for 0 k &lt; n 1. c( sq [ n 1]) c c ( o ) for otherwise we would have got by the de nition of relation , whether or not 9 c : c ( o ) 1]) is correct.

Induction: Assume that pro cessing of ETSQ( o , sq [ i + 1 ; n 1]) is correct. Let o 0 be the execution form of o rel-means that c ( o ) c ( sq [ k ]) where i + 1 k n 1. Because C tradicts p( sq [ i ])=p( o ). Then by the de nition of relation , Hence ET( o; sq [ i ]) is correct. 2 Algorithm 5 ETSQ( o , sq ): o 0 1: o 0 o 2: for i = j sq j -1 to 0 step -1 do 3: o 0 ET( o 0 , sq [ i ]) 4: if c( sq [ i ] c( o 0 ) then 5: break 6: end if 7: end for 8: for j = i -1 to 0 step -1 do 9: if t( sq [ j ]) = ins then 10: p( o 0 ) = p( o 0 )-1 11: else 12: p( o 0 ) = p( o 0 )+1 13: end if 14: end for 15: return o 0 Based on Lemmas 10 and 11, we de ne ETSQ( o; sq ) in Algorithm 5. The precondition is given in Lemma 11. The function exclusiv ely transforms o with operations in sq from sq [ n 1] to sq [0]. When the condition de ned in Lemma 10 is satis ed, we break the loop of lines 2-7 because it is no longer necessary to call ET() on the remaining operations in sq . Instead, e ects of those operations are excluded directly as in lines 8-14.
The basic idea of ensuring the correctness of ITSQ is simi-lar to that of ETSQ. We rebuild a special operation sequence itsos from a given sequence sq suc h that ITSQ( o; itsos ) achiev es the same e ects as ITSQ( o; sq ).
 Definition. 4. A sequenc e sq is an IT-Safe Operation if t( sq [ i ] )=ins and t( sq [ j ] )=del, then i &lt; j holds.
An ITSOS sq can be rewritten as sq i + sq d , where sq i includes all insertions in sq and sq d all deletions in sq .
Lemma 12. Given operation o and sequenc e sq , ITSQ( o , sq ) (2) t( o )=ins ^ sq is an ITSOS ^ for any insertion sq [ i ] : C ld ( c ( sq [ i ] ; c ( o ))) est( sq [ i ] ).

Pro of: In case t( o ) = del, by Corollary 1, ITSQ( o , sq [ i ]) is correct for any operation sq [ i ]. Consider case t( o )=ins. Because sq is an ITSOS, any insertion is pro cessed before any deletion. That is, inclusiv ely transforming o against any insertion does not lose (delete) any landmark charac-IT( o; sq [ j ]) is correct for any deletion sq [ j ]. 2 Based on the precondition given in Lemma 12, we de ne ITSQ( o; sq ) in Algorithm 6, whic h is self-explained.
The top-lev el con trol algorithm executes local and remote operations. An operation log (or history bu er HB ) is main-tained at eac h site. For best resp onsiv eness, any local oper-ation is executed and app ended to HB once it is generated. Algorithm 6 ITSQ( o , sq ): o 0 1: o 0 o ; 2: for i = 0 to j sq j -1 do 3: o 0 IT( o 0 , sq [ i ]) 4: if o 0 = then 5: break 6: end if 7: end for 8: return o 0 Every remote operation o is queued until it is causally-ready , i.e., all operations that happ ened before o are in HB . Sup-pose the initial state is s 0 and the curren t state s n , where n = j HB j . Then function Integrate( o; HB ) is called to de-rive its execution form o 0 relativ e to s n . If o 0 = , it is discarded. Otherwise o 0 is executed and app ended to HB . Apparen tly HB is a con textually serialized sequence. Algorithm 7 Integrate( o , HB ): o 0 1: &lt; sq h , sq c &gt; Transp osePrecCon( o , HB ) 2: if sq c = [] then 3: return o 0 o 4: end if 5: if t( o )=del then 6: return o 0 ITSQ( o; sq c ) 7: else f t( o )=ins g 8: sq 0 h BuildETSOS( sq h ) 9: &lt; sq hi , sq hd &gt; Transp oseInsDel( sq 0 h ) 10: o 0 ETSQ( o , sq hd ) 11: sq BuildETSOS( sq hd + sq c ) 12: &lt; sq i ; sq d &gt; Transp oseInsDel( sq ) 13: return o 0 ITSQ( o 0 , sq i + sq d ) 14: end if
In Integrate( o; HB ), we rst call Transp osePrecCon( o; HB ) to transp ose HB into two sequences: sq h , whic h includes all operations that happ ened before o , and sq c , whic h includes all operations that are concurren t with o . Due to causalit y preserv ation, we have gst( o ) = exec( s 0 ; sq h ).
If sq c is empt y, it means s n = gst( o ). Then o is returned as it is (lines 2-3) and will be executed in s n directly . If sq con tains concurren t operations, we must incorp orate the ef-fects of those operations into o to get its execution form o s . By the above analysis, we cannot perform ITSQ( o; sq c ) until the preconditions de ned in Lemma 12 are satis ed. If 6). However, if t( o )=ins, we must construct some ITSOS sq Then IT( o; sq 0 [ i ]) is alw ays correct and the problem can be translated to ITSQ( o; sq 0 ). This is achiev ed as follo ws.
We rst call function Transp oseInsDel( sq h ) to transp ose sequence sq h into two subsequences, sq hi , whic h con tains all insertions, and sq hd , whic h con tains all deletions, and sq hi and sq hd are con textually serialized. After that, we call ETSQ( o; sq hd ) to exclude the e ects of sq hd from o . Now o is de ned in state s m = exec( s 0 ; sq hi ), where m = j sq that, we call Transp oseInsDel( sq ) to get sq 0 = sq i + sq Op eration sq i [0] is also de ned in state s m . Since sq con tains insertions, all the landmark characters between c( o ) and any sq i [ k ] must be included in state s m . Therefore ITSQ( o; sq 0 ) can be correctly pro cessed.
 Algorithm 8 Transp osePrecCon( o , sq ): &lt; sq h ; sq c 1: sq h []; sq c [] 2: for i =0 to j sq 0 j -1 do 3: if sq [ i ] k o then 4: sq c sq c + sq [ i ] 5: else 6: &lt; o i ; sq c &gt; Transp oseOSq( sq c , sq [ i ]) 7: sq h sq h + o i 8: end if 9: end for 10: return &lt; sq h ; sq c &gt; Algorithm 9 Transp oseInsDel( sq ): &lt; sq i ; sq d &gt; 1: sq i []; sq d [] 2: for i =0 to j sq j -1 do 3: if t(sq[i]) = del then 4: sq d sq d +sq[i] 5: else 6: &lt; o i ; sq d &gt; Transp oseOSq( sq d , sq [ i ]) 7: sq i sq i + o i 8: end if 9: end for 10: return &lt; sq i ; sq d &gt;
The four transp osition functions 8, 9, 10, 11 are straigh t-forw ard. Function Transp osePrecCon() is adopted from [11, 13]. It transp oses sq into two subsequences sq h and sq c that sq h , all operations that happ ened before o , are con tex-o . Lemma 13 will sho w that IT/ET in Transp osePrecCon() only happ en between concurren t operations.

Transp oseInsDel( sq ) transp oses sq suc h that all insertions are con textually serialized before all deletions. The pre-condition of Transp oseOSq( sq; o ) is that sq is con textually serialized before o . The output is suc h that o 0 is con tex-pose two con textually serialized operations o 2 and o 1 suc h that in the output o 0 1 is con textually serialized before o Since o 2 is con textually serialized before o 1 , we rst do o =ET( o 1 ; o 2 ) suc h that o 0 1 and o 2 are de ned in the same state, and then do o 0 2 =IT( o 2 ; o 0 1 ) suc h that o in state exec(est( o 0 1 ), o 0 1 ). Note if o 1 dep ends on o t( o 2 )=ins, t( o 1 )=del, o 2 ! o 1 , and p( o 1 )=p( o 2 ), then we does not app ear in Transp osePreCon and Transp oseInsDel but may app ear in BuildETSOS.
 Function BuildETSOS( sq ) incremen tally builds an ET-SOS sq 0 . Initially sq 0 only includes sq [0]. Then eac h time a exactly the stop condition de ned in Lemma 10. Under this case, o is inserted after sq 0 [ j ] (line 14). Then the relation between c( o ) and other operations in the rest of sq is kno wn and recorded (line 10). If the stop condition nev er app ears, as in lines 19-20, then o is added to the head of sq 0 .
Note the use of function BuildETSOS() in lines 8 and 11 of Integrate(). BuildETSOS( sq h ) in line 8 is to ensure the correct pro cessing of lines 9-10. It can be sho wn that sq h satis es the precondition required in Lemma 11 and hence BuildETSOS( sq h ) is correct. It can also be sho wn Algorithm 10 Transp oseOSq( sq; o ): &lt; o 0 ; sq 0 &gt; 1: o 0 o ; sq 0 sq 2: for i = j sq j -1 to 0 step -1 do 3: &lt; o 0 ; sq 0 [ i ] &gt; Transp ose( sq 0 [ i ] ; o 0 4: end for 5: return &lt; o 0 ; sq 0 &gt; Algorithm 11 Transp ose( o 2 , o 1 ): &lt; o 0 1 ; o 0 2 &gt; 1: if c( o 1 ) c( o 2 ) then f determined as in get et er g 2: return &lt; o 1 ; o 2 &gt; 3: else 4: o 0 1 ET( o 1 , o 2 ) 5: o 0 2 IT( o 2 , o 0 1 ) 6: return &lt; o 0 1 ; o 0 2 &gt; 7: end if that IT/ET in line 9 is correct and that the conditions of Lemma 11 are satis ed in line 10. Similarly , BuildETSOS in line 11 ensures the correctness of line 12. Lemma 13. Transp osePr ecCon() is correct.

Pro of: Due to de nition of this function, whenev er two must have been inclusiv ely transformed with sq [ i ] before and their relation is already kno wn. Therefore Transp ose() can alw ays be correctly pro cessed. It is easy to see that the two resulted sequences sq h and sq c are also causalit y-preserving since they keep the same order of operations as in sq . 2 Lemma 14. BuildETSOS() is correct.

Pro of: The pro cess of building an ETSOS sq 0 from in-put sequence sq resem bles that of insertion sort. Eac h time we add a new operation sq [ i + 1] into the partial result sq that was built from sq [0 ; i ]. Sequence sq 0 is scanned from Note that eac h operation in sequence sq 0 actually represen ts a state transition. Hence, to insert sq [ i + 1] before some position sq 0 [ j ], we have to transp ose sq [ i + 1] and sq by calling function Transp ose(); That is, the correctness of BuildETSOS() dep ends on the correctness of Transp ose().
In Transp ose( o 1 ; o 2 ), ET is called before IT. If ET( o is correct, then the relation of c( o 1 ) and c( o 2 ) is kno wn, whic h ensures the correctness of IT. Hence to pro ve the cor-rectness of BuildETSOS(), we only need to pro ve the cor-reduced to pro ving that the conditions of Lemma 11 can be satis ed before calling BuildETSOS() in lines 8 and 11 in Integrate(). The pro ofs of these two cases are similar. For space reasons we only pro ve the case of line 8. In this case, the input sequence is sq h , whic h is causalit y-preserving due to the pro of of Lemma 13. We pro ve the correctness of sq = BuildETSOS( sq h ) by induction.
 sq h [0]) is correct by Lemma 5. Otherwise, it must be sq h [0] ! sq h [1]. Because gst( sq h [0]) s 0 and there is no other op-eration, we have C ld ( c ( sq h [0]) ; c ( sq h [1]) est( sq ET( sq h [1], sq h [0]) is correct.
 Algorithm 12 BuildETSOS( sq ): sq 0 1: if j sq j &lt; 1 then 2: return sq 0 sq 3: end if 4: sq 0 [ sq [0] ] 5: for i =1 to j sq j -1 do 6: o sq [ i ] 7: f lag false 8: for j = j sq 0 j -1 to 0 step -1 do 9: if f lag = true then 10: store c( sq 0 [ j ]) c( o ) 11: else 12: &lt; o; sq 0 [ j ] &gt; Transp ose( sq 0 [ j ] ; o ) 13: if c( sq 0 [ j ]) c( o ) or c( sq 0 [ j ]) c( o ) then 14: sq 0 sq 0 [0 ; j ] + o + sq 0 [ j + 1 ; j sq 0 j 1] 15: f lag true 16: end if 17: end if 18: end for 19: if f lag = false then 20: sq 0 o + sq 0 21: end if 22: end for 23: return sq 0
Induction: Supp ose sq 0 h is the ETSOS correctly built from sq h [0 ; i ]. Now we examine how sq h [ i + 1] is added into sq and all operations that happ ened before sq h [ i + 1] are in sq h , it is obvious that C ld ( c ( sq h [ i + 1]) ; c ( sq ETSQ( sq h [ i + 1] ; sq 0 h ) is correct. 2 .
 Lemma 15. Transp oseInsDel() is correct.

Pro of: Function Transp oseInsDel() is called twice in Func-the input sequence of Transp oseInsDel() goes through func-tion BuildETSOS() suc h that relation between any two operations in the input sequence is kno wn. Hence IT/ET in Transp oseInsDel() is alw ays correct, whic h ensures the correctness of Transp oseInsDel(). 2 Lemma 16. Inte grate() is correct.

Pro of: Due to Lemma 13, Transp osePrecCon( o; HB ) cor-rectly transp oses HB into sq h and sq c . Sequence sq h tains all the operations that happ ened before o and preserv es their happ ened-b efore relation. Due to causalit y preserv a-tion, gst( o ) = exec( s 0 ; sq h ) = est( sq c [0]).
We would have directly performed o 0 = ITSQ( o; sq c ) to sq h con tains deletions suc h that est( sq c [0]) does not con tain C ld ( c ( o ) ; c ( sq c [0]) and the correctness of IT( o , sq be guaran teed. To solv e this problem, we rst transp ose sq happ ened before o and sq hd includes all deletions that hap-pened before o . Due to Lemmas 14 and 15, this step is cor-rect. It is easy to see from the pro cess of Transp oseInsDel() that sq hd is an ETSOS. In addition, let C sq hd = est( sq possible landmark characters between o and sq hd [ i ], if any, are introduced by sq hi , we conclude that sequence sq hd isfy the preconditions of Lemma 11. Hence pro cessing o 0 = ETSQ( o , sq hd ) correctly transforms o into o 0 , whic h is de ned relativ e to state s 0 = est( sq hd [0]) = exec( s 0 ; sq
Next we transp ose sequence sq = sq hd + sq c into sq 0 = sq i + sq d suc h that sq i includes all the insertions and sq includes all the deletions in sq . Due to Lemmas 15, this step is correct and sq 0 is an ITSOS. Because sq hi + sq i not con tain any deletions, the preconditions of Lemma 12 are satis ed and hence o 00 = ITSQ( o 0 ; sq 0 ) is correct. 2 Figure 2: An example: four sites start from state \1" and con verge in \acb".
 Figure 2 sho ws a group editing session with four sites. Assume that the initial state is s 0 = \1". Site 1 performs an operation o 1 = ins(\b", 1). Concurren tly, site 2 performs o =del(0), and site 4 performs o 3 =ins(\a",0). After o 3 is executed, site 3 performs o 4 =ins(\c",1). We have o 1 k o o k o 3 , o 1 k o 3 , o 3 ! o 4 , o 1 k o 4 , and o 2 k o 4 we only consider how these operations are executed at site 1 and site 3, assuming that the execution order at site 1 is o , o 3 , o 4 , o 2 , and the order at site 4 is o 3 , o 2 , o
Site 1: Let s 1 1 = exec( s 0 , o 1 ) = \1b". Due to o 3 k o we have o s 1 1 3 = IT( o 3 , o 1 )= ins(\a",0). Executing o s to the con trol algorithm, we transp ose it into sq h = [ o IT( o 1 , o 3 )=ins(\b",2). Inclusiv ely transforming o 4 sq c results in o s when o 2 arriv es, the history bu er is HB = [ o 1 , o s 1 Since all these operations are concurren t with o 2 , we get o = ITSQ( o 2 , HB ) = del(2) and s 4 1 = exec( s 3 1 ; o s
Site 4: s 1 4 = exec( s 0 , o 3 )=\a1". When o 2 arriv es, we compute o s 1 4 2 = IT( o 2 , o 3 ) = del(1). After executing o we get state s 2 4 = \a". When o 4 arriv es, o s 2 4 4 = IT( o = ins(\c",1), the execution of whic h results in s 3 4 = \ac". Finally , o 1 arriv es, the history bu er of site 4 is HB = [ o o 2 , o we rst call function BuildETSOS() to con vert HB into an del(2). Then we call function Transp oseInsDel() to con vert sq into sq i = [ o 3 , o 0 4 ] and sq d = [ o 0 2 ]. Let sq We have o s 3 4 1 = ITSQ( o 1 , sq 0 = ins(\b", 2). Hence s 4
Similarly it can be sho wn that all the four sites con verge in the same nal state s 4 = \acb". We can verify the correct-ness of s 4 by de nitions in Section 3. Since o 1 is generated in state s 0 , we infer `1' `b' by de nition. Similarly we can infer `a' `1' from the generation of o 3 , and `a' `c' `1' from the generation of o 4 . Globally we infer the total order `a' `c' `1' `b'. Since o 2 is intended to delete character `1' at site 2, the correct result must be \acb", whic h is s 4 .
Previous work [11, 14] has established that an OT algo-vation, con vergence, and inten tion preserv ation. The inten-tion preserv ation condition is the rst attempt in the lit-erature to constrain con vergence in interactiv e group ware applications. Due to its intuitiv eness, this mo del has been well-accepted in group editors, suc h as [10, 11, 13, 14, 15]. However, the inten tion preserv ation condition is not well-formalized and dicult to verify in practice. Even in its original de nition [14], there is a well-kno wn scenario iden-ti ed as being inten tion-preserving but it is actually not [6].
Ressel et al [9] pro ves that any OT-based algorithm can achiev e con vergence in presence of arbitrary transformation paths if its IT function can satisfy two transformation prop-erties that are called TP1 and TP2. However, these two prop erties are only for IT, because they were established before the concept of ET was prop osed [11, 14].

TP1/TP2 are required in previous OT algorithms adOPT ed [9], SOCT2 [11], and GOTO [13] but have nev er been ver-i ed. SDT [6] is the rst that has been formally pro ved to satisfy TP2. However, the pro of as presen ted in [4] only considers two primitiv e characterwise insert and delete op-erations. Due to the huge num ber of cases to consider, the pro of scales poorly to a more sophisticated operation set.
Due to the widely-recognized diculties in verifying TP2, a num ber of previous OT algorithms attempted to free TP2, suc h as GOT [14], SOCT3/4 [15], NICE [10], and TIBOT [8]. However, coun terexamples sho w that, although they can achiev e con vergence, these algorithms fail to preserv e the operation e ects relation [4, 6].

It is prop osed that IT( o s 1 ; o s 2 ) must ensure s = est( o verify inten tion preserv ation [13, 14]. However, coun terex-amples sho w that these two conditions are not really su-cien t [6]. Corollaries 1 and 2 in this pap er establish sucien t conditions for IT and ET that are based on the notion of operation e ects relation instead of inten tion preserv ation.
LBT impro ves SDT [6] in the follo wing two ways. In Sec-tion 5, the execution time of function Integrate() is domi-nated by functions Transp osePrecCon(), BuildETSOS(), and Transp oseInsDel(), eac h taking time quadratic to the size of the input sequence in the worst case. Hence the worst-case time complexit y of LBT is O ( n 2 ), where n is the num ber of the history bu er (op eration log). This outp erforms SDT, the worst-case time complexit y of whic h is O ( n 3 ).
To be more concrete, Figure 3 sho ws the results of some simple exp erimen ts we did to compare the worst-case perfor-mance of SDT and LBT. The algorithms were implemen ted in C++, compiled by GNU g++ v3.3.2, and executed on a computer running RedHat Lin ux kernel 2.4.22 with an Intel Figure 3: Comparing the worst-case performance of LBT and SDT to integrate a remote operation.
 Pentium-4 2.6 GHz CPU and 2 GB RAM. Figure 3 sho ws the time to integrate a remote operation o into a log of n operations, n = M + N , in whic h M operations are con-curren t with o and N operations happ ened before o . The performance adv antage of LBT over SDT is obvious.
The exp erimen tal results in Figure 3 also rev eal that the execution time of Integrate() dep ends on the size of and the kind of operations in HB . In [5], we sho w the performance of Integrate() a ects resp onsiv eness and awareness unless a relativ ely small HB is main tained in the group editor (as in [14, 16]). Hence this performance impro vemen t is relev ant.
More imp ortan tly, the approac h of LBT is much simpli ed over that of SDT. It formally establishes the sucien t condi-tions of IT/ET functions. Then the con trol algorithm trans-poses the operation log suc h that these preconditions can be satis ed. The correctness pro of is thus reduced to only that the preconditions are satis ed. Hence the approac h of LBT scales well to a larger primitiv e operation set.
This pap er prop oses a novel approac h called LBT for concurrency con trol in group editors. It formally estab-lishes new sucien t conditions of transformation functions (IT/ET), whic h x the conditions established in [14, 13]. Based on these new conditions, LBT only needs to nd a con trol algorithm (and a particular transformation path) that ensures the correctness of IT/ET. This avoids the costs of dev eloping OT algorithms that must verify dicult trans-formation prop erties [9] and inten tion preserv ation [11, 14] as in previous work. Therefore LBT exempli es a more prac-tical approac h to dev eloping OT algorithms. In addition, the con trol algorithm presen ted in this pap er outp erforms the state-of-the-art SDT algorithm [4, 6] in the worst case and hence pro vides a better guaran tee for local resp onsiv e-ness. In future researc h, we plan to extend this work to treat stringwise operations (as in [14]) and structured data (as in [1]). For space reasons, the consistency mo del and correctness pro ofs are more rigorously presen ted in [7]. [1] Aguido Horatio Davis, Chengzheng Sun, and Jun wei [2] Clarence A. Ellis and S. J. Gibbs. Concurrency con trol [3] Ab dessamad Imine, Pascal Molli, Gerald Oster, and [4] Du Li and Rui Li. Ensuring consistency in real-time [5] Du Li and Rui Li. An operational transformation [6] Du Li and Rui Li. Preserving operation e ects relation [7] Rui Li and Du Li. A new operational transformation [8] Rui Li, Du Li, and Chengzheng Sun. A time interv al [9] Matthias Ressel, Doris Nitsc he-Ruhland, and Rul [10] Haifeng Shen and Chengzheng Sun. Flexible [11] Maher Suleiman, Mic h e le Cart, and Jean Ferri e . [12] Chengzheng Sun. Undo as concurren t inverse in group [13] Chengzheng Sun and Clarence Ellis. Op erational [14] Chengzheng Sun, Xiaoh ua Jia, Yanc hun Zhang, Yun [15] Nic holas Vidot, Mic helle Cart, Jean Ferrie, and Maher [16] Yun Yang, Chengzheng Sun, Yanc hun Zhang, and
