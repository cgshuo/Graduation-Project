 1.1 Background In recent years, due to the appealing fea tures of cloud computing, more and more data have been centralized into cl oud. To protect clients X  privacy, data with sensitive information are usually stored in the encrypted form. However, encrypted storage makes it hard to per form searches over the data. To cope with this problem, various techniques fo r searching over encrypted data, namely searchable encryption, have been proposed in the literature [1 X 4].

Searchable encryption schemes can be divided into two categories [14], the symmetric key searchable encryption (SSE) [3,4] and the public key searchable encryption (PSE) [1,2]. In SSE, the da ta sender and data receiver are the same entity or different entities sharing the same secret key. While in PSE, they are different entities and may not share a s ecret key. By comparison, SSE is more efficient than PSE, while PSE can be deployed in scenarios where it is infeasible to share a common secret key bet ween different entities.

One of the drawbacks of traditional searchable encryption schemes, both SSE and PSE, is that they only support exact keyword search. This will affect system usability, since typos and format inconsistencies often occur when users input keywords. To enhance system usability, searchable encryption schemes with fuzzy keyword search capability [9] are necessary.

In the symmetric key setting, some efficient proposals have been designed for fuzzy keyword search over encrypted data [12,13,15,16]. However, in the public key setting, to the best of our knowledge, there have been only two researches on achieving this functionality [5,9]. In addition, we find that both schemes are not efficient for real applications. In this work, we construct and implement a homomorphic encryption based IPEFKS scheme, which achieves much higher efficiency compared with these two schemes. 1.2 Contributions Our contributions in this paper are threefold. 1. We propose the primitive of IPEFKS that supports fuzzy keyword search 2. We leverage a nice property of bilinear pairings in such a way that the cloud 3. We evaluate the efficiency of the homomorphic encryption based IPEFKS 1.3 Organization work on fuzzy keyword searchable encryption. In section 3, we give the defini-tion of IPEFKS and a concrete construction of it. In section 4, we show how to allow the cloud server to build an inverted index over encrypted data in a secure way. In section 5, we compare the efficiency of IPEFKS with LWW-FKS. In section 6 we show security advant age of IPEFKS over LWW-FKS. Section 7 concludes this paper. Our work is built on fuzzy keyword searchable encryption. The most important related researches in this field are discussed below.

Fuzzy keyword search (FKS) over encr ypted data in the public key setting is firstly proposed by Li et al .in[9].Givenakeyword q , FKS intends to find the encrypted documents containing k eywords that are within a certain edit distance from q . The edit distance between two words w 1 and w 2 is the number of operations, including substitution, deletion and insertion, required to transform one of them into the other. Given a keyword, the basic idea of [9] is to enumerate all wildcard-based keywords that are within a predefined edit distance to it. Therefore, this scheme transforms a single fuzzy keyword search operation into several exact keyword search operati ons. The succeeding work done by Wang et al . [15] focuses on efficiency. They present a symmetric fuzzy keyword searchable encryption scheme with trie-traverse searching index in order to achieve high efficiency.

As discussed in [13], both schemes cited above can not use any other wildcard patterns than the ones prepared by the sender because the wildcard is realized by exact keyword search. The authors of [13] split a keyword into several characters and can achieve more splendid keyword matching patterns, e.g., wildcard search, partial matching. However, as for FKS, they give the same wildcard-based ap-proach as [9]. Another recent work on sy mmetric FKS has been presented in [12]. The authors construct a symmetric similarity keyword search scheme using a fuzzy extractor and a protocol for com puting Hamming distance. Actually, all above mentioned schemes do not support fuzzy keyword search in the real sense. The key issue to design FKS schemes i s computing the edit distance between two encrypted keywords. To solve this problem, the authors of [16] and [5] share the common idea of translating metric space. Concretely, they translate edit distance into a new metric space with locality sensitive function family.
Except for LWW-FKS, the scheme proposed in [5] is the other FKS scheme in the public key setting among all others mentioned above. It is based on the embedding algorithm in [10] and the similarity search scheme in [6]. It uses PIS (Private Information Storage) [11] and PIR (Private Information Retrieval) [7], both of which are interactive cryptographic protocol with low efficiency, especially when used to store and retrieve documents consisting of a large number of bits. This makes this scheme inefficien t for encrypted document retrieval.
Note that another research [18] sharing a similar name with ours solves the problem of keyword guessing attack but not the problem of fuzzy keyword search, which is the focus of this paper. In conclusion, the only somewhat practical FKS scheme in the public key setting is LWW-FKS. In this paper, we present a much more efficient FKS scheme than it. 3.1 Preliminary We denote vectors by lower-case bold italic letters, say x , y , z , etc. We assume all keywords are strings of the same length, if this is not the case, we append some wildcard symbols (e.g.,  X  ) to the shorter ones.

The authors of [10] show that there exist 0 &lt; X &lt; X &lt;c 2 and an embedding  X  HD such that:  X  X f ed ( x , y )  X  t ,then HD (  X  ( x ) , X  ( y ))  X   X log 2 (1 / X  ).  X  X f ed ( x , y )  X  2 c 1 ( The above fact indicates that we can use Hamming distance to represent edit distance. Therefore, we focus on searcha ble encryption with Hamming distance as the distance measurement.
 3.2 Definition of IPEFKS Definition 1. The IPEFKS scheme consists of the following five polynomial time algorithms, i.e., KeyGen , IPEFKS , TokenGen , Search and Retrieve , defined as follows:  X  KeyGen( 1  X  ) : Takes a security parameter  X  as input, and generates a pub- X  IPEFKS ( pk , w ): Takes a public key pk and a keyword w as inputs, and  X  TokenGen ( pk , v ): Given a public key pk and a query keyword v ,this  X  Search ( T v , S w ): With a token T v = TokenGen ( pk, v ) and a keyword ci- X  Retrieve ( sk , ER w , th ): Given a private key sk , the encrypted result ER w The work flow of the IPEFKS scheme is illustrated in Figure.1 . The receiver Tom runs the KeyGen algorithm to generate his public/private key pair pk, sk and announces pk publicly.Whena sender wantsto senda documentto Tom.She/heex-tracts the keywords of the document. Then the sender runs the IPEFKS algorithm to encrypt every keyword under Tom X  X  public key, and these encrypted keywords form the encrypted index of the document. The index and the encrypted documents are then sent to the cloud server. When Tom wants to retrieve doc-uments containing keywords within a certain Hamming distance threshold com-pared with his interested keyword  X  X inace X  (i.e., Tom omits an  X  X  X  of the keyword  X  X inance X ), he runs the TokenGen algorithm to generate a token and sends it to the cloud server. Upon receiving this qu ery request, the cloud server runs the Search algorithm and sends the encrypted results back to Tom, who then runs the Retrieve algorithm and returns the retrieval request back to the server. Finally, the encrypted documents are returned back to Tom. Tom uses his private key to decrypt the encrypted documents. Note that we do not specify how the documents are encrypted because it is unrelated with the search functionality.
We treat the cloud server as an honest-but-curious attacker in the security model and give a rigorous security definition as follows: Definition 2. An IPEFKS scheme is semantically secure against an adaptive chosen keyword attack if every PPT (Probabilistic Polynomial Time) attacker has a negligible advantage in the following attack game. 1. Setup . The challenger runs the KeyGen algorithm and obtains a key pair 2. Phase 1 . The attacker can ask for arbitrarily many keyword ciphertexts and 3. Challenge . At some point, the attacker sends the challenger two equal-4. Phase 2 . The attacker can continue to ask for more keyword ciphertexts, 5. Guess . The attacker outputs a guess bit b for b . The advantage of an ad-3.3 Construction In this section, we give a construction of the IPEFKS scheme based on a ho-momorphic encryption scheme, named FV.SH encryption scheme [8]. Before presenting the concrete construction, we give some intuitions. The Hamming Our construction leverages a nice prop erty of the FV.SH encryption scheme, that is when the plaintexts are polynomials with coefficients in Z 2 , the addition operation is equal to the XOR operation.

The FV.SH encryption scheme used in the following construction consists of four polynomial time algorithms, the key generation algorithm KeyGen ,the encryption algorithm Enc , the decryption algorithm Dec and the ciphertext addition algorithm Add . Detailed description of these algorithms are given in section 5.1. We don X  X  care about the ciphertext Multiplication algorithm, since it is unrelated with our work. The detailed construction is shown below.  X  KeyGen( 1  X  ) : Given a security parameter  X  , generates a public/private key  X  IPEFKS ( pk , w ): Given an m -bit keyword w = w 1 w 2  X  X  X  w m ,encodesthe  X  TokenGen ( pk , v ): Given an m -bit keyword v = v 1 v 2  X  X  X  v m ,encodesthe  X  Search ( T v , S w ): Computes the encrypted result ER w by adding T v and S w  X  Retrieve ( sk , ER w , th ): Decrypts ER w by running Dec sk ( ER w ), adds the In the IPEFKS and TokenGen algorithm, we encode the keyword by taking each bit of the keyword as the coefficient of an ( m  X  1)-degree polynomial. 3.4 Correctness and Security Lemma 1. Given two binary vectors w = w 1  X  X  X  w m and v = v 1  X  X  X  v m ,the Hamming distance of w and v equals m i =1 w i  X  v i , where the notation  X  de-notes the XOR operation.
 Correctness is guaranteed by the property of the FV.SH encryption scheme, i.e., when the keywords are encoded as polynomials in Z 2 [ x ] /x d + 1, the addition operation is equal to the XOR operation.
 Theorem 1. The IPEFKS scheme is semantically secure against a chosen key-word attack (CKA) if the FV.SH homomorphic encryption scheme is IND-CPA secure.
 Proof: Suppose there exists an adversary A that has a non-negligible advantage in breaking the IPEFKS. We show that there is an adversary B that can achieve the same advantage in winning a chosen plaintext attack (CPA) game for attacking the IND-CPA secure FV.SH e ncryption scheme. Therefore, we have a contradiction. We can conclude that A cannot exist and thus that IPEFKS is semantically secure against a chosen keyword attack (CKA).

In the chosen plaintext attack, where C is the challenger, the adversary B is supposed to give two messages m 0 ,m 1 to C . It then receives an encryption C a guess bit b and wins if b = b .

In the chosen keyword attack, B works as a simulator who acts as the chal-lenger. The adversary A outputs two messages m 0 and m 1 ( m 0 = m 1 ). B sends m 0 and m 1 to passes this challenge to A . Finally A gives a guess b for b , B outputs b as its guess bit for the CPA game described above.

As for queries from A in Phase 1 and Phase 2, B maintains two lists, L 1 ,L 2 , When A asks for a keyword ciphertext, B responds by sending Enc pk ( w )fora L .When A asks for a token, B responds by sending Enc pk ( w ) for a randomly A sends back a token and asks for the search results, B searches for the token Enc pk ( w ) and the corresponding keyword w in the list L 2 and then computes the Hamming distance between w and the keywords in the list L 1 and returns back IPEFKS ( pk, w i ) satisfying HD ( w , w i )  X  th ,where th is chosen by B .If the token sent by A is not in the list L 2 ,then B returns  X  , and the CKA game exits.

The attacker A cannot distinguish whether it is interacting with a real searcher or the simulator B since the message distribution are the same. The advantage B gains in the CPA game is the same as that of A in the CKA game. Since FV.SH is IND-CPA secure, which indicates that the advantage gained by B must be negligible, we get a secure IPEFKS scheme. In the construction described in sectio n 3.3, we do not specify the index structure of the encrypted documents. When there are a large number of documents, inverted index structure is preferable to forward index structure [19]. In this section, we show how to enable the cloud server to build an inverted index over encrypted data in a secure way. 4.1 Preliminary Bilinear pairings :Let G 1 and G 2 be two cyclic multiplicative group of prime order p , g be a generator of the group G 1 and e : G 1  X  G 1  X  X  X  G 2 be a bilinear map between them. The map satis fies the following properties: 1.Computable: given u, v  X  G 1 there is a polynomial time algorithm to com-pute e ( u, v )  X  G 2 . 2.Bilinear: for any integers x, y  X  [1 ,p ]wehave e ( g x ,g y )= e ( g,g ) xy . 3.Non-degenerate: e ( g,g )isageneratorof G 2 . 4.2 Construction cloud server and senders process as follows: Sender: To send a document with identifier ID and keywords set u ( ID )= { w 1 ,w 2 ,  X  X  X  ,w n } , the sender processes as follows: 1. Gets the public parameters, including the public key pk of the receiver, the bilinear pairing parameters ( p, G 1 , G 2 ,e,g ) of the cloud server; 2. Generates a random number r  X  Z  X  p and evaluates ( CA i ,CB i )=( g r ,w r i ), where CA i and CB i is the corresponding term for the i th keyword in the cipher-text, which will be used by the cloud server to build an inverted index without disclosing the keywords privacy. 3. Runs the keyword encryption algorithm IPEFKS to encrypt every keyword in the set u ( ID ); 4. Sends CA i = g r ,CB i = w r i , ID, and the searchable encrypted keywords IPEFKS ( pk, w i )(for i =1 , 2 ,  X  X  X  ,n ) together with the encrypted document to the cloud server.
 Cloud Server: Assume that there exist m terms in the inverted index. The j th term is set of document identifiers such that every d  X  D j contains the keyword w j . Upon receiving a sending request from the sender, the cloud server processes as follows: 1. Decides whether w i is equal to one of the m keywords by checking whether the equation e ( CA i ,SB j )= e ( SA j ,CB i ) is right for a certain j ,where j  X  { 1 ,  X  X  X  ,m } ; 2. Adds the document identifier ID to the set D j if the equation e ( CA i ,SB j )= e ( SA j ,CB i ) holds for a certain j , otherwise establishes a new quadruple, i.e, ( SA m +1 = CA i ,SB m +1 = CB i , IPEFKS ( pk, w i ) ,D m +1 ) for the new keyword w ,where D m +1 = { ID } .
 Correctness of this construction is based on the bilinear property of bilinear pairings and security relies on the fact that Diffie-Hellman problem on the G 2 group is hard. Because of the constrained space, we do not give a rigorous security proof here. In this section, we evaluate the efficiency of the IPEFKS scheme by implementing the recently proposed FV.SH encryption scheme and comparing with LWW-FKS. We use the notations illustrated in Table 1 in the remaining part of this paper.
 5.1 Implementation of the FV.SH Encryption Scheme In the FV.SH encryption scheme, ciphertexts consist of polynomials in the ring R . Plaintexts are polynomials in the ring R t . d, q, t and  X  are system parameters chosen in such a way that correctness an d security are guaranteed. The FV.SH encryption scheme consists of the following algorithms:  X  FV.SH.KeyGen (1  X  ): Samples secret key sk R  X   X  R 2 uniformly. Samples  X  FV.SH.Enc ( pk , m ): Samples u R  X   X  R 2 , e 1 ,e 2 R  X   X   X  uniformly and returns  X  FV.SH.Dec ( ct ): Computes We set two tuples of parameters for the FV.SH encryption scheme. Both tuples provide 128 bits of security with distinguishing advantage 2  X  64 .Inaddition,some optimizations (e.g., using the bounded discrete Gaussian distribution to replace the real discrete Gaussian distribution) ar e taken. For interested readers, please refer to [8] for details. We implement the scheme in C using FLINT, namely Fast Library for Number Theory [21]. We tes t the code on an Intel(R) Core(TM) i7-2600 CPU @ 3.40GHz running Linux 3.2.0-34-generic x86 64. The efficiency of the FV.SH encryption scheme is shown in Table 2. 5.2 Efficiency Comparison As we have shown in section 2, the proposal shown in [5] is not practical for encrypted document retrieval. As a resu lt, in this section, we only need to com-pare IPEFKS with LWW-FKS. To cope with the scenario where there are a large number of documents, we use an inverted index here. The process of building an inverted index over encrypted data is shown in section 4. Without loss of gener-ality, we assume the average keyword length to be 10 and the number of typos in the searcher X  X  inputs is smaller than 4, which we think is reasonable when the keyword length is 10. The exact keyword searchable encryption scheme used in LWW-FKS is PEKS [1], which takes the type A parameter in the PBC li-brary [20]. In LWW-FKS, the computation cost of the search algorithm, keyword encryption algorithm and token/trapdoor generation algorithm is proportional to O (10 t kn ), while the computation cost in IPEFKS is only linear in kn ,where kn denotes the keyword number and t denotes the edit distance threshold.
Figure.2 shows the experimental results of the search time spent by the cloud server in processing a keyword search request. It can be seen that when the edit distance gets larger, the search time of LWW-FKS increases greatly, while the search time of IPEFKS is only related with the keyword number but not the edit distance.
 Figure.3 and Figure.4 present the keyword encryption time and token(for IPEFKS)/trapdoor(for LWW-FKS) generation time respectively. When the edit distance gets larger, in LWW-FKS, more keyword encryptions are performed and more trapdoors are generated, thus l eading to increasing time consumption. While, in IPEFKS, the edit distance does no t affect these two processes, therefore only constant time is needed. The above e xperimental results demonstrate that IPEFKS is much more efficient than LWW-FKS.
 IPEFKS is resistant against keyword guessing attack [17], which poses a great threat to clients X  data privacy. While LWW-FKS suffers from this attack, because in LWW-FKS, cloud server has the capability of deciding whether a keyword is associated with the trapdoor received from the searcher independently. Specifi-cally, given a token associated with a keyword W , the cloud server can encrypt a guessed keyword q and then runs the test algorithm of LWW-FKS to check whether W = q . When the cardinality of the keyword set is only polynomial in the security parameter, which is indeed the case in real applications, the cloud server can implement this attack successf ully. In IPEFKS, the cloud server can-not test whether a keyword is associated with the trapdoor received from a searcher all by itself, because the Retrieval algorithm takes the secret key as an input, which is only known by the clients themselves. In this paper, we present a new primitive, named IPEFKS, to solve the problem of fuzzy keyword search over encrypted data. By comparison, IPEFKS is not only more efficient but also more secure than all existing schemes. Moreover, to enable the cloud server to build an inverted index over encrypted data, we propose an approach, which leverages a nice property of bilinear pairings. To the best of our knowledge, we are the first to implement the FV.SH encryption scheme in C, which we think may be of independent interest for other works. Future work includes enhancing the effici ency of the FV.SH encryption scheme by using SIMD operations and other optimizations and giving experimental results on the real datasets by implementing the prototype of the system.
 Acknowledgment. This work is partially supported by the HGJ National Sig-nificant Science and Technology Pr ojects under Grant No. 2012ZX01039-004-009, Key Lab of Information Network Secu rity, Ministry of Public Security under Grant No.C11606.
