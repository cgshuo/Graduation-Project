 REGULAR PAPER Yannis Tzitzikas  X  Anastasia Analyti Abstract A materialised faceted taxonomy is an information source where the objects of interest are indexed according to a faceted taxonomy . This paper shows how from a materialised faceted taxonomy, we can mine an expression of the Compound Term Composition Algebra that specifies exactly those compound terms (conjunctions of terms) that have non-empty interpretation. The mined expressions can be used for encoding in a very compact form (and subsequently given on minimising the storage space requirements of the mined set of compound algorithms for expression mining, analyses their computational complexity, that now become possible.
 Keywords Algorithms  X  Complexity  X  Knowledge extraction and reuse  X  Materialised faceted taxonomies 1 Introduction Assume that we want to build a catalogue of hotel Web pages and suppose that we want to provide access to these pages according to the Location of the hotels, so, we can design a faceted taxonomy , i.e. a set of taxonomies, each describing the domain from a different aspect, or facet , like the one shown in Fig. 1 .Now each object (here Web page) can be indexed using a compound term ,i.e.,asetof terms from the different facets. For example, a hotel in Rethimno providing sea ski and windsurfing sports can be indexed by assigning to it the compound term {
Rethimno , SeaSki , Windsur f ing } . We shall use the term materialised faceted taxonomy to refer to a faceted taxonomy accompanied by a set of object indices. taxonomy are meaningless, in the sense that they cannot be applied to any object of the domain. For instance, we cannot do any winter sport in the Greek Islands (Crete and Cefalonia) as they never have enough snow, and we cannot do any sea sport in Olympus because Olympus is a mountain. For the sake of this example, let this hotel also offers sea ski and windsurfing sports. According to this assumption, the partition of compound terms to the set of valid (meaningful) compound terms and invalid (meaningless) compound terms is shown in Table 1 .
 tion of a materialised faceted taxonomy. It could be exploited in the indexing pro-cess for preventing indexing errors, i.e. for allowing only meaningful compound terms to be assigned to objects. In particular, knowing this partition, it is possi-ble to generate a  X  X omplete X  navigation tree, whose dynamically generated nodes correspond to all possible valid compound terms [ 24 ]. Such a navigation tree can aid the indexer to select the desired compound term for indexing, by browsing only the meaningful compound terms. This kind of  X  X uality control X  or  X  X ndexing aid X  is especially important in cases where the indexing is done by many people who are not domain experts. For example, the indexing of Web pages in the Open Directory (which is used by Google and several other search engines) is done by more than 20.000 volunteer human editors (indexers). Apart from the indexer, the final user is also aided during his/her navigation and search by browsing only the meaningful compound terms.
 a partition would be a formidably laborious task for the designer. Fortunately, the recently emerged Compound Term Composition Algebra (CTCA) [ 24 ](whichis recalled in Sect. 3.2 ) can significantly reduce the required effort. According to (meaningful) compound terms by declaring only a small set of valid or invalid compound terms from which other (valid or invalid) compound terms are then inferred. For instance, the partition shown in Table 1 , can be defined using the expression: expression e (like the above expression) that specifies exactly those compound terms that are extensionally valid (i.e. have non-empty interpretation) in an exist-ing materialised faceted taxonomy. This problem, which we shall hereafter call expression mining or expression extraction , has several applications. For instance, it can be applied to materialised faceted taxonomies (which were not defined us-ing CTCA) in order to encode compactly and subsequently reuse the set of com-pound terms that are extensionally valid (e.g. the set of valid compound terms in Ta b l e 1 ). For example, suppose that we have in our disposal a very large medical file which stores medical incidents classified according to various aspects (like disease, symptoms, treatment, duration of treatment, patient X  X  age, genre, weight, smoking habits, patient X  X  profession, etc.), each one having a form of a hierarchy. In this scenario, expression mining can be used for extracting in a very compact form the set of all different combinations that have been recorded so far. Note that here  X  X ining X  does not have the classical statistical nature, i.e. we are not trying we are trying to mine the associations of the elements of the schema (here of the terms of the faceted taxonomy) that capture information about the knowledge do-main and were never expressed explicitly. Now, as the number of associations of this kind can be very big, we employ CTCA for encoding and representing them compactly.
 in [ 21 ], we introduced the problem of expression mining and described some basic and unoptimised algorithms for solving it. Here, (1) we provide a thorough pre-sentation of the problem of expression mining, including more expression mining subcases, and novel applications, (2) we describe analytically the computational complexity of the unoptimised algorithms, presented in [ 21 ], and (3) we intro-duce several optimisation techniques along with their computational complexity, showing that they achieve improved performance.
 applications of expression mining. Section 3 describes the required background. Section 4 formulates the general problem of expression mining and identifies sev-eral specializations of it. Section 5 describes straightforward methods for expres-compact and efficient expression. Then, Sect. 7 elaborates expression mining in the most general form of the problem. Section 8 discusses the computational com-plexity of the algorithms for all of the above cases and Sect. 9 describes several optimisations. Finally, Sect. 10 summarises and concludes the paper. All proofs are given in the appendix. 2 Applications of expression mining Faceted classification was suggested quite long ago by Ranganathan in the 1920s [ 18 ]. Roughly, expression mining can be useful in every application that involves faceted classification, specifically in every application that involves ma-terialised faceted taxonomies. The adoption of faceted taxonomies is beneficial like biology. 1 Current interest in faceted taxonomies is also indicated by several recent or ongoing projects (like FATKS, 2 FACET, 3 FLAMENGO, 4 and the emer-gence of XFML (Core-eXchangeable Faceted Metadata Language) (XFML) [ 31 ], a markup language for applying the faceted classification paradigm on the Web (for more about faceted classification see [ 5 , 11 , 16 , 18 , 29 ]). mining.
 Reusing the knowledge of materialised faceted taxonomies Expression mining can be exploited for encoding compactly the set of valid com-pound terms of a materialised faceted taxonomy. The mined expressions allow pact manner. One important remark is that the closed-world assumptions of the XFML + CAMEL (compound term composition algebraically-motivated expres-sion language) (XFML + CAMEL) [ 32 ] allows publishing and exchanging CTCA expressions using an XML format. As an example of expression mining, recall the scenario with the medical file that was mentioned in the introductory section. introduced in order to solve the problem of the analysis of data that are given on an aggregated form, i.e. where quantitative variables are given by intervals and where categorical variables are given by histograms. This kind of data are gener-ated when we summarise huge sets of data. Inescapably, even a symbolic data table could become very large in size, making its management problematic in terms of both storage space and computational time. As shown in [ 20 ], a symbolic data ta-ble can be seen as a materialised faceted taxonomy. Consequently, the algorithms that are presented in this paper can be used in order to compress a symbolic data table.
 Reorganising single-hierarchical taxonomies to faceted taxonomies hierarchical taxonomies found on the Web (like Yahoo! or ODP) and in libraries (like the majority of the thesauri (ISO 2788-1986)), so as to give them a clear, compact, and scalable faceted structure but without missing the knowledge that is hardwired in their structure and in their precoordinated vocabularies. Such a reorganisation would certainly facilitate their management, extension, and reuse. Furthermore, it would allow the dynamic derivation of complete and meaningful present the problem of missing terms or missing relationships (for more about this problem, see [ 2 ]). For example, for reusing the taxonomy of the Google directory, we now have to copy its entire taxonomy, which currently consists of more than 450,000 terms and whose RDF representation 5 is a compressed file of 46 MBytes! According to our approach, we only have to break their precoordinated terms and then partition the resulting set of elemental terms to a set of facets, using lan-guages like the one proposed in [ 19 ] (we shall not elaborate on this issue in this paper), and then use the algorithms presented in this paper for expression mining. Apart from smaller storage space requirements, the resulted faceted taxonomy can be modified/customised in a more flexible and efficient manner. Furthermore, a se-mantically clear, faceted structure can aid the manual or automatic construction of the intertaxonomy mappings [ 26 ], which are needed in order to build mediators or ically this scenario.
 Optimising query answering Suppose a materialised faceted taxonomy that stores a very large number of ob-jects and users that pose conjunctive queries (i.e. compound terms) in order to find the objects of interest. The availability of an expression e that specifies the compound terms with nonempty interpretation would allow realising efficiently nonempty answer. In this way, we can avoid performing wasteful computations for the queries whose answer will be eventually empty.
 Language engineering Language engineering is an area focusing on applications such as building natural language interfaces. This area employs ontologies, often called lexical ontologies or word-based thesauri, like WordNet [ 30 ] and Roget X  X  thesaurus. They consist of terms and relationships between terms, where terms denote lexical entries (words), while relations are intended as lexical or semantic relations between terms. For instance, in WordNet, terms are grouped into equivalence classes, called synsets . synsets are linked by hypernymy/hyponymy and antonymy relations. The former is the subsumption relation, while the latter links together opposite or mutually inverse terms such as tall/short, child/parent. Clearly, by ignoring the antonymy relation, the rest can be seen as a faceted taxonomy with the following facets: noun , verb , adverb and adjective . This faceted taxonomy plus any collection of indexed subphrases from a corpus of documents is actually a materialised faceted taxonomy that contains information about the concurrence of words (e.g. which adjectives are applied to which nouns). This kind of knowledge might be quite use-ful as it can be exploited in several applications, e.g. for building a recommender system in a word processor (e.g. in MS Word), an automatic cross-language trans-the number of the valid combinations of words would be so big that storing them explicitly would be quite problematic. Mining and storing only the CTCA expres-sion that describes the set of all valid combinations can definitely alleviate this problem. There might be also several applications related to the generative lexi-con [ 17 ].
 Sequences Suppose that we are interested in sequences of k distinct steps, where each step can be one of a finite set of actions. We can model all possible actions that can be enacted at one step as one taxonomy. In this way, we can model all possible sequences of k steps as a faceted taxonomy of k facets (facet i contains the actions that can be applied at the i th step). Now assume that we have at our disposal a log file that stores a set of sequences that occurred in the past. These sequences storing compactly these sequences in order to build a recommending (or error-avoiding) service. Expression mining can be applied in order to represent this set of sequences compactly. The T9 technique 6 (Text Input for Keypad Devices) that allows us to write quickly SMS messages from our mobile phones is a special case of this scenario. 3 Background onomies, faceted taxonomies, compound taxonomies, and the CTCA. For more information and examples, please refer to [22 X 24]. Subsequently, in Sect. 3.3 ,we define materialised faceted taxonomies. 3.1 Taxonomies, faceted taxonomies and compound taxonomies A taxonomy is a pair ( T ,  X  ) ,where T is a terminology and  X  is a reflexive and transitive relation over T , called subsumption .A compound term over T terms over the taxonomy Sports of Fig. 1 : s 1 ={ SeaSki , Windsurfing } , s 2 = {
SeaSports , WinterSports } , s 3 ={ Sports } ,and s 4 = X  .Wedenoteby P ( T ) the set of all compound terms over T (i.e. the powerset of T ). A compound terminology S over T is any set of compound terms that contains the compound term  X  .Theset of all compound terms over T can be ordered using an ordering relation that is de-rived from  X  . Specifically, the compound ordering over T is defined as follows: if s , s are compound terms over T ,then s s iff  X  t  X  s  X  t  X  s such that t  X  t . That is, s s iff s contains a narrower term for every term of s . In addition, s may contain terms not present in s . Roughly, s s means that s carries more specific indexing information than s . We say that two compound terms s , s are equivalent iff s s and s s . Intuitively, equivalent compound terms carry the same indexing information and, in our context, are considered the same. A com-pound taxonomy over T is a pair ( S , ) ,where S is a compound terminology over T ,and is the compound ordering over T restricted to S . Clearly, ( P ( T ), ) is a compound taxonomy over T . The broader and the narrower compound terms of a compound term s are defined as follows: Br ( s ) ={ s  X  P ( T ) | s s } and Nr ( s ) ={ s  X  P ( T ) | s s } . The broader and the narrower compound terms of a compound terminology S are defined as follows: Br ( S ) = X  X  Br ( s ) | s  X  S } and Nr ( S ) = X  X  Nr ( s ) | s  X  S } .
 F = ( T ,  X  ) ,where T = X  k we shall call the faceted taxonomy generated by { F 1 ,..., F k } . We call the tax-{ ogy over the terminology T of the faceted taxonomy shown in Fig. 1 .Theset S together with the compound ordering of T (restricted to S ) is a compound taxon-omy over T . For reasons of brevity, hereafter, we shall omit the term  X  from the compound terminologies of our examples and figures. 3.2 The compound term composition algebra Here we present in brief the compound term composition algebra (CTCA), an al-gebra for specifying the valid compound terms of a faceted taxonomy (for further details, see [ 23 , 24 ]).
 {
F terminology T i is defined as follows: T i ={{ t }| t  X  T i }  X  { X  X  . Note that each basic compound terminology is a compound terminology over T . The basic operations of CTCA.
 ent facets, but also terms from the same facet. Two auxiliary product operations, positive or negative modifiers, which are sets of known valid or known invalid compound terms. The unmodified product and self-product operations turn out of valid compound terms and N denotes a set of invalid compound terms. The definition of each operation is given in Table 2 .
 and S ={{ Sports } , { SeaSports }} . The compound taxonomy corresponding to S  X  S is shown in Fig. 3 , and consists of nine compound terms. Recall that, for reasons of brevity, we omit the term  X  from the compound terminologies of our examples (  X  is an element of S , S and S  X  S ).
 Fig. 4 and suppose that we want to define a compound terminology that does not contain the compound terms { Islands , WinterSports } and { Islands , SnowSki } ,be-cause they are invalid. For this purpose, instead of using a product ,wehaveto use either a plus-product or a minus-product operation. Specifically, we can use a The compound taxonomy defined by this operation is shown in the right part of pound terminology  X  P ( S , S ) contains the compound term s ={ Greece , Sports } , S  X  S  X  Br ( P ) (see the definition of plus-product in Table 2 ). Alternatively, we can obtain the compound taxonomy shown at the right part of Fig. 4 by using a minus-product operation, i.e. N ( S , S ) , with N ={{ Islands , WinterSports }} . The result does not contain the compound terms { Islands , WinterSports } and {
Islands , SnowSki } , as they are elements of Nr ( N ) (see the definition of minus-product in Table 2 ).
 Definition 1 An expression e over F is defined according to the following gram-mar ( i = 1 ,..., k ): where the parameters P and N denote sets of valid and invalid compound terms, respectively.
 called the compound terminology of e . In addition, ( S e , ) is called the compound taxonomy of e .
 sion e . The expression e actually partitions the set P ( T e )intotwosets: (a) the set of valid compound terms S e ,and (b) the set of invalid compound terms P ( T e )  X  S e .
 terms . Intuitively, a genuine compound term combines nonempty compound terms from more than one compound terminology. Specifically, the set of gen-uine compound terms over a set of compound terminologies S 1 ,..., S n is S {{ { the set of genuine compound terms over a basic compound terminology, T i , i = 1 ,..., k ,isdefinedasfollows: G pound terms are used to define a well-formed algebraic expression.
 (i) each basic compound terminology T i appears at most once in e , we presented the algorithm IsValid ( e , s ) that checks the validity of a compound where P denotes the union of all P parameters and N denotes the union of all N parameters appearing in e . Additionally, in [ 23 ], we showed why we cannot we should mention that a system that supports the design of faceted taxonomies mented by VTT and Helsinki University of Technology (HUT) under the name FASTAXON [ 25 ]. The system is currently under experimental evaluation. 3.3 Materialised faceted taxonomies Let Obj denote the set of all objects of our domain, e.g. the set of all hotel Web pages. An interpretation of a set of terms T over Obj is any (total) function I : T  X  P ( Obj ) .
 faceted taxonomy and I is an interpretation of T . An example of a materialised numbers. This will be the running example of our paper.
 simple query language is introduced next. A query over T is any string derived by the following grammar: q ::= t | q  X  q | q  X  q | q  X  X  q | ( q ) | ,where t isatermof T .Nowlet Q T denote the set of all queries over T . Any interpreta- X  I ( tion t 1  X  X  X  X  X  t k . However, in order for answers to make sense, the interpretation used for answering queries must respect the structure of the faceted taxonomy in introduced next, captures well-behaved interpretations. An interpretation I is a ( {
Crete , SeaSki } ) ={ 2 } , and  X   X  I ( { SeaSki , Windsurfing } ) ={ 4 } . 4 Problem statement The set of valid compound terms of a materialised faceted taxonomy M = ( F , I ) is defined as where  X  I is the model of ( T ,  X  ) generated by I . 7 this subset of V ( M ) . One can easily see that it holds that the materialised faceted taxonomy shown in Fig. 5 .
 Problem 1 Given a materialised faceted taxonomy, M = ( F , I ) , find an expres-sion, e , over F such that S e = V  X  ( M ) .
 looking for does not contain any self-product operation.
 where P denotes the union of all P parameters of e and N denotes the union of all N parameters of e . Among the expressions e that satisfy S e = V  X  ( M ) ,weare more interested in finding the shortest expression. This is because, in addition to smaller space requirements, the time needed for checking compound term valid-ity according to the mined expression e is reduced. 8 Reducing the time needed for checking compound term validity improves the performance of several on-line tasks associated with knowledge reuse. Indeed, as was shown in [ 24 ], the algo-rithm IsValid ( e , s ) is called during the dynamic construction of the navigation tree that guides the indexer and the final user through his/her (valid) compound term selection. Though shortest expression mining is a costly operation, it is not a routine task. Therefore, we consider that reducing the size of the mined expression is more important than reducing the time needed for its extraction. In particular, we are interested in the following problem: Problem 2 Given a materialised faceted taxonomy, M = ( F , I ) , find the shortest expression e over F such that S e = V  X  ( M ) .
 following: Problem 3 Given an expression e that does not contain any self-product opera-tion, find the shortest expression e such that S e = S e .
 Problems 2 and 3. The only difference is that, in the second problem, we have be very useful even during the design process, i.e. a designer can use the above optimiser several times during the process of formulating an algebraic expression. compound terms that contain more than one term from each facet. Here, expres-sion mining is formulated as Problem 4 Given a materialised faceted taxonomy, M = ( F , I ) , find the shortest expression e over F such that S e = V ( M ) .
 or more self-product operations.
 Problem 5 Given an expression e , find the shortest expression e such that S e = S .
 finally, in Sect. 7 , we tackle Problems 4 and 5. 5 Mining an expression One straightforward method to solve Problem 1 is to find an expression e with only one plus-product operation over the basic compound terminologies T 1 ,..., T k ,i.e. an expression of the form e = X  P ( T 1 ,..., T k ) . 1. P := V ( M )  X  G T 1 ,..., T k . 2. P := minimal ( P ) .
 of the mined expression. Specifically, it eliminates the redundant compound terms of the parameter P , i.e. those compound terms that are not minimal (w.r.t. ). P contains the minimal elements of P , then it is evident that, again, it holds that example (of Fig. 5 ), we get that P ={{ Olympus , Sno w Ski } , { Crete , SeaSki } , { form e = N ( T 1 ,..., T k ) .
 2. N := maximal ( N ) .
 The first step computes all invalid compound terms that contain at most one term ( M ) . Again, the second step is optional and aims at reducing the size of the mined expression. Specifically, it eliminates the redundant compound terms, i.e. N ={{ Mainland , SeaSports } , { Islands , WinterSports }} . Notice that here product expression (the parameter N contains only two compound terms, while P contains five). We refer to the above techniques as straightforward expression mining . 6 Mining the shortest expression Let us now turn our attention to Problem 2, i.e. on finding the shortest expres-sion e over a given materialised faceted taxonomy M = ( F , I ) such that S e = ( M ) .
 shortest expression is either a plus-product or a minus-product operation. How-ever, in the general case where we have several facets, finding the shortest expres-sion is more complicated because there are several forms that an expression can have. in the sense that it investigates all forms that an expression over F may have. We use the term expression form to refer to an algebraic expression of which the P and N parameters are undefined (unspecified). Note that an expression form can be represented as a parse tree.
 over { F 1 ,..., F k } .
 taxonomy M and specifies the parameters P and N of e such that S e = V  X  ( M ) . e ,i.e. | P  X  N | . 9 S 6.1 Deriving all possible parse trees {
F {
F names. 10 Additionally, the internal nodes of a parse tree are named + or  X  , corre-sponding to a plus-product (  X  P ) or a minus-product ( N ) operation, respectively. As we consider only well-formed expressions, every facet name appears just once in a parse tree.
 circles enclose the particular kind of extension. Similarly, the parse trees in the second row of Fig. 6(c) are derived by extending the parse tree tr 2 with the facet name C .
 following proposition gives us an upper bound.
 ParseTrees ( { F 1 ,..., F k } ) . It holds that P T k  X  ( k  X  1 ) ! X  5 k  X  1 . Algorithm 6.1 FindShortestExpr(M) the actual number of parse trees (e.g. PT 4 = 162, while 3 ! 5 3 = 750). 6.2 Specifying the parameters This section describes the algorithm SpecifyParams(e,M) (Algorithm 6.2 ), i.e. an algorithm that takes as input the parse tree of an expression e (with undefined P and N parameters) and a materialised faceted taxonomy M and returns the same parse tree but now enriched with parameters P and N that satisfy the condition S Algorithm 6.2 SpecifyParams(e,M) .
 parameter P of this operation. we must first define the parameters of all subex-G belong to G S e P is set equal to the minimal compound terms of P (for the reasons described in Sect. 5 ).
 So the procedure SpecifyParams ( e i , M ) is called recursively for all i = 1 ,..., n . Subsequently, the statement N := G and stores in N those elements of G S e equal to the maximal compound terms of N (for the reasons described in Sect. 5 ). 6.3 An example of shortest expression mining Let us now apply the above algorithms to a materialised faceted taxonomy M = ( F , I ) ,where F is the four-faceted taxonomy shown in Fig. 7 a. The set of all compound terms that consist of at most one term from each facet are ( | A |+ 1 )  X  ( | compound terms V  X  ( M ) consists of the 48 compound terms listed in Fig. 7 b. For set V  X  ( M ) .
 C {
A , B , C , D } (Fig. 7 c sketches some indicative parse trees). Then for each parse particular values to the parameters P and N of e such that S e = V  X  ( M ) .The encode very compactly the knowledge of materialised taxonomies. As we have already mentioned, this is due to the closed world assumptions of the algebraic operations. 7 Shortest expression mining in the most general case In this section, we consider the general case, where we are interested in all valid compound terms, i.e. in the whole V ( M ) . Expression mining in this case requires employing self-product operations and extending the algorithms discussed in the previous section. This is because a compound term in V ( M ) may contain more than one term from the same facet.
 of each leaf node, F i , i = 1 ,..., k , there is always a node that corresponds to For example, Fig. 8 shows the parse trees of all expressions (a) over a facet { A } and (b) over two facets { A , B } . Notice that, in the figure, we use s  X  and s to indicate the nodes that correspond to a plus-self-product and minus-self-product operation, respectively.
 algorithm SpecifyParams (Algorithm 6.2 ). It includes two extra cases, one for each self-product operation. The treatment of these cases is analogous V ( M ) . Algorithm 7.1 SpecifyParamsG(e,M) .
 8 The computational complexity of expression mining In this section, we will measure the computational complexity of expression min-ing. At first, we will measure the complexity of some basic decision problems, then of the algorithms for straightforward expression mining and, finally, of the algorithms for shortest expression mining.
 We define the source graph , = ( N , E ) , of a materialised faceted taxonomy M = ( F , I ) as follows: Roughly, the source graph is obtained by taking the union of the faceted taxonomy F and only if o  X  I ( t ) . For example, the source graph of the materialised faceted taxonomy shown in Fig. 5 coincides with the illustrated directed graph in the fig-space. 11 can easily see that the maximum number of valid compound terms of a materi-| This requires solving the following maximisation problem: We can solve this problem using the method of Lagrange multipliers , i.e. by as-solving a system of k + 1 equations. Specifically, we have the following k equa-tions:  X   X  X  X  = x means that G T 1 ,..., T k has at most ( 1 + | 1 +| T | and, for k =| T | ,weget2 | T | . Thus, | T 8.1 Complexity of some basic decision problems Here, we will elaborate on the following decision problems, where o is an object, the same task but with the additional assumption that we are interested only in ( M ) , i.e. in the compound terms that contain at most one term from each facet. All complexity results of this subsection are summarised in Table 3 . by n t ) is reachable from the node that corresponds to object o (denoted by n o ). other objects (but only with terms), thus, at most | T | 2 +| T | edges have to be processed. Thus, the time complexity of this decision problem is O ( | T | 2 ) . if all nodes that correspond to terms in s are reachable from the node that corre-denotes the number of terms in s .
 is to run decision problem (b) for each o  X  Obj . Thus, the time complexity of this problem is O ( | Obj || T | 2 | s | ) .
 Sect. 3.1 , we have to perform at most k  X  l term subsumption checks. If we have stored only the transitive reduction of the subsumption relation  X  , then term sub-sumption again reduces to the problem of reachability in the graph of the faceted taxonomy F (which is a subgraph of the source graph). As the terminologies of the facets are disjoint and subsumption links do not cross the boundaries of O (( | T | / k ) 2 | s || s | ) .
 this task is O (( | T | / k ) 2 k 2 ) = O ( | T | 2 ) . 8.2 Complexity of straightforward expression mining Here, we will measure the computational complexity of the techniques described in Sect. 5 . Recall that, in this case, we are interested only in the compound terms that contain at most one term from each facet, i.e. those in V  X  ( M ) . (f) computing P := V ( M )  X  G T 1 ,..., T k , (g) computing N := G T 1 ,..., T k  X  V ( M ) ,and (h) computing minimal(P) (resp. maximal(N) ).
 to the beginning of Sect. 8 , G T 1 ,..., T k has at most ( 1 + | sequence, the complexity of task (f) is O (( | T | k ) k | Obj || T | 2 k ) = O ( | Note that, for k = 1, we get O ( | T | 3 | Obj | ) .
 V ( M ) . The complexity of this task is the same with that of task (f), as instead of selecting the valid, here we have to select the invalid compound terms for forming the set N .
 mal )elementsofaset A of compound terms. Clearly, we need to perform at most |
A | 2 compound ordering checks (i.e. decision problem (d  X  ) ). Thus, the time com-|
N | 2 ) ).
 ( for expression mining that were described in Sect. 5 . The complexity of Step 1 is overall time complexity is O ( | complexity results presented in this subsection.
 that k cannot practically be very big (we haven X  X  seen so far any real application with more than 10 facets). Furthermore, | T | ,andevenmore | in a faceted taxonomy. For example, a faceted taxonomy of eight facets, each one having 10 terms (i.e. with | T | =80and | compound terms. Note that this set of compound terms can discriminate 1 billion objects (e.g. Web pages) in blocks of 10 elements. Yet, the above straightforward techniques are quite naive and optimised algorithms with better performance are presented in Sect. 9 .
 8.3 Complexity of shortest expression mining For measuring the computational complexity of the techniques described in Sect. 6 , we start by analysing the complexity of SpecifyParams(e,M) .First,we need to analyse the computational complexity of (i) computing P := V  X  ( M )  X  G S e (j) computing N := G S e appear in an expression e .
 in O ( | s | ) and of f ( e ) is in O ( k ) ,where k is the number of facets of F . G  X  X  X   X  T G G 1. T here exist i , j = 1 ,..., n , i = j , such that f ( s )  X  f ( e i ) = X  , 2. f ( s )  X  f ( e ) .
 (2) above. For deciding this task, we first have to compute f ( s ) andthentake least two of the above intersection operations yield a nonempty set and f ( s )  X  f ( have at most k elements ( F contains k facets), task (x) takes O ( k 2 ) time. So to decide whether an s  X  V  X  ( M ) is also an element of G S e time.
  X  ( Task ( c  X  ) + Task ( x )) = O (( | T | ( | Obj || T | 2 k )) = O ( | ( M ) .Notethat,as G This means that N can be computed as follows: for each s in G T 1 ,..., T k ,wecheck if s is valid (i.e. if s  X  V  X  ( M ) ). If not, then we check if it belongs to G S e and, if this is true, we put s in N .
 iff (  X  (  X   X  . So, for checking ( X ) ,wehavetorun n times ( n  X  k ) the decision problem G O ( | Obj || T | 2 k 2 + k 2 ) = O ( | Obj || T | 2 k 2 ) .
 ( Task ( c  X  ) +| Obj || T | 2 k 2 ) = O (( | T | k ) k | Obj || T | 2 k 2 ) = O ( | e has at most k  X  1 operations, we have to set k  X  1 parameter sets. For defining each such parameter set, we have to perform an operation of the form P := V  X  ( M )  X  G maximal(N) operation. So the time complexity of SpecifyParams(e,M) is ( k  X  1 )  X  ( Task ( i ) + Task ( h )) = ( k  X  1 )  X  O number of facets (Prop. 1 ). So, the procedure SpecifyParams(e,M) will be called algorithm that finds all possible parse trees. However, this task is computationally negligible, comparing it with the task of setting up the parameters. From this, we than the complexity of SpecifyParams(e,M) ,i.e.
 Ta b l e 5 summarises the complexity results presented in this subsection. From the expression mining is not formidably high. However, an optimised algorithm with much better complexity is going to be presented in the next section. 9 Optimisations One can easily guess that expression mining is a computationally heavy task. In this section, we describe some more efficient algorithms for expression mining. In Sects. 9.1 and 9.2 , we give two optimised algorithms for mining a plus-product and a minus-product expression. In Sect. 9.3 , we show how we can reduce the number of parse trees that have to be investigated for finding the shortest expres-sion. Finally, in Sect. 9.4 , we show how we can speed up the evaluation of the algorithm SpecifyParams(e,M) by taking advantage of the properties of CTCA. At last, we will present an optimised algorithm for shortest expression mining that takes advantage of all particular optimisations. 9.1 Mining a plus-product expression algorithm, called PlusMining(M) , for computing the parameter P .
 { t {
I  X  1 ( o ) | o  X  Obj } . It is easy to see that Br ( D D
I is the set of valid compound terms derived from D I that consist of at most one It is easy to see that the following proposition holds: Proposition 2 Let M be a materialised faceted taxonomy. It holds that (i) Br ( D I ) = V ( M )  X  G T 1 ,..., T k , and (ii) minimal ( D I ) = minimal(V(M)  X  G T 1 ,..., T k ) . and returns the desired parameter P = minimal ( D I ) . In the algorithm, symbols I Windsurfing } . Considering all objects, we derive D ={{ Olympus, Snowski } , { Crete, SeaSki } , { Crete, Windsurfing } , { Cefalonia, Seaski , ( M ) , through line (6), we get the valid compound terms that consist of at most one term from each facet. Specifically, we get D ={{ Olympus, Snowski } , { Crete, SeaSki } , { Crete, Windsurfing } , { Cef alonia , Seaski } , { Cef alonia , Windsur f ing }} . 14 In this example, D = minimal ( D ) . Therefore, the returned parameter P is the same as D .
 Algorithm 9.1 PlusMining(M) .
 of algorithm PlusMining(M) is ing(M) is much more efficient than the straightforward one of Sect. 5 . 9.2 Mining a minus-product expression In this subsection, we focus on the case that e is a minus-product operation over T ,..., T the sought parameter N by going through each s  X  G T 1 ,..., T k and then checking collected compound terms, that is, N = maximal ( G T 1 ,..., T k  X  V ( M )) . broader (w.r.t. )than { a , b } . Such an optimisation is performed in the algorithm MinusMining(M) (Algorithm 9.2 ). 15 In the algorithm, D collects selectively invalid compound terms by taking into account the previous optimisation. Thus, algorithm returns the desired parameter, N = maximal ( D ) .
 Algorithm 9.2 MinusMining(M) .
 exhaustive one of Sect. 5 . However, both algorithms have the same worst-case complexity.
 sumption relation  X  in order to avoid checking the validity of some compound check the compound term { a 2 , b } because it is certainly invalid and not broader (w.r.t. )than { a 1 , b } . 9.3 Reducing the number of candidate parse trees In this subsection, we show that some parse trees returned by ParseTrees ( {
F 1 ,..., F k } ) can been eliminated before SpecifyParams(e,M) is called, for set-expression. We start with some auxiliary definitions.
 Definition 2 We say that two well-formed expressions e and e are equivalent , and write e  X  e ,iff S e = S e .
 Definition 3 A well-formed expression e is space-minimal if every P and N pa-rameter of e satisfies the equalities P = minimal ( P ) and N = maximal ( N ) . minimal.
 minimal expression. Also notice that all algorithms that we have described so far yield space-minimal expressions. Indeed, we are interested only in space-minimal expressions.
 Proposition 3 Let e and e be two space-minimal and equivalent (i.e. e  X  e ) expressions. If e has the form e = X  P ( e 1 ,  X  X  X  , e n ) for n  X  3 and then it holds si ze ( e )  X  size ( e ) .
 Proposition 4 Let e and e be two space-minimal and equivalent (i.e. e  X  e ) expressions. If e has the form e = N ( e 1 ,..., e n ) for n  X  3 and then it holds si ze ( e )  X  size ( e ) .
 tr 8 , tr 12 , tr 14 and tr 16 returned by ParseTrees didates because the size of their corresponding expression can never be smaller than that of the expressions of the remaining parse trees.
 lows: before calling (at line (4) of Algorithm 6.1 ) the computationally expensive SpecifyParams(e,M) for a parse tree e ,wefirstcheckif e is a good candidate. We can check whether a parse tree e is a good candidate by a simple algorithm: First, we traverse the parse tree e until we reach an internal node n with a label l ,such that (i) n has a child that is also an internal node and (ii) all of the children of n that are internal nodes have the same label l . If we reach such a node n of e , we conclude that the parse tree e is not a good candidate. In that case, we don X  X  proceed in calling SpecifyParams(e,M) . ( {
F 1 ,..., F k } ) are redundant and thus can be ignored. For example, from the 162 Another important remark is that, as efficiently computable approximate optimal solutions would be more than acceptable for this problem case, it seems that the employment of genetic algorithms [ 8 ] would fit quite well to this problem in order to further reduce the number of parse trees. This is an issue for further research and experimental evaluation. 9.4 Speeding up the specification of parameters in shortest expression mining In this section, we present an optimised version of the algorithm FindShortestExpr(M) (Algorithm 6.1 ). The optimised algorithm exploits some al-gebraic properties of CTCA and it is also enhanced with the optimisations de-scribed in the previous subsections.
 taxonomy. We define V  X  ( M ) and the sets V  X  ( M ) and G T 1 ,..., T k  X  V  X  ( M ) . Actually, V are the sets P and N of the straightforward expression mining techniques that were MinusMining ( M ) .
 ( M )) and maximal ( G Params(e,M) (Algorithm 6.2 ) with equivalent but more efficient operations that G S } appearing in e .
 Proposition 5 Let M be a materialised faceted taxonomy and let e i ,i = 1 , .., n ( M )  X  P ( T than the operation minimal ( G S e  X  ( V +  X  ( M )) are much smaller than V  X  ( M ) and G smaller than G S e Proposition 6 Let M be a materialised faceted taxonomy and let e i ,i = 1 , .., n ( M )  X  P ( T eration maximal ( G S e ( M ))) ,as V  X   X  ( M ) is much smaller than G operation is needed.
 of the algorithm SpecifyParams(e,M) (Algorithm 6.2 ) by replacing the opera-tions minimal ( G S e equivalent, but more efficient, operations minimal ( G S e G V  X  ), where V + = V + expression mining (Algorithm 9.4). The algorithm first computes the parameters V (Algorithm 9.1 )and MinusMining(M) (Algorithm 9.2 ). Then it calls the procedure that is a good candidate and not a plus-product or a minus-product operation over T ,..., T which is actually the already computed parameter V  X  . Similarly, if the parse tree V + , V  X  ), as N should be set equal to V  X  parameter V  X  .
 V + and V  X  is smaller than the cost of SpecifyParams (  X  Algorithm 9.3 SpecifyParamsO ( e , V + , V  X  ) .
 Algorithm 9.4 FindShortestExprO(M) FindShortestExprO(M) wisely does not call SpecifyParamsO (  X  P ( T 1 ,..., T ), V + , V  X  ) and SpecifyParamsO ( algorithm FindShortestExpr(M) with respect to several aspects:  X  it uses the optimised algorithms PlusMining(M) and MinusMining(M) ,forcom-puting V +  X  ( M ) and V  X   X  ( M ) , respectively, sion and SpecifyParams ( e , M ) .
 we compare it with that of FindShortestExpr(M) .
 V putation minimal ( G S e is
O ( | V + || s || f ( e ) | ) = O ( | V + | k 2 ) .Let s  X   X  S i = 1 ,..., n ,haveatmost k elements, the complexity of the check s  X  G is O ( k 2 ) . Thus, the overall complexity of the computation G fore, the overall complexity of the operation minimal ( G S e O ( | V + | 2 | T | 2 ) .
 s  X  V  X  . From the construction of S (  X  (  X  S i can hold only because n times ( n  X  k ) the decision problem (c  X  ) . Thus, the time complexity of (  X  )is O ( | Obj || T | 2 k 2 ) .
 O ( | V  X  || Obj || T | 2 k 2 ) .
 plexity of SpecifyParamsO ( e , V + , V  X  ) is The complexity of computing V + and V  X  is the same as the complexity of Plus-Mining(M) and MinusMining(M) , respectively, that is (in the worst case), most PT k times, where PT k is the number of parse trees returned by overall complexity of FindShortestExprO(M) is FindShortestExpr(M) (given in Table 5 ), we get that the improvement of the for-mer over the latter is case complexity of FindShortestExprO(M) over that of FindShortestExpr(M) is obvious. Moreover, recall that FindShortestExprO(M) employs several optimisa-tions that contribute to its efficiency. 10 Conclusion Mining commonly seeks statistically justified associations or rules. In this paper, we deal with a different kind of mining. Specifically, we show how, from an object base, we can mine the associations of the elements of the schema (here of the terms of a faceted taxonomy) that capture information about the knowledge domain and were never expressed explicitly. Now, as the number of associations of this kind can be very big, we employ the compound term composition algebra (CTCA) for encoding and representing these associations compactly.
 i.e. the problem of finding algebraic expressions of CTCA that specify exactly those compound terms that are extensionally valid (i.e. have nonempty interpre-include reusing the knowledge of materialised faceted taxonomies, reorganising single-hierarchical taxonomies to faceted taxonomies, optimising query answer-ing, language engineering, recommending (or error-avoiding) services and opti-mising user-defined algebraic expressions.
 terms that consist of at most one term from each facet. For this case, we gave two straightforward methods for mining a plus-product and a minus-product ex-pression (possibly, none the shortest) and an exhaustive algorithm for finding the shortest expression. The last algorithm yields expressions with remarkably low storage-space requirements, thanks to the closed-world assumptions of CTCA. Moreover, we presented optimisations for all of the above mining cases. worst-case time complexity. We found out that, though the unoptimised algorithms are computationally heavy, their optimised versions are quite efficient in practice. Of course, the complexity of shortest expression mining is much higher than the complexity of mining a plus-product or a minus-product expression due to the fact that the number of expressions that need to be examined for finding the shortest one is exponential with respect to the number of facets. This does not reduce the benefits of our approach, as the number of facets cannot practically be very big expression mining is a rare off-line task. As explained in the paper, the time for considered that slow runs of shortest expression mining can be tolerated in order to minimise the size of the mined expression and provide efficiency for later on-line tasks, such as object indexing and navigation.
 we are interested in all valid compound terms. However, the complexity of shortest expression mining in this most general case is expected to be significantly higher (this is an issue for further research).
 algorithms. Commonly, lossless compression algorithms are efficient for files that contain lots of repetitive data, i.e. sequences of data that occur more than once. Such algorithms range from the simple RLE (run length encoding) algorithm to statistical algorithms, like Huffman compression [ 9 ], and dictionary-based algo-rithms, like LZ77 [ 33 ] (a variant of which is Gzip) and LZ78 [ 34 ]. Roughly, sta-tistical algorithms assign a smaller number of bits to symbols with higher prob-ability of appearance, while dictionary-based algorithms substitute a sequence of symbols by a pointer to a previous occurrence of that sequence. The key differ-ence of the technique proposed in this paper is that it exploits the semantics of the data, so it can reduce the size of a set of compound terms even if there are no repetitive data. It is evident that this kind of compression cannot be obtained by the classical (general-purpose) compression algorithms. However, the classi-cal compression algorithms could be applied as a postprocessing step in order to further reduce the storage space. For instance, all facet terms can be stored in a dictionary form, i.e. a code can be assigned to each term and these codes can then be used (instead of the terms) for storing the P / N parameters.
 Appendix: Proofs References Author Biographies
