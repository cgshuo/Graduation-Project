 Peer-to-Peer ( P2P ) data integration systems have recently attracted significant attention for their ability to manage and share data dispersed over different peer sources. While integrating data for answering user queries, it often happens that inconsistencies arise, because some integrity constraints specified on peers X  global schemas may be violated. In these cases, we may give semantics to the inconsistent system by suitably  X  X epairing X  the retrieved data, as typically done in the context of traditional data integration systems. How-ever, some specific features of P2P systems, such as peer autonomy and peer preferences (e.g., different source trust-ing), should be properly addressed to make the whole ap-proach effective. In this paper, we face these issues that were only marginally considered in the literature. We first present a formal framework for reasoning about autonomous peers that exploit individual preference criteria in repairing the data. The idea is that queries should be answered over the best possible database repairs with respect to the pref-erences of all peers, i.e., the states on which they are able to find an agreement. Then, we investigate the computational complexity of dealing with peer agreements and of answer-ing queries in P2P data integration systems. It turns out that considering peer preferences makes these problems only mildly harder than in traditional data integration systems. H.2.4 [ Database Management ]: systems X  Relational databases ; F.2.2 [ Analysis of Algorithms and Problem Complexity ]: Nonnumerical Algorithms and Problems Theory, Management Peer-to-Peer Systems, Data Integration Systems
Peer-to-Peer ( P2P ) data integration systems are networks of autonomous peers that have recently emerged as an effec-tive architecture for decentralized data sharing, integration, and querying. Indeed, P2P systems offer transparent ac-cess to the data stored at (the sources of) each peer p ,by means of the global schema equipped with p for modeling its domain of interest; moreover, pair of peers with the same domain of interest one peer and the system is in charge of accessing each peer containing relevant data separately, and combining local results into a global answer by suitably ex-ploiting the mapping rules.

P2P systems can be considered the natural evolution of traditional data integration systems, which have received considerable attention in the last few years, and which have already become a key technology for managing enormous amounts of information dispersed over many data sources.
In fact, P2P systems have attracted significant attention recently, both in the development of efficient distributed al-gorithms for the retrieval of relevant information and for answering user queries (see, e.g., [9, 21, 12, 13]), and in the investigation of its theoretical underpinnings (see, e.g., [16, 3, 20, 11, 9, 5]).

In this paper, we continue along this latter line of research, by investigating some important theoretical issues. In par-ticular, we consider an expressive framework where integrity constraints are specified on peer schemas in order to enhance their expressiveness, so that each peer can be in fact con-sidered a completely specified data integration system. In this scenario, it may happen that data at different peers are mutually inconsistent , i.e., some integrity constraints are vi-olated after the integration is carried out; then, a  X  X epair X  for the P2P system has to be computed [5, 17]. Roughly speaking, repairs may be viewed as insertions or deletions of tuples at the peers that are able to lead the system to a consistent state.

Our aim is to deal with data integration in P2P systems, by extending some of the ideas described in previous studies on merging mutually inconsistent databases into a single consistent theory [2, 14] and on repairing individual data integration systems [8, 6, 4, 10].
Indeed, in order to be effective in this framework, the re-pair approach should consider the peculiarities of P2P sys-tems and, specifically, the following two issues: Despite the wide interest in this field, none of the approaches in the literature considered the issue of modeling the auton-omy of the peers in providing a semantics for the system, and therefore they implicitly assume that all the peers act cooperatively in the network. Moreover, the possibility of modeling peer preferences has been rarely considered in pre-vious studies, even though it has been widely recognized to be a central issue for the design of quality-aware integra-tion systems (cf. [17]). Indeed, the first and almost isolated attempt is in [5], where the authors considered trust rela-tionships among peers in a simplified setting in which the system does not transitively propagate information through peers. Actually, an extension to the case of transitive propa-gations is also argued, but peers autonomy is not considered, and query answering is undecidable in presence of loops.
In this paper, we face the above issues by introducing a formal framework for reasoning about autonomous peers that exploit individual preference criteria in repairing data. In summary, our contributions are the following:
The rest of the paper is organized as follows. In Sec-tion 2, we briefly present some preliminaries on relational databases. In Section 3, we introduce a simple formaliza-tion of P2P data integration systems and in the subsequent section we enrich it to take care of peers X  preferences. The computational complexity of the concept of agreement in query answering is studied in Section 5. Finally, in Section 6 we draw our conclusions.
We recall the basic notions of the relational model with integrity constraints. For further background on relational database theory, we refer the reader to [1].

We assume a (possibly infinite) fixed database domain  X  whose elements can be referenced by constants c 1 ,..., c under the unique name assumption , i.e. different constants denote different objects. These elements are assumed to be shared by all the peers and are, in fact, the constants that canappearinthe P2P system.
 A relational schema (or simply schema ) RS is a pair
 X  ,  X  , where:  X  is a set of relation symbols, each with an associated arity that indicates the number of its attributes, and  X  is a set of integrity constraints , i.e., (first-order) as-sertions that have to be satisfied by each database instance. We deal with quantified constraints, i.e., first order formulas of the form: where l + m&gt; 0, n  X  0, A 1 ,...A l and B 1 ,...B m are positive of distinct variables.

Actually, to keep things simple, we shall assume through-out the paper that  X  y is empty, thereby dealing with univer-sally quantified constraints. We recall here that this kind of constraint covers most of the classical constraints issued on a relational schema, such as keys, functional dependencies, and exclusion dependencies. A brief discussion on how to generalize the results in the paper to other classes of con-straints is reported in Section 6.
 A database instance (or simply database ) DB for a schema RS =  X  ,  X  is a set of facts of the form r ( t )where r is a relation of arity n in  X  and t is an n -tuple of constants from  X . We denote as r DB the set { t | r ( t )  X  X B} .
A database DB for a schema RS is said to be consistent with RS if it satisfies (in the first order logic sense) all con-straints expressed on RS .
A relational query (or simply query )over RS is a for-mula that is intended to extract tuples of elements from the underlying domain of constants  X . We assume that queries over RS =  X  ,  X  are Unions of Conjunctive Queries (UCQs), i.e., formulas of the form {  X  x | X   X  y 1 . conj  X  X  X  X  X  X   X  y m . conj bols are in  X , and involve  X  x = X 1 ,...,X n and  X  y Y 1 ,...,Y i,n i ,where n is the arity of the query, and each X k and each Y i, is either a variable or a constant in  X .
Given a database DB for RS ,theanswertoaUCQ Q over DB , denoted Q DB ,isthesetof n -tuples of constants c 1 ,...,c n such that, when substituting each X i with c formula  X   X  y 1 . conj 1 (  X  x ,  X  y 1 )  X  X  X  X  X  X  X   X  y m to true on DB .
In this section, we introduce a simple framework for deal-ing with P2P systems. The model is not meant to be a novel comprehensive formalization, since our aim here is to face the problem of finding agreement among peers rather than to investigate new syntactic modeling features.

Therefore, our approach takes basically the same perspec-tive as [9, 11, 5, 17].
A P2P system P is a tuple P, I , N , map ,where P is anon-emptysetofdistinctpeersand I , N and map are functions whose meaning will be explained below. First, each peer p  X  P is equipped with its own data integration system I ( p ), which is formalized as a triple G p , S p
Basically, S p is meant to denote the set of sources to which p is allowed to access and is in fact modeled as a relational schema of the form S p =  X  p ,  X  , i.e., there are no integrity constraints on the sources. The structure of the global schema is, instead, represented by means of the schema G p =  X  p ,  X  p , whereas the relationships between the sources and the global schema are specified by which is a set of local mapping assertions between G p and where Q S p and Q G p are two conjunctive queries of the same arity over the source schema S p and the peer schema G p , respectively.
 Example 1 Let us introduce three peers, namely p 1 , p 2 , and p 3 , that constitute the P2P scenario that will be used as a running example throughout this paper to illustrate technical definitions.

The global schema G p 1 of peer p 1 consists of the rela-tion predicate secretary ( Employee , Manager ) (without con-straints), the source schema S p 1 consists of the relation sym-bol s 1 ,andtheset M p 1 of the local mapping assertions is { X, Y | s 1 ( X, Y ) } { X, Y | secretary ( X, Y ) } .
As for peer p 2 , the schema G p 2 consists of the rela-tion financial ( Employee , Manager ) (without constraints), the source schema consists of the relation symbol s 2 ,and M
The schema G p 3 of peer p 3 consists of the rela-tions employee ( Name , Dept )and boss ( Employee , Manager ), whose set of constraints contains the assertions (quantifiers are omitted) employee ( X, Y )  X  boss ( X 1 ,Y 1 )  X  X = Y 1 and boss ( X, Y )  X  boss ( X 1 ,Y 1 )  X  Y 1 = X , stating that managers are never employees; the source schema S p 3 comprises the relation symbols s 3 ; and, the set of the local mapping asser-tions is { X, Y | s 3 ( X, Y ) } { X, Y | employee ( X, Y )
Each peer p  X  P in a P2P system P = P, I , N , map is also equipped with the neighborhood function N providing a set of peers N ( p )  X  P  X  X  p } containing the peers (called neighbors) who potentially have some information of interest to p . Intuitively, the neighborhood relation determines the structure of a P2P system P . Such a structure is better described by the dependency graph G( P )of P , i.e., by a directed graph having P as its set of vertices and { ( p, q ) q  X  P  X  p  X  X  ( q ) } as its set of edges.

In particular, a peer q is in N ( p )iff p is interested in the data exported by q by means of its global schema, i.e., some of the global relations of p can be populated by means of the data coming from q besides the data coming from the sources of p itself. To this aim, map ( p ) defines the set of peer mapping assertions of p .

Each assertion is an expression of the form Q q Q p , where the peer q  X  X  ( p ) is a neighbor of p ,and Q q and Q are two conjunctive queries of the same arity over schemas G q and G p ,respectively.
 Example 1 (contd.) Let P r = P r , I r , N r , map r be a P2P system, where P r consists of three peers p 1 , p 2 and p 3 , such that N r ( p 1 )= N r ( p 2 )=  X  and N r ( p 3 )= { p 1 ,p 2
Figure 1 summarizes the structure of the system P r by showing, for each peer, its global schema, its source schema, and its local and peer mapping assertions. In particular, notice that the mapping assertions are such that: map ( p 1 )= map ( p 2 )=  X  ,and map ( p 3 )= { X, Y | f inancial ( X, Y )) {
X, Y | boss ( X, Y ) } X  X  X, Y | secretary ( X, Y ) } { X, Y boss ( X, Y ) } .
A source database for a P2P system P is a function D assigning to each peer p  X  P such that I ( p )= G p , S p a database instance D ( p )for S p .

A global database for P is a function B assigning to each peer p a database instance B ( p )for G p . Usually, we are interested in global databases that can be  X  X etrieved X  from a given source, as formalized below.

Given a source database D for P ,a retrieved global database for D is a global database B that satisfies the mapping assertions M p of each peer p , i.e., B is such that:  X  p  X  P and  X  ( Q S p Q G p )  X  X  p , it is the case that Q
We denote by ret ( P , D ) the set of all the retrieved global databases for D in the system P .

Notice that in the definition above we are considering sound mappings: data retrieved from the sources by the mapping views are assumed to be a subset of the data that satisfy the corresponding global relation. This is a classical assumption in data integration, where sources in general do not provide all the intended extensions of the global schema, hence extracted data are to be considered sound but not necessarily complete.
 Example 1 (contd.) Let D r be a source database for the P2P system P r such that D r ( p 1 )is { s 1 ( Albert , Bill ) ( p 2 ) consists of { s 2 ( John , Mary ) ,s 2 ( Mary , Tom ) ( p 3 )= { s 3 ( Mary , D1 ) } . Consider also the global database B r such that B r ( p 1 )= { secretary ( Albert , Bill ) ( p 2 )= { financial ( John , Mary ) , financial ( Mary , Tom ) and B r ( p 3 )= { employee ( Mary , D1 ) } . Then, it is easy to see that B r is a retrieved database for D r in P r , i.e., B r  X  ret ( P r , D r ).

Note that a global database B whose peer schema for some peer p  X  X  p 1 ,p 2 ,p 3 } is a superset of B r ( p )isin ret ( as well -we simply say that B is a superset of B r .
Given a source database D , it is particular important to investigate whether it is possible to retrieve from a database which satisfies the semantics of the network. Therefore, we next define a suitable notion of model for a P2P system. The approach has been inspired by the au-toepistemic approach of [9]; in particular, we assume that peers propagate through mapping assertions only the values they really trust.
 Definition 2 Let P = P, I , N , map be a P2P system, p  X  P a peer with I ( p )= G p , S p , M p and G p =  X  p ,  X  p D a source instance for P . Then, a p -model for P w.r.t. D a maximal nonempty set of global databases M  X  ret ( P , D such that: 1. for each B X  M , B ( p ) satisfies the constraints in  X  2. for each assertion Q q Q p  X  map ( p ), it holds:
Thus, according to Condition 1, any databases in the p -model satisfies all the integrity constraints issued over the global schema of p ; moreover, Condition 2 guarantees that peers communicate only those values that belong to all mod-els, i.e., a cautious approach to the propagation has been pursued. Finally we point out that, as for local mapping as-sertions, peer mapping assertions are assumed to be sound.
Now, given that each peer singles out its models, a notion of model for the whole system can be easily stated. Definition 3 Let P = P, I , N , map be a P2P system. A model for P w.r.t. D is a maximal nonempty set M  X  ret ( P , D ) of global databases such that, for each p  X  is a p -model. If a model for P w.r.t. D exists, we say that D satisfies P ,denotedby D| = P .

For instance, in our running example, D r does not satisfy P r ; indeed, the peer mapping asser-tions constrain the schema of p 3 to contain in ev-ery global database (retrieved from D r ) the tuples employee ( Mary , D1 ) that violate the integrity constraints over p 3 ,since Mary results to be both an employee and a manger. Therefore, retrieving data from D r leads to an in-consistent scenario.

We conclude by noticing that deciding whether a P2P system admits a model can be done efficiently. The result can be proven by modifying the techniques in [9], in order to first evaluate all the mappings in the network and then check for the satisfaction of the integrity constraints over peer schemas.
 Theorem 4 Let P = P, I , N , map be a P2P system, and D be a database instance for P . Then, deciding whether there is a model for P w.r.t. D , i.e., D| = P ,isfeasiblein polynomial time.
As shown in our running example, in general data stored in local and autonomous sources are not required to sat-isfy constraints expressed on the global schema (for example when a key dependency on G is violated by data retrieved from the sources). Thus, a P2P system may be unsatisfiable w.r.t. a source database D . In this section, we face the prob-lem of solving inconsistencies in P2P systems. Specifically, we introduce a semantics for  X  X epairing X  a P2P system. To this aim, we first provide a model for peer preferences, and then show the impact of these individual preferences on the cost of reaching a global agreed repair.
Let P = P, I , N , map be a P2P system, and D be a source database instance for P . Next, we define a repair weighting function w p ( P , D ) for each peer p , encoding its pref-erences on candidate repairs of D . Formally, w p ( P , polynomially-computable function assigning, to each source database instance D , a natural number that is a measure of the preference of p on having D as a repair for D (the lower the number, the more preferred the repair).

As a quite simple, yet natural example of weighting func-tion, we can consider the evaluation of the number of dele-tions performed to the peer X  X  sources. In this case, we responds to the size of the difference between D and D restricted to tuples of peer p . This weighting function is called cardinality-based in the following.
 Example 1 (contd.) Consider the source databases D r 1 ,and D r 3 such that: D r 1 ( p 1 )= D r 2 ( p 1 )= D r 3 ( p 2 )= {} , D r 1 ( p 3 )= {} , D r 2 ( p 3 )= { s 3 ( Mary , D1 ) ( p 3 )= { s 3 ( Mary , D1 ) } .

Assume that, for each peer p , w p ( P r , D r ) ( D )= ( p ) | , i.e., she prefers source repairs where the mini-mum number of tuples is deleted from D r ( p ). Then, w w w
The problem of solving inconsistency in  X  X lassical X  data integration systems has been traditionally faced by pro-viding a semantics in terms of the repairs of the global databases that the mapping forces to be in the semantic of the system [4, 7, 6]. Repairs are obtained by means of addition and deletion of tuples according to some minimality criterion.

We next propose a generalization of these approaches to the P2P framework, which takes into account peers prefer-ences. To this aim, we focus on finding the proper set of facts at the sources that imply as a consequence a global database satisfying all integrity constraints. Basically, such a way of proceeding allows us to easily take into account information on preferences when trying to solve inconsistency, since re-pairing is performed by directly focusing on those sources, whose integration has caused inconsistency.
 Definition 5 (Repair) Let P be a P2P system, p a peer, and D and D two source databases. We say that D is p -minimal if D | = P , and there exists no source database D
Then, D is a repair for P w.r.t. D if D is p -minimal for each peer p .
 Example 1 (contd.) It is easy to see that D r 1 , D r 2 ,and 3 satisfy P r and they are both p 1 -minimal. Indeed, peer w Moreover, D r 1 and D r 2 are equally preferred by p 2 ,whereas 2 and D r 3 are equally preferred by p 3 . Therefore, all peers agree on D r 2 , which is thus a repair for D r w.r.t. P r ever, neither D r 3 is p 2 -minimal, nor D r 1 is p 3 -minimal, and thus they are not repairs.

We next define the semantics of a P2P system, in terms of models for those sources on which all the peers agree. Definition 6 (Agreement) Let P = P, I , N , map be a P2P system, and D be an instance for P .The agreement for P w.r.t. D is the set of all of its models w.r.t. some repair, and will be denoted by Agr ( P , D ).
 Example 1 (contd.) D r 2 is p -minimal, for each peer p , and it is easy to see that the set Agr ( P r , D r tains all databases belonging to some model for P r w.r.t. D r 2 . In particular, it contains the super-sets (satisfying the constraints) of the database such that B r 2 ( p 1 )= { secretary ( Albert , Bill ) } { boss ( Mary , Tom ) , employee ( Mary , D1 ) } . Moreover, no other global database is in Agr ( P r , D r ).

We can finally characterize the answer to a user query in terms of the repairs for the system.
 Definition 7 Let P = P, I , N , map be a P2P system, let D be a source database for it, and let Q be a query over the schema of a peer p . Then, the answer to Q is the eval-uation of the query over all the possible agreed databases:
For instance, in our running example, the answer to the user query { X | boss ( X, Y ) } posed over peer p 3 ,whichasks for all employees that have a boss, is { Albert , Mary } since this query is evaluated over the supersets of the database B r 2 retrieved from D r 2 only.

We conclude the section by noticing that Agr ( P , D )isjust a formal characterization of the semantics of a P2P system. Usually, we are not interested in computing such a set; and, in fact, for practical applications, suitable techniques and optimization algorithms should be investigated to handle inconsistency at query time (in the spirit of, e.g., [10]).
Given the framework presented so far, we are in the po-sition of studying the effects of having autonomous peers repairing their source databases according to their own pref-erences. We next show that, in some cases, peers might not find an agreement on the way the repair has to be carried out. This is a somehow expected consequence of having self-ish interested peers in the absence of a global coordination. Proposition 8 There exists a P2P system P and a source database D such that there is no agreement, i.e., Agr ( P is empty.
 Proof [Sketch] . Consider the P2P system P =
P, I , N , map ,where P consists of the peers challenger (short: c )and duplicator (short: d ), that are mutually con-nected, i.e., N ( c )= { d } and N ( d )= { c } .
 Peer c is such that I ( c )= G c , S c , M c ,wheretheschema G consists of predicates r c ( X )and mr d ( X ) with constraints r ( X )  X  r c ( Y )  X  X = Y and r c ( X )  X  mr d ( Y )  X  X = Y ;the source schema consists of the relation symbol s c ;and M c contains only the assertion { X | s c ( X ) } { X | r c ( X ) Peer d is such that I ( d )= G d , S d , M d ,wheretheschema G d consists of predicates r d ( X )and mr c ( X ) with constraints r ( X )  X  r d ( Y )  X  X = Y and r d ( X )  X  mr c ( Y )  X  X = Y ;the source schema consists of the relation symbol s d ;and M d contains only the assertion { X | s d ( X ) } { X | r d ( X )
Finally, map ( c ) contains the assertion { X | r c ( X )) {
X | mr c ( X ) } , while map ( d ) contains the assertion r ( X )) } { X | mr d ( X ) } .

Let D be a source database for P such that D ( c )= { s c (0) ,s c (1) } and D ( d )= { s d (0) ,s d (1) } . We build four source databases, say D 1 , D 2 , D 3 and D 4 ,thatsatisfy P .Theyaresuchthat: D 1 ( c )= {} , D 1 ( d )= { s d (0) } ; D ( c )= {} , D 2 ( d )= { s d (1) } ; D 3 ( c )= { s c (0) D ( c )= { s c (1) } , D 4 ( d )= {} . Notice that all the other databases satisfying P are proper subsets of these ones. Then, by assuming that each peer wants to minimize the number of deletions in D , there exists no source database satisfying P that is both c -minimal and d -minimal.
In the light of Proposition 8, it is particulary relevant to investigate the complexity of dealing with peer agreements and query answering in such P2P data integration systems. In this section, we first present some basic problems arising in the proposed framework, and subsequently analyze their computational complexity. This analysis is a fundamental premise to devise effective and optimized implementations.
Given a P2P system P and a source database D for P ,we consider the following problems:
Intuitively, RepairChecking is the very basic problem of assessing whether a source instance at hand satisfies the data integration system. Then, AgreementExistence (and its corresponding computa-tional version AnyAgreementComputation ) asks for singling out scenarios where some agrement can be in fact com-puted. Finally, QueryOutputTuple represents the problem characterizing the intrinsic complexity of a query answering in the proposed framework; indeed, it is the problem of deciding the membership of a given tuple in the result of query evaluation.
Our first result is that checking whether all the peers are satisfied by a given source database is a difficult task that is unlikely to be feasible in polynomial time.
 Theorem 9 RepairChecking is co-NP-complete. Hardness holds even for cardinality-based weighting functions. Proof [Sketch] . Membership. Consider the complemen-tary problem of deciding whether there exists a peer p such that D is not p -minimal. This problem is feasible in NP by guessing a source database D and checking in that 1. D | = P ,and 2. there exists a peer p such that w polynomial time because of Theorem 4, and 2. is feasible in polynomial time because our weighting functions are poly-nomially computable.

Hardness. Recall that deciding whether a Boolean for-mula in conjunctive normal form  X  = C 1  X  ...  X  C m over the variables X 1 ,...,X n is not satisfiable, i.e., deciding whether there exists no truth assignments to the variables making each clause C j true, is a co-NP-hard problem.

We built a P2P system P  X  such that: P  X  contains a peer x i for each variable X i , a peer c j for each clause C j ,and the distinguished peer e . The source schema of x i (resp. c consists of the unary relation s x i (resp. s c j ), whereas the global schema consists of the unary relation r x i (resp. r Thesourceschemaof e consists of the unary relations s e and s , whereas its global schema consists of the unary relations r and r a . For each source relation, say s , P ( X ) contains a local mapping assertion of the form { X | s ( X ) } { X r ( X ) } . Each global relation of the form r x i is equipped that each relation must contain one atom at most. Each global relation of the form r c j is equipped with the con-straint r c j ( tx i )  X  r c j ( fx i )  X  X  X  ,where  X  is the empty dis-junction, stating that for each variable x i , r c j cannot con-tain both tx i and fx i at the same time. Moreover, peer e has also the constraint r e ( X 1 )  X  r a ( X 2 )  X  X 1 = X 2 . Consider the source database D  X  for P  X  such that: D  X  ( x i )= { s x i ( tx i ) ,s x i ( fx i ) } ;foreach x in c j , D  X  ( c j )= { s c j ( tx i ) ,s c j ( fx i ) } ;and { s sued over peers schemas, any source database D ,with D | = P  X  , is such that |D ( x i ) | X  1, for each x i .There-fore, the restriction of D to the peers of the form x i is in one-to-one correspondence with a truth-value assignment for  X , denoted by  X  ( D ). Intuitively, the atom s x i ( tx i s x i ( fx i )) means that variable X i is set to true (resp. false), whereas the atom s c j ( tx i ) means that the clause C j witnessed by the assignment for the variable X i occurring in c j .

Finally, the peers mapping assertions in P  X  are de-fined as follows. For each variable X i occurring posi-tively (resp. negatively) in the clause C j there are ex-actly two mappings of the form { r x i ( tx i ) } { r c j { r C j containing variables X j 1 , ..., X j k , there exists a mapping { r Figure 2 shows on the upper part the dependency graph G(  X  X 4 )  X  ( X 4 )  X  (  X  X 5  X  X  X 6  X  X 7 )  X  ( X 4  X  X 6  X  X 8 ).
Assume that each peer wants to minimize the number of deletions in D  X  . Then, given a source database D mini-mal w.r.t. each peer in P  X  but e , we can show that the above mappings encode an evaluation of the assignment  X  (
D ). In particular, it is easy to see that  X  ( D ) is a satisfy-ing assignment for  X  if and only if D ( e )containsthefacts { s e ( t ) ,s a ( t ) } , i.e., one fact is deleted from the source of e only. Assume, now, that D is such that D ( e )= { s e ( f ) i.e., two facts are deleted from the source of e . Then, D also e -minimal if and only if  X  is not satisfiable. Given the above complexity result, one can easily see that AnyAgreementComputation is feasible in the functional ver-sion of  X  P 2 . Indeed, we can guess in NP a source instance D , build in polynomial time a model B for P w.r.t. D (by construction in Theorem 4), and check in co-NP that D is minimal for each peer.

Actually, we can do much better. In fact, we next show that the problem is complete for the polynomial time closure of NP, and thus remains at the first level of the polynomial hierarchy.
 Theorem 10 AnyAgreementComputation is FP NP -complete. Hardness holds even for cardinality-based weighting functions.
 Proof [Sketch] . Membership. The problem can be solved by processing peers in a sequential manner. For each peer in P , we can find the minimum value of the associated prefer-ence function by means of a binary search, in which at each step we guess in NP a database instance and verify that such a preference holds. After having collected the mini-mum values for all peers, we conclude with a final guess to get a repair D , and a subsequent check that actually each peer gets its minimum possible value for P w.r.t. D . Figure 2: Constructions in Proofs of Complexity Re-sults.

Finally, a model for P w.r.t. D can be build in polynomial time (again, by construction in Theorem 4).

Hardness. Let  X  be a boolean formula in conjunctive nor-mal form  X  = C 1  X  ...  X  C m over the variables X 1 ,...,X Assume that each clause, say C j , is equipped with a weight w j (natural number). Let  X  be an assignment for the variables in  X . Its weight is the sum of the weights of all the clauses satisfied in  X  . The problem of comput-ing the maximum weight over any truth assignment, called MAX  X  WEIGHT  X  SAT ,isFP NP -complete.

Consider again the construction in Theorem 9, and mod-ify P  X  as follows. The source schema of peer e con-sists of the relation s w , whereas its global schema con-sists of the relations r w and r v , and of the constraint r ( X )  X  r w ( X, Y )  X  X  X  . The local mappings of e is { X, Y s ( X, Y ) } { X, Y | r w ( X, Y ) } . Moreover, for each clause c over variables X j 1 , ..., X j k , map ( e ) contains the assertion { r amodified P2P system. Notice that G(  X  P  X  )coincideswith G( P  X  ) (see again Figure 2).

Consider now the database instance  X  D  X  for  X  P  X  obtained by modifying D  X  such that  X  D  X  ( e ) contains the atoms s itively, peer e stores w j distinct atoms for each clause c
Let D be a source instance that satisfies  X  P  X  .AsinThe-orem 9, the restriction of D over the variables is in one-to-one correspondence with a truth assignment for  X , denoted by  X  ( D ). Then, it is easy to see that peer e must delete in D all the w j distinct atoms corresponding to a clause C j that is not satisfied by the assignment  X  ( D ). There-fore, |D ( e ) | = i |C i is false in  X  ( D ) w i .Hence,theresult easily follows, since computing the source instance that is e -minimal, say D , determines the maximum weight over any assignment for  X  as ( i w i )  X  X  D ( e ) | .

We next focus on the AgreementExistence problem. Note that membership of this problem in  X  P 2 is easy to proven, after the above theorem. However, the reduction for the hardness part we shall exploit here is rather different. Theorem 11 AgreementExistence is  X  P 2 -complete. Hard-ness holds even for cardinality-based weighting functions. Proof [Sketch] . Membership is shown with the same line of reasoning of Theorem 10. For the hardness, consider again MAX  X  WEIGHT  X  SAT ,andthe X  P 2 -complete problem of decid-ing whether it has a unique solution.

Let  X  P  X  be the P2P system built in Theorem 10, and let  X  P
 X  be a copy of it, obtained by replacing each element (both relations and peers) r in  X  P  X  by r . Then, consider the system  X  P  X  obtained as the union of  X  P  X  ,  X  P  X  and a fresh peer u . Figure 2 shows the dependency graph G(  X  P  X  ).
The local schema of u is empty, while its global schema consists of the unary relation r u with the constraint =1 r u ( bad i )  X  X  X  . The mapping assertions are as follows. For each variable X i in  X , map ( u )contains { r x i ( tx r { r u ( bad i ) } . It is worthwhile noting that, for the sake of simplicity, the mapping assertions are slightly more general than those allowed in the usual definition of P2P systems, since they involve joins among different peers. However, this is only a syntactical facility, as such a mapping can be easily simulated by introducing a suitable dummy peer.

The idea of the reduction is that, if the same assignment that maximizes the weight of the satisfied clauses is selected i ), thereby violating the constraint. Thus, there is a (non-empty) agreement in  X  P  X  if and only if there are at least two such assignments.

We conclude our investigation by observing that query answering is at least as hard as AgreementExistence .In-deed, intuitively, if peers are not able to find an agreement in an inconsistent P2P system, then the answer to any given query will be empty. Moreover, membership can be proven by the same line of reasoning of Theorem 10, and we thus get the following result.
 Theorem 12 QueryOutputTuple is  X  P 2 -complete. Hard-ness holds even for cardinality-based weighting functions.
In this paper, we investigated some important theoreti-cal issues in P2P data integration systems. Specifically, we introduced a setting in which peers take into account their own preferences over data sources, in order to integrate data if some inconsistency arise. This seems a natural setting for such kind of systems, which has not been previously investi-gated in the literature. It turns out that there are scenarios where peers do not find any agreement on the way the repair should be carried out, and where some kind of centralized coordination is required.

Actually, our results show that this coordination comes with a cost and some basic problems are unlikely to be tractable. However, the complexity of the problems studied in this paper are only mildly harder than the corresponding problems in traditional data integration systems.
This is an important feature of our approach, that paves the way for possible easy implementations, based on avail-able systems.

In particular, the prototypical implementation appears vi-able with minor efforts if done on top of integration systems that exploit a declarative approach to data integration (e.g., [18], where logic programs serve as executable logic specifi-cations for the repair computation). Indeed, our complexity results show that logic engines able to express all problems in the second level of the polynomial hierarchy, such as the DLV system [19], suffices for managing the framework, once we provide appropriate logic specifications.

A number of interesting research questions arise from this work. First, it is natural to ask whether the framework can be extended to the presence of existentially quantified constraints. This can be easily done for some special syn-tactic fragments, such as for non key-conflicting schemas, i.e., global schemas enriched with inclusion dependencies and keys, for which decidability in the context of data inte-gration systems has been proven in [7]. To this aim, one has to modify the algorithm in [9] to propagate information in a P2P system by accounting for mapping assertion as well as for inclusion dependencies, and eventually check that after such propagation no key has been violated.

We conclude by noticing that an avenue of further research is to consider more sophisticated peer-agreement semantics, besides the Pareto-like approach described here. For in-stance, we may think of some applications where peers may form cooperating groups, or do not cooperate at all. An-other line of research may lead to enrich the setting by fur-ther kinds of peer preferences criteria, by replacing or com-plementing the weighting functions proposed in this paper. The work was partially supported by the European Com-mission under project IST-2001-33570 INFOMIX.
 Francesco Scarcello X  X  work was also supported by ICAR-CNR, Rende, Italy. [1] Serge Abiteboul, Richard Hull, and Victor Vianu. [2] Marcelo Arenas, Leopoldo E. Bertossi, and Jan [3] P. Bernstein, F. Giunchiglia, A. Kementsietsidis, [4] Leopoldo Bertossi, Jan Chomicki, Alvaro Cortes, and [5] Leopoldo E. Bertossi and Loreto Bravo. Query [6] Loreto Bravo and Leopoldo Bertossi. Logic [7] Andrea Cal`  X , Domenico Lembo, and Riccardo Rosati. [8] Andrea Cal`  X , Domenico Lembo, and Riccardo Rosati. [9] Diego Calvanese, Giuseppe De Giacomo, Maurizio [10] Thomas Eiter, Michael Fink, Gianluigi Greco, and [11] Enrico Franconi, Gabriel Kuper, Andrei Lopatenko, [12] Enrico Franconi, Gabriel Kuper, Andrei Lopatenko, [13] Enrico Franconi, Gabriel Kuper, Andrei Lopatenko, [14] Gianluigi Greco, Sergio Greco, and Ester Zumpano. A [15] Gianluigi Greco and Domenico Lembo. Data [16] Alon Y. Halevy, Zachary G. Ives, Peter Mork, and [17] Maurizio Lenzerini. Quality-aware peer-to-peer data [18] Nicola Leone, Thomas Eiter, Wolfgang Faber, Michael [19] Nicola Leone, Gerald Pfeifer, Wolfgang Faber, [20] Luciano Serafini, Fausto Giunchiglia, John [21] Igor Tatarinov and Alon Halevy. Efficient query
