 This paper presents GuLP a graph query language that en-ables to declaratively express preferences. Preferences en-able to order the answers to a query and can be stated in terms of nodes/edge attributes and complex paths. We present the formal syntax and semantics of GuLP and a polynomial time algorithm for evaluating GuLP expressions. We describe an implementation of GuLP in the GuLP-it system, which is available for download. We evaluate the GuLP-it system on real-world and synthetic data.
 H.2.3 [ DATABASE MANAGEMENT ]: Languages; H.2.4 [ DATABASE MANAGEMENT ]: Systems Graph Query Languages; Preferences  X  X  like Rock music better than Pop X . This is a natural and intuitive way of expressing preferences. The underlying se-mantics of the  X  X etter than X  tells us that not only we prefer Rock music to Pop but also that sometimes we may listen to Pop music. Generally speaking, this kind of preferences are said to be qualitative as opposed to quantitative. The differ-ence consists in the fact that in the first case we are specify-ing a particular musical gender while in the second case the specification has to be accompanied by a quantitative esti-mation (e.g., Rock 0.7, Pop 0.3). Qualitative preferences are strictly more general than the quantitative ones; this is be-cause it is always possible to  X  X onvert X  scores into preference relations but not vice versa [6]. Expressing preferences is of paramount importance in many fields and especially when dealing with large volumes of data (e.g., [10, 16, 20, 19]). In-stead of providing a huge and unordered result set, it is more useful to provide a way to distinguish between more and less preferred answers. This fostered research in database the-ory about how to incorporate preferences in query languages (e.g., Kiessling [14] Chomicki [7]).

Although relational databases maintain an important role in data-intensive tasks, we are assisting to a deluge of data represented as graphs. Graphs are a powerful data structure enabling to represent in a natural way objects along with their relations. Social networks, biological networks and projects such as the Google Knowledge Graph and Linked Data on the Web [5], give just a glimpse of the magni-tude and spread of graph-like data. Hence, as in the re-lational world, the problem of expressing preferences is be-coming more and more relevant. Despite the variety of graph query languages and tools today available (see Angles and Gutierrez [2] and Wood [22] for comprehensive surveys), lit-tle has been done in terms of specific features enabling to express preferences. Some approaches have been proposed that enable expressing quantitative preferences only over graph edges (e.g., [13]). Other initiatives consider qualita-tive preferences and distinguish levels of preference by means of partial orders (e.g., [12]). Besides, the simple data model (i.e., graphs with no attributes) and query language (i.e., standard regular expressions) considered, these approaches do not enable to express complex preferences. Last but not least, we are not aware of any implementation of graph query languages with preferences.

In this paper we focus on the following research questions: why are preferences useful in a graph query language? How to declaratively express preferences? At which level of gran-ularity the user should be able to express preferences (e.g., only edges, entire paths, attributes)? Is it always useful to embed preferences in the language or in some cases it is better to execute a set of queries each expressing a level of preference?
Having preferences in a graph query language enables to drive the evaluation to consider some paths before than oth-ers thus introducing an ordering on the way results are col-lected and presented. This functionality is useful when one is interested in certain kinds of results more than in others and is crucial when dealing with large graphs. Motivated by this consideration, we face the problem of embedding pref-erences in a declarative language on the form of edge types, node and edge attributes and entire paths. To enable such a rich variety of preferences we introduce the operator in graph navigational languages. As underlying data model we consider attributed graphs that generalize other models by enabling attributes on both nodes and edges.
An example of attributed graph is depicted in Fig. 1, where nodes represent different kinds of objects such as per-sons or publications, node attributes allow to specify their properties, edges represent the relations between objects and edge attributes enable to further refine these relations. Given a graph (e.g., Fig. 1), one would like to pose queries like  X  X ind all the co-authors of Jack X  or  X  X eople known by Jack or by someone Jack knows X  . These are typical reachability queries asking for the existence of paths from a source node (i.e., Jack ) toward other nodes. This kind of requests can be fulfilled by one of the existing graph query languages [2, 22]. However, current languages do not enable to pose re-quests such as  X  find papers authored by someone related to Jack that published at CIKM but prefer Jack X  X  co-authors to persons merely known by Jack  X .
 The aim of this paper is to present GuLP (Graph Query Language with Preferences) that enables to fulfill such kinds of requests. In the previous examples, with GuLP one would obtain first the set { Paper2, Paper3, Paper5 } and then { Paper4 } . The flexibility of GuLP enables to declara-tively specify preferences in terms of path types (e.g., prefer co-author edges to knows edges), node and edge attributes (e.g., prefer professors to PhD students or co-authors with 3 papers). The benefit of a system implementing GuLP is twofold. First, it enables to present results according to user preferences declaratively specified. Second, the system could implement an any-time behavior. This means that the user can start receiving the most preferred results and stop the system at any point of the computation.
To give a hint on the features of GuLP we discuss some examples considering the graph in Fig. 1. The formal syntax and semantics of GuLP are introduced in Section 3.

Example 1.1. ( Preference based on path labels ) Find papers published by persons linked to Jack by only co-author or only knows paths giving preference to co-author paths. The request in the previous example differs from a classical reachability query in one important respect: it defines a preference, which enables to distinguish nodes in the results. In
GuLP it can be expressed as follows:
In the expression, the operator ( pref 1 ,pref 2 ,...pref used to declaratively specify preferences. Generally speak-ing, each pref i can be an edge type, a path or a test over node or edge attributes. In this example paths defined by co-author  X  are preferred to those defined by knows  X  . Hence, two levels of preference are defined; the first is associated to the expression co-author  X  /author while the second one is associated to knows  X  /author .

The evaluation of a GuLP expression returns an ordered list L of sets of nodes. Each set in the list maintains nodes that have been reached at a certain level of preference. Moreover, each node in the results only appears in the high-est preference set. The result of the evaluation is L = [ Pref1 : { Paper1 , Paper2 , Paper3 , Paper5 } , Pref2 : { Paper4 } ]. Note that the node labeled as Paper1 can be reached in both levels of preference (i.e., via both types of paths) but it is considered only at the highest level.

Example 1.2. ( Preference based on edge and node attributes ) Find conferences to which the co-authors of Ra-jya have published and present these conferences first by the co-authorship degree and then by the type of publication. This request defines preferences through a combination of edge attributes, to define the co-authorship degree, and node attributes to prefer conferences on the basis of the kind of paper published. If Full Papers are preferred to Posters , the specification in GuLP is:
The evaluation of the first part of the expression starting from the node Rajya distinguishes nodes reachable consider-ing the preference (defined via ) on the attribute papers of coauthor edges. The most preferred nodes are those reach-able via coauthor edges having the attribute papers &gt; 1; then, nodes where the same edge attribute is equal to 1 are considered. The evaluation continues with the second part of the expression where the node attribute type , reached via author edges, is used for expressing preferences. The last part considers conference nodes reachable through an edge published . Fig. 2 provides a high level overview of the evaluation of this expression. By looking at Fig. 2 one would be tempted to rewrite a GuLP expression with preferences into set of expressions without preferences and then evaluate them separately. As we will show in Section 5 (Experiment 2) this approach has an exponential running time while GuLP expressions can be evaluated in polynomial time.

Example 1.3. ( Preference based on edge and node attributes plus nesting ) Find papers, published in 2012, by someone who published at least one paper at CIKM and is linked to Jack by a path of co-author edges or knows edges. Give preference to the first type of paths.
 This request involves preferences and nesting and can can be specified in GuLP as follows: The result of the evaluation of the subexpression co-author is Pref1 = { Jack , Rajya , Marco } . As for the subexpression knows  X  the result is Pref2 = { Mike , Jose } . Results at each of the two levels of preference are filtered via the nested ex-pression [ author / published . { name = X  X IKM X  } ], which keeps only authors of CIKM papers. After the evaluation of the nested expression we have at the first level of preference Pref1 = { Jack , Rajya , Marco } , since Jack authored Paper1 and Paper2 , Rajya Paper2 and Marco Paper3 , all published at CIKM. As for the second level of preference, GuLP dis-cards Mike since he did not publish any paper at CIKM, and keeps only Jose who authored Paper4 , thus obtaining Pref2 = { Jose } . The evaluation of the subexpression au-thor considers all the papers of such persons thus giving Pref1 = { Paper1 , Paper2 , Paper3 , Paper5 } , Pref2 = { Paper4 } . The last nested expression discards all papers that have not been published in 2012, giving: Pref1 = { Paper5 } , Pref2 = {} .
The problem of expressing preferences has been addressed in [8, 10]. Foundational preference frameworks for databases have been introduced in [7, 14, 16, 20]. The aim is to en-able to express preferences over tuples. Although these ap-proaches were source of inspiration for our preference frame-work, our departure point is different: we focus on defining a declarative language for querying graphs with preferences while these approaches focus on how to compute preferred tuples given preferences on attributes (not entire complex paths). Limited form of preferences have been considered for XPath (e.g., [1, 15]). As for graphs, despite the variety of graph query languages and tools today available [2, 22], little has been done in terms of specific features enabling to express preferences. Let X  X  look at the limitations of the state of the art by considering the graph in Fig. 1. Al-most all graph languages (e.g., [17]) enable to fulfill requests such as  X  X ind the conferences where co-authors of Rajya have published X  where all nodes reachable are considered equally preferable. However, when it comes to requests such as  X  X re-fer conferences held in 2012 and then those held in 2010 X  or  X  X ind people connected to Mike but prefer first professors he knows and then people he supervises X  current approaches fail short. Vidal et al. [21] define a method based on a heuristic to chose paths from a graph. This method does not al-low to declaratively express preferences. Grahne et al. [13] presented an approach, which enables the user to assign nat-ural numbers (i.e., quantitative preferences) to graph edges and compute the answer in terms of weighted paths. As for the previous examples, this approach does not enable to express preferences in terms of node and edge attributes. Moreover, no preferences over whole paths can be expressed. Flesca and Greco [12] introduced partially ordered regular languages with which it is not always possible to obtain a unique ordering of the results. Besides, the data model con-sidered and the language are less expressive than those con-sidered in this paper. For instance with this approach it is not possible to express requests such as  X  Find papers, pub-lished in 2012, by someone who published at least one paper at CIKM and is linked to Jack by a path of coauthor edges or knows edges. Give preference to the first type of paths  X .
This analysis motivates the need for a comprehensive so-lution to the problem of declaratively expressing preferences in graph languages. We identified the following desiderata in designing GuLP : i) declarative specification : the user should declaratively express preferences so that nodes in the an-swers to a query can be presented in order of preference; ii) rich preference model : preferences should be expressed at various levels ranging from simple edge types to node and edge attributes and entire paths; iii) efficiency : GuLP expressions should be evaluated with a low polynomial com-bined complexity.
The following are the main contributions of this paper: 1. We introduce GuLP (Graph Query Language with Pref-2. We provide a simple and concise syntax and a clear 3. We devise an algorithm to evaluate GuLP expressions 4. We implement GuLP in the GuLP-it system available 5. We evaluate GuLP-it on both real-world and syn-
The paper is organized as follows. Section 2 introduces the data model and provides an overview on graph query lan-guages based on regular expressions. In Section 3 GuLP is introduced: syntax, semantics and the preference operator. Here it is also discussed the pseudo-code of the algorithm for evaluating GuLP expressions and its complexity analy-sis. Section 5 discusses the implementation and evaluation of GuLP on both a real-world and synthetic datasets. Finally, Section 6 concludes the paper and sketches future work. Data Model. An attributed graph is a directed labeled multi-graph of the form G =  X  X  , E , F n , F e , A , V n , V N is a set of nodes, E a set of edges and A a set of attribute types. An edge e  X  E is a triple of the form  X  n out , X  e where n out and n in are the outgoing and ingoing nodes and  X   X   X  is the label associated to e from a finite alphabet  X . The function F n : N  X  2 A assigns to each node a subset of attributes in A . Similarly it does F e : E  X  2 A for edges. Function V n assigns to each pair ( n,a ) s.t. n  X  N and a  X  F ( n ) the value of attribute a for node n . Similarly it does V e for edges. As an example F n assigns to the node Conf1 in Fig. 1 some attributes such as location and year , and V n assigns the value Glasgow to the pair ( Conf1 , location ) and the value 2011 to the pair ( Conf1 , year ). The func-tions F e and V e do the same for labeled edges e.g., the edge published , between Paper2 and Conf1 , has attribute track with value Privacy .
 Languages based on Regular Expressions. In this pa-per we focus on the family of reachability queries. Essen-tially, a reachability query aims at selecting nodes in the graph that are reachable from a given node via paths (i.e., strings obtained by concatenating edge labels) that belong to the language of regular expressions defined over  X . As an example, the query knows  X  starting from Jack in the graph in Fig. 1 enables to reach the nodes Mike and Jose . The reader can refer to [2] for further details. In particular, we consider Nested Regular Expressions (NREs) [17] as back-bone for the GuLP language.
GuLP is a graph query language for attributed graphs that enables expressing preferences via the preference oper-ator . In this section we present the syntax and semantics of the language.
The syntax of GuLP is reported in Table 1. The building blocks of a GuLP expression are edge labels and tests over attribute values. The symbol is a wildcard to indicate any edge label. Paths can be preference paths ( ppath ), that con-tain the preference operator , or standard paths ( spath ) that can be nested. A preference path is an expression of the form ( ppath 1 ,..., ppath k ) where the various ppath are given in order of preference.
 ppath ::= spath | ppath / ppath | ( ppath )  X  | ppath [ spath ] spath ::= edge | spath / spath | spath | spath | ( spath ) edge ::= label | label { test } label ::= l | l  X  1 | |  X  1 test ::= attr oper value | test  X  test | test | test oper ::= &gt; | &lt; | = |6 = To introduce the semantics of the language, reported in Table 2, consider the following expression ( ppath 1 , ppath The meaning of this expression recalls that of  X  ppath 1 bet-ter than ppath 2  X  in natural language, that is,  X  X  prefer to see nodes reachable from a given node n via ppath 1 and then (separately) I also like to see nodes reachable via ppath 2  X . This corresponds to define two levels of preference: one for the set of nodes reachable via ppath 1 and one for the set of nodes reachable via ppath 2 (and not ppath 1 ). At each of the two levels of preference there can be more than one node and the same node cannot belong to more than one level of preference. This reasoning can be generalized to expressions of the form ( ppath 1 ,..., ppath n ).

To deal with tests on node/edge attributes, an auxiliary function EvalT is exploited, which checks that the attributes match the criteria expressed in test . As anticipated earlier, given a GuLP expression e , an attributed graph G and a seed node n , the evaluation of e over G from n returns a list L of sets of nodes, reachable from n , where each set maintains nodes at a certain level of preference. To refer to that  X  i,j L  X  i  X  X  X  L  X  j  X  =  X  . Hence, the evaluation of a expression returns not only the most preferred results, but also results at lower levels of preference. In the case of a standard path ( spath ), that is, no preferences, there will be only one set. To give a hint of how the preference operator works, consider the following expression: where Jack is the seed node. When evaluating this expres-sion on the graph reported in Fig. 1, nodes reachable via an edge co-author or an edge knows , that is, { Rajya,Mike } are equally preferable. Starting from { Rajya,Mike } , Jose is reached via the more preferable edge knows while Rajya via the less preferable edge supervises . Overall, the result consists in two sets S 1 = { Jose } and S 2 = { Rajya } with nodes in S 1 being more preferable than nodes in S 2 .
The semantics of a GuLP expression recalls that of a total order; each pair of nodes appearing in some sets in L can be compared. We say that a node n q  X  L  X  i  X  is preferred to another node n r  X  L  X  j  X  , denoted by n q n r , if i &lt; j . Two nodes are equally preferable, denoted by n q  X  n r , if i = j (i.e., they belong to the same set). The rational behind using a total order stems from the following observation: when a user queries a search engine, his preferences (i.e., keywords) are matched against a collection of documents with relevant documents presented as a totally ordered set. We apply the same reasoning here with the difference that GuLP instead of keywords deals with regular expressions and instead of a set of documents returns a list of sets of nodes.
If one considers a partial order over the results then this reasoning does not apply any more since not all nodes are comparable [12]. As it can be observed in Table 1, there is a distinction between ppath and spath since the operator is not allowed in nested expressions and expressions involving union. We motivate this choice in the following.
 Preferences in nesting. We consider the original seman-tics of NREs according to which a nested expression in-cluded between [ ] corresponds to an existential test. This amounts at checking whether the result of this expression is not empty. With this reasoning, the evaluation of an ex-pression of the form [ ( ppath 1 ,..., ppath k )] would check if some results exist (no matter their preference level). There is another possible semantics for handling preferences in the nesting: the evaluation of [ ( ppath 1 ,..., ppath k )] outputs the highest level of preference for which some results exist. This allows to order the results also on the basis of the nested expressions. In the current implementation we consider the first semantics and leave the second one as future work. Union of preferences. Expressions dealing with the union of preference paths are not allowed as they violate the to-tal order induced by . Consider the following expression evaluated over the graph in Fig. 1: The operator | represents the union of the results of the two sub-expressions. From the first, we obtain a list of two sets L =[ { Paper2,Paper5 } , { Paper3 } ]. The second one produces only one set L 2 =[ { Paper4 } ]. As it can be noted, it is not possible to perform the union while preserving the properties of the total order imposed by the operator. For instance, nothing can be said about the level of preference of Paper4  X  L  X  0  X  w.r.t. elements in L 1  X  0  X  and L 1  X  1  X  . Why embedding the operator in the language? The motivation is threefold: i) GuLP is able to return re-sults already ordered in different levels of preference when evaluating an expression. If one wanted to apply preferences after collecting the results it would be necessary to  X  X emem-ber X  all the paths toward some result, which hinders the complexity of the language [4]; ii) the declarative specifica-tion of preferences enables to distinguish the preferred parts within the whole answer set beforehand; iii) an any-time implementation of the GuLP language gives to the user the possibility to stop the evaluation after receiving enough pre-ferred results without the need to collect all the results and then apply the preferences. This is useful when dealing with large graphs or Web navigational languages [11].
This section presents a polynomial algorithm for the eval-uation of GuLP expressions. In the following we indicate by e a GuLP expression that may contain the preference operator and by e an expression without preferences.
The evaluation of a GuLP expression starts by invoking the function Evaluate . It receives in input an attributed graph G , a GuLP expression e and a seed node n (given as I=[ { n } ]). The result of the evaluation is a list of sets of nodes Res where each set represents a level of preference and maintains nodes that are equally preferable. The pref-erence order among sets is kept by their position in the list (i.e., nodes in the set S i are preferred to node in the set S if i &lt; j , where i and j are the positions of the sets S S j in the list). If an expression is of the form ( e )  X  , that is, it includes the Kleene * operator, Evaluate calls the func-tion Closure . If this is not the case then the expression is handled by calling the function Base . The function Base called for each set S in the input I . The two main functions by which the order among results is maintained are:  X  append &amp; Remove ( L 1 ,L 2 ): it appends at the end of the  X  append &amp; Merge ( L 1 ,L 2 ): similar to the previous one with Algorithm 1 Evaluate Algorithm 2 Closure Algorithm 3 Base The basic functions used by Base and Closure are:  X  test &amp; Prune ( L,test ): remove from L all the nodes n  X  remove ( S,L ): remove from the set S all the nodes n  X  remove ( L,n ): remove from the list L the node n if it
The evaluation of e occurs from the highest preference level to the lowest. When evaluating an expression e it is necessary to avoid to evaluate the same sub-expression mul-tiple times starting form the same node. Hence, for each expression e i evaluated from a node n , the algorithm asso-ciates to the pair  X  n,e i  X  the preference level p at which n has been reached from a possible previous step in the evalu-ation. This way, if n is reached multiple times for the same or a lower preference level, e i will not be evaluated again. This is because, nodes reachable from n according to e have already been considered at a higher preference level. We focus on the following two problems.
 Problem 1 : Preference Checking
Input : An attributed graph G , a GuLP expression e , two pairs ( n,a ), ( n,b ) Question : Is ( n,a ) ( n,b ) ? Output : Yes or No
The Preference Checking problem takes in input two pairs of nodes, where n is the starting node, and checks whether the first is preferred to the second. Note that it makes sense to define such a problem only if considering the same starting node for both pairs. The second problem concerns the computation of the actual solution.
 Problem 2 : Preference Computation
Input : An attributed graph G , a GuLP expression e a starting node n
Output : List of set of nodes { S 1 , S 2 ,... S k } s.t.  X  n
S , n 2  X  S j : n 1 n 2 if i &lt; j and n 1  X  n 2 if i = j
Here, the problem is to compute a list of sets of nodes, where each set contains nodes reachable at the same level of preference from a starting node n given a GuLP expression e . In the following we prove that both problems can be efficiently solved. We assume that the graph G is stored by its adjacency list; for each node n a list of pairs ( edg,n is maintained, where edg is an edge id and n 0 is the node reachable by navigating edg . Given a node id its adjacency list can be accessed in time O (1). To make efficient the nav-igation of edges in the reverse direction (i.e., l  X  1 in Table 1), an additional data structure is maintained. Edge labels and attributes are maintained in a separate data structure that can be accessed in constant time through the edge id . Same reasoning applies for node attributes. Such an approach maintains the graph topology and the attributes separate. This is useful to leverage a secondary memory data structure (e.g., an index) to maintain attributes.

Let |G| be the size of the adjacency list representation of the graph G plus the size of the tables for storing at-tributes (note that |G|  X  |N| , where |N| is the number of nodes). Let | e | be the size of a GuLP expression. Both the Preference Checking and the Preference Computa-tion problem can be solved in polynomial time in the size of the attributed graph G and GuLP expression e . We have:
Theorem 4.1. The function Evaluate solves Prefer-ence Computation in polynomial time in |G| and | e | .
Proof. (Sketch). Let L be the list of sets of nodes pro-duced by Evaluate . We first sketch the proof of the cor-rectness of the algorithm. We start with priority between nodes n i and n j in the same set. Recall that nodes in the same set belong to the same preference level. This is be-cause n i and n j are reachable from the starting node via two paths p i and p j for which tests on node/edge attributes are satisfied. Moreover, either p i and p j spell two strings that are equal or the two strings belong to the union of languages generated via the operator | . We now discuss pri-ority between sets in L . Sets of nodes are added to L by Evaluate , Base and Closure by append &amp; Remove and append &amp; Merge ; these functions always append new sets to the end of the list by first deleting duplicates. e is evalu-ated from left to right and subexpressions appearing to the left are always preferred to those appearing to the right. Hence, append &amp; Remove and append &amp; Merge maintain the total order of the results. We have now to show that proce-dure Evaluate runs in polynomial time.
 Case 1: Preference and nesting free . This is the case in which e is a standard regular expression plus tests on attributes. Since there are no preferences, the result con-sists in one set of nodes, that is, nodes reachable from a seed node n via paths belonging to the language of the ex-pression for which tests on node and edge attributes are satisfied. The function Evaluate is recursively called on all sub-expressions of e . If these sub-expressions do not contain the Kleene operator, this procedure is invoked re-cursively at most O ( | e | ) times and the base cases (lines 22-29 of function Base ) require to check at most all the edges for all the nodes and testing attributes. This can be done in time O ( |G| ). If the Kleene operator is present, the function Closure is executed at most O ( |N| ) times (if at each recursive call to Closure only one node is produced in output). The Evaluate procedure invoked from Clo-sure is recursively called at most O ( | e | ) times. Since the base cases cost O ( |G| ), each call to Closure costs at most O ( |G| X | e | ) thus requiring polynomial time.

Case 2: Preference free . The expression e is a nested regular expression with tests on attributes. In this case, the procedure Evaluate is called at line 19 of the func-tion Base at most | e | times for each node. Let e i = e be a sub-expression containing another nested sub-expressions (i.e,. e 2 ). To evaluate e i , e 1 has to be evaluated with a cost polynomial in |G| and | e 1 | . Then, for each node in the results of e 1 , e 2 is evaluated in polynomial time in |G| and | e
Case 3: Full expressions . Consider the base case in which we have only one preference, that is, expressions of the form e = ( e 1 ,...,e k ) (note that e 1 ,...,e k are nested regular expressions). The evaluation of e corresponds to the ordered evaluation of e 1 through e k . The evaluation of each e i requires polynomial time as discussed in case 1 and case 2. The size of the result of the evaluation of each e at most |N| . In order to obtain results associated to e it is necessary to consider results from each e i . This is done by calling k times the function append &amp; Remove (line 7 func-tion Base ). This function runs in time polynomial in |N| and eliminates duplicates. Hence, the evaluation of e can be done in polynomial time and the size of the results is at most |N| . The subsequent steps of the evaluation have to be carried out starting from at most |N| nodes. The most general case is e = ( e 1 ,...,e k ) where each e i may con-tain preferences. Since the size of the evaluation of each e contains at most |N| nodes and can be done in polynomial time, with the above reasoning also e = ( e 1 ,...,e k ) can be evaluated in polynomial time and the size of the results is at most |N| (recall the append &amp; Remove function). The evaluation of e will produce a list L = { S 1 ,...,S m } of dis-joint sets of nodes containing at most |N| nodes.

Theorem 4.2. The Preference Checking problem can be solved in polynomial time in |G| and | e | .

Proof. It is necessary to check that both a and b are con-tained in the result L obtained by solving the Preference Checking problem and that a b . First it is necessary to identify the two sets S i  X  L an S j  X  L such that a  X  S i b  X  S j . If one of the two sets does not exist or if i  X  j the answer if No, otherwise it is Yes. Since L contains at most |N| nodes, this checking costs at most O ( |N| ). GuLP-it is a system implemented in Java for evaluating GuLP expressions and is available at the GuLP Web site 1 . Evaluation methodology . We performed three kinds of experiments. The first aims at showing that adding the pref-erence operator does not incur in any increasing in the time of the evaluation of GuLP expressions. The second experi-ment advocates the need of having the preference operator inside GuLP . The third experiment has been carried out by using a set of complex expressions with preferences. Here, the aim is to show the advantages of using a graph query lan-guage with preferences in order to differentiate among the nodes associated to an answer. All the experiments have been performed on an Intel Core i5 2.4 GHz with 4GBs of memory. Moreover, each experiment has been executed 5 times and the average time has been considered.

Dataset #Nodes #Edges #Node DBLP F 1.2M 2.5M 2.5M 1.4M DBLP S 485K 860K 970K 1M Datasets . In order to test GuLP-it in a real context, we used the Proximity DBLP dataset, which is available at http://kdl.cs.umass.edu/data/dblp/dblp-info.html . The dataset is a snapshot of DBLP as of April 12, 2006 and includes six different types of publications and links from publications to their authors and editors and from papers to journals, proceedings, or books in which they appear. Cita-tion links from one publication to another are also included. Interestingly, this dataset provides both node and edge at-tributes. To test the scalability of GuLP-it , we considered two datasets. The first is a subset of Proximity DBLP, re-ferred to as DBLP S where only journals, journal papers and their authors have been considered. The second one is the full dataset and is referred to as DBLP F . Table 3 sum-marizes the datasets. Due to the magnitude of the graph, attributes are kept in an index stored in secondary memory. Experiment 1 . We performed some experiments in DBLP F to test the cost of performing requests with preferences. We compared two queries with the following structure: 1. seed ( author-of[in-journal])|(author-of[in-proc] ) 2. seed ( author-of[in-journal], author-of[in-proc] ) where seed is a starting node in the graph. The first, pro-totype is a query involving the union of all the authors of journal papers reachable from the seed node with all the authors of papers in proceedings. On the other hand, the http://graphgulp.wordpress.com second prototype involves preferences. In particular, jour-nal papers are preferred to papers in proceedings. We tested four queries by using as seed node each time a different com-puter scientist. The result of the evaluation is reported in Fig. 3. As it can be observed, using the preference operator does not bring any additional cost as compared to the case in which the union is used. Times differ from query to query due to the different number of nodes reachable from the seed. For instance, Q4 for which Christos Papadim-itriou has been used as seed node, took longer since the total number of publications was higher than in the other cases. In particular, 128 publications were found in the first preference class ( i.e., Journals) while 108 in the second (i.e., proceedings). Note that with the union, it would not have been possible to distinguish between the classes; one would have gotten all the nodes in a single set.
Another experiment has been performed on DBLP S by using the expression (in-journal  X  1 {@in_year&lt;= K }, in-journal  X  1 {@in_year&gt; K )} with K ranging from 1996 to 2004 and considering even years. This gives a total of 5 query templates. Note that here no seed node has been specified so the query has been executed starting from each of the 545 nodes representing journals in the dataset. Each query defines two classes of preference: the first for journal publications before K while the second one for publications after K . On the average a query took 150s. for a total of around 270K publications found with an average of 496 papers per journal. For each query and for each K , we computed the average number of preference classes P n over all the 545 journals. This can be seen as an indicator of how results can be partitioned in two classes. The more P approaches 2 the more the result (i.e., papers in journals) can be partitioned in preference classes. For K = 2002 we obtained the maximum value of P n = 1 . 68.
 Experiment 2 . This experiment is motivated by the fol-lowing consideration. An expression with preferences e can be decomposed into a set of expressions without preferences S e . If we denote with Q the number of times the preference operator is used in e and with T the number of terms in each e , then the total number of expressions is T Q . For instance evaluating e = ( e 1 ,e 2 ) /p 4 is conceptually equiv-alent to the ordered evaluation of the two expressions e 1 and e 2 /p 4 , where each evaluation produces a set (i.e., a pref-erence class). A naive approach for evaluating e would construct the corresponding set of expressions without pref-erences and evaluate them one by one. We compared the behavior of GuLP-it with the naive approach over a syn-thetic dataset consisting of graphs with size ranging from 100 to 100K nodes. Each graph is obtained starting from a set of nodes with a ring topology and two types of edges ( p 1 and p 2 ); each node is connected to both the predeces-sor and successor with edges labeled p 1 and p 2 . For each of such graphs the expression used has the following shape e = ( p 1 ,p 2 ) / ( p 1 ,p 2 ) ... with the number of preferences (#pref) ranging from 1 to 10. For instance #pref=3 cor-responds to the expression e = ( p 1 ,p 2 ) / ( p 1 ,p ( p 1 ,p 2 ). Results are reported in Fig. 4. Figure 4: Naive vs. GuLP-it varying preferences.

As it can be noted, the execution time for the naive ap-proach grows exponentially with the number of preferences and size of the graph. On the other hand, GuLP-it shows a polynomial behavior. As an example, while with the naive approach it took around 2400s to evaluate an expression with 10 preferences, with GuLP-it it took around 50s. Here we report the results for N = 100 K . Similar trends have been observed for N = 100 ,N = 1000 ,N = 10 K .

We conduct an additional set of experiments by keeping constant the number of preferences #pref to 3, 5 and 10 and varying the number of nodes. Even in this case, an exponential behavior has been observed for the naive ap-proach while GuLP-it still maintains a low running time (results for #pref=5 are reported in Fig. 5). The motivation underlying such a different behavior of the naive approach w.r.t. GuLP-it is the following. With the naive approach for each expression, obtained from the original expression with preferences, the computation starts from scratch and so all nodes can possibly be part of the results. On the other hand, GuLP-it is able to discard nodes considered during the evaluation at a higher preference level thus reducing the number of possible paths to be explored in order to build the result set. This underlines the need to have the prefer-ence operator embedded in the language and the algorithm discussed in Section 4. GuLP in Experiment 3 Experiment 3 . The third experiment uses a set of complex queries (see Table 4) involving nesting, preferences on edges, paths and tests over node and/or edge attributes. Queries Q 1 and Q 2 have been executed on the dataset DBLP while Q 3 and Q 4 on DBLP F . All the 4 queries leverage co-authorship relations. In general, co-authorship between persons holds if there is at least one paper in common. GuLP enables to express this via the expression author-of/author-of  X  1 . This is because, from a person via the edge author-of it is possible to reach paper nodes. Then, with author-of  X  1 it is possible to navigate in the reverse direction from paper nodes toward all their authors. In Q 1 and Q 2 two ad-hoc definitions of co-authorship are ex-pressed. The first applies only if two persons have in com-mon at least one paper published before or in 1970. This is expressed in GuLP via co 1 = author-of[in-journal{in-year&lt;=1970}]/author-of  X  1 . The expression within [ ] se-lects among all papers reached via author-of only those published in journals before or in 1970. This filtering is also performed by a test over the edge attribute in-year . The second definition of co-authorship is expressed by co 2 = author-of[in-journal{in-year&gt;1970, in-year&lt;=1975}]/author-of  X  1 and holds only if there are common papers published between 1970 and 1975. The aim of Q 1 and Q 2 is to compute the closure over co 1 and co 2 . This corresponds to identify all persons for which there exists a co-author path of any length, starting from a seed node n . To simplify the presen-tation, we can rewrite Q 1 and Q 2 according to co 1 and co In particular Q 1 = ( co  X  1 ,co  X  2 ) while Q 2 = ( ( co Q 1 defines two classes of preference. The first, correspond-ing to co  X  1 , includes all persons reachable from the seed node via paths of whatever length defined over co-authorship rela-tions complying with co 1 . The second, corresponding to co is defined similarly. According to the semantics of GuLP ex-pressions, the results of the evaluation of Q 1 and Q 2 are the lists of sets L Q 1 and L Q 2 (see Section 3.1) defined as:
J co As it can be noted, the first preference class in L the same as the first preference class in L Q 2 . As for the second class in L Q 1 and the last class in L Q 2 , although be-ing defined through the same expression, they may contain different results. This is because in L Q 2 there are other pref-erence classes at a higher level of preference (i.e., they have a lower index in the list) that may contain some of the nodes contained the last preference class of L Q 1 . Recall, that each node must belong to at most one preference class.

Q 3 and Q 4, which have been evaluated over the full DBLP dataset, have a similar shape to Q 1 and Q 2, respectively. Even here, two definitions of co-authorship have been used. The first is the same as co 1 discussed before. The second one co 3 = author-of[in-proc.{year&lt;=1970}]/author-of  X  1 considers papers in proceedings and published before or in 1970 and performs tests on the node attribute year . All queries have been executed using Jeffrey D. Ullman as the seed node. Fig. 6 reports the results for Experiment 3. In particular, for each query, the co-authorship network size, the number of preference classes and the average number of co-authors per preference class is reported. As it can be noted in Fig. 6 (a), Q 2 enables discovering the largest network of co-authors. Moreover, Q 2 provided more results than Q 1. This is because, Q 2 thanks to the Kleene opera-tor outside the preference (see Table 3) enables specifying a larger number of kinds of co-authorship paths than Q 1 (see eq.1 and eq. 2). Hence, Q 2 provides also a larger number of preference classes (see Fig. 6 (b)). The same reasoning applies for Q 4 w.r.t. Q 3. Fig. 6 (c) reports the average number of nodes per preference class.

Fig. 7 reports for each query the distribution of co-authors in the various preference classes. For instance, Q 1 has 28 persons in the first preference class, defined by co  X  1 and 214 in the second one defined by co  X  2 . On the average the execution time for Q 1 and Q 2 over DBLP S was of approximatively 15min. For Q 3 and Q 4 executed over the larger DBLP average the time was of 3.5 min.
We described GuLP , a graph query language to express preferences over node/edges attributes and complex paths. We showed that the evaluation of expressions with prefer-ences can be done in polynomial time as in the case of a lan-guage without preferences. The embedding of the operator in the language is useful since a naive strategy rewriting an expression with preferences in a set of standard expres-sions (to be executed in order) has an exponential running time. We did not focus on the orthogonal problem of learn-ing preferences [18], which will be addressed in the future.
Our framework adopts a boolean matching model: nodes along the path are considered if they match a given at-tribute/edge value. An interesting extension is that of com-bining this approach with a fuzzy matching operator over attribute values [9]. From a more theoretical point of view, an interesting line of future research is the comparison of the operator, which can be seen as an n -ary relation over paths (that are not explicitly retrieved) and expressive classes of languages such as Extended Regular Path Queries that look into regular and rational relations [4, 3]. Considering other data models (e.g., RDF) is also in our research agenda. [1] S. Amer-Yahia, I. Fundulaki, and L. Lakshmanan. [2] R. Angles and C. Gutierrez. Survey of Graph Database [3] P. Barcel  X o, D. Figueira, and L. Libkin. Graph logics [4] P. Barcel  X o, C. A. Hurtado, L. Libkin, and P. T. Wood. [5] C. Bizer, T. Heath, and T. Berners-Lee. Linked Data  X  [6] J. Chomicki. Querying with Intrinsic Preferences. In [7] J. Chomicki. Preference Formulas in Relational [8] C. Domshlak, E. H  X  ullermeier, S. Kaci, and H. Prade. [9] R. Fagin. Combining Fuzzy Information from Multiple [10] R. Fagin and E. L. Wimmers. Incorporating User [11] V. Fionda, C. Gutierrez, and G. Pirr  X o. Semantic [12] S. Flesca and S. Greco. Partially Ordered Regular [13] G. Grahne, A. Thomo, and W. Wadge. Preferential [14] W. Kie X ling. Foundations of Peferences in Database [15] W. Kie X ling, B. Hafenrichter, S. Fischer, and [16] G. Koutrika and Y. E. Ioannidis. Personalization of [17] J. P  X erez, M. Arenas, and C. Gutierrez. nSPARQL: A [18] K. Stefanidis, M. Drosou, and E. Pitoura. Perk: [19] K. Stefanidis, G. Koutrika, and E. Pitoura. A survey [20] R. Torlone and P. Ciaccia. Management of User [21] M.-E. Vidal, L. Raschid, and J. Mestre. Challenges in [22] P. T. Wood. Query Languages for Graph Databases.
