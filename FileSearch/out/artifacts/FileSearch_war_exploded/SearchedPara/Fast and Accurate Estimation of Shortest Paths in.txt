 Computing shortest paths between two given nodes is a fun-damental operation over graphs, but known to be nontrivial over large disk-resident instances of graph data. While a number of techniques exist for answering reachability quer ies and approximating node distances efficiently, determining actual shortest paths (i. e. the sequence of nodes involved) is often neglected. However, in applications arising in mas -sive online social networks, biological networks, and know l-edge graphs it is often essential to find out many, if not all, shortest paths between two given nodes.
 In this paper, we address this problem and present a scal-able sketch-based index structure that not only supports es -timation of node distances, but also computes correspond-ing shortest paths themselves. Generating the actual path information allows for further improvements to the estima-tion accuracy of distances (and paths), leading to near-exa ct shortest-path approximations in real world graphs. We evaluate our techniques  X  implemented within a fully functional RDF graph database system  X  over large real-world social and biological networks of sizes ranging from tens of thousand to millions of nodes and edges. Experi-ments on several datasets show that we can achieve query re-sponse times providing several orders of magnitude speedup over traditional path computations while keeping the esti-mation errors between 0% and 1% on average.
 E.1 [ Data ]: Data Structures X  Graphs and Networks ; H.2.4 [ Database Management ]: Systems X  Query Processing Algorithms, Experimentation, Performance Graph Databases, Shortest Paths, Social Networks corresponding author Graphs are routinely used in the modern digital world in a number of settings, such as online social networks (like LinkedIn, Facebook, MySpace), synthesized entity-relati on-ships in large-scale knowledge repositories [1, 25], biolo gical interaction models [10, 12, 13], transportation networks [ 20], the massive hyperlink graph between documents of the World Wide Web, XML data, and many more.
 Due to the ever increasing size of the graphs of interest, many seemingly straightforward operations become challen g-ing. In this paper, we turn our attention to the computation of shortest paths between any two nodes in the graph, a prob-lem with long algorithmic history. This operation forms a building block for many mining tasks, and is also an increas-ingly important application in itself over instances such a s online social networks. Consider the following two applica -tion scenarios for shortest path queries: Similar applications arise for almost every instance of gra ph data, which includes the commonly studied problem of find-ing a shortest route between two points in road networks [28] . In many cases, the graphs of interest comprise millions of nodes and edges. Thus, for scalability reasons, each of the shortest path query instances has to be answered as fast as possible while minimizing the consumption of resources suc h as memory and processor cycles. What makes the shortest path computation particularly hard on large graphs? Dijkstra X  X  algorithm, the classical tech-nique to compute the shortest path between two nodes in a graph has the asymptotic runtime complexity of O m + n log( n ) , where n is the number of nodes and m is the number of edges [5]. On one of the benchmark datasets that we use in this paper  X  the Orkut social network comprising about 3 million nodes and 220 million edges  X  a straigh-forward implementation of Dijkstra X  X  algorithm takes more than 500 seconds on average. This is way too slow for most applications. The reason for this is that Dijkstra X  X  algori thm has to construct and maintain shortest paths to all nodes in the graph whose distance to the source node is smaller than the distance from the source node to the destination node. Consequently, the memory consumption of Dijkstra X  X  algo-rithm is very high, requiring to maintain a number of 2.5 million nodes in the heap for the Orkut dataset, which is prohibitively expensive for simultaneous execution of man y queries.
 The na  X   X ve alternative of precomputing all-pairs shortest paths distances and maintaining them on disk for quick lookups is practically infeasible, requiring O n 2 space. For general graphs, it has been shown that constant query time for exact shortest path distance queries is only achievable with supe r-linear space requirements during preprocessing [26]. Rela x-ing the exactness requirement, a number of distance oracles have appeared which aim at providing a highly accurate es-timate of the node distances [4, 22, 24, 26, 29]. The main application for these approaches occur in geographic infor-mation systems (GIS) or, specifically, in route planning over transportation networks. Techniques developed in this do-main exploit in a crucial way special properties of transpor ta-tion networks such as their near planarity, low node-degree and the presence of a hierarchy based on the importance of roads [2, 3]. These properties also help in devising faster variants of Dijkstra X  X  online algorithm by combining it wit h A -search and other goal-oriented pruning strategies [7]. On the other hand, the social networks that we consider in this work do not exhibit the same properties as road net-works. It is well known that social networks contain many high degree nodes, are nowhere close to planar, and typicall y have no hierarchical structures that can be exploited for im -proving shortest path queries. Potamias et al. [19] make the important observation that even a 2-approximation, which is considered highly competitive for general graphs, is ins uf-ficient in the case of social networks as the distances are already very small. Further, none of the prior work has explicitly addressed the problem of providing the shortest paths themselves, not just the node distances, as we do in this paper.
 We also briefly mention here that database research has con-sidered queries over different forms of graph databases apar t from road networks, such as XML graphs and biological net-works [8, 9, 23, 27]. The focus, however, has been primar-ily on answering reachability queries , not in computing the shortest path distance or the shortest path itself. We build upon the recently proposed sketch-based frame-work [6], which in turn is based on the classical landmark-based approach used in distance oracles [26]. The goal is to precompute and store a O ( n ) sized sketch of the graph so that any distance query can be answered approximately but with high accuracy. The prior work considered maintaining only the distance information as part of the sketch. However , we observe that for most real-world graph data (apart from road networks), like social networks, the path lengths are small enough to be considered almost constant [17], and thus propose to store the complete path information (i. e. the in-formation about constituent nodes and edges) as part of the sketch. Based on the availability of such path-sketches (as opposed to the distance-sketches in [6]) we develop a set of lightweight algorithms that can approximate shortest path s between any two nodes with at most 1% error. Additionally, we can also generate a set of paths (i. e. the identity of nodes in the path) that correspond to the estimated shortest path distance with no additional overhead  X  a feature hitherto not available.
 In summary, contributions made in this paper are as follows: 1. We introduce path-sketches , which can be effectively 2. We develop a set of lightweight, yet highly effective, 3. Along with estimates of shortest path distances, we 4. Finally, we implement all the proposed methods in In most of the datasets we used, the estimates are almost always exact, and generate a number of alternative shortest paths between a given pair nodes. The remainder of this paper is organized as follows: In the next section we explain the previously proposed distance oracle algorithm devised by Das Sarma et al. [6] (in the following referred to as the sketch algorithm) and show how simple yet powerful modifications to it yield shortest path e s-timates of higher quality. Subsequently, we describe a new algorithm that uses the data obtained in the precomputa-tion step of the sketch algorithm and returns paths whose accuracy beats the previous approaches by an order of mag-nitude at the expense of only a marginal time overhead. In section 3 we describe the implementation details of our algo -rithms within the graph database system RDF-3X . Section 4 comprises a comprehensive experimental evaluation that shows the practicability of our algorithms both in terms of query response time as well as in the approximation quality of the returned results. We conclude the paper with a review of related work and finally identify possible future researc h directions. In this section we explain our algorithms for shortest path approximation in detail. Let G = ( V, E ) denote a directed graph with vertex set V and edge set E .
 Paths and Distances. A path p of length l  X  N in the v s graph is an ordered sequence of l + 1 vertices, such that there exists, for every vertex in the sequence, an edge to its subsequent vertex, except the last one: p = ( v 1 , v 2 , . . . , v l +1 ) with v i  X  V, 1  X  i  X  l + 1 , (1) For a node v  X  V of the graph we denote by S ( v ) the set of the successors of v in G , that is the set of vertices w  X  V with ( v, w )  X  E . Thus, we can express requirement (2) equivalently as v i +1  X  X  ( v i ) , 1  X  i &lt; l. We write | p | = l to denote the length of the path p . For vertices u, v  X  V , let P ( u, v ) be the set of all paths that start in u and end in v . The distance from u to v , denoted by dist( u, v ), is the number of edges in the shortest such path  X  or infinity if v is not reachable from u : Path Approximation. Given two vertices u, v  X  V , let p denote a shortest path (note that there could be many) from u to v , that is, a path starting in u and ending in v with length | p | = dist( u, v ). Furthermore, let q be an arbitrary path from u to v . By regarding q as an approximation of the shortest path p , we can define the approximation error of this path as Path Concatenation. Let p = ( u 1 , u 2 , . . . , u l 1 , u q = ( v 1 , v 2 , . . . , v l 2 +1 ) denote paths of lenghts l spectively. Suppose u l 1 +1 = v 1 , that is, the last node in path p equals the first node in path q . Then, we can create new path, denoted by p  X  q , of length l 1 + l 2 by concatenating the paths p and q : The sketch algorithm [6] approximates the shortest path dis -tance between two given nodes in general graphs using a landmark-based approach. In order to answer a distance query for a pair of nodes ( s, d ) in real time, the algorithm employs a two-staged approach: a precomputation step to generate sketches (distances from all vertices to so-calle d landmark nodes) beforehand, and an approximation step that uses this precomputed data to provide a very fast ap-proximation of the node distance at query time. It works by combining the two distances dist( s, l ) , dist( l, d ) of the query nodes to/from a selected landmark node l into the approxi-mated distance Therefore, in the original paper [6], the authors suggest to store for every node v the distances dist( v, ) and dist( , v ) from (to) the node to (from) certain landmark nodes as the result of the precomputation. This set of node-landmark distances is called sketch of a node.
 Instead of keeping just the distances, we modify the precom-putation step to store the distances along with the actual paths. The diameters of social networks are usually small [17], so the paths are expected to be relatively short. There -fore, the storage overhead of maintaining full path informa -tion as part of the sketch is not substantial  X  our experiment s show that it is no more than twice the sketch with only distance information. Obviously, we do not incur any addi-tional computational overhead during the precomputation step, since we require no more information than generated by the breadth-first search and reverse breadth-first search steps of sketch computation.
 Also note that while the original algorithm returns an esti-mate of the distance between the query nodes, our algorithm returns more than just one approximate path between the query nodes, namely a queue of such paths (sorted in as-cending order by path length). By providing many candi-date paths, this modification could prove useful in scenario s where  X  for example  X  constraints on certain nodes/edges must be satisfied.
 In this section we explain these two building blocks of the (modified) sketch algorithm in detail: The precomputation step involves sampling some sets of nodes, computing for every node in the graph a shortest path to and from a member of this set and storing the thus obtained set of paths on external memory. These paths will be used in the approximation step later. The preprocessing, illustrated in Figure 1, works as follows: 1. Seed Set Sampling s s 2. Shortest Path Computation This precomputation routine  X  that is, seed set sampling and shortest path computation  X  is repeated k times, thereby generating for each vertex v  X  V a number of 2 rk landmarks and paths (at costs of the same number of BFS expansions from the seed sets). Note that the set of selected landmarks might be different for every node. The data (sketch) gath-ered for node v , consisting of the 2 rk landmarks and paths, is denoted by Sketch ( v ). As a result of the precomputation step, we store the sketches of all nodes on disk. In the second stage, the algorithm receives a pair of nodes, ( s, d ), as input. The goal is to compute, in real time, a path p s  X  d from s to d that provides a good approximation of the shortest path, that is, a path with small error( p s  X  d ). The sketch algorithm, presented in Algorithm 1, performs the following steps to generate such a path: 1. Load the sketches of nodes s and d from disk 2. Let L be the set of common landmarks in the sketches. 3. For each common landmark l  X  L , let p s  X  l be the path 4. Return the priority queue of paths obtained in step 3. Algorithm 1: Sketch ( s, d ) Input : s, d  X  V Result : Q  X  priority queue of paths from s to d , ordered begin 2 Load sketches Sketch ( s ) , Sketch ( d ) from disk 3 L  X  common landmarks of Sketch ( s ) and Sketch ( d ) 4 foreach l  X  L do 5 p  X  path from s to d through l 6 Add p to queue Q 7 return Q In this section we explain our modifications to the original sketch algorithm to obtain better approximations. As a first step, we eliminate cycles in the paths found by the sketch al-gorithm and as a second improvement we try exploit existing shortcuts within the paths. While these two modifications to the original algorithm are simple, they provide consider -able improvements in terms of the approximation quality, as we will show in the experimental evaluation. The paths returned by Algorithm 1 approximate the shortest path for the two query nodes and thus might be suboptimal, i. e. longer than the true shortest path. Some of the returned paths can however be easily improved, because they contain cycles. Consider the example shown in Figure 2: Suppose l  X  V is a common landmark for the nodes s, d  X  V and the sketches Sketch ( s ) and Sketch ( d ) contain the paths p queue Q returned by Algorithm 1 contains the path Obviously, we can obtain a shorter path by removing the cycle ( v 1 , v 2 , l, v 3 , v 1 ), thus obtaining the path ( s, v modified sketch algorithm, named SketchCE , is described in Algorithm 2.
 For a path of length l , our na  X   X ve cycle elimination routine performs at most O ( l 2 ) node comparisons. In theory, we could make use of more advanced cycle elimination/detectio n approaches [11]. However, the diameters and thus the short-est paths in social networks are usually bounded by a small constant [17], thus we can assume constant time complexity for the cycle elimination routine on a single path. Further-more, the number of paths in Q is bounded by the choice Algorithm 2: SketchCE ( s, d ) Input : s, d  X  V Result : Q  X  priority queue of paths from s to d , ordered begin 2 Q  X  Sketch ( s, d ) 3 foreach p = ( p 1 , p 2 , . . . , p l )  X  Q do 4 for i = 1 to l  X  1 do 5 for j = 0 to l  X  i  X  1 do 7 Q  X  Q  X  X  ( p 1 , . . . , p i , p l  X  j +1 , . . . , p l 9 return Q of precomputation rounds, k , and the number of seed sets, r . We eventually obtain the upper bound | Q |  X  2 rk for the queue size because for each vertex we store two paths for every seed set (forward and backward paths). With the standard choice r = log( n ) this leads to a time overhead of O k log( n ) for the cycle elimination enhancement. We can keep the queue Q in main memory, as a result the increase in running time with respect to the basic algorithm (Algo-rithm 1) is negligible (as we will show in the experimental evaluation). The second modification we propose is path shortcutting: Suppose the queue Q returned by the algorithm contains a path p s  X  l  X  d from s to d via a landmark l . Two nodes u, v in the path might actually have a closer connection than the one contained in the respective subpath of p s  X  l  X  d . Consider the example depicted below: While the nodes u and v are connected by a subpath of p s  X  l  X  d of length 3, the original graph contains the edge ( u, v ). We can then easily substitute this subpath by the single edge ( u, v ). Note that in all cases that allow for this shortcutting optimization, the landmar k l will be located on the subpath from u to v . s In order to find out whether any two nodes in a given path p vertex, s , and load the list S ( s ) of its successors in the orig-inal graph. Then we check if any of the successors of s is contained in the path p l  X  d from the landmark l to the des-tination vertex d . If this is the case, we can substitute the subpath from s to this node by the single edge. If no suc-cessor of s is contained in the path from l to d , we proceed to the second node in the path p s  X  l , load the set of its suc-cessors and repeat the procedure. We can terminate this routine if we either Algorithm 3: SketchCESC ( s, d ) Input : s, d  X  V Result : Q  X  priority queue of paths from s to d , ordered begin 2 Q  X  SketchCE ( s, d ) 3 foreach p = ( p 1 , p 2 , . . . , p i  X  1 , p i , p i +1 4 for j = 1 to i  X  1 do 5 S  X  set of successors of p j 6 for k = 0 to l  X  i + 1 do 8 Q  X  Q  X  X  ( p 1 , . . . , p j , p l  X  k , . . . , p l ) } 10 return Q The complete algorithm (cycle elimination + shortcutting) , called SketchCESC , is depicted in Algorithm 3. In this section we describe our third contribution, a new al-gorithm for shortest path approximation that also utilizes the precomputed sketches.
 The sketch Sketch ( v ) of a node v contains two sets of paths: (1) the set of paths connecting v to landmarks (called forward-directed paths ) and (2) the set of paths connecting landmarks to v (called backward-directed paths ). In the undirected set-ting, both sets would correspond to trees having landmarks as leaves and v as a root. Every inner node of each tree corre-sponds to a vertex contained in one of the paths in the sketch. In the directed setting, only the forward-directed part of the sketch (from v to landmarks) forms a tree, while the backward-directed paths yield a tree with  X  X eversed edges X  (see Figures 3a+b).
 Our new algorithm, named TreeSketch , takes the two from disk and constructs the tree T s , rooted at s , that con-tains all the forward paths stored in Sketch ( s ). Likewise, the  X  X eversed tree X  T d , rooted at d , containing all the back-ward directed paths from the landmarks to d is being created from Sketch ( d ). Then, the algorithm starts two breadth-first-expansion on the trees simultaneously: BFS( T s , s ) from s in T s and RBFS( T d , d ) (BFS on reversed edges) from d in T At any point of time during execution, let V Bfs and V RBfs denote the sets of visited nodes during the respective BFS runs.
 For every vertex u  X  V Bfs encountered during BFS( T s , s ), the algorithm loads the list S ( v ) of its successors in the original graph. Then, it checks whether any of the vertices discovered during RBFS( T d , d ) is contained in the list S ( u ). If such a vertex v  X  S ( u )  X  X  RBfs exists (see Figure 3c), we have found a path p from s to d , given by s s where p s  X  u and p v  X  d denote the paths from s to u in T from v to d in T d respectively (Figure 3d). An equivalent procedure is executed for every vertex encountered during reverse BFS from d .
 We continue this procedure of BFS expansions and successor list checks, adding paths discovered along the way to the queue Q . Let l shortest denote the length of the shortest path in Q . The algorithm terminates if there is no further chance to find a path that is shorter than the current shortest path in Q . This is the case when the sum of depths of both BFS The complete algorithm is depicted in Algorithm 4. We implemented all methods  X  Dijkstra X  X  online shortest-path algorithms as well as the sketch-based techniques  X  within RDF-3X [18], a recently proposed high-performance database system for storing and querying large RDF graph repositories. Before presenting the implementation detai ls, we briefly give a background on RDF-3X , focusing on its ability to store large-graphs highly compressed and, at the same time, easy to query from. Note that we omit details of query processing and optimization strategies for querie s within RDF-3X , as they are not relevant in our setting. RDF-3X is a fully functional, high-performance storage en-gine and query processor designed particularly for storing  X  as the name suggests  X  RDF and querying using SPARQL. It maintains the whole graph essentially as a huge triples table , in contrast to the recently favored property-table approac h. In the first step, each of these values are mapped to a simple integer, and this mapping is maintained in a global Dictio-nary . Then, all six possible permutations of S , P and O are maintained in six separate clustered B + -tree indexes. In Algorithm 4: TreeSketch ( s, d ) Input : s, d  X  V Result : Q  X  priority queue of paths from s to d , ordered begin 2 Load Sketch ( s ) , Sketch ( d ) from disk 5 Q  X  X  X  9 foreach u  X  Bfs ( T s , s ) and v  X  RBfs ( T d , d ) do 15 Q  X  Q  X  X  p } 22 Q  X  Q  X  X  p } 24 if dist( s, u )+dist( v, d )  X  l shortest then break 25 return Q other words, an index exists for each of ( SP O , SOP , OSP , OP S , P SO , P OS ) orderings. Each index can be signifi-cantly compressed by the use of delta-coding of triples, a generalization of similar compression used in inverted lis t indexes to id triples. Further, RDF-3X also builds 6 more indexes in order to support analytic queries efficiently. Cou n-terintuitively, the overall database size containing 12 di ffer-ent clustered B + -tree indexes with all the compressions men-tioned above works out to be smaller than the original data in triple format.
 In our implementation, we store graphs in RDF-3X edge-wise with each edge represented as a triple h s, e, t i . We do not restrict RDF-3X from building all the 12 indexes auto-matically, although we do not use all of them in this work  X  in fact, we exploit only SP O and OP S ordered indexes. Dijkstra X  X  Algorithm. Implementing Dijkstra X  X  algorithm over RDF-3X basically involves opening a scan on the SP O index to determine, for each node visited during the execu-tion of the algorithm, all the successor nodes. Note that we get reverse Dijkstra X  X  algorithm, needed during compu-tation of sketches, essentially for  X  X ree X  by simply openin g the scan on the OP S index, and letting the algorithm run. The priority-queue required during Dijkstra X  X  algorithm i s maintained in memory using an implementation available in GNU-C ++ STL. For simplicity, we store the sketches also as RDF triples in a separate database under RDF-3X . Since sketches (both distance-and path-sketches) are associated with oriented paths, we format them as follows: where, v i is the id of the source node, to and from are string literals indicating the orientation of the path, l the landmark for node v i from the seed-set S j , and d ij the corresponding shortest distance to the landmark. Simi-larly, path-sketches are also stored as triples of the form: where p ij refers to the sequence of node-ids in the path be-tween the node v i and the landmark node l ij .
 It should be noted again that RDF-3X builds 12 indexes over this triple database of sketches, but we require only one of these indexes for our shortest path estimation algorithms, namely, the B + -tree over the permutation SP O . Thus, the disk space consumption we provide later in experiments sec-tion can be further reduced significantly, although the rel-ative sizes of sketches remains the same. In all our experi-ments we used the default setting of k = 2 precomputation rounds. In this section we provide an experimental evaluation of our algorithms. First, we give an overview of the datasets used. Afterwards, in subsection 4.2, we describe the generation o f test instances used in the subsequent evaluation. The ap-proximation quality of the different approaches is assessed in subsection 4.3.1, query running time measurements are carried out in subsection 4.3.2. In addition, we briefly con-sider the question of path diversity in subsection 4.3.3. We conclude with subsection 4.3.4, where we quantify the space and time requirements for sketch precomputation. We prove the practicability of our approach by a number of experiments on the following real-world networks: Slashdot Zoo  X  a network of users of the technology-news Google Webgraph  X  a fraction of the webgraph released YouTube  X  a 2007 crawl of the social network consisting Flickr  X  a social network of about 1.7 million users of the WikiTalk  X  network of Wikipedia members commenting Twitter  X  parts of the social network of the microblogging Dataset | V | | E |  X  |S| / | V | d 0 . 9 Slashdot 77,360 905,468 23.4 90.9 % 5.59 Google 875,713 5,105,039 11.7 49.6 % 9.02 YouTube 1,138,499 4,945,382 8.7 44.7 % 7.14 Flickr 1,715,255 22,613,981 26.4 69.5 % 7.32 WikiTalk 2,394,385 5,021,410 4.2 4.6 % 4.98 Twitter 2,408,534 48,776,888 40.5 57.5 % 5.52 Orkut 3,072,441 223,534,301 145.5 97.5 % 5.70 Orkut  X  the X  X ure X  X ocial network Orkut, containing more The networks and their properties are listed in table 1. In order to evaluate the approximation quality and running times of our algorithms, we use a set of test triples of the form consisting of a pair of nodes x, y  X  V and the actual dis-tance dist( x, y ) (length of shortest path) of these nodes in the graph. We generate these triples by uniformly sampling one hundred vertices and computing shortest path trees (for -ward and backward direction) for each vertex, using Dijk-stra X  X  algorithm [5]. As output we obtain for every sampled vertex v one tree connecting the vertex to every other reach-able node and one  X  X eversed X  X ree, connecting every node for which a path to the sampled vertex exists to v .
 As a result we obtain a set of triples of the structure shown in equation (6). Then, we group these triples into categorie s corresponding to the distance dist( x, y ). From every such category, we sample at most 50 triples (tests) as our test set. The actual number of tests varies for every network be-cause both the number of groups as well as the number of contained triples might be different. In order to assess the approximation quality of the paths gen -erated by the different algorithms, we run for every triple s, d, dist( s, d ) contained in the test set a shortest path query for all 4 proposed algorithms: Sketch , SketchCE , SketchCESC , and TreeSketch . For every shortest path query ( s, d ), we compare the length l shortest of the shortest path p s  X  d in the returned queue with the true node dis-tance dist( s, d ) specified in the test triple. Then, we obtain the approximation error, error( p s  X  d ), for the path: For every algorithm we record the average approximation error over all the test triples. The obtained error values ar e provided in table 2 and plotted in Figure 4, using a logarith-mic scale to display the error values.
 As these results clearly demonstrate, the approximation qu al-ity of the algorithms we propose in this paper turns out to be superior to the previously proposed method (denoted as Approximation Error [%] Sketch ). For all datasets under consideration, we are able to return a shortest path for the query nodes with an aver-age estimation error of 1% in the worst case, while providing exact solutions in almost all cases for the Slashdot and Wik-iTalk networks (using the TreeSketch algorithm). Com-pared to the paths returned by the basic Sketch algorithm of [6], for several datasets we are able to provide two orders of magnitude improvement in approximation quality using SketchCESC and TreeSketch . The simple cycle elimi-nation enhancement also leads to a considerable decrease of estimation errors to the order of close to 1.7-2 factors for t he datasets under consideration. The second important evaluation category we are assessing is query execution time. We compare the results of our meth-ods, averaged over the test triples, to the average running time of Dijkstra X  X  algorithm. The results are listed in tabl e 2, a semilogarithmic plot of the query execution times is de-picted in Figure 5.
 Observe that, using algorithm SketchCESC , we are able to answer shortest path queries with excellent accuracy withi n on average 190 milliseconds for the smallest dataset (Slash -dot) to 4 seconds in the large Twitter dataset. Using algo-rithm TreeSketch we can provide even better path estima-tions at an negligible additional time overhead, providing the results between one and two orders of magnitude faster than the classical Dijkstra algorithm. Note that for the Slashdo t and Wikitalk dataset, the query is executed extremely fast while achieving an approximation error of 0% for almost all of the test triples.
 All query execution measurements have been carried out on an out-of-the-box laptop with a 2.0 GHz Intel Core 2 Duo processor and 4 GB of RAM, running Ubuntu Linux 10.04. Note that we filtered the previously generated test triples i n such a way, that no node of the graph appears in more than one test triple. This way, we try to eliminate caching effects of the RDF-3X database system. In many application settings it is not only important to quickly generate an accurate approximation of the shortest path, but also crucial to return as many candidate paths as possible. Our algorithms are designed in such a way that this goal can be satisfied.
 They return an ordered queue of paths which can  X  for ex-ample  X  be used to filter out candidates based on some user-specified constraints. The average number of generate d shortest paths is given in table 4.
 The number of candidate paths created by TreeSketch is always greater than the number of paths generated by the other variants. For the Twitter dataset, we able to generate 92 paths on average, more than twice as much as provided by our SketchCESC algorithm. Finally, we evaluate the space and time requirements for the preprocessing step (the sketch computation).
 Space Requirements. We evaluate the space consumption of the sketches by comparing their size against the size of the orginal database and the sketches computed by the orig-inal sketch algorithm [6], that store just the distances. Se e Table 3 and Figure 6 for a detailed overview over the neces-sary disk space for the different datasets. The path sketches Query Execution Time [ms] Space Consumption [Mb] Dataset Database Sketch dist Sketch path t precomp [ s ] Slashdot 26 Mb 112 Mb 139 Mb 267.2 Google 0.15 Gb 1.1 Gb 1.9 Gb 4,156.6 YouTube 0.19 Gb 1.3 Gb 2.5 Gb 3,159.0 Flickr 0.57 Gb 2.3 Gb 4.4 Gb 2,223.4 WikiTalk 0.22 Gb 1.9 Gb 2.1 Gb 5,430.0 Twitter 1.30 Gb 3.4 Gb 6.1 Gb 12,806.1
Orkut 5.70 Gb 5.8 Gb 7.4 Gb 36,486.2 surpass the original database size by a factor of at most 10 (with the exception of the Google dataset). Compared to the original distance sketches, storing the actual paths inste ad of just the distances incurs a comparatively low additional cost, materializing in a factor of 2 in the worst and 1.1 in the best case.
 Precomputation Time. We measure the running time of the preprocessing stage for all datasets. Table 4 provides an overview over the required times for k = 2 preprocessing iterations. Note that the required time increases linearly in k . For small datasets like Slashdot, the sketches can be ob-tained within five minutes, while the largest dataset (Orkut ) requires about 11 hours of preprocessing.
 The time measurements were conducted on Dell PowerEdge M610 servers, each of which has two Intel Xeon E5530 CPUs, 48 GB of main memory, a large iSCSI-attached disk array, and runs Debian GNU/Linux with SMP Kernel 2.6.29.3.1 as an operating system. In this paper, we have presented fast and accurate algo-rithms for the approximation of shortest paths, building upon a previously proposed algorithm for distance estima-tion using precomputed sketches. We describe how sim-ple, yet powerful, modifications to the original algorithm together with an entirely new algorithm operating on the same precomputed data yield paths with excellent quality while attaining query execution times that beat the classi-cal Dijkstra shortest path algorithm by up to two orders of magnitude. In addition, we are able to generate not only one but many candidate paths, as our experimental evaluation on a number of real world datasets underpins.
 Our algorithms have been implemented within the recently proposed high-performance RDF storage and retrieval sys-tem, RDF-3X . To evaluate the quality and speed of our ap-proaches, we have conducted a large number of experiments that prove the practicability of our algorithms in terms of speed, quality, and diversity.
 A promising future research direction in this area is the con -sideration of user-provided constraints (e. g. on the type o r label of the nodes and edge) that have to be satisfied by the returned paths.
 This work is supported by DFG (German Research Foun-dation) within the priority research program 1355  X  X calabl e Visual Analytics X . [1] S. Auer, C. Bizer, G. Kobilarov, J. Lehmann, [2] H. Bast. Car or Public Transport  X  Two Worlds. [3] H. Bast, S. Funke, D. Matijevic, P. Sanders, and [4] E. Cohen, E. Halperin, H. Kaplan, and U. Zwick. [5] T. H. Cormen, C. E. Leiserson, R. L. Rivest, and [6] A. Das Sarma, S. Gollapudi, M. Najork, and [7] A. V. Goldberg, H. Kaplan, and R. F. Werneck. Reach [8] R. Jin, Y. Xiang, N. Ruan, and D. Fuhry. 3-HOP: A [9] R. Jin, Y. Xiang, N. Ruan, and H. Wang. Efficiently [10] M. Kanehisa, S. Goto, M. Hattori, K. F.
 [11] D. E. Knuth. Seminumerical Algorithms . The Art of [12] J. K  X  ohler, J. Baumbach, J. Taubert, M. Specht, [13] J. K  X  untzer, C. Backes, T. Blum, A. Gerasch, [14] J. Leskovec, D. Huttenlocher, and J. Kleinberg. [15] J. Leskovec, J. Kleinberg, and C. Faloutsos. Graphs [16] J. Leskovec, K. J. Lang, A. Dasgupta, and M. W. [17] A. Mislove, M. Marcon, K. P. Gummadi, P. Druschel, [18] T. Neumann and G. Weikum. The RDF-3X Engine for [19] M. Potamias, F. Bonchi, C. Castillo, and A. Gionis. [20] R. C. Prim. Shortest Connection Networks and some [21] J. M. Pujol, G. Siganos, V. Erramilli, and [22] J. Sankaranarayanan and H. Samet. Distance Oracles [23] R. Schenkel, A. Theobald, and G. Weikum. HOPI: An [24] C. Sommer, E. Verbin, and W. Yu. Distance Oracles [25] F. M. Suchanek, G. Kasneci, and G. Weikum. Yago: A [26] M. Thorup and U. Zwick. Approximate Distance [27] S. Tri X l and U. Leser. Fast and Practical Indexing and [28] F. B. Zhan and C. E. Noon. Shortest Path Algorithms: [29] U. Zwick. Exact and Approximate Distances in
