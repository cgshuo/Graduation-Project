 With the proliferation of mobile devices and wireless technologies, mobile social network systems are increasingly available. A mobile social network plays an essential role as the spread of information and influence in the form of "word-of-mouth". It is a fundamen-tal issue to find a subset of influential individuals in a mobile social network such that targeting them initially (e.g. to adopt a new prod-uct) will maximize the spread of the influence (further adoptions of the new product). The problem of finding the most influential nodes is unfortunately NP-hard. It has been shown that a Greedy algorithm with provable approximation guarantees can give good approximation; However, it is computationally expensive, if not prohibitive, to run the greedy algorithm on a large mobile network.
In this paper we propose a new algorithm called Community-based Greedy algorithm for mining top-K influential nodes. The proposed algorithm encompasses two components: 1) an algorithm for detecting communities in a social network by taking into ac-count information diffusion; and 2) a dynamic programming algo-rithm for selecting communities to find influential nodes. We also provide provable approximation guarantees for our algorithm. Em-pirical studies on a large real-world mobile social network show that our algorithm is more than an order of magnitudes faster than the state-of-the-art Greedy algorithm for finding top-K influential nodes and the error of our approximate algorithm is small. F.2.2 [ Analysis of Algorithms and Problem Complexity ]: Non-numerical Algorithms and Problems Algorithms, Experimentation, Performance, Reliability Social Networks, Community Detection, Influence Maximization Corresponding author. Email: gjsong@cis.pku.edu.cn
A social network is a social structure connecting individuals or organizations. Examples of social networks include email networks, online FaceBook, and scientific collaboration networks[11]. A so-cial network plays an important role as the spread of information and influence in the form of "word-of-mouth" [16]. It is a funda-mental issue to find a small subset of influential individuals in a social network such that they can influence the largest number of people in the network [9].
 Finding a subset of influential individuals has many applications. Let us recall the motivating example given by Kempel et al. [10]. Consider a social network together with the estimates for the ex-tent to which individuals influence one another, and the network performs as the platform for marketing. A company would like to market a new product, hoping it will be adopted by a large fraction of the network. The company plans to initially target a small num-ber of "influential" individuals of the network by giving them free samples of the product (the product is expensive or the company has limited budge so that they can only choose a small number of people). The company hopes that the initially selected users will recommend the product to their friends, their friends will influence their friends X  friends and so on, thus many individuals will ulti-mately adopt the new product through the powerful word-of-mouth effect (or called viral marketing). The problem here is to choose a set of individuals to send the free samples such that they eventually influence the largest number of people in the network. Formally, the problem is called as influence maximization [10], which is, for a parameter K , to find a K -node set of maximum influence, where influence is propagated in the network according to a stochastic cascade model [10].

Kempel et al. establishes that the optimization problem of influ-ence maximization is NP-hard [10]. They use the Greedy algorithm and prove that the optimal solution for influence maximization can be approximated to within a factor of (1  X  1 study shows that the Greedy algorithm significantly outperforms the degree or centrality-based heuristics in influence maximization. The main problem of Greedy algorithm is efficiency, especially when the social network contains a large number of nodes. Re-cently, Chen et al.[4] propose an improved version of Greedy al-gorithm, called NewGreedy. To make the result better, it takes the first round with NewGreedy algorithm and the rest rounds using CELF Greedy algorithm[14], called MixedGreedy, which is shown to be more efficient than previously proposed Greedy algorithms[4, 10]. However, finding a small set of influential nodes in a large net-work with 723k nodes could still take days to complete on a modern server (as to be shown in our experiments).
In this paper, we tackle the problem of influence maximization in a Mobile Social Network (MSN) where individuals communicate with one another using mobile phones[7]. A MSN can be extracted from call logs and is modeled as a weighted directed graph: a phone user corresponds to a node; a directed edge from node v to node is established, if there exits communication from v to u , with the corresponding communication time as the weight of the edge.
We propose a new algorithm for mining top-K influential nodes, called Community-based Greedy Algorithm (CGA). The basic idea is to exploit the community structure property of social networks. Intuitively, a community is a densely connected subset of nodes that are only sparsely linked to the remaining network [8]. Communi-ties in a MSN represent real social groups [7], and thus individuals in a community will influence each other in the form of "word-of-mouth". The prohibitive cost of finding influential nodes over the whole network would be reduced greatly if we find influential nodes with regard to communities.

The main technical challenge of exploiting community structures to find top-K influential nodes is to choose which communities to mine the top-K influential nodes such that the results can be as close as the optimal solution. A straightforward solution is to mine top-K influential nodes in each community and then aggre-gate them to get the best K nodes. This is not desirable as it results in unnecessary computation. Instead we propose a dynamic pro-gramming method to incrementally choose which communities to process. Within a community we can adopt any existing algorithm to detect influential nodes. We also provide the provable approxi-mation precision of our proposed solution.

Another technical issue is that we need an efficient algorithm to partition the network into communities based on information diffu-sion model[10]. There exist a number of algorithms [3,8,13,18,20, 21, 23, 24] for community detection. However, none of them takes into account information diffusion between nodes. To this end, we extend the algorithm[18] running in O ( E ) , where E is the num-ber of edges, one of the most efficient algorithm for community partitioning, in three aspects: 1) We accommodate information dif-fusion model into the algorithm; 2) The algorithm[18] is designed for undirected and unweighted graphs and needs to be extended for weighted directed graphs; 3) The algorithm generates too many small dispersed communities and finding influential nodes with re-gard to the small communities is prone to errors. To remedy the problem, we extend the algorithm with a combination step: we de-fine combination entropy to measure the connection of two commu-nities and combine them if the combination entropy between them is larger than a threshold.

The proposed algorithm has two salient features. First, it can greatly improve the efficiency of the existing algorithms for finding top-K influential nodes while the loss in approximation precision is small. Second, it is orthogonal to existing algorithms for finding influential nodes in that it can combine with any of them by using them to detect influential nodes in a community.
 In summary our contributions are twofold.

First, we propose a new algorithm for finding top-K influen-tial nodes; the algorithm exploits the community property of social networks. We offer the provable performance guarantee of the al-gorithm. Second, we conduct experiments on a large mobile social network with 723K nodes (the largest network used in previous work has 37K nodes) to evaluate the performance of our algorithm. Experimental results show that our algorithm can improve the state-of-the-art Greedy algorithm[4] by orders of magnitude while the approximation ratio is comparable to the Greedy algorithm.
The remainder of this paper is organized as follows. Section 2 reviews related work. Section 3 presents problem statement. Sec-tion 4 details the Community-based Top-K Greedy algorithm and analyzes the precision of the algorithm. We report a performance evaluation in Section 5. Finally, we offer conclusions and research directions in Section 6.
Domingos and Richardson [6] are the first to study the influence maximization as an algorithmic problem and propose a probabilis-tic solution. Kempe et al. formulate the problem of finding a set of influential individuals as an optimization problem. They estab-lish that the optimization problem is NP-hard [10], and present a Greedy Algorithm (GA), guaranteeing that the influence degree is within (1  X  1 of the GA algorithm is to calculate the influence set of each indi-vidual, and take turns to choose the node maximizing the marginal influence value until K nodes are selected.

Leskovec et al.[14] present an optimized greedy algorithm, which is referred to as the "Cost-Effective Lazy Forward" (CELF) scheme. The CELF optimization uses the submodularity property of the in-fluence maximization objective to reduce the number of evaluations on the influence spread of nodes. Recently, Chen et al.[4] pro-pose two faster greedy algorithms called NewGreedy and Mixed-Greedy , respectively. Experiments show that MixedGreedy slightly outperforms NewGreedy . The main idea behind NewGreedy is to remove the edges that will not contribute to propagation from the original graph to get a smaller graph and do the influence dif-fusion on the smaller graph. The first round of MixedGreedy uses NewGreedy algorithm, and the rest rounds employ CELF algorithm. An earlier approach proposed by Kimura et al. [12] also removes edges that do not contribute to information diffusion, and does the propagation on the subnetwork. In addition, Chen et al.[4] also presents a degree discount heuristic algorithm called DegreeDiscount that runs faster than MixedGreedy . DegreeD-iscount assumes that the influence spread increases with the degree of nodes. Unlike Greedy algorithm, DegreeDiscount algorithm has no provable performance guarantee.

The aforementioned approaches attack the efficiency issue by ei-ther improving GA algorithm or using new heuristics. However none of them takes into consideration the community property of social networks.

We also note that Scripps et al.[20, 21] present a metric to esti-mate the number of communities to which a node is attached and define community-based roles for a node (e.g. a node that links to many nodes from different communities takes a so-called ambas-sador role). They also briefly discuss the application of community-based roles, i.e. selecting nodes with an ambassador role to maxi-mize the number of communities influenced by the selected nodes. The application problem is different from the influence maximiza-tion problem addressed in this paper and our algorithm is com-pletely different from the approach [20, 21].

Our work is also related to community detection. There are a host of algorithms for community detection. However, it remains to be a challenging problem for a large social network. Some ap-proaches assume that the number or size of the partitions into which the network is to be split is known in advance. They usually opti-mize a quality measure of network clustering, such as popular mod-ularity measure [17], and need to solve an NP-complete problem. Some popular heuristic algorithms include min-max cut method [3], normalized cut [22], SCAN[3] and Spectral Clustering[13]. In a Mobile Social Network, the number of communities and the size of communities are unknown. Also, these methods are quite ex-pensive when applied to a large network. A hierarchical clustering method [5] is proposed with complexity O ( Eh log N ) , where is the number of edges, N the number of nodes and h the depth of hierarchical clusters. Raghavan et al. [18] propose a near linear algorithm running in O ( E ) time, E the number of edges, which is less expensive than earlier algorithms. In [18], it uses a simple label propagation algorithm that uses the network structure alone as its guide and requires neither optimizing an objective function nor prior information about the communities. However, none of existing approach takes into account information diffusion.
Although we focus on mobile social network in this paper, mo-bile social network reflects the properties of other scale-free net-works, such as paper citation graph, in which degrees follow the the power-law distribution[19], and so does link-based similarity [2], and thus the proposed techniques would be applicable to other scale-free networks.
We introduce the Independent Cascade information diffusion model, and then the problem statement. Table 1 lists the notations to be used extensively in the rest of this paper.
 Notation Description
G =( V , E , W ) A weighted directed MSN with vertex set V , edge N The number of nodes in G
E The number of edges in G d The average degree of the network K The number of influential nodes to be mined I The set of K influential nodes
C i The i th community
M The number of communities  X  The average diffusion speed R ( A ) Influence degree in G of nodes in set A R m ( A ) Influence degree in community C m of nodes in A Mobile Social Networks. We extract a Mobile Social Network from the call log and model it as a directed weighted graph: a phone user corresponds to a node; a directed edge from node u to node is established, if there exits communication from u to v , with the corresponding communication time as the weight of the edge. We denoted the graph as G =( V , E , W ) , where V , E , and W represent nodes, edges, and weights, respectively.
 Independent Cascade Model. The model is originally proposed by Lopez-Pintado[15], and is the most common dynamic model in information diffusion. It is widely used in maximizing the number of individuals who are influenced by the merchandize information in direct marketing. It is used in previous work on influence maxi-mization [4, 10]. In the model we assign two states to nodes: active and inactive . Active nodes are those that are influenced by other active nodes, and are able to influence their inactive neighbors; in-active nodes are those that are not influenced by their active neigh-bors. The state of a node can be switched from being inactive to being active, but not vice versa. The model has an important pa-rameter called diffusion speed  X  . When an active node v i an inactive node v j , the inactive node becomes active at a prob-ability (rate)  X  . In a viral marketing, diffusion speed models the tendency of individuals to accept a product. Thus the diffusion is affected by diffusion speed, node degree, and the number of initial active nodes.

The Independent Cascade model does not take edge weight into consideration. However, a mobile social network is a directed weighted graph, and the weight should play an important role in informa-tion diffusion. Intuitively, the more contacts between two nodes, the more likely the influence will happen. We extend the defini-tion diffusion speed in the Independent Cascade model to accom-modate the edge weight. The influence rate raises as the weight between nodes increases. We note that Weighted Independent Cas-cade model [10], a special case of Independent Cascade model, considers node weight but not edge weight, and thus is still not di-rectly applicable to a MSN. We also note that Kempe et al. [10] also considers Linear Threshold model. As proved in [9], Lin-ear Threshold model and Independent Cascade model can be uni-fied with proper parameter initialization. We can extend the linear threshold model as we do for Independent Cascade model to ac-commodate edge weight, and our proposed algorithm is equally applicable.

DEFINITION 1. ( Diffusion Speed . ) The diffusion speed from node v i to node v j  X  ij is defined as: where  X  is the average diffusion speed of the whole network, the weight of direct edge from v i to v j , w min is the minimum weight of directed edge and w max the maximum weight in the network.
Then the diffusion mechanism can be described as follows: 1. The diffusion process begins with an initial set of active nodes 2. At each step t , an active node v i from last step S t 3. The process terminates when S t is empty. The set of nodes
DEFINITION 2. ( Influence Degree ) Let A be the ini-tial set of active nodes. The influence degree of set A is computed as: where V A is the number of nodes influenced by A during informa-tion diffusion process.
 ProblemStatement : Given a mobile social network G =( V , W ) , we aim to mine a set of top-K influential nodes S on the net-work such that R ( S ) is maximized using the extended Independent Cascade information diffusion model.
 It has been proved that the optimization problem is NP-hard [10]. A greedy algorithm can approximate the optimum to within a factor of (1  X  1 the influence maximization problem on a large-scale network. So we propose a community based greedy algorithm which mine the influential nodes in each community rather than the whole network. We first present the proposed algorithm CGA for mining top-influential nodes in communities, and then present the partitioning algorithm that takes into account the diffusion model. We also pro-vide precision analysis of the proposed algorithm.
Although a greedy algorithm gives a good approximation to the problem of finding top-K influential nodes, it is expensive for large networks.

We first present an important concept to be used in the rest of subsection. We say that a node v influences node u if node vates node u , i.e. u becomes active from inactive, for at least times out of Q simulations of the diffusion process of Independent Cascade model. We also say that u is influenced by v . Recall that whether v can influence u depends on the influence speed and also the weight from v to u .

The main idea of our method is to divide a network into commu-nities, and then choose communities to find top-K influential nodes within communities. The community structure is a salient property of social network features: Individuals within a community have frequent contact and thus are more likely to influence each other; In contrast, individuals across communities have much less con-tact with each other and thus are less likely to influence each other. This property suggests that it might be a good approximation to choose influential nodes within communities instead of the whole network. Obviously it will be more efficient to choose influential nodes within communities.

Suppose that we already divide a network into M communities (to be discussed in the next subsection). The remaining technical challenge is to choose which communities to find the top-ential nodes. A straightforward solution is to mine top-K tial nodes in each community and then aggregate them to get the top-K nodes. This is not desirable as it wastes some computation.
We propose a dynamic programming algorithm to choose which community to find the k th influential node, k  X  [1 ,K ] . Let the set of influential nodes obtained in the previous k -1 steps. We are then ready to compute the maximal increase of the influence degree with regard to community C m if we mine the k th node in C . The maximal increase is denoted as  X  R m and we have:
Note that in Equation 3 the influence degree R m ( . ) is computed with regard to the community C m rather than the whole network. nity that will yield the largest increase of influence degree among all the communities. Let R [ m, k ] ( m  X  [1 ,M ] and k  X  the influence degree of mining the k th influential node in the first m communities. We have:
The Equation 4 can be understood as follows: If the influence de-gree of mining the k th node in the first m -1 communities is smaller than that of mining the k th node in C m , we mine the k th node in C ; otherwise, we mine it in the former m -1 communities.
We select a community from the first m communities to mine by a sign function s [ m, k ] . It is defined as follows: s [ m, k ]=
To find the k th , k  X  [1 ,K ] , influential node, we choose the com-munity s [ M, k ] (Note that these sign functions s [ m, k ] are used to compute s [ M, k ] ).

In principle, we can use any existing algorithm to find the influential node in community s [ M, k ] . In this paper, we adopt the MixedGreedy algorithm [4] since it has the same approximation precision as previously proposed greedy algorithms and is shown to be more efficient.
 Algorithm 1 CGA Algorithm 1: C X  detect communities in G ; 2: M = |C| 4: for k =1 to K do 6: end for 7: for m =1 to M do 8: R [ m, 0] = 0 ; 9: end for 10: for k =1 to K do 11: for m =1 to M do 15: s [ m, k ]= s [ m  X  1 ,k ] ; 16: else 17: s [ m, k ]= m ; 18: end if 19: end for 20: j = s [ M, k ] ; 23: end for
The algorithm is outlined in Algorithm 1. It first detects commu-nities (line 1), and initializes the set of influential nodes discovered in the whole network ( I ) and in each community ( I 1 , ..., I NULL (line 3). The algorithm initializes R [ m, k ] and s [ m, k ] 4 X 9). In lines 10  X  19, the algorithm chooses which community to If the sum of the influence degree  X  R m and R [ M, k  X  1] is smaller than R [ m  X  1 ,k ] , i.e. the influence degree of mining k th node in the first m -1 communities (line 14), we should not find the node in community C m and thus label s [ m, k ] as s [ m  X  15); otherwise we mine the k th node in community C m and set s [ m, k ] as m (line 17). The algorithm will find the k th influen-tial node in the community C j , j = s [ M, k ] (line 20). We employ MixedGreedy algorithm[4] to find the node v max that maximizes R ( I j  X  X  v i } )  X  R ( I j ) in community C j (line 21).
We proceed to illustrate the CGA Algorithm with an example. 1. We mine top-2 nodes from a network. Assume that the net-2. We proceed to find which community to mine top=1 node. 3. Next, R [1 , 2] = max { R [0 , 2] ,R [3 , 1] +  X  R 1 }
Complexity Analysis: We consider the complexity of lines 2 X 23 of Algorithm 1 (line 1 will be analyzed in next subsection). The algorithm needs O ( K ) time in lines 4 X 6, and O ( M ) time in lines 7 X 9. Suppose the largest community after community detection is C , thus lines 10 X 19 take O ( MKT p ) time, and lines 20 X 23 of min-ing nodes using MixedGreedy algorithm [4, 14] (that uses New-Greedy [4] in the first round and uses CELF algorithm [14] for the rest rounds) take O ( K | C p | T p ) time, where T p compute the influence degree of a node in community C p , and it takes O ( QE p ) time (where Q is the number of simulations for the Independent Cascade model, and E p is the number of edges in community C p ). Hence the worst-case complexity of lines 2 X 23 of Algorithm 1 is O ( MKT p + K | C p | T p ) .
Community structure is a basic property of a MSN and com-munities represent real circles of social groups in which members are more likely to influence each other[1, 7]. We will make use of the detected communities to approximate the influence of nodes in the whole network. Hence, we want to detect communities based on the influences between nodes, rather than only the connection between nodes, such that the influence degree of nodes within a community can be as close as that in the whole network. There exist a number of algorithms for community detection, and they partition graphs based on the node connections. However, none of them takes into account information diffusion between nodes.
Our community detection algorithm consists of two steps, parti-tion and combination. 1) Partition. we extend the algorithm[18] with the information influence mechanism based on Independent Cascade model. The algorithm[18], a nearly linear algorithm for community detection, is designed for undirected and unweighted graph, and thus is not directly applicable to a MSN. 2) Combina-tion. The generated communities in a MSN by the partition step are very small and dispersed; we develop a method to combine commu-nities such that the difference between influence degree of a node in its community and its influence degree in the whole network is restricted. We proceed to present the two steps.
We proceed to present an overview of our partitioning method. 1) Initially, each node is assigned a unique community label from 1to N (the number of nodes); 2) for each node we compute the set of its influenced neighbors using Independent Cascade diffusion model; 3) we iteratively propagate the labels through the network in finite iterations. The main principle of the label propagation is that a node v should belong to the community that contains the maxi-mum number of its influenced neighbors. In algorithm [18], label propagation is performed among a node and its neighbors while we perform the propagation among a node and its neighbors that can be influenced by the node (based on Independent Cascade model). Note that this principle also renders our community detection prob-lem different from that considered in previous proposals, e.g. [18].
Steps 1 and 2 are straightforward and we proceed to explain the step 3, i.e. to perform the propagation of community label. This propagation is iterative in nature. At each iteration of the label propagation, we assign the community label for a node v based on the labels of its neighbors that are influenced by v . Specifically, for each node v we find out the label of the community that the majority of its influenced neighbors belong to, and the label will become the label of v . Formally, the label, denoted by v.C node v at iteration t is represented as follows: where t denotes the t th iteration, s v denotes the number of neigh-bors that are influenced by v , u i ( i  X  [1, s v ]) represents an influ-enced neighbor of node v , u i .C t  X  1 represents the community label of u i at iteration t -1, and maxCMT is to compute the majority la-bel of u i .C t  X  1 ( i  X  [1, s v ]).

The partition step is detailed in lines 1 X 16 in Algorithm 2. The algorithm takes in three arguments, a network G , the number of it-erations  X  and a threshold  X  to be used by the combination step. In the algorithm, a node v belongs to a community and its community label is denoted as v.C . Node v is also associated with a bit vector H v of length d v that is the degree of node v . Each neighbor of v corresponds to a bit H v ( j ) , j =1 , ..., d v ,in H v ences its neighbor u j , the corresponding bit H v ( j ) is set to 1 and otherwise 0. We can easily compute s v , the number of neighbors influenced by v , by counting the number of bit 1 in H v . The algo-rithm initializes the community label of each node v and finds the set of neighbors that are influenced by node v in lines 1 X 10. The function IsInfluence is implemented according to the definition of influence (Section 4.1). The algorithm then iteratively propagates community labels in lines 11 X 16: At each iteration t , we update the label of node v with the majority label of its neighbors that are influenced by v . It has been shown in[18] that the propagation will become relatively stable in a few iterations.
We expect that the difference between the node X  X  influence de-gree in its community and its influence degree in the whole network is small. To achieve a good set of top-K influential nodes with a good influence degree in our algorithm, we define combination en-tropy to measure the connections of two communities and combine two communities if the combination entropy between them is larger than a threshold.

DEFINITION 3. ( CombinationEntropy ) If a node v influences (activates) its neighbor u , we label the edge [10]. If e vu is live and v belongs to community C m ,but to a different community C l , we say that u is a live node of C L [
C m ] be the set of live nodes of C m . The combination entropy of community C l to C m is defined as: where R m ( { u } ) denotes the influence degree of node u outside the community C m , and R m ( { v } ) denotes the influence degree of node Algorithm 2 Community Detection 1: for each v  X  V do 3: for each neighbor u j of v do 6: else 8: end if 9: end for 10: end for 11: for t =1 to  X  do 12: for each v  X  V do 14: end for 15: t = t +1 ; 16: end for 18: for each v  X  V do 22: end if 23: end for 24: end for 25: isComb =1 ; 26: while isComb =1 do 27: for each community C m do 29: isComb =0 ; 31: Compute combination entropy CoEntropy( CE l m ) for com-34: isComb =1; 35: end if 36: end for 37: end for 38: end while v in its community C m . As we detect the communities based on diffusion model, we have R m ( { u } )  X  R l ( { u } ) .
For a node v in C m , L [ C m ] includes its influenced neighbors such that they will make diffusion degree of v with regard to C ent from diffusion degree of v with regard to the whole network. Intuitively, combination entropy measures the difference of diffu-sion spread of a node v ( vin C m ) between in the community and in the whole network through a node in L [ C m ] . The difference reflects the precision loss due to diffusion within communities.
We set a threshold  X  . If the combination entropy CoEntropy ( C m and C l will be combined.
 The combination step is outlined in lines 17 X 38 in Algorithm 2. In lines 17 X 24, we compute the set L [ C m ] for each community. The algorithm checks each node in L [ C m ] set and decides whether C is combined into community C m (lines 25 X 38). To make sure the combination entropy between any two communities is less than we perform the combination iteratively. We use a variable to record whether two communities are combined in each iteration; if no combination is done in an iteration ( isComb =0), we termi-nate the while-loop.
 Complexity Analysis : It needs O ( EQ ) time in lines 1 X 10, where Q , the rounds of simulations, is constant. Lines 11 X 16 need time, where  X  is constant. Lines 17 X 24 needs O ( E ) time. Let and M denote the number of communities before and after com-bination, respectively. Let C p be the maximal community. Recall that computing the influence degree for one node in C p take time. Lines 25 X 38 take O (( Z  X  M ) NT p ) time in the worst case: the number of iterations is Z -M in the worst case; each iteration takes O ( NT p ) time in the worst case, where we compute influence degree at N nodes at most. Note that in practice it will be much less expensive than the worst case complexity since it is very likely that we do not need to compute influence degree for all nodes, and the number of iterations is smaller than Z -M , and many communities are smaller than the maximal community C p . Hence the worst-case complexity of Algorithm2 is O ( E +( Z  X  M ) NT p ) . Taken together with the complexity of Algorithm1, the total worst-case complexity is
O ( E +( Z  X  M ) NT p + MKT p + K | C p | T p ) .
We proceed to derive the performance guarantee of the CGA by analyzing the approximation ratio of CGA.

LEMMA 1. Consider a node v in community C m . The in-fluence degree R m ( { v } ) of node v in its community is approximate to the influence degree in the whole network G , where  X  is the threshold used in the combination step in Algorithm 2 and  X  d is the maximal difference between the number of nodes affected by a node in network G and that in community C m . We have
PROOF. Let  X  R ( { v } )= R ( { v } )  X  R m ( { v } ) be the difference of the diffusion degree in C m and G . As the combination is based on combination entropy CoEntropy ( CE l m ) and follows threshold  X  , we have the following: where d [ v ] denotes the number of active neighbors of node fluenced by v in the whole network, d m [ v ] denotes the number of active neighbors of node v influenced by v in the community C and  X  d [ v ]= d [ v ]  X  d m [ v ] .
 Thus, we have
R m ( { v } )  X  We get the proof.
 When the directed weighted mobile social network G =( V , and diffusion speed  X  are given, the number of neighbors that a node can activate in network G or a community can be estimated. Thus  X  d is a small number.  X  is a constant.

THEOREM 1. Let I  X  be the set of K nodes that maximize the influence degree, i.e. the optimal solution to our problem; let I be the set of K nodes discovered by our algorithm; let and R ( I ) be the influence degree of the two sets, respectively. The proposed CGA obtains a (1  X  e  X  1 1+ X  d  X  ) -approximation, that is
PROOF. Let R m ( { v i } ) be the influence degree of node v community C m and R ( { v i } ) be the influence degree of node in the whole network. Let I ( k ) be the first k nodes in I . Let the in I be v k .

At least R ( I  X  )  X  R ( I ( k  X  1)) individuals that are not covered by
R ( I ( k  X  1)) are covered by the k subsets of R ( I  X  ) [16]. Hence, according to the pigeonhole principle , one of the k subsets in the uals[16]. As we spread the diffusion in community C m , the in-fluence degree of v k , R ( { v k } )  X  R ( I  X  ( k ))  X  R above analysis, we have R ( I (1))  X  R ( I  X  ( K )) following deduction process:
R ( I ( K )) = R ( I ( K  X  1)) + R { v K } lim As f ( K )=(1  X  1 tion, e  X  1 1+ X  d X  is the upper bound of f ( K ) . Hence 1  X  is the lower bound of 1  X  (1  X  1 e
Based on Theorem 1, we can derive that CGA is a more general formulation compared with greedy algorithm for mining top-fluential nodes in social networks. When  X  =0, as K approaches  X  , the approximation factor (1  X  (1  X  1 (1  X  1 /e ) , the approximation factor of Greedy Algorithm (GA). It shows the lower bound of our CGA is (1  X  1 /e ) at  X  =0 , which is the same precision with that of GA. This is to say that GA is an instance of CGA.

Remarks: The parameter  X  actually plays a role in balancing the approximation precision and efficacy. When  X  =0 , the num-ber of generated communities will be 1, i.e. all communities will be combined into one, our algorithm is the same as the original Greedy algorithm with (1  X  1 /e ) -approximation. If  X &gt; 0 have (1  X  e  X  1 1+ X  d X  ) -approximation. As  X  becomes smaller, the precision becomes higher; the number of generated communities M will become smaller and thus the complexity becomes larger.
We evaluate the effectiveness and efficiency of the proposed CGA algorithm.

The data sets we used and experimental setup beforehand are described at first, and then the results with different parameters are shown.
 All the experiments were conducted on a server with 2.0 GHz Intel Xeon 8 Core CPU and 8G memory running Debian/4.0 Oper-ating system.

We have a three-month CDR (call detailed record) data of a city from China Mobile, the largest mobile communication service provider in China. We extract a Mobile Social Network from the CDR data using the method presented in Section 3, and obtain a network with 723,201 nodes and an average degree of 13.4. Fig-ure 1 shows the degree distribution of the mobile social network. We can see that it follows the power-law distribution, i.e. it is a scale-free network as many other social networks.
We take MixedGreedy [4] as the benchmark to evaluate the pro-posed algorithm CGA for two reasons. First, MixedGreedy is the state-of-the-art Greedy Algorithm for influence maximization, and it is shown that MixedGreedy outperforms previously proposed Greedy Algorithms, such as GA[10] and CELF[14]. Second, CGA adopts MixedGreedy to find influential nodes within communities, and thus a performance comparison between them will reveal their pros and cons.

Additionally, we compare with the other greedy algorithm pro-posed by Chen et al. NewGreedy [4]. We also compare with two heuristic algorithms DegreeDiscount [4] (See related work) and Random (simply select K random nodes in the graph; it is evalu-ated in [4, 10]). To study the usefulness of the proposed commu-nity detection algorithm for CGA, we modify the algorithm CGA by replacing its community detection method (Section 3.2) with the community detection algorithm in [18], and the modified CGA is denoted as SPCGA.

We use two metrics to evaluate performance, namely the influ-ence degree and runtime, by following the previous work on influ-ence maximization.

We also evaluate the effect of parameters on performance, in-cluding the number of required nodes ( K ), the average influence speed (  X  ), and the threshold for community combination ( parameters K and  X  , we take both the previous work [4,12] and our actual network into consideration to choose the range of values.
This experiment is to evaluate the performance of the proposed community detection algorithm on a Mobile Social Network. In the Independent Cascade diffusion model, we use the diffusion speed 0 . 05 , and set the number of simulations as 100; a neighbor of a node is influenced by the node if the neighbor is activated by the node for at least 50 times in 100 simulations. To choose a value for the parameter  X  , the threshold for combination, we do experiment on a sub-graph with 1000 nodes (we randomly select a node from the whole MSN, and do a depth-first traversal starting from the se-lected node to get 1000 nodes). We do experiment with different from 0.1 to 0.6 to combine the communities generated in the par-tition step. When  X  =0.1, all the communities are combined; when  X  =0.2, most of the communities are combined and the number of final communities is only 5; when  X  =0.5, the generated communi-ties are dispersed and small (24 of them have less than 10 nodes); when  X  =0.3, we get 11 communities and this appear to be an ap-propriate number after we check the data manually. Hence we set  X  =0.3 as the threshold. Another parameter to be set is the number of iterations. It is suggested that the partitioning result would usu-ally become relatively stable after 5 iterations in [18]. We observe that it is not completely stable after 5 iterations, i.e. the partitions of some nodes are still changed. To be safe, we set the number of iterations at 20 to make it more stable.

It takes 8,702 seconds for the proposed community detection al-gorithm to complete on the whole graph. In this paper, we take the runtime of community detection as part of runtime of CGA al-gorithm. However, in practice the community detection could be regarded as a pre-processing step since after the community de-tection is done we can find top-K nodes with different K The algorithm partitions the whole network into communities. It returns 36 communities(ignoring very small communities), among which the size of the largest community is 95,690 and the others are smaller. The size distribution of extracted communities is shown in Figure 2. This experiment is to evaluate the effect of the parameter the influence degree and efficiency of different algorithms. We fix the average influence speed  X  at 0.05, network size at 723k and combination threshold at 0.3. We vary K from 1 to 30. The results are shown in Figure 3(a) and 4(a). Note that the reported runtimes of CGA and SPCGA include the time used to detect communities, which are 8,702 seconds and 1,714 seconds, respectively. Note that we use logarithmic scale for y-axis in Figure 4(a).

It can be seen in Figure 3(a) that 1) the influence degree of CGA is close to those of MixedGreedy and NewGreedy (the curve of MixedGreedy is almost overlapping with that of NewGreedy )at all values of K , and 2) the influence degree of CGA is much better than those of two heuristic methods DegreeDiscount and Ran-dom . For example, at K = 20, the influence degree of CGA is 89.96% of that of MixedGreedy while the influence degree of De-greeDiscount (resp. Random ) is only 57.62% (resp. 55.72%) of that of MixedGreedy .

We also observe in Figure 4(a) that CGA is orders of magni-tude faster than MixedGreedy . For example, at K = 20, CGA is 14.56 times faster than MixedGreedy . This is because CGA finds influential nodes in several communities, following the divide-and-conquer principle; however MixedGreedy is based on the whole network. We also find that the speedup factor increases as we in-crease the value of K .

As expected, the two heuristic methods run much faster than all greedy algorithms, especially Random needs only around 3 sec-onds. However, they perform poorly in terms of influence degree. This is consistent with the experimental results reported in previ-ous work[4, 10] X "significantly better marketing results can be ob-tained by explicitly considering the dynamics of information in a network, rather than relying solely on structural properties of the graph[10]." This would also explain why the greedy algorithms are proposed and used for influence maximization in previous work al-though heuristic methods run faster. The heuristic methods do not take information influence model into consideration, and they can-not guarantee the precision.

We find that CGA outperforms SPCGA in terms of influence degree while their runtime is similar. The only difference between them is community detection method. Hence, this demonstrates the usefulness of the proposed community detection method of CGA in finding top-K influential nodes.
This experiment is to compare with other algorithms in terms of influence degree and efficiency when we vary the average diffusion speed  X  . We vary  X  from 0.01 to 0.10 (0.01, 0.1 are used in [4,12]). This experiment is conducted on the whole network with 723,201 nodes and we set K = 20. Figures 3(b) and 4(b) show the influence degree and runtime of different algorithms, respectively. Note that we use logarithmic scale for y-axis in Figure 4(b).

Figure 3(b) shows that the influence degree of CGA is very close to the influence degree of MixedGreedy and NewGreedy at all values of  X  . We observe that the influence degree of the two meth-ods is nearly the same when  X &lt; 0 . 07 (although it cannot be seen clearly in the figure); the influence degree disparity between CGA and MixedGreedy becomes a bit larger as we increase the diffu-sion speed. This is because as the influence speed increases, a node in one community is more likely to influence the nodes in other communities, and thus the approximation of CGA would become less accurate.
 Figure 4(b) shows that CGA runs orders of magnitude faster than MixedGreedy . We also find that when we increase  X  the efficiency of MixedGreedy drops quickly (almost exponentially) while the runtime of CGA only increases slightly.

As the size of community is much smaller than the size of the whole network, increasing  X  would incur much more computation on the whole network than each community. This would explain why the runtime of MixedGreedy increases nearly exponentially while the runtime of CGA only increases moderately. When  X  smaller than 0.02, our CGA costs more time than MixedGreedy , this is because our CGA includes community detection time, the community detection time is relative large when  X  is very small. So CGA shows its advantages when  X  is larger than 0.02. When larger than 0.06, experiments on MixedGreedy and NewGreedy cannot complete in 10 days, and thus we do not give the runtime in Figure 4(b).

It can be seen that the influence degree (precision) of DegreeD-iscount and Random is much worse than those of greedy algo-rithms. For example, at  X  =0 . 01 , the influence degree of De-greeDiscount (resp. Random ) is 40.42% (resp. 29.87%) of that of MixedGreedy while CGA is 95.44% of MixedGreedy .

As expected, DegreeDiscount and Random are much faster than all greedy algorithms that take into account Independent Cas-cade model. However, their precision is much worse than that of greedy algorithms, rendering the heuristic algorithms less attractive than greedy algorithms [10]. The objective of this experiment is to evaluate the scalability of CGA and other algorithms when we increase the network size. We set diffusion speed  X  at 0.05 and K at 20. Figure 3(c) and Fig-ure 4(c) show the results of influence degree and runtime, respec-tively, when we vary the network size N from 10K to 100K. Here we randomly select a node, and then starting from the node do a bread-first traversal to generate subnetworks of different sizes.
Figure 3(c) shows the influence degree is relatively stable across the networks of different sizes for all the methods. It is consistent with the previous experiments that the precision of the two heuristic methods is much worse than that of greedy algorithms. We can see from Figure 4(c) that the runtime of both CGA and MixedGreedy increases with the increase of network size; however CGA scales better than MixedGreedy .
This experiment is to evaluate the effect of community combina-tion threshold  X  (i.e., the number of network communities in MSN) on the performance of CGA. This experiment is conducted on the whole network with 723,201 nodes and we set K =20and  X  =0.05. Since this experiment is to study the effect of  X  on CGA, we do not compare with MixedGreedy .

Table 2 gives the number of communities detected when we in-crease  X  from 0 to 0.6. The results of influence degree and runtime are shown in Figures 5(a) and 5(b), respectively.
As shown in Figure 5(a), the influence degree drops slowly as we increase  X  . The reason is that CGA finds influential nodes within a community and does not consider the influences on nodes in other communities; thus as the network is partitioned into more commu-nities, the precision of CGA will drop. Figure 5(b) shows that CGA runs faster with the increase of  X  . The reason is that with the in-crease of  X  , more communities will be generated and the average size of community will be smaller, thus CGA will run faster.
We observe that  X  plays a tradeoff between the runtime and influ-ence degree: with the increase of  X  , CGA achieves better efficiency but at the price of slight loss of influence degree. For example, when we increase  X  from 0.1 to 0.5, CGA runs about 39.63 times faster, while the influence spread drops about 38.25%. This is con-sistent with our theoretical analysis in Section 4. Note that when is 0, CGA works on the whole network and is actually the same as MixedGreedy .
In this paper we propose a new algorithm called Community-based Greedy algorithm for mining top-K influential nodes in a MSN. We first extend the basic Independent Cascade model to take weight edge of MSN into consideration. CGA has two main com-ponents, an algorithm for detecting communities by taking into account information diffusion, and a dynamic programming algo-rithm for selecting communities to find influential nodes. We also provide provable approximation guarantees for CGA. Empirical studies on a large real-world mobile social network show that our algorithm is more than an order of magnitudes faster than the state-of-the-art Greedy algorithm for finding top-K influential nodes and the error of CGA is small compared with Greedy algorithm. This work opens to several interesting directions for future work. Notably, it is relevant to take spatial information of mobile cus-tomers into consideration, and construct locations based social net-works to find influential nodes; it is also interesting to study the evolution of influential nodes over time.
This work is supported by the National Natural Science Founda-tion of China (60703066, 60874082), and Beijing municipal natural science foundation (4102026).
