 For a large peer-to-peer file-sharing system, searching a file by its name is an essen-tial problem. One initial approach is to setup up a server which maps a file name to its location. Napster ([6]) uses this approach. The problem of this approach is that it uses an unscalable central database to index all files. Another initial approach is that a node broadcasts the search request to all its neighbors when it does not find the file in its local database. Gnutella ([7]) adopts this approach. However this approach doesn't scale well because of its bandwidth consumption and unrelated search in many nodes. 
To overcome the scalability problem, several algorithms based on a distributed hash table (DHT) approach are presented ([1], [8], [9], [10], [11]). In these algo-rithms, each node in the system maintains a small routing table to form an overlay network and each data item is associated with a unique key which is hashed to deter-mine which node it will be stored at. When a search request is received by a node that does not store the search key, the node will use its routing table to routing the request to a neighbor which is closer to the key. Because hashing does not keep the order of the keys, DHT systems do not support range queries efficiently. 
Two recent papers [2] [3] try to build a peer -to-peer system on the skip list data structure. The paper [2] describes a distributed data structure called skip graphs. In a skip graph, search, insert and delete opera tions are done in logarithmic time. Because of no hashing, skip graphs support range queries more efficiently than DHT. Skip graphs also are highly resilient to node failures because they have many redundant links among nodes. The paper [3] describes a distributed data structure called SkipNet which is very similar to skip graphs. One problem of these two data structure is there are a lot of links. With N resources in the network, there is a total of O( N log N ) links. 
To decrease the number of links, this paper introduces a new scalable distributed data structure LinkNet which is built on the list data structure. To help our discussion, we briefly define some terms first. A peer-to-peer system consists of many nodes . Each node has a unique location . Typically a node's location is its IP address or domain name. A node stores many data items or elements . An An element is mapped to a pointer . A pointer is a pair &lt; location , key &gt;. Two elements form a link if their order is known. If a link is physically stored in main memory or second memory, it is a physical link ; otherwise it is a virtual link . 
Fig.1 shows a network-based sorted doubly linked list. Search in a network-based sorted doubly linked list is simple and slow. For example, to find key 98 starting from search will only go though key 4, 88, 98 and node 3, 1, 2 if the virtual link &lt;4, 88&gt; is used. For all keys in the same node, one key can share another key's pointers to form virtual links. LinkNet uses virtual links to speed search. Fig.2 shows a list-based LinkNet corresponding to Fig.1. In Fig.2, virtual links are marked by dot lines. The node 4 fails, it is still possible to find key 98 starting from key 4. 
The disadvantage of list-based LinkNet is that its performance depends on the dis-tribution of elements heavily. If each node stores only one element, the list-based LinkNet is degenerated into a network-based sorted doubly linked list. To avoid this problem, skip-list-based LinkNet is built and it is discussed in the next section. In LinkNet, a node can store many elements. These elements are stored in a sorted doubly linked list. A new LinkNet has only two special elements: header which is given a key less than any legal key, and nil which is given a key greater than any legal key. Each element has a level which is a random number capped at MaxLevel . It is not necessary that all elements are capped at the same value of MaxLevel . Our approach for concurrent operations is similar to the approach in paper [5], thus we omit the proofs of correctness in this paper. To describe the operations for LinkNet, we denote node as u , v and element as x , y . A node has a location ( u .location). When there is no confusion, the location of a node x .neighbor[R][ l ] and x .neighbor[L][ l ]. If x .location is equal to u .location, the element x is stored on the node u ; otherwise x is a pointer that points to the element x . 
The search operation (algorithm 1 in Fig.3) can be started from any node. If no elements are stored on the node, function isEmpty() creates a new LinkNet on this node and returns true. Function chooseSide() is used to decide the search direction. If there is an element whose key equals to th e search key, function localSearch() returns that element, otherwise it returns an element which is the nearest element to the search key following the search direction. new element in the level 1 of LinkNet. The search returns an element y which is the predecessor of the new element x and y 's forward pointer points to x  X  X  successor. The next step is to insert the new element into a node. A random level generated by func-tion randomLevel() is assigned to the new element. If the random level given to the new element is greater than 1, the new element will be inserted into the LinkNet level by level. The level of the element header and nil is not less than the level of any ele-ment in the LinkNet. 
The delete operation (algorithm 4 in Fig.3) is simple. A node can only delete the element stored on it. To delete an element x , it is not correct to immediately garbage collect x because other operations may have a pointer to x . Instead, func-tion putOnGarbageQueue() is used to put x onto a garbage queue whose element can be taken off any time after the completion of all searches/insertions/deletions that were in progress. 
An M elements skip-list-based LinkNet needs expect O( M ) space overall. The number of messages exchanged among nodes is used to evaluate the algorithms. For an M elements skip-list-based LinkNet, an operation (i.e. a search, insertion or dele-tion) takes expected O(log M ) messages. The search algorithm of LinkNet is simulated on a PC. The LinkNet is built with two keys are generated by a uniform random number generator. Each node has a random number of keys. The simulation search random keys starting from random selected nodes for 10,000 times to evaluate the search algorithm by the average number of hops. A hop is a message passing from one node to another node. 
The experiment results are shown in Fig.4 and Fig.5. In Fig.4, each node has aver-age 100 keys. In Fig.5, there are 100 nodes. 
The experiment shows that the search performance of list-based LinkNet is worse than that of skip-list-based LinkNet. Fig.4 also shows that when the number of nodes increases and the average number of keys of each node is a constant, the average number of search hops on skip-list-based LinkNet is O(log( M )). Fig.5 also shows that when the average number of keys on each node increases and the num-ber of nodes is a constant, the average number of search hops on skip-list-based LinkNet approaches log( N ). We have defined a new scalable distributed data structure LinkNet. By adding virtual network, the expected total space this data structure takes is O( M ), and when M is big enough, the search operation takes expected O(log N ) messages among nodes. Addi-tionally, the virtual links enhance fault tolerance of LinkNet. 
Because LinkNet keeps the order of the keys, it provides better support for range query than DHT. LinkNet also benefits many other operations. For example, it is more efficient than DHT to merge two LinkNets, split a LinkNet, and bulk load data into a LinkNet. school of computing, National University of Singapore. The design presented here is the result of much fruitful discussion with Beng Chin Ooi. 
