 Ian J. Goodfellow goodfeli.@iro.umontreal.ca Aaron Courville Aaron.Courville@umontreal.ca Yoshua Bengio Yoshua.Bengio@umontreal.ca DIRO, Universit  X e de Montr  X eal, Montr  X eal, Qu  X ebec, Canada We consider here the problem of unsupervised feature discovery for supervised learning. In supervised learn-ing, one is given a set of examples V = { v (1) ,...,v ( m ) } and associated labels { y (1) ,...,y ( m ) } . The goal is to learn a model p ( y | v ) so that new labels can be pre-dicted from new unlabeled examples v .
 The idea behind unsupervised feature discovery is that the final learning problem can become much easier if the problem is represented in the right way. By learn-ing the structure of V we can discover a feature map-ping  X  ( v ) that can be used to preprocess the data prior to running a standard supervised learning algorithm, such as an SVM.
 There has been a great deal of recent interest in in-vestigating different unsupervised learning schemes to train  X  from V . In particular, the goal of deep learn-ing (Bengio, 2009) is to learn a function  X  that con-sists of many layers of processing, each of which re-ceives the previous layers as input and incrementally disentangles the factors of variation in the data. Deep learning systems are usually created by composing to-gether several shallow unsupervised feature learners. Examples of shallow models applied to feature dis-covery include sparse coding (Raina et al., 2007), re-stricted Boltzmann machines (RBMs) (Hinton et al., 2006; Courville et al., 2011b), various autoencoder-based models (Bengio et al., 2007), and hybrids of autoencoders and sparse coding (Kavukcuoglu et al., 2010). In the context of probabilistic generative mod-els, such as the RBM,  X  ( v ) is typically taken to be the conditional expectation of the latent variables, and the process of learning  X  consists simply of fitting the gen-erative model to V .
 Single-layer convolutional models based on simple fea-ture extractors currently achieve state-of-the-art per-formance on the CIFAR-10 object recognition dataset (Coates and Ng, 2011; Jia and Huang, 2011). It is known that the best models for the detection layer of the convolutional model do not perform well when fewer labeled examples are available (Coates and Ng, 2011). In particular, sparse coding outperforms a sim-ple thresholded linear feature extractor when the num-ber of labeled examples decreases. Our objective is to further improve performance when the number of la-beled examples is low by introducing a new feature extraction procedure based on spike-and-slab sparse coding. We hypothesize that these features have a stronger regularizing effect than sparse coding fea-tures. Their superior performance with low numbers of labeled examples allows us to improve performance on datasets with high numbers of classes and low num-bers of labeled examples.
 In this paper we overcome two major scaling chal-lenges. First we scale inference in the spike-and-slab coding model to work for the large problem sizes required for object recognition. We then use the enhanced regularization properties of spike-and-slab sparse coding to scale object recognition techniques to work with large numbers of classes and small amounts of labeled data. The Spike-and-Slab Sparse Coding (S3C) model con-sists of latent binary spike variables h  X  X  0 , 1 } N , latent real-valued slab variables s  X  R N , and real-valued D -dimensional visible vector v  X  R D generated according to this process:  X  i  X  X  1 ,...,N } ,d  X  X  1 ,...,D } , where  X  is the logistic sigmoid function, b is a set of biases on the spike variables,  X  and W govern the lin-ear dependence of s on h and v on s respectively,  X  and  X  are diagonal precision matrices of their respec-tive conditionals, and h  X  s denotes the element-wise product of h and s .
 To avoid overparameterizing the distribution, we con-strain the columns of W to have unit norm, as in sparse coding. We restrict  X  to be a diagonal matrix and  X  to be a diagonal matrix or a scalar. We refer to the variables h i and s i as jointly defining the i th hidden unit, so that there are a total of N rather than 2 N hidden units. The state of a hidden unit is best un-derstood as h i s i , that is, the spike variables gate the slab variables.
 In the subsequent sections we motivate our use of S3C as a feature discovery algorithm by describing how this model occupies a middle ground between sparse coding and the spike-and-slab Restricted Boltzmann Machine (ssRBM). The S3C model avoids many disadvantages that the ssRBM and sparse coding have when applied as feature discovery algorithms. 2.1. Comparison to sparse coding Sparse coding has been widely used to discover fea-tures for classification (Raina et al., 2007). Recently Coates and Ng (2011) showed that this approach achieves excellent performance on the CIFAR-10 ob-ject recognition dataset.
 Sparse coding (Olshausen and Field, 1997) describes a class of generative models where the observed data v is normally distributed given a set of continuous latent variables s and a dictionary matrix W : v  X  N ( Ws, X  I ). Sparse coding places a factorial prior on s such as a Cauchy or Laplace distribution, chosen to en-courage the mode of the posterior p ( s | v ) to be sparse. One can derive the S3C model from sparse coding by replacing the factorial Cauchy or Laplace prior with a spike-and-slab prior.
 One drawback of sparse coding is that the latent vari-ables are not merely encouraged to be sparse; they are encouraged to remain close to 0, even when they are active. This kind of regularization is not necessarily undesirable, but in the case of simple but popular pri-ors such as the Laplace prior (corresponding to an L 1 penalty on the latent variables s ), the degree of regu-larization on active units is confounded with the degree of sparsity. There is little reason to believe that in re-alistic settings, these two types of complexity control should be so tightly bound together. The S3C model avoids this issue by controlling the sparsity of units via the b parameter that determines how likely each spike unit is to be active, while separately controlling the magnitude of active units via the  X  and  X  parameters that govern the distribution over s . Sparse coding has no parameter analogous to  X  and cannot control these aspects of the posterior independently.
 Another drawback of sparse coding is that the factors are not actually sparse in the generative distribution. Indeed, each factor is zero with probability zero. The features extracted by sparse coding are only sparse be-cause they are obtained via MAP inference. In the S3C model, the spike variables ensure that each fac-tor is zero with non-zero probability in the generative distribution. Since this places a greater restriction on the code variables, we hypothesize that S3C features provide more of a regularizing effect when solving clas-sification problems.
 Sparse coding is also difficult to integrate into a deep generative model of data such as natural images. While Yu et al. (2011) and Zeiler et al. (2011) have recently shown some success at learning hierarchical sparse coding, our goal for our future work is to in-tegrate the feature extraction scheme into a proven generative model framework such as the deep Boltz-mann machine (Salakhutdinov and Hinton, 2009). Such models with their combination of feed-forward and feed-back connections during inference can learn a much richer description of the data than simple stacked feed-forward models. We expect that being able to extract such complicated structure during un-supervised learning on a large number of unlabeled examples will yield even better performance with high numbers of classes and low numbers of labels per class than a feed-forward architecture. Existing inference schemes known to work well in the DBM-type set-ting are all either sample-based or are based on vari-ational approximations to the model posteriors, while sparse coding schemes typically employ MAP infer-ence. Our use of variational inference makes the S3C framework well-suited to integrate into the known suc-cessful strategies for learning and inference in DBM models. It is not obvious how one can employ a vari-ational inference strategy to standard sparse coding with the goal of achieving sparse feature encoding. 2.2. Comparison to Restricted Boltzmann The S3C model also resembles another class of models commonly used for feature discovery: the RBM. An RBM (Smolensky, 1986) is a model defined through an energy function that describes the interactions be-tween the observed data variables and a set of latent variables. It is possible to interpret the S3C as an energy-based model, by rearranging p ( v,s,h ) to take the form exp { X  E ( v,s,h ) } /Z , with the following en-ergy function: The ssRBM model family is a good starting point for S3C because it has demonstrated both reasonable per-formance as a feature discovery scheme and remarkable performance as a generative model (Courville et al., 2011a). Within the ssRBM family, S3C X  X  closest rel-ative is a variant of the  X  -ssRBM, defined by the fol-lowing energy function: where the variables and parameters are defined identi-cally to the S3C. Comparison of equations 2 and 3 re-veals that the simple addition of a latent factor interac-tion term 1 2 ( h  X  s ) T W T  X W ( h  X  s ) to the ssRBM energy function turns the ssRBM into the S3C model. With the inclusion of this term S3C moves from an undi-rected ssRBM model to the directed graphical model described in equation (1). One can think of this term as designed to cancel the interactions in the RBM X  X  marginal p ( h,s ) that make the RBM X  X  partition func-tion intractable. This change from undirected model-ing to directed modeling has three important effects, that we describe in the following paragraphs: The effect on the partition function: The most immediate consequence of the transition to di-rected modeling is that the partition function becomes tractable. This changes the nature of learning algo-rithms that can be applied to the model, since most of the difficulty in training an RBM comes from esti-mating the gradient of the log partition function. The partition function of S3C is also guaranteed to exist for all possible settings of the model parameters, which is not true of the ssRBM.
 The effect on the posterior: RBMs have a facto-rial posterior, but S3C and sparse coding have a com-plicated posterior due to the  X  X xplaining away X  effect. This means that for RBMs, features defined by similar basis functions will have similar activations, while in directed models, similar features will compete so that only the most relevant feature will remain active. As shown by Coates and Ng (2011), the sparse Gaussian RBM is not a very good feature extractor  X  the set of basis functions W learned by the RBM actually work better for supervised learning when these parameters are plugged into a sparse coding model than when the RBM itself is used for feature extraction. We think this is due to the factorial posterior. In the vastly overcomplete setting, being able to selectively activate a small set of features that cooperate to explain the input likely provides S3C a major advantage in dis-criminative capability.
 The effect on the prior: The addition of the inter-action term causes S3C to have a factorial prior. This probably makes it a poor generative model, but this is not a problem for the purpose of feature discovery. The notion of a spike-and-slab prior was established in statistics by Mitchell and Beauchamp (1988). Outside the context of unsupervised feature discovery for su-pervised learning, the basic form of the S3C model (i.e. a spike-and-slab latent factor model) has ap-peared a number of times in different domains (L  X ucke and Sheikh, 2011; Garrigues and Olshausen, 2008; Mo-hamed et al., 2011; Zhou et al., 2009; Titsias and L  X azaro-Gredilla, 2011). In most work, the model varies slightly from S3C. For example, Titsias and L  X azaro-Gredilla (2011) share a single spike activation proba-bility parameter across all spike variables. L  X ucke and Sheikh (2011) use exactly the S3C model, but use in-tractable exact inference. To this literature, we con-tribute an approximate inference scheme that scales to the kinds of object classifications tasks that we con-sider. We outline this inference scheme next. Having explained why S3C is a powerful model for un-supervised feature discovery we turn to the problem of how to perform learning and inference in this model. Because computing the exact posterior distribution is intractable, we derive an efficient and effective infer-ence mechanism and a variational EM learning algo-rithm.
 We turn to variational EM (Saul and Jordan, 1996) because this algorithm is well-suited for models with latent variables whose posterior is intractable. It works by maximizing a variational lower bound on the log-likelihood called the energy functional (Neal and Hin-ton, 1999). More specifically, it is a variant of the EM algorithm with the modification that in the E-step, we compute a variational approximation to the posterior rather than the posterior itself. While our model admits a closed-form solution to the M-step, we found that online learning with small gradient steps on the M-step objective worked better in practice. We therefore focus our presentation on the E-step, given in Algorithm 1.
 The goal of the variational E-step is to maximize the energy functional with respect to a distribution Q over the unobserved variables. We can do this by selecting the Q that minimizes the Kullback X  X eibler divergence: where Q ( h,s ) is drawn from a restricted family of dis-tributions. This family can be chosen to ensure that Q is tractable.
 Our E-step can be seen as analogous to the encod-ing step of the sparse coding algorithm. The key dif-ference is that while sparse coding approximates the true posterior with a MAP point estimate of the latent variables, we approximate the true posterior with the distribution Q .
 We use the family Q ( h,s ) =  X  i Q ( h i ,s i ). This is a richer approximation than the fully factorized fam-ily used in the mean field approximation. It allows us to capture the tight correlation between each spike variable and its corresponding slab variable while still allowing simple and efficient inference in the approxi-mating distribution. It also avoids a pathological con-dition in the mean field distribution where Q ( s i ) can never be updated if Q ( h i ) = 0.
 Observing that eq. (4) is an instance of the Euler-Lagrange equation, we find that the solution must take the form where  X  h i and  X  s i must be found by an iterative pro-cess. In a typical application of variational inference, the iterative process consists of sequentially applying fixed point equations that give the optimal value of the parameters  X  h i and  X  s i for one factor Q ( h i ,s i the value all of the other factors X  parameters. This is for example the approach taken by Titsias and L  X azaro-Gredilla (2011) who independently developed a varia-tional inference procedure for the same problem. This process is only guaranteed to decrease the KL diver-gence if applied to each factor sequentially, i.e. first updating  X  h 1 and  X  s 1 to optimize Q ( h 1 ,s 1 ), then updat-ing  X  h 2 and  X  s 2 to optimize Q ( h 2 ,s 2 ), and so on. In a typical application of variational inference, the op-timal values for each update are simply given by the solutions to the Euler-Lagrange equations. For S3C, we make three deviations from this standard approach. Because we apply S3C to very large-scale problems, we need an algorithm that can fully exploit the benefits of parallel hardware such as GPUs. Sequential updates across all N factors require far too much run-time to be competitive in this regime.
 We have considered two different methods that enable parallel updates to all units. In the first method, we start each iteration by partially minimizing the KL divergence with respect to  X  s . The terms of the KL di-vergence that depend on  X  s make up a quadratic func-tion so this can be minimized via conjugate gradient descent. We implement conjugate gradient descent ef-ficiently by using the R-operator to perform Hessian-vector products rather than computing the entire Hes-sian explicitly (Schraudolph, 2002). This step is guar-anteed to improve the KL divergence on each iteration. We next update  X  h in parallel, shrinking the update by a damping coefficient. This approach is not guaran-teed to decrease the KL divergence on each iteration but it is a widely applied approach that works well in practice (Koller and Friedman, 2009).
 With the second method (Algorithm 1), we find in practice that we obtain faster convergence, reaching equally good solutions by replacing the conjugate gra-dient update to  X  s with a more heuristic approach. We use a parallel damped update on  X  s much like what we do for  X  h . In this case we make an additional heuristic modification to the update rule which is made neces-sary by the unbounded nature of  X  s . We clip the update to  X  s so that if  X  s new has the opposite sign from  X  s , its magnitude is at most  X   X  s . In all of our experiments we used  X  = 0 . 5 but any value in [0 , 1] is sensible. This prevents a case where multiple mutually inhibitory s units inhibit each other so strongly that rather than being driven to 0 they change sign and actually in-crease in magnitude. This case is a failure mode of the parallel updates that can result in  X  s amplifying without bound if clipping is not used.
 Figure 1 shows that our E-step produces a sparse rep-resentation. Figure 2 shows that the explaining-away effect incrementally makes the representation more sparse.
 Algorithm 1 Fixed-Point Inference Our inference scheme achieves very good computa-tional performance, both in terms of memory con-sumption and in terms of runtime. The computational bottleneck in our classification pipeline is SVM train-ing, not feature learning or feature extraction. Comparing the computational cost of our inference scheme to others is a difficult task because it could be confounded by differences in implementation and because it is not clear exactly what sparse coding prob-lem is equivalent to an equivalent spike-and-slab sparse coding problem. However, we observed informally dur-ing our supervised learning experiments that feature extraction using S3C took roughly the same amount of time as feature extraction using sparse coding. In Fig. 4, we show that our improvements to spike-and-slab inference performance allow us to scale spike-and-slab modeling to the problem sizes needed for ob-ject recognition tasks.
 As a large-scale test of our inference scheme X  X  ability, we trained over 8,000 densely-connected filters on full 32  X  32 color images. Some example filters are pre-sented in Fig. 5. This exercise demonstrated that our approach scales well to large (over 3,000 dimensional) inputs, though it is not yet known how to use features for classification as effectively as patch-based features which can be incorporated into a convolutional archi-tecture with pooling. For comparison, to our knowl-edge the largest image patches used in previous spike-and-slab models with lateral interactions were 16  X  16 (Garrigues and Olshausen, 2008).
 Finally, we provide empirical justification for our heuristic inference method. Timing experiments pre-sented in Fig. 6 show that the heuristic method is con-sistently faster than the conjugate gradient method. We conducted experiments to evaluate the usefulness of S3C features for supervised learning on the CIFAR-10 and CIFAR-100 (Krizhevsky and Hinton, 2009) datasets. Both datasets consist of color images of objects such as animals and vehicles. Each contains 50,000 train and 10,000 test examples. CIFAR-10 con-tains 10 classes while CIFAR-100 contains 100 classes, so there are fewer labeled examples per class in the case of CIFAR-100.
 For all experiments, we used the same overall proce-dure as Coates and Ng (2011) except for feature learn-ing. CIFAR-10 consists of 32  X  32 images. We train our feature extractor on 6  X  6 contrast-normalized and ZCA-whitened patches from the training set. At test time, we extract features from all 6  X  6 patches on an image, then average-pool them. The average-pooling regions are arranged on a non-overlapping grid. Fi-nally, we train an L2-SVM with a linear kernel on the pooled features.
 Coates and Ng (2011) used 1600 basis vectors in all of their sparse coding experiments. They post-processed the sparse coding feature vectors by splitting them into the positive and negative part for a total of 3200 fea-tures per average-pooling region. They average-pool on a 2  X  2 grid for a total of 12,800 features per image (i.e. each element of the 2  X  2 grid averages over a block with sides d (32  X  6 + 1) / 2 e or b (32  X  6 + 1) / 2 c ). We used E Q [ h ] as our feature vector. This does not have a negative part, so using a 2  X  2 grid we would have only 6,400 features. In order to compare with similar sizes of feature vectors we used a 3  X  3 pooling grid for a total of 14,400 features (i.e. each element of the 3  X  3 grid averages over 9  X  9 locations). 6.1. CIFAR-10 We use CIFAR-10 to evaluate our hypothesis that S3C resembles a more regularized version of sparse coding. On the full dataset, S3C achieves a test set accuracy of 78 . 3  X  0 . 9 % with 95% confidence. Coates and Ng (2011) do not report test set accuracy for sparse cod-ing with  X  X atural encoding X  (i.e., extracting features in a model whose parameters are all the same as in the model used for training) but sparse coding with different parameters for feature extraction than train-ing achieves an accuracy of 78 . 8  X  0 . 9% (Coates and Ng, 2011). Since we have not enhanced our perfor-mance by modifying parameters at feature extraction time these results seem to indicate that S3C is roughly equivalent to sparse coding for this classification task. S3C also outperforms ssRBMs, which require 4,096 ba-sis vectors per patch and a 3  X  3 pooling grid to achieve 76 . 7  X  0 . 9% accuracy. All of these approaches are close to the best result using the pipeline from Coates and Ng (2011) of 81 . 5% achieved using thresholding of linear features learned with OMP-1. These results show that S3C is a useful feature extractor that per-forms comparably to the best approaches when large amounts of labeled data are available.
 We then tested the regularizing effect of S3C by train-ing the SVM on small subsets of the CIFAR-10 train-ing set, but using features that were learned on patches drawn from the entire CIFAR-10 train set. The results, summarized in Figure 3, show that S3C has the ad-vantage over both thresholding and sparse coding for a wide range of amounts of labeled data. (In the ex-treme low-data limit, the confidence interval becomes too large to distinguish sparse coding from S3C). 6.2. CIFAR-100 Having verified that S3C features help to regularize a classifier, we proceed to use them to improve perfor-mance on the CIFAR-100 dataset, which has ten times as many classes and ten times fewer labeled examples per class.
 We compare S3C to two other feature extraction meth-ods: OMP-1 with thresholding, which Coates and Ng (2011) found to be the best feature extractor on CIFAR-10, and sparse coding, which is known to per-form well when less labeled data is available. We eval-uated only a single set of hyperparameters for S3C. For sparse coding and OMP-1 we searched over the same set of hyperparameters as Coates and Ng (2011) did: order to use a comparable amount of computational resources in all cases, we used 1600 hidden units and a 3  X  3 pooling grid for S3C, while for the other two methods, which double their number of features via sign splitting, we considered 2  X  2 pooling with 1600 latent variables and 3  X  3 pooling with 800 latent vari-ables. These results are summarized in Table 1. The best result to our knowledge on CIFAR-100 is 54 . 8  X  1% (Jia and Huang, 2011), achieved using a learned pooling structure on top of  X  X riangle code X  fea-tures from a dictionary learned using k-means. This feature extractor is very similar to thresholded OMP-1 features and is known to perform slightly worse on CIFAR-10. Table 1 shows that S3C is the best known detector layer on CIFAR-100. If combined with the pooling strategy of Jia and Huang (2011) it has the potential to improve on the state of the art. Using a pooling strategy of concatenating 1  X  1, 2  X  2 and 3  X  3 pooled features we achieve a test set accuracy of 53 . 7  X  1%. For the NIPS 2011 Workshop on Challenges in Learn-ing Hierarchical Models (Le et al., 2011), the orga-nizers proposed a transfer learning competition. This competition used a dataset consisting of 32  X  32 color images, including 100,000 unlabeled examples, 50,000 labeled examples of 100 object classes not present in the test set, and 120 labeled examples of 10 object classes present in the test set. We applied the same approach as on the CIFAR datasets and won the com-petition, with a test set accuracy of 48.6 %. This approach disregards the 50,000 labels and treats this transfer learning problem as a semi-supervised learn-ing problem. We experimented with some transfer learning techniques but the transfer-free approach per-formed best on leave-one-out cross-validation on the 120 example training set, so we chose to enter the transfer-free technique in the challenge. We have motivated the use of the S3C model for unsu-pervised feature discovery. We have described a vari-ational approximation scheme that makes it feasible to perform learning and inference in large-scale S3C models. We have demonstrated that S3C is an effec-tive feature discovery algorithm for both supervised and semi-supervised learning with small amounts of labeled data. This work addresses two scaling prob-lems: the computation problem of scaling spike-and-slab sparse coding to the problem sizes used in object recognition, and the problem of scaling object recog-nition techniques to work with more classes.

