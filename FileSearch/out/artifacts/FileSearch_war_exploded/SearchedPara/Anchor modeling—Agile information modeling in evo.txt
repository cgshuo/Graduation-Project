 1. Introduction needs, also change. In order to address these challenges, data models of warehouses have to be modular, these requirements. One third of implemented warehouses have at some point, usually within the architecture, and less than a third quotes their warehouses as being a success [33] . in a set of novel constructs capturing aspects such as historization and of the data model [27] . Furthermore, evolution through extensions (instead of modi development where short iterations are required. It is simple to which are typical data warehouse scenarios, are thus easily re longevity of a data warehouse, shortens the implementation time, and simpli evolution examples, and results from performance tests. The article is organized as follows. Section 2 de literature, and Section 11 concludes the article and suggests directions for further research. 2. Basic notions of anchor modeling
In this section, we introduce the basic notions of Anchor Modeling by de of Anchor Modeling is given in Fig. 1 .

De fi nition 1. (Identities). Let I be an in fi nite set of symbols, which are used as identities.
De fi nition 2. (Data type). Let D be a data type. The domain of
De fi nition 3. (Time type). Let T be a time type. The domain of 2.1. Anchors
De fi nition 4. (Anchor). An anchor A is a string. An extension of an anchor is a subset of
An example of an anchor is AC_ Actor with an example extension {#4711, #4712, #4713}. 2.2. Knots example of a knot is GEN_ Gender , see Fig. 2 d, which includes two values, instance is suf fi cient.

De fi nition 5. (Knot). A knot K is a string. A knot has a domain, which is of a knot K with range D is a bijective relation over I  X 
An example of a knot is GEN_ Gender with domain I and range STRING. An example extension is { 2.3. Attributes fi stable but may change over time.

De fi nition 6. (Static attribute). A static attribute B S is a string. A static attribute B range. An extension of a static attribute B S is a relation over {  X  #55,  X  Maiden Lane  X   X  ,  X  #56,  X  Drury Lane  X   X  }.

De fi nition 7. (Historized attribute). A historized attribute B data type D for range, and a time type T as time range. An extension of a historized attribute B example extension is {  X  #55,  X  TheGlobeTheatre  X  ,1599-01-01
De fi nition 8. (Knotted static attribute). A knotted static attribute B domain and a knot K for range. An extension of a knotted static attribute B extension is {  X  #4711, #0  X  ,  X  #4712, #1  X  }.

De fi nition 9. (Knotted historized attribute). A knotted historized attribute B anchor A for domain, a knot K for range, and a time type T relation over I  X  I  X  T .
 nalLevel , and time range DATE. An example extension is { 2.4. Ties once in a tie, occurrences need to be quali fi ed using the concept of roles.
De fi nition 10. (Anchor role). An anchor role is a string. Every anchor role has a type, which is an anchor.
De fi nition 11. (Knot role). A knot role is a string. Every knot role has a type, which is a knot. PAT_ ParentalType .

De fi nition 12. (Static tie). A static tie T S is a set of at least two anchor roles. An instance t pairs  X  R i ,  X  i  X  , i =1, ... , n , where R i is an anchor role , and the type of atLocation is ST_ Stage . An example extension is {{ #55  X  }, {  X  wasHeld , #913  X  ,  X  atLocation , #56  X  }}.

De fi nition 13. (Historized tie). A historized tie T H is a set of at least two anchor roles and a time type historized tie T H ={ R 1 , ... , R n , T } is a set of pairs An extension of a historized tie T H is a set of instances of T
ST_ Stage and the type of isPlaying is PR_ Program . An example extension is {{ {  X  atLocation , #55  X  ,  X  isPlaying , #23  X  , 2004-04-01}, {
De fi nition 14. (Knotted static tie). A knotted static tie T KS instance t KS of a static tie T KS ={ R 1 , ... , R n , S role, S j is a knot role,  X  i  X  I , w j  X  I , n  X  2, and m
De fi nition 15. (Knotted historized tie). A knotted historized tie T a time type T . An instance t KH of a historized tie T KH a time point p, where R i is an anchor role, S j is a knot role, T is a set of instances of T KH .

De fi nition 16. (Identi fi er). Let T be a (static, historized, knotted, or knotted historized) tie. An identi containing at least one anchor role. Furthermore, if T is a historized or knotted historized tie, where identi fi er for T must contain T .
 a tie. The circles on the tie edges in Fig. 3 indicate whether the connected entity is part of the identi white).

De fi nition 17. (Anchor Schema). An anchor schema is a 13-tuple anchors, K is a set of knots , B S is a set of static attributes , B is a set of knotted historized attributes, R A is a set of anchor roles, historized ties, T KS is a set of knotted static ties, T KH hold for an anchor schema: (i) for every attribute B  X  B S  X  B H  X  B KS  X  B KH , domain( B ) (ii) for every attribute B  X  B KS  X  B KH , range( B )  X  K (iii) for every anchor role R A  X  R A , type( R A )  X  A (iv) for every knot role R K  X  R K , type( R K )  X  K (v) for every tie T  X  T S  X  T H  X  T KS  X  T KH , T p R A  X  R
De fi nition 18 . (Anchor model). Let A=  X  A , K , B S , B H , B for A is a quadruple  X  ext A , ext K , ext B , and ext T  X  knots to extensions of knots, ext B is a function from attributes to extensions of attributes, and ext extensions of ties. Let proj i be the i th projection map. An anchor model must ful (i) for every attribute B  X  B S  X  B H  X  B KS  X  B KH , proj (ii) for every attribute B  X  B KS  X  B KH , proj 2 ( ext B (iii) for every tie T and anchor role R A  X  T ,{  X  |  X  R A (iv) for every tie T and knot role R K  X  T ,{  X  |  X  R K , (v) every extension of a tie T  X  T S  X  T H  X  T KS  X  T KH shall respect the identi 2.5. Naming convention
A good naming convention should ful fi ll a number of criteria, some of which may con unambiguous, without too many rules having to be introduced. Furthermore, in order to be used in many different in XML, or in a programming language.
 suf fi xed with  X  ID  X  , and in ties also with the role they take. Names of time ranges have names with their encapsulating entity. 3. Running example program they have performed. If they perform consistently better or worse, the rating changes to re performance and the total revenue gained from it.
 programs they are playing and historized for capturing the changes in these ratings. 4. Guidelines for designing anchor models attributes [6,11] , valid time and transaction time [6,15] , the following guidelines have been formulated. 4.1. Modeling core entities and transactions 4.2. Modeling attribute values
DD  X   X  attribute values have to be repeated resulting in increased storage requirements and update anomalies.
Guideline 2b. Use a knotted static attribute if attribute values represent categories or can take on only a otherwise use a static attribute.
 categories are of importance.

Guideline 2c. Use a knotted historized attribute if attribute values represent categories or a versioning of these are of importance. 4.3. Modeling relationships Guideline 3a. Use a historized tie if a relationship may change over time, otherwise use a static tie. the anchors AC_ Actor and PR_ Program , may be categorized as a program. These categories are then represented by instances of the knot RAT_ Rating . Guidelines 3a and 3b can also be combined in the case when a category of a relationship may change over time. change over time. 4.4. Modeling large relationships made as small as possible.

PE_ in _AC_ wasCast _ST_ atLocation _PR_ wasPlayed is {{  X  times.
 relationship.
 modeled as references to one and the same knot RAT_ Rating with the extension { new tie AC_ part _PR_ in _RAT_ artistic _RAT_ technical with extension {{ 12}, {  X  part , #4711  X  ,  X  in , #17  X  ,  X  artistic ,#3  X  situation occurs in historized ties when more than one role is not in the identi which there can be no doubt as to what has changed between versions.
Guideline 4b. Include in a (knotted) historized tie at most one role outside the identi replacing the knot roles in the tie.
 ff R A 1 ; f 1 hi ; ... ; R An ; f n hi ; R K ; 21 hi ; 2010 remodeling to a static tie is possible. The new tie has {{ the introduced knotted historized attribute has {  X  #538,#21,2010 valuesif joined)optional, but italsoputs thevalues  X  farther away of duplication and how fast this duplication will occur by the speed with which new versions arrive. synchronously within the relationship. 4.5. Modeling states when the actor entered the unmarried state with the time point 1947-08-29. and common form, modeled states are of the types  X  in state capture marriage can have the extension {  X  #0,  X  Not married exactly one is true at any given moment. A more advanced state model would have the form neither of fi rst to n th state  X  . An example extension for such a knot is {  X  #0,  X  Lacking color  X   X  }.
 be mutually exclusive and exhaustive.
 whether an actor is still active or not. The knot PLV_ ProfessionalLevel can be extended with the state  X  with which programs are playing at the stages.

Note, however, that not all attributes that change over time represent states. For example, the attribute which would result in the absence of an instance. 5. From anchor model to relational database the table is the anchor and the name of the column is the abbreviation of the Anchor suf AC_ Actor will be translated into the table AC_ Actor (AC_ID) where the domain for AC_ID is example, the knot GEN_ Gender is translated to the table GEN_ Gender (GEN_ID, GEN_ Gender ), see Fig. 6 a. for knotted historized attributes.
 6. Schema evolution examples AC_ desires _PR_ toPlay .
 program was played. Usage of the old tie may be transitioned to the new one, rendering the old tie obsolete. ful fi ll its purpose. For example, say that critics introduce a new grade, model. Either a new knot is introduced with the new names, or references to  X  Terrible  X  can get new instances in the tie, having references to studying the model itself it is impossible to determine whether this modi determined.
 operations altering already existing objects, which raises the complexity considerably. 7. Physical implementation 7.1. Indexes in an anchor database unique indexes over the values in knot tables can be automatically generated given an anchor schema. 7.1.1. Indexes on anchor and knot tables 7.1.2. Indexes on attribute tables storage media itself. 7.1.3. Indexes on tie tables order in which the columns appear cannot be unambiguously determined from the identi another ordering of the columns may be necessary.
 each row of the entire PR_ Program table in order to fi nd the values that we are looking for. 7.1.4. Partitioning of tables more or less importance). 7.2. Loading practices allowed only for removing erroneous data. A complete history is thereby stored for accurate information [26] .
If a zero update strategy is used together with properly maintained metadata, it is always possible to thereby guaranteeing its integrity. database. 7.3. Views and functions the natural key view, as its composition is unknown to the schema. 7.3.1. Complete view joining the anchor table with all its associated attribute tables. 7.3.2. Latest view 7.3.3. Point-in-time function shown. 7.3.4. Interval function ensure that the time point used for historization lies within the two provided time points. See Fig. 9 . 7.3.5. Natural key view the attribute ST_LOC_ Stage _ Location . A performance is uniquely identi found in attributes spread out over several anchors ( Fig. 10 ).
 identi fi er. An example of a natural key view can be seen in Fig. 11 . 7.4. Utilizing table elimination plan of a query if the following two conditions are ful fi (i) no column from T is explicitly selected (ii) the number of rows in the returned data set is not affected by the join with T.
In order to take advantage of table elimination primary and foreign keys have to be de de fi execution.
 yielding reduced access time. 8. Verifying performance in anchor databases in databases modeled using other techniques.

No systematic study has yet been carried out for investigating the data in a couple of hours. However, as the quality of the initial solution could potentially have in systematic tests are needed.
 planned to be carried out in future. 8.1. Considerations for the experiment
Given a body of information and intended searches over it, the following conditions in
It is assumed that the body of information can be described using entities, identi (a) The data is time dependent and its changes need to be kept. (b) The data is sparse, i.e. many entities lack some of their attribute values. (c) The number of distinct data values is small compared to the number of all data values. (d) Identi fi ers constitute a small portion of the total amount of data. (e) There are many identi fi ers. (f) There are many properties. (g) Searches address relatively few of the properties in the entities over which the search is done. (h) Searches include conditions that impose bounds on values.

For data warehouse environments, many of these conditions are typically ful of ful fi llment affect the performance in an anchor database compared to a less normalized database. 8.2. The experiment studying the in fl uence of the various degrees of ful fi all possible values for the conditions in subpanels (e)  X  4 *
Finally, the principles for populating the databases were as follows. In the one extra version was added for each instance of the key in the table, effectively doubling the number of rows. and detailed results are available from http://www.anchormodeling.com . 8.3. Analysis of the results database as well as situations where it does not. In fact, the more of the listed conditions, (a) some degree the better the anchor database performs. In some cases, a single condition being ful suf fi approximative behavior. In the graphs a single condition is allowed to change, while all others remain graphs can be explained as follows. (h) For every added condition limiting the number of rows in the 8.4. Conclusions from the experiment
A limitation of the experiment is the small number of steps in which the degrees of condition ful in other RDBMS could be different and therefore needs to be veri hardware should also be measured and compared. Stan dardized test suites and benchmarks, such as TPC-H, investigated.
 remains to be investigated and provides a direction for further research. 9. Bene fi ts  X 
Ease of Modeling  X  ,  X  Simpli fi ed Database Maintenance  X  are valid regardless of what representation is used, whereas
Sections 5 and 7 ). 9.1. Ease of modeling 9.1.1. Expressive concepts and notation risk of introducing errors in an anchor model. 9.1.2. Historization by design the form of historized attributes and ties ( Sections 2.3 and 2.4 ). 9.1.3. Agile development affecting the existing parts of a model (cf. bus architecture [17] ). 9.1.4. Reduced translation logic special considerations in that representation. This near 1 even eliminates the need for, translation logic. 9.1.5. Reusability and automation speeding up development. 9.2. Simpli fi ed database maintenance 9.2.1. Ease of attribute changes possible to trace when and what caused an attribute value to change. 9.2.2. Absence of null values space. 9.2.3. Simple index design index need be undertaken as there are unambiguous rules for determining what indexes are relevant. 9.2.4. Update-free asynchrony include several attributes) ( [17] , pp. 271  X  274). 9.3. High performance databases 9.3.1. High run-time performance restricts the data set scanned during a query, yielding less response time. 9.3.2. Ef fi cient storage 9.3.3. Parallelized physical media access than others can also reside on speedier media for faster access. 9.3.4. Less index space needed gain. Most of the time the table can be scanned quickly enough anyway. 9.3.5. Relevant compression normalized database. 9.3.6. Reduced deadlock risk a deadlock is reduced. 9.3.7. Better concurrency attribute tables are accessed by them. 9.3.8. Query independence models are thereby better suited for general analysis, i.e. when the intended queries are hard to predict. 10. Related research with less normalized databases is also done and fi nally temporal databases are discussed. 10.1. Data warehousing approaches the data warehouse and in this way speed up the response time. Furthermore, also Inmon points out that retrieval.

Hubs are used to capture business entities and add a data warehouse identi terminology.

Satellites are not necessarily highly normalized. In fact, warehousing.
 10.2. Conceptual modeling approaches for relational database design.

Anchor Modeling is also similar to ER (Entity Relationship) modeling [4] , see Fig. 20 , and UML (Uni
EER (Enhanced Entity Relationship) models [7] , instead Anchor Modeling provides three prede in order to represent either temporal properties or relationships to categories. 10.3. Less normalized databases based on the de fi nition of 6NF according to Ref. [6] . 10.4. Temporal databases query language [34] . Database modeling approaches, such as the original ER model, do not include speci optimizing temporal queries.
 10.4.1. Time in anchor modeling the times represent:  X  when a value is changed  X  ,  X  when information was recorded 10.4.2. Changing time updating them, by modeling a knot holding the state of validity for the attribute or tie. 10.4.3. Recording time when a certain piece of information is entered into the domain of discourse, or database. In many scenarios a single recording time per piece of information is suf to a metadata structure, which preferably also should be anchor modeled. 10.4.4. Happening time depending on the event being momentaneous (  X  happened at recording times. The reason for introducing  X  happening time or transaction time per se. 11. Conclusions and further research directions for further research.
 modi fi cations. This feature is the basis for a number of bene and high run-time performance.
 direction for future work.
 be expected to be especially well suited.
 predictions never can be made. A model is not built to last, it is built to change.
References
