 The Web is a huge collection of interconnected data. Managing and processing such Semantic Web has emerged as the next generation of the World Wide Web, and it is the Web. In the Semantic Web [14], RDF [12] (Resource Description Framework) and RDF Schema [3] are commonly used to describe metadata. 
The Resource Description Framework (RDF ) is the first W3C recommendation for resources are, for example, web pages or books. Descriptions can be characteristics of resources, such as author or content of a website. We call such descriptions metadata. ments can be intuitively understood as a graph: resources are nodes and statements are arcs connecting the nodes. 
The RDF data model has no mechanism to define names for properties or re-property names. Different RDF schemas can be defined and used for different appli-follows the syntax of the RDF data model. as Jena [17]; the other exclusively use forward chaining strategy, such as RStar [15] and Sesame [5]. crease the need for disc memory. However, the task of processing a query is reduced chaining inference is the decrease in requir ed storage size and import data time, while the main disadvantage is the decrease in performance of query processing. 
In addition, a forward chaining based system needs a truth maintenance system situation in which a triple insert into an RDF storage, and the triple match the premise part of a rule used in the inference engine, then the rule is fired, consequently, addi-time later the triple needs to be deleted from the RDF storage, in order to maintain the consistency of the storage, the triples derived from it also should be deleted from the RDF storage. To cope with this scenario, a TMS system that records the justifications can X  X  result in additional derived triples. 
Many performance tests were conducted for current RDF storage and query sys-that when RDF data consists exclusively of a large class or property hierarchy that is both broad and deep, or the complexity of the model theory and expressiveness of the modeling language increase (for example when moving from RDF Schema to OWL [16]), the disadvantage of larger storage space may at some point outweigh the advan-tage of faster querying. 
Based on the above considerations, we feel that the inference strategy employed by existing systems that exclusively use forward chaining strategy have not yet presented a good solution to the deletion operation by now. Therefore, we design a RDF storage and query framework with flexible inference strategy, which can combine forward and backward chaining inference strategies. In addition, a new solution to the deletion illustrated by primary experiments. 2.1 Overview engine and backward chaining inference en gine, are designed for the functionality of data insertion and data query respectively. The framework has an inference rule con-system. Therefore, a truth maintenance system is built into the framework to maintain consistency as well as make derivations available. The TMS controller is designed to issues related to these components will be addressed in the following subsections. 2.2 Inference Rule Cont roller and Inference Engines As discussed in section 1, forward chaining inference strategy and backward chaining inference strategy have their strong strength. Therefore, the framework uses a mixed backward chaining inference engine for data query. The rules used in each inference engine are controlled by the inference rule controller. Applications can configure the inference engines through the controller according to their own characteristics. engine make an inference based on the current RDF storage state and the rules in both storage except for the triples directly inferr ed by the rules in the backward inference whole procedure runs iteratively. 
To query information from the RDF storage, the backward chaining inference en-gine receives query from RDF query language processor, then it draws conclusions in terms of the current RDF storage state and the rules which inference rules controller specifics. 2.3 TMS Controller and TMS System A forward chaining inference system has special need for a truth maintenance system. are two related reasons for this need. One is to keep the consistency of RDF storage, work records the justifications for each triple inferred by an RDFS rule. When a triple is removed from the RDF storage, any justifications in which it plays a part are also removed. The triples justified by removing justification are checked to see if they are still supported by other justification. If not, then these triples are also removed. some applications. Consequently, applications can choose whether or not to use TMS system through the TMS controller component. 2.4 RDF Storage management systems as backend stores [1,2]. This is a straightforward approach since it is appropriate to represent RDF triples in a relational table of three columns and the relational DBMS (RDBMS) has been well studied. 
Other components access RDF storage through standard SQL sentence. As to for-ward chaining inference engine, if the triples in the current storage match the premise part of a RDFS rule, then the rule is fired, newly derived triples are recorded into the target matches the conclusion part of a RDFS rule, search the storage, if triples match premise part of the rule as sub target, carry out the same actions. 2.5 RDF Query Language Processor Several languages for querying RDF data have been proposed and implemented, some in the form of traditional database query languages (e.g. SQL, OQL), others based on logic and rule languages. Judging from the impact of SQL to the database community, the Semantic Web in general [10]. W3C set up RDF Data Access Working Group (DAWG) in Feb. 2004. DAWG devotes to developing specifications for RDF query language and access control protocol. SPARQL is a RDF query language developed by DAWG according to the technology requirement and design objectives referred above. 
RDF query language processor receives the request in a specific RDF query lan-guage form, analyzes and checks whether the submitted query accords with the syntax of the query language. A valid query is parsed and transformed into a medium state. Then send the result to the backward chaining inference engine. The existing systems that exclusively use forward chaining strategy have not yet pre-problem, which consists of two algorithms, including insertion algorithm and deletion the deletion algorithm is relative simple. At first, we give three definitions. a22  X  b2. If some conclusions in rule1 match some premises in rule2, then we can say that rule 2 depends on rule 1. triple 2. where inf is a triple justified by the justification, dep1 and dep2 are triples justifying dep2=null, it indicates that inf is an explicit triple. 3.1 Dependency Between RDFS Entailment Rules and RDF Schema, and it presents a set of entailment rules. In [13], the author charac-terizes these rules as follow:  X 
Type Rules assign default ( X  X oot X ) types for resources (rules rdf1, rdfs4a and rdfs4b).  X  rdfs10).  X  property (rules rdfs5, rdfs6, rdfs7).  X 
Domain/Range Rules infer resource types from domain and range assignments (rules rdfs2 and rdfs3). 
The RDF Semantics specification was published on February 10,2004. It added rules related to rdfs:ContainerMembershipProperty (rdfs12) and rdfs:Datatype (rdfs13). Table 2 shows the dependency between RDFS entailment rules in terms of the triggering rules, and on the vertical direction are triggered rules. If one rule depend on definitions of rdfs3 and rdfs9 are presented in table 1. We can see that rdfs9 depend on rdfs3, so we place a token * in row 9, column 3. 3.2 Cyclic Dependency of Rules The following two examples present the problem. Example 1: 1. (uuu, rdf:type, rdfs:Resource) (explicit) Example 2: 1. (rdfs:subClassOf, rdfs:domain, rdfs:Class) (explicit) 2. (uuu, rdf:subClassOf, rdfs:Resource) (explicit) 
Example 1 shows that a justification (1, 1, 2, rdfs2) added into the TMS system in term of the rdfs2, namely triple 1 is justified by itself. As to Example 2, the following cording to rdfs2 and rdfs8 respectively. This presents that triple 2 depends on triple 3 justified by triple 2. All these examples have cyclic dependencies. 
The cyclic dependencies result in a problem. When delete a triple, if the TMS sys-cannot be deleted because it is justified by itself. In Example 2, it seems that triple 2 However, the justification says that triple 3 depends on triple 2, so this deletion can be conducted. 3.3 Algorithm Table 3 and Table 4 respectively. The following terms are used in the two algorithms. S: the set of justifications in TMS system. T: the set of triples including both explicit triples and derived triples. A: the set of triples that will be inserted into RDF storage. D: the set of triples that will be deleted from RDF storage. V: the set of triples that depend on the current inserted triple. I: the set of triples that were inferred by the current insert triple. Step3. Insert t2 into T, and compute I of t2, meanwhile, bind t2 X  X  V to each triple in I Step4. Determine whether I is empty. If yes, go to step 2, otherwise select a triple t4 Step5. Insert the dependent triples (produce in step 3) of t4 to t4 X  X  V, then determine Step2. Let a variable named removed is false. Go to step 3. Step3. If D is null or removed is false, terminate. Otherwise, go to step 4. We have developed a prototype system of the presented framework. In order to evalu-ate the feasibility of our framework, we conduct an experiment on Wordnet data set. mantic relations between them. In our experiment, we choose the Wordnet 1.6 schema (wordnet-20000620.xml) and the set of nouns (wordnet-20000620.xml). 
The experiment was run on a 2.0GHz PC with 512M physical memory. The oper-ating system is Windows XP Professional and the backend database is mysql 4.1.12. rarely used, such as rdfs1, rdfs4a, rdfs4b, etc. In this experiment, we take rdfs2, rdfs3, inference engine with all of these rules. Table 5 shows the number of triples inferred by each rule. We see that the size of the triples inferred by rdfs3 is more than half of all triples inferred. rdfs9, rdfs11, and backward chaining inference engine with rdfs3. Table 6 shows the used in our experiment. Query 2 relates to the rdfs3, but Query 1 doesn X  X . Query 1: return comment of the verb in Wordnet. PREFIX wn: &lt; http://www.cogsci.princeton.edu/~wn/schema/&gt; PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; select ?comment where{wn:Verb rdfs:comment ?comment} Query 2: return the type of the word in the form of  X  X earning X . PREFIX wn: &lt; http://www.cogsci.princeton.edu/~wn/schema/&gt; PREFIX rdf: &lt; http://www.w3.org/1999/02/22-rdf-syntax-ns&gt; select ?type where {?ID wn:wordForm 'leaning'. ?ID rdf:type ?type} query samples referred above. The query results generated by both systems are same. addition, the latter system needs less storage space. The experiment illustrates that our framework is feasible. In this paper, we present an RDF storage and query framework with flexible inference addition, a new solution to the deletion operation is also given within our framework. The feasibility of our framework is illustrated by primary experiments. 
This work is a primary research in combing two inference strategies. More experi-exploit the practical usage of our framework. These will be our future work. The work is supported in part by National Key Basic Research and Development Program of China under Grant 2003CB317004, and in part by the Natural Science Foundation of Jiangsu Province, China, under Grant BK2003001. We would like to thank Dr. Yuqing Zhai and Dr. Yangbing Wang for their suggestions on this paper. 
