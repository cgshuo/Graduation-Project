  X  Sanjiv Kumar  X  Shih-Fu Chang  X  Fast approximate nearest neighbor search arises com-monly in a variety of domains and applications due to massive growth in data that one is confronted with. An attractive solution to overcome the speed bottleneck that an exhaustive linear scan incurs is the use of algo-rithms from the Locality-Sensitive Hashing (LSH) fam-ily ( Gionis et al. , 1999 )( Charikar , 2002 )( Datar et al. , 2004 ) which use random projections to convert input data into binary hash codes. Although enjoying theo-retical guarantees on sub-linear hashing/search time and the accuracy of the returned neighbors, LSH-related methods typically need long codes and a large number of hash tables to achieve good search accuracy. This may lead to considerable storage overhead and re-duced search speed. Hence, in the literature, directly learning data-dependent hash functions to generate compact codes has become popular. Such hashing typically needs a small number of bits per data item and can be designed to work well with a single hash table and constant hashing time. The state-of-the-arts include unsupervised hashing ( Liu et al. , 2011 ), semi-supervised hashing ( Wang et al. , 2012 ), and su-pervised hashing ( Liu et al. , 2012 ).
 Most of the existing hashing methods try to solve the problem of point-to-point nearest neighbor search. Namely, both queries and database items are rep-resented as individual points in some feature space. Considering complex structures of real-world data, other forms of hashing paradigms beyond point-to-point search have also been proposed in the past, e.g., subspace-to-subspace nearest neighbor search ( Basri et al. , 2011 ). In this paper, we address a more challenging point-to-hyperplane search problem, where queries come as hyperplanes in R d , i.e., ( d  X  1)-dimensional subspaces, and database items are con-ventional points. Then the search problem is: given a hyperplane query and a database of points, re-turn the points which have minimal distances to the hyperplane. In the literature, not much work has been done on the point-to-hyperplane problem except ( Jain et al. , 2010 ) which demonstrated the vital im-portance of such a problem in making SVM-based ac-tive learning feasible on massive data pools. Active learning (AL), also known as pool-based active learning, circumvents the high cost of blind labeling by selecting a few samples to label. At each iteration, a typical AL learner seeks the most informative sam-ple from an unlabeled sample pool, so that maximal information gain is achieved after labeling the selected sample. Subsequently, the learning model is re-trained on the incrementally labeled sample set. The classi-cal AL algorithm ( Tong &amp; Koller , 2001 ) used SVMs as learning models. Based on the theory of  X  X ersion spaces X  ( Tong &amp; Koller , 2001 ), it was provably shown that the best sample to select is simply the one closest to the current decision hyperplane if the assumption of symmetric version spaces holds. Unfortunately, the ac-tive selection method faces serious computational chal-lenges when applied to gigantic databases. An exhaus-tive search to find the best sample is usually compu-tationally prohibitive. Thus, fast point-to-hyperplane search is strongly desired to scale up active learning on large real-world data sets.
 Recently, hyperplane hashing schemes were proposed in ( Jain et al. , 2010 ) to cope with point-to-hyperplane search. Compared with the brute-force scan through all of the database points, these schemes are signif-icantly more efficient with theoretical guarantees of sub-linear query time and tolerable loss of accuracy for retrieved approximate nearest neighbors. Con-sequently, when applying hyperplane hashing to the sample selection task for SVM active learning, one can scan orders of magnitude fewer database points to de-liver the next active label request, thereby making ac-tive learning scalable.
 In ( Jain et al. , 2010 ), two families of randomized hash functions were proved locality-sensitive to the angle between a database point and a hyperplane query; however, long hash bits and plentiful hash tables are required to cater for the theoretical guarantees. Actually, 300 bits and 500 tables were adopted in ( Jain et al. , 2010 ) to achieve reasonable performance, which incurs a heavy burden on both computation and storage. To mitigate the above mentioned issues, this paper proposes a compact hyperplane hashing scheme which exploits only a single hash table with several tens of hash bits to tackle point-to-hyperplane search. The thrust of our hashing scheme is to design and learn bilinear hash functions such that nearly parallel input vectors are hashed to the same bits whereas nearly per-pendicular input vectors are hashed to different bits. In fact, we first show that even without any learn-ing, the randomized version of the proposed bilinear hashing gives higher near-neighbor collision probabil-ity than the existing methods.
 Next, we cast the bilinear projections in a learning framework and show that one can do even better by us-ing learned hash functions. Given a hyperplane query, its normal vector is used as the input and the corre-sponding hash code is obtained by concatenating the output bits from the learned hash functions. Then, the database points whose codes have the farthest Ham-ming distances to the query X  X  code are retrieved. Crit-ically, the retrieved points, called near-to-hyperplane neighbors , maintain small angles to the hyperplane fol-lowing our learning principle. Experiments conducted on two large data sets up to one million corroborate that our approach enables scalable active learning with good performance. Finally, although in this paper we select SVM active learning as the testbed for hyper-plane hashing, we want to highlight that the proposed compact hyperplane hashing is a general method and applicable to a large spectrum of machine learning problems such as minimal tangent distance pursuit and cutting-plane based maximum margin clustering. First of all, let us revisit the well-known margin-based AL strategy proposed by ( Tong &amp; Koller , 2001 ). For the convenience of expression, we append each data vector with a 1 and use a linear kernel. Then, the SVM classifier becomes f ( x ) = w  X  x where vector x  X  R d represents a data point and vector w  X  R d determines a hyperplane P w passing through the ori-gin. Fig. 1 (a) displays the geometric relationship be-tween w and P w , where w is the vector normal to the hyperplane P w . Given a hyperplane query P w and a database of points X = { x i } n i =1 , the active selec-tion criterion prefers the most informative database point x  X  = arg min x  X  X  D ( x , P w ) which has the min-imum margin to the SVM X  X  decision boundary P w . Note that D ( x , P w ) = | w  X  x | / k w k is the point-to-hyperplane distance. To derive provable hyperplane hashing like ( Jain et al. , 2010 ), this paper focuses on a slightly modified  X  X istance X  | w  X  x | k of the point-to-hyperplane angle where  X  x , w  X  [0 ,  X  ] is the angle between x and the hy-perplane normal w . The angle measure  X  x , w  X  [0 ,  X / 2] between a database point and a hyperplane query can readily be reflected in hashing.
 As shown in Fig. 1 (b), the goal of hyperplane hash-ing is to hash a hyperplane query P w and the infor-mative samples (e.g., x 1 , x 2 ) with narrow  X  x , w into the same or nearby hash buckets, meanwhile avoid-ing to return the uninformative samples (e.g., x 3 , x 4 ) with wide  X  x , w . Because  X  x , w =  X  x , w  X   X  2 , the point-to-hyperplane search problem can be equiva-lently transformed to a specific point-to-point search problem where the query is the hyperplane normal w and the desirable nearest neighbor to the raw query P w is the one whose angle  X  x , w from w is closest to  X / 2, i.e., most closely perpendicular to w . This is very different from traditional point-to-point nearest neighbor search which returns the most similar point to the query point. If we regard | cos(  X  x , w ) | = | w as a similarity measure between x and w , hyperplane hashing actually seeks for the most dissimilar point x  X  of | cos(  X  contrary, the most similar point such as w or  X  w is surely uninformative for the active selection criterion, and must be excluded. In this section, we first briefly review the existing lin-ear function based randomized hashing methods, then propose our bilinearly formed randomized hashing ap-proach, and finally provide theoretic analysis for the proposed bilinear hash function. 3.1. Background  X  Linear Hash Functions Jain et al. ( Jain et al. , 2010 ) devised two distinct fam-ilies of randomized hash functions to attack the hyper-plane hashing problem.
 The first one is Angle-Hyperplane Hash (AH-Hash) A , of which one example is h
A ( z ) = [sgn( u  X  z ) , sgn(  X  v  X  z )] , z is a hyperplane normal where z  X  R d represents an input vector, and u and v are both drawn independently from a standard d -variate Gaussian, i.e., u , v  X  N (0 , I d  X  d ). Note that h
A is a two-bit hash function which leads to the prob-ability of collision for a hyperplane normal w and a database point x : The probability monotonically decreases as the point-to-hyperplane angle  X  x , w increases, ensuring angle-sensitive hashing.
 The second is Embedding-Hyperplane Hash (EH-Hash) function family E of which one example is h ( z ) = where V ( A ) returns the vectorial concatenation of ma-trix A , and U  X  N (0 , I d 2  X  d 2 ). In particular, the EH hash function h E yields hash bits on an embedded space R d 2 resulting from vectorizing rank-one matrices zz  X  and  X  zz  X  . Compared with h A , h E gives a higher probability of collision for a hyperplane normal w and a database point x : which also bears the angle-sensitive hashing property. However, it is much more expensive to compute than AH-Hash.
 It is important to note that both AH-Hash and EH-Hash are essentially linear hashing techniques. On the contrary, in this work we introduce bilinear hash func-tions which allow nonlinear hashing. 3.2. Bilinear Hash Functions We propose a bilinear hash function as follows where u , v  X  R d are two projection vectors. Our mo-tivation for devising such a bilinear form comes from the following two requirements: 1) h should be in-variant to the scale of z , which is motivated by the fact that z and  X  z (  X  6 = 0) hold the same point-to-hyperplane angle; and 2) h should yield different hash bits for two perpendicular input vectors. The former definitely holds due to the bilinear formulation. We show in Lemma 1 that the latter holds with a con-stant probability when u , v are drawn independently from the standard normal distribution.
 For the purpose of hyperplane hashing described above, the pivotal role of bilinear hash functions is to map the query point w (the hyperplane normal) and the desirable most informative point (with  X  x , w =  X / 2) to bitwise different hash codes, whereas map w and the undesirable most uninformative point (with  X  , w = 0 or  X  ) to identical hash codes. Therefore, hyperplane hashing works by finding the points in X whose codes have the largest Hamming distances to the query code of w . 3.3. Theoretic Analysis Based on the bilinear formulation in eq. ( 6 ), we define a novel randomized function family Bilinear-Hyperplane Hash (BH-Hash) as: B = h B ( z ) = sgn( u  X  zz  X  v ) , i.i.d. u , v  X  N (0 , I Here we prove several key characteristics of B . Spe-cially, we define h B ( P w ) =  X  h B ( w ) for an easy deriva-tion.
 Lemma 1. Given a hyperplane query P w with the normal vector w  X  R d and a database point x  X  R d , the probability of collision for P w and x under h B is Proof. This probability is equal to the probability of h ( w ) 6 = h B ( x ). Because the two random projections u and v are independent, Pr h B ( w ) 6 = h B ( x ) = Pr sgn( u  X  w ) = sgn( u  X  x )  X  Pr sgn( v  X  w ) 6 = sgn( v  X  x ) + Pr sgn( u  X  w ) 6 = sgn( u  X  x ) Pr sgn( v  X  w ) = sgn( v By exploiting the fact Pr sgn( u  X  z ) = sgn( u  X  z  X  ) = 1  X   X  z , z  X  / X  from ( Goemans &amp; Williamson , 1995 ), which completes the proof.
 Lemma 1 shows that the probability of h B ( w ) 6 = h B ( x ) is 1/2 for perpendicular w and x that hold  X  x , w =  X / 2 (accordingly  X  x , w = 0). It is important to realize that this collision probability is twice of that from the linear AH hash function h A described in Sec. 3.1 .
 Theorem 1. The BH-Hash function family B is tance measure D ( x , P w ) =  X  2 Proof. Using Lemma 1, for any h B  X  B , when D ( x , P Likewise, when D ( x , P w ) &gt; r (1 +  X  ) we have
Pr h B ( P w ) = h B ( x ) &lt; This completes the proof.
 Note that p 1 , p 2 ( p 1 &gt; p 2 ) depend on 0  X  r  X   X  2  X  &gt; 0. We present the following theorem by adapting Theorem 1 in ( Gionis et al. , 1999 ) and Theorem 0.1 in the supplementary material of ( Jain et al. , 2010 ). Theorem 2. Suppose we have a database X of n points. Denote the parameters k = log 1 /p and c  X  2 . Given a hyperplane query P w , if there ex-ists a database point x  X  such that D ( x  X  , P w )  X  r , then the BH-Hash algorithm is able to return a database at least 1  X  1 c  X  1 e by using n  X  hash tables of k hash bits each. The query time is dominated by O ( n  X  log 1 /p evaluations of the hash functions from B and cn  X  com-putations of the pairwise distances D between P w and the points hashed into the same buckets.
 We defer the proof to the supplementary material due For each of AH-Hash, EH-Hash and BH-Hash, we plot the collision probability p 1 and the query time expo-nent  X  under  X  = 3 with varying r in Fig. 2 (a) and (b), respectively. At any fixed r , BH-Hash accomplishes the highest probability of collision, which is twice p 1 of AH-Hash. Though BH-Hash has slightly bigger  X  than EH-Hash, it has much faster hash function computa-tion, i.e.,  X (2 dk ), instead of  X ( d 2 ( k + 1)) of EH-Hash per hash table for each query or data point.
 It is interesting to see that AH-Hash and our proposed BH-Hash have a tight connection in the style of hash-ing database points. BH-Hash actually performs the XNOR operation over the two bits that AH-Hash out-puts, returning a composite single bit. As a relevant reference, the idea of applying the XOR operation over binary bits in constructing hash functions has ever been used in ( Li &amp; K  X onig , 2010 ). However, this is only suitable for the limited data type, discrete set, and still falls into point-to-point search. Despite the higher collision probability of the proposed BH-Hash than AH-Hash and EH-Hash, it is still a ran-domized approach. The use of random projections in h B has two potential issues. (i) The probability of colliding for parallel P w and x with  X  x , w = 0 is not too high (only 1/2 according to Lemma 1). (ii) The hashing time is sub-linear O ( n  X  log 1 /p der to bound the approximation error of the retrieved neighbors, as shown in Theorem 2. AH-Hash and EH-Hash also suffer from the two issues. Even though these randomized hyperplane hashing methods main-tain bounded approximation errors, they require long hash codes and plenty (even hundreds) of hash tables to cater for the accuracy guarantees. Hence, these so-lutions have tremendous computational and memory costs which limit the practical performance of hyper-plane hashing.
 To this end, we propose a Compact Hyperplane Hash-ing approach to further enhance the power of bilinear hash functions such that, instead of being random, the projections are learned from the data. Such learning yields compact yet discriminative codes which are used in a single hash table, leading to substantially reduced computational and storage needs.
 We aim at learning a series of bilinear hash functions { h j } to yield short codes. Note that h j is different from the randomized bilinear hash function h B j , and that we consistently define h j ( P w ) =  X  h j ( w ). We would like to learn h j such that smaller  X  x , w results in larger h ( P w ) h j ( x ). Thus, we make h j ( P w ) h j ( x ) to mono-tonically decrease as  X  x , w increases. This is equivalent to the requirement that h j ( w ) h j ( x ) monotonically in-creases with increasing sin(  X  x , w ) = | cos(  X  x , w ) | . Suppose k hash functions are learned to produce k -bit codes. We propose a hash function learning approach with the goal that P k j =1 h j ( w ) h j ( x ) /k  X  | cos(  X  Further, since P k j =1 h j ( w ) h j ( x ) /k  X  [  X  1 , 1] and | cos(  X  which makes sense since  X  x , w =  X / 2, i.e.,  X  x , w = 0, [1 : k ]. As such, the proposed learning method achieves explicit collision for parallel P w and x .
 Enforcing eq. ( 11 ) tends to make h j to yield identi-cal hash codes for nearly parallel inputs whereas bit-wise different hash codes for nearly perpendicular in-puts. At the query time, given a hyperplane query, we first extract its k -bit hash code using the k learned hash functions applied to the hyperplane normal vec-tor. Then, the database points whose codes have the largest Hamming distances to the query X  X  code are returned. Thus, the returned points, called near-to-hyperplane neighbors , maintain small angles to the hy-perplane because such points and the hyperplane nor-mal are nearly perpendicular. In our learning setting, k is typically very short, no more than 30, so we can retrieve the desirable near-to-hyperplane neighbors via constant time hashing over a single hash table. Now we desribe how we learn k pairs of projections ( u j , v j ) k j =1 so as to construct k bilinear hash functions { h j ( z ) = sgn( u  X  j zz  X  v j ) } k j =1 . Since the hyperplane normal vectors come up only during the query time, we cannot access w during the training stage. Instead, we sample a few database points for learning projections. Without the loss of generality, we assume that the first m ( k &lt; m  X  n ) samples saved in the matrix X m = [ x 1 , , x m ] are used for learning. To capture the pairwise relationships among them, we define a matrix where 0 &lt; t 2 &lt; t 1 &lt; 1 are two thresholds. For any sample x , its k -bit hash code is written as H ( x ) = [ h 1 ( x ) , , h k ( x )], and P k j =1 h j ( x H ( x i ) H  X  ( x i  X  ). By taking advantage of the learn-ing goal given in eq. ( 11 ), we formulate a least-squares style objective function Q to learn X m  X  X  bi-nary codes as Q = 1 k BB  X   X  S 2 [ H  X  ( x 1 ) , , H  X  ( x m )]  X  represents the code matrix of X m and k . k F denotes the Frobenius norm. The thresholds t 1 , t 2 used in eq. ( 12 ) have an important role. When two inputs are prone to being parallel so that | cos(  X  x i , x ing Q drives each bit of their codes to collide, i.e., H ( x i ) H  X  ( x i  X  ) /k = 1; when two inputs tend to be per-pendicular so that | cos(  X  x i , x minimizing Q tries to make their codes bit-by-bit dif-ferent, i.e., H ( x i ) H  X  ( x i  X  ) /k =  X  1. With simple algebra, one can rewrite Q as Every bit vector b j  X  { 1 ,  X  1 } m in B = [ b 1 , , b determines one hash function h j parameterized by one projection pair ( u j , v j ). Note that b j  X  X  are separable in the summation, which inspires a greedy idea for solving b j  X  X  sequentially. At a time, it only involves solving one bit vector b j ( u j , v j ) given the previously solved vectors b  X  1 , , b  X  j  X  1 . Let us define a residue b j can be pursued by minimizing the following cost Discarding the constant term, the final cost is given as Note that g ( u j , v j ) is lower-bounded as eq. ( 14 ) is al-ways nonnegative. However, minimizing g is not easy because it is neither convex nor smooth. Below we propose an approximate optimization algorithm. Since the hardness of minimizing g lies in the sign function, we replace sgn() in b j with the sigmoid-shaped function  X  ( x ) = 2 / (1 + exp(  X  x ))  X  1 which is sufficiently smooth and well approximates sgn( x ) when | x | &gt; 6. Subsequently, we propose to optimize a smooth surrogate  X  g of g defined by where the vector We derive the gradient of  X  g with respect to [ u  X  j , v agonal elements come from the m -dimensional vector ( R sents the Hadamard product (i.e., elementwise prod-uct), and 1 denotes a constant vector with m 1 entries. Since the original cost g in eq. ( 15 ) is lower-bounded, its smooth surrogate  X  g in eq. ( 16 ) is lower-bounded as well. We are thus able to minimize  X  g using the regu-lar gradient descent technique. Note that the smooth surrogate  X  g is still nonconvex, so it is unrealistic to look for a global minima of  X  g . For fast convergence, we adopt a pair of random projections ( u 0 j , v 0 j ), which were used in h B j , as a warm start and apply Nesterov X  X  gradient method ( Nesterov , 2003 ) to accelerate the gradient decent procedure. In most cases we attain a locally optimal ( u  X  j , v  X  j ) at which  X  g ( u  X  j close to its lower bound.
 The final optimized bilinear hash functions are given as h j ( z ) = sgn ( u  X  j )  X  zz  X  v  X  j k the randomized hashing, it is not easy to prove their theoretical properties such as the collision probabil-ity, they result in a more accurate point-to-hyperplane search than the randomized functions h B j , as demon-strated by the subsequent experiments.
 With the learned hash functions H = [ h 1 , , h k ] in hand, we can implement the proposed compact hyper-plane hashing by simply treating a -1 bit as a 0 bit. In the preprocessing stage, each database point x is converted into a k -bit hash code H ( x ) and stored in a single hash table with k -bit hash keys as entries. To perform search at the query time, given a hyperplane normal w , we 1) extract its hash key H ( w ) and per-form the bitwise NOT operation to get the key H ( w ); 2) look up H ( w ) in the hash table for the nearest entries up to a small Hamming distance, obtaining a short list L whose points are retrieved from the found hash buckets; 3) scan the list L and then return the point x  X  = arg min x  X  X  | w  X  x | / k w k . In fact, searching within a small Hamming ball centered at the flipped code H ( w ) is equivalent to searching the codes that have largest possible Hamming distances to the code H ( w ) in the Hamming space. 5.1. Datasets We conduct experiments on two publicly available datasets including the 20 Newsgroups textual corpus and the 1.06 million subset, called Tiny-1M , of the 80 million tiny image collection 1 . The first dataset is the version 2 2 of 20 Newsgroups . It is comprised of 18,846 documents from 20 newsgroup categories. Each document is represented by a 26,214-dimensional tf-idf feature vector that is  X  2 normalized. The Tiny-1M dataset is a union of CIFAR-10 3 and one million tiny images sampled from the entire 80M tiny image set. CIFAR-10 is a labeled subset of the 80M tiny image set, consisting of a total of 60,000 color images from ten object categories each of which has 6000 sam-ples. The other 1M images do not have annotated la-bels. In our experiments, we treat them as the  X  X ther X  class besides the ten classes appearing in CIFAR-10 , since they were sampled as the farthest 1M images to the mean image of CIFAR-10 . Each image in Tiny-1M is represented by a 384-dimensional GIST ( Oliva &amp; Torralba , 2001 ) feature vector. For each dataset, we train a linear SVM in the one-versus-all setting with an initially labeled set which contains randomly selected labeled samples from all classes, and then run active sample selection for 300 it-erations. The initially labeled set for 20 Newsgroups includes 5 samples per class, while for Tiny-1M in-cludes 50 samples per class. For both datasets, we try 5 random initializations. After each sample selection is made, we add it to the labeled set and re-train the SVM. We use LIBLINEAR 4 for running linear SVMs. All our experiments were run on a workstation with a 2.53 GHz Intel Xeon CPU and 48GB RAM. 5.2. Evaluations and Results We carry out SVM active learning using the minimum-margin based sample selection criterion for which we apply hyperplane hashing techniques to expedite the selection procedure. To validate the actual perfor-mance of the discussed hyperplane hashing methods, we compare them with two baselines: random selec-tion where the next label request is randomly made, and exhaustive selection where the margin criterion is evaluated for all currently unlabeled samples. We compare four hashing methods including two ran-domized linear hashing schemes AH-Hash and EH-Hash ( Jain et al. , 2010 ), the proposed randomized bi-linear hashing scheme BH-Hash, and the proposed learning-based bilinear hashing scheme that we call LBH-Hash. Notice that we use the same random pro-jections for AH-Hash, BH-Hash, and the initializa-tion of LBH-Hash to shed light on the effect of bi-linear hashing (XNOR two bits). We also follow the dimension-sampling trick in ( Jain et al. , 2010 ) to ac-celerate EH-Hash X  X  computation. In order to train our proposed LBH-Hash, we randomly sample 500 and 5000 database points from 20 Newsgroups and Tiny-1M , respectively. The two thresholds t 1 , t 2 used for implementing explicit collision are acquired accord-ing to the following rule: compute the absolute cosine matrix C between the m sampled points { x i } m i =1 and all data, average the top 5% values among C i. across x  X  X  as t 1 , and average the bottom 5% values as t 2 . So as to make the hashing methods work under a com-pact hashing mode for fair comparison, we employ a single hash table with short code length. Concretely, we use 16 hash bits for EH-Hash, BH-Hash, and LBH-Hash, and 32 bits for AH-Hash because of its dual-bit hashing spirit on 20 Newsgroups . When applying each hashing method in an AL iteration, we perform a hash lookup within Hamming radius 3 in the corre-sponding hash table and then scan the points in the found hash buckets, resulting in the neighbor near to the current SVM X  X  decision hyperplane. Likewise, we use 20 bits for EH-Hash, BH-Hash, and LBH-Hash, and 40 bits for AH-Hash on Tiny-1M ; the Hamming radius for search is set to 4. It is possible that a method finds all empty hash buckets in the Hamming ball. In that case, we apply random selection as a supplement. We evaluate the performance of four hashing meth-ods in terms of: 1) the average precision (AP) which is computed by ranking the current unlabeled sample set with the current SVM classifier at each AL itera-tion; 2) the minimum margin (the smallest point-to-hyperplane distance | w  X  x | / k w k ) of the neighbor re-turned by hyperplane hashing at each AL iteration; 3) the number of queries among a total of 300 for every class that receive nonempty hash lookups. The former two results are averaged over all classes and 5 runs, and the latter is averaged over 5 runs. We report such results in Fig. 3 and Fig. 4 , which clearly show that 1) LBH-Hash achieves the highest mean AP (MAP) among all compared hashing methods, and even out-performs exhaustive selection at some AL iterations; 2) LBH-Hash accomplishes the minimum margin closest to that by exhaustive selection; 3) LBH-Hash enjoys almost all nonempty hash lookups (AH-Hash gets al-most all empty lookups). The superior performance of LBH-Hash corroborates that the proposed bilinear hash function and the associated learning technique are successful in utilizing the underlying data infor-mation to yield compact yet discriminative codes. Finally, we report the computational efficiency in Ta-bles 1-3 of the supplementary material, which indicate that LBH-Hash takes comparable preprocessing time as EH-Hash and achieves fast search speed. We have addressed hyperplane hashing by proposing a specialized bilinear hash function which allows efficient search of points near a hyperplane query. Even when using random projections, the proposed hash function enjoys higher probability of collision than the exist-ing randomized methods. By learning the projections further, we achieve compact yet discriminative codes that permit substantial savings in both storage and time needed during search. Large-scale active learn-ing experiments on two datasets have demonstrated the superior performance of our compact hyperplane hashing approach.

