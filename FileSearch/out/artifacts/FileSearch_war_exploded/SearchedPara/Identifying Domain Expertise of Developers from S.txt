 We are interested in identifying the domain expertise of developers of a software system. A developer gains expertise on the code base as well as the domain of the software system he/she develops. This information forms a useful input in allocating software implementation tasks to developers. Domain concepts represented by the system are discovered by taking into account the linguistic information available in the source code. The vocabulary contained in source code as identifiers such as class, method, variable names and comments are extracted. Concepts present in the code base are identified and grouped based on a well known text processing hypothesis -words are similar to the extent to which they share similar words. The developer X  X  association with the source code and the concepts it represents is arrived at using the version repository information. In this line, the analysis first derives documents from source code by discarding all the programming language constructs. KMeans clustering is further used to cluster documents and extract closely related concepts. The key concepts present in the documents authored by the developer determine his/her domain expertise. To validate our approach we apply it on large software systems, two of which are presented in detail in this paper. H.3.3 [ Information Storage and Retrieval ]: Information Search and Retrieval  X  Clustering. D.2.9 [ Software Engineering ]: Management  X  Programming Teams Documentation, Design, Experimentation, Verification. Document Clustering, Version History, Developer Expertise. Developers implementing software systems, gain expertise over a period of time on different aspects of software development  X  programming languages, libraries , frameworks and the domain of the software system. A developer implementing an online auction system using Java 2 Enterprise Edition (J2EE) not only gains knowledge on using Servlet or Java Beans but also understands the process related to creating an auction. This information is particularly useful in large organizations where there are several development projects in similar domain using similar technologies. Identifying developer expertise based on the domain and technical know-how can be a very useful input for allocating projects or tasks. In software engineering, much work has been done in identifying experts for a source code file. Expertise Recommender [11], Expertise Browser [12], use check-in logs from version repository to determine the list of experts a given source code file. This information is useful but is very specific to a given project. In software services organization, developers work on multiple projects and multiple technologies. Identifying the expertise of a developer in a project agnostic manner will help in ensuring developers with the right skill work on a specific project or task. Domain and technical know-how of a developer, thus, forms an important input for defining the skill. Extracting the technical expertise of a developer from the source code is straightforward as the details of the frameworks, libraries and other program specific information is readily available. The work described in this paper looks at extracting concepts present in the source code, associating the information with the developers based on check-in logs of the version repository and defining the domain expertise of a developer. The domain knowledge present in source code is extracted based on the private final void confirmOrder( Document doc) { } linguistic information present in source code. As d escribed by Kuhn et.al. [15], the source code of a system has two distinct sets of information  X  structural information and linguis tic information. Linguistic information provides a useful input for understanding the concepts represented by the system. Consider th e method confirmOrder shown in Figure 1. Scanning through th e method helps in realizing the purpose of the method  X  send s a mail to the customer with details of the order processed. Figur e 2 depicts a method with the same structural information. Howeve r, we realize the purpose of the method is different  X  mailing th e details of a processed claim. The developers implementing the co de would have gained different domain expertise through the process of implementing the system. In the examples, the lingu istic information present is the source code represents t he domain concepts of the system. Extracting this information from the code authored by a developer is representative of develo per X  X  domain expertise. The code authored by a developer is extr acted from the source code version repository. The main goal of this work, hence, is to identify c oncepts from the vocabulary present in source code. Source code docu ments are generated by discarding all the programming languag e constructs. These documents are used for further analysis. The key terms are extracted by clustering source code documents and i dentifying key discriminating terms in each of the clusters. T he documents are associated to the developers to identify the co ncepts a developer has worked on. While all the studied syst ems are written in Java, the approach of extracting concept s and identifying developer expertise is language indepen dent as the programming language constructs are discarded. The paper is structured as follows. Section 2 deta ils the approach used for extracting concepts and associating it wit h the developers of the system. Section 3 presents the results of us ing the approach on three case studies. Section 4 presents the key p arameters that impact the results. Section 5 browses the related w ork and Section 6 concludes and presents future work. Figure 3 shows the overview of our approach. First we process the source code to source code documents. The documents are clustered to create a homogeneous set. The key (dis criminative and descriptive) terms of the resulting clusters ar e identified as domain concepts. The concepts present in the docume nts authored by the developer forms the developer X  X  domain exper tise. The details of the steps to identifying the developer e xpertise are presented in the following sub-sections. The source code files are broken down to the requir ed level of granularity  X  class or files to create documents th at would be clustered. The following steps are involved in crea ting source code documents. Step 1: Term extraction . Multi-word identifiers are broken down into single words. For example, jdbcConnection, ser viceXML, JMSTopic are all broken down into the respective si ngle words  X  jdbc, Connection, service, XML, JMS, Topic. Words t hat are less than 3 characters in length are ignored. All terms are converted to lower-case.
 Step 2: Stop-word elimination . Commonly used words in English, all programming language constructors, some commonl y used identifiers such as temp and common language terms (for Java Object, get, set ) are added to the stop-word list and discarded. Step 3: Morphological generalization . All the terms are reduced to their morphological root using Porter X  X  stemmer [9]. For example, counting and counter both become count. We build the document and term matrix, with all documents and al l terms. Source code documents are represented using the vec tor-space model [10]. In this model, each document d is considered to be a vector in the space of the distinct terms m present in the collection of n documents. The tf-idf term weighting scheme is applied representing each document d as the vector. tf i corresponds to the frequency of the i th term in the document and log( n/df corresponds to its inverse document frequency where df number of documents that contain the i th term. The similarity between a pair of documents d i and d j is measured by taking the cosine of the angle formed between the tf -idf representations of the vectors. This similarity measure becomes one if the document vectors point in the same direction (i.e., they con tain identical set of terms in the same relative proportion), and zero if there is nothing in common between them (i.e., the vectors a re orthogonal to each other). We use K-Means clustering to group documents into homogeneous sets based on the co-occurring terms [1] . Various clustering algorithms are available from CLUTO [7]. A study [6] shows that these algorithms are efficient and effec tive in producing both hierarchical and non-hierarchical cl ustering solutions. The clustering tool provides a total of seven different criterion functions that produce high-quality clust ers and optimize various aspects of intra-cluster similarity, inter-cluster dissimilarity, and their combinations. The mathemat ical definition of the clustering criterion (or objective) function s used in our approach is given by the function I2 where k is the total number of clusters, S i is the set of documents assigned to the i th cluster, v and u represent two documents, and sim( v, u ) is the similarity between two objects. This crite rion function was used as it resulted in reasonably bala nced clusters. private final void processClaim( Document doc) { } Concept identification works as follows. The most d escriptive and discriminative terms of a cluster are identified as key concepts for the group of similar source code documents. The set of descriptive terms is determined by selecting the terms that con tribute the most to the average similarity between the documents of each cluster. On the other hand, the set of discriminating terms is determined by selecting terms that are more prevalent in the c luster compared to the rest of the documents. In general, there wil l be an overlap between the descriptive and discriminating terms. When a developer submits code to a source repositor y (also known as  X  X hecking-in X ), the repository logs the su bmission. The commit log entry contains information, such as the file that was checked in, the user-id of the committer, its revis ion number, the check-in date and time, and the check-in comment ma de by the committer. The source repository software allows a user to view all the log entries for a specific file. Establishi ng the link between the source code files and the developers is hence t rivial. The following steps are carried out  X  For each developer, the list of source code files h e/she has  X  The time period of the developers association with a file is Post clustering, the source code documents are assi gned clusters based on the similarity of concepts in them. We vis ualize the distribution of concepts for each developer. Figure 4 shows the distribution of source code documents belonging to different concept clusters authored by a developer. This is d one by mapping the source code files to their respective s ource code documents and identifying the cluster the source co de document belongs to. Concept dispersion can be used to ident ify the predominant concepts the developer has worked on. T here could be developers working on multiple domain concepts f or their functionality. Figure 4 below represents a case whe re multiple sets of concepts of the system have been referred by a d eveloper during the implementation. However, the developer i s unaware of certain concepts in the system, not having worked o n them at all. Figure 4 Concept Dispersion for documents authored by a developer where each cluster represents a set of cl osely related concepts To apply the method, source code documents are extr acted. CLUTO, the clustering tool kit is used to group doc uments containing similar concepts. The method is evaluate d in two steps; domain concepts extracted from source code and the use of domain expertise of developers for allocating tasks . For evaluating the domain concepts extracted from sourc e code, two open source systems are studied  X  JBoss Application server and Lucene Search Engine Library. The complete source c ode is acquired. The concepts extracted from source code are compared to the concepts extracted from other documentations of the systems. Precision and Recall metrics are used to d o the comparison. For evaluating the use of domain expert ise for allocating tasks, we use a project at the research lab, extract concepts and define the domain expertise of the dev elopers. A set of development tasks are chosen. For each task, the required domain expertise is identified. The expertise of th e developers identified by our approach is used to choose the de velopers. The team leads choice of developers is compared to the developers chosen by our method. The details of the case studies are given below  X  In the first case study we apply it on a large appl ication  X  The second case study is the open source Java searc h engine Table 1 summarizes the size of each case study. It lists the number of classes, methods and terms that were extracted f rom the two software systems. Source code has relatively limit ed vocabulary as compared to textual documents JBoss is a Java 2 Enterprise Edition (J2EE) Applica tion Server. This is a large application implementing the comple te specification. A source code document is extracted from a Java Class. The number of clusters is set to 25.A key in put to setting k  X  the number of concept clusters is the number of m odules the software application is divided into. Software modu les are often decomposed based on the runtime behavior and can us e multiple domain concepts. However, we have seen that the num ber of concept clusters is close to the structural decompo sitions defined by the developers. Table 2 shows the number of sour ce code documents clustered and the key concepts that are e xtracted for 10 of the 25 clusters As shown in the Table 2, each of these set of conce pts is representative of the core functionalities provided by the application server. Cluster 1 groups all the docume nts related to http://www.jboss.org http://lucene.apache.org Web Service. Cluster 2 represents all the concepts related to Enterprise Java Beans. Important concepts related t o the J2EE application server can be identified  X  Java Messagi ng Service (JMS), Java Database Connectivity (JDBC), Enterpise Java Beans (EJB), Aspect Oriented programming (AOP), Java Mana gement Exchange (JMX), and server implementation concepts such as Security, Multi-threading, Remote Method Interface (RMI) implementation. Figure 5 shows the concept dispersion across three developers of JBoss. As shown developer  X  X drian X  has primarily wo rked Case Study Classes Methods Terms 
Cluster # of 1 138 Wsdl, operation, 2 169 proxy, ejb , context , 3 187 Session, connect, 4 230 Cache, lock, timeout, 5 285 mbean , server , notify, 6 202 role , security, principle 7 206 jdbc , entity , command 8 208 Servlet, request, http, 9 227 Method ,advisor, message queues, the container and the server implem entation. Similarly, developer  X  X nil.saladhana X  has worked on implementing security and identity management of the Jboss appli cation server. There are some authors who would have worked on imp lementing several concepts in the system. For example, author  X  X cott.stark X  has worked on most concepts of the application serv er. Concept dispersion across the documents authored by develop ers can hence be used to identify the expertise of develope rs. Version history information can also be used to ide ntify the time period during which the author worked on the concep ts. This can also be a useful input in identifying the developer for a given task. For example, the author  X  X cott.stark X  worked on con cepts related to JDBC and EJBQL in the year 2005. Hence, the auth or could be currently inactive in the given domain. The concept s a developer is actively working on can be used to evaluate the relevance of the expertise for a given task. Lucene is a Java Search Engine Library from Apache. This is a small application with approximately 600 documents. The number of clusters is set to 5 based on the distinct modul es present in the concepts are representative of a search engine. Con cepts represent searching, ranking, index creation, index storage a nd performance benchmarking of the library. Figure 6 shows Concept dispersion for one of the active contributors to the search en gine  X   X  X tis X . Table 3 Concept Clusters for Lucene Search Engine Figure 6 Concept Dispersion for author 'otis' Having contributed to all the modules of the librar y, the author has worked on all the concepts related to the libra ry. We see similar dispersions for the author of Lucene  X  X  X utt ing X . As mentioned in the previous section, check-in logs pr ovide information on time periods during which active con tributions were made by the author. Figure 7 depicts the time line plot for author  X  X utting X  showing that the author not being very active for some of the concepts related to storage and creatio n of index. Figure 7 Time line veiw of the concepts worked on b y developer Evaluating concept identification techniques is a d ifficult task. Concepts identified by different techniques have to be compared. Further validating results requires human intervent ion and hence is a time-consuming process. An obvious approach is to utilize the traditional measures of information retrieval, name ly precision and recall. Precision measures the degree of accura cy and any errors in the returned concepts; and recall measure s the degree of completeness and any errors by reason of missing co ncepts. To avoid manual verification of correctness of conc epts extracted, we compare the concepts extracted from source code with the concepts extracted from documents available for the applications. Our assumption is based on the fact that the docume nts and user guides would also reflect key concepts of the syste m. Table 4 shows the precision recall values obtained when com paring all the concepts (union of all concepts) extracted from sou rce code with all the concepts extracted from user guides. The te rms were extracted using the same technique as described in section 2, by preprocessing the user guides (stop word eliminatio n and stemming). We observe a low recall as a lot of disc ussions in the user guides are focused on the runtime behavior of the system. Concepts such as performance, mysql, error, loading and reboot were dominant in JBoss documents. In Lucene documen ts concepts such as platform, framework, office word, compact, http://manning.com/hatcher2/ Cluster # of 1 57 task, run, perf, time, 2 128 query, term, token, 3 84 scorer, sorter, 4 113 token, analyzer, filter, 5 148 term, segment, vector, Case Study Documents Precision Recall JBoss User 
Guides Lucene In 
Action 3 Table 4 Precision and Recall of Concepts extracted from User clusters were dominant reflecting the deployment as pects of a search engine library. In this section, we describe a user study conducted on a project for allocating tasks using the domain expertise of a developer. The project is a UML 2.0 design tool that supports SOA development. A core team member of the project was asked to spec ify 10 development tasks and some key concepts that repres ent the tasks. For each task, the team member was asked to choose from the set of 8 project developers. The set of developers cons isted of those who were found to have committed source code files from July 2006 to December 2007 and had actively made commits for the past three months. Our approach was then used to identify the develope rs. For each task, based on the key concepts provided by the cor e team member, a set of developers was identified using de veloper X  X  concept dispersion. Developers, who had worked on e ven a single source code file that represented the domain concep t, were chosen suitable for the task. Table 5 lists the tasks and key concepts representing the task, the precision and recall val ues for the developers chosen by the core team member and the d evelopers chosen using the domain expertise. 
Table 5 Precision and Recall of Developer chosen fo r a task Task Name Task1 Service, transform, Task2 Impact, model, Task3 Report, Publish, Task4 Dialog, shell, Task5 Transform, bpel, Task6 constraint, Task7 Viewer, test, litmus 33% 100% Task8 Service, transform, Task9 Pattern, uml, package 67% 67% Task10 Xsd ,schema, property 33% 100% The results of using domain expertise in identifyin g developers suitable for a task results in a precision of 68% and recall of 93% on an average. The approach seems effective in most cases with two bad precision values where the key terms identi fied by the core team member were generic enough for all the de velopers to have worked on the concept. In these cases of false positives, developers identified had a very low percentage of expertise on the particular concept. The results would improve i f we provide a relevance ranking mechanism to rank the expertise o f the developers for a task. However, in the current stud y, any developer having worked on the concept, irrespectiv e of time and degree of expertise, was considered suitable. In this section we discuss the variation points of the approach that impact automatic extraction of concepts and their d ispersion for developers. Concepts can be extracted from source code if well defined naming convention is followed  X  Java Naming Convent ion, Hungarian notation. If the code does not follow any naming convention, extracting multiple words from identifi ers will not be accurate and hence the extracted concepts and hiera rchies will fail to reflect reality. Identifier names are very important for our approac h. In cases where abbreviations are widely used, concepts detec ted have the abbreviated names. The developer will need to under stand what the concept means from the abbreviations. A mixed u se of abbreviations and the complete name will result in the same concept being identified as two different concepts. For example in the case study of Lucene Search Engine Library, the re are two concepts doc and document that refer to the same concept. Similarly in JBoss ctx and context are used to represent the same concept. Larger the value of K, larger is the number dispers ion of developer X  X  expertise among the groups of concepts. This would help in identifying several concepts and their asso ciations with the developers. However, in systems where the concepts are closely related, a large K, fragments the expertise of a de veloper across several small groups. We have arrived at k empirica lly in all our studies. We start with the value of k equal number of structural decompositions of the system assuming that the deco mpositions are representative of different concepts in the sys tem. The value of k is then arrived at by identifying the number of o verlapping concepts that occur in the clusters. Based on the check-in log file data, our approach a ssumes that the person checking-in the file is the person who has c reated or updated the file. This approach may not hold for al l projects, especially some of the open source projects such as Firefox. The developer who updates source code file submits requ ests that the change be applied to the source repository and only a subset of the project community can actually commit such a submit ted change. In some scenarios, there could be multiple develope rs working on a module and only one of them would check-in all th e code files for the module. In such scenarios, special processi ng of data would be required. Maletic and Marcus [14] did some early work to account for the linguistic information in source code. They use Lat ent semantic Indexing (LSI) to group the software entities. Kuhn et. al [15] further extend this work and apply LSI on object or iented systems at different levels of abstractions. The authors bu ild a term-document matrix form source code where a document i s a software artifact (class, method). LSI is applied o n this matrix to build an index with similarities. The similarity be tween software artifacts is visualized as a correlation matrix tha t helps developers identify highly related software artifacts. The app roach, as discussed by the authors, creates one or two large domain clusters and several small independent clusters. The work pr esented in this paper is similar to semantic clustering where we id entify concepts with similar purpose. The concepts that have been i dentified in the approach presented in this paper groups documen ts consistently without creating any dominating set. T he extracted concepts are further used to define the domain expe rtise of the developer. In the past, software system has been decomposed an d grouped in subsystem using well known hierarchical clustering techniques with the clustering criterion taking into account t he structural dependencies between software artifacts [13]. In this work we use the linguistic information and apply document clust ering techniques. Document clustering techniques are used to generate one-level hierarchies. Over the years a variety of different algorithms have been developed. These algorithms ca n be categorized along different dimensions based either on the underlying methodology of the algorithm, leading to agglomerative [3] or on partitional approaches [2]. Karypis et al [4] [5] compare different clustering techniques and cri terion. They conclude that paritional algorithms such a K-means perform as well as agglomerative clustering techniques. Two significant efforts towards providing a list of experts for a source code file: the Expertise Recommender [11] and the Expertise Browser [12]. Both of these projects use the source repository check-in log for a particular file conta ining the user name of the person who performed the commit, to det ermine who has expertise for that source file. The Expertise R ecommender uses this heuristic to present the name of the deve loper with the most recent expertise for the source file. The Expe rtise Browser uses the heuristic to gather and rank the expertise of developers for the source file. In each of these cases, the in tent is to discover either the developer or group of developers who hav e expertise with a specific source code file. This work generates clusters of documents using par itional k means clustering. The key concepts in the clusters are identified associated to the knowledge gained by developers wo rking on the documents or the code base. Source code contains semantics of a software system in the names of identifiers and comments. In this paper we prese nt our approach to retrieve the concepts present in the so urce code vocabulary and use it to define the expertise a dev eloper gains when working on the code base. We introduce concept extraction, clustering and dispersion of the concepts to define the expertise for a developer. We see groups of co-occuring conce pts and we interpret them as linguistic topics that reveal the domain of the code. As compared to our previous approaches in ide ntifying experts of a given file in the software system, we identify expertise of developers in the context of the domai n of the system. We applied the approach on several case studies wit h different characteristics, two of which are presented in this paper. The case studies show that our approach can successfully ext ract the concepts of the system. Concept dispersion helps in identifying the distribution of knowledge of concepts the devel oper has gained. Our experiments show that this information is useful in identifying the suitability of a developer for a gi ven development task. As part of our future work we intend to rank the list of developers by taking into account the percentage of work done on the concept and the time line during which the deve loper worked on a concept(s). [1] Z. Harris, Mathematical Structures of Language, Wil ey, [2] A.K. Jain and R. C. Dubes. Algorithms for Clustering Data . [3] B. King. Step-wise clustering procedures. Journal o f the [4] Y. Zhao and G. Karypis. Evaluation of hierarchical [5] Y. Zhao and G. Karypis. Empirical and theoretical [6] M. Steinbach, G. Karypis, and V. Kumar. A compariso n of [7] G. Karypis. CLUTO: A Software Package for Clusterin g [8] C. Nevill-Manning, I. Witten, and G. Paynter. Lexic ally-[9] M. F. Porter. An algorithm for suffix stripping. Pr ogram, [10] G. Salton. Automatic Text Processing: The Transform ation, [11] D. W. McDonald and M. S. Ackerman. Expertise [12] A. Mockus and J. D. Herbsleb. Expertise browser: A [13] S. Mancoridis, B. Mitchell, Y. Chen, and E. Gansner , [14] J. I. Maletic, A. Marcus, Using latent semantic ana lysis to [15] Kuhn, A., Ducasse, S., and G X rba, T. 2007. Semantic
