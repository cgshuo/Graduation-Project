 Spatio-temporal databases play an important role in applications involving space and time, such as road traffic supervision and location based mobile services in large cities. Consider that a traffic manager may use a mouse to draw a region of the downtown area on the city map to find the amount of vehicles running in the area right now. Furthermore, he may also want to learn how this value has changed in the past 1 hour so that he (she) is capable of providing suggestions for drivers by doing some prediction. Such tasks can be performed well provided that aggregate queries (e.g., SUM, AVG) are processed efficiently.

One direct kind of solutions to processing aggregate queries is to calculate answers based on a database reserving the moving traces of all objects, such as TPR-tree[10] and R FFP -tree[9]. However, such methods may consume too much storage resource and computation resource. An alternative kind of methods prefers to calculate answer s based on compact structures. For example, Sun et al. process SUM query by using an AMH structure, which represents w  X  w cells by at most B buckets, B w 2 [11]. But Sun et al. X  approach still suffers following weaknesses. First, although parameter B is critical for the quality of answers, no general value of B is mentioned to ensure the quality for all queries. Second, the reorganization of cells partition i s only performed when system is free, so that the quality of the answer continue s to deteriorate dur ing two consecutive reorganization operations.

The purpose of this paper is to calculate qualified answers for aggregate queries with small space resource and computation resou rce. We mainly con-sider two kinds of queries (e.g. SUM and AVG) and retain others as a piece of future work. The SUM query returns the number of objects within a certain area at a time point, while the AVG query returns the average number of ob-jects per basic cell at a time point. Let A and A denote the query answer and the correct answer respect ively. The absolute error  X  a and relative error  X  r ,are defined as  X  a = | A  X  A | and  X  r = | A  X  A | A . A novel structure, named AMH*, is proposed to summarize spatio-temporal information. As an improved version of AMH structure, AMH* also splits the whole area into lots of buckets, but the number of buckets can grow or shrink according to the change of the data distribution. Based on AMH*, the absolute error and (or) the relative error of a query can be restricted smalle r than a predefined parameter.

The rest of the paper is organized as follows. Section 2 formally defines the problem and reviews related work. Our solution is proposed in Section 3. In Section 4, we present extensive experimental studies and report our findings. Finally, Section 5 concludes the paper with a summary. 2.1 Query Definition We consider an environment containing n objects and 1 central site. When an object moves, it sends its identity and new location, but not its velocity, to the central site through wireless network. S tatic objects do not send information to the central site. At any time point, the central site knows the locations of all objects. The central site partitions the whole data space into a 2D grid containing w  X  w cells, each with width 1 /w on each axis. Each cell c is associated with a frequency F c , representing the amount of objects in its extent currently. The two kinds of aggregate queries are defined as follows.
 SUM query sum ( q T ,q R ) : q T is the time point, q R is the query range. It returns the number of objects within a range q R at time q T .
 the average number of objects per cell in a range q R at time q T .

If q T =0, the query constitutes a present query; else if q T &lt; 0, it turns to be a historical query. Consider a small example where the data space is partitioned into 5  X  5 cells, and the data distributions at time points 0 and 1 are listed in Figure 1. Let q R be the rectangle of the shadowed part. At time point 1, the query sum (0 ,q R ) returns 48, and the query avg (  X  1 ,q R ) returns 5.3. 2.2 Related Work Processing spatio-temporal aggregate queries has been widely studied for a long period[6]. One kind of methods is based on building various indexes for all mov-ing objects, such as TPR-tree[10] and R PPF -tree[9]. However, such methods are inefficient to cope with the problem because of large storage consumption, expen-sive updating cost, and slow response time. An alternative kind of methods only constructs an compact structure to present the whole spatio-temporal database, such as query adaptive histograms (e.g., STGrid[1] and STHoles[3]) and other multi-dimensional approximation structu res (e.g., DCT-based histogram[5], the wavelet-based histogram[7]).

The previous work mostly related to our work appears in [4,8,11,12]. The methods in [8,12] are similar to  X  X onventional X  processing framework where every query invokes disk I/Os and returns an exact answer. Contrarily, Sun et al. build AMH structure (be reviewed in Section 2.3) to compress data and return approximate answers[11]. The work in [4] also considers how to mine frequent items in spatio-temporal databases with small error. 2.3 Adaptive Multi-dimensi onal Histogram (AMH)[11] An AMH contains at most B buckets. Each bucket b k is defined as ( R, n k ,f k , g ,v k ), where R is its rectangular extent, n k is the number of cells in R , f k is the average frequency of these cells (i.e., f k =(1 /n k )  X  cell c in b average  X  X quared X  frequen cy of these cells (i.e, g k =(1 /n k )  X  cell c in b and v k is their variance (i.e., v k =(1 /n k )  X  cell c in b can be calculated through v k = g k  X  f 2 k . A binary partition tree (BPT) is used to index all buckets. In a BPT tree, each leaf node represents a bucket, and each intermediate node is associated with a r ectangular extent R that encloses the extents of its (two) children. Buckets are reorganized when the system is free. Figure 2 shows the AMH structure and BPT tree upon the data distribution in Figure 1(a). All 25 cells are separated into 6 buckets. 3.1 Architecture Figure 3 shows the architecture of the approach. The scenario contains multiple (moving) objects and a single server site. Each moving object reports its location (not the velocity) to the server site only when it changes location. The server site consists of three components, spatio-temporal database , item processing engine and query processing engine , which are described as follows.
 Spatio-temporal Database: The spatio-temporal database contains two parts, AMH* and past index. As an improved version of AMH, AMH* summarizes the current data distribution by using multiple buckets in format All buckets are organized in a BPT-tree. The number o f buckets in AMH* can grow or shrink during the running time without any restriction on the maximum amount of buckets. When a bucket becomes  X  X ld X , it moves to the past index at once. A bucket becomes  X  X ld X  because of following reasons: (1) the frequency of any cell in the bucket changes; (2) split and (/or) merge operations are executed to reorganize the bucket extents. Such  X  X ld X  buckets must be saved in the past index to serve for the past timestamp queries (i.e., q T &lt; 0). Many methods have been devised to organize the buckets in the past index, such as packed B-tree[11] (used in this paper) and 3D R-tree[2].
 Item Processing Engine: Item processing engine maintains the spatio-temporal database during the running time. When the frequency of any cell c changes, it invokes Algorithm maintain (Algorithm 1.1) to find the bucket b covering cell c , update fields of bucket b and invoke isValidBucket subroutine to check whether the bucket b is valid or not (Lines 2-4). The isValidBucket subroutine will be introduced in Section 3.2 in detail. If bucket b is invalid, Al-gorithm split ( b ) (Algorithm 1.2) is invoked to split b into several valid buckets. For any rectangular bucket ( col  X  row ), there exist ( col + row  X  2) different partitioning ways because the bucket can be divided through x-axis or y-axis. By applying greedy algorithm, each time we choose the way with smallest value of the weighted variant sum WVS (e.g., WVS = n l  X  v l + n r  X  v r ), where ( n l ,v l ) and ( n r ,v r ) belong to two children buckets b l and b r . Otherwise if the bucket b is valid, Algorithm merge (Algorithm 1.3) is invoked to merge some redundant buckets into one larger valid bucket (Lines 6-7).
 Query Processing Engine: Query processing engine calculates answer for a query. Remember that the current data distribution is stored in AMH*, and the history data distributions are stored in past index . We can always find many buckets to construct q R at that time. Let S denote the set of cells belonging to q ,and f ( c )= f b , where cell c is covered by the bucket b , the SUM query and AVG query can be answered as follows. Algorithm 1. Outline of the algorithm 3.2 Check the Validation of a Bucket The goal of Algorithm isValidBucket ( b ) is to test the validation of bucket b . Here, we claim four cases (Case (1)-(4)). If one or multiple cases are employed by Algorithm isValidBucket to test a bucket, the bucket is valid (/invalid) when such case(s) is(are) satisfied (/unsatisfied). For example, if isValidBucket only tests Case 2 for all buckets, the relative error for a SUM query must be smaller Lemma 1. Let X denote a random variable with an expect E(X) and a deviation use E ( X ) to estimate the value of X , with a probability  X  , the maximum absolute The correctness of the lemma comes from the definition of  X  a and  X  r .
According to Equ. (1)-(2), the answer for a query is calculated by a set of cells. Here, let X c denote a random variable for the frequency of cell c (i.e., F c ). Then, its expect value E ( X c ) is equal to the average frequency of the bucket it (i.e., v ( c )). The answer of a query can be treated as a random variable following normal distribution (i.e., function  X  (  X  ) is defined as:  X  = 1  X  Case 1. The absolute error for any SUM query is smaller than  X  sum,a if for any Case 2. The relative error for any SUM query is smaller than  X  sum,r if for any
We sketch the proof here. Let Y be a random variable to represent the an-swer of a SUM query. Then, E ( Y )= i =1 ..p E ( X i )= i =1 ..p f i ,  X  ( Y )= Case 3. The absolute error for any AVG query is smaller than  X  avg,a if for any Case 4. The relative error for any AVG query is smaller than  X  avg,r if for any We sketch the proof here. Let Z denote the random variable for the answer of a  X  In this section, we implement a series of ex periments to evaluate the performance of our approach. All codes are written in C# and run in a PC with 512M memory. We use two sets of points (e.g., D 1 and D 2 ), each containing 10k 2D points, as shown in Figure 4(a) and (c). We then create 10k objects moving from a point in D 1 (randomly selected) t oanotherpointin D 2 (also randomly selected) in straight lines with different velocities . Here, the whole data space is separated into 50  X  50 cells. We set  X  =0 . 95 (i.e.,  X  (  X  )=2 . 0) and  X  sum,r =0 . 5. Figure 4 demonstrates the data distribution and bucket partitions in the initial stage, middle stage and final stage. Clearly, the histogram shape continues to change.
Figure 5 demonstrates how the number of buckets changes with the time going on. We can observe that the number of buckets changes under different distributions to reserve the precision. Figure 6 reports the qualities of two SUM queries. The sizes of q R in query 1 and query 2 are 25  X  25 and 25  X  6 respectively. in the x-axis. The y-axis represents the relative errors of two queries. In all situations, the relative error is no more than 2%. As a critical task in spatio-temporal field, getting qualified answers for aggregate queries still encounters some big challeng es. Many researchers prefer to get pre-cise answers after building indexes for all spatio-temporal logs. However, it may raise large additional costs, such as storage consumption, updating cost, and the computation consumption. Others try to get approximate answers by maintain-ing compact structures efficiently, but they fail to provide qualified answers.
In this paper, we devise a novel approach to get qualified answers for aggregate queries (including SUM and AVG queries) in spatio-temporal database. The core structure of the approach, named AMH*, splits the whole data space into a small number of rectangular buckets. We show that the absolute error and (/or) the relative error of a query can be kept smaller than predefined thresholds if all buckets satisfy some conditions at the same time. Besides, our approach only consumes small storage space, has low updating cost and quick response time. Experimental results evaluate the performance of our approach.

