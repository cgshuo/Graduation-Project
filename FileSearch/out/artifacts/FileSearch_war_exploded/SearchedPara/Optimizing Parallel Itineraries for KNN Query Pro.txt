 Spatial queries for extracting data from wireless sensor net-works are important for many applications, such as envi-ronmental monitoring and military surveillance. One such query is K Nearest Neighbor (KNN) query that facilitates sampling of monitored sensor data in correspondence with a given query location. Recently, itinerary-based KNN query processing techniques, that propagate queries and collect data along a pre-determined itinerary, have been developed concurrently [12][14]. These research works demonstrate that itinerary-based KNN query processing algorithms are able to achieve better energy efficiency than other existing algorithms. However, how to derive itineraries based on different performance requirements remains a challenging problem. In this paper, we propose a new itinerary-based KNN query processing technique, called PCIKNN , that de-rives different itineraries aiming at optimizing two perfor-mance criteria, response latency and energy consumption . The performance of PCIKNN is analyzed mathematically and evaluated through extensive experiments. Experimen-tal results show that PCIKNN has better performance and scalability than the state-of-the-art.
 Categories and Subject Descriptors: H.3.4 [Systems and Software]: Distributed Systems General Terms: Design, Experimentation and Performance Keywords: K nearest neighbor query, wireless sensor net-works.
We have witnessed a rapid technological advance in wire-less sensor networks (WSNs) in recent years. WSNs, which consist of a large number of sensor nodes capable of sens-ing, computing, and communications, can be used in a va-riety of applications such as border detection, environmen-tal monitoring, smart home, and security surveillance. A lot of times, WSNs are deployed over a wide geographical area to facilitate long-term monitoring and data collection tasks. Thus, spatial queries that aim at extracting sensing data from sensor nodes located in certain areas of inter-ests are essential to many WSN applications [6]. In this paper, we focus on the processing of K nearest neighbors (KNN) query, a classical spatial query with importance in many application domains in WSNs. A KNN query facili-tates data sampling of the sensors located in a geographical proximity via specification of a query point q and a sam-ple size K . Using a KNN query, one could obtain sensor data (e.g., environmental measurements) near a query loca-tion of interests. Through years of research effort, efficient KNN query processing algorithms have been developed for centralized spatial databases[7][9][10]. However, due to the stringent resource constraints at sensor nodes (e.g., limited energy, computational, storage and communication capaci-ties), traditional KNN processing techniques are infeasible for wireless sensor networks because collecting sensing data from large-scale sensor networks into centralized databases incurs high energy consumption and long latency.
To cope with the above-mentioned issues, in-network pro-cessing techniques for KNN queries have been developed [11][12][14]. In these WSN systems, a KNN query is injected to the network (usually via an access point ) and propagated to the sensor nodes qualified by specified predicates. As a result, sensor data from these nodes are collected and returned to the access point. Existing in-network KNN query processing techniques can be categorized into two types: a) infrastructure-based and b) infrastructure-free . The former relies on a network infrastructure (e.g., based on R-trees [1] or spanning trees in WSN) for query propa-gation and processing [11]. Maintenance of those network infrastructures is a major issue. In the dynamic environ-ments of wireless sensor networks, maintaining infrastruc-tures incurs excessive communications and thus energy over-head among sensor nodes. On the other hand, the latter does not rely on any pre-established network infrastructure to process queries. Recently, two infrastructure-free KNN query processing techniques have been concurrently devel-oped [12][14]. By propagating queries and collecting data along well-designed itineraries, these techniques avoid the overhead of maintaining a network infrastructure.
Obviously, the performance (such as the response latency and energy consumption) of these KNN query processing techniques is dependent on the itineraries. With a long itinerary, long processing latency and high energy consump-tion are expected due to the long journey query and data may travel. Thus, itinerary planning is a vitally impor-tant design issue for itinerary-based KNN query processing. Moreover, with different performance requirements (e.g., en-ergy efficiency and response latency) from applications, it X  X  important to design itineraries that meet specific application requirements. In this paper, we propose a new itinerary-based KNN query processing technique that derives different itineraries aiming at optimizing two performance criteria, response latency and energy consumption .

Specifically, the proposed new technique is based on opti-mized parallel concentric-circle itineraries (thus named as PCIKNN ). PCIKNN is designed to allow a KNN query propagated in multiple concurrent threads. Clearly, with a larger number of concurrent KNN threads propagated, both the response latency and the energy consumption are sig-nificantly reduced. Furthermore, analytical models for the latency and the energy consumption of PCIKNN are de-rived. By optimizing the latency latency and the energy con-sumptions, PCIKNN derive itineraries with two modes (i.e., min latency mode and min energy mode), specifically tai-lored to minimize response latency or energy consumption, respectively. Additionally, an important issue for itinerary-based KNN query processing is to estimate a search bound-ary covered by derived parallel itineraries. A technique has been developed to derive accurate boundary estimation in order to improve performance of our KNN processing. In our approach, we derive multiple itineraries to facilitate parallel processing of the query. The performance of PCIKNN is analyzed mathematically and evaluated through extensive experimentation based on simulation. Experimental results show that PCIKNN has better performance and scalability than the state-of-the-art.

The contributions of this study are summarized as follows:
The rest of the paper is organized as follows. Preliminar-ies, including the problem definition and basic ideas of ex-isting itinerary-based KNN query processing is introduced. The design of our PCIKNN technique and analytic models for two optimization modes are described in Section 3. A mechanism for KNN boundary estimation is presented in Section 4. The performance of PCIKNN and other exist-ing techniques is evaluated in Section 5. Finally, Section 6 concludes this paper.
In this section, the basic assumptions made in this re-search and the definition of KNN query are specified. Then, the general idea of itinerary-based KNN query processing is introduced. Finally, the problem addressed in this paper is presented.
 Figure 1: Overview of itinerary-based KNN query processing.
We assume that sensor nodes in wireless sensor networks are randomly distributed in a two-dimensional space. Each sensor is location-aware via GPS or other localization tech-niques. By periodically inter-exchanging information among sensor nodes nearby, a sensor node is able to maintain its own neighboring information. As mentioned before, KNN query processing provides a way to sample the data from sensor nodes located in the proximity of a given query lo-cation. We now define the KNN query in wireless sensor networks as follows: Definition : ( K N earest N eighbor query). Given a set of sensor nodes M and a geographical location (denoted as a query point q ), find a subset M  X  of k nodes ( M  X   X  M, | M  X  | = K ) such that  X  n 1  X  M  X  and  X  n 2  X  M  X  M  X  , distance function.

KNN queries can be issued at any sensor node (called source node ), which is the starting node for in-network query processing. The source node is also responsible for reporting the query result.

As mentioned before, itinerary-based KNN query process-ing techniques are infrastructure-free, thereby saving a con-siderable amount of maintenance overhead. Without loss of generality, an itinerary-based KNN query processing algo-rithm typically consists of three phases: i) routing phase; ii) KNN boundary estimation phase; and iii) query dissem-ination phase. Figure 1 shows an overview of the itinerary-based KNN query processing. Details of the three query processing phases are described below: Routing phase: Figure 1(a) illustrates the routing phase. Explicitly, when a KNN query Q is issued at a source node, the query Q that specifies the query point q and the sample size K is routed to the sensor node nearest to the query point q (referred the home node ) by using a geo-routing protocol such as GPSR [2][3]. In the routing phase, partial network information, such as the number of nodes and the area cov-ered by communication ranges of relay messages, is collected while the query is enrouting towards the home node. KNN boundary estimation phase: Upon arrival of a query at its home node, the partial network information gathered in the routing phase is used to estimate the initial KNN boundary, which is likely to contain K sensor nodes. Then the KNN query is propagated within the KNN bound-ary. The solid circle line in Figure 1(a) is the estimated KNN boundary. Note that the estimated KNN boundary could be dynamically updated (which is our approach) while the query is propagated within the KNN boundary.
 Query dissemination phase: It can be seen in Fig-ure 1(b) that, after estimating the initial KNN boundary, the home node propagates the query to each node within the KNN boundary. A KNN query is propagated along well-designed itineraries, while partial query results are aggre-gated at the same time. After reaching the end of itineraries, aggregated query results are sent back to the source node. This phase is also named as query propagation and data collection phase in this paper.
 Query propagation is a critical issue for itinerary-based KNN query processing. Therefore, in the next section, we detail the itinerary-based query propagation and data col-lection. The detailed steps of query propagation are illustrated in Figure 2(a), where the gray line is a well-designed itinerary. As shown in the figure, sensors are categorized into Q-node (marked as black nodes) and D-node (marked as gray nodes). Upon receiving a query, a Q-node broadcasts a probe mes-sage including the query Q and the itinerary information to its neighbors. Each neighbor node (i.e., D-node) receives the probe message and then sends its sensed data to the Q-node. After collecting data from D-nodes nearby, the Q-node finds the next Q-node along the itinerary and forwards the current query result to the next Q-node. The next Q-node is deter-mined by exploring the maximum progress heuristic in that the next Q-node with the farthest distance to the current Q-node along the proceeding direction of the itinerary is se-lected. The width of the itineraries w is set to  X  3 2 r , where r is the transmission radius of a sensor node, for full coverage shown in Figure 2(b). Readers are referred to [5] [13] for detailed implementation of itinerary-based query propaga-tion. Finally, the last Q-node forwards the aggregated query result to the source node where the KNN query is issued. Figure 3: Parallel concentric itineraries in PCIKNN.
Some itinerary structures such as spiral itinerary [14] and multiple itineraries [12] are proposed. As mentioned before, itinerary structures have a great impact on the performance of itinerary-based KNN query processing techniques. Long itineraries may incur long latency and heavy energy con-sumption, because the query propagation and data collec-tion are performed along the itineraries. A query may have a long journey and have to carry more collected data on long itineraries, thereby increasing both the latency and the energy consumption. In addition to the length and num-ber of itineraries, the number of concurrent KNN query threads propagated also have an impact on performance of itinerary-based KNN query processing techniques. Clearly, with a larger number of concurrent threads propagated along itineraries, the latency of KNN query processing may be im-proved. However, prior works explore multiple itineraries by fixing the number of concurrent KNN query threads to the number of itineraries. Thus, in this paper, we aim at de-signing itineraries that allow more concurrent KNN query threads to be propagated.
In this section, we first describe the design of parallel concentric-circle itineraries and give a brief comparison of concurrent threads of PCIKNN and existing works. Then, corresponding to the targeted performance criteria, i.e., re-sponse time and energy consumption, we analytically derive the number of parallel itineraries to be employed. Finally, we verify our analytical results with simulation results.
As pointed before, the number and structure of itineraries have an impact on performance of itinerary-based KNN query processing algorithms. Intuitively, a KNN query executed concurrently through a large number of itineraries will incur small latency and energy consumptions. However, in real-ity, it X  X  not feasible to use an excessive number of itineraries due to packet collisions. Here, we explore the design issue of parallel concentric-circle itineraries by assuming a bound-ary that contains K nearest sensor nodes to the query point is given. We will address the issue of estimating this KNN boundary later in Section 4.
Given a query point q and an estimated KNN boundary, the area within the boundary can be divided into multiple concentric-circle itineraries. Let C i denote the i th circle with a radius w  X  i , where w is the itinerary width , the distance between itineraries. Similar to [12][14], w can be set as where r is the transmission range of a sensor node. In order to propagate KNN query along concentric-circle itineraries, we partition the KNN boundary into multiple sectors . Fig-ure 3(a) shows an example of concentric-circle itineraries, where the number of sectors is 4. For each sector, we have three types of itinerary segments: 1) a branch-segment , 2) a set of peri-segments , and 3) return-segments . As shown in Figure 3(b), a branch segment is a straight line in each sector, peri-segments are portions of concentric-circles and the return-segments are the boundary lines among sectors. With these segments of itineraries, KNN query are concur-rently executed at these segments of itineraries. It is worth mentioning that the number of concurrent KNN query prop-agated are maximized in our PCIKNN.

In light of itinerary segments derived above, a KNN query is first propagated along with branch-segments in each sec-tor. Along the branch-segment, a Q-node broadcasts a probe message and aggregates the partial results from D-nodes within the region width of w . Then, for each sector, when the KNN query reaches one of concentric-circles, two KNN query threads are forked to propagate along the two peri-segments, while the original KNN query continues to move along the branch-segment. This process repeats at outer concentric-circles, which increases the number of the con-current threads for executing the KNN query. To prop-agate a KNN query in two peri-segments, the Q-node in the branch segment first finds two Q-nodes in peri-segments and evenly divide the partial query result collected to these two Q-nodes. Then, these two Q-nodes will start perform-ing KNN query dissemination with peri-segments. When KNN queries propagating along peri-segments arrive the boundary lines of their sectors, KNN queries with data col-lected are returned back to the home node through return-segments. Once the home node receives more KNN query results, it is able to decide whether to continue KNN query propagation or not. This leads to more precise KNN query results in PCIKNN. It can be seen by exploring parallel concentric-circles, the number of concurrent KNN query prop-agated is maximized. Furthermore, due to the high paral-lelism of PCIKNN, PCIKNN achieves high performance in terms of response time and energy consumption.
In the following, we will use an example to illustrate the la-tency and energy performances of IKNN, DIKNN and PCIKNN in terms of the number of concurrent KNN query propa-gated. Assume that the KNN boundary is known and all these algorithms are performed within this boundary. In our illustrative example, the radius R of KNN boundary is set to 4 w and there are 4 concentric-circles. First, we analyze the latency performances which is directly affected by the number of concurrent KNN query propagated. Figure 4(b) shows the parallel IKNN algorithm proposed in [14], which has two itineraries. Hence, the number of concurrent KNN query propagated is 2. For DIKNN and PCIKNN, the num-ber of sectors affects the performances directly. Assume that the number of sectors is set to 4, which is bigger than the number of itineraries in parallel IKNN. Thus, in DIKNN, the concurrent KNN query propagated is 4 (as shown in Figure 4(a)). In PCIKNN, each itinerary in the sector has a branch-segment and two peri-segments for each concentric circle for query propagation. Therefore, the maximal number of con-current KNN query propagated is 44 (branch-segment  X  1, peri-segments  X  8 and return-segment  X  2 in each sector) for 4 itineraries shown in Figure 3. Comparing these three algo-rithms, PCIKNN has the largest number of concurrent KNN query propagated. As a result, it is expected to have better latency performance than others.

Second, for the energy performance, we evaluate the av-erage length of a KNN query propagated to estimate the energy consumption. When an itinerary is longer, the en-ergy consumed for carrying data increases faster. Thus, it has lower total energy consumption and better energy performance if the average length of a KNN query prop-agated is shorter. All algorithms have the total length of concentric-circle itineraries. The total length of concentric-circle itineraries is formulated as follows: In our example, since R is set to 4 w , the total length of concentric-circles is thus determined as 16  X w (i.e., 2  X   X  w  X  (0 . 5 + 1 . 5 + 2 . 5 + 3 . 5) = 16  X w ). In parallel IKNN, the total itinerary length is the sum of concentric-circles and addi-tional branch-segments length which is 3 . 5 w in each sec-tor. Consequently, the average length of a concurrent KNN DIKNN, the total length of itineraries is the sum of the total length of concentric-circles and additional branch seg-ments (i.e., 4). Since there are four KNN query propagated, the average itinerary of each KNN query is calculated as sectors to be 4, the total length of itineraries in PCIKNN is estimated as 16  X w +12  X  3 . 5 w , which consists of concentric-lengths, branch-segments and return-segment. Explicitly, a sector has a branch-segment, two return-segments with their length as 3 . 5 w . However, though the length of itineraries is larger, the total number of concurrent KNN query prop-agated is also larger. In Figure 3(a), there are 44 KNN query propagated. As a result, the average itinerary length Among the three algorithms, PCIKNN has the smallest av-erage itinerary length for a KNN query. Thus, PCIKNN should have the best energy performance. The results are illustrated in Table 1. Table 1: Comparison of concurrent query threads and query lengths.
 Table 2: Parameters used in our analytical model.
From the above analysis, PCIKNN is able to allow as many concurrent KNN query threads as possible in itineraries derived. Thus, with a good parallelization, PCIKNN has smaller latency time and energy consumption than existing works.
PCIKNN explores parallel concentric-circles itineraries to achieve better parallelism. Thus, to determine an appropri-ate number of sectors (denoted as S ) is a critical issue. When the number of sectors is larger, the length of total itineraries will increase because the numbers of branch-segments and return-segments are also increased. However, when a smaller number of sectors is used, the length of peri-segments in each sector increases, thereby incurring more energy consump-tion for propagating KNN queries and carrying more partial KNN results. There is an obvious bound of the number of sectors that is when the length of peri-segments is zero. In this section, we derive analytical models to determine the appropriate number of sectors in accordance with the two optimization goals considered, i.e., minimum latency (re-ferred to as min latency ) and the minimum energy (referred to as min energy ).
Given a KNN boundary with radius R and network den-sity d , we intend to derive an appropriate number of sectors to meet the optimization objectives. Note that the network density is able to estimate while routing KNN query and will be described later. Assumptions made in our analysis are discussed as follows. We assume that sensor nodes are uniformly distributed and there is no void area in the mon-itored region. Message transmissions are reliable, i.e., there is no message lost. Query propagation along the branch-and return-segments are one hop for each concentric circle and each Q-node is ideally located in the itineraries. Parameters used in our analysis are summarized in Table 2
In PCIKNN, when the number of sectors is increased, peri-segment is expected to shorten, thus reducing the la-
Figure 5: Information statistics in routing path. tency. For each sector, once a KNN query arrives bound-aries among sectors, the partial results should be trans-mitted to the home nodes. With a larger number of sec-tors, network jams are likely to happen around the home node, degrading the latency of PCIKNN. Therefore, the latency time of PCIKNN mainly depends on two values: latency peri and latency home . Explicitly, latency peri is the latency of propagating KNN query in peri-segments at the farthest concentric-circle from the home node because the la-tency of query propagation along peri-segments at the inner concentric-circle is smaller. On the other hand, latency home is the time spent for processing partial results at the home node. Therefore, the latency time of PCIKNN is formulated as
To calculate latency peri , we should take into account mes-sage delays for sending probe messages and receiving D-nodes messages at each Q-node. Thus, we could have latency as follows: , where E peri hop is the expected number of Q-nodes in the peri-segment at the farthest concentric-circle and E peri D expected number of D-nodes of a Q-nodes. The expected number of D-nodes is estimated as the number of D-nodes in the gray area in Figure 5. Consequently, we have , where Er is the expected length of each hop of Q-nodes. According to [12], Er is formulated as Er = r 2
As for the latency time spent on collecting partial results at the home node, we assume that partial results are sent to the home nodes at the same time (which is the worst-case scenario). Hence, we have the following latency: According to the above derivations, the latency time for PCIKNN is able to derived as follows: latency = (  X   X  R S  X  Er  X  (1+ w  X  Er  X  d )  X  Delay )+(2  X  S  X  Delay )
In order to obtain the optimal number of sectors to achieve the minimal latency time of PCIKNN, we could differentiate the above latency formula. Therefore, the optimal number of sectors is derived as follows:
As mentioned above, a long itinerary length shall incur more energy consumption. However, the energy consump-tion of PCIKNN should consider the energy consumption on the query propagation and data collection along with branch-segments and return-segments. Explicitly, a small number of sectors leads to long itineraries in each sector, in-curring heavy energy consumption overall in carrying data collected from D-nodes. On the contrary, a large number of sectors increases the number of branch-segments and return-segments, incurring more energy consumption on query prop-agation and data collection. Thus, an optimal number of sectors can be derived to minimize the energy consumption. Generally speaking, the energy consumption of PCIKNN in-volves two parts in each itinerary segment: 1) Data collected from D-nodes should be carried hop-by-hop along with KNN query. 2) KNN query is propagated along with Q-nodes. Without loss of generality, the energy consumption is mod-eled as the communication cost in terms of the number of bits transmitted among sensor nodes. Thus, the energy con-sumption of PCIKNN is the sum of energy consumption corresponding to branch-segment, peri-segment and return-segment of all sectors. Since there are multiple concentric-circle itineraries in PCIKNN, the energy consumption on the type -segment in the i th concentric-circle itineraries is expressed by energy type,C sumption of peri-segment itineraries in the first concentric-circle is represented as energy peri,C where the number of concentric-circles is R w .
 The energy consumption is modeled as E hop  X  Bits , where E hop is the expected number of hops and Bits is the energy consumption to transmit one data bit per hop. Let E type hop,Ci denote the expected number of hops in the type-segment on Ci . For example, E branch hop,Ci is the expected number of hops in the branch-segment on Ci . Furthermore, E type D the expected number of D-nodes of a Q-node in the type -segment. For computation simplification, we simplify the radius of Ci is i  X  w . In the following, we will derive the energy consumption in each itinerary segment.

Note that the energy consumption in each segment con-sists of D-nodes data carrying energy and Q-nodes query propagation energy. For the energy consumption for the branch segment on Ci , we could have the following formula: to be connected hop-by-hop along with a branch-segment and D-nodes data collected are divided into peri-segments.
Similar, we could derive the energy consumption in the peri-segment as follows:
Since we have two return-segments in each sector, the en-ergy consumption is modeled as follows:
Putting the above formulas together, we could further uti-lize differentiation to derive the optimal number of sectors so as to minimize the energy consumption of PCIKNN. Conse-quently, the optimal number of sectors is derived as follows:
Model Validation : The simulation environment for model validation is that there are 1000 sensor nodes randomly dis-tributed in a 500  X  500 simulation field. Total 100 KNN queries are issued, where K=300. The simulation results are shown in Figure 6 and Figure 7. The minimal latency model determines S latency =6.4 rounded to 6 is equal to the experiment minimal latency with S=6. The minimal energy model derives S energy =7.1 rounded to 7 also matched the experiment result with S=7. These comparisons show that our analysis is pretty accurate. From the formulas derived, we could easily determine the number of sectors with its quality very close to the optimized objectives.
Obviously, the precision of the KNN boundary estimation has a direct impact on the performance of itinerary-based KNN query processing. In this section, we develop a mecha-nism to estimate KNN boundary. Furthermore, to increase the accuracy of KNN query, we dynamically adjust KNN boundary in PCIKNN.
Figure 8: Estimating coverage areas of routing. Figure 9: Intersection covered area with various node distances.
An over-estimated KNN boundary will lead to excessive energy consumption and long latency, whereas an under-estimated KNN boundary may reduce the accuracy of query results. Thus, boundary estimation is very critical to the success of itinerary-based KNN query processing. Here we assume that sensor nodes do not have a priori knowledge about the density and distribution of nodes in the network. To address this issue, DIKNN [12] first collect (partial) net-work information in the query routing phase to derive the network density, which in turn is used to estimate a bound-ary that are likely to contain K sensor nodes. Clearly, how to precisely determine the network density from the partial information gathered in the routing phase is important. In the following, we will describe our approach to derive the network density in the routing phase.

By using a geo-routing protocol, e.g., GPSR, KNN query is greedily forwarded from the source node to the home node. In the routing phase, network information, such as the num-ber of nodes and the coverage area shown the dotted area in Figure 8(b) along the routing path, is obtained. This in-formation (i.e., coverage area of routing and the number of nodes encountered) are gathered and sent along with KNN query. Let A i denote the area covered by relay messages up to the i th hop and N um represents the total number of nodes within the coverage area of the routing path. They are collected and updated as a KNN query moves forward hop-by-hop. Once the query reaches its home node, the col-lected information is used to estimate the network density.
Next, we demonstrate how to update these two values in the routing phase. A message relay from node N i to node N i +1 is shown in Figure 8(a), where the gray area is the newly explored area, denoted as EA i . The number of sensor nodes in EA i is denoted by inc i +1 . By adding inc i +1 to Num, one could have the most updated number of nodes encountered so far. The value of EA i is formu-lated as EA i =  X r 2  X  H (2 r  X  dist ( N i , N i +1 )), where r is the transmission radius of a sensor, H(.) is a linear func-tion and dist ( N i , N i +1 ) is the Euclidean distance between N i and N i +1 . By extensive experiments, we observed that the intersection area between two sensor nodes is almost negative correlated with dist ( N i , N i +1 ) shown in Figure 9. Thus, one cannot simply derive the intersection area of two sensor nodes as 2 r  X  dist ( N i , N i +1 ). As can be seen in Figure 9, the result of DIKNN is simply estimated the intersection area by 2 r  X  dist ( N i , N i +1 ), where r is transmission radius and is set to 40m, the same as in [12][14]. It can be seen in Figure 9, the estimation area by [12] does not have the same trend with the real intersection area. Thus, in this paper, to precisely estimate the intersection area between two sensor nodes, we explore linear regression techniques and H(.) is thus formulated as: where c 1 and c 2 are coefficients, which are determined by [4].

In fact, H function, to be empirically determined in our simulation, is used to estimate the intersection area of N and N i +1 . Hence, the total area covered by relay messages up to i th hop is as follows:
When a KNN query reaches the home node, the home node computes the network density D as D= Num A , where A is the total area covered by relay messages from the source node. As a result, the KNN boundary is estimated as fol-lows:
Although DIKNN also explores the network density to estimate the KNN boundary region, the network density derived in DIKNN is not accurate due to poor estimation of total coverage area. Specifically, the intersection area of two sensor nodes is coarsely determined. Furthermore, an additional list is used to record local information. This list, sent along with KNN query, incurs significant more energy overhead. We compare the performance of our proposed mechanism with that of DIKNN later.
The above boundary estimation is under the assumption that sensor nodes are uniformly distributed in the monitored region. However, most of real sensor networks are spatial irregularity. To deal with the spatial irregularity, we propose one mechanism in which KNN boundary is further adjusted according to the local network information within a sector. Furthermore, due to the nature of PCIKNN, the home node is able to decide whether KNN should be propagated or not. In other words, if the number of nodes in KNN query results is not larger than K, the home node will inform Q-nodes at the farthest concentric-circle to continue KNN search for one more concentric-circle. The above procedure will be
Figure 10: Updating KNN boundary dynamically. repeated until the number of sensor nodes in KNN boundary is larger or equal to K. This guarantees the query accuracy of KNN query.

After estimating the KNN boundary with radius R , KNN query is then propagated to branch-segments. The network information obtained in the routing phase (i.e., the total coverage area A and the number of nodes Num) is sent with KNN query processing. When KNN query is propagated along with the branch-segment, local network information within the segment is accumulated via the above operation in the routing phase. A B (respectively, N um B ) is the cover-age area (respectively, number of nodes) along the branch-segment. Consequently, we could derive the network density by exploring local network information. Hence, the network density is updated as follows: By exploiting local network information in each sector, PCIKNN is able to dynamically adapt KNN boundary. For example, the gray area in Figure 10 is adapted to node densi-ties in sectors. Even though this adapted boundary still can-not guarantee the accuracy of KNN query result, PCIKNN performs further processing the query results at the home node and adjusts KNN boundary as needed. Basically, the home node checks whether the KNN query is satisfied by the collected result or not. If the number of nodes within the KNN boundary is not larger than K, Q-nodes at the farthest concentric-circle will further extend one concentric -circle itinerary to search more number of nodes. We develop a simulation to evaluate the performance of PCIKNN and other closely related works, i.e., IKNN and DIKNN. The simulation model and parameter settings are presented in Section 5.1. The experimental results are re-ported in Section 5.2.
Our simulation is implemented in CSIM[8]. There are 1000 sensor nodes randomly distributed in a 500  X  500 m 2 re-gion. The transmission radius of a node is 40 m . For each sensor node, the average number of neighboring nodes is 20. The message delay for transmitting or receiving messages is
Figure 11: Query accuracy under various density. 30 ms . To simplify our experiments, we assume sensor nodes to be static. For each query, the location of a query point q is randomly selected. The value of K for each KNN query is drawn randomly. A KNN query is answered when the query result is returned to the source node. For each round of experiment, 5 queries are issued from randomly selected source nodes. Each experimental result is obtained by aver-age of twenty rounds of experiments. Three itinerary-based KNN algorithms are implemented. Algorithm IKNN [14] exploring one itinerary is adopted while Algorithm DIKNN [12] with minimum latency is utilized. For fair comparison, we derive the result of DIKNN with the minimum energy by selecting the minimum energy from all possible numbers of sectors in DIKNN. We compare three algorithms in terms of energy consumption, query latency and query accuracy under various environment factors such as the network den-sity, the number of sample size (i,e., K for KNN queries). These performance metrics are summarized as follows:
Energy Consumption (Joules): The total amount of energy consumed for processing a KNN query in a simulation run.

Query Latency (ms): The elapsed time between the time a query is issued and the time the query result is re-turned to the source node.

Query Accuracy(%): The percentage ratio of the num-ber of sensor nodes that are exactly the K nearest sensor nodes to query point q over the number of sensor nodes in KNN query results collected.
In this section, we first investigate the impact of network density on the three examined algorithms. Then, we study the scalability of these three algorithms to the value of K . Finally, we examine the accuracy of boundary estimation.
First, we investigate the impact of network density to the performance of the three examined algorithms. Here, the network density is measured as the number of sensor nodes deployed in a fixed monitored region (i.e., 500  X  500 m 2 ). We varied the number of sensor nodes from 600 to 1500. As a result, the average number of neighbors for each node is varied from 10 to 30. Figure 11 shows that all three algo-rithms have better query accuracy when the network den-sity is increased. However, when the network is sparse (i.e., the number of nodes is smaller than 800 nodes), PCIKNN
Figure 12: Query latency under various density. Figure 13: Energy consumption under various Den-sity. outperforms IKNN and DIKNN. This is because a KNN query propagating along itineraries in IKNN and DIKNN may easily get dropped. Due to the high parallelism in itineraries, PCIKNN is robust. Only a few D-nodes are lost if a KNN query is dropped. Furthermore, DIKNN utilizes the estimated KNN boundary to decide whether KNN query should be stopped or not (i.e., without dynamic adaptation like PCIKNN). Consequently, the query accuracy of DIKNN is significantly reduced. This phenomenon is worsen when the network density is low. In a fairly dense network, both IKNN and PCIKNN have better query accuracy. As can be seen in Figure 12, the latency of PCIKNN is the lowest among three algorithms, showing the strength of concur-rent KNN query propagation. The latency is lower when the number of nodes is increased for each algorithm. In the dense network, the latency of three algorithms tends to decrease. Clearly, in a dense network, KNN boundary is small, leading to a short latency. Figure 13 shows the energy consumption of three algorithms. PCIKNN has the lowest energy consumption, showing the merits of itinerary designed in PCIKNN.
Next, we investigate the impact of sample size K to scala-bility of the three algorithms. Clearly, K has a direct impact on the number of nodes involved in query processing. In this experiment, the value of K is varied from 50 to 400. The query accuracy of IKNN, DIKNN and PCIKNN is shown in Figure 14. It can be seen in Figure 14 that the query accuracy of DIKNN is significantly reduced as K increases, because the KNN query result of each itinerary in DIKNN is directly sent back to the source without further processing even though DIKNN adjusts KNN boundary and exchanges information among itineraries. On the other hand, PCIKNN and IKNN have good query accuracy under the varied K . The latency increases as K increases since more sensor nodes are discovered. As seen in Figure 15, PCIKNN has the smallest latency, validating our analytical model for mini-mum latency of PCIKNN. As seen in Figure 16, energy con-sumption of all algorithms tends to increase as K increases because the number of sensor nodes involved is increased as well. PCIKNN has the smallest energy consumption. Fur-thermore, compared with PCIKNN with the minimum la-tency mode (i.e., P CIKN N min l atency ), PCIKNN with the minimum energy (i.e., P CIKN N min e nergy ) indeed has the minimal energy consumption, showing the correctness of our optimized derivation.
To evaluate the proposed KNN boundary estimation tech-nique, we set the value of K to be 300. To avoid the ef-fect of network boundary, query points in the middle region (i.e., 100 m  X  100 m ) are selected. The liner regression func-tion of PCIKNN is set to H ( dist ( N i , N i +1 )) = (  X  76 . 9166  X  dist ( N i , N i +1 ) + 4999 . 0903) by liner regression technique in [4]. The optimal KNN boundary is the average distance of k th distant nodes of all queries derived by the experiments. As shown in Figure 17, PCIKNN is very close to the opti-mal KNN boundary under various network density. How-
Figure 16: Energy consumption under various K. Figure 17: KNN boundary estimation of DIKNN and PCIKNN. ever, the boundary estimated in DIKNN does not fit well with the trend of the optimal KNN boundary. Moreover, in Figure 17, when the number of nodes is smaller than 800, the KNN boundary estimated in DIKNN is smaller than the optimal value because the KNN boundary is large and the routing path from the source node to the home node is not long enough to estimate a region contained K sensor nodes. On the other hand, even though the routing path is long enough to estimate the KNN boundary, the result is not precise due to the inaccuracy of coverage areas in rout-ing path. Figure 17 demonstrates the correctness and the accuracy of our KNN boundary estimation. In this paper, we proposed an efficient itinerary-based KNN algorithm, PCIKNN, for KNN query processing in the sensor network. PCIKNN disseminates queries and col-lects data along pre-designed itineraries with high paral-lelism. We derived the latency and the energy consumption of PCIKNN and then by optimizing the derived formulas, we are able to determine the appropriate number of sectors for PCIKNN. Furthermore, by exploring linear regression, the KNN boundary estimated is as close as the optimal one. In addition, PCIKNN is able to dynamically adjust KNN boundary by considering local network information within sectors. Furthermore, KNN query is guaranteed to be an-swered since the home node will decide whether to further extend the boundary or not based on collected KNN query result. Extensive experiments have been conducted. Experi-mental results show that PCIKNN significantly outperforms others in terms of energy consumption, query latency and query accuracy.
 Wen-Chih Peng was supported in part by the National Sci-ence Council, Project No. NSC 95-2221-E-009-061-MY3 and by Taiwan MoE ATU Program. Wang-Chien Lee was sup-ported in part by the National Science Foundation under Grant no. IIS-0328881, IIS-0534343 and CNS-0626709. [1] A. Guttman. R-Trees: A Dynamic Index Structure for [2] B. Karp and T. H. Kung. GPSR: Greedy Perimeter [3] F. Kuhn, R. Wattenhofer, and A. Zollinger.
 [4] S. J. Leon. Linear Algebra with Applications . Prentice [5] D. Niculescu and B. Nath. Trajectory Based [6] H. Qi, X. Wang, S. Iyengar, and K. Chakrabarty. High [7] N. Roussopoulos, S. Keeley, and F. Vicent. Nearest [8] H. Schwetman. CSIM user X  X  guide (version 18) . [9] T. Seidl and H. Kriegel. Optimal Multi-Step k-Nearest [10] Z. Song and N. Roussopoulos. K -Nearest Neighbor [11] J. Winter, Y. Xu, and W. C. Lee. Energy Efficient [12] B. Wu, K. T. Chuang, C. M. Chen, and M. S. Chen. [13] J. Xu, Y. Xu, W. C. Lee, and G. Mitchell. Processing [14] Y. Xu, T. Y. Fu, W. C. Lee, and J. Winter.

