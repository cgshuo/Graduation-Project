 | H.2 [ Database Management ]: Miscellaneous Algorithms
The problem of updating XML views is more complex than in the relational scenario due to its nested hierarchic al structure. While several research projects [1, 4] began to explore this XML view updating problem, they typically provide no guarantee for avoiding view side effects. An update translatability analysis can be employed to reason about the potential view side effects before performing the update. Intuitively, such analysis could examine the ac-tual base data [2, 3]. However, as indicated by [2], this data-centric search for a translation tends to be very ex-pensive, even for relational view updates. Instead, in our HUX project, we have designed a comprehensive solution of exploring schema-knowledge to optimize this analysis.
Fig. 1(a) shows a running example of a relational database for a course registration system. A virtual XML view in Fig. 1(c) is defined by the view query in Fig. 1(b). The following examples illustrate cases of classifying update s as translatable or not translatable. Here we only use a delete primitive with the format (delete nodeID ) , where nodeID is the abbreviated identifier of the element to be deleted. For example, CI1.PS1 represents the first Professor-Student element of the first ClassInfo element.
 Example 1. Update u 1 = { delete CI1.PS1.S2 } over the XML view (Fig. 1) deletes the student  X  X ike Fisher X . We can delete Student. t 2 to achieve this without causing any view side effect. This can be concluded by looking at the schema of the view. From the view query (Fig. 1(b)), each student can only appear once in the view, namely, in the ClassInfo element that represents its course-professor-s tudent relationship. Deleting any student element in the view can always be translated as deleting the student tuple without causing any side effect. The schema knowledge is suffi-cient to decide if an update is translatable .
 Example 2. Consider the update u 2 = { delete CI1.C1 } . The appearance of the view element CI1.C1 is determined by two tuples: Professor. t 1 and Course. t 1 . There are three choices for achieving this update: T 1 = { delete Professor. t T = { delete Course. t 1 } and T 3 = { delete Professor. t 1 Course. t 1 } . All of three translations would cause a view side effect, namely, the whole ClassInfo element would disappear . This conclusion again can be made based on schema knowl-edge. From the view query, we see that any ClassInfo ele-ment must always have a pair of Professor and Course sub-elements. Deleting the course element would break this join condition and thus make the whole ClassInfo element disap-pear. The schema knowledge is sufficient to classify the update as untranslatable .

Example 3. For update u 3 = { delete CI1 } , it is easy to see that T 1 = { delete Course. t 1 } will achieve the update with-out causing any view side effect for the same reason as Ex-ample 1. On other hand, T 2 = { delete Professor. t 1 } will cause a side effect since CI2 would disappear. For update u 4 = { delete CI3 } , we find that T  X  1 = { delete Course. t 3 translation for the same reason as Example 1. T  X  2 = { delete Professor. t 2 } is a correct translation since CI3 is the only class Prof. Tim Merrett teaches. The difference here indi-cates that the schema knowledge itself is not sufficient for deciding translatability. The translatability depends on the actual base data.
As we can see from the above examples, not only view updates can happen anywhere along the view hierarchy, but also side effects can appear anywhere in the view. The XML view side effect checking is thus more complex than in the relational case. A view update can be classified as translat-able or untranslatable using either schema or data knowl-edge. In this paper, we aim to support updates of XML views by (i) extending the relational view update solution and (ii) utilizing schema knowledge as much as possible. For this, we propose our schema-centric XML view updat-ing system named HUX (Handling Updates in XML).
 HUX bridges the XML and relational view update problem. One direction for handling updates over XML views may be to  X  X onvert X  the XML view update problem to the equivalent relational view update problem (if possi-ble). For this purpose, let us follow the approach from the literatur (SilkRoute and [1]) and treat the XML view as a  X  X omposition X  of a set of relational views. Here, each node in the schema graph of the view (Fig. 2) can be consid-ered as generated by a relational view, with an associated SQL query. The set of instances of a schema node is there-fore given by this SQL query. Intuitively, an update over a schema node can be treated as an update over its relational mapping view. This can then be handled as relational view update problem. However, such a simple transformation be-tween the two problems is not sufficient. The relationship between a parent SQL view and its children SQL views is critical in the XML view scenario for side effect-free check-ing. For instance, in Example 1, when deleting an element of S -node we also need to check for side effects on elements of CI node. This side effect is implied by the relationship between the relational views of S and CI nodes. The rela-tionship between the parent SQL view and the child SQL view is explicitly defined by the join constraints specified i n the view query (typically, this join is specified in terms of foreign key constraints). Secondly, the relationship is al so restricted by the update behavior. We will assume the most commonly used update behavior: deleting an element in the XML view should also delete all its children elements. HUX is a schema-centric solution. Fig. 3 shows the HUX framework. The Schema-driven TranslAtability Reasoning (STAR) process first filters out all untranslat-able updates and classifies some updates as definitely trans-latable based purely on the schema. For updates that cannot be classified by the STAR process, the Schema-directed Data Checking (SDC) process examines a subspace of the data (guided by the schema knowledge) to definitely decide whether the update is or is not translatable. Untranslat-able updates are directly rejected. Updates, that success-fully pass the STAR or SDC process, are forwarded to the SQL Update Generator to produce the correct SQL update statements to be executed over the underlying relational database. HUX guarantees that the generated SQL updates are view side effect-free. Requiring no extra side effect chec k-ing or roll back results in a major performance benefit. In our example, during the schema level check, update u 1 is classified as translatable. We translate this update by dele t-ing the corresponding tuple in the Student relation. Update u 2 will be found to be untranslatable by the schema-level check. Updates u 3 and u 4 cannot be classified as translat-able or untranslatable by the schema-level check. Therefor e we proceed to the data-level check, where we find that u 3 and u 4 are both translatable, and the respective candidate translations are suggested.
We propose the first pure data-driven strategy for XML view updating, which guarantees that all updates are fully classified. We propose a schema-driven update translata-bility reasoning strategy, which uses schema knowledge to efficiently filter out untranslatable and identify translata ble updates when possible. We then design an interleaved strat-egy that combines both schema and data knowledge into one update algorithm to perform a complete classification for XML view updates. We have implemented algorithms and optimization techniques in HUX (Details and proofs in [5]).
