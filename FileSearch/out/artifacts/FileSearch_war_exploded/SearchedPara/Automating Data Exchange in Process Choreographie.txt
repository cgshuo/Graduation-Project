 In daily business, organizations interact with each other, e.g., concluding contracts or exchanging information. Fig. 1 describes an interaction between a customer and a supplier with respect to a request for a quote. The customer sends the request to a chosen supplier which internally processes it and sends the resulting quote as response which then is handled internally by the customer. An interaction between business processes of multiple organizations via message exchange is called process choreography [32]. The industry standard BPMN (Business Process Modeling and Notation) [20] provides the following concepts to model process choreographies. A choreography diagram describes the order of message exchanges between multiple participants from a global view, called global choreography model . The message exchanges are then refined into send and receive ac-tivities distributed over the different par ticipants. This can be captured in collaboration diagrams describing how each participant X  X  public process interacts with other partic-ipants [2], also called local choreography model . Deriving a local choreography from a global one is a non-trivial step; various techniques are required [7] including locally enforcing the order of globally specified message exchanges.

Typically, these two choreography models are used to globally agree on a contract about the messages exchanged and their order. In above example, both participants agreed that first the customer may send a re quest to the supplier which is then answered with a quote by the supplier. Based on the agr eement, each participan t has to implement its public process as a private process describing the executa ble part of this participant including the interactions with other participants as described in the choreography; this private process is called a process orchestration [13]. Existing approaches for deriving an orchestration for each participant from a choreography, such as the Public-to-Private approach [2], only cover the control-flow perspective of the contract: ensuring the cor-rect order of messages. In the following, we address the correct contents of messages to achieve a correct data exchange that realizes the choreography.

Generally, organizations store their data in local databases that other choreography participants cannot access. These databases follow local data schemes which differ among the organizations. However, the interacting organizations want to exchange data and therefore have to provide the information to be sent in a format which is understood at the receiving side. Thus, an agreed exchange message format has to be part of the global contract mentioned above. For a successful process choreography, it has to be ensured that messages to be sent are provided correctly and that received messages are processed correctly based on the global contract . In more detail, three challenges arise: C1 X  X ata Heterogeneity. Interacting participants, such as our customer and supplier, each implement their own data schema for ha ndling their private data. For sending a message to another participant, this local data has to be transformed into a message the recipient can understand. In turn, the received message has to be transformed into the local data schema to allow storing and processing by the recipient.
 C2 X  X orrelation. A participant may run multiple instances simultaneously. Therefore, messages arriving at the receiver side need to be correlated to the correct process in-stance to allow successful interaction.
 C3 X 1:n Communication. In choreographies, there may be multiple participants of the same type, e.g., multiple suppliers, a customer sends a request for quote to. Thus, individual processes need to communicate with a multitude of (external) uniform par-ticipants.
 Current choreography mode ling languages such as BPMN do not provide concepts to solve C1-C3. Instead, each participant ma nually implements message creation and pro-cessing for their private process, which is e rror-prone, hard to maintain, and easily re-sults in incompatibilities to other participants in the choreography.

In this paper, we describe a model-driven approach to automate the data exchange from process choreography models while maintaining existing control flow aspects to realize process choreographies. We utilize the industry standard BPMN and extend its choreography modeling by few but essential concepts for the data exchange. We de-scribe a modeling guideline that shows how to utilize the new concepts for specifying details required to automate data exchange of a private orchestration model that is con-sistent to a public choreography model (the c ontract). We introduce operational seman-tics for the new modeling concepts which makes the orchestration models executable, and thus allows running the entire choreography purely model-based.

Thereby, we assume correctness of modeled choreographies, i.e., realizability [7], and correctness of data flow within each privat e process orchestration model, i.e., object life cycle conformance [14]. Further, we assume that all partners agreeing on the global contract, i.e., the structure of data objects, have the same understanding of the object X  X  content, i.e., agree upon the co-domain for all data attributes. Following, no abnormal behavior of data exchanges and their control flow can occur.

The remainder of this paper is structured as follows. Section 2 discusses the require-ments derived from above challenges. Subsequently, we explain the modeling guideline in Section 3 followed by the operational semantics allowing to execute the modeled choreographies directly from process model information in Section 4. In Section 5, we discuss our implementation and its feasibility for implementing all service interaction patterns purely model-based [3]. Section 6 is devoted to related work and Section 7 concludes the paper. The challenges C1-C3 described above give rise to specific requirements for automat-ing data exchange in process choreography modeling and execution. We discuss these requirements and their possible realization in the following.
 R1 X  X ontent of Message. Messages contain data of different types exchanged between participants. The involved participants have to commonly agree on the types of data and their format they want to exchange.
 R2 X  X ocal Storage. The participants create and pro cess data used for communication with other participants in their private processes. This needs to be stored and made avail-able in their local databases.
 R3 X  X essage Provision. As the data provided in a message is local to the sender, the data must be adapted to the agreed format su ch that the recipient can interpret the mes-sage content.
 R4 X  X essage Routing. Multiple parties may wait for a message at a certain point in time. This requires to route the message to the correct recipient.
 R5 X  X essage Correlation. After being received by a par ticipant, the message needs to be correlated to the activity instance whic h is capable to process the message content. R6 X  X essage Processing. Activities receiving messages have to extract data from the message and to transform it into the local data format usable within their processes.
Requirements R1, R2, R3, and R6 are basic features to realize C1; R4 and R5 origi-nate in C3; and R5 also addresses C2.

Languages such as WSDL [27] use data modeling to specify message formats; we adopt these ideas to address R1. Requirements R2, R3, and R6 concern the processing of data in an orchestration. The approach in [16] allows to model and enact data depen-dencies in BPMN processes for create, read, update, and delete operations on multiple data objects  X  even in case of complex object relationships. For this, annotations on BPMN data objects are automatically transformed into SQL queries (R2). Further, data querying languages such as XQuery [30] allo w to implement data transformations be-tween a message and a local data model. In the following, we combine these approaches to specify message extraction (R3) and message storage (R6) in a purely model-based fashion. Languages such as BPEL [19] and BPMN [20] correlate a message to a pro-cess instances based on key attributes in the message; we adopt this idea to address R5. The next sections describe how to model process choreographies including details re-quired to automate the data exchange so that data stored locally at the sender X  X  side can be transmitted and stored in the receiver X  X  local data model consistent with the global contract.

Requirement R4, the actual t ransmission of messages from sender to receiver, is abstracted from in choreography and process models and also not discussed in this paper. One can use standard technologies such as middleware or web services to realize the communication between the p rocess engines of participants. This section introduces a few concepts that allow implementing the automatic data ex-change of a process choreography in an entirely model-based approach. We present these concepts embedded in a modeling guideline for devising private orchestration models consistent to a public choreography model; Section 4 presents the execution semantics for our choreography models.

Figure 2 illustrates our modeling guideline which has a global level , where the pub-lic contract is defined, and a local level , where the local process implementations can be found. We assume that the choreography partners have already specified a collabora-tion diagram that shows how each participan t X  X  public process int eracts with the other participants and ensures local enforceability of control-flow [2]; see Fig. 2 (top). To support data exchange between participants, we propose that this public contract is sup-plemented with a global data model in which th e partners specify the business objects to be exchanged; see Fig. 2 (top middle). Next, we follow and extend the P2P approach [2] to move from the global to the local level: each pa rticipant separatel y defines a local data model and a schema mapping between their local and the global data model and imple-ments the private process conforming to their public process in the global collaboration diagram. Next, we describe the details of the global contract followed by the local level both along our modeling guideline.
 On the global level, all choreography parties together define the following artifacts: Global collaboration diagram: The global collaboration diagram describes the control flow layer of the choreography, i.e., it desc ribes which messages are exchanged in which order on a conceptual level. Exemplary, th e left part of Fig. 3 shows the collaboration diagram of the Request for quote choreography sketched in the introduction. It includes public processes with all necessary send and r eceive tasks for each participant, the cus-tomer and the supplier.
 Global data model: Messages are used to exchange data. In choreography modeling languages such as WS-CDL [10] or BPEL4Chor [6], the data carried by a message is described technically by attribute nam es and data types for each message individ-ually [27]. Instead, we propose that the interacting parties first agree on data objects they want to share and document this in a global data model, for instance using XSD ( http://www.w3.org/standards/xml/schema ). In our example, customer and supplier have agreed on three data objects, Global Request , Global Quote ,and Global Articles , as shown in the upper part of Fig.5. Each object has a unique identifier attribute (e.g., r id for Global Request ) and some have a foreign key attribute (e.g., r id for Global Quote ) to express relationships.
 Message Definition: Then, message types are specified by referring to business objects defined in the global data model. We assume that each message carries exactly one global data object; nested objects allow placi ng complex data object hierarchies within one message. Further, we adopt key-based correlation [19, 20] for messages: each mes-sage contains a set of key/value pairs that allow identifying the correct process instance on the receiver side; each key is an attribute of some data object in the global data model. For example, Request Message of Fig. 3 (left) refers to the Global Request object and Quote Message refers to Global Quote which has multiple Global Article objects. A Quote Message will contain a Global Quote object and all its Global Article objects. Both messages use attribute r id of Global Request as correlation key.
Altogether, a message is declared as tuple m =( name, CI, d ) , where name is the message type, the correlation information CI  X  K  X  V is a set of key/value pairs, and d is the actual data object in the message. To model this tuple, BPMN must be extended as shown in the UML class in Fig. 3. Originally, a mes-sage contains a string identifying its name, i.e., message type. We add correlation information as a list of strings, each denoting one key/value pair, and the payload as data object.

Then, each participant loca lly creates the following artifacts based on the global contract: Local Data Model: Each participant defines a local data model which de-scribes the classes of data objects handled by the private process. For example, the local data model of the Customer has four classes Re-quest , Quote , Quote Details ,and Quote Item ; see Fig. 5 (bottom).
 We propose to also use the local data model to design the schema for the database where the objects are stored and accessed during the pro-cess execution. There are some requirements to the local data model wrt. the global data model as described next.
 Schema Mapping: A schema mapping defines how attributes of local classes map to at-tributes of global classes, and allows to automate a data transformation between global objects contained in messages and local objects. For this paper, we consider an attribute-to-attribute schema mapping which inject ively maps each attribute of a global object to an attribute of a local object as shown in Fig. 5. Note that the attributes of object Global Quote are distributed over objects Quote and Quote Details . The local imple-mentation can hide private data in a local attribute by not mapping it to a global attribute (the mapping is not bijective), e.g., the state attributes of each local class. Local data model and schema mapping must ensure that primary and foreign keys are managed locally to avoid data inconsistency: when a local object can be created from a received global object, key attributes of the global object must map to non-key attributes of the local objects. For example, the local Quote shall be created from a Global Quote ob-ject, thus Quote gets the attributes g q id and g r id to store the primary key q id and the foreign key r id of Global Quote for local use. Typically, these keys are used for correlation.
 Executable private process: Based on the global collaboration diagram, each partici-pant designs their private process by enriching their public process with activities that are not publicly visible. In addition, each process (and each subprocess) gets assigned a case object ; instantiating the process also cr eates a new instance of this case object that uses as primary key value the process instance id [16]. Fig. 3 (right) shows the pri-vate process model of the customer. First, activity Create request creates and prepares a new instance of case object Request (see  X  X O X  in the top left corner of the process). The schema mapping defines which local data objects are required to derive the pay-load d and the correlation information CI for a message to be sent; this is included in the process model by associating the required data objects as input to the send task. In our example in Fig.3, activity Send request creates a Request Message containing a Global Request . The respecting local Request object is associated to Send request as input. Correspondingly, we associate the local data objects into which the payload of a received message is transformed as output objects of a receive task. The last activ-ity modeled in the customer process receives the Quote Message . The payload of this message is transformed into data objects Quote , Quote Details , and the multi-instance data object Quote Item all being associated as output to the receive task. The process designer has to specify whether the receive task creates new or updates existing data objects. We use the data annotations described in [16] to express operations and depen-dencies of local objects. In the given example, the message payload is used to create new data objects only as indicated by the identifier new in the upper part of each ob-ject. Local data schema, schema mapping, and private process together define the local choreography of the participant.

Fig.6 shows the private process model and the local data model of the second partic-ipant  X  the Supplier . Here, each attribute of a local class directly maps to a correspond-ing attribute with an equivalent name in the corresponding global class. For instance, attribute price of class Global Article maps to to attribute articlePrice of class Article , attribute r id of class Global Request maps to attribute g r id of class Request ,andso on. The private process has three activities: After receiving the Global Request ,whichis stored as Request object in state received , the supplier processes the request and creates the Quote . Sending the Global Quote message requires data objects Quote and Article to set the payload and Request to set the correlation identifier Global Request.r id .
This modeling guideline proposes a logical order in which the artifacts should be created based on dependencies between th em. However, situations may arise where a different order (or iterations) are required. In any case, by refining the public process into a private one and by defining local data model and schema mapping as described, a process modeler always obtains a local choreography that is consistent with the global contract. In the next section, we show how to make the local choreography executable, thus achieving a correct implementation by design. As discussed by the requirements of Sectio n 2, exchanging a message requires the fol-lowing 7 steps that we illustrate in Fig. 7 for the supplier sending a quote to the customer: (1) The required data objects are retrieved from the supplier X  X  database (satisfying R2 of Section 2) and (2) transformed to the message (satisfying R1 &amp; R3), which is (3) sent from the supplier and (4) received at the customer X  X  side (satisfying R4). The received message is then (5) correlated to the corresponding activity instance (satisfying R5), where the message (6) gets transformed into data objects (satisfying R1 &amp; R6) which are then (7) stored in the customer X  X  database (satisfying R2 again).

We now present the operational semantics for the modeling concepts of Section 3 that automatically enact th ese steps from the local process model only. We first con-sider sending and receiving messages in Secti ons 4.1 and 4.2, respectively, followed by correlation handling in Section 4.3. 4.1 Send According to the BPMN specification [20], each activity goes through various life cycle states including inactive , ready , active , completing ,and completed in this order. Upon process instantiation, all activities are in state inactive and await enablement (state ready ) taking place if the control fl ow proceeds to this activity and its input data is available.

Sending a message first requires all specified input data objects to be available to activate the send task. By Section 3, each send task has all required data ob-jects as input data and availability can be checked via an automatically generated SQL query [16]. For example, activity Send quote requires data object Quote in state created with primary key q id and foreign key r id pointing to object Request ;the corresponding guard is (SELECT COUNT (q id) FROM Quote WHERE r id = $ID AND state = created)  X  1 . This SQL query returns the number of Quote entries in the local database that are in state  X  X reated X  and related via foreign key r id to the case object instance Request of the current process instance (identified by $ID ); there has to be at least one [16]. For example, consider the database extract of Fig. 8a that shows four entries in the Request , Quote ,and Article tables. If the cur-rent process instance has $ID=6 , then executing the SQL query returns 1, i.e., the required Quote is available. Availability is checked in this way for all input data objects.
If all input objects are available, the send task retrieves the data objects from the lo-cal database (step 1) and transforms them into the actual message (step 2). For retrieval, we adapt the SQL statements of [16] by replacing  X  SELECT COUNT ...  X  1  X  with  X  SELECT *  X . For example, object Quote is retrieved by SELECT * FROM Quote WHERE r id = $ID AND state = created . All specified input objects are re-trieved in this way. Then the global object and the correlation information of the mes-sage are obtained through the specified schema mapping. In our example, we retrieve all objects of Fig. 8a. From these, object Quote and its contained objects Article are transformed into object Global Quote and corresponding Global Article s. This yields the global objects of Fig. 8b, note the two Global Article s with foreign key q id = 30 to the Global Quote . After transformation, all three global objects are added to the payload of the message to be sent by the corresponding sent task. The correlation in-formation Global Request.r id = 21 is taken from attribute g r id of the local object Request as specified in Fig. 5. After completin g the message creation and adding the correlation identifier, the state of the send task changes from ready to active .Thework now performed by a send task is to initiate the actual sending of the prepared message shown in Fig. 8b. 4.2 Receive After a received message has been correlated to the corresponding instance (see Sec-tion 4.3) it can be processed by basically reversing the two steps for sending a message. First, the objects in the message are transformed into the local data model (step 6 in Fig. 7) followed by storing them in the local database (step 7). A receive task can only receive a message when it is in state active ; when it received the message it changes to state completing . In this activity state, the transformation and storage steps take place.
In our example, the received message of Fig. 8b is transformed via the schema map-ping of Fig. 5: Global Quote and its contained Global Article s are mapped to a Quote , Quote Details , and multiple Quote Items as shown in Fig. 8c. Note that attributes in bold are private attributes that are not defined by the schema mapping (consider them empty for now). For instance, the local object Quote gets attributes g r id =30and g q id = 21 while attributes state , r id ,and q id (in bold) are only set in the last step after all objects have been transformed.

The last step persists the transformed data objects in the local database based on the annotated output data objects of the receive task. For this, we use the ap-proach of [16] for automatically deriving SQL queries for creating or updating objects. In our example, all output objects of Receive quote are annotated with [new] , i.e., are newly created. The original approach of [16] only considers the annotations for primary key, foreign key, and state to generate the SQL query which would yield the query INSERT INTO Quote (q id, r id, state) VALUES (DEFAULT, $ID, received) for data object Quote ( $ID identifies the current process instance). In this paper, we extend the query to include the information of the local data objects ext racted from the received message. The complete query for the Quote object looks as follows: INSERT INTO Quote (q id, r id, state, g r id, g q id) VALUES (DEFAULT, $ID, received, 21, 30) . For the multi-instance data object Quote Item , we generate two queries, one for each extracted local data object.

Fig. 8c visualizes the customer database a fter inserting all data objects extracted from the received message (for instance $ID =21). In this step, data objects have to be persisted in the right order to ensure the validity of key relations. In our example, the Quote object has to be stored first to ensure that the foreign key value for object Quote Details is known. This requires that key relati onships do not form a cycle. Technically, we traverse the graph of dependencies between data objects starting at the root, e.g., first object Quote , then object Quote Details , and finally both Quote Item objects are inserted. When the graph is completely t raversed, the receive task reaches the completed state.
 Objects without annotation [new] are updated which happens analogously [15]. While the order of object processing is not important for updates, updates cannot be ap-plied to data collections, i.e., multi-instance objects, because the objects in the message may be different from the objects stored locally. Assigning explicit global ids would solve this issue, but is out of scope for this paper. We also allow combinations of inserts and updates for one receive task, if the limita tions of both operations are considered, i.e., insertion order for newly created objects and no update on data collections. 4.3 Correlation Before a message can be handled, it has to be assigned to its receiving instance which is also known as correlation handling . The standard approach is key-based correla-tion [19, 20], where some attributes of the data model are designed as correlation keys . An incoming message is correlated to a process instance when both store the same value for all correlation keys in the message ; any two instances must be distinct on their corre-lation values. We first consider the case when an instance has all keys initialized already and then discuss how to initialize a key.
 All keys initialized. Our approach refines key-based correlation by making correlation keys part of the global data model. On the one hand, each message m =( name, CI, d ) explicitly defines a number of correlations keys CI , where each key d 2 . a  X  CI points to some attribute a of some global data object d 2 (not necessarily d ). For example, the message of Fig. 8b has the correlation key Global Request . r id while its payload is of type Global Quote (as specified in Fig. 3). On the oth er hand, each participant defines a local data model, where each correlation key attribute d 2 . a of m is mapped to a local attribute f ( d 2 . a )= d 2 . b of some local data object d 2 . Each process instance $ID has its own case object instance and related object instances; message m correlates to $ID when the value of each d 2 . a  X  CI matches the value of the corresponding f ( d 2 . a ) of some data object related to instance $ID . For example, the Customer maps Global Request . r id to Request . r id (see Fig. 5). Thus, the message of Fig. 8b can be correlated to a process instance where the case object has Request . r id =21 . Formally, the correlation information of a message m =( name, CI, d ) is a set CI = { ( k 1 ,v 1 ) ,..., ( k n ,v n ) } of key/value pairs, where each key k i = d i .a i is an attribute a i of a global data object d i . A participant X  X  schema mapping f maps each key to a local attribute f ( d i .a i )= d i .a i .The value of the correlation attribute d i .a i can be extracted with respect to the case object c of the receiving instance $ID as follows. Object d i relates to c via foreign key relations. Thus, we can build an SQL query joining the tables that store d i and c , select only the entries where the primary key of c equals the results of this query. By ensuring that in the local data model the relations from c to d are only 1:1, the extracted value e ( d i .a i ,c, $ID )= v is uniquely defined. Now, m correlates to an instance $ID of a process with case object c iff for each ( k i ,v i )  X  CI holds e ( f ( k i ) ,c, $ ID )= v i . This definition can be refined to not only consider the case object of the entire process, but also the case object and instance id of the scope that encloses the active task that can receive m .
 Initializing correlation keys. When sending a message m , then its correlation keys are automatically initialized by extracting for each global correlation attribute k i the corre-sponding value e ( f ( k i ) ,c, $ ID )= v i from the sender X  X  local data model. Technically, this can be done in the same way as extracting the payload of m , see Section 4.1. From this point on, all process instances receiving a message with correlation key k i have to agree on the value v i . The only exception is when e ( f ( k i ) ,c, $ ID )=  X  is still unde-fined at the receiving instance. By initializing the local attribute f ( k i ) to value v i ,we can make $ID a matching instance for m . Thus, we generalize the above condition: m correlates to an instance $ID of a process with case object c iff for each ( k i ,v i )  X  CI key attribute f ( k i ) can be initialized for $ID to value v i by generating an SQL update statement as discussed in Section 4.2.
 We implemented our approach by extending the camunda Modeler , a modeling tool sup-porting BPMN, and the camunda BPM Platform , a process engine for BPMN process models. The modeling tool was extended with the annotations for messages and data ob-jects described in Section 3; message type s of the global data model are specified in XSD and a simple editor allows to create an attribute-wise schema mapping from the global to the local data model. Once a private choreography model has been completed, the user can automatically generate XQuery expressions (http://www.w3.org/TR/xquery/) at the send and receive tasks to transform between local and global data model (Sec-tion 4). The engine was extended with a me ssaging endpoint for s ending and receiving messages in XML format to correlate messages, to read and write local data objects by generating SQL queries from process models, and to process messages as described in Section 4. As the concepts in this paper, also our implementation does not address R4 (message routing); in particular if the receiving task is not in state active to receive the incoming message, the message will be discarded. Making the process layer compatible with error handling of the message transport layer is beyond the scope of this paper.
To demonstrate the feasibility of our approach, we implemented the service interac-tion patterns [3] which capture basic forms of message-based interaction. For the sake of brevity, we explain the central challenges and how they were solved in our approach; see [15] for details of our solutions. (A) Single transmission, bilateral. Two participants A and B each send/receive one mes-sage; patterns (P1:send) ,( P2:receive ), and ( P3:send/receive ) are affected. The chal-lenges are to (1) generate and send a message, (2) to correlate a message based on an initialized or uninitialized key, and (3) to process a received message. Our running example in Fig. 3 shows how these challenges are solved. (B) Single transmission, multilateral. Participant A sends/receives one message from multiple participants B1, B 2, ..., each. The challenge in (P4.racing incoming message) is to receive only one message and discard oth ers (solved by enabling the receive task only once). The challenge in (P5.one-to-many send) is to generate multiple messages with different correlation information for di fferent recipients (solved by placing a send task in a multi-instance subprocess  X  each in stance provides a unique id that is used as correlation identifier). The challenge in (P6.one-from-many receive) is to correlate mul-tiple incoming messages (solved by using the same correlation key in all messages  X  the first message initializes the key and all subsequent messages are correlated accordingly). Pattern (P7.one-to-many send/receive) combines patterns P5 and P6  X  its challenges are solved by combining solutions for P5 and P6. (C) Multi-transmission interaction. Participant A directly exchanges multiple messages with one or more participants B1, B2, ... The challenge in (P8.multi-response) is to re-ceive multiple replies for one request until a  X  X top X  condition holds (solved by using the same correlation key in request and replies, the stop condition is limited to timeouts and  X  X inalizing X  message types). The challenge in (P9.contingent request) is to resend a request to a different recipient after no reply to a first request was received (solved by placing send/receive tasks in an iterative subprocess that produces a new correlation identifier in each iteration, and timer events to trigger a new iteration). The challenge in (P10.atomic multicast) is to send a cancellation message to n recipients when less than m out of n recipients responded to a request (partially solved by placing send/re-ceive tasks within a multi-instance subprocess with timeout gateways  X  the m out of n condition has to be defined manually). (D) Routing. Participant B forwards messages from A to further participants C, D, ... which then send a reply to A directly. The challenge in (P12.relayed request) is to for-ward a correlation key of A to a participant C that can use the key in a reply to A (solved by making the correlation key part of the messages routed to C and by ensuring that each participant on the way can map the key to its local data model). The challenge in (P13.dynamic routing) is to forward a message to C or D based on the contents of a message sent by A (solved by using the attribute pattern A2 of [17] on an exclusive gate-way that chooses between sending to C or sending to D). The challenge in (P11.request w/ referral) is to forward a message from A to some participant X whose URL is de-fined in the message (partially solved by defining the endpoint URL of X through a variable, the assignment to that variable from the contents of the message has to be defined manually).

Our implementation and the implemented patterns are available at http://bpt.hpi.uni-potsdam.de/Public/BPMNData . While briefly discussing approaches being related to the presented concepts, we focus on the communication between distributed p artners, the transformation of data, and message correlation. The service interaction patterns discussed in [3] describe a set of recurrent process choreography scenarios occurring in industry. Thus, they are a major source to validate choreography support of a modeling language. Besides BPMN [20] as used in this paper as basis, there exist multiple solutions to cope with process chore-ographies. Most prominent are BPMN4Chor [5], Let X  X  Dance [35], BPEL4Chor [6], and WS-CDL [29]. From these, only BPEL4Chor and WS-CDL realize operational semantics to handle message exchange by reusing respectively adapting the concepts defined in BPEL [19]. Though, message transfor mation to achieve interoperability be-tween multiple particip ants is done with imperative constructs, i.e., the process engineer has to manually write these transformations and has to ensure their correctness. Addi-tionally, BPEL4Chor and WS-CDL are not model-driven as the approach introduced in this paper.

Apart from process and service domains, dis tributed systems [24] describe the com-munication between IT systems via pre-sp ecified interfaces similar to the global con-tract discussed in this paper. Usually, the corresponding data management is done by distributed databases [21] and their enhancements to data integration systems [12, 25] as well as parallel database systems [8] or is done by peer-to-peer systems [9, 26]. The database solution allows many participants to share data by working with a global schema which hides the local databases, but unlike our approach, the participants work on the same database or some replication of it. Peer-to-peer systems take the database systems to a decentralized level and incl ude mechanisms to deal with very dynamic situations as participants change rapidly. In process choreographies, the participants are known and predefined such that a centralized solution as presented in this paper saves overhead as, in the worst case, the decentralized approach requires a schema mapping for each communication between two particip ants instead of only one mapping per par-ticipant to the global schema. The transform ation of data between two participants can be achieved via schema mapping and matching [22,23], a mediator [33], an adapter [34], or ontology-based integration [4,18,31]. For instance, [4] utilizes OWL [28] ontologies, which are similar to our global data model, and mappings from port types to attributes via XPath expressions to transform data between web services. In this paper, we utilize schema matching due to the close integration of database support for data persistence.
Returning to the process domain, there exist fundamental works describing the im-plementation of process choreographies [1, 7] with [1] ensuring correctness for inter-process communication. These works only describe the control flow side although the data part is equally important as messages c ontain the actual artifacts exchanged. [11] introduces a data-aware collaboration appro ach including formal correctness criteria. They define the data exchange using data-aware interaction nets, a proprietary notation, instead of a widely accepted one as BPMN, t he industry standard for process modeling, used as basis in this paper. We presented an approach allowing to model and automate the data exchange of pro-cess choreographies entirely model-driven . Thereby, we utilized the industry standard BPMN and extended the model-driven data dependency enactment approach catered for process orchestrations with concepts for process choreographies. Based on challenges of data heterogeneity, correlation, and 1:n communication, we identified a set of six requirements covering the retrieval of data from the sender X  X  local database, the data transformation into a global data schema all participants agreed upon, the correlation of a message to the correct activity instance, the transformation from the global to the receiver X  X  local database schema, and the s torage of the data there. The message rout-ing between participants is out of scope of this paper by adapting existing technologies as, for instance, web services. In this pap er, we describe a modeling guideline with the artifacts required to automatically execute the mentioned steps from these only. Further-more, we describe the corresponding operational semantics and provide details about our implementation. Our approach has been implemented; we could implement all ser-vice interaction patterns of [3] except f or dynamically setting URLs of recipients and evaluating data conditions over aggregations of data objects; both are outside the scope of this paper and deserve future work. Also the integration of process layer and mes-sage transport layer (in particular wrt. handling message transport errors) is outside the scope of this paper. The current approach only utilizes tasks to send and receive mes-sages. However, BPMN also supports message events to which the discussed concepts could be applied as well by overcoming BPMN X  X  limitation that events cannot trans-form and correlate data objects. In future work, we plan to provide an integrated formal verification technique for model-driven data enactment in process orchestrations and choreographies.
