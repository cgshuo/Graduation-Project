 In outsourced spatial databases, the LBS provi des query services to the clients on behalf of data owners (e.g., government land surv ey department or non-profit organizations) for better service quality and lower cost. However, such an outsourcing model brings great challenges to query integrity. Since the LBS server is not the real owner of data, it may return incorrect or incomplete query results intentionally or unintentionally. Thus, there is a need for the clients to authenticate the soundness and completeness of query results, where soundness means that the original data is not modified by the LBS server and completeness means that no valid result is missing. This problem is known as au-thenticated query processing in the literature [3, 6, 7, 10 X 13, 17, 18].

A typical framework of authenticated query processing is shown in Fig. 1. The data owner (DO) builds an authenticated data structure (ADS) for the spatial dataset before outsourcing it to the LBS. To support efficient query processing, the ADS is often a tree-like index structure, whose root is signed by the DO using her private key. In addition to the spatial dataset, the DO transfers the ADS and its root signature to the LBS server. Upon receiving a query from the client, the LBS server returns the query results, the root signature, and a verification object (VO) that is constructed from the ADS. The correctness of the query results can be verified by the client using the VO, the root signature, and the DO X  X  public key.

Authenticated processing of location-based queries is a hot topic in the database area [16, 18, 19]. Nevertheless, most of the existing studies focused on spatial-only queries, including range queries [3,16], nearest-neighbor (NN) queries [19], and shortest-path queries [18]. These queries are not sufficient to support LBS applications that need to consider both spatial and non-spatial attributes of queried objects. A typical scenario is finding nearby car parks with cheap parking fees, where the distance is a spatial attribute and the parking fee is a non-spatia l attribute. To deal with this kind of multi-criterion search, location-based skyline que ries (LSQs) have received considerable at-tention in LBS research (e.g., [4, 9, 15, 20]). In general, the dynamic nature of spatial attributes makes LSQs unique and challenging, which implies that the skyline results would differ with respect to different query locations. Taking the above car-park-finding scenario for example, the distance from a clie nt to a car park varies with the location of the client. Such dynamic nature of query resu lts signifies the necessity of authenticating LSQ results.

In a previous work [8], we have proposed an efficient index, called MR-Sky-tree, for authenticating one-shot LSQs. However, in L BS applications, users may sometimes pre-fer continuous queries; e.g., a driver may issue a continuous LSQ like  X  X inding nearby car parks with cheap park fees X  as he drives o n the street. The authentication prob-lem for continuous LSQs is more challenging since it is not efficient to repeat one-shot query authentication whenever the client ch anges location. In this paper, we propose three novel techniques, i.e., using valid scope , visible region ,and incremental VO to reduce both the computation and communication cost. Specifically, the valid scope de-fines an area in which the query results do not change. The visible region is a super set of valid scopes in which the client is able to compute the new results locally with-out contacting the server. Lastly, if the query point moves out of the visible region, the server can return only a part of VO, called incremental VO , to the client so as to save the communication cost.

On the whole, our contributions made in this paper can be summarized as follows:  X  We propose a valid scope computation and authentication algorithm for continuous  X  We propose a concept of visible region, by which the LSQ results can be computed  X  We propose the construction and merge algorithms for incremental VO, which  X  We conduct extensive experiments to evaluate the performance of the proposed The rest of this paper proceeds as follows. S ection 2 reviews the related work and gives some preliminaries on the problem to be studied. In Section 3, we propose three opti-mization techniques for continuous LSQs. The proposed techniques and algorithms are experimentally evaluated in Section 4. Finally, this paper is concluded in Section 5. In this section, we give the formal definition of location-based skyline queries (LSQs) and describe our previous work MR-Sky-tre e [8], which can be used to authenticate one-shot LSQs. We consider a set of data objects O . Each object o  X  O is associated with one spatial location attribute (denoted by o.x and o.y ) and several non-spatial attributes (e.g., parking fee and service quality, denoted by o.A i for the i -th non-spatial attribute). In this paper, we employ the Euclidean distance metric to measure the spatial proximity. Definition 1. (Dominance) Given two objects o and o ,if o .A i is not worse than o.A i for any non-spatial attribute A i , then we say o non-spatially dominates o , and o is a non-spatial dominator of o . Formally, it is denoted as o o .Thesetof o  X  X  non-spatial dominator objects is denoted as Dom( o ). Given a query point q ,if(1) o non-spatially dominates o , and (2) o is no farther away from q than o (i.e., o also spatially dominates o ), then we say o dominates o w. r. t. the query point q . Formally, it is denoted as o q o . Definition 2. (Location-based Skyline Query (LSQ)) Given an object set O ,the location-based skyline of a query point q is a subset of O ,LSQ( O,q ), in which each object is not dominated by any other object in O w. r. t . q .
 By definition, LSQs have an intuitive characteristic, i.e., for a given query point q , if an object o is closer than all its non-spatial dominators, o must be a member of LSQ( O,q ). With this characteris tic,wedefineaconcept skyline scope , which can be used to accelerate LSQ processing and authentication.
 Definition 3. (Skyline Scope) For any object o  X  O , its skyline scope in a 2D plane P is denoted as SS( o )= { q | q  X  P  X  o  X  LSQ ( q,O ) } ,where o  X  LSQ ( q,O ) means  X  m  X  Dom ( o ) , o is closer to q than m , i.e., dist S ( o , q ) &lt;dist S ( m , q ). The skyline scope of an object o is essentially the Voronoi cell of o in the object set { o } X  Dom ( o ) .IfDom( o )isempty, o  X  X  skyline scope is the entire space. In general, the Voronoi cell can be computed using a divide-and-conquer algorithm, with a time complexity of O( | O | log | O | )[2].

With the skyline scopes for all objects, a location-based skyline can be found by searching the objects whose skyline scopes cover the query point q . For example, Fig. 2(a) shows the non-spatial attributes ( A 1  X  A 4 ) of objects a -k , where a smaller non-spatial value is preferred. The spatial location and skyline scope of each object are shown in Fig. 2(b). Since the query point q is covered by the skyline scopes of a, b, d, e, f and g (the skyline scopes of a, d, f and g are the entire scope), the LSQ( O,q ) results are these six objects.

To support query authentication, the skyline scopes of all objects are inserted into an MR-tree [16] as data entries. The MR-t ree is a combination of MH-tree [5] and R*-tree [1]. Each leaf node in the MR-tree is identical to that of R*-tree, which stores pointers pointing to actual data objects. The digest of a leaf node is obtained by hashing the concatenation of the binary representations of all objects in the node. Each internal node contains a number of entries in the form of ( ptr i ,MBR i ,H i ) , 1 where ptr i is the pointer pointing to the i -th child, MBR i and H i are the minimum bounding rectangle and the digest of the i -th child, respectively. The digest of an internal node summarizes the MBRs and digests of all children nodes. The use of digests makes possible the pruning of index nodes in the VO while being able to verify the correctness of query results. We call this MR-tree indexing skyline scopes as MR-Sky-tree. Fig. 2(c) shows the MR-Sky-tree for our running example, where N 1 , N 2 , N 3 and N 5 are the entire space.

Given LSQ( O,q ), the VO of this query is represented by a subtree of the MR-Sky-tree index (termed as VOTree ). In detail, the server checks, from the root and down-wards, whether each child of an MR-Sky-tree node covers the query point q . If it does not, the child is pruned, while its MBR and digest are inserted into the VOTree .Oth-erwise, the node is unfolded and the children of the node are checked recursively by repeating the above procedure. Fig. 2(d) shows the final VOTree for our running exam-ple. Since N 6 and N 7 does not cover q , their digests and MBRs are inserted into VOTree instead of their children.

To verify the query results, the client checks the following three facts: 1) the skyline scopes of all objects in the result set should cover the query point q ; 2) no MBRs of the pruned nodes and no skyline scopes of the non-result objects cover q ; 3) the root signature matches the digest computed from VOTree . The fact 3 ensures the soundness of the results, and facts 1-3 ensure the completeness of the results.
To authenticate continuous LSQs such as  X  X inding nearby car parks with cheap park-ing fees, X  a naive method is to repeat the query processing and VO construction pro-cesses shown in Section 2, whenever the client changes location. Obviously, this method is not efficient on both computation and communication cost. In this section, we pro-pose three techniques to improve the performance. First, we compute the valid scope of query point q , in which the LSQ results remain the same as LSQ( q,O ). By the valid scope, the clients need not send location updates to the server or re-compute the query results by itself. Second, we introduce a concept of visible region for each VO. If the query point is located in the visible region, the new LSQ results can be computed by the client locally, without contacting the server. Lastly, when the client moves out of the visible region, we propose an incremental VO technique so that only a small part of VO needs to be sent back to the client.
 3.1 Valid Scope and Its Authentication As mentioned above, the valid scope of q is the area that shares the same LSQ results with q . This means if the client moves from q to any point in the valid scope, no skyline object leaves the skyline set and no non-skyline object enters the skyline set. Hence, the valid scope can be computed by: Take Fig. 3 for example. Firstly, we compute the intersection area of the skyline scopes of all skyline objects. Since the skyline set in our running example is { a, b, d, e, f, g } , the intersection area of their skyline scopes is the shaded area in Fig. 3(a). Secondly, the part which intersects with the skyline scope of any non-skyline object is removed from the valid scope. In Fig. 3(a), since c is not a skyline object, the part which intersects with c  X  X  skyline scope should be removed. As a result, the final valid scope is the shaded area in Fig. 3(b).

After computing the valid scope, we construct the VOTree, with which the client can verify the soundness of the valid scope. We define the intersection area of the skyline scopes of all skyline objects as the valid scope verification region ( VSVR ) (just like the shaded area in Fig. 3(a)). The idea is that, if a node in the MR-Sky-tree does not intersect with VSVR , the node need not be unfolded and only its digest and MBR are inserted into the VOTree. The pseudo-code of the valid scope computation and VO construction algorithm is summarized in Algorithm 1.
 The following theorem proves the correctness of Algorithm 1.
 Theorem 1. The VOTree constructed by Algorithm 1 can be used to verify the correct-ness of valid scope VS .
 Proof. The client can verify VS by the following two facts: 1) all query points inside VS share the same LSQ results with LSQ( q,O ); 2) any query point p outside VS satisfies LSQ( p, O ) = LSQ( q,O ).
Fo r f a c t 1 , s i n c e VS is contained in VSVR and all nodes intersects with VSVR are unfolded and stored in the VOTree, the client has a full view about the skyline scopes that intersect with VS . As such, the client can verify the LSQ results for any point inside VS .
Fo r f a c t 2 , i f p is outside VS but inside VSVR , all the nodes that cover p would be unfolded according to Algorithm 1. Hence, the client can verify LSQ( p, O )bythe covering skyline scopes. Otherwise, if p is outside VSVR , we show LSQ( p, O ) = LSQ( q,O ) by contradiction. Suppose there exists such a point p that satisfies LSQ( p, O ) =LSQ( q,O ). Since p is outside VSVR , p must be outside the skyline scope of some member(s) in LSQ( q,Q ). Hence, such member(s) will not be in the result set of LSQ( p, O ) according to the definition of skyline scope, which leads to LSQ( p, O ) = LSQ( q,O ). The verification of the valid scope is similar to that of the MR-Sky-tree method (see Section 2). The client should check: 1) the valid scope is identical to the area computed by Equation (1); 2) the root signature matches the digest computed from the VO. 3.2 Visible Region When the client moves out of the valid scope, we may still not need to issue a new query. It is possible to compute the new results locally. By the current VO, the client has a full view about the skyline scope coverage of the region that is not covered by any pruned node. We call such a region as visible region . For example, as shown in Fig. 2(b), if the client moves form q to q 1 , we can compute the new LSQ results as { a, c, d, f, g } locally, since no pruned object in the current VO covers q 1 .
 Formally, the visible region can be obtained as follows: where P denotes the entire space and PN denotes the index nodes which were pruned in the VO. Take Fig. 2(b) for example. Since the nodes N 6 and N 7 were pruned in the VO construction, the client has no idea about the skyline scope distribution in the region that is cover by these two nodes. Thus, the visible region is P -( N 6 N 7 ). 3.3 Incremental VO When the client moves out of the visible region, we have to issue a new query to update the results. A simple method for the server is to reconstruct a new VO and return it to the client. However, this method is ineffic ient because it does not reuse the previous VO to reduce the communication cost. In this section, we propose an incremental VO technique to address this problem.

The main idea of incremental VO is to reuse the VOTree of the last query, since it may overlap with the VOTree of the new query. Thus, we modify the VO construction algorithm in the MR-Sky-tree method by the following changes (Algorithm 2): 1) if a node does not cover the new query point, its related information (including MBR and digest) need not be stored in the incremental VO since the client can get them from the previous VO (we use a label  X  X it X  to represent such nodes; see Line 11); 2) if a leaf node covers the last query point, it also need not be returned to the client (Line 14), since all its members have been available in the previous VO.
 Revisit our running example. If the query point move from q to q 2 , the incremental VO is shown in Fig. 4. The node N 7 does not cover the new query point q 2 , it is replaced by label  X  X it. X  Since the leaf nodes N 3 , N 4 and N 5 cover the last query point q ,they are also represented by label  X  X it. X  Only the node N 6 covers q 2 and does not cover q . Hence, it is unfolded and all its children skyline scopes are inserted into the incremental VO. While the storage overhead for label  X  X it X  is negligible, the main communication cost here is incurred by the unfolded leaves. Fortunately, the number of such leaves is usually small for continuous queries.

After the client receives the incrementa l VO, it will merge the incremental VO with the previous VO. The merge algorithm traverses the incremental VO and the previous VO in parallel to construct the merged VO. T he type of the incremental VO node deter-mines what is inserted into the merged VO. We use two heaps INC Q and PRE Q to temporarily store the nodes of the incremental VOTree and the previous VOTree. Dur-ing the merge process, if the incremental VO node is an index node, we just insert the corresponding node of the previous VO into the merged VO. And then their children are inserted into INC Q and PRE Q for further processing (Line 6-9). If the incremental VO node is a leave labeled  X  X it, X  the whole subtree of the corresponding node in the previous VO is inserted the merged VO without any change (Line 10-11). Otherwise, the incremental VO node must be an unfolded leaf and is inserted into the merged VO instead of the previous one (Line 12-13). 4.1 Experiment Setup In this section, we evaluate the performance of our proposed techniques and algorithms through experiments. The spatial object set used in the experiments contains 2,249,727 objects representing the centroids of the street segments in California [14]. All testing datasets draw objects randomly from this set. The data space is normalized to a 100,000 Unit  X  100,000 Unit square, where 1 Unit represents about 1 m . The non-spatial at-tribute values of these objects are synthesized with a uniform distribution in the interval [0, 100,000]. The page size is 4K bytes and the size of each object is 320 bytes. The hashing function we use for the MR-Sky-tree is SHA-512, and the size of each digest is 64 bytes. Table 1 summarizes the default settings and value ranges of various system parameters.

We measure the performance of continuous LSQ authentication with three metrics: communication cost, server computation time and client verification time. We compare the effects of the three optimization techniques proposed in in Section 3 with the naive Algorithm 3. VO Merge Algorithm on the Client method, which repeatedly updates the query results and the corresponding VO when the client changes location. We assume that the client moves with an average speed of 6 m/s and the location sampling period is 100 seconds.

We conducted the experiments on a workstation (Intel Xeon E5440 2.83GHz CPU) running on Ubuntu Linux Operating System. The simulation codes were written in Java (JDK 1.6). Each measurement is the average result over 100 sampling periods. Communication Cost. We first measure the size of the VO transferred between the server and clients as the metric of communi cation cost. We compare the performance of four schemes: 1) the naive method without any optimization (denoted as Naive ); 2) the MR-Sky-tree based method optimized with the valid scope technique (denoted as VS ); 3) the MR-Sky-tree based method using both the valid scope and visible region techniques (denoted as VS+VR ); 4) the MR-Sky-tree based method optimized with all proposed techniques (denoted as All ). The evaluation results are shown in Figs. 6(a) through 6(c). We can observe that the communication cost of VS is close to that of the naive method, while VS+VR and All achieve a much lower cost. This is because the area of the valid scope is generally ve ry small and the adjacent query points are seldom located in the same valid scope. If we promote the location update frequency by reducing the sampling period (see the left part of Fig. 6(c)), this increases the chance that the adjacent query points are located in the same valid scope, which demonstrates the advantage of VS over the naive method. The visible region is much larger than the valid scope since many nodes in the MR-Sky-tree will be unfolded as long as they cover the query point. As a result, VS+VR gains much performance improvement over VS in most cases tested. Finally, employing the incremental VO technique further reduces the VO size by a factor of up to 10. Server Computation Time. We first measure the effect of the proposed optimization techniques (denoted as Opt ) for continuous LSQs in Fig. 7. All the three proposed techniques, i.e., the valid scope, visible re gion, and incremental VO, are applied. We can see that Opt performs much better than the naive method since many query points are located in the visible region and their queries need not be sent to the server for re-evaluation. To examine the time cost o f each optimization technique, we break the query processing into several steps and compare the average time cost for each step under various settings. As shown in Fig. 8, in the optimized continuous LSQ processing, the server may spend the computation time in three steps: original VO construction (denoted as Ori VO ), valid scope computation (denoted as VS ) and incremental VO construction (denoted as inc VO ). We observe that the valid scope construction costs the most time since it needs to combine the skyline scopes of all skyline objects and then remove the part of non-skyline objects. For all three steps, the computation time increases as increasing dataset cardinality and non-spatial dimensionality. This is as expected due to the increased size of the skyline result set. Client Verification Time. As shown in Fig. 9(a), the average client verification time of the proposed optimization techniques is much better than the naive method for short lo-cation sampling periods, due to the same reason explained in the previous experiments. When the location sampling period is long, the query needs to be re-evaluated by the server at almost every period. In this case, the client would incur some unnecessary cost in valid scope checking and VO merging. In fact, for the proposed optimization techniques, the client verification time may be spent on four parts: 1) VO verification (denoted as VO verify ), which is the same as that in one-shot queries; 2) valid scope checking (denoted as VS check ), which checks whether the query point is located in the valid scope; 3) visible region utilization (denoted as VR ), which checks weather the visible region covers the query point and use the visible region to compute new LSQ results; 4) VO merging (denoted as VO merge ), which merges the incremental VO and the previous VO to make a new VO. Figs. 9(b) and 9(c) show the average cost of each step under various settings. We can observe that the valid scope checking uses the least time, while the costs of the other three parts are similar.
 In this paper, we have studied the problem of authenticating continuous location-based skyline queries with integrity assurance. We have developed three optimization tech-niques based on the MR-Sky-tree method, i.e., using valid scope, visible region, and incremental VO to reduce both the computation and communication cost. The experi-ment results show that our proposed techniques perform better than the existing method in terms of various performance metrics.

As for future work, we will extend the authentication problem to road network en-vironments, where the query distance is defined by network distance. As the skyline scope does not work for network distance, new query authentication algorithms need to be developed.
 Acknowledgments. This work is supported by GRF Grant HKBU210811, NSFC Grant 60903169, and the Hong Kong Scholars Program. Lin Xin X  X  research is also supported by the Fundamental Research Funds for the Central Universities.

