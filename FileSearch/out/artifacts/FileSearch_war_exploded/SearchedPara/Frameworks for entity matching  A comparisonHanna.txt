 1. Introduction
Entity matching (also referred to as duplicate identification, record linkage, entity resolution or reference reconciliation) referring to the same real-world entity. Entities to be resolved may reside in distributed, typically heterogeneous data sources or in a single data source, e.g., in a database or a search engine store. They may be physically materialized or dynam-ically be requested from sources, e.g., by database queries or keyword searches.

Entity matching is a challenging task particularly for entities that are highly heterogeneous and of limited data quality, e.g., regarding completeness and consistency of their descriptions. Table 1 illustrates some of the problems for a biblio-graphic example of three duplicate entries for the same paper. It is assumed that the bibliographic entities have automati-cally been extracted from fulltext documents and may thus contain numerous quality problems such as misspelled author names, different ordering of authors, and heterogeneous venue denominations.
 The entity matching problem was originally defined in 1959 by Newcombe et al. [45] and was formalized by Felligi and
Sunter [26] 10 years later. Since then it has been considered under various facets and from different communities, including the AI research community, the DB research community, and industry. Numerous approaches have been proposed for entity matching especially for structured data. For overview surveys and two tutorials see [60,28,3,25,35,31] , respectively. Due to the large variety of data sources and entities to match there is no single  X  X  X est X  match algorithm. A single match approach typically performs very differently for different domains and match problems. For example, it has been shown that there is no universally best string similarity measure [29,50] . Instead it is often beneficial and necessary to combine several meth-ods for improved matching quality, e.g., to consider the similarity of several attributes or to take into account relationships between entities. For large datasets, it is also necessary to apply so-called blocking strategies to reduce the search space for entity matching and achieve sufficiently fast execution times. Hence, several entity matching frameworks have recently been developed which support multiple approaches for blocking and matching as well as their combination. A key problem to be addressed either manually or with the help of machine learning techniques is how to find an effective and efficient combi-nation of different techniques.

To investigate the state of the art in this respect we comparatively analyze 11 proposed entity matching frameworks. We focus on research prototypes but do not consider the more general system approaches on data cleaning and data integration, such as AJAX [27] and Potters X  X  Wheel [48]. We also exclude commercial systems such as ChoiceMaker, DataCleanser (EDD),
Merge/Purge Library (Sagent/QM Software) or MasterMerge (Pitney Bowes) from our discussion since they are not widely available and their algorithms are not described in the public literature.

In contrast to the previously published surveys [60,28,3,25] we do not focus on specific algorithms but study which spec-trum of approaches is provided by different frameworks and how the approaches can be combined. Our study considers both frameworks which do or do not utilize training data to find an effective configuration to solve a given entity matching task.
We further study how the different frameworks have been quantitatively evaluated. The study aims at providing an over-view of the current state of the art regarding research entity matching frameworks and their evaluations. Our comparison criteria should enable to categorize and compare further frameworks and methods for entity matching as well as their eval-uations. Furthermore, they should be helpful in identifying promising frameworks as well as areas where more work is needed.

The remaining part of this paper is organized as follows: in Section 2 we briefly introduce the entity matching problem and specify high-level requirements for an entity matching framework. Section 3 compares the functionality of 11 selected entity matching frameworks based on a common set of criteria. In Section 4 we then compare how the considered frame-works have been evaluated to assess their effectiveness and efficiency. Section 5 concludes the paper. 2. Requirements for entity matching frameworks The considered frameworks have to solve the entity matching problem which can be stated as follows: Definition 1 ( Entity matching problem ). Given two sets of entities A 2 S data sources S A and S B , the entity matching (EM) problem is to identify all correspondences between entities in A B representing the same real-world object. The definition includes the special case of finding pairs of equivalent entities within a single source  X  A  X  B ; S A  X  S B  X  . The match result is typically represented either by a set of correspondences, sometimes called a mapping, or by a set of clusters. A correspondence c  X  X  e S . An optional similarity value s 2 X  0 ; 1 indicates the similarity or strength of the correspondence between the two objects. In the alternate result representation, a cluster contains entities that are deemed to represent the same real-world object.
Ideally all entities in a cluster refer to the same object, and no two entities from two different clusters refer to the same object.

There are several high-level requirements and desiderata that should be met as far as possible by a suitable entity match-ing solution and thus by entity matching frameworks.

Effectiveness : The main goal of entity matching is to achieve a high-quality match result with respect to recall and pre-cision, i.e., all real corresponding entities but no others should be included in the result. Achieving this goal for different match tasks typically requires the flexible combination and customization of different match methods. A key concern will thus be which match approaches are supported and how they can be combined.

Efficiency : Entity matching should be fast even for voluminous datasets. For very large datasets this typically prescribes the use of blocking methods to reduce the search space for entity matching (see next section).

Genericity, offline/online matching : The supported entity matching methods should be applicable to different match tasks from various domains (e.g., enterprise data, life science data) and for different data models (e.g., relational, XML). Further-more, an EM framework should be applicable to offline and online match tasks. Online match tasks arise for interactive data integration steps such as mediated queries or data mashups based on specific user input. Offline entity matching is less time-critical than online matching which can thus better deal with large datasets and may allow for more match algorithms to be applied. Entity matching during the ETL (extract, transform, load) process of data warehouses is a sample case for offline matching.

Low manual effort/self-tuning : The manual effort to employ an EM framework should be as low as possible, in particular for selecting the methods for blocking and matching, their parameters and their combination. Ideally, the framework is able to solve these tasks automatically in a self-tuning manner, e.g., with the help of machine learning methods utilizing training data. On the other hand, selecting and labeling training data may also incur manual effort which should therefore be low.
A key challenge in developing a successful EM framework is that some of the posed requirements are in conflict with each other, e.g., effectiveness and efficiency or genericity and ease-of-use. For example the use of blocking methods improves effi-ciency by reducing the search space. However, this may eliminate some relevant entity pairs from consideration and thus reduce effectiveness (recall) of entity resolution. On the other hand, the combined use of several match algorithms may im-prove effectiveness but will typically lead to increased computational overhead and thus reduce efficiency. Successfully resolving entities in diverse domains with the help of a generic entity matching framework is more difficult than for only one domain. Non-generic frameworks may thus incur a reduced manual effort to provide training or to find a suitable com-bination and customization of algorithms. 3. Functional comparison of EM frameworks We compare 11 proposed EM frameworks (Table 2 ). Our selection tries to cover a broad spectrum of different approaches.
We have selected three frameworks that need no training and eight training-based frameworks. We focused on those frame-works which allow the combined use of several match algorithms and for which evaluation results have been published.
Clearly, our comparison can only cover a current snapshot of existing systems and not all relevant frameworks can be in-cluded for space reasons. However, we believe that our methodology to compare different frameworks can be used to eval-uate further systems or to update the characteristics when frameworks improve or new evaluations become known. In this section we focus on the functionality of the different frameworks. In Section 4, we analyze published evaluation results for the frameworks. Before we start the comparative discussion for the frameworks we first provide more information of some key comparison criteria influencing the high-level requirements of effectiveness, efficiency and self-tuning: blocking meth-ods, matchers, combination of matchers, and training selection. 3.1. Comparison criteria 3.1.1. Entity type
Methods for relational entity matching assume that each tuple represents an entity and all attribute values describe that entity. Sufficiently similar data values of two tuples imply that they are duplicates. Complex structured and XML data is semi-structured and is organized hierarchically. This complicates entity matching, compared to relational data that is flat and usually well-structured. It is not clear whether a child element represents part of the description of an element (as does a relational attribute), or if it represents a related object (as does a relationship with another table). Furthermore, elements describing the same kind of entity are not necessarily equally structured. These structural differences are due to either dif-ferent representations of same entities (e.g., persons may be represented as managers or employees), or differences allowed by the schema, e.g., multiplicities of elements (e.g., persons having no, one, or multiple phone numbers). 3.1.2. Blocking methods
Blocking is needed for large inputs to reduce the search space for entity matching from the Cartesian product to a small subset of the most likely matching entity pairs. Numerous blocking algorithms have been proposed in the past years (see [4] for an overview). These techniques typically use a key to partition the entities to be matched into groups (blocks). Matching of an entity can then be restricted to the entities in the same block. The key is typically composed from parts (e.g., first let-ters) of entity attribute values.

As a criterion for comparing frameworks we distinguish between disjoint and overlapping blocking methods. Disjoint methods build mutually exclusive blocks, i.e., each entity is assigned to one block. Implementations may use sorting or hash-ing on the key. Overlapping methods may result in overlapping blocks of entities; implementations include the (multi-pass) sorted neighborhood approach [33], bi-gram indexing [4], canopy clustering [40] and iterative blocking [59]. These methods can require an entity to be matched against multiple blocks (increased overhead) but may lead to a better recall than disjoint methods. For a recent comparison of several blocking methods see [23].

The definition of the key is a critical issue with all blocking methods. A suboptimal choice may lead to over-selection of many dissimilar entity pairs that impedes efficiency, or, worse, sorting out true matching entity pairs thus decreasing match quality. The key may have to be determined manually or (semi-)automatically based on training data [10,42] . 3.1.3. Matchers
Entity matching requires a way to determine whether two entities are alike enough to represent the same real-world en-tity. A matcher is an algorithm specifying how the similarity between two entities is computed. We distinguish two types of matchers: attribute value matchers and context matchers.

Attribute value matchers use a similarity function and apply it on the values of a pair of corresponding attributes or attri-bute concatenations of the input datasets. They typically return a value between 0 and 1 indicating the degree of similarity between two entities. The previously proposed approaches mostly assume that corresponding attributes from the input datasets have been determined beforehand, either manually or with the help of schema matching. The corresponding attri-butes and similarity functions used for matching may have to be selected manually or they could be determined (semi-)automatically, similarly to the key selection for blocking. Numerous similarity functions may be employed, in particular generic string similarity measures (see [20,25] for a comprehensive comparison). Similarity computation may also utilize synonyms, homonyms, abbreviations, acronyms, or geographic name variations. In offline data integration, e.g., for data warehousing, such auxiliary sources are often used by separate data cleaning steps to resolve representational differences before entity matching begins.

Context matchers consider the context or semantic relationships of different entities for similarity computation. Context matchers commonly represent contextual information (e.g., semantic relationships, hierarchies) in a graph structure, see for example [16,34,7,6,15,21,22,51] . The graph structure allows the propagation of similarity information (e.g., represented as edge weights or auxiliary nodes) to related entities. For example to disambiguate several persons with the same name one may additionally consider contextual information such as their affiliations or co-authors. 3.1.4. Combination of matchers
There are many possibilities for combining multiple matchers within a match strategy. In general, the combination may be expressed by a decision function which applies matchers from a given set of matchers to determine for each pair of enti-ties whether or not the entities match.

We distinguish between three kinds of combination approaches: numerical, rule-based and workflow-based combina-tions. Numerical approaches combine the similarity values of entity pairs  X  e etc. by a numerical combination function f : f  X  m 1  X  e i of similarity values. The resulting numerical value is then mapped to a match or non-match decision. Examples for numerical combination approaches can be found in [26,41,52,32].

Rule-based approaches derive the match decision by a logical combination (or predicate) of match conditions. A match condition can be a threshold condition defined on the similarity value computed by a single matcher m : C  X  m  X  e or by several matchers (e.g., using a numerical combination function f ) or express a hard constraint (e.g., every paper has a single publisher). A simple match rule R consists of the logical conjunction of n match conditions: R  X  two books may be considered to match if the string similarities of their title and author attributes both exceed certain thresholds. Such simple match rules consisting only of threshold conditions for single attribute value matchers have also been called similarity joins ; their restricted structure permits an efficient execution in many cases [1]. Complex match rules allow the combination of multiple simple match rules, e.g., by disjunction a human expert to specify such match rules declaratively.

Workflow-based combination of matchers such as supported by MOMA [55] allows almost arbitrary complex combinations of matchers, e.g., to apply a sequence of matchers to iteratively refine a match result or to combine the results of indepen-dently executed matchers.

Key decisions to be made for the specification of a combination strategy expressed as a numerical combination function, match rules, or a match workflow include selecting and configuring the matchers to be used. The chosen configuration can have a large impact on the overall quality but even experts will find it difficult and time-consuming to determine a good selection. The use of supervised (training-based) approaches or learners aims at automating the process of entity matching to reduce the required manual effort. Training-based approaches, e.g., Na X ve Bayes [49], logistic regression [46], Support Vec-tor Machine (SVM) [11,43,49] or decision trees [63,29,49,53,54,56] have so far been used for some subtasks, e.g., determining suitable parameterizations for matchers or adjusting combination functions parameters (weights for matchers, offsets). However, training-based approaches require suitable training data and providing such data typically involves manual effort.
Furthermore, some decisions (e.g., selection of the similarity functions and attributes to be evaluated) may still have to be determined manually. Hence it is important to analyze for training-based approaches which tasks still require manual deci-sions. In the framework comparison we consider whether a framework supports a numerical combination approach, match rules, or match workflows. We further assess whether and for which tasks training is utilized. 3.1.5. Training selection
Training-based EM frameworks promise a reduced manual effort to find suitable match strategies but their effectiveness critically depends on the size and quality of the available training data. For entity matching it is important that the training data is representative for the objects to be matched and exhibit the variety and distribution of errors observed in practice.
We thus investigate how training data is selected in the proposed frameworks. Selection of training example may be manual, semi-automatic or automatic. With manual selection entities have to be chosen and labeled by a user. Semi-automatic selec-tion still requires a human for labeling, but entity pairs are automatically chosen for labeling. Automatic selection provides and labels training examples automatically without any inspection by a user.
 3.2. Comparison
Table 2 compares the 11 selected frameworks for entity matching within three groups. The first group includes (three) frameworks that do not utilize training data, while the (four) frameworks of the second group depend on training data.
The third group includes hybrid approaches which support supervised matcher combinations as well the manual specifica-tion of EM strategies without training. For each group, the frameworks are listed in chronological order of their year of pub-lication. All inspected frameworks support only one type of entities either relational (10 frameworks) or XML (one frameworks), i.e., no framework is able to handle both types. All frameworks focus on offline matching, i.e., they do not yet cover online matching. Online matching has been addressed to some extent in [8,9]. Three of the 11 frameworks operate without training; four of the eight training-based frameworks, the Context Based Framework [16], FEBRL [18,17] , STEM [36] and TAILOR [24], also support the manual specification of EM strategies without training (hybrid frameworks). Four of the training-based frameworks expect the users to provide suitable training data manually, while Active Atlas [53,54] , MARLIN [11,12] , STEM [36] and FEBRL [18,17] have also investigated (semi-)automatic training methods.

Most training-based frameworks  X  but none of the others  X  provide explicit support for blocking based on disjoint or/and overlapping entity partitioning. This seems to be influenced by the fact that the trained methods to determine matches, such as SVM or decision trees, are computationally expensive so that blocking is mandatory to reduce the search space even for small-sized match tasks. Canopy-like clustering and sorted neighborhood are the most common blocking techniques. The definition of the blocking key is not yet derived from training data but has to be specified manually in all training-based frameworks. This is a serious limitation for the optimization potential of training-based methods.

All frameworks support attribute value matchers utilizing a large variety of string similarity functions. ( Table 3 indicates which similarity functions have been used in the evaluations). Two frameworks additionally provide context matching but only one of the training-based frameworks. All frameworks support the combination of multiple matchers. Most frameworks support (complex) match rules, numerical combination functions, or both approaches. Only one framework, MOMA [55], al-lows the definition of match workflows.

Seven of the eight training-based frameworks (Active Atlas [53,54] , Context Based Framework [16], MARLIN [11,12] , Mul-tiple Classifier System [62], Operator Trees [13] and TAILOR [24]) utilize training for learning match rules, mostly by employ-ing decision tree algorithms. Training data is utilized to automatically determine the order in which different matchers are applied as well as threshold conditions on the similarity values computed by the matchers. Another approach pursued by seven training-based frameworks (Context Based Framework [16], MARLIN [11,12] , Multiple Classifier System [62], Operator
Trees [13], FEBRL [18,17] , STEM [36] and TAILOR [24]) is to utilize training for automatically determining a numerical com-bination function f . The combination function is determined through the choice of the employed supervised learning algo-rithm. The most often employed learner for this task is the SVM. For the SVM the combination function f is a weighted sum of matcher similarity values s i of the form f  X  sgn P n i  X  1 offset b . Besides the SVM, the Context Based Framework [16], the Multiple Classifier System [62] and FEBRL [18,17] frame-works consider other supervised learners (e.g., logistic regression) for determining a combination function. All training-based frameworks optimize the combination of a manually predetermined set of matchers, i.e., they do not explicitly select which attributes or similarity functions should be used.

In the following three sections we discuss specific features of the 11 frameworks. We start with the three approaches that do not require training. The training-based frameworks are highlighted in Section 3.2.2 and hybrid frameworks supporting both combination strategies are considered in Section 3.2.3. 3.2.1. Frameworks without training
BN ( Bayesian Network ): Leit X o et al. [38] propose a framework for matching XML entities based on a Bayesian network (BN) model. Bayesian networks provide a graph-based formalism to explicitly represent the dependencies among the entities of a domain. This model is derived from the structure of the XML entities to be matched. The approach numerically combines the similarity for direct attributes value of two XML entities as well as the similarity for descendant XML entities. The user has to specify a match probability threshold above which entities are considered matches.

MOMA (Mapping-based Object Matching) : MOMA [55] is a domain-independent framework for entity matching providing an extensible library of matchers, both attribute value and context matchers. To solve a particular match problem MOMA allows the specification of a workflow of several matchers and combination operators. Each matcher and workflow step determines a so-called same-mapping (set of corresponding entity pairs) that can be refined by additional matchers and steps. The final mapping determined by a match workflow is stored in a mapping repository and can be re-used in other workflows. A so-called neighborhood matcher implements a context-based match approach and utilizes semantic relation-ships between different entities, such as publications of authors or publications of a conference. MOMA supports compose and merge operators to combine different mappings for the same match problem. Different combination functions (avg, min, max, weighted and prefer) can be used to derive a combined similarity values for input correspondences to be combined into a merged correspondence. MOMA does not explicitly offer blocking methods. However, a blocking-like reduction of the search space could be implemented by a liberal attribute matching within a first workflow step whose result is then refined by further match steps.

SERF (Stanford Entity Resolution Framework) : The SERF project [5] develops a generic EM infrastructure with the focus on improving the efficiency of entity matching. The authors do not study the internal details of matchers (similarity functions) but view them as  X  X  X lack boxes X  to be invoked by the EM engine. Different algorithms are provided to minimize the number of invocations to these potentially expensive black boxes by keeping track of previously compared values thus avoiding redundant comparisons. Multiple matchers can be combined by a disjunction of manually defined simple match rules. 3.2.2. Training-based frameworks
Active Atlas : The Active Atlas system proposed by Tejada et al. [53,54] allows the training-based determination of match rules by utilizing a combination of several decision tree learners. Training selection is semi-automatic to minimize the num-ber of required training examples. This is achieved by letting the decision tree learners vote on the most informative example of additional information (e.g., stemming, abbreviations) to determine the common tokens of two attribute values. A disjoint blocking strategy based on hashing is supported.

MARLIN (Multiply Adaptive Record Linkage with Induction) : MARLIN [11,12] employs a training-based approach for combin-ing multiple matchers using the SVM at two levels. At the first level attribute value matchers are tuned. At the second level the SVM is applied to determine a combination of the tuned matchers from the previous step. MARLIN utilizes the canopies clustering method using Jaccard similarity for overlapping blocking. Two methods for semi-automatic training selection are supported: static-active and weakly-labeled negative selection. Static-active selection compares the entities to be resolved with some string similarity measure and selects only pairs that are fairly similar according to this measure to find near-duplicate entity pairs for training. For  X  X  X egacy X  datasets with few duplicate entries the weakly-labeled negative training selection is proposed. It randomly selects entity pairs with few shared tokens for training; these pairs are thus likely non-duplicates.

Multiple Classifier System : In Ref. [62] a Multiple Classifier System approach is proposed that employs a variety of super-vised learners for combining matchers, including decision trees, 1-rule, Na X ve Bayes, linear and logistic regression, back prop-agation neural network, and k -nearest neighbors. Furthermore, meta-combination approaches for combining several supervised learners are supported, namely cascading, bagging, boosting, and stacking. While bagging and boosting combine multiple supervised learners of the same type, cascading and stacking are used to combine supervised matchers of different types (e.g., logistic regression and decision tree learning). Blocking support is not explicitly mentioned, but the evaluation suggests that some blocking method has been applied.

Operator Trees : Chaudhuri et al. [13] specify EM strategies by operator trees which correspond to the union (disjunction) of multiple similarity joins. Manually labeled training samples are used to construct the Operator Trees by a recursive divide and conquer strategy. The maximum number of similarity joins in an Operator Tree and the maximum number of similarity function predicates per similarity join can be restricted by the user. Blocking is not explicitly supported. However, the authors state that the canopies clustering method using Jaccard similarity is applied in the evaluation. For comparison a nu-meric matcher combination utilizing the SVM is considered. 3.2.3. Hybrid frameworks
TAILOR : TAILOR [24] is a toolbox for record linkage supporting numerical and rule-based combination approaches for multiple matchers without training as well as training-based. Five similarity functions are provided for attribute value matching, namely hamming distance, edit distance, Jaro X  X  algorithm, q-grams and soundex. For training-based combination the user can choose among three probabilistic approaches for numerical combination and two rule-based approaches utiliz-ing decision tree learning. Training data must be manually provided by the user. Disjoint as well as overlapping blocking methods are supported.

FEBRL (Freely Extensible Biomedical Record Linkage) : FEBRL [18,17] is a hybrid framework supporting a training-based numerical combination approach utilizing the SVM as well as numerical approaches without training. FEBRL is the only one of the considered frameworks that is freely available on the web under an open source software license. It was originally developed for entity matching in the biomedical domain (hence the name). A large selection of 26 different similarity mea-sures is available for attribute value matching. FEBRL supports one disjoint as well as three overlapping blocking methods. Besides manual training selection two strategies for automatic training are supported [17]: threshold-and nearest-based.
Both methods select entity pairs automatically and do not require manual labeling by a user. To determine matching/ non-matching training examples the threshold method selects entity pairs whose similarity values are within a certain dis-tance to exact similarity or total dissimilarity for all considered matchers. The nearest method sorts the similarity vectors of the entity pairs according to their distances from the vectors containing only exact similarities and only total dissimilarities, respectively, and then selects the nearest entity pairs for training.

STEM ( Self-Tuning Entity Matching ): STEM [36] is a hybrid framework supporting the automatic construction of entity matching strategies. The framework addresses the problem of how to automatically configure and combine several matchers using numerical combination approaches. Several training-based numerical combination approaches are supported utilizing the SVM, decision trees, logistic regression and their combination. Different similarity measures are available for attribute value matching. Besides manual training selection two strategies for automatic training are supported: Threshold-Equal and Threshold-Random. With Threshold-Random entity pairs are randomly selected among the ones satisfying a given min-imal threshold t applying a similarity measure m , whereas Threshold-Equal selects an equal number ( n /2) of matching and non-matching pairs from the ones satisfying a given minimal threshold t applying a similarity measure m .
Context Based Framework : The Context Based Framework [16] is a graph-based hybrid framework supporting a two stage training-based numerical combination approach. The first stage tunes attribute value and context matchers using mainly
SMOreg, a support vector regression approach. At the second level a second learner, e.g., logistic regression is applied to determine a combination of the tuned matchers from the previous step. The Context Based Framework utilizes a canopy-like technique for blocking. Methods for training selection are not supported. Manually labeled training samples have to be pro-vided for both stages of the combination approach. 4. Evaluation comparison
In this section we compare the published evaluations of the considered frameworks. Table 3 summarizes the evaluations. 4.1. Comparison criteria To compare the evaluations of entity matching frameworks we consider the following criteria:
Type of test problems: Test problems may involve real-world data sources or may be artificially generated. # Domains/# Sources/# Tasks: How many domains, sources and match tasks are considered? Semantic entity types: What kinds of match problems have been solved? Min/Max # Entities: What is the minimum/maximum number of entities involved in a match task? Min/Max # Attributes: What is the minimum/maximum number of attributes used for solving a match tasks?
Used Matchers: Which matchers (similarity functions) have been used? # Training examples: How many examples were used for training?
Blocking performance measures: For the evaluation of blocking techniques three measures have been proposed: pairs com-pleteness, reduction ratio and F -score. Pairs completeness ( PC ) indicates which share of the truly matching entity pairs are preserved after blocking. PC thus corresponds to a recall measure and a high value is important for effectiveness. The reduction ratio ( RR ) measure indicates the fraction of all possible entity pairs which is eliminated by blocking; it indicates how far the search space is reduced and thus efficiency is improved. F -score combines pairs completeness ( PC ) and reduc-tion ratio ( RR ) via a harmonic mean, F -score  X  2 PC RR
Effectiveness measures (achieved max. values): The effectiveness of entity matching is commonly determined with the stan-dard measures precision ( P ), recall ( R ), and F -measure with respect to a manually determined  X  X  X erfect X  result. Alternative, an accuracy measure ( A ) is being used. These measures are formally defined as follows. The set of derived correspondences is comprised of True Positives ( TP ) and False Positives ( FP ), i.e., correctly and falsely proposed matches. False Negatives ( FN ) are true correspondences that have not been identified, while True Negatives ( TN ) are false matches which have been correctly discarded. Precision is defined as P  X  j TP j j TP j X j FP j measures.

Efficiency measures: The efficiency is commonly determined in terms of the execution time ( ET ). For training-based approaches the training time ( TT ) has to be considered additionally.The values in parentheses in Table 3 give the reported value ranges for the considered efficiency measures. 4.2. Comparison
Table 3 gives a summary about the evaluations of the considered frameworks as reported in the corresponding research papers. All frameworks offer a selection of matchers and combination approaches resulting in a huge number of possible configurations. Since it is impossible to exhaustively explore the configuration space, the reported evaluations cover only a restricted choice of configurations.

The summarized results indicate a substantial diversity between the different studies. The evaluations employ up to se-ven test problems from one to five domains. Popular domains for evaluation are the bibliographic, E-commerce and personal data domains. Some test problems from the RIDDLE repository (e.g., Cora, Restaurant) are used in the evaluations of five frameworks (Active Atlas, MARLIN, Operator Trees, FEBRL and STEM). Moreover, MOMA and STEM consider the same biblio-graphic match tasks DBLP X  X oogle Scholar and DBLP X  X CM. Most test problems are small and deal only with a few 100 enti-ties; the largest test problem used in the evaluations matches 100,000 entities. All frameworks are evaluated on real-world test problems; the evaluations of BN, FEBRL and TAILOR additionally utilized artificially created test problems. While the use cially for very large datasets. Moreover, real datasets are highly different in match difficulty making it problematic to gen-eralize findings to other datasets. Artificially created match problems allow for more controlled test conditions for arbitrary many entities. However, artificially introduced errors are not domain-specific, do not necessarily cover all error types, and their distribution might be unrealistic.

Up to 18 attributes are considered for solving a given entity matching task. Most commonly the used attribute value matchers are based on the string similarity measures edit distance, (exact) equality, Jaro X  X inkler and TF X  X DF. From the large selection of 26 different similarity measures available for attribute value matching with FEBRL only two are used in the eval-uation. For the evaluation of TAILOR it is unclear which of the five supported similarity measures are applied in the evaluation.

The effectiveness of the frameworks is commonly evaluated in terms of precision, recall, and F -measure. The weaker accu-racy measure has been used in the evaluations of Active Atlas, the Multiple Classifier System and TAILOR. As expected the reported effectiveness values are typically high. However, these values do not allow a representative comparison of the rel-ative effectiveness of the frameworks due to the high diversity of the test problems and employed evaluation methodology (e.g., different measures, training sizes, etc.).

Efficiency is evaluated for six of the 11 frameworks, mostly by measuring the execution times for matching (SERF, Multi-ple Classifier System, Operator Trees, Context Based System, FEBRL). For three training-based frameworks (Context Based System, Multiple Classifier System and Operator Trees) the time needed for training is reported.

The evaluations concerning blocking methods are rather unsatisfying so far. Only for FEBRL and TAILOR different blocking methods are compared in terms of reduction ratio, pairs completeness and F -score on artificial test problems. Experimental comparisons of blocking algorithms on real-world test problems are missing.

The influence of training selection is an important issue in evaluating training-based frameworks. Unfortunately, some evaluations provide few details on the selection (Context Based System, Multiple Classifier System, Operator Trees and TAI-
LOR) and size of training data (FEBRL). Four of the eight training-based frameworks (Active Atlas, FEBRL, MARLIN and STEM) have investigated the issue of training selection and evaluated (semi-)automatic approaches. The influence of different train-ing-set sizes is investigated for Active Atlas, MARLIN, Operator Trees, STEM and TAILOR. In the evaluation of the Multiple
Classifier System a relatively large amount of training data is used thus favoring good match quality at the expense of a high manual effort for labeling.

In the following, we briefly discuss selected evaluation details for each framework. A summary of the effectiveness per-formance is given for those frameworks where the evaluation reported F -measure values. 4.2.1. Frameworks without training BN : The evaluation considered artificial as well as real-world datasets on movies and CDs (IMDB, IMDB+FilmDienst,
FreeDB). The evaluation investigated the impact of the choice of the threshold on effectiveness, the impact of data quality matiX [57], a previously proposed XML entity matching framework. In the evaluation all attribute values are considered as textual strings and edit distance is used for similarity computation. The framework achieved high precision and recall values in all cases.

MOMA (mapping-based object matching) : The authors evaluated the framework on match tasks from the bibliographic do-main. The evaluation considered three data sources (Google Scholar, DBLP and ACM Digital Library) and matching tasks for publications, authors, and venues. The combination of several matchers and mappings was shown to compensate weak-nesses of individual strategies; the neighborhood matcher proved to be very valuable. Table 4 gives a summary of the max-imal effectiveness performance reported for MOMA on five considered match tasks.

SERF (Stanford Entity Resolution Framework) : The evaluation regarded comparison shopping and hotel datasets from Ya-hoo. Two manually defined match strategies were used for the evaluation. The evaluation considered the efficiency in terms of the runtimes of the match strategies. The runtime results mainly depend on the number of attribute value comparisons.
The most dominant factor of the runtime for any algorithm compared in the evaluation turns out to be the total time for comparing string values. 4.2.2. Training-based frameworks
Active Atlas : The evaluation considered three datasets involving restaurants, companies and airports. The evaluation com-pared decision tree learning for rule-based matcher combination with two baseline combination approaches without train-ing. For training selection a random approach and the semi-automatic active learning were compared. The experimental results show that the training-based approaches achieve higher accuracy values than the manually specified baseline EM strategies utilizing no training. Active learning required fewer labeled examples than random training selection. MARLIN : The evaluation compared the performance of support vector machines (SVM) to decision trees revealing that SVM significantly outperform decision trees when training data is limited. Further experiments demonstrate the comparative utility of static-active, weakly labeled negative and random training selection using TF X  X DF and edit distance for attribute value matching and SVM as the learner. The highest performance was achieved when training data is a mix of examples se-lected using the static-active strategy and randomly chosen entity pairs. In situations where human labeling of negatives is expensive or infeasible (e.g., due to privacy issues), using weakly-labeled non-duplicates is found to be valuable for automatic acquisition of negative examples. Table 5 gives a summary of the maximal effectiveness performance reported for TAILOR on the four considered match tasks.
 gers) from a single domain. The dataset consisted of 25,000 passenger pairs of which 5000 where matching pairs. Various experiments compare accuracy, training time and matching time of different training-based combination approaches. For training a relatively large amount of training data is used (66% of the 25,000 examples) thus favoring good match quality however at the expense of a high manual overhead for labeling.

Operator Trees : The evaluation considered several datasets from different domains: organization names and addresses, personal data of hurricane evacuees, and three datasets from the RIDDLE repository (Cora, Restaurant and Bird). The ap-proach is compared with a domain specific address cleansing solution as well as with the SVM. On the evacuees dataset the SVM offers better recall at higher precision. However, at lower precision the recall of Operator Trees is close to that of SVMs. Therefore, the authors propose to use Operator Trees as an efficient filter (with low target precision) before invoking
SVMs. On the smaller RIDDLE datasets, the recall values achieved by operator trees are comparable to that of the SVM at the
DBMS-based Operator Tree implementation executes significantly faster than SVM models, even if they employ blocking. 4.2.3. Hybrid frameworks
TAILOR : The evaluation compares various string similarity measures (Bigrams, Trigrams, EditDistance and Jaro) for attri-bute value matching, disjoint (sorting) and overlapping (sorted neighborhood) blocking, and matcher combination strategies utilizing training (probabilistic, decision tree and hybrid) and without training. The blocking evaluation showed no clear advantage for overlapping approaches with larger window size over disjoint methods with short key sizes. Maximum pairs completeness and reduction ratios of about 0.95 are achieved. The other evaluation results show that (i) attribute value matchers based on Jaro X  X  algorithm perform better than the other attribute value matchers. (ii) training-based approaches outperform approaches without training.

FEBRL : In Ref. [4] two disjoint (sorting and sorted neighborhood) and two overlapping (bigram indexing and canopy clus-tering) blocking methods are compared in terms of reduction ratio, pairs completeness and F -score on artificial test problems with varying entity sizes. Both bigram indexing and canopy clustering outperform the two disjoint blocking methods with the right parameter settings. Pairs completeness with the two disjoint methods had a maximum of about 0.96, whereas the maximum for canopy clustering with TF X  X DF is 0.98. Canopy clustering also achieved the best reduction ratio of 0.9 and best
F -score of over 0.98. However, the method seems highly dependent on the choice of the threshold. With a suboptimal choice pairs completeness drops to 0.8. The evaluation in [17] evaluates the threshold and the nearest-based training selection methods. The evaluations showed that a SVM-based matcher combination with automatic training selection is often better than a numeric matcher combination without training. Table 6 gives a summary of the effectiveness performance reported for FEBRL on four considered match tasks.
 STEM : The evaluation compares various string similarity measures (Cosine, EditDistance, Jaccard, Jaro X  X inkler, Monge-Elkan, TF-IDF and Trigram), matcher combination strategies utilizing training (decision tree, SVM, logistic regression and multiple learning) and manually configured strategies. The evaluation is performed for different training sizes and four match tasks. The evaluation shows that the automatically constructed EM strategies can significantly outperform manually configured combined strategies. This is especially true for difficult match tasks and often possible for small training sizes, thereby requiring a low labeling effort. The evaluation of several learners revealed that the SVM and the multiple learning approach produce the most stable results even for small training sizes. By contrast decision trees perform well only for large amounts of training data. Table 7 gives a summary of the effectiveness performance reported for STEM on the four consid-ered match tasks. Comparing the results for STEM with MOMA, we observe that the training-based STEM could outperform
MOMA for the DBLP X  X oogle Scholar task ( F -measure 0.92 vs. 0.89) but was less effective for DBLP X  X CM ( F -measure 0.96 vs. 0.99) since it did not utilize context matching such as MOMA. STEM achieved a higher F -measure for the restaurant task (from the RIDDLE repository) than Marlin (0.97 vs. 0.92). However, these singular performance observations cannot be gen-eralized to other test cases.

Context Based Framework : The evaluation considered match tasks from two domains, personal webpages and biblio-graphic references (publications, authors, departments and organizations). The authors compare various attribute value and context matchers (eTFIDF, connection strength), matcher combination strategies utilizing training (mainly SMOreg, Lo-gistic) and manually configured strategies. The evaluation shows that matcher combination strategies considering context and utilizing training can outperform manually configured combined strategies. Effectiveness performance measured in terms of F -measure range between 0.599 and 0.89 on the personal webpages task. Training times differ depending on the utilized learner from 0.11 s to 53.66 s. The application times range from less then 1 s to less than 5 s depending on the size of the dataset. 5. Summary and discussion
Entity matching frameworks allow the combined use of blocking and multiple matcher algorithms to effectively solve diverse match tasks. They have to meet challenging and partly contradicting requirements, in particular high effectiveness, efficiency, genericity and low manual effort. To assess the current state of art we comparatively analyzed the functionality and published evaluation results of 11 proposed research prototypes for entity matching. The comparisons are based on a common set of criteria. Criteria for the functional comparison include the supported choices for blocking methods, matchers, combination of matchers, and training selection. Criteria for the evaluation comparison consider the used test problems, ap-plied match strategies and the achieved effectiveness and efficiency performance. The proposed criteria have value beyond the systems considered here but should enable to categorize and comparatively assess further entity matching frameworks and their evaluations.

Our study indicates a research trend towards using supervised (training-based) and hybrid approaches to semi-automat-ically determine an EM strategy for a given match task. Most of the considered frameworks including the most recent ones,
Operator Trees and the Context Based Framework, employ supervised learners to derive numerical combination functions or match rules specifying how multiple matchers should be combined for deriving a match decision. Hybrid frameworks pro-vide the largest scope of methods for solving entity matching tasks, in particular for blocking and the combined use of several matchers. Among the considered hybrid frameworks, FEBRL offers the largest selection of different blocking strategies and attribute value matchers, while the Context Based Framework supports the largest number of learners as well as context matching. Unfortunately, the flexibility of the hybrid frameworks comes at the price of an increased complexity for users to choose an appropriate method (selection of matchers to be considered, size and selection of training data)  X  despite the use of supervised machine learning approaches.

The functional comparison reveals a number of further research directions. All frameworks focus on offline matching, i.e., they do not yet cover online matching. The definition of the blocking key is not yet derived (semi-)automatically from train-ing data but has to be specified manually in all considered frameworks. While attribute value matchers are well supported the combination of context and attribute matchers is not and should be further studied. Training-based EM frameworks should provide more support for (semi-)automatic selection of suitable training data with low labeling effort. So far train-ing-based approaches only helped to optimize some decisions, e.g., determining parameters for matchers (e.g., similarity thresholds) and combination functions (e.g., weights for matchers) while other decisions (e.g., selection of the similarity functions and attributes to be evaluated) still have to be determined manually.

The published framework evaluations used diverse methodologies, measures, and test problems making it difficult to assess the effectiveness and efficiency of each single system. While the reported evaluation results are usually very positive, the tests so far mostly dealt with small match problems so that the scalability of most approaches is unclear. Hence, scalability to large test cases needs to be better addressed in future frameworks. Some recent work regarding scalability has focused on computational aspects of string similarity computation [50,1,30,61] and time-completeness trade-offs [39]. Fur-thermore, we see a strong need for comparative performance evaluations of different frameworks and EM strategies. Stan-dardized benchmarks for entity matching are needed for comparative investigations; first proposals exist [44,58] but have not yet been implemented or applied. Published evaluation results should also be reproducible by other researchers, ideally by providing the prototype implementations and test data.

References
