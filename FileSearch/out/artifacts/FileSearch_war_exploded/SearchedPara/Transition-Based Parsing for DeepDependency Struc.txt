 Peking University Peking University Peking University Peking University can be derived from linguistic analysis grounded by CCG , conduct experiments on CCG -grounded functor X  X rgument analysis, disambiguation. 1. Introduction ( bilexical dependencies. Under CCG ,thisisdonebyrelatingthelexicalheadsoffunctor categories and their arguments (Clark, Hockenmaier, and Steedman 2002). Under as  X  X rink. X  study on applying transition-based methods to generate HPSG be produced by augmenting existing transition systems.
 354 in boosting accuracy (Sagae and Lavie 2006; Zhang et al. 2009; McDonald and Nivre study on various ensemble models for dependency tree parsing. They found that the transition system X  X amely, Titov et al. (2009) X  X  system ( to build a better hybrid system.
 models to semantics-oriented deep dependency structures, for example, functor X  X rgument analysis and HPSG -grounded reduced minimal recursion semantics ( experiments on CCG -grounded functor X  X rgument analysis (Hockenmaier and Steedman 2014), and HPSG -grounded semantic dependency analysis (Miyao, Ninomiya, and ichi some non-obvious facts: 1. Data-driven models with appropriate transition systems and 2. Parsers built upon heterogeneous tra nsition systems and decoding orders 3. Transition combination significant ly improves parsing accuracy on a wide 4. Pseudo trees contribute to semantic dependency parsing (SDP) equally
Tsujii 2008; Auli and Lopez 2011b; Martins and Almeida 2014; Xu, Clark, and Zhang 2008; Auli and Lopez 2011b), and outperform a shift-reduce based approach.
 lcwm/grass . 2. Transition Systems for Graph Spanning 2.1 Background Notations w , ... , w 1. V = { 0, 1, 2, ... , n } , 2. A  X  V  X  R  X  V . 356 both labeled and unlabeled parsing models.
 quadruple S = ( C , T , c s , C t ), where 1. C is a set of configurations, each of which contains a buffer 2. T is a set of transitions, each of which is a (partial) function t : 3. c s is an initialization function, mapping a sentence x to a configuration 4. C t  X  C is a set of terminal configurations.
 of transitions t 1 , ... , t m and a sequence of configurations c t ( c i  X  1 ) = c i ( i = 1, ... , m ), c m  X  C t ,and A c oracle sequence. And we define  X  A c denote a transition sequence as either t 1, m or c 0, m .
 and partially built structures are organized by a stack. A set of S are performed sequentially to consume words from the queue and update the partial behaviors of transition actions. 2.2 Naive Spanning and Locality connected by an arc. Accordingly, a  X  X aive X  spanning algorithm can be implemented modified by Nivre (2008).
 pair of words. L EFT -A RC (  X  | i , j |  X  )  X  (  X  | i , j |  X  ) R IGHT -A RC (  X  | i , j |  X  )  X  (  X  | i , j |  X  ) S HIFT (  X  , j |  X  )  X  (  X  | j ,  X  ) P OP (  X  | i ,  X  )  X  (  X  ,  X  ) S WA P (  X  | i | j ,  X  )  X  (  X  | j , i |  X  ) S WA P T (  X  | i | j ,  X  )  X  (  X  | j | i ,  X  ) 2.3 System 1: Online Re-ordering in Titov et al. (2009) and Nivre (2009), is to allow a S WA P respect to the class of all directed graphs without self-loop. 2.3.1 The System. We define a transition system S S = ( C c = (  X  ,  X  , A )  X  C contains a stack  X  of nodes, besides  X  ration for a sentence x = w 1 , ... , w n to be c s ( x ) set of all configurations of the form c t = (  X  , [], A ) (for any shown in Figure 2 and explained as follows.
 358 THMM ), see Titov et al. (2009). We also denote Titov et al. (2009) X  X  system as S considered. The idea is inspired by Titov et al. (2009). Given a sentence x b be the front of  X  c node j  X   X  c linked to p in  X  A c is any node q under the top of  X  c in Figure 3. Let c i = t i ( c i  X  1 ); we continue to compute t Lemma 1
If t i is sh , L (  X  c Proof
It cannot be the case that for some u &gt; 0, L ( j u ) strictly precedes L ( j be sw . It also cannot be the case that for some u &gt; v because when j v  X  1 is shifted onto the stack, L ( j v )precedes L ( j do not change L ( j v )and L ( j u )afterwards.
 Lemma 2
For i = 0, ... , m , there is no arc ( j , k )  X   X  A c Proof
When j  X   X  c ( j , k )or( k , j )in  X  A c only link to nodes in  X  c ical orders, and from Lemma 1 the top of  X  c ra should be applied.

Theorem 1 t , ... , t Proof
From Lemma 2, we can infer that  X  A c transitions is always finite. We define a swap sequence to be a subsequence t types t in the sequence, then #( la ), #( ra ), #( pop ), and #( sh ) finite. 2.4 System 2: Two-Stack X  X ased System complete with respect to the class of d irected graphs without self-loop. 2.4.1 The System. We define the two-stack X  X ased transition system S where a configuration c = (  X  ,  X  ,  X  , A )  X  C contains a primary stack stack  X  .Weset c s ( x ) = ([], [], [1, ... , n ], {} ) for the sentence x R L EFT -A RC (  X  | i ,  X  , j |  X  )  X  (  X  | i ,  X  , j |  X  ) R IGHT -A RC (  X  | i ,  X  , j |  X  )  X  (  X  | i ,  X  , j |  X  ) S HIFT (  X  ,  X  , j |  X  )  X  (  X  | j ,  X  ,  X  ) P OP (  X  | i ,  X  ,  X  )  X  (  X  ,  X  ,  X  ) M EM (  X  | i ,  X  ,  X  )  X  (  X  ,  X  | i ,  X  ) R ECALL (  X  ,  X  | i ,  X  )  X  (  X  | i ,  X  ,  X  ) 360 and pop transitions just like in Section 2.3.2. After that, let b be the front of if there is j  X   X  c sequence of mem to make j the top of  X  c make j the top of  X  c Theorem 2
S 2 S is complete with respect to direc ted graphs without self-loop. Proof finite, and every time a node is shifted onto  X  c shifted node. dependency parsing problem. Different from their system, our new system maximizes the utility of two memory modules and is able to handle any directed graphs. extended one introduced by Choi and Palmer (2011), also use two memory modules. lists is to simulate one memory module that allows accessing any unit in it. 2.5 Extension graphs by adding a new transition: Theorem 3 S L can parameterize the S HIFT transition with tag labels. 3. Statistical Disambiguation 3.1 Transition Classification based statistical parser tries to find the transition sequence c following score configuration and a transition, as follows: where  X  defines a vector for each configuration X  X ransition pair and for linear combination.
 of parser in the discriminative se tting corresponds to estimating in Zhang and Clark (2008, 2011b). 3.2 Transition Combination A any two words, therefore an A RC transition is not followed by another A 362 L EFT -A RC (  X  | i ,  X  , j |  X  )  X  (  X  | i ,  X  , j |  X  ) R IGHT -A RC (  X  | i ,  X  , j |  X  )  X  (  X  | i ,  X  , j |  X  ) S HIFT (  X  ,  X  , j |  X  )  X  (  X  | j ,  X  ,  X  ) P OP (  X  | i ,  X  ,  X  )  X  (  X  ,  X  ,  X  ) M EM (  X  | i ,  X  ,  X  )  X  (  X  ,  X  | i ,  X  ) R ECALL (  X  ,  X  | i ,  X  )  X  (  X  | i ,  X  ,  X  )
L EFT -A RC -S HIFT (  X  | i ,  X  , j |  X  )  X  (  X  | i | j ,
L EFT -A RC -P OP (  X  | i ,  X  , j |  X  )  X  (  X  ,  X  , j |  X 
L EFT -A RC -M EM (  X  | i ,  X  , j |  X  )  X  (  X  ,  X  | i , j
L EFT -A RC -R ECALL (  X  | i ,  X  | i , j |  X  )  X  (  X  | i |
R IGHT -A RC -S HIFT (  X  | i ,  X  , j |  X  )  X  (  X  | i | j ,
R IGHT -A RC -P OP (  X  | i ,  X  , j |  X  )  X  (  X  ,  X  , j |  X 
R IGHT -A RC -M EM (  X  | i ,  X  , j |  X  )  X  (  X  ,  X  | i , j
R IGHT -A RC -R ECALL (  X  | i ,  X  | i , j |  X  )  X  (  X  | i obtain the transitions presented in Figure 5.
 there are two edges between two words w a and w b ,itmustbe w A) Add a new type of transitions to each system, which consist of a L
B) Use a non-directional A RC transition instead of L EFT
Algorithm 1 encode label 1: procedure E NCODE L ABEL ( type , lLabel , rLabel ) 2: if type == L EFT then 3: return  X  left  X  + lLabel 4: else if type == R IGHT then 5: return  X  right  X  + rLabel 6: else 7: return  X  both  X  + lLabel +  X  |  X  + rLabel 8: end if 9: end procedure
Algorithm 2 decode combined label, return a pair of left label and right label 1: procedure D ECODE L ABEL ( label ) 2: if label . startswith ?( X  left  X ) then 3: return { label [4 :], nil } 4: else if label . startswith ?( X  right  X ) then 5: return { nil , label [5 :] } 6: else 7: return { label [4 : label . index ( | )], label [( label 8: end if 9: end procedure performance decreases when using more transitions.
 us eliminate the invalid calculation and save time effectively. A RC transition instead of L EFT /R IGHT -A RC (label) X  X on-A we encode two-cycle labels, but also L EFT /R IGHT -A performance loss.
 derived as follows: 364
Algorithm 3 Oracle generation for the THMM system 1: procedure E XTRACT O NE O RACLE ( c , A gold , label ) 2: if c = (  X  | i , j |  X  , A )  X  X  X  k [ k j  X  X  X  l [( i , l , k ) 3: if label = nil then 4: return R EDUCE 5: else 6: return A RC ( label )  X  R EDUCE 7: end if 8: else if c = (  X  | i , j |  X  , A )  X  X  X  l [( i , l , j )  X  9: A gold  X  A gold  X  ( i , l , j ) 10: return E XTRACT O NE O RACLE ( c , A gold , label ) 11: else if c = (  X  | i 1 | i 0 , j |  X  , A )  X  X  X  k 0 k 1 [ k 12: if label = nil then 14: else 15: return A RC ( label )  X  S WA P 16: end if 17: end if 18: if c = (  X  , j |  X  , A ) then 19: if label = nil then 21: else 22: return A RC ( label )  X  S HIFT 23: end if 24: end if 25: return nil 26: end procedure We want to emphasize that, although the E XTRACT O E an A RC (label) X  X on-A RC transition and assign a value for that 3.3 Feature Design with stack  X  and buffer  X  , we denote the top two nodes in the top element of  X  is denoted by  X  0 and the front of  X  of node n is denoted by n . lc , the right-most one by n .
Algorithm 4 Oracle generation for the online re-ordering system 1: procedure E XTRACT O NE O RACLE ( c , A gold , label ) 2: if c = (  X  | i , j |  X  , A )  X  X  X  k [ k j  X  X  X  l [( i , l , k ) 3: if label = nil then 4: return R EDUCE 5: else 6: return A RC ( label )  X  R EDUCE 7: end if 8: else if c = (  X  | i , j |  X  , A )  X  X  X  l [( i , l , j )  X  9: A gold  X  A gold  X  ( i , l , j ) 10: return E XTRACT O NE O RACLE ( c , A gold , label ) 11: else if c = (  X  | i , j |  X  , A )  X  X  X  i [ i &lt; i  X  i 12: if label = nil then 14: else 15: return A RC ( label )  X  S WA P 16: end if 17: end if 18: if c = (  X  , j |  X  , A ) then 19: if label = nil then 21: else 22: return A RC ( label )  X  S HIFT 23: end if 24: end if 25: return nil 26: end procedure the tree between two nodes. Given two nodes n 1 and n 2 ,wedenotethepathfeatureas path ( n 1 , n 2 ) and the coarse-grained path feature as cpath ( n node n is denoted as n . h .
 template functions. All feature templates are described here. 366
Algorithm 5 Oracle generation for the two-stack X  X ased system 1: procedure E XTRACT O NE O RACLE ( c , A gold , label ) 2: if c = (  X  | i ,  X  s , j |  X  , A )  X  X  X  k [ k j  X  X  X  l [( i , l , k ) 3: if label = nil then 4: return R EDUCE 5: else 6: return A RC ( label )  X  R EDUCE 7: end if 8: else if c = (  X  | i ,  X  s , j |  X  , A )  X  X  X  l [( i , l , j ) 9: A gold  X  A gold  X  ( i , l , j ) 10: return E XTRACT O NE O RACLE ( c ,  X  s , A gold , label ) 11: else if c = (  X  | i ,  X  s , j |  X  , A )  X  X  X  i [ i &lt; 12: if label = nil then 13: return M EM 14: else 15: return A RC ( label )  X  M EM 16: end if 17: else if c = (  X  | i ,  X  s | i s , j |  X  , A ) then 18: if label = nil then 20: else 21: return A RC ( label )  X  R ECALL 22: end if 23: end if 24: if c = (  X  ,  X  s , j |  X  , A ) then 25: if label = nil then 27: else 28: return A RC ( label )  X  S HIFT 29: end if 30: end if 31: return nil 32: end procedure f
X . w , X . p , X . w  X  X . lp . l , X . w  X  X . rp . l , X .
X . w  X  X . lc . a , X . w  X  X . rc . a , X . w  X  X . p . a , X
X . rc . set , X . p  X  X . rc . set g
X . w , X . p , X . w  X  X . lp . l , X . p  X  X . lp . l , X .
X . lc . a , X . p  X  X . lc . aX . w  X  X . lc . set , X . p  X  f
X
X f
X . wp  X  Y . wp , X . wpY . w , X . wp  X  Y . p , X . w  X  Y . wp , X
X . p  X  Y . p f
X . wp  X  Y . wp , X . wpY . w , X . wp  X  Y . p , X . w  X  Y . wp , X
Y . w , X . p  X  Y . p , X . w  X  Y . w  X  X . rc . a , X . w  X  Y
X , Y . d , X . w  X  Y . p  X  X , Y . d , X . p  X  Y . w  X  X , Y
X . p  X  Y . p  X  Y . lc . set f
X . w  X  Y . p  X  Z . p , X . p  X  Y . w  X  Z . p , X . p  X  Y . p f
X . w  X  Y . p  X  Z . p  X  X , Z . l , X . p  X  Y . w  X  Z . p  X  X , Z
Z . p  X  X , Z . l f
X . p  X  Y . p  X  Z . p  X  W . p  X  X , Z . l  X  X , W . l f
X , Y . path , X , Y . cpath , X . p  X  Y . p  X  X . tp . w , X
Y . p  X  Y . tp . w , X . p  X  Y . w  X  Y . tp . p , X . w  X  Y . f
X 4. Tree Approximation 368 analysis (Miyao, Ninomiya, and ichi Tsujii 2004), and reduction of defined in Section 3.3) to incorporate syntactic information for disambiguation. syntactic analysis.
 determine which edges are to be kept by finding the maximum spanning tree. More formally, given a set of nodes V , each possible edge ( i , j ), where i , j heuristic weight  X  ( i , j ). Among all trees (denoted as tree T max contains the maximum sum of values of edges: defined here.
 condition holds for semantic dependency parsing. 5. Empirical Evaluation 5.1 Set-up
CCG -style functor X  X rgument analysis, LFG -style grammatical relation analysis, and transition-based deep dependency parsing models.
 the same phenomenon, annotation schemes may not agree with each other. Take the different data sets, please refer to Ivanova et al. (2012). (Hockenmaier and Steedman 2007; Tse and Curran 2010). Following previous experi-Flickinger 2000), and manually disambiguated. As part of the full argument structures are concerned. Different from DeepBank but similar to CCGBank 370 (a) Format 1: Propositional semantics, from PropBank.
 (b) Format 2: MRS -derived dependencies, from DeepBank HPSG (c) Format 3: Predicate-argument structures, from Enju HPSG (d) Format 4: Functor-argument structures, from CCGBank.

DeepBank and EnjuBank data sets are from SemEval 2014 Task 8 (Oepen et al. 2014), data sets for experiments.
 tagger 3 (SR-HMM; Huang, Harper, and Petrov 2010). Experiments for English Chinese CCGBank and GRBank, we use gold-standard POS tags. graphs is precision and recall of tokens that are defined as w 5.2 Parsing Efficiency 372 use a grammar. 5.3 Importance of Transition Combination modified by every transition.
 utilize the transition combination strategy. 5.4 Model Diversity and Parser Ensemble
B , we define the following metric: directions yield quite different parsing results. forparserensemble.Foreachpairofwordsineachsentence,wecountthenumberof the arc with the most common label of what the models give. efficiently. 5.5 Impact of Syntactic Parsing sive evaluation presented in Punyakanok, Roth, and Yih (2008) and Zhuang and Zong 374 the performance gap will be larger.
 informative features lead to on average 1.14% and 1.03% absolute improvements for
English and Chinese CCG parsing. Compared with SRL, the improvement brought by predicates and their nominalization, whereas the semantic graphs grounded by generated by a syntactic parser much more than semantic dependency parsing. 376 (2011), and the second one is a second-order graph-based parser and Chinese CCGBank data. For both English and Chinese experiments, 5-fold cross and McDonald 2008; Torres Martins et al. 2008). 5.6 Effectiveness of Tree Approximation approximation, we compare the contribution to semantic dependency parsing of syn-
As a result, the final graph parsing benefits less. 378 ensemble is still helpful, thou gh the improvement is limited. English 93.48% 93.47%
Chinese 80.97% 80.81% 5.7 Comparison with Other Parsers two different architectures.
 380 382 information only to achieve h igh-accuracy semantic parsing. results on all sentences, which is achieved b yEnjuParser.FromTable9,wecanclearly of the annotation styles. Though both corpora are based on more when fewer output edges are targeted. The two approaches achieve equivalent performance for CCG parsing. 6. Related Work are typically related to a particular co mputational linguistic theory (e.g., 384 architecture has been implemented for CCG parsing (Zhang and Clark 2011a; Ambati dependency structures.

Such approaches, for example, transition-based (Yamada and Matsumoto 2003; Nivre 2008) and graph-based (McDonald 2006; Torres Martins, Smith, and Xing 2009) mod-principled dynamic programming strategies have been used to explore more possible hypotheses (Zhang and Clark 2008; Huang and Sagae 2010). When we implement our accuracy.
 ate dependency graphs in which a word may depend on multiple heads, and evaluated have been introduced in Martins and Almeida (2014) and Du, Sun, and Wan (2015). 7. Conclusion dealing with complex linguistic phenomena beyond surface syntax. transition-based parsers can provide practical solutions to these tasks. Acknowledgments References 386 388
