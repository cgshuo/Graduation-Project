 Mining frequent closed items ets provides complete and condensed information for non -redundant association rules generation. Extensive studies ha ve been done on mining frequent closed itemsets, but they are mainly intended for traditional characteristics into consideration. In this paper, we propose a novel approach for mining closed frequent itemsets over data streams. It computes and maintains closed itemsets online and incrementally, and can output the current closed frequent itemsets in real time based on users X  speci fied thresholds. Experimental results show that our proposed method is both time and space efficient, has good scalability as the number of transactions processed increases and adapts very rapidly to the change in data streams. H.2.8 [ Database Management ]: Database Applications  X  Data Mining. Algorithms, Performance, Experimentation. Data stream, frequent closed itemsets, association rules. Frequent closed itemsets provi de complete and condensed information for non-redundant a ssociation rules generation. Recently, much research has been done on closed itemsets mining multiple scans are needed, and when ever new transactions arrive, additional scans must be performed on the updated transaction database; therefore, they are not suitable for data stream mining. databases, data streams have th e following characteristics. First, they are continuous, unbounded, and usually come with high speed. Second, the volume of data streams is large and usually changes with time. rapidly, such as web transacti ons, telephone records, and network flows, much research on how to get frequent patterns in a data stream environment has been conducted. In [2, 7, 10], the authors propose algorithms to find frequent itemsets over the entire history of data streams. In [3 , 5, 8], different sliding window models are used to find recently frequent itemsets in data streams. These algorithms focus on mining frequent itemsets, instead of closed frequent itemsets, with one scan over entire data streams. closed frequent itemsets over a da ta stream sliding window. The algorithm maintains a dynamically selected set of itemsets which includes four types of nodes: infrequent gateway nodes, unpromising gateway nodes, inte rmediate nodes, and closed nodes. For each node, the itemset itself, node type, support and sum of the ids of the transacti ons in which the itemset occurs (tid_sum) are stored. These se lected itemsets form a boundary between closed frequent itemsets and the rest of the itemsets. When a new transaction arrives, it checks the closed frequent itemsets stored in a hash tabl e with its support and tid_sum properties and incrementally updates the associated nodes X  information. Moment judges th e closed itemsets indirectly through node property checking and excludes them from the other three types of boundary nodes stored in the data structure. It stores much more information other than the current closed frequent itemsets, which consum es much memory, especially when the support threshold is low. Furthermore, the exploration and node type checking are time consuming. directly compute closed itemsets online and incrementally without the help of any support informati on. Nothing other than closed itemsets is maintained in our derived data structure. When a new transaction arrives, it performs the closure checking on the fly; only associated closed itemsets and their support information is incrementally updated. This achieves both time and space efficiency, especially when a dataset contains highly correlated transactions. The current closed frequent itemsets can be output in real time based on any user X  X  specified thresholds. We then evaluate the performance of our proposed algorithm. formally defines the concept of closed itemsets and describes the notations to be used throughout th e paper. Section 3 presents our proposed CFI-Stream algorithm. The performance evaluation is depicted in Section 4. Finally, Section 5 concludes the paper. X  X  I is called an itemset. A k-subset is called a k-itemset. Each contain X. appearing in a data stream D, respectively. The concept of a belonging to T, while function g returns the set of transactions containing a given itemset X. Definition 1 An itemset X is said to be closed if and only if C(X) called a Galois operator or a closure operator. X is an itemset whose closure C(X) is equal to itself (C(X) = X). closed itemset. In this section, we present our proposed CFI-Stream algorithm and in-memory data structure, calle d DIrect Update (DIU) tree, to perform the closure checking onlin e over a data stream sliding window. We first give an overv iew of CFI-Stream. Then, we discuss the conditions that we need to check for closed itemsets and how we check for them when performing addition and deletion operations on the DIU tree. Based on this, we develop an online algorithm to discover and incrementally update closed itemsets. When a transaction arrives or leaves the current data stream sliding window, the algorithm checks each itemset in the transaction on the fly and updates the associated closed itemsets X  supports. Current closed itemsets are maintained and updated in real time in the DIU tree. The closed frequent itemsets can be DIU tree. current closed itemsets. Each node in the DIU tree represents a stores the closed i-itemsets, where k is the maximum length of the current closed itemsets. Each node in the DIU tree stores a closed itemset, its current support inform ation, and the links to its immediate parent and children nodes. Figure 1 illustrates the DIU figure shows that currently there are 4 closed itemsets, C, AB, CD, and ABC in the DIU tree, and their associated supports are 3, 3, 1, and 2. Figure 1. The lexicographica l ordered direct update tree require multiple scans over data [9, 11-13], our proposed method performs the closure checking on th e fly with only one scan over data streams. It updates only the s upports of the associated closed itemsets in the DIU tree online, which reduces the computation incremental algorithm where we check for closed itemsets and update their associated supports based on the previous mining approaches that rescan and regenerate all closed itemsets when a new transaction arrives. 10], we store only the information of current closed itemsets in the DIU tree, which is a compact and complete representation of all itemsets and their support info rmation. The current closed frequent itemsets can be output in real time based on users X  specified thresholds by browsing the DIU tree. Also, our algorithm handles the concept-drifting problem in data streams by storing all current closed itemsets in the DIU tree from which all updated. We discuss the update of the DIU tree and the closure checking procedure for addition and deletion operations in Sections 3.2 and 3.3. DIU tree when a new transaction arrives and its closure check. First, we identify and prove the following conditions in which we need to check whether an itemset is closed or not when a new transaction t arrives in the current sliding window. Condition 1: when the newly arrived transaction t is in the original transaction set, if the largest itemset X it contains is not currently in the DIU original transaction set to see whether they are closed or not. Condition 2: when the newly arrived transaction t is not in the not. Below we prove why we only need to check for closed itemsets in the above two conditions. We will use the Lemma 1 and Corollary 1 in our following proofs. The proof of Lemma 1 is given in [9]. Corollary 1 is derived from Lemma 1. Lemma 1 Given an itemset X and an item i  X  I, g(X)  X  g(i)  X  i  X  C(X). Corollary 1 Assume C T (X) is X X  X  closure within transaction set where i  X  C T (Y), i  X  Y, then we have i  X  X and C T discuss the update and mainte nance rules under these two conditions. In the following proof, we assume X and Y are transactions after t arrives, C T1 (X) is X X  X  closure in transaction set T1, and C T2 (Y) is Y X  X  closure in transaction set T2. already exists in the original transaction set T1, we have g  X  . When g T1 (X)  X   X  , for any itemset Y, g T1 (Y) =  X  . If Y  X  X  X  g (Y)  X  g T1 (X)  X   X  . This is a contradiction with g Therefore this condition does not happen. If Y  X  X  X  g g (Y) =  X  . Thus, we do not need to discuss cases when g T1  X  . When g T1 (X)  X   X  and g T1 (Y)  X   X  , we examine cases according to the following conditions: Y  X  X and Y  X  X. When Y is a subset of X, Y  X  X, we divide it into two sub conditions to analyze: X is or is not in the DIU tree. When X is in the DIU tree, it is a closed itemset, therefore C = X. We have the following Le mmas 2 and 3. From these two lemmas, we show that if a closed itemset X which already exists in the DIU tree arrives, for any itemset Y, Y  X  X, if Y is unclosed, Y will remain unclosed, and we only need to update Y X  X  support. Therefore, for most of the existing closed itemsets, we do not need to update the DIU tree structure; we simply update their supports, which consume a small amount of time. Lemma 2 Given T2 = T1  X  {X}, if C T1 (X) = X and Y  X  X and C T1 (Y) = Y, then we have C T2 (Y) = Y. Lemma 3 Given T2 = T1  X  {X}, if C T1 (X) = X and Y  X  X and C T1 (Y)  X  Y, then we have C T2 (Y)  X  Y. When X is not in the DIU tree, it is not a closed itemset, therefore C T1 (X)  X  X. Similarly, we have the following Lemmas 4 and 5. From Lemma 4, we show that if a new closed itemset which is not the DIU tree, they will remain closed, and thus we simply need to update their supports. From Lemma 5, we show that if a new closed itemset which is not originally in the DIU tree arrives, then we need to add it as a new closed itemset to the DIU tree. Lemma 4 Given T2 = T1  X  {X}, if C T1 (X)  X  X and Y  X  X and C T1 (Y) = Y, then we have C T2 (Y) = Y. Lemma 5 Given T2 = T1  X  {X}, if C T1 (X)  X  X and Y = X, then we have C T2 (Y) = Y= X. When Y is not a subset of X, Y  X  X, we have the following Y X  X  closure does not change. That is to say that if Y is an unclosed itemset before X arrive s, then Y will remain unclosed after X arrives; and, if Y is a clos ed itemset before X arrives, then Y will remain closed after X arrives. Thus, the DIU tree structure does not need to be updated, a nd we only need to update Y X  X  support. Lemma 6 Given T2 = T1  X  {X}, if Y  X  X, then we have C = C T1 (Y). has not already appeared in the original transaction set T1, we have g T1 (X) =  X  . We discuss two sub cases according to the following conditions: Y  X  X and Y  X  X. When Y is a subset of X, Y  X  X, we divide it into two sub conditions to discuss: Y exists in the original transaction set T1 or Y does not exist in the original transaction set T1. When Y is already in the origin al transaction set T1, then g C
T2 (Y) = C T1 (Y)  X  {X}. We will perform the closure checking to decide Y X  X  closure, which will be discussed in Section 3.2.2. When Y does not exist in the original transaction set T1, then g (Y) =  X  . We have the following Lemma 7. In this lemma, we itemset in transaction set T2; and if Y  X  X, then Y is not a closed itemset in transaction set T2. Lemma 7 Given T2 = T1  X  {X}, if Y = X, then we have C T2 = Y; if Y  X  X, then we have C T2 (Y)  X  Y. is not in the original transaction set T1. If Y is already in the original transaction set T1, then g We have the following Lemma 8. Similar to Lemma 6, in this lemma we prove that when Y is not a subset of X, Y X  X  closure does not change in transaction set T2. Lemma 8 Given T2 = T1  X  {X}, if Y  X  X, then C T2 (Y) = C If Y is not in the original transaction set, then g T1 (Y) =  X  . If Y  X  X, we have g T2 (Y) = g T1 (Y) =  X  , which is meaningless to discuss. transaction arrives, for most cases, the DIU tree structure does not change and we only need to update the associated itemsets X  supports, which thus reduces the processing costs. There are only two cases that we need to perform the closure check: 1) when g g (X) =  X  , g T1 (Y)  X   X  , and Y  X  X. We will discuss how to check for closed itemsets in the following section. The CFI-Stream algorithm checks whether an itemset is closed or Below, we discuss the checking procedure when performing the addition operation on the DIU tree. In the following Theorem 1, we show that for any coming unclosed itemset Y, we can always find one and only one closed itemset in the DIU tree equal to Y X  X  closure, such that X c = C(Y). Theorem 1 For any itemset Y, if C(Y)  X  Y and g(Y)  X   X  , then we can always find one and only one closed itemset X c  X  C, where C is a set of existing closed ite msets that satisfies C(Y) = X Y  X  X c . Y, we can find X c0 with a minimum number of items in it and X  X  Y. For any other X c1  X  Y, from the above discussion we know that g(X c0 )  X  g(X c1 ). Because Y  X  X c0 , then g(Y)  X  g(X g(X c1 ). To find X c  X  C(Y), we have g(X c ) = g(Y); only X fulfill this requirement. In this way, C(Y) can be found in the original transaction set T1. Below, we show how we use this C(Y) arrives. Corollary 2 Given T2 = T1  X  {X}, if C T1 (X)  X  X and g  X  X, C T1 (Y)  X  Y, (C T1 (Y)/Y)  X  X =  X  , then we have C closed in transaction T2 or not. If (C T1 (Y)/Y)  X  {X} =  X  , then Y data streams arrives. transaction leaves the slidi ng window and its closure check. First, we identify and prove the following condition in which we need to check whether an itemset is closed or not when an old transaction leaves the current sliding window: When the number of the transactions with same itemset of X is equal to zero, if Y is a subset of X, and Y is a closed itemset in the original transaction set, we need to check whether Y is currently closed or not. Below, we prove why we only need to check for closed itemsets in the above condition. from the current sliding window, th e number of transactions with Below, we discuss the update a nd maintenance rules under these two conditions. set T 1 , and C T2 (Y) is Y X  X  closure under transaction set T When the number of transactions with the same itemset X is greater than zero, we have the following Lemma 9. From this lemma, we know that Y X  X  closure does not change when the number of transactions with the same itemset X is greater than leaves, Y will remain unclosed after X leaves; and if Y is a closed itemset before X leaves, Y will remain closed after X leaves. Lemma 9 Given T2 = T1 \ {X}, {X}  X  T2, we have C C T1 (Y). When the number of transactions with same itemset of X is equal to zero, {X}  X  T2, we discuss according to the following two sub conditions: Y is not a subset of X and Y is a subset of X. If Y is not a subset of X, we have the following Lemma 10. In this lemma, we prove that when {X} no longer exists in transaction set T2, Y is not a subset of X and Y X  X  closure does not change in transaction set T2. Lemma 10 Given T2 = T1 \ {X}, if {X}  X  T2 , then C T2 (Y) = C T1 (Y). conditions: Y is a closed itemset in transaction set T1 and Y is not a closed itemset in transaction set T1. When Y is a closed itemset in the transaction set T1, that is to say when Y  X  X, C T1 (Y) = Y, we need to perform the closure check, which we will discuss furt her in Section 3.3.2. When Y is not a closed itemset in transaction set T1, we have the following Lemma 11. In this lemma, we prove that when Y is a subset of X, Y is not a closed itemset in transaction set T2. Lemma 11 Given T2=T1\{X}, if Y  X  X, C T1 (Y)  X  Y, then C T2 (Y)  X  Y. transaction leaves the current s liding window, for most cases, the DIU tree structure does not change and we need to update only the associated supports, which t hus reduces the update costs. There is only one case in which we need to perform the closure check: when {X}  X  T2, Y  X  X, and C T1 (Y) = Y. We will discuss how to check for closed itemsets in the following section. The CFI-Stream algorithm checks whether an itemset is closed or not on the fly and incrementally updates the DIU tree based on the previous mining results with one scan of data streams. Below, we discuss the checking procedure for the deletion operation. In the following Theorem 2, we show that for any itemset Y, if Y  X  X, C T1 (Y) = Y, {X}  X  T2, then we can always find C T2 original closed itemsets. Theorem 2 For any itemset Y, if Y  X  X, C T1 (Y)=Y, {X}  X  T2, then C T2 (Y)  X  C T1 . That is to say, we can always find C C subset of X, {Y}  X  T2. Y is a closed itemset in transaction set T2. Lemma 12 For any itemset Y, if Y  X  X, {Y}  X  T2, we have C T2 (Y) = Y. that we need to perform the closure checking for the deletion operation, if {Y}  X  T2, the Y is closed in the new transaction set T2. Below we show how we perfo rm the closure check when {Y}  X  T2, and to see if Y is a clos ed itemset in transaction set T2 after X leaves. Corollary 3 If Y  X  X, {Y}  X  T2, for all u which satisfies C T2 (u i ) = u i , Y  X  u i , and C T2 u  X  ...  X  u n.. C CFI-Stream algorithm on the fly when old itemsets leave the current sliding window. Based on our discussions in Secti ons 3.2 and 3.3, we derive an algorithm to perform online checking for closed itemsets over data streams. The CIF-Stream algorithm performs an addition operation when a new transaction arrives and a deletion operation when an old transaction leaves the current sliding window. By performing the addition and dele tion operations, the CFI-Stream algorithm checks each itemset in the transaction on the fly and updates the associated closed ite msets X  supports. Current closed itemsets are maintained and updated in real time in the DIU tree. The closed frequent itemsets can be output any time at the user X  X  request by traversing the DIU tree. itemsets set C. If X is in C, it updates X X  X  support, and for all X X  X  one transaction in the original tr ansaction set, it checks whether it is a closed itemset for itself and a ll its subsets (lines 9 to 36); and it updates the associated supports fo r all the closed itemsets (lines 37 to 40). If X is a newly arrived closed itemset and does not exist subset of added transaction, a cl osure checking is performed (lines 16-24). In the following algorithm description, X and Y represent itemsets, X s and Y s represent X X  X  support and Y X  X  support, Len(X) represents the length of the items et X, which is the number of items in an itemset X, C represents the original closed itemsets in the DIU tree, and C new represents new closed itemsets in the DIU tree after itemset X arrives. Algorithm 1 CFI-Stream  X  Addition 1: X_close = true; C new =  X  ; 2: procedure Add(X, C, C new ) 4: for all (Y  X  X and Y  X  C) 5: Y s  X  support(Y, C) + 1; 6: end for 7: if (X_close = true) return; 8: else 9: if (support(X, C) &gt; 0 ) 10: if(C new =  X  ) 11: X 0  X  X; 12: C new  X  X; 13: X_close = false; 14: X s  X  support (X, C) + 1; 15: else 16: X c =  X  ; 17: for all ( K  X  X and K  X  C) 18: if (len(K)&lt;len(M) then M=K; 19: end for 20: X c  X  M; 21: if ((X c /X)  X  X 0 =  X  and X 22: C new  X  C new  X  X; 23: X s  X  support(X, C) + 1; 24: end if 25: end if 26: else 27: if (C new =  X  ) then 28: X 0  X  X; 29: C new  X  X; 30: X s = 1; 31: end if 32: end if 33: end if 34: for all (m  X  X and Len(m) = Len(X)-1 35: call Add(m, C, C new ); 36: end for 37: if (X = X 0 ) 38: C  X  C  X  C new ; 39: support(X, C) = X s ; 40: end if 41: end procedure operation when an itemset X leaves the current sliding window. CFI-Stream first checks if X is in the current closed itemsets set C support and X X  X  subsets X  support belonging to C (lines 3 to 6). Otherwise, it checks the itemset X and all its subsets which are in itemsets (lines 8 to 26) and update s the support for all its subsets subset Y exists in transaction, Y should keep closed (lines 11-13). Otherwise a closure check for the subset Y is performed (lines 14-are no longer closed after transaction {X} leaves. Algorithm 2 CFI-Stream  X  Deletion 2: procedure Delete (X, C, C obsolete ) 3: if (count(X)  X  2) then 4: for all (Y  X  X and Y  X  C) 5: Y s  X  support(Y, C)  X  1; 6: end for 7: else 8: length = Len(X); 9: for all (len  X  1) 10: for all ( Y  X  X and Y  X  C and Len(Y) = length) 11: if (count(Y)  X  2) then 12: Y s  X  support(Y, C)  X  1; 13: else 14: M = I; 15: for all ( U  X  Y and U  X  C) 16: M = M  X  U; 17: end for 18: if (M = Y) then 19: Y s  X  support(Y, C)  X  1; 20: else 21: C obsolete = C obsolete  X  Y; 22: end if 23: end if 24: end for 25: length = length-1; 26: end for 27: end if 28: C  X  C \ C obsolete 29: support(Y, C) = Y s ; 30: end procedure We compare our algorithm with Moment [4], which is the state-performance evaluation, the synthe tic datasets T10.I6.D100K and T5.I4.D100K-AB are used. Each data set is generated by the same method as described in [1], where the three numbers of each dataset denote the average transaction size (T), the average maximal potential frequent itemset size (I) and the total number of transactions (D), respectively. In all experiments, the transactions of each dataset are looked up one by one in sequence to simulate the environment of an online data stream. CFI-Stream over the 100 sliding windows under different minimum supports for the dataset T10.I6.D100K. As the minimum support decreases, the running time for Moment increases, since the number of closed frequent itemsets and the boundary nodes increases. For CF I-Stream, the running time is independent of the support info rmation since it discovers and maintains all closed itemsets in the DIU tree. As the number of need to be reprocessed; only their supports need to be updated incrementally, therefore less processing time is needed per transaction. Also we can see from Figure 2 that CFI-Stream runs much faster than Moment when the support threshold is relatively low, because the number of boundary nodes stored in the data structure of Moment increases when the support threshold drops; as the number of nodes to be processed and checked for node property increase, execution tim e increases. When the support threshold is relatively high, thes e two algorithms have comparable number of the boundary nodes in Moment decreases, while CFI-Stream processes the same number of all the closed itemsets independent of support information. This is especially beneficial when users have different specified support thresholds in their online queries. number of itemsets of Moment and CFI-Stream for the dataset T10.I6.D100K. The memory usage for Moment increases when the minimum support decreases. Th is is because the number of itemsets it keeps track of increases. The memory usage remains almost the same when the support changes in CFI-Stream. This is because CFI-Stream stores all closed itemsets in the DIU tree independently of the support information. The overall memory usage is proportional to the numbe r of closed itemsets in the consumes much less memory space than Moment when the support threshold is low, because when the user defined support threshold is small, the numbe r of nodes it maintains in the memory increases dramatically, which includes all the infrequent gateway nodes, unpromising gatewa y nodes, intermediate nodes, and closed nodes. As the support threshold increases, the memory usage of Moment drops. These two algorithms consume almost the same amount of memory space. Moment takes slightly a smaller amount of memory space than CFI-Stream. This is because CFI-Stream stores all closed itemsets in the DIU tree so that the frequent closed itemsets can be output based on any user-specified thresholds in real time. We can see that CFI-Stream is the number of frequent closed itemsets and the corresponding number of frequent itemsets is large. In this paper we proposed a novel algorithm, CFI-Stream, to discover and maintain closed freque nt itemsets in the current data stream sliding window. The algor ithm offers an incremental method to check and maintain clos ed itemsets online. All closed frequent itemsets in data streams can be output in real time based on users X  specified thresholds. Ou r performance studies show that and space efficiency independent of support information, and it can adapt to the concept-drifting in data streams. Experimental results show that our method can achieve better performance than a representation algorithm for the state-of-the-art approaches in terms of both time and space overhead, especially when the we plan to extend our proposed al gorithm to different data stream applications. This work is partially supported by (while serving at) NSF, the NASA grant No. NNG05GA30G, and the DoD-OSU grant. We thank Dr. Yun Chi at the University of California for providing us the Moment algorithm source code. [1] R. Agrawal, R. Srikant; Fast algor ithms for mining association rules; [3] J. H. Chang, W. S. Lee; A sliding window method for finding [10] G. S. Manku, R. Motwani; Approxi mate frequency counts over data [11] J. Pei, J. Han, and R. Mao; Closet: An efficient algorithm for mining [13] M. J. Zaki and C. J. Hsiao; Charm: An efficient algorithm for closed 
