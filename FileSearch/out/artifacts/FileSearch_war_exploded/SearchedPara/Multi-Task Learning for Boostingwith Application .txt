 In this paper we propose a novel algorithm for multi-task learning with boosted decision trees. We learn several dif-ferent learning tasks with a joint model, explicitly addres sing the specifics of each learning task with task-specific param-eters and the commonalities between them through shared parameters. This enables implicit data sharing and regu-larization. We evaluate our learning method on web-search ranking data sets from several countries. Here, multitask learning is particularly helpful as data sets from different countries vary largely in size because of the cost of editori al judgments. Our experiments validate that learning various tasks jointly can lead to significant improvements in perfor -mance with surprising reliability.
 I.2.6 [ Artificial intelligence ]: Learning; H.3.3 [ Information storage and retrieval ]: Information search and retrieval Algorithms
Multi-task learning algorithms [2] aim to improve the per-formance of several learning tasks through shared models. Previous work focussed primarily on neural networks, k -nearest neighbors [2] and support vector machines [6]. In this paper, we introduce a novel multi-task learning algo-rithm for gradient boosting. This is motivated by our inter-est in web search ranking: gradient boosted decision trees are indeed among the state-of-the-art algorithms for large -scale web-search ranking [11, 19].

Web search ranking is often treated as a supervised ma-chine learning problem [12]: each query-document pair is represented by a high-dimensional feature vector and its label indicates the document X  X  degree of relevance to the query. Like many other supervised learning problems, ma-chine learned ranking requires a large number of labeled training examples, which are time consuming and expen-sive to obtain. This problem becomes more acute with spe-cialization: most major search engines offer indeed special -ized rankings for different countries or regions. The proble m of high editorial cost is prominent if one attempts to build many such specialized, country-specific ranking functions  X  as building each ranking function requires its own set of hand-labeled data. On the other hand, a large fraction of queries are region-insensitive. Thus, it seems worthwhile to treat the different countries as tasks that are not completel y independent of one another as they share some common-alities, yet, differ enough that one cannot na  X   X vely combine their training data sets.

A common related line of research is domain adaptation (DA). Here, one assumes a source domain with large train-ing data and a target domain with very little training data. The test case is exclusively in the target domain. The main principle behind DA is to learn a model for the source and adapt it to the target domain. In the web-search example the source could be a well established country and the tar-get a new country where the search engine is still relatively new. Gao et al. [8] address this particular case with boosted decision trees through model interpolation and refinement.
Related to our work, but fundamentally different, is multi-task boosting for face verification [17]. It learns a set of boosted classifiers and is based on a probabilistic model where a multinomial variable indicates how much each booste d classifier contributes to each task. The learning algorithm involves Expectation-Maximization (EM) to learn both the multinomial random variables as well as the classifiers. Dai et al. [5] developed a variation of AdaBoost [15] that can incorporate training data from a different distribution tha n the test set. Instead of learning multiple models, their ap-proach down-weights data points that are not representable for the test set. A different method of cross domain learning is discussed in [3], which uses both feature level and in-stance level knowledge transfer across domains. The featur e level knowledge transfer is modeled as an optimization func -tion in RankingSVM [9] by learning the underlying common feature representation across domains. The instance level knowledge transfer is achieved by sample weighting.
Compared to all these approaches, in this paper, we pro-pose a novel algorithm to capture task specifics and com-monalities simultaneously. Given data from T different tasks, the idea is to learn T + 1 models  X  one for each specific task and one global model that captures the commonali-ties amongst them. The algorithm is derived systematically based on the connection between boosting and  X  1 regular-ization [14]. To the best of our knowledge we are not aware of any work that jointly models several tasks by explicitly learning both the commonalities and idiosyncrasies throug h gradient boosted regression.

Our contribution in this paper is three-fold: 1. We introduce a novel multi-task learning algorithm 2. We exploit the connections between boosting and  X  1 3. Driven by the success of gradient boosted decision trees
Although we mainly focus on multi-task learning for rank-ing across different countries, it is important to point out that our algorithm can readily be used in other scenarios. In the context of web-search one might encounter different multi-task problems, such as customizing ranking function s for different query types by modeling both the commonal-ities across the query types and the idiosyncrasies of each query set. Further, our algorithm is not specific to web search ranking and is equally applicable to any standard machine learning task such as classification or regression.
The rest of the paper is organized as follows. We formally introduce the multi-task learning problem in section 2 and propose our approach in section 3. The connection between boosting and  X  1 regularization serves as motivation for our derivations. In sections 4, 5 and 6, we evaluate our method on several real-world large scale web-search ranking data sets. Section 7 presents the conclusions and future directi ons for our work. Assume that we are given learning tasks t  X  X  1 , 2 , . . . , T } . Further, the data for these tasks, { ( x 1 , y 1 ) , . . . , ( x is also given to us. Each task t is associated with a set of indices I t that denotes the data for this particular task. These index sets form a partition of { 1 , . . . , n } ( i.e. , I I s =  X  when t 6 = s and  X  T t =1 I t = { 1 , . . . , n } ). We also define I 0 = { 1 , . . . , n } . At this point, we assume that all the tasks share the same feature space; we will later show how this assumption can be relaxed. Finally, we suppose that we are given a cost function C t defined as a function of the predicted values for all points in I t . For instance, in regression setting, we might consider squared loss: We also overload the definition of C t to allow it to be defined as a function of the parameters of the function to be learned. For instance, in case of a linear class of functions,
Previous work has mainly focused on Neural Networks [2, 4] or Support Vector Machines [6]. This latter work is of par-ticular interest because it inspired the algorithm present ed in this paper. In this SVM based multi-task learning, a clas-sifier w t is specifically dedicated for the task t . In addition, there is a global classifier w 0 that captures what is common among all the tasks. The joint optimization problem is then to minimize the following cost: In [6], all the  X  i , i  X  1 have the same value, but  X  0 different. Also, a classification task is considered: the lab els are y i  X  X  X  1 } and the loss function is Note that the relative value between  X  0 and the other  X  i controls the strength of the connection between the tasks. In the extreme case, if  X  0  X  +  X  , then w 0 = 0 and all tasks are decoupled; on the other hand, when  X  0 is small and  X  i  X  +  X  ,  X  i  X  1, we obtain w i = 0 and all the tasks share the same decision function with weights w 0 .
In practice, the formulation (3) suffers from the draw-back that it only allows linear decision boundaries. This can be very limiting especially for more complex real-world prob-lems. A standard method to avoid this limitation is to ap-ply the kernel-trick [16] and map the input vectors indirectly into a high dimensional feature space, x i  X   X  ( x i ), where, with careful choice of  X  , the data is often linearly separa-ble. The kernel-trick is particularly powerful, because th e mapping  X  is explicitly chosen such that the inner-product between two vectors  X  ( x i )  X   X  ( x j ) can be pre-computed very efficiently  X  even if the dimensionality of  X  ( x i ) is very high or infinite. The kernel-trick has been adapted to multi-task learning by [6]. Unfortunately, for many real-world prob-lems, the quadratic time and space complexity on the num-ber of input vectors is often prohibitive.

In certain domains, such as text classification, it can be the case that the data is indeed linearly separable  X  even without the application of the kernel-trick. However, the input space X is often already so high dimensional, that the dense weight vectors w t become too large for learning to be feasible  X  especially when the number of tasks T becomes very large. Recently, the authors of [18] applied the hashing-trick to a non-regularized variation of (3) and mapped the input data of all tasks into a single lower dimensional fea-ture space. Similar to the kernel-trick, the high-dimensio nal representation is never computed explicitly and all learni ng happens in the compact representation.
In this paper we focus on the case where the data is too large to apply the kernel-trick and not linearly separable, which is a key assumption for the hashing-trick. As already noted in the introduction, boosted decision trees are very well suited for our web search ranking problem and we now present our algorithm, multi-boost for multi-task learning with boosting.
Instead of mapping the input features into a high dimen-sional feature space with cleverly chosen kernel functions , we propose to use a set of non-linear functions H = { h 1 , . . . , h to define  X  : X  X  R J as  X  ( x i ) = [ h 1 ( x i ) , . . . , h Instead of assuming that we can compute inner-products efficiently (as in the kernel-trick), we assume that we are provided with an oracle O that solves the least-squared re-gression problem efficiently up to  X  accuracy: for some targets z i . For the sake of the analysis we assume that |H| = J is finite, but in practice, we used regression trees and H is infinite.

Even though J may be very large, it is possible to learn linear combinations of functions in H using the so-called boosting trick . Viewing boosting as a coordinate descent optimization in a large space is of course not new and was first pointed out in [13]. The contribution of this paper is the adaptation of this insight to multi-task learning.
Let us apply the boosting-trick to the optimization prob-lem (3). For disambiguation purposes, we denote the weight vector for task t in R J as  X  t . As J can be very large, we can only store vectors  X   X  R J if they are extremely sparse. For this reason, we change the regularization in (3) from an  X  norm to an  X  1 -norm. We can state our modified multi-task learning formulation as where, as in (2), C t (  X  ) is defined as C t ( . . . , h  X ,  X  ( x A minor technical difference from (3) is that the regularizer is introduced as a constraint. We do not make any explicit assumptions on the loss functions C t ( ), except that it needs to be differentiable.

Similar to the use of the kernel-trick, our new feature rep-resentation  X  ( x i ) forces us to deal with the problem that in most cases the feature space R J will be extremely high dimensional. For example, for our experiments in the result section, we set H to be the set of regression trees [1]  X  here |H| is infinite and  X  ( x i ) cannot be explicitly computed. To the rescue comes the fact that we will never actually have to compute  X  ( x i ) explicitly and that the weight vector  X  be made sufficiently sparse with the  X  1 -regularization in (6).
In this section we will derive an algorithm to solve (6) efficiently. In particular we will follow previous literatur e by [14] and ensure that our solver is in fact an instance of gradient boosting [13]. To simplify notation, let us first transform the multi-task optimization (6) into a tradition al single-task optimization problem by stacking all paramete rs into a single vector  X   X  R J ( T +1) , defined as This reduces (6) to the much simpler optimization problem where we define the norm k  X  k  X  = P T t =0  X  t k  X  t k 1 in this section is to find an algorithm that solves (8) without ever computing any vector  X  ( x i ) explicitly.  X 
As a first step, let us define a simple iterative algorithm to solve (8) that [14] refer to as  X   X  boosting . Intuitively, the idea is to follow the regularization path as is slowly in-creased from 0 to the desired value in tiny  X  &gt; 0 increments. This is possible under the assumption that the optimal vec-tor  X  in (8) is a monotonic function of componentwise. At each iteration, the vector  X  is updated only incrementally by an additive factor of  X   X  , with k  X   X  k  X   X   X  . More precisely,  X   X  is found through the following optimization problem:
Following [14], it can be shown that, under the mono-tonicity assumption stated above, solving (9) for the right number of iterations does in fact solve (7). Therefore,  X  -boosting satisfies the  X  1 regularization constraint from (6) implicitly . Because the  X  1 -norm of the vector  X  increases by at most  X  during each iteration, the regularization is not controlled by the upper bound but instead by the number of iterations S for which this  X  update is performed.
As we are only moving in very tiny  X  steps, it is fair to approximate C ( ) with the first-order Taylor expansion. By  X  X nstacking X  the representation from (7), this leads to with g t j :=  X  X 
Let us define the outputs at the training points as Using the chain-rule, On the other hand, Combining the above equations, we finally obtain:
We can now rewrite our optimization problem (9) with the linear approximation (10) as:
With a change of variables  X   X  t j  X   X  t  X  t j , the problem be-comes one of minimizing an inner product under  X  1 con-straint. If we make the additional assumption that the class of functions H is closed under negation ( h  X  X  X  X  X  h  X  X  ) then it is easy to show that the solution of (13) is given by:
Intuitively, (14) finds the direction with steepest descent , across all tasks and all functions in H , and takes an  X  -step.
It remains to show that we can compute the single non-zero index of (14) efficiently with the help of the oracle (5). Assuming that the weighted functions h  X  X  are normalized over the input, i.e. P i  X  I t h ( x i ) 2 = 1 1 , we can express (5)
The optimal couple ( t, j ) from (14) is thus (  X  t,  X   X  (
The parametrization in terms of  X  is just conceptual and in practice we update the function F t ( ) :=  X   X  t ,  X  ( ) of  X  :
The algorithm multi-boost with the update-rule (16) is summarized in Algorithm 1 and is illustrated in Figure 1. The computational complexity of this algorithm is linear in the number of training samples as well as in the number of tasks.
For the sake of simplicity, we have tried to keep the above derivation as simple as possible, but there are in fact sever al extensions that we have implemented:
The training points from different tasks may have different features, and in fact, that is the case in our web search ranking application. To address this issue, we introduce, f or each task t , a set of functions H t defined over the features for that task. H 0 is the set of functions defined over the
There is a flaw in our reasoning since in general this equa-tion cannot hold for all t simultaneously. However, we will later present an extension where the functions h depend on t . That will solve this problem. Figure 1: A layout of four ranking tasks that are learned jointly. The four countries symbolize the different ranking functions that need to be learned, where  X  1 , . . . ,  X  4 are the parameter vectors that store the specifics of each individual task. The various tasks interact through the joint model, symbolized as a globe with parameter vector  X  0 . intersection of the various feature sets. That does not chan ge the algorithm fundamentally; the main difference is that now u in equation (11) is defined as  X   X  0 ,  X  0 ( x i )  X  +  X   X  where  X  0 and  X  t are defined with respect to the functions of H 0 and H t respectively.

Instead of performing an  X  -gradient step, we follow the framework of [19] and perform an approximate Newton step at each iteration. At the core of this approach is the com-putation of the second derivatives of the loss, t i =  X  2 the use of a weighted least square algorithm as an oracle with weights t i .

We ntroduce a weight c t for each task t such that the new global objective function is C := P c t C t . We experiment with two choices for c t : c t = 1 and c t = 1 | I t | . Algorithm 1 Multi-boost ( S iterations)
F t = 0  X  0  X  t  X  T for s  X  1 to S do end for
Predict a new example x of task t as F 0 ( x ) + F t ( x )
In this section we present the experimental setup for our experiments. The data sets include large-scale web ranking training sets for various countries. All the data sets conta in randomly sampled queries from the search engine query logs. Country Train Valid Test Train Valid Test Table 1: Details of the subset of data used in experi-ments. The countries have been sorted in increasing size of the number of training queries.
 For each query, a set of URLs is sampled from the results retrieved by several search engines. For each query-url pai r, an editorial grade containing 0  X  4 is obtained that describes the relevance of the url to the query. Each query-url pair is represented with several hundred features.

The size in terms of number of queries and the number of query-url pairs in the training, test and validation sets fo r each country is shown in Table 1. The country names are anonymized for confidentiality purposes. Note that there are some empty cells for some countries which indicate that the test and validation sets are not available for them.
The performance of various ranking models is measured on the test set using Discounted Cumulative Gain [10] at fifth position, which we refer to as DCG-5. We experimented with two different types of loss functions: the squared loss a s in GBDT [7] and a pairwise preference loss as in RankSVM [9] and GBRank [19]: if x i is to be preferred to x j , the cor-responding loss for that pair is max(0 , 1  X  ( f ( x i )  X  f ( x We thus refer to GBDT and GBRank as our learning meth-ods for ranking both with and without multi-task learning. More background information on learning to rank can be found in a recent survey paper [12].

The experimental results have been divided into two sec-tions. In the next section we present preliminary results on a small subset of the complete feature set. For the large-scale experiments in Section 6, we present the results with the complete feature set containing more than 500 features such as text match scores, spam scores, link based features, click features and page classifier outputs. In most of the ex-periments, the parameters of the algorithms are tuned using a validation set. But for some of them  X  that we will point out  X  some parameters are set to default values which in general give good performances. These values are 20 for the number of nodes per tree, 1200 for the number of trees and 0.05 for the shrinkage rate [7].
In this section we present preliminary experimental result s on a subset of data sets with a smaller feature set containing 11 most important features such as a static rank for the page on the web graph, a text match feature and the output of a spam classifier.

Also we did not use in this section the validation and test sets described in Table 1. Instead we split the given trainin g set into a smaller training set, a validation set and a test set. The proportions of that split are, in average over all countries, 70%, 15% and 15% for respectively the training, validation and test sets. The reason for this construction w ill become clearer in the next section; in particular, the test s ets from Table 1 were constructed by judging the documents that our candidates functions retrieved and cannot thus be used for experimentation but only as a final test.
We initially discuss the correlation between train MSE and test DCG. Later, we compare several baseline ranking models and discuss the effect of sample weighting.
For each experiment, we calculated the DCG on both val-idation set and the test set after every iteration of boostin g. All parameters  X  the number of iterations, number of nodes in regression trees and the step size  X   X  were selected to maximize the DCG on the validation set and we report the corresponding test DCG.
 Train MSE and Test DCG: We show how the train MSE and test DCG change for a typical run of the experiment in Figure 2. The training loss always decreases with more iterations. The test DCG improves in the beginning and but the model starts overfitting at some point, and the DCG slighlty deteriorates after that. Thus it is important to ha ve a validation set to pick the right number of iterations as we have done. In the rest of the experiments in this section, we tuned the model parameters with the validation set and report the improvements over the test. Figure 2: Train MSE and test DCG as a function of the number of iterations.
 Baseline Experiments: We first did a smaller experiment on six countries. The aim in this experiment was to compare with the following baseline methods: Country weighted unweighted pooling cold-start A 0.561 1.444 -0.320 -0.282 C 1.135 1.295 0.972 1.252 D -0.043 -0.233 -1.096 -2.378 E 0.222 0.342 -2.873 -3.624 M -2.385 -0.029 -1.724 -6.376 N -0.036 0.705 -1.160 -3.123 Table 2: Percentage change in DCG over indepen-dent ranking models for various baseline ranking models.
Table 2 summarizes the results relative to the indepen-dent baseline. The two heuristic schemes  X  cold-start and pooling  X  did not show any improvement overall (in fact, most DCG values were lower). Hence in all of the experi-ments that follow, we used the independent ranking model as the baseline and show that our multi-task learning al-gorithm can improve over the independent models as well. As described in Section 3.3, we can provide a weight for each data set in the multi-task learning scenario that we proposed. In this table the unweighted scheme refers to set-ting the weight as 1 for each example and weighted refers to weighting each data set by the inverse number of samples in the data set. Thus weighted gives equal weight to each data set, while unweighted has no weight on each sample, so effec-tively larger data sets have higher weight in the unweighted setting. The results indicate that the average performance of the unweighted scheme seems better than the weighted one. Note that a relative improvement of 1% is considered to be substantial in the web search ranking domain. 2 Steps taken by the two weighting schemes: Typical behavior of the steps taken with the two weighting schemes are shown in Figure 3. In both schemes, initially, a num-ber of global steps are taken. Since global steps minimize the objective function for every country, it is attractive i ni-tially. However, once the commonality among the tasks has been captured by the global steps, they are no longer very attractive. The algorithm takes many local steps from that point onwards. Furthermore, with the unweighted scheme, the countries with significantly more data dominate the ob-jective. Thus, the multi-task algorithm takes significantl y more steps in such countries. On the other hand, in the weighted scheme, smaller countries are relatively easier to fit than bigger ones and a lot of steps are taken in these countries. Although we presented two extreme weighting schemes, other weighting schemes with specific weights to each country are possible.
 Finding appropriate groups of countries: Finding an appropriate grouping of countries that is beneficial to each country so that the tasks in that group can help each other is a nontrivial task. Since we wanted to find out the best group of countries that is most beneficial to each country,
What we mean here is that improvements reported in web search ranking papers are typically of the order of 1%; see for instance Figure 1 of [19].
 Table 3: Percentage improvement over independent for the best countries found on the validation set. we searched all possible combinations of countries. Specif -ically we explored 2 11 combinations of possible groupings for eleven countries and found the best group of countries that helps a given country based on the validation data set. Then we tested this best model on the test set to observe its performance. Since this experiment involves a very larg e number of combinations, we have fixed to some default val-ues the learning parameters of the gradient boosted decisio n tree algorithm (number of nodes, shrinkage and number of trees). Table 3 shows the experimental results for this task . Each row shows the DCG-5 gain of the best grouped multi-task ranking model over the independent ranking model for each country. We can see that the multi-task ranking model improves the performance in every single country over the country-specific ranking model.
In this section we present the experimental results by test-ing the multi-task algorithms on the large scale web search ranking data sets with complete feature sets. We illustrate that our methods help to customize the ranking models on a number of country-specific data sets. For Sections 6.1, 6.2 and 6.3, we fixed the parameters such as number of trees, number of nodes per tree and compare multi-task ranking models with independent models on the validation set. In Section 6.4 and 6.5, we did complete model selection on the validation set and report the results on the test set.
Note that we have two different experimental setting in this paper. Most of the experiments are in a reranking set-ting, where a fixed set of documents with relevance grades are exposed to the ranking models for each query. This is the traditional setting used in almost all of the learning to rank papers. On the other hand, in Sections 6.4 and 6.5, we present results based on web-scale experimental setting, where all the documents 3 in the web index are exposed to the ranking models. To our knowledge, we are the first to provide results in such a setting. It also serves as a fur-ther validation to the results obtained with the reranking experimental setting.
To be precise, it would be infeasible to score all the doc-uments in the index and only the potentially relevant doc-uments  X  as determined by a basic ranking function  X  are scored. Country Multi-GBDT Multi-GBRank A +1.53 +0.72 +0.69 +0.75 B +1.81 +1.58 +2.22 +1.64 C +0.92 +0.52 +0.92 +0.01 D +4.14 +3.62 +1.77 +1.84 E -1.37 -1.45 -0.18 -0.91 F +0.57 +1.80 +1.67 +2.22 G +4.34 +4.68 +1.74 +0.75 H +0.34 +0.96 +0.52 +0.85 I -0.50 -0.80 -0.07 +0.32 J +0.10 -0.69 +0.74 -0.64 K +2.37 +2.38 +3.40 +2.01 N +0.53 -1.23 +0.51 -0.92 Mean +1.23 +1.01 +1.16 +0.66 Table 4: DCG-5 gains with Multi-GBDT and Multi-GBRank learning algorithms in two different weight-ing settings. The gains are over independent-GBDT and independent-GBRank respectively.
As indicated earlier, our method can be applied to a any loss function and in particular it can be combined with a pairwise ranking model (see Section 4). In this section, we compare the results of pointwise and pairwise ranking schemes, which we refer to as Multi-GBDT and Multi-GBRank methods, to the independent ranking models in each country. Table 4 shows the results of both learning algorithms with the two weighting schemes discussed in Section 5. It can be seen that in both pointwise and pairwise ranking schemes, multitask ranking models have better average performance over the independent models.
An important aspect of the multi-task learning algorithms that we proposed is that if we can group the tasks so that they are related and benefit each other, we can boost the performance of the individual tasks. To demonstrate the benefits of grouping the related tasks, we grouped the relate d countries into several groups and present results in Table 5 . For each country, DCG-5 gain compared to the independent ranking model for each country is shown for all the groups in which it was involved. The underlying learning algorithm in this experiment was GBDT and we used the unweighted scheme of our multi-task learning algorithm.

We organized the countries into eight groups based on con-tinents and language of the countries and we anonymized the group names. Each of these groups involve a set of coun-tries which are indicated in the columns of Table 5. It can be noted that different groups are beneficial to each country and finding an appropriate grouping that is beneficial to a specific country is challenging. The negative numbers for some countries indicate that none of the groups we selected were improving that particular country and the independent ranking model is still better than various groupings we trie d.
In this section we present comparison results of our multi-boost method with the domain adaptation method described in [8]. In this domain adaptation setting, the key idea is to utilize the source data to help and adapt to the target do-main. We chose the source data as the simple combination of data from all of the countries and varied the target do-main. In addition, the adaptation method also requires an additional parameter in terms of the number of trees that are added at the end of the base model to train with the target domain data. We fixed the number of base model trees to be 1000 and the number of additive trees as 200. Figure 4 shows the DCG-5 gains of our method over the adaptation method in [8]. The multi-task method outper-forms the adaptation method in most of the countries, while the adaptation method is better in a couple of countries. Since the multi-task method allows the domains to learn from each other, it fosters better interaction among the do-mains than the adaptation method. Also a key difference with the adaption method is that multi-task automatically decides the number of steps taken towards each of the do-mains by choosing the domain that minimizes the objective function at each step. Moreover, since the steps are inter-leaved among the domains, the target data is introduced earlier to the model than the adaptation method. has not been tested.
 Figure 4: DCG-5 gains of multi-task models over the adaption models. The dashed line represents the mean gain, 0.65%.
The experimental results with web-scale experimental set-ting are shown in Table 6. To perform this test, several multi-task models were first trained with various parame-ters including the grouping and weighting as some of the parameters in addition to the standard GBDT parameters such as number of trees, number of nodes per tree and the shrinkage rate [7]. Of these models, we picked the model with the highest DCG-5 on the validation set as the Best valid model. We also selected the top three models on the vali-dation set as well as the independent model to be evalu-ated in the web-scale experimental setting. This means that all the top documents retrieved by these models were sent for editorial judgements. Of these three selected models, the one achieving the highest DCG-5 on the test set is de-noted Best test . Table 6 shows the improvements with both Table 6: Web scale results obtained by judging all the urls retrieved by the top 3 multi-task models as well as the independent model. Best valid refers to DCG-5 gain with the best model on the validation set while Best test refers to the highest DCG-5 gain on the test set.

The results indicate that the small tasks have much to benefit from the other big tasks where the training data size is large. It can also be noticed that the difference between reranking and web scale results is also dependent on the size of the validation or reranking data set. When the size of the validation set is large, there is more confidence on the resul ts from the reranking results.
As discussed in Section 3, a byproduct of our multi-task learning algorithm with multiple countries is a global model, F 0 that is learned with data from all the countries. This global model can be utilized to deploy to the countries where there is no editorial data available at all, which could serv e as a good generic model. Table 7 shows the results of the global models in the same web-scale setting as in the previ-ous section. For each country we present the DCG-5 gains Table 7: DCG-5 gains of global models trained with multi-task approach compared with simple data combination from of all countries. of the multi-task global models over that baseline ranking model F 0 . A key difference between these two models is that the multi-task global model primarily learns the commonal-ities in the countries while simple data combination model could learn both commonalities and the country specific id-iosyncrasies. While these country specific idiosyncrasies are helpful for the that specific country, it might actually hurt other countries. Although the global model does not per-form well in a few countries, the average performance of the multi-task global ranking model is better than the simple data combination model.
In this paper we introduced a novel multi-task learning algorithm based on gradient boosted decision trees that is specifically designed with web search ranking in mind. We model the problem of learning the ranking model for vari-ous countries in a multi-task learning framework. The cus-tomization of the ranking models to each country happens naturally by modeling both the characteristics of the lo-cal countries and the commonalities separately. We pro-vided a thorough evaluation of multi-task web search rank-ing on large scale real world data. Our multi-task learning method lead to reliable improvements in DCG, especially after specifically selecting sub-sets that are learned join tly.
The results in this paper validate that multi-task learning has a natural application in web-search ranking. As future work, we want to apply this multi-task approach to other ranking adaptation problems where the tasks could involve various query types such as navigational and informational queries. Our proposed multi-task learning framework could learn a ranking model for all of these query types jointly while still learning a generic global learning model that ca n work across all types of queries.

Furthermore, we could apply our algorithm to other ma-chine learning tasks beyond ranking for which boosted deci-sion trees are well suited. [1] L. Breiman, J. Friedman, C. J. Stone, and R. A. [2] R. Caruana. Multitask learning. In Machine Learning , [3] D. Chen, Y. Xiong, J. Yan, G.-R. Xue, G. Wang, and [4] R. Collobert and J. Weston. A unified architecture for [5] W. Dai, Q. Yang, G. Xue, and Y. Yu. Boosting for [6] T. Evgeniou and M. Pontil. Regularized multi X  X ask [7] J. Friedman. Greedy function approximation: a [8] J. Gao, Q. Wu, C. Burges, K. Svore, Y. Su, N. Khan, [9] R. Herbrich, T. Graepel, and K. Obermayer. Large [10] K. Jarvelin and J. Kekalainen. IR evaluation methods [11] P. Li, C. J. C. Burges, and Q. Wu. Mcrank: Learning [12] T.-Y. Liu. Learning to rank for information retrieval. [13] L. Mason, J. Baxter, P. Bartlett, and M. Frean. [14] S. Rosset, J. Zhu, T. Hastie, and R. Schapire. [15] R. Schapire, Y. Freund, P. Bartlett, and W. Lee. [16] B. Sch  X  olkopf and A. Smola. Learning with kernels . [17] X. Wang, C. Zhang, and Z. Zhang. Boosted multi-task [18] K. Weinberger, A. Dasgupta, J. Attenberg, [19] Z. Zheng, H. Zha, T. Zhang, O. Chapelle, K. Chen,
