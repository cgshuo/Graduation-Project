 More and more people upload their travel information to Flickr, Baidu Lvyou and other social networking sites for sharing their travel experiences. By analyzing such data, researchers can mine a popular tourist attractions and tourism paths to recommend. Existing researches include: recommending the path according to users X  demand [3, 4, 6, 7, 9] and recommending attractions based on the popularity of the path [2, 10, 11].

Considering the real-life demand of a new path search: a tourist, traveling in an unfamiliar city, requires help for planning the trip:  X  X n order to obtain the most popular tourist paths, how to select the attractions if I departure from the hotel at 8:00 and need to catch the train at 18:00? X  When users assign the source (hotel), the destination (railway station), and the permitted time (10 hours) of the tour, how to find the optimal tour path?
The problem above is multi-constraint optimal path search (MCOPS) prob-lem. The solution of this MCOPS problem is NP hard. Existing methods can not find the optimal path under the constraints while the permitted time is not enough to visit all attractions in any path, because their search rule is visiting either all attractions or no attraction in a path. The time and the popularity score are different when we select the different attractions to visit in the same path. For example, a path contains five attractions and the tourist does not have enough time to visit all. In order to answer the problem, we propose a new search rule to find the optimal path, making a choice on any attraction (visit or pass by) in any path, according to the tradeoff between permitted time and popularity score of attractions. As our search rule need to make a choice on any attraction (visit or pass by), the search cost will be larger.

How to reduce the search cost of finding the optimal path is a challenge for us. We devise an exact algorithm based on breadth-first search to find the optimal path efficiently when the data sets are relatively small. And we propose a heuristic algorithm based on the shortest path, which searches the optimal path nearby the shortest path. It is scalable to relatively large data sets. In the paper, we mainly make the following contributions: (1) We propose a new search rule to find the optimal path with multi-constraint (2) We present an exact algorithm based on breadth-first search. when the at-(3) We propose a heuristic algorithm based on the shortest path, which finds (4) The experimental results on real d ata sets reveal that our algorithms are
The rest of the paper is organized as follows. We briefly review the related work in Section 2. Section 3 gives the definition of MCOPS problem and prove its NP-hardness. In Sections 4 and 5 we propose an exact algorithm and a heuristic algorithm, respectively. S ection 6 gives the empirical study. Finally, Section 7 concludes the paper.
 In recent years, a large number of relev ant studies on tourist paths recommen-dations and searches, usually contain two cases as following: recommending the path according to users X  demand and based on the GPS trajectories.

The work [6] proposes an exact algorithm, namely Trip-Mine, which can find the optimal trip having the highest total popularity score from the source node s and finally back to s. It takes the attraction map as a complete graph and use the permutation of all attractions to solve the problem. Lu X. et al. [7] collect geo-tagged photos from Flickr and built travel paths based on these photos. They define popularity scores on each attraction and each path, and recommend a path having the highest popularity score within a travel duration in the whole map. The exact recommendation algorithm rans in an extreme long time based on dynamic programming. The work [1] proposes a greedy algorithm to solve MCOPS problem as ours, but its accuracy is not well. The problems in the work [6, 7] are similar to ours, but Trip-Mine approach and dynamic programming algorithm can not efficient to solve our problem.

The work [9] proposes a KOR problem. It aims to find an optimal path, in which a set of user-specified keywords is covered, a specified budget constraint is satisfied, and an objective score of the path is optimal. In this work, two approximation algorithms are proposed.

With the development of GPS mobile positioning system, using GPS tra-jectory data to mine the best path receives wide concerns. The work [3] finds popular paths from users historical trajectories. The popularity score is defined as the probability from the source location to the target location estimated using the Absorbing Markov Chain based on the trajectories. Chen et al. [2] propose k-BCT and IKNN query algorithm to get k routes which can go through the user-specified location track well. Cong et al. [4] propose a BCK-tree indexing technology to quickly search the shortest path covering all keywords.
The problems in the work [2 X 4, 9] con cern the popularity of path between attractions. But in this paper, we pay attention to the popularity of attractions in itself, it is more suitable the demand of users who want to experience the value of attractions. This section describes the related defini tions of multi-constraint optimal path search problem and complexity analysis. 3.1 Optimal Path Search We use a graph G to express a road network graph, or a graph extracted from users X  historical trajectories. For example, if G is a traffic network, the attributes can be travel duration, travel distance, popularity, travel cost and so on. For simplicity, we consider undirected graphs in this paper. However, our discussion can be extended to directed gr aphs straightforwardly. Given a graph G =( V,E ), it consists of a set of nodes V and a set of edges E  X  V  X  V .Eachnode v  X  V represents a location; each edge in E repre-sents a directed path between two locations in V , and the edge from v i to v j is represented by e ( v i ,v j ).

Let P be a path from v 0 to v n , P = v 0 ,..., ( v i ), ...,v n ,where v i with a bracket denotes an unvisited node, while the others denote visited nodes. For example, P = v 0 , ( v 1 ) ,v 2 represents a path from v 0 to v 2 ,andthenode v 1 is unvisited (simply passed by), while the nodes v 0 and v 2 are visited. Definition 1. Popularity Score and Cost Score. Given a graph G =( V,E ) . For each node v  X  V ,weuseapair ( w p ,w c ) to express its popularity w p and cost w c , and for each edge e =( v i ,v j ) we use a weight w to express its cost. For any path P = v 0 , v 1 ,...,v n , the popularity score of P is denoted as PS ( P ), and the cost score of P is denoted as C ( P ). Let V P be the set of the nodes in the path P and V A be the set of visited nodes, V A  X  V P . The cost score for path P is defined as the summation of the cost values of all visited nodes and all the edges in P : and the popularity score of the path P is the summation of the popularity score of all visited nodes:
For example, Fig. 1 shows an example of a graph G , in which each node v w Problem Formulation. Given a query q =( v s ,v d , C ), where v s is the source node, v d is the destination node, and C is the permitted cost by users. Find the optimal path P from v s to v d such that it satisfies the following two conditions: Example 1. Consider the graph shown in Fig. 1. Let query q =( v 1 ,v 5 , 10). Find an optimal path with the maximum popularity score.
 7, C ( P ) = 10. In this case, there are not all nodes can be visited in any path due to permitted cost C , so existing methods can not find the optimal path. When we traverse any node based on breadth-first search, we must consider two states of this node (visited or pass by). In the path, the nodes v 2 is the node only passed by but unvisited. If there are m nodes on one path, we can get the 2 m combina-tions. After we get all combinations of all paths satisfying multi-constraint, we select the maximum popularity score as the optimal path. 3.2 Complexity of the Problem Theorem 1. The problem of solving MCOPS problem is NP-hard.
 Proof Sketch: If a node has the cost score and popularity score, the node can be expressed as the node has an edge with cost score and popularity score to itself. Then this problem can be reduced from the NP-hard shortest weight-constrained path problem (SWCPP) [8]. Given a graph in which each edge has a length and a weight, SWCPP finds a path that has the shortest length with the total weight not exceeding a specified value. The problem of answering MCOPS queries is a generalization of SWCPP. The problem of solving MCOPS becomes equivalent to the SWCPP. When the graph is relatively small, we do exact search to get the optimal path answering our MCOPS problem. A naive approach is to traverse all paths based on the breadth-first search. When we get all combinations of all paths satisfying multi-constraint, we select the path with maximum popularity score as the op-timal finally. The main problem of the naive approach is that too many partial paths need to be stored on each node. In o rder to make it efficient, we propose two pruning strategies according to the lower bound of cost and the upper bound of popularity score in this section respectively.
 To simplify the expression, we introduce the following notations in Table 1.
By observing real-life attractions information, we find that the attraction with more popularity always cost more. So we assume that all attractions have the same popularity score per unit cost in this paper and we set  X  i =  X  .And  X  i,j is the key node in the shortest path. We can find all nodes of the shortest path based on the key node efficiently. Theorem 2. Given a graph G andaquery q =( v s ,v d , C ) , v i is the current node invalid path.
 Proof Sketch: c i,d is the lower bond of cost spending from the current node v to the destination v d ,and( c + c i,d ) is the lower bond of the cost from the current path to v d through v i .( c + c i,d ) &gt; C means that the path extending from the node v i does not satisfy the permitted cost, so it is an invalid path, and all paths extending from the current path through v i are all invalid ones. Theorem 3. Given a graph G and a query q =( v s ,v d , C ) , ps max is the maxi-mum popularity score of all path found. Let v i is the current node to extend, c is the cost of current path, and ps is the popularity score of current path. The current path is an invalid path if ps +  X  ( C X  c  X  c i,d ) &lt;ps max . Proof Sketch: According to the lower bound of the cost spending in the path, we can compute the upper-bound of remaining cost, which is equal to ( C X  c  X  c i,d ), i.e., the maximum cost to spend in the attractions.  X  is the popularity score per unit cost, so the upper bound of the popularity we get in the remaining cost is no more than  X  ( C X  c  X  c i,d ). If ps +  X  ( C X  c  X  c i,d ) &lt;ps max ,itmeansthat the popularity score of any path from the current path to the destination v d is less than ps max . So the current path extending from v i is not a valid path.
In order to improve the searching effici ency and reduce the memory storage re-quirement, we proposed the pruning algorithm according to the Theorem 2 and Theorem 3, i.e., we prune the invalid path according to the lower bound of cost and the upper bound of popularity score. The pseudo code is presented in Algorithm 1.
We use a queue Q to organize the partial path. We initialize the queue Q and p as NULL ( p is used to store the partial path), and use variable ps max to store the maximum popularity score we have got currently. p k i represents the k -th partial path from the source node v s to the current node v i .Ifthecostfrom the source node v s to the destination node v d is less than the permitted cost C , We create a path p 0 s at the starting node v s and enqueue it into Q (lines 1-3). Then we calculate the popularity score per unit cost and use variable  X  to store it (line 4). We keep dequeuing path from Q . If the popularity score of current path is more than the maximum popularity score, we replace the ps max with it (line 7). We terminate the algorithm when Q is empty (line 5).

For each outgoing neighbor v j of the current node v i , we extend the current path. If the lower bound of the cost in this path is more than the permitted cost C , or the upper bound of the popularity score in this path is less than the maximum popularity score ps max we have got, we stop extending for the path is invalid. Otherwise, we create the partial path ( p k j ) passing by the node v j : add the cost w ( v i ,v j )to( p k i )andsetthestateof v j as FALSE. If v j is not the destination, enqueue ( p k j )into Q (lines 8-12). Compute the new lower bound of cost and upper bound of popularity score visiting the node v j . If the lower bound is less than the permitted cost C , and the upper bound is more than the maximum popularity score, we create the partial path ( p k +1 j ): add the cost w not the destination, enqueue ( p k j )into Q (lines 13-19). Finally, the path p with the maximum popularity score is the optimal path (line 20).
 Algorithm 1. Exact Search Algorithm The exact search algorithm is used to the case with relatively few nodes. In order to answer the MCOPS problem in a relatively large graph, we propose a heuristic search algorithm based on the shortest path.
By observing, we draw a conclusion that we can get more popularity score path when spending less cost on the path. Because we spend the less cost in the edge, we get more remaining cost to visit the nodes. Thus we can get more popularity score because the popularity score per unit cost of all nodes is equal. Then we can obtain the maximum popularity score extending the path nearby the shortest path from the source to the destination.
 Theorem 4. If the permitted cost C is just equal to the cost of visiting all nodes in the shortest path, the shortest path is the optimal path.
 Proof Sketch: If the query q =( v s ,v d , C ), the popularity score per unit cost is  X  ,and p is the shortest path from the source node v s to the destination node v d , the cost spending in the path only is c s,d . And if the path p is any path from the source node v s to the destination node v d , the remaining cost to spend in attractions is C X  C ( p ) along the path p , while the remaining cost to spend in attractions along the shortest path p is C X  c s,d . Therefore, C X  c s,d  X C X  C ( p ), larger than that of the path p . We can conclude that the shortest path p is the optimal path.
 Based on the Theorem 4, we get the Lemma 1.
 Lemma 1. If the permitted cost C is just equal to the cost of visiting partial nodes in the shortest path, the path composed of the partial nodes along the shortest path is the optimal path.

The basic idea of heuristic search algorithm based on shortest path is: we get the shortest path from the source to the destination firstly, then we extend the path to one-hop nodes nearby the shortest path.

The path we find based on the cases setting in Theorem 4 and Theorem 5, is just the optimal path. However, the optimal path is probably not in the shortest path, but it should be nearby the shortest path. We get the optimal path along the shortest path using exact search firstly, then we extend the current optimal path to one-hop node between any pair nod es in the shortest path. We iterate the above process till the cost is not enough to visit any other node. Finally, we get a approximate optimal path. When we search in the shortest path exactly and extend the path nearby the shortest path, we prune the invalid path according to the Theorem 2 and Theorem 3. The pseudo code is presented in Algorithm 2.
We initialize the optimal path: p as NULL and a query q =( v s ,v t , C ) (line 1). we get the shortest path p from the source node to the destination node, and compute the related cost and the popularity of path p (lines 2-4). we compare cost min with C .If C &gt;cost min ,and C &lt;cost max , we exact search in the shortest path and get the current optimal path (lines 5-7). Otherwise, if C &gt;cost max ,we take the shortest path as current optimal path (lines 8-10). If the remaining cost is more than 0, we extend the path to one-hop node between any two visited nodes in p till the remaining cost is not enough to visit any other node (lines 11-12). Finally, the path p is the optimal path we find (line 13).

For example, given a query q ( s,d, C )=( v 1 ,v 5 , 12), in order to find the optimal Algorithm 2. Heuristic Search Algorithm Thenwefindtheoptimalcombinationusing theexactsearch: p = v 1 , ( v 2 ) ,v 3 , ( v 4 ) , v 5 as the current optimal path, C ( p )=10 &lt; is 2. We extend the path to one-hop node nearby the shortest path: v 7 ,v 10 ,and v 11 , score. So The path p is the optimal path and C ( p ) = 12 and ps ( p )=8.
We utilize the pre-processing results in order to accelerate the algorithms. We use the Floyd-Warshall algorithm [5], which is a well-known algorithm for finding all pairs shortest path. We store the minimum cost between any two nodes c i,j , and the next to last node in the current shortest path  X  i,j . This section mainly studies the efficiency of all algorithms. 6.1 Experimental Settings We use nine data sets in our experimental study. Five are generated from real attractions data. By extracting the subgraph of Beijing from Baidu Lvyou, we obtain five data sets containing 100, 150, 200, 250 and 300 nodes, respectively. To create the graph, we use the travel distance as the cost on each edge, the star level remarking by users as the popularity score in the range (1,5), and the average visiting time of an attractions as the cost on each node.

The other four are generated from real map data. By extracting the subgraph of Beijing road network, we obtain 4 data sets containing 800, 1000, 2000 and 3000 nodes, respectively. The travel distance is used as the cost on each edge, and we randomly generate the popularity score and the cost in the range (1,5) on each node to create the graph.

We generate a query set with any pairs of all nodes from data sets, and select 50 queries from all pairs randomly. Finally, we computed the average running time for each query set.
 All algorithms were implemented in VC++ and ran on an Intel(R) Xeon(TM)2 CPU E7300@2.93GHz with 8GB RAM. 6.2 Experimental Results The objective of this set of experiments is to study the efficiency of DAP [7], Trip-Mine [6] and the algorithms that we proposed with variation on the data set size and permitted time C . (1) Varying the Size of Data Set Fig. 2 (a), (b) and (c) shows that the running time of three exact algorithms: DAP, Trip-Mine and Exact-Searh we proposed, processing the query set varying the number of the nodes respectively, when the permitted time C is 4 hours, 8 houres and 16 hours limit. Exact-Searh algorithm always outperforms DAP and Trip-Mine in terms of runtime. The reason is that the pruning strategies we proposed are relatively efficient. As expected, all algorithms run slower as we increase the permitted time.

Fig. 3 (a), (b) and (c) shows that the running time of Heuristic Search algo-rithms: processing the query set varying the number of the nodes respectively, when the permitted time C is 8 hours, 12 hours and 16 hours limit, respectively. The running time of this algorithm is affected by the data set size. It runs slower with increasing the data set size. Howe ver, when the permitted time is no more than 16 hours and the number of nodes is 3000, it is efficient. (2) Varying the Time Limit C Fig. 4 (a), (b) and (c) shows the running time of three exact algorithm processing querys varying the permitted time C when the number of nodes is 100, 200 and 300, respectively. Exact-Searh algorithm always outperforms DAP and Trip-Mine in terms of runtime. The reason is that the pruning strategies we proposed are relatively efficient. As expected, all algorithms run slower as we increase the permitted time.

Fig. 5 (a), (b) and (c) shows that the running time of Heuristic Search algo-rithms: processing the query set varying permitted time C when the number of nodes is 800, 1000, 2000 and 3000, respectively. The running time of this algo-rithm is affected by the permitted time C . It run more slower with the increasing of permitted time. However, when the permitted time is no more than 16 hours and the number of nodes is 3000, it is efficient. This MCOPS problem is NP hard. In order to answer the problem, we propose a new search rule. How to reduce the search cost for finding the optimal path effi-ciently is a challenge for us. We devise an exact algorithm based on breadth-first search to find the optimal path for relatively small data sets. In this algorithm, we prune invalid path according to the lower-bound of time and the upper-bound of popularity score on path. And we propose a heuristic algorithm based on the shortest path, which finds the optimal path nearby the shortest path. It is scal-able to relatively large data sets. The exp erimental results on the real data sets reveal that our algorithm is able to find the optimal path in high efficiency. In the future work, we would like to improve the efficiency of the algorithms and current pre-processing approach.
 Acknowledgments. The work is partialcly supported by the National Natural Science Foundation of China (No s. 61322208, 61272178), the Joint Research Fund for Overseas Natural Science of China (No. 61129002), the Doctoral Fund of Ministry of Education of Chi na (No. 20110042110028), and the Fundamental Research Funds for the Central U niversities (No. N120504001, N110804002).
