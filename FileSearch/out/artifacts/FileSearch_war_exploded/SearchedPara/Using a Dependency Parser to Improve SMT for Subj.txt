 Over the past ten years, statistical machine transla-tion has seen many exciting developments. Phrase-based systems (Och, 2002; Koehn et.al., 2003; Och and Ney, 2004) advanced the machine transla-tion field by allowing translations of word sequences (a.k.a., phrases) instead of single words. This ap-proach has since been the state-of-the-art because of its robustness in modeling local word reordering and the existence of an efficient dynamic programming decoding algorithm.

However, when phrase-based systems are used between languages with very different word or-ders, such as between subject-verb-object (SVO) and subject-object-verb (SOV) languages, long dis-tance reordering becomes one of the key weak-nesses. Many reordering methods have been pro-posed in recent years to address this problem in dif-ferent aspects.

The first class of approaches tries to explicitly model phrase reordering distances. Distance based distortion model (Och, 2002; Koehn et.al., 2003) is a simple way of modeling phrase level reordering. It penalizes non-monotonicity by applying a weight to the number of words between two source phrases corresponding to two consecutive target phrases. Later on, this model was extended to lexicalized phrase reordering (Tillmann, 2004; Koehn, et.al., 2005; Al-Onaizan and Papineni, 2006) by applying different weights to different phrases. Most recently, a hierarchical phrase reordering model (Galley and Manning, 2008) was proposed to dynamically deter-mine phrase boundaries using efficient shift-reduce parsing. Along this line of research, discrimina-tive reordering models based on a maximum entropy classifier (Zens and Ney, 2006; Xiong, et.al., 2006) also showed improvements over the distance based distortion model. None of these reordering models changes the word alignment step in SMT systems, therefore, they can not recover from the word align-ment errors. These models are also limited by a maximum allowed reordering distance often used in decoding.

The second class of approaches puts syntactic analysis of the target language into both modeling and decoding. It has been shown that direct model-ing of target language constituents movement in ei-ther constituency trees (Yamada and Knight, 2001; Galley et.al., 2006; Zollmann et.al., 2008) or depen-dency trees (Quirk, et.al., 2005) can result in signifi-cant improvements in translation quality for translat-ing languages like Chinese and Arabic into English. A simpler alternative, the hierarchical phrase-based approach (Chiang, 2005; Wu, 1997) also showed promising results for translating Chinese to English. Similar to the distance based reordering models, the syntactical or hierarchical approaches also rely on other models to get word alignments. These mod-els typically combine machine translation decoding with chart parsing, therefore significantly increase the decoding complexity. Even though some re-cent work has shown great improvements in decod-ing efficiency for syntactical and hierarchical ap-proaches (Huang and Chiang, 2007), they are still not as efficient as phrase-based systems, especially when higher order language models are used.

Finally, researchers have also tried to put source language syntax into reordering in machine trans-lation. Syntactical analysis of source language can be used to deterministically reorder input sen-tences (Xia and McCord, 2004; Collins et.al., 2005; Wang et.al., 2007; Habash, 2007), or to provide mul-tiple orderings as weighted options (Zhang et.al., 2007; Li et.al., 2007; Elming, 2008). In these approaches, input source sentences are reordered based on syntactic analysis and some reordering rules at preprocessing step. The reordering rules can be either manually written or automatically ex-tracted from data. Deterministic reordering based on syntactic analysis for the input sentences provides a good way of resolving long distance reordering, without introducing complexity to the decoding pro-cess. Therefore, it can be efficiently incorporated into phrase-based systems. Furthermore, when the same preprocessing reordering is performed for the training data, we can still apply other reordering ap-proaches, such as distance based reordering and hi-erarchical phrase reordering, to capture additional local reordering phenomena that are not captured by the preprocessing reordering. The work presented in this paper is largely motivated by the preprocessing reordering approaches.

In the rest of the paper, we first introduce our de-pendency parser based reordering approach based on the analysis of the key issues when translating SVO languages to SOV languages. Then, we show exper-imental results of applying this approach to phrase-based SMT systems for translating from English to five SOV languages (Korean, Japanese, Hindi, Urdu and Turkish). After showing that this approach can also be beneficial for hierarchical phrase-based sys-tems, we will conclude the paper with future re-search directions. In linguistics, it is possible to define a basic word order in terms of the verb (V) and its arguments, subject (S) and object (O). Among all six possible permutations, SVO and SOV are the most common. Therefore, translating between SVO and SOV lan-guages is a very important area to study. We use English as a representative of SVO languages and Korean as a representative for SOV languages in our discussion about the word orders.

Figure 1 gives an example sentence in English and its corresponding translation in Korean, along with the alignments between the words. Assume that we split the sentences into four phrases: (John , t @ ), (can hit , `  X   X   X  X  ), (the ball ,  X   X  D ) and (. , .). Since a phrase-based decoder generates the translation from left to right, the following steps need to happen when we translate from English to Korean:  X  Starts from the beginning of the sentence,  X  Jumps to the right by two words, translates  X  X he  X  Jumps to the left by four words, translates  X  X an  X  Finally, jumps to the right by two words, trans-It is clear that in order for the phrase-based decoder to successfully carry out all of the reordering steps, a very strong reordering model is required. When the sentence gets longer with more complex structure, the number of words to move over during decod-ing can be quite high. Imagine when we translate the sentence  X  English is used as the first or second language in many countries around the world .  X . The decoder needs to make a jump of 13 words in order to put the translation of  X  is used  X  at the end of the translation. Normally in a phrase-based de-coder, very long distance reordering is not allowed because of efficiency considerations. Therefore, it is very difficult in general to translate English into Korean with proper word order.

However, knowing the dependency parse trees of the English sentences may simplify the reordering problem significantly. In the simple example in Fig-ure 1, if we analyze the English sentence and know that  X  X ohn X  is the subject,  X  X an hit X  is the verb and  X  X he ball X  is the object, we can reorder the English into SOV order. The resulting sentence  X  X ohn the ball can hit . X  will only need monotonic translation. This motivates us to use a dependency parser for En-glish to perform the reordering. Figure 2 shows the dependency tree for the example sentence in the previous section. In this parse, the verb  X  X it X  has four children: a subject noun  X  X ohn X , an auxiliary verb  X  X an X , an object noun  X  X all X  and a punctuation  X . X . When transforming the sentence to SOV order, we need to move the object noun and the subtree rooted at it to the front of the head verb, but after the subject noun. We can have a simple rule to achieve this.

However, in reality, there are many possible chil-dren for a verb. These children have some relative ordering that is typically fixed for SOV languages. In order to describe this kind of ordering, we pro-pose precedence reordering rules based on a depen-dency parse tree. All rules here are based English and Korean examples, but they also apply to other SOV languages, as we will show later empirically. A precedence reordering rule is a mapping from T to a set of tuples { ( L, W, O ) } , where T is the part-of-speech (POS) tag of the head in a depen-dency parse tree node, L is a dependency label for a child node, W is a weight indicating the order of that child node and O is the type of order (either NORMAL or REVERSE ). The type of order is only used when we have multiple children with the same weight, while the weight is used to determine the relative order of the children, going from largest to smallest. The weight can be any real valued num-ber. The order type NORMAL means we preserve the original order of the children, while REVERSE means we flip the order. We reserve a special label self to refer to the head node itself so that we can apply a weight to the head, too. We will call this tuple a precedence tuple in later discussions. In this study, we use manually created rules only.

Suppose we have a precedence rule: VB  X  (nsubj, 2, NORMAL), (dobj, 1, NORMAL), (self, 0, NORMAL). For the example shown in Figure 2, we would apply it to the ROOT node and result in  X  X ohn the ball can hit . X .

Given a set of rules, we apply them in a depen-dency tree recursively starting from the root node. If the POS tag of a node matches the left-hand-side of a rule, the rule is applied and the order of the sen-tence is changed. We go through all children of the node and get the precedence weights for them from the set of precedence tuples. If we encounter a child node that has a dependency label not listed in the set of tuples, we give it a default weight of 0 and de-fault order type of NORMAL. The children nodes are sorted according to their weights from highest to lowest, and nodes with the same weights are ordered according to the type of order defined in the rule. 3.1 Verb Precedence Rules Verb movement is the most important movement when translating from English (SVO) to Korean (SOV). In a dependency parse tree, a verb node can potentially have many children. For example, aux-iliary and passive auxiliary verbs are often grouped together with the main verb and moved together with it. The order, however, is reversed after the move-ment. In the example of Figure 2, the correct Korean word order is  X  ``` (hit)  X  X  X   X  X  X   X  X  X  X  X  X  (can) . Other categories that are in the same group are phrasal verb particle and negation.

If the verb in an English sentence has a preposi-tional phrase as a child, the prepositional phrase is often placed before the direct object in the Korean counterpart. As shown in Figure 3,  X  )  X  t \  X  ( X  X ith a bat X ) is actually between  X  t @  X  ( X  X ohn X ) and  X   X   X  D  X  ( X  X he ball X ).

Another common reordering phenomenon is when a verb has an adverbial clause modifier. In that case, the whole adverbial clause is moved together to be in front of the subject of the main sentence. Inside the adverbial clause, the ordering follows the same verb reordering rules, so we recursively reorder the clause.

Our verb precedence rule, as in Table 1, can cover all of the above reordering phenomena. One way to interpret this rule set is as follows: for any node whose POS tag is matches VB* (VB, VBZ, VBD, VBP, VBN, VBG), we group the children node that are phrasal verb particle (prt), auxiliary verb (aux), passive auxiliary verb (auxpass), negation (neg) and the verb itself (self) together and reverse them. This verb group is moved to the end of the sentence. We move adverbial clause modifier to the beginning of the sentence, followed by a group of noun subject (nsubj), preposition modifier and anything else not listed in the table, in their original order. Right be-fore the verb group, we put the direct object (dobj). Note that all of the children are optional. 3.2 Adjective Precedence Rules Similar to the verbs, adjectives can also take an aux-iliary verb, a passive auxiliary verb and a negation as modifiers. In such cases, the change in order from English to Korean is similar to the verb rule, except that the head adjective itself should be in front of the verbs. Therefore, in our adjective precedence rule in the second panel of Table 1, we group the auxiliary verb, the passive auxiliary verb and the negation and move them together after reversing their order. They are moved to right after the head adjective, which is put after any other modifiers.

For both verb and adjective precedence rules, we also apply some heuristics to prevent exces-sive movements. In order to do this, we disallow any movement across punctuation and conjunctions. Therefore, for sentences like  X  John hit the ball but Sam threw the ball  X , the reordering result would be  X  John the ball hit but Sam the ball threw  X , instead of  X  John the ball but Sam the ball threw hit  X . 3.3 Noun and Preposition Precedence Rules In Korean, when a noun is modified by a preposi-tional phrase, such as in  X  the way to happiness  X , the prepositional phrase is usually moved in front of the noun, resulting in  X   X  X  X   X  X  X  (happiness) &lt;&lt;&lt; \\\  X  X  X  888 (to the way)  X  . Similarly for relative clause mod-ifier, it is also reordered to the front of the head noun. For preposition head node with an object modifier, the order is the object first and the preposition last. One example is  X  with a bat  X  in Figure 3. It corre-sponds to  X  )))  X  X  X  ttt (a bat) \\\ (with)  X . We handle these types of reordering by the noun and preposi-tion precedence rules in the third and fourth panel of Table 1.

With the rules defined in Table 1, we now show a more complex example in Figure 4. First, the ROOT node matches an adjective rule, with four children nodes labeled as (csubj, cop, advcl, p), and with precedence weights of (0, -2, 1, 0). The ROOT node itself has a weight of -1. After reordering, the sen-tence becomes:  X  because we do n X  X  know what the future has Living exciting is .  X . Note that the whole adverbial phrase rooted at  X  know  X  is moved to the beginning of the sentence. After that, we see that the child node rooted at  X  know  X  matches a verb rule, with five children nodes labeled as (mark, nsubj, aux, neg, ccomp), with weights (0, 0, -2, -2, 0). In this case, the verb itself also has weight -2. Now we have two groups of nodes, with weight 0 and -2, respectively. The first group has a NORMAL order and the second group has a REVERSE order. Af-ter reordering, the sentence becomes:  X  because we what the future has know n X  X  do Living exciting is .  X . Finally, we have another node rooted at  X  has  X  that matches the verb rule again. After the final re-ordering, we end up with the sentence:  X  because we the future what has know n X  X  do Living exciting is .  X . We can see in Figure 4 that this sentence has an almost monotonic alignment with a reasonable Ko-rean translation shown in the figure 1 . As we mentioned in our introduction, there have been several studies in applying source sentence re-ordering using syntactical analysis for statistical ma-chine translation. Our precedence reordering ap-proach based on a dependency parser is motivated by those previous works, but we also distinguish from their studies in various ways.

Several approaches use syntactical analysis to provide multiple source sentence reordering options through word lattices (Zhang et.al., 2007; Li et.al., 2007; Elming, 2008). A key difference between their approaches and ours is that they do not perform reordering during training. Therefore, they would need to rely on reorder units that are likely not vio-lating  X  X hrase X  boundaries. However, since we re-order both training and test data, our system oper-ates in a matched condition. They also focus on ei-ther Chinese to English (Zhang et.al., 2007; Li et.al., 2007) or English to Danish (Elming, 2008), which arguably have less long distance reordering than be-tween English and SOV languages.

Studies most similar to ours are those preprocess-ing reordering approaches (Xia and McCord, 2004; Collins et.al., 2005; Wang et.al., 2007; Habash, 2007). They all perform reordering during prepro-cessing based on either automatically extracted syn-tactic rules (Xia and McCord, 2004; Habash, 2007) or manually written rules (Collins et.al., 2005; Wang et.al., 2007). Compared to these approaches, our work has a few differences. First of all, we study a wide range of SOV languages using manually ex-tracted precedence rules, not just for one language like in these studies. Second, as we will show in the next section, we compare our approach to a very strong baseline with more advanced distance based reordering model, not just the simplest distor-tion model. Third, our precedence reordering rules, like those in Habash, 2007, are more flexible than those other rules. Using just one verb rule, we can perform the reordering of subject, object, preposi-tion modifier, auxiliary verb, negation and the head verb. Although we use manually written rules in this study, it is possible to learn our rules automat-ically from alignments, similarly to Habash, 2007. However, unlike Habash, 2007, our manually writ-ten rules handle unseen children and their order nat-urally because we have a default precedence weight and order type, and we do not need to match an often too specific condition, but rather just treat all chil-dren independently. Therefore, we do not need to use any backoff scheme in order to have a broad cov-erage. Fourth, we use dependency parse trees rather than constituency trees.

There has been some work on syntactic word or-der model for English to Japanese machine transla-tion (Chang and Toutanova, 2007). In this work, a global word order model is proposed based on fea-tures including word bigram of the target sentence, displacements and POS tags on both source and tar-get sides. They build a log-linear model using these features and apply the model to re-rank N -best lists from a baseline decoder. Although we also study the reordering problem in English to Japanese transla-tion, our approach is to incorporate the linguistically motivated reordering directly into modeling and de-coding. We carried out all our experiments based on a state-of-the-art phrase-based statistical machine transla-tion system. When training a system for English to any of the 5 SOV languages, the word alignment step includes 3 iterations of IBM Model-1 training and 2 iterations of HMM training. We do not use Model-4 because it is slow and it does not add much value to our systems in a pilot study. We use the standard phrase extraction algorithm (Koehn et.al., 2003) to get all phrases up to length 5. In addition to the regular distance distortion model, we incor-porate a maximum entropy based lexicalized phrase reordering model (Zens and Ney, 2006) as a fea-ture used in decoding. In this model, we use 4 re-ordering classes ( +1 , &gt; 1 ,  X  1 , &lt;  X  1 ) and words from both source and target as features. For source words, we use the current aligned word, the word before the current aligned word and the next aligned word; for target words, we use the previous two words in the immediate history. Using this type of features makes it possible to directly use the maxi-mum entropy model in the decoding process (Zens and Ney, 2006). The maximum entropy models are trained on all events extracted from training data word alignments using the LBFGS algorithm (Mal-ouf, 2002). Overall for decoding, we use between 20 to 30 features, whose weights are optimized using MERT (Och, 2003), with an implementation based on the lattice MERT (Macherey et.al., 2008).
For parallel training data, we use an in-house col-lection of parallel documents. They come from var-ious sources with a substantial portion coming from the web after using simple heuristics to identify po-tential document pairs. Therefore, for some doc-uments in the training data, we do not necessarily have the exact clean translations. Table 2 shows the actual statistics about the training data for all five languages we study. For all 5 SOV languages, we use the target side of the parallel data and some more monolingual text from crawling the web to build 4 -gram language models.

We also collected about 10K English sentences from the web randomly. Among them, 9.5K are used as evaluation data. Those sentences were translated by humans to all 5 SOV languages studied in this paper. Each sentence has only one reference trans-lation. We split them into 3 subsets: dev contains 3,500 sentences, test contains 1,000 sentences and the rest of 5,000 sentences are used in a blindtest set. The dev set is used to perform MERT training, while the test set is used to select trained weights due to some nondeterminism of MERT training. We use IBM BLEU (Papineni et al., 2002) to evaluate our translations and use character level BLEU for Korean and Japanese. 5.1 Preprocessing Reordering and Reordering We first compare our precedence rules based prepro-cessing reordering with the maximum entropy based lexicalized reordering model. In Table 3, Baseline is our system with both a distance distortion model and the maximum entropy based lexicalized reorder-ing model. For all results reported in this section, we used a maximum allowed reordering distance of 10. In order to see how the lexicalized reordering model performs, we also included systems with and without it ( -LR means without it). PR is our pro-posed approach in this paper. Note that since we ap-ply precedence reordering rules during preprocess-ing, we can combine this approach with any other reordering models used during decoding. The only difference is that with the precedence reordering, we would have a different phrase table and in the case of LR , different maximum entropy models.

In order to implement the precedence rules, we need a dependency parser. We choose to use a deterministic inductive dependency parser (Nivre and Scholz, 2004) for its efficiency and good ac-curacy. Our implementation of the deterministic dependency parser using maximum entropy models as the underlying classifiers achieves 87.8% labeled attachment score and 88.8% unlabeled attachment score on standard Penn Treebank evaluation.

As our results in Table 3 show, for all 5 lan-guages, by using the precedence reordering rules as described in Table 1, we achieve significantly bet-ter BLEU scores compared to the baseline system. In the table, We use two stars (  X  X  X  ) to mean that the statistical significance test using the bootstrap method (Koehn, 2004) gives an above 95% signif-icance level when compared to the baselie. We mea-sured the statistical significance level only for the blindtest data.

Note that for Korean and Japanese, our prece-dence reordering rules achieve better absolute BLEU score improvements than for Hindi, Urdu and Turkish. Since we only analyzed English and Ko-rean sentences, it is possible that our rules are more geared toward Korean. Japanese has almost exactly the same word order as Korean, so we could assume the benefits can carry over to Japanese. 5.2 Reordering Constraints One of our motivations of using the precedence re-ordering rules is that English will look like SOV lan-guages in word order after reordering. Therefore, even monotone decoding should be able to produce better translations. To see this, we carried out a con-trolled experiment, using Korean as an example.
Clearly, after applying the precedence reordering rules, our English to Korean system is not sensitive to the maximum allowed reordering distance any-more. As shown in Figure 5, without the rules, the blindtest BLEU scores improve monotonically as the allowed reordering distance increases. This indi-cates that the order difference between English and Korean is very significant. Since smaller allowed reordering distance directly corresponds to decod-ing time, we can see that with the same decoding speed, our proposed approach can achieve almost 5% BLEU score improvements on blindtest set. 5.3 Preprocessing Reordering and The hierarchical phrase-based approach has been successfully applied to several systems (Chiang, 2005; Zollmann et.al., 2008). Since hierarchical phrase-based systems can capture long distance re-ordering by using a PSCFG model, we expect it to perform well in English to SOV language systems.
We use the same training data as described in the previous sections for building hierarchical systems. The same 4 -gram language models are also used for the 5 SOV languages. We adopt the SAMT pack-age (Zollmann and Venugopal, 2006) and follow similar settings as Zollmann et.al., 2008. We allow each rule to have at most 6 items on the source side, including nonterminals and extract rules from initial phrases of maximum length 12. During decoding, we allow application of all rules of the grammar for chart items spanning up to 12 source words.

Since our precedence reordering applies at pre-processing step, we can train a hierarchical system after applying the reordering rules. When doing so, we use exactly the same settings as a regular hier-archical system. The results for both hierarchical systems and those combined with the precedence re-ordering are shown in Table 4, together with the best normal phrase-based systems we copy from Table 3. Here again, we mark any blindtest BLEU score that is better than the corresponding hierarchical system with confidence level above 95%. Note that the hier-archical systems can not use the maximum entropy based lexicalized phrase reordering models.

Except for Hindi, applying the precedence re-ordering rules in a hierarchical system can achieve statistically significant improvements over a normal hierarchical system. We conjecture that this may be because of the simplicity of our reordering rules. Other than the reordering phenomena covered by our rules in Table 1, there could be still some local or long distance reordering. Therefore, using a hierar-chical phrase-based system can improve those cases. Another possible reason is that after the reordering rules apply in preprocessing, English sentences in the training data are very close to the SOV order. As a result, EM training becomes much easier and word alignment quality becomes better. Therefore, a hier-archical phrase-based system can extract better rules and hence achievesbetter translation quality.
We also point out that hierarchical phrase-based systems require a chart parsing algorithm during de-coding. Compared to the efficient dynamic pro-gramming in phrase-based systems, it is much slower. This makes our approach more appealing in a realtime statistical machine translation system. In this paper, we present a novel precedence re-ordering approach based on a dependency parser. We successfully applied this approach to systems translating English to 5 SOV languages: Korean, Japanese, Hindi, Urdu and Turkish. For all 5 lan-guages, we achieve statistically significant improve-ments in BLEU scores over a state-of-the-art phrase-based baseline system. The amount of training data for the 5 languages varies from around 17M to more than 350M words, including some noisy data from the web. Our proposed approach has shown to be robust and versatile. For 4 out of the 5 languages, our approach can even significantly improve over a hierarchical phrase-based baseline system. As far as we know, we are the first to show that such reorder-ing rules benefit several SOV languages.

We believe our rules are flexible and can cover many linguistic reordering phenomena. The format of our rules also makes it possible to automatically extract rules from word aligned corpora. In the fu-ture, we plan to investigate along this direction and extend the rules to languages other than SOV.
The preprocessing reordering like ours is known to be sensitive to parser errors. Some preliminary error analysis already show that indeed some sen-tences suffer from parser errors. In the recent years, several studies have tried to address this issue by us-ing a word lattice instead of one reordering as in-put (Zhang et.al., 2007; Li et.al., 2007; Elming, 2008). Although there is clearly room for improve-ments, we also feel that using one reordering during training may not be good enough either. It would be very interesting to investigate ways to have efficient procedure for training EM models and getting word alignments using word lattices on the source side of the parallel data. Along this line of research, we think some kind of tree-to-string model (Liu et.al., 2006) could be interesting directions to pursue.
