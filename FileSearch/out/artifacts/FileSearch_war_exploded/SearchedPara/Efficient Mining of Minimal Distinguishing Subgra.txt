 1.1 Motivation Distinguishing patterns are those whose frequencies change significantly from one dataset to another. They are able to capture regions of high differences between two classes of data and emerging trends in business or demographic data, and can be used to construct accurate and robust classifiers. Like other patterns or rules composed of conjunctive combinations of elements, distinguishing patterns can be easily understood and used directly by people. Emerging pattern is such a kind of distinguishing pattern. Emerging patterns show strong distinguishing knowledge and have been shown to be very successful for constructing accurate and r obust classifiers[3], as well as providing intuitive description of sharp differences between classes of data. They have also been used in bioinformatics applications, like predicting the likelihood of diseases such as acute lymphoblastic leukemia and discovering knowledge in gene expression data[2]. The authors of [1] introduced the concept of a distinguishing subsequence, which is a subsequence that appears frequently in one cl ass of sequences, yet infrequently in an-other. Distinguishing subsequences can be applied to the comparison of proteins, design of microarrays, characterization of text and the building of classification models.
Furthermore, since graphs can represent more complicated relationships among dif-ferent objects, distinguishing graphs have raised great interest and played a significant role in the mining of distinguishing patterns. There are many situations where DGPs can be applied, such as comparing structural differences between chemical compounds. 1.2 Preliminary Concepts To simplify our discussion, in the following we introduce some preliminary concepts and notations. The problem of mining minimal DGPs is also formulated.

In this paper, we consider only simple gra phs, i.e., undirected graphs without multi-edges and self-loops. An undirected labeled graph G can be represented by a 6-tuple, G the set of edges in G , L v and L e are the sets of vertex labels and edge labels respectively, F : V  X  L v and F e : E  X  L e are mapping functions assigning the labels to the vertices and edges respectively. A graph G 1 is graph isomorphic to another graph G 2 iff there ex-graph of another graph G 2 iff V 1  X  V 2 and E 1  X  E 2  X  ( V 1  X  V 1 ) . Equivalently, G 2 is the supergraph of G 1 .If G 1 is graph isomorphic to a subgraph g of G 2 ,wesay G 1 is subgraph isomorphic to G 2 and g is an instance of G 1 in G 2 .

An input graph database D is a set of input graphs, the number of graphs in D is denoted by | D | . Given a database D , the number of graphs that contain at least one instance of g is called the support of g w.r.t. D , denoted by sup ( g, D ) . Assume we have a database D defined upon a set of input gr aphs and a partition of D into two sets, the positive class of input graphs(denoted by D p ) and the negative class of in-put graphs(denoted by D n ). The supports of g w.r.t. D p and D n (i.e., sup ( g, D p ) and sup ( g, D n ) )arenamedas positive support and negative support , respectively. While the context is clear, we will omit the dataset names and use psup ( g ) and nsup ( g ) in-stead of sup ( g, D p ) and sup ( g, D n ) , respectively.
 Definition 1. (Distinguishing Subgraph Pattern) Given a database which consists of a positive dataset D p and a negative dataset D n , the positive support threshold  X  and the negative support threshold  X  (  X ,  X   X  [0 , 1] ,  X &gt;&gt; X  ) ,a distinguishing subgraph pattern (abbreviated as DGP) is a subgraph g satisfying the following two constraints: (1) psup ( g ) / | D p | X   X  ,(2) nsup ( g ) / | D n | X   X  .Furthermore, g is a minimal DGP if no proper-subgraph of g is a DGP.
 In the following, by default we assume the input graph database D consists of two classes of graphs, one is positive and the other is negative. The set of positive graphs is denoted by D p , while the set of negative graphs is denoted by D p .
 Problem Statement: Given an input graph database D which is composed of a positive dataset D p and a negative dataset D n , a positive support threshold  X  and a negative support threshold  X  (  X ,  X   X  [0 , 1] , X  &gt;&gt;  X  ) , we study the problem of mining the complete set of minimal DGPs from the database D . Distinguishing pattern mining has been ex tensively studied in recent years, such as emerging pattern and emerging rule mining, distinguishing subsequence discovery[1], contrast graph mining[4] and so on. However, no existing work can be directly used to enumerate interesting differences between classes of graphs. Contrast graphs intro-duced in [4] is defined as the graph structure appears in one positive input graph but never appears in the negative input graphs, which is a special case of DGP on the con-dition that | D p | =1 ,  X  =1 and  X  =0 . Thus, the algorithm they proposed in [4] cannot be applied widely and popularly. DGPs proposed in this paper, however, does not have these restrictions. Therefore, algorithms for mining minimal DGPs can be applied more widely and popularly. Whereas, no previous work were done on this issue and it is urgent to devise new algorithms for mining minimal DGPs.

To our best knowledge, in this paper we propose the first algorithm for mining mini-mal DGPs from two classes of graph datasets. According to the definition of DGPs, we can get a rudimentary solution for mining DGPs. Firstly, we can discover the complete set of frequent subgraphs in D p , denoted by S p . Secondly, we can mine the complete set of frequent subgraphs in D n , denoted by S n . Finally, the set S p  X  S n is the result of DGPs and the minimal DGPs can be generated from it. Apparently, this approach is rather brute-force and will take an un acceptable time. To improve the efficiency of the above method, we use an enumeration strategy to inspect the frequent subgraphs w.r.t. the support threshold  X  in D p . Once inspect a frequent subgraph g in D p ,we check the support of this subgraph in D n .If sup ( g, D n ) / | D n | X   X  , we can say that g is a DGP. Together with other techniques, we can determine whether g is a minimal DGP or not.
 3.1 Enumeration of Positive Frequent Subgraphs Many previous work were done on mining frequent graph patterns, typical examples include gSpan[6], CLAN[5], Cocain*[7] and so on. As shown in previous research, to discover and enumerate the frequent graph patterns in the graph dataset, we need to handle two basic problems discussed in this section.
The first problem is to find a canonical representation of graphs s.t. if two graphs have identical canonical representations, they are isomorphic. The DFS Code intro-duced in [6] is a popular representation of g raphs which is widely used in recent years. Minimum DFS code has a nice property: two graphs g and g are graph isomorphic iff min ( g )= min ( g ) ( min ( g ) represent the minimum DFS code of the graph g ). More-over, with the help of minimum DFS codes, the problem of mining frequent subgraphs is reduced to mining frequent minimum DFS codes which are sequences. After finding a canonical representation for graphs, we need an enumeration strategy to guarantee that we can discover the complete set of frequent subgraphs. Based on the minimum DFS code, DFS Code Tree enumeration strategy was proposed in [6], whose advan-tage and efficiency are verified by the expe rimental results on both real and synthetic datasets. Therefore, this efficient enumeration strategy is also adopted in this work. Fig-ure 2 shows the DFS Code Tree for the frequent subgraph patterns with support 100% in d p in our running example shown in Figure 1. 3.2 Discovery of Minimal DGPs Lemma 1. (Early Pruning) If g is a DGP w.r.t. the positive and negative datasets, then all descendants of this pattern in the DFS Code Tree will not be minimal DGPs. g in the DFS Code Tree, g must be a proper-supergraph of g , according to the property of Frequency Antimonotone[6], sup ( g ,D n ) | D in d p , g must be not a minimal DGP. This is because even g is frequent and is a DGP pattern, it will not be a minimal DGP as one of its proper-subgraph, g , is a DGP.
According to Lemma 1, we can prune unpromising parts of search space. However, we still cannot determine whether a DGP is minimal or not. Even if the current subgraph is a DGP, but we cannot state it is minimal. Therefore, while a DGP is discovered, two operations should be performed. The first one( CHK1 ) checks whether the current pattern is a proper-supergraph of other already discovered DGPs. If so, just discard it. The second( CHK2 ) checks whether the current pattern is a proper-subgraph of already discovered DGPs. If so, remove these patterns and insert this DGP to the result set.
Fortunately, if a DGP p is a proper-supergraph of another DGP p which is discovered before, p will not be enumerated. If p is a descendant of p in the DFS Code Tree, p must be pruned according to Lemma 1; otherwise, if p is generated from other paths, the DFS Code of p must be not minimal and will be pruned by the s = min ( s ) ). Consequently, we do not need to do the operation CHK1. 3.3 Algorithms In this section, we will describe the algorithms used in our solution by integrating vari-ous techniques discussed earlier.
 MDGP-Mine Algorithm. At first, we introduce A LGORITHM 1 MDGP-Mine which can discover the complete set of minimal DGPs. We first scan D p to get frequent edge set E f of D p (line 1). After then, we remove the edges which are not in E f from both D p and D n (line 2). Thirdly, we find the edges in D n which satisfy the negative support constraint. Since these single edges are DGPs and all supergraphs which contain one of them will be not minimal. Therefore, we insert them to the result set directly and remove them from the datasets and E f (line 3). After then, we sort the edges remaining in E f , and call DGP-Enum for each edge to discover minimal DGPs(lines 4-5). DGP-Enum Algorithm. Whereafter, S UB A LGORITHM 2 DGP-Enum for inspecting the frequent subgraphs in D p and mining minimal DGPs will be introduced. First, we check whether current DFS code d is minimal or not, if not we can stop growing d (lines 07-08). Second, we determine whether d is a DGP, if so we insert d to the result ac-cording to the minimal checking scheme and stop growing d in term of Lemma 1(lines 09-11). Meanwhile, if d is not a DGP, we get the extensible DFS edge set E for d (line 12) and sort them(line 13). For each DFS edge e in E ,weadd e into d to get a new DFS code and enumerate it(lines 14-15). We conducted comprehensive experiments to evaluate MDGP-Mine. All experiments were performed on a PC running FC 4 Linux and with 1.8GHz AMD CPU and 1GB memory. Datasets are generated by a synthe tic generator. The parameters accepted by the generator are the same as described in [7]. In Figure 3 a) we fixed the size of positive input graphs | D p | at 40 k and varied the size of negative input graphs | D n | from 50 k to 100 k . While in Figure 3 (b) we fixed | D n | =50 k and varied | D p | from 50 k to 100 k . The results in Figure 3 show that the runtime of MDGP-Mine has a linear relationship with both | D p | and | D n | . Therefore, the algorithm MDGP-Mine is scalable. In this paper, we firstly studied the problem of mining the complete set of minimal DGPs and proposed a novel algorithm MDGP-Mine. Comprehensive experiments show that MDGP-Mine is efficient and scalable.

