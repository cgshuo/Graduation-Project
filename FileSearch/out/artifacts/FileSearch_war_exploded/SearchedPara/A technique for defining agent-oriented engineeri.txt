 1. Introduction
In engineering there is a strong connection between the final quality of the product and the process followed to obtain it. In order to obtain high-quality processes, engineers handle them like any other engineering artifact with the purpose of refining its stages, for instance, or finding inconsistencies, defining support tools, or optimizing it ( Debnath et al., 2007 ). This process management requires its formalization, usually using a process modeling language ( Breton and B ezivin, 2001 ). The formal description of processes allows engineers to share their experi-ence in projects and provide customized support for them. For instance, processes describe stages, tasks, constraints and artifacts that a team must consider in a project.

Agent oriented engineering (AOE) has proved to be suitable in the modeling and developing of complex and distributed systems (Negenborn et al., 2008; Posadas et al., 2008; Xiang and Lee, 2008 ). This success is largely due to the research effort devoted to the definition of methodologies ( Cuesta et al., 2002a,b; Pav  X  on et al., 2005 ). These methodologies describe the artifacts and models needed in a development process. Nevertheless, their use engineers prefer a given process. If the process explicitly describes these features, engineers may use them to make choices that improve their management of the project; this issue has still not been completely explored.

Moreover, the industrial application of processes requires the availability of suitable support tools, namely, editors that allow experts to create the appropriate process models in an automated manner. Several editors have been proposed for this purpose based on process-oriented languages, like a process engineering software (APES) ( IPSquad, 2009 ), the eclipse process framework (EPF) ( EPF, 2008 ) and Metameth ( Cossentino et al., 2006 ). Likewise, Petri-net-based tools ( Van der Aalst and Van
Hee, 1996 ) were previously used to define processes. However, the existing tools lack relevant features; in particular, they usually constraint the process types that can be defined, because they consider only part of the common concepts in the literature.

Based on the previous analysis, this paper proposes a new technique, with its related tool support, for the definition of
AOE process models. This technique has been applied to define processes for creating both hardware and software agents, concerning multiple domains such as holonic systems, scheduling, manufacturing and automotive industries. It is based on the process and methodology definitions proposed by Cernuzzi et al. (2005) . However, our work considers that a methodology can be applied following different development processes. The metho-dology defines non-changing aspects such as the entities of the models and the roles implied; the choice of the process depends on the project features. This approach allows a team to use a particular methodology and dynamically change the process to adapt to new constraints.

This work considers process models, at a high level of abstraction, as a dependency graph. This graph has three basic components: the process participants (i.e. roles and workers ), the consumed and generated products (i.e. work products ), and the activities and tasks undertaken during the process, these being particular instances (i.e. work definitions ) of the work to be done. Most processes require additional guidance or suggestions as to the activities to be performed and when they should be completed. In addition, modeling processes require several orthogonal and complementary views. Each of these views provides a partial explanation of the whole process and allows its gradual definition. This kind of approach is commonly adopted to describe complex models.

AOE projects face the problem of their products including a wide range of artifact types, such as software, robots, knowledge, organizations, workflows and reconfigurable hardware ( Nwana, 1996; Naji et al., 2004 ). Thus, a fundamental challenge is to find a standard language for process definition capable of dealing with such a variety. The Methodology Technical Committee (Cossentino and Garro, 2005 ) of the Foundation for Intelligent Physical Agents (FIPA) has suggested the use of the software &amp; systems process engineering metamodel (SPEM) ( O.M.G., 2008 ) for this purpose.
SPEM is a standard defined by the Object Management Group (OMG) to model engineering processes. It is specified as a UML profile ( O.M.G., 2007 ) and currently has a stable version, which is 2.0. Although SPEM was initially proposed to model software processes, it has also been applied in other fields. For instance, the document with the latest version of the standard ( O.M.G., 2008 ) contains examples of its use in hardware design and economical investment.

This work also provides an open-source editor tool for defining process models with the proposed technique. This tool has been generated with a model-driven development (MDD) ( Atkinson and Kuhne, 2003 ) approach from a metamodel that represents the complete SPEM standard ( O.M.G., 2005 ).
 focused on exemplifying and documenting the activities previously defined.

The next subsections discuss these steps in further detail. 2.1. Lifecycle
The process specification starts by modeling a particular lifecycle for development. In this definition, the analyst sets aside the participants and products, and focuses on the definition of the activities to be accomplished in each step. The development process is divided into consecutive phases, and each of these in a different number of iterations depending on the phase.
The specification of the lifecycle follows an iterative and incremental process that includes several steps. The technique begins by defining the elements (i.e. phases, iterations and activities) that constitute the lifecycle and their temporal relationships. Each phase (e.g. inception, elaboration, construction or transition) includes a number of iterations, which are sequences of activities to achieve a particular goal. After defining the phases, the minimum and maximum number of iterations allowed for each phase must be determined. Finally, the individual activities of the iterations are modeled. These activities represent atomic actions to be accomplished.

After specifying the development process with the activities to perform in each iteration, designers define the disciplines related with these activities. 2.2. Disciplines
Disciplines in SPEM determine process packages that take part in the process activities related with a common subject. The definition of the discipline concept has changed from the initial standard of SPEM 1.1 ( O.M.G., 2005 ) to the 2.0 standard ( O.M.G., 2008 ). In SPEM 1.1, disciplines represent a specialization of selected subactivities, where these new subactivities cannot appear in other packages or disciplines. However, in SPEM 2.0, a discipline is a categorization of work (i.e. tasks for method content ), based upon similarity of concerns and cooperation in work effort.
The technique proposed in this paper can be used with any of the standards, although the considered standard will influence the degree of granularity of the disciplines model.

For a better understanding of disciplines, designers must detail the participants before defining the subactivities (i.e. tasks) that constitute each discipline. The definition of participants is made based on the different roles that each of them will play throughout the project and the products to be obtained. For instance, in the case studies several participants have been defined, like analyst and scrum master; these participants obtain products such as the use case model or the scenarios view.
Once the participants, products, disciplines and processes are defined, each activity must be divided for each iteration depending on the tasks pertaining to each discipline. The activities must be performed by any of the specified participants, and they can consume/produce any of the existent products.
In this step, the process is similar to the previous ones, but it includes the relationships between activities and tasks. Activities and consumed/produced products cannot be related directly, so designers use the disciplines and roles to establish this relationship. 2.3. Guidances
The guidances provide information about certain modeling elements. Each guidance is associated to a guidance kind . SPEM definition stage for the generation of the tool must be considered in order to adapt the metamodel where necessary.

EMF can automatically generate the editor from the SPEM metamodel in ECore. Since there can be alternatives and potential errors in the specification of the metamodel, the results of this automatic generation may differ from those expected. If testing shows that changes are necessary, the metamodel is modified in the design phase and the tool is generated again.

When the tool is considered sufficiently stable, the develop-ment process reaches the maintenance phase and the tool is delivered to the user. In particular, the editor tool was used for defining the INGENIAS ( Pav  X  on et al., 2005 ) processes that appear in the case studies (see Section 4). In the definition of INGENIAS processes, the tool revealed certain problems, such as usability problems and missing modeling concepts. Such problems, and the improvements suggested by users, are addressed in the main-tenance phase. This feedback may imply returning to the design phase to change the metamodel. 3.2. SPEM structural features
The definition of the metamodel using the guideline proposed (Garc  X   X a-Magarin  X  o et al., 2009a ), requires the consideration of the structural features inherent to SPEM. These SPEM features are:
Feature 1. Entities with attributes . In SPEM, most entities have attributes. WorkDefinition and Process entities are examples of this.

Feature 2. Relationships with attributes . For example, the precedes relationship includes an attribute called PrecedesKind .
Feature 3. Relationships with attributes in their ends . The associa-tion relationship has several attributes, such as isNavigable and multiplicity .

Feature 4. N-ary relationships. ParentWork , for example, is a many-to-many relationship that connects a set of WorkDefinition entities to a set of WorkDefinition entities as their children.
Feature 5. Several kinds of relationships . For instance, some of the relationships in SPEM are precedes and association .

Feature 6. Entity hierarchy . This hierarchy uses inheritance to propagate attributes from super-entities to their sub-entities. This makes the definition of new entities more robust and easy. For example, entities such as Namespace , GeneralizableElement or parameter extend the ModelElement entity, and the classifier extends the GeneralizableElement entity.

Feature 7. Relationship hierarchy . This hierarchy also uses the attribute inheritance, providing the same advantages as the entity hierarchy. For example, SPEM contains an abstract relationship called relationship , which is extended with several relationships such as generalization , association and dependency . the relationships between activities, their iterations and phases are defined. Fig. 3 shows a snapshot of the definition of the precedence relationships among lifecycle, phases and iterations. Disciplines for INGENIAS UDP . The disciplines included in the
UDP for INGENIAS are RequirementsSpecification , Analysis , Design and Implementation . The INGENIAS methodology suggests that, before detailing the subactivities (i.e tasks ) that constitute each discipline, the analyst must identify the participants. This definition is based on the different roles that each participant will play throughout the project and the products used. The roles that must be defined are as follows: analyst , architect , developer , tester , project manager and freeman . The products are the following: use case diagram , environment model , organization model , interaction model , agent model , object and task model , glossary , NonFunctional requirement and stakeholder vision .
Guidances for INGENIAS UDP . The most relevant INGENIAS guidances are described below in this section. The reader can see their definition using the editor tool in Fig. 4 . This figure contains the entities related to the Guidances, but it does not show the relationships for the sake of brevity. These entities are guidance, guidance kinds, external descriptions and work products. The defined guidances are: General technique . It explains how to develop a complete INGENIAS specification intended to generate running code.
This technique offers the means of developing a general product. The general product is supposed to be any kind of product.

Model-driven technique . This guideline recommends the user to follow the MDD ( Atkinson and Kuhne, 2003 principles in
INGENIAS, as described by Pav  X  on et al. (2006) . Basically, the user edits the MAS specification using the INGENIAS develop-ment kit (IDK) editor. This specification is the model on which the development is based. In the specification, the user can add pieces of code to specify the fine-grained behavior of elements.
As this code belongs to the specification, it is not overwritten when the system is generated. Working only on the specifica-tion fastens the process as it avoids distributing the specifica-tion and code in different artifacts that must be kept Fig. 5 shows some guidance external descriptions for the UDP in
INGENIAS. The properties tab shows the attributes content, language, medium and name. In this case, the reader can see the beginning of the external description of the model-driven technique. 4.2. INGENIAS with scrum process
The second case study comprises the definition of a process model that adapts the scrum development process for its use with the INGENIAS methodology ( Pav  X  on et al., 2005 ). A Scrum is a rugby technique whereby the ball is put back into play. The term was adopted in 1987 by Ikujiro Nonaka and Hirotaka Takeuchi to describe hyper-productive development. As pointed out by
Schwaber and Beedle (2001) , Scrum is an empirical agile project management framework that is used to iteratively deliver high value increments to the customer. Scrum relies on self-organizing teams to deliver these increments. The customer and the product owner are responsible for providing the development team with a list of desired features using business value as the mechanism for prioritization. The discussion should make it clear that Scrum is a model for the management of the process of development. It is not a methodology, yet a framework that can cover several meth-odologies.
 Once the steps for modeling a new process contained in
Section 2 have been applied to scrum, the results can be summarized as follows: (1) Process model :, The creation of a new version of a work (2) Lifecycle : In scrum, each release is produced in a number of completely new product backlog with the editor. For instance, the
IDK 2.7 distribution comes with a complete cinema project. This project can be used for other distributed e-commerce develop-ments in which the user needs to access the information and/or description of the product jointly with its location, check the products according to particular preferences, and then decide to buy or not to buy the product.

After the completion of this initial model, the scrum master and the product owner establish in the preparation tasks the plan release . This plan release defines the sprints necessary for the product.

To complete the initial product backlog and the preparation tasks, it must be taken into account that an agent in the IAF performs a simple deliberation cycle:
The identification of new tasks to be scheduled and of tasks to be removed from the schedule . A task is scheduled if it is capable of satisfying a pursued goal and its input facts are available in the mental state of the corresponding agent. A task is removed from the schedule if its objective has already been achieved or some of its input facts are not available.
 The Execution of one scheduled task .

This deliberation cycle omits the classic perception step. This step is not needed because the arrival of new information at any moment does not cause any kind of internal conflict for the agent.
The addition of new pieces of information does not imply a change in the already scheduled tasks, although it may add new ones.
These changes are described with the IDK, mainly modifying the agent , interaction and task and goal models.

From the scrum perspective, the project team must be completely involved in the consecution of the release within the planned sprints. The following tasks must be performed in each sprint (see Figs. 8 and 9 ): plan sprint , update product backlog , daily works , manage problems , conduct scrum daily meeting , review sprint , and conduct retrospective .
 Disciplines for INGENIAS-scrum . As previously discussed, in the
INGENIAS-scrum approach the disciplines are the tasks required in each sprint. This subsection explains the intended meaning of each task as related to the IAF. Firstly, according to the guidelines for the scrum process in INGENIAS ( Garc  X   X a-Magarin  X  o et al., be done from the point of view of the development team. It can be regarded as fine-grained planning of detailed tasks. The product increment is a partial product obtained at the end of each sprint, which can only be deployed in the production environment or also made available to users.
 From the INGENIAS-scrum perspective, those artifacts are the INGENIAS model and the JADE code produced in each release.
An INGENIAS model can describe a system at both a low and high level of detail. In the description of each model, the scrum master can establish the work required in the next release, while a release may be identified with a package entity of the INGENIAS model.

According to these roles and products, the tasks that must be performed during a development cycle are the following: Initiate product backlog . See the previous subsection. Preparation tasks . See the previous subsection.
 Plan release . See the previous subsection.

Sprint planning . It involves the following steps: define the sprint X  X  goal, select the items, identify tasks from items, estimate tasks, assigning tasks and getting team commitment .

Update product backlog . The update should consider the scope of the changes introduced in the current sprint before planning the next sprints. It must be performed in three steps: collecting changes, reprioritizing items and re-estimating items .
Daily scrum . The team performs backlog tasks to reach the sprint goal free of burdens. Each scrum team selects the tasks to be performed or modified in that sprint.

Sprint retrospective . It allows the feedback and adaptation of the process.

Sprint review . It contains the changes and works that have been done in the sprint. These artifacts will be available for the next sprints.

Problem management . Considering the problems that con-stantly arise in a project and seeking solutions.
 Release work . The last sprint prepares the product release.
Guidance for INGENIAS-scrum . To the best of our knowledge, the same guidance used for UDP can be followed in the INGENIAS-scrum process. 5. Discussion and comparison of the results
This section compares the presented technique and tool with related works. To the best of our knowledge, there are no explicit descriptions in the literature on how to use editor tools for defining process models. This means that the proposal introduced in this paper can only be compared with other languages, tools and the language used for creating the editor metamodels.
This comparison entails qualitative and quantitative features as explained in the following subsections. 5.1. Qualitative comparison of tools
Although there is an increasing interest in process modeling and standardization in AOE encouraged by FIPA Methodology
Technical Committee ( Cossentino and Garro, 2005 ), there are still few tools that enable development process definition. This section discusses APES ( IPSquad, 2009 ), EPF ( EPF, 2008 ) and Metameth (Cossentino et al., 2006 ) as the most relevant tools.
APES ( IPSquad, 2009 ) is a process modeling software that, according to its authors, follows the SPEM 1.1 specification (O.M.G., 2005 ). The tool has several relevant features, such as its compliance with the standard, and the functionalities for the contrary, in our approach a technique for defining processes complements the tool. 5.2. Metrics for the quantitative comparison
Although most process tools state that they use SPEM for the defining of their metamodels, they usually cover just a subset of
SPEM. This section compares these subsets in order to measure the suitability of the existing tools for the process modeling needs.
In addition, the usability of tools is also considered. Given that there can be a variety in the requirements for process modeling languages depending on the considered methodologies, the experiments for comparison considered in this work focus on
MAS-related processes. The next subsections describe the metrics that are used for the quantitative comparison.
 Availability metric . The goal of the availability metric ( Garc  X   X a-
Magarin  X  o et al., 2009c ) is to measure the suitability of a modeling language for a particular problem domain. The higher the value of this metric, the more suitable the modeling language is for the problem domain. A low value indicates that the language does not have concepts that engineers consider necessary.

The idea behind this metric is that, for a particular problem domain, some concepts of the language are necessary and others are not. The availability metric measures the percentage of these necessary concepts that are contained in the modeling language.
The metric is defined with the ratio indicated in Eq. (1). In the equations of this paper, nc indicates the number of necessary concepts (i.e. metamodeling elements) in the modeling of the particular problem domain; and ncmm indicates the number of these necessary concepts that are actually contained in the metamodel. The concepts studied can be either entities, relation-ships or other kinds of metamodeling elements. availability  X  ncmm nc  X  1  X 
The set of necessary concepts for a particular problem domain must be adapted according to the process modeling language, i.e. the user must adhere to the concepts that the metamodel contains. Given a metamodel, the user decides which concepts are necessary for solving a particular problem. Once this set is selected, the user must detect if any concept is missing for solving the problem, denoting the number of these missing concepts as mc . Thus, Eq. (1) can be rewritten as Eq. (2), which also calculates the availability metric. The best result is obtained when there are no missing concepts (i.e. mc  X  0); in this case, the availability measurement is the unity (i.e. 100%). availability  X  ncmm ncmm  X  mc  X  2  X 
This metric depends on the expertise of the user about the utility of the concepts of the process modeling language for a particular problem domain. In order to reduce these variations, the presented framework recommends the two following guards.
Firstly, when comparing a set of modeling languages, the same person must evaluate all of them. Secondly, a large number of users must evaluate the collection of modeling languages to statistically reduce the mentioned variations. These statistical assumptions are already applied to successful empirical cost estimation methods such as COCOMO ( Boehm et al., 1995 ). Specificity metric . The goal of the specificity metric ( Garc  X   X a-
Magarin  X  o et al., 2009c ) is to measure the percentage of the modeling concepts that are actually used for modeling a particular problem domain. If the value of this metric is low, it means there are many concepts that are not used for modeling the problem domain. Accordingly, the scope of the modeling language is probably broader than necessary. In contrast, if the value of the methodology ( Chella et al., 2006 ), and the OPEN process framework (OPF) adapted for Tropos ( Henderson-Sellers et al., 2004 ).
Table 1 presents the results obtained in this experiment. The availability is probably the most relevant metric in this comparison, as it is fundamental that the editor supports the elements needed by users. The availability measurement of the presented editor is 98.4%, which indicates that it supports most of the elements needed by users for the mentioned process domains.
EPF offers an availability of 84.2%. For instance, the concept of steps within the tasks (i.e. activities) is missing in EPF. Finally,
Apes2 only supports some of the necessary elements with the lowest availability, just 28.2%. Thus, the editor presented in this paper gets the best results.

The specificity metric obtains high results when the tool supports few unnecessary elements. As one can observe in Table 1 ,
EPF obtains the highest result for specificity, 87.5%. On the contrary, the presented editor obtains the lowest value, 46.3%.
The reason for this measurement value is that the presented editor completely supports the SPEM standard, and therefore it includes some modeling elements not required for the considered process models, but needed when considering different process models.

In short, the presented editor supports more process modeling elements than other existent tools. This makes the availability of concepts for modeling processes the highest (98.4%) but, on the other hand, in most cases only a small subset of the elements is actually used (46.3%). Thus, the results of the comparative show the appropriateness of the presented tool for modeling AOE processes. It can define complex and detailed AOE process models because of the availability of a large variety of modeling concepts.
This is a relevant feature given the variety of processes considered in AOE.

Another important aspect is the usability measurement that applies the metrics presented in Section 5.2. For this experiment, the same group of testers was asked to measure the usability metrics for all the considered tools. For this test, the UDP definition within the context of the INGENIAS methodology was used (see Section 4.1).

Table 2 shows the average of the usability measures for the different tools. As one can observe, the best result is obtained by modeling tools. The combined use of the technique and the tool is aimed at facilitating the specification of processes for non-expert engineers.
 The paper illustrates the approach with the definition of the UDP and scrum processes for the INGENIAS methodology.
The INGENIAS AOE methodology has been applied in several engineering fields such as manufacturing systems, knowledge management, business workflow definition and multisensor surveillance. The UDP and Scrum processes are applied to create MAS that can include both software and hardware agents.
These experiments and the use of a general-purpose language for process definition, i.e. SPEM, provide a partial support for the claim that the approach is applicable to different engineering fields.

From the AOE perspective, another important result is that an example of a methodology that can follow several processes is made available. This example reinforces the idea that methodol-ogies and processes can be considered in two orthogonal and coupled dimensions that address different needs of projects.
The technique and tool proposed in this paper will undergo further experimentation in future works in order to define other processes and methodologies. These experiments are aimed at satisfying several goals. Firstly, they are expected to offer additional evidence on the general applicability of the approach in different engineering domains. Secondly, these experiments will allow the refinement of the technique to provide specific steps for explicitly considering the features of given methodolo-gies and processes. The models that are constructed in this way can assist designers in selecting the appropriate methodology and process model for a specific project. Thirdly, this definition of models also constitutes a basis for comparing processes.
The definition of the suitable metrics for this comparison is still an open issue. Fourth, the technique and tool presented can be further compared to other approaches in the literature. In particular, Petri-nets-based approaches ( Van der Aalst and Van
Hee, 1996 ) for defining processes can be considered, as well as their mechanisms incorporated for controlling some changes in dynamic process models. Finally, the contributions of the current paper can also be useful for the purpose of dividing processes into fragments ( Henderson-Sellers and Gonzalez-Perez, 2005 ). After this fragmentation, pieces from different processes can be combined to define new processes customized for specific settings.
 Acknowledgments This work is supported by the  X  X  X gent-based Modelling and Simulation of Complex Social Systems (SiCoSSys) X  X  project of the
Spanish Council for Science and Innovation (Grants TIN2008-06464-C03-01 and TIN2005-08501-C03-03), FEDER funds, and the
Grant for Research Group 910494 from the Region of Madrid (Comunidad de Madrid) and the University Complutense of Madrid.

Appendix A. Definition of the metamodel for generating the presented editor tool
This section provides details concerning the definition of the metamodel that generated the subject editor tool by means of the
EMF ( Budinsky, 2003 ). Practitioners can download the complete metamodel from the  X  X  X dditional material for papers X  X  section in the  X  X  X oftware X  X  section at http://grasia.fdi.ucm.es/ .
Deciding the appropriate metamodel structure is required to guarantee the tool usability, because, as the editor tool is generated from the metamodel, the specification models and the pop-up dialogs of the editor-tool depend on the metamodel. In particular, elements are grouped in the presented metamodel according to the original SPEM packages, which are core, actions, state machines, activity graphs, model management, basic elements, dependencies, process structure, process components and process lifecycle . The aforementioned structure is represented with the following ECore elements:
An EClass called specification for the root of the specification model . This EClass has containment EReferences that point EClasses representing SPEM packages.
 An EClass for each SPEM package . Each of these EClasses has two
EReferences, these being an entities container and a relation-ships container respectively.

An EClass for representing an entities container for each SPEM package.
 An EClass for representing a relationships container for each SPEM package.

In conclusion, in the presented tool, the structure of both the specification models and the pop-up dialogs is similar to the SPEM structure. This circumstance improves the usability of the tool, because engineers are usually familiar with the SPEM specifica-tion ( O.M.G., 2005 ) and the tool presents the information in a similar way.

