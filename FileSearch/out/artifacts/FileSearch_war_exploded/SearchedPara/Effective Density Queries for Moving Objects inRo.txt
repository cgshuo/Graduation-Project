 The advances in mobile communication and database technology have enabled innovative mobile applications monitoring moving objects. In some applications, the object movement is constrained by an underlying spatial network, e.g., ve-hicles move on road networks and trains on railway networks. In this scenario, objects can not move freely in space, and t heir positions must satisfy the network constrains. A network is usually modeled by a graph representation, comprising a set of nodes (intersections) and a set of edges (segments). Depending on the application, the graph may be directed, i.e. each edge has an orientation. Addi-tionally, moving objects are assumed t o move in a piecewise linear manner [6], i.e., each object moves at a stable velo city at each edge. The distance between two arbitrary objects is defined as the network distance between them on the network. Several types of queries have been studied in the road network, such as kNN queries [7], range queries [9], aggregate nearest neighbor queries [11], reverse nearest neighbor queries [12].

In this paper, we focus on the problem of dynamic density queries for moving objects in road networks. The objective is to find dense areas with high concen-tration of moving objects in a road network efficiently. The density query can be used in the traffic management systems to identify and predict the congested areas or traffic jams. For example, the transportation bureau needs to monitor the dense regions periodically in order to discover the traffic jams.
Existing research works on the density query [2,4] assume the objects moving in a free style and define the density quer y in the Euclidean space. In this setting, the general density-based queries ar e difficult to be answered efficiently and their focus is hence turned to simplified queries [2] or specialized density queries without answer loss [4]. These methods use the grid to partition the data space into disjoint cells and report the rectan gle area with the fixed size. However, the real dense areas may be larger or smaller than the fixed-size rectangle and appear in different shapes. Simplifying the d ense query to return the area with fixed size and shape can not reflect the natural congested area in real-life application. We focus on the density query in the road-network setting, where the dense area consists of road segments containing large number of moving objects and may be formed in any size and shape. The real congested areas can therefore be obtained by finding the dense segments. In addition, for querying objects moving in a road network, the existing methods based on a regular spatio-temporal grid ignore the network constraint and therefore result in inaccurate query results.
Considering the real-life application, finding dense regions for a point in time is more useful than finding the dense regions for a period of time [4]. In this paper, we study the querying for dense regions consisting of dense segments for a point in time. For monitoring the dense areas of moving objects in the road network, the dense query requests need to be issued periodically in order to find the changes of dense areas. If we use the existing methods, the total cost is quite high since each query request requires accessing all objects in the road network. Since clustering can represent the dense areas naturally, we propose a cluster-based method to process density querie s in a road network. The moving objects are first grouped into cluster units on each road segment according to their locations and moving patterns. Then the cluster units are maintained continu-ously. The process can be treated as a separate pre-processing for the periodical density queries. For density query processing, we use a two-phase algorithm to identify the dense areas based on the su mmary information of the cluster units. Maintaining cluster units comes with a cost, but our experimental evaluations demonstrate it is much cheaper than keeping the complete information about individual locations of objects to process the dynamic density queries.
Our contributions are summarized as follows:  X  We define the density query for moving objects in road networks that is  X  We propose a cluster-based algorithm to efficiently monitor the dense areas  X  We show, through extensive experiments, that our query algorithms achieve
The rest of the paper is organized as fo llows. Section 2 reviews related work on density query processing and clustering moving objects. Section 3 gives the problem definition. Section 4 details our density query method including dynamic cluster maintenance and two-phase quer y algorithm. Experim ental results are shown in Section 5. We conclude this paper in Section 6. Density query for moving objects is first proposed in [2]. The objective is to find regions in space and time that with the density higher than a given threshold. They find the general density-based queries difficult to be answered efficiently and hence turn to simplified queries. Speci fically, they partition the data space into disjoint cells, and the simplified dens ity query reports cells, instead of arbi-trary regions that satisfy the query conditions. This scheme may result in answer loss. To solve this problem, Jensen et al. [4] define an effective density query to guarantee that there is no answer loss. The two works both assume the objects moving in a free style and define the density query in Euclidean space. However, efficient dynamic density query in spatial networks is crucial for many applica-tions. As an example of a real world, considering that the queries correspond to vehicles distribution in the road network, the users would like to know real-time traffic density distribution. Clearly, in this case the Euclidean density query methods are inapplicable, since the path between two cars is restricted by the underlying road network. Additionally, these existing query methods can not re-flect the natural dense area in a road network since they simplify the dense query to return the area with fixed size and shape. The grid-based algorithms also ig-nore the network constraint and result i n inaccurate query res ults. It is natural to represent the dense area in a road network as road segments containing large number of moving objects. We exploit the network property and define effective road-network density query ( e -RN DQ ) to return the natural density areas with arbitrary size and shape in the road network.
 Existing network based clustering algorithms are also related to our work. Jain et al. [3] use the agglomerative hierarchical approach to cluster nodes of a graph. CHAMELEON [5] is a general-purpose algorithm, which transforms the problem space into a weighted kNN graph, where each object is connected with its k nearest neighbors. Yiu and Mamoulis [10] define the problem of clustering objects based on the network distance and propose algorithms for three different clustering paradigms, i.e., k-medoids for K-partitioning, -link for density-based, and single-link for hierarchical clustering. The -link method is most efficient to find dense segments in road network. However, all these solutions assumed a static dataset. Li et al. [6] propose the micro moving cluster (MMC) to clustering moving objects in Euclidean spaces. Our clusteri ng algorithm focuses on moving objects in the road network which exploits the road-network features and provides the summary information of moving obj ects to density query processing.

There are some other related works on q uery processing in spatial network databases [1,7,11]. Their focus is to evaluate various types of queries based on the network distance by minimizing the cost of the expensive shortest path computation. To the best of our knowledge, this is the first work which specifies on the cluster-based method for dynamic density queries in spatial networks. As the result of density queries in the road network are the set of dense segments, we first introduce the concepts of density and dense segment .
 Definition 1. Density. Thedensityofaroadsegment s is represented as density Definition 2. Dense Segment ( DS ) . The road segment s is a dense segment (DS) if and only if density(s)  X   X  ,where  X  is a user-defined density parameter. A straightforward method to process the query is to traverse all objects mov-ing on a road network to compute dense regions by their number, the length of the segment and a given density threshold. Figure 1 shows a density query in a road network. Obviously, the cost is very high and it is difficult to find ef-fective results. Specifically, the query r esults may have three problems as follows: 1) The different DS may be overlapped, such as Case 1 in Figure 1. 2) The distribution of moving objects may be very skewed in some DS , namely, the distribution of objects is dense in one part of a DS , but it is sparse in another part, such as Case 2 in Figure 1. 3) Some DS may contain very few objects, such as Case 3 in Figure 1.
Such query results are less useful. Thus, we define an ef f ective density query in a road network to find the useful dense regions with a high concentration of objects and symmetrical distribution of objects as well as no overlapping. Definition 3. Effective Road-Network Density Query ( e-RNDQ ) : Given density parameter  X  , find all dense segments that satisfy the following conditions : 1. Any dense segment set can not be intersecting (namely no overlaps). 2. In each dense segment set, the distance between any neighboring object is not more than a given distance threshold  X  . 3. The length of dense segments is not less than a given length threshold L . 4. Any dense segment containing moving objects is in the query result set. The first condition ensures that the result is not redundant. It avoids the case 1 in Figure 1. The second condition guarantees that objects are symmetrically distributed in a dense segment set. The third condition provides restriction that there is no small segments that only cont ain few objects in the result. The fourth condition ensures that query results do not suffer from answer loss. 4.1 Overview Considering the feature of road networks, we propose a cluster-based density querying algorithm, which regards clustering operation as a pre-processing to provide the summary information of moving objects. In the query processing, we develop a two-phase filter-and-refinement algorithm to find dense areas. 4.2 Cluster-Based Query Preprocessing To reduce the cost of clustering maintenance, we introduce the definition of Cluster Unit. A cluster unit is a group of moving objects close to each other at present and near future time. It will be incrementally maintained with moving of objects in it. Specifically, we constrain the objects in a cluster unit moving in the same direction and on the same segment. F or keeping the objects in a cluster unit dense enough, the network distance between each pair of neighboring objects in a cluster unit does not exceed a system threshold . As mentioned in Introduction, we assume that objects move in a piecewis e linear manner and the next segment to move along is known in advance. Formally, a cluster unit is defined as follows: Definition 4. Cluster Unit ( CU ) . A cluster unit is represented by CU= ( O, n o to n a , speed i is the moving speed and ( n b ,next node ) is the next segment to move along. Without loss of generality, assuming pos 1  X  pos 2  X   X  X  X   X  pos n , it must satisfy | pos i +1  X  pos i | X  (1  X  i  X  n  X  1) . Since all objects are on the same segment ( n a ,n b ) , the position of the CU is determined by an interval ( head, tail ) in terms of the network distance from n a . Thus, the length of the CU is | tail  X  head | . ObjNum is the number of objects in the CU.
 Initially, based on the definition, a set of CU are created by traversing all seg-ments in the network and their associated objects. The CUs are incrementally maintained after their creation. As tim e elapsed, the distance between adjacent objects in a CU may exceed . Thus, we need to split the CU. A CU may also merge with its adjacent CUs when they are within the distance of . Hence, for each CU, we predict the time when they m ay split or merge. The predicted split and merge events are then inserted int o an event queue. Afterwards, when the first event in the queue takes place, we process it and update the affected CUs. This process is continuously repeated. The key problems are: 1) how to predict split/merge time of a CU, and 2) how to process a split/merge event of a CU.
The split of a CU may occur in two cases. The first one is when CU arriving at the end of the segment (i.e., an intersection node of the road network). When the moving objects in a CU reach an intersection node, the CU has to be split since they may head in different directions. Obviously, a split time is the time when the first object in the CU arrives at the node. In the second case, the split of a CU is when the distance between some neighboring objects moving on the segment exceed . However, it is not easy to predict the split time since the neighborhood of objects changes over time. Therefore, the main task is to dynamically maintain the order of ob jects on the segment. We compute the earliest time instance when two adjacent objects in the CU meet as t m .We then compare the maximum d istance between each pair of adjacent objects with until t m . if this distance exceeds at some time, the process stops and the earliest time exceeding is recorded as the split time of CU. Otherwise, we update the order of objects starting from t m and repeat the same process until some distance exceed or one of the objects arrives at the end of the segment. When the velocity of an object changes over the segment, we need to re-predict the split and merge time of the CU.

To reduce the processing cost of splitting at the end of segment, we propose group split scheme. When the first object leaves the segment, we split the original CU into several new CUs according to obj ects X  directions (which can be implied by next node ). On one hand, we compute a to-be-expired time (i.e., the time until the departure from the segment) for each object in the original CU and retain the CU until the last object leaves the segment. On the other hand, we attach a to-be-valid time (with the same value as to-be-expired time )foreach object in the new CUs. Only valid object s will be counted in constructing CUs.
The merge of CUs may occur when adjacent CUs in a segment are moving together (i.e., thei r network distance  X  ). To predict the initial merge time of CUs, we dynamically maintain the boundary objects of each CU and their validity time (the period when they are treated as boundary of the CU), and compare the minimum distance between the boundary objects of two CUs with the threshold at their validity time. The boundary objects of CUs can be obtained by maintaining the order of objects during computing the split time. The processing of the merge event is similar to the split event on the segment. We get the merge event and time from the event queue to merge the CUs into one CU and compute the split time and merge time of the merged CU. Finally, the corresponding affected CUs in the event queue are updated.
Besides the split and merge of CUs, new objects may come into the network or existing objects may leave. For a new object, we locate all CUs of the same segment that the object enters and see if the new object can join any CU ac-cording to the CU definition. If the object can join some CU, its split and merge events are updated. If no such CUs are found, a new CU for the object is created and the merge event is computed. For a leaving object, we update the split and merge events of its original CU if necessary. Due to the limitation of the space, we omit the algorithm pseudo of maintaining CUs. 4.3 Density Query Processing Based on the dynamic CUs, density query at any time point can be processed ef-ficiently to return dense areas in the road networks. And then the dense segment (DS) we defined in Section 3 is represented as ( CU , n a , n b , startpos , endpos , len , N ), where CU is the set of cluster units on segment ( n a , n b ), startpos is the start position of the DS, and endpos is the end position of the DS, len is the length of DS, N is the number of objects. To obtain the effective dense areas restricted in the e-RNDQ, we introduce the parameter  X  to DS.
 Definition 5.  X  -Dense Segment (  X  -DS ) .ADSis  X  -DS if and only if the dis-tance between any adjacent CUs is not more than  X  (i.e. guarantee that the distance between any adjacent object satisfies Distance ( o i ,o i +1 )  X   X  ), and density is not less than  X  . (For convenience, we abbreviate the term  X  -DStoDSinthe sequel) In fact,  X  is a user-defined parameter of the density query and is a system parameter to maintain the CUs. Since the distance of adjacent objects is not more than in a CU, in order to retrieve dense areas based on CUs, we require  X  max {  X , 1 segment set, which may contain several DSs in different segments. Therefore, we exploit network nodes to optimize the combination of these DSs.
 Definition 6.  X  -ClusterNode (  X  -CN ) .IneachDS, n a is  X  -CN of the DS, if and Definition 7. Dense Segment Set ( DSS ) . A DSS consists of different DSs where the distance between adjacent DSs is not more than  X  and the total length of DSs in the DSS is not less than L, the density in the DSS is not less than  X  . Actually, DSS may contain DSs located in different segments where DSs are joined by  X  -CN. DSS constitutes the road-network density query results. Sup-pose the density query p arameter is given as (  X ,  X , L, t q ), where t q is the query time. For query processing based on CUs, our algorithm includes two steps: (1) The filtering step: Merge CUs into DSs by checking the parameter of  X  and  X  , which can prune some unnecessary segments. In this step, we can obtain a series of dense segments, specifically, a list of DSs and  X  -CNs.
 Algorithm 1. Filter (  X ,  X , t q ) (2) The refinement step: Merge the adjacent DSs around  X  -CNs to con-struct DSS by checking the parameter of  X  ,  X  , L and finally find out the effective density query result consisting of dense segment sets.

We explain the two steps of density query processing in detail. Firstly, accord-ing to network expansion approach [8], we traverse each segment to retrieve CUs sequentially, then compute the distance between adjacent CUs and the density of them. If the distance is not more than  X  and the density is not less than  X  ,the CUs are merged to be a DS. Figure 2 shows an example. Given  X  =1.5 and  X  =2, we compute DS at query time t q . The road segment s 1 (represented as &lt;J 1 , J 2 &gt; ) includes two CUs named cu 1 and cu 2 . Assume that the distance between cu 1 and cu 2 is 1.2 at t q which is less than  X  , and the density is 1.8 after merging cu 1 with cu 2 which is more than  X  , cu 1 and cu 2 can construct a DS (we call it DS 1 ). The start position of DS 1 is the head of cu 1 and the end position of DS 1 is the tail of cu 2 . The number of objects in DS 1 is the sum of the number of objects in cu 1 and that in cu 2 . Assume that the distance between DS 1 and node J 2 is 1.0 which is less than  X  , J 2 is the  X  -CN of DS 1 (we call it  X  -CN 1 ). We insert DS 1 into the DS list of  X  -CN 1 . In this way, we can obtain DS 2 on s 3 including cu 4 and DS 3 on s 4 including cu 3 respectively. The  X  -CN of DS 2 (  X  -CN 2 )is J 4 and that of DS 3 is J 2 . So the DS list of  X  -CN 1 includes DS 1 and DS 3 , while the DS list of  X  -CN 2 includes DS 2 . Algorithm 1 shows the pseudo. Algorithm 2. Ref inement (  X ,  X , L, t q )
In the refinement step, we compute den se segment sets so that the effective dense areas can be obtained. We traverse the list of each  X  -CN and evaluate whether those DS s around the  X  -CN can construct DSS based on the def-inition 8. Given L =100 in Figure 2. As the Distance( DS 1 ,  X  -CN 1 )=1.0 and Distance( DS 3 ,  X  -CN 1 )=0.7, the distance between DS 1 and DS 3 is 1.7, which is less than  X  . In addition, if DS 1 is merged with DS 3 , the density is more than  X  . Therefore, DS 1 and DS 3 can be merged to be a DSS named DSS 1 .Inthesame way, we check if there are other dense segments can be merged with DSS 1 by utilizing its  X  -CN and insert it into DSS 1 . Finally, we check if the total length of DSS 1 is more than L .Ifso, DSS 1 is one of the answers of the density query. Repeat the process until all  X  -CN s containing dense segments are accessed. Then we can obtain all dense areas which are represented as dense segment sets at t q . Note that a DS may be involved in the lists of two  X  -CNs . To avoid scanning the same nodes repeatedly, we mark the scanned  X  -CN as accessed node. Algorithm 2 shows the pseudo of the refinement step. In this section, we compare t he cluster-based density query processing with the existing density-based road-network clustering algorithm, -link proposed by Yiu et al. [10] in terms of query per formance and accuracy since -link also returns the dense areas which consist of the density-based clusters of objects. We monitor the query results by running the -link algorithm periodically and by maintaining CUs and finding the dense segments based on CUs.
 Experimental Settings. We implement the algorithms in C++ and carry out experiments on a Pentium 4, 2.4 GH z PC with 512MB RAM running Windows XP. For monitoring the dense areas in a road network, we design a moving object generator to produce synthetic datasets. The generator takes a map of a road network as input, and our experiment is based on the map of Beijing city. We set K hot spots (destination nodes) in the map. Initially, the generator places 80 percent objects around the hot spots and 20 percent objects at r andom positions, and updates their locations at each time unit. The query workload is 100 and each query has three parameter s: (i) the density threshold  X  ; (ii) the threshold for dense segment length L ; (iii) the threshold for the distance of adjacent objects  X  . The query cost is measured in terms of C PU time. We also measure the accuracy of query answers.
 Comparison with the -link Algorithm. To evaluate the performance, we first measure the total workload time and average query response time of two algo-rithms when varying the number of moving objects from 100K to 1M. We execute the CU maintenance and query processing in comparison with the static -link on all objects at each time unit during 0 to 20 time units. For total workload time (shown in Figure 3), we measure the total CPU time including CU maintenance and query processing based on CUs. Figure 4 shows the average query response time for periodic query processing. In fact, considering the feature of road network, a CU represents the summary informatio n of its objects and is incrementally up-dated over time with low cost, which can h elp speeding up the query processing. Therefore, our method is subs tantially better than the static one in terms of aver-age query response time and still better in terms of total workload time. Accuracy Density Query. We evaluate the accuracy of density queries by computing average correct ratio of the number of objects in query result to that in the dataset around hot spots. Let avgCorrectRate represent the average correct ratio of query result, Query objN um be the number of objects of the result, Real objN um be the average number of objects around each hot spot in the dataset, avgCorrectRate can be calculated by the following equation: where M denotes the number of dense areas (i.e., DSS) in the query result. Figure 5 shows the comparison of the two methods in the query accuracy. We can see that the accuracy of our query algorithm is higher and stable with the different data distributions. Effect of Parameters. Finally, we study the effect of parameters (  X  , L ,  X  and ) of our methods on the query performance. Given value at 2.5,  X  value at 4.5, and L value at 100, we change density threshold  X  from 1 to 5.5 to evaluate time cost of query processing. Figure 6 shows t he experimental result. In addition, we also evaluate time cost by adjusting the parameter L from 100 to 1000, and the result is similar to Figure 6. Next, when fixing the value at 2.5, we vary  X  from 2 to 6.5 to study its effect on the query processing. Finally, as the number of CUs depends on the system parameter , we change the value of from 0.5 to 3 to measure the maintenance cost of CUs. Figure 7 and Figure 8 show the effect of the two parameters. We observe that when  X  and are set to 4.5 and 2.5, the method achieves the highest efficiency in our experimental settings. In this paper, we introduce the definition of the dense segment and propose the problem of the effective road-network density query. Under our definition, we are able to answer queries for dense segments and find out dense areas in road network with arbitrary shape and arbitr ary size. We present an cluster-based algorithm to response dynamic density queries and analyze the cost of cluster maintenance based on the object X  X  movement feature in the road network. The cluster-based pre-processing can efficiently support density queries in road net-work. The experimental results show the efficiency and accura cy of our methods.
