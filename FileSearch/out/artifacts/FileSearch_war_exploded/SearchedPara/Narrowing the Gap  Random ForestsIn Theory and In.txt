 David Matheson 2 DAVIDM @ CS . UBC . CA
University of Oxford, United Kingdom University of British Columbia, Canada Random forests are a type of ensemble method which makes predictions by averaging over the predictions of sev-eral independent base models. Since its introduction by Breiman (2001) the random forests framework has been ex-tremely successful as a general purpose classification and regression method.
 Despite their widespread use, a gap remains between the theoretical understanding of random forests and their prac-tical use. A variety of random forest algorithms have ap-peared in the literature, with great practical success. How-ever, these algorithms are difficult to analyze, and the basic mathematical properties of even the original variant are still not well understood (Biau, 2012).
 This state of affairs has led to a polarization between theo-retical and empirical contributions to the literature. Empir-ically focused papers describe elaborate extensions to the basic random forest framework, adding domain specific re-finements which push the state of the art in performance, but come with no guarantees (Schroff et al., 2008; Shot-ton et al., 2011; Montillo et al., 2011; Xiong et al., 2012; Zikic et al., 2012). In contrast, theoretical papers focus on simplifications of the standard framework where analysis is more tractable. Notable contributions in this direction are the recent papers of Biau et al. (2008) and Biau (2012). In this paper we present a new variant of random regres-sion forests with tractable theory, which relaxes two of the key simplifying assumptions from previous works. We also provide an empirical comparison between standard random forests and several models which have been analyzed by the theory community.
 Our algorithm achieves the closest match between theoreti-cally tractable models and practical algorithms to date, both in terms of similarity of the algorithms and in empirical performance.
 Our empirical comparison of the theoretical models, some-thing which has not previously appeared in the literature, provides important insight into the relative importance of the different simplifications made to the standard algorithm to enable tractable analysis. Random forests (Breiman, 2001) were originally conceived as a method of combining several CART (Breiman et al., 1984) style decision trees using bagging (Breiman, 1996). Their early development was influenced by the random subspace method of Ho (1998), the approach of random split selection from Dietterich (2000) and the work of Amit &amp; Geman (1997) on feature selection. Several of the core ideas used in random forests are also present in the early work of Kwokt &amp; Carter (1988) on ensembles of decision trees.
 In the years since their introduction, random forests have grown from a single algorithm to an entire framework of models (Criminisi et al., 2011), and have been applied to great effect in a wide variety of fields (Svetnik et al., 2003; Prasad et al., 2006; Cutler et al., 2007; Shotton et al., 2011; Criminisi &amp; Shotton, 2013).
 In spite of the extensive use of random forests in practice, the mathematical forces underlying their success are not well understood. The early theoretical work of Breiman (2004) for example, is essentially based on intuition and mathematical heuristics, and was not formalized rigorously until quite recently (Biau, 2012).
 There are two main properties of theoretical interest asso-ciated with random forests. The first is consistency of es-timators produced by the algorithm, which asks (roughly) if we can guarantee convergence to an optimal estimator as the data set grows infinitely large. Beyond consistency we are also interested in rates of convergence; but in this paper we focus on consistency, which, surprisingly, has not yet been established even for Breiman X  X  original algorithm. Theoretical papers typically focus on stylized versions of the algorithms used in practice. An extreme example of this is the work of Genuer (2010; 2012), which studies a model of random forests in one dimension with completely ran-dom splitting. In exchange for simplification researchers acquire tractability, and the tact assumption is that theo-rems proved for simplified models provide insight into the properties of their more sophisticated counterparts, even if the formal connections have not been established.
 An important milestone in the theory of random forests is the work of Biau et al. (2008), which proves the con-sistency of several randomized ensemble classifiers. Two models studied in Biau et al. (2008) are direct simplifica-tions of the algorithm from Breiman (2001), and two are simple randomized neighbourhood averaging rules, which can be viewed as simplifications of random forests from the perspective of Lin &amp; Jeon (2006).
 More recently Biau (2012) has analyzed a variant of ran-dom forests originally introduced in Breiman (2004) which is quite similar to the original algorithm. The main dif-ferences between the model in Biau (2012) and that of Breiman (2001) are in how candidate split points are se-lected, and that the former requires a second independent data set to fit the leaf predictors.
 While the problem of consistency of Breiman X  X  algorithm remains open, some special cases have proved tractable. In particular, Meinshausen (2006) has shown that a model of random forests for quantile regression is consistent and Ishwaran &amp; Kogalur (2010) have shown the consistency of their survival forests model. Denil et al. (2013) have shown the consistency of an online version of random forests. In this section we briefly review the random forests frame-work. For a more comprehensive review we refer the reader to Breiman (2001) and Criminisi et al. (2011).
 Random forests are built by combining the predictions of several trees, each of which is trained in isolation. Unlike in boosting (Schapire &amp; Freund, 2012) where the base models are trained and combined using a sophisticated weighting scheme, typically the trees are trained independently and the predictions of the trees are combined through averag-ing.
 There are three main choices to be made when constructing a random tree. These are (1) the method for splitting the leafs, (2) the type of predictor to use in each leaf, and (3) the method for injecting randomness into the trees. Specifying a method for splitting leafs requires selecting the shapes of candidate splits as well as a method for eval-uating the quality of each candidate. Typical choices here are to use axis aligned splits, where data are routed to sub-trees depending on whether or not they exceed a threshold value in a chosen dimension; or linear splits, where a linear combination of features are thresholded to make a decision. The threshold value in either case can be chosen randomly or by optimizing a function of the data in the leafs. In order to split a leaf, a collection of candidate splits are generated and a criterion is evaluated to choose between them. A simple strategy is to choose among the candidates uniformly at random, as in the models analyzed in Biau et al. (2008). A more common approach is to choose the candidate split which optimizes a purity function over the leafs that would be created. A typical choice here is to maximize the information gain (Hastie et al., 2013). The most common choice for predictors in each leaf is to use the average response over the training points which fall in that leaf. Criminisi et al. (2011) explore the use of sev-eral different leaf predictors for regression and other tasks, but these generalizations are beyond the scope of this paper. We consider only simple averaging predictors here. Injecting randomness into the tree construction can happen in many ways. The choice of which dimensions to use as split candidates at each leaf can be randomized, as well as the choice of coefficients for random combinations of features. In either case, thresholds can be chosen either randomly or by optimization over some or all of the data in the leaf.
 Another common method for introducing randomness is to build each tree using a bootstrapped or sub-sampled data set. In this way, each tree in the forest is trained on slightly different data, which introduces differences between the trees.
 In this section we describe the workings of our random for-est algorithm. Each tree in the random regression forest is constructed independently. Unlike the random forests of Breiman (2001) we do not preform bootstrapping between the different trees. 4.1. Tree construction Each node of the tree corresponds to a rectangular subset of
R D , and at each step of the construction the cells associ-ated with leafs of the tree form a partition of R D . The root of the tree corresponds to all of R D . At each step of the construction a leaf of the tree is selected for expansion. In each tree we partition the data set randomly into two parts, each of which plays a different role in the tree con-struction. We refer to points assigned to the different parts as structure and estimation points respectively.
 Structure points are allowed to influence the shape of the tree. They are used to determine split dimensions and split points in each internal node of the tree. However, structure points are not permitted to effect the predictions made in the tree leafs.
 Estimation points play the dual role. These points are used to fit the estimators in each leaf of the tree, but have no effect on the shape of the tree partition.
 The data are randomly partitioned in each tree by assign-ing each point to the structure or estimation part with equal probability. This partition is required to ensure consistency; however, there is no reason we cannot have additional parts. For instance, we could assign some points to a third, ig-nored part of the partition in order to fit each tree on a subset of the data. However, we found that subsampling generally hurts performance, so we do not pursue this idea further.
 The tree construction is parameterized by k n , which gives a minimum number of estimation points that must appear in each leaf. The subscript n , which corresponds to the size of the training set, indicates that the minimum leaf size depends on the number of training data. 4.2. Leaf expansion When a leaf is selected for expansion we select, at random, min(1+Poisson(  X  ) ,D ) distinct candidate dimensions. We choose a split point for the leaf by searching over the can-didate split points in each of the candidate dimensions. A key difference between our algorithm and standard ran-dom forests is how the set of candidate split points is gener-ated. In a standard random forest, points are projected into each candidate dimension and every possible split point is evaluated as a candidate split point. In our algorithm we restrict the range of the search by first selecting m of the structure points in the leaf and evaluating candidate split points only over the range defined by these points. Re-stricting the range in this way forces the trees to be (ap-proximately) balanced, and is depicted in Figure 1. For each candidate split point S we compute the reduction in squared error, where A is the leaf to be split, and A 0 ,A 00 are the two chil-dren which would be created by splitting A at S . The nota-tion  X  Y A denotes the empirical mean of the structure points falling in the cell A and N s ( A ) counts the number of struc-ture points in A . The variables I j  X  { e,s } are indicators which denote whether the point ( X j ,Y j ) is a structure or estimation point.
 The split point is chosen as the candidate which maximizes I ( S ) without creating any children with fewer than k n mation points. If no such candidate is found then expansion is stopped. 4.3. Prediction Once the forest has been trained it can be used to make predictions for new unlabeled data points. To make a pre-diction for a query point x , each tree independently predicts and the forest averages the predictions of each tree Here A n ( x ) denotes the leaf containing x and N e ( A n denotes the number of estimation points it contains. Note that the predictions made by each tree depend only on the estimation points in that tree; however, since points are as-signed to the structure and estimation parts independently in each tree, structure points in one tree have the opportu-nity to contribute to the prediction as estimation points in another tree. In this section we prove consistency of the random re-gression forest model described in this paper. We denote a tree partition created by our algorithm trained on data D n = { ( X i ,Y i ) } n i =1 as f n . We use the variable Z to denote the randomness in the tree construction, which includes the selection of candidate dimensions as well as any other ran-dom choices involved in the construction.
 As n varies we obtain a sequence of classifiers and we are interested in showing that the sequence { f n } is consistent as n  X  X  X  . More precisely, Definition 1. A sequence of estimators { f n } is consistent for a given distribution on ( X,Y ) if the value of the risk functional converges to 0 as n  X   X  , where f ( x ) = E [ Y | X = x ] is the (unknown) regression function.
 In order to show that our random forest classifier is consis-tent, we will take advantage of its structure as an empirical averaging estimator.
 Definition 2. A (randomized) empirical averaging estima-tor is an estimator that averages a fixed number of (possibly dependent) base estimators, i.e. where Z ( M ) = ( Z 1 ,...,Z M ) is composed of M (possibly dependent) realizations of Z .
 The first step of our construction is to show that the con-sistency of the random regression forest is implied by the consistency of the trees it is composed of. The following proposition makes this assertion precise. A similar result was shown by Biau et al. (2008) for binary classifiers and a corresponding mutli-class generalization appears in Denil et al. (2013). For regression, it is particularly straightfor-ward.
 Proposition 3. Suppose { f n } is a consistent sequence of estimators. Then { f ( M ) n } , the sequence of empirical aver-aging estimators obtained by averaging M copies of { f n } with different randomizing variables is also consistent. Proof. We must show that R ( f ( M ) n )  X  0 . Compute by the triangle inequality and the fact that ( P n i =1 a which is the desired result.
 Proposition 3 allows us to focus our attention on the con-sistency of each of the trees in the regression forest. The task of proving the tree estimators are consistent is greatly simplified if we condition on the partition of the data into structure and estimation points. Conditioned on the parti-tion, the shape of the tree becomes independent of the esti-mators in the leafs. The following proposition shows that, under certain conditions, proving consistency conditioned on the partitioning variables is sufficient.
 Proposition 4. Suppose { f n } is a sequence of estimators which are conditionally consistent for some distribution on ( X,Y ) based on the value of some auxiliary variable I . That is, for all I  X  I and that P ( I  X  X  ) = 1 . Moreover, suppose f ( x ) is bounded. If these conditions hold and each f n bounded with probability 1, then { f n } is unconditionally consistent, i.e. R ( f n )  X  0 .
 Proof. Note that and Both of these terms are finite by the boundedness assump-tions. This means we can apply the dominated convergence theorem to obtain which is the desired result.
 With these preliminary results in hand, we are equipped to prove our main result.
 Theorem 5. Suppose that X is supported on R D and has a density which non-zero almost everywhere. Moreover, sup-pose that f ( x ) is bounded and that E Y 2 &lt;  X  . Then the random regression forest algorithm described in this paper is consistent provided that k n  X   X  and k n /n  X  0 as n  X  X  X  .
 Proof. Since the construction of the tree is monotone trans-formation invariant we can assume without loss of general-ity that X is supported on [0 , 1] D with uniform marginals (Devroye et al., 1996).
 By Proposition 3 it is sufficient to show consistency of the base estimator. Moreover, using I to denote an infinite se-quence of partitioning variables, by Proposition 4 it is suffi-cient to show consistency of the base estimator conditioned on I . To this end, we appeal to Theorem 4.1 from Gy  X  orfi et al. (2002). According to this theorem { f n } is consis-tent if both diam( A n ( X ))  X  0 and N e ( A n ( X ))  X   X  in probability (recall A n ( X ) denotes the leaf containing X ). Consider a tree partition defined by the structure points (fixed by conditioning on I ) and the additional randomiz-ing variable Z . That N e ( A n ( X ))  X   X  is trivial, since N e ( A n ( X ))  X  k n . To see that diam( A n ( X ))  X  0 in probability, let V n ( x ) be the size of the first dimension of A n ( x ) . It suffices to show that E [ V n ( x )]  X  0 for all x in the support of X .
 Let X 1 ,...,X m 0  X   X  | A note the structure points selected to determine the range of the split points in the cell A n ( x ) . Without loss of gen-erality, we can assume that V n ( x ) = 1 and that  X  1 X Uniform[0 , 1] , where  X  1 is a projection onto the first coor-dinate. Conditioned on the event that the first dimension is cut, the largest possible size for the first dimension of the child cells is bounded by Recall that we choose min(1+Poisson(  X  ) ,D ) distinct can-didate split dimensions, and define the following events Then, using V 0 to denote the size of the first dimension of the child cell, By Lemma 6 in Appendix A, Iterating this argument we have that after K splits the ex-pected size of the first dimension of the cell containing x is upper bounded by so it suffices to have K  X  X  X  in probability. This is shown to hold by Proposition 7 in Appendix A, which proves the claim. In this section we describe two different random forest models which have been previous analyzed in the literature. We discuss some of the differences between them and the model in this paper, and the relationship of the three mod-els to Breiman X  X  original algorithm. Both of the models we discuss here were originally presented as classification algorithms, but adapting them for regression is straightfor-ward.
 The first model we compare to our own is the scale invari-ant random forest from Biau et al. (2008), which we refer to as Biau08. The trees in this forest are constructed by repeatedly expanding leaf nodes as follows: a leaf in the tree is chosen uniformly at random for expansion. Within this leaf a dimension is chosen uniformly at random and the data are sorted according to their projection into the chosen dimension. Finally, if there are N data points in the leaf being expanded then a random index I is drawn from the set { 0 , 1 ,...,N } and the split point is chosen so that the I smallest values fall into one of the children and the rest in the other. Leaf expansion continues in this manner until a specified number of terminal nodes has been reached. The second model we compare to is the algorithm analyzed in Biau (2012), which we refer to as Biau12. The trees in this forest assume the data is supported on [0 , 1] D , so data must first be scaled to lie in this range. Trees are grown by expanding leafs in breadth first order until a specified number of terminal nodes has been reached. Leafs in this model are expanded by selecting a fixed number of random candidate dimensions (with replacement). For each candi-date dimension there is one candidate split point which lies at the midpoint of the cell being expanded. To choose be-tween the different candidate dimensions, the information gain from each split is computed and the candidate split point with the greatest information gain is selected. An important feature of Biau12 is that fitting the model re-quires partitioning the data set into two parts. One of these parts is used for determining the structure of the trees, and the other part is used for fitting the estimators in the leafs. The roles of the two parts of this partition are identical to the structure and estimation points in our own algorithm. The main difference between how Biau12 partitions the data and how we do so is that for Biau12 the partition into structure and estimation points is the same for all the trees in the forest, whereas in our algorithm the partition is ran-domly chosen independently for each tree.
 Comparing our algorithm and the two from Biau to Breiman X  X  original random forests algorithm we see there are two key points of difference: (1) How candidate split points are chosen, and (2) how data splitting happens (if at all).
 In our experiments we look at how different choices for these two factors effect the performance of random forests on several regression problems. In this section we empirically compare our algorithm to Biau08 and Biau12 (described in Section 6) and Breiman (the original algorithm described in Breiman (2001)) on several datasets.
 The purpose of these experiments is to provide insight into the relative impact of the different simplifications that have been used to obtain theoretical tractability. To this end we have chosen to evaluate the different algorithms on several realistic tasks, including and extremely challenging joint prediction problem from computer vision.
 Since the algorithms are each parameterized slightly differ-ently it is not possible to use the same parameters for all of them. Breiman and our own algorithm specify a minimum leaf size, which we set to 5 following Breiman X  X  advice for regression (Breiman, 2001).
 Biau08 and Biau12 are parameterized in terms of a target number of leafs rather than a minimum leaf size. For these algorithms we choose the target number of leafs to be n/ 5 , meaning the trees will be approximately the same size as those grown by Breiman and our own algorithm.
 Biau12 requires the data to lie within the unit hypercube. For this algorithm we pre-process the data by shifting and scaling each feature into this range. 7.1. UCI datasets For our first set of experiments we used four data sets from the UCI repository: Diabetes, Wine Quality, YearPredic-tionMSD and CT Slice. With the exception of diabetes, these datasets were chosen for their relatively large number of instances and features.
 In all the experiments in this section we follow Breiman X  X  rule of thumb of using one third of the total number of at-tributes as candidate dimensions. All results in the this sec-tion are the mean of five runs of five fold cross validation. For our algorithm we choose m = 1000 structure points for selecting the search range in the candidate dimensions. We experimented with other settings for m but found our results to be very insensitive to this parameter.
 Figure 2 compares the performance of several different ran-dom forest algorithm variants on the four UCI data sets. The clear trend here is that Breiman X  X  algorithm outper-forms our own, which in turn outperforms both algorithms from Biau. Generally Biau12 outperforms Biau08, except in the wine quality data set where, strangely, the order is reversed.
 Figure 2 includes a variant of our algorithm which performs data splitting at the forest level, and also a variant of Biau12 which performs data splitting at the tree level. This differ-ence appears to have relatively little effect when there is sufficient data; however, for the Diabetes dataset, which is comparatively small, splitting at the tree instead of the for-est level significantly improves performance.
 In all cases the gap between Biau12 and our algorithm is larger than the difference in performance from changing how data splitting is done. This indicates that in a practical sense it is the split selection strategy that accounts for most of the improvement of our algorithm over Biau12.
 We also experimented with variants of Biau12 and our own algorithm with no data splitting. The most notable thing here is that when data splitting is removed our algorithm is very competitive with Breiman. This indicates that the gap in performance between our algorithm and standard random forests can be contributed almost entirely to data splitting.
 We performed all of these experiments using a range of forest sizes. Figure 3 (left) shows performance as a func-tion of forest size. In the interest of space we present this figure only for the CT slice dataset, but the curves for the other datasets tell a similar story. This figure shows that the results from Figure 2 are consistent over a wide range of forest sizes.
 Figure 3 (right) more closely examines the effects of the different data splitting and split point selection strategies. 7.2. Kinect Pose Estimation In this section, we evaluate our random forest algorithm on the challenging computer vision problem of predicting the location of human joints from a depth image and corre-sponding body part labels. See Figure 4 for an example. Typically the first step in a joint location pipeline is to pre-dict the body part labels of each pixel in the depth image and the second step is to use the labelled pixels to predict joint locations (Shotton et al., 2011). Further refinements to this procedure can predict both the pixel label and joint lo-cations simultaneously using a Hough forest as in Girshick et al. (2011); however these refinements are well beyond the scope of this paper.
 Since our primary goal is to evaluate regression models rather than to build an end product, we implement only the second step in the basic pipeline. Using depth images with ground truth body part labels for each pixel as training data, we learn a regression model of the offset from a pixel to a joint.
 For each joint, we train a forest on the pixels of body parts associated with that joint and predict the relative offset from each pixel to the joint. Typically these errors would be post-processed with mean shift to find a more accurate final prediction for the joint location. We instead report the regression error directly to avoid confounding factors in the comparison between the forest models.
 Each joint has its own model that predicts the offset from a pixel to the location of the joint. An offset is predicted for all pixels with body part labels associated with a joint. To build our data set, we sample random poses from the CMU mocap dataset and render a pair of 320x240 resolu-tion depth and body part images along with the positions of each joint in the skeleton. The 19 body parts and one back-ground class are represented by 20 unique colour identifiers in the body part image.
 For this experiment we generate 2000 poses for training and 500 poses for testing. To create the training set, we sample 20 pixels without replacement from each body part class in each pose. We then sample 40000 pixels without replacement from the sampled pixels with the associated body part labels across all poses. During testing we eval-uate the MSE of the offsets of all pixels associated with a joint. Figure 4 visualizes the raw depth image, ground truth body part labels and the votes for the left hand made by all pixels in the left arm.
 The features associated with each pixel are depth differ-ences between pairs of pixels at specified offsets from the target. At training time, candidate pairs of offsets are sam-pled from a 2-dimensional Gaussian distributions with vari-ance 40.0 (chosen by cross validation). The offsets are scaled by the depth of the target pixel to produce depth in-variant features. Figure 4 (left) shows candidate feature offsets u and v for the indicated pixel. The resulting fea-ture value is the depth difference between the pixel at offset u and the pixel at offset v . In this experiment we sample 1000 candidate offsets at each node.
 Figure 5 shows the MSE and standard deviation for each joint in pixel units. In the interest of space we only show the joints for the left side of the body but we see similar results for the right side. Just as with the UCI datasets, the dominant ordering from largest to smallest test error is Biau08, Biau12, Ours and Breiman. It is fascinating that an algorithm as simple and useful as random forests has turned out to be so difficult to analyze. Motivated by this, we set as our goal to narrow the gap between the theory and practice of regression forests, and we succeeded to a significant extent.
 In this paper we were able to derive a new regression forest algorithm, to prove that it is consistent, and to show that its empirical performance is closer to Breiman X  X  model than previous theoretical variants.
 Our empirical study, which compares the algorithm widely used in practice to recent theoretical variants for the first time, also casts light on how different design choices and theoretical simplifications impact performance.
 We focused on consistency because this is still an impor-tant open problem. We believe that our theoretical analysis and empirical study clarify the state of understanding of random forests and help set the stage for further research in this area.
 However, we believe that our theoretical analysis and em-pirical study help in setting the arena for embarking on other types of analyses, including finite sample size com-plexity bounds, asymptotic convergence rates, and consis-tency of random forests in machine learning problems be-yond regression.
 Some of the data used in this paper was obtained from mocap.cs.cmu.edu (funded by NSF EIA-0196217).
 R
