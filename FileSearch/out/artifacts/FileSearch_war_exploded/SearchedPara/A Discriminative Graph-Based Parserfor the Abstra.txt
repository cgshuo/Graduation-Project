 Semantic parsing is the problem of mapping nat-ural language strings into meaning representa-tions. Abstract Meaning Representation (AMR) (Banarescu et al., 2013; Dorr et al., 1998) is a semantic formalism in which the meaning of a sentence is encoded as a rooted, directed, acyclic graph. Nodes represent concepts, and labeled di-rected edges represent the relationships between them X  X ee Figure 1 for an example AMR graph. The formalism is based on propositional logic and neo-Davidsonian event representations (Parsons, 1990; Davidson, 1967). Although it does not encode quantifiers, tense, or modality, the set of semantic phenomena included in AMR were se-lected with natural language applications X  X n par-ticular, machine translation X  X n mind.

In this paper we introduce JAMR, the first pub-lished system for automatic AMR parsing. The system is based on a statistical model whose pa-rameters are trained discriminatively using anno-tated sentences in the AMR Bank corpus (Ba-narescu et al., 2013). We evaluate using the Smatch score (Cai and Knight, 2013), establishing a baseline for future work.

The core of JAMR is a two-part algorithm that first identifies concepts using a semi-Markov model and then identifies the relations that ob-tain between these by searching for the maximum spanning connected subgraph ( MSCG ) from an edge-labeled, directed graph representing all pos-sible relations between the identified concepts. To solve the latter problem, we introduce an appar-ently novel O ( | V | 2 log | V | ) algorithm that is sim-ilar to the maximum spanning tree (MST) algo-rithms that are widely used for dependency pars-ing (McDonald et al., 2005). Our MSCG algo-rithm returns the connected subgraph with maxi-mal sum of its edge weights from among all con-nected subgraphs of the input graph. Since AMR imposes additional constraints to ensure seman-tic well-formedness, we use Lagrangian relaxation (Geoffrion, 1974; Fisher, 2004) to augment the MSCG algorithm, yielding a tractable iterative al-gorithm that finds the optimal solution subject to these constraints. In our experiments, we have found this algorithm to converge 100% of the time for the constraint set we use.

The approach can be understood as an alterna-tive to parsing approaches using graph transduc-ers such as (synchronous) hyperedge replacement grammars (Chiang et al., 2013; Jones et al., 2012; Drewes et al., 1997), in much the same way that spanning tree algorithms are an alternative to us-ing shift-reduce and dynamic programming algo-comparison of these two approaches is beyond the scope of this paper, we emphasize that X  X s has been observed with dependency parsing X  X  diver-sity of approaches can shed light on complex prob-lems such as semantic parsing. Our approach to AMR parsing represents an AMR parse as a graph G =  X  V,E  X  ; vertices and edges are given labels from sets L V and L E , respec-tively. G is constructed in two stages. The first stage identifies the concepts evoked by words and phrases in an input sentence w =  X  w 1 ,...,w n  X  , each w i a member of vocabulary W . The second stage connects the concepts by adding L E -labeled edges capturing the relations between concepts, and selects a root in G corresponding to the focus of the sentence w .

Concept identification (  X  3) involves segmenting w into contiguous spans and assigning to each span a graph fragment corresponding to a concept from a concept set denoted F (or to  X  for words that evoke no concept). In  X  5 we describe how F is constructed. In our formulation, spans are contiguous subsequences of w . For example, the words  X  X ew York City X  can evoke the fragment represented by We use a sequence labeling algorithm to identify concepts.

The relation identification stage (  X  4) is similar to a graph-based dependency parser. Instead of finding the maximum-scoring tree over words, it finds the maximum-scoring connected subgraph that preserves concept fragments from the first stage, links each pair of vertices by at most one consists of the labels ARG0 X  X RG5, and does not include labels such as MOD or MANNER , for ex-ample. Linguistically, the determinism constraint enforces that predicates have at most one semantic argument of each type; this is discussed in more detail in  X  4.

To train the parser, spans of words must be la-beled with the concept fragments they evoke. Al-though AMR Bank does not label concepts with the words that evoke them, it is possible to build an automatic aligner (  X  5). The alignments are used to construct the concept lexicon and to train the concept identification and relation identifica-tion stages of the parser (  X  6). Each stage is a discriminatively-trained linear structured predic-tor with rich features that make use of part-of-speech tagging, named entity tagging, and depen-dency parsing.

In  X  7, we evaluate the parser against gold-standard annotated sentences from the AMR Bank corpus (Banarescu et al., 2013) under the Smatch score (Cai and Knight, 2013), presenting the first published results on automatic AMR parsing. The concept identification stage maps spans of words in the input sentence w to concept graph fragments from F , or to the empty graph fragment  X  . These graph fragments often consist of just one labeled concept node, but in some cases they Concept identification is illustrated in Figure 2 us-ing our running example,  X  X he boy wants to visit New York City. X  Let the concept lexicon be a mapping clex : ments for sequences of words. (The construc-tion of F and clex is discussed below.) Formally, a concept labeling is (i) a segmentation of w into contiguous spans represented by boundaries b , giving spans  X  w b b 0 = 0 and b k = n , and (ii) an assignment of each phrase w b c  X  clex ( w b
Our approach scores a sequence of spans b and a sequence of concept graph fragments c , both of arbitrary length k , using the following locally de-composed, linearly parameterized function: score ( b , c ;  X  ) = where f is a feature vector representation of a span and one of its concept graph fragments in context. The features are:  X  Fragment given words : Relative frequency es-timates of the probability of a concept graph fragment given the sequence of words in the span. This is calculated from the concept-word alignments in the training corpus (  X  5).  X  Length of the matching span (number of to-kens).  X  NER : 1 if the named entity tagger marked the span as an entity, 0 otherwise.  X  Bias : 1 for any concept graph fragment from F and 0 for  X  .

Our approach finds the highest-scoring b and c using a dynamic programming algorithm: the zeroth-order case of inference under a semi-Markov model (Janssen and Limnios, 1999). Let S ( i ) denote the score of the best labeling of the first i words of the sentence, w 0: i ; it can be calcu-lated using the recurrence: S (0) = 0 The best score will be S ( n ) , and the best scor-ing concept labeling can be recovered using back-pointers, as in typical implementations of the Viterbi algorithm. Runtime is O ( n 2 ) . clex is implemented as follows. When clex is called with a sequence of words, it looks up the sequence in a table that contains, for every word sequence that was labeled with a concept fragment in the training data, the set of concept fragments it was labeled with. clex also has a set of rules for generating concept fragments for named entities and time expressions. It generates a concept frag-ment for any entity recognized by the named entity tagger, as well as for any word sequence matching a regular expression for a time expression. clex returns the union of all these concept fragments. The relation identification stage adds edges among the concept subgraph fragments identified in the first stage (  X  3), creating a graph. We frame the task as a constrained combinatorial optimization problem.
 Consider the fully dense labeled multigraph D =  X  V D ,E D  X  that includes the union of all la-beled vertices and labeled edges in the concept graph fragments, as well as every possible labeled edge u `  X  X  X  v , for all u,v  X  V D and every `  X  L E . 4
We require a subgraph G =  X  V G ,E G  X  that re-spects the following constraints: 1. Preserving : all graph fragments (including la-bels) from the concept identification phase are subgraphs of G . 2. Simple : for any two vertices u and v  X  V G , E G includes at most one edge between u and v . This constraint forbids a small number of perfectly valid graphs, for example for sentences such as  X  X ohn hurt himself X ; however, we see that &lt; 1 % of training instances violate the constraint. We found in preliminary experiments that including 3. Connected : G must be weakly connected (ev-ery vertex reachable from every other vertex, ig-noring the direction of edges). This constraint follows from the formal definition of AMR and is never violated in the training data. 4. Deterministic : For each node u  X  V G , and for each label `  X  L  X  edge in E G from u with label ` . As discussed in  X  2, this constraint is linguistically motivated. One constraint we do not include is acyclicity , which follows from the definition of AMR. In practice, graphs with cycles are rarely produced by JAMR. In fact, none of the graphs produced on the test set violate acyclicity.

Given the constraints, we seek the maximum-scoring subgraph. We define the score to decom-pose by edges, and with a linear parameterization: The features are shown in Table 1.

Our solution to maximizing the score in Eq. 2, subject to the constraints, makes use of (i) an al-gorithm that ignores constraint 4 but respects the others (  X  4.1); and (ii) a Lagrangian relaxation that iteratively adjusts the edge scores supplied to (i) so as to enforce constraint 4 (  X  4.2). 4.1 Maximum Preserving, Simple, Spanning, The steps for constructing a maximum preserving, simple, spanning, connected (but not necessar-ily deterministic) subgraph are as follows. These steps ensure the resulting graph G satisfies the constraints: the initialization step ensures the pre-serving constraint is satisfied, the pre-processing step ensures the graph is simple, and the core al-gorithm ensures the graph is connected. 1. (Initialization) Let E (0) be the union of the concept graph fragments X  weighted, labeled, di-rected edges. Let V denote its set of vertices.
Note that  X  V,E (0)  X  is preserving (constraint 4), as is any graph that contains it. It is also sim-ple (constraint 4), assuming each concept graph fragment is simple. 2. (Pre-processing) We form the edge set E by in-cluding just one edge from E D between each pair of nodes:  X  For any edge e = u `  X  X  X  v in E (0) , include e in  X  For any two nodes u and v , include only the
Note that without the deterministic constraint, we have no constraints that depend on the label of an edge, nor its direction. So it is clear that the edges omitted in this step could not be part of the maximum-scoring solution, as they could be replaced by a higher scoring edge without vi-olating any constraints.

Note also that because we have kept exactly one edge between every pair of nodes,  X  V,E  X  is sim-ple and connected. 3. (Core algorithm) Run Algorithm 1, MSCG , on  X  V,E  X  and E (0) . This algorithm is a (to our knowledge novel) modification of the minimum spanning tree algorithm of Kruskal (1956).
Note that the directions of edges do not matter Steps 1 X 2 can be accomplished in one pass through the edges, with runtime O ( | V | 2 ) . MSCG can be implemented efficiently in O ( | V | 2 log | V | ) time, similarly to Kruskal X  X  algorithm, using a disjoint-set data structure to keep track of con-complexity is O ( | V | 2 log | V | ) .
 The details of MSCG are given in Algorithm 1. In a nutshell, MSCG first adds all positive edges to the graph, and then connects the graph by greedily adding the least negative edge that connects two previously unconnected components.
 Theorem 1. MSCG finds a maximum spanning, connected subgraph of  X  V,E  X  Proof. We closely follow the original proof of cor-rectness of Kruskal X  X  algorithm. We first show by induction that, at every iteration of MSCG , there exists some maximum spanning, connected sub-input : weighted, connected graph  X  V,E  X  output : maximum spanning, connected let E (1) = E (0)  X  X  e  X  E |  X  &gt; g ( e ) &gt; 0 } ; create a priority queue Q containing { e  X  E |  X  &gt; g ( e )  X  0 } prioritized by scores; i = 1 ; while Q nonempty and  X  V,E ( i )  X  is not yet spanning and connected do end return G =  X  V,E ( i )  X  ; Base case: Consider G (1) , the subgraph contain-ing E (0) and every positive edge. Take any maxi-mum preserving spanning connected subgraph M of  X  V,E  X  . We know that such an M exists be-cause  X  V,E  X  itself is a preserving spanning con-nected subgraph. Adding a positive edge to M would strictly increase M  X  X  score without discon-necting M , which would contradict the fact that M is maximal. Thus M must contain G (1) .
 Induction step: By the inductive hypothesis, there exists some maximum spanning connected subgraph M =  X  V,E M  X  that contains G ( i ) . and the hypothesis still holds.

Otherwise, since M is connected and does not contain e , E M  X  X  e } must have a cycle containing e . In addition, that cycle must have some edge e 0 contain a cycle, and e would not connect two un-fact that e was chosen by MSCG .

Since e 0 is in a cycle in E M  X  X  e } , removing it will not disconnect the subgraph, i.e. ( E M  X  X  e } ) \ { e 0 } is still connected and spanning. The score of e is greater than or equal to the score of e 0 , oth-erwise MSCG would have chosen e 0 instead of e . Thus,  X  V, ( E M  X  X  e } ) \{ e 0 } X  is a maximum span-the hypothesis still holds.
 is a spanning connected subgraph. The maximum spanning connected subgraph M that contains it cannot have a higher score, because G contains every positive edge. Hence G is maximal. 4.2 Lagrangian Relaxation If the subgraph resulting from MSCG satisfies con-straint 4 (deterministic) then we are done. Oth-erwise we resort to Lagrangian relaxation (LR). Here we describe the technique as it applies to our task, referring the interested reader to Rush and Collins (2012) for a more general introduction to Lagrangian relaxation in the context of structured prediction problems.

In our case, we begin by encoding a graph G =  X  V
G ,E G  X  as a binary vector. For each edge e in the fully dense multigraph D , we associate a bi-nary variable z e = 1 { e  X  E G } , where 1 { P } is the indicator function, taking value 1 if the propo-sition P is true, 0 otherwise. The collection of z e form a vector z  X  X  0 , 1 } | E D | .

Determinism constraints can be encoded as a set of linear inequalities. For example, the con-straint that vertex u has no more than one outgoing ARG0 can be encoded with the inequality:
X All of the determinism constraints can collectively be encoded as one system of inequalities: with each row A i in A and its corresponding entry b in b together encoding one constraint. For the previous example we have a row A i that has 1 s in the columns corresponding to edges outgoing from u with label ARG0 and 0 X  X  elsewhere, and a corresponding element b i = 1 in b .

The score of graph G (encoded as z ) can be written as the objective function  X  &gt; z , where  X  e =  X  &gt; g ( e ) . To handle the constraint Az  X  b , we in-troduce multipliers  X   X  0 to get the Lagrangian relaxation of the objective function: And the dual objective: Conveniently, L So for any  X  , we can find z  X   X  by assigning edges the new Lagrangian adjusted weights  X   X  A &gt;  X  and reapplying the algorithm described in  X  4.1. We can find z  X  by projected subgradient descent, by starting with  X  = 0 , and taking steps in the direction: If any components of  X  are negative after taking a step, they are set to zero.

L ( z ) is an upper bound on the unrelaxed ob-jective function  X  &gt; z , and is equal to it if and only if the constraints A z  X  b are satisfied. If tion to the constrained solution. Otherwise, there exists a duality gap, and Lagrangian relaxation has failed. In that case we still return the sub-graph encoded by z  X  , even though it might vio-late one or more constraints. Techniques from in-teger programming such as branch-and-bound or cutting-planes methods could be used to find an optimal solution when LR fails (Das et al., 2012), but we do not use these techniques here. In our experiments, with a stepsize of 1 and max number of steps as 500 , Lagrangian relaxation succeeds 100% of the time in our data. 4.3 Focus Identification In AMR, one node must be marked as the focus of the sentence. We notice this can be accomplished within the relation identification step: we add a special concept node root to the dense graph D , and add an edge from root to every other node, giving each of these edges the label FOCUS . We require that root have at most one outgoing FO -CUS edge. Our system has two feature types for this edge: the concept it points to, and the shortest dependency path from a word in the span to the root of the dependency tree. In order to train the parser, we need alignments be-tween sentences in the training data and their an-notated AMR graphs. More specifically, we need to know which spans of words invoke which con-cept fragments in the graph. To do this, we built an automatic aligner and tested its performance on a small set of alignments we annotated by hand.
The automatic aligner uses a set of rules to greedily align concepts to spans. The list of rules is given in Table 2. The aligner proceeds down the list, first aligning named-entities exactly, then fuzzy matching named-entities, then date-entities, etc. For each rule, an entire pass through the AMR graph is done. The pass considers every concept in the graph and attempts to align a concept fragment rooted at that concept if the rule can apply. Some rules only apply to a particular type of concept fragment, while others can apply to any concept. For example, rule 1 can apply to any NAME con-cept and its OP children. It searches the sentence for a sequence of words that exactly matches its OP children and aligns them to the NAME and OP children fragment.

Concepts are considered for alignment in the or-der they are listed in the AMR annotation (left to right, top to bottom). Concepts that are not aligned in a particular pass may be aligned in subsequent passes. Concepts are aligned to the first match-ing span, and alignments are mutually exclusive. Once aligned, a concept in a fragment is never re-to the fragment by rules 8 X 14.

We use WordNet to generate candidate lemmas, and we also use a fuzzy match of a concept, de-fined to be a word in the sentence that has the longest string prefix match with that concept X  X  la-bel, if the match length is  X  4 . If the match length is &lt; 4 , then the concept has no fuzzy match. For example the fuzzy match for ACCUSE -01 could be  X  X ccusations X  if it is the best match in the sen-tence. WordNet lemmas and fuzzy matches are only used if the rule explicitly uses them. All to-kens and concepts are lowercased before matches or fuzzy matches are done.

On the 200 sentences of training data we aligned by hand, the aligner achieves 92 % preci-sion, 89 % recall, and 90 % F 1 for the alignments. We now describe how to train the two stages of the parser. The training data for the concept identifi-cation stage consists of ( X,Y ) pairs:  X  Input: X , a sentence annotated with named entities (person, organization, location, mis-ciscellaneous) from the Illinois Named Entity
Tagger (Ratinov and Roth, 2009), and part-of-speech tags and basic dependencies from the Stanford Parser (Klein and Manning, 2003; de
Marneffe et al., 2006).  X  Output: Y , the sentence labeled with concept subgraph fragments.
 The training data for the relation identification stage consists of ( X,Y ) pairs:  X  Input: X , the sentence labeled with graph frag-ments, as well as named enties, POS tags, and basic dependencies as in concept identification.  X  Output: Y , the sentence with a full AMR Alignments are used to induce the concept label-ing for the sentences, so no annotation beyond the automatic alignments is necessary.

We train the parameters of the stages separately using AdaGrad (Duchi et al., 2011) with the per-ceptron loss function (Rosenblatt, 1957; Collins, 2002). We give equations for concept identifica-tion parameters  X  and features f ( X,Y ) . For a sentence of length k , and spans b labeled with a sequence of concept fragments c , the features are: To train with AdaGrad, we process examples in the training data (( X 1 ,Y 1 ) ,..., ( X N ,Y N )) one at a time. At time t , we decode (  X  3) to get  X  Y t and compute the subgradient: We then update the parameters and go to the next example. Each component i of the parameter vec-tor gets updated like so:  X  is the learning rate which we set to 1. For relation identification training, we replace  X  and f ( X,Y ) in the above equations with  X  and We ran AdaGrad for ten iterations for concept identification, and five iterations for relation iden-tification. The number of iterations was chosen by early stopping on the development set. We evaluate our parser on the newswire section of LDC2013E117 (deft-amr-release-r3-proxy.txt). Statistics about this corpus and our train/dev./test splits are given in Table 3.
For the performance of concept identification, we report precision, recall, and F 1 of labeled spans using the induced labels on the training and test data as a gold standard (Table 4). Our concept identifier achieves 84 % F 1 on the test data. Pre-cision is roughly the same between train and test, but recall is worse on test, implicating unseen con-cepts as a significant source of errors on test data.
We evaluate the performance of the full parser using Smatch v1.0 (Cai and Knight, 2013), which counts the precision, recall and F 1 of the concepts and relations together. Using the full pipeline (concept identification and relation identification stages), our parser achieves 58 % F 1 on the test data (Table 5). Using gold concepts with the re-lation identification stage yields a much higher Smatch score of 80 % F 1 . As a comparison, AMR Bank annotators have a consensus inter-annotator agreement Smatch score of 83 % F 1 . The runtime of our system is given in Figure 3.

The large drop in performance of 22 % F 1 when moving from gold concepts to system concepts suggests that joint inference and training for the two stages might be helpful. Our approach to relation identification is inspired by graph-based techniques for non-projective syn-tactic dependency parsing. Minimum span-ning tree algorithms X  X pecifically, the optimum branching algorithm of Chu and Liu (1965) and Edmonds (1967) X  X ere first used for dependency parsing by McDonald et al. (2005). Later ex-concepts P R F 1 P R F 1 gold .85 .95 .90 .76 .84 .80 automatic .69 .78 .73 .52 .66 .58 tensions allow for higher-order (non X  X dge-local) features, often making use of relaxations to solve the NP-hard optimization problem. Mcdonald and Pereira (2006) incorporated second-order features, but resorted to an approximate algorithm. Oth-ers have formulated the problem as an integer lin-ear program (Riedel and Clarke, 2006; Martins et al., 2009). TurboParser (Martins et al., 2013) uses Lagrangian relaxation, to integrate third-order fea-tures into a CLE backbone. Future work might ex-tend JAMR to incorporate additional linguistically motivated constraints and higher-order features.
The task of concept identification is similar in form to the problem of Chinese word segmenta-tion, for which semi-Markov models have success-fully been used to incorporate features based on entire spans (Andrew, 2006).

While all semantic parsers aim to transform nat-ural language text to a formal representation of its meaning, there is wide variation in the mean-ing representations and parsing techniques used. Space does not permit a complete survey, but we note some connections on both fronts.

Interlinguas (Carbonell et al., 1992) are an im-portant precursor to AMR. Both formalisms are intended for use in machine translation, but AMR has an admitted bias toward the English language.
First-order logic representations (and exten-sions using, e.g., the  X  -calculus) allow variable quantification, and are therefore more power-ful. In recent research, they are often associ-ated with combinatory categorial grammar (Steed-man, 1996). There has been much work on sta-tistical models for CCG parsing (Zettlemoyer and Collins, 2005; Zettlemoyer and Collins, 2007; Kwiatkowski et al., 2010, inter alia ), usually using chart-based dynamic programming for inference.
Natural language interfaces for querying databases have served as another driving applica-tion (Zelle and Mooney, 1996; Kate et al., 2005; Liang et al., 2011, inter alia ). The formalisms used here are richer in logical expressiveness than AMR, but typically use a smaller set of concept types X  X nly those found in the database.

In contrast, semantic dependency parsing X  X n which the vertices in the graph correspond to the words in the sentence X  X s meant to make semantic parsing feasible for broader textual domains. Al-shawi et al. (2011), for example, use shift-reduce parsing to map sentences to natural logical form.
AMR parsing also shares much in common with tasks like semantic role labeling and frame-semantic parsing (Gildea and Jurafsky, 2002; Pun-yakanok et al., 2008; Das et al., 2014, inter alia ). In these tasks, predicates are often disambiguated to a canonical word sense, and roles are filled by spans (usually syntactic constituents). They consider each predicate separately, and produce a disconnected set of shallow predicate-argument structures. AMR, on the other hand, canonical-izes both predicates and arguments to a common concept label space. JAMR reasons about all con-cepts jointly to produce a unified representation of the meaning of an entire sentence. We have presented the first published system for automatic AMR parsing, and shown that it pro-vides a strong baseline based on the Smatch eval-uation metric. We also present an algorithm for finding the maximum, spanning, connected sub-graph and show how to incorporate extra con-straints with Lagrangian relaxation. Our feature-based learning setup allows the system to be easily extended by incorporating new feature sources. The authors gratefully acknowledge helpful cor-respondence from Kevin Knight, Ulf Hermjakob, and Andr  X  e Martins, and helpful feedback from Nathan Schneider, Brendan O X  X onnor, Waleed Ammar, and the anonymous reviewers. This work was sponsored by the U. S. Army Research Laboratory and the U. S. Army Research Office under contract/grant number W911NF-10-1-0533 and DARPA grant FA8750-12-2-0342 funded un-der the DEFT program.
