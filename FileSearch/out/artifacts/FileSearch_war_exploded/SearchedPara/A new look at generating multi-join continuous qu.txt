 1. Introduction 1.1. Continuous query plan generation optimal output rate [10]. [9,11,12] , approximation of query results [13] and in some cases thrashing. same output rate [10].
 problem. 1.2. Relationship between resource usages results (memory) with the assumption that this will also reduce CPU costs. recompute intermediate tuples.
 mal analysis highlighting these resource trade-offs.
 a qualified plan exists in the solution space Fig. 2 . 1.3. The proposed approach run-time optimization needed for streaming applications.
 layer of plan generation into action.
 moved at the expense of increasing CPU resources needed for their re-computation. 1.4. Summary of contributions generating a query plan whose usages of both CPU and memory resources are within the system capacities. tive correlation between the resources usages.
 our first layer of optimization, as their respective starting point. solution is to expensive. 1.5. Organization our approach is presented in Section 6 through our experiments. Section 8 concludes the paper. 2. Preliminaries usage have a positive or a negative correlation. 2.1. Join method basics utilized. However, this would further complicate the already NP-Hard problem considered in this work. are first inserted into the state of A (denoted as S A ), then used to probe the state of B  X  S tinuous multi-join queries.
 in this work are not restricted by it.

P realizing the user query captured by the join graph JG . 2.2. Cost analysis for mjoin join orderings in Fig. 4 b, a new tuple from A is first inserted into state S window frame are purged 2 from S A (at cost C d ). This inserted tuple is then joined with tuples in state S are CPU A  X  k A  X  C i  X  C d  X  X  k A j S B j r AB C j  X  k A The total CPU processing costs for our mjoin are: The memory costs for the mjoin (Fig. 4 b) thus is estimated as: 2.3. Cost models for bjtree Fig. 4 , a new tuple from A is first inserted into the state S tuples in state S B . The joined tuples are inserted into intermediate state S tuples in state S AB . The cost models to compute the unit CPU costs for input A is CPU k k Estimated memory costs is given by the total state size: The first two terms in Eq. (4) are identical for bjtrees of any shape. The third term, 2 j S 2.4. Condition for negative correlation
As indicated by Eqs. (3) and (5) , MEM bjtree is always larger than MEM
From this, several key observations can be drawn, the CPU usage as no re-computations are needed. resources needed to store them as well as the CPU resources needed to maintain them.
In this work, we exploit this phenomenon of sacrificing one resource to gain another. 3. Qualified plan solution space 3.1. The basics on optimal vs. qualified plans query Q represented by a join graph JG and the available system resources CPU i.e., CPU  X  P 1 ; JG  X  &lt; CPU  X  P 2 ; JG  X  &lt; CPU avail threshold while the optimal plan P 1 exceeds the system memory resources, i.e., Memory  X  P not adhere to both the resource constraints, while missing the qualified plan P
Definition 2. Given the available system resources CPU avail
CPU avail and Memory  X  P ; JG  X  6 Mem avail .

The objective of this work is to design algorithm(s) that generate a qualified plan as in Definition 2 . 3.2. The jtree solution space r r r the mjoin solution is a qualified solution and therefore we choose accordingly.  X  CPU mjoin  X  is above the system CPU threshold. While the memory utilization of mjoin  X  Mem us to profit from this negative resource correlation. 3.3. Dynamic programming-based exploration of jtree space [25] could similarly be employed.
 all possible query plan shapes, including bushy bjtrees , mjoins and jtrees ,asin Fig. 1 . respective system thresholds at an early stage.
 nate at some iteration k , where k &lt; n , if no sub-plans of size k are found to be qualified. Algorithm 1. JTree-Finder for exploring jtree solution space
Input : Join Graph JG over U  X f A ; B ; C ... g ; Dual-Resource Constraints: CPU
Output : Set of Qualified Query Plans  X  Q  X  or 1 1: SubPlans  X  X ; ; SubPlans  X  k : set of plans of size k 2: Add all input streams in U to SubPlans [1] 3: for pSize = 2 to j U j do 4: for all V # U and j V j X  pSize do 5: PT Find all distinct partitions of V 6: for each partition PT  X  i 2 PT do 7: P  X  Generate Plans  X  PT  X  i ; SubPlans  X  X  8: for each P i 2 P do 9: if  X  Memory  X  P i ; JG  X  6 Mem avail  X  AND  X  CPU  X  P i 10: if pSize  X j U j then 11: Add P i to Q 12: else 13: Add P i to SubPlans[pSize] 14: if  X  SubPlans  X  pSize  X  /  X  then return 1 15: return Q // Return Qualified Plans and represented by a join graph JG . The available system resources are CPU have already been generated in the previous iterations.
 3.3.1. Time complexity 4. Evaluation of JTree-finder 4.1. Experimental methodology 4.1.1. Objectives 4.1.2. Environment 4.1.3. Organization
Our experiments are categorized into four sets by adjusting (1) availability of system resources CPU (Fig. 5 d) in the solution space. 4.1.4. Experimental setup tuples accumulated in all of its queues within one unit time. In this work, this is denoted as CPU query processing the required CPU  X  CPU reqd  X  must be 6 1 unit time (implying CPU in the input queues making it infeasible to keep up with the new tuples coming from input streams.
We measured the per tuple run-time average costs of join  X  C parameter settings in the 4 sets of experiments.
 4.2. Analysis of different plan types 4.2.1. Experiment set 1
When both mjoin and bjtree are qualified plans they have similar accumulated throughput 4.2.2. Experiment set 2 the queue sizes are kept small on an average. 4.2.3. Experiment set 3 (Fig. 8 c). As the memory of bjtree accumulates (Fig. 8 d) it reaches the threshold  X  M memory temporarily used by the intermediate results. 4.2.4. Experiment set 4 Accumulated Throughput (tuples) include general jtrees. 4.2.5. Comparative study number of streams N in between 3 and 20 streams . Accumulated Throughput (tuples) Accumulated Throughput (tuples) Accumulated Throughput (tuples/sec) 5. Our approach: two-layer plan generation 5.1. Overview query plans. Algorithm 2 presents the pseudo-code of our framework. 11). For example, consider the scenario when the memory resources needed by the mjoin, Memory  X  P is triggered to explore the jtree search space.
 Algorithm 2. Two-layer plan generation
Input : Join Graph JG ; S  X f A ; B ; C ... g Resource Constraints: CPU
Output : Qualified Query Plan P or 1 1: // Layer-One 2: P mjoin  X  Find MJoin Ordering  X  JG  X  3: if Memory  X  P mjoin ; JG  X  6 Mem avail then 4: if CPU  X  P mjoin ; JG  X  6 CPU avail return P mjoin 5: else return 1 // Mem avail Bound Restrictive 6: P bjtree  X  Find BJTree Ordering  X  JG  X  7: if CPU  X  P bjtree ; JG  X  6 CPU avail then 8: if Memory  X  P bjtree ; JG  X  6 Mem avail return P bjtree 9: else return 1 // CPU avail Bound Restrictive 10: // Layer-Two 11: P  X  State Selection  X  JG ; CPU avail ; Mem avail ; P mjoin 12: Mem r  X  Memory  X  P ; JG  X  ; CPU r  X  CPU  X  P ; JG  X  13: if  X  Mem r 6 Mem avail  X  AND  X  CPU r 6 CPU avail  X  return P 14: P  X  State Removal  X  JG ; CPU avail ; Mem avail ; P bjtree 15: Mem r  X  Memory  X  P ; JG  X  ; CPU r  X  CPU  X  P ; JG  X  16: if  X  Mem r 6 Mem avail  X  AND  X  CPU r 6 CPU avail  X  return P 17: return 1 // No Qualified Plan Found system thresholds. In this regard, we present two polynomial-time algorithms that start from either P erated in the previous layer. Our state-selection algorithm (Section 5.2) starts with an mjoin plan P is dependent on several factors such as where P mjoin and P such as memory-spilling [11,12,9] , load shedding [8,10] or query distribution [28,29] . without a result (4). 5.2. The state-selection algorithm by saving on the corresponding re-computation CPU costs.
 intermediate results can save CPU costs.
 The edge weight connecting vertices V x and V y is the estimated intermediate state size, k tion algorithm chooses the edge with the largest (frequency/weight) ratio.
Fig. 9 c. In each iteration the algorithm selects an edge with the max
For each edge V x V y , the algorithm accesses the benefits of storing its intermediate states. Vertices V into one vertex with input rate of k V x k V y r V x V y , i.e., we create a binary join V be stored to reduce the CPU usage, or (2) memory usage of jtree exceeds Mem Algorithm 3. State-selection algorithm
Input : Dual-Resource Constraints: CPU avail ; Mem avail ; Join Graph JG ; P
Output : Qualified JTree Plan P or 1 2: CPU r  X  CPU  X  P ; JG  X  ; Mem r  X  Memory  X  P ; JG  X  3: while  X  CPU r &gt; CPU avail  X  AND  X  Mem r &lt; Mem avail 4: E = Set of candidate edges in JG 5: while ( E != null) do 6: Choose E 7: Let E i be an edge that connect vertices V x and V y 8: JG new  X  Merge vertices V x and V y to V xy in JG 9: Optimize  X  V xy ; JG new ; CPU avail ; Mem avail  X  10: P new MJoin Ordering  X  JG new  X  11: CPU new  X  CPU  X  P new ; JG new  X  12: if  X  CPU new &lt; CPU r  X  then 13: P  X  P new ; CPU r  X  CPU new ; JG  X  JG new 14: if Memory  X  P ; JG new  X  &gt; Mem avail then 15: return 1; // No qualified plan found 16: Remove E i from E 17: if  X j E j X  X  0  X  then return 1 18: return P // Exist loop when qualified plan found
The output rate of the merged vertices DE is k D k E r DE constraints to return a qualified implementation of the merged vertex. 5.2.1. Time complexity case time complexity of O  X  n 3 log  X  n  X  X  . 5.3. The state-removal algorithm
JG , system resource constraints CPU avail and Mem avail and the bjtree plan P thereby saving on the memory resources utilized but in turn increasing the total CPU consumption. explored.
 Algorithm 4. State-removal algorithm
Input : Dual-Resource Constraints: CPU avail ; Mem avail ; Join Graph JG ; P
Output : Qualified JTree Plan P or 1 2: S = set of all intermediate states in P current 3: while S  X  / do 4: CPU r  X  CPU  X  P ; JG  X  ;min ratio  X 1 5: for (each S i 2 S ) do 6: op 1 = join operator contains S i 7: op 2 = join operator with feeds tuples to S i 8: P new  X  Merge  X  P ; op 1 ; op 2  X  9: // 1. Merges op 1 and op 2 into newOp ; 10: // 2. Generates join ordering for newOp 11: CPU new = CPU  X  P new ; JG  X  12: state-ratio  X  X  CPU new CPU r  X  =  X j S i j X  13: if  X  state-ratio &lt; min ratio  X  then 14: min ratio  X  state-ratio;state  X  S i ; P s  X  P new 15: Remove state from S ; P  X  P s 16: if (CPU  X  P ; JG  X  6 CPU avail  X  AND (Memory  X  P ; JG  X  17: return P // A Qualified Plan 18: return 1 // No Qualified Plan Found removing the state and the additional CPU resources needed to recompute the intermediate results. If CPU tively, the increase in CPU costs can be computed as D CPU removed intermediate state. State quality ratio is defined as D surpasses the cost of recomputing the state, the D CPU factor is negative. 5.3.1. Time complexity complexity of O  X  n 2 log  X  n  X  X  , the total running time is bounded by O  X  n 3 log  X  n  X  X  . 6. Comparative study 6.1. Experimental methodology 6.1.1. Objectives ated by the state-selection versus by the state-removal algorithms. 6.1.2. Environment
We use the same testing environment that was presented in Section 4. 6.1.3. Organization the time unit of 1 s, thus CPU avail  X  1s. 6.2. Effectiveness of proposed algorithms (a) (b) mented in Java.
 ger N as JTree-Finder fails due to its exponential time complexity. state of the particular solution space we studied. 6.3. Resource utilization of generated plans CPU Cost (sec) plan that is closer to that starting point. 6.4. Discussion: statistic gathering and plan migration 7. Related work based language proposed to express continuous queries against streams and updatable relations. However, like mjoin, it suffers from the additional re-computation CPU costs. ator. Our solution instead looks at the query plan-level, exploring the entire jtree solution space. a plan that satisfies multiple resource constraints within a central system. 8. Conclusions and future work tially qualified plans and (2) the effectiveness of our algorithms over the state-of-the-art techniques. identify their correlations to CPU and memory resource usages.
 Acknowledgment
References
