 Gerd Gr  X  oner 1 , Christian Wende 2 ,MarkoBo X  skovi  X  c 3 , Fernando Silva Parreiras 1 ,
Tobias Walter 1 , Florian Heidenreich 2 , Dragan Ga X  sevi  X  c 3 , and Steffen Staab 1 The increasing number of software systems with similar required functionality has led software engineers to move from d evelopment of single software systems to the development of Software Product Lines (SPLs). A SPL is a set of software systems that share most of the features [ 1]. Because of the sh ared commonalities, development of families improves reusability and is more cost effective [2].
ASPL 1 is typically specified with three kinds of models: problem space mod-els , solution space models and mapping models [3]. Problem space models define available features of the members of the SPL, as well as their interdependen-cies. They are typically used by stakehol ders for selection of desired features of the product. The set of selected features is called configuration . Solution space models are comprehensive models that speci fy the realization of complete SPLs. In this paper, we focus on business process families, i.e., families whose solu-tion space models are business process model templates. Business process model templates are specified by business process modeling languages and composed of business process patterns. From solution space models, a particular product, i.e., a business process model is derived by removing or adding parts of it. Finally, mapping models define mapping relations between problem space and solution space models. They regulate which parts might be removed from the business process model according to the selected features from the problem space model.
Given such a representation of business process families, we have to guaran-tee that each process model, that is built according to a feature configuration, does not violate any well-formedness constraints of the business process model template. Due to the size of contempor ary business process families, it is time consuming, costly and error-prone to manually validate that each configuration has a well-formed corresponding busines s process model. For these reasons, an automated approach for the constraint validation is necessary.

To address this problem, in this paper, we propose a classification of interre-lationships between elements of busin ess process models and demonstrate how this classification can be used for the validation. The classification is based on an analysis of basic workflow patterns, a set of conceptual basis for process lan-guages. This classification is specified in Description Logics (DL), which we use as means of validating business process templates. A typical SPL consists of three kinds of artifacts, representing its problem space, solution space and mappings between the problem and solution space [3]. We introduce one such SPL, a part of the Electronic Store (e-store) SPL [4].
Fig. 1 depicts a snippet of the business process family of the e-store case study. The representation contains a feature model to represent commonality and variability of the business process fam ily, a business process model template, specified in the Business Process Modeling Notation (BPMN) and mappings between features and elements of the business process model template.
Interdependencies in the feature model are specified with mandatory and op-tional parent-child relationships and alternative and or feature groups .A manda-tory parent-child relationship specifies that if a parent feature is selected in a certain configuration, its mandatory child feature has to be too (e.g., E-Shop and StoreFront ). An optional parent-child relationship specifies a possibility of the selection, e.g., StoreFront and WishList .An alternative feature group ,or xor feature group ,(e.g., Basic and Advanced ), specifies that when their parent feature is selected, exactly one of the members of the group can be selected. Finally, an or group (e.g., Emails , ProductFlagging and AssignmentToPageTypesForDisplay ) defines a set of features from which at least one has to be selected.
Feature models also contain interdependencies between features that are not captured by the tree structure of feature diagrams, called cross-tree constraints, namely includes and excludes . Includes means that if an including feature is in a configuration, the included feature has to be as well (e.g., EmailWishList and Registration ). Excludes is the opposite to includes .

Business process model templates are specified in a business process modeling language. In Fig. 1, we use BPMN to sp ecify a business process model tem-plate. Such a template typically consists of process patterns like subprocesses ( WishList ), activities (e.g., WishListNameEntry ), gateways (diamonds), condi-tional sequence flows and data objects ( WishListName ). These process patterns impose well-formedness constraints like grouping of activities.

Finally, mappings connect the features with elements of the solution space model that implement the business logic of particular configurations. For ex-ample, every configuration that contains the Registration feature, contains the WishListName data object. On the contrary, every configuration that does not contain the feature MultipleWishList leads to a business process model where the corresponding mapped activity WishListNameEntry is missing. All elements of the business process model template that are not mapped to any feature are contained in every business process model.

The problem in this context is given by the constraints of both modeling spaces in combination with mappings bet ween the feature model and the business process model template. Given a particular feature configuration and a mapping, we have to ensure, that the corresponding business process model satisfies the well-formedness constraints of the template. In this paper, Description Logic (DL) [5] is used to formalize the constraints of interests in models of interests and ena ble validation services. We could have used some other formalism, but we opted for DL as it is precise and expressive enough to serve our purpose -formalize constraints that need to hold between our models of interest. Discussions of expan siveness of DL over some other options, although an important research topic, is outside of the scope of this paper. 3.1 Modeling with Description Logics DL is a decidable subset of first-order logic (FOL). A DL-based knowledge base is established by a set of terminological axioms (TBox) and assertions (ABox). The TBox is used to specify classes, which den ote sets of individuals and properties defining binary relations between individuals. The main syntactic constructs are depicted in Table 1, supplemented by the corresponding (FOL) expressions. 3.2 Representing Models of Business Process Families In this section, we provide formal definitions of the three considered modeling spaces: (i) problem space, (ii) solution space and (iii) mapping space that com-bines features from the problem space with entities in the solution space. Definition 1. AFeatureModel  X  = F , F P , F M , F IOR , F XOR , F cr is a tree structure that consists of features F . F p  X  X  X F is a set of parent and child feature pairs, F M  X  X  is a set of mandatory features with their parents. All other features are optional. F IOR  X  X  ( F )  X F and F XOR  X  X  ( F )  X F are sets of pairs of child features and its common parent feature. The child features are either inclusive or exclusive features. Finally, F cr  X  X  X F is a set of cross-tree constrained feature pairs that are either in an includes or excludes relation.
Axiom 1 defines StoreFront and BusinessManagement as mandatory child fea-tures of E-Shop . There is no such axiom for optional child features. Except of the root feature, each feature has a parent feature. Axiom 2 defines E-Shop as the parent feature of StoreFront . For inclusive and exclusive child features, a class union is used. For instance, Axiom 3 defines Basic and Advanced as exclusive child features of the parent feature Searching . The axiom ensures that only one feature is selected (cf. [6]). Axiom 4 dep icts a cross-tree constraint where the feature EmailWishList includes Registration .

The solution space is defined by a business process model template. In Def. 2, we give generic definitions for solution space models. We focus on elements that are mapped to features, i.e., these elements realize a certain feature. Obviously, the granularity of mapping solution spac e models (e.g., classes, attributes) de-pends on the applications. In the reset of this paper, all elements that are sub-classes of the BPMN class Element canbemappedtofeatures.
 Definition 2. A Solution Space Model  X  = S , T consists of entities S that could be mapped to features and entities that are not mapped and do not directly realize features ( T ). The sets S and T are disjoint.
 Concrete process models found in the solution space are automatically trans-formed to a knowledge base  X   X  . The transformation creates classes for con-structs of the BPMN metamodel, like the classes Activity and SequenceEdge ,in-dependently of the concrete BPMN model template. All elements of the BPMN model template are modeled as subclasses of Element (i.e., elements of S ). Vertex , Activity and SequenceEdge are subclasses of Element (Axiom 5). RequestWishList is a concrete activity, defined by a subclass axiom too (Ax-iom 6). Likewise, an edge E1 in the process model is represented by a subclass axiom (Axiom 7). The relations from activities to edges are described using existential restrictions on the object property outgoingEdge (Axiom 8).
Mappings (Def. 3) connect features F and the elements S of the solution space model  X  . A feature can be mapped to multiple elements and likewise an element in the solution space might realize multiple features.
 Definition 3. For a feature model  X  = F , F P , F M , F IOR , F XOR , F cr and a solution space model  X  = S , T , a Mapping Model M is a relation M  X  X  X S , that is defined as F X S := { ( f, s ): f  X  X  X  s  X  X } .
 Finally, we transform the mapping models into a TBox  X  M . For each mapped element E  X  X  in  X  , we introduce a class Map E that is a subclass of Map . The object property feature is used to describe the mappings from elements to features. A mapping from an element E toafeature F is represented by an axiom Map E  X  feature.F (Axiom 9). The mapping classes Map E are introduced to separate the feature mapping from the solution space. In order to ease the validation later on, we define the property hasF eature as a subproperty of the property feature form the mapping model (Axiom 10). 3.3 Well-Formedness in the Business Process Model Templates Besides solution space models, we have to represent syntactic and structural well-formedness constraints of the proces s models. They are imposed by the BPMN language and by basic workflow patterns, as described in [7].

We focus in our work on structural well-formedness for two reasons. Firstly, for the class of structural models, structural constraints coincide with behavioral constraints (see the work on behavioral profiles that are derived from process structure trees [8]). Secondly, there are techniques to derive structured models for a broad class of unstructured models [9].

Elements of the business process model template that are not mapped to any feature occur in each process model. In c ontrast, the appearance of a mapped element in a process model depends on the feature configuration. For the sake of a more compact representation, we introduce auxiliary constructs. In Axiom 11, each element with at least one mapping to a mapping class is defined by the class M appedElement . Axioms 12, 13 and 14 define (composite) properties.
We identify three types of constraints. (i) An element might require another element. (ii) An element always appear in conjunction with another element. (iii) Elements of a process model might exclude each other. There is no influence on elements in inclusive or -branches by feature mappings, since well-formedness violations only occur due to missing elements in the process model.

We introduce three classes Required , Conjunct and Exclude to capture ele-ments according to the different cons traints. For instance, if element E is classi-fied as a required element, we expect that E is subsumed by the (super-) class Required . Additionally, a property isRequired is introduced to get for an el-ement its required element. The corresponding element E that requires E is obtained by a derivable axiom like E  X  isRequired.E . Likewise, we can use the property sibling (Axiom 14) to get the sibling activities.
 Sequence. A sequence describes a series of a ctivities that are connected by sequence edges. In a BPMN model, there are no dangling edges allowed, i.e., if there is a mapping to an activity, a violation might occur, if the activity is missing. Let us consider the mapping of the optional feature MultipleW ishList to the activity W ishListN ameEntry . In this case, we have to guarantee that sequence edges require their correspo nding source and target vertex. Axiom 15 defines each mapped activity with an incoming or outgoing sequence edge as required . The corresponding properties incomingEdge and outgoingEdge are defined as subproperties of the introduced property isRequired (Axiom 16). Container Element. BPMN models facilitate grouping and decomposition of activities. Axiom 17 describes that container elements such as groups and sub-processes are supposed to be required by their elements. Groups in a BPMN model use the property activities to define which activities are members of this group, while subprocesses use the properties vertices and sequenceEdges .These properties are defined as subproperties of isRequired in order to have a connec-tion to the element X  X  counterparts (Axiom 18).
 Conditional Flow. Activities with outgoing conditional sequence edges impose the existence of at least one unconditional outgoing sequence edge. This con-straint might be violated in the case an unconditional sequence edge is mapped and could be possibly removed in a certain configuration. For instance, consider the mapping of the optional feature MultipleW ishList to the conditional out-going edges of the activity RequestW ishList in Fig. 1. In this case, a feature configuration could result in a process model without any outgoing uncondi-tional edge. In order to avoid this, we describe in Axiom 19 that a mapped unconditional edge which is the only outgoing edge is required.
 Opening Gateway. An opening gateway is used to express the divergence of a control flow. While the number of outgoing branches is arbitrary in general, it is required that there are at least two outgoing sequence edges. Otherwise the gateway does not represent any divergence. Axiom 21 defines a mapped sequence edge that is one of at most two outgoing edges as a required element. Axiom 22 defines the property composition of source and outgoingEdge as subproperty of isRequired in order to find the counterparts.
 Closing Gateway. The convergence of a control flow in a process is described by closing gateways. Like for opening gat eways, a closing gateway needs at least two incoming sequence edges. Axioms 23 and 24 are similar to the previous Axioms just for closing gateway. Exclusive Branching. Activities that appear in exclusive branches are sup-posed to be exclusive, i.e., it is not allowed to execute activities from alternative branches in a process execution. Axiom 25 defines each mapped element between XOR-gateways as a subclass of Exclude .
 Parallel Branching. If activities occur in parallel branches, they have to be executed commonly, i.e., if an activity of the first branch is executed, then also the activity of the second branch is ex ecuted. In Axiom 26, we define elements between AND-gateways as subclasses of the class Conjunct .
 Our aim is to ensure that the well-formedness constraints are satisfied in all process models that can be derived fro m a process model template. The con-straints are represented by logical for mulas, DL expressions in our case. We use the expression f  X  to represent a constraint on features and f  X  to represent a constraint on elements of the busines s process. From a logical point of view, checking whether the constraint given by f  X  ensures that the constraints repre-sented by f  X  hold, can be realized by checking whether the implication f  X   X  f  X  holds for each interpretation, i.e., f  X   X  f  X  is a tautology.

In order to test the implication f  X   X  f  X  for all mapped elements, we have to tackle the following problems. (i) While the constraints in the problem space are directly represented b y the axioms, the constraints of the process model template are implicitly given by the elem ent X  X  dependencies (cf. Sect. 3). Hence, we have to classify and derive constraints of the mapp ed elements. (ii) We have to guarantee that the same vocabulary and the same expression structure is used in f  X  and f  X  . This is realized by building constraint expressions . (iii) Finally, we have to check in DL whether the implication holds.

In Sect. 3.3, we specify implicit constraints of business processes and define axioms in order to allow a dynamic classification of mapped and constrained elements. These elements are cate gorized as subclasses of the classes Required , Conjunct and Exclude . Defined properties ( sibling and isRequired )aswellastheir inverse properties help to get their count erparts. E.g., for the conjunct element E , the counterpart ( E ) can be found by using the subsumption E  X  sibling.E . Building Constraint Expressions. For the mapped elements, we build class expressions f  X  and f  X  . To check the implication (subsumption in DL ( f  X  f  X  )), we describe f  X  and f  X  by complex class expressions in DL. Additionally, we introduce a class expression f  X  which will be used in the next step (Def. 4).
Depending on the constraint type ( Conjunct , Required or Exclude )oftheel-ement E , the expression f  X  is built either as intersection, implication or exclusive class expression. However, instead of the element E , we use the corresponding mapping class Map E (cf. Axiom 9) of the mapping model and the property feature that is a superproperty of hasF eature (cf. Axiom 10). This guarantees the alignment of classes and properties between  X   X  and  X   X  .

For the feature model, f  X  is the intersection of parents and cross-tree con-straints of all mapped features ( F )of E . The absence of optional child features in the parent definition of the feature mo del (Axioms 1-3) directly meets the need of the feature representation in f  X  , since for an optional mapped feature, we can not guarantee the appearance of the corresponding element in each business process model. The set F of mapped features F is obtained from the mapping knowledge base  X  M by axioms like Map E  X  feature.F . Cross-tree constraints are captured by the expression cr ( F ). To allow a subsumption checking of the expressions in cr ( F ), we define the properties includes and excludes as sub-properties of feature . The functions elements and element are abbreviations. The element(s) is/are either the element that require another element or sibling elements, they can be found by using the introduced properties isRequired and sibling .
 Definition 4. The final knowledge base  X  is constructed from the problem, so-lution and mapping space knowledge bases, i.e.,  X  :=  X   X   X   X   X   X   X  M . Moreover, for each mapped and constrained element, an axiom f  X   X  X  f  X  f  X  is added to  X  ,where f  X  and f  X  are defined as follows:  X  for each element E Conjunct and S := elements ( sibling, E ) :  X  for each element E Required and E := element ( isRequired, E ):  X  for each element E Exclude and S := elements ( sibling, E ) : Implication Checking. We reduce subsumption checking f  X  f  X  toaclas-sification problem by introducing f  X  . According to Def. 4, we add for each sub-sumption checking problem the corresponding axiom f  X   X  X  f  X  f  X  . Finally, we check for each class expression f  X  whether it is equivalent with the top class ( f there is a violation. Moreover, f  X  is a subclass of the corresponding mapping class Map E . This directly indicates the elemen t that violates the constraint.
The validation effort is determined by the number of mappings and the num-ber of elements that are involved in one of the constraints ( Required , Conjunct and Exclusive ). There are two steps where reasoning is applied. (i) We classify the knowledge base in order to find the constrained elements. To build the class expressions f  X  (for each mapping one expression), we use class subsumption to get the counterparts. For this purpose, we have to iterate over each element that is a subclass of Required , Conjunct and Exclusive , but without any further classification. (ii) The second step is a further knowledge base classification, in order to find those expressions f  X  that are not equivalent to the top class . Class subsumption and classification are both standard reasoning services that are quite tractable in practice. The DL expressivity is SHOIN . This section demonstrates the correct ca pturing of the constraints in DL by the implication f  X   X  f  X  . We start with an consideration of the constraint coverage by these expressions. Afterwards, we show that well-formedness of the business process model template can be concluded from the implication checking. Constraint Coverage. In our case, we know that both models are correct on its own. Hence, a violation of the well-formedness constraints can only be caused by the mappings. Our aim is to guarantee the well-formedness of each process model from the business process m odel template, for each valid feature configuration. We consider di fferent cases how an element E might be involved in a feature mapping. In case the element is not mapped, there might be no violation, since the constraint types only contains mapped elements. E remains in each process model and is not involved in any constraint with another element.
If E is mapped to at least one feature F , it depends whether E is involved in a well-formedness constraint. In case E is not involved, there cannot be any vio-lation of a well-formedness constraint, due to the same reasons as for unmapped elements. More difficult is the case when E is involved in one of the constraints. The constraint expression f  X  (Def. 4) encodes the corresponding constraint of E with its counterpart elements, e.g., sibling elements. The intention of f  X  is, that the encoded constraint has to be satisfied in all business process models. Hence, we have to check whether f  X  holds for each feature configuration.
Again, we know that without any mapping there is no violation in the business process model template. Therefore, we know that only the constraints of the mapped feature F might lead to a violation of f  X  . The expression f  X  captures these constraints of all mapped features F of E . We build f  X  as a conjunction on all these features (cf. Def. 4) to capture the case that there are multiple mappings of one element E . The constraints of the features are directly given by the definition of the parent features and the cross-tree constraints of F .
The alignment is solved by a design decision of the mapping model (cf. Sect. 3.3). The property feature maps an element E toafeature F ,byan axiom Map E  X  feature.F . The property hasF eature is defined as a subprop-erty of feature from the mapping space (Axiom 10) . Hence, all class expressions from the problem space using the property hasF eature are subsumed by expres-sions where this property is replaced by its superproperty feature .InDef.4,we use Map E instead of elements E in the expression f  X  . Hence, f  X  and also f  X  only contain classes of the feature model and hasF eature and feature are in a subproperty relation. The expression f  X  is composed of the mapped elements ( Map E of  X  M ) according to the logical meaning of their constraint classification ( Required , Conjunct or Exclude ).
 Formula Representation in DL. In the validation, we check whether f  X  ( f tion f  X  f  X  holds for each interpretation (tautology). Due to the alignment, we can compare f  X  and f  X  by DL reasoning. Finally, we have to demonstrate that this subsumption ensures that the solution space constraints are satisfied for each allowed feature configuration (Lemma 1).
 Lemma 1 (Correctness of the Validation). For mappings from an element E to a set of features F , f  X  are the constraints of F and f  X  the constraints of E .If f  X  is subsumed by f  X  then the well-formedness constraints of all elements E hold.
 Proof. Looking to the different types of constraints in both spaces, we basically deal with implication , and , or and xor . Hence, we have to consider all possible combinations in both spaces and check whether f  X   X  f  X  is a tautology. This kind of logical problem is in the nature of propositional logic. Hence in Def. 4, we define the DL expressions f  X  and f  X  in a propositional style. The term connec-tors are the DL counterparts, e.g., the intersection ( ) for an and (  X  ). Instead of propositional variables, there are class expressions like  X  hasF eature.F contain-ing features and the properties feature and hasF eature from  X   X  and  X  M .Itis easy to see in Def. 4 that f  X  is built as a DL expression representing either a con-junctive, exclusive or implicative combination. In f  X  , we conjunctively connect the parent features and the cross-tree co nstraints that are already represented in this modeling style. The evaluation of our approach has been conducted by providing a proof-of-concept which has been developed by int egrating the FeatureMapper [10] and the transformation of the control flow parts of BPMN to DL, as described in [11]. Setting. We applied the validation to the case study that was introduced in Sect. 2 and is part of the e-store SPL [4]. The feature model consists of 287 fea-tures, 2 top features, 192 of the features are leaf features and all others are parent features. There are 21 cross-tree references, including mandatory and optional as well as OR-grouped features. The pr ocess model contains 84 activities.
In the settings, we validated feature models with 154 features and with the entire feature model (287 features). In both cases, we build either 22 or 48 mappings. The average validation time using the Pellet reasoner is 2970 ms for 154 features with 22 mappings and 4430 ms for 287 features with 48 mappings. The time for the transformation to DL is less that the validation time. This is based on the fact that we use the DL-oriented feature model of [6] and we only transform the relevant control flow informations of BPMN to DL. Validation Exemplified. We demonstrate the validation of one map-ping for an easy example from the case study excerpt of Fig. 1. We as-sume a mapping from the subprocess W ishList to the mandatory feature BusinessM anagement . The mapping is represented in  X  by an axiom Map W ishList  X  f eature.BusinessM anagement . We expect no con-straint violations since the feature BusinessM anagement is mandatory. Concerning the validation, f  X  is build using the parent definition, i.e., f The expression f  X  is build using the class Map W ishList from the mapping model ( f  X   X  X  X  f eature.BusinessM anagement ). For the subsumption checking of f  X  by f  X  , we can replace the property feature by hasF eature .Itiseasy to see that due to the negation of f  X  , f  X  is equivalent to the top class : f  X  hasF eature.BusinessM anagement . In case a particular mapping causes a violation, the user finds the corresponding constraint expression f  X  classified as not equal to the top class ( ).
 Lessons Learned. In Sect. 3.3, we already distinguished the focus of our work on well-formedness constraints to the work on behavioral profiles of [12]. After a deeper comparison of both formalisms, w e find two interesting aspects that di-rectly impose further research challenges. Firstly, behavioral profiles are efficient to compare process behavior and behavior consistency. It might be a promis-ing step to extend our well-formedness constraint validation towards a behavior constraint validation, while we still offer the same feature-oriented configuration view in combination with the mappings. S econdly, in this context, we see poten-tial on using DL for the validation. The main challenge from the DL modeling perspective is to handle the possibility of concurrent executions of activities. This problem seems to be in line with the descriptive modeling style of DL to capture this kind of execution potentiality. Due to the increasing need of business p rocesses customization, several ap-proaches for the development of families of business processes have been in-troduced like Schnieders et al. [13], Boffoli et al. [14], La Rosa et al. [15] and van der Aalst et al. [16]. Schnieders et al. [13] model families of business process models as a variant-rich business process model. A configuration of such a fam-ily is performed by directly selecting business process elements of variant-rich processes. In order to support such an approach, Schnieders et al. extend BPMN with concepts for modeling variation. H owever, in order to perform it, such an approach requires from a customer know ledge of business process modeling.
Boffoli et al. [14] and La Rosa et al. [15] also distinguish between business process models and problem space models. Boffoli et al. model problem space as variability table, while La Rosa et al. provide variability by questionnaires. They provide guidance to derive valid configurations, while our aim is to guarantee that for each possible and valid feature configuration there is a corresponding valid process model that satisfies th e well-formedness constraints.
More similar to our objective is the approach for process configuration from van der Aalst et al. [16]. Their framework e nsures correctness-preserving config-uration of (reference) process models. In contrast to our wor k, they capture the variability directly in the workflow net by variation points of transitions. Ac-cordingly, a configuration is built by assigning a value to the transitions, while our approach uses feature selections.

Weidlich et al. [8,12] derive behavior profiles to describe the essential be-havior in terms of activity relations like exclusivity, interleaving and ordering of activities. Weber et al. [17] extend p rocess models by semantic annotations and use them for the validation of proces s behavior correct ness that captures control-flow interaction and behavior of a ctivities. In contrast to our work, their focus is on behavioral constraints, while we consider structural well-formedness constraints. Moreover, our particular emphasis is on the feature-oriented process family representation.

In the context of SPLs several approaches have been introduced, in order to ensure the well-formedness of solution sp ace models. Czarnecki et al. [18] specify constraints on solution space model configurations using OCL constraints. Prob-lem space models, solution space models with OCL constraints, and mappings between them are transformed to Binary-Decision Diagrams.

Thaker et al. [19] introduce an approach for the verification of type safety, i.e., the absence of references to undefined classes, methods, and variables, in solu-tion space models w.r.t. all possible problem space configurations. They specify the models and their relations as propositional formulas and use SAT solvers to detect inconsistencies. Janota et al. [20] and van der Storm [21] introduce ap-proaches to validate the correctness of mappings between feature and component models. They use propositional logics too. As shown in the related work section, our contribution is primarily related to the validation of families of business processes. While the concept of business process families was previously introduced and even covered in our own work [22], there have been very limited (if any) attempts to propose a validation of such families.
Our proposal validates business process models w.r.t. their well-formedness constraints; mappings to problem space models; and dependencies in the prob-lem space models. Hence, unlike other approaches on validation of (model-driven) software product lines, our approach also considers the very nature of business process models through the set of busin ess process practices encoded in con-trol flow patterns. Even though, in this paper, we used BPMN for defining the solution space of business process families, our approach is easily generalizable to other types of business process mod eling languages. This can be deduced from control flow patterns used in this paper and control flow support analyzes presented in the relevant literature [23].
We evaluated our work with the largest publicly-available case study, for which we were able to find all the three types of models. While this case study has a realistic size, we would like to have a benchmarking framework which will allow for simulating larger solution space and mapping models. This is similar to what has been already proposed for feature models [24], but now to be enriched for the generation of business process model te mplates of different c haracteristics. We plan to organize a user study where the proposed approach will be evaluated by asking software modelers to complete some tasks by applying our tooling. A further plan is to extend our validation formalism towards behavioral constraints in the business process model template.
 Acknowledgements. This work has been supported by the EU Project MOST (ICT-FP7-2008 216691).

