 Historical census data capture valuable information of individuals and house-holds in a region or a country. They play an important role in analysing the social, economic, and demographic asp ects of a population. [2,17,19] Census data are normally coll ected on a regular basis, e.g. every 10 years. When linked over time, they provide insightful knowledge on how individuals, families and households have changed over time. Such information can be used to support a number of research topics in the social sciences.

Due to the benefit of historical census data linkage, and the fact that there are large amount of data available, automatic or semi-automatic linking methods have been explored by data mining researchers and social scientists [2,11,17,19]. These methods treat histo rical census data linkage as a special case of record linkage, and apply string comparison methods to match individuals. Some re-searchers have linked historical census data with other types of data, and used Bayesian inference or discriminative learning methods to distinguish matched from non-matched records [20]. Although progress has been made in this area, the current solutions are far from practical in dealing with the ambiguity of data.
Difficulties of historical census data linkage come from several aspects. These include poor data quality caused by the census data collection and digitisation process, and large amount of similar values in names, ages and addresses. More importantly, the condition of individuals in a household may change significantly between two censuses. For example, peopl e are born and die, get married, change occupation, or moved home. These problems are made more challenging in early historical census, i.e. those collected in the 19th or early 20th century, where only limited information about individuals were available. As a result, linking individuals is not reliable, and many false or duplicate matches are often gener-ated. This is also a common problem in other record linkage applications, such as author disambiguation [8].

To tackle this problem, some methods have used the household information in the linkage process to help reducing e rroneous matches. For example, a group linking method [16] has been applied to generate a household match score by combining similarity scores from each matched individual in a household [9]. This allows the detection of possible truth matches of both households and individuals by selecting candidates with the highest group linking score. When labeled data are available, Fu et al. developed a hou sehold classification method based on multiple instance learning [6,10]. In this method, individual links are considered as instances and household links as bags. Then a binary bag level classifier can be learned to distinguish matched and non-matched households.

Nonetheless, these household linking methods treated a household as a set of collected entities that correspond to indi viduals. They have not taken the struc-tural information of households into consideration. While personal information, such as marital status, address and occupation, may change over time, surnames of females may change after marriage, and even ages may change due to different time of the year for census collection or input errors, the relationships between household members normally remain unchanged. This is the most stable struc-tural information of a household. Such relationships include but are not limit to age difference, generation difference, and role-pairs of two individuals in a household. If the structural information can be incorporated into the linking model, the linking accuracy can be improved. Figure 1 shows an example on how household structure helps improve the household linking performance.
A graph-based approach is a natural solution to model the structural relation-ship between groups of records. During the past years, several graph matching methods have been proposed to match records. Domingos proposed a multi-relational record linage method to de-duplicate records [7]. This method defines conditional random fields, which are undirected graphical models, on all candi-date record pairs. Then a chain of inference is developed to propagation matching information among linked records. Hall and Fienberg reported a method to build bipartite graphs and evaluate the confidence of different hypothetical record link assignments [12]. This method can be used to link datasets of moderate size. Nuray-Turan et al. built a graph model and labelled dataset to compute the strength of connections among linked candidate records [15]. A self-tuning approach is devel-oped to update the model in a linear programming fashion. Furthermore, hierar-chical graphical model have been proposed to cope with the potential structure in large amount of unlabeled data [18].

Because the goal of graph methods is to match or de-duplicate multiple records, all of them treat records that are linked to each other as vertices and links between them as edges. Therefore, the edges show the similarity between individual records. In our research, on the contrary, we build graphs on house-holds. Specifically, the vertices in graph correspond to members in a household, while the edges shows the relationship between members in that household. Then we transform the household linking problem to a graph matching problem [3], i.e., household matching is determined not only by individuals, but also by the structure of their households.

The contribution of this paper is two-fold. First, we develop a graph matching method to match households in historica l census datasets. Our method demon-strates excellent performance in finding potential household matches and re-moving multiple matches. Second, to generate more accurate record matching results, we adopted a logistic regression method to estimate the probability that two vertices across two household graphs are matched. Given a query household, the goal of our work is to find the best matching household among a list of target households, and then to determine whether this match is a true match. In the proposed method, we show that this goal can be reached by a graph matching method, whose structure is summarised in Figure 2. The first step is record similarity calculation, whose results are used to find candidate matched record pairs. These records are then used to construct graph for each household. Graph matching is then performed based on vertex matching and graph similarity calculation. 2.1 Definition Let H be a query household and r i  X  H be the record of the i th member in this household, with M = | H | be the total number of records in household H , and 1  X  i  X  M . Similarly, let H  X  X  be a household amongst a list of target households in H to be linked with H ,and r j  X  H be the record of the j th member in H , with M = | H | the number of records in household H ,and 1  X  j  X  M .If H and H refers to the same household, they are matched.
 Otherwise, H and H are not matched.
 An undirected attributed graph G =( V,E, , X  ) can be defined on H ,where V is a set of vertices correspond to the household members. E  X  V  X  V is a set of edges connecting vertex pairs, which sh ow the relationship between household with vertices and edges respectively. In a similar manner, we can define a graph G =( V ,E , , X  )onhousehold H .

Once these household graphs are built, the household linking problem becomes a graph matching problem, such that the matched household can be identified based on graph similarity [21]. During this process, a key step is to generate a matching matrix for the graph pair such that vertices in V can be matched to vertices in V . When labeled data is available, this problem can be solved by the quadratic or linear assignment method [3].

In the census household linking problem, domain knowledge tells that each individual in one household can only be matched to one individual in another household. In the following, we show how this domain knowledge is used to develop an efficient vertex matching method. Furthermore, we introduce a vertex matching method to match household members before graph construction, such that the sizes of graphs can be reduced. 2.2 Record Similarity The historical census datasets used in thi s research contain attributes for each individual in a specific district as detailed in Section 4. Approximate string matching methods can be applied to these attributes to generate similarity val-ues. During this process, a blocking technique [5] is used to remove those record pairs with low similarities, so that the cost of computation can be reduced. Each attribute may have a different contribution in matching two records. In order to estimate the contribution from each attribute, we model the vertex matching problem as a binary classification problem, and solve it by logistic regression method. Assume we have T record pairs x i , i =1 , 2 ,  X  X  X  ,T , with label y i = +1 for matched and y i =  X  1 for non-matched classes. Let features of record pairs be x ij ,where0  X  x ij  X  1, j =1 , 2 ,...,Q ,and Q is the number of similarities generated from different approximate string matching methods on the record attributes. A logistic regression model is given by where w is a vector of coefficients corresponding to the input variables. Then the maximum likelihood estimation of w is which can be solved by iterative optimisation methods [13].

Once the optimal solution w  X  is available, the posterior probability that a record pair is matched can be calculated as Note that this posterior probability can be considered as the vertex similarity in the following graph model. It should also be pointed out that the logistic regression based record similarity is independent of graph matching, hence, can be used on any pairwise record comparison as long as a training set is available. 2.3 Record Linking The outputs of the above step are record pair similarities. Here, we need to determine which record pairs may be a true match. Decisions can be made by comparing the vertex similarity with a threshold  X  , such that In our method, following the classic decision rule of logistic regression classifica-tion [1], we set  X  =0 . 5.
 After thresholding, low similarity record pairs are removed from consideration. In the remaining record pairs, the query record may still be linked to multiple target records. For this case, the record pa ir with the highest similarity shall be selected. In some cases, more than one record pairs may have the same highest similarity value, then all of the matched records are selected. 2.4 Graph Generation and Vertex Matching After the record pair selection step, a gra ph can be generated for each household. Note that the record matching step can remove a large number of low probability links, such that individual links in a household without high probability do not need to be included in the graph generation. This allows small household graphs to be generated, which leads to high computation efficiency.

As mentioned previously, several tar get records may be selected for a query record at the record matching step. Therefore, one-to-many and many-to-one vertex mappings may be generated between two graphs. Then the optimal vertex to vertex correspondence has to be determined. Although such vertex matching can be done by supervised learning [3], in our method, we adopted the Hun-garian algorithm [14], which is a more straightforward method with an O ( n 3 ) computational complexity, where n is the number of vertices. This algorithm generates the vertex matching that maximizes the sum of matched probabilities. The output of this step is graph pairs with one-to-one vertex mapping. Note that the average number of members in a household is less than 5, therefore, the complexity of this step is not a significa nt factor that affects t he efficiency of our method. 2.5 Graph Similarity and Matching In the previous record matching step, a r ecord may be linked to multiple records in different households. Therefore, a graph containing the record may be linked to several other graphs. Similar to the r ecord matching step, decisions also have to be made on which graph pair is a possibly a true match, and if there are multiple matches, which pair is the correct one. This requires the calculation of graph similarity. Here, we define the similarity between graph G and G as where f v ( V,V )and f e ( E,E ) are the total vertex similarity and total edge similarity, respectively, and  X  is a parameter that controls the contribution from f ( V,V )and f e ( E,E ).

Note that vertex similarity has been generated in the record matching step from the output of the Hungarian algorithm. Let sim v ( r i ,r i )bethevertexsim-ilarity of the i th record pair x i in the graph, and the total number of vertices in G be N ,then
The calculation of total edge similarity is based on differences of edge at-tributes (details to be described later ) between each pair of edges in the graph pair. Let r ijk be the k th ( k  X  [1 ,...,K ]) attribute of the edge r ij which connects record r i and r j in graph G ,and r ijk be the corresponding edge in graph G , then where L is the number of edges in the graph. sim e ( r ij ,r ij ) is the edge similarity, which is defined as follows where sim a ( r ijk ,r ijk ) is the edge attribute similarity.

The graph similarity calculation allows selecting the optimal match from sev-eral target graph candidates. Th en whether the selected graph G  X  is a true match of the query or not can be judged by the following condition: If the graph similarity is larger than threshold  X  , then it is considered as true match. Note that parameters  X  , ! and  X  can be learned from the training set by grid search. In this section, we give implementation de tails of several key steps in our method. Starting from the record similarity calculation, we adopted 10 combinations of attributes and approximate string matching methods to generate features of record pairs for the logistic regression model. The implementation of the string matching methods follows the work done by Christen [4] and Fu et al. [9], ex-cept that the age similarity is based on probabilities generated by a Gaussian distribution on the age differences. A summary of these attributes and string matching methods are provided in Table 1. In calculating the total vertex sim-ilarity f v ( V,V ), an alternative method is the group linking approach proposed in [16]. We implemented this model and combined it with the total edge similar-ity for graph similarity calculation. Different from [9], we used the probability generated by the logistic regression step to calculate record similarity, instead of using an empirical record similarity calculation by adding the attribute-wise similarities. Then the group linking based graph vertex similarity is calculated using the following equation where M and M are the numbers of household members in H and H respec-tively. N is the set of record pairs matched between H and H as defined in Equation (6). Note that different from the vertex similarity calculated in Equa-tion (6), group linking takes the number of distinct household members into consideration rather than merely the matched members.

Equation (8) requires calculation of several edge attribute similarities. In the proposed method, such edge attributes are generated to reflect the structural prop-erty of households. In more detail, three a ttributes have been considered. They are age and generation differences between tw o household members connected by an edge, and the role pair between two household members. The calculation of age difference is straightforward. When comparing edges in two graphs, the edge sim-ilarity on this attribute is the probability generated by the Gaussian distribution of the difference of the age differences in two edges. The generation difference is based the relative generation with respect to that of the household head. A lookup table is built for this purpose. For example, as shown in Figure 1, a record with role value  X  X ife X  is in the same generation as the a record with X  X ead X , therefore their generation difference is 0. The generation difference between  X  X ead X  and  X  X on X  or  X  X aughter X  is 1.

The role pairs are even more complex. We listed most of the possible role pairs between two household members and generated a lookup table to show how such role pair can change. For example,  X  X ife-son X  may change to  X  X ead-son X  if the husband of a household died in between census and the wife became the head. When comparing two edges, binary valu es are generated fo r both generation difference and role pair attributes. If the corresponding generation difference value of two edges is different, the similarity is 0, otherwise, it is set to 1. For the role pair attribute, if a role pair change is has been recorded in the training data, we set the similarity to 1, otherwise, it is set to 0. In the experiments, we used six census dat asets collected from the district of Rawtenstall in North-East Lancashire in the United Kingdom, for the period from 1851 to 1901 in ten-year intervals. These datasets are in digital form, and each census is a table that contains information of record for each individual. There are 12 attributes for each record, including address of the household, full name, age, sex, relationship to the household head, occupation and place of birth et al. These data were standardised and cleaned before applying the record/household linkage step as done in [9]. In total, there are 155,888 records which correspond to 32,686 households in the six datasets. 4.1 Results on Synthetic Data We built a synthetic dataset from the real census dataset in order to evaluate the performance of our method. We manually labeled 1,250 matched household pairs from the 1871 and 1881 historical census datasets. The labels also include matched records in the matched households. These became the positive samples in the dataset. Then we built negative samples by randomly selecting households and records in the 1871 and 1881 datasets, we built links to labelled positive data. Because both household and individual follow one-to-one match, we are sure that these negative samples are true un-matched samples. In this way, we have generated a dataset with ground truth at both household and record levels.
In order to train the logistic regression model in Equation (1),  X  in Equa-tion (5), ! in Equation (8), and  X  in Equation (9), we split the synthetic dataset into a training and a testing test with equal number of households. After these parameters had been learned on the training set, we applied them to the graph matching model and evaluate the model on the testing set.
 We compared our method (Graph Matching) with several baseline methods. The first baseline method (Highest Similarity) matches household based on the highest record similarity. If one query hou sehold is linked to sev eral target house-holds, the target household with the highest record similarity is selected. The second baseline (Vertex Similarity) builds household graphs using linked records. Then the household matching is determined only by the vertex similarity calcu-lated by Equation (6). This is equivalent to calculating the mean record similarity on those records used to build graphs. The third method (Group Linking) is the group linking method [9] as defined by Equation (10). We replaced the vertex similarity with the group linking score in the graph matching step, so that the final decision of household matching is determined by the sum of group linking and edge similarity. We mark this method as  X  X roup Graph X .

Figure 3 shows the precision-recall curve of record matching, when the pro-posed logistic regression method is used to generate the similarity between pairs of records, or when the sum of the attribute-wise similarities generated by the approximate string matching methods are taken directly as similarity between pairs of records, which was the method a dopted in [9]. The precision and recall values change with the thresholds use d to determine whether two records are matched or not. This figure shows that the performance of logistic regression model has significantly outperformed the sum of similarity method. This is due to the training process that allows better modelling of the data distribution.
To show how effective the training step is, we used the trained logistic regres-sion model,  X  , ! ,and  X  G as the default values for the proposed graph matching method, and evaluated the method on the testing set using precision and re-call values. We also calculate the F-measure, which allows balanced contribution from both precision and recall. The resul ts from the methods being compared are summarised in Table 2. It can be seen that the graph matching method has generated the best F-score when combined with group linking for graph simi-larity calculation. Its performance is very close to the graph matching method as proposed in this paper, which has significantly outperformed record similar-ity based method. This shows that by considering the structure information of households, we can greatly improve the linking performance.
 4.2 Results on Historical Census Datasets Finally, we trained the graph model on the whole labelled data set, and applied it to all six historical census datasets. Similar to the experiment setting in [10], we classified all household and record lin ks from any pair of consecutive census datasets, e.g. 1851 with 1861, 1861 with 1871, and so on. The matching results are displayed in Table 3 for the number of total household matches found on different datasets that include multiple matches of a household in another dataset, and in Table 4 for the number of unique household matches for which a household in one dataset is only matched to one household in another dataset. From the tables, it can be observed that both graph-based methods and the group linking method have generated much less total matches and unique matches than the record similarity based methods. Note that the difference between total matches and unique matches are duplicate matches. The results indicate that the proposed graph matching methods are very effective reduce number of duplicate matches. In this paper, we have introduced a graph matching method to match households across time on the historical census data. The proposed graph model considers not only record similarity, but also incorporates the household structure into the matching step. Experimental results have shown that such structure information is very useful in household matching practise, and when combined with a group linking method, can generate very reliable linking outcome. This method can easily be applied to other group record linking applications, in which records in the same group are related to each other. In the future, we will develop graph learning methods on larger datasets, and incorporate more features for graph similarity calculation.
