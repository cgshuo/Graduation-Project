 Architecture, and aim at supporting intero perable machine-to-m achine interactions over the Web. Because of inherent autonomy and heterogeneity , Web services are Process mediation is very valuable for complex service interactions in which several Web services may involve. However, pro cess mediation is optional for RPC-style service interactions, where there is only a single request-response message exchange. 
Based on the message exchange patterns speci fied for a Web service, called as the public process, process mediation aims at resolving message sequence mismatches for: (1) s ervice discovery and selection : to ensure that discovered and/or selected Web used for identifying whether a goal and the services are compatible from a behavioral aspect, (2) service composition : process mediation would gu arantee that there are only resolvable behavioral mismatches [12] among a goal and Web services, and (3) service execution : process mediation would instruct the exchange of messages among Web services, and thus smooth the interaction. 
In this paper, we propose a novel approach of process mediation for dealing with SWSs conceptual models. In addition, we propose an architecture for process mediation based on Triple Space Computin g (TSC) [8]. Potential solutions are presented for resolvable mismatches. Furtherm ore, we classify th ese mismatches into five classes. The main contributions of this paper are four-fold: (1) a novel approach process mediation based on TSC, (3) potential solutions for resolvable message sequence mismatches, and (4) five cla sses for these resolvable mismatches. 
The rest of the paper is organized as follows: In Section 2, we give an introduction to WSMO and TSC. In Section 3, we propose our TSC-based architecture for process mediation. In Section 4, we present potential solutions for resolvable message sequence mismatches and categorize them into five classes. In Section 5, we discuss related works. In Section 6, we conclude this paper and indicate our future work. Due to the space limitation, we give a brie f introduction to WSMO in Section 2.1 and Triple Space Computing in Section 2.2. 2.1 WSMO WSMO is one of the major SWSs conceptual models initiated by the Web Service components: ontology , Web services , goal , and mediator , following the framework proposed in WSMF [9]. Web services and goals have a common component: an view of operational competence: choreography [10] and orchestration [14]. 
Choreography describes the behavioral interface of Web services by which a client user X  X  point of view. A user can be a person, an application, or another Web service. 
Orchestration defines the behavioral interface of a Web service for achieving its functionality by aggregating other Web services [18]. An orchestration could be regarded as a  X  composition  X  of several  X  sub-goals  X . Each  X  sub-goal  X , acting as a user, consumes another Web service through its choreography. However, an orchestration choreography. 2.2 Triple Space Computing TSC is a persistent communication and coordination paradigm for application and service integration on the Web [21]. It is based on the convergence of Semantic Web Web-scaled and space-like middleware to enable so-called Web paradigm: communication medium in the same way as the humans use the Web [21]. The main not need to know each other and there is no explicit communication channel between them. They exchange information by writing and reading RDF triples to and from a Space would follow TSC data schema, which follows RDF specification. This makes the provider and the requester independent of their internal data schemas. 
Besides the functionality of space-based computing, TSC offers more features such as transaction support, distribution, and query using RDF format etc. For more In this Section, we propose an approach of process mediation addressing behavioral mismatches for WSMO-based Web services, and present a TSC-based architecture for process mediation. 3.1 Process Mediation Framework Process mediation bridges potential behavioral mismatches between a user and a Web service chorography, or between a  X  sub-goal  X  of a Web service orchestration and the choreography of another Web service. Data mediation is necessary to support process shown in Figure 1. Process mediation would concentrate on behavioral compatibility partners, and an interaction involving multiple partners can often be decomposed into several pair-wise interactions. 3.2 Architecture TSC-based process mediation architecture is presented in Figure 2. Data mediation addresses potential data heterogeneity problems if a user and a Web service are described by different ontologies. TSC brings machine-to-machine Web service interaction to Web scale, and acts as a co mmunication middleware between a user and space within TSC for a given interaction, which includes two sub-spaces: one for the user and another for the Web service. Data would follow TSC data schema. The user and the Web service send requests to and retrieve responses from TSC. They do not communicate directly. Based on data stored in TSC, process mediation could handle possible behavioral mismatches between the user and the Web service. 
Typically, Web service interactions are based on the message exchange paradigm, service interactions are: Backend storage : TSC provides a global, Web-scale space middleware for service available in a shared virtual data space. Asynchrony : TSC acts as a message broker between Web services. Therefore, Web services do not need to know each other explicitly, and communication channels between Web services are unnecessary [6]. 
Without loss of generality, we assume that the messages exchanged between Web services in a given interaction are asynchronous because synchronous can always be acknowledgement (ACK) to indicate that a message sent was received by the receiver and semantically valid. Or negative acknowledgement (NAK) to indicate that the data received is invalid in syntax. State archiving for Web service interactions : TSC allows the storing of the history of the advantages: (1) this enables the monitoring of communicating applications, therefore observed behavior of Web services. Therefore, we can check whether this observed manual adjustment, but does not need to start again from scratch. This is critical for long-running or non-repeatable interactions. Semantic autonomy : TSC data model acts as intermediate model for the partners involving in a given interaction. They do not need to agree on a common data representation. Therefore, data mediation is not mandatory. A Web service interaction, especially that of complex Web services, often requires a flow of messages exchanged among the partner(s), and needs to maintain a state internally [2]. There may be some mismatches between the exchanged messages if the interaction is not realize their public processes, and thus the messages sent by one partner are exactly the same in terms of order and granularity as requested by its corresponding partner [12]. In problems. message sequence mismatches (Section 4.1) and resolvable message sequence mismatches [12] (Section 4.2 and 4.3). 4.1 Irresolvable Message Sequence Mismatches Irresolvable message sequence mismatches means that these mismatches cannot be handled automatically. As stated in [12], th e following two scenarios are presented as irresolvable message sequence mismatches : (1) one partner wants to receive a lacking a required message, and (2) one partner expects an ACK for a certain message, but the other does not want to receive this message. Process mediation cannot generate such an ACK. Otherwise the entire communication is changed. following two solutions: (1) to change the interface definition for the goal and/or the Web service to avoid mismatches, or (2) to operate manually (such as skipping the activity that causes a fault) to bypass the failure. 
However, Web service interface is often not allowed to be changed arbitrarily, and it is processes, and irresolvable mismatches are out of the scope process mediation. 4.2 Resolvable Mismatches and Potential Solutions The left side of Figure 3 presents five scenarios for resolvable message sequence priori knowledge of ontologies used by the business partners. Below we introduce these mismatch scenarios and their potential solutions: expected by BP2. Process mediation should retain and store  X  X  X  for possible later use. mediation adds or updates data instance for  X  X  X  in the sub-space of BP2. Scenario B : suppose that BP1 sends messages  X  X  X  and then  X  X  X  to BP2, while BP2 expects to receive  X  X  X  and then  X  X  X . Process mediation reverses the ordering of these two messages. Based on the ontology of BP2, process mediation knows that both  X  X  X  and  X  X  X  are expected by BP2, and process mediation adds or updates data instances for both  X  X  X  and  X  X  X  in the sub-space of BP2. Scenario C : suppose that BP1 sends both  X  X  X  and  X  X  X  in a single message to BP2, while mediation should split this single message from BP1. Potential Solution : There are two kinds of possible reasons for this mismatch: ontology of BP1, while  X  X  X  and  X  X  X  are modeled by different concepts in the ontology of BP2. -The ontologies of BP1 and BP2 are the same for  X  X  X  and  X  X  X : one concept for  X  X  X  and message of BP1: ( X  X  X  +  X  X  X ) implies two concepts, while the messages of BP2:  X  X  X  and  X  X  X  imply only one concept. 
Data mediation knows the mapping for BP1 ( X  X  X  +  X  X  X ) to BP2 ( X  X  X ) and BP2 space of BP2. Scenario D : suppose that BP1 sends two messages  X  X  X  and  X  X  X  to BP2, while BP2 expects to receive them in one single me ssage. Process mediati on should combine two messages from BP1 into one message for BP2. Potential Solution : This is the reverse case of Scenar io C, and could be solved in the similar way as presented in Scenario C.  X  X  X . If  X  X  X  is expected by BP2, and BP2 is not willing to send an ACK back, process mediation should generate this ACK and send it back to BP1. mediation knows that  X  X  X  is expected by BP2, so it updates the sub-space of BP2 for syntax, a NAK is returned. Process mediation has the knowledge of message formats for both BP1 and BP2. 4.3 Discussion In this section, we analyze these resolvable mismatches shown in Figure 3. They can be categorized into five classes: Class One: Extraneous data . Scenario A in Figure 3 is a good example of this class: one partner provides more data than what its partner wants to receive. However, this is only applicable to asynchronous communication. If the interaction is synchronous, this falls into irresolvable mismatches. An example is illustrated in Figure 4, which is synchronous counterpart of Scenario A: 
BP1 expects a response for  X  X  X .  X  X  X  is not expected by BP2, which means that BP2 not. If process mediation generates an ACK (or NAK) to BP1 for  X  X  X , ACK (or NAK) BP2, but  X  X  X  is not correct in terms of format or syntax ). Obviously, ACK (or NAK) process mediation could not generate and send an ACK (or NAK) back to BP1, and this is a scenario of irresolvable mismatches. Class Two: Interaction with synchronous and asynchronous communication . Scenario E in Figure 3 falls into this class, which means that one partner is synchronous while the other is asynchronous. Based on the discussion in Class One, it is clear that Class Two is resolvable only if the data sent is expected by the receiver. which means that the partners use differen t ontologies, and some mismatches exist between these ontologies. Data mediation aims at supporting process mediation for solving these data heterogeneity problems. Class Four: Message granularity heterogeneity . Scenarios C and D in Figure 3 messages. Class Five: Unnecessary me ssage sequence dependencies . Scenarios B and D in Figure 3 fall into this class. Message sequence dependency means the ordering of the messages. The necessary message sequence dependency means that message ordering should be held during execution phases. We further explain this by Scenario B in Figure 3. Firstly, we rename message  X  X  X  sending as MsgA, while message  X  X  X  sending as MsgB. The purpose of messages renaming is to indicate that this concept applies to both incoming and outgoing messages. Necessary message sequence dependency of MsgA and MsgB indicates that: MsgA s hould be sent or received before MsgB, while MsgB should not be sent or received before MsgA. 
Based on Scenario B, Figure 5 gives an example for unnecessary message sequence dependency, and shows that an unnecessary dependency can be removed. In scenario B, BP1 is willing to send  X  X  X  and then  X  X  X . However, BP1 could reverse the sequence by sending  X  X  X  and then  X  X  X . The changed sequence has no impact to the behavior of BP1 because  X  X  X  does not depend on  X  X  X . It is the same for messages  X  X  X  and  X  X  X  in BP2. 
Based on this observation, we remove the sequence between  X  X  X  and  X  X  X  as presented in Scenario B1. The behavior specified by Scenario B1 is the same as that of Scenario B, while the message sequence mismatch in Scenario B disappears in Scenario B1. Scenario B1 is actually an example of perfect-match. Figure 6 presents examples for necessa ry message sequence dependency in change. These mismatches are irresolvable. Scenario B2 : BP1 is willing to send  X  X  X  then wait for  X  X  X , and after that send  X  X  X .  X  X  X  may be the response of  X  X  X , therefore the content of  X  X  X  may depend on the content of necessary and cannot be changed. Similar for BP2 that the sequences among  X  X  X ,  X  X  X  because BP1 waits for  X  X  X  while BP2 waits for  X  X  X . Process mediation cannot generate  X  X  X  for BP1, as well as  X  X  X  for BP2. Scenario D2 : BP1 wants to send  X  X  X  then wait for  X  X  X , after that send  X  X  X . Based on the analysis of Scenario B2, the sequences among  X  X  X ,  X  X  X  and  X  X  X  are necessary and cannot be changed. The same for BP2 that the sequence between ( X  X +b X ) or ( X  X +a X ) and  X  X  X  is necessary and should be preserved. The interaction between BP1 and BP2 fails because BP1 waits for  X  X  X  while BP2 waits for ( X  X +b X ) or ( X  X +a X ). The requirement of process mediation for supporting complex Web service authors present the scope of process medi ation, list resolvable message sequence mismatches, propose an approach to integrate process mediation as a component into WSMX [19], and specify the interaction mode of process mediation with other components. In addition, they argue that pr ocess mediation would be used to support starting point of process mediation in WSMX . This paper benefits much from this work, especially message sequence mismatches in Section 4. However, the proposed for complex ones such as choice or loop [20]. The work does not mention the importance of process mediation for complex service interactions, in which process mediation needs to support service discovery and selection to guarantee that the goal and the services are be haviorally compatible. 
An adapter-based approach is proposed in [4] intending to semi-automatically resolve Web service differences at interface and business protocol levels. Possible differences between Web services are identified and captured by mismatch patterns . A pattern includes a business logic template, and can be used as a type of mismatch addressed by an adapter. However, mismatch patterns at the interface level are actually data heterogeneity problem s covered by data mediation. Mismatch patterns at the business protocol level are the same as our resolvable mismatches listed in Figure mechanism to addre ss these mismatches. 
In [23], the authors present the purpose of a process mediator within WSMX, which is a message broker among the partners. Process mediator needs to decide which data belongs to which partner(s) based on choreography and ontology of the partner(s). This work extends process mediation to multi-lateral interactions, and focuses on message forwarding among the partners. However, this data distribution among the partners is actually, only a part of task that should be addressed by process mediation. Process mediation is a complex task and important for complex service interactions in which behavioral heterogeneity problems ma y exist in public processes. We argue that process mediation would aim at pair-wise interactions only. We propose a process mediation architecture based on TSC, and present potential solutions for resolvable message sequence mismatches. In addition, we categorize these resolvable mismatch scenarios into five classes. This analysis generalizes the resolvable message sequence mismatches, provides the basis for checking Web service compatibility from the behavioral aspect, and offers an opportunity to have a uniform solution to address these mismatches. work is based on the exchanged messages, which represent a part of service behavior. It is a common sense that two public processes, which are locally compatible, do not needs to consider comp atible [5] on the public process level, and to check whether the implement this proposal for evaluating it against the real data sets taken from the real-life use cases. Acknowledgments. The work presented in this paper was supported (in part) by the EU funded TripCom Specific Targeted Research Project under Grant No. FP6-027324, and (in part) by the Lion project supported by Science Foundation Ireland under Grant No. SFI/02/CE1/I131.

