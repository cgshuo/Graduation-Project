 Monitoring systems today often involve continuous queries over streaming data, in a distributed collaborative system. The distribution of query operators over a network of proces-sors, and their processing sequence, form a query configura-tion with inherent constraints on the throughput it can sup-port. In this paper we propose to optimize stream queries with respect to a version of throughput measure, the pro-filed input throughput . This measure is focused on matching the expected behavior of the input streams. To prune the search space we used hill-climbing techniques that proved to be efficient and effective.
 Categories and Subject Descriptors: H.2 DATABASE MANAGEMENT Miscellaneous General Terms: Algorithms, Performance Keywords: Data Management, Stream, Continuous Queries, Query Optimization
A continuous monitoring query can be deployed in various configurations, some better than others with respect to opti-mization criteria such as latency, work, or throughput. Most previous work focused on choosing the query configuration that minimizes total latency and/or work. Each operator of a continuous query requires a certain amount of execution time for every incoming data tuple, which leads to an upper bound on the rate at which tuples can be processed. If the input streams exhibit higher rates than the query operators can process, then special mechanisms need to be in place to handle them. When high input rates represent only short bursts, buffers can be used to temporarily store the over-flow of incoming data. If, instead, the high rates have to be supported for a long period of time, then data need to be purged out of the input to the operators. This approach cannot avoid the deterioration of the quality of query re-sults. There has been a large body of recent research that focused on which events to shed in order to return a high-quality result. However, some loss of quality is unavoidable when information is discarded. For some applications any event may contain critical information and the reduction in the quality of results should be minimized.

We focus on a problem complementary to that of load shedding: finding a query configuration that, given resource and quality constraints, can successfully process the high-est incoming stream rates. This translates into finding an order of query operators and a placement of the operators on physical nodes that maximize throughput. The measure of throughput quantifies the number of tuples that can be processed by the system in a unit of time. Since our goal is to maximize the input rate that can be processed without bottlenecks, we express throughput as a vector that quan-tifies the processing of each input stream. Moreover, input streams vary in behavior, knowledge that is incorporated into an input profile (or simply a profile ). The goal of maxi-mizing throughput is often times relevant only if it satisfies the requirements of the input profile. Out of the large space of possible query configurations, our goal is to find the query plans that maximize throughput and adhere to the input profile.

Examples of data stream management systems are Au-rora/Borealis [4, 1], STREAM [9], TelegraphCQ [3], and Gigascope [5]. Designed to operated on single or multiple nodes, they mostly focus on minimizing the end-to-end data processing latency. Viglas and Naughton [8] proposed a rate-based optimization technique for streams, that maximizes the output rates. The problem of query execution for fixed plans in widely-distributed environments is also studied by Ahmad and Cetintemel [2] (minimize the bandwidth use, or meet certain quality of service requirements) and Piet-zuch et al. [6](targeted to minimize end-to-end latency in distributed applications). Another recent study [7] describes algorithms for efficient, in-network execution of filter queries on streaming data.
A query may receive input from multiple data streams with different rate fluctuations. One stream may come from a source that rarely emits events, while another stream may be characterized by long bursts of data at very high rates. If the query optimizer is given even coarse information on the expected input behavior, it can generate a query plan that is appropriate under these assumptions. Note that without this additional knowledge, the query optimizer will have no way of distinguishing between many feasible solutions, and may decide that the best solution is one that accepts a high input rate on the slower stream and a low input rate on the fast stream. We profile the input as an assignment of val-ues to the input rates that becomes a target for supported throughput: &lt;r p 1 ,r p 2 ,  X  X  X  r p n &gt; . Asolution ment of values to the input stream rate variables of a given configuration C such that all the constraints are satisfied . The quality Q p ( C.S )ofasolution C.S should then quantify how much the solution achieves towards the goal of max-imizing the throughput with respect to the profile. Note that the goal can also be surpassed. The quality Q p ( C.S of a solution C.S with respect to an input profile vector defined as: Q p ( C.S )= min
Note that a configuration has an infinite number of solu-tions. Consider one solution C.S = &lt;r s 1 ,r s 2 ,  X  X  X  r s all possible C.S = &lt;r s 1 ,r s 2 ,  X  X  X  r s n &gt; such that also solutions for this configuration. The quality of a con-figuration is characterized by the best solution under that configuration.

Letasetofconstraints { f i } have the following proper-ties: 1)constraint f i is of the form f i ( r 1 ,  X  X  X  ,r f () is a monotonically increasing function, and 3) c i is a constant that measures the capacity of a resource or a qual-ity of service requirement. The constraints { f i } describe the restrictions imposed in the distributed system by the phys-ical resources (such as cpu and memory constraints of the physical nodes) and the service quality guarantees (such as application requirements on latency). Under these defini-tions, the throughput optimization problem becomes a non-linear programming problem, and can be formally defined as follows: Given a query plan Q (representing multiple contin-uous queries), a set of physical nodes { N i } organized in a network, and a set of constraints { f i } , find an assignment of the operators in Q to the nodes { N i } (called a configura-tion), so as to maximize the objective function Q p ( C ) ,for all the configurations C that satisfy the constraints { f
To find a solution, the query optimizer needs to traverse the search space of configurations, and compare each visited configuration with the configuration that was the best so far. Finding an optimal configuration is a hard problem, and hill-climbing techniques can reach very good results efficiently. Recall that each configuration can have an infinite number of solutions that satisfy the given constraints. To quickly identify the best solution for each configuration, we observe the following: Let a query configuration C be restricted by constraints that are of the form f ( r 1 ,  X  X  X  ,r n )  X  c a constant and f () is monotonically increasing. For a profile p = &lt;r p 1 ,r p 2 ,  X  X  X  r p n &gt; , a solution with greatest on the surface bounding the region of feasible solutions and on the line through origin and p . The proof is omitted due to lack of space.
 Figure 1: Example of best solution for a configura-tion C 1
To illustrate this point in two dimensions, consider the example in Figure 1. For configuration C 1 the intersection of the constraint boundary with the line through origin and &lt; 30 , 45 &gt; is at the solution C 1 .S . Any solution with same or better quality according to the Q p ( C.S ) measure increases either r 1 or r 2 , or both. This solution lies in the darker re-gion where C 1 .S is the lower left corner. One can see that, due to the shape of the feasible space imposed by the prop-erties of the constraints, no point in the feasible space can also be in the shaded region. Note that the above observa-tion allows us to compare two configurations by comparing the intersection points of the feasible space boundaries with the line from origin to the profile point p .

In our implementation of a distributed query optimizer we used hill-climbing techniques to prune the search space. We experimented with greedy algorithms, Tabu, Reactive Tabu, and Simulated Annealing. The various hill-climbing tech-niques performed similarly, obtaining the optimal or near-optimal solution in more than 90% of the time. Simulated Annealing is orders of magnitude faster than the other ap-proaches, and therefore it may be preferable especially for large query plans.
In this paper we explore continuous query optimization, which maximizes the system X  X  runtime capacity with respect to input rates that have an observed profile. An input pro-file represents the knowledge on input behavior, that is use-ful in targeting solutions appropriate for the specific run-time requirements of the system. The notion of a profile can be generalized further to include a set of target points, representing characteristics of input streams. Fitting the solution to the line segments described in this way by the profile corresponds to finding a solution that can support an evolving set of requirements. We plan to look into op-timizing throughput according to various types of profiles, incremental query re-configuration, and improving parame-ters through learning.
