 Abstract We present a set of language resources and tools X  X  morphological parser, a morphological disambiguator, and a text corpus X  X or exploiting Turkish morphology in natural language processing applications. The morphological parser is a state-of-the-art finite-state transducer-based implementation of Turkish mor-phology. The disambiguator is based on the averaged perceptron algorithm and has compiled from the web and contains about 500 million tokens. This is the largest Turkish web corpus published.
 Keywords Turkish language resources Morphological parser Morphological disambiguation Web corpus 1 Introduction Turkish is an agglutinative language with a highly productive inflectional and derivational morphology which is quite regular (Lewis 2001 ;Go  X  ksel and Kerslake 2005 ). In morphologically rich languages, grammatical features and functions, which are associated with the syntactic structure of a sentence in other types of language, are often represented within the morphological structure of a word in such as Distributed Morphology (Halle 1993 ) and A-Morphous Morphology (Anderson 1992 ) relate morphology and syntax rather than considering morphology as concentrated in a single component of the grammar. Language applications for morphologically rich languages often require to exploit the syntactic and semantic information stored in the word structure. Therefore, we need some language resources and tools to extract and utilize this information.
 In this paper, we describe the language resources that we built for processing the Turkish morphology. We make these language resources available for research purposes:  X  A finite-state morphological parser (Sect. 2 ): It is a weighted lexical transducer  X  An averaged perceptron-based morphological disambiguator (Sect. 3 ): The  X  A web corpus (Sect. 4 ): We aimed at collecting a representative sample of the 2 Finite-state morphological parser There are some previous computational studies on Turkish morphology. Oflazer ( 1994 ) gives a two-level morphological description implemented using the PC-KIMMO environment (Antworth 1990 ). However, its lexicon coverage is quite limited and it requires the PC-KIMMO system to run the parser which prevents the integration of the parser into other applications. Later, Oflazer has reimplemented this specification using Xerox finite-state tools, 1 twolc (a two-level rule compiler) (Karttunen and Beesley 1992 ) and lexc (a lexicon compiler). This implementation requires the Xerox software for execution and the parser is not publicly available. O  X  ( 1995 ) describes Turkish morphophonemics and morphotactics using Augmented Transition Network formalism. While these studies consider only word-internal processes, Bozs  X ahin ( 2002 ) proposes a morphemic grammar-lexicon for the integrated representation and processing of inflectional morphology, syntax, and semantics in a unified grammar architecture. Despite these studies, there is no publicly available state-of-the-art morphological parser for Turkish. Considering the success of finite-state machines in language and speech processing (Mohri 1997 ), it is essential for a Turkish morphological parser to be available as a finite-state transducer in order to incorporate the morphology of the language as a knowledge source into other finite-state models.

In Turkish, theoretically one can produce an infinite number of words by inserting some derivational suffixes like the causative suffix in a word multiple times. Even if we ignore such iterations which are rarely used in practice, we can generate a word like the following using each suffix only once:  X  X (behaving) as if you are among those whom we could not cause hastily to become immortal X  X 
We can break this word into morphemes as shown below: In order to build a morphological parser, we need three components: a lexicon listing the stem words annotated with some information such as the part-of-speech tags to determine which morphological rules apply to them, a morphotactics component (morphosyntax) that describes the word formation rules by specifying the ordering of morphemes, and a morphophonemics component that describes the phonological alternations occurring in the morphemes during word formation. All these components can be implemented using finite-state transducers (FSTs).
We started with the specification of the Turkish morphology in the PC-KIMMO system (Oflazer 1994 ). The phonological rules and the morphotactics have been expanded and modified to cover the phenomena and the exceptions not handled in the PC-KIMMO implementation. We used the morphosyntactic tag set of Oflazer et al. ( 2003 ). Since the root word lexicon of the PC-KIMMO system with about 23,000 root words is limited in terms of word coverage and contains many misspelled words, we compiled a new lexicon of 55,278 root words based on the Turkish Language Institution dictionary ( http://www.tdk.gov.tr/ ). We define  X  X  X oot word X  X  as described by Aronoff ( 1993 ). The average number of parses per word on a morphologically disambiguated corpus of about 830,000 words parsed by parser.

The two-level rules (Koskenniemi 1984 ) that describe the phonological alternations in Turkish are compiled into a finite-state transducer (Kaplan and Kay 1994 ). For this purpose, we used the Xerox two-level rule compiler (Karttunen et al. 1987 ; Karttunen and Beesley 1992 ) . We composed the lexicon/morphotactics transducer with the morphophonemics transducer which is the intersection of the phonological rule transducers to build the lexical transducer of the parser (Karttunen et al. 1992 ). We used AT&amp;T FSM tools (Mohri 1997 ) for finite-state operations. The resulting finite-state transducer can also be used with the OpenFST weighted finite-state transducer library (Allauzen et al. 2007 ).

We show below the morphological analysis of the word mentioned previously in this section as an example:  X  ol  X  um  X  Noun sHz  X  Adj  X  Without lA  X  s  X  Verb  X  Become DHr  X  Verb  X  Caus The morphological representation is similar to the one used in (Oflazer and Inkelas 2006 ). Each output of the parser begins with the root word and its part-of-speech tag in brackets. These are followed by a set of lexical morphemes associated with morphological features (nominal features such as case, person, and number agreement; verbal features such as tense, aspect, modality, and voice information). The inflectional morphemes start with a ? sign. The derivational morphemes start with a -sign and the first feature of a derivational morpheme is the part-of-speech of the derived word form. A morphological feature may be appended without any morpheme, indicating that the feature is also applicable to the current word form.
The word coverage rate of the morphological parser is about 96.7% on the text corpus collected from online newspapers (see Table 3 ). The parser can also recognize the punctuation marks and the numerical tokens. It is highly efficient and can analyze about 8,700 words per second on a 2.33 GHz Intel Xeon processor. The morphological parser was also converted into a stochastic parser using the language resources described in this paper, which makes it the first stochastic morphological parser for Turkish (Sak et al. 2009 ). 3 Morphological disambiguation The morphological parser may return more than one possible analysis for a word due to ambiguity. For example, the parser outputs four different analyses for the word kedileri as shown below. The English glosses are given in parentheses. kedi [Noun] ? lAr [A3pl] ? SH [P3sg] ? [Nom] (his/her cats) kedi [Noun] ? lAr [A3pl] ? [Pnon] ? YH [Acc] (the cats) kedi [Noun] ? lAr [A3pl] ? SH [P3pl] ? [Nom] (their cats) kedi [Noun] ? [A3sg] ? lArH [P3pl] ? [Nom] (their cat)
This parsing ambiguity needs to be resolved for further language processing using a morphological disambiguator (morphosyntactic tagger). There are several studies for morphosyntactic tagging in morphologically complex languages such as Czech (Hajic and Hladka  X  1998 ), which is an inflective language, and Basque (Ezeiza et al. 1998 ) and Hungarian (Megyesi 1999 ), which are agglutinative languages. For morphological disambiguation in Turkish, several constraint voting methods have been applied (Oflazer and Tu  X  r 1996 , 1997 ). A statistical model has also been used (Hakkani-Tu  X  r et al. 2002 ), where statistics over inflectional groups (chunks formed by splitting the morphological analysis of a word at derivation boundaries) are estimated by a trigram model. A recent work has employed a decision list induction algorithm called Greedy Prepend Algorithm (GPA) to learn morphological disambiguation rules for Turkish (Yu  X  ret and Tu  X  re 2006 ). The averaged perceptron algorithms previously applied to classification problems (Freund and Schapire 1999 ) have also been adapted very successfully to natural language processing (NLP) tasks such as syntactic parsing of English text (Collins and Duffy 2002 ) and part-of-speech tagging and noun phrase chunking (Collins 2002 ). This methodology was also proved to be quite successful for morphological disambiguation of Turkish text (Sak et al. 2007 ). 3.1 Methodology The problem of finding the most likely morphological analyses of the words in a morphological analyses on a training set and then choosing the most likely parse output using the estimated parameters. For parameter estimation, we use the averaged perceptron algorithm. This algorithm is very flexible in features that can be incorporated in the model and the parameter estimation just requires additive updates to a weight vector.

We presented an application of the averaged perceptron algorithm to morphological disambiguation of Turkish text in a previous study (Sak et al. 2007 ). In that study, a baseline trigram-based model of Hakkani-Tu  X  r et al. ( 2002 ) is used to enumerate n-best candidates of alternative morphological parses of a sentence. Then the averaged perceptron algorithm is applied to rerank the n-best candidate list using a set of features. In the present study, we do not use a baseline model to generate n-best candidates. Instead, we do a Viterbi decoding (Viterbi 1967 ) of the best path in the network of ambiguous morphological parses of the words in a sentence.

We split the morphological analysis of a word into morphemic units to be used as features by the perceptron algorithm. For this purpose we make use of the morpheme boundaries (both inflectional and derivational ones) in the analysis. This representation is different than the one used by Hakkani-Tu  X  r et al. ( 2002 ) and Sak et al. ( 2007 ), where only derivational boundaries are used to split the morphological analysis of a word into chunks called inflectional groups. A morphosyntactic tag t i , morpheme tag m i . The morpheme tag m i is the concatenation of the morphosyntactic tags of morphemes m i , j for j = 1, ... , n i , where n i is the number of morphemes in t i :
For example, the morphological analysis of the word w i  X  ula  X  smad i g i t  X  ula  X  s  X  Verb  X  mA  X  Neg DHk  X  Noun+PastPart  X  X  A3sg  X  SH  X  P3sg  X  X  Nom is represented as its root tag and morpheme tags as follows: The set of features that we incorporate in the model is a subset of the features used by Sak et al. ( 2007 ). The feature set takes into account the current morphosyntactic templates are given in Table 1 . We basically add unigram, bigram and trigram features over the root and the morpheme tags. The discriminative training algorithm of the perceptron learns the feature weights for each instance of these features. 3.2 Perceptron Algorithm A variant of the perceptron algorithm is repeated in Fig. 1 from Collins ( 2002 ). The algorithm estimates a parameter vector a using a set of training examples ( x i , y i ), which will be used for mapping from inputs x [ X to outputs y [ Y . In our setting, X is a set of sentences and Y is a set of possible morphological parse sequences. The algorithm makes multiple passes (denoted by T ) over the training examples. For each example, it finds the highest scoring candidate among all candidates using the current parameter values. If the highest scoring candidate is not the correct parse, it updates the parameter vector a by the difference of the feature vector representation of the correct candidate and the highest scoring candidate. This way of parameter update increases the parameter values for features in the correct candidate and downweights the parameter values for features in the competitor. For the application parameters X  X  since they are more robust to noisy or inseparable data (Collins 2002 ). The averaged parameters c are calculated by summing the parameter values for each feature after each training example and dividing this sum by the total number of examples. The perceptron algorithm is adapted to the disambiguation problem as follows:  X  The function GEN ( x i ) maps the input sentence x i to the candidate parse  X  The representation U  X  x ; y  X 2&lt; d is a d -dimensional feature vector. Each followed by the root tag go  X  r [Verb] in the tag sequence t [1: n ] . Then, the algorithm will update the 100th component of the parameter vector a by adding U scoring candidate.  X  The expression U  X  x ; y  X  a denotes the inner product
With this setting, the perceptron algorithm learns an averaged parameter vector c that is used to choose the most likely morphological parse sequence of a test sentence x using the following function: 3.3 Experiments and results In order to measure the performance of the morphological disambiguator, we used a semi-automatically disambiguated Turkish corpus of about 950,000 tokens (including markers such as begin and end of sentence markers) that has been tagged with Oflazer X  X  parser. In addition to the correct morphological analysis of a word, alternative ambiguous analyses are also available in the corpus given as output by the morphological analyzer. The output format of the morphological parser developed in this work is somewhat different from that used in the corpus due to the improvements on the phonological rules and the morphotactics. Therefore, we converted the corpus to the parser format used in this work in order to be able to train a disambiguation model over the outputs of our morphological parser. In this conversion, the morphological analysis of 95.5% of the tokens were mapped automatically to an analysis in the form used by the morphological parser. The 2.6% of the tokens (mostly misspelled words and proper nouns) could not be parsed and they were marked as unknown words. The remaining 1.9% of the tokens were mapped to an analysis which has the minimum edit distance with the original parse.
This data set was divided into training, development and test sets with respective sizes of about 850,000 (45,000), 47,000 (2,500) and 48,000 (2,500) tokens (sentences). The training set was used for parameter estimation and the development set was used for feature selection. The trained model was tested on this semi-automatically disambiguated test set. We also tested the same trained model on a manually disambiguated test set (converted into our parser format) of 958 tokens. The accuracies on these two test sets were obtained as 97.05% (the 95% confidence interval is [0.9689, 0.9720]) and 96.45% (the 95% confidence interval is [0.9526, 0.9763]), respectively.

We also compared the performance of the perceptron algorithm on the original manually disambiguated test corpus of 958 tokens with previous studies on this corpus. The results are given in Table 2 . The trigram-based model of Hakkani-Tu  X  r et al. ( 2002 ) is our implementation. The confidence interval for the 96.45% accuracy indicates that the performance improvement of the perceptron model over the other models is not statistically significant and we need a larger manually disambiguated corpus to verify the performance improvements. We also measured the accuracy of the perceptron algorithm on the ambiguous cases only. In the test set containing 958 tokens, 579 tokens are unambiguous (96 of them are markers). The disambiguation accuracy on the 379 ambiguous tokens is 91.0%, while the baseline accuracy (selecting a parse randomly) is 38.5%.

The morphological disambiguator is also a part-of-speech (POS) tagger when we consider the POS tag of a word as the POS tag of the last derived word form as given in the morphological parse of the word. The POS tagging performance of the disambiguator is about 98.6% for both test sets.

The perceptron algorithm trains a disambiguation model by making four passes over the training examples of about one million tokens in one hour on a 2.33 GHz Intel Xeon processor. The generated model contains about 580,000 features. This is the dimension of the feature vector. It can disambiguate 1,000 words per second on the same processor. 4 Web corpus Due to the productive morphology and parsing ambiguity in agglutinative languages, we need a large corpus of sentences for robust parameter estimation in statistical NLP models. There have been very few efforts to build a Turkish text corpus. METU Turkish Corpus is a hand-compiled annotated collection of two million words of written Turkish samples (Say et al. 2002 ). Another effort is the collection of web pages of Turkish newspapers containing about 2.5 million words for Turkish speech recognition research (Salor et al. 2002 ). These corpora are limited in size and coverage to be successfully used in many statistical natural language applications.

It has been reported that probabilistic models of language based on a very large corpus, even if the corpus is noisy, are better than those based on estimates from smaller, cleaner data sets (Kilgarriff and Grefenstette 2003 ). The web is being increasingly used by researchers to build web corpora (Liu and Curran 2006 ), since the other language resources are not large enough or not suitable in terms of language coverage and the web is instantly and freely available.

In this research, we built a web corpus for Turkish and cleaned it using the morphological parser and some heuristics. The Turkish web corpus ( BOUN Corpus ) is composed of four subcorpora. Three of these (Milliyet, Ntvmsnbc, Radikal) are from three major news portals in Turkish (collectively referred as NewsCor ) and the other one ( GenCor ) is a general sampling of Turkish web pages. The statistics about the numbers of words, tokens (words and lexical units such as punctuation marks), and types (distinct tokens) are shown in Table 3 . The percentages of the tokens and types that can be parsed by the morphological parser are also indicated. We observe that, due to the agglutinative nature of the language, the number of types (4.1M) is quite large. Also, the number of types parsed (1.57M) in the corpus being about 30 words are used commonly in Turkish. For the encoding of the web corpus, we used the XML Corpus Encoding Standard, XCES ( http://xces.org ) as used by Say et al. ( 2002 ). 4.1 Corpus statistics In this section, we present some corpus statistics in order to get an idea about the coverage of the corpus and also to observe the morphological characteristics of the Turkish language. Figure 2 shows statistics about the types relative to the corpus size (number of tokens) excluding the numerical tokens. As can be seen, the number of types is increasing continuously for both corpora and for the combined corpus. For instance, when the corpus size was increased from 490M to 491M, 5,539 new types (of which 1,009 can be parsed successfully) have been added to the corpus. This situation is mostly due to misspelled word forms and partly due to the productive morphological structure of Turkish and the rich web environment. The analysis of a small sample of these 4,530 types that cannot be parsed shows that about 70% of them are spelling errors, 20% are foreign words, and 10% are proper names.

We also analyzed the corpus coverage statistics with respect to the vocabulary size (number of types). The most frequent 50K types cover only 89% of the corpus, while 300K types are necessary in order to attain a coverage ratio of about 97%. The agglutinative nature of the language and the diversity of the web contents are the basic reasons of this result. A similar statistic related to the percentages of infrequent types shows that almost half of the types (about 2.0M) occur only once in the corpus. The number of types occurring less than 10 times is 3.4M. Thus, we see that the majority of the types in the corpus are very infrequent.

To understand the source of the large number of types in the corpus, we give statistics for the stems and lexical endings (tokens stripped of their stems in lexical form such as ? lAr ? Hn ) in Fig. 3 . As the corpus size increases, the number of unique stems approaches to the size of our lexicon (55,278 root words). The number of unique endings increases steadily as new data are added. This increase means that people freely derive new word forms by making use of suffix combinations not used before. Although we know that theoretically there is no limit on the number of derivations in Turkish, we might expect that in practice a (large) subset of all possible derived forms will cover the daily use of the language. However, this expectation does not hold even for a corpus of nearly 500M tokens; in the last 1M tokens of the corpus 5 new stems and 32 new lexical endings emerged and for the last 10M tokens these numbers were 61 and 268, respectively. The number of unique stems in the corpus is about 49,000, which is significantly less than our root lexicon size. Therefore, we can conclude that we need some more text from other domains to see all the root words. On the other hand, we expect that the statistics for lexical endings are not domain dependent. All the analyses have been done after randomly ordering the documents in the corpus.
 5 Conclusions In this paper, we presented some essential tools and resources for exploiting the Turkish morphology in natural language processing applications. Morphology is a very important knowledge source for morphologically complex languages like Turkish. Using these resources and tools, one can parse a text corpus and obtain the morphological analyses of the words as well as their probabilities, disambiguate the parse outputs, train statistical models using the web corpus, and build applications that fully exploit the information hidden in the morphological structure of words. These resources are available for non-commercial research purposes. 2 References
