 As the ubiquitous interplay of structured, semi-structured and unstructured data from different sources, neither DB-style structured query requiring knowledge of full schema and complex language, nor IR-style keyword search ignoring latent structures, can satisfy users. In this paper, we present a novel Semi-Structured Search Engine (3SE) that provides easy, flexible, precise and rapid access to heterogeneous data represented by a semi-structured graph model.

By using an intuitive 3SE Query Language (3SQL), users are able to pose queries on heterogeneous data in a varying degree of structural constraint according to their knowledge of schema. 3SE evaluates 3SQL queries as the top-k answers composed of  X  X ogical units X  and relationship paths between them, and thus can extract meaningful information even if the query conditions are vague, ambiguous, and inaccurate. Categories and Subject Descriptors: H.3.3 [Informa-tion Search and Retrieval]: Retrieval models General Terms: Language Keywords: semi-structured query, heterogeneous data
Currently, there are rapid-growing amount of data man-agement scenarios that need to deal with large collections of heterogeneous data. Such scenarios are widely involved within World Wide Web, personal information management, digital libraries, etc. How to query heterogeneous data bases has become a significant challenge in database community.
As an overview, Figure 1 displays the solution space of existing querying methods. We roughly divide the space into nine blocks in terms of structural requirements of query and data, respectively. For example, we can find the typi-cal querying methods for unstructured data (e.g., keyword search like Google), structured/semi-structured data (e.g., SQL, XQuery, SPARQL) and heterogeneous data (e.g., query-ing data warehouse) in the space. Moreover, keyword prox-imity search, which can extract structurally related infor-data. However, lack of explicit structural constraints is a serious limitation to keyword search when the schema is not totally agnostic to users.

Consequently, the proper query mechanism for heteroge-neous data bases should be adaptive to users X  knowledge of schema and let users write intuitive queries in a varying degree of structural constraint. We call such query mech-anism as semi-structured query . Current research on semi-structured query is focused on traditional databases (e.g., [17, 6, 2, 15, 9]) as well as unstructured data (e.g., [3]).
What we are interest in is the central block, namely, semi-structured querying on heterogeneous data, which is a com-bination that has not been well studied. Previous works in this field only provides very limited query functionalities, such as [7]. Although the research efforts on flexibly query-ing XML data can be trivially used to query heterogeneous data because of the similar data models, these methods are also not perfect. For example, previous works on extending XQuery (e.g., [15] brings new keyword search functional-ity to XQuery users without requiring perfect knowledge of document structures) still suffer from even more complex query writing. On the other hand, the methods that en-hance the keyword queries with structural constraints can-not offer powerful structured query functionality (e.g., [6] only allows users to specify in which labels of elements the given keywords should appear). In addition, there are other open problems like the form of answers, scoring and ranking, top-k -style query processing and so on.

In this paper, to overcome the above challenges and pro-vide both user-friendly and powerful query functionalities on heterogeneous data, we present the design of Semi-Structured Search Engine (3SE), which is a novel instance of emerging DB+IR querying systems. By using the 3SE Query Lan-guage (3SQL), users can easily and flexibly enhance ordinary keyword queries with structural constraints in terms of their knowledge of schemas. Various query conditions besides key-word are supported by 3SQL, such as attribute predicate, relationship expression and implicit link-aware search con-dition. Distinct from previous works, 3SE evaluates 3SQL queries as  X  X ogical units X , which are tightly connected enti-ties satisfying individual conditions, connected by relation-ship paths matching the corresponding expressions in a va-riety of flexible forms. In this way, 3SE could effectively find meaningful information even if vague, ambiguous and inaccurate conditions are specified by users with incomplete knowledge of schema. These connected logical units will be scored and ranked in terms of their structural compactness.
In the rest of this paper, Section 2 introduces the graph model, and then Section 3 presents the detailed design of 3SE. We conclude in Section 4.
In a nutshell, we model heterogeneous data uniformly as adirectedgraph G = {V , E} ,where V is a collection of ver-texes which can represent arbitrary data entities like docu-ments, web pages, relational tuples, XML elements or con-ceptual objects, and E is a collection of edges which can represent relationships like hyperlinks, foreign-primary key references, parent-child relationships or semantic relation-ships. To model both structured and unstructured parts of adataentity,avertex v  X  X  can have a set of attribute name/value pairs and unstructured content. Moreover, dif-ferent from the naive graph models used in [14], an edge or a combined symbol  X  X rite &gt;  X  to describe a relationship, or assemble multiple symbols in an expression as  X  X rite &gt; cite &gt;  X  to express more complex relationships. In summary, a 3SQL query is written as a sequence  X  E 1 R 1 ... R n  X  1 E n  X  X ith n 1, which straightforwardly com-bines structural constraints into keyword queries for more expressiveness and better precision. As an example,  X  X ohn Berkeley write &gt; cite &gt; [database (year &gt; =2007)] X  is a full query, which is as intuitive as natural languages.
Note that, 3SQL aims to provide  X  X roper X  expressiveness to all levels of users. We try to enable even casual users to exactly express most of their information needs without suf-fering from difficult query-composing. Therefore, 3SQL does not support variable bindings like  X $ x = { John Berkeley }  X , and thereby it is failed to express more complex branching queries like  X $ xR 1 $ y ;$ yR 2 $ z ;$ zR 3 $ x  X , w h i ch a r e n o t often used by ordinary users according to the investigation in [13]. Although such design cuts off some expressiveness, it can significantly increase the ease-of-use, and more impor-tantly, improve the efficiency of query processing.
Matched Vertex If a vertex (entity) can satisfy all basic conditions in a condition set, which means it contains all keywords and has all attribute predicates evaluated as true, it is called matched vertex . Eachconditionsetinanentity query has a set of matched vertexes in the data graph.
Logical Unit 3SE evaluates an entity query as  X  X ogical units X  but not individual vertexes. A logical unit is defined as a Minimum Connected Tree (MCT), which is a tree con-taining at least one matched vertex of each condition set. So that it can satisfy all condition sets as a whole. The concept of  X  X inimum X  means there is no proper sub-tree of MCTs satisfying all condition sets. For example, as illustrated in Figure 2(c), unit u 1 is an MCT answer to entity query  X  X a (type:university)] b X  that intends to find the person who is an editor of  X  X  X  journal ( v 2 ) and works at  X  X  university X  ( v 1 ). The de facto target entity v 3 is contained in u 1 , even though v 3 cannot satisfy any condition set. Hence, use MCTs to answer entity query can tolerate ambiguous conditions and effectively reduce the requirements on knowledge of schema by leveraging the underlying relationships.

Relationship Path In a relationship expression, each (combined) relationship symbol is evaluated as paths, on which relationships can satisfy the direction (and name) con-ditions. To match the whole expression, a path should be joined by paths of corresponding symbols and connect the units of entity queries on both sides of the expression. 3SE allows users to intuitively and flexibly specify the re-lationships between logical units. A relationship expression can be very unspecific, like in query X  X ohn &lt;&gt; (type=paper) X  where the description is as vague as having neither name nor direction, so that users with very limited knowledge of schema would not suffer from being incapable of writ-ing valid queries. On the other hand, a relationship ex-pression can be very concrete, like in query  X  X ohn write &gt; (type=paper) X  where the target relationships are strictly specified, so that users with perfect knowledge of schema could take full advantage of their knowledge. Moreover, users could use relationship expressions to denote paths hav-ing more than one relationships. For example, consider to find the papers published by Springer while the typical data are like  X  X pringer publish &gt; some proceedings &lt; inproceedings  X 
The scoring function of relationship path p is: ,where len ( p ) is the length of path p .

Based on (1) and (2), given an answer a = u 1 p 1 ... p n  X  1 u n with n 1, its score is computed as:
We use an example to explain our scoring functions. For the answer in Figure 2(c), score ( u 1 ) = 2 (no matter which vertex is the root), score ( u 2 )=1, score ( u 3 )=0, score ( p 1 )= 2, and score ( p 2 )=2. Thus, score ( a ) = 2+1+0+2+2 = 7.
Note that, the final scoring function is monotonic, in the sense that if score ( u 1 ) score ( u 1 ), score ( p 1 ) score ( p 1 ) and score ( u 2 ) score ( u 2 ), then score ( a ) score ( a ), where a = u 1 p 1 u 2 and a = u 1 p 1 u 2 . So, 3SE can deal with such monotonic queries by Threshold Algorithm [8].
In brief, a 3SQL query can be logically represented as a tree of operators for processing. For instance, the exam-ple query  X  X a (type:university)] b &lt; cite &gt;&gt; (year &gt; =2007) f &lt;&lt;&gt;&gt; g X  is parsed to the query tree illustrated in Fig-ure 3. The query tree will be executed bottom-up in fol-lowing steps: 1) For each basic condition c , generate  X  c , which represents the set of objects satisfying c .2)Foreach condition set C =[ c 1 ... c m ], compute the intersection  X 
C = m j =1  X  c j , to produce the objects satisfying all the conditions in the condition set by using an intersect opera-tion denoted by  X   X   X . 3) For each entity query E = C 1 ... C , perform proximity search operation denoted by  X   X   X , t h e input of which is  X  C 1 ...  X  C l , to produce U , a sorted list of MCTs, as logical unit answers to E ; 4) For each relation-ship expression R , generate the sorted list P of paths that are matched by R and connect logical units returned by the two entity queries linked by R , by using a connect operation denoted by  X   X . 5) Lastly, based on the sorted list U 1 P 1
