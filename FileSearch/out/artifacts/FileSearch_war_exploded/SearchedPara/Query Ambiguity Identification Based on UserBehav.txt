 Traditional search engines usually focus on satisfying elaborative information needs. However, research [1] shows th at queries often come out ambiguous or underspecified, especially with the increase of mobile device usage in recent years.
When a search engine receives an ambig uous/broad query from a user and it knows little about this user, the best it can do is to present a diversified result list that covers several interpretations/subtopics of the query (see Fig. 1 for an example). On the contrary, if the search engine knows much about the user, it can generate a personalized search result list according to the user X  X  profile [2]. Compared with traditional search tasks, diversified search and personalized search tasks require more computational r esources. Meanwhile, diversification may lack effectiveness, and may even hu rt the performance of clear queries. Therefore, query ambiguity identificatio n is essential for assessing whether search engine should introduce a diversified ranking or personalized search process. However, identifying a query X  X  ambiguity manually is laborious and complicated. When judging a query, a human annotator usually makes a decision based on his/her personal experience. In such case, the annotator might not be able to make the correct judgment until he/she i nvests enough time in researching on a specific query. It is thus of vital importa nce for Web search engines to identify query ambiguity automatically.

To identify ambiguous queries automatically, there have been a number of works such as [3,4]. They classified queries into 3 categories: Ambiguous , Broad and Clear . Based on this taxonomy, they proposed a supervised learning model to classify queries to Type A (Ambiguous) and Type A (Broad and Clear). The top retrieved documents are crawled as a description of the query. Each document is classified into predefined categories and modeled as a possibility distribution on different topics. Further, they estimate the distances between documents and train a binary classifier with Support Vector Machine.

We can see that, to a great extent, most ex isting query ambiguity identification frameworks depend on a process of supervised document topic classification. It is an ambitious move to construct a high-quality training corpus for document classification. More importantly, the training corpus should be updated with the rapid changes of Web content, which is both time/labor consuming and almost impossible for practical Web search applications.

In this work, we try to address the problem of query ambiguity identification without topic-based classification. We propose a query ambiguity identification framework which adopts a supervised learning approach to automatically iden-tify query ambiguity based on the featur es extracted from a number of evidences, i.e., query logs, SERPs and query session s. Inspired by recent word representa-tion approach  X  X ord2vec X  [5], we adopt the algorithm on large scale of search sessions to present queries as vectors and then extract features for ambiguity identification.

Our main contribution includes: (1) we proposed a query ambiguity identifi-cation framework without a content classification; (2) we proposed a novel query ambiguity description method based on query representation, to the best of our knowledge, this is the first approach that adopts  X  X ord2vec X  methods in the con-text of Web search user behavior; (3) we construct a dataset for query ambiguity identification with information collected from a practical search engines. 2.1 Query Ambiguity Taxonomy Most of the previous query intent identification approaches were based on a famous taxonomy of 3 categories: informational, navigational and transactional; this approach was proposed by Border et al. and Rose et al. [7,8]. To judge if search results benefits from diversification, query ambiguity categories is more instructive for search engines.

Song et al. reviewed previous works [9,10] and constructed the taxonomy of queries from being ambiguous to specific in three types: Ambiguous :aquery that has more than one meaning; Broad : a query that covers a variety of subtopics, and a user might look for one of the subtopics by issuing another query; Clear : a query that has a specific meaning and covers a narrow topic [3]. A user study on 60 queries which five human subjects involved in indicates that human annotators X  judgment reach an agreement as high as 90% when classi-fying queries into Type A and Type A (Type B and Type C ), while it is more difficult for the annotators to discriminate whether a query falls under Type B or Type C .

Another taxonomy about query ambiguity differentiate queries by how  X  X ar-row X  or  X  X eneral X  the intent of the query reflects [11]. Narrow queries usually means users submit queries for specific answers, such as  X  X ow to configure java X  , while general queries means that users attempt to visit some relevant web re-sources like the query  X  X ew York X  . 2.2 Query Classification Web queries can be classified according t o different taxonomies, such as search task type (Navigational, Informational and Transactional), query topics (KDD-Cup 2005) [12] and query ambiguity (Ambiguity vs Broad vs Clear, or Narrow vs General).

The search result lists returned by se arch engines are often regarded as a pseudo-relevance feedback [13]. The KDD-CUP participants started the trend of using the search engine directory servi ces and the categories of the open direc-tory project (ODP) to classify queries to predefined categories [14]. Document content, anchor links, hyperlinks and URL s have been considerably used in clas-sifications. The importance of inlinks, authorities, hubs and anchors in web query classification were compare d by Westerveld et.al [15].

Several previous works included user behavior as a functional feature in query classification [16,17]. Liu et al. proposed a method to differentiate navigational queries from informational/transactional queries with features extracted from user click histories [18]. Wang et al. [19] proposed an ambiguous query identifi-cation method with user entropy.

Song et al. have proposed a SVM classifier to solve the query ambiguity clas-sification problem [3]. In their approach, each query is represented by possibility distributions on content categories of its top retrieved documents. Features are extracted from the distances between the possibility vectors. In a following work, they included user clicks which may affect the weights of document [4], and im-proves the classification performance.

However, as stated earlier, document cl assification is a great challenge on web environment because the construction and update of training corpus is complex and time-consuming. It must be pointed out that there is a significant difference between Song et al.  X  X  approach and ours in the way of query session information utilization. They scrawled the top 20 snippets of follow up queries for content classification while we attempt to analyze the distributions of vectors whose queries are in session context.

Hafernik et al. proposed a less expensive method to classify queries into nar-row or general using only part of speech ( POS) information and query length as features [11]. It could be argued they did not utilize any user behavior informa-tion for classification. 2.3 Distributional Representation Distributional representation has been successfully used for a wide variety of tasks in natural language processing and information retrieval, such as synonym detection, concept categorization and sentiment analysis. Mikolov et al. proposed a skip-gram based method significantly improved the training speed and vector quality by subsampling of frequent words [5,6]. The linearity of skip-gram model make it very suitable on process large amount of documents. To assess diversification or personalization opportunities, we are focusing on differentiating queries that reflect clea r user intents between the ones that needs diversification. We adopt the taxonomy and ambiguity definitions proposed by Song et al. , however, we attempt to classify query into Type C (Clear) and Type C (Ambiguous and Broad). This is because ambiguous queries and broad queries need diversified search or person alized search while clear queries need not, which means we have to take broad queries into account while deciding whether diversification or personalizatio n is needed. Thus, from this perspective, classification between Type C and Type C is more instructive for search engines. 3.1 Problem Formulation and Framework Overview The problem of query ambiguity identification can be formulated as a classifica-tion process: f is the identification function which indicates whether the query is clear or not and Q = { q 1 ,q 2 ,q 3 ,... } , which denotes the query space,
The framework is shown in Fig. 2. It is constructed on three levels: data, feature and application.
On the data level, given a query q i , we first enrich the information on q i with various evidence resources. By scrawlin g search result pages of the query, we can get the most relevant documents about the query. From user click-through data, we can learn the interaction pattern of sp ecific users. By collecting large scale of user sessions, we can adopt query representation algorithm on the dataset to present every query as a vector for further analysis.

On the feature level, we extract features from both the query q i itself (for example, the query length, if the query contains stopwords etc.) and the infor-mation enriched before. In this work, we investigate the effectiveness of Ba-sic Features (BF) , User Click Behaviors (UCB) , Search Result Hints (SRH) and Session Features (SF) .

On the application level, we construct a training set by sampling some queries from search logs and labeling them by ambiguity. Each query and its label can be presented as ( q i ,l i )where q i is a query and the label l i  X  X  X  1 , +1 } .We apply Support Vector Machine (SVM) to learning a classifier that minimizes the generalization error, or at least an upper bound on it. We select the nonlinear SVM with RBF (Radial Basis Function) kernel as our setting because it performs well on our dataset. 3.2 Query Enrichment and Feature Extraction In this section, we describe how to use user clicks, sessions and SERPs to enrich a query and extract features that are designed to distinguish query ambiguity. Basic Features. There are three basic features that may be useful in identi-fying query ambiguity: (1) QueryLength : the length of the query; (2) IfCon-tainStopword : if the query contains a stopword; (3) IfContainQuestion :if the query contains a question or interrogative. All of the three features can be extracted without any other web resource. It is notable that QueryLength is as-sumed to be very helpful because usually the longer the query is, the more intent information it may carry. If a query contains a stopword or appears to be a ques-tion, it usually describes the user X  X  intent specifically. Thus , IfContainStopword and IfContainQuestion are supposed to be functional.
 User Click Features. Previous works shows that user click features are very helpful in query intent classification and they might be functional to our query ambiguity identification task, because query intent in some degree suggests the ambiguity of query. For example, a navigational query usually reflects clear intent to visit the homepage of a website.

Liu et al. proposed two assumptions in [18]: Less Effort Assumption (user tends to click a small number of URLs when performing a navigational type search) and Cover Page Assumption (user tends to click only the first few URLs when performing a navigational type search).

Based on these two assumptions, they proposed two features nClickSatis-fied ( nCS )and nResultSatisfied ( nRS )for query intent classification as follows :
Click distribution proposed by Lee [20] is believed to be functional. We cal-culate the percentage of clicks on the top-n clicked results ( nTCP ). Besides these features, we are introducing two features which indicates the types of user clicked result, RecommClickedPercentage ( RCP )and CommonRe-sultClickedPercentage ( CRCP ) defined as follows:
The type distribution of user-clicked results might suggest some characteristics of the query specificity. For example, if many users submit a query and then click its query recommendation on the SERP, this process of actions may suggests that it is very possible that the query is ambiguous and user needs to narrow down to a subtopic with the help of recommendations.
 Search Result Hints. Modern search engines usually incorporate search re-sults from multiple vertical search eng ines into SERP (See an example in the Fig. 3). These vertical search engines usually focus on some categories of web resource such as videos, images, maps and drama s etc. When the search engine receives a query, it might activate some vertical sea rch engines, and vertical search results might be incorporated into the SERP according the result of ranking algorithm. This way, we can try to figure out what the queries are talking about by dig-ging into the specific types of results presented on the SERP. Further more, it may help us identify query ambiguity. By reviewing the content types of vertical results on SERPs, we extract 13 features by counting if a certain type of vertical result appears on the SERP, for instance, video, image, music, drama, news and etc. Each of them may describe a particul ar aspect of the queries, for example, if the there are direction results on the SERP, that may suggest that the query contains a name of a location. 3.3 Session Features Query2vec. Query session context may contain some information about the query ambiguity. By reviewing the session corpus, we intuitively find that for a clear query, the queries in session context usually focus on a specific topic while ambiguous queries are often surrounded by queries which covers many subtopics. For example, take the queries in Table 1 for example, the query  X  X ind X  is ambiguous, its preceding q ueries and following queries cover several domains or topics: Operating System (windows, wind7 download), Music (bboxwind, nobody knows, Dad I X  X  back), Weather (windy, wind speed) and Wind Information Co., Ltd (wind information, wind dataset, wind stock expert), which is a famous integrated service provider of financial data, information and software. Another query  X  X igh-resolution map of China X  is clear and its context queries are mainly focused on the map of China, wit h differences in the details.

Inspired by recent distri butional word representat ion approach [5], we attempt to present every query as a vector and ext ract features from both the original query and its  X  X eighbors X  vectors. We call it  X  X uery2vec X  to shadow, as an application of  X  X ord2vec X  .

We further assume that context queries of a specific query, which carry vague intent, may scatter in the quer y vector space. If we treat a user search session as a document , queries in the sessions are just like words in the documents. We can learn a vector presentation for every query by training on large scale of user sessions. Formally, we can describe this the training process as the following
First, we collect a large scale of user sessions as a document D = { s 1 ,s 2 ,s 3 ... } , where s i denotes the user sessions, each session contains a sequence of individual queries. Similar to [5], skip-gram model is adopted on this problem, the training objective is to learn query vector repres entations that are good at predicting the nearby queries. We chose a computationally efficient approximation of the full softmax, the hierarchical softmax, which will improve both the quality of the vectors and the training speed. One of applications with the vectors is to calculate similarities between any two items. For words in documents, the simi-larities means the possibility that the two words have similar meanings or share common properties, or propose the same connotation. For queries in sessions, the similarities between queries usually indicates the similarity of user intents, which the two queries reflect.
 Features Extraction. As stated before, each query can be presented as a vector with query2vec algorithm. For query q i , we can pick out its top-k frequently occurred preceding and following queries separately as P ( each query can be presented by its vector, We can get two vector sets P V and F V by replacing queries by vectors, where the queries is sorted by times of co-occurance in descending order.
We calculate Diameter , Mean and Standard Deviation (SD) on similarities be-tween queries from both P V ( Preceding and Following queries. Click entropy is also chosen to describe the dis-tribution of the two sets. The vector similarity is measured by cosine similarity. We utilize the open source toolkit word2vec 1 to train the query representations. The length of top co-occurre d preceding and following queries is a parameter can be tuned. 4.1 Experiment Setup With the help of a famous Chinese comme rcial search engine, we collect query logs from April 1, 2012 to April 30, 2012. We extract the information of the query, clicked URL, timestamp and anonymized user-id. Private information is removed as much as possible to avoid the leak of privacy information. The click-through log contains 2,625,029 unique queries, 4,699,150 unique URLs, 72,106,874 query-URL pairs, and 717,916,107 individual clicks.

Search sessions are divided according to the time interval between two queries issued by a user. We separate two cons ecutive queries into two sessions if the interval exceeds 30 minutes. After removi ng all the single-query sessions, there are 160,526,561 sessions left on which the  X  X uery2vec X  algorithm is conducted. To construct a training set, we randomly sample 1,000 queries from query logs. After removing the pornographic ones, there are 810 queries left. With the help of 2 professional assessors, we label each query as clear or not-clear according to the following labeling criteria: Clear: the query reflects a clear user intent.

Not Clear: the query may have different interpretations (Ambiguous) or covers several subtopics (Broad) of an entity.

After the annotators double-checked the annotations, the query-set contains 485 Clear queries and 325 Not clear queries in total. The  X  value of annotation between three assessors is 0.756, which denotes the accessors reach agreements on most of the instances. 4.2 Classification Performance By adopting the proposed query enrichment and feature extraction methods, several groups of features are extracted to describe the corresponding queries including: Basic Features (BF), User Click Features (UCF), Session Features (SF) and Search Result Hints (SRH). We train a SVM classifier to combine these features. Intuitively, we choose Precision, Recall and F1-Score for evalu-ation purposes just as other query ambiguity identification works[3,4]. All the evaluation results are obtained with 5-folded cross validation. The length of top co-occurred preceding and following qu eries, parameters of SVM(cost and  X  )are tuned to gain its best performance for comparison.

FromTable2,wecanseethatthe Basic Features plays an important role in query ambiguity identification. Feature combinations 1 to 4 show the per-formance of classifiers with only one group of features. Since Basic Features get the best performance, we focus on t he improvement brought by User Click Features, Session Features and Search R esult Hints with the existence of Basic Features. With the number of involved feature groups increases, the classification performance also improves. Feature combinations No. 7 and No. 11 illustrates that Session Features help improve the performance (compared with Feature combinations No.1 and No. 9 respectivel y), which show the effectiveness of the proposed  X  X uery2vec X  method. BF+UCF+SF+SRH outperforms other fea-ture combinations and archives Precision 0.821, Recall 0.820 and F-Score 0.819. Comparing with other combinations, we find that Basic Features is the most helpful for the query ambiguity problem and Search Result Hints, User Click Features and Session Features, also contribute to the classification performance.
The taxonomy of Narrow/General queries proposed by Hafernik et al. is quite similar with our Clear/Not-Clear from the ambiguity identification X  X  perspective. Therefore, we also implemented their cl assification method as a baseline to com-pare with. As shown in Table 2, several of our feature combinations (including Combinations No. 5, 6, 8, 9, 10 and 11) outperforms this baseline method. The classifier sometimes makes mistakes when predicting ambiguous queries. For example, the query  X 5566 X  , it is the name of a famous boy band which was very active ten years ago, it is also the name of a well-known Chinese navigational website . However, most users select the r esults for navigation website, making the user behavior features (UCF, SF) bring negative influence to the classifier.
We divide the the queries into two group: low&amp;medium frequency group(0-1000 clicks) and high frequency group(1000+ clicks) and compare algorithm performance with all features on different queries groups.

Results from Table 3 show that our algorithm is of most help for low&amp;medium frequency queries. It would be promising because the vast majority of queries processed by search engines is made up by low and medium frequency queries. 4.3 Comparison of Feature Contributions Experiment is also conducted to evaluate the contributions of individual fea-tures. First, we train a model with BF+UCF+SF+SRH features, and the parameters are tuned to gain its optimal performance.

After that, we remove each feature from the above model with all features and calculate the performance loss caused by the feature removal. We use accuracy (the proportion of both true positive and true negative examples) to evaluate the differences with the original model. We can see that a larger performance loss represents a larger contribution of the corresponding feature to the classification framework.

According to the results shown in Fig. 4, Query Length contributes the most to this task. This effect can be explained by the fact that most ambiguous queries are relatively short, which accords with the conclusions given by [4], [11]. Nowadays, a typical short query submitted to a search engine usually cannot offer enough information for the ranking algorithm to give a high quality result list. Therefore, the best a search engine candoistoprovideadiversifiedorper-sonalized search results. In this work, to identify query ambiguity, we propose a 3-level framework which takes user behavi or features collected from click-through logs into consideration. Especially, besid es the features collected from queries, we focus on how to tell the differences between clear and ambiguous queries via fea-tures extracted from multi-query sessions. Inspired by recent progresses in word representation, we propose a query representation approach named  X  X uery2vec X  which constructs representations from the distributions of contexts in query logs. Experiments based on large scale commercial search engine logs show effec-tiveness of the proposed framework as well as the corresponding representation approach. In the future, we plan to adopt the ambiguity identification algorithm in practical search environment to guide the diversified or personalized ranking process.
 Acknowledgment. This work was supported by Natural Science Foundation (61073071) and a Research Fund FY14-RES-SPONSOR-111 from Microsoft Re-search Asia.

