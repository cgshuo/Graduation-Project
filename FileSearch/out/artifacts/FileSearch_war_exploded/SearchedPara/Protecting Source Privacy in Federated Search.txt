 Many information sources contain information that can only be accessed through search-specific search engines. Feder-ated search provides search solutions of this type of hidden information that cannot be searched by conventional search engines. In many scenarios of federated search, such as the search among health care providers or among intelligence agencies, an individual information source does not want to disclose the source of the search results to users or other sources. Therefore, this paper proposes a two-step feder-ated search protocol that protects the privacy of informa-tion sources. As far as we know, this is the first attempt to address the research problem of protecting source privacy in federated text search.
 Categories and Subject Descriptors: H.3.3 [Informa-tion Search and Retrieval]: Retrieval models General Terms: Security Keywords: Federated search, Source privacy
Information plays crucial roles in today X  X  fast pace-driven environment. How to find relevant information has been in-vestigated in the field of information retrieval. Information can be copied (or crawled) and accessed by conventional search engines like Google or Yahoo!. When information is hidden from conventional engines, techniques applied to conventional search engine cannot be utilized directly. Fed-erated search [1] has emerged as an answer to this problem.
Imagine the following two scenarios: 1) For better under-standing of the spread of a specific disease, researchers may want to know if it has been reported by some health moni-toring agencies. Due to possible liability, the agencies may not be willing to disclose their identities to the researchers. 2) Surgical accidents often occur across hospitals and health care centers. Reports are kept for the occurrences of such events. Some researchers may be interested in analyzing common mistakes among hospitals in a specific region so that more effective means to prevent these mistakes could be developed. However, some hospitals may not be willing to share their reports because of possible damage on their reputations and obligations to the public. In order to benefit from these information, source privacy needs to be protected in the federated search environment, while traditional fed-erated search techniques are not applicable here. We next investigate how to achieve this objective.
The following notations are adopted extensively through-out the paper: The protocol consists of two sub-protocols: ranked list gen-eration (RLG) and content retrieval (CR). The RLG pro-tocol simulates the behavior of conventional search engines to generate a global ranked lists. Once a user receives the ranked list, the CR protocol can be used to retrieve the de-sired content one at a time. Before detailing the RLG pro-tocol, we first describe two functions used as building blocks for RLG: Gen List and Merge . The Gen List function gen-erates an encrypted ranked list L i based on Q u . Suppose pu is the public key of a user u , k i is the private key of source S , t ij is the snippet of document d ij at S i and l ij is the corresponding hyper link. Let L ij denote the j th element in L , then L ij is formatted as E pu ( k ij ) || E k ij ( t ij where  X  indicates some similarity score. Given L i and L j the Merge function returns a new ranked list containing the top K elements between L i and L j according to  X  .
Algorithm 1 highlights the key steps of the RLG proto-col. At step 1, a user broadcasts his or her query to all the sources in a specific federated search environment. At steps 2-4, each source independently generates an encrypted ranked list. (For now, we assume all information sources use the same retrieval algorithm). At steps 5-8, the ranked lists are merged sequentially from S 1 to S m , and finally, S m the global ranked list to the user. Since the snippets are encrypted by private keys, the snippets generated at a spe-cific source are not disclosed to any other sources during the merging process. Once the user receives the global ranked list L m , using his or her public key, the user can get all the keys used to encrypt the snippets and their corresponding encrypted links. Based on the contents of the snippets and Algorithm 1 The RLG Protocol 1: u sends Q u to S 1 , . . . , S m 2: for all S i  X  S do 3: L i  X  Gen List ( S i , Q u , K ) 4: end for 5: for i  X  2 to m do 7: L i  X  Merge ( L i  X  1 , L i , K ) 8: end for 9: S m sends L m to u Algorithm 2 The CR Protocol 1: u sends E k ( l ) to S 1 2: if Retri ( S 1 , E k ( l )) 6 = NULL then 3: S 1 sets d  X  E pu ( k  X  1 ) || E k  X  4: else 5: S 1 randomly generates d 6: end if 7: for i  X  2 to m do 8: S i  X  1 sends d, E k ( l ) to S i 9: if Retri ( S i , E k ( l )) 6 = NULL then 10: S i sets d  X  E pu ( k  X  i ) || E k  X  11: end if 12: end for 13: S m sends d to u scores, the user can decide which document to be retrieved via the CR protocol. Note that public key encryption is used here to transport private keys (this is one of the most common uses of a public key encryption system in practice).
Algorithm 2 highlights the key steps of CR. Suppose E k ( l ) is the encrypted link from which the user wants to retrieve the desired document. First, the user sends E k ( l ) to S step 3, the Retri function returns NULL if the link can-not be decrypted. If S 1 can properly decrypt E k ( l ) (i.e., Retri ( , ) 6 = NULL ), it can use l to obtain the desired docu-ment, denoted as c 1 . S 1 then encrypts c 1 with a key k  X  is encrypted using the user X  X  public key. At the end of this step, S 1 passes the encrypted document to the next source. If S 1 cannot decrypt E k ( l ), S 1 randomly generates a docu-ment (pseudo-document) and passes it to the next source. At steps 7-12, sources S 2 , . . . , S m perform similar operations as S 1 does at steps 2-6, except that whenever Retri returns NULL , the source just passes the received document to the next source. At the end, S m sends the encrypted document to the user. The user then decrypts to get the private key that allows the user to obtain the actual document. Note that only one source has the intended document, and CR returns one document only. Suppose both S 1 and S 2 do not have the document. If S 1 does not pass a pseudo-document to S 2 , then S 2 can infer that S 1 does not possess the docu-ment desired by the user. Therefore, the pseudo-document is utilized to prevent such inference attack.

When the number of sources is large, the CR protocol becomes inefficient because it needs to visit every available source. Next, we briefly discuss how to solve this issue. The basic idea is that when each source generates the lo-cal ranked list in the RLG protocol, it randomly selects a subset t sources in S to generate a retrieval path. Let pu i denote the public key of S i and pu denote the user X  X  public key. Suppose t = 3 and { S 1 , S 2 , S 5 } is the selected subset by S 2 , then the retrieval path can be constructed is appended after the encrypted document link. When the document is chosen by the user, he or she can decrypt and find the first source on the retrieval path and then send the encrypted link to the source. In the previous example, the user sends E k ( l ) and E pu 1 ( S 2 || E pu 2 ( S 5 || E S . After performing the computation specified by the CR protocol, S 1 can decrypt and find the next source on the path. Then S 1 sends local computation results, E k ( l ) and E the path, S 5 directly sends the user the retrieved document.
At each source, the computation complexity of RLG is similar to any commonly used IR algorithm to retrieve the top K documents in the local database. The communication complexity of RLG is bounded by O( c m ), where c is the constant communication between any two adjacent sources assuming the public key and snippet sizes are fixed across the system. The computation complexity of CR at each source is bounded by the time to encrypt a document, and the communication complexity of CR is bounded by O( d m ), where d is the size of the document.
Anonymization protocols proposed in [3, 5] are not suit-able to achieve our objective. First of all, in our problem domain, the user identity needs not to be protected. As a result, we do not need to anonymize the communication from the user to the sources. Secondly, the source privacy needs to be preserved when they collaboratively produce the global ranked list. Since anonymizing the communica-tion among the sources alone does not prevent a source from observing the contents of other sources X  local ranked lists , source privacy is violated. Nevertheless, if preventing th e disclosure of sources X  IP addresses is a part of our objec-tive, the aforementioned anonymization protocols could be utilized together with our proposed protocols.
In this paper, we have proposed a federated search pro-tocol to protect source privacy. One issue we have yet to discuss is the need for score global normalization. One may argue that global normalization can lead to consistent simi -larity scores. However, global normalization may distort t he distribution of local source X  X  data. We will address this is sue in the future. In addition, we will add a resource selection phase to increase source privacy by hiding similarity score s and to make the retrieval protocol more efficient.
