 1. Introduction
Users interact with database systems by means of application programs. A transaction is an abstraction that represents a chronize the execution of concurrent transactions to guarantee database consistency. The component in the database system ations belonging to different transactions by means of a concurrency control protocol.

Concurrency control protocols may present aggressive or conservative behavior [28] . An aggressive concurrency control synchronize them correctly.
 synchronizing operations. Otherwise, the scheduler must abort some transactions. rion to ensure database consistency. The Two Phase Locking Protocol (2PL) is the most widely used conservative protocol based on serializability. Among the protocols with aggressive behavior that use a pessimistic approach, the Timestamp
Ordering (TO), and the Serialization Graph Testing (SGT), are noteworthy. A scheduler implementing an aggressive concur-trol protocol is called a conservative scheduler.

A Mobile Adhoc NETwork(MANET) [16] isa wirelessdynamicnetwork, inwhich nodes can joinorleave the network dynam-ically.SomedatabaseapplicationsthatuseMANETtechnologyare:industrial andcommercialapplicationsinvolvingcooperative tempresentedin [12] . MANETsallowuserscarryingportabledevicestoaccessdatabaseservices regardless oftheir physicalloca-tion or movement patterns. Thus, a dynamic collection of autonomous mobile databases, called mobile database community may join an MDBC or a participant may transiently disconnect from the MDBC (due to communication disruptions or to save power), an MDBC is characterized as a dynamically configurable environment. Observe that the concept of MDBC models a dynamically configurable multidatabase [6] whose members (local databases) can move across different locations.
As already mentioned, mobile units may join and leave an MDBC at anytime. In such a dynamic environment, the use of a contextit isbeingexecuted.AsshowninSection 4 ,thearrivalofanewmobileunitinanMDBCdrasticallymodifiesthescenario
This paper presents the Intelligent Transaction Scheduler (ITS), characterized by having a hybrid behavior (conservative reasonable throughput, while generating correct global schedules in dynamically configurable environments. Furthermore, controlling concurrency in dynamically configurable environments, such as an MDBC. Therefore, we claim that an adaptive scheduler is quite appropriate for controlling concurrency in dynamically configurable environments, whose configuration (topology) may change dynamically.

It is worthwhile to note that although the ITS has been developed for use in dynamically configurable environments, it can also be used to synchronize operations of concurrent transactions in any other distributed environment with static topology as well.
 The remainder of this paper is organized as follows: Section 2 presents the architecture of the proposed scheduler (ITS); schedules); Section 4 describes aspects of ITS X  implementation, its use in MDBCs and an analysis of the obtained results; 2. ITS  X  intelligent transaction scheduler the computing environment during a given time period; and the Scheduler , the component that executes the concurrency control protocols selected by the Analyzer. 2.1. Analyzer
The Analyzer is an Expert System  X  ES based on fuzzy logic [19] . The Analyzer module presented in Fig. 1 illustrates the Context and sends the information about the decision made internally back to the Scheduler. described as follows. 2.1.1. Specification of the problem and identification of input and output fuzzy variables
The problem is to choose the most appropriate scheduler behavior, either aggressive or conservative, according to a num-ber of computing environment characteristics. The most appropriate behavior should reduce the delays caused by the syn-
During the knowledge acquisition phase, the following variables were investigated: read operation rate, write operation behavior and database size. These variables were considered to influence the choice of the most appropriate scheduler for the adaptive scheduler. The input variables used by ITS are described as follows.
 period of time.
 the execution and may cause an abort of the transactions.
 scheduler.
 behavior. 2.1.2. Definition of the fuzzy sets for each fuzzy variable the fuzzy values L (low), M (medium) and H (high), and their universe of discourse ranges from 0 to 100. The points x specialist).

The trapezoidal shape was chosen for these fuzzy sets because this shape has good response time (linear function) and its configuration is easy. With this shape, the specialist defines the values he is certain of: interval [0, x presents a low value, the interval [ x 2 , x 3 ] where it presents a medium value and the high value interval [ x in which the specialist is uncertain about behavior variations are represented by [ x
C (conservative). 2.1.3. Construction of the rules
The knowledge acquisition process for the definition of the rules was developed by means of many meetings between the knowledge engineer and the database concurrence control specialists. The observation technique was used to analyze the ior schedulers to analyze the scheduler with different scenarios.

Many rules composed of the combination the input fuzzy variables were investigated, but some of them cannot occur in lowing combination is impossible: a scheduler with an aggressive behavior and lock waiting rate with a medium or high This way, after analyzing all the combinations of the input variables, it was verified the 8 rules were sufficient. After this process the knowledge database was structured with 8 rules described as follows: Rule 5 :IF atr = L AND cor = M AND isb = C THEN sb =C.

Rule 6 :IF atr = L AND cor = H AND isb = C THEN sb = C.For these two rules the following axiom is valid: if the aborted Rule 7 :IF atr = M THEN sb =C.
 Rule 8 :IF atr = H THEN sb =C.
 behavior is aggressive, producing medium or high value for the aborted transaction rate, then the scheduler should change its behavior to conservative to decrease the aborted transaction rate. 2.1.4. Development of the ES The ES was implemented in Java language using the JFuzzy API [13] developed by National Research Council of Canada X  X  and reasoning. 2.1.5. Evaluation and Improvement the ES
The ITS X  X  evaluation was executed during the entire specification, development and test phases of the ITS. During the the tests applied in the scheduler with fixed concurrency control protocols (aggressive or conservative).
Many tests were executed in relation to the linguistic variable values and their respective fuzzy sets, during the entire implementation phase, for guaranteeing that they are correct. In Section 4 , the presented tests show that the Analyzer behaved as expected. 2.2. Scheduler
The module of the ITS responsible for synchronizing operations belonging to several transactions is the Scheduler. The scheduler is composed of the following components: Protocols , which stores the code of concurrency control protocols;
Engine , which executes the concurrency control protocols; Aggressive DB and Conservative DB , which store necessary information for scheduling the transactions when the scheduler has aggressive or conservative behavior, respectively;
Transition DB , which stores necessary information for controlling the transactions in the course of a transition period from one behavior to another; Interface , which implements the communication between the scheduler and the other components.
 might be transactions being synchronized by an aggressive protocol, while others are being synchronized by a conservative tocols are being executed simultaneously during the transition phase. In Section 3 , we prove that the ITS presents that feature. 3. ITS X  self-adaptability computational environment (e.g., a new client starts to submit several new transactions with write operations). In other words, ITS is able to switch the concurrency control protocol used for synchronizing operations belonging to concurrent ule implements concurrency control protocols with conservative and aggressive behavior.

Therefore, the challenge is to maintain the database in a consistent state during the transition phase, which corresponds to the time interval when there are transactions being synchronized by two different concurrency control protocols. This
Section presents how ITS produces correct schedules, even during the transition phase and another important feature  X  semantic serializability [4] . 3.1. The transaction model cution of concurrent transactions is modeled by the concept of schedule ( Definition 2 ).
Definition 1 ( Transaction ). A transaction T is a sequence of distinct actions a of operations of a transaction T is represented by OP ( T ).

Definition 2 ( Schedule ). A schedule S over a set T ={ T
T * T 2 * * T n . The order of operations belonging to a transaction T over T . That means, if an operation p i precedes q i in a transaction T before q i , in any schedule over T . The set of operations of a schedule S is represented by OP ( S ). jection P of S on the set M is a schedule for which the following conditions must hold: (i) P only contains operations of transactions belonging to M ; (ii) " q 2 OP ( P ), then q 2 OP ( S ), and (iii) " o , q 2 OP ( P ), o &lt; P q then o &lt; S q .

Definition 4 ( Conflicting operations ). Let p i and q j be operations of transactions T tions p i and q j conflict, if at least one of them is a write operation, and both access the same database object. 3.2. ITS implementing classical serializability transactions (see Definition 6 ).

Definition 5 ( Active transaction ). A transaction T i is active if:
Definition 6 ( Completed transaction ). A transaction T i used.
 any conflicting operations p i and q j which belong to transactions T is conflict serializable by means of its Serialization Graph. Let S be a schedule over the set of transactions T ={ T
The serialization graph for S is a directed graph SG( S ) = (N,E), where N = T and an edge T i 6  X  j ), if there are two operations p in T i and q in T SG( S ) contains no cycle.
 ing to S and S 0 is preserved in S J . The ordered join operation is defined formally as follows. Definition 7 ( Ordered join ). An ordered join of two schedules S and S 0 , S k S 0 , results in a schedule S (i) OP ( S J )= OP ( S ) YOP ( S 0 ); (ii) " p , q 2 OP ( S ), p &lt; S q then p &lt; S J q ; (iii) " p , q 2 OP ( S 0 ), p &lt; S 0 q then p &lt; S J q , and (iv) " p , q 2 OP ( S ) \ OP ( S 0 ), if p &lt; S q then p &lt; the transactions T 1 , T 2 and T 3 , and S 0 is defined over the transactions T presents the interleaving of the operations of S and S 0 , in accordance with the item 4 (iv) of Definition 7 . mally, an ITS is generated by applying an ordered join operation over three schedules, S behavior change (with new Protocol P2). Finally, S transition ations synchronized during the transition phase.

Definition 8 ( ITS ). Let S 0 be a schedule on a set of transactions T
T \ T i =  X  ,0&lt; i 6 n . A schedule S ITS is defined as follows: where S 0 is the initial schedule, before any change of the scheduler behavior, S scheduler behavior changes. If the scheduler does not change its behavior, S Fig. 4 illustrates the notion of ITS schedule (see Definition 8 ). S
Definition 7 ) on all schedules S i and S transition i , with 0 &lt; i &lt; n +1.In Fig. 4 , each S operations synchronized by two different concurrency control protocols, one with conservative behavior and the other with aggressive. This occurs during the transition phase, when the scheduler (ITS) changes its behavior.
It is important to note that the schedules S i and S transition ferent sets of transactions. For example, S 0 is the projection of S behavior change.

In order to implement a conservative or an aggressive behavior, the ITS uses well-known protocols, such as strict 2PL and tain the database in a consistent state during the transition phase.

The schedule produced during a transition phase involves the active transactions at the instant a behavior change noti-fication arrives, called T old , and the transactions submitted during the transition phase, called T tions involved in the transition phase is T transition = T period, called S transition , is in fact the projection (see Definition 3 )of S in S operations belonging to transactions in T old , and the new protocol P2, which schedules operations of transactions in
T . Recall that P1 and P2 are based on serializability and present different behaviors, either aggressive or conservative. In order to guarantee that S transition is correct, Axiom 1 (described next) must hold.

Axiom 1. The conflicting operations belonging to T old and T both protocols (aggressive and conservative).

Lemma 1. Let S transition be a schedule produced by the ITS during the transition phase. Then S
Proof. During the transition phase, the ITS maintains two schedules  X  the schedule S old protocol over T old , and the schedule S new produced by a new protocol over T 1 , the ITS (during the transition phase) requires that the conflicting operations belonging to the sets T alized in the same order. Thus, S transition is correct. h Theorem 1. If S ITS is a schedule produced by ITS, then S Proof. Consider S ITS a schedule created by ITS, where
S and S i are generated by protocols (with aggressive or conservative behavior) that use protocols based on already proven correctness criteria (e.g, serializability). The schedule S the schedules S 0 , S transition and S i do not have cycles. The schedules generated by ordered join operations in S and S transition k S i are correct, that is, they do not introduce cycles in the SG( S 1. the schedule order of the common operations on the schedules involved at an ordered join operation is preserved [item (iv) of Definition 7 ], and 2. S 0 and S i are defined over two sets of transactions T Since SG( S ITS ) does not have any cycle, S ITS is correct. h
In order to describe how the ITS correctly schedules operations of concurrent transactions, let T (0 &lt; j 6 m ), i 6  X  j , be transactions, where T i 2 T
R1 : " p i 2 OP ( T i ), p i must be scheduled by the protocol that was in use before the transition phase, and " q be scheduled by the new protocol;
R2 : " p i 2 OP ( T i ), " q j 2 OP ( T j ), where p i conflicts with q to the rules of the new and old protocols;
R3 : Operations of T i have execution priority over operations of T of T j may induce the abort of T j .

It is important to note that rule R1 guarantees that each transaction is scheduled by the protocol chosen by the Ana-behaviors, i.e., conservative and aggressive) the serialization graph for S operations should have the same serialization order; independently of the type of behavior they have been scheduled.
In other words, R2 guarantees Axiom 1 and Lemma 1 . Observe that if Axiom 1 and Lemma 1 hold, then Theorem 1 holds conflicting operations of T j , or the conservative protocol may need to reject conflicting operations of T transaction. 3.3. ITS implementing semantic serializability has been quite appropriate for conventional database applications. However, the nature and requirements of transaction processing in dynamically configurable environments (e.g., an MDBC) are quite different from those in conventional appli-transaction is submitted directly to a mobile database on the same host. A mobile transaction, denoted M subsequences { SUB i ,1 , SUB i ,2 , SUB i ,3 , ... , SUB as an ordinary (local) transaction.

Although mobile and local transactions coexist, in an MDBC there is no central component that has information on the trol model is unsuited for processing transactions in dynamically configurable environments, such as an MDBC. For that reason, a correctness criterion, denoted Semantic Serializability (S izability, it provides a higher degree of inter-transaction parallelism of mobile transactions by relaxing the atomicity property [5,6] .

The S e S model is based on the use of semantic knowledge to relax the notion of absolute transaction atomicity [4] . The result of an update action executed by a mobile transaction on an object belonging to a particular semantic unit does not depend on the values of objects belonging to other semantic units that were previously read by the same transaction.
In other words, there are no update dependencies between objects of different semantic units. With this approach a trans-semantic unit [4] .

Definition 9 ( Atomic unit  X  AU ). Let T be a transaction on database DB  X  Y defined for DB . An atomic unit Q SU
SU , where: in which N = T , T is a set of transactions, and E represents the set of labeled edges T operations, which are in conflict, p 2 OP ( T i ), q 2 OP ( T tocols with exclusive aggressive or conservative behavior based on S is discussed more thoroughly.

By definition, a schedule S ITS is composed of the following schedules (see Definition 8 ): (i) the schedules produced by conservative and aggressive protocols, and (ii) the schedule in the transition phase.
 with a notification of behavior change. For ITS implementing S ( Definition 11 ).

Definition 10 ( Active atomic unit ). An atomic unit is active if: (i) o n is its last operation and has not yet been successfully executed.

Definition 11 ( Completed atomic unit ). An atomic unit is said to be completed if: (i) o n is the its last operation and has been successfully executed, or (ii) the atomic unit has been aborted.

Using the atomic unit concept, the same transaction T may be scheduled by the ITS using concurrency control protocols unit was scheduled with a different behavior. Transaction T began being scheduled with conservative behavior, went through a transition period, where the schedule behavior is hybrid, and ended with an aggressive concurrency control protocol.

Accordingly, the process of producing correct schedules is even more complex when ITS is using the S illustrate this assertion, consider Fig. 6 , where AU 1 ,AU to the set of transactions, over which the schedule S o is defined. The atomic units AU inition 10 ), when the transition phase started, while AU different behaviors, since S o has old atomic units (initiated before the behavior change notification, AU atomic units (initiated after the behavior change notification, AU since a schedule may be generated by different concurrency control protocols, each of which presents different behaviors (conservative or aggressive).

Definition 12 ( S e S Schedule ). Let S be a schedule defined over the set of transactions T , S transactions belonging to T , which has finished their execution before the behavior change notification, and S projection of the transactions of T that were active at the moment of the behavior change notification. The schedule S is transactions T that initiated their execution with protocol P1. This schedule involves all the transactions that were completed before the behavior change notification ( S completed moment of the behavior change notification.

In the following, it is proven that a schedule S produced by ITS using semantic serializability is correct, i.e., S is semantically serializable ( S 2 S e S).
 Lemma 2. If S is a schedule produced by ITS using the S e correct, i.e., S is semantically serializable (S 2 S e S).
 Proof. Let S be a scheduler produced by ITS using S e S as correctness criterion.
 Case 2. Schedule S is generated during a behavior change.
 any cycle (this is proven in [4] ). By definition, the projection S either aggressive or conservative behavior) based on S e S correctness criteria (e.g., SeL). Thus, such protocols do not synchronize operations which introduce a cycle in the graph SSG ( S ) [4] . The projection S initiated after the behavior change, are scheduled by protocols based on S not have cycles, therefore S is correct.

The schedule produced during the transition period by ITS implementing the S operations of two different sets of atomic units: the set of the active atomic units at the instant a behavior change new behavior, called AU new . Furthermore, the following relationships are valid: AU set of transactions initiated after the behavior change notification) and AU the sets AU old and AU new . S transition (see Definition 8 ) represents the projection of S
T transition phase  X  a protocol P1 used to schedule operations belonging to active atomic units in AU protocol P2, which schedules operations of atomic units in AU should hold. h
Axiom 2. The conflicting operations belonging to AU old and AU tion) order by both protocols (aggressive and conservative) over each semantic unit.

Lemma 3. Let S transition be a schedule produced by the ITS using S alizable (i.e., S transition is correct).

Proof. During the transition phase, the ITS maintains two schedules: the schedule S set of the active atomic units ( AU old ) at the moment of the behavior change notification; and the schedule S new protocol over the atomic units initiated after the behavior change notification ( AU
S
Theorem 2 proves that the schedules produced by ITS using S
Theorem 2. If S ITS is a schedule produced by ITS using S
Proof. Consider S ITS a schedule created by ITS, where S ITS schedule S transition is correct ( Lemma 3 ). Therefore, the semantic serialization graphs for the schedules S do not have cycles over same label (semantic unit). The schedules generated by ordered join operations in S and S transition k S i are correct in that they do not introduce cycles with the same label in the SSG ( S semantic unit, and (ii) S 0 and S i are defined over two sets of transactions T
Since SSG ( S ITS ) does not have cycles over same label SU 3.4. Implementation issues
This section describes how the ITS produces schedules in a dynamically configurable environment by using either clas-characterize a dynamic environment is used.

Users interact with mobile databases in an MDBC by invoking transactions. A transaction represents a sequence of operations on database objects. There are two types of transactions in an MDBC environment: local transactions and mo-bile transactions. A local transaction is submitted directly to a mobile database on the same host. A mobile transaction, denoted M i , consists of a set of subsequences { SUB i ,1 executed at a mobile database MDB k as an ordinary (local) transaction. In other words, a mobile transaction M as follows: M i ={ SUB i ,1 , SUB i ,2 , SUB i ,3 , ... , SUB bile transaction models distributed transactions, which are composed of mobile subsequences of database operations. One of the main problems of concurrency control in an MDBC is that each local DBMS has the autonomy to manage its own transactions.

In an MDBC, a local schedule models the execution of several interleaved operations belonging to local and mobile trans-local transactions in the MDBC [5,6] .

Definition 10 ( Global schedule ). A global schedule S is a schedule resulting from the concurrent execution of all the transactions, T = M [ L (local and mobile transactions), at all the local databases. For any mobile unit, MU a set of mobile and local transactions executing at mobile host MU
Since each mobile unit is autonomous on the execution of the local and mobile transactions, another component is nec-
The problem of maintaining correct global schedules in an MDBC is complicated by the presence of local transactions that not ensure that the global schedule is also correct [14] .
 ITS uses the implicit ticket method (ITM) [11] .

On the other hand, to produce correct global schedules according to the S 10 ) on the set of mobile transactions is semantically serializable.
 4. Experimentation results
In order to evaluate the performance of the proposed self-adaptable scheduler (ITS), its operation was compared with alizability transaction model was evaluated. So, the ITS was compared with schedulers implementing either strict 2PL or timestamp ordering (TO) protocols. Thereafter, the performance of the ITS implementing protocols based on semantic seri-alizability model was evaluated. The performance of these protocols was evaluated based on the following metrics: this rate is high, it means that the throughput is low.
 Abort rate : This metric indicates the number of aborts that occurred for a set of concurrent transactions. of operations. 4.1. Simulation environment
In order to simulate the execution of the ITS in a dynamically configurable environment, a mobile database community (MDBC) was used, formed by n mobile units interconnected by a wireless network. Moreover, any mobile unit can leave the network and new mobile units can join the MDBC. The simulation environment has three components: the ITS, the Trans-actionSimulator and the MDBCSimulator , which are described as follows.
 The MDBCSimulator component simulates a dynamically configurable environment. In fact, that component simulates an
MDBC whose topology may change dynamically due to the mobility of mobile databases (residing in mobile hosts). By means of that component, it is possible to define: the initial number of the mobile units, and the amount of available data items in each mobile unit for the MDBC; if and when (in milliseconds) a mobile unit belonging to the MDBC should leave the MDBC, and when new mobile units join the MDBC.

The transaction simulator, TransactionSimulator , is a software component that creates mobile transactions, and submits operation.

The ITS implementation is composed of two main modules: the analyzer, implemented with the JFuzzy API [13] and the choose the initial scheduler behavior.

For the scheduler module, the protocols TO (aggressive) and 2PL (conservative) were implemented. Recall that those pro-uler module implements the protocols SeTO (aggressive) and SeL (conservative).

The configuration of each component in the simulated mobile environment is made by means of a graphic interface. With this simulator, the user can configure several test scenarios. All components were developed using Java language. 4.2. Analysis of results
In order to use the ITS, the administrator should configure the fuzzy variable values used by the Analyzer to select the considered low when between 0 and 20, medium when between 40 and 60, and high when between 80 and 100; and cor is or conservative schedulers for defining these values. These values were coherent with the rules defined for the Analyzer. operations. After a period of time, a new mobile database joins the MDBC, which submits mobile transactions composed of write operations.
 with 3 mobile units, MU 1 ,MU 2 and MU 3 . After five seconds a new mobile unit, MU
The MU 3 has only one database. The MU 3 does not create mobile transactions. The mobile unit MU simulator, but does not have a database for the MDBC. The transactions generated by MU operations only and are executed over the global scheme of the MDBC. The mobile transactions generated by MU posed of 80% read operations (and 20% write operations). The write operation is always executed over one data item of the global scheme. The initial scheduler behavior is conservative.
 actions, the results obtained ( Figs. 8 X 10 ) were derived from the transactions generated by MU actions respectively). In the tests with 300, 400 and 500 transactions, the transaction simulators of the MU generated 100 mobile transactions each, and the MU 4 generated 100, 200 and 300 mobile transactions, respectively. The to synchronize the operations of the mobile transactions during the entire period. The conservative behavior of ITS was implemented by means of the strict 2PL protocol, while the aggressive behavior was implemented by TO protocol. At a sec-tocol was used.

In Figs. 8 X 10 , one can observe that the schedulers implementing 2PL and TO protocols behaved similarly to ITS up to 200 operations, consequently there will be neither operations in queue, nor aborted transactions.
After the new mobile unit, MU 4 , entered the MDBC, which occurs 5 s after the initial MDBC is formed, the ITS demon-(TO). The protocol that presented the worst performance in relation to lock waiting rate was the 2PL, because the mobile transactions generated by MU 4 have one write operation executed over only one data item (a type of hot spot), and there sive behavior was the most appropriate.

In the second scenario, the MDBC is formed by the same mobile units described in the first scenario. The mobile unit MU also enters the MDBC after 5 s. The differences are: the mobile transactions generated by MU operations and 80% write operations. Those operations are executed over a set of 20 data items. In order to evaluate the ITS performance, the same five sets of tests were executed. Moreover, the ITS X  initial behavior was set to aggressive. transactions, since all operations are read operations. After MU appropriate.

Looking more closely at Figs. 8, 9, 11 and 12 one can observe that the ITS is able to find a good compromise between the abort rate and lock waiting rate compared to schedulers implementing a fixed concurrency control protocol (in our tests currency in dynamically configurable environments, such as an MDBC.

When the ITS implements a correctness criterion more permissive than syntactic serializability, this claim holds as well,
In the third scenario, five sets of tests were run in which the ITS synchronized operations of 100, 200, 300, 400 and 500 were derived from the transactions generated by MU 1 and MU SeL (conservative), the second implementing SeTO (aggressive) and finally the ITS. The schedulers implementing SeL and
SeTO protocols behaved similarly to the ITS when the tests were executed without the mobile unit MU and MU 2 submit transactions composed of read operations only. During this period (before the arrival of the MU that the ITS Scheduler should continue with conservative behavior.
 to lock waiting rate ( Fig. 14 ) was the one implementing SeL (with exclusive conservative behavior), because the mobile transactions generated by MU 4 have one write operation executed over one data item only, and there is a high number of operations waiting for the unlocking of this data item. The difference between the ITS with semantic serializability and cor = L AND lwr = H THEN sb = A) to determine that the most appropriate behavior is aggressive.
In the fourth scenario, the ITS with semantic serializability correctness criterion was applied where the MDBC was com-posed of the same mobile units, MU 1 ,MU 2 ,MU 3 and MU 4 aggressive. In order to evaluate the ITS, the tests were executed with three schedulers: SeL, SeTO and ITS.
In this scenario, after the MU 4 entered, the SeTO scheduler increased the aborted transaction rate ( Fig. 17 ), MU The Analyzer used Rule 7 (Rule 7: IF atr = M THEN sb = C) (see Fig. 19 ).
 5. Related work In the literature, there are some proposals for concurrency control algorithms with aggressive and conservative behavior. formance from the scheduler. However, none of these proposals supports the notion of a self-adaptable scheduler, with for a scheduler at any given moment. Finally, the manner in which the ITS produces correct schedules and ensures, thus, database consistency (see Section 3 ) is also innovative. Some of these aspects are discussed as follows.
Bernstein and Goodman presented in [28] algorithms that integrate characteristics of 2PL and TO. Their idea was to divide the synchronization process into two groups: rw synchronization (rw  X  read and write operations) and rwr synchronization (read X  X rite X  X ead operations). An interface between a 2PL and a TO algorithm was created to guarantee correct schedules, since both protocols can be used for rw and ww synchronization. This interface uses locked points to induce timestamps. A necessary. Moreover, this approach, unlike the ITS, does not present any scheduler behavior change.
Bhargava [10] defined algorithmic adaptability as the set of techniques for dynamically changing from the execution of which refers to changes over time (this method generally has a brief conversion period); per-transaction, which consists of methods that allow each transaction to choose its own algorithm, different transactions running at the same time may algorithm based on properties of the data items they access. The method presented by Bhagava, which comes closer to function is not necessary.
 anism when there are many hot spots (data items accessed concurrently by many conflicting operations) in the system, and an optimistic mechanism when most of the transactions are accessing data which do not represent hot spots (i.e., data ac-cessed by non-confliction operations). In order to define which mechanism should be applied at a given moment, the ap-uler is using the optimistic technique at a given moment, when suddenly several transactions are submitted. Suppose that ments, being used in conjunction with any lock-based concurrency control algorithm. The goal of this proposal is to use age and transaction X  X  read/write ratio. These parameters are combined in the non-linear aging function, which provides block).

Besides having an adaptive behavior, the ITS can implement different correctness criteria, such as classical (syntactic) applications, such as computer-aided design and software engineering (CAD and CASE), geographic information systems (GIS) and workflow management systems (WFMS). Such applications consist of long-living and (possibly) interactive transactions.

Most of the transaction models presented in the literature related to mobile computing assume that mobile units access ically configurable environments, such as an MDBC, are based on the use of concurrency control protocols with exclusive cussed in the following.

SESAMO [5] is a concurrency control mechanism based on semantic serializability [4] . According to SESAMO mechanism, the mobile transaction concurrency control is distributed among several independent mobile multidatabase transaction izable Schedule (SGS3) resulted from the union of all the PGS3 produced by the corresponding MOTSs. This proposal implements an aggressive behavior.

Gruenwald and Banik in [20] present a description of a model for transaction management in MANETs. Depending on the communication capacity, memory size and energy limitations, the mobile units are classified in two groups: Small Mobile
Host (SMH) and Large Mobile Host (LMH). When all sub-transactions of a global transaction have been completed, a global aggressive behavior, as well. Recall that approaches implementing concurrency control protocols with aggressive behavior present high aborted transaction rates when executed over hot spots.
 brid behavior, suitability of being used in dynamically configurable environments, and the support for protocols based on rectness criteria (i.e., serializability and semantic serializability). 6. Conclusion
This paper presented the ITS  X  a scheduler that adapts its behavior dynamically and automatically (without human inter-Section 3 .

In order to evaluate the viability of the ITS using serializability, two protocols, 2PL (conservative behavior) and TO (aggressive behavior), were implemented in the core of ITS. In order to evaluate the ITS using semantic serializability, two protocols were implemented, SeL (conservative) and SeTO (aggressive). However, it is important to note that the ITS fixed behavior (aggressive or conservative).

The tests presented in Section 4 simulated the use of the ITS for synchronizing transactions in an MDBC  X  a dynamically for controlling concurrency in dynamic environments, such as an MDBC, since it is able to find a good compromise between the abort rate and lock waiting rate compared to schedulers implementing static behavior, i.e., fixed concurrency control protocols.
 The results obtained demonstrate the viability of employing the ITS in a dynamic environment, such as an MDBC. environment; and an Analyzer (ES) specification for mobile environments, including the following variables: number of mobile units, disconnect rate and available rate.

References
