 A graph neighborhood consists of a set of nodes that are nearby or otherwise related to each other. While existing de fi nitions con-sider the structure (or topology) of the graph, we note that they fail to take into account the information propagation and diffusion characteristics, such as decay and reinforcement , common in many networks. In this paper, we fi rst de fi ne the propagation ef fi ciency of nodes and edges. We use this to introduce the novel concept of zero-erasure (or impact ) neighborhood (ZEN) of a given node, n , consisting of the set of nodes that receive information from (or are impacted by ) n without any decay. Based on this, we present an im-pact neighborhood indexing ( INI ) algorithm that creates data struc-tures to help quickly identify impact neighborhood of any given node. Experiment results con fi rm the ef fi ciency and effectiveness of the proposed INI algorithms.
 H.3 [ Information Storage and Retrieval ]: Miscellaneous Graph neighborhood, impact propagation, indexing
A graph neighborhood consists of a set of graph nodes that are nearby or otherwise related to each other. Common de fi ni-tions include h -hop neighborhoods [3,7,17], reachability neighbor-hoods [7], cluster/partition neighborhoods [10], or hitting distance neighborhoods [6,13]. [2,4,5,15,16] and others presented random walks based proximity measures in graphs. In many applications, including viral-marketing, blogosphere, and social networks [1], relatedness of a pair of graph nodes depends on how information (or in fl uence) fl ows from one node to the other in the underlying topology. Various algorithms have been proposed to identify in-fl uencers or to maximize overall in fl uence in such networks [11]. These rely on various cascade, contagion, and diffusion models (such as the order-independent cascade and threshold-based mod-els) to capture the dynamics of fl ow. This work is supported by NSF Grant 1043583  X  X iNC: NSDL Middleware for Network-and Context-aware Recommendations X .
Note that, while their details differ, these various propagation models have two properties in common: (a) decay with distance, meaning that the further one moves away from the source of in-formation/in fl uence, the less likely she is to be impacted and (b) reinforcement , meaning that multiple paths over which informa-tion/in fl uence is received can reinforce the core message, increas-ing its impact 1 . Relying on this observation, we introduce the con-cept of impact neighborhoods , which captures both topological and propagation characteristics of graphs, including decay and rein-forcement: We say that a node n is likely to impact another node m in a given network (with decay and reinforcement), if information (a sequence of bits) originating at n reaches m .Wede fi ne the im-pact neighborhood of a given node n as the set of nodes that receive information from (or are impacted by ) n .

Impact neighborhoods are fundamentally different from h -hop [3, 7, 17] and hitting-distance neighborhoods [6, 13, 14], both of which place (direct or indirect) limits on the number of steps. In contrast, impact neighborhood depends on the ef fi ciency with which the nodes and the edges propagate information. In prob-abilistic de fi nitions of reachability neighborhoods [7], entire mes-sages can be lost at nodes or edges of the graph with some probabil-ity. In this sense, our de fi nition of impact neighborhood is related to probabilistic reachability neighborhoods. The key difference, however, is that the de fi nition of impact neighborhood allows mul-tiple imperfect (or weakened) messages received at a node to be recombined to strengthen (or reinforce) its impact.

The structure of the paper is as follows: In Section 2, we in-troduce the key concepts, leading to the problem de fi nition. In-tuitively, we associate each node in the network with a random, binary string that acts as the node X  X  fi ngerprint. The impact prop-agation within the network is modeled as transmissions of these fi ngerprints in the form of signatures. Random bit erasures are in-troduced to model the decay in the network and signature compo-sition is used to model reinforcement . The impact that n has on m is modeled as the likelihood that n  X  X  fi ngerprint is correctly trans-mitted (i.e., propagates) from n to m . In Section 3, we present the outline of the basic INI algorithm to compute zero-erasure neigh-borhoods (ZENs) and impact neighborhoods (for a given impact radius, r ). INI propagates fi ngerprints in the network subject to bit-erasures, modeling decay. During query time, impact neighbor-hoods are identi fi ed by querying the network nodes for the query node X  s fi ngerprint. In Section 4, we focus on the reduction of pro-cessing costs through the use of combined signatures that eliminate the need for each node n i to explicitly propagate the fi ngerprint of each node n j . In Section 5, we propose a novel grid-signature scheme which signi fi cantly reduces the noise in the system, thereby improving accuracy. We evaluate INI in Section 6.
We use the terms in fl uence and impact interchangeably. Figure 1: The fi ngerprint of node n i propagates in the graph, subject to bit erasures. Node n j is impacted by node n i to reinforcements despite an impact gap between n i and n
As brie fl y discussed in the introduction, we associate each node in the network with a random, binary fi ngerprint.
 graph. Each node n i  X  V has a fi ngerprint which is a b -length bit-string, with c bits set to 1.
 Propagation. Propagation is modeled as transmissions of fi n-gerprints within the graph; random bit erasures are introduced to model the decay in the network. We say that a node n impact s another node m ,if n  X  X  fi ngerprint reaches m intact (Figure 1). be a graph and let n i ,n j  X  V be two nodes on the network, with to 1, on node n i . We say that information/in fl uence/impact propa-gates from n i to n j with E ef fi ciency if one of the c non-zero bits of  X  i may be erased (i.e., set to 0 ) during the transmission from n to n j with erasure probability , p e =1  X  X  .
 Propagation and erasure characteristics of the network are taken to be consistent over suf fi ciently long periods of time: G (
V,E ) be a graph and let n i ,n j  X  V be two nodes on the network, with an edge from n i to n j .A persistent erasure mask corresponding to this edge is a b -length bit-string marking the positions of bit erasures.
 Reinforcement. As shown in Figure 1, when there are multiple paths from n to m , a given bit of n  X  X  fi ngerprint has more opportu-nities for reaching m intact.
 Let G ( V,E ) be a graph and let n j  X  V be a node on the network. Let in ( n j )  X  V be a subset of nodes with edges towards n reinforced copy of the message,  X  i,j , originating at node n the copy of the message  X  i at node n h and is the bit-wise or operation (due to erasures  X  i,h can differ from  X  i ). Zero-Erasure Neighborhoods (ZENs). The zero-erasure neigh-borhood of n is the set of nodes that receive n  X  X  fi ngerprint intact. G (
V,E ) be a graph with ef fi ciency E and let n i  X  V be a node on the network. Let also  X  i be a b -length bit-string, with c bits set to 1. The zero-erasure neighborhood , Z E ( n i ) of n i is a subset of V : ZENs in Linear Graphs. We fi rst study ZENs on linear graphs which do not provide opportunities for reinforcement.
 Let S ( V,E ) be a linearly-structured (in fi nite) graph, such that n 0  X  V has no incoming edges and there is an edge from node n  X  V to n i +1  X  V (and there are no other edges in E ). Let the propagation ef fi ciency of the network 2 and let  X  0 bit-string, with c bits set to 1, on n 0 . The distance to which  X  expected to propagate without any erasures of 1 bits is referred to as the zero-erasure radius (or ZE-radius, r ze )of Z E ( n The following theorem relates the zero-erasure radius, r ze ef fi ciency, E , of a (linearly-structured) network.

T HEOREM 1. The zero-erasure propagation radius, r ze ,isless than or equal to 1 p e ,where p e =1  X  X  is the erasure probability; We can restate this theorem in the form of a constraint on
Radius Constraint :1  X  A corollary of this formulation is that the zero-erasure radius r does not need to be an integer ; we can talk about non-integer radii, such as 2 . 3 , meaning that the expected number of hops information will propagate without errors is 2 . 3 .
 ZENs with Reinforcement. Intuitively, the linear-equivalent ra-dius of Z E ( n i ) re fl ects the observation that nodes in Z have a similar chance of receiving the fi ngerprint of n i r -hop neighbors would have on a linearly structured graph. Let Z E ( n i ) be the zero-erasure neighborhood of n G . The corresponding linear-equivalent zero-erasure ra-dius of Z E ( n i ) is de fi ned by two bounds, r le,  X  and r r Impact Neighborhoods. Letusbegivenagraph G ( V,E ) , a node n , and a target (linear-equivalent) radius, r , and asked to identify the nodes within the zero-erasure neighborhood. We use Theorem 1 to identify two bounds, E  X  ( r )=1  X  1 r and E ( r )=1  X  1 the required propagation ef fi ciency corresponding to radius, r ,and de fi ne the impact neighborhood with (linear equivalent) radius, r : The r -radius impact neighborhood , N ( r, n i ) ,of n i is the neigh-borhood de fi ned by the propagation ef fi ciency, E  X  ( r N (
Given an input graph, G ( V,E ) and a target radius, r , the off-line zero-erasure (or impact) neighborhood indexing ( INI rithm creates a signature-based index structure, by selecting a cor-responding erasure rate, p e , and by propagating the node signatures in the network with this erasure rate: Step 1 (Initialization): In its very fi rst step, the INI sociates to each node n i in the graph an (almost) unique fi ngerprint,  X  ,whichisa b -length bit-string, with c random bits set to 1. To prevent collisions, b and c need to be selected carefully: Step 2 (Propagation): Next, the INI algorithm propagates these fi ngerprints within the graph, subject to erasures re fl ecting the un-derlying network ef fi ciency, E . At each step, each node receives fi ngerprints from its incoming edges, applies its own signature and the corresponding erasure mask to each fi ngerprint, and forwards the updated fi ngerprints. A key theorem states that cycles in the network have no effect on how far information propagates:
It is trivial to extend this de fi nition to the cases where different edges have different ef fi ciencies. Let G ( V,E ) be a graph and let n i ,n j  X  V be two nodes in V .Let  X  be a b -length bit-string, with c bits set to 1, on node n G ( V,E ) be an acyclic subset of G which preserves all simple paths in G from n i to all other vertices n h  X  V . Then, if  X  the copy of the message  X  i at node n j on G and  X  i,j is the copy at node n j on G ,then  X  i,j =  X  i,j .
 The proof follows from the persistency property of the erasures (See De fi nition 3). Since propagation is not affected by the cycles, it follows that the impact neighborhoods (that depend on propa-gation) are also immune to cycles. INI terminates as soon as the bit-strings propagation within the network reaches a fi xed-point. Step 3 (Indexing): After propagation, each node, n i , aggregates all fi ngerprints it received into a combined signature,  X  These are indexed using signature indexing, such as [18]. Query Processing: Once the INI index is created, a query for the zero-erasure neighborhood, Z E ( n i ) ,of n i is answered by searching the node fi ngerprint,  X  i , of the query node within the combined signature,  X  comb ( n j ) , of each node, n j in the graph: Z n j (  X  comb ( n j )  X  i )=  X  i , where is bitwise-and.
Obviously, propagating individual fi ngerprints until a fi xed-point is achieved and maintaining at each node a different erasure mask for each and every other node would be very inef fi cient. As shown in Figure 2, we associate to each node a single erasure mask. At each iteration, each node combines all incoming signatures into a single combined signature,  X  comb (by  X  X r X  X ng the bit-strings) and applies this single erasure mask to this combined signature.
Let us assume that we use a combined signature,  X  comb ,inte-grating a set, S ,of b -length signatures, each with c non-zero bits. If we erase one non-zero bit of  X  comb with probability p the chance that the erased bit corresponds to one of the c non-zero bits of  X   X  X  ,is c b . Hence, given p comb , we can compute the single bit erasure probability, p ind , for individual signatures,  X  p ind = p comb  X  c b . Therefore, if the erasure rate in the network for the individual signatures is p ind = p e =1  X  X  , we need to erase one bit from the combined signature,  X  comb , with probability, to match the erasure rate of the individual signatures. Note that, as long as (1  X  X  )  X  b c  X  1 , this constraint can be used for computing the single bit erasure rate for the combined signature. However, if the value (1  X  X  )  X  b c is larger than 1, we need to erase more than 1 bit. Thus, we achieve the necessary degree of erasure by erasing k&gt; 1 random bits from the combined signature with p probability instead. In that case, the probability that exactly l&gt; one bits have been erased on a given individual bit string will be Given this, the expected number of bit erasures is X ind = c p ind ( l ) . This implies that the values of p such that the expected number of one bits erased during propagation is close to 1  X  X  ; in other words X ind =(1+ )  X  (1  X  X  ) , for an error rate very close to 0. Note that, since b c , we can simplify the computation of p  X  and k as follows: Let us assume that we erase k bits out of the overall b bits 3 ; we can write the probability, none of the c non-zero bits will be erased as (1  X  p  X  )+ In our experiments presented in Section 6, we set p  X  =1 (i.e., perform erasure in each and every step of propagation) and thus pick k such that
While the search for neighborhood nodes using the combined signatures can be implemented ef fi ciently, there may be false pos-itives in the query results. Bits remaining in the partially erased signatures of the nodes outside the zero-erasure neighborhood (i.e., exo-neighborhood noise ) may contribute to false positives. False positives can also arise when the fi ngerprints of two or more nodes inside the zero-erasure neighborhood may combine in a way that matches the fi ngerprint of a node which is in reality not in the neighborhood  X  the in-neighborhood noise .

Letusbegivenagraph G ( V,E ) and node n i  X  V on which we are measuring the exo-neighborhood noise. Intuitively, the like-lihood, p exo ( n i ) , of exo-neighborhood noise on n i depends on the number of nodes outside the zero-erasure neighborhood of n and how far they are located from n i . Here, we fi rst treat exo-neighborhood noise along with the in-neighborhood noise to obtain an upper bound on the false positive rate. Then, in Section 5.2, we discuss how to reduce exo-neighborhood noise.
Let us consider the combined signature,  X  comb ( n i ) , at node n The combined signature is composed of m = | Z E ( n i ) | tures from the nodes within the zero-erasure neighborhood of n and also the exo-neighborhood noise from outside the neighbor-hood. Remember from Section 2, that each of the m node sig-natures contributing to  X  comb ( n i ) is a b -length bit-string, with c random bits set to 1. Thus, we can compute the probability of a given bit in the combined signature,  X  comb ( n i ) ,beingsetto1as us consider a query q to identify the zero-erasure neighborhood of n i . Let us assume that we are given an upper-bound on the false positive rate  X  fp . We can formalize the false positive rate constraint as 1  X  (1  X  p exo ( n i ))  X  e  X  cm b c  X   X  fp Z ( n i )  X  V , we remove dependency on m by tightening this tuitively, this constraint treats all the nodes in V as if they are in the zero-erasure neighborhood. Thus, to prevent double counting of the exo-neighborhood noise, we can set p exo ( i ) to 0 the above constraint can be simpli fi ed to Note that this is a pessimistic constraint and will in practice result in unnecessarily large values of b .
Due to the probabilistic nature of the erasures and the possible existence of exo-neighborhood noise in the system, in individual runs, the propagation may differ from the predicted distance. Thus,
The details of this process are out of the scope of this paper. we need to tighten the probabilistic spread of the propagation. We achieve this by associating to each node, n i  X  V , not a single com-bined signature, but a set,  X  comb ( n i ) ,of u  X  v signatures, logically arranged into grid consisting of u rows, each with v signatures Intuitively, the combined signature at each grid-cell corresponds to an independent run of the INI propagation algorithm and there is a different erasure mask corresponding to each grid-cell (i.e., run). Let n i be a node in the graph and let  X  comb ( n i ) consist of u combined signatures at node n i : Based on this, given a target erasure probability, p e ,if u , v ,and p are selected in such a way that
Erasure Equivalence Const . : p e =(1  X  (1  X  p ) v ) u , then the expected propagation distance with erasure probability p when using a grid-signature with u rows and v columns will be the same as the original expected propagation distance with era-sure probability p e without using a grid-signature. As we see next, having u&gt; 1 and v&gt; 1 helps the INI indexing scheme reduce the false positive rates as well as (perhaps counter-intuitively) the overall space, communication, and processing costs.
Let p ok be the probability of a zero-erasure neighborhood node being successfully located using a single combined signa-ture, whereas p fp be the probability of a node being returned as a false positive. When using a grid-signature corresponding to u  X  v combined signatures as described above, the probabil-ity of a neighborhood node being successfully located becomes p side of the neighborhood being returned as a false positive becomes p has a separating effect on the probabilities: relatively large val-ues of p are pushed even higher, whereas values that are close to 0 are pulled even lower. As a consequence, assuming that ini-tially we have p fp &lt;p ok ,the separating nature of the function 1  X  (1  X  ( p ) v ) u , ensures that p rows and v columns of bit-signatures helps bring the likelihood of false positives down, without affecting the radius.
In practice, we do not perform u  X  v individual propagations for each cell in the grid for each node. Instead, for each row, we create a single combined row erasure mask, with erasure probability p row =1  X  (1  X  p ) v , recording the combined positions of erasures for each row and apply this row erasure mask on the signatures at each step (Figure 3). Since the distance to which each bit can propagate is reduced, combined row signatures of the nodes may carry lesser exo-neighborhood noise, and the propagation step may require fewer iterations to reach a fi xed-point.
A similar multi-hashing technique is leveraged for nearest neigh-boring searching in high dimensional spaces [9] (b) Construction of a combined grid-signature (post-propagation) Figure 4: Using smaller number of signature bits than b (com-puted in Section 5) results in false positives Data sets. First, small linearly structured graphs are used for as-sessing whether the proposed impact neighborhood schemes work as expected in controlled settings. Then, real data sets are used for observing the effectiveness and ef fi ciency of the algorithm in larger networks: The dense  X  X nline student community X  data set, with 1899 nodes and 59835 edges, is from [19]. The  X  X eer-to-peer network X  data set, with 36682 nodes and 88328 edges, is from [20]. Default parameters. For all experiments, the signature length, b , and the number, c , of bits set to 1 are selected using the worst-case formulation in Section 5 such that the false positive rate is Also, as Section 2, the default probability of erasure, p 1 /r ,where r is the target radius.
 Implementation. The code has been implemented using Java. We run our experiments on a Intel Core i5-2400 CPU @ 3.1GHz with 8GB of RAM (of which 1GB was allocated as the Java heap size). During propagation, all data structures are maintained in memory; when all signatures do not fi t into memory of a single server, they are divided into multiple independent partitions, each of which fi ts into memory, and run in parallel. Similarly, different rows of a grid signature are processed in parallel. Once the propagation is over, the aggregated signatures are indexed in a bit-sliced manner.
In this subsection, we fi rst con fi rm the key ideas in the paper on graphs with simple structures: this allows us to directly observe the effects of the various design decisions and parameter settings. Ex-periments for the "online student community" sets are run 50 times; for the larger "peer-to-peer network" data set, each experiment is run 10 times.
 Signature Length. Figure 4 con fi rms that using smaller signatures multiple divisions can help accommodate larger graphs during indexing. Figure 5: (a) A fi xed erasure may lead to drops in accuracy, whereas (b) adaptive erasure helps improve accuracy Figure 6: Distribution of matching nodes for a target radius of 4 on a linear graph (1000 runs). than the signature length, b (192 bits in these experiments), ob-tained using the worst-case formulation in Section 5, may lead to an increase in the number of false positives (though the false posi-tives stay small even with up to 50% drop in signature length). Grid-Signatures. In Figure 5, we study the impact of increasing the number of rows and columns. As can be seen in Figure 5(a) naively increasing the number of grid columns results in misses, whereas increasing the number of rows results in false positives. However, in line with the discussion in Section 5.2, one can adjust the erasure rate to match the target radius Figure 5(b).
As shown in Figure 6, when using only one signature per node ( u =1 ,v =1 ), there is a large variance (misses or false positives) in the number of nodes retrieved in individual runs. When using a grid-signature ( u =2 ,v =2 ), on the other hand, the variance in the number of matches is greatly reduced (with the mean being around the target radius  X  3 in this example) as predicted in Section 5.2.
Table 1 shows the indexing and query execution times for net-works of different densities of connectivities. The table shows that (a) the number of nodes impacts the amount of computation that needs to be performed for each iteration, whereas the num-ber of edges impacts how far the information travels (i.e., how many iterations are needed); (b) the use of grid signatures increases erasure signature generation time, but (especially in larger graphs and larger impact radii) it also reduces the propagation times (by eliminating noise, which may contribute to additional propagation work); (c) querying times are very fast, even for large graphs and different radii; (d) as the graphs grow in size and/or become dense, the lengths of the signatures grow  X  the growth in signature length can be limited by using multi-row grid signatures (which eliminate noise, thus the number of bits to be encoded); and (e) the per-server memory footprint of the index creation process can be kept under control by using multiple divisions, processed in parallel.
In this paper, we fi rst formally de fi ned the concept of zero-erasure and r -radius impact neighborhoods and proposed a prop-agation and erasure based impact neighborhood indexing ( INI algorithm for ef fi ciently identifying the neighborhood of a given node. We also proposed various optimization techniques to reduce false positives and improve storage and execution time ef fi ciency of the algorithm. Experiments con fi rmed the ef fi ciency and effec-tiveness of INI in identifying impacts neighborhoods.
