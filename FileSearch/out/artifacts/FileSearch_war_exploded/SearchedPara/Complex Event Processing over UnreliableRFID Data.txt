 CEP can correlate individual RFID readings and transform them into semantic-rich complex events, and therefore plays a key role in monitoring applications. For example, shoplifting in a retail sto re can be detected by processing a complex event in such scenario: an item has been picked up at a shelf and then taken out of the store without being first checked out in a specific time window.
Raw RFID data is inherently incomplete, noisy, and need to be cleansed. We classify the inaccuracy of RF ID data into two categories: unreliability and uncertainty . Here, unreliability refers to the erroneous readings that can be corrected by deterministic cleansing rules. In a retail store, for instance, if an item has been picked up from a shelf and checked out later on, any other shelf readings for this item in-between should be false p ositives. Instead uncertainty refers to the inconsistent RFID readings which cannot be determinately eliminated by cleansing rules due to their ambiguities . An instance of uncertainty occurs when the two different shelf readers detect an item simultaneously. So either of the two readings can be false positive, but available RFID data cannot arbitrate. In this paper, we focus only on RFID event stream containing unreliable readings, and leave the issues of CEP over uncertain RFID streams for future work.
The straightforward solution to CEP over unreliable RFID event stream is to filter out unreliable readings upfront, and then execute CEP. But this may cause CEP-enabled systems delaying to trigger corresponding response. More-over, since cleansed events are needed to be temporarily recorded, it may gener-ate large number of intermediate results. In this paper, we proposed an approach to incorporate cleansing requirements into CEP. Our approach is first to convert unreliability of RFID readings into its corresponding reliability constraints in complex event specifications, and then dir ectly evaluate the transformed complex events over unreliable event streams. The main contributions are as following:  X  We present a declarative C leansing L anguage for U nreliable RFID E vent  X  Based on CLUES, we propose an automated mechanism to enable evalu- X  By extending the existing NFA implementation frameworks, we propose two Due to value-based constraints and sliding windows in RFID complex event spec-ification, traditional evaluation frameworks [1][3] is no longer applicable. And their employed fixed data structures, such as tree [3], directed graph [1], finite automata [2], or Petri net [4], cannot adapt to necessary extensions required by RFID complex event specifications. To address these issues and to optimize CEP over huge-volume RFID data, Eugene et al [5] proposed a declarative specifica-tion language SASE and an NFA-based evaluation framework. Unfortunately, none of them can handle unreliable readings existed in RFID event streams.
RFID data is inherently incomplete, n oisy, and need to be cleansed before being forwarded. SMURF [7] aims to capture the accurate time window of tag existence by viewing RFID stream a s a statistical sample of the tags in physical world, and filters RFID data at t he low level of edge device. In practice, however, RFID readings usually require to be analyzed and cleansed in a bigger context of business flow, so cleansing th us need to be executed probably within a large sliding window. A deferred approach was proposed in [8] for detecting RFID data anomalies by defining cleansing rules with SQL-TS and performing application-specific cleansing at query time. In [6], Wang et al provided with example rules for data filtering and cleansing. But these off-line and RDBMS-based solutions cannot be applied to RFID CEP. Other related work [11] [12] tried to perform interpretation and imputation over uncertain RFID data by fully exploiting the temporal and spatial relationships among the readings, but neither of them addressed the issues of RFID CEP.
There exist some work [14] [13] on even t queries and evaluation over uncer-tain RFID data streams. A temporal model and some evaluation frameworks with corresponding optimizations were proposed in [13] to recognize patterns and perform CEP over the streams with imprecise timestamps. Event pattern detection and query evaluation techniques over correlated probabilistic streams was studied in [14]. As far as we know, there are no any related studies on CEP incorporate with data cleansing over unreliable RFID event streams yet. RFID data can be seen as a sequence of RFID tuples with the form of (Oid, Rid, RTime) ,where Oid is the ID of an object, Rid is the ID of a reader, Rtime is the occurrence time of the reading. CEP is used to correlate individual RFID readings in event stream to form semantically meaningful complex events appropriate for end applications. Shoplifting monitoring in a retail store, for instance, requires to detect a sequence o f occurrence or non-occurrence of events having same Oid within a specific time window. As an RFID complex event specification language, SASE [5] is declarative and has the overall structure as:
The EVENT clause describe a sequence pattern, and its components are occurrence or non-occurrence of component events in a temporal order. The WHERE clause specifies constraints on those events. The WITHIN clause spec-ifies the sliding window for the whole sequ ence of events. For example, the com-plex event corresponding to shoplifti ng in a retail store can be specified as Q 1 :
In Q 1 , SEQ denotes sequence pattern. SHELF , COUNTER and EXIT are different event types. The sign ! denotes non-occurrence of an event (also called as a negation event).

The NFA approach of SASE [5] can flexibly implement attribute value com-parisons between events. It creates an NF A for each query, us es instance stacks to record the events in different states, and partition the entries based on the attribute values to facilitate comparisons among events.

As for an RFID complex event, the value of Oid has a large domain, so the partitioning strategy is no longer applicable. Correlating the events with the same Oid thus requires to involve search operation on Oid .AnexampleofNFA evaluation on a complex event with the same Oid is presented in Fig. 1. We denote an event type with a capital letter, a primitive event with a lowercase letter and a subscript (where the letter and subscript indicate event type and object ID, respectiv ely). For instance, a i is an event of type A and its Oid is i .
RFID readings usually contain false positives and false negatives. Directly applying the NFA approach to CEP over unreliable RFID event streams may produce incorrect results. We will detail our solutions in the next section. The unreliabilities of RFID event stream can be specified by cleansing rules. An effective specification lan guage of cleansing rule is supposed to be declarative, sequence-based and easy-specifying. Un like SQL-TS [8] which specifies cleansing rules in relational tables, CLUES is for RFID event streams. Its format is as: where the IF clause specifies the complex event. The FORALL clause specifies the objects may have unreliable readings. &lt; Oid specification &gt; can be a boolean combination of predicates with using comparison operators or containment op-erator (i.e.  X  ). The keyword EXIST indicates that the reading may be false negative, while NOT EXIST false positive. The WITHIN clause specifies the temporal constraints for the specified complex event. The keywords BEFORE and AFTER are used to specify if the unreliable reading occurs before or after the complex event. The &lt; window &gt; specifies the size of valid time window be-tween unreliable reading and the complex event. With the BEFORE ,thetime window refers to the occurrence time gap between unreliable reading and the first component event of the complex event. With the AFTER , the time window refers to the occurrence time gap between unreliable reading and the last com-ponent event. Also the &lt; window &gt; alone can be set as an absolute time interval.
The CLUES cleansing language is declar ative, so we can construct event se-quences and specify common RFID cleansi ng rules in a straightforward way. Note that there is no action clause defined in CLUES language, cleansing action has in fact been implicitly specified by the EXIST or NOT EXIST keywords. EXIST implies that the reading may be missing and thus need to be recovered if absented. In contrast, NOT EXIST implies that the reading may be a false positive, thus has to be dropped if presented. The EXIST | NOT EXIST clause specifies the inclusive or exclusive relationship between an unreliable reading and its triggering complex event. Vario us cleansing rules can thus be composed from the clauses of EXIST | NOT EXIST , FORALL and WITHIN ,suchas: Example 1: Exclusive Rule. Consider an item is transported to location A (event type A ). Suppose the transportation time is at least 1 minute and the items may be accidentally read by location B (event type B ) nearby. We use the following cleansing rule R e to remove all B readings before an A reading:
According to R e ,any B event followed by an A event on the same object within one minute is supposed to be a false positive.
 Example 2: Inclusive Rule. Suppose that an item detected at location A is always moved to location B within 2 minutes due to business flow. We use the following cleansing rule R i to compensate some probably missed B readings:
According to R i ,any A event should be followed by a B event on the same object within two minutes.
 Example 3: Cross Reading Rule. An item stays at location A ,andmaybe accidentally read by location B . We use the following cleansing rule R c to detect this type of cross readings:
According to R c ,iftwo A events on the same object occur within 3 minutes, any B event on that object in-between is supposed to be a false positive. Example 4: Packaging Rule. Consider a pallet and its contained cases is being moved together along a certain business path. Suppose that pallet tags are always more readable, but due to material interfering and tag orientation, case tags may fail to be detected. We u se the following cleansing rule R p to recover missed A readings for the cases:
Here Oid  X  a 1 .Oid denotes that the object (case) with unreliable reading is contained in a 1 (pallet). According to R p , as a pallet reading occurs, the readings for the contained cases should be detect ed before or after it within 5 seconds. With CLUES cleansing rules, CEP over unreliable RFID event streams can be solved through imposing reliability constraints on component events and then evaluating the transformed complex event. 5.1 Complex Event Transformation Suppose that the complex event specified in the IF clause is denoted by P c .For false positive, we can use [!P c ] to represent its reliability constrain (! denotes non-occurrence of P c ), and the reliability of a reading depends on non-occurrence of P . Similarly, for false negative, we can use [ | P c ] ( | denotes an option), a missed reading should be recovered by verifying occurrence of P c . Semantically, both predicates [!P c ] and [ | P c ] impose additional constraints on events.
Suppose that the event type of false positive readings specified in a CLUES cleansing rule is A . Its reliability is formally specified as: where P c is the complex event specified in the IF clause of cleansing rule. &lt; Oid qualification &gt; , derived from &lt; Oid specification &gt; in the FORALL clause, spec-ifies additional qualifications on the Oid of component events in P c . &lt; Rtime qualification &gt; , derived from the WITHIN clause, specifies additional constraints on the Rtime of component events in P c .

Generally, P c consists of multiple component events, and may has its own attribute value comparisons and time window specifications. The reliability con-straint shares the same event sequence pattern as P c , but its WHERE clause has to integrate the Oid and Rtime qualifications specified in cleansing rule with those of P c using  X  . Consider the cleansing rule R c in Section 4, a reading of type B should be imposed with a reliability constraint as: Note that the constraints (B.Oid = A 1 .Oid) and (A 1 .Rtime  X  B.Rtime  X  A .Rtime) are derived from the cleansing rule.
 The unreliability constraint of false negative readings of type A is as:
Since a false negative reading is ac tually absented from event stream, &lt; Oid on P c . Instead, they delimit the probable Oid and Rtime values of the missed readings. Consider the cleansing rule R i presented in Section 4, B events should be imposed with a reliability constraint as:
Fig. 2 shows how to transform CLUES rules into reliability constraints. In false positive case, incorporating reliability constraint into complex event specification is straightforward as the event with constraints will be substantiated during evaluation. In false negative case, reliability constraints is to detect a missing event and specify the value of Oid and Rtime .The Oid of missing event may be = or  X  the Oid of P c . But the occurrence time of a false negative reading depends on the occurrence time of its corresponding complex event specified in reliability constraint, as well as business flow. In this paper, we assume that a false negative may occur within the inferred time interval. 5.2 NFA-Based Evaluation Approaches We use NFA-based evaluation framework for RFID complex event with reliability constraints. The primitive approach is to evaluate the complex event first, and then validate component events case-by-case using reliability constraints. For false positive, the reliability constraint of a B reading is denoted as B[!P c ] . To check reliability constraint, the primitive approach has to record the instances of P c . While validating a B event, it checks if it has a corresponding P c instance by searching on Oid and Rtime . Note that if the WITHIN clause of cleansing rule has the keyword BEFORE or AFTER , the reliability constraint can be transformed into B.!P c or !P c .B , respectively. For false negative, the reliability constraint is denoted as B[ | P c ] .Since B event may be missing, the primitive approach has to detect all complex event instances with or without B event first. Then for each partially matched complex events, checks if there is a P c instance which implies a corresponding B event occurred before.

The primitive approach produces all mat ching complex event instances with-out reliability constraints and record the instances of P c specifiedinconstraints. Next, we will present an advanced approach which interleaves reliability val-idation with CEP and evaluates reliability constraints eagerly, thus effectively reduce intermediate result size during evaluation.
 For false positive B[!P c ] , the advanced approach d etects the instances of P c and uses them to filter out unreliable B events. It evaluates CEP and P c simultaneously. Consider the case that B event is specified to occur before or within the time window of P c in reliability constraint. The corresponding B events are considered as unreliable and removed from NFA as a P c instance is found. A B event in NFA is considered as reliable only after it is out of the time window of B[!P c ] .Sothe P c instances do not need to be recorded. For the case that B event is specified to occur after the time window of P c ,asa P c instance is detected, its corresponding B event is unavailable, so the P c instances have to be temporarily stored. The B event will be checked immediately against the existing P c instances once available. A P c instance can be dropped only after it is out of the sliding window of B[!P c ] . Each event in NFA is marked as valid or uncertain , and will be changed from uncertain to valid if it is out of the sliding window of B[!P c ] . It will immediately be removed once marked as invalid .
An evaluation example of B[!P c ] is shown in Fig. 3. It supposes that the occurrence time gap between d 2 and b 2 is &gt; 1minute. (b 2 ,u) and (b 2 ,v) denotes b 2 to be uncertain and valid , respectively. Once d 2 is encountered, b 2 has fallen out of the sliding window of B[!C] ,isthusconsideredas valid .

The advanced approach processes false negative B[ | P c ] in a similar way. When-ever a P c instance is detected, its corresponding B event, whose probable oc-currence time is specified as a time interval, should be inserted into NFA if not exists. In case that B event is specified to occur before or within the time window of P c , it will be clear whether the corresponding B event is missing once the P c is detected. For the case that the B event is to occur after the time window of P , even though the corresponding B event of P c does not exist in NFA by the time P c is detected, it may occur later. The supposed B event inferred from P c should be replaced with this real one as it occurs and be inserted into NFA.
Suppose that B[ | P c ] is followed by D ,and B event is specified to occur before or within the time window of P c .Whena D event occurs and its corresponding B event not existed in NFA, an imaginary B event will be generated and inserted. The imaginary B event is initially marked as uncertain , and updated to valid as its corresponding P c is detected. An example of evaluating B[ | P c ] is shown in Fig. 4, where the corresponding b 2 event of c 2 is missed in the event stream. We conduct a preliminary experimental study to validate our evaluation ap-proaches on two metrics: memory usage and processing time. Used memeory is measured by the total number of buffered event instances. We first generated synthetic RFID data by emulating tags moving along a path of A  X  B  X  D .The complex event to be evaluated is A.B.D , and its components have same Oid . The B events are supposed to be unreliabl e, and can be determined by relia-bility constraints involving C events. We consider both false positive reliability constraint (i.e. B[!C] ) and false negative one (i.e. B[ | C] ), where C event is spec-ified to be after B event within a time window. All the tests is running on a Windows machine with Intel Core 2 Dual 2GHz CPU and 2GB RAM. 6.1 Advanced Approach vs. Primitive Approach This test is to compare the performance between the advanced approach and the primitive one. Among the generated data, there are 50 thousand events can match A.B.D with varying sliding window from 50 to 500, 10 thousand inaccurate A.B.D whose B readings are followed by C readings with varying time window of B[!C] from 20 to 200 for false positive case, 10 thousand A.D whose B events in-between are falsely missed but can be recovered if with the corresponding C events for false negative case, and some other noisy readings.
Fig. 5 shows the results for A.B[!C].D ,where 50/20 on the X-axis means that the sliding window of A.B.D is 50 while the time window of B[!C] is 20. The advanced approach is better on memory usage with the margins larger than 30% as sliding window &gt; 300, as shown in Fig. 5(a). That X  X  because the primitive approach has to record C readings and unreliable B readings, and the total number of these readings will grow accordingly as the sliding window increases. Even though the two approaches process C readings differently, they execute roughly the same number of event correlations and thus take nearly the same CPU time, as shown in Fig. 5(b).

Fig. 6 shows the results for A.B[ | C].D . The primitive approach records all C events and complex events of A.D , while the advanced one only buffers the C events with preceding A events and D events preceded by either B or C events. So the advanced approach uses less memory, as shown in Fig. 6(a). The primitive approach produces many ina ccurate complex events of A.D which need to be checked against C events. While the advanced one processes C events eagerly and does not need such checking. We can see that the advanced approach obviously outperforms the primitive one on CPU time, as shown in Fig. 6(b). 6.2 Advanced Approach vs. Traditional NFA Approach In this test, we study the performance di fferences between the advanced approach and the traditional NFA approach without reliability constraints. The test RFID data includes 100 thousand accurate complex events of A.B.D and other complex events involving false B events. Unreliability rate for an event stream is defined to be the ratio of the number of complex events with false B events to the total number of matching complex events. We varies unreliability rate from 5% to 50%. Instead, the traditional approach assums that each B event is reliable.
Fig. 7 shows the results for the false positive case. The advanced approach does not records C events, but need to cache the constructed instances of A.B.D until the B events is out of the time window of B[!C] . The advanced approach performs worse by around 15%, as shown in Fig. 7(a). Note that the used memory of the advanced approach does not grow with the increasing unreliability rates. That is because even though the total number of false positive B events becomes larger as unreliability rates increase, they are distributed in a larger event stream. Therefore higher unreliability rates do not necessarily mean more memory usage given a fixed sliding window. The traditional approach does not process C events, but constructs more complex events of A.B.D . So the differences of CPU time between the two are negligible, as shown in Fig. 7(b).

Fig. 8 shows the results for the false negative case. As the advanced approach records the C events with corresponding A events, it performs worse on memory usage, as shown in Fig. 8(a). The extra is proportional to the number of com-plex events of A.C within the sliding window of A.B.D . Because the advanced approach processes more C events, it performs worse on CPU time, as shown in Fig. 8(b). As the number of C events increase with the increasing unreliability rates, the degradation is roughly linear to the increase of unreliability rates. In this paper, we study the issues of CEP over unreliable RFID event streams. First, we present CLUES, an RFID cleansing language, to define unreliability of RFID readings, and then transform reading unreliability into reliability con-straint in complex event specification. Thus CEP can be directly performed over unreliable RFID event streams. Finally, we extend the current NFA evaluation framework to facilitate RFID CEP with reliability constraints. The preliminary experimental results show that our approach is effective and efficient.
There still exist such possible extensions for the CLUSE as: 1) The IF clause can be extended to accommodate boolea n combination of multiple complex events, and 2) The EXIST | NOT EXIST clause can be enhanced to allow speci-fying one or even multiple complex events. Also we plan to investigate the issue of CEP over RFID event streams with both unreliable and uncertain readings. Acknowledgments. This work is supported by the NSFC under Grant No. 60720106001 and No. 60803043, and the National National High Technology Development 863 Program of China under Grant No. 2009AA1Z134.

