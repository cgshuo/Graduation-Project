 Given a record set D and a query function F ,a top -k preference query ( top -k query for short) returns k records from D , whose values of function F on their attributes are the highest. The top -k query is crucial to ma ny multi-criteria decision making applications. For example, autonomous robot explore a given spatial region under dangerous environment and returns the search results as a sequence of objects ranked by a scoring f unction. As another example, in self-determinded soccer robet game, mobile robotic system list an ordered set of objects based on how aggressive the teammate object is or how weakly the rival objects is matching the score function used in the game.

Existing work on top -k query processing is to avoid searching all the objects in the underlying dataset, and limiting the number of random accesses to the spatial data. A key technique to evaluate top -k query is building index on the dataset. They can be divided into four categories: Sorted list-based, Layer-based, View-based and Sketch-based. 1. Sortedlists -based . The methods in this category sort the records in each dimension and calculate the rank by parallel scanning each list until the top -k results are returned, such as TA[6] and SA[2]. 2. Layer -based . The algorithms organize all records into consecutive layers, such as DG[9],Onion[3] and AppRI[7]. The organization strategy is based on the common property among the records, such as the same convex hull layer in Onion[3]. Any top -k query can be answered by up to k layers of records. 3. View -based . Materialized views are used to answer a top -k query, such as PREFER[5] and LPTA[4]. 4. Sketch -based . Data stream sketch-based method is used to calculate top -k query, such as RankCube[8].
 In this paper we proposed a hybrid index structure gridded dominant graph (GDG) method to improve top -k query efficiency, which integrates grid index into dominant graph (DG) index. The rest of this paper is organized as follows. The next section discusses related work. Sect ion 3 describes the problem description and definition. Section 4 gives the index structure and algorithm. Section 5 present and analyze the experiments, and Section 6 concludes. There are considerable amount of query answering algorithms proposed for top -k queries in the literatures. The threshold algorithm (TA) [6] is one of the most common algorithms. TA first sorts the values in each attribute and then scans the sorted lists in parallel. A threshold value is used to prune the tuples in the rest of the lists if they cannot have better scores than the threshold. A lot of follow-on methods have built on the TA algorithm as it addresses a common category of top -k queries, where the scoring function is a monotone function composed by using various attributes associated with the objects in the input dataset.
The layer-based method divided all the tuples of the dataset into several layers; any top -k query can be answered by up to k layers of records. There are some layered methods, such as DG[9],Onion[3] and AppRI[7]. The Onion method takes convex hull as origination rule. For given preference liner function, the result only exists in the convex hull la yer. The process of Onion is calculating the convex hull of the dataset. The first convex hull is calculated and then the next is calculated on the rest dataset, and so on, until no dataset is left. The layer rule in AppRI method is the tuple t is put into layer l , if and only if it satisfy two conditions: a) For any liner function, t is not in the result of top -( l -1); b) Exists at least one function satisfy t belongs the result of top -l . The layer rule in DG is each layer is the former Skyline. The first skyline is calculated, then the second skyline is computed on th e rest dataset, till no dataset is left. The most important property in DG is the necessary condition that a record can be in top -k answers is that all its parents in DG have been in top -( k -1) answers. Benefiting from the property, the search space (that is the number of retrieved records from the record set to answer a top -k query) of a top -k query is reduced greatly. The difference between DG and the other two methods is there is dominant relationship in DG, so it is n ot necessary to access and calculate all the former record set in front of k layer.
 The DG method based on k -skyband is to keep adding the candidate points. Our method is to prune the free points based on Reverse Dominant Point Set. In other words, if exists k -1 points dominate the point e , all the points dominated by e can be pruned. We begin by specifying the notation that will be used in the rest of this paper. We use D = { O 1 ,O 2 ,  X  X  X  ,O N } to denote a set of objects, the state of each object x ( i =1 ,  X  X  X  ,d )isthe i th property of the object. All the properties composed d dimension space; each state o f an object is a point the space.
 Definition 1. (Dominate [1]). Given two objects O 1 and O 2 in a d dimension space, we say that O 1 dominates O 2 if and only if they satisfy the following two conditions: 1) in any dimension i, the value of O 2 is larger than or equal to O 1 , Definition 2. (Aggregate Monotone Function [9]). An aggregation function i .
 Both DG and Grid index implement aggregate monotone function top -k prefer-ence query through order the records in advance.
 Definition 3. (Free). If one point or Cell can never be the top-k result, which needn X  X  to be calculated, then we call it is free.
 Definition 4. (Reverse Dominant Point Set). In data points set P, RDP S = { e } X  X  t | Dominate ( t, e ) ,e,t  X  P } ,isthe RDP S of e, denoted by RDP S ( e ) . The number of Reverse Dominant Point Set is denoted by RDP SCount ( e ). The free points in the top -k query results can be pruned by RDP S , as shown in the next lemma.
 Lemma 1. Let e  X  P , m = RDP SCount ( e ) ,if m = k , then for any monotone top -k preference query function f , the points dominated by e are free. The proof is omitted.
 Definition 5. (Determine Point). Let e, e  X  P , e dominate e , m = RDSP Count ( e ) , m = RDSP Count ( e ) ,if m &lt;k and m  X  k ,wecall e is the Determine Point of top -k query.
 Definition 6. (Dominant Graph Index[9]). Given a set D of objects in a d dimension space, D has k nonempty maximal layers L i ,i =1 ,  X  X  X  ,n .The objects O in i th maximal layer and records O in ( i +1) th layer form a bipartite graph g i ,i =1 ,  X  X  X  , ( m  X  1) .There is a directed edge from O to O in g i if and only if record O dominates O . We call the directed edge as  X  X arent-children relationship X . All bipartite graphs g i are joined to obtain Dominate Graph ( DG for short). The maximal layer L i is called i th layer of DG .
 To build a DG offline, any skyline algorithm can be used to find each layer of DG. Then, the  X  X arent-children relationship X  between records in the i th layer andthatinthe( i + 1)th layer. Essentially, DG is a lattice structure, which uses  X  X ominating relationship X  as  X  X artial order, X  as defined in Ref[9].
 As a popular index in data stream management, grid index is very efficient. The extent of each cell on every dimension is  X  1 and  X  2 . Assuming a 2-dimensional space, the cell C i,j at column i and row j contains all the tuples whose i  X   X  1 &lt; O.x 1  X  ( i +1)  X   X  1 and j  X   X  2 &lt;O.x 2  X  ( j +1)  X   X  2 , denoted by IN ( O, C i,j ). Then for each object O , the cell C i,j it belongs to can be easily computed by i = -
O.x 1 / X  1 . and j = -O.x 2 / X  2 . . The right-top point of C i,j is denoted C i,j .Max , while the left-bottom point of C i,j is denoted C i,j .Min .
 Definition 7. (Cell Dominate). Let C a ,C b  X  Cell ,if  X  e  X  C a ,  X  s  X  C b , Dominate ( e, s ) is right, then call C a Dominate C b , denoted by ( C a ,C b ) .Wecall C a is parent of C b ,and C b is child of C a . The Cells which are neither parent nor child of C a are called siblings of C b .
 We can determine the dominant relationship between two Cells via C a .Min , C .Max , C b .Min and C b .Max . Building the DG index is expensive as it requires a full scan of the entire dataset. When k is known, we can only build the k layer skyline index, and then get the results. Due to the property of RDSP, we can prune more records while build the k layer index.
 Definition 8. ( k -Max Calculating Region, k -MCR.) If there is Cell C i , the sum of the points in the parent Cell of C i is m , the sum of the points in the siblings Cell of C i is l , and the sum of points in C i is n ,if m&lt;k and m + n + l  X  k ,then C i is Determine Cell. The Union region of C i parent and sibling Cells is k -Calculating Region, k -CR. All the child Cells of C i are k -Free Region. The Intersection Region of all the k -CR are the k -Max Calculating Region, k -MCR.
 Theorem 1. For any monotone top -k preference query function f ,itsresults are in the k -MCR.
 Proof is omitted.
 Corollary 1. If n&lt;k , then top-n query can be calculated from k -MCR. Let C a ,C b  X  CELL ,if  X  t  X  C a ,  X  s  X  C b ,f ( t ) &gt;f ( s ), then a dominates b by function f , denoted by f  X  Dom ( C a ,C b ).
 Property 1. C a ,C b  X  CELL ,if Dominate ( C a ,C b ) ,then f  X  Dom ( C a ,C b ) . Property 2. C a ,C b  X  CELL , for given function f ,if fminscore ( a )  X  fmaxscore ( b ) ,then f  X  Dom ( a, b ) .
 Where fminscore ( C i ), fmaxscore ( C i ) is the minimum and maximum f value of Cell C i .
 Example 1. Figure. 1 is 4  X  4grid.The ak points are data points, we execute top -2 query, where a, d, e, f are skyline points, b, g, h are sk -2 points, c, k, i are is 3, for 3 &gt; 2, then C 2 , 3 is determine cell. The shadowed region in Figure. 1(a) is 2-CR of C 2 , 3 . The non-shadowed region isn X  X  the calculated region. Similarly, C 3 , 2 is the determine cell in Figure. 1(b). T he shadowed region in Figure. 1(b) is 2-CR of C 2 , 3 . The non-shadowed region isn X  X  the calculated region. The shadowed region in Figure. 1(c) is 2-CR of intersection of C 2 , 3 and C 3 , 2 , i.e. 2-MCA . Definition 9. (Max Search Region by f , k -MSRf ). For top -k function f , if there is Cell C i ,thesumofthe f -parent Cell of C i is m, the sum of f -siblings Cell of C i is l , and the sum of points in C i is n ,if m&lt;k and m + n + l  X  k ,then C i is f -Determine Cell. The Union region of C i f -parent and f -sibling Cells is the k -Max Search Region by f , k -MSRf .
 That is, when f is given, we can improve the efficiency more by pruned the redundant Cells in the k -MCR .
 Theorem 2. For any monotone top -k preference query function f ,itsresults are in the k -MSRf .
 Proof is omitted. 4.1 Grid Index Structure The GDG index is based on grid index and DG index, as shown in Figure. 2.
There are two parts in the GDG index, which are DG and k -MCR. We main-tain the layer and dominate relationship between the data point dp . Each data point dp is composed of id , cid (cell id ), the pointer set of its children chd ,and the next pointer to the next data in the same layer sk-i .Thesk-i ( i =1 ,  X  X  X  ,k ) (skyline-i ) , represents the i th skyline of the DG index. The same sk -i and the data points dp in the same cell are stored in the continuous memory via link structure. There is one GL link table in the k -MCR, each node of the link table is the cell in the grid. The basic information Inf and link information with DG DG -link is stored in the cell.
 Theorem 3. GCG index correctly finds top -k answers.
 Proof is omitted. 4.2 Initial Computation Module We calculated the k -MSRf through the initial computation module(CM), and can get the approximate order relationships among the grid cells. Then we can obtain the free cells in the top-k queries about function f , which can be pruned. It is shown in algorithm 1.

As shown in algorithm 1, Lines 1 to 2 calculate the maximum and minimum point of cell C from the k -MCR points. Lines 5 to 11 calculate the k -MCR f of the cells. Because the results of the data sets function f are mapped into one dimensional space, it is simple to calculate the f -relationship between the data points. For lines 8 to 9 read the ordered cells, we can judge cell C is f determine cell without judge the father of cell C . 4.3 GDG Query Module After calculated k -MCR f , we can get the result sets of top-k query must be located in the data points in the region of the k -MCR f . The data points outside the region are free, can not appear in the result set.

As shown in algorithm 2, the top-k query algorithm is similar with DG, with the k MSR f points are pruned. Line 1 read the data in the first layer Sk  X  1of DG, pruned the points without in the k MSR f region, and put the results into Algorithm 1. Algorithm of Initial Computing k  X  MSRf the CL list. The data in CL are ordered by the f value, and the count of the data in CL is k  X  n ,where n is the number of result set( RS ). Line 1 put the data have largest R value into RS . Lines 2 to 21 calculated the rest of the RS one by one. The proof of algorithm 2 X  X  correctness is omitted.
 Algorithm 2. k -MCR Traveler Algorithm 4.4 Space Complexity and Time Complexity We firstly analysis the space complexity of the algorithm. Suppose the dimension of data set is d , the m is the number of intervals in index. We can get the total number of cells is M = m d . Each data point needs d memory units. The ratio of k -MCR in total cells is P , with two points in this type cells, one is total numers, the f -value of this cell. So the number of total memory units is m d  X  P  X  (2 d +4). Let the ratio of k -MSR f in total cells is P , where cell X  X  f -value is mapped to one cell ID ,is m d  X  P .Thenumberof k -MSR f access points in GDG is s  X  d . So, the space complexity of our method is O ( m d ), where m is the number of intervals in index, d is the dimension.

Then we analysis the time complexity. Suppose the distribution of the data is uniform distribution, then the number of points in each cell is about N/m d . During the process of building index k -MCR, the complexity of k -MCR equals scan the data set time plus find the determine point time. Let N is the sum of the data points in the window, then scan the data set time is O ( N ). Find the determine point time is find the cell.Min point. The worst case is find the whole cell set, the time is O ( M ), where M is the total number of cells in the Grid Index. If N is large, and M is small, then the complexity of k -MCR is O ( N ), where N is the window size. Similarly, we can get the complexity of k -MSR f is O ( M  X  P + log ( M  X  P )), approximately equal O ( M ), where M is the total number of cells in the Grid Index. All experiments were carried out on a PC with Intel Core2 6400 dual CPU running at 2.13GHz and 2GB RAM. The operating system is Fedora with the Linux kernel version 2.6.35.6. All algorithms were implemented in C++ and compiled by GCC 4.5.1 with -O3 flag. Our experiments are conducted on both real and synthetic datasets.

Synthetic datasets are generated as follows. We first use the methodologies in [10] to generate 1 million data elements with the dimensionality from 2 to 5 and the spatial location of data elements follow independent distribution. Syn-thetic datasets are represented with U i , which have 1000K tuples, the granularity is 8000, with normal distribution between [0,7999]. The real data dataset is from http://archive.ics.uci.edu/ml/machine-learning-databases/ covtype/, 54 dimen-sions, 10 dims are numeric. We choose 3 numeric variable as dimension, while the granularity is 1989, 5787 and 5827 respectively.
 We first compare the space and time cost during building the index between DG and GDG.

The method we compared with is RankCube[4] and DG[9], the dataset is of-fline. Our methods are GDG40 and GDG80, where each dimension is divided into 40 intervals and 80 intervals. As synthetic data (3 dimension) in Figure. 3(a), when answer top-100 queries, the DG index is 10K 572K tuples, the maximum ratio is 57.2%. While the GDG40 index is 9K 74K tuples, the maximum ratio is 7.4%, and the GDG40 index is 8K 39K tuples, the maximum ratio is 3.9%. As real data in Figure. 3(b)(580 tuples), when answer top-100 queries, the DG index is 216K tuples, the ratio is 37%. While the GDG40 index is 19K 34K tuples, the maximum ratio is 6%, and the GDG80 index is 6K 24K tuples, the maximum ratio is 4%. So, our methods can reduce the size of index obviously.
Secondly, the comparisons of the numbe r of access data, query response time among our method and RankCube[4] , DG[9] is completed.

As shown in Figure. 4 and Figure. 5, for each function f has different number of access data and query response time, we choose 10 functions, then take average value as the result. As shown in Figure. 4, our methods have less number of access data than RankCube[4] and DG[9], where GDG80 is the best.

As shown in Figure. 5, our methods have better performance than the exist-ing RankCubee[4] and DG[9] method, both using synthetic data and real data environments.

We can draw conclusions from the experimental results as follows. Firstly, some data sets accessed in DG method are free, which are pruned in GDG method. So GDG method can decrease the number of access points and response time. Secondly, the RankCube method a ccess the data set unordered and have no hierarchical relationships, but GD G method did. So the number of access points and response time of GDG method is better. Finally, Compared GDG80 and GDG40, the former one has more intervals, the result is more precise, so the the number of access points is better. But the time of precalculated k MSR f is increased a little. The top -k query is well used in spatial dara or searching multi-dimensional data stream to recognize important objects. A grid-index based on reserve data points set ( RDP S ) is presented to calculate mul ti-dimensional preference top -k .Be-cause of the correlation between top -k and skyline computation, when the count of one point X  X  RDP S is bigger than or equals to the value of k ,itisforsuretobe pruned the point X  X  dominant set. RDP S canbecalculatedwithgrid-indexalgo-rithm quickly. Combining grid-index and dominant graph index, we get gridded dominant graph (GDG) index. Analytical and experimental evidences display that GDG index approach performs better on both storage of index and effi-ciency of queries.

The GDG index we proposed in this paper can clearly reduce the index size, the random access of the dataset a nd increase the performance of top -k queries, which can satisfy the critical performance demand in robots environments.
In our future work, we will study how apply RDSP in other layered index, such as Onion and AppRI, to reduce rando m access number of datasets. Morever, we will use our methods to analysis online data streams, which can be used in the mobile robots exploring in the computational complicated environments. Acknowledgments. The authors acknowledge the financial support by State Key Development Program of Basic Research of China (No. 2013CB329601), National Key Technology R&amp;D Program (No. 2012BAH38B-04),  X 863 X  program (No. 2010AA -012505, 2011AA010702) and NSFC(No. 60933005). The author is grateful to the anonymous referee for a careful checking of the details and for helpful comments that improved this paper.
