 In the past few years, XML has emerged as the dominant standard for repre-senting information and exchanging data over the Internet [2]. The Document Type Definition (DTD) [2] determines the structures of XML documents via a set of rules and is the primarily used schema language nowadays [9]. But its too simple to represent complex XML document structures. Many other XML schema languages such as SOX [3], XML schema [5], Schematron [6], DSD [7], XDR [10] have been proposed to solve this problem. Although most of them are more powerful in modeling than DTD, they do not support object oriented features except for XML Schema and SOX [8]. However, XML Schema and SOX are too complicated for nonexperts to comprehend and use [4][11]. In addition, some important features in inheritance such as overriding and blocking, are not supported in SOX and only indirectly supported in XML Schema.
 and functionality for structure modeling so that it is capable of supporting XML applications with wide spectrum. To achieve this, the most important feature needed to be integrated into DTD is the object orientation. In this paper, we extend DTD systematically with some additional key features to enable pure object oriented modeling and we call the new schema language Extended DTD. quirements of the Extended DTD; (2) we describe the components of Extended DTD including Scope Declaration Component, Element Declaration Compo-nent, Attribute Declaration Component, NameSpace Declaration Component, Import/Include Declaration Component; (3) we describe the validity constraints of Extended DTD; Finally, we come to the conclusion. This section discusses the requirements on Extended DTD and Extended DTD components. 2.1 Requirements and Analysis There are three tenets in object-oriented design, namely encapsulation, inheri-tance and polymorphism, which can improve the design, structure and reusability of the application design. To totally emphasize the principles and completely en-able object-oriented model design framework, Extended DTD needs to support mechanisms including element type derivation, scope specification, namespace and external schema constructs enclosure. 2.2 Scope Declaration Component In Extended DTD, scope can be specified at two levels: document level and element level. A scope specified for a document applies for all elements and attributes declared in this document while a scope specified for an element only applies for this element itself.
 be individually defined for each element and attribute declared in this document. The syntax to declare the scope of a document is: &lt; scope scopeOfDocument &gt; This declaration clause specifies the scope of a document to be public or private. For example, the following clause specifies the scope of an Extended DTD doc-element or an attribute, please refer to the subsecitons 2.3 and 2.4 respectively. 2.3 Element Declaration Component This subsection describes how to declare an XML element type in Extended DTD including the composition of an element declaration and explanation on each component of the declaration.
 &lt; !ELEMENT elementName scopeOfElement ISA superElementName WITH-OUTELEMENT (withoutElementList) (elementContentModel) &gt; The elementName is the name of the element which should be an NCName de-fined in XML-Namespaces [12]. This name belongs to the document namespace declared at the beginning of the document. The scopeOfElement is the scope of the element and can be public or private, which means that the element is exportable or not exportable respectively. The scope of an element is by default public. A public element is exportable while a private element is only available within the document where it is declared. ISA is the keyword to declare the ele-ment hierarchy and the superElementName following it is the name of the super-element. Super-element must be an element declared in the same document or in the external construct that is imported or included in this document. The ele-ment being declared will inherit from its super-element; WITHOUTELEMENT is the keyword specifying the elements that should be blocked in the inheri-tance process and withoutElementList is the name list of the elements contained in the parent element content model that should be blocked in the inheritance process. With this mechanism, inheritance with blocking and overriding can be supported. The elementContentModel is the Content model of the element being declared. The constraints, syntax and composition of the elementContentModel property are the same as in DTD.
 content is a simple character string or empty and without sub-elements in content model, and complex element that contains other elements in its content model or includes one or more attribute values or both at the same time. In Extended DTD, only complex elements can be used for inheritance in which new complex elements can be derived from existing complex elements. The derived complex element will inherit all content model elements and attributes from its base type and the actual content model of this element is its parent X  X  content model with the elements being blocked removed and with its own content model appending to it.
 (HomePhone) (WorkPhone, Salary, Teaches) &gt; declares an element Teacher , which is a derived type of Person with HomePhone blocked in the inheri-tance and WorkPhone, Salary, Teaches as its own content model elements. The definition of element Person is &lt; !ELEMENT Person (Name, BirthDate, HomePhone) &gt; while the actual content model is (Name, BirthDate, WorkPhone, Salary, Teaches) . 2.4 Attribute Declaration Component Literally, the attribute declaration is the same as in DTD. All constraints on DTD attribute declaration also apply for Extended DTD attribute declaration. Extended DTD attribute should have the same scope and namespace as the element it belongs to. 2.5 NameSpace Declaration Component XML namespace specification is defined in one of the W3C Recommendations called Namespaces in XML [12]. DTD doesn X  X  support namespace [14], which makes it incapable of supporting code reuse by enclosing constructs from external schema documents. This is one of the biggest limitations of DTD that make it unsuitable for flexible and modular design of complex XML applications. is a collection of names that are unique with respect to each other. By doing this, many name conflicts can be avoided. In Extended DTD, names must be unique within a single namespace, but they can be the same in different namespaces without causing any conflict. This will solve the possible name conflict when we enclose an external construct which has the same element or attribute name as in the enclosing document by using different namespaces.
 beginning of the document before the actual schema definition starts. For the syntax to declare a namespace, please refer to the W3C specification Namespaces in XML [12]. For example, &lt; xmlns =  X  X ttp://www.university.ca X  &gt; declares the default namespace of the XML document is  X  X ttp://www.university.ca X  and &lt; xmlns:e =  X  X ttp://www.external.com X  &gt; declares the name space e is  X  X ttp:// www.external.com X  . 2.6 Import / Include Declaration Component In order to enable object oriented modular design and construct reuse, Extended DTD needs to provide mechanisms to assemble a whole schema definition from multiple schema documents to allow enclosure of external constructs. The dec-laration should be at the beginning of the schema document before the actual schema declaration starts and there are two types of enclosure declarations de-pending on namespaces of the schemas:  X  &lt; include schemaURI &gt;  X  &lt; import nameSpace schemaURI &gt; document Students.edtd from the same namespace in the current document while &lt; import  X  X ttp://www.external.com X  ExternalPersons.edtd &gt; to enclose an Ex-tended DTD document ExternalPersons.edtd from a different namespace in the current document. This section discusses the validity constraints of Extended DTD. The validation of the XML documents against Extended DTD will be based on the validity constraints of DTD [13] with some additional validation rules:  X  The element content model in Extended DTD depends not only on its own  X  The Extended DTD supports polymorphism, which means that an element In this paper, we extend DTD with object orientation supporting mechanisms to make it more expressive and able to express XML document structures in a wide spectrum. First we describe the Extended DTD components including their compositions, properties, constraints. We also discuss the validation rules of XML document against Extended DTD.
 ented feature supporting XML schema languages. Table 1 compares four schema languages.
 people who are already familiar with DTD. Also, it is much more expressive and capable to support complex, modular XML application design, which makes it a truly powerful XML schema language.

