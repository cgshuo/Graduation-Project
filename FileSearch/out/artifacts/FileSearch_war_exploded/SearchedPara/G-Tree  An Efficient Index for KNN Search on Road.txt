 In this paper we study the problem of k NN search on road networks. Given a query location and a set of candidate objects in a road network, the k NN search finds the k near-est objects to the query location. To address this problem, we propose a balanced search tree index, called G -tree .The G -tree of a road network is constructed by recursively parti-tioning the road network into sub-networks and each G -tree node corresponds to a sub-network. Inspired by classical k NN search on metric space, we introduce a best-first search algorithm on road networks, and propose an elaborately-designed assembly-based method to efficiently compute the minimum distance from a G -tree node to the query location. G -tree only takes O ( | V | log | V | ) space, where | V ber of vertices in a network, and thus can easily scale up to large road networks with more than 20 millions vertices. Ex-perimental results on eight real-world datasets show that our method significantly outperforms state-of-the-art methods, even by 2-3 orders of magnitude.
 H.2.8 [ Database Applications ]: Spatial databases KNN search, Road network, Spatial databases
Mobile devices (e.g., smartphones) have become more and more popular in our daily life. To provide users with location-based search experiences, location-based service(LBS) sys-tems(e.g., Foursquare and Google Maps for Mobile) have been widely deployed and accepted by mobile users.
K nearest neighbor ( k NN) search on road networks is a fundamental problem in LBS. Given a query location and a set of static objects (e.g., gas stations) on the road network, the k NN search problem finds k nearest objects to the query location. k NN search on road networks has many real-world applications. For example, a tourist looking for k nearest  X  gas stations  X  X hile driving in a city requires a k NN query. As another example, an ambulance searching for k nearest  X  hospitals  X  X n an emergency case also requires a k NN query.
There are a large number of studies on k NN search on road networks [3, 8, 9, 14, 15, 16, 20, 23]. However, exist-ing methods still cannot support very large road networks (e.g. the whole USA road network). The main limitation of these approaches is either high memory consumption or heavy search overhead. Consider the state-of-the-art ap-proaches, SILC [23] and ROAD [15, 16], SILC requires O ( | V | 1 . 5 ) space to store all-pair shortest paths and ROAD employs Dijkstra-like algorithm for k NN finding, which has very poor scalability and efficiency on large road networks. For example, for the whole USA dataset(24M vertices), we estimate that ROAD needs over 105 days for pre-processing, and SILC consumes approximately 618GB memory!
In this paper, our goal is to design an elegant index which supports efficient k NN search on large road networks. In-spired by the classical R -tree on Euclidean space, we design our index on road networks by considering two core features. The first one is a balance tree structure, and we propose a balanced search tree index, called G -tree .The G -tree of a road network is constructed by recursively partitioning the road network into sub-networks and each G -tree node corresponds to a sub-network. The second one is to enable best-first search on such tree-based index, since the best-first algorithm has been widely applied and shown to be superior in performance [7]. However, it is non-trivial to devise the best-first search algorithm on G -tree since it is not easy to efficiently calculate the graph distance between the query lo-cation and a tree node, which is an essential operation in the best-first search algorithm. To address this issue, we define a shortest-path distance function which returns the mini-mum distance between a tree node and the query location, and propose an elaborately-designed assembly-based method to efficiently implement this function. The assembly-based method employs a dynamic-programming algorithm rather than the conventional network-expansion search algorithm, thus significantly reduces the overhead for calculating this function. G -tree only takes O ( | V | log | V | ) space, hence, it can easily handle very large road networks, even with more than 20 million vertices. Experiments on eight real-world datasets show that our method significantly outperforms state-of-the-art methods, even by 2-3 orders of magnitude. To summarize, we make the following contributions.
The structure of this paper is organized as follows. We define the k NN search problem and review related works in Section 2. We present our G -tree index and and an efficient search algorithm in Section 3&amp;4. We discuss the path recov-ery, G -tree construction, maintenance and extension issues in Section 5. Experiment results are reported in Section 6. Data Model. We model a road network as an undirected weighted graph G = V , E ,where V is a set of vertices and E is a set of edges. Each edge ( u, v )in E has a weight (e.g., distance, travel time, etc.), which is a positive value. Given a path between vertex u and vertex v ,thesumofweights of edges along the path is called the distance of the path. A path with the shortest distance is called a shortest path. Let SP ( u, v ) denote a shortest path between u and v ,and SPDist ( u, v ) denote the shortest-path distance between u and v . We will discuss how to extend our method to support directed graphs in Section 5.4.

For example, Figure 1 shows a road network. The weight of edge ( v 2 ,v 6 )is3. SP ( v 4 ,v 9 )= v 4 v 3 v 2 v 6 path between v 4 and v 9 and SPDist ( v 4 ,v 9 ) = 15. Query Model. Given a graph G , a query q is a triple q = v q , C ,k ,where v q is a query location, C is a subset of vertices in G (e.g., gas stations), and k is an integer. Each vertex in C is called an object.
 Top-k Answers. Given a graph G and a query q = v q , C ,k , the answer, denoted by R ,isasetof k nearest objects to the query location such that, (1) The size of R is k , i.e., |R| = k ; (2) Each answer is an object, i.e., R X  X  ; (3)  X  v  X  X  ,  X  u  X  X  X  X  , SPDist ( v q ,v )  X  SPDist ( v q ,u ).
For simplicity, in the paper we assume that both the query location and the objects are at vertices. If not, we can use heuristic method, e.g. to place them on the nearest vertex.
For example, in Figure 1, consider q = v 4 , { v 3 ,v 9 ,v There are three objects (which are denoted by solid rectan-gles). We have SPDist ( v 4 ,v 3 )=2, SPDist ( v 4 ,v 9 ) = 15 and SPDist ( v 4 ,v 15 ) = 21. The top-2 answers are R = { v 3
Existing studies [15, 16, 20, 23] addressed the same prob-lem as ours. INE [20] extended the Dijkstra algorithm [4] by expanding neighbor vertices from the query location un-til k NN answers have been found. IER [20] improved INE by utilizing spatial pruning techniques, e.g, taking the Eu-clidean distance as a bound, to prune unpromising expan-sions. IER and INE are  X  X lind X  algorithms since they can neither capture the global distance from objects to the query location nor prune unnecessary objects efficiently.
ROAD [15, 16] also extended the Dijkstra algorithm by us-ing a hierarchical structure. ROAD recursively partitions a road network into sub-networks, pre-computes the shortest-path distances of  X  X hortcuts X  within a sub-network, and or-ganizes them in a hierarchical manner. By using Dijkstra-like network expansion, ROAD can skip sub-networks which do not contain an object. However it cannot prune sub-networks with objects which are widely scattered. For ex-ample, if the objects are uniformly distributed (e.g., Mcdon-ald X  X  or gas stations), ROAD will degenerate to the Dijkstra algorithm and have to traverse the whole network. Thus ROAD performs poorly, especially on large networks. We call ROAD a  X  X alf-blind X  algorithm as it partially captures global distance information.

Although ROAD uses a hierarchical structure, it is differ-ent from our method as follows. First, the tree structures are different. G -tree is a balanced search tree while ROAD is not. Second, the k NN finding paradigms are fundamen-tally different. ROAD employs an expansion-based method and cannot utilize the global distance information, e.g., the shortest-path distance from a query location to tree nodes, to do effective pruning. G -tree adopts a best-first search algorithm which only accesses tree branches containing ob-jects and thus reduces the space space significantly. Thus our method significantly outperforms ROAD (see Section 6).
SILC [23] pre-computes the shortest paths between all vertex pairs and uses a quadtree-based encoding to store the shortest paths. It utilizes the materialized pairs to find k nearest neighbors by using Euclidean distance and stores the shortest-path distance as a bound. However if there are large numbers of objects clustered in a small region, SILC is inefficient. Moreover, SILC consumes O ( |V| 1 . 5 ) storage space and incurs high pre-processing overhead, and thus it is impractical for large road networks.

There are some studies which assume that the object set is given [3, 8, 9, 14]. They pre-compute and materialize results of potential queries on the graph. However these ap-proaches highly depend on the given object set. In addition they involve high pre-computation cost and large memory overhead. works and in metric space. Their problem is different from ours. They focused on how to combine keyword information and distance information to compute top-k answers, while we emphasized on finding k nearest neighbors. k NN Queries for Moving Objects on Road Networks: There are quite a number of studies on k NN queries for moving objects monitoring [10, 19, 26, 27]. These works studied the problem of finding nearest moving objects (e.g., taxies) to a location and focused on dealing with frequent updates of moving objects. In our case, we emphasize on the efficiency of the k NN queries on the static objects (e.g., gas stations), of which the ideas and implementations are totally different.
 Single-Pair Shortest Path Queries: Many previous stud-ies [1, 2, 6, 11, 12, 24, 25] addressed the problem of shortest path queries between two vertices on road networks. How-ever, it is worth noting that k NN search is radically different from single-pair shortest path solution. Though k NN search involves shortest path computation, the key point of k NN search is to quickly find those promising top-k objects rather than to calculate the shortest path from the query location to all candidate objects then rank them. Therefore, it is not feasible to apply them to handle the k NN search on road networks effectively. Although HEPV [11] and HiTi [12] also organize the road network into a hierarchical structure, they still use  X  X alf-blind X  Dijkstra-like network expansion, while G -tree is fundamentally different which fully utilizes the best-first search and employs dedicated assembly-based method to calculate the distance between the query location to a tree node.
In Euclidean space, tree structured indices, e.g., R -tree , have salient features to support k NN search. We would like to incorporate two of these features in our G -tree to sup-port k NN search on road networks. The first feature is the balanced tree structure that can help to prune subtrees. We will discuss it in this section. The second feature is the effi-cient computation of the minimum distance from the query location to tree nodes which is used for best-first search, which will be discussed in Section 4.
Before we present the G -tree structure, for ease of pre-sentation, we first introduce some important concepts which will be used throughout the paper.
 Definition 1 (Graph Partition). Given a graph G = V , E ,where V is the vertex set and E is the edge set of G partition of G is a set of subgraphs, i.e., G 1 = V 1 , E V 2 , E 2 ,..., G f = V f , E f such that (2) For i = j , V i  X  X  j =  X  ,and (3)  X  u, v  X  X  i ,if ( u, v )  X  X  ,then ( u, v )  X  X  i .
Vertices in different subgraphs may be connected in the original graph G but be separated in different subgraphs after partitioning. To differentiate such vertices from others, we define a concept, called borders .

Definition 2 (Borders). Given a subgraph G i of G ,a vertex u  X  X  i is called a border if  X  ( u, v )  X  X  and v/  X  X  We use B ( G i ) to denote the border set in graph G i . A subgraph G i is called a super-graph of another subgraph G j if V i  X  X  j and E i  X  X  j . Based on these concepts, next we formally define the G -tree structure.

Definition 3. A G -tree is a balanced search tree that satisfies the following properties. (1) Each node represents a subgraph. The root node cor-responds to the graph G . The subgraph of a parent node is a super-graph of those of its child nodes. (2) Each non-leaf node has f (  X  2) children. (3) Each leaf node contains at most  X  (  X  1) vertices. All leaf nodes appear at the same level. (4) Each node maintains its border set and a distance ma-trix. In the distance matrix of a non-leaf node, the columns/rows are all borders in its children and the value of each entry is the shortest-path distance between the two borders. In the distance matrix of a leaf node, the rows are all borders in the node, columns are all vertices in the node, and the value of each entry is the shortest-path distance between the border and the vertex.

Conditions (1)-(3) ensure that the G -tree has a balanced search tree structure. It is worth noting that for each node we do not maintain the physical subgraph. Instead, we only maintain a dummy subgraph ID. As there is a one-to-one correspondence between a node and a subgraph, for simplic-ity,  X  X odes X  and  X  X ubgraphs X  are interchangeably used if the context is clear. In the paper  X  X odes X  refer to G -tree nodes and  X  X ertices X  refer to vertices in the graph. Condition (4) is used to efficiently compute the shortest-path distance from a vertex u to a vertex v , i.e., SPDist ( u, v ). We will use it to compute the minimal distance from a vertex u toanode n , i.e., SPDist ( u, n )=min { SPDist ( u, v ) | v is a vertex in n which will be discussed in Section 4.

Example 1. Figure 2(b) shows the G -tree of the road network in Figure 2(a). The borders of each node are shown in the rectangle box under the node. For example, G 1 has three borders { v 1 ,v 6 ,v 10 } . The distance matrix of each node is listed around the tree node. For G 1 , its children G 3 and G 4 contain five borders { v 1 ,v 6 ,v 7 ,v 8 ,v 10 rows/colmuns of G 1  X  X  distance matrix are the five borders. The set of vertices of each leaf node are shown in the circled numbers. For instance, G 4 contains two borders { v 8 ,v and four vertices { v 8 ,v 9 ,v 10 ,v 11 } .In G 4  X  X  distance matrix, the rows are borders { v 8 ,v 10 } and the columns are vertices { v 8 ,v 9 ,v 10 ,v 11 } . The entry ( v 8 ,v 11 ) = 11 since the shortest distance between border v 8 and v 11 is 11.
We use a graph partition based method to build the G -tree . Initially, we take the graph G as the root. Then we partition G into f equal-sized subgraphs (i.e., |V 1 | X  ... |V f | ) and take them as the root X  X  children. Next we recur-sively partition the children and repeat this step until each leaf-node X  X  subgraph has no more than  X  vertices. Notice that during the partitioning, for each subgraph, we will add its borders into the corresponding node. For example, in Figure 2(a), suppose f =2and  X  = 4, the original graph G 0 is partitioned into two subgraphs G 1 and G 2 . G 1 is further partitioned into G 3 and G 4 . G 2 is partitioned into G 5
Graph partitioning is an important step in G -tree con-struction. The optimal one should not only generate ap-proximately equal-sized subgraphs, but also minimize the number of borders. However, it has been proven that the optimal graph partitioning is NP-Hard [5]. In this paper, we adopt a famous heuristics algorithm, called the multi-level partitioning algorithm [13]. The multilevel partition algorithm can guarantee that each subgraph nearly has the same size and thus G -tree is a balanced search tree.
For distance matrices of G -tree , we need to compute the shortest-path distance between a border and a border/vertex(non-leaf/leaf). We can use a single source shortest-path algo-rithm, e.g. Dijkstra algorithm, to compute the graph dis-tance. It starts from each border/vertex within one G -tree node, expands the edges until if all borders of such node have been reached. In Section 5.2, we will introduce an efficient bottom-up algorithm to speed up this procedure.

Notice that we focus on the memory-based index in this paper and leave the disk-based index as our future work. Height: The height of the G -tree is H = log f |V|  X  +1. Number of Nodes: At level 0, there is one node (the root). In level i ,thereare f i nodes. There are |V|  X  leaf nodes. Thus the total number of nodes is O ( f f  X  1 |V|  X  )= O ( |V| Number of Borders: A road network is usually modeled as a planar graph [23]. We also consider the planar graph in the space analysis. Consider a node on the i -th level. Its bor-ders are generated by its parent which has |V| /f i  X  1 vertices. According to the Planar Separator Theorem [18], the f -partition on the parent totally involves O (log 2 f  X  |V| borders. Hence, the total number of borders in the G -tree is
O ( Distance Matrix: The average number of borders in a leaf node is O (log 2 f  X  |V| /f H +1 )= O (log 2 f  X  the total distance-matrix size of all leaf nodes is O (log  X  rows/columns of its distance matrix are the union of borders in its children. Each node on level i generates O (log 2 the distance-matrix size at level i is O (log 2 2 f  X |V| ). Hence the total matrix size of non-leaf nodes is O ( H log 2 2 f O Overall Space: The overall size of the G -tree is O ( |V|  X   X  |V| +log 2 2 f  X  log f |V|  X   X |V| ). It is worth noting that log and log f |V|  X  are small, thus G -tree is scalable.
In this section, using the G -tree index, we propose a best-first k NN search algorithm for road networks.
The basic idea of our algorithm is as follows. Suppose we can use function SPDist ( v q ,n ) to compute the minimum distance between the query location v q and a tree node n . Given a query q = v q , C ,k , we first locate the leaf nodes of query location and objects using a hash table which maps a vertex to the corresponding leaf node. For each leaf node n found, we construct an occurrence list L ( n )whichiscom-posed of IDs of objects that appear in the leaf node (line 1). Then for each ancestor n a of such a leaf node, we also con-struct an occurrence list L ( n a ), which is composed of IDs of n  X  X  children that contain objects. Thus from the root, we can easily figure out which nodes contain objects based on the occurrence list. Figure 7(a) illustrates an example for C = { v 3 ,v 9 ,v 15 } . For example, for G 5 , its occurrence list is { v 3 } as vertex v 3 is an object. For G 2 , its occurrence list is {G 5 , G 6 } as nodes G 5 and G 6 contain objects.

Then we initialize a priority queue Q and a result set R (line 2). Initially we put root, SPDist ( v q , root )=0 into Q (line 3). We iteratively dequeue the first element e of Q and handle it separately according to whether e is an object, a leaf node or a non-leaf node(line 4 to line 18). Figure 3 shows the pseudo-code of our algorithm.

It is worth noting that if R has k answers, the algorithm can safely terminate. This is because the distance from the query location v q to the k th answer is currently the best. Thus our algorithm can correctly find the top-k answers.
Example 2. Consider the query q = { v 4 , { v 3 ,v 9 ,v 15 on the graph in Figure 1. We first construct the occurrent list and then compute the top-2 answers as follows. Step 1: Enqueue the root node, i.e. G 0 , 0 .
 Queue: G 0 , 0 Step 2: Dequeue G 0 , 0 . Find two child nodes in the occur-rence list of G 0 , i.e. G 1 and G 2 .Get SPDist ( v 4 , G SPDist ( v 4 , G 2 )=0 . Enqueue G 2 , G 1 .
 Queue: G 2 , 0 G 1 , 7 Step 3: Dequeue G 2 , 0 . Find two child nodes in the occur-rence list of G 2 , i.e. G 5 and G 6 .Get SPDist ( v 4 , G SPDist ( v 4 , G 6 )=16 . Enqueue G 5 , G 6 .
 Queue: G 5 , 0 G 1 , 7 G 6 , 16 Step 4: Dequeue G 5 , 0 . Find a vertex v 3  X  X  5 .Get SPDist ( v 4 ,v 3 )=2 . Enqueue v 3 .
 Queue: v 3 , 2 G 1 , 7 G 6 , 16 Step 5: Dequeue v 3 , 2 . R = { v 3 } .
 Queue: G 1 , 7 G 6 , 16 Step 6: Dequeue G 1 , 7 . Find a child in the occurrence list of
G 1 , i.e., G 4 .Get SPDist ( v 4 , G 4 )=13 and enqueue G Queue: G 4 , 13 G 6 , 16 Step 7: Dequeue G 4 , 13 . Find a vertex v 9  X  X  4 .Get SPDist ( v 4 ,v 9 )=15 . Enqueue v 9 .
 Queue: v 9 , 15 G 6 , 16 Step 8: Dequeue v 9 . R = { v 3 ,v 9 } . Top-2 answers have been generated. Algorithm terminates.

The biggest challenge in the algorithm is to efficiently im-plement SPDist ( v q ,e ) under three circumstances: MinDist-Inside-Leaf , MinDist-Outside-Leaf ,and MinDist-Outside-NonLeaf . To address this problem, we will present our dedicated assembly-based method in next section.
One significant issue remained in Algorithm 1 is to calcu-late the SPDist ( v q ,e )where e is a vertex or node. This is the most important part in the framework of G -tree , since it will greatly affect the efficiency of k NN search. In this sec-tion, we discuss how to efficiently implement the function Algorithm 1 : KNNSearch ( q = v q , C ,k , G ) Input : q = v q , C ,k : A query; G :A G -tree Output : R : The top-k result list; Compute the occurrence list L based on C ; 1 Initialize priority queue Q =  X  and result set R =  X  ; 2
Q .Enqueue( G .root, 0 ); 3 while R .Size() &lt;k &amp; Q is not empty do 4 SPDist ( v q ,e ). First, we introduce two naive methods, and then we present our dedicated assembly-based method . Naive Method 1: A naive solution is to pre-calculate the minimum distances between all vertices and nodes/vertices. In this case, we can use O (1) time to implement the SPDist function. Obviously the space complexity is O ( |V| 2 + |V| O ( |V| 2 ). Apparently when |V| becomes large, this method may incur an unacceptable memory cost and is not scalable. Naive Method 2: Another naive method is to utilize bor-ders based on the following  X  closure  X  property.
Lemma 1 (Closure). Given a subgraph G i = V i , E i , for any vertex u/  X  X  i and v  X  X  i , any shortest path between u and v must contain a border in B ( G i ) , i.e., for any shortest path SP ( u, v ) ,  X  w  X  X  ( G i ) ,w  X  SP ( u, v ) . Proof. We omit the proof due to space constraints.
As shown in Figure 2(a), consider v 9  X  X  1 and v 4  X  X  5 .As v and v 9 are not within the same subgraph, any path from v to v 9 must contain a border in G 1 , e.g., v 6 . Similarly, any path must contain a border in G 4 , e.g., v 8 .

Consider a query location v q , a vertex v ,and v q /  X  leaf ( where leaf ( v ) denotes the leaf node of v . Based on Lemma 1, we can decompose SPDist ( v q ,v ) into two sub-paths. The first one is from v q to B ( leaf ( v )) and the second one is from B ( leaf ( v )) to v .Thuswehave SPDist ( v q ,v )= min
Similarly, given a query location v q and a tree node n such that v q /  X  n ,wehave Based on this property, we propose another naive method. We pre-compute and store the shortest-path distances of all vertex-border pairs. Thus we can efficiently implement MinDist-Outside-Leaf and MinDist-Outside-NonLeaf . The space complexity is O ( |V| log 2 f  X  |V|  X   X  = log 2 f  X  support MinDist-Inside-Leaf , we need to pre-compute and (a) Assembling on G -tree . store shortest-path distance between all vertexes in the same leaf node. The space complexity is O (  X  |V| ). Thus the to-tal space complexity is O ( log 2 f  X   X  |V| 2 +  X  |V| ). Although this method reduces the storage space, it is still not scalable to large graphs.
 Assembly-based Method: We have an observation that many shortest paths share common sub-paths, and we do not need to store shortest-path distances for all pairs between vertices and borders. Instead we only materialize some pairs and assemble these pairs to implement the SPDist function. We use an example to show our idea. For example, in Fig-ure 2(a), consider two vertices v 4 ,v 5 and a border v 8 path from v 5 to v 8 is v 5 v 3 v 2 v 6 v 7 v 8 . The two paths share one of the common sub-path v 2 v 6 v 7 v 8 which is the shortest path from border v 2 to border v 8 . This common path can be used to compute the shortest path from v 4 to v 8 and the shortest path from v 5 to v 8 . Thisimpliesustoonlystore the shortest-path distances of pairs between borders (e.g., ( v 2 ,v 8 )) within one G -tree node.
 Thus, we pre-compute and store the following pairs. (1) For a leaf node, we maintain the vertex-border pairs in the same leaf node, e.g., ( v 4 ,v 2 ); (2) For a non-leaf node, we maintain the border-border pair, where the borders are from its children, e.g., ( v 2 ,v 6 )innode G 0 ,( v 6 ,v 8 )innode For each node, we use a distance matrix to maintain the shortest-path distances between such pairs on the G -tree (Section 3.1). Based on the distance matrix, we can as-semble these pairs and compute the shortest-path distance from a vertex to a node/vertex. For example, to compute the shortest path from v 4 to v 9 , we can assemble ( v 4 ( v 2 ,v 6 ), ( v 6 ,v 8 ), and ( v 8 ,v 9 ) (as shown in Figure 4). Next we formally introduce our method based on three cases. MinDist-Outside-Leaf: Consider two vertices u, v in two different leaf nodes. Let LCA ( u, v ) denote the least common ancestor of nodes leaf ( u )and leaf ( v ). Let LCA ( u, v ) , G ( u ) ,  X  X  X  , G x ( u )= leaf ( u ) denote the ancestors of leaf ( u ) from LCA ( u, v )to leaf ( u ) as illustrated in Figure 5. Let cestors of leaf ( v )from LCA ( u, v )to leaf ( v ).
We consider two general cases. The first one is within one adjacent levels of nodes, e.g., G i ( u )and G i  X  1 ( u ), 1 &lt;i the shortest path from u to G i  X  1 ( u ) must contain a border in G i ( u ) based on the closure property, thus
The second case is between two branches, i.e., from G 1 ( u ) to
G 1 ( v ). Similarly, we have SPDist ( u, G 1 ( v )) = min
Equations 3 and 4 indicate that calculating SPDist ( u, u is only related to those of adjacent level, i.e. SPDist ( u, u Thus, we can implement a dynamic-programming algorithm to efficiently calculate SPDist ( u, v ). Consider the nodes G ( u )= leaf ( u ), G x  X  1 ( u ) ,  X  X  X  , G 1 ( u ), G 1 ( v ) , leaf ( v ). We first compute SPDist ( u, u x )for u x  X  X  Then based on these results, we move forward to the next level to compute SPDist ( u, u x  X  1 )for u x  X  1  X  X  x  X  1 we cross from G 1 ( u )to G 1 ( v ), and move to the other branch. Iteratively, we can finally get SPDist ( u, v ). Figure 5 shows theentireprocedure.

Lemma 2. Consider a border b of node n . The border has the following properties. (1) For any child of n , e.g., c ,if b is in node c , b must be a border of node c .(2) b must be a border of one of n  X  X  children.

Note that, for any border-border pair in SPDist of Equa-tions 3 and 4, e.g., ( u 2  X  X  2 ( u ) ,u 1  X  X  1 ( u )), they must appear in the distance matrix of a node (e.g., G 1 ( u ), since u 1 must be a border of a child of G 1 ( u ) based on Lemma 2 and u 2 is a border of G 1 ( u ) X  X  child G 2 ( u )). Thus we can ef-ficiently get the shortest-path distance of each pair from a distance matrix on the G -tree .

To summarize, given a query location v q and a vertex v where v q /  X  leaf ( v ), to compute SPDist ( v q ,v ), we first compute their least common ancestor and the nodes on the paths from LCA ( v q ,v )to leaf ( v q )and leaf ( v ). Then we use the dynamic programming to compute SPDist ( v q ,v ).
Example 3. Figure 6 and Figure 7(b) illustrate how to compute the shortest-path distance from v 4 to v 9 .Initially we locate leaf nodes G 5 (for v 4 )and G 4 (for v 9 ) by the hash table we mentioned at Section 4.1. Their LCA is G 0 .We use G 5 , G 2 , G 1 , G 4 to compute the minimum distance. Each element in Figure 6 represents v i , SPDist ( v q ,v i ) .Bydy-namic programming, we can finally get SPDist ( v 4 ,v 9 )=15 . The shortest-path contains vertices v 4 , v 2 , v 6 , v 8 MinDist-Outside-NonLeaf: Given a query location v q , anode n ,and v q  X  n , we compute SPDist ( v q ,n )based on SPDist ( v q ,n )=min w  X  X  ( n ) SPDist ( v q ,w ). Since each SPDist ( v q ,w  X  X  ( n )) can be computed using the MinDist-Outside-Leaf function, we can easily compute SPDist ( v q MinDist-Inside-Leaf: Given a query location v q , a vertex v ,and v q  X  leaf ( v ), consider a shortest path SP ( v q tween v q and v . There are two cases: (1) SP ( v q ,v )doesnot contain a vertex outside node leaf ( v q ). In this case, we use the Dijkstra algorithm to compute the shortest path in node leaf ( v q ). Let DijkDist ( v q ,v ) denote the distance. Since the subgraph w.r.t. the leaf node is not large, the Dijkstra algorithm is efficient enough. (2) SP ( v q ,v ) contains a vertex
Figure 6: An Example of MinDist-Outside-Leaf. outside node leaf ( v q ). In this case, SP ( v q ,v )mustcontain two borders b 1 ,b 2 in leaf ( v q ). Let BorderDist ( v q the shortest distance from v q to v with outside vertices and,
BorderDist ( v q ,v )= min Based on the two cases, we have,
SPDist ( v q ,v )=min BorderDist ( v q ,v ) , DijkDist ( v
Our method can correctly compute the shortest-path dis-tance as formalized in Theorem 1.

Theorem 1. Given a query location v q and a node/vertex e , the shortest-path distance between v q and e computed by our algorithm is exactly SPDist ( v q ,e ) .
 Materialization-based Improvement: Although we can use MinDist-Outside-Leaf and MinDist-Outside-NonLeaf to calculate SPDist ( v q ,e ), implementing them individually will result in many duplicated computations. For example, in Figure 7(b), if we calculate SPDist ( v 4 ,v 9 )and SPDist ( v separately, we have to compute SPDist ( v 4 ,b i  X  X  2 )twice. Obviously, given a query location v q , we only need to cal-culate SPDist ( v q ,b i  X  X  i ) once. Hence, we materialize b SPDist ( v q ,b i ) on the G -tree nodes which have been visited (see Figure 7(b)). Obviously this materialized method can avoid the duplicated computations, with space cost O ( log (see Section 4.3).
Compared with the network-expansion search approach, our assembly-based method has two superior advantages. First, our method significantly reduces the overhead for cal-culating SPDist ( v q ,e ). It is easy to see that we only traverse subtrees of G -tree which contain promising objects, and each tree node is only accessed once. Second, since SPDist ( v is computed by means of step-by-step dynamic program-ming algorithms, and those materialized intermediate results SPDist ( v q ,b i )on G -tree node are indispensable for effective pruning in best-first search (i.e., SPDist ( v q ,n )), therefore, there are no redundant computations for k NN search, which makes our method very efficient for large road networks. Time Complexity: The k NN search consists of two parts. The first one is the local Dijkstra search within MinDist-Inside-Leaf . The time complexity is O (  X  log  X  ). The sec-ond one is MinDist-Outside-Leaf . Since the dynamic-programming algorithm will only access each node of G -tree v v
Figure 8: An Example of Shortest-path Recovery. once and each time it only scans the distance matrix of the tree node, the worst-case time complexity of MinDist-Outside-Leaf is the total size of the distance matrices of G -tree , i.e., O (log 2 2 f  X  log f |V|  X   X |V| ). To sum up, the worst-case time complexity of the assembly-based method is
O (  X  log  X  +log 2 ity is much smaller than the worst-case complexity. Space Complexity: For each node of G -tree , the dynamic-programming algorithm maintains SPDist ( v q ,b i ), where b is a border. Thus, the worst-case space complexity is the total number of borders, i.e. O ( log 2 f  X   X  |V| ).
It is worth noting that Algorithm 1 only returns distance rather than vertex-by-vertex path. However, the latter is sometimes very useful (e.g., in navigation system). In this section, we briefly discuss how to recover the path from the query location v q to an answer v a  X  X  selected by a user.
Since we use assembly-based method for the k NN finding, we can only get a list of selected borders from v q to v a the imperfect shortest path SP ( v q ,v a )= v q b 1 b 2  X  X  X  there may be no direct edges between two adjacent vertices, e.g., b i ,b i +1 , we need to add some other vertices between them to generate the real shortest path SP ( v q ,v a ).
The main idea is to apply divide-and-conquer to itera-tively add new vertices into the SP ( v q ,v a ). For example, in Figure 8, to compute the shortest-path distance from v between v 4 and v 2 , we need to find a vertex, i.e. v 3 ,to add between them(since SPDist ( v 4 ,v 2 )= SPDist ( v 4 ,v SPDist ( v 3 ,v 2 )). Similarly we add vertex v 7 between v v . Thus the shortest path is SP ( v 4 ,v 9 )= v 4 v 3 v 2 v
Luckily, we can always find a border b w to split b i ,b i +1 into b i ,b w and b w ,b i +1 ,where b i ,b w ,b i +1 must all appear in the same distance matrix from LCA ( G ( b i ) , G ( b i +1 root node of G -tree . Thus, each vertex finding only costs O (
HB max ). However, due to lack of space, we have to omit the details and proofs here. Any interested readers may contact the authors for further information.
We propose a bottom-up method to efficiently compute the distance matrix. The basic idea is that we first compute the shortest-path distance of borders of nodes in the lower level and then use these distances to compute the shortest-path distance of borders of nodes in the upper level. For example, in Figure 9, to compute the shortest-path distance between borders v 2 and v 10 . A naive method needs to access v and v 7 . As we have calculated the shortest-path distance between v 6 and v 10 in G 1 , we skip vertex v 7 and directly use v 6 ,v 10 in G 0 . We use this property to compute the distance matrix. Our algorithm works as follows. (1) Initially, for each leaf node, we use the Dijkstra algo-rithm to compute the shortest-path distance between any two borders in the leaf node. (2) We remove all non-border vertices in the leaf node and add shortcuts between any two borders of the leaf node. (3) We move to the parent of leaf nodes and use the Dijkstra algorithm to compute the shortest-path distance between any two borders in the parent based on the updated graph. (4) We repeat steps 2 and 3 and terminate the algorithm if we have processed the root node. Figure 9: Distance Matrix Computation (Distances of Borders to v 2 ).
We discuss how to maintain the G -tree for network up-dates. Although it is a very hard problem to support up-dates for shortest-path queries in graphs [22], we propose a feasible method to adjust the G -tree with a low overhead for network updates. We consider four basic operations and other operations can be split into these basic operations. Insert a new vertex u with an edge to an existing vertex v : We first locate the leaf node leaf ( v ) and insert u into leaf ( v ). If leaf ( v ) has more than  X  vertices, we partition the leaf ( v )into f nodes. Then, we recursively repartition the ancestor of leaf ( v ) until all nodes have no more than  X  children. Distance matrices are also updated. Remove a vertex u with only one edge to another vertex v : We first locate node leaf ( u )andremove u from leaf ( u ) and the corresponding distance matrix. If leaf ( is empty, we recursively repartition the ancestor of leaf ( u ). Add an edge ( u, v ) : If u (or v ) becomes a border from a non-border vertex, we add it into the corresponding dis-tance matrix. If weight ( u, v )  X  SPDist ( u, v ), we do not up-date the G -tree ; otherwise we update the distance matrix as follows. Consider a pair b i ,b j in a distance matrix. We check whether SPDist ( b i ,u )+ weight ( u, v )+ SPDist ( SPDist ( b i ,b j ). If so, we directly update SPDist ( b SPDist ( b i ,u )+ weight ( u, v )+ SPDist ( v,b j ). Remove an edge ( u, v ) : If u (or v ) becomes a non-border vertex from a border, we remove it from the corresponding distance matrix. If weight ( u, v )  X  SPDist ( u, v ), we do not update the G -tree ; otherwise we update the distance matrix as follows. Consider a pair b i ,b j in a distance matrix. If SPDist ( b i ,u )+ weight ( u, v )+ SPDist ( v,b j ) &gt; SPDist ( b we do not update SPDist ( b i ,b j ) as we will not use ( u, v )to compute SPDist ( b i ,b j ); otherwise we recompute SPDist ( b
In this section we discuss how to use the G -tree to support directed graphs with a minor change. First, in the distance matrix, we keep the shortest distances of directed paths from a vertex to a border/vertex. We only need to slightly modify the pre-computation method in Section 5.2 to compute the Data Description # Vertices #Edges CAL California(Undirected) 21,048 21,693 SF San Francisco(Undirected) 174,956 223,001 COL Colorado(Undirected) 435,666 528,533 FLA Florida(Undirected) 1,070,376 1,356,399 E-USA East USA(Undirected) 3,598,623 4,389,057 C-USA Center USA(Undirected) 14,081,816 17,146,248 USA USA(Undirected) 23,947,347 29,166,672 WA Washington(Directed) 514,654 1,246,353 directed distances. Second, our method relies on using the assembly based algorithm to implement the SPDist func-tion. Nevertheless, the assembly based method still works for directed graphs based on the following reasons. (1) The closure property (Lemma 1) still holds for directed graphs, i.e., given a subgraph G = V , E , any directed path from u  X  X  to v/  X  X  must contain at least one border in B ( G ). (2) We can still use the dynamic-programming algorithm in Section 4.2 to compute the shortest distance of a directed path. Third, we slightly modify the Dijkstra algorithm to support the directed graphs. Datasets: We used eight real-world datasets with various sizes from 20,000 vertices to 24 million vertices. CAL con-sists of highways and main roads in California and SF con-tains detailed street networks in San Francisco 1 ,whichare widely used in previous studies [15]. COL , FLA , E-USA , C-USA and USA are road networks of USA 2 ,whichare composed of detailed streets, roads and highways. WA is the road network of a directed graph of Washington State 3 The statistics of these datasets is illustrated in Table 1. Query Sets: To evaluate the k NN search performance, we randomly chose 100 vertices as the query location, and for each query location we generated 100 groups of objects, thus we had 10,000 queries for each query set. For objects we uniformly selected 0.0001, 0.001, 0.01 , 0.05, 0.1 of vertices from the dataset as objects (the default value is 0.01). For k ,weused1,5, 10 , 20, 50 (the default value is 10). We compared with state-of-the-art methods SILC [23] and ROAD [15, 16]. SILC was implemented by ourselves and ROAD was provided by the authors. All the algorithms were implemented in C++. In G -tree , the default fanout is f =4and  X  is set to 64, 128, 128, 256, 256, 512 and 512 re-spectively for the first seven datasets. For implementing the SPDist function, as two naive methods were not scalable in space( O ( c |V| 2 )), we only used the assembly-based method. For SILC and ROAD , we used default settings as stated in the original papers and both were conducted under memory-based setting. All experiments were conducted on a Linux computer with Intel 2.50GHz CPU and 16GB memory.
G -tree has two parameters -fanout f and the number of vertices in a leaf node  X  . We tested the effect on the two parameters. We varied  X  in { 32, 64, 128, 256, 512 } and f in { 2, 4, 8, 16 } . We evaluated the number of borders, the index size, index build time, and the average k nearest neighbors search performance of 10,000 queries. We used the COL dataset. Figure 10 shows the results.

We made two observations. First, with the increase of f , the number of borders, the index size, the index build time and the query time first decreased and then increased. Our http://www.cs.fsu.edu/  X  lifeifei/SpatialDataset.htm http://www.dis.uniroma1.it/challenge9/index.shtml http://depts.washington.edu/giscup/roadnetwork method achieved the best results when f =4. Themain reasons are as follows. On the one hand larger fanouts will generate larger numbers of borders to partition a subgraph. On the other hand, larger fanouts will reduce the height of G -tree and the number of nodes that need to be partitioned.
Second, with the increase of  X  , the number of borders de-creased. This is because bigger  X  results in smaller tree size. Besides, the index size and construction time also decreased, as the index size depends on the number of borders. With the increase of  X  , the search time first decreased and then increased. Because if  X  is larger, it takes more time on the Dijkstra search in large leaf nodes; if  X  is smaller, it involves large numbers of borders. We selected  X  = 128 as a trade off between query efficiency and indexing size.
We compared our proposed method against state-of-the-art methods SILC [23] and ROAD [15, 16], in terms of in-dex overhead and k NN search time. Our method can pro-cess all datasets. Since ROAD and SILC took a mass of pre-processing time and consumed large amount of mem-ory, both schemes failed on E-USA , C-USA and USA .In addition, SILC also failed to run on FLA . For example, on E-USA , we estimated 4.8 days to be required for ROAD , and 36.5GB memory cost for SILC .
 Evaluation on Index Construction: We first evaluated the time and space overhead of indexing. Figure 11 illus-trates the index sizes and index build time.

We can see that G -tree outperformed ROAD and SILC in index build time and sizes. On COL , the index build time of G -tree was better than ROAD by an order of magnitude and nearly three orders of magnitude better than SILC .Forin-dexsizes,on COL , G -tree consumed 45.5 MB, ROAD took up 145 MB and SILC required 1535 MB. This is because the space overhead of SILC is O ( |V| 1 . 5 ) and it is rather ex-pensive to compute all-pair shortest paths. ROAD involved larger numbers of borders than our methods and needed to store shortest-path distances of all border pairs. Thus ROAD took more space and time than ours. Furthermore, G -tree only took 16.8 hours to build index on USA . Evaluation on k NN Search: We evaluated the k NN search efficiency of G -tree , ROAD and SILC by varying the num-ber of answers k , the number of objects |C| , datasets, and distances from query location to top-k answers. k NN Search by Varying k : We used the COL dataset and evaluated the average search time of 10,000 queries. We set |C| =0 . 01 |V| . Figure 12(a) shows the results.
We can see that G -tree outperformed the two state-of-the-art methods for different k , and even by 2-3 orders of magnitude for k  X  10. The main reason is as follows. Since SILC had to search multiple quadtrees to find distances be-tween query location and objects, this operation was very costly and inefficient for larger k .As ROAD employs an expansion-based method, it only pruned the nodes which have no objects and cannot use distance-based pruning. On (c) Index Size(MB). dataset, k =10 , 1% uniform vertices as objects). (c) Varying Datasets. Figure 12: Performance Comparison on k NN Search (
COL dataset, k =10 , 1% uniform vertices as objects). the contrary, G -tree used the SPDist function to prune un-promising nodes. Thus if k is larger, the improvement of G -tree over SILC and ROAD becomes larger too. k NN Search by Varying Object Sizes: We evaluated the k NN search performance by varying object sizes. We used the COL dataset. We generated five sets of objects with different sizes, where the sizes are respectively 0.0001, 0.001, 0.01, 0.05 and 0.1 of the number of the vertices in the dataset. Note that, we stopped at 0.1 as candidate objects are usually in small quantity compared with vertex size. We randomly generated 10,000 queries, set k = 10, and evaluated the average time. Figure 12(b) shows the results.

We made two observations. First, with the increase of the number of objects, the elapsed time of the three algorithms decreased. This is because for smaller number of objects, the objects are sparse and uniformly distributed in the dataset, and the average distance from the query location to the near-est neighbor tends to be larger. Thus the algorithms need to visit more vertices. Second, G -tree outperformed SILC and ROAD alot. With G -tree , we can directly locate the promising tree nodes and prune unpromising ones by best-first search, while this is what ROAD and SILC fail to do. Therefore, changing the sizes of objects has no significant effect on our G -tree . k NN Search by Varying Datasets: We tested the perfor-mance of three algorithms on four datasets CAL , SF , COL and FLA .Weset k =10 and |C| =0 . 01 |V| . Figure 12(c) shows the results. We can see that G -tree outperformed ROAD and SILC on every dataset. For example, on FLA , ROAD took about 1000 milliseconds, SILC cannot support this large road network as it consumed too much memory. G -tree only took 2 milliseconds. Notice that with the increase of the dataset size, the improvement of G -tree over SILC and ROAD becomes large, because G -tree can efficiently prune unnecessary subgraphs based on the SPDist function. k NN Search by Varying Object Distances: We generated four query sets based on the distances from the query location to the objects on COL dataset. We first computed the min-imum bounding box of the geometric coordinates for all the vertices on the dataset and then calculated the length of the diagonal line denoted by l d . Next, we generated four query sets where the distances of objects to the query location are tained 10,000 queries. The four query sets are respectively
Figure 14: Scalability on Performance of G -tree . called  X  near  X ,  X  far  X ,  X  farther  X ,  X  farthest  X . Figure 12(d) shows the results. We can see that G -tree significantly out-performed ROAD and SILC , even in 2-3 orders of magni-tude. SILC and ROAD achieved very poor performance since they had to traverse long distance paths before they accessed all top-k answers.
We evaluated the efficiency of our path-recovery algo-rithm. As ROAD cannot support path recovery 4 ,weonly compared with SILC . We used the same setting as the k NN search. The result is shown in Figure 13.

In the figure we show both the search time and the path recovery time. We can see that our algorithm can efficiently find the path. For example, on the FLA dataset, it only took 0.1 milliseconds. With the increase of the distance from the objects to the query location, the path recovery took more time as our method will access more vertices. However, Our method was still much better than SILC . We evaluated the time and space scalability of the G -tree . As the first seven datasets had various sizes, we evaluated the scalability using the first seven datasets. We set k =10 and |C| =0 . 01 |V| . Figure 14(a) shows the efficiency results.
In the ROAD paper, the authors did not discuss the path recovery issue. (a) On Add/Delete Vertices. Figure 15: Evaluation on G -tree Maintenance Cost.
We can see that G -tree scaled well as the data size in-creased from 0.01 million to 24 million. The average search time on the USA dataset 24 million vertices was only 20 mil-liseconds. Table 2 shows the space scalability of the G -tree . We can see that the index size of G -tree increased linearly with the increases of the data size.
 Table 2: Scalability on Index Sizes(MB) of G -tree . Size CAL SF COL FLA E-USA C-USA USA Data 1.13 11.7 28.0 70.8 244.3 990 1725 Index 1.34 22.4 45.5 109 425.5 1943 3184
We evaluated the scalability on the USA dataset by par-titioning the dataset into five equal-sized subgraphs. Then we merged 1, 2, 3, 4, 5 subgraphs to test the scalability. Figure 14(b) shows the results and G -tree scaled well.
We evaluated the G -tree maintenance cost for network updates by inserting/deleting vertices and edges. Figure 15 shows the results. Our method can efficiently support up-dates. For vertex updates, the average time was 10 millisec-onds on the FLA dataset. For edge updates, the average time was 200 milliseconds. Notice that it is a very hard problem to support edge updates [22]. As road networks are not updated frequently, the update time is acceptable.
We evaluated the search efficiency of G -tree on a directed graph WA .Weset f =4and  X  = 128. Table 3 shows the overview of the G -tree on dataset WA .

We compared the k NN performance with SILC and ROAD by varying k and object size |C| , as shown in Figure 16. G -tree still significantly outperformed existing methods. The results are consistent with those on undirected graphs.
In this paper we have studied the problem of k NN search on road networks. We proposed a balanced search tree struc-ture G -tree and devised an efficient best-first search algo-rithm on the basis of the assembly-based method. Exper-imental results show that G -tree significantly outperforms state-of-the-arts in terms of both efficiency and index sizes. Figure 16: Evaluation on Directed Graphs ( k =10 , 1% uniform vertices as objects).
