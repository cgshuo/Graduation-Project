 There has been fruitful research work on ef ficiently processing skyline queries [2,4,6,12,1,8] in database systems. However, current methods have only considered so-called min/max attributes like price and quality which a user wants to minimize or maximize. Actually, in addition to the min/max attributes, objects can also have spa-tial attributes like x, y coordinates that can be used to represent relevant constraints on the query results. Paper [7] distinguished these two types of attributes (attributes such as quality and price are called min/max attributes and attributes such as x and y are called spatial attributes) and proposed a new family of query types, neighborhood dom-inant queries (NHDQs), which consider the relationship between min/max and spatial attributes. One limitation of the paper is that they only consider to process queries with respect to one reference point. However, there are many applications that demand to consider multiple reference points at the same time. Moreover, in most of scenarios, the desired decisions are described with some qualifying boolean constraints, which specify what subsets of data should be considered valid.
 This paper studies the problem of MDMS skyline query (M ulti-D imensional M ulti-S ource skyline query), which optimizes skyline query with respect to multiple sources in the multi-dimensional space. We propose a new query evaluation model, called Bit-Structure , to answer MDMS skyline queries efficiently. We store compressed bit vector in the structure to capture our goal of respondi ng to multi-source and multi-dimensional analysis. Based on the BitStructure , we develop efficient query algorithms.
The rest of the paper is organized as follows. We give the problem statement and present challenges for processing it in Section 2. In Section 3, we present an overview of our solution, introduce the BitStructure data structure, and provide our query processing framework based on BitStructure . The experimental results are discussed in section 4. Section 5 surveys the related work and Section 6 concludes the paper. Let B beasetof boolean dimensions, D beasetof min/max dimensions, and S be a set of spatial dimensions of the dataset P . The three sets of dimensions are not neces-sarily exclusive. To ensure easier discussion later on in the paper, a min/max or spatial dimension is also called a preference dimension, and a tuple is also called a point. For the min/max attributes, we assume, without loss of generality, that users prefer minimal values.
 Definition 1. Given a point p  X  P , and a set of query points Q = { q 1 ,q 2 , ..., q n } in thespaceof S .The multi-source distance between p and Q is defined as: where dist ( p, q ) means the Euclidean distance between points p and q.
 Definition 2. Given two points p  X  P , p  X  P , and a set of query points Q = { q 1 ,q 2 , ..., q n p dominates p with respect to Q if: 1. p [ i ]  X  p [ i ] for all dimensions D i , D i  X  D , 1  X  i  X | D | . 2. MSDist ( p, Q )  X  MSDist ( p ,Q ) . 3. p [ i ] &lt;p [ i ] for at least one dimension D i , 1  X  i  X | D | or MSDist ( p, Q ) &lt; Problem Statement: Given a set of boolean predicates g i over dimensions in B in which 1  X  i  X  u (if not empty) and u is a positive integer, a set of query points Q = { q 1 ,q 2 , ..., q n } in the space of S , a MDMS skyline query with respect to Q returns the set Sky of those points in P which satisfy g i ,forall 1  X  i  X  u , and are not dominated by any other point of P .
 A straightforward approach to address MDMS skyline query is to, (1)materialize MSDists for each point in P ; (2)evaluate the skyline query using an existing method; (3)check for the boolean conditions and return the result. However, such an approach can be very expensive due to the fact that we need to compute MSDist for all points although we only need the skyline ones. In this section, we first specify the data structure of BitStructure , its block constructing and filtering, and then introduce our query processing framework based on it. 3.1 BitStructure Given a data set P , we assume that its first | B | attributes are the boolean attributes, the next | D | attributes are the min/max attributes and the remaining | S | attributes are the spatial attributes.
 Definition 3. Given a data set P ,asetof boolean attributes B = { B 1 ,...,B | B | } , and a set of preference attributes R = { R 1 ,...,R | R | } ,a BitStructure consists of |
B | materialized selection cuboids C S ( B cuboids bin R i (i= 1 ,..., | R | ).
 The BitStructure is efficient if the data set P is small. However, when P has a huge number of points, the BitStructure would be very large. The common method to the problem is to use a compact tuple ID list as an alternative. We choose to compress the bit vectors using the WAH compression method [17] to reduce the BitStructure size instead. 3.2 Block Constructing and Filtering We propose to generate a grid to speed up the processing of our queries. Instead of intersecting bins on all attributes and generating one unified grid, we intersect bins on min/max attributes and spatial attributes respectively and generate an asymmetrical grid: intersecting bins over min/max attributes and b S j ( j =1 ,...,y S ) over spatial attributes.
Note that in implementation, there is no need to generate a grid and materialize it. Since most of the blocks can be pruned during query processing even before they are constructed, we adopt the policy to construct blocks on-the-fly when needed. Once constructed, a block is assigned a block id . In addition, a block b in a N attributes space b li and b ui is the lower bound and upper bound value for the block along attribute i respectively.

To perform boolean filtering on b , we only need to intersect the bit vector of b with that of corresponding selection cuboids. 3.3 Query Processing Given a data set P , a set of boolean selections B , and a set of query points Q , our algorithm for processing MDMS skyline query consists of two phases: min/max search phase and spatial search phase. The intuition behind this two-phase query processing idea is that the intermediate result obtained in the first phase can be used to prune the search space of the second phase.
 Min/max Search phase: This phase searches the min/m ax space and returns a subspace skyline Sky D . The algorithm follows the branch-and-bound principle to progressively retrieve data blocks [12]. It consists three steps: pre-process, search, and evaluate (Al-gorithm 1). We briefly explain each step as follows. Having initialized the result set Sky D (line 1), the pre-process step computes the first candidate block and inserts it into the heap (line 2). The first candidate block corresponds to the block which has the smallest MinDist to the origin point o in the min/max space.

The search step finds the next candidate block for query processing. The blocks in the heap are ordered in ascending order of MinDist to the original point o . Initially, the heap only contains the first candidate block found in the pre-process step. Iteratively, the algorithm picks the top block b of the heap as the next candidate block and removes it from the heap (line 4). b is examined by the procedure DominatePrune() against the already computed skyline points (line 5). If the lower bound of block b in the min/max space is dominated by some point s  X  Sky D , all points in b can be dominated by s and b can be safely pruned.

Line 8 checks whether b is pruned by the boolean predicate. As discussed in Section condition and that of the block b . A temporal variable tempset is used to record those points that pass the dominate and boolean checking. The algorithm further retrieves all neighboring blocks of candidate block b and inserts them into the heap (line 9). Since each block can be neighboring with multip le blocks, a hash-table is maintained to ensure each block will only be inserted once.

Given the tempset computed in the search step, procedure ComputeBlockSkyline() in the evaluate step performs the task of computing the skyline for all points in tempset .If tempset is not empty, the algorithm first performs similar dominate pruning on all points in it against the already computed skyline points, and then does pair-wise Comparison to compute the skyline Sky . Sky is further merged into the final result Sky D (line 12). The algorithm terminates when there is no more blocks in the heap.
 Lemma 1. Given any point p  X  Sky D ,if p is non-duplicate in subspace D , p is a MDMS skyline point in the full space ( B  X  D  X  S ).
 P ROOF : Omitted for space limitation.
 Based on the lemma, we know that any non-duplicate skyline point in subspace D is a MDMS skyline point in the full sp ace. For those duplicate points in Sky D ,wefurther compare their MSDist to Q and then delete those points who have larger MSDists. From now on, we assume Sky D only including non-duplicate points.
 Spatial Search Phase: This phase searches the spatia l space and computes the final MDMS skyline Sky . Given the intermediate result Sky D returned in the first phase, we define two bound variables dist lb and dist ub as the minimal and m aximal MSDist over all points in Sky D . Based on this, we have the following lemmas.
 Lemma 2. Any block b can not contain a MDMS skyline point if: where R Q represents the minimum bounding rectangle (MBR) formed by points in Q . P ROOF : Omitted for space limitation.
 According to lemma 2, if the min imal distance between block b and R Q is greater than
Q | ,then b can be safely pruned. Lemma 2 incurs minimum overhead, since for every block it requires a single distance computa tion. However, as mentioned in [11], the condition is not very tight. It leads to unnece ssary block access. For example, assuming dist ub =7,since MinMinDist ( b, R Q ) =6 &lt;dist ub = 7, according to lemma 2, block b in Fig. ?? needs to be visited although it cannot contain MDMS skyline points. We presents a tighter bound to avoid such visits.
 Lemma 3. Any block b can not contain a MDMS skyline point if: P ROOF : Straightforward. Omitted.
 We will now explain how to employ lemma 2 and 3 to prune the spatial space, and how to get the final MDMS skyline. The pseudo code of Algorithm 2 is used to perform this task. The main differences between Algorithm 2 and Algorithm 1 lie in: (1)how to locate the first candidate block; (2)how to order candidate blocks in the heap; (3)how to do the dominant pruning; (4)how to compute the block skyline.

At the very beginning of Algorithm 2, we set the values for two bound variables, dist lb and dist ub . At the same time, we initialize another two variables Sky S 1 and Sky S 2 to be empty. Sky S 1 and Sky S 2 are used for computing the block skyline and will be explained later.

Recall in min/max space, the first candidate block is corresponding to the one that is closest to the origin. In contrast, in spatia l space, the block who has the most powerful pruning ability is the one that is nearest to Q . Therefore, we locate the first candidate block to be that whose centroid is nearest to all points in Q . For the same reason, in the heap, candidate blocks with nearer centroids to Q are ordered before blocks with farther centroids.
Now we explain how the procedure DominatePrune() works in the spatial space. If lemma 2 is satisfied (line 13-14), DominatePrune() returns value 1 which indicates that block b can be pruned safely. Otherwise, we need further check if lemma 3 is satisfied (15-16). Please note that once a block b is pruned, we need not consider the neighboring blocks of b any more. The reason is, for those neighboring blocks of b that are farther to Q than b is, they must satisfy the pruning condition also and can be pruned safely; for those neighboring blocks of b that are nearer to Q than b is, they must have been visited before since our block visiting order is from near to far.

Ifbothlemma2and3fail, DominatePrune() returns value 0 which means that b cannot be pruned and need to be processed further. Procedure ComputeBlockSkyline() is called to process those blocks that pass the dominate pruning and boolean filtering. For each point p  X  b , it can either be dominated by at least one point in Sky ,and therefore fails to affect Sky , or can not be dominated by any point in Sky and should become part of Sky itself. In that case, p might also dominate points currently in Sky , which must of course be removed. Therefore, Procedure ComputeBlockSkyline() in the spatial space must efficiently support two operations: first, checking whether a point p is dominated by the current Sky ; second, removing the points in Sky that are dominated by p . The ability of any technique to perform these two tasks can be augmented by utilizing the following observations.
 Lemma 4. Given any point p  X  P , if: then, p can not be dominated by any point p  X  P if p satisfies MSDist( p ,Q)  X  dist lb . P ROOF : Straightforward. Omitted.
 Lemma 5. Given any point p  X  P , p cannot dominate any point p  X  Sky D .
 P ROOF : Straightforward. Omitted.
 These lemmas imply that a number of points in Sky is irrelevant for the checking tasks. We divide all points in Sky into three separate subsets: Sky D , Sky S 1 ,and Sky S 2 .The last two subsets maintain skyline point s generated in the spatial search phase; Sky S 1 represents those points whose MSDists are smaller than dist lb ,and Sky S 2 represents those points whose MSDists are equal to or larger than dist lb . Thus, to do dominant checking, we only need to consider points in the corresponding subsets instead of the entire Sky . line 18-24 of Algorithm 2 summarizes the high level strategy that is em-ployed to keep Sky S 1 and Sky S 2 up to date. Please note that Sky D is only used for pruning here, and it will not change when the algorithm is proceeding.

Finally, Sky D , Sky S 1 and Sky S 2 are merged together to form the final skyline result. To evaluate the efficiency and scalability of our query processing algorithms, extensive experiments are conducted. In this secti on, we report only part of our results due to space limitation. All our experiments are conducted on a PC with an Intel Pentium IV 1.6GHz CPU and 1G main memory, running Microsoft Windows XP. Experiment results are reported on synthetic datasets. All run time reported here includes I/O time.
The default values of dimensionality is 6, data size is 100k, the number of query points in | Q | is 5. For simplicity, we used the same number of boolean dimensions, min/max dimensions and spatial dimensions. As an example, for 6 dimensions, we chose 2 dimensions as boolean dimensions, 2 dimensions as min/max dimensions, and the remaining 2 dimensions as spatial dimensions.

We compare our proposed query processing algorithm based on an asymmetrical grid (referred as ASYM MDMS ) against the following alternative methods: (1)Straight-forward method (referred as STR MDMS ) implemented using the method discussed in Section 2; (2)Query processing algorith m based on a symmetrical grid (referred as SYM MDMS ).

We randomly generate 100 different MDMS skyline queries. Each query has a num-ber n of points, distributed uniformly in the space of S . Figure 1(a) shows the aver-age run time of the three algorithms for answering a MDMS skyline query when n is increased from 2 to 7. Obviously, from the results, we can see that SYM MDMS out-performs STR MDMS . Among the algorithms, ASYM MDMS performs best as expected due to the asymmetrical partition for different types of attributes and the early pruning strategies applied in the spatial search phase.

Next, we look at the run time of three algorithms as the number of dimension in-creases from 3 to 12. Figure 1(b) depicts the experiment result. We observe that with increasing number of dimension, the runtime of STR MDMS and SYM MDMS increases more significantly than that of ASYM MDMS . This is again due to the fact that the prun-ingismoreeffectiveinthe ASYM MDMS approach.

Figure 1(c) shows run time of the three algorithms as the number of points in-creases from 20,000 to 100,000. From the results, we can see that the run time of both STR MDMS and SYM MDMS algorithms increases dramatically with respect to the size of data sets. However, the ASYM MDMS method increases modestly.

To evaluate possible impacts by different distributions of query points, we generate 100 different MDMS skyline queries with clustered query points. Figure 1(d) depicts the experiment result over two different query distributions ( Cluster and Random ) with different boolean selectivity. Since the trends are the same for all three algorithms, we only show the results of ASYM MDMS as it is the most efficient. Boolean selectivity determines the filtering power by boolean predicates and is defined as the number of points that pass the boolean checking as a proportion of | P | . We observe that Cluster outperforms Random . The difference between them increases with selectivity. This is because cluster query distribution has high possibility to generate a small | R Q | which results in effective pruning in spatial space. In this paper, we have introduced a novel type of skyline queries, so-called MDMS skyline queries, which optimizes skyline query with respect to multiple sources in the multi-dimensional space. Such queries suppor t a micro-economic approach to decision making, considering not only min/max attributes but also spatial attributes. We propose a new query evaluation model, called BitStructure , to answer MDMS skyline queries efficiently. Based on the BitStructure , we develop efficient query algorithms. Our exper-imental evaluation demonstrates that the proposed algorithms are efficient and scalable.
