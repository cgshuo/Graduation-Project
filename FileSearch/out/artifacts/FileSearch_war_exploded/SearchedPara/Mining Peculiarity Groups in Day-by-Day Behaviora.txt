
With the advance of data mining research and practice, the concept of data mining is also evolving. Data should not be viewed as isolated numbers or token; we actually mine behavior through the data [1], [2]. Behavior mining plays a critical role in many important areas and makes data mining more meaningful [1], [2], [3], [4], [5].

One of the most significant and popular studies in be-havior mining is the recognition of unexpected behaviors in datasets. A great amount of human behavioral data has been recorded in various computer systems, such as the stock trading system, traffic monitoring system, medical insurance system, and so on. In the real world, human daily life consists of behaviors performed by individuals day-by-day to achieve corresponding goals, while daily behavioral data are recorded in computer systems, which we call Day-by-Day Behavioral Data . As is well known, a lot of interesting knowledge is embedded in the day-by-day behavioral data. A. Background
Day-by-day behavioral data can reflect each object X  X  be-havioral pattern, which is usually performed by individual objects actively and separately. Generally speaking, one object performs individual behaviors instead of organized behaviors, while two or more objects might demonstrate organized features if they contain common behaviors on a sufficient number of identical dates. These objects are dramatically different from other individual objects and exhibit certain peculiarities. Hereafter, we refer to these objects as a Peculiarity Group and the ordered list formed by the common behaviors in chronological order as a Common Behavioral Pattern .

Peculiarity groups usually perform a series of common behaviors for certain organizations, such as financial fraud-ulence, terrorist crime and so on. It is a significant task for many departments, such as law-enforcing departments and supervisory authorities, to mine peculiarity groups from day-by-day behavioral datasets.

In this paper, we identify this interesting and practical problem: mining peculiarity groups in day-by-day behav-ioral datasets . Peculiarity groups can be found in a wide range of social areas. To appreciate the motive for pursuing the problem, consider the following application scenarios. Scenario 1. Mining price manipulation behaviors in the stock market
It is an important task for stock exchanges to discover the manipulation behaviors of the stock price. Obeying the trading rule  X  X +1 X  in the Chinese mainland stock mar-ket, each account X  X  daily transactions are recorded in the database, i.e., a day-by-day stock trading behavioral data for each account is constructed, which together form a day-by-day behavioral dataset. Since the trading volume of a private investor is restricted according to the rule, the broker would utilize multiple accounts to manipulate the prices in order to make profits. Therefore, these accounts usually perform the common behaviors like  X  X uying X ,  X  X ncreasing X ,  X  X nderweighting/decreasing X ,  X  X iquidation/selling X .
For example, some accounts performed common behav-iors ( { buying share C } on 11 March 2009, { buying share G , increasing share C } on 12 March 2009, { decreasing share G , increasing share C } on 13 March 2009, { selling share G } on 14 March 2009, { selling share C } on 15 March 2009), which form a common behavioral pattern: &lt; (11 March 2009, { buying share C } ), (12 March 2009, { buying share G , increasing share C } ), (13 March 2009, { decreasing share G , increasing share C } ), (14 March 2009, { selling share G } ), (15 March 2009, { selling share C } ) Note that the meaning is critically different if the behavior  X  X uying share C  X  occurs on a different date (i.e., the account O 1 buys share C on 11 March and O 2 buys share C on 12 March, but O 1 and O 2 will not contain a common behavior pattern).

In general, stock trading behaviors are mainly individual behaviors, therefore it is a peculiarity if there is a group of accounts which performs the common behaviors on a suffi-cient number of the same dates. This brings those accounts are under suspicion of manipulating the price of stock and they are regarded as peculiarity groups. Correspondingly, the supervisory authorities hope to find these accounts (i.e., peculiarity groups) in order to capture the evidence for supervising price manipulation events.
 Scenario 2. Mining criminal gang behaviors
In criminal cases employing automobiles as criminal tools, a criminal gang usually uses multiple automobiles during the preparation period before committing the crime; for example, in order to be familiar with the environment, check the location, and so on. In other words, multiple criminals X  automobiles will appear in same places on some same dates. Fortunately, behaviors such as the automobiles passing road-crossings or buildings will be recorded in the traffic monitoring system, and so the day-by-day behavioral data for each automobile is constructed, which together form a day-by-day behavioral dataset.
 Again, let us use an example to illustrate this problem. Automobiles O 1 , O 2 , O 3 appeared in the same places in five days: &lt; (11 April 2009, building D), (12 April 2009, hotel H), (13 April 2009, bridge B), (14 April 2009, hotel C), (15 April 2009, hotel H) &gt; , which is a common behavioral pattern they contain.

The appearance of an automobile in different places is generally an individual behavior; therefore, it is a pecu-liarity if there is a group of automobiles which appeared in the same places on a sufficient number of identical dates. Finding these automobiles (i.e., peculiarity group) will provide clues facilitate the detection of criminal cases by law enforcement departments.
 B. Problem Statement
The behaviors are recorded day-by-day and each object may perform zero, one or multiple behaviors on each day, therefore the behavioral data should be listed day-by-day, and daily behaviors with respect to each object should be recorded as a set of behaviors. Based on the above observa-tions, the day-by-day behavioral dataset can be formalized as the expression mode shown in Table I. It represents m objects X  daily behaviors in n days which are listed in chronological order. Note that each object X  X  daily behaviors form a set of the behaviors denoted as B , B = { ...,b i ,... } ( b i represents one behavior). It is possible that some objects have no any behavior on a minority of days, so B can be set to null (i.e., B =  X  ).

The day-by-day behavioral dataset is a novel data expres-sion mode for daily behavioral data. It is day-by-day, set-value-oriented, and the length of each row is equal, so it is not very well represented by other modes, such as the expression modes of sequence data or high dimensional data. 1). A sequence is an ordered list of non-empty item-sets [6]. It is not suitable to express empty set and day-by-day feature. 2). The length of each row in the high dimensional data is equal, but the dimensions are independent of the order. Therefore, the day-by-day behavioral dataset is not the traditional high dimensional dataset.

The peculiarity groups mining problem is to mine the peculiarity groups as in scenario 1 and scenario 2. Generally speaking, the objects in a peculiarity group possess orga-nized features, which differentiate them from other individ-ual objects. Peculiarity means that the objects conduct some common behaviors over several same days ( e.g. l days), these objects have a common behavioral pattern with length l . No matter how many the objects contain the common behavioral pattern, the larger l is, the stronger the degree of peculiarity will be. Therefore, the length of the common behavioral pattern can be regarded as a measurement of the degree of peculiarity. In fact, peculiarity groups mining aims to mine the common behavioral patterns which satisfy the degree of peculiarity and corresponding set of objects.
Because, as mentioned above, the peculiarity group is a peculiar phenomenon, the number of common behavioral patterns and peculiarity groups is relatively few. In respect of the peculiarity groups mining problem in day-by-day behavioral datasets, we propose the following hypothesis.
Hypothesis 1.1: Most objects act individually and sepa-rately in a day-by-day behavioral dataset, and would not have common behavioral patterns.

Corollary 1.1: The number of peculiarity groups is rel-atively few, and the objects within them are also few compared to the total number of objects. The behaviors in the common behavioral patterns are also few relative to all the behaviors in the dataset.
 In this paper, based on Hypothesis 1.1, we present the Peculiarity Groups Mining ( PGM ) problem, which is to mine the peculiarity groups in the day-by-day behavioral datasets. The problem is a novel and practical data mining problem. It clearly overlaps with work on traditional outlier mining, clustering mining and sequential pattern mining; however it is critically different from them. We will discuss the differences in Section II in detail.
 C. Our Contributions
Although of great potential, to the best of our knowledge, the problem of mining the peculiarity groups in the day-by-day behavioral datasets has not been explored before. In this paper, we tackle the problem and make several contributions.
The rest of the paper is organized as follows. The related work is reviewed in order to illustrate the critical differences between our problem and existing methods in Section II, and the PGM problem is formally presented in Section III. An algorithm for solving the problem is developed in Section IV, and the experimental evaluation using real datasets is reported in Section V. Section VI concludes the paper and discusses several interesting and promising directions for future work.

Behavior mining is an important problem in data mining and many algorithms have been presented [1], [2], [3], [4], [5]. However, with the development of behavior mining in more and more applications, there are still many challenging problems. The PGM problem is an interesting and important problem whose exploration will have practical value.
Firstly, from the aspect of the form, day-by-day behavioral data is a set-value-oriented high dimensional data. However, on one hand, set-value-oriented high dimensional data is seldom handled by existing methods; on the other hand, the meaning of the  X  X ate X  in day-by-day behavioral data is different from the general dimension ( e.g.  X  X ame X ,  X  X ge X ), because the  X  X ate X  is ordered chronologically. In the PGM, in particular, the number of  X  X ate X  records the length of the common behavior pattern to measure the peculiarity. But there is no such constraint on the  X  X imension X  of existing high dimensional data. Therefore the traditional expression of high dimensional data is not enough to represent day-by-day behavioral data.

Secondly, there is a clear distinction between the PGM problem and the traditional sequential pattern mining prob-lem [6], [7], [8], [9], although the common behavioral patterns of the group are required. Sequential pattern mining was first introduced by Agrawal and Srikant [6] as follows: find the complete set of those frequent patterns whose occurrences are no less than the minimum support threshold, where the support is the number of data sequences that contain the pattern . That is to say, the more frequently the pattern occurs, the better the pattern is. However, whether a pattern is a common behavioral pattern is unrelated to its frequency in our PGM problem. In fact, based on Hypothesis 1.1, the frequency of a common behavioral pattern is often not high. Furthermore, for effectiveness and efficiency con-siderations, constraint-based sequential pattern mining algo-rithms are presented. Pei et al. conducted a systematic study and classified the constraint into seven categories, including item, length, super-pattern, aggregate, regular expression, duration and gap constraints [10]. However the constraint  X  X he identical behavior should appear on the same date X  on the common behavioral pattern has not been covered.
Thirdly, an outlier is an observation that deviates so much from other observations as to arouse suspicion that it was generated by a different mechanism [11]. Some algorithms for outlier detection have been proposed [12], [13], [14] for high dimensional cases. The peculiarity group is an outlier relative to other individual objects; however, the peculiarity group is the set of objects instead of a single object in which the objects are dramatically different from other individual objects. It is a new type of outlier. Zhong and Yao et al. presented the peculiarity oriented mining problem and algorithms [15], [16], [17]. However these algorithms cannot be applied to the set-value-oriented data directly. Furthermore, unlike traditional outliers, the number of objects in the group is not restricted, and they contain a common behavioral pattern. Pei and Wang et al . presented a pattern-based clustering method to find the objects with a common behavioral pattern [18], [19]. They demanded that each object should have exactly one and at most one pattern in a subspace. But for the PGM problem aiming at the set-value-oriented data, an object may be assigned to multiple peculiarity groups because it perhaps has multiple patterns in a subspace. This case cannot be handled in [18].
In addition, the aim of PGM is different from clustering although the objects in the peculiarity group are similar to each other, which confirms the traditional definition of the cluster to some extent. Because, based on Hypothesis 1.1, the number of individual objects absent from the peculiarity group is more than those in the peculiarity group. Most objects (all individual objects) do not belong to any cluster, i.e., PGM will not gather all the objects into each cluster.
In conclusion, the PGM problem in the set-value-oriented day-by-day behavioral datasets is a new and interesting problem with broad applications. In this paper, we first tackle the problem and present an effective mining algorithm.
This section defines the basic concepts and formally introduces the problem of mining peculiarity groups.
Definition 3.1: ( behavior ) : A behavior is an event per-formed by an object, denoted as b . The object is denoted as O .

Let  X  = { b 1 ,b 2 ,...,b i ,...,b n } be a set of all the be-haviors, and  X  O= { O 1 ,O 2 ,...,O j ,...,O m } be a set of all the objects, where b i is a behavior and O j is an object respectively.

Example 3.1:  X  X uying share C  X  is an account O 1  X  X  a behavior and O 1 is an object.

Definition 3.2: ( one-day-behavioral-data ) :Asetofthe behaviors conducted by one object O in one day is defined as one-day-behavioral-data w.r.t the object O , denoted as B , B = { b 1 ,b 2 ,...,b i ,...,b k } , where b i is a behavior, B  X   X  .

Example 3.2: { buying share A , selling share C , increas-ing share G } is a one-day-behavioral-data w.r.t an account O 2 on 11 March 2009.

Given a date ( e.g. , 11 August 2011), the dates of n continuous days beginning from this date are denoted as 1,2,..., n .

Definition 3.3: ( day-by-day behavioral data ) : An ordered list of n one-day-behavioral-day w.r.t the object O on n days in day-by-day order is defined as a day-by-day behavioral data w.r.t the object O , denoted as S . S = &lt; (1 ,B 1 ) , (2 ,B 2 ) ,..., ( j, B j ) ,..., ( n, B n ) &gt; sents the j th day (1  X  j  X  n ) , B j = { b 1 ,b 2 ,...,b one-day-behavioral-data w.r.t object O on j th day ( B j can be null ) , ( j, B j ) is also called an element of the day-by-day behavioral data. n is the length of the day-by-day behavioral data.

A behavior can occur at most once in an element of a day-by-day behavioral data, but can occur multiple times in different elements.

Example 3.3: S = &lt; (11 March 2009, { buying share C } ) (12 March 2009, { buying share G , increasing share C } ) March 2009, { decreasing share G } ) &gt; is O 3  X  X  day-by-day behavioral data.

Definition 3.4: The set of m day-by-day behavioral data of length n beginning from the same start date is defined as a day-by-day behavioral dataset, denoted as D ( as shown in Table I ) .
 Definition 3.5: ( l -day behavioral pattern ) :Let S day behavioral data w.r.t an object O , then P = &lt; ( i 1 ,PB i a l -day behavioral pattern with respect to the object O ,if there exist integers 1  X  i j  X  n such that PB i j  X  B i j  X  n . l is called as the length of the pattern P , denoted as | P | = l . Correspondingly, we refer that the pattern P is contained by the object O .

Example 3.4: In Example 3.3, S is O 3  X  X  day-by-day behavioral data, then P = &lt; (11 March 2009, { buying share C } ) , (13 March 2009, { decreasing share G } ) &gt; is a 2-day behavioral pattern w.r.t O 3 ( i.e., | P | =2) , and we can say the pattern P is contained by the object O 3 .

Definition 3.6: ( common behavioral pattern ) :Givena day-by-day behavioral dataset D ,a l -day behavioral pat-tern P is a common behavioral pattern w.r.t the objects { O 1 ,O 2 ,...,O k } ( k  X  2) if P is contained by these objects { O 1 ,O 2 ,...,O k } respectively.

Definition 3.7: ( degree of peculiarity ) : The length of a common behavioral pattern P is defined as the degree of peculiarity, denoted as PF . The longer the common behavioral pattern is, the more peculiar the object group with the pattern will be.

Definition 3.8: ( peculiarity behavioral pattern ) :Givena degree of peculiarity threshold  X  , a common behavioral pattern P is a peculiarity behavioral pattern if the length of P is no less than  X  ( i.e., | P | X   X  ) .

Definition 3.9: ( peculiarity group ) : Given a peculiar-ity behavioral pattern P , the group of the objects { O 1 ,O 2 ,...,O k } is a peculiarity group if each object in { O 1 ,O 2 ,...,O k } contains the pattern P .

Definition 3.10: ( peculiarity groups mining ) :Givena day-by-day behavioral dataset D and a degree of peculiarity threshold  X  , the PGM problem is to find all common behavioral patterns and corresponding objects such that the degree of peculiarity is no less than  X  .

The Peculiarity Groups Mining algorithm is designed to find the peculiarity behavioral patterns and peculiarity groups in a day-by-day behavioral dataset. That is to say, if some objects perform common behaviors on a sufficient number of identical dates, then these common behaviors form a peculiarity behavioral pattern and corresponding objects form a peculiarity group. According to the definitions in Section III, the length of the peculiarity behavioral pattern should be no less than a degree of peculiarity threshold, so the patterns are too short to be meaningful for mining the peculiarity groups. Existing sequential pattern mining algorithms which use a bottom-up search strategy to generate long patterns from short patterns will produce a lot of short and redundant patterns, especially when the support thresh-old is low [20], [21], [22]. However, based on Hypothesis 1.1, a group of objects with the peculiarity behavioral pattern is a peculiar phenomenon, so the number of objects in such a group is usually relatively few, i.e., the pattern has relatively low support. Although some long pattern mining algorithms exist, they do not handle the constraint on the common behavioral pattern.

To avoid the generation of many meaningless short pat-terns, unlike existing algorithms which perform their search by enumeration of patterns, the PGM algorithm performs search by enumeration of object groups. That is, the PGM algorithm uses object extension strategy instead of pattern growth strategy.

Figure 1 illustrates the complete object group enumeration tree without any pruning strategies for a dataset shown in Table II. Each node in the tree represents a group of objects ` O, and P ( ` O) represents the common behavioral pattern with respect to the objects in ` O. For example, the node  X 12  X  represents the group of objects { O 1 ,O 2 } , along with it exhibits a common behavioral pattern P ( ` O)= &lt; { b 1 { b 6 }{ b 8 } &gt; .

The tree will contain many object groups without common behavioral patterns. These object groups can be pruned in advance. For this purpose, the core steps of the PGM algorithm are shown as follows. 1. Find the peculiarity object pairs (i.e., the peculiarity groups containing only two objects) and their peculiarity behavioral patterns (i.e., the length of the pattern is no less than  X  ); 2. Start with each peculiarity group containing k objects (for short, peculiarity k -object-group, k  X  2 ) to generate new potentially candidate object group containing k +1 ob-jects (for short, candidate k +1-object-group); 3. Compute the common behavioral pattern of the objects in candidate k +1-object-group, and then get the peculiarity behavioral pattern satisfying the degree of peculiarity thresh-old  X  (i.e., the length of the common behavioral pattern is no less than  X  ). Based on the peculiarity behavioral pattern, to generate the corresponding peculiarity k +1-object-group; 4. Processes 2 and 3 continue until no any new peculiarity group is found.

We need to specify two key details: 1. Candidate k +1-object-group generation: how candidate object-groups are generated. We want to generate as few candidates as possible while maintaining completeness. 2. The common behavioral patterns of the candidate k +1-object-groups computation.

The framework of the PGM algorithm is shown in Algo-rithm 1.
 Algorithm 1 PGM( D,  X  ) Input: D : the day-by-day behavioral dataset;  X  : the mini-Output: return the peculiarity groups in D : PG . 1: for i =1 to m  X  1 do 2: for j =1 to m do 3: OP ij =POP( O i , O j ,  X  ); 4: // function POP: to compute the peculiarity object 5: if OP ij =  X  then 7: end if 8: end for 9: end for 10: for k =3 ; PG k  X  1 =  X  ; k ++ do 11: CPG k = candidatePG( PG k  X  1 , X  ); 12: // function candidatePG: to generate candidate k -13: for all candidate group c  X  CPG k do 14: Compute the common behavioral patterns of the 15: PG k = { c  X  CPG k | the length of the common 16: end for 17: end for 18: return PG = k PG k Generating the peculiarity object pairs:
The day-by-day behavioral dataset and common behav-ioral pattern possess the following features: 1. The length of each day-by-day behavioral data in dataset is equal (i.e., the length is equal to n ); 2. The common behavioral pattern is the pattern in which identical behavior appears on the identical date; 3. The number of identical days with identical behaviors is no less than  X  .

Let S 1 and S 2 be two day-by-day behavioral data w.r.t the objects O 1 , O 2 respectively. If O 1 and O 2 have common behavioral pattern, then the length of the pattern should be no less than  X  . To decide whether the objects O 1 , O 2 would be the peculiarity pair, we should compare S 1 and S 2 . Based on the features mentioned above, a scan over S 1 and S 2 may be not from beginning to end (shown in Function 2 and Figure 2). Function 2 Computing the peculiarity object pair POP( O i ,O j , X  ) Require: O i , O j : the object pair in D ;  X  : the minimum Ensure: return the peculiarity object pair OP . 1: P =  X  ; 2: // S i and S j : the day-by-day behavioral data w.r.t the 3: l =0; // the number of matched days in S i and S j 4: for r =1 to n do 5: // n : the length of S i (or S j ) 6: len = n  X  r + l ;// ( n  X  r ): the length of unchecked 7: if len &lt;  X  then 8: OP =  X  9: return 10: // ( O i , O j ) is not a peculiarity object pair 11: else 12: if ( S i [ r ]  X  S j [ r ] =  X  ) then 13: l = l +1 ; 14: P [ l ]= S i [ r ]  X  S j [ r ] ; 15: end if 16: end if 17: end for 18: OP = { O i ,O j } ; 19: return OP
To illustrate the PGM algorithm more clearly, we will use some tables as a running example. Table II is the sample dataset. Table III is a peculiarity object pairs table, denoted POPT (Let  X  =4). In POPT, each tuple lists a pair of objects, along with the peculiarity behavioral pattern of objects in the pair.

We now focus our attention on the problem of how to generate the candidate object-groups.

We have generated all the peculiarity object pairs, that is to say, the peculiarity 2-object-groups have generated ( k =2). Now we need to get peculiarity k +1-object-groups. The PGM algorithm use the self-join and prune step to gen-erate candidate k +1-object-groups from peculiarity k -object-groups shown in the candidatePG function (see Function 3).
The candidatePG function takes as argument PG k  X  1 ,the set of all peculiarity k -1-object-groups. It returns a superset of the set of all peculiarity k -object-groups. The function works as follows. First, in the join step, we join PG k  X  1 with PG k  X  1 (shown in Function 3 1-4); Next, in the prune step, we prune some candidates using prune property (shown in Function 3 5-11).
 Function 3 Generating the set of the candidates Require: PG k  X  1 : the set of the peculiarity k -1-object-Ensure: return the set of the candidate k -object-group 1: insert in CPG k ; 2: select p [1] ,p [2] ,...,p [ k  X  1] ,q [ k  X  1] 5: for each c  X  CPG k do 6: for each ( k -1)-subset s of c do 8: delete c from CPG k ; 9: end if 10: end for 11: end for
In Function 3, the condition  X  p [ k  X  1] &lt;q [ k  X  1]  X  ensures that no duplicates are generated.

Note that the PGM problem aims at the dataset which contains the most individual objects, i.e., the peculiarity group is a peculiar phenomenon. Therefore the proportion of the objects in the peculiarity group is relatively low.
Example 4.1: Table IV shows that the set of the candi-date 3-object-groups CPG 3 generated from the set of the peculiarity 2-object-groups PG 2 according to the self-join step.

However the set of the candidate object-groups is the superset of the set of the peculiarity object-groups, and the objects in some candidates maybe have no peculiarity behavioral patterns. If we compute all of the candidates to get their common behavioral patterns in order to decide whether they would be the peculiarity groups, then owing to the number of candidates being very large, the amount of calculation will be large.

In order to decrease the calculation time, we should compress the search space. We need to decrease the number of candidates, that is to say, we should generate as few candidates as possible while maintaining completeness.
Property 4.1: Let BO be a set of k objects { O 1 ,O 2 ,...,O k } ,if BO is a peculiarity k -object-group, then each subset of BO k -1-object-group is a peculiarity k -1-object-group.
 Proof. Let SUB = { O 1 ,O 2 ,...,O k  X  1 } be a subset of and P be the common behavioral pattern of the objects { O 1 ,O 2 ,...,O k  X  1 } in SUB .

Assume that SUB is not a peculiarity k -1-object-group, then the length of P is less than  X  (i.e., | P | &lt; X  ).
Let Q be the common behavioral pattern of the object O k and the objects { O 1 ,O 2 ,...,O k  X  1 } in SUB , then Q  X  O and Q  X  P , so the length of Q , | Q | X | P | , i.e., | Q | &lt;  X  . Therefore, the common behavioral pattern Q in BO is not satisfying the threshold, i.e., BO is not a peculiarity k -object-group.

Based on Property 4.1, we can decide whether the can-didate in the set of the candidate object-groups would be a peculiarity group, that is to say, we can decide that if the subset of a peculiarity k -object-group is not in peculiarity 1-object-group, then the candidate k-object-group containing the k -1-subset is not a peculiarity group. Therefore we can prune the candidates based on Property 4.1 to decrease the number of candidate k -object-groups, and then the number of computation times are decreased. So in the prune step, we can delete all object-groups c  X  CPG k such that some ( k -1)-subset of c is not in PG k  X  1 (shown in Function 3 5-11).

Example 4.2: As shown in Table V, { O 2 ,O 3 ,O 5 } and { O 2 ,O 4 ,O 5 } are not the peculiarity groups and can be pruned, because { O 3 ,O 5 } , { O 4 ,O 5 } are not in the set of PG 2 . So we only need to compute the common behavioral patterns of the other five candidates to generate the pecu-liarity 3-object-group PG 3 .
 Computing the peculiarity behavioral patterns.
The common behavioral patterns of the candidate k -object-group derive from the common behavioral pattern of the peculiarity k -1-object-group and the k th object. Therefore, we can use the peculiarity behavioral patterns of the peculiarity k -1-object-group G ( { O 1 ,O 2 ,...,O and the other object O k not in G to generate the com-mon behavioral pattern of the candidate k -object-group ( { O 1 ,O 2 ,...,O k  X  1 ,O k } ). The computation method is sim-ilar to the method in the peculiarity object pair computing.
Example 4.3: The peculiarity 3-object-group is self-joined to generate the candidate 4-object-group CPG 4 : { O 1 ,O 2 ,O 3 ,O 4 } . { O 1 ,O 2 ,O 3 } is a peculiarity group ( see in Table V ) , then the common behavioral pattern of { O 1 ,O 2 ,O 3 ,O 4 } can be generated from the peculiarity pattern of { O 1 ,O 2 ,O 3 } and the object O 4 . We find the pattern satisfying the threshold  X  ,so { O 1 ,O 2 ,O 3 ,O a peculiarity group.

In this section we conducted the experiments to study the efficiency and effectiveness of our algorithm on real datasets. The implementations were in Visual C++. The experiments were conducted on a 2.1GHz Pentium and 4GB memory running the Windows Vista Business. One real dataset comes from the traffic monitoring dataset (for short, TMDateset ) in which the automobiles X  daily appearance behaviors at each monitor device are recorded, the other dataset is the Chinese-Medical-Insurance card usage dataset (for short, CMICDateset ) which contains the insured members X  card-usage behaviors in hospitals day-by-day. In the TMDateset , the length of the day-by-day behavioral data is 40, and there are 46,307 day-by-day behavioral data records. The number of behaviors within elements is 68. In the CMICDateset , the length of the day-by-day behavioral data is 100, and there are 152,790 day-by-day behavioral data records. The number of behaviors within elements is 708. There exist the peculiarity groups which are evidenced in practice. Note that the degree of peculiarity threshold  X  is set to the percent of the length of the day-by-day behavioral data in the following experiments. 1). The experimental results of scalability with the degree of peculiarity threshold  X  on both CMICDateset and TM-Dateset respectively is shown in Figure 3 (here the number of objects is set to 2,000). The lower the degree of peculiarity threshold is, the high the runtime of the PGM algorithm is. But when the threshold is close to the largest length of the peculiarity behavioral patterns, the runtime is almost stable. 2). Figure 4 shows the scalability of the PGM algorithm with respect to the number of objects on both CMICDateset and TMDateset (here the degree of peculiarity threshold is set to 20%). 3). The PGM algorithm uses the object-extension strategy considering that the length of day-by-day behavioral data n is always relatively long and the degree of peculiarity threshold is high. What is more, the occurrence of the peculiarity behavioral pattern in the objects of a peculiarity group is relatively few (i.e., the support is low). However, the pattern-extension method will generate a great amount of useless short patterns when the support is low. Figure 5 shows the runtime of the PGM algorithm and the pattern-extension method called PEM using prefix projection strat-egy on CMICDateset (here the number of objects is set to 1,000 and the degree of peculiarity threshold is set to 30%). When n is low, both are close in terms of runtime. However, as the length n increases, the gaps become clear. PGM is more efficient than the pattern-extension method PEM. 4). In China, each person has one medical-insurance-card provided by government X  X  medical insurance fund. The patient pays for medical services using his card. Some suspects plot fraud medical treatments together with some doctors to cheat medical insurance fund. Because there is a limitation sum of each card for each usage, one typical kind of medical-insurance-card fraud behavior is that one suspect gains the medical treatments using multiple cards in order to get as many drugs as he can. And then the suspect can sell these drugs to make profit.
 Figure 6 shows the resulting peculiarity groups from the CMICDateset dataset with respect to 6,000 objects and the degree of peculiarity threshold is 20% . In Figure 6, each row means that one peculiarity group in which the objects go to multiple hospitals to get medical treatment on a sufficient number of identical dates. The behavior is represented by the code of the hospital (like  X 359 X ). For example, the objects in G 4 have the peculiarity behavioral pattern &lt; 79, 85, 142, 79, 142, 79, (64,85), 93, (64,85), 79, (175,79), 79, 79, 79, 79, 79, 465, 79, 79, 79, 79, 85 &gt; , in which  X (175,79) X  illustrates that each object in G 4 went to multiple hospitals (i.e.,  X 175 X  and  X 79 X ) on one day (the 56 th day), i.e., each object X  X  daily behavior may be a form of set-value. On the other hand, because the suspects often plot together with their familiar doctors, the hospitals which they go are usually relatively changeless, i.e., the hospital codes are usually changeless (or some hospital codes often repeat several times). For example, there is only one hospital code  X 160 X  which occurs repeatedly in G 7 , i.e., the objects of G 7 can get lots of drugs in this hospital ( X 160 X ) to cheat the medical insurance fund.
In summary, our performance study shows that the PGM algorithm is efficient and practical in real world.
The famous Pareto principle (80-20 rule) states that, for many events, roughly 80 % of the effects come from 20 % of the causes; thus, the peculiarity groups mining problem finds a wide range of applications. In this paper, we defined a set-value-oriented day-by-day behavioral data which can express behavioral data in various areas and proposed a novel behavior mining problem, namely peculiarity groups mining based on the peculiarity behavior pattern. Further-more, as the first attempt to tackle the problem, we devised a peculiarity groups mining method aiming at the features on the dataset and problem. The experimental study on real data indicated that our method is efficient and practical.
Future work can be extended from several aspects: The research was supported in part by the National Grand Fundamental Research 973 Program of China under Grant No. 2005CB321905, Shanghai Leading Academic Discipline Project under Grant No. B114 and the Development Fund of Shanghai Science and Technology Commission under Grant No.08511500203. The authors would like to thank professor Jian Pei and professor Longbing Cao for their insightful comments and feedback.

