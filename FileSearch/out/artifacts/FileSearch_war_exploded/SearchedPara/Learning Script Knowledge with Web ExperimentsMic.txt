 A script is  X  X  standardized sequence of events that describes some stereotypical human activity such as going to a restaurant or visiting a doctor X  (Barr and Feigenbaum, 1981). Scripts are fundamental pieces of commonsense knowledge that are shared between the different members of the same cul-ture, and thus a speaker assumes them to be tac-itly understood by a hearer when a scenario re-lated to a script is evoked: When one person says  X  X  X  X  going shopping X , it is an acceptable reply to say  X  X id you bring enough money? X , because the SHOPPING script involves a  X  X ayment X  event, which again involves the transfer of money.
It has long been recognized that text under-standing systems would benefit from the implicit information represented by a script (Cullingford, 1977; Mueller, 2004; Miikkulainen, 1995). There are many other potential applications, includ-ing automated storytelling (Swanson and Gordon, 2008), anaphora resolution (McTear, 1987), and information extraction (Rau et al., 1989).

However, it is also commonly accepted that the large-scale manual formalization of scripts is in-feasible. While there have been a few attempts at doing this (Mueller, 1998; Gordon, 2001), efforts in which expert annotators create script knowledge bases clearly don X  X  scale. The same holds true of the script-like structures called  X  X cenario frames X  in FrameNet (Baker et al., 1998).

There has recently been a surge of interest in automatically learning script-like knowledge re-sources from corpora (Chambers and Jurafsky, 2008b; Manshadi et al., 2008); but while these efforts have achieved impressive results, they are limited by the very fact that a lot of scripts  X  such as
SHOPPING  X  are shared implicit knowledge, and their events are therefore rarely elaborated in text.
In this paper, we propose a different approach to the unsupervised learning of script-like knowl-edge. We focus on the temporal event structure of scripts; that is, we aim to learn what phrases can describe the same event in a script, and what con-straints must hold on the temporal order in which these events occur. We approach this problem by asking non-experts to describe typical event se-quences in a given scenario over the Internet. This allows us to assemble large and varied collections of event sequence descriptions (ESDs), which are focused on a single scenario. We then compute a temporal script graph for the scenario by identify-ing corresponding event descriptions using a Mul-tiple Sequence Alignment algorithm from bioin-formatics, and converting the alignment into a graph. This graph makes statements about what phrases can describe the same event of a scenario, and in what order these events can take place. Cru-cially, our algorithm exploits the sequential struc-ture of the ESDs to distinguish event descriptions that occur at different points in the script storyline, even when they are semantically similar. We eval-uate our script graph algorithm on ten unseen sce-narios, and show that it significantly outperforms a clustering-based baseline.

The paper is structured as follows. We will first position our research in the landscape of re-lated work in Section 2. We will then define how we understand scripts, and what aspect of scripts we model here, in Section 3. Section 4 describes our data collection method, and Section 5 explains how we use Multiple Sequence Alignment to com-pute a temporal script graph. We evaluate our sys-tem in Section 6 and conclude in Section 7. Approaches to learning script-like knowledge are not new. For instance, Mooney (1990) describes an early attempt to acquire causal chains, and Smith and Arnold (2009) use a graph-based algo-rithm to learn temporal script structures. However, to our knowledge, such approaches have never been shown to generalize sufficiently for wide coverage application, and none of them was rig-orously evaluated.

More recently, there have been a number of ap-proaches to automatically learning event chains from corpora (Chambers and Jurafsky, 2008b; Chambers and Jurafsky, 2009; Manshadi et al., 2008). These systems typically employ a method for classifying temporal relations between given event descriptions (Chambers et al., 2007; Cham-bers and Jurafsky, 2008a; Mani et al., 2006). They achieve impressive performance at extract-ing high-level descriptions of procedures such as a
CRIMINAL PROCESS . Because our approach in-volves directly asking people for event sequence descriptions, it can focus on acquiring specific scripts from arbitrary domains, and we can con-trol the level of granularity at which scripts are described. Furthermore, we believe that much information about scripts is usually left implicit in texts and is therefore easier to learn from our more explicit data. Finally, our system automat-ically learns different phrases which describe the same event together with the temporal ordering constraints.

Jones and Thompson (2003) describe an ap-proach to identifying different natural language re-alizations for the same event considering the tem-poral structure of a scenario. However, they don X  X  aim to acquire or represent the temporal structure of the whole script in the end.

In its ability to learn paraphrases using Mul-tiple Sequence Alignment, our system is related to Barzilay and Lee (2003). Unlike Barzilay and Lee, we do not tackle the general paraphrase prob-lem, but only consider whether two phrases de-scribe the same event in the context of the same script. Furthermore, the atomic units of our align-ment process are entire phrases, while in Barzilay and Lee X  X  setting, the atomic units are words.
Finally, it is worth pointing out that our work is placed in the growing landscape of research that attempts to learn linguistic information out of data directly collected from users over the Inter-net. Some examples are the general acquisition of commonsense knowledge (Singh et al., 2002), the use of browser games for that purpose (von Ahn and Dabbish, 2008), and the collaborative anno-tation of anaphoric reference (Chamberlain et al., 2009). In particular, the use of the Amazon Me-chanical Turk, which we use here, has been evalu-ated and shown to be useful for language process-ing tasks (Snow et al., 2008). Before we delve into the technical details, let us establish some terminology. In this paper, we dis-tinguish scenarios , as classes of human activities, from scripts , which are stereotypical models of the internal structure of these activities. Where EAT -describes a number of events, such as ordering and leaving, that must occur in a certain order in order ity. The classical perspective on scripts (Schank and Abelson, 1977) has been that next to defin-ing some events with temporal constraints, a script also defines their participants and their causal con-nections.

Here we focus on the narrower task of learning the events that a script consists of, and of model-ing and learning the temporal ordering constraints that hold between them. Formally, we will spec-ify a script (in this simplified sense) in terms of a directed graph G s = ( E s ,T s ) , where E s is a set of nodes representing the events of a scenario s , and T s is a set of edges ( e i ,e k ) indicating that the event e i typically happens before e k in s . We call G s the temporal script graph (TSG) for s .

Each event in a TSG can usually be expressed with many different natural-language phrases. As the TSG in Fig. 3 illustrates, the first event in the can be equivalently described as  X  X alk to the counter X  or  X  X alk up to the counter X ; even phrases like  X  X alk into restaurant X , which would not usu-ally be taken as paraphrases of these, can be ac-cepted as describing the same event in the context of this scenario. We call a natural-language real-ization of an individual event in the script an event description , and we call a sequence of event de-scriptions that form one particular instance of the script an event sequence description (ESD) . Ex-script are shown in Fig. 1.

One way to look at a TSG is thus that its nodes are equivalence classes of different phrases that describe the same event; another is that valid ESDs can be generated from a TSG by randomly select-ing phrases from some nodes and arranging them in an order that respects the temporal precedence constraints in T s . Our goal in this paper is to take a set of ESDs for a given scenario as our input and then compute a TSG that clusters different de-scriptions of the same event into the same node, and contains edges that generalize the temporal in-formation encoded in the ESDs. In order to automatically learn TSGs, we selected 22 scenarios for which we collect ESDs. We de-liberately included scenarios of varying complex-ity, including some that we considered hard to scenarios with highly variable orderings between narios for which we expected cultural differences (
We used the Amazon Mechanical Turk 1 to col-lect the data. For every scenario, we asked 25 peo-ple to enter a typical sequence of events in this sce-nario, in temporal order and in  X  X ullet point style X . We required the annotators to enter at least 5 and at most 16 events. Participants were allowed to skip a scenario if they felt unable to enter events for it, but had to indicate why. We did not restrict the participants (e.g. to native speakers).
In this way, we collected 493 ESDs for the 22 scenarios. People used the possibility to skip a form 57 times. The most frequent explanation for this was that they didn X  X  know how a certain sce-nario works: The scenario with the highest pro-portion of skipped forms was CREATE A HOME -the only one in which nobody skipped a form. Be-cause we did not restrict the participants X  inputs, the data was fairly noisy. For the purpose of this study, we manually corrected the data for orthog-raphy and filtered out forms that were written in broken English or did not comply with the task (e.g. when users misunderstood the scenario, or did not list the event descriptions in temporal or-der). Overall we discarded 15% of the ESDs.
Fig. 1 shows three of the ESDs we collected the example illustrates, descriptions differ in their starting points ( X  X alk into restaurant X  vs.  X  X alk to counter X ), the granularity of the descriptions ( X  X ay the bill X  vs. event descriptions 8 X 11 in the third sequence), and the events that are mentioned in the sequence (not even  X  X at food X  is mentioned in all ESDs). Overall, the ESDs we collected con-sisted of 9 events on average, but their lengths var-ied widely: For most scenarios, there were sig-nificant numbers of ESDs both with the minimum length of 5 and the maximum length of 16 and ev-erything in between. Combined with the fact that 93% of all individual event descriptions occurred only once, this makes it challenging to align the different ESDs with each other. We will now describe how we compute a temporal script graph out of the collected data. We proceed in two steps. First, we identify phrases from dif-ferent ESDs that describe the same event by com-puting a Multiple Sequence Alignment (MSA) of all ESDs for the same scenario. Then we postpro-cess the MSA and convert it into a temporal script graph, which encodes and generalizes the tempo-ral information contained in the original ESDs. 5.1 Multiple Sequence Alignment The problem of computing Multiple Sequence Alignments comes from bioinformatics, where it is typically used to find corresponding elements in proteins or DNA (Durbin et al., 1998).

A sequence alignment algorithm takes as its in-put some sequences s 1 ,...,s n  X   X   X  over some al-phabet  X  , along with a cost function c m :  X   X   X   X  R for substitutions and gap costs c gap  X  R for in-sertions and deletions. In bioinformatics, the ele-ments of  X  could be nucleotides and a sequence could be a DNA sequence; in our case,  X  contains the individual event descriptions in our data, and the sequences are the ESDs.

A Multiple Sequence Alignment A of these se-quences is then a matrix as in Fig. 2: The i -th col-umn of A is the sequence s i , possibly with some gaps ( X   X ) interspersed between the symbols of s , such that each row contains at least one non-gap. If a row contains two non-gaps, we take these symbols to be aligned ; aligning a non-gap with a gap can be thought of as an insertion or deletion.
Each sequence alignment A can be assigned a cost c ( A ) in the following way: c ( A ) = c gap  X   X  + where  X  is the number of gaps in A , n is the number of rows and m the number of sequences. In other words, we sum up the alignment cost for any two symbols from  X  that are aligned with each other, and add the gap cost for each gap. There is an algorithm that computes cheapest pair-wise alignments (i.e. n = 2 ) in polynomial time (Needleman and Wunsch, 1970). For n &gt; 2 , the problem is NP-complete, but there are efficient al-gorithms that approximate the cheapest MSAs by aligning two sequences first, considering the result as a single sequence whose elements are pairs, and repeating this process until all sequences are incor-porated in the MSA (Higgins and Sharp, 1988). 5.2 Semantic similarity In order to apply MSA to the problem of aligning ESDs, we choose  X  to be the set of all individ-ual event descriptions in a given scenario. Intu-itively, we want the MSA to prefer the alignment of two phrases if they are semantically similar, i.e. it should cost more to align  X  X xit X  with  X  X at X  than  X  X xit X  with  X  X eave X . Thus we take a measure of se-mantic (dis)similarity as the cost function c m .
The phrases to be compared are written in bullet-point style. They are typically short and elliptic (no overt subject), they lack determiners and use infinitive or present progressive form for the main verb. Also, the lexicon differs consider-ably from usual newspaper corpora. For these rea-sons, standard methods for similarity assessment are not straightforwardly applicable: Simple bag-of-words approaches do not provide sufficiently good results, and standard taggers and parsers can-not process our descriptions with sufficient accu-racy.

We therefore employ a simple, robust heuristics, which is tailored to our data and provides very shallow dependency-style syntactic information. We identify the first potential verb of the phrase (according to the POS information provided by WordNet) as the predicate, the preceding noun (if any) as subject, and all following potential nouns as objects. (With this fairly crude tagging method, we also count nouns in prepositional phrases as  X  X bjects X .)
On the basis of this pseudo-parse, we compute the similarity measure sim : where pred , subj , and obj are the similarity val-ues for predicates, subjects and objects respec-tively, and  X , X , X  are weights. If a constituent is not present in one of the phrases to compare, we set its weight to zero and redistribute it over the other weights. We fix the individual simi-larity scores pred , subj , and obj depending on the WordNet relation between the most similar WordNet senses of the respective lemmas (100 for synonyms, 0 for lemmas without any relation, and intermediate numbers for different kind of Word-Net links).

We optimized the values for pred , subj , and obj as well as the weights  X  ,  X  and  X  using a held-out development set of scenarios. Our exper-iments showed that in most cases, the verb con-tributes the largest part to the similarity (accord-ingly,  X  needs to be higher than the other factors). We achieved improved accuracy by distinguishing a class of verbs that contribute little to the meaning of the phrase (i.e., support verbs, verbs of move-ment, and the verb  X  X et X ), and assigning them a separate, lower  X  . 5.3 Building Temporal Script Graphs We can now compute a low-cost MSA for each scenario out of the ESDs. From this alignment, we extract a temporal script graph, in the following way. First, we construct an initial graph which has one node for each row of the MSA as in Fig. 2. We interpret each node of the graph as representing a single event in the script, and the phrases that are collected in the node as different descriptions of this event; that is, we claim that these phrases are paraphrases in the context of this scenario. We then add an edge ( u,v ) to the graph iff (1) u 6 = v , (2) there was at least one ESD in the original data in which some phrase in u directly preceded some phrase in v , and (3) if a single ESD contains a phrase from u and from v , the phrase from u directly precedes the one from v . In terms of the MSA, this means that if a phrase from u comes from the same column as a phrase from v , there are at most some gaps between them. This initial graph represents exactly the same information as the MSA, in a different notation.

The graph is automatically post-processed in a second step to simplify it and eliminate noise that caused MSA errors. At first we prune spu-rious nodes which contain only one event descrip-tion. Then we refine the graph by merging nodes whose elements should have been aligned in the first place but were missed by the MSA. We merge two nodes if they satisfy certain structural and se-mantic constraints.

The semantic constraints check whether the event descriptions of the merged node would be sufficiently consistent according to the similarity measure from Section 5.2. To check whether we can merge two nodes u and v , we use an unsuper-vised clustering algorithm (Flake et al., 2004) to first cluster the event descriptions in u and v sep-arately. Then we combine the event descriptions from u and v and cluster the resulting set. If the union has more clusters than either u or v , we as-sume the nodes to be too dissimilar for merging.
The structural constraints depend on the graph structure. We only merge two nodes u and v if their event descriptions come from different se-quences and one of the following conditions holds:  X  u and v have the same parent;  X  u has only one parent, v is its only child;  X  v has only one child and is the only child of  X  all children of u (except for v ) are also chil-
These structural constraints prevent the merg-ing algorithm from introducing new temporal re-lations that are not supported by the input ESDs.
We take the output of this post-processing step as the temporal script graph. An excerpt of the graph we obtain for our running example is shown in Fig. 3. One node created by the node merg-ing step was the top left one, which combines one original node containing  X  X alk into restaurant X  and another with  X  X o to restaurant X . The graph mostly groups phrases together into event nodes quite well, although there are some exceptions, such as the  X  X ollect utensils X  node. Similarly, the tempo-ral information in the graph is pretty accurate. But perhaps most importantly, our MSA-based algo-rithm manages to keep similar phrases like  X  X ait in line X  and  X  X ait for my order X  apart by exploiting the sequential structure of the input ESDs. We evaluated the two core aspects of our sys-tem: its ability to recognize descriptions of the same event ( paraphrases ) and the resulting tem-poral constraints it defines on the event descrip-tions ( happens-before relation ). We compare our approach to two baseline systems and show that our system outperforms both baselines and some-times even comes close to our upper bound. 6.1 Method We selected ten scenarios which we did not use for development purposes, five of them taken from the corpus described in Section 4, the other five from the OMICS corpus. 2 The OMICS corpus is a freely available, web-collected corpus by the Open Mind Initiative (Singh et al., 2002). It contains several stories (  X  scenarios) consisting of multi-ple ESDs. The corpus strongly resembles ours in language style and information provided, but is re-stricted to  X  X ndoor activities X  and contains much more data than our collection (175 scenarios with more than 40 ESDs each).

For each scenario, we created a paraphrase set out of 30 randomly selected pairs of event de-scriptions which the system classified as para-phrases and 30 completely random pairs. The happens-before set consisted of 30 pairs classified as happens-before , 30 random pairs and addition-ally all 60 pairs in reverse order. We added the reversed pairs to check whether the raters really prefer one direction or whether they accept both and were biased by the order of presentation. We presented each pair to 5 non-experts, all US residents, via Mechanical Turk. For the para-phrase set, an exemplary question we asked the rater looks as follows, instantiating the Scenario and the two descriptions to compare appropriately: For the happens-before task, the question template was the following: We constructed a gold standard by a majority deci-sion of the raters. An expert rater adjudicated the pairs with a 3:2 vote ratio. 6.2 Upper Bound and Baselines To show the contributions of the different system components, we implemented two baselines:
Clustering Baseline: We employed an unsu-pervised clustering algorithm (Flake et al., 2004) and fed it all event descriptions of a scenario. We first created a similarity graph with one node per event description. Each pair of nodes is connected with a weighted edge; the weight reflects the se-mantic similarity of the nodes X  event descriptions as described in Section 5.2. To include all input in-formation on inequality of events, we did not allow for edges between nodes containing two descrip-tions occurring together in one ESD. The underly-ing assumption here is that two different event de-scriptions of the same ESD always represent dis-tinct events.

The clustering algorithm uses a parameter which influences the cluster granularity, without determining the exact number of clusters before-hand. We optimized this parameter automatically for each scenario: The system picks the value that yields the optimal result with respect to density and distance of the clusters (Flake et al., 2004), i.e. the elements of each cluster are as similar as possible to each other, and as dissimilar as possi-ble to the elements of all other clusters.

The clustering baseline considers two phrases as paraphrases if they are in the same cluster. It claims a happens-before relation between phrases e and f if some phrase in e  X  X  cluster precedes some phrase in f  X  X  cluster in the original ESDs. With this baseline, we can show the contribution of MSA.

Levenshtein Baseline: This system follows the same steps as our system, but using Levenshtein distance as the measure of semantic similarity for MSA and for node merging (cf. Section 5.3). This lets us measure the contribution of the more fine-grained similarity function. We computed Leven-shtein distance as the character-wise edit distance on the phrases, divided by the phrases X  character length so as to get comparable values for shorter and longer phrases. The gap costs for MSA with Levenshtein were optimized on our development set so as to produce the best possible alignment.
Upper bound: We also compared our system to a human-performance upper bound. Because no single annotator rated all pairs of ESDs, we con-structed a  X  X irtual annotator X  as a point of com-parison, by randomly selecting one of the human annotations for each pair. 6.3 Results We calculated precision, recall, and f-score for our system, the baselines, and the upper bound as fol-lows, with all system being the number of pairs la-belled as paraphrase or happens-before , all gold as the respective number of pairs in the gold standard and correct as the number of pairs labeled cor-rectly by the system.
The tables in Fig. 4 and 5 show the results of our system and the reference values; Fig. 4 describes the paraphrasing task and Fig. 5 the happens-before task. The upper half of the tables describes the test sets from our own corpus, the remainder refers to OMICS data. The columns labelled sys contain the results of our system, base cl describes the clustering baseline and base lev the Levenshtein baseline. The f-score for the upper bound is in the column upper . For the f-score values, we calcu-lated the significance for the difference between our system and the baselines as well as the upper bound, using a resampling test (Edgington, 1986). The values marked with  X  differ from our system significantly at a level of p  X  0 . 01 ,  X  marks a level of p  X  0 . 1 . The remaining values are not signifi-cant with p  X  0 . 1 . (For the average values, no sig-nificance is calculated because this does not make sense for scenario-wise evaluation.)
Paraphrase task: Our system outperforms both baselines clearly, reaching significantly higher f-scores in 17 of 20 cases. Moreover, for five scenarios, the upper bound does not differ sig-nificantly from our system. For judging the pre-cision, consider that the test set is slightly biased: Labeling all pairs with the majority category ( no paraphrase ) would result in a precision of 0.64. However, recall and f-score for this trivial lower bound would be 0.

The only scenario in which our system doesn X  X  CHINE , where the upper bound is not significantly better either. The clustering system, which can X  X  exploit the sequential information from the ESDs, has trouble distinguishing semantically similar phrases (high recall, low precision). The Leven-shtein similarity measure, on the other hand, is too restrictive and thus results in comparatively high precisions, but very low recall.

Happens-before task: In most cases, and on average, our system is superior to both base-lines. Where a baseline system performs better than ours, the differences are not significant. In four cases, our system does not differ significantly from the upper bound. Regarding precision, our system outperforms both baselines in all scenarios
Again the clustering baseline is not fine-grained enough and suffers from poor precision, only slightly better than the majority baseline. The Lev-enshtein baseline gets mostly poor recall, except for ANSWER THE PHONE : to describe this sce-nario, people used very similar wording. In such a scenario, adding lexical knowledge to the sequen-tial information makes less of a difference.
On average, the baselines do much better here than for the paraphrase task. This is because once a system decides on paraphrase clusters that are essentially correct, it can retrieve correct informa-tion about the temporal order directly from the original ESDs.

Both tables illustrate that the task complexity strongly depends on the scenario: Scripts that al-low for a lot of variation with respect to ordering larly challenging for our system. This is due to the fact that our current system can neither represent nor find out that two events can happen in arbitrary order (e.g.,  X  X ake out pan X  and  X  X ake out bowl X ).
One striking difference between the perfor-mance of our system on the OMICS data and on our own dataset is the relation to the upper bound: On our own data, the upper bound is almost al-ways significantly better than our system, whereas significant differences are rare on OMICS. This difference bears further analysis; we speculate it might be caused either by the increased amount of training data in OMICS or by differences in lan-guage (e.g., fewer anaphoric references). We conclude with a summary of this paper and some discussion along with hints to future work in the last part. 7.1 Summary In this paper, we have described a novel approach to the unsupervised learning of temporal script in-formation. Our approach differs from previous work in that we collect training data by directly asking non-expert users to describe a scenario, and then apply a Multiple Sequence Alignment algo-rithm to extract scenario-specific paraphrase and temporal ordering information. We showed that our system outperforms two baselines and some-times approaches human-level performance, espe-cially because it can exploit the sequential struc-ture of the script descriptions to separate clusters of semantically similar events. 7.2 Discussion and Future Work We believe that we can scale this approach to model a large numbers of scenarios represent-ing implicit shared knowledge. To realize this goal, we are going to automatize several process-ing steps that were done manually for the cur-rent study. We will restrict the user input to lex-icon words to avoid manual orthography correc-tion. Further, we will implement some heuristics to filter unusable instances by matching them with the remaining data. As far as the data collection is concerned, we plan to replace the web form with a browser game, following the example of von Ahn and Dabbish (2008). This game will feature an algorithm that can generate new candidate scenar-ios without any supervision, for instance by identi-fying suitable sub-events of collected scripts (e.g. inducing data collection for PAY as sub-event se-
On the technical side, we intend to address the question of detecting participants of the scripts and integrating them into the graphs, Further, we plan to move on to more elaborate data structures than our current TSGs, and then identify and repre-sent script elements like optional events, alterna-tive events for the same step, and events that can occur in arbitrary order.

Because our approach gathers information from volunteers on the Web, it is limited by the knowl-edge of these volunteers. We expect it will per-form best for general commonsense knowledge; culture-specific knowledge or domain-specific ex-pert knowledge will be hard for it to learn. This limitation could be addressed by targeting spe-cific groups of online users, or by complementing our approach with corpus-based methods, which might perform well exactly where ours does not. Acknowledgements We want to thank Dustin Smith for the OMICS data, Alexis Palmer for her support with Amazon Mechanical Turk, Nils Bendfeldt for the creation of all web forms and Ines Rehbein for her effort with several parsing experiments. In particular, we thank the anonymous reviewers for their helpful comments.  X  This work was funded by the Cluster of Excellence  X  X ultimodal Computing and Inter-action X  in the German Excellence Initiative.
