 Parsing-based search ,i.e.,parsingkeywordsearchqueriesusinggram-mars, is o X en used to override the traditional  X  X ag-of-words X  se-manticsinwebsearchandenterprisesearchscenarios.Comparedto the X  X ag-of-words X  X emantics,theparsing-basedsemanticsisricher and more customizable. While a formalism for parsing-based se-mantics for keyword search has been proposed in prior work and ad-hocimplementationsexist,theproblemofdesigninge X ciental-gorithmstosupportthesemanticsislargelyunstudied.Inthispaper, we present a suite of e X cient algorithms and auxiliary indexes for thisproblem. Ouralgorithmsworkforabroadclassesofgrammars usedinpractice,andcoveravarietyofdatabasematchingfunctions (set-and substring-containment, approximate and exact equality) and scoring functions (to  X lter and rank di X erent parses). We for-mally analyze the time complexity of our algorithms and provide anempiricalevaluationoverreal-worlddatatoshowthatouralgo-rithmsscalewellwiththesizeofthedatabaseandgrammar.
 H. X . X [ InformationStorageandRetrieval ]:InformationSearchand Retrieval X  Information Filtering Parsing;KeywordSearch;E X ciency
Overthepastfewyears,internetsearchtechnologyhasprogressed farbeyondthetraditionalbag-of-wordsretrievalframework.Inpar-ticular,forsomewebsearchqueries, parsing-based semantics isem-ployedto X  X arse X  X hequeryusingsomerulesorgrammarandsome underlying database of facts, and this parse in X uences the search output. As a simple example, for the query seattle to redmond , typical search engines use rules to identify that the query matches  X  location  X  to  X  location  X  since seattle and redmond arebothpresent in a location table. is parse, once identi X ed, may then be con-sumed by a map application which displays a map with directions alongsidethesearchresults. e parse of a query provides clues to possible user intentions be-hindthequery. Forinstance,aquery  X  business  X  customer support presumably looking for customer support contact information for a speci X c business. A better understanding of the user intentions allows the search system to customize the output to a query [ X  X ,  X  X ],e.g.,showamapofdrivingdirectionsordisplaycontactinfor-mation. ( X ) A parsing-based approach allows the query to contain non-contentterms(e.g., from, to ),combinedataandschematerms (e.g., best buy phone ), and relate content both inside and outside of X  X oinpaths X (e.g., godfather brando  X  X atchingasinglerowin a movie-actor relation versus new york to scottsdale  X  match-ing multiple rows in a location relation); such queries are hard to supportinkeywordsearchoverdatabasesthatinterpretsallsearch termsascontentarisingfromsomerowinthedatabase. override the bag-of-words retrieval framework and provide inter-netuserswithbetterorenhancedsearchresults. Infact,priorwork has shown that search results where such enhanced information is provided have an order of magnitude higher user satisfaction rate thanthosewithout[ X  X ]. Tothebestofourknowledge,however,the implementationsofthesesemanticsaread-hoc,andtherehasbeen noformalstudyofthee X ciencyoftheparsing-basedsemanticsfor internetkeywordsearch.

Parsing keyword search queries is equally relevant in enterprise keyword search over databases [ X  X ]. Previous work at IBM on the Avatarprojectforenterprisesearch[ X  X , X  X ]usedheuristicstoparse keywordsearchqueriestoagrammar.Morerecently,Faginetal.[ X  X ] providedaformalbasisfortheproblemofansweringqueriesusing a(particularinstanceof)parsing-basedsemantics,andshowedthat the problem admits a polynomial time (in input and output size) solution. Whilethisresultcontainskeyinsightsintothetheoretical complexityoftheproblem,Faginetal.[ X  X ]didnotproposee X cient algorithmsorindexesfortheproblem.Fore X cientkeywordsearch, indexing techniques that avoid repeated scans of the entire input databasetoansweraqueryarecritical. e central goal of this paper is to develop e X cient query answering algorithms to support parsing-based keyword search.

Our techniques are general; in particular, we study how the fol-lowingdimensionsimpactthee X ciencyofourapproach. (Forour illustrations throughout, we use the Tables  X  and  X  as the database overwhichsearchisperformed.)  X . Grammar: Acentralcomponentofqueryparsingisthegrammar that speci X es how queries are parsed. We consider a rich class of grammarsthatcanbelooselycharacterizedasaregularexpression over database concepts (columns) and special keywords (e.g., to , from ). Anexample X  X attern X  X s  X  Product  X  vs  X  Product  X  ,whichcan be used to parse the query quiet comfort vs quiet point , given rows P  X  and P  X . While this is desirable in some cases, it is some-times useful to constrain matches to arise from the same row. Our patterns support relational constraints to express such constraints: In the pattern,  X  Store  X  Location  X   X  phone , the common superscript  X  indicatesthatmatchesfor Store and Location shouldarisefromthe same row. e pattern would parse the query bose tucson phone , butnotthequery bose glendale phone ,givendatainTable X a. is pattern captures the intention  X  X hone number of a store at a given location X  X etterthanthepatternwithoutrelationalconstraints.  X . Matching: To parse a query, we need to determine if a particu-lar phrase in a query matches a value in the database. Given that keywordqueriesaretypicallyshortandincomplete,requiringexact matcheswouldnotberobust.Wethereforefocuson set containment asa matching function todeterminematches,whichiswidelyusedin traditionalkeywordsearch.Wealsoconsiderandpresentresultsfor otherwell-knownmatchingfunctionssuchasapproximateequality andsubstringcontainment.  X . Scoring: Again,tobeabletohandleshortandimprecisequeries, weworkwitharelaxedde X nitionofaparsethatcanskipoverand  X  X over X  only a subset of query terms. With this relaxed de X nition, o X en a query can be parsed in a multitude of ways. In this setting, it is important to be able to capture preferences for one parse over an other. A natural preference is to prefer parses that cover more querytermstoparsesthatcoverless. Weconsiderageneralclassof scoringfunctionstoexpresssuchpreferences,andthisclassincludes well-knownsequentialmodelssuchasCRFsandHMMs[ X  X ].

Designinge X cientalgorithmsforthegeneralclassofgrammars, matching,andscoringfunctionsthatweconsiderischallenging. In practice, adatabasecancontain X  X  X softablesandgrammarmight beadisjunctionof X  X  X  X sofpatterns. Toillustratesomechallenges, consideranapproachforthisproblembasedonconstructingan X  X x-panded X  X rammar.Forexample,wecouldexpandtherule  X  Product  X   X  Product  X  by replacing each  X  Product  X  with all possible values fromthe Product columninthedatabase(wetemporarilyignoreis-suesarisingfromnon-equalitymatching). Atraditional X nitestate automatoncanbebuiltforthisexpandedgrammarandusedtoparse queries.Infact X  X swedemonstrateinthefullversionofthispaper X  thespacerequiredforthisapproachcanbeformallyshowntobeim-practicablylarge.Moreover,priorwork[ X  X ]hasempiricallyveri X ed thatsuchapproachesperformpoorlyinpractice.

In developing e X cient techniques to parse keyword queries, we needtoaddressthefollowingquestions:  X  How do we represent and store the grammar, and how is this representationconsultedwhileparsing? egrammarmaybevery large.Howdoweavoidparsingeachofthepatternsinthegrammar individually,andhowmayweenableparsingwhilesharing X  X artial X  parsesbetweenpatterns? Howdowemaintainthesepartialparses (potentiallyalargenumber)compactly?  X  Whichdatastructuresorindexesdoweneedtoavoidrepeated scansoftheentiredatabase?Whatisthemoste X cientwayofmatch-ing,withorwithoutrelationalconstraintsforvariousmatchingfunc-tions? In some queries, there may be noise tokens or misspelled words. Howdoweeliminatetheblowupthatoccurswithconsider-ingallsubsetsofkeywordswhilematching?Atwhatstageofparsing shouldweperformmatching?  X  How do we adapt our techniques to be e X cient for di X erent scoring functions (i.e., those that score or rank complete parses  X  suchasCRFandHMM)anddi X erentmatchingfunctions(i.e,equal-ityorapproximateequalityandstringcontainment)?Isthereaclas-si X cationoffunctionsforwhichwecanbemoree X cient? Howdo wedesignourinfrastructuretobeabletoseamlesslysupportmore patterns,ordi X erentmatchingorscoringfunctions? Our Solution: e solution that we propose in based on a general extensiblearchitectureofthreemodulesthatwecall  X ltering , ing ,and matching . Oursolutionusesa non-deterministic  X nite state automaton (NFA) over database concepts. For a given query, the matchingmoduleidenti X esphrasesinthequerythatmatchwitha valueinthedatabaseandthestitchingmoduleusestheinputfrom the matching module to traverse the NFA and identify parses with a high score. e  X ltering module uses various heuristics to prune theNFAtominimizetheworkdonebythematchingandstitching modules. Inadditiontoe X cientalgorithmsforthesemodules,one of our contributions is the architecture itself: the clean separation andthepreciseinterfacethatwedevelopbetweenthematchingand stitching modules enables us to relatively easily extend our frame-worktosupportanewmatchingfunctiongivenanindexing X  X racle X  forthefunction.
 E X ciencyandQuality: ee X ectivenessofanysearchsystemhinges ontwoaspects(a)thee X ciencyofthesearchsystem, whichisour focus, and (b) the quality of the retrieved search results. Broadly, quality refers to how good the system is in  X  X nderstanding X  user queries and returning relevant results. In a parsing-based system, the choice of the grammar used to parse queries, the choice of the scoring function used to rank queries, and the actions performed once the parse is identi X ed, all impact the quality of the output re-sults. esechoicesinturndependonthetargetapplication. Con- X guring the system for best quality for a speci X c application is a goal of this paper. ere exists a large body of work on related problems [ X ,  X  X ,  X  X ] that can be leveraged for this purpose and this continuestobeanactiveareaofresearch. eresultsinthispaper are application-independent and orthogonal to the work on improving quality , and we believe most techniques for con X guring a parsing-basedsearchsystemforqualitywouldbene X tfromourstudyofper-formancerelatedaspects.
 Outline of the paper: InSection X ,weformallypresenttheseman-ticsofparsing-basedkeywordsearchandtheproblemofanswering queries under this semantics. We present our techniques in Sec-tion X andevaluatethemempiricallyinSection X . Wecoverrelated workinSection X beforeconcluding.
Inoursystem,thepreprocessinginputconsistsofadatabaseover which keyword search is is to be performed, and a grammar that speci X estheparsing-basedsemanticsofkeywordsearch.Ourgoalis todesignalgorithmsandindexstructurestosupporte X cientpars-ing of keyword search queries over the database for the semantics speci X ed by the grammar. roughout, we use D and G to denote theinputdatabaseandgrammar,respectively. edatabaseconsists ofacollectionoftableswithtextcolumns.Forsimplicity,weassume thatcolumnnamesareunique. Foracolumn C ,weuse Table ( C ) denotethe(unique)tablethatcolumn C ispartof. that we call non-terminals . Informally, a non-terminal represents the unit of  X  X atching X  against the database while parsing queries. esimplestnon-terminalsareoftheform  X  C f  X  , where C isacol-umninthedatabaseand f denotesa matching function usedtode- X ne the notion of a match. A matching function has the signature string  X  string  X  { true,false } .Examplematchingfunctionsinclude exactandapproximatestringequalityandstringcontainment(de- X ned subsequently). More generally, a non-terminal is of the form  X  C tion;the  X  i valuesaresymbolscalled relational variables thatencode relational constraints : Informally, the matches for all columns withthesamerelationalvariableshouldcomefromthesamerecord inthedatabase. Forrelationalconstraintstobemeaningful,were-quire that Table ( C i ) = Table ( C j ) whenever  X  i =  X  non-terminalsinvolvingasinglecolumnas basic non-terminals those involving relational constraints relational non-terminals the following, we drop the matching function subscripts when the functionsareclearfromcontextornotrelevanttothediscussion.
Example  X . Foroursampledatabase,anexampleofabasicnon-terminalis  X  Store  X  andexamplesofrelationalnonterminalsare  X  nonterminal  X  Store  X  Address  X   X  wouldnotbevalidsince Store belong to di X erent tables. An example of a grammar is the regular expression  X  Product  X  +  X  Store  X  ?  X  Category  X  .  X  We introduce relational nonterminals for two reasons: First, it is a precise way of specifying relational constraints. Second, as we dis-cuss in Section  X . X , the set of columns in a relational nonterminal form a natural unit, since columns connected by a relational con-straintneedtobecollectively X  X atched X  X gainstthedatabase.
Wedonotexplicitlymodelkeywordconstantssuchas phone and structingadummysinglecolumntablewithasinglerowcontaining theconstant.
 fyingzeroormore parses ofagivenquery. Weassociatea score with eachparse, computedusinga scoring function . eoutputconsists ofparsessuitablyrankedand X lteredusingtheirscores.

For the purposes of de X ning the semantics, we view all strings asasequenceof tokens . Inourexamples, weusewhitespaceasde-limiterstode X netokens,butourtechniquesareindependentofthe Table X :Examplequeriesandtheirbestparse(correspondingtothe least valueofnoise) tokenization scheme. Given a token sequence q = t  X  ,...,  X   X  a  X  b  X  n ,the token interval q [ a , b ] isde X nedtobethesubse-quence t a ,..., t b . Whentheoriginalsequence q isclearfromcon-text, we use interval [ a , b ] as a shorthand for q [ a , vals I  X  = [ a  X  , b  X  ] and I  X  = [ a  X  , b  X  ] , we say Given I = [ a , b ] ,wede X ne I . start  X  a and I . end  X  b For the rest of this section, assume a query q = t  X  ,..., formally de X ne the notion of a match for a non-terminal. A token interval [ a , b ] is a match for a basic non-terminal  X  C D contains a value v in column C such that f ( q [ a , b ] , e following example introduces a couple of matching functions andillustratesmatching.

Example  X . Giventwotokensequences q and v ,thesetcontain-ment function f  X  ( q , v ) = true if every token in q occurs in false otherwise. e equality function f = ( q , v ) = true i X  are identical. Let q denote query Q  X  in Table  X . e intervals nonterminal  X  Store f  X   X  . However, nonterminal  X  Store f onematchinginterval, [  X , X  ] .  X 
A match for a (relational) nonterminal  X  C  X   X   X  f  X  ... C quenceofintervals I  X  &lt; ... &lt; I m suchthatthereexistrows in database D satisfying ( r i = r j ) whenever  X  i =  X  j  X   X  j  X  m , f j ( q [ I j ] , r j [ C j ]) = true. Here, r j jectionofrow r j oncolumn C j .Notethatthisde X nitiongeneralizes thede X nitionofamatchforbasicnonterminals.

Example  X . Considerthenonterminal  X  Company  X  , Product  X  let f  X  bethematchingfunctionforbothcolumns. ecommonre-lationalvariable X impliesthatamatchforthetwocolumnsshould come from the same record of ProductInfo. Let q denote query Q X  (Table  X ). e interval sequence [  X , X  ] , [  X , X  ] is a match for sincethereexistsrecord P  X suchthat q [  X , X  ] (i.e., audio technica ) is contained in P  X  [ Company ] and q [  X , X  ] ( quiet ) is contained in P  X  [ Product ] . On the other hand [  X , X  ] , [  X , X  ] is not a match: al-though q [  X , X  ] ( quiet comfort )iscontainedinthe Product the match involves two records, P  X  and P  X , violating the relational constraint.  X  Given a match M =  X  I  X  ,..., I m  X  for a nonterminal  X  C C betheinterval [ I  X  . start , I m . end ] . Notethat Extent est interval containing the intervals I  X  ,..., I m in M . We note that theabovede X nitionisvalidevenformatchesofbasicnonterminals; however, for such matches M , Extent ( M ) is trivially the single in-tervalin M .
 De X nition  X . ( parse ) A parse of a query q using a grammar de X ned as a sequence of nonterminals N  X  ... N m and matches ..., M m correspondingtothenonterminalssuchthat:  X . Extent ( M  X  ) &lt; ... &lt; Extent ( M m ) Wedenotethisparse  X  N  X   X  M  X  ,..., N m  X  M m  X  .

Example  X . Consider query Q  X  in Table  X  and let G be the dis-junction of regular expression patterns in Table  X . Let f  X  matchingfunctioneverywhere.Aparseforthisqueryis:  X  X  X  Product [  X , X  ] ,  X  Product  X   X  [  X , X  ] X  . e sequence  X  Product  X   X  fromthepattern  X  Product  X  + .Similarly,aparsefor Q  X is  X  X  X  [  X , X  ] ,  X  Address  X   X  [  X , X  ] X  .Asthisexamplesuggests,aparseneednot be X  X erfect X  X ndtherecouldbetokens(e.g., from, tp )inthequery notcoveredbytheparse.  X  ere could be several parses for a given query and it is useful in asearchsystemtocapturepreferencesforsomeparsesoverothers. Such preferences can be used to suitably  X lter or rank parses that arereturnedtotheuser. Inthispaper,weconsider scoring functions to express such preferences. A scoring function assigns a numeric score to a parse, with a higher score indicating greater preference. We denote the score returned by a scoring function F for query andparse P using F ( q , P ) .

Whilethescoresofparsescanbeusedinavarietyofwaysto X lter andrankthem,forpresentationalsimplicity,intherestofthepaper, werestrictourselvestotheproblemofidentifyingtheparsewiththe highest score. Our techniques can be generalized to other ranking and X lteringsettings.

Foranarbitraryscoringfunction,wecannotdobetterthanenu-meratingandscoringallparsestoidentifythebestone. Weidentify andstudytwogeneralclassesofscoringfunctionscalled linear and coverage-based whichadmitmoree X cientapproaches.

De X nition  X . Consider a parse P = N  X   X  M  X  ,..., N m  X  M a query q . A scoring function F ( q , P ) is linear if it can be ex-tion,thefunction F ( q , P ) is k -thorderlinearifitcanbeexpressed as  X  e overall score of a linear function is a sum of  X  X ocal X  contribu-tionsforeachnonterminalintheparse,wherethelocalcontribution foranonterminaldependsonlyonthematchforthenonterminal. For k -thorderlinearfunctions,thelocalcontributiondependsalso ontheprevious k nonterminalsintheparse. Notethatstandardse-quentialmodelssuchasHMMsorCRFs[ X  X ]are X rst-orderlinear.
Givenquery q = t  X  ,..., t n andparse P ,wesayatokenis covered if it is contained in some interval in some match in P . For De X -Cov ( q , i , P ) = trueif t i iscoveredby P ,falseotherwise. De X nition  X . Consider a parse P for a query q and let Cov ( q , i , P ) denotethecoverageindicatorfunction.Ascoringfunc-tion F ( q , P ) is coverage-based if it is of the form  X  e overall score of a coverage-based function (herea X er, simply a coverage function )isthesumofpositiveindividualtokencontribu-tions,consideringonlytokensthatarecoveredbytheparse.Wecan showthateverycoveragefunctionisalinearfunction.

Example  X . A simple coverage function is the number of tokens covered in a parse. In the rest of the examples, coverage function implicitlymeansthisfunction. Withthisfunction,thescoreforthe  X   X . Itisalsousefultoconsiderthe noise ofaparse,de X nedtobethe numberoftokensnotcoveredbytheparse.Table X provides(within parenthesis)thenoisevalueofthebestparseforeachquery.  X  us,weaddressthefollowingprobleminthispaper:
P  X  X f X u X   X . Given a grammar G , a database D and a scoring function F , design algorithms and index structures for the following task at query time: On being given query q, determine the parse such that F ( q , P ) is maximized.

Although we focus mostly on parsing, the full output of a query consists of the parses and the database records that contribute to each parse. With this de X nition, we can verify that parsing-based keywordsearchgeneralizesbag-of-wordskeywordsearch. parsing-basedkeywordsearchproblemintroducedinSection X . In particular,wepresentalgorithmsfore X cientlyidentifyingthebest parseforagivenquerystring;thedetailsofindexingstructuresthat we build at preprocessing time is embedded in the description of theparsingalgorithms. Fortheremainderofthissection,assumea database D ,agrammar G ,alinearscoringfunction F ,andaquery string q = t  X  ,..., t n . (Our techniques work for k -th order linear functionswithminormodi X cations.)Webeginwithanoverviewof ouralgorithmsbeforepresentingthedetails. ulescalled matching and stitching ;thestitchingmoduleisthemain queryprocessingmodulethatinvokesmatchingfromwithinit.Con-ceptually,wemayviewthematchingmoduleasourinterfacetothe database D ,whilethestitchingmoduleisourinterfacetothegram-mar G . e scoring function F impacts our use of both matching andstitching, sincewemayusethenatureof F tosharecomputa-tion. ( iswillbecomeclearlateron.) classical regular expression parsing: It uses an NFA Q that repre-sents(apartof)grammar G ,andtraverses Q basedonthematches identi X edbythematchingstep. estitchingmoduleusesthescor-ingfunctiontoprunetraversalsguaranteednottoproducethebest parse. e matching module identi X es matches for nonterminals in grammar G . All access of data in D is con X ned to the matching module, which contains indexes for e X cient data access. Some of the logic of scoring parses is  X  X ushed X  into the matching step and the set of the matches returned by the matching module is not an exhaustiveenumeration.

A third module, called  X ltering is invoked in the beginning be-fore control passes on to stitching. Informally, this step starts with the  X  X riginal X  NFA Q orig corresponding to the entire grammar and uses the input query q to produce a pruned NFA Q , which is input to the stitching step. e pruned NFA Q has the property that any parse of q in Q orig is also a valid parse in Q . e  X ltering module is optional for correctness but important for e X ciency, es-peciallywhengrammar G islarge. Duetospaceconsiderations,the description of the  X ltering module is omitted and can be found in theextendedtechnicalreport[ X  X ].
Figure X illustratestheoverviewofouralgorithm. Everythingin-side the dotted rectangle indicates query time computation while everything outside indicates data structures built at preprocessing time. erestofthissectiondescribeseachthesemodules. uleisaccessedfromthestitchingmoduleformatchingportionsof thequerytoaspeci X cnonterminal. ing module for a speci X c nonterminal N is F  X  X o M Z X h X u X  ( Essentially, this function returns matches M for a nonterminal that start at a and end before b , for all pairs of locations However,thisstepcanbeveryexpensivesincethenumberofsuch matches M canbeexponentialin n .Instead,wedesignF  X  X o M Z X h X u X  toreturnatmost  X  n  X   X  matches:forallmatches M thathavethesame Extent ( M ) ,itreturnsthematchwiththelargest g ( q , N ,
BeforeweintroducethesecondinterfaceF  X  X o M Z X  M Z X h X u X  ,we will X rstde X neanimportantconcept. Ifthematchingfunctionsat-is X esanaturalpropertytermed monotonicity ,thematchingmodule willbemuchmoree X cient(aswewillseesubsequently).

De X nition  X . Let u and v = xuy betokensequencessuchthat u asubsequenceof v .Amatchingfunction f is monotonic if f ( truewhen f ( v , w ) = trueforanytokensequence w .

Example  X . e containment function f  X  is monotonic, since if v is contained in w , any subsequence u of v is also contained in e subsequence function is another example: if v is a subsequence of w ,thenanysubsequenceof v isalsoasubsequenceof w .
 Whenthenonterminalisbasic,andwhenthematchingfunctionis monotonic,thenthematchingmoduleadditionallysupportsanin-terfaceF  X  X o M Z X  M Z X h X u X  ( q , N ) . isinterfaceprovidesatmost matches M ,orderedbytheirstartpositions. Eachofthesematches is maximal , i.e., they are not contained in any other matches of Itiseasytoshowthatwhenthematchingfunctionforabasicnon-terminal is monotonic, there can be at most one maximal match beginningateachlocation a .
 In the next section, we will see how F  X  X o M Z X h X u X  and F  X  X o -M Z X  M Z X h X u X  arecalleduponbythestitchingmoduleasneeded. Wenowdiscussmatchingforabasicnonterminal N =  X  C f  X  . Recall that the match for N is an interval [ a , b ] such that f true for some value v in column C . Natural matching functions f include f = (equality), f  X  (set containment), f subs (substring con-tainment [ X  X ]), f jacc (approximate equality using jaccard), and (approximate equality using edit). ese are all well-known func-tionsthathavebeenusedinsimilarproblemsettingssuchasrecord matching[ X  X ]andsegmentation[ X  X ].

For most of these functions f , even the simpler problem of ver-ifying for a  X xed sequence u , whether there exists a value such that f ( u , v ) = true is nontrivial when the number of distinct values in C is large and is the subject of prior research [ X  X ]. In the following,werefertoanyalgorithmforthisveri X cationproblemas an oracle for f . Given an oracle for f , a straightforward algorithm for F  X  X o M Z X h X u X  is to invoke the oracle for each of the vals. We can o X en do better: For f = , the Aho Corasick algorithm provides a linear algorithm; prior work has studied designing e X -cient algorithms for f jacc [ X ] and f edit [ X  X ]. We leverage this prior workformatchingalgorithmsfor f = , f jacc ,and f edit .
We do not know of any prior matching algorithm for f  X  and we presentanalgorithmforthiscase  X  X nfact,thisalgorithmgeneral-izestoanyothermonotonicfunction f byreplacingthecallstothe containmentoraclewithcallstoanoraclefor f . isalgorithmuses O ( n ) setcontainmentoraclecallstoidentifyallmaximalmatching intervals and therefore provides an implementation of F  X  X o M Z X  -M Z X h X u X  .To X ndallmatches(F  X  X o M Z X h X u X  ),wesimplyconsider all interval [ l , r ] isamatchinginterval,weincrement r ,otherwise,in-crement l .Whenwe X ndamatchingmatch [ l , r ] ,weaddittotheset ofmaximalmatches maxMatches andremoveanypreviouslyadded interval [ l , r  X   X  ] from maxMatches .Foranymaximalinterval wecanshowthat l doesnotcross a until r reaches b and r doesnot cross b until l reaches a , implying that we correctly identify asamaximalmatchinginterval.

Example  X . Considermatching nonterminal  X  Address  X  from Ta-ble X bfor q = 1 south capitol avenue 392 havelock road .Since eachoftheintervals, [  X , X  ]( 1 ) , [  X , X  ]( 1 south ) ,..., capital avenue ) iscontainedin Address ,thealgorithmreachesthe state l =  X , r =  X withasinglemaximalmatch [  X , X  ] . Subsequentin-l =  X , r =  X .We X ndanothersequenceofmatchingintervals [  X , X  ]  X  ] , [  X , X  ] resultinginthesecondmaximalmatch [  X , X  ] atwhichpoint thealgorithmterminates.
 Forthesetcontainmentoracle,weusetheimplementationproposed in[ X ].Wecanfurtherexploitthefactthatsubsequentcallstotheor-acledi X erbyexactlyonetokentoimprovethee X ciencyoftheora-cle; asimilar optimizationhas beenproposed by[ X ] inthe context ofsegmentation.
 We now discuss matching for a relational nonterminal N =  X  C press some natural patterns, e.g., the pattern  X  Company  X  Product  X  (information about a speci X c product sold by a company) or the pattern  X  Movie  X  eater  X   X  (informationaboutmovieshowtimesata giventheater).

For simplicity, we assume that all columns share the same rela-tional variable, i.e.,  X   X  = ... =  X  m =  X  , meaning that all columns C belongtothesametable(called T )ofthedatabase. Withthisas-sumption, a match for N is a sequence of intervals [ a  X  , [ a m , b m ] suchthat [ a i , b i ] matches r [ C i ] ( i  X  [ r  X  T . We discuss details of handling nonterminals with multiple relational variables in the full version of the paper. Unlike basic nonterminal matching, we do not know of prior work that can be directlyusedformatchingrelationalnonterminals.

Tobeabletoenforcerelationalconstraints,weassumethatoracles forcolumnlevelmatchfunctions f i returnsortedrecordidenti X ers ( rid-lists ). e naive algorithm enumerates every possible interval clefor f i withsequence q [ a i , b i ] ,andmergestherid-listsreturned bythecolumnoracles. esequence M isavalidmatchifthereisa commonrecord r commontoallrid-lists. isalgorithmcanbeex-pensivesincethereare X  ( n  X  k ) possibleintervalsequences.Wenext presentamoree X cientalgorithmthatgeneralizesthealgorithmfor basic nonterminals for the case where all matching functions are monotonic.

Let m =  X (i.e., N isabasicnonterminal)andconsiderthefollow-ingalgorithmtoenumerateallmaximalmatchesof N . Weoperate in n stepsandatstep l wegeneratemaximalmatchesstartingatpo-sition l (ifoneexists). Wehaveathandallmaximalmatchesfound so far that contain l . Let us call this set Overlap ( l ) tervalweareseekingismaximal, itmustcontainatleastonepoint outsideeachoftheaboveintervals;thatis,thenewmaximalinterval startingat l (ifoneexists)must hit thecomplementsofeachinter-valin Overlap ( l ) .Let r denotetherightmostpointofanyintervalin Overlap ( l ) . enwecanshowthat [ l , r +  X  ] istheunique hitting interval for Overlap ( l ) , implying that any maximal interval startingat l shouldcontain [ l , r +  X  ] . ereforewecanidentifythis intervalby X  X rowing X  X heinterval [ l , r +  X  ] totheright.Wecanshow that the algorithm sketched above is identical to the algorithm for basicnonterminals. weconstructmaximalmatchesintheorderoftheirstartpositions. ese start positions are m -dimensional and ordered lexicograph-ically. We seek a minimal interval sequence with the current start position  X  a  X  ,..., a m  X  that hits the complements of each maximal match found so far overlapping  X  a  X  ,..., a m  X  . We illustrate an ex-ampleinFigure X forthecase m =  X . ereare X maximalinterval  X  a , b  X  (also marked in the  X gure). Unlike the single dimensional case,wecannotidentifyauniqueendpositionthatisoutsideallthe abovemaximalmatches. us,wecanconstructthehittinginterval sequencestartingat  X  a  X  ,..., a m  X  inmultipleways. elastlocation correspondingto a i canbeseteitherto a i itselforto I i . thesequence  X  I  X  ,..., I m  X   X  Overlap ( X  a  X  ,..., a m  X )  X rst dimension of the end position of the hitting set is a the tokens in R , while the second dimension is b or one of the to-kensin S . Acrossthedimensions,weconsiderallcombinationsand  X nd a minimal hitting set which is then grown in each dimension. Weformalizethecomplexityoftheabovealgorithmbythefollow-ingtheorem. ealgorithmcanbefoundintheextendedtechnical report[ X  X ].

T  X u X  X u X   X  (H  X  X  X  X  X  X  S u X  A  X  X  X  X  X  X  X  X  ). e algorithm described above  X nds all m-dimensional maximal matches in O ( mn m c oracle calls, where c is the maximum number of maximal matches containing a token.
 Typically c isasmallconstant,thusthecomplexityisdominatedby n . Unfortunately, for relational matching, we cannot avoid being exponentialinthedimensionalitythroughthefollowingresult.
T  X u X  X u X   X  (L  X  X u X  B  X  X  X o ). In the worst case,  X nding a rela-tional match for a nonterminal N =  X  C  X   X  f oracle calls. As described in Section  X . X , the NFA Q is either the original NFA Q orig corresponding to G or a pruned NFA produced by the  X lter-ing module. For now, we assume that Q = Q orig . In other words,  X lteringisnotused.
 WedescribehowwegeneratetheNFA Q fromtheinputgrammar G ,notingthatthisstephappensonlyonce,thattooatpreprocessing time. e NFA Q that we generate has the following three proper-ties: ( X ) the transition edges of the NFA are nonterminals in the set of nonterminal sequences accepted by Q is exactly the set ofnonterminalsequencesin G ,and( X )thereareno  X  -transitionsin Q . WecanconstructsuchanNFAusingstandardalgorithms[ X  X ], whileensuringthatthenumberofstatesin Q islinearinthesizeof G andthenumberoftransitions,quadraticinthesizeof G . Figure X  showspartoftheNFAcorrespondingtopatterns X and X inTable X . We X rstpresentageneralalgorithmforstitchingthatworksforany linear function; subsequently, we present a more e X cient special-izedalgorithmthatcanbeusedwhenthegrammar G satis X essome conditions.
 egeneralstitchingalgorithmusesdynamicprogrammingtocom-pute,foreverystate s inNFA Q andeveryposition p  X  [  X , n ] query q ,thescoreofthebestparseforthepre X x t  X  ,..., t p thatends bestparsefor t  X  ,..., t p thatendsinstate s involvesanoptimalparse for some t  X  ,..., t p  X  ( p  X  &lt; p ) that ends in a state matchforanonterminal N thatcanbeusedtotransitionfrom s  X  to s inNFA Q . Formally: where we range over all s  X  , p  X  , N , M such that p  X  &lt; Q .

Edges , M isamatchfor N , Extent ( M ) . Start = p  X  and Extent End &lt; p . Recallthat g isthe X  X ocal X  X unctionofthelinearfunction F (seeDe X nition X ).

We incorporate two improvements over the naive dynamic pro-gramming algorithm suggested by Equation  X . First, we compute the valueof thesecond termin Equation X  for everypossible value of
N , p  X  , p . We can show that this improves the e X ciency of dy-namicprogrammingsincethesecondtermdoesnotdependon s  X  . Formally,wecompute: Wenotethat bmScore [ N , p  X  , p ] isthebestscoreofamatchfornon-terminal N thatstartsatposition p  X  andendsbefore p . Wecannow rewriteEquation X as: wherewerangeover s  X  , p  X  ,and N asbefore.

Second,tocompute bmScore [ N , p  X  , p ] ,weneedtoiterateoverall matches M fornonterminal N thatstartat p  X  andendbefore p stepcanbeexpensivesincethenumberofmatchesforanontermi-nalcanbeexponential.AsdescribedinSection X . X ,forthis,wepush Algorithm  X  Parseusingcoveragefunctionformonotonicmatching functions somescore-based X lteringintothematchingstep.Insteadofreturn-ing all matches for N , F  X  X o M Z X h X u X  returns at most  X  n thatdominateallothers.

Detailedalgorithmsareomittedduetospacelimitationsandmay befoundintheextendedtechnicalreport[ X  X ].
 Time and space complexity: e time complexity of the algo-rithm described above depends on the matching step. We showed in Section  X . X  that the time complexity of each F  X  X o M Z X h X u X  call is
O ( outputsize ) = O ( n  X  ) , ignoring a one-time processing cost, which depends on the matching function and the kind of nonter-minal (basic vs relational) being matched. e time complexity of dynamicprogramming is O ( En  X  ) where E = S Q . Edges S isthenum-ber of edges in NFA Q . To compute bmScore , we perform O work for each nonterminal N and the number of nonterminals is bounded by E . us, the overall time complexity of the algorithm is O ( En  X  ) . espacecomplexityis O ( Sn ) ,where S = S Q . the number of states in NFA Q , since we use O ( n ) space for each statein Q .
 Wepresentamoree X cientstitchingalgorithmforthecoveragescor-ing function when the matching functions for all the columns are monotonic (see De X nition  X ) and all nonterminals are basic (non relational). eideaspresentedhereareapplicableevenwhenonly a subset of columns use monotonic matching functions and even whenonlyasubsetofnonterminalsarebasic. esedetailsareomit-tedduetospaceconsiderations.
 Likethepreviousalgorithm,themoree X cientalgorithm(called P Z X  X u CM X  X eeAlgorithm X )usesdynamicprogramming. Forev-ery position p  X  [  X , n ] and state s , we compute the best parse of t ,..., t p endinginstate s . Tosimplifyourpresentation,weusethe noise function to  X nd the best parse instead of the coverage scor-ingfunction. (Ourtechniquesapplytothegeneralvariant.) Recall fromExample X thatnoiseisde X nedtobethenumberoftokensnot coveredbyaparse, andthebestparseisonewithminimumnoise. Let noise [ s , p ] denotetheminimumnoiseofaparseendingatstate s andposition p .

Figure  X  illustrates the two possible scenarios for the best parse endingatstate s andposition p dependingonwhetherthetoken t is covered by the parse (case ( a ) ) or not (case ( b ) ). For case Algorithm  X  Computingminimumnoisevalues as illustrated in Figure  X , assume that we transition from state to state s using a match M for nonterminal N . Since we consider only basic nonterminals, match M is a single interval of the form [ p , p ] . For this case, noise [ s , p ] = noise [ s  X  , p  X  ] uncoveredtokensintheinterval [ p  X  , p ] . Forcase ( b ) ,thetoken isnotcovered,andtherefore noise [ s , p ] = noise [ s , p wherewerangeoverall s  X  , p  X  , N suchthat p  X  &lt; p , ( andthereexistsamatch M = [ p  X  , p ] fornonterminal N .
WecancomputeCase ( a ) ofEquation( X )bycomputingforeach edge ( s  X  , N , s )  X  Q . Edges thevalue: andtakingtheoverallminimumacrossalledges. Whenthematch-ing function for N is monotonic, the set of p  X  values in Expres-sion ( X ) happen to be contiguous. Let ` N ( p ) denote the smallest position  X  p suchthat [  X  p , p ] isamatchfor N . (Wede X ne if p is not contained in any match for N .) From monotonicity, it follows that for every ` N ( p )  X  p  X  &lt; p , interval [ for N ;further, [ p  X  , p ] isnotamatchforany p  X  outsideofthisrange. e steps  X  X - X  X  of Algorithm  X  implement the computation of Ex-pression( X ). using the maximal matches of N , provided the maximal matches are sorted by their start positions. Recall that a maximal match of abasicnonterminal N isamatchthatisnotcontainedinanyother matchof N . emonotonicityofthematchingfunctionimpliesthat ` ( p Algorithm X takes O (  X  ) amortizedtime. fore Step  X  X  of Algorithm  X  can take  X  ( n ) time as stated. We can exploit the monotonicity of the matching function to implement this step in amortized O (  X  ) time. Intuitively, this algorithm (Al-gorithm  X ) maintains a list  X  i , v ( i ) X  such that i increases and decreasesaswetraversethelistfromstarttoend.
 Time and space complexity: e time complexity of the algo-rithmis O ( En ) , whilethespacecomplexityis O ( Sn ) . eproofs, alongwiththerestofthepseudocode,canbefoundintheextended technicalreport[ X  X ].
Asnotedearlierinthepaper,weknowofnopriorworkthatpro-posese X cientalgorithmsforparsing-basedkeywordsearch. ere-fore,thegoalofourexperimentalevaluationistostudytheoverall performanceofourparsinginfrastructureasafunctionofthenum-ber of patterns, the data size, the scoring function and the query length. We use a (score) threshold variant of the problem, not the best-parse variant presented, so as to be able to study the perfor-manceofouralgorithmsasafunctionofthethreshold.
 Implementation : Ourimplementationisin-memory. Here,were-portperformanceforthecontainmentmatchingfunctionandcov-eragescorefunction(speci X cally,thenoisefunctionvariant);wein-clude other results in the full version of the paper. As discussed in Section X . X ,ourimplementationofthecontainmentoracleisbased onthealgorithmin[ X ]; wealsousetheoptimizationtoexploitthe overlap between successive oracle calls from [ X ]. We build one set containmentindexpertableacrossallcolumnsbutinvokecontain-mentoperationsonthesubsetofcolumnsneededforparsing. Data and Experimental Setup : Weusetwodatasetsforoureval-uation. e X rstdatasetcontainsinformationaboutproductscom-piledbyalargecomparativeshoppingengine. ereare X  X  X tables inthedataset,eachcontaininginformationaboutoneproductcat-egory. e i th product category table Category i contains product nameaswellasotherattributesrelevanttothecategoryascolumns. etotalnumberofrowsacrossallproductcategorytablesis  X   X mil-lion. eotherdatasetisasingletableofabout X millionproprietary addressesthatwewillrefertoas Address .  X 
Address columns  X  intendedtorepresentquerieslookingforspeci X c productsnearagivenaddress. Weenforcerelationalconstraintson the product columns as well as on the address columns separately (thereisnojointrelationalconstraint). us,therearetworelational nonterminals in each pattern, one corresponding to Category onecorrespondingto Address . Patternsaregeneratedfromeachta-ble
Category i byselectingdi X erentsubsetsofcolumnsfrom Category (forthe X rstrelationalnonterminal)followedbyasubsetfrom Ad-dress (for the second). is method of pattern generation lets us controlthenumberandsizeofthepatterns. Foragivensetofpat-terns,theoverallgrammaristhedisjunctionofallpatterns.Queries aregeneratedforagivenpatternbychoosingtokensatrandomfrom thecolumnsinapatternwhilerespectingrelationalconstraints.We addrandomnoisetothequerystringsbyinjectingspurioustokens.
Ourdefaultsetuputilizestables Category i for i  X  {  X ... X  X  X  patterns are all combinations of two columns from each Category table followed by two columns from Address  X  X orresponding to a totalof X  X  X  X patterns. eaveragequerylengthis X . X tokensandthe noisethresholdoftheparsingissetto X . X (i.e., X  X  X oftheparsecan be noise.) Each experimental setting is averaged over  X  X  X  X  X  ran-dom queries. Finally, our experiments are conducted on a work-station running Enterprise Windows Server  X  X  X  X  with a dual core AMDOpteron X . X  X GHzprocessorand X  X GBofRAM.
 Overall Performance and Varying Number of Patterns : We  X rst consider the performance of our parsing algorithm as the number ofpatternsinputincreases. Weincreasethenumberofpatternsby varyingthenumberofproductcategoriesaswellasthenumberof columnsusedtode X neapattern.Figure X (a)showstheresultsofour study. e X-axis shows the number of patterns and the Y-axis re-portstheaverageparsingtimeperqueryinmilliseconds. epars-ingtimeisdividedamongthethreepartsofthealgorithm X  X  X ter, matchingandstitching.

We observe from Figure  X (a) that even with  X  X  X  X  X  patterns and data size containing a total of  X  million rows (over all tables), the totalparsingtimeislessthan X msperquery.

Next, we observe that generally, the parsing time is dominated by the matching step. However, when the number of patterns in-creases,the X lteringphasealsobeginsconsumingsubstantialtime. estitchingtimeisconsistentlysmallthroughoutalthoughtheab-solute value of the stitching time also increases with the number of patterns. is behavior is expected  X  the  X ltering step has to e X ectively consider all the input patterns for a given query. How-evertheoutputofthe X lteringstepistypicallyamuchsmallernum-ber of patterns implying that the NFA size for stitching is typically small. Matching is the only step that accesses the database; thus, even though matching happens only over a small subset of non-terminals,itisrelativelyexpensive.
 Data Size : Wenextstudytheparsingperformanceasafunctionof thedatasize. Wevarythedatasizebyconsideringdi X erentsubsets ofthe Address table. Figure X (b)reportstheresultofthestudy. e X-axis reports the number of rows in the Address table and the Y-axis, the parsing time. As noted earlier, the number of patterns in ourdefaultsetupis X  X  X  X (correspondingto X  X  X productcategories). eonlypartoftheparsingsensitivetothedatasizeisthematching step that issues set containment lookups. We  X nd that the cost in-creasesonlysub-linearlywithdatasize. isisbecauseourcontain-mentchecksareoptimizedforincrementallookups,donotrequire thefullresulttobematerializedanduseanoutput-sensitiveindex. Varying Noise And Query Length :Wenowstudytheparsingper-formanceasafunctionofthenoisethresholdandquerylength.Fig-ures  X (a) and (b) show the results. e X-axis respectively shows the noise (as a fraction of the query length) and the average query length. e Y-axis shows the average parse time. As expected, the parsingtimedoesincreasewithboththenoiseaswellasthequery length. e absolute value of each of the steps increases with the aboveparameters.
 Matching Algorithms : Fromtheabovediscussion,weseethatthe matchingstepconsumesasigni X cantfractionoftheoverallparsing time. Infactwhenthenumberofpatternsisnotverylarge,thecost ofmatchingdominatesthecostofparsing. isisexpectedbecause matching is the step where data access takes place and is therefore sensitivetothedatasize. Wenowcomparetheperformanceofour matchingalgorithmwithabrute-forcealternativethatbasicallycon-siders all interval sequences consistent with a token-level contain-ment  X lter. We consider matching against the Address table with onerelationalnonterminalcontaininguptofourcolumnswithare-k of columns in the relational nonterminal. For a given k , the pat-terns are di X erent sets of columns of size k . For each column set, wegeneratequerystringsbychoosingtokensatrandomfromeach column. eoverallquerylengthis X xedat X tokens.

Figure X (c)showstheplotwiththeX-axiscapturingthenumber ofcolumnsandtheY-axisshowingthematchingtime(inms). We  X ndthatthehittingsetbasedalgorithmyieldsasigni X cantspeedup ofuptoafactorof X overthebruteforcealternativeevenforrelatively shortqueriesof X tokens. Wenotethatuptoapoint,thematching timeincreaseswiththenumberofcolumnsbutwhenthenumberof columnsincreasesfrom X to X ,thematchingtimedecreasesforboth algorithms. isisanartifactofthequerygenerationprocess.Since thequerylengthis X xedandsincewechooseatleastonetokenfrom eachcolumnperquery,alargernumberofcolumnscorrespondstoa smallerrangeoftokenspercolumnwhichcanleadtomoree X cient matchingasdemonstratedinFigure X (c). and keyword search [ X  X ] are the ones most closely related to our work. We  X rst describe how a parsing-based keyword search ap-proach(suchasoursortheframeworkdescribedinFaginetal.[ X  X ]) contrastswiththesetwo. Next,wedescribedetaileddi X erencesbe-tweenourworkandspeci X crelatedpapers.
 Segmentation, Keyword Search and Parsing: Stringsegmentation has goals similar to keyword search, in that the query is to be seg-mented into portions that match the database. However, the ap-proachtakenisdi X erent:segmentationreliesprimarilyonlocal(typ-icallytokenlevel)signals(e.g.,isthewordcapitalized,doesitfollow a punctuation symbol), as well as dictionary signals (e.g., does the wordmatchthedatabase). esesignalsareweightedappropriately throughamachine-learnedHMMorCRFmodel.

On the other hand, keyword search treats a query as a bag of words(andthereforelosesanyorderinginformation),butrelieson relational signals to(implicitly)interpretthequeryandretrievere-sults. us,thekeywordsearchsystemcorrectlyinterpretsthequery derivesfromonerecordcontaining(theauthor) gray and(thebook) interpretthisquerycorrectly.

We can view a parsing-based keyword search system as bridg-ingthespectrumbetweensegmentationandbag-of-wordskeyword search and therefore inherits the bene X ts of both approaches. We can con X gure a parsing-based search system as a pure segmenta-tion system or as a pure bag-of-words system, or anywhere in be-tween. isallowsustoexploretradeo X sinstructuredvsunstruc-turedinterpretationsofquery,exploitinglocalvsrelationalsignals, and sophisticated vs simpler con X guration alternatives. Note that ourtechniquescanalsobeusedtoimprovetheperformanceofpure segmentation systems. Also, we hypothesize that relational signals couldbeausefulfeatureforsegmentationquality,butthishypoth-esis requires detailed study and empirical validation and is outside thescopeofthispaper.
 Wenowdescribedetaileddi X erenceswithspeci X ctopics: Parsing-based Keyword Search: Fagin et al. [ X  X ] introduced the problemofparsing-basedkeywordsearch.Givenagrammar,adata-baseofdocumentsandaquery,theirgoalistoreturnthemostspe-ci X cparse(i.e.,theparsethatmatchesthesmallestnumberofdoc-uments). eyshowthatthisproblemisintractable;however,they  X nd that the problem of returning all relevant parses has polyno-mialcomplexityintheinputandoutput. Subsequently,in[ X  X ],they add rewrite rules, and show that under certain conditions,  X nding all rewritten parses is decidable. In our work, we focus instead on e X ciency,i.e.,howdowedesignalgorithmsandindexstructuresto e X cientlysupportageneralparsing-basedkeywordsearch.
We di X er from prior work [ X  X ] in our use of a scoring function to express parse preference. In [ X  X ], ideas from query containment areusedtode X nea partial ordering overparses. erearetwoad-vantagestothescoringfunctionapproachcomparedtothecontain-mentapproach:( X )ContainmentbasedorderingisshowntobeNP-hard[ X  X ],whilescoringfunctionorderingistractableformanyin-terestingclassesoffunctionsthatweconsider.( X )Scoringfunctions imposeatotalorderingovertheparsesunlikecontainment,so,e.g., thetop-kparsesareunambiguouslyde X ned.
 Dictionary-based Segmentation: Chandel et al. [ X ] consider the problemofstringsegmentationwhilesharinglookupsonthestruc-tureddata. However,theirworkdoesnotparsewithagrammaror supportrelationalconstraints. However,wedousetheiralgorithms toimprovethee X ciencyofourcontainmentlookups(Section X ). Another recent work focuses on query segmentation using CRFs [ X  X ]. ey use a notion similar to maximal matches to es-tablishmatchesthatalsoappearinthedatabase.However,notethat thisworkalsodoesnotconsiderrelationalconstraints,anddoesnot supportagrammar. Once again, this work does not consider relational constraints or a grammar, and restricts matches to be tokens from a single table. However, notethatsomeoftheirprobabilistictechniquescouldbe utilizedtoinferpatterns.
 General Keyword Search: erehasbeenalargebodyofworkon KeywordSearchindatabasesoverthelastdecade.(See[ X  X ]foratu-torialonthesubject.) Inparticular,somepopulardatabasesystems that support keyword search include DBXplorer [ X ], SPARK [ X  X ], BANKS[ X ]andDiscover[ X  X , X  X ]. esesystemsfocusongenerat-ingaconnectedsubgraphoftuples,wherethesmallerthesubgraph, the better it is ranked. However, these approaches do not possess the  X ne-grained control over user intent that parsing with a gram-mar allows. Also, to the best of our knowledge, none of these ap-proachesallowspecialkeywords(e.g., from, to )ornoisetokensin thequery.Ourtechniquesareorthogonaltotheworkonimproving scoring[ X  X ],orincorporatingaggregation[ X  X ]andAND/ORoper-ators[ X  X ].
 Web Search: erehasbeensomeworkrecentlyonquerysegmen-tation by using click logs and query logs [ X  X ,  X  X ]  X  however, these approaches do not leverage the rich structured information in the database,anddonotconsiderrelationalconstraints.
 Query Expansion and Approximate Match: Recent work [ X  X ] has alsolookedatexpandingonthenotionofa X  X atch X  X etweenapor-tion of the search query and a concept in underlying data (such as synonyms, hypernyms and hyponyms). Other papers tackle the problemusingrewriterules[ X  X , X  X ],querysubstitutions[ X  X ],query cleaning [ X  X ], and e X cient approximate entity extraction [ X  X ,  X  X ]. ese papers are orthogonal to our work (which focuses on e X -ciency of the basic parsing infrastructure) and can be used to po-tentiallyidentifyuserintentevenbetter.
 Query Classi X cation and Understanding User Intent: ere has been a lot of recent work on query intent classi X cation [ X  X ,  X  X ,  X ]. egoalofthisworkistoidentifyifasearchquerybelongstoapar-ticularcategoryornot(e.g.,navigationalvsinformational,travelvs nontravel). eoutputofaintentclassi X cationsystemisacategor-ical value that can be used, for example, to direct the query to an appropriatesearchvertical. Incontrast,theoutputofaquerypars-ing system is more detailed and the kinds of challenges and issues studied by the two problems are fundamentally di X erent. We note thatqueryclassi X cationandqueryparsingcancomplementonean-othersincequeryparsingisrelevantandusefulevena X erwenarrow downthesearchverticalusingqueryclassi X cation.
 XPathStreaming: erehasbeensomeworkonidentifyingmatches from a given set of XPaths [ X  X ,  X  X ]. Most prior work in this area builds an automata and then  X  X treams X  the XML data through the automata. However, this body of work focusses on exactly match-ing the given XPath, does not have any underlying data or rela-tionalconstraints,andthereforerequiresdi X erenttechniques. Sim-ilarworkhasaddressedtheproblemofretrievingandindexingreg-ularexpressions[ X ],whilenotaddressingtheproblemofmatching againstanauxiliarydatabaseinadditiontoagrammar.
 Frequent Itemsets: Finally, we note that relational matching is re-latedtothewell-knownproblemof X ndingfrequentitemsets[ X  X , X ]. Whileouroverallsolutionissimilar,weuseinformationspeci X cto ourproblemtocarefullychoosehittingsetsandobtainanalgorithm thatunderreasonableassumptionsisworst-caseoptimal.
In this paper, we considered the problem of e X ciently parsing a query according to a set of regular expression patterns over struc-tured data. Our infrastructure hinges on two modules: matching, where data access is performed, and stitching along an NFA. We also developed a  X ltering module which prunes a large number of states from the NFA. We provide e X cient algorithms for each of these modules, handling ( X ) a number of matching functions, in-cluding set containment, approximate match and equality, ( X ) re-lational constraints and ( X ) linear and coverage scoring functions, such as HMM, CRF and additive noise. Our algorithms scale well withbothdatasizeandthesizeoftheregularexpression.
