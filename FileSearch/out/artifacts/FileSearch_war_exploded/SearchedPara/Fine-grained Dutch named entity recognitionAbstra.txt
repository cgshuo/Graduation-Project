 Abstract This paper describes the creation of a fine-grained named entity anno-tation scheme and corpus for Dutch, and experiments on automatic main type and subtype named entity recognition. We give an overview of existing named entity annotation schemes, and motivate our own, which describes six main types (per-sons, organizations, locations, products, events and miscellaneous named entities) and finer-grained information on subtypes and metonymic usage. This was applied to a one-million-word subset of the Dutch SoNaR reference corpus. The classifier for main type named entities achieves a micro-averaged F-score of 84.91 %, and is publicly available, along with the corpus and annotations.
 Keywords Named entity recognition Annotation Classifier ensembles Subtype classification 1 Introduction Named entity recognition (NER) is the task of automatically identifying names in text and classifying them into a pre-defined set of categories. These categories are application-dependent, and will therefore differ across domains. In the biomedical domain, for example, proteins, genes and chemical substances are common named entities. General-domain NER is typically concerned with finding names of persons, locations and organizations, and sometimes also dates and amounts (Nadeau and Sekine 2007 ). Originating as a subtask for information extraction at the Sixth Message Understanding Conference (MUC-6) (Grishman and Sundheim 1996 ), NER has been an active field of study in the past 15 years.

Finding named entities in text is often an essential preprocessing step for NLP applications. Systems for information retrieval and question answering are usually designed to process information related to named entities. Some opinion mining tasks are focused on monitoring or summarizing the sentiment expressed about specific entities, such as companies, products or services (Liu 2010 ). Named entity information can also be helpful for other NLP problems. In coreference resolution systems, for example, it is commonly included in feature representations (Rahman and Ng 2009 ). For machine translation, NER is helpful to find chunks of text that should not be translated (Babych and Hartley 2003 ).
 NER on English newswire text has reached near-human performance (Zhou and Su 2002 ) for the detection of person, organization and location mentions. State-of-the art systems use supervised machine learning, where a model is trained on an annotated corpus that provides gold standard instances to learn from, the size of which is essential to achieve good performance. Such corpora are available for heavily researched languages such as English, but are scarce or small for most minority languages, such as Dutch. Furthermore, many named entity corpora consist of texts from a single genre (mostly newswire for general-domain NER). This causes robustness problems: systems that have been trained on one particular genre tend to perform worse on unseen genres (Poibeau and Kosseim 2001 ). The corpus presented in this paper aims to resolve these problems for Dutch: at one million words manually annotated for general-domain NER, it is the largest corpus to date, consisting of texts from different genres, as described in Sect. 4 .

One of the future challenges for NER research is to classify named entities into a hierarchy of subtypes instead of the coarse main type categories. Named entities of main type location could, for example, be further classified as pertaining to the subtypes continent or country . Such subtype classification would be especially valuable for applications that involve question answering, information retrieval or the automatic construction of ontologies (Lee et al. 2006 ). Another alley of future research is that of metonymic usage detection (Markert and Nissim 2002 ). The literal reading of a named entity may differ from its intended reading, when metonymy is present. Names of countries, for example, may be used to represent the national sports team. This kind of information is relevant for other tasks, such as coreference resolution, information extraction and question answering. Our corpus was annotated with newly developed guidelines that describe fine-grained named entity subtypes, and metonymic usage.

The resulting corpus was used for machine learning experiments on main type and subtype NER. For main type NER, three different machine learning algorithms were used that had previously been successfully applied to the NER problem: memory-based learning (MBL) (De Meulder et al. 2002 ), Support Vector Machines (SVMs) (Asahara and Matsumoto 2003 ) and conditional random fields (CRFs) (Mccallum and Li 2003 ). We also experimented with classifier ensembles, using genetic algorithms to find a good ensemble composition, as proposed in Ekbal and Saha ( 2010 ). These experiments resulted in a robust and state-of-the-art main type NER system for Dutch. Experiments on subtype classification showed that only subtypes that occur frequently in the training data could be learned.

The remainder of this paper is structured as follows: in Sect. 2 , we provide an overview of related work. Section 3 presents the annotation scheme and Sect. 4 the corpus we developed. In Sect. 5 , an overview is given of the methods used, Sects. 6 and 7 describe the experiments and results for main type and subtype NER, respectively. Finally, Sect. 8 concludes this paper. 2 Related work An extensive literature exists on main type NER (Nadeau and Sekine 2007 ). Early approaches developed for the MUC-7 competition were predominantly rule-based (Chinchor 1998 ). These required manually creating rules, a time-consuming process which hinders porting to new domains or languages. However, rule-based systems are still useful today for tasks where training material is unavailable (e.g. Sekine and Nobata 2004 ). Rules are often combined with gazetteers, where candidate names are looked up in lists of names belonging to a given category.

More recent systems typically use supervised machine learning, which rely on an annotated training corpus, from which a learning algorithm infers patterns associated with named entities, based on morphological, syntactic, lexical and contextual features. Supervised systems have been built that attain performances on the English MUC shared task datasets similar to that of human annotators (Zhou and Su 2002 ). Given these results, the NER problem, as it was defined for the MUC competitions for English, could almost be considered solved. However, because of the acquisition bottleneck for large annotated corpora, some work has focused on unsupervised and semi-supervised NER.

In a typical unsupervised approach, named entities are clustered based on contextual similarity (e.g. Alfonseca and Manandhar 2002 ). Another unsupervised technique exploits the simultaneous occurrence of named entities in news sources, allowing the detection of rare or new named entities (Shinyama and Sekine 2004 ). These kinds of entities are often missed by supervised systems, making the two approaches complemental.

In semi-supervised NER, a small supervised set of seeds is used to start the learning process. The system looks up sentences that contain these seeds, tries to identify contextual rules for them, and then looks for words occurring in similar contexts to expand the seed list. When repeated, this bootstrapping technique eventually yields a large number of hits, with a performance that rivals baseline supervised approaches (Nadeau et al. 2006 ).

In summary, supervised methods currently yield the best performance, but an annotated corpus is a prerequisite. Among the named entity resources available for English are the manually annotated datasets from the MUC-7 Named Entity Task (Chinchor 1998 , 162,692 tokens) and the CoNLL-2003 shared task (Tjong Kim Sang and De Meulder 2003 , 301,418 tokens), and the BBN Pronoun Coreference and Entity Type Corpus (Weischedel and Brunstein 2005 ), which provides a named entity and coreference annotation layer for the Penn Treebank corpus of Wall Street Journal texts (1,173,766 tokens). For Dutch, however, the data from the CoNLL-2002 shared task (Tjong Kim Sang 2002a ), containing 309,686 tokens from four editions of the Belgian newspaper De Morgen of 2000, constitute the only corpus annotated with named entity information that is readily available at present.
The CoNLL corpora were annotated with four main type named entities: persons, locations, organizations and miscellaneous entities. Because of the importance of shared tasks for the NER field, this CoNLL typology is a standard for main type NER, along with those developed for the MUC conferences (Chinchor 1997 ) and ACE (LDC 2008 ). LDC ( 2008 ), Sekine and Nobata ( 2004 ) and Weischedel and Brunstein ( 2005 ) described hierarchies for fine-grained classification into subtypes, with up to 200 categories. For the annotation of metonymy in named entities, guidelines have been proposed by LDC ( 2008 ) and Markert and Nissim ( 2002 ). We developed guidelines that attempt to synthesize these systems into one, which can be applied to Dutch and other languages. A notable difference between Dutch and English that is addressed in the guidelines, is the fact that Dutch compounds are written in one word. As a result, named entities may be embedded in longer strings that, as a whole, are not a named entity. The resulting guidelines are discussed and motivated in detail in Sect. 3 .

Whereas coarse-grained NER is well-researched, fine-grained classification of named entities into subtypes has not been so widely studied. Fleischman ( 2001 ) introduces a system that categorizes locations into 8 subtypes. First, instances are classified using context word unigrams, bigrams and trigrams as features. Then, each instance is given the class that occurs most frequently with that instance. This second step ignores the possibility that identical instances may have different classifications (e.g. Washington the state, and Washington the city). The system is enhanced in Fleischman and Hovy ( 2002 ), for subtype classification of persons into 8 professions. Instead of using surface forms from the context, each context position is represented as the likelihood that it co-occurs with any of the 8 subtypes. Eight topic signatures are used to convey semantic information about the overall context, and eight more that have been expanded using WordNet. Classification performance is good on validation data, but on held-out test data it is hampered by the automatic training data collection, which was compiled using high-confidence classifications from an initial classifier trained on seeds.

More recent work on fine-grained NER has focused mainly on extending the number of classes and linking entities to existing concept hierarchies such as those found in Wikipedia or the People Ontology. Notable examples are the work of Ponzetto and Navigli ( 2009 ), who enrich WordNet synsets using a taxonomy of fine-grained category-tagged instances from Wikipedia (amongst which many named entities), Ling and Weld ( 2012 ), who propose a NER system capable of doing multi-label prediction from 112 tags, and Hoffart et al. ( 2013 ), who present YAGO, a knowledge base that links factual information (such as time and place information) to nearly 10 million entities. However, such systems that focus on ontology population or knowledge base enrichment do not tackle fine-grained tagging of all the entities encountered in a given document. Ekbal et al. ( 2010 ) describe a tentative system for open-domain fine-grained NER for persons, using a maximum entropy classifier with features that describe context words, affix, POS and chunk information, capitalization, word length and frequency, presence of non-alphanumeric characters and the class of the previous word.

In this paper, we present experiments on subtype classification for all main types that have subtypes (persons, locations, organizations, products and events), in order to test its feasibility on our dataset, and to provide a baseline for further research.
To our knowledge, the only NER system available for Dutch is the one integrated in Frog 1 (van den Bosch et al. 2007 ). This system looks up persons, organizations and locations using the gazetteers described in De Meulder et al. ( 2002 ), and other lists of names harvested from Teletext. It has recently been replaced by a NER system trained on the data described in this paper. 3 Annotation In this section, we describe previous work on named entity annotation guidelines, and lay out and motivate differences with our annotation guidelines (Desmet and Hoste 2010 ), 2 followed by examples. Figure 1 gives a schematic overview of the possible annotations. 3.1 Main types and subtypes In 1995, the first widely-used named entity annotation guidelines were developed for the MUC shared tasks, which were aimed at information extraction from text. Three kinds of annotation were proposed: entities (persons, organizations and locations), times (dates and times) and quantities (monetary values and percent-ages). These were known as enamex , timex and numex annotations. The enamex category is the one that is typically associated with named entities in the strict sense of proper names.

For the CoNLL NER shared task of 2002, only enamex entities were considered, and a fourth miscellaneous category was added for proper names falling outside the original 3 enamex groups.

The ACE guidelines for entities also expanded the enamex typology. They introduce categories for geo-political entities or GPEs (geographical regions defined by political or social groups, such as nations) which were previously annotated as locations, facilities (man-made structures such as buildings or bridges) which subsume some entities from the types location and organization, vehicles and weapons . Furthermore, they describe subtypes for most categories (e.g. locations can have subtype address, boundary, celestial, water-body, land-region-natural, region-international or region-general ). The ACE guidelines also define two forms of metonymy annotation, which are discussed below.

Brunstein ( 2002 ) describes the categories and guidelines assembled by BBN. It has two levels, with 29 main types and 64 subtypes, and further expands the hierarchy proposed for ACE. Weapons and vehicles become subtypes under the main type product , and the following new main types are added: NORP (nationality, religions, political and other named entities describing affiliation), events, plants, animals, substances, diseases, works of art, laws, games, languages and contact information . It also includes and expands the timex and numex categories ( date, time, percent, money, quantity, ordinal and cardinal ).

The most elaborate typology is the one described in Sekine and Nobata ( 2004 ). It consists of hierarchies for namex, timex and numex expressions. In the namex hierarchy, organization, location, facility, product, event, natural object, title and unit have subtypes, whereas person, vocation, disease, god, ID number, color and name-other do not. For some types, the hierarchy is more than two levels deep: subtypes can have subtypes, e.g. natural object &gt; living thing &gt; animal &gt; invertebrate &gt; insect .

The timex category was further elaborated in Ferro et al. ( 2005 ). Because of the availability of spatiotemporal information in our corpus (see Sect. 4 ), a timex category would have been redundant in our annotation scheme. The annotation scheme we propose is solely focused on expressions from the enamex category.
The typology we developed aims to strike a balance between granularity, learnability and task independence. Whereas the level of detail in MUC and CoNLL may be too limited for some applications, Sekine X  X  rule-based approach suggests that his typology is too detailed to be learned automatically. We therefore made a relatively coarse-grained structure consisting of six main types, with subtypes that capture the granularity of the more elaborate typologies. One example is location , which incorporates facility as a subtype, along with celestial, water-body , etc. We chose not to have main types that are tailored to a specific task, such as the weapons and vehicles categories in ACE.

The six main type categories are as follows:  X  PER: names of persons, fictitious characters, gods, artist names and generational  X  ORG: names of organizations, including organizational suffixes; e.g. European  X  LOC: names of locations, and derived adjectives; e.g. Paris, Mount Everest,  X  PRO: names of products, awards, works of art and languages; e.g. Office 2007,  X  EVE: names of events; e.g. World War II, Katrina  X  MISC: miscellaneous names of species, substances, periods etc.; e.g. Mesozoic ,  X  Persons are categorized into 9 fields: sports (such as athletes and coaches),  X  Organizations can be classified as governmental (public institutions), commer- X  Locations are divided into continents, countries, regions (such as provinces and  X  Products are classified as shares (on the stock market), languages or  X  Events are labeled as either human (such as wars and sports events) or natural 3.2 Metonymic usage Some entities can be hard to annotate because of ambiguity between main types, such as locations , GPEs and organizations . Such entities can often take on different roles, according to their usage. Consider Sentence 1: 1. The White House opted for modern works of art, including a Rothko.

Cases like White House being classified as location rather than organization are a common confusion (Nothman et al. 2009 ). Similarly, Rothko can be considered a person or product entity. This ambiguity can be solved by annotating metonymy, in which one expression is used to refer to the referent of a related one.

The ACE guidelines describe two forms of metonymy. Nickname metonymy capital city referring to a government, or a location name denoting a sports team. Cross-type metonymy occurs when multiple aspects of an entity are referenced at the same time, such as organizations and the facilities they occupy (e.g. They will be visiting the White House tomorrow ).

Markert and Nissim ( 2002 ) argue that although metonymic readings are potentially open-ended and can be innovative, there is a regularity to the metonymic usage of word groups. Therefore, given a semantic class (e.g. location), several regular metonymic patterns (e.g. place-for-event) can be specified that instances of the class are likely to undergo. They describe three patterns for locations ( place-for-people, place-for-event and place-for-product ) and five patterns for organizations ( org-for-members, org-for-product, org-for-facility, org-for-stock-index and org-for-event ), along with some general patterns that may apply to all semantic classes ( object-for-representation and object-for-name , when a name is used as a mere signifier, or other-metonymy for metonymy that does not fit a common pattern) (Nissim and Markert 2005 ).

We adapted this approach, by describing metonymic patterns for all main types except miscellaneous . By marking whether a named entity is used literally or metonymically, we can consistently label named entities for their literal main and subtype, and use metonymic roles to point to their intended main and subtype. This is exemplified in Sentence 2:
Because it is often impractical to determine whether a named entity is used metonymically as PER or as ORG, we combined them in the intended type human . White House might refer to a person, namely the U.S. president, or to an organization-like group of people such as the White House staff.

Marking metonymy does not only do away with confusable main types, it should also benefit other NLP tasks such as coreference resolution. For example, a coreferential resolution algorithm could link an inanimate noun phrase like the painting to Rothko in Sentence 2 if it has access to named entity classifier output that does not only mark  X  X  X othko X  X  literally as an (animate) person, but also metonymically as a product. This in turn allows information extraction and question answering applications to link the selling price of 1.7 million to Rothko .
The addition of metonymy annotations further contributes to the experimental value of the corpus, as automatic metonymy resolution is a valuable field of study in itself. 3.3 Guideline evaluation In order to evaluate the guidelines, two linguists annotated a set of eight randomly selected texts from the corpus, containing 14,244 tokens in total. Two evaluation metrics were used: Kappa (Carletta 1996 ) and F-score ( b = 1) (Van Rijsbergen 1979 ). F-scores were calculated by taking one annotator as the gold standard and scoring the annotations of the other for precision and recall. This yields the same results as averaging the precision or the recall scores of both annotators, when using the other as a gold standard.

Scores were calculated on 5 levels: chunks (whether a word is annotated as a named entity or not), main type, subtype, usage and metonymic role. For each level, scores were calculated on the entire set, and on a subset containing only those tokens (a) on which both annotators agreed on the preceding level, and (b) which can receive annotation on the current level ( MISC and PER , for example, are not included in the subset for subtype, because they cannot receive subtype annotation). We present these subset results in order to have scores that are not influenced by annotations that are irrelevant at the considered level. The results can be found in Table 1 .
The results show high agreement scores for all levels: Kappa scores above 0.80 are characterized as almost perfect agreement. We can conclude that annotation can be carried out consistently. 4 Dataset The annotation scheme described in Sect. 3 was applied to a part of the STEVIN 3 -funded SoNaR corpus. 4 SoNaR is a reference corpus of written Dutch that comprises a wide variety of texts, including traditional text types (such as newswire, manuals, autocues, fiction and reports) as well as new media (such as blogs, forums, chat and SMS), for a total of 500 million words (Oostdijk et al. 2008 ).

A diverse 1-million-word subset ( SoNaR 1 ) has been manually annotated with named entity information. The diversity in text types, which was lacking in the Dutch CoNLL-2002 dataset, should allow for a more robust classifier and better cross-corpus performance (Nothman et al. 2009 ). It should also make SoNaR 1 an interesting corpus for research on domain adaptation. The possibility to train a robust classifier was essential, because the NER system trained on SoNaR 1 was used to automatically label the remainder of SoNaR.

SoNaR 1 does not only contain named entity information, it has also been provided with a number of other manually corrected annotation layers. The corpus has been syntactically annotated, and there are four semantic layers: named entities, coreference relations, semantic roles and spatiotemporal expressions (Schuurman et al. 2009 ).

SoNaR 1 and its annotation layers are to be released along with the other SoNaR deliverables, including the main type named entity classifier described below, and will be freely available for academic use. The Dutch Human Language Technology Agency (HLT-agency) 5 is responsible for distribution. 4.1 Corpus annotation Manual annotation was done using the MMAX2 annotation tool (Muller and Strube 2006 ). For the named entity task, six annotation layers were created X  X ne per main type. Per text, each annotation layer is stored as a standoff XML file, the content of which is defined by a scheme file. These scheme files contain the possible attributes for every annotation, such as the available subtypes, the choice between literal and metonymic usage, and the metonymic role, if applicable.

Annotation speed averaged around 3,500 words per hour. Taking into account the verification of the annotations by a second annotator, the actual annotation speed was close to 2,000 words per hour.
 4.2 Corpus statistics The distribution of main named entities, subtypes and metonymic usage in the corpus is described in Tables 2 , 3 and 4 , respectively.
 Nearly 10 % of the tokens in the SoNaR corpus are part of a named entity chunk. Locations are the most prevalent main type, followed by persons and organizations. For every six named entities, five pertain to one of these three categories. Miscellaneous entities and products are uncommon, and events are rare.

This distribution is comparable to that in the Dutch datasets for the CoNLL-2002 shared task, which is also presented in Table 2 . The frequency of named entities (9.30 %) is nearly identical. Persons are more frequent in the CoNLL data, locations less frequent, and organizations about equally frequent. The high proportion of locations in the SoNaR data can be explained because nouns and adjectives derived from locations (such as French or Frenchman ) are annotated as LOC in SoNaR, and as MISC in CoNLL. Consequently, MISC annotations are more frequent in CoNLL than in SoNaR. We can conclude that the named entity frequencies in the SoNaR corpus do not violate expectations based on another corpus.
 The subtype distribution is skewed for most main types, except organizations. Person entities in our corpus typically belong to the fields of politics or arts, which together represent more than half of the entities. Around 15 % of the annotations did not pertain to any of the fields, or could not be disambiguated from the context. For locations, countries make out almost half of the annotations, followed by population centres (e.g. Madrid ) and regions (e.g. Alabama ). The remaining location subtypes occur with some frequency, although fictional (e.g. Azkaban ) and extraterrestrial locations (e.g. Mars ) are rare.

Especially for products and events, the skewness of the data is high: out of 2,352 product annotations, there are 77 instances with subtype language, and only 2 with subtype share. This can in part be explained by the nature of the data, which does not include financial news, for which the share subtype is intended. For events, only 24 have subtype natural (e.g. Alex, Zuidwesterstorm ), as opposed to 1,107 with subtype human, which is to be expected given the low number of named natural events.
Metonymy occurs with almost one in twenty named entities in the corpus. It is most frequent in organizations and locations, which are often used to signify humans. Out of 2,610 metonymically used named entities, 223 have an other metonymic role, meaning that 91.46 % of the entities (2,387) follow a predefined metonymic pattern. 5 Methods In this section, we describe the methods used for the main type and subtype classification experiments. We discuss the various classification frameworks that were used ( 5.1 ), the methods used for ensembling classifiers ( 5.2 ), extracted features ( 5.3 ) and evaluation metrics ( 5.4 ). 5.1 Classification frameworks The main type classification experiments in this paper were done with three families of supervised learning algorithms: MBL, SVMs and CRFs. The subtype classification experiments were done with MBL. We briefly describe each classification framework below. 5.1.1 Memory-based learning Memory-based learning algorithms are called lazy learners because they perform no generalization on the instance base they are trained on (Daelemans and van den Bosch 2005 ). All the instances are stored in memory, and new instances are classified by comparing them to the instance base, for example with a k -nearest neighbour algorithm. When a k -value of 1 is used, the classifier labels an unseen instance with its closest neighbour in the instance base. Various distance and feature weighting metrics can be used to determine which neighbour is closest. For larger values of k , some voting mechanism has to be applied to choose one class label from the nearest neighbours set.

We experimented with TiMBL. 6 version 6.2.1 (Daelemans et al. 2009 ). 5.1.2 Support vector machines A support vector machine is a learning classifier capable of binary classification. It learns from the training instances by mapping them to a high-dimensional feature space, and constructing a hyperplane along which they can be separated into the two classes. New instances are classified by mapping them to the feature space and assigning a label depending on its position with respect to the hyperplane. SVMs are said to have a robust generalization ability (Vapnik and Cortes 1995 ).

For multiclass classification problems, separate SVMs have to be built. With the pairwise approach, one SVM is trained for every pair of classes. Another method is one vs rest , where one SVM is built for each class to distinguish it from all other classes.

The SVM implementation used in our experiments is YamCha, 7 version 0.33 (Kudo and Matsumoto 2003 ), with pairwise multiclass classification. 5.1.3 Conditional random fields A conditional random field is a probabilistic classifier that is used to segment and label sequential data, which makes it especially apt for natural language processing tasks like NER. CRFs take an input sequence X with its associated features, and try to infer a hidden sequence Y , containing the class labels. They are as such comparable to Hidden Markov Models (HMMs) and Maximum Entropy Markov Models (MEMMs). However, CRFs, unlike HMMs, do not assume that all features are independent, and they can take future observations into account using a forward-backward algorithm, unlike MEMMs, thus avoiding two fundamental limitations of those models (Lafferty et al. 2001 ).

For our main type experiments, CRF ?? 8 version 0.53 was used. CRF ?? is a sequence tagger, which requires a template file that specifies the combinations of features it needs to consider. 5.2 Classifier ensembles and genetic algorithms The standard way to improve NER classification performance is by optimizing a single classifier. This may involve finding the most informative features, and discarding the uninformative ones (feature selection, Isozaki and Kazawa 2002 )or finding the right settings for a specific algorithm [parameter tuning, De Meulder and Daelemans 2003 ). An alternative research direction is that of combining several classifiers into an ensemble, and combining their output using a voting procedure (Wang et al. 2008 ). The assumption is that combining a diverse set of classifiers improves the generalization accuracy, provided that the ensemble X  X  members have sufficient individual performance and their errors do not entirely overlap.
The output of the individual classifiers in an ensemble can be combined using the following voting procedures:  X  Normal majority voting: every classifier casts a vote for a class tag, and the tag  X  Globally weighted voting: the weight of a classifier X  X  vote is determined by its  X  Class weighted voting: a classifier X  X  vote for one particular class is weighted by  X  Smoothed class weighted voting: the same principle as class weighted voting,
Finding a good combination of classifiers for an ensemble is not a trivial search problem: for n candidate classifiers, there are 2 n -( n ? 1) possible ensemble combinations.
 Genetic algorithms provide an efficient way to select a near-optimal ensemble. They operate on a representation of the search space, called the genome, which in the case of constructing an ensemble from a set of n classifiers can be a binary string of length n , in which every bit represents a classifier. The technique is inspired by evolutionary biology, borrowing evolutionary concepts such as selection (well-adapted or fit individuals are more likely to survive), inheritance (the genetic material is passed on to later generations), mutation (new generations introduces some random variation in the genetic material) and crossover (new genetic material is formed by combining the material of parents). The technique is applied to a problem (Whitley 1994 ).

The search space defined by the genome is explored as follows: 1. An initial population P (0) is created, containing | P | randomly instantiated 2. For each chromosome, a fitness score is calculated. This is done by having the 3. The next step is to select chromosomes that will populate the intermediate 4. When selection is complete, recombination on the intermediate population can 5. Steps 2 X 5 are repeated until a predefined number of generations has been
In Sect. 6.1 , we describe how the genetic algorithm approach was applied to our classifier ensemble selection problem. Our system used Pyevolve, 9 a Python implementation of genetic algorithms. 5.3 Feature representation Supervised machine learning algorithms require that the information present in a classified into a predefined set of classes based on a vector of features describing its attributes.

In the case of main type NER, every token from the corpus is represented by an instance, which has a class indicating whether the token is a named entity, and if so, which type. IOB2 notation (Tjong Kim Sang 2002b ) is used to represent named entity chunks, where O stands for outside a chunk (not a named entity), B for begin (start of a NE chunk) and I for inside a chunk.

The subtype classification systems are main type specific (e.g. locations only), and are presented with instances representing named entities of that main type, with the subtype as the class to be predicted.

We extracted a range of features to describe instances, many of which are commonly used in the field (Tjong Kim Sang 2002b ; Nadeau and Sekine 2007 )or have been studied for Dutch before (Bogers 2004 ). For the main type experiments, the following features were used:  X  Basic information : the original token, its POS tag, which was obtained by  X  Orthographic information : non-exclusive binary features capturing ortho- X  Word shape : a symbolic feature that tests for the same orthographic characteristics  X  Patterns : binary features indicating whether the token matches regular  X  Word length : the number of characters in the token.  X  Character ngrams : the first and the last n characters of the token.  X  Function word : a binary feature indicating whether the token occurs in a list of  X  Chunks : a symbolic feature with a base phrase chunk tag, obtained with the  X  Class tag : the correct classification is taken from the annotations, and is  X  Token : the named entity of which the subtype has to be determined. Multiword  X  Context : the three tokens preceding and following the named entity to be  X  Character ngrams : 6 string features containing the first and the last 2, 3 or 4  X  Decompounding : in Dutch, compounds are written in one word. Decompound- X  Class tag : a symbolic feature indicating the correct subtype. 5.4 Evaluation For main type classification, we evaluate performance using micro-averaged F-score. In micro-averaging, an overall F-score is computed globally over all instances (thus giving higher weight to frequent classes), whereas in macro-averaging, F-scores are first computed for each class under consideration, and then averaged (such that each class has an equal weight in the final score). We use the conlleval.pl script 10 made available for the CoNLL shared tasks, which was written to work with IOB notation, counting NE chunks as one.

For subtype classification, both micro-averaged and macro-averaged F-scores are reported.

Because of the computational requirements of the experiments, a smaller corpus was selected from SoNaR 1 as the development corpus, that had been entirely annotated and double-checked at the time of the experiments. This development corpus consisted of 99 autocue scripts for news shows on Dutch public television experiments. Evaluation on this corpus was done with threefold cross-validation.
After development, the best-performing main type NER system was retrained on the entire corpus. We report tenfold cross-validation performance on this corpus. 6 Main type classification 6.1 Experimental setup The main type NER is a sequence labeling task: each sentence is a sequence of tokens, which needs to be assigned a sequence of IOB labels. Context information is relevant: if one token starts a Person chunk ( B-PER ), it is likely that the next token may also be in that chunk ( I-PER ).

CRF is designed as a sequence labeling machine learner, which tries to find an optimal sequence of labels for the given input sequence. In order to provide context information to the MBL and SVM learners as well, the instances were windowed. Experiments with different window sizes on the development set indicated that a left context of 3 and a right context of 1 yielded the best results. All features were windowed in this fashion.

We experimented with a manual and an automatic approach to find the best-performing combination of features and learning algorithm.

First, we manually combined the features described in Sect. 5.3 into 8 different feature sets, shown in Table 5 . Basic information (original token, POS tag and position in the sentence) was deemed indispensable, and is included in every feature set.

These feature sets were tested with 3 configurations of the classification frameworks:  X  TiMBL with default settings: the IB1 ( k -nearest neighbour) algorithm with a k - X  CRF ?? with the standard feature template.  X  YamCha, using a pairwise multi-class strategy.

These configurations were combined with the 8 feature sets, and tested using threefold cross-validation on the development corpus.

Secondly, we tested whether better performance could be achieved by combining classifiers into an ensemble. These ensemble selection experiments were done automatically, using genetic algorithms to find an optimal classifier ensemble, an approach similar to the one proposed by Ekbal and Saha ( 2010 ), where GAs are used to construct a classifier ensemble out of 19 Maximum Entropy classifiers. We hypothesized that ensembling different types of classifiers would benefit the ensemble performance, assuming that each classifier type makes different kinds of errors (Hastie et al. 2001 ).

The genetic algorithm setup used to find the best classifier ensemble was configured as follows (we refer to Sect. 5.2 for a description of the various settings). A 24-bit genome was used to represent the search space. Every bit in the genome represents the presence (1) or absence (0) of 1 of the 24 classifiers in order, and the combination of those bits determines which classifiers are combined into an ensemble. The chromosome 111111110000000011111111, for example, represents an ensemble in which all TiMBL and all YamCha classifiers are used, and none of the CRF ?? classifiers. The population size | P | was 50. Single Point Crossover occurred with a probability of 0.90, and Flip Mutation with a probability of 0.02, so that every bit in the chromosome had a 2 % chance of being flipped. We stopped the evolution after 40 generations. The selection and mutation types and probabilities are Pyevolve X  X  default parameters. We used the same population size and number of generations as used in the experiments described in Ekbal and Saha ( 2010 ).
Finally, we used the results from the individual and ensemble experiments to construct a system trained on the entire 1-million-word corpus, and report results using tenfold cross-validation. 6.2 Results and discussion 6.2.1 Individual classifiers The performance of each combination of a feature set and a classifier configuration is reported in Table 6 .

It shows that the CRF classifiers present in the pool perform best on average. The best individual classifier is the CRF classifier trained with feature set B, which contains all features (with character ngrams of length 4). 6.2.2 Ensemble classifiers Table 7 presents the outcome of the ensemble selection experiments for each voting mechanism. The genome describes which of the 24 classifiers are included in the ensemble. The precision, recall and F-scores of these ensembles, the ensembling of all classifiers and the best individual classifier are presented in Table 8 .
It can be observed in Table 7 that the best-performing classifier ensembles, regardless of the voting mechanism used, consist of classifiers from all three classification frameworks. Of particular interest is the occurrence of the TiMBL classifiers trained on feature sets D and F, present in all but one and all classifier ensembles, respectively. These classifiers achieve an individual F-score of 75.06 and 76.59, respectively, well below the F-scores of the selected CRF and SVM classifiers. This observation may corroborate that combining different types of learning algorithms in a classifier ensemble can lead to better generalization performance of an ensemble.

A first observation to be made in Table 8 is the influence of the chosen voting mechanism, used for combining the class tags of each individual classifier in an ensemble. In our experiments, the results with class weighted voting consistently trail the other results. We had hypothesized that this could be caused by the higher weight it gives to majority classes, and anticipated the problem with smoothed class weighting. The results confirm that smoothing has a positive effect. Performance differences between the three best voting mechanisms are small, but overall, a simple voting strategy such as normal majority or globally weighted voting can be recommended.
All best-performing classifier ensembles outperform the ensembles consisting of all classifiers by a significant margin. The difference in F-score between the best-performing classifier ensemble (normal majority voting, 84.44) and the best-performing individual classifier (CRF ?? trained on feature set 2, 83.77) is 0.67 % points. This difference was found to be statistically significant.

For the calculation of statistical significance of the F-score, we applied the bootstrap resampling test (Noreen 1989 ; Yeh, 2000 ) to the output of the classifier, a significance test that has been used earlier in the framework of the CoNLL shared task on NER (Tjong Kim Sang and De Meulder 2003 ). Instances are randomly drawn with replacement from the classifier output, forming a so-called bootstrap sample. From the output of each system, 1,000 such bootstrap samples were taken, and the distribution of the F-scores on these samples is assumed to be the distribution of the performance of that system. We used these F-scores to calculate the average F-score, the standard error and the upper and lower boundary of the center 90 % distribution.
If the bootstrap-sampled averaged F-score of system X is outside the 90 % center of system Y , the performance difference between these systems is considered to be statistically significant.

The results confirm that genetic algorithms can be successfully applied to the task of finding a classifier ensemble that outperforms the best individual classifier. However, the performance gains measured in our experiments are not as large as the ones reported in Ekbal and Saha ( 2010 ), where improvements of up to 12.88 F-score percentage points are reported. One possible explanation for this is that the base classifiers used in their experiments were not as strong as the ones used in our experimental setup, leaving a bigger margin for improvement. 6.2.3 Ensembles versus tuning Because of the observation that ensembling did not bring large performance gains, we wanted to test whether an optimized individual classifier could improve on the best ensemble X  X  performance. In a further experiment, we tried to enhance the feature set of the best-performing CRF classifier by including the features of the second-best classifier it did not already have, namely prefixes and suffixes of length 4. This classifier achieved an F-score of 84.91 on the dataset, thus outperforming both the best individual classifier and the best ensemble classifier by 1.14 and 0.47 % points, respectively.
This may suggest that optimizing a single classifier (e.g. with feature selection or parameter optimization) can lead to better performance than using a classifier ensemble approach. This dilemma is consistent with findings for other tasks, such as word sense disambiguation. In the third Senseval competition, for example, a highly optimized single classifier outperformed classifier ensemble systems on the challenge data (Decadt et al. 2004 ). More recent work by Brody et al. ( 2006 ) and Navigli and Ponzetto ( 2012 ), on the other hand, present successful word sense disambiguation approaches with classifier ensembles.

An important factor to consider in the trade-off between ensemble selection and classifier optimization is the computational cost. For large search spaces (e.g. when there are many possible ensemble combinations, features or parameter settings to consider), the cost of evaluating a single combination determines how fast the space ensemble combination, this cost is relatively small, because evaluation consists of combining (known) outputs of individual classifiers, applying a voting strategy, and calculating a performance measure. For classifier optimization, on the other hand, evaluation consists of training a classifier, generating test output, and calculating performance. Lazy learners, such as TiMBL, are forgiving to such an approach, because they can be trained very quickly. However, the time required to evaluate a single greedy classifier, such as CRF ?? , can quickly make optimization computationally infeasible without grid computing infrastructure.
 6.2.4 Feature selection As it has been shown in previous work that lazy learning approaches like TiMBL are more vulnerable to bad features than greedy ones such as SVM and CRF (Daelemans and Hoste 2002 ; Hoste 2005 ), we did feature selection for TiMBL using a genetic algorithm. SVM and CRF are more robust because of their inherent feature weighting. CRF ?? for example was not harmed by bad features: it delivered the best-performing classifier when it had every feature at its disposal (see Table 6 ).
Gallop (Desmet et al. 2013 ), a genetic algorithm toolbox for optimizing learning algorithms, was used for feature selection on two levels: feature groups and individual features. For feature group selection, a 9-bit genome encoded the presence or absence of any of the 8 feature groups described in Sect. 5.3 , with character ngrams divided into two groups (trigrams and four-grams). For individual feature selection, every feature was represented in a 23-bit genome.

Evolution was set to run for 100 generations of 10 individuals each (mutation rate 0.3, crossover rate 0.7). The selected features and resulting scores are presented in Table 9 .
 In our experiment, feature selection yields a performance gain of close to 1 % F-score. Feature group selection performs somewhat better than individual feature selection, which may be due to its reduced search space and better chance for an optimal solution, but both feature selection approaches largely agree on which features are useful for NER with TiMBL.

Unsurprisingly, the original token and POS tag are useful, although the inclusion of the sentence-initial feature appears to be unnecessary. It may be irrelevant because TiMBL has access to a window of 2 tokens on either side of the target token, and infers positional information there.

Orthographic features remain largely unselected, even with individual feature selection. Only the All lowercased and punctuation features are chosen. We hypothesize that the other features are either irrelevant, or redundant because of e.g. character ngram features. The word shape features is also discarded.

Of the pattern features, the detection of name initials is useful, whereas URLs do not need a separate feature. Name initials detection is likely to help classification (as person) rather than detection.

Word length is not relevant to NER. Character ngram information, on the other hand, is. With feature group selection, both trigrams and four-grams are selected. The individual feature selection shows that four-gram prefixes are the most informative.
The function word feature is selected individually, but its presence does not seem to make a difference for feature group selection. Finally, chunking information is not selected in either selection approach.

These experiments show that feature selection is worthwhile for TiMBL classifiers. However, it clearly does not close the gap in performance compared to CRF and SVM. 6.2.5 System evaluation For the development of the publicly released NER system, the best-performing CRF ?? classifier using all features was trained on the 1-million-word SoNaR 1 500-million-word SoNaR corpus. We report results using tenfold cross-validation on SoNaR 1 in Table 10 , and a confusion matrix in Table 11 .

The overall F-score of 80.71 is 3.80 % points lower than the overall F-score on the development set. This drop in performance is to be expected, given that the classifier was optimized for performance on the development set. Overall, precision is slightly higher than recall, but both metrics are balanced.

The results per main type are consistent with the amount of training data available in the corpus: location, the most frequent type, has the highest F-score, followed by person and organization. For these types, precision and recall are balanced. For products, events and miscellaneous entities, however, precision is higher than recall. Recall is low for products in particular, which are most often incorrectly tagged as not-an-entity or as persons.

We see two possible causes for the lower scores for these three types. The variance of the contexts in which persons, organizations and locations may occur is more limited than that for miscellaneous entities and products, thus making it easier to infer patterns from them. The lower availability of training instances for the less frequent types is also a hindrance to performance.

These results cannot directly be compared to output from other systems, but it is worthwhile to consider them alongside results on the Dutch shared task dataset from CoNLL-2002. In Table 12 , we present the results achieved on this dataset with the system of Carreras et al. ( 2002 ). To our knowledge, no work has been published that beat this system X  X  performance for Dutch.

We compare the best shared task results on the development set to our results from tenfold cross-validation on the entire corpus (Table 10 ), which provides a similar difficulty (the test set is not entirely unexpected: in the case of CoNLL, it was the development set, in the case of SoNaR, tenfold cross-validation was used).
It would be unfair to compare these results directly, because of differences in annotation scheme and dataset. Furthermore, the CoNLL-2002 shared task focused on multilingual NER (in this case, for Spanish and Dutch). In general, however, we can observe a few parallels between the results. Overall precision and recall are well-balanced, and overall F-score is roughly comparable at around 80 %. Per-type precision and recall shows the same trends: better precision than recall for ORG and MISC, better recall than precision for LOC. The per-type scores on the CoNLL data have a smaller spread than those on the SoNaR data, where F-scores for PER and ORG are considerably higher, and for MISC (and PRO and EVE) considerably lower than the overall F-score. 7 Subtype classification In this section, we describe experiments on automatic subtype prediction of named entities, after their main type has been determined. 7.1 Experimental setup We approach subtype classification as a pure classification task, where a named entity needs to be given one of the subtypes that its main type allows. We therefore developed five separate classifiers, one for each main type that has subtypes, i.e. all main types except miscellaneous.

The input for each of these systems consisted of all named entities from the development corpus of the correct main type. In a real world setting, a subtype classification system would have to rely on imperfect main type classification for its input, with error percolation and lower performance as a result. We include an end-to-end evaluation at the end of this section.
 We tested different combinations of the features described in Sect. 5.3 , using TiMBL with k = 1. CRF ?? and YamCha, as opposed to TiMBL, are sequence taggers that are unsuitable for a task where instances should be classified without influence of preceding or following instances. We evaluate using threefold cross validation and report micro-and macro-averaged F-score. It is not infrequent that word forms occur multiple times, and both in the training and the test fold (e.g. countries or continents). When they have the same subtype label, their classification is trivial. However, duplicates are not necessarily redundant: more instances provide more context to generalize from, and some word forms have multiple subtype labels (e.g. Washington the state and the city). This is why we report scores over all instances (measuring overall performance), over instances already seen in training (measuring performance on possibly ambiguous word forms), and over instances not seen in training (measuring generalization performance).

We include scores for two baseline systems. The first is a na X   X  ve frequency baseline that assigns the subtype label that occurs most often in training to all test instances. The second baseline is a classifier that only uses the word form as a feature, and is only capable of looking it up in the training data and assigning the most frequent corresponding label. It can therefore be viewed as an informed lookup baseline. On unseen data, these baselines will perform identically, because the lookup baseline falls back on the most frequent class when no match is found. 7.2 Results and discussion 7.2.1 Persons The results for subtype classification on persons are presented in Table 13 .No decompounding features were used for person subtype classification, because the head of a person X  X  name should not be indicative of his profession. Each column in the table represents a classifier. The presence or absence of features used for each classifier is indicated with 1 or 0 in the upper section of the table. The score of the best-performing classifier per metric or subtype is boldfaced. Relative frequencies are given next to each subtype, and subtypes are ordered according to frequency.
For all instances, the classifier with all features performs best. However, for rare subtypes such as business, science, army and fiction, the lookup baseline cannot be beaten. On seen instances, all classifiers that have access to character ngram information perform best. On unseen instances, the three most frequent subtypes (politics, sports and arts) can be modeled with some success, using all features. Law and clergy entities perform well, considering their frequencies. This is due to common context words, such as advocaten ( lawyers ) in the case of law entities. 7.2.2 Organizations Table 14 presents the results for organization subtype classification. Overall, the systems with more features perform better. For all instances, the best results are achieved with all features, although leaving out decompounding information has little influence on performance. Both baselines are easily beaten.
 For seen instances, the lookup baseline performs well, as should be expected. Because of ambiguous word forms, no perfect score is achieved. For commercial and miscellaneous entities, the ambiguity is handled slightly better when ngrams and decompounding are added.

For unseen instances, decompounding hurts performance for governmental and miscellaneous organizations: the classifier with token, context and ngram information performs better. Decompounding does help for detecting commercial organizations. For miscellaneous organizations, the frequency baseline performs best, so no effective learning occurs. This is likely due to the heterogeneous nature of the category. 7.2.3 Locations The results for location subtype classification (Table 15 ) also show that all features are useful. When evaluating on all instances, leaving out any of the features degrades performance, except for the cosmos, water and country subtypes. The development corpus did not contain any fictitious locations.

The results on seen instances are comparable to the ones for organization subtypes: the lookup baseline is beaten by classifiers that include ngram and decompounding information. Extraterrestrial and line locations can be perfectly disambiguated using ngram information only.

On unseen instances, ngrams, context and decompounding help the most, in that order, because eliminating these features from classifier combinations hurt performance most. Unseen population centres, line locations and countries can be predicted well with F-scores above 65 %. Regions, points, continents and water locations can be predicted with some accuracy, extraterrestrial locations not at all. This is consistent with the amount of available training instances for these subtypes.
 7.2.4 Products Character ngrams are the most informative feature for subtype classification of products (Table 16 ). The classifier that only uses ngrams achieves the best macro-averaged F-score on all sets. Adding token, context or decompounding information results in identical or lower scores, showing that these features are either not salient, or harmful.

There were only two instances of products of type share in the dataset, both occurring in the same fold. This fold would either be in training, or in test, and is therefore either not tested, or never seen in training.

On seen instances, the lookup baseline cannot be beaten. On unseen instances, however, classifiers with token and ngram information perform better when evaluating with macro-averaged F-score, because they are capable of detecting languages with some accuracy (50 %). When evaluating with accuracy, however, both baselines perform best, because of the high frequency of miscellaneous products in the data. 7.2.5 Events The results on events (Table 17 ) show that unseen natural events cannot be learned with the features we use. This is probably caused by a lack of training data. There is no ambiguity in the data: word forms either describe natural or human events, which is why the lookup baseline and most other classifiers get perfect results on seen instances.

For unseen instances, the frequency baseline is never beaten, because it never assigns the label natural , whereas the other classifiers do, incorrectly. 7.2.6 All subtypes Overall, the subtype classification experiments show that subtypes can only be detected in unseen word forms when there is enough training material available for the subtype in question (see Table 3 ). All features were useful in predicting those subtypes, particularly character ngrams and context words.

When insufficient training material is available, the frequency baseline performs best in terms of micro-averaged F-score on unseen instances, because of the skewness of the subtype distribution (for events and products). 7.3 End-to-end evaluation We evaluated the performance of subtype classifiers based on perfect input, i.e. input that had been correctly classified at the main type level. In a real world setting, however, such input is not available, and subtype classification is done on imperfect main type information. Table 18 presents subtype classification results (using all subtype features) on main named entity output generated by the single best-performing CRF classifier described in the previous section.

In our cascading setup, errors percolating from the main type level can never be corrected on the subtype level. This end-to-end evaluation is therefore informative mainly to gauge the impact of noise introduced by the main type level on subtype classification performance.

As is to be expected, we find that the drop in subtype performance is consistent with main type performance: persons and locations, which have high recall rates on the main type level, show a 5 X 10 % drop in subtype performance, compared to performance drops of around 50 % for products and events, caused by poor recall on the main type level. Overall, we can conclude that end-to-end automatic subtype classification yields good accuracy for persons, locations and organizations. 8 Conclusions and future work This paper introduced a number of publicly available named entity resources for Dutch. A one-million word corpus consisting of different genres was hand-annotated for named entities, for which subtype and metonymy information is available. Other syntactic and semantic annotation layers are also present in the corpus, making it ideal for experimenting with gold standard preprocessing information, in order to establish performance ceilings.

The annotation scheme and guidelines that were developed integrate ideas from the literature on main types, subtypes and metonymy in named entities, and are aimed at fine-grained annotation that is not tailored to a specific task or genre. High inter-annotator agreement shows that the guidelines can be applied consistently. The guidelines were developed for annotation on Dutch text, but could be applied to other languages as well.

The annotated corpus was used for building a state-of-the-art NER system for main types, and for experimenting on subtype classification. The adopted approach to use genetic algorithms to construct a good ensemble of classifiers resulted in a minor performance improvement over the best individual classifier, but at a high computational cost. Optimizing the features and settings of an individual classifier proved to be a better approach (84.91 % micro-averaged F-score). The resulting system uses a single CRF classifier.

Experiments on subtype classification showed that skewness of some of the classes inhibited proper learning (for product and event subtypes). For organizations and locations, subtypes that occurred with some frequency could be learned successfully. We hope these experiments invite further research on the corpus.
In future work, we would like to investigate the effect on main type classification performance of doing feature selection using conditional random fields instead of MBL, and of hyperparameter tuning. Given that the corpus consists of different genres, we would also like to experiment on performance across genres and domain adaptation. The resulting main type NER system will also be evaluated as a component for other NLP tasks.

The features we used for subtype classification are useful, but there is room for improvement, especially for subtypes that lack evidence in the training data. Adding features that better capture contextual clues shared by entities of the same subtype would likely be beneficial, as well as features that derive information from external resources such as name ontologies or Wikipedia.

Finally, the corpus we present is a resource that should be very interesting for experiments on metonymy resolution.
 References
 Abstract This paper describes the creation of a fine-grained named entity anno-tation scheme and corpus for Dutch, and experiments on automatic main type and subtype named entity recognition. We give an overview of existing named entity annotation schemes, and motivate our own, which describes six main types (per-sons, organizations, locations, products, events and miscellaneous named entities) and finer-grained information on subtypes and metonymic usage. This was applied to a one-million-word subset of the Dutch SoNaR reference corpus. The classifier for main type named entities achieves a micro-averaged F-score of 84.91 %, and is publicly available, along with the corpus and annotations.
 Keywords Named entity recognition Annotation Classifier ensembles Subtype classification 1 Introduction Named entity recognition (NER) is the task of automatically identifying names in text and classifying them into a pre-defined set of categories. These categories are application-dependent, and will therefore differ across domains. In the biomedical domain, for example, proteins, genes and chemical substances are common named entities. General-domain NER is typically concerned with finding names of persons, locations and organizations, and sometimes also dates and amounts (Nadeau and Sekine 2007 ). Originating as a subtask for information extraction at the Sixth Message Understanding Conference (MUC-6) (Grishman and Sundheim 1996 ), NER has been an active field of study in the past 15 years.

Finding named entities in text is often an essential preprocessing step for NLP applications. Systems for information retrieval and question answering are usually designed to process information related to named entities. Some opinion mining tasks are focused on monitoring or summarizing the sentiment expressed about specific entities, such as companies, products or services (Liu 2010 ). Named entity information can also be helpful for other NLP problems. In coreference resolution systems, for example, it is commonly included in feature representations (Rahman and Ng 2009 ). For machine translation, NER is helpful to find chunks of text that should not be translated (Babych and Hartley 2003 ).
 NER on English newswire text has reached near-human performance (Zhou and Su 2002 ) for the detection of person, organization and location mentions. State-of-the art systems use supervised machine learning, where a model is trained on an annotated corpus that provides gold standard instances to learn from, the size of which is essential to achieve good performance. Such corpora are available for heavily researched languages such as English, but are scarce or small for most minority languages, such as Dutch. Furthermore, many named entity corpora consist of texts from a single genre (mostly newswire for general-domain NER). This causes robustness problems: systems that have been trained on one particular genre tend to perform worse on unseen genres (Poibeau and Kosseim 2001 ). The corpus presented in this paper aims to resolve these problems for Dutch: at one million words manually annotated for general-domain NER, it is the largest corpus to date, consisting of texts from different genres, as described in Sect. 4 .

One of the future challenges for NER research is to classify named entities into a hierarchy of subtypes instead of the coarse main type categories. Named entities of main type location could, for example, be further classified as pertaining to the subtypes continent or country . Such subtype classification would be especially valuable for applications that involve question answering, information retrieval or the automatic construction of ontologies (Lee et al. 2006 ). Another alley of future research is that of metonymic usage detection (Markert and Nissim 2002 ). The literal reading of a named entity may differ from its intended reading, when metonymy is present. Names of countries, for example, may be used to represent the national sports team. This kind of information is relevant for other tasks, such as coreference resolution, information extraction and question answering. Our corpus was annotated with newly developed guidelines that describe fine-grained named entity subtypes, and metonymic usage.

The resulting corpus was used for machine learning experiments on main type and subtype NER. For main type NER, three different machine learning algorithms were used that had previously been successfully applied to the NER problem: memory-based learning (MBL) (De Meulder et al. 2002 ), Support Vector Machines (SVMs) (Asahara and Matsumoto 2003 ) and conditional random fields (CRFs) (Mccallum and Li 2003 ). We also experimented with classifier ensembles, using genetic algorithms to find a good ensemble composition, as proposed in Ekbal and Saha ( 2010 ). These experiments resulted in a robust and state-of-the-art main type NER system for Dutch. Experiments on subtype classification showed that only subtypes that occur frequently in the training data could be learned.

The remainder of this paper is structured as follows: in Sect. 2 , we provide an overview of related work. Section 3 presents the annotation scheme and Sect. 4 the corpus we developed. In Sect. 5 , an overview is given of the methods used, Sects. 6 and 7 describe the experiments and results for main type and subtype NER, respectively. Finally, Sect. 8 concludes this paper. 2 Related work An extensive literature exists on main type NER (Nadeau and Sekine 2007 ). Early approaches developed for the MUC-7 competition were predominantly rule-based (Chinchor 1998 ). These required manually creating rules, a time-consuming process which hinders porting to new domains or languages. However, rule-based systems are still useful today for tasks where training material is unavailable (e.g. Sekine and Nobata 2004 ). Rules are often combined with gazetteers, where candidate names are looked up in lists of names belonging to a given category.

More recent systems typically use supervised machine learning, which rely on an annotated training corpus, from which a learning algorithm infers patterns associated with named entities, based on morphological, syntactic, lexical and contextual features. Supervised systems have been built that attain performances on the English MUC shared task datasets similar to that of human annotators (Zhou and Su 2002 ). Given these results, the NER problem, as it was defined for the MUC competitions for English, could almost be considered solved. However, because of the acquisition bottleneck for large annotated corpora, some work has focused on unsupervised and semi-supervised NER.

In a typical unsupervised approach, named entities are clustered based on contextual similarity (e.g. Alfonseca and Manandhar 2002 ). Another unsupervised technique exploits the simultaneous occurrence of named entities in news sources, allowing the detection of rare or new named entities (Shinyama and Sekine 2004 ). These kinds of entities are often missed by supervised systems, making the two approaches complemental.

In semi-supervised NER, a small supervised set of seeds is used to start the learning process. The system looks up sentences that contain these seeds, tries to identify contextual rules for them, and then looks for words occurring in similar contexts to expand the seed list. When repeated, this bootstrapping technique eventually yields a large number of hits, with a performance that rivals baseline supervised approaches (Nadeau et al. 2006 ).

In summary, supervised methods currently yield the best performance, but an annotated corpus is a prerequisite. Among the named entity resources available for English are the manually annotated datasets from the MUC-7 Named Entity Task (Chinchor 1998 , 162,692 tokens) and the CoNLL-2003 shared task (Tjong Kim Sang and De Meulder 2003 , 301,418 tokens), and the BBN Pronoun Coreference and Entity Type Corpus (Weischedel and Brunstein 2005 ), which provides a named entity and coreference annotation layer for the Penn Treebank corpus of Wall Street Journal texts (1,173,766 tokens). For Dutch, however, the data from the CoNLL-2002 shared task (Tjong Kim Sang 2002a ), containing 309,686 tokens from four editions of the Belgian newspaper De Morgen of 2000, constitute the only corpus annotated with named entity information that is readily available at present.
The CoNLL corpora were annotated with four main type named entities: persons, locations, organizations and miscellaneous entities. Because of the importance of shared tasks for the NER field, this CoNLL typology is a standard for main type NER, along with those developed for the MUC conferences (Chinchor 1997 ) and ACE (LDC 2008 ). LDC ( 2008 ), Sekine and Nobata ( 2004 ) and Weischedel and Brunstein ( 2005 ) described hierarchies for fine-grained classification into subtypes, with up to 200 categories. For the annotation of metonymy in named entities, guidelines have been proposed by LDC ( 2008 ) and Markert and Nissim ( 2002 ). We developed guidelines that attempt to synthesize these systems into one, which can be applied to Dutch and other languages. A notable difference between Dutch and English that is addressed in the guidelines, is the fact that Dutch compounds are written in one word. As a result, named entities may be embedded in longer strings that, as a whole, are not a named entity. The resulting guidelines are discussed and motivated in detail in Sect. 3 .

Whereas coarse-grained NER is well-researched, fine-grained classification of named entities into subtypes has not been so widely studied. Fleischman ( 2001 ) introduces a system that categorizes locations into 8 subtypes. First, instances are classified using context word unigrams, bigrams and trigrams as features. Then, each instance is given the class that occurs most frequently with that instance. This second step ignores the possibility that identical instances may have different classifications (e.g. Washington the state, and Washington the city). The system is enhanced in Fleischman and Hovy ( 2002 ), for subtype classification of persons into 8 professions. Instead of using surface forms from the context, each context position is represented as the likelihood that it co-occurs with any of the 8 subtypes. Eight topic signatures are used to convey semantic information about the overall context, and eight more that have been expanded using WordNet. Classification performance is good on validation data, but on held-out test data it is hampered by the automatic training data collection, which was compiled using high-confidence classifications from an initial classifier trained on seeds.

More recent work on fine-grained NER has focused mainly on extending the number of classes and linking entities to existing concept hierarchies such as those found in Wikipedia or the People Ontology. Notable examples are the work of Ponzetto and Navigli ( 2009 ), who enrich WordNet synsets using a taxonomy of fine-grained category-tagged instances from Wikipedia (amongst which many named entities), Ling and Weld ( 2012 ), who propose a NER system capable of doing multi-label prediction from 112 tags, and Hoffart et al. ( 2013 ), who present YAGO, a knowledge base that links factual information (such as time and place information) to nearly 10 million entities. However, such systems that focus on ontology population or knowledge base enrichment do not tackle fine-grained tagging of all the entities encountered in a given document. Ekbal et al. ( 2010 ) describe a tentative system for open-domain fine-grained NER for persons, using a maximum entropy classifier with features that describe context words, affix, POS and chunk information, capitalization, word length and frequency, presence of non-alphanumeric characters and the class of the previous word.

In this paper, we present experiments on subtype classification for all main types that have subtypes (persons, locations, organizations, products and events), in order to test its feasibility on our dataset, and to provide a baseline for further research.
To our knowledge, the only NER system available for Dutch is the one integrated in Frog 1 (van den Bosch et al. 2007 ). This system looks up persons, organizations and locations using the gazetteers described in De Meulder et al. ( 2002 ), and other lists of names harvested from Teletext. It has recently been replaced by a NER system trained on the data described in this paper. 3 Annotation In this section, we describe previous work on named entity annotation guidelines, and lay out and motivate differences with our annotation guidelines (Desmet and Hoste 2010 ), 2 followed by examples. Figure 1 gives a schematic overview of the possible annotations. 3.1 Main types and subtypes In 1995, the first widely-used named entity annotation guidelines were developed for the MUC shared tasks, which were aimed at information extraction from text. Three kinds of annotation were proposed: entities (persons, organizations and locations), times (dates and times) and quantities (monetary values and percent-ages). These were known as enamex , timex and numex annotations. The enamex category is the one that is typically associated with named entities in the strict sense of proper names.

For the CoNLL NER shared task of 2002, only enamex entities were considered, and a fourth miscellaneous category was added for proper names falling outside the original 3 enamex groups.

The ACE guidelines for entities also expanded the enamex typology. They introduce categories for geo-political entities or GPEs (geographical regions defined by political or social groups, such as nations) which were previously annotated as locations, facilities (man-made structures such as buildings or bridges) which subsume some entities from the types location and organization, vehicles and weapons . Furthermore, they describe subtypes for most categories (e.g. locations can have subtype address, boundary, celestial, water-body, land-region-natural, region-international or region-general ). The ACE guidelines also define two forms of metonymy annotation, which are discussed below.

Brunstein ( 2002 ) describes the categories and guidelines assembled by BBN. It has two levels, with 29 main types and 64 subtypes, and further expands the hierarchy proposed for ACE. Weapons and vehicles become subtypes under the main type product , and the following new main types are added: NORP (nationality, religions, political and other named entities describing affiliation), events, plants, animals, substances, diseases, works of art, laws, games, languages and contact information . It also includes and expands the timex and numex categories ( date, time, percent, money, quantity, ordinal and cardinal ).

The most elaborate typology is the one described in Sekine and Nobata ( 2004 ). It consists of hierarchies for namex, timex and numex expressions. In the namex hierarchy, organization, location, facility, product, event, natural object, title and unit have subtypes, whereas person, vocation, disease, god, ID number, color and name-other do not. For some types, the hierarchy is more than two levels deep: subtypes can have subtypes, e.g. natural object &gt; living thing &gt; animal &gt; invertebrate &gt; insect .

The timex category was further elaborated in Ferro et al. ( 2005 ). Because of the availability of spatiotemporal information in our corpus (see Sect. 4 ), a timex category would have been redundant in our annotation scheme. The annotation scheme we propose is solely focused on expressions from the enamex category.
The typology we developed aims to strike a balance between granularity, learnability and task independence. Whereas the level of detail in MUC and CoNLL may be too limited for some applications, Sekine X  X  rule-based approach suggests that his typology is too detailed to be learned automatically. We therefore made a relatively coarse-grained structure consisting of six main types, with subtypes that capture the granularity of the more elaborate typologies. One example is location , which incorporates facility as a subtype, along with celestial, water-body , etc. We chose not to have main types that are tailored to a specific task, such as the weapons and vehicles categories in ACE.

The six main type categories are as follows:  X  PER: names of persons, fictitious characters, gods, artist names and generational  X  ORG: names of organizations, including organizational suffixes; e.g. European  X  LOC: names of locations, and derived adjectives; e.g. Paris, Mount Everest,  X  PRO: names of products, awards, works of art and languages; e.g. Office 2007,  X  EVE: names of events; e.g. World War II, Katrina  X  MISC: miscellaneous names of species, substances, periods etc.; e.g. Mesozoic ,  X  Persons are categorized into 9 fields: sports (such as athletes and coaches),  X  Organizations can be classified as governmental (public institutions), commer- X  Locations are divided into continents, countries, regions (such as provinces and  X  Products are classified as shares (on the stock market), languages or  X  Events are labeled as either human (such as wars and sports events) or natural 3.2 Metonymic usage Some entities can be hard to annotate because of ambiguity between main types, such as locations , GPEs and organizations . Such entities can often take on different roles, according to their usage. Consider Sentence 1: 1. The White House opted for modern works of art, including a Rothko.

Cases like White House being classified as location rather than organization are a common confusion (Nothman et al. 2009 ). Similarly, Rothko can be considered a person or product entity. This ambiguity can be solved by annotating metonymy, in which one expression is used to refer to the referent of a related one.

The ACE guidelines describe two forms of metonymy. Nickname metonymy capital city referring to a government, or a location name denoting a sports team. Cross-type metonymy occurs when multiple aspects of an entity are referenced at the same time, such as organizations and the facilities they occupy (e.g. They will be visiting the White House tomorrow ).

Markert and Nissim ( 2002 ) argue that although metonymic readings are potentially open-ended and can be innovative, there is a regularity to the metonymic usage of word groups. Therefore, given a semantic class (e.g. location), several regular metonymic patterns (e.g. place-for-event) can be specified that instances of the class are likely to undergo. They describe three patterns for locations ( place-for-people, place-for-event and place-for-product ) and five patterns for organizations ( org-for-members, org-for-product, org-for-facility, org-for-stock-index and org-for-event ), along with some general patterns that may apply to all semantic classes ( object-for-representation and object-for-name , when a name is used as a mere signifier, or other-metonymy for metonymy that does not fit a common pattern) (Nissim and Markert 2005 ).

We adapted this approach, by describing metonymic patterns for all main types except miscellaneous . By marking whether a named entity is used literally or metonymically, we can consistently label named entities for their literal main and subtype, and use metonymic roles to point to their intended main and subtype. This is exemplified in Sentence 2:
Because it is often impractical to determine whether a named entity is used metonymically as PER or as ORG, we combined them in the intended type human . White House might refer to a person, namely the U.S. president, or to an organization-like group of people such as the White House staff.

Marking metonymy does not only do away with confusable main types, it should also benefit other NLP tasks such as coreference resolution. For example, a coreferential resolution algorithm could link an inanimate noun phrase like the painting to Rothko in Sentence 2 if it has access to named entity classifier output that does not only mark  X  X  X othko X  X  literally as an (animate) person, but also metonymically as a product. This in turn allows information extraction and question answering applications to link the selling price of 1.7 million to Rothko .
The addition of metonymy annotations further contributes to the experimental value of the corpus, as automatic metonymy resolution is a valuable field of study in itself. 3.3 Guideline evaluation In order to evaluate the guidelines, two linguists annotated a set of eight randomly selected texts from the corpus, containing 14,244 tokens in total. Two evaluation metrics were used: Kappa (Carletta 1996 ) and F-score ( b = 1) (Van Rijsbergen 1979 ). F-scores were calculated by taking one annotator as the gold standard and scoring the annotations of the other for precision and recall. This yields the same results as averaging the precision or the recall scores of both annotators, when using the other as a gold standard.

Scores were calculated on 5 levels: chunks (whether a word is annotated as a named entity or not), main type, subtype, usage and metonymic role. For each level, scores were calculated on the entire set, and on a subset containing only those tokens (a) on which both annotators agreed on the preceding level, and (b) which can receive annotation on the current level ( MISC and PER , for example, are not included in the subset for subtype, because they cannot receive subtype annotation). We present these subset results in order to have scores that are not influenced by annotations that are irrelevant at the considered level. The results can be found in Table 1 .
The results show high agreement scores for all levels: Kappa scores above 0.80 are characterized as almost perfect agreement. We can conclude that annotation can be carried out consistently. 4 Dataset The annotation scheme described in Sect. 3 was applied to a part of the STEVIN 3 -funded SoNaR corpus. 4 SoNaR is a reference corpus of written Dutch that comprises a wide variety of texts, including traditional text types (such as newswire, manuals, autocues, fiction and reports) as well as new media (such as blogs, forums, chat and SMS), for a total of 500 million words (Oostdijk et al. 2008 ).

A diverse 1-million-word subset ( SoNaR 1 ) has been manually annotated with named entity information. The diversity in text types, which was lacking in the Dutch CoNLL-2002 dataset, should allow for a more robust classifier and better cross-corpus performance (Nothman et al. 2009 ). It should also make SoNaR 1 an interesting corpus for research on domain adaptation. The possibility to train a robust classifier was essential, because the NER system trained on SoNaR 1 was used to automatically label the remainder of SoNaR.

SoNaR 1 does not only contain named entity information, it has also been provided with a number of other manually corrected annotation layers. The corpus has been syntactically annotated, and there are four semantic layers: named entities, coreference relations, semantic roles and spatiotemporal expressions (Schuurman et al. 2009 ).

SoNaR 1 and its annotation layers are to be released along with the other SoNaR deliverables, including the main type named entity classifier described below, and will be freely available for academic use. The Dutch Human Language Technology Agency (HLT-agency) 5 is responsible for distribution. 4.1 Corpus annotation Manual annotation was done using the MMAX2 annotation tool (Muller and Strube 2006 ). For the named entity task, six annotation layers were created X  X ne per main type. Per text, each annotation layer is stored as a standoff XML file, the content of which is defined by a scheme file. These scheme files contain the possible attributes for every annotation, such as the available subtypes, the choice between literal and metonymic usage, and the metonymic role, if applicable.

Annotation speed averaged around 3,500 words per hour. Taking into account the verification of the annotations by a second annotator, the actual annotation speed was close to 2,000 words per hour.
 4.2 Corpus statistics The distribution of main named entities, subtypes and metonymic usage in the corpus is described in Tables 2 , 3 and 4 , respectively.
 Nearly 10 % of the tokens in the SoNaR corpus are part of a named entity chunk. Locations are the most prevalent main type, followed by persons and organizations. For every six named entities, five pertain to one of these three categories. Miscellaneous entities and products are uncommon, and events are rare.

This distribution is comparable to that in the Dutch datasets for the CoNLL-2002 shared task, which is also presented in Table 2 . The frequency of named entities (9.30 %) is nearly identical. Persons are more frequent in the CoNLL data, locations less frequent, and organizations about equally frequent. The high proportion of locations in the SoNaR data can be explained because nouns and adjectives derived from locations (such as French or Frenchman ) are annotated as LOC in SoNaR, and as MISC in CoNLL. Consequently, MISC annotations are more frequent in CoNLL than in SoNaR. We can conclude that the named entity frequencies in the SoNaR corpus do not violate expectations based on another corpus.
 The subtype distribution is skewed for most main types, except organizations. Person entities in our corpus typically belong to the fields of politics or arts, which together represent more than half of the entities. Around 15 % of the annotations did not pertain to any of the fields, or could not be disambiguated from the context. For locations, countries make out almost half of the annotations, followed by population centres (e.g. Madrid ) and regions (e.g. Alabama ). The remaining location subtypes occur with some frequency, although fictional (e.g. Azkaban ) and extraterrestrial locations (e.g. Mars ) are rare.

Especially for products and events, the skewness of the data is high: out of 2,352 product annotations, there are 77 instances with subtype language, and only 2 with subtype share. This can in part be explained by the nature of the data, which does not include financial news, for which the share subtype is intended. For events, only 24 have subtype natural (e.g. Alex, Zuidwesterstorm ), as opposed to 1,107 with subtype human, which is to be expected given the low number of named natural events.
Metonymy occurs with almost one in twenty named entities in the corpus. It is most frequent in organizations and locations, which are often used to signify humans. Out of 2,610 metonymically used named entities, 223 have an other metonymic role, meaning that 91.46 % of the entities (2,387) follow a predefined metonymic pattern. 5 Methods In this section, we describe the methods used for the main type and subtype classification experiments. We discuss the various classification frameworks that were used ( 5.1 ), the methods used for ensembling classifiers ( 5.2 ), extracted features ( 5.3 ) and evaluation metrics ( 5.4 ). 5.1 Classification frameworks The main type classification experiments in this paper were done with three families of supervised learning algorithms: MBL, SVMs and CRFs. The subtype classification experiments were done with MBL. We briefly describe each classification framework below. 5.1.1 Memory-based learning Memory-based learning algorithms are called lazy learners because they perform no generalization on the instance base they are trained on (Daelemans and van den Bosch 2005 ). All the instances are stored in memory, and new instances are classified by comparing them to the instance base, for example with a k -nearest neighbour algorithm. When a k -value of 1 is used, the classifier labels an unseen instance with its closest neighbour in the instance base. Various distance and feature weighting metrics can be used to determine which neighbour is closest. For larger values of k , some voting mechanism has to be applied to choose one class label from the nearest neighbours set.

We experimented with TiMBL. 6 version 6.2.1 (Daelemans et al. 2009 ). 5.1.2 Support vector machines A support vector machine is a learning classifier capable of binary classification. It learns from the training instances by mapping them to a high-dimensional feature space, and constructing a hyperplane along which they can be separated into the two classes. New instances are classified by mapping them to the feature space and assigning a label depending on its position with respect to the hyperplane. SVMs are said to have a robust generalization ability (Vapnik and Cortes 1995 ).

For multiclass classification problems, separate SVMs have to be built. With the pairwise approach, one SVM is trained for every pair of classes. Another method is one vs rest , where one SVM is built for each class to distinguish it from all other classes.

The SVM implementation used in our experiments is YamCha, 7 version 0.33 (Kudo and Matsumoto 2003 ), with pairwise multiclass classification. 5.1.3 Conditional random fields A conditional random field is a probabilistic classifier that is used to segment and label sequential data, which makes it especially apt for natural language processing tasks like NER. CRFs take an input sequence X with its associated features, and try to infer a hidden sequence Y , containing the class labels. They are as such comparable to Hidden Markov Models (HMMs) and Maximum Entropy Markov Models (MEMMs). However, CRFs, unlike HMMs, do not assume that all features are independent, and they can take future observations into account using a forward-backward algorithm, unlike MEMMs, thus avoiding two fundamental limitations of those models (Lafferty et al. 2001 ).

For our main type experiments, CRF ?? 8 version 0.53 was used. CRF ?? is a sequence tagger, which requires a template file that specifies the combinations of features it needs to consider. 5.2 Classifier ensembles and genetic algorithms The standard way to improve NER classification performance is by optimizing a single classifier. This may involve finding the most informative features, and discarding the uninformative ones (feature selection, Isozaki and Kazawa 2002 )or finding the right settings for a specific algorithm [parameter tuning, De Meulder and Daelemans 2003 ). An alternative research direction is that of combining several classifiers into an ensemble, and combining their output using a voting procedure (Wang et al. 2008 ). The assumption is that combining a diverse set of classifiers improves the generalization accuracy, provided that the ensemble X  X  members have sufficient individual performance and their errors do not entirely overlap.
The output of the individual classifiers in an ensemble can be combined using the following voting procedures:  X  Normal majority voting: every classifier casts a vote for a class tag, and the tag  X  Globally weighted voting: the weight of a classifier X  X  vote is determined by its  X  Class weighted voting: a classifier X  X  vote for one particular class is weighted by  X  Smoothed class weighted voting: the same principle as class weighted voting,
Finding a good combination of classifiers for an ensemble is not a trivial search problem: for n candidate classifiers, there are 2 n -( n ? 1) possible ensemble combinations.
 Genetic algorithms provide an efficient way to select a near-optimal ensemble. They operate on a representation of the search space, called the genome, which in the case of constructing an ensemble from a set of n classifiers can be a binary string of length n , in which every bit represents a classifier. The technique is inspired by evolutionary biology, borrowing evolutionary concepts such as selection (well-adapted or fit individuals are more likely to survive), inheritance (the genetic material is passed on to later generations), mutation (new generations introduces some random variation in the genetic material) and crossover (new genetic material is formed by combining the material of parents). The technique is applied to a problem (Whitley 1994 ).

The search space defined by the genome is explored as follows: 1. An initial population P (0) is created, containing | P | randomly instantiated 2. For each chromosome, a fitness score is calculated. This is done by having the 3. The next step is to select chromosomes that will populate the intermediate 4. When selection is complete, recombination on the intermediate population can 5. Steps 2 X 5 are repeated until a predefined number of generations has been
In Sect. 6.1 , we describe how the genetic algorithm approach was applied to our classifier ensemble selection problem. Our system used Pyevolve, 9 a Python implementation of genetic algorithms. 5.3 Feature representation Supervised machine learning algorithms require that the information present in a classified into a predefined set of classes based on a vector of features describing its attributes.

In the case of main type NER, every token from the corpus is represented by an instance, which has a class indicating whether the token is a named entity, and if so, which type. IOB2 notation (Tjong Kim Sang 2002b ) is used to represent named entity chunks, where O stands for outside a chunk (not a named entity), B for begin (start of a NE chunk) and I for inside a chunk.

The subtype classification systems are main type specific (e.g. locations only), and are presented with instances representing named entities of that main type, with the subtype as the class to be predicted.

We extracted a range of features to describe instances, many of which are commonly used in the field (Tjong Kim Sang 2002b ; Nadeau and Sekine 2007 )or have been studied for Dutch before (Bogers 2004 ). For the main type experiments, the following features were used:  X  Basic information : the original token, its POS tag, which was obtained by  X  Orthographic information : non-exclusive binary features capturing ortho- X  Word shape : a symbolic feature that tests for the same orthographic characteristics  X  Patterns : binary features indicating whether the token matches regular  X  Word length : the number of characters in the token.  X  Character ngrams : the first and the last n characters of the token.  X  Function word : a binary feature indicating whether the token occurs in a list of  X  Chunks : a symbolic feature with a base phrase chunk tag, obtained with the  X  Class tag : the correct classification is taken from the annotations, and is  X  Token : the named entity of which the subtype has to be determined. Multiword  X  Context : the three tokens preceding and following the named entity to be  X  Character ngrams : 6 string features containing the first and the last 2, 3 or 4  X  Decompounding : in Dutch, compounds are written in one word. Decompound- X  Class tag : a symbolic feature indicating the correct subtype. 5.4 Evaluation For main type classification, we evaluate performance using micro-averaged F-score. In micro-averaging, an overall F-score is computed globally over all instances (thus giving higher weight to frequent classes), whereas in macro-averaging, F-scores are first computed for each class under consideration, and then averaged (such that each class has an equal weight in the final score). We use the conlleval.pl script 10 made available for the CoNLL shared tasks, which was written to work with IOB notation, counting NE chunks as one.

For subtype classification, both micro-averaged and macro-averaged F-scores are reported.

Because of the computational requirements of the experiments, a smaller corpus was selected from SoNaR 1 as the development corpus, that had been entirely annotated and double-checked at the time of the experiments. This development corpus consisted of 99 autocue scripts for news shows on Dutch public television experiments. Evaluation on this corpus was done with threefold cross-validation.
After development, the best-performing main type NER system was retrained on the entire corpus. We report tenfold cross-validation performance on this corpus. 6 Main type classification 6.1 Experimental setup The main type NER is a sequence labeling task: each sentence is a sequence of tokens, which needs to be assigned a sequence of IOB labels. Context information is relevant: if one token starts a Person chunk ( B-PER ), it is likely that the next token may also be in that chunk ( I-PER ).

CRF is designed as a sequence labeling machine learner, which tries to find an optimal sequence of labels for the given input sequence. In order to provide context information to the MBL and SVM learners as well, the instances were windowed. Experiments with different window sizes on the development set indicated that a left context of 3 and a right context of 1 yielded the best results. All features were windowed in this fashion.

We experimented with a manual and an automatic approach to find the best-performing combination of features and learning algorithm.

First, we manually combined the features described in Sect. 5.3 into 8 different feature sets, shown in Table 5 . Basic information (original token, POS tag and position in the sentence) was deemed indispensable, and is included in every feature set.

These feature sets were tested with 3 configurations of the classification frameworks:  X  TiMBL with default settings: the IB1 ( k -nearest neighbour) algorithm with a k - X  CRF ?? with the standard feature template.  X  YamCha, using a pairwise multi-class strategy.

These configurations were combined with the 8 feature sets, and tested using threefold cross-validation on the development corpus.

Secondly, we tested whether better performance could be achieved by combining classifiers into an ensemble. These ensemble selection experiments were done automatically, using genetic algorithms to find an optimal classifier ensemble, an approach similar to the one proposed by Ekbal and Saha ( 2010 ), where GAs are used to construct a classifier ensemble out of 19 Maximum Entropy classifiers. We hypothesized that ensembling different types of classifiers would benefit the ensemble performance, assuming that each classifier type makes different kinds of errors (Hastie et al. 2001 ).

The genetic algorithm setup used to find the best classifier ensemble was configured as follows (we refer to Sect. 5.2 for a description of the various settings). A 24-bit genome was used to represent the search space. Every bit in the genome represents the presence (1) or absence (0) of 1 of the 24 classifiers in order, and the combination of those bits determines which classifiers are combined into an ensemble. The chromosome 111111110000000011111111, for example, represents an ensemble in which all TiMBL and all YamCha classifiers are used, and none of the CRF ?? classifiers. The population size | P | was 50. Single Point Crossover occurred with a probability of 0.90, and Flip Mutation with a probability of 0.02, so that every bit in the chromosome had a 2 % chance of being flipped. We stopped the evolution after 40 generations. The selection and mutation types and probabilities are Pyevolve X  X  default parameters. We used the same population size and number of generations as used in the experiments described in Ekbal and Saha ( 2010 ).
Finally, we used the results from the individual and ensemble experiments to construct a system trained on the entire 1-million-word corpus, and report results using tenfold cross-validation. 6.2 Results and discussion 6.2.1 Individual classifiers The performance of each combination of a feature set and a classifier configuration is reported in Table 6 .

It shows that the CRF classifiers present in the pool perform best on average. The best individual classifier is the CRF classifier trained with feature set B, which contains all features (with character ngrams of length 4). 6.2.2 Ensemble classifiers Table 7 presents the outcome of the ensemble selection experiments for each voting mechanism. The genome describes which of the 24 classifiers are included in the ensemble. The precision, recall and F-scores of these ensembles, the ensembling of all classifiers and the best individual classifier are presented in Table 8 .
It can be observed in Table 7 that the best-performing classifier ensembles, regardless of the voting mechanism used, consist of classifiers from all three classification frameworks. Of particular interest is the occurrence of the TiMBL classifiers trained on feature sets D and F, present in all but one and all classifier ensembles, respectively. These classifiers achieve an individual F-score of 75.06 and 76.59, respectively, well below the F-scores of the selected CRF and SVM classifiers. This observation may corroborate that combining different types of learning algorithms in a classifier ensemble can lead to better generalization performance of an ensemble.

A first observation to be made in Table 8 is the influence of the chosen voting mechanism, used for combining the class tags of each individual classifier in an ensemble. In our experiments, the results with class weighted voting consistently trail the other results. We had hypothesized that this could be caused by the higher weight it gives to majority classes, and anticipated the problem with smoothed class weighting. The results confirm that smoothing has a positive effect. Performance differences between the three best voting mechanisms are small, but overall, a simple voting strategy such as normal majority or globally weighted voting can be recommended.
All best-performing classifier ensembles outperform the ensembles consisting of all classifiers by a significant margin. The difference in F-score between the best-performing classifier ensemble (normal majority voting, 84.44) and the best-performing individual classifier (CRF ?? trained on feature set 2, 83.77) is 0.67 % points. This difference was found to be statistically significant.

For the calculation of statistical significance of the F-score, we applied the bootstrap resampling test (Noreen 1989 ; Yeh, 2000 ) to the output of the classifier, a significance test that has been used earlier in the framework of the CoNLL shared task on NER (Tjong Kim Sang and De Meulder 2003 ). Instances are randomly drawn with replacement from the classifier output, forming a so-called bootstrap sample. From the output of each system, 1,000 such bootstrap samples were taken, and the distribution of the F-scores on these samples is assumed to be the distribution of the performance of that system. We used these F-scores to calculate the average F-score, the standard error and the upper and lower boundary of the center 90 % distribution.
If the bootstrap-sampled averaged F-score of system X is outside the 90 % center of system Y , the performance difference between these systems is considered to be statistically significant.

The results confirm that genetic algorithms can be successfully applied to the task of finding a classifier ensemble that outperforms the best individual classifier. However, the performance gains measured in our experiments are not as large as the ones reported in Ekbal and Saha ( 2010 ), where improvements of up to 12.88 F-score percentage points are reported. One possible explanation for this is that the base classifiers used in their experiments were not as strong as the ones used in our experimental setup, leaving a bigger margin for improvement. 6.2.3 Ensembles versus tuning Because of the observation that ensembling did not bring large performance gains, we wanted to test whether an optimized individual classifier could improve on the best ensemble X  X  performance. In a further experiment, we tried to enhance the feature set of the best-performing CRF classifier by including the features of the second-best classifier it did not already have, namely prefixes and suffixes of length 4. This classifier achieved an F-score of 84.91 on the dataset, thus outperforming both the best individual classifier and the best ensemble classifier by 1.14 and 0.47 % points, respectively.
This may suggest that optimizing a single classifier (e.g. with feature selection or parameter optimization) can lead to better performance than using a classifier ensemble approach. This dilemma is consistent with findings for other tasks, such as word sense disambiguation. In the third Senseval competition, for example, a highly optimized single classifier outperformed classifier ensemble systems on the challenge data (Decadt et al. 2004 ). More recent work by Brody et al. ( 2006 ) and Navigli and Ponzetto ( 2012 ), on the other hand, present successful word sense disambiguation approaches with classifier ensembles.

An important factor to consider in the trade-off between ensemble selection and classifier optimization is the computational cost. For large search spaces (e.g. when there are many possible ensemble combinations, features or parameter settings to consider), the cost of evaluating a single combination determines how fast the space ensemble combination, this cost is relatively small, because evaluation consists of combining (known) outputs of individual classifiers, applying a voting strategy, and calculating a performance measure. For classifier optimization, on the other hand, evaluation consists of training a classifier, generating test output, and calculating performance. Lazy learners, such as TiMBL, are forgiving to such an approach, because they can be trained very quickly. However, the time required to evaluate a single greedy classifier, such as CRF ?? , can quickly make optimization computationally infeasible without grid computing infrastructure.
 6.2.4 Feature selection As it has been shown in previous work that lazy learning approaches like TiMBL are more vulnerable to bad features than greedy ones such as SVM and CRF (Daelemans and Hoste 2002 ; Hoste 2005 ), we did feature selection for TiMBL using a genetic algorithm. SVM and CRF are more robust because of their inherent feature weighting. CRF ?? for example was not harmed by bad features: it delivered the best-performing classifier when it had every feature at its disposal (see Table 6 ).
Gallop (Desmet et al. 2013 ), a genetic algorithm toolbox for optimizing learning algorithms, was used for feature selection on two levels: feature groups and individual features. For feature group selection, a 9-bit genome encoded the presence or absence of any of the 8 feature groups described in Sect. 5.3 , with character ngrams divided into two groups (trigrams and four-grams). For individual feature selection, every feature was represented in a 23-bit genome.

Evolution was set to run for 100 generations of 10 individuals each (mutation rate 0.3, crossover rate 0.7). The selected features and resulting scores are presented in Table 9 .
 In our experiment, feature selection yields a performance gain of close to 1 % F-score. Feature group selection performs somewhat better than individual feature selection, which may be due to its reduced search space and better chance for an optimal solution, but both feature selection approaches largely agree on which features are useful for NER with TiMBL.

Unsurprisingly, the original token and POS tag are useful, although the inclusion of the sentence-initial feature appears to be unnecessary. It may be irrelevant because TiMBL has access to a window of 2 tokens on either side of the target token, and infers positional information there.

Orthographic features remain largely unselected, even with individual feature selection. Only the All lowercased and punctuation features are chosen. We hypothesize that the other features are either irrelevant, or redundant because of e.g. character ngram features. The word shape features is also discarded.

Of the pattern features, the detection of name initials is useful, whereas URLs do not need a separate feature. Name initials detection is likely to help classification (as person) rather than detection.

Word length is not relevant to NER. Character ngram information, on the other hand, is. With feature group selection, both trigrams and four-grams are selected. The individual feature selection shows that four-gram prefixes are the most informative.
The function word feature is selected individually, but its presence does not seem to make a difference for feature group selection. Finally, chunking information is not selected in either selection approach.

These experiments show that feature selection is worthwhile for TiMBL classifiers. However, it clearly does not close the gap in performance compared to CRF and SVM. 6.2.5 System evaluation For the development of the publicly released NER system, the best-performing CRF ?? classifier using all features was trained on the 1-million-word SoNaR 1 500-million-word SoNaR corpus. We report results using tenfold cross-validation on SoNaR 1 in Table 10 , and a confusion matrix in Table 11 .

The overall F-score of 80.71 is 3.80 % points lower than the overall F-score on the development set. This drop in performance is to be expected, given that the classifier was optimized for performance on the development set. Overall, precision is slightly higher than recall, but both metrics are balanced.

The results per main type are consistent with the amount of training data available in the corpus: location, the most frequent type, has the highest F-score, followed by person and organization. For these types, precision and recall are balanced. For products, events and miscellaneous entities, however, precision is higher than recall. Recall is low for products in particular, which are most often incorrectly tagged as not-an-entity or as persons.

We see two possible causes for the lower scores for these three types. The variance of the contexts in which persons, organizations and locations may occur is more limited than that for miscellaneous entities and products, thus making it easier to infer patterns from them. The lower availability of training instances for the less frequent types is also a hindrance to performance.

These results cannot directly be compared to output from other systems, but it is worthwhile to consider them alongside results on the Dutch shared task dataset from CoNLL-2002. In Table 12 , we present the results achieved on this dataset with the system of Carreras et al. ( 2002 ). To our knowledge, no work has been published that beat this system X  X  performance for Dutch.

We compare the best shared task results on the development set to our results from tenfold cross-validation on the entire corpus (Table 10 ), which provides a similar difficulty (the test set is not entirely unexpected: in the case of CoNLL, it was the development set, in the case of SoNaR, tenfold cross-validation was used).
It would be unfair to compare these results directly, because of differences in annotation scheme and dataset. Furthermore, the CoNLL-2002 shared task focused on multilingual NER (in this case, for Spanish and Dutch). In general, however, we can observe a few parallels between the results. Overall precision and recall are well-balanced, and overall F-score is roughly comparable at around 80 %. Per-type precision and recall shows the same trends: better precision than recall for ORG and MISC, better recall than precision for LOC. The per-type scores on the CoNLL data have a smaller spread than those on the SoNaR data, where F-scores for PER and ORG are considerably higher, and for MISC (and PRO and EVE) considerably lower than the overall F-score. 7 Subtype classification In this section, we describe experiments on automatic subtype prediction of named entities, after their main type has been determined. 7.1 Experimental setup We approach subtype classification as a pure classification task, where a named entity needs to be given one of the subtypes that its main type allows. We therefore developed five separate classifiers, one for each main type that has subtypes, i.e. all main types except miscellaneous.

The input for each of these systems consisted of all named entities from the development corpus of the correct main type. In a real world setting, a subtype classification system would have to rely on imperfect main type classification for its input, with error percolation and lower performance as a result. We include an end-to-end evaluation at the end of this section.
 We tested different combinations of the features described in Sect. 5.3 , using TiMBL with k = 1. CRF ?? and YamCha, as opposed to TiMBL, are sequence taggers that are unsuitable for a task where instances should be classified without influence of preceding or following instances. We evaluate using threefold cross validation and report micro-and macro-averaged F-score. It is not infrequent that word forms occur multiple times, and both in the training and the test fold (e.g. countries or continents). When they have the same subtype label, their classification is trivial. However, duplicates are not necessarily redundant: more instances provide more context to generalize from, and some word forms have multiple subtype labels (e.g. Washington the state and the city). This is why we report scores over all instances (measuring overall performance), over instances already seen in training (measuring performance on possibly ambiguous word forms), and over instances not seen in training (measuring generalization performance).

We include scores for two baseline systems. The first is a na X   X  ve frequency baseline that assigns the subtype label that occurs most often in training to all test instances. The second baseline is a classifier that only uses the word form as a feature, and is only capable of looking it up in the training data and assigning the most frequent corresponding label. It can therefore be viewed as an informed lookup baseline. On unseen data, these baselines will perform identically, because the lookup baseline falls back on the most frequent class when no match is found. 7.2 Results and discussion 7.2.1 Persons The results for subtype classification on persons are presented in Table 13 .No decompounding features were used for person subtype classification, because the head of a person X  X  name should not be indicative of his profession. Each column in the table represents a classifier. The presence or absence of features used for each classifier is indicated with 1 or 0 in the upper section of the table. The score of the best-performing classifier per metric or subtype is boldfaced. Relative frequencies are given next to each subtype, and subtypes are ordered according to frequency.
For all instances, the classifier with all features performs best. However, for rare subtypes such as business, science, army and fiction, the lookup baseline cannot be beaten. On seen instances, all classifiers that have access to character ngram information perform best. On unseen instances, the three most frequent subtypes (politics, sports and arts) can be modeled with some success, using all features. Law and clergy entities perform well, considering their frequencies. This is due to common context words, such as advocaten ( lawyers ) in the case of law entities. 7.2.2 Organizations Table 14 presents the results for organization subtype classification. Overall, the systems with more features perform better. For all instances, the best results are achieved with all features, although leaving out decompounding information has little influence on performance. Both baselines are easily beaten.
 For seen instances, the lookup baseline performs well, as should be expected. Because of ambiguous word forms, no perfect score is achieved. For commercial and miscellaneous entities, the ambiguity is handled slightly better when ngrams and decompounding are added.

For unseen instances, decompounding hurts performance for governmental and miscellaneous organizations: the classifier with token, context and ngram information performs better. Decompounding does help for detecting commercial organizations. For miscellaneous organizations, the frequency baseline performs best, so no effective learning occurs. This is likely due to the heterogeneous nature of the category. 7.2.3 Locations The results for location subtype classification (Table 15 ) also show that all features are useful. When evaluating on all instances, leaving out any of the features degrades performance, except for the cosmos, water and country subtypes. The development corpus did not contain any fictitious locations.

The results on seen instances are comparable to the ones for organization subtypes: the lookup baseline is beaten by classifiers that include ngram and decompounding information. Extraterrestrial and line locations can be perfectly disambiguated using ngram information only.

On unseen instances, ngrams, context and decompounding help the most, in that order, because eliminating these features from classifier combinations hurt performance most. Unseen population centres, line locations and countries can be predicted well with F-scores above 65 %. Regions, points, continents and water locations can be predicted with some accuracy, extraterrestrial locations not at all. This is consistent with the amount of available training instances for these subtypes.
 7.2.4 Products Character ngrams are the most informative feature for subtype classification of products (Table 16 ). The classifier that only uses ngrams achieves the best macro-averaged F-score on all sets. Adding token, context or decompounding information results in identical or lower scores, showing that these features are either not salient, or harmful.

There were only two instances of products of type share in the dataset, both occurring in the same fold. This fold would either be in training, or in test, and is therefore either not tested, or never seen in training.

On seen instances, the lookup baseline cannot be beaten. On unseen instances, however, classifiers with token and ngram information perform better when evaluating with macro-averaged F-score, because they are capable of detecting languages with some accuracy (50 %). When evaluating with accuracy, however, both baselines perform best, because of the high frequency of miscellaneous products in the data. 7.2.5 Events The results on events (Table 17 ) show that unseen natural events cannot be learned with the features we use. This is probably caused by a lack of training data. There is no ambiguity in the data: word forms either describe natural or human events, which is why the lookup baseline and most other classifiers get perfect results on seen instances.

For unseen instances, the frequency baseline is never beaten, because it never assigns the label natural , whereas the other classifiers do, incorrectly. 7.2.6 All subtypes Overall, the subtype classification experiments show that subtypes can only be detected in unseen word forms when there is enough training material available for the subtype in question (see Table 3 ). All features were useful in predicting those subtypes, particularly character ngrams and context words.

When insufficient training material is available, the frequency baseline performs best in terms of micro-averaged F-score on unseen instances, because of the skewness of the subtype distribution (for events and products). 7.3 End-to-end evaluation We evaluated the performance of subtype classifiers based on perfect input, i.e. input that had been correctly classified at the main type level. In a real world setting, however, such input is not available, and subtype classification is done on imperfect main type information. Table 18 presents subtype classification results (using all subtype features) on main named entity output generated by the single best-performing CRF classifier described in the previous section.

In our cascading setup, errors percolating from the main type level can never be corrected on the subtype level. This end-to-end evaluation is therefore informative mainly to gauge the impact of noise introduced by the main type level on subtype classification performance.

As is to be expected, we find that the drop in subtype performance is consistent with main type performance: persons and locations, which have high recall rates on the main type level, show a 5 X 10 % drop in subtype performance, compared to performance drops of around 50 % for products and events, caused by poor recall on the main type level. Overall, we can conclude that end-to-end automatic subtype classification yields good accuracy for persons, locations and organizations. 8 Conclusions and future work This paper introduced a number of publicly available named entity resources for Dutch. A one-million word corpus consisting of different genres was hand-annotated for named entities, for which subtype and metonymy information is available. Other syntactic and semantic annotation layers are also present in the corpus, making it ideal for experimenting with gold standard preprocessing information, in order to establish performance ceilings.

The annotation scheme and guidelines that were developed integrate ideas from the literature on main types, subtypes and metonymy in named entities, and are aimed at fine-grained annotation that is not tailored to a specific task or genre. High inter-annotator agreement shows that the guidelines can be applied consistently. The guidelines were developed for annotation on Dutch text, but could be applied to other languages as well.

The annotated corpus was used for building a state-of-the-art NER system for main types, and for experimenting on subtype classification. The adopted approach to use genetic algorithms to construct a good ensemble of classifiers resulted in a minor performance improvement over the best individual classifier, but at a high computational cost. Optimizing the features and settings of an individual classifier proved to be a better approach (84.91 % micro-averaged F-score). The resulting system uses a single CRF classifier.

Experiments on subtype classification showed that skewness of some of the classes inhibited proper learning (for product and event subtypes). For organizations and locations, subtypes that occurred with some frequency could be learned successfully. We hope these experiments invite further research on the corpus.
In future work, we would like to investigate the effect on main type classification performance of doing feature selection using conditional random fields instead of MBL, and of hyperparameter tuning. Given that the corpus consists of different genres, we would also like to experiment on performance across genres and domain adaptation. The resulting main type NER system will also be evaluated as a component for other NLP tasks.

The features we used for subtype classification are useful, but there is room for improvement, especially for subtypes that lack evidence in the training data. Adding features that better capture contextual clues shared by entities of the same subtype would likely be beneficial, as well as features that derive information from external resources such as name ontologies or Wikipedia.

Finally, the corpus we present is a resource that should be very interesting for experiments on metonymy resolution.
 References
