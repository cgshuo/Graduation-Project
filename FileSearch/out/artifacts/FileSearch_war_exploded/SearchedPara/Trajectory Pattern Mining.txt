 The increasing pervasiveness of location-acquisition tech-nologies (GPS, GSM networks, etc.) is leading to the collec-tion of large spatio-temporal datasets and to the opportunity of discovering usable knowledge about movement behaviour, which fosters novel applications and services. In this paper, we move towards this direction and develop an extension of the sequential pattern mining paradigm that analyzes the trajectories of moving objects. We introduce trajectory patterns as concise descriptions of frequent behaviours, in terms of both space (i.e., the regions of space visited during movements) and time (i.e., the duration of movements). In this setting, we provide a general formal statement of the novel mining problem and then study several different in-stantiations of different complexity. The various approaches are then empirically evaluated over real data and synthetic benchmarks, comparing their strengths and weaknesses. H.2.8 [ Database Applications ]: Data mining Algorithms Trajectory patterns, Spatio-temporal data mining
Spatio-temporal patterns that succinctly show the cumu-lative behaviour of a population of moving objects are useful abstractions to understand mobility-related phenomena. In particular, a form of pattern, which represents an aggre-gated abstraction of many individual trajectories of moving objects within an observed population, would be extremely useful in the domain of sustainable mobility and traffic man-agement in metropolitan areas, where the discovery of traffic Copyright 2007 ACM 978-1-59593-609-7/07/0008 ... $ 5.00. flows among sequences of different places in a town (origin-destination flows) is a key issue [2].

Nowadays, the movement of people or vehicles within a given area can be observed from the digital traces left be-hind by the personal or vehicular mobile devices, and col-lected by the wireless network infrastructures. For instance, mobile phones leave positioning logs, which specify their lo-calization, or cell, at each moment they are connected to the GSM network; analogously, GPS-equipped portable devices can record their latitude-longitude position at each moment they are exposed to a GPS satellite, and transmit their tra-jectories to a collecting server. The pervasiveness of ubiqui-tous technologies guarantees that there will be an increasing availability of large amounts of data pertaining to individual trajectories, at increasing loca lization precision; therefore, there is an opportunity  X  and a challenge  X  to discover auto-matically, from these trajectories, spatio-temporal patterns that convey useful knowledge.

In this paper, we precisely address this problem, and intro-duce a novel form of spatio-temporal pattern, which formal-izes the mentioned idea of aggregate movement behaviour. The new pattern, that we call a trajectory pattern ,represents a set of individual trajectories that share the property of vis-iting the same sequence of places with similar travel times. Therefore, two notions are central: (i) the regions of interest in the given space, and (ii) the typical travel time of moving objects from region to region. In fact, in our approach a trajectory pattern is a sequence of spatial regions that, on the basis of the source trajectory data, emerge as frequently visited in the order specified by the sequence; in addition, the transition between two consecutive regions in such a se-quence is annotated with a typical travel time that, again, emerges from the input trajectories. For instance, consider the following two trajectory patterns over regions of interest in the centre of a town: Railway Station 15 min  X  X  X  Castle Square 2 h 15 min  X  X  X  Museum ( a ) Railway Station 10 min  X  X  X  Middle Bridge 10 min  X  X  X  Campus ( b )
Here, pattern (a) may be interpreted as a typical be-haviour of tourists that rapidly reach a major attraction from the railway station and spend there about two hours before getting to the adjacent museum. Pattern (b), instead, may highlight the pedestrian flow of students that reach the university campus from the station: for them, the central bridge over the river is a compulsory passage. It should be observed that a trajectory pattern does not specify any particular route among two consecutive regions: instead, a typical travel time is specified, which approximates the (sim-ilar) travel time of each individual trajectory represented by the pattern. Also, it should be observed that the individual trajectories aggregated in a pattern are not necessarily si-multaneous: we only require that such trajectories visit the same sequence of places with similar transition times, even if they start at different absolute times 1 . Trajectory patterns are a spatio-temporal variant of the temporally-annotated sequences ,or T AS in short, introduced in [5], where only the time dimension is taken into account and the elements of a frequent sequence are generic events without any specific spatial semantics.

Obviously, once defined a potentially useful pattern, it is necessary to provide an effective mining algorithm to extract trajectory patterns from the source trajectory data. We ac-tually provide three algorithms for trajectory pattern min-ing, with reference to three approaches of increasing com-plexity for dealing with the spatial dimension. The first two solutions share the idea that the problem of identify-ing the regions of interest is a discretization problem for the spatial dimension, to be tackled before the actual mining of trajectory patterns: in this approach, the input trajecto-ries are transformed from sequences of points into sequences of regions of interest in a preprocessing step; then, in the pattern mining step, the temporal dimension only is taken into account, in order to mine sequences with temporal an-notations, by adopting the method introduced in [5]. The first two methods differ in the form of spatial discretization adopted: The third trajectory pattern mining algorithm is genuinely spatio-temporal, in the sense that the identification of the re-gions of interest is dynamically intertwined with the mining of sequences with temporal information. This approach is capable to detect more precise trajectory patterns, as the re-gions of interest are incrementally identified as locally dense regions, i.e., with respect to the trajectories in the patterns found so far.

The methods have been put in practice in an empirical ex-periment over synthetic and real datasets of GPS trajectory data, as a preliminary demonstration of the computational feasibility of our approach, as well as of the usefulness of the introduced pattern. Summarizing, the contributions pre-sented in this paper are: ( i ) the definition of the novel tra-jectory pattern (Section 3); ( ii ) a density-based algorithm for discovering regions of interest (Section 4); ( iii )atra-jectory pattern mining algorithm with predefined regions of
It is however possible to focus on specific time intervals, e.g., rush hours, by temporal selection over the input tra-jectories. interest (Section 5); ( iv ) a trajectory pattern mining algo-rithm which dynamically discovers regions of interest (Sec-tion 6). The paper is completed by a discussion of related work (Section 2) and a report of preliminary empirical ex-periments (Section 7).
In this section we summarize some relevant research re-lated to the topic of this paper, and introduce some basic concepts and terminology.
The basic frequent sequential pattern (FSP) problem, orig-inally introduced in [1], is defined over a database of se-quences D , where each element of each sequence is a time-stamped set of items  X  i.e., an itemset . Time-stamps de-termine the order of elements in the sequence. Then, the FSP problem consists in finding all the sequences that are frequent in D , i.e., appear as subsequence of a large percent-age of sequences of D .Asequence  X  =  X  1  X  X  X  X  X  X   X  k is a subsequence of  X  =  X  1  X  X  X  X  X  X   X  m (  X   X  )ifthereexist integers 1  X  i 1 &lt; ... &lt; i k  X  m such that  X  1  X  n  X  Then we can define the support supp D ( S )ofasequence S as the percentage of transactions T  X  D such that S T ,and say that S is frequent w.r.t. threshold s min if supp D ( S ) s min . Since its first definition, many algorithms for sequen-tial patterns have been proposed, from the earliest in [1], to the more recent PrefixSpan [9] and SPADE [12].

Moving from the discrete realm of items and events to the continuous context of spatio-temporal sequences, such as the sequence of positions of a moving object, the standard no-tion of sequential pattern borrowed from transactional data mining, i.e., a pattern that exactly occurs several times in the data, usually cannot be applied and thus some kind of tolerance to small perturbations is needed. To the best of our knowledge, the existing literature on this subject is com-posed of only a few recent works, that tackle the problem from different viewpoints.

The work in [3] considers patterns that are in the form of trajectory segments and searches approximate instances in the data; on the opposite, the work in [7] provides a clustering-based perspective, and considers patterns in the form of moving regions within time intervals, such as spatio-temporal cylinders or tubes and counts as occurrences all trajectory segments partially contained in the moving re-gions. Finally, a similar goal, but focused on cyclic patterns, is pursued in [8]: the authors propose an effective and fast mining algorithm for retrieving maximal periodic patterns, treating time as discrete, yet dealing with continuous spatial locations that are discretized dynamically through density-based clustering.

We conclude this section mentioning a different line of re-search focused on the extraction of patterns over sequences of events that describe also the temporal relations between events, e.g., sequences with characteristic transition times between consecutive events (as first proposed in [11] and later more deeply explored by [5]), or more general sets of events with temporal constraints between them, such as chronicles [10]. We notice that these methods are not spe-cific for moving object data, and so far no specific work has been presented in literature for the spatio-temporal context.
This paper, instead, focusses on a method for extracting patterns containing both spatial and temporal information, building on the work in [5], which is purely temporal. The rest of this section briefly su mmarizes the key aspects of this work.
Temporally annotated sequences ( T AS ), introduced in [5], are an extension of sequential patterns that enrich sequences with information about the typical transition times between their elements. T AS  X  X  have the following form: also represented as a couple T =( S, A )ofasequence S = s 0 ,...,s n with temporal annotations A =  X  1 ,..., X  n .
As an example, a T AS over the web pages visited along sev-eral user navigation sessions can be the following: {  X / X  {  X /papers.html X  } 90  X  X  X {  X /kdd.html X  } , that represents a se-quence that starts from the root, then after 2 seconds con-tinues with page  X  X apers.html X  and finally, after 90 seconds ends with page  X  X dd.html X .

Similarly to traditional sequential pattern mining, the no-tion of frequency is based on the notion of support of a T AS which in turn is defined as the number of input sequences that contain the T AS . The key notion of containment can be defined as follows:
Definition 1. (  X  -containment (  X  )) Given a time thresh-old  X  ,a T AS T = s 0  X  1  X  X  X  X  X  X   X  n  X  X  X  s n is  X  -contained (or occurs ) in an input sequence I = ( I 0 ,t 0 ) ,..., ( I m ,t m ) , denoted as T  X  I , if and only if there exists a sequence of integers 0  X  i 0 &lt;  X  X  X  &lt;i n  X  m such that: Essentially, a T AS T is  X  -contained into an input sequence I if there is an occurrence of T in I (condition 1) having transition times similar to the annotations in T (condition 2). An example of  X  -containment is the following: where the sequence in T occurs in I , and the transition times of the occurrence differ at most of 2 time units. Therefore, if  X   X  2wehavethat T  X  I .

Now, frequent sequential patterns can be easily extended to the notion of frequent T AS  X  X  , which are simply defined as T AS  X  X  that are  X  -contained in at least s min input sequences, s min being a minimum support threshold provided by the user. However, introducing time in sequential patterns gives rise to a novel issue: in general the number of frequent T AS for a dataset is infinite. For instance, in the single-sequence example given above, if  X  =2and s min = 1, not only T is frequent, but also any other variant of T having transition times t 1 ,t 2 ,where t 1  X  [1 , 5] and t 2  X  [9 , 13].
In [5] it was shown that discovering the frequent T AS  X  X  ( S, A ) for any given sequence S can be neatly formalized as a density estimation problem (in particular, a kernel-based estimation problem), and that the infinite set of frequent T AS  X  X  can be represented in a finite and concise way.
Finally, an efficient prefix projection-based algorithm for extracting frequent T AS  X  X  was provided, that interleaves pre-fix extension steps and detection of frequent annotations for each prefix, exploiting the monotonicity properties of den-sity over the annotation space and the relations between frequent sequences and frequent T AS  X  X .
The basic object of our investigation is the trajectory that describes the movement of an object. To our purpose, a tra-jectory of an object is a sequence of time-stamped locations, representing the traces collected by some wireless/mobility infrastructure, such as the GSM mobile phone network, or GPS traces recorded by portable devices and transmitted to a central server. The location, like a GSM cell or a lat-long pair, is abstracted using ordinary Cartesian coordinates, as formally stated by the following:
Definition 2. (ST-sequence) A spatio-temporal sequence (ST-sequence) or trajectory is a sequence of triples S = stamp,  X  0  X  i&lt;k t i &lt;t i +1 and ( x i ,y i ) are points in R
The fundamental step in moving from sequences to spatio-temporal sequences consists in replacing the discrete ele-ments that form each sequence, usually taken from a prede-fined alphabet, with spatial locations. Therefore, mining spatio-temporal sequences will focus on the relations be-tween (chronologically ordered) positions in space, whereas standard sequence mining focuses on relations between some given event types (taken from the above mentioned alpha-bet).

The key task in sequence mining consists in counting the occurrences of a pattern, i.e., those segments of the input data that match a candidate pattern. Matching the elements of a sequence in standard sequential patterns requires sim-ple equality tests between symbols; instead, in our context it requires matching spatial locations, on the base of some no-tion of approximated match and error tolerance. That can be formally expressed in a simple and general way by means of a neighborhood function N : R 2  X  X  ( R 2 ), which assigns to each pair ( x, y )aset N ( x, y ) of neighboring points.
Definition 3. (Spatial containment, N )Given a sequence of spatial points S = ( x 0 ,y 0 ) ,..., ( x k ,y k ) ,aspatio-tempor-al sequence T = ( x 0 ,y 0 ,t 0 ) ,..., ( x n ,y n ,t n ) and a neigh-borhood function N : R 2  X  X  ( R 2 ), we say that S is con-tained in T ( S N T ,orsimply S T ,when N is clear from context) if and only if there exists a sequence of integers 0 i &lt;  X  X  X  &lt;i k  X  n such that:  X  0  X  j  X  k . ( x j ,y j )
The inclusion of temporal information in a sequential pat-tern can be obtained by making the patterns include tem-poral constraints between consecutive elements of the se-quence, following the same spirit of temporally annotated sequences ( T AS )[5]:
Definition 4. (T-pattern) A Trajectory pattern , called T-pattern, is a pair ( S, A ), where S = ( x 0 ,y 0 ) ,..., ( x is a sequence of points in R 2 ,and A =  X  1 ,..., X  k  X  R the (temporal) annotation of the sequence. T-patterns will also be represented as ( S, A )=( x 0 ,y 0 )  X  1  X  X  X  ( x 1 Figure 1: Matching T-pattern ( x 0 ,y 0 )  X  1  X  X  X  ( x 1 ,y against an input ST-sequence.

An occurrence of a T-pattern takes place when both spa-tial positions and transition times of the pattern approxi-matively correspond to those found in an input sequence: Definition 5. (Spatio-temporal containment, N, X  ) Given a spatio-temporal sequence T , time tolerance  X  ,a neighborhood function N : R 2  X  X  ( R 2 ) and a T-pattern that ( S, A ) is contained in T (( S, A ) N, X  T ,orsimply ( S, A ) T , when clear from context) if and only if there ex-ists a subsequence T of T , T = ( x 0 ,y 0 ,t 0 ) ,..., ( x such that: 1. S N T ,and where  X  j = t j  X  t j  X  1 .

Intuitively, a T-pattern is contained in a trajectory if the latter contains an approximated instance of the former, the approximation being associated with both the spatial and the temporal dimensions. We notice that comparisons are not performed on absolute times, as spatio-temporal con-tainment is based on the transition times between two con-secutive elements in the sequence, expressed by the  X  i and  X  i terms of condition 2 in Definition 5.

As an example, Figure 1 shows how the spatial and tempo-ral constraints essentially form a spatio-temporal neighbor-hood around each point of the reference trajectory. More-over, we notice that in our model the neighborhood N () of a point depends only on the spatial coordinates of the points, and therefore neighborhoods are time-independent. In the graphical example, this is reflected by the shape of the spatio-temporal neighborhood, which is obtained as ex-trusion of a spatial neighborhood along the time dimension.
From containment, a natural definition of support and fre-quent pattern can be assigned, as well as a general definition of the trajectory pattern mining problem.

Definition 6. (Trajectory pattern mining) Given a data-base of input trajectories D , a time tolerance  X  ,aneighbor-hood function N () and a minimum support threshold s min , the trajectory pattern mining problem consists of finding all frequent T-patterns, i.e., all T-patterns ( S, A ) such that where the support support D , X ,N of a T-pattern ( S, A )isthe number of input trajectories T  X  X  such that ( S, A ) N, X  T .
Notice that the neighborhood function is a parameter of the definition of containment, and different neighborhood functions yield different variants of frequent T-patterns. In particular, some choices lead to very complex mining prob-lems, while others yield more tractable variants. Section 4 will introduce an approach of the latter kind, while Section 6.1 discusses a complex example of the former kind and is followed by a trade-off solution described in Section 6.2.
The general problem defined is Section 3 flexibly allows to follow several different approaches, each corresponding to a different choice of the neighborhood function N ( x, y ). Choosing a neighborhood function essentially means imple-menting some specific notion of spatial similarity that will be used in the spatio-temporal containment test. In this section, in particular, the neighborhood function is used to model Regions-of-Interest (RoI), that represent a natural way to partition the space into meaningful areas and, cor-respondingly, to associate spatial points with region labels. A straightforward solution is to reduce the problem of T-pattern mining to the problem of mining simple T AS  X  X , for which an efficient solution was already provided. The details of such a reduction process are provided in Section 4.1. Here we assume to receive as input a set R of disjoint spa-tial regions  X  each representing a place that is relevant for our analysis  X  which will be used to define a neighborhood function in the following way:
The neighborhood of a spatial point is the whole region it falls in, i.e., two points are considered similar iff they fall in the same region. All points that are not covered by the regions in R have an empty neighborhood, meaning that they are not similar to any point (including themselves). The result is that points disregarded by R will be virtually deleted from trajectories and spatio-temporal patterns.
Static neighborhoods N R () greatly simplify the problem of mining T-patterns. Indeed, it results that we can re-place ST-sequences with corresponding sequences of regions, thus treating the spatial information only in a preprocessing step 2 :
Theorem 1. A T-pattern ( S, A ) is contained in a ST-borhood N R () iff the T AS ( S ,A ) is contained in sequence T , where S (resp. T ) is obtained by mapping each spatial point ( x, y ) of S (resp. T )to N R ( x, y ) , removing empty regions.
The regions associated with each point, i.e., N R ( x, y ), are essentially used as labels representing events of the form  X  X he trajectory is in region N R ( x, y )attime t  X . Thus, the meth-ods developed for extracting frequent T AS  X  X  can be directly applied to the translated input sequences, and each pattern
Due to space limitations, proofs of theorems are not given here, and are available in [6]. (
T AS )oftheform A  X   X  B represents (i.e., can be translated back to) the set of T-patterns { ( x, y )  X   X  ( x ,y ) | ( x, y ) A  X  ( x ,y )  X  B } . As we can see, in the RoI approach to the problem, the output obtained by the translated input sequences (i.e., A  X   X  B ) also provides a clear and compact representation of the real set of frequent T-patterns that are contained in the original dataset.

In several contexts the mining problem comes with an apriori knowledge of suitable Regions-of-Interests to ap-ply, manually obtained by experts in the application do-main or simply through commonsense. For instance, origin-destination matrices are a common tool for the analysis of urban mobility flows, and both origins and destinations are usually given as background knowledge or they are the re-sults of some preliminary study [2]. However, in some cases we do not have these information in advance, and therefore they have to be derived someway, as discussed in the rest of this section.
 When Regions-of-Interest are not provided by external means (manually specified by the user, chosen by ad hoc algorithms exploiting some form of background knowledge, etc.) they have to be automatically computed through some heuristics.
This approach is very similar to the previous one, with the difference that regions are automatically derived from actual data, instead of being statically defined a priori. The un-derlying idea is that locations frequently visited by moving objects probably represent interesting places, as opposed to seldom-visited locations that represent occasional behaviors. E.g., the tourists of a historical town will probably visit the same places of interest, while the routes they follow to move from one interesting place to another may sensibly vary, de-pending on the specific domain (town or countryside).
The natural way of doing that is to consider the set of locations touched by any moving object, possibly taking into account also the duration of its stay on the locations, and to apply some form of clustering algorithm. In particular, the discussion above suggests to adopt methods that take into consideration the density of spatial regions. A detailed solution for the problem is provided in Section 4.2.
Assuming to know a suitable set of RoI, applying them to the T-pattern mining problem simply consists in prepro-cessing the input sequences to corresponding sequences of RoI.

This process implicitly assumes that the observations that compose the input ST-sequences describe the movement of objects to a sufficient level of detail, which can be satisfac-tory, e.g. in the case of GPS trajectories, or not, as in the case of GSM trajectories.

Making assumptions about the movement of objects out of the observation points means to provide a model for such movement, for which a wide range of alternatives are avail-able in the spatio-temporal data modeling literature, e.g., linear regression, Bezier X  X  curves, probabilistic models, con-straints models, etc. One of the simplest and most fre-quently adopted models is the linear regression, which as-sumes a constant speed, constant direction movement be-tween each pair of consecutive observations. When the full motion of objects is reconstructed, in general an object stays inside a region A for a time interval I , instead of a single instant t , and therefore it is not obvious which time-stamp should be associated with the event  X  X egion A  X  X nthetrans-lated sequence. A time-stamp should be chosen following some criteria that correctly models the kind of events de-scribed in the resulting T AS  X  X , since the simple one used so far, i.e.,  X  X he object is inside the region X , is not applicable any more. The basic solution, which will be adopted in the rest of this paper, consists in choosing the time-stamp in the following way:
More advanced solutions could consider exiting times in place of entering times, or both of them, by creating two distinct events R in and R out representing the events  X  X nter R X  and  X  X xit from R X .
When Regions-of-Interest are not known a priori, some heuristics that enable to automatically identify them are needed. Several different methods are possible:
In this section we sketch an example of the second type, that consists in choosing popular regions of the space, thus making only use of the input ST-sequences and not consid-ering any form of geographical knowledge.

The approach is developed in two steps: first, dense (i.e., popular) points in space are detected, and then a set of sig-nificant regions are extracted to represent them succinctly.
The vague notion of popular region can be formulated in several different ways, one of the most natural being any re-gion of space that is visited by several distinct individuals. Following the philosophy behind the notion of T-patterns, in particular, we can start reasoning at the finest level of gran-ularity and consider first popular points in space, i.e., points that are visited by several individuals. Then, adopting the same kind of spatial tolerance introduced in the definition of T-patterns, we can refine the definition by modelling the popularity of a point as the number of distinct moving ob-jects that pass close to it w.r.t. a neighborhood function.
Computing the popularity of points is a distinct count problem (a trajectory touching a point multiple times should
Figure 2: Density with and without regression be counted only once) which becomes complex and compu-tationally expensive if tackled over a continuous space. The complexity of the problem, moreover, can increase depend-ing on the kind of neighborhood used to model the spatial uncertainty (e.g., spherical neighborhoods are more difficult to handle than square ones) and on whether some kind of regression between trajectory points is adopted or not (deal-ing with regression is more complex than dealing with only the points explicitly contained in the trajectories).
To efficiently compute popular points, we discretize the working space through a regular grid with cells of small size. A typical choice is to set cell width at a given fraction of the chosen neighborhood. Then, the density of cells is com-puted by taking each single trajectory and incrementing the density of all the cells that contain any of its points or, tak-ing uncertainty into account, all the cells that intersect the neighborhood of any point of the trajectory. An example of that is provided in Figure 2(a), where a trajectory of two points is shown, with a square neighborhood, a grid hav-ing cell size equal to 1 / 3 of the neighborhood, and where the cells with incremented density are gray colored. In case trajectories are reconstructed through regression, moreover, the increment is performed over all the cells met along the interpolated curve, including the buffer around the curve in-duced by the uncertainty neighborhood, as exemplified by Figure 2(b). As discussed above, this process is performed ensuring to increment the density of each cell at most once for each trajectory.
Popular cells represent an extremely fine-grained informa-tion that is difficult to handle properly, due to their (typi-cally) large number, but they are a useful basic information for computing larger areas, easier to handle and more mean-ingful for a pattern extraction task.

In general, the set of popular regions can be extremely large  X  even infinite, if we work on a continuous space. Therefore, some additional constraints should be enforced to select a significant, yet limited, subset of them. Straight-forward constraints, such as minimality or maximality of the region, fail to provide a reasonable selection, since the single popular cells are all and the only minimal popular regions, while the whole space is the only maximal popular region.
In this paper we adopt a more complex, yet intuitive, def-inition of popular region, based on the popular cells intro-duced above.

Definition 7. (Popular region set) Given a grid G of n  X  m cells, each with its density G ( i, j )(1  X  i  X  n and 1  X  m ) and a density threshold  X  ,a popular region set for G a collection R of sets of cells from G , such that: (i) each r  X  R forms a rectangular region; (ii) sets in R are pairwise disjoint; (iii) all dense cells in G are contained in some set r that r  X  R has size h  X  k , all its rectangular supersets r of size ( h +1)  X  k or h  X  ( k + 1) violate (iv) or r and r contain exactly the same number of dense cells.

Essentially, a popular region set provides a coverage of dense cells through disjoint, rectangular regions with some form of local maximality (condition (v)). In particular, for each region we consider the average density of its cells, in-stead of its overall density (which is generally higher), and larger rectangles are preferred only if they add dense regions. Finally, we remark that in general there exist more than one popular region set for a grid.

A simple algorithm for extracting one of the possible so-lutions is provided in Figure 3. The algorithm iteratively considers all popular cells (see cells filtering at (1) and cells scan at (3)) not yet covered by existing popular regions (step (4)). For each of them builds a corresponding single cell region (step (5)) and tries to extend it as much as possible along all four possible directions (steps (7 X 8)). Then, among the directions that yield admissible larger regions w.r.t. the requirements in Definition 7 (step (9)), if any, it chooses the one that maximizes the average density of the new region 3 (steps (10 X 12)). The process is repeated as long as the re-gion can be extended, and at the end the resulting region is added to the output set and all its cells are marked to avoid overlaps with next regions (steps (14 X 15)).
 Algorithm: PopularRegions( G ,  X  ) Input: A grid G with densities G ( i, j ), a density threshold  X  Output: A set R of rectangular regions over G . 1. R =  X  ; G  X  = { ( i, j )  X  X |G ( i, j )  X   X  } ; 2. foreach ( i, j )  X  X  do used ( i, j )= false ; 3. foreach ( i, j )  X  X   X  in descending order of G ( i, j ) do 4. if  X  used ( i, j ) then 5. r = { ( i, j ) } ; 6. repeat 7. foreach dir  X  X  left , right , up , down } do 8. r dir = r extendedondirection dir ; 9. ext = { dir | r dir  X  X   X  avg density ( r dir )  X   X  10. if ext =  X  then 11. dir =argmax d  X  ext avg density ( r d ); 12. r = r dir ; 13. until ext =  X  ; 14. foreach ( i, j )  X  r do used ( i, j )= true ; 15. R = R  X  X  r } ; 16. return R ; Figure 3: Algorithm for Popular Regions extraction
In Figure 4 an example of all the steps for the extrac-tion of popular region sets is represented: in (a) we have (a sampling of) the input dataset of trajectories; in (b) the cor-responding densities of the cells over a grid of size 100
Notice that also any alternative choice would yield results compliant with Definition 7. Algorithm: Static RoI T-pattern( T in , G 0 ,  X  , ,  X  ) Input: A set of input trajectories T in ,agrid G 0 ,aminimum support/density threshold  X  , a radius for spatial neighbor-hoods , a temporal threshold  X  .
 Output: A set of couples ( S, A ) of sequences of regions with temporal annotations. 1. G = ComputeDensity( T in , G 0 , ); (Sect. 4.2.1) 2. RoI = PopularRegions( G ,  X  ); (Sect. 4.2.2) 3. D =Translate( T in , RoI ); (Sect. 4.1) 4. T AS mining( D ,  X  ,  X  ); ([5]) Figure 5: Mining frequent T-patterns with static Regions-of-Interests are plotted; finally, in (c) the dense cells (w.r.t. a given threshold) are highlighted in dark/red and the popular re-gions extracted are drawn. As we can see, the resulting regions can contain non-dense cells, yet they are not pre-dominant (due to the average density threshold enforced in the algorithm) and there are no vertical or horizontal bands without at least one dense cell. Some dense cells, however, were too isolated to be merged with others, and so form very small regions. Finally, the regions obtained experimentally show a reasonably balanced shape.

Theorem 2. The complexity of the PopularRegions( G ,  X  ) algorithm is O ( |G| log |G| ) .

We notice that when the density threshold adopted in this task is equal to the minimum support for the T-patterns, dense cells approximatively represent the set of frequent T-patterns of length 1, i.e., the simplest patterns formed by single spatial points ( x 0 ,y 0 ). However, in the approach out-lined above, such dense cells are used to form the regions that will be used to extract all the T-patterns, not only those of length 1, thus making the strong assumption that such cells and groups of cells are meaningful for patterns of any length.
The spatial discretization process described in the pre-vious section can be readily integrated to the T AS mining algorithm in [5] to obtain a simple method for extracting T-patterns following the approach based on (static) Regions-of-Interest. Figure 5 summarizes the resulting algorithm. Projecting all the input trajectories over the given grid G , and using a spatial neighborhood or radius ,step(1) computes the density of each cell of the grid. Next, a set of Regions-of-Interest are automatically computed by means of the popular region extraction method (step (2)). Then, exploiting Theorem 1, in step (3) the input trajectories are preprocessed to sequences of regions w.r.t. the RoI obtained at the previous step, and the preprocessed trajectories are used as input for the T AS mining algorithm, whose output is also the output of our main algorithm.
In this section we discuss the complexity of the T-pattern mining problem in its more general variant and provide an approximated algorithm for them, based on Regions-on-Interest dynamically computed within the mining process.
The RoI-based neighborhoods discussed in the previous sections, although not very intuitive at a first glance, lead to a simple, yet useful, instantiation of the general frequent T-pattern mining problem.

However, in some contexts such a solution, based on fixed or pre-computed regions, is not significant, while more stan-dard and general neighborhood functions, on the contrary, can provide a better choice for the notion of spatial sim-ilarity we need to model. Examples of that are spherical neighborhoods ( N (  X  x )= {  X  y |||  X  x  X   X  y || 2  X  } or square neighborhoods ( N (  X  x )= {  X  y |||  X  x  X   X  y spectively defining a circle of radius and a square of side 2 centered around the given point.

When we adopt such standard neighborhoods, we have to face the T-pattern mining problem in its full generality, which requires to return every T-pattern that fits in several input ST-sequences. Fitting in a ST-sequence T ,inparticu-lar, means that T contains n distinct points (i.e., a sequence of n observations) that match the n points in the T-pattern in the sense of Definition 5.

As we can see, understanding which input sequences T support a T-pattern in principle requires to check all sub-sequences of T searching for anyone that matches with it, i.e., anyone whose n points and n  X  1 transition times have the corresponding items of the T-pattern within their neigh-borhoods. Similar to what was done with for T AS  X  X , we can see the problem from the opposite viewpoint: a T-pattern matches an input ST-sequence T when it falls in the neighborhood of any of its subsequences, which is equiv-alent to say that it falls in the union of the neighborhoods of all possible subsequences of T , that for convenience we will call the neighborhood of T . Then, frequent T-patterns are those that fall in the neighborhood of several input ST-sequences, which is a plain formulation of a kernel-based density-estimation problem where we look for dense points in a space that represents T-patterns by means of tuples of points plus corresponding ( n  X  1)-ples of transition times The kernel adopted on this space is simply the product of the neighborhoods applied for each element of the n -ple (resp. ( n  X  1)-ple), i.e., an N () (or other spatial neighborhood) for each point and N  X  () for each transition time. E.g., looking for all frequent T-patterns of length 3 with spatial neigh-borhood N () is equivalent to find all dense points in R 8 where 8 = 2  X  3 + 2, i.e., 2 dimensions for each point in the T-patternand1foreachtransitiontime.

In the general case extracting frequent T-patterns trans-lates to a density-estimation problem over spaces of rapidly-growing dimensionality, i.e., over R 3 n  X  1 ( n being the pat-tern length). In particular, as compared to the T AS mining problem, T-patterns exacerbate the difficulty of the den-sity estimation task in two ways: (i) the dimensionality of working spaces of T AS  X  X  grows less quickly ( R n  X  1 instead of R n  X  1 ); (ii) the sequence component in each T AS strongly limits the number of instances that can be found within each input sequence, making the density estimation task easier.
More precisely, in our context the neighborhoods of all sub-sequences of a single ST-sequence T are aggregated through set union, i.e., they do not sum up their contributions to density, while contributions are summed up for neighbor-hoods of different ST-sequences. We are essentially facing a multi-instance density-estimation problem, that introduces a complication to the standard density-estimation setting.
From the discussion given above, we can easily deduce that in a general setting the T-pattern mining problem be-comes intractable even for small pattern lengths. That moti-vates the development of simpler heuristic approaches, that try to extract the same kind of information contained in pure T-patterns but with some simplifying approximation.
The main issue in the general T-pattern mining problem is that we need to consider density for space and transition times in parallel, making it a high-dimensional problem.
Here a trade-off solution is provided, that approximates the more general instantiations of the T-pattern problem, by adopting a step-wise approach in building T-patterns, and approximating sets of similar T-patterns by means of a RoI-based representation.
We start by observing that the set P 0 of T-patterns of length 1 for a dataset of trajectories T 0 consists of all points ( x 0 ,y 0 )over R 2 that are dense w.r.t. the given neighbor-hood function, i.e., all points that are touched or that fall close to a sufficient number of the input trajectories.
Inordertodiscoverallpatterns P 1 of length 2, i.e., of the examine the occurrences of each input trajectory in the rep-resentation space R 5 looking for dense points, as discussed in Section 6.1. However, that will yield patterns whose first points, ( x 0 ,y 0 ), are a subset of those found in P 0 , and, more generally, any frequent T-pattern of length n +1 is the ex-tension of some frequent T-pattern of length n , as stated by the following property.

Theorem 3 (Anti-Monotonicity). Let T be an in-put trajectory, and let  X  and the spatial neighborhood func-tion N () be the parameters for the T-pattern mining prob-lem. Then:
This property implies that the support of a T-pattern is less than or equal to the support of any its prefixes, and thus allows us to adopt a level-wise approach by mining step-by-step patterns of increasing length. Moreover, it also states that, in a similar way, transition times can be searched in a separate step, after finding the interesting spatial points.
A critical aspect of this approach is the fact that at each step we have in general an infinite number of possible points to consider, e.g., the patterns in P 0 correspond to all the points that fall in any dense region of R 2 w.r.t. the neigh-borhood function. To deal with this problem, we introduce an approximation of the basic method, where points are not treated separately, but at each step are clustered together by following the approach described in Section 4.2, to form ba-sic regions that are treated as an indivisible entity. As in the case of static RoI, the set of regions derived this way can be used to translate trajectories to sequences composed of such regions, which will be used to extend the actual pattern.
Notice that each occurrence of a region in the translated sequence is associated with a time stamp, which is the time stamp of the corresponding original point in the trajectory, or, in case the trajectory was reconstructed through regres-sion, the entry time of the trajectory in the region.
Exploiting the monotonicity property provided by Theo-rem 3, we can safely search for any frequent pattern p n +1 ( x jectories that are already known to contain the subpattern p n =( x 0 ,y 0 ) ment of such trajectories really needs to be searched, since we only need to find continuations of the pattern p n , and no point occurring before the end time of p n can be appended to p n to obtain p n +1 . Therefore, any point occurring before such end time can be removed from the trajectory. That essentially means that we can follow a projection-based ap-proach, as adopted by PrefixSpan [9] for sequential patterns and by MiSTA [5] for frequent T AS  X  X .

The main difference from existing methods for mining se-quential patterns or episodes is that our input data and the projections obtained at each step will contain trajectories, rather than sequences of events or itemsets. Then, at each step we dynamically derive the interesting regions from the trajectory segments of the actual projection, use such RoI to translate the whole projection to a set of sequences of regions, and finally apply a standard prefix extension step over the resulting sequences.

The algorithm is summarized in Figure 6. Its structure closely follows the algorithm introduced in [5] for mining frequent T AS  X  X  and shares the same representation for tem-poral annotations (i.e., the transition times associated to each occurrence of the prefix in the sequences of a projec-tion) and the same functions for handling them 5 (see steps (6), (8) and (14)). In particular, each projection is associ-ated with a prefix (the pattern built so far) and is formed by a set of trajectories, each trajectory being associated with a set of annotations, representing the timings of all occur-rences of the prefix in the trajectory  X  they are used by function ExtractFrequentTimings to extract frequent tem-poral annotations.

The algorithm proceeds in a level-wise style and itera-tively consider all existing projections of increasing prefix size (steps (2 X 4)). If the the actual pattern has transition times to be evaluated (step (5))  X  i.e., it contains at least two regions  X  we compute its frequent temporal annotations (step 6). The resulting set of frequent annotations is re-turnedandusedtoprunethep rojection by removing use-less trajectories, i.e., those that were not associated with any frequent annotation (steps (7 X 8)). Then, in order to extend the actual pattern by one step, we first analyze the trajecto-ries in the projection to discover the new RoI (steps (9-10)) and use them to translate trajectories to corresponding se-quences of RoI (step 11). Now, the translated trajectories are used to extend the prefix by all admissible regions (steps (12 X 13)), i.e., all those having a sufficiently high support. For each region r , the extension of the prefix is performed by function ExtendProjection in step (14), which selects the translated trajectories where r occurs and updates the cor-responding temporal annotations (refer to [5] for further details). Then, the results of the prefix extension are re-produced in the trajectories of the original projection (step (15)), by removing the trajectories corresponding to the re-moved sequences of RoI (the link between them is kept by a trajectory ID) and by removing the segments of trajectory that cannot be used for future prefix extensions (i.e., those that precede the first end time of all prefix occurrences, as described at the beginning of this section). Finally, at step (18) the updated projection and the new prefix (one region longer than the original one) are queued for processing at the next iteration of the main cycle (step (2)). The compu-tation stops when no more extensions are possible, and so no new projections are produced by steps (12 X 18).
In this section we summarize the results of a set of exper-iments aimed at showing some sample trajectory patterns obtained from real data and at empirically evaluate the scal-ability of the proposed algorithms.

The real data used in these experiments describe the GPS traces of a fleet of 273 trucks in Athens, Greece, for a total of 112203 points 6 . Running both the Static RoI T-pattern and Dynamic RoI T-pattern algorithms with various parameter
More exactly, step (6) summarizes three operations introduced in [5]: Extract annotation blocks, Com-pute density blocks ,and Coalesce density blocks ;step (8) corresponds to function Annotation-based prune ;and step (14) corresponds to extend proj . Download at http://isl.cs.unipi.gr/db/projects/rtreeportal/ Algorithm: Dynamic RoI T-pattern( T in , G 0 ,  X  , ,  X  ) Input: A set of input trajectories T in ,agrid G 0 ,aminimum support/density threshold  X  , a radius for spatial neighbor-hoods , a temporal threshold  X  .
 Output: A set of couples ( S, A ) of sequences of regions with temporal annotations. 1. L =0; T 0 = { ( T in  X { X  X  , ) } ; 2. while T L =  X  do 4. foreach ( T, prefix )  X  T L do 5. if | prefix | X  2 then 6. A = ExtractFrequentTimings( T ); ([5]) 7. Output ( prefix , A ); 8. T = PruneEmptyAnnotations( T , A ); ([5]) 9. G = ComputeDensity( T , G 0 , ); (Sect.4.2.1) 10. RoI = PopularRegions( G ,  X  ); (Sect.4.2.2) 11. D =Translate( T , RoI ); (Sect.4.1) 12. foreach r  X  RoI do 13. if support D ( r )  X   X  then 14. D =ExtendProjection( D , r ); ([5]) 15. T = { ( traj , A ) | ( traj , A )  X  T 16. T L +1 = T L +1  X  X  ( T , append ( prefix ,r )) } ; 17. L ++; Figure 6: Mining frequent T-patterns with dynamic Regions-of-Interest settings (the same for both algorithms), several frequent tra-jectory patterns were discovered. Among them, two patterns are shown in Figure 7(left) over a simplified plot of the roads of the area, and provide an example of how the same kind of pattern hidden in the data is detected by the two differ-ent approaches, static and dynamic. The T-pattern A  X  t 1  X  X  X  B  X  t 2  X  X  X  B was discovered through the dynamic approach, with main temporal annotations ( X  t 1 ,  X  t 2 )  X  [330 , 445] list of annotations is omitted here for lack of space), and es-sentially represents frequent movements similar to a round trip, since the first and last re gions are adjacent. The corre-sponding static T-pattern A  X  t 1  X  X  X  B  X  t 2  X  X  X  B provides a coarser description of the same behavior, composed of larger regions ( B replaces B and B ), with the presence of a loop and as-sociated to a larger set of annotations (not listed for lack of space). It is quite clear that the dynamic T-pattern provides more precise information than its static counterpart.
The performances of the static and dynamic algorithms have been studied by means of synthetic data, generated by the CENTRE synthesizer described in [4]. Data contain 50% of purely random trajectories and 50% of trajectories that follow predefined patterns, randomly chosen among a set of 100 (random) patterns. Where not otherwise specified, the datasets contain 1000 trajectories, each one described on average by 200 points, and the algorithms are run with a minimum support/density threshold equal to 5%, spatial neighborhood of radius 10, time tolerance equal to 300 and density grid of size 100x100.

Figure 7(center) reports the execution times obtained by both algorithms over datasets with increasing number of in-put trajectories. The curves show an almost linear scalabil-ity with very similar times for both algorithms. Observing the running times for different minimum support thresholds (also used as density threshold for the region extraction pro-cess), then, we can see in Figure 7(right) that, interestingly, running times grow when the minimum support is decreased, as expected, but then quickly decrease when it goes below a given value, thanks to the effect of density on the region extraction process, which partitions the space in a smaller number of regions, thus causing the main algorithm to gen-erate less projections. We observe, moreover, that while the static algorithm performs better on extreme support thresh-old values, its execution times grow much faster when clos-ing to the critical middle values, exceedings the time limits enforced in these experiments (60 minutes).

The impact of other parameters was also investigated, but for lack of space we give here only a brief summary of the results: increasing the radius of the spatial neighborood ( ) we obtain irregular performances, yet very large values lead to very high execution times; changing the time tolerance threshold (  X  ) we obtain results very similar to computing T AS  X  X  (see [5]); finally, increasing the number of points in each trajectory causes a quasi-linear growth of times.
In this paper, we introduced the trajectory pattern mining problem, together with several different methods to extract T-patterns from trajectory data. The first empirical assess-ment reported in Section 7 exhibits promising results, from the point of view of both computational feasibility and use-fulness of the mined T-patterns. In our view, T-patterns are a basic building block for spatio-temporal data mining, around which more sophisticated analysis tools can be con-structed, including: Research efforts are being put in these directions, as well as in a large-scale experiment aimed at testing the concrete usefulness of trajectory pattern mining in the analysis of traffic flows in a metropolitan area. [1] R. Agrawal and R. Srikant. Mining sequential [2] K. Ashok. Estimation and Prediction of [3] H. Cao, N. Mamoulis, and D. W. Cheung. Mining [4] F. Giannotti, A. Mazzoni, S. Puntoni, and C. Renso. [5] F. Giannotti, M. Nanni, and D. Pedreschi. Efficient [6] F. Giannotti, M. Nanni, F. Pinelli, and D. Pedreschi. [7] P. Kalnis, N. Mamoulis, and S. Bakiras. On [8] N. Mamoulis, H. Cao, G. Kollios, M. Hadjieleftheriou, [9] J. Pei et al. Prefixspan: Mining sequential patterns by [10] A. Vautier, M.-O. Cordier, and R. Quiniou. An [11] M. Yoshida et al. Mining sequential patterns including [12] M. J. Zaki. Spade: An efficient algorithm for mining
