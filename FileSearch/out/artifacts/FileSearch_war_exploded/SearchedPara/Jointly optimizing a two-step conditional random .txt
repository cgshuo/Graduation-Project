 There are more than 6000 languages in the world and 10 languages of them have more than 100 mil-lion native speakers. With the information revolu-tion and globalization, systems that support mul-tiple language processing and spoken language translation become urgent demands. The transla-tion of named entities from alphabetic to syllabary language is usually performed through translitera-tion, which tries to preserve the pronunciation in the original language.

For example, in Chinese, foreign words are written with Chinese characters; in Japanese, for-eign words are usually written with special char-acters called Katakana; examples are given in Fig-ure 1.
 An intuitive transliteration method (Knight and Graehl, 1998; Oh et al., 2006) is to firstly convert a source word into phonemes, then find the corre-sponding phonemes in the target language, and fi-nally convert them to the target language X  X  written system. There are two reasons why this method does not work well: first, the named entities have diverse origins and this makes the grapheme-to-phoneme conversion very difficult; second, the transliteration is usually not only determined by the pronunciation, but also affected by how they are written in the original language.

Direct orthographical mapping (DOM), which performs the transliteration between two lan-guages directly without using any intermediate phonemic mapping, is recently gaining more at-tention in the transliteration research community, and it is also the  X  X tandard Run X  of the  X  X EWS 2009 Machine Transliteration Shared Task X  (Li et al., 2009). In this paper, we try to make our system satisfy the standard evaluation condition, which requires that the system uses the provided parallel corpus (without pronunciation) only, and cannot use any other bilingual or monolingual resources.
The source channel and joint source channel models (JSCMs) (Li et al., 2004) have been pro-posed for DOM, which try to model P ( T | S ) and P ( T, S ) respectively, where T and S denote the words in the target and source languages. Ekbal et al. (2006) modified the JSCM to incorporate different context information into the model for Indian languages. In the  X  X EWS 2009 Machine Transliteration Shared Task X , a new two-step CRF model for transliteration task has been proposed segment a word in the source language into char-acter chunks and the second step is to perform a context-dependent mapping from each chunk into one written unit in the target language.

In this paper, we propose to jointly optimize a two-step CRF model. We also propose a fast de-coding algorithm to speed up the joint search. The rest of this paper is organized as follows: Sec-tion 2 explains the two-step CRF method, fol-lowed by Section 3 which describes our joint opti-mization method and its fast decoding algorithm; Section 4 introduces a rapid implementation of a JSCM system in the weighted finite state trans-ducer (WFST) framework; and the last section reports the experimental results and conclusions. Although our method is language independent, we use an English-to-Chinese transliteration task in all the explanations and experiments. 2.1 CRF introduction A chain-CRF (Lafferty et al., 2001) is an undi-rected graphical model which assigns a probability to a label sequence L = l sequence C = c performed through the L-BFGS algorithm (Wal-lach, 2002) and decoding is performed by the Viterbi algorithm. We formalize machine translit-eration as a CRF tagging problem, as shown in Figure 2.
 Figure 2: An pictorial description of a CRF seg-menter and a CRF converter 2.2 CRF segmenter In the CRF, a feature function describes a co-occurrence relation, and it is usually a binary func-tion, taking the value 1 when both an observa-tion and a label transition are observed. Yang et al. (2009) used the following features in the seg-mentation tool:  X  Single unit features: C  X  2 , C  X  1 , C 0 , C 1 , C 2  X  Combination features: C  X  1 C 0 , C 0 C 1 Here, C note the previous and next characters, and C C left and right of C
One limitation of their work is that only top-1 segmentation is output to the following CRF con-verter. 2.3 CRF converter Similar to the CRF segmenter, the CRF converter has the format shown in Figure 2.

For this CRF, Yang et al. (2009) used the fol-lowing features:  X  Single unit features: CK  X  1 , CK 0 , CK 1  X  Combination features: CK  X  1 CK 0 , where CK represents the source language chunk, and the subscript notation is the same as the CRF segmenter. 3.1 Joint optimization We denote a word in the source language by S , a segmentation of S by A , and a word in the target langauge by T . Our goal is to find the best word  X  T in the target language which maximizes the prob-ability P ( T | S ) .
 tation in the first CRF and the best output in the second CRF, which is equivalent to where P ( A | S ) and P ( T | S, A ) represent two CRFs respectively. This method considers the seg-mentation and the conversion as two independent steps. A major limitation is that, if the segmenta-tion from the first step is wrong, the error propa-gates to the second step, and the error is very dif-ficult to recover.

In this paper, we propose a new method to jointly optimize the two-step CRF, which can be written as:
The joint optimization considers all the segmen-tation possibilities and sums the probability over all the alternative segmentations which generate the same output. It considers the segmentation and conversion in a unified framework and is robust to segmentation errors. 3.2 N-best approximation In the process of finding the best output using Equation 2, a dynamic programming algorithm for joint decoding of the segmentation and conversion is possible, but the implementation becomes very complicated. Another direction is to divide the de-coding into two steps of segmentation and conver-sion, which is this paper X  X  method. However, exact inference by listing all possible candidates explic-itly and summing over all possible segmentations is intractable, because of the exponential computa-tion complexity with the source word X  X  increasing length.

In the segmentation step, the number of possible segmentations is 2 N , where N is the length of the source word and 2 is the size of the tagging set. In the conversion step, the number of possible candi-dates is M N  X  , where N  X  is the number of chunks from the 1st step and M is the size of the tagging set. M is usually large, e.g., about 400 in Chinese and 50 in Japanese, and it is impossible to list all the candidates.

Our analysis shows that beyond the 10th candi-date, almost all the probabilities of the candidates in both steps drop below 0.01. Therefore we de-cided to generate top-10 results for both steps to approximate the Equation 2. 3.3 Fast decoding algorithm As introduced in the previous subsection, in the whole decoding process we have to perform n-best CRF decoding in the segmentation step and 10 n-best CRF decoding in the second CRF. Is it really necessary to perform the second CRF for all the segmentations? The answer is  X  X o X  for candidates with low probabilities. Here we propose a no-loss fast decoding algorithm for deciding when to stop performing the second CRF decoding.

Suppose we have a list of segmentation candi-dates which are generated by the 1st CRF, ranked by probabilities P ( A | S ) in descending order A : A 1 , A 2 , ..., A N CRF decoding starting from A we get a list of candidates T : T ranked by probabilities in descending order. If we can guarantee that, even performing the 2nd CRF decoding for all the remaining segmentations A change, then we can stop decoding.

We can show that the following formula is the stop condition:
P k ( T 1 | S )  X  P k ( T 2 | S ) &gt; 1  X 
The meaning of this formula is that the prob-ability of all the remaining candidates is smaller than the probability difference between the best and the second best candidates; on the other hand, even if all the remaining probabilities are added to the second best candidate, it still cannot overturn the top candidate. The mathematical proof is pro-vided in Appendix A.

The stop condition here has no approximation nor pre-defined assumption, and it is a no-loss fast decoding algorithm. The JSCM represents how the source words and target names are generated simultaneously (Li et al., 2004): where S = ( s langauge and T = ( t target language.

The training parallel data without alignment is first aligned by a Viterbi version EM algorithm (Li et al., 2004).

The decoding problem in JSCM can be written as: After the alignments are generated, we use the MITLM toolkit (Hsu and Glass, 2008) to build a trigram model with modified Kneser-Ney smooth-ing. We then convert the n-gram to a WFST M (Sproat et al., 2000; Caseiro et al., 2002). To al-low transliteration from a sequence of characters, a second WFST T is constructed. The input word is converted to an acceptor I , and it is then com-bined with T and M according to O = I  X  T  X  M where  X  denotes the composition operator. The n X  X est paths are extracted by projecting the out-put, removing the epsilon labels and applying the n-shortest paths algorithm with determinization in the OpenFst Toolkit (Allauzen et al., 2007). We use several metrics from (Li et al., 2009) to measure the performance of our system. 1. Top-1 ACC: word accuracy of the top-1 can-didate 2. Mean F-score: fuzziness in the top-1 candi-date, how close the top-1 candidate is to the refer-ence 3. MRR: mean reciprocal rank, 1/MRR tells ap-proximately the average rank of the correct result 5.1 Comparison with the baseline and JSCM We use the training, development and test sets of NEWS 2009 data for English-to-Chinese in our experiments as detailed in Table 1. This is a paral-lel corpus without alignment.

Training data Development data Test data 31961 2896 2896
We compare the proposed decoding method with the baseline which uses only the best candi-dates in both CRF steps, and also with the well known JSCM. As we can see in Table 2, the pro-posed method improves the baseline top-1 ACC from 0.670 to 0.708, and it works as well as, or even better than the well known JSCM in all the three measurements.

Our experiments also show that the decoding time can be reduced significantly via using our fast decoding algorithm. As we have explained, with-out fast decoding, we need 11 CRF n-best decod-ing for each word; the number can be reduced to 3.53 (1  X  X he first CRF X +2.53  X  X he second CRF X ) via the fast decoding algorithm.

We should notice that the decoding time is sig-nificantly shorter than the training time. While testing takes minutes on a normal PC, the train-ing of the CRF converter takes up to 13 hours on an 8-core (8*3G Hz) server.
 Measure Top-1 Mean MRR Baseline 0.670 0.869 0.750 Joint optimization 0.708 0.885 0.789 JSCM 0.706 0.882 0.789 Table 2: Comparison of the proposed decoding method with the previous method and the JSCM 5.2 Further improvement We tried to combine the two-step CRF model and the JSCM. From the two-step CRF model we get the conditional probability P the JSCM we get the joint probability P ( S, T ) . The conditional probability of P be calculuated as follows: P JSCM ( T | S ) = They are used in our combination method as: P ( T | S ) =  X P CRF ( T | S ) + (1  X   X  ) P JSCM ( T | S ) where  X  denotes the interpolation weight (  X  is set by development data in this paper).

As we can see in Table 3, the linear combination of two sytems further improves the top-1 ACC to 0.720, and it has outperformed the best reported  X  X tandard Run X  (Li et al., 2009) result 0.717. (The reported best  X  X tandard Run X  result 0.731 used target language phoneme information, which re-quires a monolingual dictionary; as a result it is not a standard run.) Measure Top-1 Mean MRR Baseline+JSCM 0.713 0.883 0.794
Joint optimization + JSCM 0.720 0.888 0.797 state-of-the-art 0.717 0.890 0.785 In this paper we have presented our new joint optimization method for a two-step CRF model and its fast decoding algorithm. The proposed method improved the system significantly and out-performed the JSCM. Combining the proposed method with JSCM, the performance was further improved.

In future work we are planning to combine our system with multilingual systems. Also we want to make use of acoustic information in machine transliteration. We are currently investigating dis-criminative training as a method to further im-prove the JSCM. Another issue of our two-step CRF method is that the training complexity in-creases quadratically according to the size of the label set, and how to reduce the training time needs more research.
 The CRF segmentation provides a list of segmen-tations: A : A probabilities P ( A
The CRF conversion, given a segmenta-tion A put T
In our fast decoding algorithm, we start per-forming the CRF conversion from A and then A didates T : T ties P P k ( T l | S )( l = 1 , 2 , ..., L ) ity of P ( T
If we continue performing the CRF conversion to cover all N ( N  X  k ) segmentations, eventually we will get: If Equation 3 holds, then for  X  i 6 = 1 ,
P k ( T 1 | S ) &gt; P k ( T 2 | S ) + (1  X 
Therefore, P ( T maximizes the probability P ( T | S ) .
