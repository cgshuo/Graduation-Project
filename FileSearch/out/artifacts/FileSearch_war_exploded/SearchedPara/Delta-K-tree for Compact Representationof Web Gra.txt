 In the applications of web management and mining, the World Wide Web struc-ture can be represented by a directed gr aph, where each web page corresponds to a graph node and each hyperlink corresponds to a graph edge. Such a directed graph is known as web graph. Lots of basic algorithms and operations are based on the web graphs to analysis and mine the inner structure of the web. For exam-ple, some famous webpage ranking algorithms, such as Pagerank [1] and HITS [2] used in the primary search engines, are based on the web graph structure. Their key techniques are computing the out-degree and in-degree of each node and analysis the connected relations bet ween different nodes. With the explosive development of the Internet, the scale of web graphs is growing at an amazing speed. To meet the need of large-scale gra ph data management, there is a trend towards studying efficient compression techniques and fast querying algorithms in recent years.

Traditional methods for storing and manipulating the web graphs mostly store a graph in an adjacency matrix or list. In order to guarantee efficient querying, it requires the entire adjacency matrix or list to be loaded into the memory. However, it X  X  not practical for the increasingly large scale of graph data with millions of nodes and edges to be memory-resident. According to the official report by CNNIC (China Internet Network Information Center) [3], the numbers of web pages and hyperlinks were about 86.6 billion and 1 trillion respectively by the end of 2012 in China. This web graph has to be stored using adjacent list over 16TB. The huge memory space poses great challenge to the traditional storing methods.

There exist three aspects of researche s to solve excessive storage problem: (1) Storing the graph in external memory since the external memory is much cheaper and larger compar ed with main memory [4, 5]. (2) Using distributed system to partition the graph into small subgraphs and manipulating subgraphs in distributed computers [6 X 8]. (3) Converting the graph to compact form which requires less space while supporting fast querying [9 X 12].

In our research, we focus on the third a spect and aim to represent web graphs in highly compact form, thus manipulating huge graphs in main memory. In practice, such compression algorithm is beneficial for the former two aspects of research. For the external memory schem e, the locality of access will be promoted since much more compressed graph data is available in the main memory at one time. For the distributed system scheme, highly compact structure will allow fewer computers to do the same work and reduce the network traffic.

Among all the algorithms for compressing graphs, K 2 -tree [11] is a repre-sentative algorithm with high compression ratio and fast querying performance. This algorithm uses an adjacency matrix to represent a graph and exploits its sparsity for effective compression. However, K 2 -tree ignores an important char-acteristic of the similarity between ad jacent rows or columns in the adjacency matrix, which can be exploited for improving the compression ratio.

In this paper, we proposed a new tr ee-form structur e named as Delta-K 2 -tree. A series of experiments indi cate that our approach outperforms K 2 -tree in compression ratio while still supporting fast querying. Furthermore, a node reordering algorithm is proposed to make better use of the similarity between nonadjacent rows or columns, which can further improve the compression ratio of Delta-K 2 -tree. Researchers in the field of web graph compression are mostly interested in form-ing a compact representation which supp orts efficient querying operations, such as checking the connected relation between two page nodes, extracting the suc-cessors of any page node, etc. The most influential representative in this trend is WebGraph [9] framework. When we use WebGraph for compressing the web graphs made up by URLs (Uniform Resource Locator), the URLs have been previously sorted in lexicographical order aiming to make similar URLs appear in adjacent locations. According to the similarity between the adjacent URLs, the method achieves a good trade-off be tween compression ratio and querying speed. Variants of the WebGraph [13 X 16] keep optimizing the storage space by more effective encoding and reordering techniques.

With the same reordering process as W ebGraph in the previous stage, [12] further exploits the structural characteristics of the web graph adjacency matrix. In the research, six kinds of regular sub-graphs are extracted and compressed to achieve high compression ratio. Whereas the querying speed of finding all neighbors of the given page is particularly slow since the query requires numerous accesses to all the sub-graphs.

Instead of using the lexicographical order, AD algorithm proposed in [10] reorders the web graph nodes based on the Bradth First Search (BFS) scheme. Taking the advantage of similarity be tween adjacent nodes in the adjacency list after node reordering, AD is competitive with WebGraph in compression efficiency and querying speed.

All approaches mentioned above just provide forward querying operation and that they can be simply converted into one that supports bidirectional querying operations. In [16], a web graph is divided into two sub-graphs, where one con-tains all bidirectional edges and the other contains all unidirectional edges. The method compresses both of the above two sub-graphs and a transposed graph of the unidirectional sub-graph. However, such extended methods require extra space to store the transposed graph.

In [11], Brisaboa et. al. present a K 2 -tree structure that offers forward and reverse query without constructing the transposed graph. It highly considers the properties of large empty areas of the graph adjacency matrix and gives very good compression ratio. In this paper, we improve the performance of K 2 -tree via exploiting the similarity between adja cent nodes in the graph adjacency matrix and reordering nonadjacent nodes to further improve the compression ratio. We compared our method with the best alte rnatives in the literature, offering a series of space/time analysis according to the underlying experimental results. 3.1 Notation As used herein, a directed graph G =( V, E ) indicates a web graph, where V represents the set of nodes and E represents the set of edges in the graph. Each node corresponds to a page and each edge corresponds to a link. Using n ( n = | V | ) indicates the number of nodes and m = | E | indicates the number of edges. A square matrix { a i,j } only containing 0s and 1s indicates the adjacency matrix. a i,j is 1 if there is an edge from v i to v j and 0 otherwise.
 3.2 K 2 -tree In [11], an unbalanced tree structure named K 2 -tree represents an adjacency matrix. In the K 2 -tree, each node stores 1 bit information, 0 or 1. Every node in the last level of the K 2 -tree represents an element in the matrix and every other node represents a sub-matrix in the matrix. Except in the last level of the K 2 -tree, the node stored 1 corresponds to the sub-matrix containing at least one 1 and the node stored 0 corresponds to the sub-matrix containing all 0s. In the phase of K 2 -tree construction, the n  X  n adjacency matrix is divided into K 2 equal parts and each part is a n corresponds to a child of the root of K 2 -tree. If and only if a sub-matrix contains at least one 1, the child is 1, otherwise the child is 0. For those children who are 1, go on dividing them into K 2 equal parts recursivel y until the sub-matrix contains all 0s or only one element.

In real web graphs, m is far less than n 2 so that the adjacency matrix is extremely sparse. Due to the characteristic of sparsity, K 2 -tree achieves high compression ratio of the web graphs by using one node to represent a sub-matrix containing all O (1)) bits which is asymptotically twice the information-theoretic lower bound necessary to represent all the matrices of n  X  n with m 1s.

In the phase of query, for two given nodes v i and v j ,wecanuse K 2 -tree to determine if a i,j is 0 or 1. Using the root as the current node, find a child which represents the sub-matrix containing a i,j . a i,j is 0 if the child stores 0. Otherwise, using the child as the current node, go on finding a child of the current node until the child stores 0 or the current node has no child. a i,j is 0 if the last node we find store 0 and a i,j is 1 otherwise.
 In practice, if n is not a power of K , the matrix could be extended to K log K n  X  K log K n by adding 0s at the right and the bottom. The K 2 -tree is stored in two bit arrays, T and L . T stores nodes except those in the last level via traversing the K 2 -tree level by level from left to right. L stores nodes in the last level from left to right. Fig. 1 shows an adjacency matrix and K 2 -tree according to the matrix when K = 2, and 0s in the grey area are added to solve the problem that n is not a power of K .
 In order to find a child of the given node of K 2 -tree efficiently by using T and L , T needs to permit Rank query. Rank ( T,i )(0 i&lt; | T | ) counts the number of 1s from position 0 up to position i in T . The first position in T is 0. For example, a given node of K 2 -tree represented by T [ i ] has children if T [ i ] = 1, then the s -th child of the node is at position Rank ( T,s )  X  K 2 + s of T : L . T : L represent the connection of T and L .[17]provesthat Rank can be calculated in constant time using sub-linear space. 3.3 Rank The implementation of Rank in [17] achieves very good results theoretically, however the realization is complicated. [18] proposes a simple implementation and shows that in many practical cases the simpler solutions are better in terms of time and extra space. For a bit array T , the method uses an array R to store every B position of Rank , R [ ! i B " ]= Rank ( T, ! i B " X  B ),andusesanarray popc to store number of 1s in all the different b -bit array. Then Rank ( T,i )= R [ b, to j -th position and B is a multiple of b . When the length of T is t , the length of R is ! t B " and the length popc is 2 b .

Due to that we can use mm popcnt u64 in SSE (Streaming SIMD Extensions) to calculate the number of 1s in 64-bit integer, we set b to 64 and use T , an array of 64-bit integers, to store every 64 bits of the bit array in practical applications in Fig. 2. B is set to 2 w  X  b for the convenience of the programming. As w increases, the computation increases and the space decreases simultaneously. 4.1 Motivation By taking advantage of adjacency matrix X  X  sparsity, K 2 -tree compresses the web graph efficiently and its space is k 2 m (log K 2 n 2 m )+ O (1)) bits in the worst case. We prove Theorem 1 that as m decrease the total space of K 2 -tree, in the worst case, decreases when K and n are not changed. According to the theoretical analysis, if we can reduced the number of 1s and unchanged the size of the matrix simultaneously, it can reduce the space of K 2 -tree.
 Theorem 1. The space of K 2 -tree of the sparse matrix, in the worst case, de-creases with number of 1 s decreases in the case of unchanging n and K . x&gt; e a c , y &lt; 0and y decreases with x increases. According to sparsity of the matrix, x is greater than e a c obviously. 4.2 Construction and Query The characteristic of similarity betw een neighbors of different pages has been found and is used widely in compression algorithms such as WebGraph and AD. We also use the characteristic to reduce the number of 1s. We use a matrix named Delta-matrix to store the differ ence between adjacent rows or columns in the adjacency matrix. We take rows f or example. The Delta-matrix can be constructed with the method in Fig. 3, where Count1s ( matrix [ i ]) and Count-Dif ( matrix [ i ] ,matrix [ j ]) represent the number of 1s in i -th row in the matrix and the number of differences between same positions in i -th row and j -th row in the matrix. D in Fig. 3 is a n -bit array to record which rows in the Delta-matrix represent the differences. According to the construction, the number of 1s in the Delta-matrix is not greater than that in the adjacency matrix.
The Delta-matrix and the n-bit array D instead of the adjacency matrix can be used to represent web graphs. We use { a i,j } to represent the adjacency matrix and { a i,j } to represent the Delta-matrix. Ele ments in the adjacency matrix can be obtained from the Delta-matrix and D by formulate (1) where  X  means exclusive-OR and s is the number of consecutive 1s in D from i -th position forward.
We use K 2 -tree to compress the Delta-matr ix instead of the adjacency matrix to reduce the space. However, we need to access the K 2 -tree of the Delta-matrix several times to obtain an element in the adjacency matrix. So if the number of consecutive 1s in D is very large, query will become very time-consuming. To resolve this problem, we propose two methods: (1) We replace nodes in the last level of K 2 -tree of the Delta-matrix with elements of the same positions in the adjacency matrix. We call the modified K 2 -tree Delta-K 2 -tree. For example in Fig. 4, the dotted line indicates nod es replaced. (2) When using Delta-K 2 -tree, if we access a node stored 0 which is no t in the last level, then it means all elements in the sub-matrix represented by the node are all 0s. So one access can obtain several elements. In practical applications using the above two methods, one query to obtain an element in the adjacency matrix merely needs about 2 accesses to Delta-K 2 -tree on average. In addition, Delta-K 2 -treecanusesimi-larity between adjacent columns as same as adjacent rows, which can be selected according to the actual situation. 4.3 Nodes Reordering Delta-K 2 -tree uses the characteristic of similarity between adjacent nodes in web graphs. Actually, the similar nodes may not be adjacent. We can use nodes reordering method to change the order of nodes in the web graph to make better use of the characteristic. That is to find an order of nodes in order to obtain the Delta-matrix with the minimal 1s.

We use a directed graph G =( V, E ) to represent the similarity of nodes in the matrix. In this subsection, G does not represent the web graph. v i in V represents i -thnodeandtheweightsof e ( v i ,v j ) for every two different vertexes is the the minimum of the number of i -th node X  X  neighbors and the number of difference between i -th node X  X  neighbors and j -th node X  X  neighbors. For an n nodes web graph, there is a graph G containing n vertexes and n ( n  X  1) edges. Every Hamiltonian path in G corresponds to an order of nodes in the web graphs and the weights of the path is the number of 1s in the Delta-matrix. So, the problem is transferred into the shortest Hamiltonian path problem.
The shortest Hamiltonian path is a NP-complete problem, so we propose a heuristic algorithm to solve it. The algorithm randomly selects a starting vertex and traverses all vertexes once by edge of the current vertex with minimal value. The order of vertexes in the shortest Hamiltonian path is the order of nodes in the web graph. 5.1 Experimental Environment and Test Data Our test dataset are real web graphs obtained from the Laboratory for Web Algrithmics [9]. Table 1 describes the numbers of nodes and edges and the the filenames on their website [19].Our expe riments are based on the operation sys-tem Red Hat Enterprise Lin ux 6.0 Server (64 bits) with Intel(R) Core(TM) i7-3820CPU@3.60GHz and 32GB RAM. All tests use only one CPU core. The compilers used are gcc version 4.4.7 and java version 1.7.0 09.

We compare Delta-K 2 -tree with the state-of-the-art algorithms, including K 2 -tree, WebGraph, and AD, in memory spac e and querying speed over the test data. We implement K 2 -tree and Delta-K 2 -tree in C++. The version of We-bGraph we use is 3.2.1 which is publicly available at [19]. The version of AD we use is 0.3.2 which is publicly available at [20]. WebGraph and AD both are implemented in Java. 5.2 Memory Space Comparison with Different Options Table 2 shows the comparison in memory space between K 2 -tree and Delta-K 2 -tree with different options. Space is measured in bpe (bits per edge), by dividing the total space of the compressed data by the number of edges in the web graphs.
We configure K 2 -tree and Delta-K 2 -tree with parameter K =2 , 4. Rank is configured with parameter B = 512. For Delta-K 2 -tree, we test four different options. Delta-K 2 -tree use similarity between adjacent rows or columns in the adjacency matrix are labeled with row and column . Nodes reordering before compression is labeled with reorder .

Results show that our proposal leads to about 40% reduction in space with K 2 -tree. In different options, compression effi ciency by using similarity of columns is better than rows. Compression efficiency can be improved significantly by our nodes reordering method.
 5.3 Memory Space Comparison with Other Approaches Table 3 shows the comparison in memory space among K 2 -tree, WebGraph, AD and Delta-K 2 -tree. Space is measured in bpe.
 We configure WebGrap h with parameters w =70and m = 300, configure AD with parameters l = 100 and configure K 2 -tree and Delta-K 2 -tree with parameter K =2and B = 512 to favor compression over speed. As WebGraph and AD are based on adjacency list, they only support forward querying. We use the technique proposed in [16] to solve the problem by using some extra space, which has been introduced in related work.

Results show that the space of our proposal is minimal among all algorithms while supporting both forward and reverse querying.
 5.4 Space/Speed Trade-Off Comparison with Other Approaches We do this experiment while WebGraph and AD only supporting forward query-ing without any extra space. We test qu erying speed in tow aspects, query for link and query for neighbors. Query for link represents checking the connecting relation between two given nodes. Query for neighbors is to obtain all neigh-bors of the given node. Space is measured in bpe. Speed is measured in nspe (nanoseconds per edge). Speed of query f or link is the time of one query. Speed of query for neighbors is calculated by dividing the time of one query by the number of the neighbors.

Fig. 5 shows the space/speed trade-off comparison of query for link, and Fig. 6 shows the space/speed trade-off comparison of query for neighbors.We config-ure WebGraph with parameters ( w,m )=(1 , 1) , (3 , 3) , (70 , 300), configure AD with parameters l =4 , 8 , 16 , 100 and configure K 2 -tree and Delta-K 2 -tree with parameter K =2and B =64 , 128 , 256 , 512.

On querying speed, our proposal does not have advantages. When querying for link, K 2 -tree is the fastest. When querying for neighbors, WebGraph is the fastest. However, our proposal shows be tter space/speed trade-off performance especially in querying for link. When qu erying for link, if we need high compres-sion and fast speed at the same time, Delta-K 2 -tree is the best choice. We have presented a new compression method, Delta-K 2 -tree, for web graphs by taking advantage of the characteristics of similarity of the hyperlinks and sparsity of the adjacency matrices and a node reordering algorithm to fur-ther improve compression. We compare it with the common used alternatives [9 X 11] in the field. Our experiments show that it achieves high compression ratio while supporting fast forward and reverse querying. When querying for checking the connecting relation between two given pages, it is a competitive method to satisfy the requirement of high compression and fast querying.

The node reordering algorithm can improve compression of Delta-K 2 -tree, however it can not get the optimal solution. Thus, to design new heuristic node reordering algorithm is one of our possible future works. How to improve query-ing speed using Delta-K 2 -tree is also a consideration for us.
 Acknowledgement. This research was supported by the National Natural Science Foundation of Ch ina (No. 61202477); the Strategic Priority Research Program of the Chinese Academy of Sciences (No. XDA06030602); the Na-tional High Technology Research and Development of China (863 Program) (No. 2011AA010705, 2012AA012502).

