 Enterprise Application Integration (EAI) continues to receive widespread focus by organizations offering them as means of integrating their conventional busi-ness applications with each other, with the growing amount of cloud applications and with their partners X  systems. In many cases, the integration middleware sys-tems serve as the enabling technology for distributed, mission-critical business processes. For that, these systems offer well-defined modeling capabilities to de-scribe integration semantics (e. g., message creation, transformation, routing) as well as runtime systems that interpret the definitions for efficient message process-ing. Figure 1 shows a typical conceptual overview of application-to-application (A2A) and business-to-business (B2B) integration, which can be found in many organizations (cf. Reese [ 12 ]). The dominating aspects are the many connections or integration adapters, which are currently under-represented in the (integration) modeling domain. Integration semantics are generally described based on a com-prehensive (often graphically depicted) syntax and execution semantics (process model). In their best practices book Enterprise Integration Patterns (EIP), Hohpe and Woolf [ 7 ] have collected a widely used and accepted collection of integration patterns that are typical concepts used when implementing a messaging system and have proven to be useful in practice. However, they do not specify a semantic model for the formalization of the integration syntax and semantics. Most notice-able, the integration adapter modeling with its manifold characteristics is reduced to a Channel Adapter icon.
 with well-defined building blocks for modeling EIPs in the Business Process Model and Notation (BPMN) [ 11 ], which is a  X  X e-facto X  standard for modeling business process semantics and their runtime behavior [ 14 ]. We mapped EIPs to BPMN compatible syntax and defined execution semantics adapted to mes-sage processing. We extended that notion to end-to-end flows of messages, called Integration Flow (IFlow) [ 13 ]. In a nutshell, an IFlow can be seen as message-based integration from a sending application (Sender, BPMN Participant )to one or many receiving applications (Receiver(s), BPMN Participant )via BPMN Message Flow configurations (denoting the inbound and outbound adapters) and dedicated participant(s) that specify an integration process (composition of EIPs). We decided on BPMN for defining a  X  X essage-based integration X  DSL due to its sufficient coverage of control flow, data and exception flow, process modeling capabilities and execution semantics [ 13 , 16 ]. The work on  X  X ata in Business Processes X  [ 8 ] shows that besides Configuration-based Release Processes (COREPRO) [ 10 ], which mainly deals with data-driven process modeling, (busi-ness) object status management, and UML activity diagrams, BPMN achieves the highest coverage in the categories relevant for our approach. Compared to BPMN and apart from the topic of  X  X bject state X  representation, neither Work-flow Nets [ 20 ] nor petri nets support data modeling at all [ 8 ]. For instance, Figure 2 shows an excerpt of an asynchronous integration scenario from the Internet of Things (IoT) domain, syntactically expressed in BPMN according to [ 13 ]. The encrypted incoming message is of type  X  X D X  (short for Teleme-try Data ), which has to be normalized with respect to its timestamps using a Message Transformation pattern [ 7 ]. The Message Queue Telemetry Transport (MQTT) 1 is used as transport protocol, which is a common, lightweight queu-ing protocol frequently used in the IoT domain. The approach to specifying integration semantics and its runtime works well for common integration sce-narios [ 13 ]. More complex scenarios have to deal with non-trivial combinations of message exchange pattern (MEP) and quality of service (QoS) levels. These notions are mostly induced during the adapter processing and continued into the integration process. Currently, integration modeling approaches (a) do not classify adapter characteristics, (b) leave the default adapter processing (mostly) hidden in the various runtime implementations, and (c) do not allow for config-uration or change of the default behavior.
 In this paper, we comprehensively investigate the range of characteristics of adapters during the integration flow processing and the various ways, in which they can be addressed. This provides the foundation for a classifica-tion of the adapter modeling, which we subsequently define in the form of an adapter flow (AF) and patterns. The pattern-based approach to adapter clas-sification is a continuation of our previous work on the EIPs and the IFlow. a conceptual framework for classifying the adapter processing capabilities of mid-dleware systems more generally based on the IFlow modeling approach, while being independent of the specific runtime platforms. The major contributions of this work are (1) a comprehensive classification of common adapter character-istics in integration systems and beyond, (2) an extension of the BPMN-based IFlow model for adapter flows (AFs) that make default processing visible to the user for all identified categories from (1) and allows for change of the default behavior, (3) the derivation of common adapter processing patterns and their representation in BPMN, as well as (4) the application to an existing open source middleware system, the technical analysis and discussion of the proposed app-roach as experimental validation in two examples. In a nutshell, we propose an answer to the underlying questions of the observations (a-c), e. g.,  X  X hich QoS does the IFlow in Figure 2 have? X  and  X  X ow can the default handling be adapted to custom requirements? X .
 Section 2 discusses adapter modeling characteristics, before we derive adapter processing patterns as an extension to the IFlow in Section 3 , which we prototypi-cally applied in two examples in Section 4 . Section 5 summarizes our experiences, Section 6 discusses related work, and Section 7 concludes. In this section, we introduce a generalized integration system architecture, clas-sify adapter characteristics and formulate them as modeling requirements. The adapter type classification is based on [ 7 ], supported by an analysis of 151 mes-sage endpoints, contributed to Apache Camel [ 3 ], and an integration expert workshop with 20 experienced integration experts from 7 different companies (cf. Suppl. Material [ 15 ]). As illustrated in Figure 3 conventional integration systems consist of a set of event-based or polling consumer adapters, an integra-tion process engine, which executes sets of routing and message transformation tasks, and a set of producer adapters. The adapters represent the Message End-point pattern [ 7 ] and have to deal with security concerns and (possibly) format conversions from the sender format F s ( msg ) to an internal format (i. e., Canonical Data Model (CDM) [ 7 ]) that is used for the integration process-ing, and eventually conversions from the CDM to the target format understood by the receiver.
 usly) or directly sent to the integration system process engine (synchronously). This engine uses a set of outbound adapters to actively interact with exter-nal systems. During the whole integration process, the recoverability should be ensured; thus, the internal message representations have to be stored locally using an operational data store or are queued for cross-process or cross-system message exchange. The execution environment of the consumer and producer adapters is an adapter runtime, which is part of the application server for con-ventional integration systems, however, can be an arbitrary software stack. The connections to related parts of the system (e. g., Messaging System, Data Store) are discussed subsequently as part of the classification. We consider five main categories, which allow to comprehensively describe adapters. Hence we discuss common capabilities from these categories and derive requirements ( general adapter modeling approach.
 Adapter Type. Adapters can be canonically differentiated by their type: con-sumer or producer (as seen before). A consumer adapter allows the message sender applications to connect to the integration system. Message consumers are further sub-devided by their behavior into polling and event-based adapters. The polling adapter (e. g., File, (S)FTP) is configured to actively check for messages to read and process them ( R-1 : Model Polling Consumer). Hereby, settings like the polling interval, location, (initial) delay and format, can be specified. In con-trast, an event-based consumer specifies an endpoint configuration (e. g., Servlet URI), on which it registers a  X  X assive X  listener that waits for events or callbacks from the sender ( R-2 : Model Event-based Consumer). A producer adapter for-wards the messages to their receivers ( R-3 : Model Producer). The analysis of the 119 Apache Camel component bundles supports this differentiation (cf. [ 15 ]), by showing ten  X  X onsumer only X  (6 . 6%), 33  X  X roducer only X  (22%) and 108  X  X on-sumer+producer X  adapters. Despite the difficult task of determining  X  X ctive X  adapters, at least 34% of the sender adapters are  X  X olling X .
 Configuration Complexity. The analysis of 119 component bundles resulted to 151 single components, or adapters. In other words, components like mail encap-sulate multiple endpoints represented by protocols like smtp , pop3 , imap ( R-4 : Model Multi-Component Adapter). Another outcome of the analysis showed that 30 / 151 components require more complex configurations, e. g., for the param-eterization of connection and credential details like Java bean, key/trust store references as shown in Figure 3 ( R-5 : Allow for complex model references). Complementarily the user study resulted into a strong vote for scenario specific adaptations of the adapter X  X  behavior. That means, an adapter shall provide extension points to hook in one or more custom processors, which can be mod-eled similar to an IFlow [ 13 ]. Evidence for such a requirement can be found in concepts like  X  X hannel modules X  in SAP X  X  Process Integration system. This is an extension to adapters, which can be combined to the notion of  X  X essage channel X  modeling, similar to the integration process ( R-6 : Model Message Channels). Hence a message channel consists of consumer/producer adapters and arbitrarily many ordered processors.
 Integration Styles. The Message Exchange Pattern (MEP) defines whether a message is sent inOnly (i. e., one-way) or inOut (i. e., two-way). A  X  X wo-way X  message requires an (a)synchronously sent response, while a  X  X ne-way X  mes-sage will never result to a response ( R-7 : Model MEP). A synchronous mes-sage exchange requires an immediate response during the initiated communi-cation (i. e., mostly by event-based adapters), while an asynchronous exchange allows for an early close of the initiated communication and the response will be sent via mechanisms like  X  X unction/method callback X  ( R-8 : Model Mes-sage Synch/Asynch communication). In this context, persistent adapters like  X  X eb Service-Reliable Message X  that receive and store the message, send an immediate response and then start a transactional redelivery, which represents  X  X ynch/asynch bridge X  adapters ( R-9 ): Model Message Synch/Asynch or Asynch/Synch communication). These adapters are necessary to  X  X ridge X  asynch. communica-tion to synch. endpoints and vice versa. QualityofService. The most common service qualities of an integration system, which can be induced or supported by adapters are abbreviated as BE , ALO , EO , EOIO (sorted by the increasing quality level). The Best Effort (BE) messag-ing can be summarized as  X  X ire-and-forget X , which means that no guarantee for the delivery of a message is given. If a message shall be delivered At Least Once (ALO), it has to be persistently stored and redelivered from an adapter or the integration process ( R-10 : Model Message Redelivery (from a Message Store)). before update). That means, messages shall be send Exactly Once In Order (EOIO). Therefore, EO is extended by a Resequencer pattern [ 7 ], which collects messages to emit them in the correct order ( R-12 : Model Resequencer). Adapter Architecture and Tasks. Figure 4 draws a conceptional view on the internal architecture of a common adapter. Each adapter specifies a Connec-tor or connection handler. The connector establishes a physical connection to the message endpoints ( R-13 : Model Physical Connection). For secure connec-tions (e. g., user/password, certificates), a Security Handler is used ( R-14 : Model Security Relevant Configurations). Polling consumers might require a Scheduler for the configuration of the polling interval (cf. similar to R-1 ). For the QoS and monitoring support (e. g., message and channel monitoring), an operational data store or a message queue has to be used ( R-15 : Model (Queued-) Persistence, similar to R-10). The counterpart to the transport protocol handling connector (e. g., HTTP, FTP, JMS) is the Format Conversion (e. g., XML, JSON, CSV). An adapter shall be able to transform the sender format F representation F cdm ( msg ) and eventually to the receiver format Model Control and Data Flow). The modeled adapter shall be re-used in different adapter instances/configurations ( R-17 : Approach shall allow for re-use). Following the IFlow modeling approach of Ritter [ 13 , 14 ] adapters are repre-sented as message flows in BPMN (cf. Figure 2 ). To model integration processes with  X  X imple X  adapter configuration this approach is sufficient, although it over-defines BPMN message flows, makes the characteristics of an adapter implicit and does not allow for modeling of complex logic other than on second-level property sheets. For more complex adapter processing (cf. R-6 ), we subsequently define an explicitly modeled Adapter Flow similar to integration processes and discuss basic processing capabilities. We then derive more complex patterns from the requirements to model capabilities such as (secure) communication patterns (e. g., request/response and  X  X ridging X ) and QoS patterns (e. g., reliable messag-ing with (transactional) redelivery, idempotent receiver, message resequencer). 3.1 Adapter Flow An AF replaces the currently used BPMN message flow by an additional BPMN pool outside the integration process for more complex adapters with the need to specify an own control-, data-and exception flow. Thus, all messaging capabili-ties as described in the EIPs can be expressed within AFs. However, the physi-cal connections to the sender/receiver ( R-13 ) are represented by message flows. (bottom-right; R-10 ). These mechanisms are explicitly modeled using BPMN Exclusive Gateway elements. An adapter can decide to terminate the process-ing of one message (top-left) or the whole process (bottom-left) in exceptional situations or through other events. In case of synch. communication, a response is returned to the sender. When the basic processing capabilities are combined, more complex  X  X dapter processing X  can be expressed. To avoid re-occurring, complex adapter modeling patterns for communication and QoS support are required (cf. R-17 ). 3.2 Communication Patterns The (adapter) communication patterns specify several more complex interactions of adapters and integration processes within and outside an organization. Communication Styles and Bridge Patterns. Common (business) applications support interfaces for synchronous (synch) and/or asynchronous (asych) commu-nication styles. Synch. communication means applications respond to requests (e. g., with error codes or resulting data), while the requesting application is blocking in order to get the response (RPC-style). In asynch. communication, the sending application sends requests without waiting for responses from other applications and immediately continues with its processing after sending a mes-sage (non-blocking). However, the sending application may offer callback inter-faces for getting responses back for it X  X  previously and asynchronously sent requests. Integrating applications that do not share the same communication style requires an adapter that bridges/translates between both communication styles. Such a bridging adapter is modelled in Figure 6(a) , which shows the modeled data and control flow for a synch to asynch bridge (cf. R-16 , R-8 ), in which the synchronous call follows the inOut message exchange pattern ( R-7 ). The Synch. Call in the integration process is modelled as BPMN Service Task which connects with a message flow to the Synch-Asynch Bridge BPMN Pool . The message is forwarded to an Async. Call represented as a BPMN Inter-mediate Message End Event that connects via a message flow to the External Participant . It continues with asynch. processing that reacts to Callback mes-sagesinanBPMN Intermediate Message Start Event and forwards the response to the Synch. Call service task. Following the same pattern, Figure 6(b) shows a model for a asynch to synch bridge (cf. R-9 ) and includes the handling of responses and forwarding them to callback interfaces. Both bridge adapter mod-eling patterns can be reused, applied and adjusted in other IFlows (cf. R-17 )or  X  X nlined X  to the integration process of an IFlow.
 Processing Patterns. The AFs can be modeled to adapt between two integration processes across tenant or network boundaries (A2A and B2B), for which an integration process is associated to one tenant or network. In the case of cross-tenant integration, the IFlow of tenant T a can adapt to an IFlow in another tenant T b by representing the IFlow T b as an delegate in IFlow versa. As such, IFlows are either  X  X ocal X  to one tenant, which means that they are locally visible and modifiable or they are  X  X emote X  which means that they can only be connected from  X  X ocal X  IFlows but not made visible or modified. Hereby, for synch. communication the  X  X emote X  IFlow could be represented as a collapsed BPMN Pool (which cannot be expanded) and connected to the  X  X ocal X  integration process with request/response BPMN message flows. For (reliable) asynchronous communication a shared data store is used to make the necessary queuing step explicit. As a representative pattern, this  X  X emote X  IFlow delegate can be used to model across networks or IFlows, by changing its type. 3.3 Quality of Service Patterns The QoS levels ( R-10 X  X -12 ) denote more complex configuration building blocks. Subsequently, the necessary patterns are defined and mapped to BPMN. Reliable Messaging. To guarantee that a message is not lost in asynchronous scenarios the message must be stored into a message store (e. g., database) or enqueued to a messaging system (e. g., JMS brokers), before the reception is explicitly or implicitly acknowledged via ack to the sender. As such, an inte-gration system aims to store the message in the consumer adapter, sending the ack messages to unblock the sender waiting for a response and to minimize the ducer adapter (cf. R-3 ) to the data store (such as queue/topic names). Through BPMN Timer Event , the polling behavior of a consumer adapter can be modeled ( R-1 ). For instance, Figure 7 (bottom, right) shows the periodical, transactional dequeue of messages using a BPMN Task within a transactional subprocess, which specifies the transactional boundaries. In case of exceptions during the task processing within these boundaries, the message is not dequeued from the queue. A message redelivery would be attempted in the next polling interval (cf. R-10 ). Although Topics for publish/subscribe scenarios could be modeled similarly, they could be represented by BPMN signal end/start events (cf. Section 3.5 in [ 15 ]). The transferred message would be determined by the associated BPMN Data Object and the corresponding events would be identifiable by their matching names. Clearly this would make the inner mechanics implicit, but would allow for the modeling of an event-based consumer adapter (cf. R-2 ). For (reliable) asynchronous, inOut messaging (cf. Figure 8 ), we assume a  X  X eply-to X  header field attached to the req-msg indicating that the AF (right JMS Adapter) should reply to the specified queue. The (queued) response is correlated to the waiting integration process instance by using the identifier of the req-msg . Idempotency Repository. To support AMO and EO (in combination with Reliable Messaging ), the integration system needs to take care that messages are not sent twice to the receiver (cf. R-11 ). This is modeled by a flow step the integration process (or AF) that filters already sent messages, which is preferably executed just before the message is sent to the receiving application in a producer AF. Figure 10 shows the filter processing as part of a producer AF (bottom) by accessing an Idempotency Repository [ 7 ], which is represented as a BPMN data store, storing the identifiers of already processed messages against it checks the current message identifier.
 Message Resequencing. The resequencer (cf. [ 14 ])canbeusedfor In-Order (IO) scenarios, for which the messages have to be ordered according to a sequence num-ber. Alternatively, order preserving queues (e. g., specified in JMS) are used to keep messages in sequence. The EOIO processing additionally requires the com-bination of Reliable Messaging with redelivery semantics and a filter step using the Idempotency Repository to guarantee that the messages are sent exactly once and in order (cf. R-12 ). Let us apply the rather abstract BPMN AF definitions and integration patterns to two intriguing integration scenarios, which cover secure, reliable messaging as well as most difficult QoS configurations. Coming back to the motivating exam-ple and questions around the visualization (2) and re-configuration (3) of the expected default exception handling and compensation in the  X  X eliable Time Series Normalization X  scenario (Section 1 ) Figure 9 shows the syntax proposal following our mapping to BPMN. The devices enqueue an encrypted TD mes-sage to the telemetry queue in the messaging system using an MQTT adapter (cf. R-6 ). The integration process listens to the queue using a JMS adapter, which decrypts the received messages (cf. R-14 ) and passes them to the integra-tion process, where the message content is normalized.
 The QoS support is crucial for integration systems. When sending a message synchronously to a receiver, BE is applied (i. e., delivery will be attempted other-wise the sender will receive an exception message). In case of asynchronous, reli-able, in-order messaging this is not sufficient. The message has to be persistently stored and a retry has to be started to guarantee its delivery (cf. R-10 ), e. g., in a message queue, since the sender cannot be notified. In addition, the order of the messages according to a Message Sequence [ 7 ] has to be guaranteed using a Resequencer pattern (cf. R-12 ). If in addition, duplicate messages are filtered out during the processing (cf. R-11 ), the QoS is called EOIO, syntactically in Figure 10 . The consumer AF starts with a synchronous part by storing the mes-sage and sending a response. Hereby, the  X  X edelivery on Exception X  sub-process acts as a combined ALO, synch/asynch bridge pattern, which then starts the asynchronous delivery of the message to the integration process, which collects messages and orders them along defined sequences using a  X  X esequencer X  sub-process pattern and synchronously emits the messages to the producer adapter. The producer adapter checks whether a message has already been processed and synchronously sends it to the receiver. The receiver X  X  response (i. e., acknowl-edgement or exception) is passed to the integration process, which triggers a message redelivery on exception.
 This section discusses  X  X x-post X , practical experiences with the defined adapter modeling based on an evaluation with integration experts from different enter-prises as interviews, workshops and surveys (cf. Suppl. Material [ 15 ]). The Modeling Complexity. Some BPMN syntax elements are not applicable to the integration environment in an useful way. For example, the lane element has no semantic meaning and could only be used to structure certain aspects of the integration systems, such as distinguishing normal logic from AF logic. Though this would increase the size of the diagram leading to a confusing model. Addi-tionaly, in Figure 7 , for queuing with a message broker the data association to the message broker is denoted with the queue name to/from messages should be enqueued/dequeued. Although this was rated as complex (e. g., the adapter on top-left communicates with the adapter on bottom-right, while the adapter on top-right seems more related to the adapter on top-left), it was favored over the BPMN Signal approach proposed for topics. In case of many connections to the message broker, a partitioning of the IFlow into several smaller diagrams would help to make the single parts more understandable (cf.  X  X n-context X  editing), while tool support would be needed to show the complete IFlow on demand. The alternative of modeling several instances of one broker in one IFlow, which are then connected to related adapters only, was not seen as desirable solution. Modeling Preferences. The modeling of AFs was very well received, while the participants differentiated between producer and consumer adapter modeling. The producer adapter modeling allows for adding scenario-specific  X  X re-processing X  capabilities to the system, before entering the integration process (e. g., especially for bridges). The consumer AFs were seen limited to the QoS support, while potential  X  X ost-processing X  logic could be executed in the inte-gration process. However, from a modularity and resource consumption point of view, a clear separation of adapter and integration process logic was received well. The explicit modeling of security related topics like key stores was con-troversially discussed. While participants with a more technical background like the proposed approach (e. g., helping them to be precise in the security aspect modeling), more business related participants complaint about the additional complexity. Both parties agreed that a more explicit modeling of the inner work-ings of a message broker is not necessary and the transactional de-queuing with the BPMN Transactional Sub-Process was rated intuitive. Recently, the topics of  X  X ntegration adapter X  and QoS were mainly discussed in the areas of  X  X ervice-oriented Architectures X  (SOA) and connectivity to  X  X ata Warehouses X  (DW). However, the closest related work can be found in the Enter-prise Integration Pattern (EIP) icon notation collected by Hophe et al. [ 7 ]. The EIP notation defines modeling building blocks for core integration aspects (e. g., resequencer, publish/subscribe, durable (topic) subscriber and channel adapter). In addition, to these pattern, our approach has a representation of an idempo-tent receiver, a messaging system for  X  X tore-and-forward X  processing (guaranteed message delivery) and different levels of service quality can be modeled. Quality of Service. Most of the QoS definitions, from this work, can be found in standard industry middleware systems, too. For instance, the WebLogic system [ 9 ] knows EO, ALO as  X  X uplicates only mode X , and  X  X t-Most Once X  (AMO), which can be modeled by our approach through an idempotent receiver pattern. From a modeling point of view, adapters are reduced to one icon and a property sheet, similar to the EIP icon notation. Closer to our approach, G  X  onczy et al [ 5 ] define a proprietary meta-model for reliable messaging with acknowledge-ments for some QoS (i. e., ALO, EO) and target to apply verification approaches using graph transformations [ 6 ]. However, other service qualities, e. g., IO, AMO, EOIO, are currently undefined.
 Model-driven Adapter Development and Re-configuration. There are some app-roaches for automatic adapter generation and re-configuration from the SOA domain, to which we aligned our terminology, however, they do not define a (conceptual) modeling approach for integration adapters. Nezhad [ 4 ] summa-rizes work on model-driven development of web services, while highlighting the importance of a QoS support. Other approaches target the self-adapting adapters in terms of signature-/protocol-level and quality related re-configurations and planning (e. g., [ 19 ]). We consider these approaches complementary to our work. Data-Intensive Adapter Modeling. Through data warehouse connectivity scenar-ios, the Extract-Transform-Load (ETL) domain gained interest in the conceptual modeling of more  X  X ata-intensive X  adapters (e. g., [ 17 ]). Although characteris-tics like QoS are not relevant for data warehouse connectivity, these modeling approaches can be seen as domain-specific, complementary work. For instance, Akkaoui et al. mapped ETL processes to BPMN [ 1 ] and provided a mainte-nance framework for [ 2 ], which can be seen as subset of our approach. There are several UML-based approaches, e. g., for modeling data mining with time-series data [ 21 ] or ETL data flows [ 18 ], which mostly define new icon notations, similar to the EIP notation. Their focus on the data flow limits the modeling to data transformation. In this paper, we (a) define common adapter types within integration systems (starting from literature and small empirical studies), (b) extend our BPMN-based definition of IFlows [ 13 , 14 ] by AF constructs and patterns to make the default adapter behavior visible, and thus (c) provide a basis for a scenario-specific adapter configuration. We started with a systematical analysis of com-mon adapter characteristics (cf. R-1 X 9, R-13 X 17), spanning to edge cases like QoS modeling (cf. R-10-12).
 them to the integration flows and define common integration adapter processing capabilities and patterns. We applied our approach to the real-world  X  X nter-net of things X  integration scenario and the  X  X xactly-once-in-order X  QoS case. The evaluation exclusively targets the syntactical feasibility and applicability of the approach. The presented examples show some minor shortcomings due to BPMN X  X  focus on control over data flow and advice to change the proposed, which we solved by explicit modeling of AFs as separate BPMN pools.
 real-world case studies as well as integration expert and partner interviews show the value of the modular, pattern-based and explicit modeling approach, how-ever, highlights topics for further (quantitative) analysis. A solution for some of the mentioned issues with BPMN can be found in further investigations of the possibilities to use BPMN extensions. However, as pre-existing elements may not be modified and the syntax of BPMN models (such as conditional data flows) may not be changed, the mitigations might go beyond the current BPMN syntax.
