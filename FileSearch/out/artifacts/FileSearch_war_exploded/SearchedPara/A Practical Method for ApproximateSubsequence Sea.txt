 Since the size of DNA databases is increasi ng considerably in these days, methods of fast indexing and query processing are essential for efficient DNA subsequence search. The suffix tree [4] has been known to be a good index structure for DNA subsequence search. Recently, there hav e been many research efforts on efficient construction and query processing with suffix trees [5][10][4]. The suffix tree still has the following drawbacks due to its structural features [3][4][11]: (1) high storage overhead, (2) poor locality in disk accesses, and (3) difficulty in seamless integration with DBMS.

In this paper, we propose a novel index structure that supports DNA sub-sequence search efficiently and also re solves the drawbacks of the suffix tree mentioned above. The proposed index structure basically adopts a trie [4] as its primary conceptual structure and rea lizes the trie by pointerless binary bit-string representation [13]. It extracts s ubsequences of the pre-determined length from every possible position of a DNA sequence, and stores only those subse-quences in the index. They are called window subsequences and their length is usually much smaller than the average length of all the suffixes within a DNA sequence. This method is devised based on the observation that the length of longest common prefixes among suffixes in a DNA sequence is fairly small.
The DNA subsequence search with the proposed method uses the dynamic programming technique [4] and finds all the similar subsequences that exist on the paths of a binary trie. By traversing the trie index in a breadth-first fashion, it accesses each related page within the i ndex only once. However, the proposed method stores only the window subsequen ces of the pre-determined length, and thus suffers from large post-processing time in case of long query sequences. To overcome this problem, we divide such a long query sequence into shorter ones, and then perform subsequence searc h for each of them. This alleviates the problem of performance degradation even with long query sequences. The performance of DNA subsequence search can be improved by exploiting indexing mechanisms. The methods propo sed in references [1][2][12] employ the inverted index, which has been frequently applied in the area of information re-trieval. They extract words , fixed length intervals over lapped with one another, from every sequence, and build a posting list of &lt;sequence number , offset&gt; for each word. The method proposed in reference [6] maps every subsequence into a point in multidimensional space by the wavelet transform, and then constructs a multidimensional index on those points. By using the index, it processes range queries and nearest neighbor queries. This method enjoys nice search perfor-mance owing to a relatively small size of the index.

The suffix tree [4] is an index in a form of a persistent tree, and has been widely used in DNA subsequence search. Pr eviously, it is not easy to construct a disk-resident suffix tree whose size is la rger than that of main memory. Recently, reference [5] proposed a method for suffix tree construction by using the concept of partitioned suffix trees. Also, reference [10] proposed a top-down disk-based approach for efficient construction of suffi x trees. Reference [7] proposed an ap-proach for similar subsequence search that returns the results in the similarity based order by using dynamic programming and the A*-algorithm. However, the performance of approximate subsequence search with the suffix trees deteriorates as the length of a query sequence or a tole rance increases. A query partition-ing method was proposed to solve this problem [8]. It partitions a given long sequence into shorter ones, and perfo rms subsequence search for each of them with a smaller tolerance. Then, it merges t he results thus obtained from all the subsequence searches.
 The suffix tree, which is a compressed digital trie built on all the suffixes of given sequences, has been known to be a good index structure for DNA subsequence search [4]. The suffix tree can compress input data sequences substantially when they have a lot of common prefixes. A DNA s equence can be considered as a string from the alphabet = { A, C, G, T } . Since the size of the alphabet is very small (which is 4), it is likely that there exis t a considerable number of common prefixes in the suffixes of input sequences. However, longest common prefixes ( LCP )inthe suffixes extracted from DNA sequ ences are commonl yveryshort.
Figure 1 shows distribution of lengths of LCPs in suffixes extracted from a DNA sequence. We have used a 28.6Mbp DNA sequence in human chromosome 21 for the analysis. We have observed that the average and maximum lengths of LCPs in suffixes are 15 and 451, respectively, and that the number of suffixes that share LCPs whose length is 13 is largest(about 7.2 millions). Also, most suffixes share LCPs of a length 11 to 15, and 82.6% of LCPs have a length 1 to 15.

Based on this observation, we build an index not on all the suffixes extracted from a DNA sequence but only on their pre fixes with a pre-determined length. That is, we place a sliding window of the length | W | at every possible position of a DNA sequence, extract the subsequences covered by all the windows from a DNA sequence, and then insert them into the trie. We call these subsequences window subsequences . From our LCP analysis, we set the length | W | as 15. We extract | S | window subsequences from a DNA sequence S . The indexing with such window subsequences contributes to decrease the index size significantly and also makes the search of a leaf node simplified.
To represent all the symbols in the alphabet, we use the minimum number of bits instead of using one byte, thereby ach ieving high compression ratio. Figure 2 shows binary codes to represent all th e symbols in DNA sequences. Here, N, S, and Y denote wild-card characters [12] and  X $ X  denotes a special character used for padding to make all the window subsequences have a length of | W | .Given sequence S =  X  X CGACT X , we extract window subsequences whose length is 4 from S , allocate 3 bits for each symbol as shown in Figure 2, and represent each window subsequence into a corresponding binary bit-string as shown in Figure 3. In earlier work [13], we proposed a disk based index structure for efficient DNA sequence matching, exploiting the basic concept of pointerless binary tries. Pointerless binary tries require an alphabet to have only two symbols of 0 and 1. This makes every node have at most two outgoing edges. In this representation, the symbols on edges do not need to be stored explicitly if the following rules are enforced: (1) the outgoing edge labeled with 0 is assumed to connect to the left child node, and (2) the outgoing edge labeled with 1 is assumed to connect to the right child node. Our index structure basically adopts the binary trie as its primary conceptual st ructure. It consists of three parts: a binary trie, a page table, and a leaf table. The binary trie is an index structure storing all the window subsequences extracted from a DNA sequence. The page table stores the link information for pages within the binary trie. The leaf table stores the starting offsets of window subsequences within a DNA sequence. Figure 4 shows a binary trie constructed from the window subsequences of Figure 3. Here, node numbers in the trie are determined by the order of nodes being written into a disk page. Figure 5 shows its internal representation. The node structure is represented by a two-bit number and then is written into an appropriate page. In Figures 4 and 5, the rectangles of dotted lines represent pages stored in disk. To discover all the subsequences similar to a query sequence Q , most similarity search algorithms [5][7][8][4] based on a suffix tree traverse the tree in a depth-first fashion and, during the traversal, they build a dynamic programming (DP) table [4] using Q as its Y-axis and the sequence on the path from the root to the node being visited currently as its X-axis. We could apply such similarity search algorithms to binary tries. However, the proposed trie index contains only a two-bit number of each node. As a result, pointers from parents to their children, node levels, and subsequences on the paths from the root can not be extracted directly from the proposed trie index. Th erefore, we need to uncover this implicit information whenever reading a new page during the traversal of the proposed binary trie. In addition, our binary trie is a disk-based index structure where the nodes on the same level are stored consecutively within a disk page. As a consequence, when we traverse all pat hs of the binary trie, we may access the same node multiple times within a single page and/or the same disk page more than once.

To solve the problem of accessing the same nodes and/or same disk pages mul-tiple times, we propose to traverse the binary trie in a breadth-first order. That is, by visiting the nodes of the binary trie in a breadth-first fashion, our proposed Search-Trie() shown in Algorithm 1 effectively finds all the subsequences whose edit distances to a query sequence Q are not larger than a distance tolerance T .
Let us explain briefly how Search-Trie() operates. The algorithm employs two queues, Qpagenumber for examining data pages sequentially and Qnode for visit-ing the trie nodes of a current page one by one. The whole algorithm consists of two  X  X hile X  loops, an outer loop for data pages and an inner loop for trie nodes of a current page. For each child node CN i of a current node current Node ,we execute the following steps (Lines 7-19). First of all, we assign TRUE to vari-able moreV isit which indicates whether or not we need to traverse the index further downwards (Line 8). Function AppendBitString() creates CN i Path ,the path from the root to node CN i , by extending the path from the root to node current Node into node CN i (Line 9). If the length of CN i Path becomes a mul-tiple of 3, we compose a new symbol by aggregating the last 3 bits of CP i Path and then call function AddColumn() (Line 11). Function AddColumn() adds a col-umn for the new symbol to the DP table constructed so far (i.e., current DP T ), which results in a new DP table DP T CN i .

Let dist be the value at the last row of the last column of DP table DP T CN i (Line 12). If dist is not larger than distance tolerance T , all the subsequences containing the sequence on path CN i Path as their prefixes should be included in an answer set. Therefore, in such a case, we call function FindAnswers() where all leaf nodes under node CN i are retrieved with their sequence and offset infor-mation. After that, we assign FALSE to variable moreV isit in order to indicate more extension of path CN i Path is unnecessary (Line 15).
 On the contrary, if dist is larger than distance tolerance T ,wecallfunction FurtherVisit() which determines whether or not we have to go down under CN i . Lines 18 and 19 are executed only when variable moreV isit is TRUE. If node CN i is a leaf, we cannot decide if CN i is an actual answer and thus should perform the post-processing of CN i by executing function FindCandidateAnswer() (Line 18). This step is necessary for pro cessing query sequences longer than window subsequence W .Ifnode CN i is not a leaf, we push node CN i onto Qnode by calling function CheckpageAndPush() and continue the execution of the algorithm. Note that, if the number of nodes already processed within a current page reaches the maximum number of nodes (i.e., maxN ode )thatcan be stored within a single page, we locate the next data page by looking up page table P and then push it onto Qpagenumber and its root node onto Qnode .
Since the binary trie has been built from a set of window subsequences of a fixed length, function FindCandidateAnswer() has to be executed when query sequences are longer than the window subs equences. However, in most cases, Algorithm 1. Query processing algorithm Search-Trie the number of candidate answers grows quickly as | Q | X  X  W | becomes larger. In this paper, we propose to use a partition-based query processing [8] which circumvents this situation by decomposing a long query sequence into multiple pieces and then treating each p iece as a separate query.

The proposed partition-based query processing algorithm is shown in Algo-rithm 2. Function Search-Trie-By-SubQuery() partitions a query sequence Q into p subqueries of appropriate lengths (Line 1). The number of subqueries and the length of each subquery are determined by considering how the performance of function Search-Trie() changes with respect to the length of a query sequence. For each sub query SQ i obtained in the previous step, we perform the similarity-based searching by calling function Search-Trie() of Algorithm 1 (Lines 2-3). Note that the distance tolerance of each subquery is adjusted to T/p .Atlast,we construct a final answer set after executing function postProcessing() with a set of candidate answers candidateSet (Line 4). When offset i is given as a candidate answer, the post-processing step retrieves the corresponding data subsequence S [ i  X  X  Q | X  T , ..., i + | Q | + T ] and computes its distance to Q using dynamic programming.
 Algorithm 2. Query processing algorithm Search-Trie-By-SubQuery In this section, we show the effectivenes s of our approach via performance eval-uation with extensive experiments. We compared the performances of the three approaches Search-Trie , Suffix ,and SW :(1) Search-Trie represents our approach that employs the pointerless binary trie as an index structure. Note that the win-dow size is 15 (i.e., | W | = 15). (2) Suffix is an existing approach based on the suf-fix tree. We implemented the suffix tree by utilizing the source code of the TDD (Top-Down Disk-Based) technique [10] downloaded from http://www.eecs.umich. edu/tdd. (3) SW is the Smith-Waterman algorithm [9] based on dynamic program-ming. As a data set, we used two Homo sapiens chromosome sequences ,chro-mosome 21 (chr 21) of 28.6 Mbps and chromosome 19 (chr 19) of 56Mbps. The hardware platform is the Pentium IV 3.2GHz PC equipped with 1 Gbytes main-memory. The software platform is Redhat Linux 9 (Kernel Version 2.4.20).
In Experiment 1, we compared Search-Trie with Suffix in the respect of an index size. Figure 6 summarizes the size of each index component of the two approaches with changing data sizes. From the experimental result, we observe that the index size increases linearly in proportion to the data size in both ap-proaches. However, in comparison with Suffix , the proposed Search-Trie saves about 40% storage space.

In Experiment 2, we compared Search-Trie and Suffix in the respect of the elapsed time for approximate subsequence search. The total elapsed time is the time spent in finding all the subsequences whose edit distances to a query se-quence are not larger than tolerance T . We also examined the total number of hits returned by Search-Trie and Suffix .
Figure 7 shows the elapsed times of approximate subsequence search by Suffix and Search-Trie with various query sequence le ngths. The distance tolerance T is set to 10% of the length of the query sequence. Search-Trie outperforms Suffix when query sequences are not so long. Search-Trie runs 4 to 9 times faster than Suffix when query sequences are shorter th an 40. However, the performance of Search-trie deteriorates as query sequences get longer. This is because Search-Trie generates many candidate answers, which result in much time being spent for post-processing when | Q || W | . Next, Figure 8 shows the elapsed times of approximate subsequence search by Suffix and Search-Trie with various tolerance values. The query sequence length is fixed to 30 in this experiment. Search-Trie outperforms Suffix when tolerance values are not so large. Compared with Suf-fix , Search-Trie is about 4 to 17 times faster when tolerance values are less than 4. However, the performance of Search-trie deteriorates as tolerance values get larger. This results from the fact that the number of candidate answers increases as tolerance value s become larger.

On the other hand, Suffix shows better performance for long query sequences or large tolerance values. For large DNA sequences, however, Suffix becomes impractical when query sequences are t oo long or tolerance values exceed a certain threshold. This is because, in such cases, Suffix has to traverse a huge index structure in a depth-first order an d therefore needs to access a large number of index pages repeatedly. The experimental result reveals that Suffix on the data sequence of 56 Mbps (i.e., chr 19) cannot handle the cases of either ( | Q | =60 and | T | =6)or( | Q | =30and | T | =6).

In Experiment 3, we compared the performance of Seach-Trie-By-SubQuery with that of Search-Suffix-By-SubQuery . Seach-Trie-By-SubQuery denotes our ap-proximate subsequence search approach based on Search-Trie and a query parti-tioning method with optimal p values. Search-Suffix-By-SubQuery denotes another approximate subsequence search approach based on Suffix , instead of Search-Trie , with the same query partitioning method. We also included the traditional algo-rithm SW in this experiment. When we apply the query partitioning method to Suffix or Search-Trie , we determine optimal p values by considering both the per-formance of index searching and the overhead of post-processing. To select optimal p values, we utilized results of Experiment 2.

Figure 9 shows the total elapsed times of the three approximate subsequence search approaches. The data sequences used in this experiment is chr 19 of 56Mbps. Also, the tolerance value T is set to 10% of the length of the query se-quence. The query sequences are partiti oned into subquery sequences of length 25 in Seach-Trie-By-SubQuery . Also, the query sequences are properly partitioned into subquery sequences of length 20 or 40 in Seach-Suffix-By-SubQuery . Accord-ing to our experimental results, we see that our method performs better than the other two methods and returns the answers very quickly even with large DNA data sequences. Search-Trie-By-SubQuery shows good performance regardless of the length of query sequences, and achieves 3 to 9 times speedup compared to Search-Suffix-By-SubQuery and 75 to 200 times speedup compared to SW . In this paper, we have proposed an index structure and a query processing algo-rithm for approximate DNA subsequenc e search. The DNA subsequence search with the proposed index uses the dynamic programming technique, and finds all the similar subsequences stored on the pat hs of a binary trie. By traversing the trie index in a breadth-first fashion, it accesses just the pertinent pages within the index only once. In cases of a long sequence, it divides a query sequence into a set of shorter subsequences and ret rieves actually similar subsequences by performing subsequence search for every shorter subsequence.
 Acknowledgments. This work was supported by Korea Research Foundation Grant funded by Korea Government (MOEHRD, Basic Research Promotion Fund) (KRF-2005-206-D00015), by the Brain Korea 21 Project in 2007, by Korea Science and Engineering Foundation(KOSEF) grant funded by the Korea Gov-ernment(MOST) (No. R01-2006-000-11106-0), by the MIC of Korea under the ITRC support program supervised by the IITA(IITA-2005-C1090-0502-0009).
