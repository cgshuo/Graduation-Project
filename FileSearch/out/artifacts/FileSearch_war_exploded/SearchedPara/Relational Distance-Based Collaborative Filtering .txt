 In this paper, we present a novel hybrid recommender system called RelationalCF , which integrate content and demographic information into a collaborative filtering framework by using relational distance computation appr oaches without the effort of form transformation and feature construction. Our experiments suggest that the effective combination of various kinds of information based on relational distance approaches provides improved accurate recommendations than other approaches. H.3.3 [Information Storage and Re trieval]: Information Search and Retrieval -Information Filtering. Design, Algorithms, Human Factors Hybrid recommender system, relational distance, collaborative filtering Recommender systems help users to deal with information overload and guide them in a pers onalized way to interesting or useful objects in a large space of possible options. One of the most difficult challenges for these systems is predicting a rating, which indicates how a particular user liked a particular object. Recommender systems are usually classified into the following three categories according to the sources of data on which recommendation is based. In collaborative filtering systems, the typical sources of data in a co llaborative filtering system consist of a vector of items and their ratings, continuously augmented as the user interacts with the system over time. In content-based recommender systems, the objects of interest are defined by their associated features and the user will be recommended objects similar to the ones the user prefe rred in the past. In demographic recommender systems, the systems aim to categorize the user based on personal attributes a nd make recommendations based on demographic classes. To avoid certain limitations of each pure category recommender systems, many researchers have explored hybrid recommender systems. However, the additi onal effort of data form transformation and feature construction is needed in most of the hybrid recommender systems. Furthermore, few of them simultaneously consider the collaborative, content and to address exactly this problem. An example movie sales database R is adopted to illustrate our approach. The example database consists of four relations: relation user(user id, age, gender, occupation, zip code) , relation movie(movie id, movie title, release date, video release date) , relation movie-genre(movie id, genre) , and relation rating(user id, movie id, rating) . Relation User describes demographic informa tion about the users. Relation movie describes information about the movies and relation movie-genre does genre information about the movies. Relation rating stores the ratings of movies given by users. Among them, the foreign key user id of relation rating references the primary key user id of relation User , the foreign key movie id of relation rating references the potential key movie id of relation movie, and the foreign key movie id of relation movie-genre references the potential key movie id of relation movie. These references model the one-to-many relationships between the corresponding relations. It is noteworthy that re presenting the database using just one big relation (i.e., the cartesian product of all 4 relations) can lead to meaning error when computing similarity between movies. Due to many one-to-many relationships between the corresponding relations, the big rela tion may have more than one row for one movie, which violat es the general assumption in typical similarity computation that each movie has just one row in the relation. In order to calculate similarity between movies, relation movie is considered as the main relation. Once the main relation is determined, similarity between m ovies can be calculated by using relational distance measure de scribed as follows. Here, similarity between movies= 1-relational distance between movies . Each instance, M , of the movie relation will give rise to one relational instance , M + , i.e. an instance that spans the different relations in R . Given instance M , we create a relational instance M + that will have the same set of attributes and the same values for these attributes as M has. Furthermore each foreign key and the primary key add in M + one attribute of type set or of type list. The value with which M is associated in some relation when we follow one link defined by the key. These actually relational instances are retrieved by a simple SQL query. By recursive application of this procedure we obtain the complete description of the relational instance M + . Specially, when computing the distance between relative demographic information of any pair of movie instances, we add in M + one attribute DI of type set, whose value of the attribute will be the set of instances with which M is associated in relation user when we follow the foreign key movie id and user id of relation rating . The computation of the distance between two relational instances is done in a recursive manner traversing the full tree structures of the relational instances. For com putational reasons the depth of recursion is controlled by a depth parameter depth . In order to compute distance dist between any two relational instances R ia , R of relation R i with k attributes, we use the formula the R ia , R ib for attribute A k and W k are weights for a given attribute. In our current experiments, W k s are assigned to 1s. The sum runs over all standard attributes, all set attributes and all list attributes of the relation R i . The function diff depends on the type of the attribute A k on which it is applied. For standard continuous 
