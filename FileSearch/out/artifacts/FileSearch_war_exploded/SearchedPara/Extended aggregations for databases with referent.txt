 1. Introduction
There has been a growing interest on the problem of obtaining improved answer sets produced by queries in a setting integrity errors commonly arise in scenarios where several organizations have their databases integrated, where exchanging or updating information is frequent, or where table definitions change. Database integration represents a common scenario where similar tables coming from multiple source databases (OLTP systems) have different referential integrity constraints and each DBMS provides distinct mechanisms and rules to enforce referential integrity. Therefore, source databases may vio-data model behind a relational database evolves, incorporating new attributes and new relations not defined before, causing old data to violate new referential integrity constraints.
One way to deal with the problem of violation of integrity constraints is by updating the database in order to achieve consistency. This strategy has been thoroughly studied recently and several solutions have been proposed. In [19,3] consis-be exploited, for example, with OLAP queries. Fixing errors is difficult because it requires understanding inconsistencies across multiple tables, potentially going back to the source databases. A good overview on data cleaning can be found in [14,33] . This strategy presents several disadvantages. First of all, in many real-world scenarios, we cannot be sure that the techniques used to repair the database are error-free. The chief disadvantage about such approach is that the database must be modified. Second, the original database is updated and the user loses track of which data elements represent either
Removing data is the easiest, but generally not an acceptable solution. In many data warehouse environments, the repair is done by adding rows to some dimension tables to make explicit that the fact with an invalid foreign key exists in the data-ommended in [22]. Letting referential errors go undetected can lead to expensive repair processes and queries producing incomplete answers. When a data warehouse has many denormalized tables (materialized views) repairing referential integ-bound particular aggregated groups of the answer sets of aggregate functions.

In this work we propose an innovative strategy in order to obtain improved answer sets produced by queries posed over and bound aggregation answer sets by using the most likely values from the correct references. We introduce extended the repair techniques mentioned above, we are not interested in updating the database foreign key values by substituting determine the expected correct answer set or determine the lower and upper bounds of the answer set of standard aggre-gates computed over a joined table on foreign key-primary key attributes with potential referential integrity violations or ies, we present a probabilistic interpretation of the extended aggregate functions and show that these functions together with the standard SQL grouped attribute aggregations computed over a joined table on foreign key-primary key attributes with potential referential integrity violations are part of a common probabilistic framework.
 main contributions. We explain how to compute aggregations in the presence of undefined references or of referential integ-rity errors and we introduce several families of extended aggregations. We show how we can implement our proposal in SQL.
We show how the extended aggregates may be improved in the presence of columns not independent. Section 4 presents experiments with real and synthetic databases. Section 5 discusses related research. Section 6 concludes the article. 2. Definitions 2.1. Referential integrity
A relational database is denoted by D  X  R ; I  X  , where R is a set of N tables R  X f R of referential integrity constraints. A referential integrity constraint, belonging to I , between two tables R ment of the form: R i  X  K  X ! R j  X  K  X  , where R i is the referencing table, R is the primary key or a candidate key of R j . In general, we refer to K as the primary key of R sume simple primary and foreign keys and the common attribute K has the same name on both tables R for every referential constraint: (1) R i K and R j K have the same domains and (2) for every tuple r tuple r j 2 R j such that r i  X  K  X  r j  X  K . The primary key of a table ( R
When two tables are joined and aggregations are computed, the tuples with an undefined foreign key value that reference defined, as opposed to the undefined dimension tuples explained above.

Referential integrity can be relaxed. We assume the database may be in an invalid state with respect to I . That is, some relaxed state . In a relaxed database R i may contain tuples having R 2.2. Aggregations
Let F agg  X  R A  X  be a simplified notation to denote the answer set returned by an aggregation, where agg() is an aggregate function and A is some attribute in R to compute aggregations on, or equivalently in SQL SELECT agg  X  R A  X  FROM R ;
The value of this atomic table with one tuple and one attribute will be denoted as agg  X  R A  X  to make it compatible for B will be denoted as B F agg  X  R A  X  , or in SQL SELECT agg  X  R A  X  FROM R GROUP BY R B ;
Throughout the article, since there exist several different definitions for aggregate functions [26] which have distinct on the standard SQL definition [21].

Our proposal can be applied in any database. However, our examples refer to an OLAP database. In this work, the follow-ing two tables will be used: where R i with primary key PK represents a referencing table playing the role of the fact table and R table acting as the dimension table. Attribute K is a foreign key in R which the aggregate function is applied.

We are particularly interested in computing aggregations over a joined table on foreign key-primary key attributes, in this ing an undefined group in the answer set as explained above but interested in receiving an answer set a rigorous database would provide.

Motivated by the fact that a null reference provides no information and the ffl operator eliminates R assume that foreign keys are allowed to have nulls. To consider both scenarios, and in order to simplify our exposition, throughout the article we will denote as R  X  K the set of values in p We denote a generic null value by g .

Throughout the article, since we are assuming that the data warehouse user is not interested in receiving an undefined group in the answer set of an aggregation over a joined table on foreign key-primary key attributes, R tion, R j  X  K  X  p K  X  r K  X  0 NA 0  X  R j  X  X  , causing the undefined values in R errors.

With these ideas in mind, the answer set returned by an aggregation over a joined table on foreign key-primary key attri-butes will be denoted as: F agg  X  R i A ; r i  X  K 2 R j  X  K  X  or equivalently in SQL assuming g is invalid SELECT agg  X  R i A  X 
FROM R i JOIN R j  X  K ON R i K  X  R j K where agg() is an aggregate function, as defined above. The corresponding aggregate function list with grouping attribute K will be denoted as: K F agg  X  R i A ; r i  X  K 2 R j  X  K  X  , written in SQL with the same assumption as above as SELECT agg  X  R i A  X  FROM R i JOIN R j  X  K ON R i K  X  R j K GROUP BY R i K ;
In formal terms the problem we are solving is the following. An inconsistency may arise due to undefined references or referential integrity errors when group: and total aggregates: are computed over joined tables.
 Now, given k 2 R j  X  K , we will denote as agg  X  R i
F agg  X  R i A ; r i  X  K 2 R j  X  K  X  that corresponds to the tuples where r corresponds to the answer set given by the following equivalent expression written in SQL to highlight the selected group SELECT agg  X  R i A  X  FROM R i JOIN R j ON R i K  X  R j K GROUP BY R i K HAVING R i K  X  k ; Equivalent SQL expressions are given throughout our work because our proposal was implemented and evaluated in SQL.
Finally, observe that keys consisting of multiple attributes can be easily generalized based on the same ideas. If a multi-attribute key has at least one attribute with an invalid or undefined value, then the entire key is considered invalid/ undefined. 2.3. Motivating examples
Our examples throughout the article are based on a chain of stores database with three tables: sales(storeId , cityId, regionId, amt,qtr, ... ) city(cityId , cityName, country, ... ) region(regionId , regionName, ... ) which are the result of integrating two databases from two companies, X and Y, that are in a process of database integra-state is shown in Fig. 1 , where invalid references are highlighted, assuming that the null value is invalid.
Fig. 2 shows a strict database with no referential integrity errors, which is the same database as above but after an ETL process where the invalid references NXX and g in table sales were changed to point to a new tuple in table city with the following data: h NA ; NotAvailable ; g ; ... ; i .

The unioned query computes the sales amounts grouped by city.cityId, cityName and the total sales amount. But, as we can see from the query in Fig. 4 , the answer set is inconsistent in a summarizable sense. That is, let s 2 sales : Their total sum of sales amount is different.
 query gives grouped aggregates, that considered as a whole, are inconsistent with respect to the total given by the same tuples are eliminated from the aggregate function answer set. With a strict database obtained after fixing the referential an approximate answer set of the true real values?
Suppose the information from Y is more reliable than information from X. A query getting total sales by region and total overall sales is shown in Fig. 5 . In this case, a summarizable consistent answer set is obtained joining with the foreign invalid or undefined foreign key values? This will be a goal of our approach. 3. Aggregations in databases with referential integrity issues
In this section we will present our proposal. First we will provide some preliminary definitions. Based on these defini-tions, we present our extended aggregations in data warehouses with undefined references or databases with referential integrity errors. 3.1. Preliminary definitions
For the following definitions, consider a relaxed database where the referential integrity constraint R As stated in Section 2.2, we denote as R j  X  K the set of values in p or a similar description.
 domain of an attribute, and one and only one of the elements of the subset is the true value of the partial value.
R i K , where its probabilities are associated to each defined value of the referenced primary key, say R corresponds to the probability that an invalid or an undefined foreign key reference in R defined reference in R j  X  K . Let k 2 R j  X  K , and p  X  k  X 2 RPP the associated probability. We say that R
The idea behind the RPPs is to associate to each referenced, defined primary key value a probability. Each probability cor-in the corresponding foreign key. Notice that for each referenced key, a set of RPPs may be defined, one or more for each foreign key that references it. Users with good database knowledge may assign these probabilities. Depending on the prob-abilities the user assigns to the defined foreign key values, different RPPs under which completeness may be satisfied (Eq. key values were equally probable, a uniform RPP would be defined. Another special case could be a skewed probability dis-ertheless, a feasible way to assign these probabilities when computing our proposed aggregate functions is following the intuition that a high probability will correspond to a high frequency in the foreign key and a low probability corresponds to a low frequency.

Definition 2 ( Frequency weighted RPP ). Let k 2 R j  X  K and n  X jf r defined reference in r i  X  K . We define p  X  k  X  as
We are assuming a uniform probability distribution function if there are only undefined or invalid values in R we do not have more information. Thus defined then R j K is complete under the Frequency weighted RPP .
Example 3. Consider the relaxed database of Fig. 1 or the strict database of Fig. 2 . The Frequency weighted RPP that corresponds to sales.cityId considering the defined values of the referenced primary key city.cityId , h LAX ; MEX ; ROM ; MAD ; LON i ,is
Here, we are assuming g is an invalid value. If this were not the case, the Frequency weighted RPP that would correspond to the correct values taking g as valid, that is, for h LAX ; MEX ; ROM ; MAD ; LON ; g i the Frequency weighted RPP would be Notice in Fig. 2 that if we assume g is a valid value, the ETL process would leave g in attribute sales.cityId in tuple 5.
We can design RPPs that fail to meet completeness. Two special RPPs where completeness may not be satisfied are the following: For the next two definitions, let k 2 R j  X  K Definition 3 ( Full RPP ). Define p  X  k  X  as p  X  k  X  X  1.
 Definition 4 ( Restricted RPP ). Define p  X  k  X  as p  X  k  X  X  0.

With the Full RPP we associate to each defined, correct reference probability 1, meaning that every undefined or invalid reference of the foreign key is in fact the associated valid value. On the other hand, with the Restricted RPP we associate probability 0 instead.

Definition 5 ( Referentiality (REF) ). Let r i 2 R i and k 2 R value r i  X  K with respect to k , REF  X  r i  X  K ; k  X  , as follows: where the probability p  X  k  X  corresponds to a given RPP.

Intuitively, REF  X  r i  X  K ; k  X  is the degree to which a foreign key value r k 2 R j  X  K . 3.2. Extended aggregate function definitions
For the following definitions, consider a relaxed database where the referential integrity constraint R violated or a strict database with undefined references as described in Section 2.1. Let r databases with undefined references will be defined under a given RPP as follows:
In Eqs. (5) and (6), we are assuming the tuples with g in r gate function is computed over R i K , here also the tuples with g in r assuming also, as in many OLAP scenarios (e.g. Example 1 ), that the r or negative. The specific name and meaning of the extended aggregate is obtained by changing prefix x _ and using the cor-responding RPP, according to Table 1 .

Eq. (4) corresponds to count( * ) . When g is assumed to be an invalid reference, the RR extended aggregates correspond to integrity violations.
 Table 2 .

The referentiality of the same foreign key that corresponds to the tuples with invalid or undefined references using different RPPs is shown in Table 3 .

Next we show how to compute the different extended aggregates that correspond to the aggregate sum() using the corresponding RPP shown in Table 3 . Frequency weighted referential: Fig. 6 shows the origin of each equation element and the RPP involved.
 Full referential: f _ sum(sales.amt, s[cityId] = LAX) = 216.00 Restricted referential: r _ sum(sales.amt, s[cityId] = LAX) = 118.00 Weighted referential: w _ sum(sales.amt, s[cityId] = LAX) = 137.60 The last expression computed with the Uniform RPP .

Observe that the referentiality is useful to easily understand the meaning of our extended aggregates. However, the inter-pretation given in Fig. 6 could be misleading in the case where there are no tuples in R key value k , where k is a defined reference. For example LON in our running example. If the probability associated to this value is zero or there are no invalid tuples, there would be no tuples that qualify so our extended aggregates would give g , taking the standard SQL definition [21], and not zero.
 mind we define x _ avg() as
Remember that in Eqs. (5) and (6) , we are assuming the tuples with g in r
Extended aggregates for max() and min() can be defined also under our framework. The FR and RR variants are defined as follows
In order to compute the WR and, specifically, the FWR variants, we need to compute the average of the maximum/min-invalid or undefined reference in foreign key R i K . Let E present in E i is e m , where m  X d p  X  k  X  e e , assuming there are tuples with an invalid or undefined reference in R ence may be present in E i . To determine the ways the r i of the maximum/minimum of r i  X  A of all the R i instances, for a certain defined value k , we proceed as follows. Let  X  a sequence of all the r i  X  A values in E i and, in the case of the w _ max() functions, the items of  X  a f r j r i 2 R i ^ r i  X  K  X  k g  X  / , in this sequence, the r quence for each k value. Notice also that these sequences may have repeated values.

With these definitions we have
Intuitively,  X  a e  X  has the maximum values of r i  X  A of the r stances of R i where the defined reference k may be present in E the maximum of r i  X  A in e 1 m 1 instances, a 2 in e 2 m 1
The w _ min() functions are defined accordingly, taking sequence  X  a amin  X  MIN  X f r i  X  A j r i 2 R i ^ r i  X  K 2 R j  X  K g X  instead of amax when r e  X  2. The number of tuples that best fit the average of tuples value LAX may be present in these tuples is are 65 and 33, and the maximum value of s  X  amt in the valid tuples where s  X  cityId  X  LAX is 64. Then  X  a
According to Eq. (10) we have simplified notation defined in Section 2.2, we have the following: 3.3. Function properties
Our extended aggregate functions must fulfill certain properties to be considered clean extensions of their counterparts in standard SQL.
 increasing or decreasing aggregate as in many OLAP scenarios (e.g. Example 1 ), where the measure attribute, when different gate, respectively.

Proposition 1. The extended aggregates x _ count(*) , x _ count() and x _ max() are ascending aggregates. If 8 r x _ sum() functions are ascending aggregates.
  X  a
 X  , in the case a tuple is inserted, the aggregate will only possibly increase when the inserted tuple meets the condition r  X  A &gt; amax , no matter if it has a defined, undefined or invalid reference in r the aggregate because, at most, an item of  X  a e  X  could decrease or could be eliminated. h Equivalently, for x _ min() and for x _ sum() with negative values in the measure attribute, we have the following:
Proposition 2. The extended aggregates x _ min() are descending aggregates. If 8 r descending aggregates.
 ing that the answer sets will not be different compared to the ones from the standard SQL joined aggregations, that is, the
SQL grouped attribute aggregations computed over a joined table on foreign key-primary key attributes. Here, we assume g is invalid.
 Proposition 3. If 8 r i 2 R i ; r i  X  K 2 R j  X  K then F x agg  X  X   X  F agg  X  X  .
 Proof. This is easily seen observing that if there are no tuples with an invalid or undefined value in foreign key
R i K ; 8 r i 2 R i ; r i  X  K 2 R j  X  K , then, by Definition 5 we have REF  X  r by the definitions of our extended aggregates, that the tuples that qualify for a given extended aggregate are the tuples where r i  X  K  X  k ; k 2 R j  X  K where, in this context, R SQL grouped attribute aggregations computed over a joined table on foreign key-primary key attributes [21]. h
Summarizable consistency . For the WR and FWR count(*) , count() and sum() aggregate functions, a summarizable consistency preserve the results over the subsets of its partitions. We will prove summarizable consistency for aggregate w _ count  X  R inition 5 , and the completeness property under an RPP of these type of aggregates, Eq. (3).

Proposition 4. Let r i 2 R i and attribute PK its primary key. Then Proof. By Definition 4 we have
Using Definition 5 where r i  X  K  X  k and r i  X  K 2 R j  X  K we have
Using Definition 5 where r i  X  K  X  k we have
Using Definition 5 where r i  X  K  X  R j  X  K we have
Since the RPP of the WR aggregate functions meets the completeness property we have which proves the equality of both expressions. h
Summarizable consistency for w _ sum  X  R i A  X  can be formulated as because rigorously repairing a tuple, in our context, is equivalent to transfer a tuple from set f r f r j r also a consequence of the completeness property (Eq. (3)) under an RPP of the WR and FWR aggregates. As for the x _ avg() on the value of the foreign key.
 updating the undefined or invalid reference with the defined value we are considering. 3.4. SQL implementation of extended aggregations erence in foreign key cityId , lines 7 X 26. The corresponding query for database in Fig. 2 could be computed with a view of table city excluding the tuple marked as undefined.

We first compute a temporal table named fw temp , lines 7 X 14, with five attributes: values referenced by the foreign key sales : cityId ; the foreign key sales : cityId valid values taken from city : cityId , renamed as K ; the number of tuples with a given value in the foreign key sales : cityId , rfreq ; the number of rows that have a value different from null in a given attribute, to compute aggregate function count() ,is computed from the tuples with a value different from null in sales : cityId ; freq ; finally, the sum() of attribute sales : amt for each group, as sumagg .

For this implementation we use an alternative way to express fw _ sum  X  R have:\ considered an invalid reference. By computing a RIGHT OUTER JOIN and a GROUP BY in lines 12 and 14, respectively, if there same row, attribute freq will hold the number of invalid values different from null. Notice that the cardinality of table that follows, line 15, computes the sum() and fw _ sum() for each value in the element list. We show in lines 16, 18 and 20 the place where each element of the FWR aggregate is computed.In line 17, for each tuple in the answer set, one for each are no tuples with invalid values (COALESCE clause in line 19), multiplied by the corresponding value in the frequency weighted RPP (dynamically computed in lines 21 X 23). The additional overhead due to the computation of the FWR aggre-need to substitute attribute sumagg with attributes rfreq or freq , respectively in the appropriate places.
We were able to design a clean function invocation for the SQL implementation of the FWR aggregates because the fre-quency weighted RPP is computed dynamically. For the other WR aggregates, the user is required to provide the correspond-ing RPP. In Fig. 8 we show an SQL implementation using table fw temp which was computed in the past SQL example and a has two fields: Kpp holds the referenced and unreferenced values and pp holds their corresponding probability. The user has must add to one. The SELECT statement in lines 10 X 16 covers the different cases in order to give a complete, summarizable consistent answer set. In a related work, in [30] we studied the performance of several techniques to compute by means of
SQL clauses referential quality metrics. The SQL implementation presented above may be optimized with one of the tech-niques studied, namely the early foreign key grouping technique. This technique evaluates a group-by clause by foreign keys 8 X 14, may be changed to the one presented in Fig. 9 . In Section 4 we present several experiments concerning this optimization.

To compute aggregate function w _ max() we need to compute the maximum of each group of tuples of each of the defined references in the referencing table, determine sequence  X  a the number of tuples with an undefined reference, according to Eq. (10), compute each maximum. Function w _ min() is com-puted accordingly. 3.5. Extended aggregates computed on tables with columns not independent
We can improve the estimated answer sets of our extended aggregations computed over a joined table on foreign key-undefined references). Consider a table with foreign keys belonging to a set of attributes that are not mutually indepen-dent. This scenario is possible when two or more databases are integrated and there are tables that share a common pri-mary key. Functional dependencies may be defined between sets of attributes involving foreign keys. Although the database may not be in 3NF, remember we are assuming a relaxed database or a strict database with undefined references, and our goal now is to keep all data, instead of repairing it. Suppose we have two foreign keys R
R
K b referencing R j b K b , where R j a and R j b are two referenced tables, and an attribute R tion is computed. In our running example city may stand for table R sales.cityId and sales.regionId , respectively. Also suppose the following functional dependency should hold between both attributes: R i K a ! R i K b . We can imagine this situation as if a set of elements represented by values in attribute
R i K a , e.g. cities, should be contained in an element represented by a value of R
R i K a and R i K b , may each have a RPP associated, say RPP k 2 R j b  X  K b . Suppose r i  X  K a R R j a  X  K a , that is, r of defined references that may occur in r i  X  K a , say S where p  X  k a j k b  X  is the conditional probability that the defined reference in r ditional probability p  X  k a j k b  X  may not be equal to p  X  k
Based on definition of completeness of a referenced primary key under an RPP, see Definition 1 , we say a set of defined references, say S k b , is complete under the conditional probabilities of its elements given a value, say k
Consider now the case where r i  X  K b R R j b  X  K b and r
R  X  K b , say k b , we have p  X  k b j k a  X  X  1 and for the rest, the conditional probability is zero.
Example 6. Consider the relaxed database of Fig. 1 or the strict database of Fig. 2 . Observe the tuple with value 5 in sales.storeId . As discussed before, the frequency weighted RPP may be used to compute our extended aggregates. According to Example 3 and assuming g is invalid, next we show the frequency weighted RPP: tioned above is a city in the Americas region. That is considering the values of the referenced primary key city.cityId , h LAX ; MEX ; ROM ; MAD ; LON i ,is where the probabilities that correspond to LAX and MEX are the following conditional probabilities considering there are three tuples that correspond to the Americas region.

To improve the estimated answer sets of our frequency weighted extended aggregations we can proceed as follows. Ob-serve that the set of defined references in R i K b defines a partition of the corresponding set of defined references in R
Assuming all the references in R i K b are defined references, we can define a partition of R and including the tuples with an invalid or an undefined reference in R partitions with tuples with defined references in R i K b table R j a that are not associated to a defined reference in R not associated to any region. Tuples with an invalid or undefined reference in both foreign keys R for part of the corresponding aggregate of all the defined references in R
As for the tuples with a defined reference in R i K a but with an invalid or undefined reference in R ted as correct tuples by dynamically repairing the tuple with the corresponding value of R ues of the functional dependency assuming there is at least one correct tuple with the defined reference in R corresponding defined value in R i K a . Otherwise, these tuples are treated as a separated partition.
In case there are violations to the functional dependency, in order to reconstruct feasibly the functional dependency so we can apply the strategy explained above, we can follow the intuition that a dependency violation appears with a much less frequency than a correct functional dependency. On the other hand, a pair of values of R quently associated in a number of tuples may be considered as a correct pair of values according to the functional depen-dency constraint. With these ideas in mind, we can reconstruct the functional dependency by choosing for each correct reference k a in R i K a the correct reference k b in R i one value.

Take the databases of our running examples in Fig. 1 and 2. We show in Table 4 how the aggregation fw sum  X  X  may be improved by means of the foreign key regionId .
Now, if the trusted foreign key is R i K a , we proceed in a similar fashion. A defined reference of foreign key K only one value of K b . If a pair of defined values k a ; k sidered an invalid value. 3.6. Probabilistic interpretation
In order to obtain a valid inference from our extended aggregate functions, it is important that the user bears in mind the following assumptions. Notice we are assuming that R j K is complete. That is, R all the possible defined values. On the other hand, attribute R is assumed to be an element of a set, the set of referenced defined values. Although we can design RPPs that fail to meet completeness (see Definition 1 ), the set of referenced defined values is assumed to be complete. Alternative approaches,
Users may assign different RPPs, nevertheless, the Frequency weighted RPP assumes that the probability that a certain defined value be the actual value that should stand instead of the invalid or undefined value in a foreign key, depends on undefined value does not depend on the invalid or undefined values. As for the aggregate functions like sum() where the aggregate function is applied over an attribute, we are assuming that the foreign key and the invalid or undefined values
Now consider a set of binomial random variables each one of them represented by a potentially defined reference of a resents is present in R i K . Next, given our assumptions, suppose that each tuple of R That is, it is rigorously repaired with respect to referential integrity with value k .

Notice that if k 2 R i  X  K (if g is valid, then it should be considered also) then jf r lower bound of the corresponding binomial random variable. If k R R integrity errors or with undefined references) were unsuccessful. That is, the case where the actual value of attribute R r foreign key R i K are indeed k . We can see then that for the random variables described above, if k 2 R that it takes a value lower than jf r i j r i 2 R i ^ r i ability is 1 that it has a value lower or equal to jf r i takes place. If k R R i  X  K the corresponding values are 0 and jf r pute the expected value of the binomial random variable by adding to its initial value the product between the number of independent trials (tuples with an invalid or undefined reference) and its corresponding probability in the RPP. This value with an invalid or undefined reference were rigorously repaired with respect to referential integrity. and upper bounds, respectively, of the value the corresponding standard aggregate may take when the tuples with an invalid or undefined reference are rigorously repaired with respect to referential integrity. The WR and FWR are the expected value of the corresponding standard aggregates of the aggregate functions we mentioned above and its result depends on which tuples with an invalid or undefined reference, where e  X jf r ples with an invalid or undefined reference then, the meaning of Eq. (10) in this context is also, as the other WR and FWR aggregates, the expected value of the corresponding standard aggregate. 3.7. Discussion
In order to evaluate the usefulness of the answer sets delivered by the WR and the FR aggregations, the following impor-are there and does a repair process eventually give the answer set delivered by the weighted referential aggregations? We discuss these issues below.

As in Section 3.2, let e be the number of tuples with an invalid or undefined reference in foreign key R or undefined foreign key, defined in Section 3.3, let a rigorous referential integrity repair of attribute R
R , with the same number of tuples, but with the invalid or undefined values of foreign key K replaced with defined values taken from the set of values of R j  X  K . The number of potential referential integrity repairs of attribute R pretation just discussed we can see that for the aggregate function count() there are e  X  1 or less plausible answers and 2 for the aggregate function count() for the group represented by value LAX are {2,3,4} because there are 2 invalid/undefined as an invalid reference. If we compute the probabilities of each of the plausible answers considering the RPP of the same example we have {(2,0.44), (3,0.44), (4,0.11)}, where the first number of each pair is the plausible answer and the second yId takes place.

In the same way, for the aggregate function sum() the plausible answers for value LAX and their corresponding probabil-plausible answer 151 is 0.66 with the plausible answers sorted on ascending order. As we can see from Example 4 the cor-functional dependencies may be used to reduce the number of potential referential integrity repairs, improving this way the answer sets of our extended aggregates.

We can see then that the proposed aggregations are a very efficient way to compute the estimated answer sets and the upper and lower bounds of the corresponding aggregate functions, although we do not pretend to give an exact result of a rigorous repair process.

Finally, this work covers the standard SQL aggregates. Other aggregate functions may be defined extending the same basic ideas presented in the article. 4. Experimental evaluation
We used two real databases and a synthetic database, generated with the TPC-H DBGEN program [35]. For each specific case we report the relational DBMS used. We used standard SQL (ANSI) in our implementation, making it portable in each relational DBMS. 4.1. Real databases 4.1.1. Government organization
We present our extended aggregates on a database from a government organization responsible of supervising education 16,000 public and private schools. Evaluation of extended aggregations was carried out on the DBMS Oracle 9i.
The government organization supervises the preschool, elementary and middle school systems. It verifies that certain minimum services are provided such as student evaluations every two months, scholarships, scholastic breakfasts and others.

Every annual cycle each school sends information to a centralized database about its enrolled student population, and every two months sends information about its active student population. Nevertheless, more than 30% of the registered schools are not connected to the database. These schools represent about 10% of all the student population, but are the schools with the lowest budget. It has been detected that the records that come from these schools have a high incidence gates, the government organization discarded entirely the tuples with referential errors losing valuable data.
Several assumptions about the database were discussed and were validated by the user in order to obtain valid inferences from the extended aggregates: the number of erroneous tuples was proportional to the number of records sent by a given school a tuple with an erroneous foreign key in the schoolId field came from a school that was not connected to the database a referential integrity error did not depend on the particular type of entity that the corresponding tuple came from when computing aggregate functions where an attribute is aggregated (e.g. sum() ), this attribute did not depend on the foreign key (e.g. the amount received per student did not depend on the studentId because all students receive monthly the same amount)
Our extended aggregations have been used to answer queries related to information about how many services and of what type a student or a school have received. By identifying the schools that potentially can send data with referential bounds in sums and counts. Results were discussed with the Information Technology manager, a database developer and two users. The IT manager was relief upon having an alternative method to respond to the users while he had a solution that had to do with altering the database to correct the referential integrity problems. The database developer was surprised at how quickly this alternative solution was implemented. Users have told us that the computed estimates are useful. Also, they experience also shows how our techniques can be combined with other strategies. 4.1.2. Retail company
An important retail company in Mexico listing on the stock market for more than 25 years tried our extended aggregates agents. The agents are advisers working in specialized departments that participate in sales and they earn commissions based on sales depending on the number of sales and the total amount sold of their corresponding products. In every point 7% of the total number of sales that should appear with an agent X  X  code, have an invalid value in this field. Table 5 shows several registers of how the information is received, some of them with no information in the agent X  X  code field, agentId .
Several assumptions about the database were discussed and were validated by the user in order to obtain valid inferences nor on the attribute that was aggregated.

The commission is paid after a given time to avoid paying an agent when a product is returned. A bonus is added to com-considering the total amount of sales without an agent code and taking into account the total number of sales where an agent took part. Tables 6 and 7 show the amount of sales per agent, the commission earned and the bonus computed using fw _ sum() . 4.2. TPC-H Database
Our synthetic databases were generated by the TPC-H DBGEN program [35], with scaling factors 1 and 2. We did not de-eral different probability distribution functions (pdfs) including uniform, Zipf and geometric, and in two foreign keys ( l orderkey , and l suppkey ).
 randomly inserted according to three different pdfs, that follow the parameters shown in Table 8 , where R referenced table. To evaluate the time performance of the most demanding computation of our extended aggregation, that zation technique named early foreign key grouping (see Section 3.4). 4.3. Approximation accuracy
In order to evaluate the approximation accuracy for the WR aggregations, we conducted the following experiments. We neous values were generated so that they follow the three pdfs introduced above and were inserted randomly in order to simulate a scenario where the errors occurred in an independent manner. Before doing so, we stored the valid references on another table in order to  X  X  X epair X  the invalid references when needed. We simulated a process of gradually repairing the database and within this process we also computed our proposed aggregate functions. Remember that in our framework, we are not interested in how repairs are done, but in getting an approximation of the answer set. We then evaluated the FWR aggregations and their corresponding standard SQL joined aggregations. Next, we repaired a 2% random subset of the original invalid references; our FWR aggregations and standard SQL joined aggregations were computed again. We repeated this pro-compare such values with the  X  X  X orrect X  ones on the final repaired table.
 low variance. Each plot, one for each pdf, shows the maximum and minimum correct aggregate values eventually reaching
In the next experiment we evaluated the approximation accuracy for the WR aggregations, but with different RPP. We the tuples belonging to the valid reference with the highest and lowest probability. In Table 9 , we present the different w _ sum() values sorted on descending order. We can see a correspondence between the obtained w _ sum() values and the sta-cisely the pdf used by TPC-H. 4.4. Time performance The queries used to compute the WR, FWR and FR aggregations first compute an auxiliary table, fw _ temp in Figs. 7 and 8.
In SQL, this table is computed with a RIGHT OUTER JOIN between the referenced table and the referencing table with several aggregations depending on the function answer set that is needed. For example, for the fw _ sum() extended aggregation it computes both count() and sum() for each group and the corresponding values for the invalid references. It also computes the aggregate values of the invalid references, taken such references as a single group. The tuples in this group can be tinct values that are in the foreign key.
 experimental results evaluate performance of extended aggregation against standard SQL joined aggregations with foreign formance is good, slightly slower than SQL.

As we can see, there are even instances where our proposed aggregations perform better than the standard SQL joined aggregations. This is because: (1) an early aggregation grouping is computed before executing the join operation (push  X  X  X roup by X  before join) and the remaining computations are done on the auxiliary table described earlier. For the sum() aggregations, performance depends on the size of the referenced table, as can be seen in Fig. 11 . For the WR aggregates, the additional computations are done over the auxiliary table. This overhead is linear in the size of the referenced table.
Since obtaining the auxiliary table prove to be the most demanding computation while computing our extended aggre-tations were measured with and without the early foreign key grouping optimization technique. As we can see, the size of the referenced table plays an important role while measuring time performance.

Summarizing, the performance of our extended aggregations computation depends on the size of the referencing table, the number of invalid values and the number of distinct values in the foreign key attribute. Using the early foreign key grouping optimization technique should be incorporated in an implementation of the extended aggregates. 5. Related work
Research on managing and querying incomplete data has received significant attention. In [9] the authors define a set of values is the true one. The authors develop algorithms for several aggregate functions that deliver sets of partial values.
In our work, we explore a similar idea, assuming that an incorrect reference represents imprecise data. The source of this when we know the tuple holding the incorrect reference comes from a specific source database. Getting consistent answer focus on time complexity and identify the set of inclusion dependencies under which getting a consistent answer set is decidable. In contrast, in our work we focus on aggregations, where referential integrity constraints are not satisfied. In [7] the authors identify two complementary frameworks to define views over integrated databases and they propose tech-authors study scalar aggregation queries in databases that violate a given set of functional dependencies. They study the putations can be done in polynomial time. The authors do not address the specific problem of computing aggregations in the presence of invalid foreign keys.

There are several approaches that allow to dynamically obtain consistent answers, that is, answers that do not violate integrity constraints, without modifying the database. In [17] based on query rewriting, the authors proposed a system named ConQuer that retrieves data that is consistent with respect to key constraints given by the user together with their queries. A similar strategy is used in [20], but for consistent answering of conjunctive queries under key and exclusion dependencies. This is done by rewriting the query in Datalog with negation. In [11] the authors present a framework for computing consistent query answers. They consider relational algebra queries without projection and denial constraints. is done to use in some way the inconsistent tuples to obtain an improved answer.

From a data modeling perspective, uncertainty and imprecision have also been handled with extended data models that capture more information about the expected behavior of databases. By defining an imprecise probability data model [27], the authors can handle imprecise and uncertain data. They develop a generalized aggregation operator capable of determin-but uncertain value should be stored. Also, associated to the values of the referenced primary key with respect to a given method, exploiting the frequency weighted RPP, to get such probabilities. Reference [4] presents an extended OLAP data model to represent both uncertain and imprecise data. The authors introduced aggregation queries and the requirements that guided their semantics in order to handle ambiguous data. Certain knowledge about the data is needed to determine ing extended databases and an extended database model where a probability may be associated to a set of facts where each one of them may represent a possible world. Finally, in [6] the authors extended their previous framework to remove the independence assumption over imprecise facts. We want to stress the fact that this work does not discuss evaluation issues when referential integrity errors occur. Such omission is important because in a database integration scenario, where accu-rate aggregations are required, tables are likely to have referential integrity errors.

Concerning the properties of the aggregate functions, in [23] the authors define an ascending aggregate function as a monotonic increasing function. Descending functions are defined accordingly. In contrast, in our work, we conceived a with an invalid foreign key always accounts for an amount of the aggregate total value. Concerning summarizability [25], esting scenario arises when for all tuples the foreign key holds invalid values. Since a frequency weighted RPP cannot be
A closely related research field studies probabilistic databases. Concerning query answering, in [16] the authors present a negation meaningful from the viewpoint of probability theory. Operations such as join must take into account the strategies take advantage of functional dependencies to improve our extended aggregates. To use our techniques adequately, the user has to take into consideration the assumptions behind our extended aggregates. On the other hand, these assumptions allow efficiency in the computation of our aggregates. In [13] the authors show that the data complexity of most SQL queries over represent.

Specifically, concerning aggregate operators in probabilistic databases in [34] the authors define aggregate operators over probabilistic DBMSs and present linear programming based semantics for computing these aggregate operators. Neverthe-run in polynomial time, but the result may be an approximation of the correct answer. An important difference with our work is that the aggregate operators in probabilistic databases are defined over probability intervals. The use of a RPP to
In contrast, in our work, we bound our aggregates considering the value of the answer set. Our lower or upper bounds refer to the lower or upper value an answer set can reach.

To close our discussion on related work, we summarize past research on improving database systems to handle referen-key grouping optimization technique mentioned in Section 3.4, used to obtain the auxiliary table to compute our extended aggregates. Since extended joins involving foreign keys are needed to compute our aggregates, we adapted the optimization techniques so it could be used in our computations. In [32] we generalize referential integrity metrics to distributed dat-erential integrity browser for distributed databases. In [18,29] we presented our initial studies of how to improve aggregations. 6. Conclusions
This work improved SQL aggregations to return enhanced answers sets in the presence of referential integrity errors. Ref-introduced the following families of extended aggregate functions: weighted referential (WR), frequency weighted referen-erential aggregations (FWR) whose RPP is based on a dynamically evaluated RPP computed from the frequency of tuples with a given reference in the referencing table. FR aggregations represent an extreme repair scenario where each aggregated gations are helpful when the user needs to include, for each group, all tuples with invalid references. We studied how to compute our extended aggregations considering independent and dependent columns. Our extended aggregations exhibit important properties, which are essential to consider them correct extensions of standard SQL aggregations. A WR aggrega-ues exist, then the extended aggregation result is equal to the result returned by it standard SQL counterpart. A WR sum aggregation is safe and summarizable consistent and when it behaves as an increasing or decreasing function, then it is ascending or descending, respectively. All extended aggregations, together with WR and FR maximum and minimum aggre-aggregates are ascending, whereas minimum aggregates are descending; both fulfill the safe property. On the other hand, FR are evaluated with plain SQL queries without modifying the DBMS code, which provides fast and wide applicability. Exper-iments with two real databases and a synthetic database evaluated usefulness, accuracy and performance.
There are several research issues for future work. Some of our ideas can be extended to more general SPJ queries, espe-incomplete. Due to the dynamic nature of extended aggregates, we need to improve them with online aggregation tech-niques for interactive use. We would like to propose a system that based on query rewriting, the user could retrieve, out Acknowledgments
The first author was sponsored by the UNAM information technology project  X  X  X acroproyecto de Tecnolog X as para la Uni-versidad de la Informaci X n y la Computaci X n X . The second author was partially supported by NSF Grants CCF 0937562 and IIS 0914861. We would like to thank the participants of the workshop ACM DOLAP 08 for their interesting comments and feed-back and all the anonymous reviewers for insightful comments which helped us to extend an earlier version of this paper.
References
