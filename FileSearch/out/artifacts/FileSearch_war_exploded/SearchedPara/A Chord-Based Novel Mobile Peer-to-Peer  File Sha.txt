 With the increasing technology of mobile devices and wireless networks, it gets more and more prevalent to share various resources by mobile devices such as a PDA or a mobile phone via different types of wireless access networks such as GPRS and IEEE 802.11 wireless LAN. On the other hand, compared to the constraints of traditional Client/Server (C/S) architecture, such as the systemic fragility, the bottleneck of sys-tem performance caused by high-load of the center server, the overmuch bandwidth consumption for broadcasting message and so on, Peer-to-Peer (P2P) network is more appropriate to employ in mobile computin g environment because it adopts distribut-ing services among equal nodes and improves the scalability and reliability of the whole system. However unfortunately, all existing P2P protocols have not specially considered the problems of wireless joining for mobile devices, for instance, limited CPU and memory of mobile devices, intermittent disconnection, limited bandwidth, high transmission delay etc. So how to obtain more efficient and effective mobile P2P techniques have recently become prominent discussion topics. 
For the new generation of scalable P2P systems that support distributed hash table (DHT) functionality, such as Tapestry [1], Pastry [2], Can [3] and Chord [4], files are for storing a certain range of keys. Each DHT system employs a different routing algorithm and has its own attractive respects and disadvantages at the same time. But we appreciate the simplicity, scalability and high-efficiency of Chord much more. Although some researchers have presented a mobile P2P protocol M-CAN [5] based on CAN, the theory of hierarchical structure and registering mechanism can not be applied to Chord directly. In this paper, we will propose a novel mobile P2P file shar-ing protocol, M-Chord, by ameliorating Chord protocol and adopting hierarchical structure and registering mechanism aim to accord with the characteristics of MP2P. As an extensible P2P routing algorithm, Chord adopts the simple logic structure, simple systematic interface and uses one-dimensional circular key space. Considering the constraints of mobile environment, we have modified and improved the base Chord protocol to obtain an efficient lookup protocol in MP2P, M-Chord. 2.1 Hierarchical St ructure of M-Chord M-Chord adopts hierarchical structure to organize mobile peers and it introduces the theory of register mechanism used in M-CAN to manage resources. There are two kinds of nodes in M-Chord, super nodes and ordinary nodes. Super nodes are the nodes having larger memory, better computing capability and more reliable connec-tion. Ordinary nodes are associated with super nodes by the register mechanism. Firstly, when a sharing file is published in M-Chord system, it will be assigned a file ID according to its content and title by hash function. Every super node manages a range of file IDs separately. The node which has sharing files will be registered on some super nodes according to the IDs of its shared files. The node which has no sharing files will be appointed a super node with minimum load. A super node will be registered on itself but it should also present the information of all its sharing files to its corresponding super nodes. Every ordinary node needs to record the IDs and ad-dresses of its super node(s). Every super node needs to maintain two tables: one is the routing finger table, the other is sharing files directory, which records the information about its registered files, such as the file IDs, the registered nodes X  addresses etc. For super nodes, we use Chord to manage them. 2.2 Routing in M-Chord wanted file firstly. Then the source node would submit a request containing this ID to the source super node which the source node is registered on [5]. After receiving the request, the source super node would lookup its finger table and go on with the rout-ing process until the destination super node whose ID space covers the ID of the wanted file receives the request. The routing process on the ring is the same as Chord. Then the destination super node would launch a lookup process locally. If the destina-tion super node can find the very file ID in its directory, which means the destination node which owns the wanted file is registered locally, it would return the destination node X  X  address to the source node. After the source node gets the destination node X  X  address, it would try to communicate with the destination node directly. A lookup is left or failed already), or if the sender receives no reply within some timeout window. 2.3 Node Join When a new node joins M-Chord, it must register itself on one or more appropriate corresponding super nodes should update their sharing file directory in time. 
In order not to make super nodes be the bottleneck of the whole system, we set a rule that any super node can manage n nodes at most. If a super node manages more kinds of split strategies, real split and virtual spilt. OS) will first choose a new super node (denoted as NS) from its registered nodes. NS is the node with the best connection among registered nodes. We assign an ID to the new super node by the following formula . 
Unlike Chord system, which generate the node identifiers by hashing its IP address to an m -bit space, M-Chord system will identify the ordinary node uniquely by its super nodes to ensure the uniqueness of the IDs of super nodes too. 
The registered nodes will be divided into two groups. One group continues to be managed by the original super node, and the other group is managed by the new super node. Then we should go on with four steps. (1)Generate the finger table of the new super node NS . (2)Update neighbor information of OS and NS . (3) Update sharing file directories of OS and NS . (4)Update finger tables of all super nodes except NS . 
Fig.1 and Fig.2 show an instance for super node splitting. Suppose one super node can manage four ordinary nodes at most. Fig.1 shows the state when peer E joined and regis-tered on super node 3. Super node 3 has exceeded the management maximum, so it will be split. Fig.2 shows the state after super node 3 splitting. A new super node, super node 1 is generated and the rest registered nodes are divided into two groups. Virtual split strategy. The rationale of virtual split strategy is very simple. Like real split, in virtual split process the original super node OS will first choose a new super node NS from its registered nodes, then divide the rest registered nodes into two groups. Each group has the same number of nodes and each super node manages one group. Unlike real split strategy, we assign the same ID as OS to NS . Then NS and OS will update their sharing file directories to keep consistent. Because there is not a new node ID generated on the M-Chord ring, it is unnecessary to update the finger tables of other super nodes. We only need to copy the finger table and neighbor information from OS to NS . But we should note that during the process of lookup operation, one position of routing path may relate to more than one super node. If we need to check the finger table of this position, we only need to check one node randomly. Moreover, the destination super node ID may also correspond to more than one super node. In lookup the destination node. 
In fact, the processes of node joining and super node splitting are also the system construction process. At first, there is only one node that covers the whole ID space in the number of registered nodes exceeds the limit n . Then the split process will be triggered. If sharing files are distributed equally on the whole ID space, real spilt will balance the load of M-Chord ring perfectly. But if there are too many sharing files within a certain continuous file ID range, real splitting may cause a  X  X ocal saturation X  nodes and the super node in this series can not split any more although there are many exceed a certain limit, it is forbidden when the file attempts to be published by later joined nodes. Compared with virtual split, real split will increase some expenses, such as the expense of updating all super nodes X  finger tables. However although virtual split is simple and highly efficient, it will cause the whole system load-unbalance because it allows too many nodes congregating on one position of M-Chord ring. So in practice, we can combine these two strategies to achieve the best performance. In our simulation experiment, we stipulate that to every node ID on the ring, there exist two virtual super nodes at most. If exceeds, real split will be performed. 2.4 Node Departure When an ordinary node leaves the system, we only need to modify the directory of its space of its successor to cover the missing space. If the successor super node manages more than n nodes, a split process would be triggered. To evaluate the performance of M-Chord system, we design our simulation based on the platform P2PSIM [6], a P2P simulation software developed by MIT. P2PSIM has provided the interface of Chord and we made some modification and extension on the basal Chord to implement M-Chord. We design two data sets with different n stand-ing for the maximum that one super node can manage ordinary nodes with the value 5 and 10 separately. For each data sets, we will compare the average data flow of Chord node, super node of M-Chord and ordinary node of M-Chord, measured by the unit bw (bytes/node/s), under different total node number (128, 256, 512, 1024, 2048). Our testing data accords with Kingdata [7]. Fig.3~4 show the result with different parame-ter value. Clearly we can find that the average data flow of super node in M-Chord is the largest, Chord node is secondary and the minimum is ordinary node of M-Chord. This demonstrates that super nodes have shielded most expenses and the total network bandwidth occupation of the whole M-Chord is reduced remarkably. In this paper, we have presented a mobile P2P protocol M-Chord. The particularities and constraints of MP2P make traditional P2P protocols lowly-efficient and unreli-able. Aim to accord with the characteristics of MP2P, we introduce hierarchical struc-ture and registering mechanism into Chord. From our experimental results, we know that compared to Chord, M-Chord greatly reduces the network bandwidth occupation. M-Chord system has high-efficiency and good robustness in mobile computing envi-ronment. In the future, we intend to improve the performance of M-Chord by decreas-ing super node X  X  load and the additional expenses of super node splitting and so on. This work is supported by Natural Science Foundation of China (No.60573077), and the Nature Science Foundation of Anhui Province (No.050420305). 
