 Inclusion dependencies form one of the most fundamental classes of integrity constraints. Their importance in classi-cal data management is reinforced by modern applications such as data cleaning and profiling, entity resolution and schema matching. Surprisingly, the implication problem of inclusion dependencies has not been investigated in the con-text of SQL, the de-facto industry standard. Codd X  X  rela-tional model of data represents the idealized special case of SQL in which all attributes are declared NOT NULL. Driven by the SQL standard recommendation, we investigate inclu-sion dependencies and NOT NULL constraints under sim-ple and partial semantics. Partial semantics is not natively supported by any SQL implementation but we show how classical results on the implication problem carry over into this context. Interestingly, simple semantics is natively sup-ported by every SQL implementation, but we show that the implication problem is not finitely axiomatizable in this con-text. Resolving this conundrum we establish an optimal so-lution by identifying the desirable class of not-null inclusion dependencies (NNINDs) that subsumes simple and partial semantics as special cases, and whose associated implication problem has the same computational properties as inclusion dependencies in the relational model. That is, NNIND im-plication is 2-ary axiomatizable and PSPACE-complete to decide. Our proof techniques bring also forward a chase pro-cedure for deciding NNIND implication, the NP-hard sub-class of typed acyclic NNINDs, and the tractable subclasses of NNINDs whose arity is bounded.
 F.4.3 [ Mathematical Logic and Formal Languages ]: Formal Languages X  Decision problems ; H.2.3 [ Database Management ]: Languages X  Data description languages Management, Theory c  X  Axiomatization; Computational complexity; Implication; In-clusion dependency; Null; Semantics; SQL Motivation. Domain, entity and referential integrity form the three most fundamental classes of integrity rules, al-ready proposed by Codd in his seminal paper [14]. Refer-ential integrity is enforced by foreign keys and, more gen-erally, inclusion dependencies (INDs). INDs empower us to specify which data must be duplicated in what relations, they can express referential integrity at the logical level and are an invaluable tool for classical data management tasks, including conceptual data modeling [12], schema de-sign [32], and query answering [25]. Informally, an IND R [ X ]  X  S [ Y ] with attribute sequences X =  X  A 1 , . . . , A and Y =  X  B 1 , . . . , B n  X  on relation schemata R and S , respec-tively, is satisfied by a relational database with R -relation r and S -relation s , if for every R -tuple t there is some S -tuple t such that for all i = 1 , . . . , n , the value t ( A i ) matches the value t  X  ( B i ). An example IND in the TPC-C schema 1 is which states that every order references some customer c id wh o placed the order in a district d id of a warehouse w id . As { c id, d id , w id } fo rms a key over Customer , this IND is even a foreign key. In the context of the relational model, INDs and their core computational problem of deciding im-plication have received dedicated interest, see for example [9, 16, 37]. Renewed interest in INDs comes from modern appli-cations such as data cleaning [3], data integration [7], data profiling [13, 40], schema matching [6], the semantic web [8, 38], and query answering [18]. Surprisingly, INDs have only received little attention in the context of the industry stan-dard SQL, which subsumes relations as the idealized special case where all attributes of the schema have been declared NOT NULL, that is, the null marker  X  must not feature in any of the table columns. In fact, the SQL standard proposes a simple and partial semantics for INDs. Both se-mantics apply the definition from the purely relational case above, but they differ in which tuples t they consider, and the definition of a match between t ( A i ) and t  X  ( B i IND under partial semantics R [ X ]  X  p S [ Y ], all tuples t are considered, and t ( A i ) matches t  X  ( B i ) if and only if t ( A or t ( A i ) = t  X  ( B i ) holds. For an IND under  X  X imple X  seman-tics R [ X ]  X  s S [ Y ] there is a distinction between R -tuples h ttp://www.tpc.org/tpcc/ t wh ich are total on X , that is, where for all i = 1 , . . . , n , the value t ( A i ) is different from  X  , and R -tuples t which are partial on X , that is, not total on X . Only X -total tu-t ( A i ) = t  X  ( B i ) holds. For an example, consider a database where the only tuple t of the database occurs in the Order relation and has projection  X  X  X  , d 1 , w 1  X  on  X  c id, d id, w id Th is database satisfies the simple IND
Order [c id , d id , w id ]  X  s Customer [c id , d id , w id ] , but violates the partial IND Order [c id , d id , w id ]  X  p Customer [c id , d id , w id ] . It is known that simple semantics for foreign keys is natively supported by all SQL implementations, but partial seman-tics is not natively supported by any SQL implementation [36]. On the one hand, it is not surprising that the implica-tion problems for INDs under simple and partial semantics are different from one another. For example, the partial IND above implies the partial IND but the simple IND above does not imply the simple IND the latter being confirmed by our single-tuple database from before. On the other hand, it is surprising that the impli-cation problem has only been investigated under partial se-mantics, and only under the assumption that the null marker can occur in every column [29]. In fact, it is a simple obser-vation that the implication problem for INDs under partial semantics and NOT NULL constraints enjoys the same ax-iomatization as INDs in relational databases. For simple semantics in isolation, the difference to partial semantics is already captured by the example above, that is, we estab-lish an axiomatization for simple INDs that results from the axiomatization for partial INDs by omitting the projection rule. However, things already change dramatically when we consider simple INDs in combination with NOT NULL con-straints only. In this case, the associated implication prob-lem is not k -ary axiomatizable for any finite k . This result is rather discouraging for database practice where simple semantics is natively supported, but not partial semantics. We emphasize the importance of the ability to reason about simple and partial INDs under NOT NULL constraints by the following example from database design.

Example 1. Consider the following relation schemata in which NOT NULL attributes A are denoted by A [ N N ] : Conference (CName[NN],...), Participant (PName[NN],...), Chair (CName[NN],PName[NN],...), Booking (CName,PName,Date[NN],Room[NN]), and
Talk (CName,PName,Date,...). The designer has identi-fied the following inclusion dependencies: Chair [CName]  X  Conference [CName], Chair [PName]  X  Participant [PName], Booking [CName, PName]  X  s Chair [CName, PName], Talk [CName, PName]  X  p Talk [CName, PName].
 If we were able to reason about simple and partial inclusion dependencies under NOT NULL constraints, this would al-low us to detect the following: i) the IND
Talk [CName, PName]  X  s Chair [CName, PName] is implied by the specified INDs, indicating that (if fully pop-ulated) presentations can only be given by conference chairs, which indicates clearly a design flaw, and ii) the IND
Talk [CName]  X  s Conference [CName] is not implied by the specified constraints, but should hold. The challenge. For these reasons, database research is expected to answer the important practical question how the semantics of INDs should be defined in the context of the industry standard SQL. Ideally, the semantics can be defined such that all of the following targets are met: i) simple and partial semantics are subsumed by the seman-tics as special cases, and ii) the semantics enjoys similar computational properties to that of its idealized special case in which all attributes are specified NOT NULL. More pre-cisely, condition ii) means that the associated implication problem is finitely axiomatizable and PSPACE-complete to decide. Ideally, there would be some expressive fragments whose implication is easier or even tractable to decide. Contributions. Strongly motivated by our observations about the simple and partial semantics of SQL inclusion dependencies, we address the challenge as follows. 1. We investigate the implication problem of INDs under both simple and partial semantics, each in combination with that of NOT NULL constraints, as suggested by the SQL standard. The idealized special case where all attributes are declared NOT NULL yields in each case the well-known semantics of INDs over pure relations. Note that finite and unrestricted implication problems coincide for the classes of constraints considered here. Therefore, we commonly speak of the implication problem. 2. In the presence of NOT NULL constraints, we show that partial semantics enjoys the same finite axiomatization as traditional INDs, but simple semantics is not k -ary axioma-tizable for any finite k . The latter result already holds when all relation schemata have four or less attributes. Establish-ing concise axiomatizations aids in human understanding of constraint interaction and forms the foundation for devel-oping (efficient) solutions to decision problems, which are fundamental to applications as critical as schema design, in-tegrity enforcement and query processing. 3. Based on the understanding we gain from showing that the implication of NOT NULL constraints and INDs under simple semantics is not finitely axiomatizable, we propose the class of not null inclusion dependencies (NNINDs). The class of NNINDs exhibits a natural semantics, and subsumes simple and partial semantics as special cases. We show that NNINDs enjoy a finite axiomatization and their implication problem is PSPACE-complete to decide, thereby recovering the positive results about INDs in relational databases. 4. Exploiting our completeness argument of our finite ax-iomatization, we establish a chase procedure for deciding the implication problem of NNINDs, subsuming the well-known chase for relational INDs as an idealized special case. 5. We show that the arity of NNINDs is a parameter that makes their implication problem fixed parameter-tractable. This also applies to the relational case. For tree-like NNINDs it follows that their implication problem is decidable in lin-ear time. In contrast to the relational case, we show that typed NNINDs are NP-hard and thus unlikely to be decid-able in PTIME, already in the acyclic case.
 Summary. Our results identify NNINDs as a class of refer-ential integrity rules that accommodates the requirements of th e de-facto industry standard and market leader SQL, pro-vides database practitioners with capabilities to express de-sirable properties of the underlying application domain, and retains the positive computational properties of relational INDs, which the database community has been exploring in classical and modern data management.
 Organization. We summarize related work in Section 2 to differentiate our contributions. In Section 3 we formally introduce simple and partial semantics for INDs. The ax-iomatization and non-axiomatizability, respectively, of par-tial and simple INDs and NOT NULL constraints is dis-cussed in Section 4. NNINDs are introduced in Section 5, and their implication problem is axiomatized and shown to be PSPACE-complete. The chase and important fragments of NNINDs are identified in Section 6. We conclude in Sec-tion 7 and discuss some possible directions of future work.
INDs form one of the most prolific concepts in database research and practice. We cannot list all the contributions made possible by them. Some insight into their diverse ap-plication areas was given in the introduction. Instead, we will focus on the main achievements regarding the implica-tion problem of INDs and to highlight the novelty of our contributions.

INDs generalize the notion of referential integrity, which was known to the broader database community during the 1970s [17]. A seminal paper on INDs is [9], in which infer-ence rules are presented, a Chase procedure is established, and the PSPACE-completeness of the implication problem is shown. Acyclic INDs were introduced in [39], and it was shown in [15] that their implication problem is NP-complete. Typed INDs, i.e. INDs of the form R [ X ]  X  S [ X ], are decid-able in PTIME [10].

The only paper addressing the implication of INDs in the presence of null markers is [29], but it only covers partial semantics and the other extreme case in which all columns can feature nulls. It is shown that the associated implication problem is the same as that for INDs over pure relations. In-dex design for efficiently enforcing and validating the partial semantics of INDs is discussed in [34, 36].

We conclude that previous research has not investigated the important combined class of inclusion dependencies and NOT NULL constraints, neither under simple nor partial semantics as recommended by the SQL standard. Only the idealized special cases where either all or no attributes are specified NOT NULL have been studied, while the latter has only been studied for partial semantics. Our result that the combined class of simple inclusion dependencies and NOT NULL constraints is not k -ary axiomatizable for any finite k is surprising and discouraging for current database prac-tice. It is surprising since: i) in both idealized special cases inclusion dependencies are axiomatizable, and ii) under the  X  X o information X  semantics of null values, NOT NULL con-straints do not increase the difficulty of axiomatizing im-plication for other classes of equality-generating or tuple-generating constraints that have been studied previously [2, 24]. In [30] it is shown that for functional dependencies un-der possible world semantics, no k -ary axiomatization exists. Possible world semantics captures only the null marker in-terpretation  X  X alue exists but unknown X  but not  X  X alue does not exist X . For these reasons we apply the popular and SQL-compliant  X  X o information X  interpretation [2, 20, 24, 33].
In this section we formalize the notions of partial and simple inclusion dependencies in the context of SQL.
Let A = { A 1 , A 2 , . . . } be a countably infinite set of sym-bols, called attributes or columns . A relation schema is a finite non-empty sequence R =  X  A 1 , . . . , A n  X  of distinct at-tributes in A . Database schemata are finite sets of relation schemata. Each attribute A of a relation schema R is as-sociated with a countably infinite domain dom ( A ) of the possible values that can occur in column A . To encompass partial information the domain of every attribute contains a distinguished null marker, denoted by  X  .

A tuple t over R =  X  A 1 , . . . , A n  X  ( R -tuple or simply tuple, if R is understood) is an element of the Cartesian product dom ( A 1 )  X   X   X   X   X  dom ( A n ). A relation r over R ( R -relation or simply relation, if R is understood) is a set of R -tuples. While SQL tables may contain duplicates, these have no impact on whether an IND holds, so it suffices to study re-lations. Sometimes, we also write instance when referring to a relation. We may also refer to a relation with null marker occurrences when we want to emphasize the fact that null markers can be present. When necessary we say that rela-tions are finite. A database assigns a relation to each of its relation schemata that are part of the underlying database note the projection of tuple t (relation r ) on the attributes A 1 , . . . , A i m . That is, r [ X ] = tuple t ( R -relation r ) we say that t ( r ) is X -total if for all A permits the specification of attributes as NOT NULL. We denote the NOT NULL attributes of a relation schema R by NN( R ), and the attributes on which a tuple t is different from  X  by NN( t ). For relations with null markers, different extensions of classical inclusion dependencies (INDs) exist. We study the two most prominent extensions, called partial and simple semantics, as defined by the SQL standard. Definition 1 (less informative tuple).
 Consider tuples t 1 , t 2 over R 1 =  X  A 1 , . . . , A m  X   X 
B 1 , . . . , B m  X  . We say that t 1 is less informative 2 (or t 2 is more informative than t 1 ), written as t 1  X  t If for every tuple in relation r 1 there exists some more in-formative tuple in relation r 2 , we write r 1  X  r 2 . Definition 2 (partial/simple IND).
 Let neither X nor Y contain duplicate attributes. We call an expression of the form R [ X ]  X  p S [ Y ] a partial inclusion dependency , and an expression of the form R [ X ]  X  s S [ Y ] a simple inclusion dependency .
 A partial IND R [ X ]  X  p S [ Y ] holds for relations r, s over R, S if r [ X ]  X  s [ Y ] .
 A simple IND R [ X ]  X  s S [ Y ] holds for relations r, s over R, S if for every X -total tuple t r  X  r there exists a tuple t  X  s such that t r [ X ] = t s [ Y ] .

While only partial INDs have been considered in the liter-ature [29], both partial and simple semantics are supported in the SQL standard (for foreign keys), and DBMSs support only simple semantics (and again only for foreign keys). This
Wh ile X  X ess or equally informative X  X ould be more accurate,  X  X ess informative X  is predominant in the literature. mo tivates a closer investigation of simple INDs, and in par-ticular their relationship to partial INDs.

The core computational problem in the theory of database constraints is the implication problem. The problem is the core problem in logic [4] and has several motivations in prac-tice, inclusive of i) the ability to compute small represen-tation systems (covers) for the sets of constraints that are actively enforced in a database system results in time sav-ings that increase proportionally with the volume of the data that is being updated, and ii) the ability to decide whether a constraint is implied by a given set empowers database systems to decide whether a constraint can be used for opti-mizing a query on the fly. For a given class C of constraints, the (finite) implication problem for C is to decide for a given finite set  X   X  {  X  } of constraints in C , whether  X  (finitely) implies  X  . That is, whether every (finite) database that sat-isfies all the constraints in  X  also satisfies  X  . Two sets of constraints are semantically equivalent if either of the sets implies all of the other set X  X  constraints.

When talking about inclusion dependencies, we will need to identify subsets of the left-hand-side that X  X atch X  X ubsets of the right-hand-side. The following concept helps in this. Definition 3 (induced mapping).
 Let X =  X  A 1 , . . . , A m  X  and Y =  X  B 1 , . . . , B m of equal length, with distinct A i . The mapping induced by X and Y , denoted ( X 7 X  Y ) , is When applied to a set of values U , we obtain the images of values in U  X  X :
We can now express an important relationship between partial and simple INDs precisely.

Theorem 1. Every partial IND is semantically equiva-lent to a set of simple INDs. Specifically: Proof. It is easy to see that R [ X ]  X  p S [ Y ] implies every R [ X  X  ]  X  s S [ Y  X  ] in the set.

To show the reverse, let r, s be instances of R, S so that ev-ery R [ X  X  ]  X  s S [ Y  X  ] holds on r, s , and t  X  r . From R [ X S [ Y  X  ] with X  X  = NN( t )  X  X , it follows that there exists t with t [ X  X  ] = t  X  [ Y  X  ]. But this means t [ X ]  X  t  X  such a t  X  exists for all t  X  r , R [ X ]  X  p S [ Y ] is satisfied.
Thi s means that any DBMS which supports simple INDs indirectly supports partial INDs as well. Note that the op-posite does not hold:
Example 2. Consider the schemata R =  X  A  X  , S =  X  B  X  with instances r = { X  X  X  X  X  and s =  X  . Then the simple IND R [ A ]  X  s S [ B ] holds on r, s , but the partial INDs R [] and R [ A ]  X  p S [ B ] are violated.

Nevertheless, partial INDs are valuable in that they allow constraints to be expressed efficiently, i.e., without resorting to an exponential number of equivalent simple INDs. As users of a database should be encouraged to specify con-straints that can enforce quality data, we will investigate both partial and simple INDs.
Concise axiomatizations aid in human understanding of constraint interaction and form the foundation for devel-oping (efficient) solutions to decision problems. These are fundamental to applications as critical as schema design, integrity enforcement and query processing. In particular, our understanding why simple INDs are not finitely axiom-atizable will lead to our proposal of NNINDs in Section 5. While the connection between simple and partial inclusion dependencies as described in Theorem 1 may appear obvi-ous in retrospect, we only discovered it while searching for an axiomatization of NNINDs.

In this section, we will discuss axiomatizations for impli-cation problems of partial and simple INDs, both in isolation and combination with NOT NULL constraints. The notions of inference rules, soundness, completeness and (finite) ax-iomatization are standard [1].

The following definition falls in the same category as  X  X n-duced mapping X . It formalizes what it means to rearrange the attributes on both sides of an IND  X  X orrespondingly X . Definition 4 (Index Permutation &amp; Projection). An index permutation &amp; projection function of order (k,m) , or ( k, m ) -IPP, with k  X  m , is an injective mapping  X  : { length m by mapping its indices: Where the order ( k, m ) of an IPP is clear from the context, we will not mention it explicitly.

Given two lists X, Y , the existence of an IPP function mapping X to Y is denoted by X  X  IPP Y .

An axiomatization for partial INDs has been established by Levene and Loizou in [29, Theorem 3.3]:
Theorem 2. The following axioms are sound and com-plete for partial inclusion dependencies.

W e remark that although NOT NULL constraints are not considered in [29], the proof of [29, Theorem 3.3] still works, without any modification, when we do consider them.
As long as we do not consider NOT NULL constraints, the axiomatization of simple INDs is even simpler:
Theorem 3. The following axioms are sound and com-plete for simple INDs without NOT NULL constraints.
Pr oof. As the proof for Lemma 1 in Section 5, except that  X  must be a permutation, and the null propagation rule is not needed.

Next we consider the real-world case in which simple INDs coexist with NOT NULL constraints. Surprisingly, while simple INDs studied in isolation possess an elegant axioma-tization (Theorem 3), it turns out that no (finite) axiomati-zation exists in the presence of NOT NULL constraints.
Theorem 4. For the implication of simple inclusion de-pendencies with NOT NULL constraints, no k -ary axioma-tization exists. In particular, no finite axiomatization exists. This holds even if all relation schemata are restricted to con-tain four (or fewer) attributes.

Proof. Consider the database schema R with relation schemata R 0 = . . . = R k +1 = ABCD , with NN( R 0 ) = BC , NN( R i&gt; 0 ) = B . Let  X  = { R i [ ABC ]  X  s R i +1 [ ACD ] 0 . . . k } . One can verify that  X  R 0 [ A ]  X  s R k +1 [ A ] =:  X  We will show that  X  0 cannot be derived using any k -ary set of (sound) derivation rules. To do so, we first need to establish which intermediate INDs could be derived. In the following we only consider non-trivial INDs with ordered LHS attributes.

Claim (*): If  X  R n [ X ]  X  s R m [ Y ] =:  X  /  X   X  with n then  X  = R n [ AC ]  X  s R n +1 [ AD ].
 To show this, consider an instance over R with where * donate unique values. One may verify that  X  holds for this instance. If D  X  X then  X  is violated by the first tuple in r n . If AC * X then  X  is violated by the second or third tuple in r n . This leaves X  X  { AC, ABC } . As value 1 only occurs in relations r n and r n +1 , and  X  is non-trivial, m = n + 1. Thus either  X  = R n [ AC ]  X  s R n +1 [ AD ] or  X  = R n [ ABC ]  X  s R n +1 [ ACD ]. As  X  /  X   X , only the first option remains, showing Claim (*).

Claim (**): If  X  R 0 [ X ]  X  s R m [ Y ] =:  X  /  X   X  then To show this, consider an instance over R with For  X  to hold we must have D /  X  X (first tuple) and A  X  X (second tuple). For m &gt; 2, neither 2 nor 1 occurs in r we must have X = Y = A . For m = 2 only 2 occurs in r 2 , so we must have X = Y = A or X = AB, Y = AD . For m = 1 the options X  X  { A, AB, AC, ABC } remain. X = ABC means Y = ACD so  X   X   X . The remaining cases are all covered in Claim (**).
 We can summarize claims (*) and (**) as follows: The set contains all (non-trivial) INDs implied by  X  over R .
Finally, let  X   X  X   X   X   X  be any set of at most k INDs implied by  X  such that  X  0 /  X   X   X  X  . Then for some m  X  1 , . . . , k +1,  X  contains no IND with R m on its RHS. Consider the instance It is easy to see that all INDs in  X   X  which might lie in  X  hold for this instance, while  X  0 is violated. This shows that  X  0 cannot be derived using a rule with k or less premises. Hence no k -ary axiomatization exists.

W e have seen that in the presence of NOT NULL con-straints, partial INDs enjoy a finite axiomatization (see the remark after Theorem 2), while simple INDs do not. As a final case, we consider partial and simple INDs together.
Corollary 1. For the implication of partial and simple inclusion dependencies with NOT NULL constraints, no k -ary axiomatization exists. This holds even if all relation schemas are restricted to contain four (or less) attributes. Proof. Assume that such an axiomatization A existed. Then we can construct an axiomatization A  X  by replacing every rule in A with multiple corresponding rules, in which each partial IND R [ X ]  X  p S [ Y ] is replaced by multiple sim-ple INDs, as per Theorem 1, for cardinalities of X up to four. But this would make A  X  a k -ary (for some finite k ) ax-iomatization for simple INDs over relation schemata of size four or less, contradicting Theorem 4.

As simple INDs and NOT NULL constraints are the cur-rent reality of database practice, database research must an-swer the important question whether there is some suitable extension of INDs from relational databases to SQL. In the next section we propose an affirmative answer and establish strong evidence for the suitability of our proposal.
In this section we propose not null inclusion dependen-cies (NNINDs) as a new class of inclusion dependencies in SQL. The definition of NNINDs is a natural consequence of the non-axiomatizability result for simple INDs and NOT NULL constraints. Both simple and partial INDs are special cases of NNINDs, and we establish a finite axiomatization and the PSPACE-completeness for their implication prob-lem. Therefore, we are able to provide an optimal response to the challenges brought forward by the results of the last section: NNINDs can address the recommendations of the industry standard SQL, and retain the computational prop-erties of its idealized special case of INDs over pure relations.
The central reason why simple inclusion dependencies can-not be axiomatized, is that information about attributes be-ing NOT NULL cannot be propagated. In the following we will define NNINDs, show how they express partial and sim-ple INDs as special cases and how they facilitate the propa-gation of NOT NULL attributes. Defi nition 5 (not null inclusion dependency).
 Let R be a relation schema, r a relation over R and U  X  R . We denote by r U the set of all U -total tuples in r : A not null inclusion dependency (NNIND) is an expression of the form where R, S are schemata, U, V sets and X, Y sequences of equal length with U, X  X  R and V, Y  X  S . We say that such an NNIND holds on relations r, s over R, S iff
Note that (as for partial/simple INDs) we do not consider repeated attributes in X or Y .
 Proposition 1.
 Partial and simple INDs are special cases of NNINDs:
Hence NNINDs generalize partial and simple INDs in a unified framework, which allows more fine-grained control over the handling of null values.

Example 3. We may now make the following observa-tions for Example 1: i) The attribute CName in Booking is NULL and the IND  X  1 :
Booking [CName, PName]  X  s Chair [CName, PName] is simple (and not partial) to allow bookings not related to conferences, ii) the IND  X  2 :
Booking [CName]  X  s Chair [CName] also holds, and iii)  X  1 and  X  2 can be replaced by the NNIND Booking CName [CName,PName]  X  Chair [CName,PName].
Our central result for this section will be a (finite) axiom-atization of NNINDs.

Theorem 5. The set of axioms from Table 1 is sound and complete for not null inclusion dependencies.
To establish some results needed to prove Theorem 5, we introduce the auxiliary notion of quasi-simple NNINDs. Quasi-simple NNINDs can be axiomatized without use of the Tertium Non Datur Rule, and completeness of this ax-iomatization is easier to establish.
 Definition 6 (quasi-simple NNIND).
 We call NNINDs of the form R UX [ X ]  X  S V [ Y ] quasi-simple . One may note that quasi-simple NNINDs include simple INDs. The relationship between partial and simple INDs extends to NNINDs and quasi-simple INDs (with the differ-ence that NNINDs include quasi-simple NNINDs, whereas partial INDs do not include simple ones):
Theorem 6. Every NNIND is semantically equivalent to a set of quasi-simple NNINDs. Specifically: R U [ X ]  X  S V [ Y ]  X  { R UX  X  [ X  X  ]  X  S V [ Y  X  ] |
Proof. It is easy to see that R U [ X ]  X  S V [ Y ] implies every R UX  X  [ X  X  ]  X  S V [ Y  X  ] in the set.

To show the reverse, let r, s be instances of R, S so that every R UX  X  [ X  X  ]  X  S V [ Y  X  ] holds on r, s , and t  X  From R UX  X  [ X  X  ]  X  S V [ Y  X  ] with X  X  = NN( t )  X  X , it follows that there exists a V -total t  X   X  s with t [ X  X  ] = t  X  this means t [ X ]  X  t  X  [ Y ], and since such a t  X  exists for all U -total t  X  r , R [ X ]  X  p S [ Y ] is satisfied.
W e note that carrying not-null sets on the RHS of NNINDs is not a necessary condition for extending partial and simple INDs. However, they are required in order to obtain a finite axiomatization.

Lemma 1. The first four rules of Theorem 5 are sound, and complete for the derivation of quasi-simple NNINDs. Proof. It is easy to verify that the axioms are sounds. Thus it remains to show that any implied quasi-simple NNIND can be derived.

Let R 1 , . . . , R n denote our relation schemata. Let  X  be a set of NNINDs, and  X  = R UX [ X ]  X  S V [ Y ] a quasi-simple NNIND with  X   X  . We shall create a database r 1 , . . . , r by adding tuples, one at a time, and show inductively that for each tuple there exists a matching NNIND which can be derived using our axioms.

Initialize the database with a single tuple t 0  X  r with Further tuples are added by repeated application of the fol-lowing ( chase -like) rule:
Rule (*): If  X  contains a dependency  X  i = R i U  X  [ X  X  ] R
V  X  [ Y  X  ] and for some U  X  -total tuple t  X  r i there does not exist a V  X  -total tuple t  X   X  r j with t [ X  X  ]  X  t  X  [ Y the following tuple t  X  to r j : where we use the abbreviation V  X  X  X  := V  X   X  NN( R j ) and the notation A i := ( Y  X  7 X  X  X  )( B i ) for readability. We say that t was added as a result of  X  i and t .

The number of different attribute values is finite, so re-peated application of Rule (*) terminates. The resulting database r 1 , . . . , r n satisfies  X , as otherwise Rule (*) could be applied again. As  X  implies  X  by assumption, r 1 , . . . , r also satisfies  X  . As t 0  X  r is UX -total, this means that there exists a V -total tuple t 1  X  s with t 0 [ X ] = t 1 [ Y ].
Claim (**): If r j contains a tuple t  X  with t 0 [ X ] = t then (with  X  denoting derivability)
If we prove Claim (**), then since s contains t 1 , it follows that  X   X  R UX [ X ]  X  S NN( t 1 ) [ Y ]. From this  X   X   X  follows with another application of reflexivity and transitivity (re-ducing NN( t 1 ) to V ).

We proceed by induction on the sequence of tuple addi-tions. For t  X  = t 0 Claim(**) follows by the reflexivity axiom. R U [ X ]  X  S V [ Y ] S V [ Y ]  X  T W [ Z ] R [ X ]  X  S V [ Y ] R U [ X ]  X  S W [ Y ] U [ X ]  X  S V [ Y ] S V [ B Y ] So let t  X  be added as a result of  X  i and t from Rule (*). By construction this means
From t 0 [ X ] = t  X  [ E ] it follows that E  X  Y  X  , as all values in t outside Y  X  are 0 or  X  . Hence there exists an IPP  X  such that E =  X Y  X  . We thus obtain t 0 [ X ] = t  X  [ E ] = t  X  t [  X X  X  ]. Thus by induction hypothesis, we have Furthermore, as Rule (*) was applicable, we must have U  X   X  NN( t ). We can thus derive
As E =  X Y  X  , this shows Claim (**) and completes the proof.
 W e are now ready to show Theorem 5.

Proof (Theorem 5). Soundness of Tertium Non Datur (D) may not be obvious, so we provide a brief proof. Con-sider any U -total tuple t over R . If t [ A ]  X  =  X  then ex-istence of a V -total t  X  with t [ AX ]  X  t  X  [ AX ] follows from R UA [ AX ]  X  S V [ BY ]. If t [ A ] =  X  then by R U [ X ]  X  there exists a V -total t  X  with t [ X ]  X  t  X  [ X ]. With t [ A ] = it follows that t [ AX ]  X  t  X  [ AX ].

To show completeness, denote again our relation schemata by R 1 , . . . , R n . Let  X  be a set of NNINDs, and some NNIND with  X   X  . We show that for all IPP  X  and W  X   X X we have We proceed by induction on the cardinality of W . Let | W | = 0. Then  X   X   X   X  , and our claim follows by Lemma 1.

So assume (1) holds for all | W |  X  n , and let | W  X  | = n + 1 and  X  some IPP. Pick A  X  W  X  so that W  X  = AW with |
W | = n , and let  X  A be derived from  X  by  X  X ropping X  A . By (1) we have  X   X   X  W and  X   X   X  W A . From we can derive, using Tertium Non Datur (plus Permutation to make A the first attribute): This shows (1) which includes  X   X   X  as a special case.
B y Lemma 1, the Tertium Non Datur rule is not needed to derive simple INDs. Nor is it required to derive partial INDs from a set of partial INDs, as per Theorem 2. While it is necessary for completeness using our definition of NNINDs, one may thus wonder whether it could be avoided by us-ing a more conservative generalisation of partial and simple INDs. Theorem 1 suggests that this is not possible, and the following example confirms this (it is of course possible to replace it by some other rule, though we suspect that any replacement rule would be very similar and not simpler).
Example 4. Let R = AB , S = CD be relation schemata without NOT NULL constraints, and a set containing only simple and partial INDs. Then  X  im-plies the partial IND R [ A ]  X  S [ C ] , as shown below: One may verify that R [ A ]  X  S [ C ] cannot be derived with-out use of rule (D). Note that R []  X  S [] is non-trivial, and expresses that S is non-empty if R is non-empty.

It has been shown in [9, Theorem 3.3] that implication of standard INDs is PSPACE-complete. As NNINDs ex-tend standard INDs, implication between NNINDs is at least PSPACE-hard. We will show that it lies in PSPACE next.
The following lemma shows PSPACE-computability for quasi-simple NNINDs. Le mma 2. Let  X  be a set of (general) NNINDs and  X  = R
UX [ X ]  X  S V [ Y ] a quasi-simple NNIND. Then  X   X  iff there exists a sequence where S i are relation schemata, and U i , X i  X  S i such that for each 0  X  i &lt; n the NNIND is either an instance of the reflexivity axiom (R) or can be derived (non-deterministically in linear space) from a single NNIND in  X  .

Proof. The  X  X f X  direction is obvious. For the  X  X nly if X  direction, consider the derivation trees constructed in the proof of Lemma 1. Our S U i i [ X i ] for i &gt; 1 are the RHSs of the NNINDs derived, and each  X  X onnecting X  NNIND is derived from the respective R i U  X  [ X  X  ]  X  R j V  X  [ Y in linear space.

By making use of the relationship between quasi-simple and general NNINDs established in Theorem 6, we can now derive PSPACE-completeness for the latter.

Theorem 7. The implication problem for not null inclu-sion dependencies is PSPACE-complete.

Proof. The PSPACE-hardness follows from PSPACE-hardness for relational INDs [9, Theorem 3.3].

It remains to show that it lies in PSPACE. From Lemma 2 it follows that there exists a non-deterministic algorithm that decides derivability of quasi-simple NNINDs in linear space. By Theorem 6 we can check implication of a non-quasi-simple NNIND by sequentially checking quasi-simple NNINDs, again in linear space (while the number of quasi-simple NNINDs is exponential, they can be enumerated in linear space). This provides us with a linear space non-deterministic algorithm. Existence of a deterministic poly-nomial space algorithm follows from Savitch X  X  Theorem.
In the case of pure relations, the PSPACE-completeness result for deciding the implication of INDs has motivated researchers to identify expressive fragments whose implica-tion problem is less complex to decide. In this section, we pursue the same goal for NNINDs.
To establish tractablility results for NNINDs with boun-ded arity, we shall require a chase procedure for NNINDs. In any case, the chase is of interest as an algorithm for de-ciding implication. As implication of an NNIND reduces to implication of a set of quasi-simple NNINDs (of bounded cardinality for NNINDs of bounded arity) by Theorem 6, we will only consider a chase for quasi-simple NNIDs. Algorithm 1 (Chase for quasi-simple NNINDs).
 Input: A database schema ( R ,  X ) with R = ( R 1 , . . . , R and a database r = ( r 1 , . . . , r k ) over R . Output: A modified database chase ( r ,  X ) .
 Method: Apply the following rule as long as possible:
NNIND: If I contains a dependency R i U [ X ]  X  R j V [ Y ] and where we use the abbreviation V  X  := V  X  NN( R j ) and the notation A i := ( Y 7 X  X )( B i ) for readability. Lemma 3. Let  X  be a set of NNINDs over R , and  X  := R
UX [ X ]  X  R j V [ Y ] be a quasi-simple NNIND over R . Let the initial database r consist of a single tuple t  X  r i with t [ X ] = (1 , . . . , | X | ) , t [ A ] = 0 for A  X  ( U  X  and t [ A ] =  X  elsewhere. Then  X   X  iff relation chase ( r ,  X ) contains a V -total tuple s  X  r j with t [ X ] = s [ Y ] . Proof. See proof of Lemma 1.

F or classical and partial inclusion dependencies, special-ized chase algorithms can be found in [1, 29].
As a negative result we consider typed NNINDs, which are commonly encountered in database practice. Interestingly, it turns out that the complexity of the implication problem of typed NNINDs differs from that of typed INDs. In [10] it was shown that for typed INDs, implication can be decided in polynomial time. For typed NNINDs the associated im-plication problem is NP-hard, already in the case where the given set of NNINDs is acyclic.
 Definition 7 (typed NNINDs).
 We call an NNIND R U [ X ]  X  S V [ Y ] typed if X = Y . Definition 8 (acyclic NNINDs).
 We call a set  X  of NNINDs acyclic if the directed graph G with the relation schemata as nodes and an edge R  X  S for every NNIND R U [ X ]  X  S U [ Y ]  X   X  is acyclic. Theorem 8. The implication problem for typed acyclic NNINDs is NP-hard.

Proof. We will reduce the conjunctive normal form sat-isfiability problem (CNF-SAT) to it.

Let V be a set of boolean variables and C = { c 1 , . . . , c set of clauses over V = { v 1 , . . . , v n } . We construct a schema R = { R 0 , . . . , R n +1 } and an acylic set  X  = {  X   X  n , . . . ,  X  of typed NNINDs over R as follows. W e claim that  X  implies  X  := R 0  X  [ X ]  X  R n +1  X  [ X ] iff satisfiable.
 Let S be any derivation sequence that derives  X  from  X . Such a sequence would necessarily consist of exactly one of  X  ,  X   X  i for i = 1 , . . . , n , followed by  X  0 . In order for  X  be applicable, a not-null condition must be derived for each A . For this to happen, at least one  X  i or  X   X  i must occur in S with A j  X  V i or A j  X  V  X  i , respectively.
 Consider now the truth assignment T S : which satisfies a clause c j  X  C iff  X  i  X  S for some v i  X  i  X  S for some  X  v i  X  c j . By definition of V i and V  X  have v i  X  c j iff A j  X  V i and  X  v i  X  c j iff A j  X  V  X 
Thus, if a derivation sequence S exists showing  X   X  , then T S is a truth assignment satisfying C . Conversely, every truth assignment T satisfying C gives rise to a derivation sequence S with T = T S showing  X   X  .

Whi le the proof of Theorem 8 uses NNINDs with non-empty sets V , this is not strictly necessary. We could easily avoid this by replacing each  X  i with a pair of partial INDs R  X  1 [ X ]  X  p S i [ X ] and S i [ X ]  X  p R i [ X ] by adding an addi-tional schema S i with NOT NULL constraints on V i , and respectively for  X   X  i . This gives us the following corollary.
Corollary 2. The implication problem for typed acyclic simple and partial inclusion dependencies with NOT NULL constraints is NP-hard to decide.

We remark that by Corollary 2 the increased difficulty in deciding implication of typed NNINDs cannot be blamed on our choice in defining NNINDs, but is intrinsic to simple and partial IND in combination with NOT NULL constraints.
In [9, 16] it was shown that implication for inclusion de-pendencies of bounded arity can be decided in polynomial time. As we will show next, this result not only extends to NNINDs, but can actually be strengthened to show fixed-parameter tractability.
 Definition 9 (arity).
 The arity of a NNIND R U [ X ]  X  S V [ Y ] is the length of X (equivalently Y ). When we talk of implication for bounded arity, we mean implication over subclasses of NNINDs in-duced by a fixed upper bound on their arity.

Theorem 9. The implication problem for NNINDs is fixed parameter-tractable in their arity.

Proof. Let m denote a bound for the arity of all NNINDs in  X   X  {  X  } . Consider Algorithm 1 for quasi-simple NNINDs, i.e. where  X  is quasi-simple. The number of distinct at-tribute values that may occur in tuples produced during our chase is bounded by m + 2.
 For each tuple generated, there exists some NNIND  X   X  = R
U  X  [ X  X  ]  X  R j V  X  [ Y  X  ]  X   X  that generates it. Consider now the tuples generated by  X   X  . By construction they only differ on Y  X  , and thus their number is bounded by ( m + 2) | Y ( m +2) m . Hence the total number of tuples generated during our chase is bounded by |  X  |  X  ( m + 2) m . Since the number of chase steps (successful or not) is limited by |  X  | times number of tuples occurring in our chase tables, and each chase step can be implemented to run in polynomial time, this means that running time for our chase is bounded by P (input size)  X  ( m + 2) m for some polynomial P . Finally, we can decide implication of a non-quasi-simple NNIND of arity  X  m by checking implication of at most 2 m quasi-simple NNINDs by Theorem 6. This gives us an overall running time bounded by which shows fixed parameter-tractability in m .

An other tractable class of INDs are tree-like INDs, mean-ing that G in Definition 8 is a tree (or forest) without dupli-cate edges. Implication for tree-like INDs can be decided in linear time [31], and the proof generalizes to our setting.
Theorem 10. For tree-like NNINDs the implication prob-lem can be decided in linear time.
SQL will continue to dominate database practice in the foreseeable future. Domain, entity and referential integrity are therefore fundamental rules that real-world data is gov-erned by. We have studied INDs under the SQL require-ments of nulls, NOT NULL constraints, simple and par-tial semantics. We showed the surprising impossibility re-sult that simple INDs and NOT NULL together cannot be finitely axiomatized. This motivated the challenging ques-tion whether SQL INDs can be defined such that simple and partial semantics are both covered, and their good compu-tational properties from pure relations are retained. We es-tablished that NNINDs provide an affirmative answer: their implication is finitely axiomatizable, PSPACE-complete to decide, and solvable by a chase procedure. We showed the implication of typed acyclic NNINDs to be NP-hard, the im-plication of general NNINDs to be fixed-parameter tractable in their arity, and the implication of tree-like NNINDs to be decidable in linear time.

The open problems already mentioned and several oth-ers warrant future research. Mitchell established an ele-gant non-k -ary axiomatization for the finite implication of FDs and INDs [37]. Finite and unrestricted implication of FDs and unary INDs and FDs are different but both ax-iomatizable and PTIME decidable [16]. A seminal paper in query optimization is [25], which exploited a chase for FDs and INDs to characterize containment between conjunctive queries. A seminal paper in schema design is [32] which provides justifications for the IND normal form over rela-tional databases. These results would all be interesting to investigate in the real-world context of SQL.

A fundamental result for relational databases concerns the undecidability of (finite) implication for the combined class of FDs and INDs [11, 37]. Based on this infeasibility, several sufficient conditions on the structure of the given constraint sets have been identified that guarantee no interaction be-tween these fragments of the constraint classes [35]. It is desirable to establish similar conditions in SQL, as these would simplify computation. The combination of NNINDs with different notions of keys [5, 19, 21, 22, 23, 26, 27, 28] appears to be a sensible approach to address entity and ref-erential integrity together. This research is supported by the Marsden Fund Council from New Zealand Government funding, and by the Natural Science Foundation of China (Grant No. 61472263). [1] S. Abiteboul, R. Hull, and V. Vianu. Foundations of [2] P. Atzeni and N. M. Morfuni. Functional dependencies [3] J. Bauckmann, Z. Abedjan, U. Leser, H. M  X  uller, and [4] E. B  X  orger, E. Gr  X  adel, and Y. Gurevich. The Classical [5] P. Brown and S. Link. Probabilistic keys for data [6] L. Cabibbo. On keys, foreign keys and nullable [7] A. Cal` X , D. Calvanese, and M. Lenzerini. Data [8] D. Calvanese, W. Fischl, R. Pichler, E. Sallinger, and [9] M. Casanova, R. Fagin, and C. Papadimitriou.
 [10] M. Casanova and V. Vidal. Towards a sound view [11] A. Chandra and M. Vardi. The implication problem [12] P. Chen. The entity-relationship model -toward a [13] Z. Chen, V. Narasayya, and S. Chaudhuri. Fast [14] E. Codd. A relational model of data for large shared [15] S. Cosmadakis and P. Kanellakis. Functional and [16] S. Cosmadakis, P. Kanellakis, and M. Vardi.
 [17] C. J. Date. Referential integrity. In VLDB , pages [18] J. Gryz. Query folding with inclusion dependencies. In [19] M. Hannula, J. Kontinen, and S. Link. On [20] S. Hartmann, M. Kirchberg, and S. Link. Design by [21] S. Hartmann, U. Leck, and S. Link. On Codd families [22] S. Hartmann and S. Link. Efficient reasoning about a [23] S. Hartmann and S. Link. Expressive, yet tractable [24] S. Hartmann and S. Link. The implication problem of [25] D. Johnson and A. Klug. Testing containment of [26] H. K  X  ohler, U. Leck, S. Link, and H. Prade. Logical [27] H. K  X  ohler, S. Link, and X. Zhou. Possible and certain [28] V. Le, S. Link, and M. Memari. Schema-and [29] M. Levene and G. Loizou. Null inclusion dependencies [30] M. Levene and G. Loizou. Axiomatisation of [31] M. Levene and G. Loizou. Guaranteeing no interaction [32] M. Levene and M. Vincent. Justification for inclusion [33] E. Lien. On the equivalence of database models. J. [34] S. Link and M. Memari. Static analysis of partial [35] H. Mannila and K. R  X  aih  X  a. The Design of Relational [36] M. Memari and S. Link. Index design for enforcing [37] J. Mitchell. The implication problem for functional [38] R. Pichler, A. Polleres, S. Skritek, and S. Woltran. [39] E. Sciore. Inclusion dependencies and the universal [40] M. Zhang, M. Hadjieleftheriou, B. Ooi, C. Procopiuc,
