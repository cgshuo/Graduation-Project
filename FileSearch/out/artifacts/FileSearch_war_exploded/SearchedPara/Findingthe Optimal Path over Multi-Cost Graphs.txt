 Shortest path query is an important problem in graphs and has been well-studied. However, most approaches for shortest path query are based on single-cost (weight) graphs. In this paper, we intro-duce the definition of multi-cost graph and study a novel query: the optimal path query over multi-cost graphs. We propose a best-first branch and bound search algorithm with two optimizing strategies. Furthermore, we propose a novel index named k -cluster index to make our method more space and time efficient for large graphs. We discuss how to construct and utilize k -cluster index. We con-firm the effectiveness and efficiency of our algorithms using real-life datasets in experiments.
 H.3.3 [ Information Storage and Retrieval ]: Information Search and Retrieval Algorithms Multi-cost graphs, optimal path, non-linear functions
Graphs have been widely used to model complex relationships among various entities in real applications. Shortest path query in graphs is an important problem and has been well-studied. How-ever, most of existing works assume that there is a single cost type on edges. In fact, the edges may have multiple cost types to de-scribe the relationships among various entities. In a transportation network, there are several cost types to measure an edge(representing a highway) between two cities, such as length, traveling time, toll fee, etc. We call a graph multi-cost graph if there are several cost types on edges. In real applications, these cost types coexist and may collectively affect the decisions of users. It is unadvisable to choose a shortest path by a single cost type. For example, in trans-portation network, the summed toll fee of the path with the shortest length may be too expensive to accept. In this case, users prefer to choose a path which is slightly longer than the shortest path but its toll fee is very low. Therefore, it is important to find an optimal path under global consideration according to user X  X  preference.
We utilize a score function f (  X  ) to measure the importance of paths in multi-cost graphs. f (  X  ) calculates an overall score for a path according to all cost types of this path. Given a score function f (  X  ) , starting vertex s and ending vertex t , in this paper, our objec-tive is to find a path from s to t that has the minimum score. This path is said to be the optimal path from s to t under function f (  X  ) . To the best of our knowledge, our paper is the first research work about the optimal path query over multi-cost graphs.

All existing works for shortest path problem utilize the follow-ing property: any sub-path of a shortest path is also a shortest path. Unfortunately, this property does not hold in multi-cost graphs if score function is non-linear(detailed in section 2). Thus, all exist-ing methods cannot solve the optimal path problem over multi-cost graphs. As analysis in the works about transportation problem[4], the non-linear score functions are existent and reasonable.
The main contributions are summarized below. Given a multi-cost graph G , score function f (  X  ) , starting vertex s and ending vertex t . First, we define a novel optimal path query over multi-cost graphs. Second, we propose a best-first branch and bound search algorithm with two optimizing strategies. Third, we propose a novel index for multi-cost graphs, named k -cluster index, which makes our method more efficient for large graphs. k -cluster index is with lower space cost than naive index. Fourth, we introduce how to answer the optimal path query over multi-cost graphs by k -cluster index. Finally, we confirm the effectiveness and efficiency of our algorithms using real-life datasets.
A multi-cost graph is a simple directed graph, denoted as G = ( V, E ) , where V is the set of vertices and E is the set of edges. Each edge e  X  E is represented by e = ( u, v ) , u, v  X  V , e is called u  X  X  outgoing edge or v  X  X  incoming edge and v ( or u ) is called u ( or v )  X  X  outgoing(or incoming) neighbor. Each edge e  X  E is as-signed a cost vector cost ( e ) , cost ( e ) = ( c 1 , c 2 c is the i -th cost value of edge e according to the d cost types in-volved in decision making. For example, in transportation network, an edge e between city A and B represents a highway from A to B . would be the Euclidean distance between A and B , c 2 would be the driving time from A to B , and c 3 could be the toll fee, etc. In this paper, we assume c i  X  0 . This assumption is reasonable, because the cost cannot be less than zero in real applications. Our work can be easily extended to handle undirected graphs, an undirected edge e = ( u, v ) is equivalent to two directed edges e 1 and e 2 = ( v, u ) , where cost ( e 1 ) = cost ( e 2 ) = cost ( e ) . For simplicity, we only discuss directed graphs in following.
A path p is a sequence of vertices ( v 0 , v 1 ,  X  X  X  , v l V (0  X  i  X  l ) and e i = ( v i  X  1 , v i )  X  E (0 &lt; i  X  l ) . p is simple if and only if there is no repeated vertex in p , i.e., v i 6 = j, 0  X  i, j  X  l . The cost vector cost ( p ) of path p is the vector sum of its constituent edges. Let { e 1 , e 2 ,  X  X  X  , e l stituent edges of path p and let cost ( p ) = ( c 1 ( p ) , c be the cost vector of path p . Then, cost ( p ) = Here, c i ( p ) = c ( e j ) are the i -th cost value of cost ( p ) and cost ( e
Score function f (  X  ) is an aggregate function specified by user in multi-dimensional space. For each data object, f (  X  ) aggregates its values on all dimensions to one overall score. Generally, the best object is the object with the minimum score. In this paper, f (  X  ) computes score of a path p according to cost ( p ) , i.e., f ( p ) = simplicity, we use f ( p ) in following paper. We assume function f (  X  ) is monotone increasing, i.e., for any two different paths p and p , if (  X  i, c i ( p )  X  c i ( p 0 ))  X  (  X  i, c i ( p ) &lt; c f ( p 0 ) . The restriction of monotonicity is a common property and it is reasonable[2]. Its intuitive meaning is that: if all costs of a path p are less than that of another path p 0 , then the overall score of p is at least good as p 0 . The definition of the optimal path over multi-cost graphs is given as below: Definition 2.1: ( Optimal Path ) Given a multi-cost graph G ( V, E ) and score function f (  X  ) , s, t  X  V are any two different vertices in G . Let P s,t represent the set of all simple paths from s to t in in G that has the minimum score among all paths in P s,t , that is, f ( sp ( s, t ))  X  f ( p ) for any p  X  P s,t . 2
The problem of the optimal path query over multi-cost graphs is given as follows: Problem Statement : Given a multi-cost graph G ( V, E ) , score function f (  X  ) , starting vertex s and ending vertex t . Find the opti-mal path sp ( s, t ) from s to t such that f ( sp ( s, t )) is minimum.
If score function f (  X  ) is linear, i.e., for any two edges e e ( i 6 = j ), f ( e i + e j ) = f ( e i ) + f ( e j ) , We only need to con-sider f ( e ) as edge e  X  X  single-one weight. We apply existing al-gorithm, e.g., Dijkstra algorithm, to compute the shortest path ac-cording to weight f ( e ) . This shortest path is exactly the optimal path for our problem. Otherwise, there is another path p 0 f ( p 0 ) = f ( P i =1 f ( e i ) , which is in contradiction to the correctness of the shortest path (Dijkstra) algorithm.

If score function f (  X  ) is non-linear, i.e., f ( e i + e f ( e j ) , then existing methods cannot solve our problem. The frame-works of these methods are that: build an index to maintain the shortest paths between any two vertices in index. Given a query, algorithms first retrieve the shortest paths to be visited inside in-dex and then concatenate them by the shortest paths outside index. All these methods utilize the following property: any sub-path of a shortest path is also a shortest path. Hence, they only need to maintain the shortest paths for any two vertices in index. However, the optimal sub-path property does not hold in multi-cost graphs if score function is non-linear. As shown in Fig. 1, the score function is f ( x, y ) = x 2 + y 2 . We find that the optimal path from s to r is s  X  a  X  c  X  r . Here, the sub-path p : s  X  a  X  c is not the optimal path from s to c , because its score is f (1 , 6) = 37 , which is larger than the score f (4 , 4) = 32 of path p 0 : s  X  b  X  c . It states the sub-path of the optimal path may not be an optimal path.
In this section, we propose a best-first branch and bound search algorithm with two optimizing strategies.
Given a multi-cost graph G ( V, E ) , score function f (  X  ) , starting vertex s and ending vertex t , all possible paths started from s in G can be organized in a search tree. Here, the root node represents starting vertex set { s } , and any non-root node represents a path started from s . Let C and C 0 be two nodes in the search tree and they represent two different paths started from s in G . The node C is the parent of another node C 0 if they satisfy the following two conditions: (i) C  X  C 0 and | C 0 | = | C | + 1 ; (ii) the only vertex v  X  C 0 \ C satisfies v /  X  C and v  X  N + ( u ) , where u is the ending vertex of C and N + ( u ) is the outgoing neighbor set of u . C  X  C 0 implies C is a path prefix of C 0 , | C | represents the number of vertices in C . v /  X  C guarantees there does not exist circle if append v to C , i.e., C 0 is a simple path. With the search tree, the problem to find the optimal path from s to t in G becomes a tree searching problem. That is to find a node C , where the ending vertex of C is t , such that in the search tree C has the minimum score f ( C ) no larger than any other C 0 whose ending vertex is t . In the following, we use C to refer a node in the search tree as well as the path it representing.

We use a min-heap H to maintain the nodes to be visited in the search tree. The nodes in H are sorted by their scores. We initial-ize H only with the starting vertex set { s } . Our algorithm performs best-first branch and bound search over the search tree by repeat-edly popping up the top element C , which has the minimum score f ( C ) in H . Below, let  X  indicate the current minimum f ( C ) of C whose ending vertex is t . Initially,  X  =  X  .

For a node C , if f ( C ) &gt;  X  , then there does not exist the optimal path from s to t in the subtree rooted at C . Thus, we can prune this branch safely. Lemma 3.1 guarantees the correctness of this pruning rule.
 Lemma 3.1: For any two nodes C and C 0 in the search tree, if C is an ancestor of C 0 , then f ( C 0 ) &gt; f ( C ) . 2
The correctness of Lemma 3.1 can be proved by the monotonic-ity of function f (  X  ) .

When a node C pops up from H , algorithm will expand C by processing the children of C in search tree. Assume that the ending vertex of C is u . For any v  X  N + ( u ) , we first check whether there exists a circle if append v to C , i.e., v  X  C or not. If v /  X  C , we calculate the score f ( C 0 ) for node C 0 = C  X  X  v } , C of C and its ending vertex is v . In case of v 6 = t , if f ( C by Lemma 3.1, we can safely prune the subtree rooted at C f ( C 0 ) &lt;  X  , we insert C 0 into H . In case of v = t , C from s to t . If f ( C 0 ) &lt;  X  , we use C 0 instead of the current optimal path from s to t and update  X  by f ( C 0 ) . C 0 will not be inserted into H when its ending vertex is t .

The algorithm terminates when H =  X  , or the score f ( C )  X   X  for the top element C in H . When the algorithm terminates, the Algorithm 1 F IND -sp ( s, t ) -best-first -SEARCH ( G, s, t, f (  X  ) ) 2: while H6 =  X  do 3: let C be the path by popping up the top element from H and 4: if f ( C )  X   X  then 5: break ; 8: if v = t then 11: else 17: else 19: for each p  X  SKYP ( s, v ) do 25: return sp ( s, t ) ,  X  ; current optimal path corresponding to  X  is the answer. The best-first branch-and-bound algorithm is shown in Algorithm 1.
To further enhance the power of pruning, we develop two prun-ing rules. We first introduce the definition of skyline path before giving these rules.
 Definition 3.1: ( Path Dominate ) Given a multi-cost graph G ( V, E ) , p and p 0 are two different paths in G . We say p dominates p noted as p  X  p 0 , iff for  X  i (1  X  i  X  d ) , c i ( p )  X  c  X  i (1  X  i  X  d ) , c i ( p ) &lt; c i ( p 0 ) . Here, c i cost value of cost ( p ) and cost ( p 0 ) . 2 Definition 3.2: ( Skyline Path ) Given a multi-cost graph G ( V, E ) and two vertices u, v  X  V . Let P u,v denote the set of all paths from u to v in G . A path p is said to be a skyline path from u to v if and only if p cannot be dominated by any other path p 0 i.e., @ p 0  X  P u,v , p 0  X  p . 2 Skyline path based pruning : For any vertex u  X  G , we use a set SKYP ( s, u ) to maintain the skyline paths from s to u that have been searched up to now. Initially, SKYP ( s, u ) =  X  . Given a node C , assume that the ending vertex of C is u . If  X  p  X  SKYP ( s, u ) , p  X  C , then the subtree rooted at C can be pruned safely, otherwise path C should be inserted into SKYP ( s, u ) . In addition, if  X  p  X  SKYP ( s, u ) , C  X  p , then p should be removed from SKYP ( s, u ) . Lemma 3.2 guarantees the correctness of this pruning rule. Lemma 3.2: Let C and C 0 are two different nodes in the search tree and both of their ending vertices are u . If C 0  X  C , then the optimal path from s to t cannot be in the subtree rooted at C . 2
The correctness of Lemma 3.2 can be proved by the monotonic-ity of function f (  X  ) .
 Next, we introduce the definition of the L ower B ound of O ptimal P ath ( LBOP ) and then give the second pruning rule.
 Definition 3.3: ( Lower Bound of Optimal Path( LBOP ) ) Given a multi-cost graph G ( V, E ) . Each edge e  X  E has a cost vector cost ( e ) , cost ( e ) = ( c 1 ( e ) ,  X  X  X  , c d ( e )) . G graphs, G i = ( V, E ) . The weight of any edge e in G i is c said to be a weighted graph based on i -th cost value in G . For any set of single-one cost shortest paths from u to v , where P is the weighted shortest path from u to v in G i . The cost of P the lower bound of optimal path ( LBOP ) from u to v in G . 2 LBOP based pruning: We pre-compute  X  u,v for any two vertices u and v in G . Given a node C , let the ending vertex of C be u . We estimate a lower bound LB ( C ) according to  X  u,t , LB ( C ) = f ( C +  X  u,t ) . LB ( C ) indicates the lower bound of the score of any path whose ending vertex is t in the subtree rooted at C . If LB ( C )  X   X  , then the subtree rooted at C can be pruned safely. Lemma 3.3 guarantees the correctness of this pruning strategy. Lemma 3.3: Let C be a node in search tree. LB ( C )  X   X  . If a path ended at t in the subtree rooted at C . then f ( e
The correctness of Lemma 3.3 can be proved by the monotonic-ity of function f (  X  ) . We note that the branch and bound algorithm need to maintain  X  u,v for every two vertices u and v in G , which is too expensive for large graphs. In addition, the time cost is also expensive for large graphs. Next, we propose a new index named k -cluster index, which has small space cost and perform well on large graphs. We introduce what is k -cluster index and how to construct it. Definition 4.1: ( K-Cluster) Given a graph G ( V, E ) , k -cluster is a partition { V 1 ,  X  X  X  , V k } of V , such that: (1) for  X  V V  X  V j =  X  ; (2) V = cluster in G . A vertex v is said to be an entry of cluster V v  X  V i ; and (2)  X  u , u /  X  V i  X  u  X  N  X  ( v ) . Similarly, A vertex v is said to be an exit of cluster V i , if (1) v  X  V u /  X  V i  X  u  X  N + ( v ) . N  X  ( v ) and N + ( v ) are v  X  X  incoming and outgoing neighbor set, respectively. Entries and exits are also said to be the border vertices . 2
We use V.entry and V.exit to denote the entry set and exit set of G , respectively. Obviously, V.entry = V.exit = set and exit set of cluster V i .
 A k -cluster index includes two parts: inter-index and inner-index .
Inter-index: Inter-index maintains the LBOP for every pair of border vertex and entry in G . It is essentially a matrix whose size is ( | V.exit | + | V.entry | )  X | V.entry | . Each row represents a border vertex (entry or exit) u in G and each column represents an entry v in G . Each cell A u,v indicates the LBOP  X  u,v from u to v .
Inner-index: Inner-index contains k sub-indices, where each sub-index I x corresponds to a cluster V x . Each sub-index I tains two components: (i) Skyline-Path-Inner-Index I S LBOP -Inner-Index I L x .

Skyline-Path-Inner-Index I S x in cluster V x is a collection of the sets of skyline paths for every pair of entry and exit in V I x = { SKYP x ( u, v ) | u  X  V x .entry, v  X  V x .exit } . SKYP is the set of skyline paths from u to v in G x , where G induced subgraph of V x on G . Note that the paths in SKYP only pass through the vertices in V x .
LBOP -Inner -Index I L x in cluster V x is a | V x | X | V x maintain LBOP s for every two vertices u, v  X  V x . Similar to inter-index, each cell A u,v indicates the LBOP  X  u,v from u to v .
By inter-index and LBOP -inner-index, we can compute  X  s,t any two vertices s and t in G . Given two vertices s and t , we first identify the clusters which contain s and t respectively. Let V s and V t denote the clusters that contain s and t respectively. If V = V t , we can directly retrieve  X  s,t from LBOP -inner-index I If V s 6 = V t , we give Lemma 4.1 to help us to compute  X  Lemma 4.1: Given a multi-cost graph G and two vertices s and t , let V s and V t be the clusters that contain s and t respectively, V V .  X  s,t is the LBOP from s to t ,  X  s,t = (  X  ( s,t );1 ,  X  X  X  ,  X  For any entry v  X  V t .entry ,  X  s,v and  X  v,t are LBOP from s to v and LBOP from v to t respectively.  X  s,v = (  X  ( s,v );1 ,  X  X  X  ,  X  Proof Sketch: By the definition of LBOP ,  X  ( s,t ); i is the cost of single-one cost shortest path P ( s,t ); i in G i . Obviously, P passes through a vertex in V t .entry . Without loss of generality, assume this vertex is v . P ( s,t ); i can be divided into two segments: (i) sub-path from s to v ; and (ii) sub-path from v to t .  X  and  X  ( v,t ); i are the costs of shortest paths from s to v and from v other hand,  X  ( s,t ); i is the minimum cost among all paths from s  X  ( s,v ); i +  X  ( v,t ); i . Next, we prove v is the vertex that minimizes  X  one cost shortest path in G i . Therefore, Lemma 4.1 is proved. 2
We compute  X  s,t in two cases: (i) s  X  V s .entry  X  V s .exit ; and (ii) s /  X  V s .entry  X  V s .exit . For case (i), we first compute  X   X  retrieved from inter-index and LBOP -inner-index I L t respectively. which is the i -th cost value of  X  s,t . For case (ii),  X  retrieved from inter-index directly. We compute  X  ( s,v ); i We first retrieve  X  ( s,u ); i from LBOP -inner-index I L from inter-index for every u  X  V s .exit . By Lemma 4.1, we select  X 
Inter-index and LBOP -inner-index I L x in each cluster V constructed easily. For LBOP -inner-index I L x , we adopt existing shortest path algorithm to compute  X  u,v for any two vertex u, v  X  V . For inter-index, we compute  X  u,v for any u  X  V.entry  X  V.exit and v  X  V.entry . Note that: if entry u and exit v are in the same cluster V x , we do not need to maintain  X  u,v in inter-index because it has been maintained in LBOP -inner-index I L x
To construct I S x , we need to compute SKYP x ( u, v ) for every pair of entry u and exit v in each cluster V x . We propose a breadth-first branch and bound search algorithm, which is in a similar man-ner as Algorithm 1. We build a search tree rooted at { u } for G like that in Algorithm 1 and use a queue Q to maintain the nodes to be searched, where G x is the induced subgraph of V x on G . When a node C pops up from queue, we expand C by processing the chil-dren of C . For a child C 0 of C , assume the ending vertex of C w . In case of w 6 = v , if  X  p  X  SKYP x ( u, v ) , p  X  C prune the subtree rooted at C 0 . Otherwise, C 0 is inserted into Q . In case of w = v , if @ p  X  SKYP x ( u, v ) , p  X  C 0 , then we insert p into SKYP x ( u, v ) . On the other hand, if  X  p  X  SKYP C 0  X  p , we remove p from SKYP x ( u, v ) .
 We also propose two pruning rules to improve efficiency.

Skyline path based pruning : We maintain a set SKYP x ( u, w ) for each w  X  V x in the searching process. For a node C whose ending vertex is w , if  X  p  X  SKYP x ( u, w ) , p  X  C , then the subtree rooted at C can be pruned safely. Otherwise, we insert C into SKYP x ( u, w ) . In addition, if  X  p  X  SKYP x ( u, w ) , C  X  p , we remove p from SKYP x ( u, w ) .

LBOP base pruning : For a node C whose ending vertex is w , consider  X  w,v from w to v . We estimate a lower bound LB ( C ) for C , LB ( C ) = cost ( C ) +  X  w,v . If  X  p  X  SKYP x ( u, v ) , p  X  LB ( C ) , then the subtree rooted at C can be pruned safely.
The correctness of above two pruning rules can be proved as similar as that of pruning rules in Algorithm 1.
There are several ways to partition a graph to k clusters. For different partitions, the number of entries and exits are different. In our problem, the less number of entries and exits makes the size of k -cluster index smaller. Intuitively, the less edges among different clusters results in the less number of entries and exits in graph. Thus, k -cluster partition problem is to find a partition such that the edges among k different clusters are sparse and the edges in a cluster are dense. It is a graph partition problem and this problem has been well studied. We adopt the multi-level graph partitioning technique proposed by Karypis et al. in [1], which is an efficient partition algorithm.
Given an optimal path query from s to t , we construct a shrunk graph  X  G = (  X  V ,  X  E ) .  X  V includes three parts: (i) V S x 6 = s,t ( V x .entry  X  V x .exit ) . V s and V t are the clusters that con-tain s and t respectively.  X  E also includes three parts: (i) ( u, v )  X   X  E , iff (( u, v )  X  E )  X  (( u, v  X  V s )  X  ( u, v  X  V t )) ; (ii) ( u, v )  X  iff (( u, v )  X  E )  X  (( u  X  V x .exit )  X  ( v  X  V y .entry )) , where V x 6 = V y ; and (iii) we create m new edges { ( u, v ) 1 ,  X  X  X  , ( u, v ) for any entry u  X  V x .entry and any exit v  X  V x .exit , where V x 6 = V s and V x 6 = V t . Note that m is the size of SKYP In case (iii), each edge ( u, v ) i (1  X  i  X  m ) from u to v represents a skyline path in SKYP x ( u, v ) . The optimal query from s to t on G ( V, E ) is equivalent to the optimal path query on  X  G (
We utilize a best-first branch and bound search algorithm as sim-ilar as Algorithm 1 to compute the optimal path on  X  G ( that  X  G is not a simple graph, because there are multiple edges be-tween entry u and exit v in a cluster V x . We define a new search tree as follows such that Algorithm 1 can work on  X  G .

Given graph  X  G , starting vertex s and ending vertex t , all pos-sible paths started from s in  X  G can be organized in a search tree. Here, the root node represents starting vertex set { s } . Any non-root node C = { v 0 , ( v 0 , v 1 ) , v 1 ,  X  X  X  , ( v l  X  1 , v started from s , where v 0 = s and ( v i  X  1 , v i ) is an edge from v For two different nodes C and C 0 in the search tree, C is the parent of C 0 if they satisfy the following two conditions: (i) C  X  C | C 0 | = | C | + 1 ; and (ii) C 0 \ C is a tuple set { ( u, v ) , v } , where u and v are the ending vertex of path C and C 0 respectively, and ( u, v ) is an edge from u to v .

We run Algorithm 1 on this search tree. When a node C pops up from the min-heap H , we expand the C by processing the children of C . Assume that the ending vertex of C is u . Then, for each C 0 of C . There may exist several edges from u to v when u  X  V .entry and v  X  V x .exit . These edges represent skyline paths from u to v in G x . To check if C 0 can be pruned or not, we also propose basic pruning rule, skyline path based pruning rule, and LBOP based pruning rule that are as similar as that in Algorithm 1. For LBOP based pruning rule, we compute LBOP as we discussed in Section 4.1. If C 0 cannot be pruned, it is inserted into min-heap H . Algorithm terminates when H =  X  or f ( C )  X   X  for the top element C in H . All experiments were done on a 3.0GHz Intel Pentium Core i5 CPU PC with 8GB main memory, running on Windows 7. We test the following five real datasets.

CAITN : The C hicago A nonymized I nternet T races N etwork is a communication network on Chicago. It is an undirected graph with 4,837 vertices and 17,426 edges.

CARN : The Ca lifornia R oad N etwork is an undirect graph with 21,047 vertices and 21,692 edges.

EuAll : EuAll is an email communication network, email users are vertices and the communications between them are edges. It is a directed graph with 11,521 vertices and 32,389 edges.

Slashdot : Slashdot is a technology related news website known for its specific user community. We generate a directed graph with 20,639 vertices and 187,672 edges.

HepPh : HepPh citation graph is a directed graph extracted from the e-print arXiv with 34,546 papers and 421,578 edges.

In each graph, we randomly assigned d costs to each edge ( d  X  { 2 , 3 } ). we randomly generate 1,000 pairs of vertices and query the shortest paths between each pair of vertices. The query time reported is the average time on each dataset. We set score function as f ( x 1 ,  X  X  X  , x d ) = Querying time : As shown in Table 1, we investigate the querying time on five datasets by comparing k -cluster index with naive index for d = 2 and d = 3 . Naive index is the matrix to maintain  X  for every two vertices u and v in G . In this experiment, we set number of clusters k = 50 . For all datasets, the querying time of k -cluster index are much less than that of naive index. Specially, in HepPh, the querying time of naive index are 17 . 653 and 21 . 467 seconds for d = 2 and d = 3 respectively but the querying time of k -cluster index are only 0 . 4372 and 0 . 5402 seconds. The querying time using k -cluster index are always in order of magnitude faster than naive index. This is because k -cluster index pre-computes the skyline paths for any entry u and any exit v in each cluster. Index size : The index size is shown in Table 2. We compare the size of k -cluster index with naive index when d = 2 and d = 3 . The number k of clusters is also set as 50. We find the size of k -cluster index are much smaller than that of naive index. In HepPh, for d = 2 , the size of naive index is 4124.96 MB but the size of k -cluster is only 138 . 37 MB. These results state k -cluster index is space efficient and thus k -cluster index is suitable for large graphs.
Most existing works for shortest path problem [3, 6, 7] utilize the property of optimal sub-path in the shortest path: any sub-path of a shortest path is also a shortest path. Therefore, they only need to maintain the shortest paths among vertices in index and com-pute the shortest path by concatenating the sub shortest paths in index. Unfortunately, in multi-cost graphs, the property of optimal sub-path in a shortest path does not hold. Hence, all these meth-ods cannot solve the optimal path problem proposed in our paper. Mouratidis et al. in [5] studies skyline queries and top-k queries on multi-cost transportation networks. For any vertex v in graph, all distances on different dimensions between v and query point form the cost vector of vertex v . The definition of the cost vector in this work is different with our work and thus its query results are points but not paths. Therefore, the methods in this work cannot be applied to the optimal path problem in our paper.
In this paper, we defined the optimal path query problem over multi-cost graphs and proposed a best-first branch and bound search algorithm with two optimizing strategies. We also proposed a novel index named k -cluster index to make our method more efficient for large graphs. We confirmed the effectiveness and efficiency of our algorithms using real-life datasets.
This work is supported by the National Grand Fundamental Re-search 973 Program of China under grant 2012CB316200, the Na-tional Natural Science Foundation of China under grant 61173022, 61173023, and grants of the Research Grants Council of the Hong Kong SAR, China No. 419109, 418512.
