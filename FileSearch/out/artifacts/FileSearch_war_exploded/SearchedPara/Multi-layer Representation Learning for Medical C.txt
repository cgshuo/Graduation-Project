 Proper representations of medical concepts such as diagno-sis, medication, procedure codes and visits from Electronic Health Records (EHR) has broad applications in healthcare analytics. Patient EHR data consists of a sequence of visits over time, where each visit includes multiple medical con-cepts, e.g., diagnosis, procedure, and medication codes. This hierarchical structure provides two types of relational infor-mation, namely sequential order of visits and co-occurrence of the codes within a visit. In this work, we propose Med2Vec , which not only learns the representations for both medical codes and visits from large EHR datasets with over million visits, but also allows us to interpret the learned representa-tions confirmed positively by clinical experts. In the experi-ments, Med2Vec shows significant improvement in prediction accuracy in clinical applications compared to baselines such as Skip-gram, GloVe, and stacked autoencoder, while pro-viding clinically meaningful interpretation.
 Representation Learning; Medical Concepts; Healthcare An-alytics; Neural Networks
Discovering efficient representations of high dimensional concepts has been a key challenge in a variety of applications recently [2 ]. Using various types of neural networks, high-dimensional data can be transformed to continuous real-valued concept vectors that efficiently capture their latent relationship from data. Such succinct representations have been shown to improve the performance of various com-plex tasks across domains spanning from image processing [22 , 17 , 36 ], language modeling [ 3, 25 ], word embedding [26 , 30 ], music information retrieval [31 ], sentiment analy-sis [ 32 ], and multi-modal learning of images and text [18 ].
Efficient representations for medical concepts is an im-portant, if not essential, element in healthcare applications as well. Medical concepts contain rich latent relationships that cannot be represented by simple one-hot coding [29 , Chapter 2.3.2]. For example, pneumonia and bronchitis are clearly more related than pneumonia and obesity. In one-hot coding, such relationship between different codes are not represented. Despite its limitation, many healthcare appli-cations [ 7, 33] still use the simple sum over one-hot vectors to derive patient feature vectors. To overcome this limi-tation, it is common in healthcare applications, to rely on carefully designed feature representations [ 34, 16 , 38 ]. How-ever, this process often involves ad-hoc feature engineering that requires considerable expert medical knowledge and is not scalable nor comprehensive in general.

Recently, studies have shown that it is possible to learn efficient representations of healthcare concepts without med-ical expertise while significantly improving the performance of various healthcare predictive models. [ 9, 10 , 8, 23 , 6] Despite this progress, learning efficient representations of healthcare concepts, however, is still an open challenge. The difficulty stems from several aspects: 1. Electronic Health Record (EHR) data have a unique 2. Learned representations should be interpretable. While 3. The algorithm should be scalable enough to handle To address such challenges in healthcare concept represen-tation learning, we propose Med2Vec and make the following contributions.
In the following section, we discuss related works, then describe our method in section 3. In section 4, we explain experiment design and interpretation method in detail. We present the results and discussion in section 5. Then we conclude this paper with future work in section 6.
In this section, we first describe the preliminary ideas used in learning representation for words. Then, we review the algorithms developed for representing healthcare data.
Representation learning of words using neural network based methods have been studied since the early 2000 X  X  [3, 12 , 28 , 35]. Among these techniques, Skip-gram [ 26 ] is the basis of many concept representation learning methods, including our own. Skip-gram is able to capture the subtle relationships between words, thus outperforming the previ-ous works in a word analogy task[ 24].

Given a sequence of words w 1 ,w 2 ,...,w T , Skip-gram learns the word representations based on the co-occurrence infor-mation of words inside a context window of a predefined size. The key principle of Skip-gram is that a word X  X  representa-tion should be able to predict the neighboring words. The objective of Skip-gram is to maximize the following average log probability. where c is the size of the context window. The conditional probability is defined by the softmax function: where v w and v 0 w are the input and output vector represen-tations of word w . W is the number of words in the vocab-ulary. Basically, Skip-gram tries to maximize the softmax probability of the inner product of the center word X  X  vector and its context word X  X  vectors. 1
Pennington et al. proposed GloVe, [30 ] which learns an-other word representations by using a similar principle as Skip-gram. GloVe uses the global word co-occurrence ma-trix to learn the word representations. Since the global co-occurrence matrix is often sparse, GloVe can be computa-tionally less demanding than Skip-gram, which is a neural
Mikolov et al. [26 ] also use hierarchical softmax and neg-ative sampling to speed up the learning process. We focus on the original simple formulation. Figure 1: Skip-gram model architecture: v ( w t ) is a vector representation for the word w t . The goal of Skip-gram is to learn vector representations of words that are good at predicting neighboring words. network model using the sliding context window. On the other hand, GloVe employs a weighting function that could require a considerable amount tuning effort.

Beyond one level representation like Skip-gram and GloVe, researchers also proposed hierarchical learning representa-tions for the text corpus, which has some analogy to our healthcare setting with two level concepts namely: codes and visits. Le and Mikolov [20 ] proposed to learn representations for paragraphs and words simultaneously by treating para-graphs indicators as words. However, their algorithm assigns a fixed set of vectors for both words and paragraphs in the training data. Moreover, their approach does not capture the sequential order among paragraphs. Skip-thought [19 ] proposed an encoder-decoder structure: an encoder (Gated Recurrent Units (GRU) in their case) learns a representation for a sentence that is able to regenerate its surrounding sen-tences (via GRU again). Skip-thought cannot be applied directly to EHR data because unlike words in sentences, the codes in a visit are unordered. Also, the interpretation of Skip-thought model is difficult, as they rely on complex RNNs.
Recently researchers start to explore the possibility of ef-ficient representation learning in the medical domain.
Minarro et al. [27 ] learns the representations of medical terms by applying Skip-gram to various medical text col-lected from PubMed, Merck Manuals, Medscape and Wikipedia. De Vine et al. [ 13] learns the representations of UMLS concepts from free-text patient records and medical jour-nal abstracts. They first replaced the words in documents to UMLS concepts, then applied Skip-gram to learn the dis-tributed representations of the concepts. However, none of them studied longitudinal EHR data with a large number of medical codes.

Skip-gram was directly applied to structured longitudinal visit records to learn the representation of medical codes ( e.g. diagnosis, medication, procedure codes) [9 , 10]. In [9], the authors demonstrated that simply aggregating the learned representation of medical codes to create a visit rep-resentation leads to improved predictive performance. How-ever, simply aggregating the code representations is not the optimal method to generate a visit representation as it com-pletely ignores the temporal relations across adjacent vis-its. We believe that taking advantage of the two-level in-formation (the co-occurrence of codes within a visit and the sequential nature of visits) and the demographic informa-tion of patients will give us better representation for both medical codes and patient visits. RNNs have been applied to analysis of longitudinal patient records [8 , 23] and can generate both code and patient representations. However, despite their outstanding predictive performance, RNNs are difficult to interpret [ 6] which limits their applications in healthcare. In this section, we describe the proposed algorithm Med2Vec . We start by mathematically formulating the EHR data struc-ture and our goal. Then we describe our approach in a top-down fashion. We also explain how to interpret the learned representations. We conclude this section with complexity analysis.

We denote the set of all medical codes c 1 ,c 2 ,...,c |C| EHR dataset by C with size |C| . EHR data for each patient is in the form of a sequence of visits V 1 ,...,V T where each visit contains a subset of medical codes V t  X  C . Without loss of generality, all algorithms will be presented for a single patient to avoid cluttered notations. The goal of Med2Vec is to learn two types of representations: Code representations We aim to learn an embedding func-Visit representations Our second task is to learn another
Figure 2 depicts the architecture of Med2Vec . Given a visit V t , we use a multi-layer perceptron (MLP) to generate the corresponding visit representation v t . First, visit V represented by a binary vector x t  X  { 0 , 1 } |C| where the i -th entry is 1 only if c i  X  V t . Then x t is converted to an intermediate visit representation u t  X  R m as follows, using the code weight matrix W c  X  R m  X |C| and the bias vector b c  X  R m . The rectified linear unit is defined as ReLU ( v ) = max( v , 0 ). Note that max() applies element-wise to vectors. We use the rectified linear unit (ReLU) as the activation function to enable interpretability, which will be discussed in section 3.3 .

We concatenate the demographic information d t  X  R d , where d is the size of the demographic information vector, to the intermediate visit representation u t and create the final visit representation v t  X  R n as follows, using the visit weight matrix W v  X  R n  X  ( m + d ) and the bias vector b v  X  R n , where n is the predefined size of the visit Figure 2: Structure of Med2Vec : A visit comprised of several medical codes is converted to a binary vector x t  X  X  0 , 1 } The binary vector is then converted to an intermediate visit representation u t . u t is concatenated with a vector of de-mographic information d t , and converted to the final visit representation v t , which is trained to predict its neighboring representation. We use ReLU once again as the activation function. We discuss our efficient training procedure of the parameters W c , b c , W v and b v in the next subsection.
As mentioned in the introduction, the sequential informa-tion of visits can be exploited for learning efficient represen-tations of visits and potentially codes. We train the MLP using a very straightforward intuition as follows: a visit de-scribes a state in a continuous process that is a patient X  X  clinical experience. Therefore, given a visit representation, we should be able to predict what has happened in the past, and what will happen in the future. Specifically, given a visit representation v t , we train a softmax classifier that predicts the medical codes of the visits within a context window We minimize the cross entropy error as follows, where W s  X  R |C| X  n and b s  X  R |C| are the weight matrix and bias vector for the softmax classifier, w the predefined con-text window size, exp the element-wise exponential function, and 1 denotes an all one vector. We have used MATLAB X  X  notation for selecting a row in W s and a coordinate of b
As we described in the introduction, healthcare datasets contain two-level information: visit-level sequence informa-tion and code-level co-occurrence information. Since the loss function in Eq. (2 ) can efficiently capture the sequence level information, now we need to find a way to use the second source of information, i.e., the intra-visit co-occurrence of the codes.

A natural choice to capture the code co-occurrence infor-mation is to use Skip-gram. The main idea would be that
We also tried predicting the visit representations ..., v t  X  1 , v t +1 ,... instead of the medical codes, but obtained poor results. the representations for the codes that occur in the same visit should predict each other. To embed Skip-gram in Med2Vec , we can train W c  X  R m  X |C| (which also produces intermedi-ate visit level representations) so that the i -th column of W will be the representation for the i -th medical code among total |C| codes. Note that given the unordered nature of the codes inside a visit, unlike the original Skip-gram, we do not distinguish between the  X  X nput X  medical code and the  X  X utput X  medical code. In text, it is sensible to assume that a word can serve a different role as a center word and a context word, whereas in EHR datasets, we cannot classify codes as center or context codes. It is also desirable to learn the representations of different types of codes ( e.g. diagno-sis, medication, procedure code) in the same latent space so that we can capture the hidden relationships between them.
However, coordinate-wise interpretation of Skip-gram codes is not straightforward because the positive and negative val-ues of W c make it hard for each coordinate to focus on a single coherent medical concept. For intuitive interpreta-tion, we should learn code representations with non-negative values. Note that in Eq.( 1), if the binary vector x t is a one-hot vector, then the intermediate visit representation u t comes a code representation. Therefore, using the Skip-gram algorithm, we train the non-negative weight ReLU ( W c ) in-stead of W c . This will not only use the intra-visit co-occurrence information, but also guarantee non-negative code representations. Moreover, ReLU produces sparse code rep-resentations, which further facilitates easier interpretation of the codes.

The code representations to be learned is denoted as a matrix W 0 c = ReLU ( W c )  X  R m  X |C| . From a sequence of visits V 1 ,V 2 ,...,V T , the code-level representations can be learned by maximizing the following log-likelihood, where p ( c j | c i ) =
The single unified framework can be obtained by adding the two objective functions ( 3) and ( 2) as follows, + X
By combining the two objective functions we learn both code representations and visit representations from the same source of patient visit records, exploiting both intra-visit co-occurrence information as well as inter-visit sequential information at the same time.
While the original Skip-gram learns code representations that have interesting properties such as additivity, in health-care we need stronger interpretability. We need to be able to associate clinical meaning to each dimension of both code and visit representations. Interpreting the learned represen-tations is based on analyzing each coordinate in both code and visit embedding spaces.

If information is properly embedded into a lower dimen-sional non-negative space, each coordinate of the lower di-mension can be readily interpreted. Non-negative matrix factorization (NMF) is a good example. Since we trained ReLU ( W c )  X  R m  X |C| , a non-negative matrix, to represent the medical codes, we can employ a simple method to inter-pret the meaning of each coordinate of the m -dimensional code embedding space. We can find the top k codes that have the largest values for the i -th coordinate of the code embedding space as follows, where argsort returns the indices of a vector that index its values in a descending order. By studying the returned med-ical codes, we can view each coordinate as a disease group. Detailed examples are given in section 5.1
To interpret the learned visit vectors, we can use the same principle we used for interpreting the code representation. For the i -th coordinate of the n -dimensional visit embed-ding space, we can find the top k coordinates of the code embedding space that have the strongest values as follows, where we use the same argsort as before. Once we ob-tain a set of code coordinates, we can use the knowledge learned from interpreting the code representations to under-stand how each visit coordinate is associated with a group of diseases. This simple interpretation is possible because the intermediate visit representation u t is a non-negative vector, due to the ReLU activation function.

In the experiments, we also tried to find the input vector x t that most activates the target visit coordinate [ 14, 21 ]. However, the results were very sensitive to the initial value of x , and even averaging over multiple samples were producing unreliable results.
We first analyze the computational complexity of the code-level objective function Eq. ( 3). Without loss of generality, we assume the visit records of all patients are concatenated into a single sequence of visits. Then the complexity for Eq. (3) is as follows, where T is the number of visits, M 2 is the average of squared number of medical codes within a visit, |C| the number of unique medical codes, m the size of the code representation. The M 2 factor comes from iterating over all possible pairs of codes within a visit. The complexity of the visit-level objective function Eq.( 2) is as follows, where w is the size of the context window, n the size of the visit representation. The added terms come from generating a visit representation via MLP. Since size of code represen-tation m and size of visit representation n generally have the same order of magnitude, we can replace n with m . Further-more, m is generally smaller than |C| by at least two orders of magnitude. Therefore the overall complexity of Med2Vec can be simplified as follows.
 Here we notice that M 2 is generally larger than w . In our work, the average number of codes M per visit for two datasets are 7.88 and 3.19 according to Tables 1, respec-tively, whereas we select the window size w to be at most 5 in our experiments. Therefore the complexity of Med2Vec is dominated by the code representation learning process, for which we use the Skip-gram algorithm. This means that exploiting visit-level information to learn efficient represen-tations for both visits and codes does not incur much addi-tional cost.
In this section, we evaluate the performance of Med2Vec in both public and proprietary datasets. First we describe the datasets. Then we describe evaluation strategies for code and visit representations, along with implementation details. Then we present the experiment results of code and visit rep-resentations with discussion. We conclude with convergence and scalability study. We make the source code of Med2Vec publicly available at https://github.com/mp2893/med2vec.
We evaluate performance of Med2Vec on a dataset pro-vided by Children X  X  Healthcare of Atlanta (CHOA) 3 . We ex-tract visit records from the dataset, where each visit contains several medical codes ( e.g. diagnosis, medication, procedure codes). The diagnosis codes follow ICD-9 codes, the medica-tion codes are denoted by National Drug Codes (NDC), and the procedure codes follow Category I of Current Procedu-ral Terminology (CPT). We exclude patients who had less that two visits to showcase Med2Vec  X  X  ability to use sequen-tial information of visits. The basic statistics of the dataset are summarized in Table 1. The data are fully de-identified and do not include any personal health information (PHI).
We divide the dataset into two groups in a 4:1 ratio. The former is used to train Med2Vec . The latter is held out for evaluating the visit-level representations, where we train models to predict visit-related labels.

We also use CMS dataset, a publicly available 4 synthetic medical claims dataset. The basic information of CMS is also given in Table 1. Compared to CHOA dataset, the CMS dataset has more patients but fewer unique medical codes. The average number of codes per visit is also smaller than that of CHOA dataset. Since CMS dataset is synthetic, we use it only for testing the scalability in section 4.7 .
For a comprehensive qualitative evaluation, we perform a relatedness test by selecting 100 most frequent diagnosis http://www.choa.org/ https://www.cms.gov/Medicare/ Quality-Initiatives-Patient-Assessment-Instruments/ OASIS/DataSet.html
Dataset CHOA CMS # of patients 550,339 831,210 # of visits 3,359,240 5,464,950
Avg. # of visits per patient 6.1 6.57 # of unique medical codes 28,840 21,033 -# of unique diagnosis codes 10,414 14,111 -# of unique medication codes 12,892 N/A -# of unique procedure codes 5,534 6,922 Avg. # of codes per visit 7.88 3.19
Max # of codes per visit 440 44 (95%, 99%) percentile # of codes per visit (22, 53) (9, 13) codes and their 5 closest diagnoses, medications and pro-cedures in terms of cosine similarity. This will allow us to know if the learned representations effectively capture the la-tent relationships among them. Two medical experts from CHOA check each item and assign related , possible and un-related labels.

We use medical code groupers to quantitatively evalu-ate the code representations. Code groupers are used to collapse individual medical codes into clinically meaningful categories. For example, Clinical Classifications Software (CCS) groups ICD9 diagnosis codes into 283 categories such as tuberculosis, bacterial infection, and viral infection.
We apply K-means clustering to the learned code rep-resentations and calculate the normalized mutual informa-tion (NMI) based on the group label of each code. We use the CCS as the ground truth for evaluating the code representation for diagnosis. For medication code evalua-tion, we use American Hospital Formulary Service (AHFS) pharmacologic-therapeutic classification, which groups NDC codes into 165 categories. For procedure code evaluation, we use the second-level grouping of CPT category I, which groups CPT codes into 115 categories.Thus, we set the num-ber of clusters k to 283, 165, 115 respectively for the diagno-sis, medication, procedure code evaluation, which matches the numbers of groups from individual groupers.

For baselines, we use popular methods that efficiently ex-ploit co-occurrence information. Skip-gram (which is used in learning representations of medical concepts by [10 , 9]) is trained using Eq. (3 ). GloVe will be trained on the co-occurrence matrix of medical codes, for which we counted the codes co-occurring within a visit. Additionally, we also report well-known baselines such as singular value decom-position on the co-occurrence matrix.
We evaluate the quality of the visit representations by performing two visit-level prediction tasks: predicting the future visit and predicting the present status. The former will evaluate a visit representation X  X  potential effectiveness in predictive healthcare while the latter will evaluate the how well it captures the information in the given visit. The details of the two tasks are given below.
 Predicting future medical codes : We predict the med-ical codes that will occur in the next visit using the visit representations. Specifically, given two consecutive visits V and V j , the medical codes c  X  V j will be the target y , the medical codes c  X  V i will be the input x , and we use soft-max to predict y given x . The predictive performance will be measured by Recall@k due to its similarity to the dif-ferential diagnosis. Doctors iteratively perform differential diagnosis by generating a list of most likely diseases for an undiagnosed patient based on the available information. We set k = 30 to cover the complex cases of CHOA dataset, as over 167,000 visits are assigned with more than 20 medical codes according to Table 1. We predict the grouped medical codes, obtained by the medical groupers used in Section 4.2 . Predicting Clinical Risk Groups (CRG) level : A pa-tient X  X  CRG level indicates his severity level. It ranges from 1 to 9, including 5a and 5b. The CRG levels can be di-vided into two groups: non-severe (CRG 1-5a) and severe (CRG 5b-9). Given a visit, we use logistic regression to pre-dict the binary CRG class associated with the visit. We use Area Under The Curve (AUC) to measure the classification accuracy, as it is more robust to class imbalance in data. For baselines, we use the following methods.
 Binary vector model (One-hot+) : In order to compare with the raw input data, we use the binary vector x t as the visit representation.
 Stacked autoencoder (SA) : Stacked autoencoder is one of the most popular unsupervised representation learning al-gorithms [37 ]. Using the binary vector x t concatenated with patient demographic information as the input, we train a 3-layer stacked autoencoder (SA) [4 ] to minimize the recon-struction error.The trained SA will then be used to generate visit representations.
 Sum of Skip-gram vectors (Skip-gram+) : We first learn the code-level representations with Skip-gram only (Eq. (3)). Then for the visit-level representation, we simply add the representations of the codes within the visit. This ap-proach was proven very effective for heart failure prediction in [ 9]. We append patient demographic information at the end.
 Sum of GloVe vectors (GloVe+) : We perform the same process as Skip-gram+, but use GloVe vectors instead of Skip-gram vectors. We use the recommended hyperparam-eter setting from [ 30].

We use the held-off dataset, which was not used to learn the code and visit representations, to perform the two pre-diction tasks. The held-off dataset contains 672,110 visits assigned with CRG levels. In order to train the predictors, we divide the held-out data to training and testing folds with ration 4:1. Both softmax and logistic regression are trained for 10 epochs on the training fold. We perform 5-fold cross validation for each task and report the average performance. For all baseline models and Med2Vec , we use age, sex and ethnicity as the demographic information in the input data.
For learning code and visit representations using Med2Vec and all baselines, we use Adadelta [ 39] in a mini-batch fash-ion. For Skip-gram, SA and Med2Vec , we use 1,000 visits per batch. For GloVe, we use 1,000 non-zero entries of the for efficient computation, we preprocessed the EHR dataset Table 2: Average score of the medical codes from the relat-edness test. 2 was assigned for related , 1 for possible and 0 for unrelated Table 3: Clustering NMI of the diagnosis, medication and procedure code representations of various models. All mod-els learned 200 dimensional code vectors. All models except SVD were trained for 10 epochs.
 co-occurrence matrix per batch. The optimization termi-nates after a fixed number of epochs. In section 4.6 , we show the relationship between training epochs and the perfor-mance. We also show the convergence behavior of Med2Vec and the baselines in section 4.7 .
 Med2Vec , Skip-gram, GloVe and SA are implemented with Theano 0.7.0 [5 ]. K-means clustering for the code-level eval-uation and SVD are performed using Scikit-learn 0.14.1. Softmax and logistic regression models for the visit-level evaluation are implemented with Keras 0.3.1, and trained for 10 epochs. All tasks are executed on a machine equipped with Intel Xeon E5-2697v3, 256GB memory and two Nvidia K80 Tesla cards.

We train multiple models using various hyperparameter settings. For all models we vary the size of the code repre-sentations m (or the size of the hidden layer for SA), and the number of training epochs. Additionally for Med2Vec , we vary the size of the visit representations n , and the size of the visit context window w .

To alleviate the curse of dimensionality when training the softmax classifier (Eq.( 2)) of Med2Vec , we always use the medical code groupers of section 4.2 so that the softmax classifier is trained to predict the grouped medical codes instead of the exact medical codes. To confirm the impact of this strategy, we train an additional Med2Vec without using the medical code groupers.
Table 2 shows the average score of the medical codes from the qualitative code evaluation. On average, Med2Vec suc-cessfully captures the relationship between medical codes. However, Med2Vec seems to have a hard time capturing proper representation of medications. This is due to the precise na-ture the medication prescription. For example, Med2Vec cal-culated that Ofloxacin , an antibiotic sometimes used to treat middle-ear infection, was related to sensorineural hearling loss (SNHL), an inner-ear problem. On the surface level, this is a wrong relationship. But Med2Vec can be seen as capturing the deeper relationship between medical concepts that is not always clear on the surface level.

Table 3 shows the clustering NMI of diagnosis, medication and procedure codes, measured for various models. Med2Vec so that the visit records of all patients are concatenated into a single sequence of visits. while fixing others to the basic configuration.
 the CMS dataset. shows more or less similar conformity to the existing groupers as Skip-gram. SVD shows the weakest conformity among all models. GloVe exhibits significantly stronger conformity than any other models. Exploiting the global co-occurrence matrix seems to help learn code representations where sim-ilar codes are closer to each other in terms of Euclidean distance.

However, the degree of conformity of the code representa-tions to the groupers does not necessarily indicate how well the code representations capture the hidden relationships. For example, CCS categorizes ICD9 224.4 Benign neoplasm of cornea as CCS 47 Other and unspecified benign neoplasm , and ICD9 370.00 Unspecified corneal ulcer as CCS 91 Other eye disorders . But the two diagnosis codes are both eye re-lated problems, and they could be considered related in that sense. Therefore we recommend the readers use the evalua-tion results for comparing the performance between Med2Vec and other baselines, rather than for measuring the absolute performance.

In the following visit-level evaluation, we show the domi-nant predictive performance of Med2Vec indicates that code representations X  strong conformity to the groupers does not necessarily imply good visit representations.
The first row of Figure 3 shows the Recall@30 for predict-ing the future medical codes. First, in all of the experiments, Med2Vec achieves the highest performance, despite the fact that it is constrained to be positive and interpretable. The second observation is that Med2Vec  X  X  performance is robust to choice of the hyperparameters in a wide range of values. Comparing to a more volatile performance of Skip-gram, we can see that including the visit information in training not only improves the performance, but also stabilizes it too.
Another fascinating aspect of the results is the overfitting Table 4: Performance comparison of two Med2Vec models. The top row was trained with the grouped code as mentioned in section 4.4 . The bottom row was trained without using the groupers. Both models were trained for 10 epochs with m,n = 200, w = 1.
 Model Future code prediction CRG prediction Grouped codes 0.7605 0.9150
Exact codes 0.7574 0.9155 pattern in different algorithms. Increasing the code repre-sentation size degrades the performance of all of the algo-rithms, as it leads to overfitting. Similar behavior can be seen as we train GloVe+ for more epochs which suggests early stopping technique should be used in representation learning [ 1]. For Med2Vec , increasing the visit representation size n seems to have the strongest influence to its predictive performance.

The bottom row of figures in Figure 3 shows the AUC for predicting the CRG class of the given visit. The overfitting patterns are not as prominent as the previous task. This is due to the different nature of the two prediction tasks. While the goal of CRG prediction is to predict a value re-lated to the current visit, predicting the future codes is tak-ing a step away from the current visit. This different nature of the two tasks also contributes to the better performance of One-hot+ on the CRG prediction. One-hot+ contains the entire information of the given visit, although in a very high-dimensional space. Therefore predicting the CRG level, which has a tight relationship with the medical codes within a visit, is an easier task for One-hot+ than predicting the future codes.

Table 4 shows the performance comparison between two different Med2Vec models. The top model is trained with the grouped codes as explained in section 4.4 , while the bottom models is trained with the exact codes. Considering the marginal difference of the CRG prediction AUC, it is evident that our strategy to alleviate the curse of dimensionality was beneficial. Moreover, using the grouped codes will improve the training speed as the softmax function will require less computation. We compare the convergence behavior of Med2Vec with Skip-gram (Eq. (3 )), GloVe and SA. For SA, we measure the convergence behavior of a single-layer. We train the models for 50 epochs and plot the normalized difference of time t . We also study the scalability of all models except One-hot+, as there is no representation learning in it. We vary the size of the training data and plot the time taken for each model to run one epoch.

The left figure of Fig 4 shows the convergence behavior of all models when trained on the CHOA dataset. SA shows the most stable convergence behavior, which is natural given that we used a single-layer SA, a much less complex model compared to GloVe, Skip-gram and Med2Vec . All models ex-cept SA seem to reach convergence after 10 epochs of train-ing. Note that Med2Vec shows similar, if not better con-vergence behavior compared to Skip-gram even with added complexity.

The center figure of Fig 4 shows the minutes taken to train all models for one epoch using the CHOA dataset. As we have analzyed in section ssec:complexity, Med2Vec takes essentially the same time to train for one epoch. Both Skip-gram and Med2Vec , however, takes longer than SA and GloVe. This is mainly due to having the softmax function for training the code representations. GloVe, which is trained on the very sparse co-occurrence matrix naturally takes the least time to train.

The right figure of Fig 4 shows the training time when using the CMS dataset. Note that Med2Vec and Skip-gram takes similar time to train as SA. This is due to the smaller number of codes per visit, which is the computationally dom-inating factor of both Med2Vec and Skip-gram. GloVe takes less time as the number of unique codes are smaller in the CMS dataset. SA, on the other hand, takes more time because the number of visits have doubled while the the number of unique codes is about 73% of that of the CHOA dataset.
Given the importance of interpretability in healthcare, we demonstrate three stages of interpretability for our model in collaboration with the medical experts from CHOA. First, to analyze the learned code representations we show top five medical codes for each of six coordinates of the code embed-ding space and explain the characteristic of each coordinate. This way, we show how we can annotate each dimension of the code embedding space with clinical concepts. The six co-ordinates are specifically chosen so that they can be used in the later stages. Second, we demonstrate the interpretability of Med2Vec  X  X  visit representations by analyzing the meaning of two coordinates in the visit embedding space.

Finally, we extend the interpretability of Med2Vec to a real-world task, the CRG prediction, and analyze the medi-cal codes that have strong influence on the CRG level. Once we learn the logistic regression weight w LR for the CRG pre-diction, we can extract knowledge from the learned weights by analyzing the visit coordinates to which the weights are strongly connected.

Instead of analyzing the visit coordinates, however, we propose an approximate way of directly finding out which code coordinate plays an important role in predicting the CRG class. Our goal is to find u t such that maximizes the output activation as follows 6 Given the fact that ReLU (  X  ) is an increasing function (not-strictly though), we make an approximation and find the so-lution without the ReLU (  X  ) term. The approximate solution can be found in closed form u ? t  X  ( W &gt; v w LR ) + . Finally, we calculate the element-wise product of u ? t and max( W c + b This is to take into account the fact that each code co-ordinate has different maximum value. Therefore, instead of simply selecting the code coordinate with the strongest connection to the CRG level, we consider each coordinate X  X  maximum ability to activate the positive CRG prediction.
The resulting vector will show the maximum influence each code coordinate can have on the CRG prediction.
As we are interested in influential codes, we assume the demographic information vector is zero vector and omit it for ease of notation. Medications and procedures are appended with (R) and (P) respectively.
Table 5 shows top ten codes with the largest value in each of the six coordinates of the code embedding space. The co-ordinate 112 is clearly related to sickle-cell disease and organ transplant. The two are closely related in that sickle cell dis-ease can be treated with bone-marrow transplant. Prograf is a medication used for preventing organ rejection. Co-ordinate 152 groups medical codes related to sports-related injuries, specifically broken bones. Coordinate 141 is related to brain injuries and hearing loss due to the brain injuries. Neurofibromatosis(NF) is also related to this coordinate be-cause it can cause tumors along the nerves in the brain. Cystic fibrosis(CF) seems to be a weak link in this group as it is only related to NF in the sense that both NF and CF are genetically inherited. Coordinate 184 clearly represents medical codes related to epilepsy. Epilepsy is often accom-panied by convulsions, which can cause joint pain. Cerebral artery occlusion is related epilepsy in the sense that epileptic seizures can be a manifestation of cerebral arterial occlusive diseases[ 11]. Also, both blood in feces and the joint pain can be attributed to Henoch X  X ch  X  onlein purpura, a disease primarily found in children. Coordinate 190 groups diseases that are caused by congenital chromosome anomalies, es-pecially the autosome. Acquired hypothyroidism seems to be an outlier of this coordinate. Coordinate 199 is strongly related to congenital paralysis. Baclofen is a medication used as a muscle relaxer. Quadraplegia patients can have weakened respiratory function due to impaired abdominal muscles[15 ], in which case tracheostomy could be required.
We now analyze two visit coordinates: coordinate 50 and 41. Both visit coordinates have the strongest connection to the logistic regression learned for the CRG prediction. For visit coordinate 50, the two strongest code coordinates connected to it are code coordinates 112 and 152. Then nat-urally, from our analysis above, we can easily see that visit coordinate 50 is strongly activated by sickle-cell disease and sports-related injuries. For visit coordinate 41, code coor-dinates 141 and 184 have the strongest connection. Again from the analysis above, we can directly infer that visit coor-dinate 41 can be seen as a patient group consisting of brain damage &amp; hearing loss patients and epilepsy patients. By repeating this process, we can find the code coordinates that are likely to strongly influence the CRG level.

However, finding the influential code coordinates for CRG level can be achieved without analyzing the visit represen-tation if we use Eq.( 5). Applying Eq.( 5) to the logistic re-gression weight of the CRG prediction, we learned that code coordinates 190 and 199 are the two strongest influencer of the CRG level. Using the analysis from above, we can natu-rally conclude that patients suffering from congenital chro-mosome anomalies or congenital paralysis are most likely to be considered to be in severe states, which is obviously true in any clinical setting.

The results indicate that interpretable visit representa-tions learned by Med2Vec not only improve the prediction accuracy, but also identify the influential clinical concepts.
In this paper, we proposed Med2Vec , a scalable two layer neural network for learning lower dimensional representa-tions for medical concepts. Med2Vec incorporates both code co-occurence information and visit sequence information of the EHR data which improves the accuracy of both code and visit representations. Throughout several experiments, we successfully demonstrated the superior performance of Med2Vec in two predictive tasks and provided clinical inter-pretation of the learned representations.
 [1] Y. Bengio. Learning deep architectures for ai. Founda-[2] Y. Bengio, A. Courville, and P. Vincent. Representation [3] Y. Bengio, R. Ducharme, P. Vincent, and C. Janvin. A [4] Y. Bengio, P. Lamblin, D. Popovici, H. Larochelle, et al. [5] J. Bergstra, O. Breuleux, F. Bastien, P. Lamblin, [6] Z. Che, S. Purushotham, R. Khemani, and Y. Liu. [7] R. Chen, H. Su, Y. Zhen, M. Khalilia, D. Hirsch, [8] E. Choi, M. T. Bahadori, and J. Sun. Doctor ai: Pre-[9] E. Choi, A. Schuetz, W. F. Stewart, and J. Sun. Medical [10] Y. Choi, C. Y.-I. Chiu, and D. Sontag. Learning low-[11] L. Cocito, E. Favale, and L. Reni. Epileptic seizures in [12] R. Collobert and J. Weston. A unified architecture [13] L. De Vine, G. Zuccon, B. Koopman, L. Sitbon, and [14] D. Erhan, Y. Bengio, A. Courville, and P. Vincent. Vi-[15] J. Forner. Lung volumes and mechanics of breathing in [16] M. Ghassemi, T. Naumann, F. Doshi-Velez, N. Brim-[17] G. E. Hinton, S. Osindero, and Y.-W. Teh. A fast learn-[18] R. Kiros, R. Zemel, and R. R. Salakhutdinov. A multi-[19] R. Kiros, Y. Zhu, R. Salakhutdinov, R. S. Zemel, [20] Q. Le and T. Mikolov. Distributed representations of [21] Q. V. Le. Building high-level features using large scale [22] Y. LeCun, L. Bottou, Y. Bengio, and P. Haffner. [23] Z. C. Lipton, D. C. Kale, C. Elkan, and R. Wetzell. [24] T. Mikolov, K. Chen, G. Corrado, and J. Dean. Effi-[25] T. Mikolov, M. Karafi  X at, L. Burget, J. Cernock`y, and [26] T. Mikolov, I. Sutskever, K. Chen, G. S. Corrado, [27] J. A. Minarro-Gim  X enez, O. Mar  X  X n-Alonso, and [28] A. Mnih and G. E. Hinton. A scalable hierarchical dis-[29] K. P. Murphy. Machine learning: a probabilistic per-[30] J. Pennington, R. Socher, and C. D. Manning. Glove: [31] J. Schluter and S. Bock. Improved musical onset detec-[32] R. Socher, A. Perelygin, J. Y. Wu, J. Chuang, C. D. [33] J. Sun, C. D. McNaughton, P. Zhang, A. Perer, [34] J. Sun, F. Wang, J. Hu, and S. Edabollahi. Super-[35] J. Turian, L. Ratinov, and Y. Bengio. Word representa-[36] P. Vincent, H. Larochelle, Y. Bengio, and P.-A. Man-[37] P. Vincent, H. Larochelle, I. Lajoie, Y. Bengio, and P.-[38] Y. Wang, K. Ng, R. J. Byrd, J. Hu, S. Ebadollahi, [39] M. D. Zeiler. Adadelta: An adaptive learning rate
