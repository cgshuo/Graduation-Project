 ships between software artifacts. We call these relationships  X  X raceability links. X  Here we focus on links between requirements and source code files, which are called  X  X e-links automatically X  and the source code file  X  X inkRecover.java X  implementing the requirement, a requirements traceability link exists between them. Grasping require-for improving the modification efficiency for change requests [1,2,12]. 
Because software must be analyzed to identify and extract traceability links, if the links manually due to the massive number of combinations between requirements and source code files. Consequently, some methods to automatically recover requirements larity-based methods recovering links by co mparing representation similarity between actual software products, we applied a typical similarity-based method to a large en-terprise system developed by a company, and the method recovered links with a recall of 60.2% and a precision of 41.1%. This accuracy is unsuitable for practical use. 
To cover weakness of the similarity-based method and improve the application ef-fect, herein we propose a method that extends the similarity-based method using two configuration management log to compensate for the lack of information about the relationships between the requirements and the source code. The second technique is covered links. Validation of links is an inevitable and ordinary cost in the traceability recovering process because traceability recovery methods retrieve some incorrect independent of the representation similarity between requirements and source code. 
We applied our refined method to the abovementioned enterprise system to eva-We recovered traceability links between 192 requirements and 694 source code files. The system has known 726 correct links. In this study, we evaluate recall and preci-sion by comparing the known correct links to the links recovered by our refined me-thod. This study addresses the following Research Questions.  X 
RQ1: How accurately can we recover links by the similarity-based method?  X 
RQ2: How much does the addition of the log-based method improve the recovery accuracy?  X 
RQ3: How much does the addition of link recommendations improve the recovery accuracy? We answered these questions by conducting evaluation experiments. We recovered links with a recall of 80.4% and a precision of 64.8%, which is more than a 20 percent they can recover 80% of the correct links when they validate about 1.3 links for each method. Although our method uses user feedback, it will eventually require less effort of the user. The contributions of this study are:  X 
We propose a traceability recovery method that extends the similarity-based me-thod by incorporating two techniques.  X 
We develop a prototype interactive tool to implement our refined method.  X 
We validate our refined method by comparative experiments with the similarity-based method using sufficiently large software. 
The remainder of the paper is organized as follows. Section 2 provides background Section 5 discusses related works. Finally, section 6 provides a conclusion. 2.1 Similarity-Based Method To recover links automatically, most of previous methods compare the representation similarity between requirements and source code because related documents often share a lot of same words. We call them  X  X imilarity-based method. X  The vector space model (VSM) proposed by Salton et al. is one of the most typical techniques to calcu-late the representation similarity between documents [13]. When the similarity-based method using the VSM (e.g., [2]) compares the representation between requirements terms are extracted from the requirement names or the requirement specification doc-uments. For source code files, terms are extracted from the identifiers (e.g., the name of file, class, method, and field) and source code comments. Consequently, the effec-it performs poorly in some scenarios. For example, in non-English speaking countries, engineers often use their native language in documents and source code comments to facilitate communications. If requirements are written in a non-English language, only even if requirements are written in English, this method does not work well when the identifier lacks meaningful terms (e.g., using an extremely shortened form). 2.2 Log-Based Method As mentioned above, the similarity-based method cannot accurately recover links for traceability recovery method using the configuration management log [11]. The con-figuration management log contains information about modifications of software artifacts. We mainly considered the log of version control system such as Apache X  intermediary. Because revision messages, requirements and source code comments source code files that have no revision histories in the log. To resolve such weakness, herein we combine the similarity-based method with the log-based method. 2.3 User X  X  Validation and Call Relationships Users must validate the recovered candidate links because they may contain incorrect links or overlook links. This cost is inevitable unless the method recovers links with perfect accuracy. Therefore, the results of user X  X  validation can be used for accuracy improvement without an additional burden for the users. ships are often linked by the same requirement. X  The code element represents ele-ments that comprise the source code (e.g., methods, classes and files). For example, in linked with the requirement  X  X ecover links X  because both the caller method  X  X inkRe-cover.recover() X  and the callee method  X  X ink.setRelevance() X  are linked with the detail in section 3.6. 2.4 Motivating Examples We have applied the typical similarity-based method using the VSM to a large enter-prise system, which was developed by a Japanese company. Hence, the requirement specification documents are written in Japanese. Although the source code comments are also written in Japanese, some source code files lack comments. Consequently, the accuracy motivated us to extend the similarity-based method. 
After improving some problems of the log-based method proposed, we applied it to the abovementioned enterprise system. As a result, we found that this method is superior to the similarity-based method under certain circumstances. When we limited the target agement log (the number of source code files decreases from 694 to 317), this method recovered links with a recall of 67.6% and a precision of 69.1%. Meanwhile, the simi-377 source code files without revision histories. The superiority under certain circums-method with the log-based method. 3.1 Overview We propose a method to recover requirements traceability links. This method extends the similarity-based method using two techniques. In this study, we calculate the simi-larity between documents by using the VSM. Figure 3 shows the overview of our method. Our method requires three artifacts as inputs. 1. Requirements requirements that are concrete and objective (i.e., software functional and non-functional requirements). 2. Source code files 
Because our method applies natural language processing and analyzes call relation-ships, our method can be applied to source code languages that the above two techniques are applicable for. The prototype tool for our method currently supports 
Java X  2 [16] (partly C and C++). 3. Revisions of the configuration management log cuses on the log of the version control system. Our tool currently supports Subver-sion and Git. Prior to employing our method, unnecessary revisions, which indicate revisions including simultaneous modification of too many source code files are excluded; that is, the tool excludes revisions involving over 10 source code files. First, we create a document-term matrix (DTM) using the three input artifacts. The DTM is a matrix indicating the frequency of terms that occur in documents. Next, two notes the similarity score calculated by the similarity-based method. The second is the indicate all relationships between the target elements. For example, if the target sys-However, the reliability as a score in the candidate links differs. 
After calculating the score, users specify a target (requirement or source code file) that they want to recover links. Then our tool displays candidate links of the specified method. This algorithm sorts candidate links using two kinds of scores and user feed-links X  as the target, the tool displays the sorted candidate links of the requirement. They judge the correctness of the candidate links, and each time, the result is provided dating the correctness of the first presented link, the presentation order is re-sorted. 
Finally, after users identify some correct links, users can determine the require-files each requirement is related to. Below our method is described in detail. 3.2 Document-Term Matrix Generation extracted from the requirement name and the requirement specification document. Terms of the source code file are extracted from source code comments and identifiers. Then, if the identifier is represented as the connected term (e.g., LinkRe-cover, recover_Links()), the identifier is decomposed into individual terms. Terms of revisions are extracted from revision messages. 
Here,  X  represents a set of documents and  X  presents a set of terms. For a docu-ment  X   X   X  X  X  X  X  containing  X  valid terms [i.e.,  X  X  X  X   X  is the number of appearances of  X   X  in represented by N-dimensional vector  X   X   X   X   X   X   X  as In the VSM, the vector of the document is represented as Formula (1). However, we use the vector weighted by TF-IDF to more accurately represent the document charac-teristics. TF-IDF indicates the term frequency and inverse document frequency. Fre-quently used terms in a document have high importance for the document. On the other hand, common terms used in many documents have low importance (e.g., gen-eral words). The term frequency value of  X   X  in  X   X  is defined as If the number of documents is represented as  X  and the number of documents con-defined as Therefore, the vector weighted by TF-IDF is defined as  X   X   X   X   X   X   X  X  X  X  X   X   X 
The similarity between two documents  X   X  and  X   X  angle between the two document vectors  X  X   X   X   X   X   X   X  and similarity.  X  X  X  X  X  X   X   X ,  X   X  (Document Similarity,  X 1.0 X  X  X  X 0 X  the cosine similarity as To calculate the similarity between all documents (containing requirements, source code files and revisions), a document-term matrix columns is generated. Here  X  represents the number of documents and represents the total number of terms in the documents. The matrix is defined as calculate similarities between all documents using the DTM. 3.3 Calculating the Similarity-Based Score In this approach, we calculate two kinds of relevance scores for each candidate link. code. We call this first score the  X  X imilarity-based score. X  Basically, ment name, we set the maximized score (i.e., 1.0) to the similarity-based score. This software traceability tend to record the name of relevant requirements in source code comments. The effectiveness of this process depends on the quality of comments. (  X  X  X ,  X  ). The similarity-based score  X  X  X  X  X  X  X  between requirement source code file  X   X  (  X   X   X ,  X   X   X   X   X  ) is defined as 3.4 Calculating the Log-Based Score Additionally, we calculate the second relevance score using the log-based method. revisions and the weight of the source code files for each revision. 
Here  X  represents a set of revisions (  X  X  X  ). The number of source code files modified in revision  X   X  (  X   X   X   X  ) is represented as code files  X   X  in revision  X   X  is defined as Therefore, the log-based score  X  X  X  X  X  X  X  between requirement file  X  is defined as  X  represents the number of revisions. We calculate revision and sum up their multiplied values (  X  X  X  X  *  X  X  X  X  X  X  3.5 Sorting Algorithms Here the target is either the requirement or source code file. Candidate links are sorted by our algorithm. The kind of target determines which algorithm is used. 
As described in section 2.4, the log-based method is superior to the similarity-presence of the revision history. For a file without revision histories in the configura-tion management log (i.e., all log-based scores are 0), the candidate links are sorted in revision history, the links are sorted in descending order of the log-based score. candidate links are sorted in descending order of the similarity-based score. However, on the other hand, candidate links get preferential rights if they have the highest log-based score in the group of candidate links when targeting any source code files. Can-didate links with preferential rights are prior to links without the rights. (i.e., even if cending order of the log-based score. 3.6 Link Recommendations Our tool presents sorted candidate links to users, and then the users validate the links starting from the top. Because their judgments are provided as feedbacks to the tool, Here the call relationships of the source code file indicate the relationships of methods relationships. We call this type of recommendation a  X  X ink Recommendation. X  values:  X  RCR (Recommendation Count by calleR) X  and  X  RCE (Recommendation source code file  X  X inkRecover.java X  is judg ed as correct, the link recommends a can-vanceCalculator.java X  because the method  X  X ecover() X  in the file  X  X inkRecover.java X  is the caller of the method  X  X alculate() X  in the file  X  X elevanceCalculator.java. X  Then the value RCR of the candidate link increases by one. Likewise, if a link with the file  X  X ink.java X  is judged as correct, the value RCE of the candidate link increases by one. 3.7 Sorting Algorithm with User Feedback 3.5 by two values RCR and RCE . 
The algorithm is designed on the basis of the hypothesis that links recommended order of the value that multiplies RCR and RCE . Second, the links with the same mul-and RCE . Third, the links with the same added value are sorted by the algorithm men-tioned in the section 3.5. In Figure 5 that shows an example of link order, the link A is the top of the order because it has the highest multiplied value ( RCR * RCE ). The link descending order of the similarity-based score. 4.1 Overview subsystem has 726 known correct links. Hence, the following experiments target this subsystem, which has more than 80KLOC. We recovered traceability links between 192 requirements and 694 source code files where the requirements are extracted from the requirement specification documents. Source code files are implemented by Java X . We use 7090 revisions of the Subversion log. Requirements, source code comments and revision messages are written in Japanese. 
To evaluate the improvement in recall and precision, we conducted three experi-we recovered links by using the method combining the similarity-based method and the log-based method. Third, we conducted an experiment evaluating the effective-ness of the link recommendation. 
For each experiment, we recovered links by repeating the following cycle. 1. Specify a target (requirement or source code file). 2. Validate candidate links of the specifi ed target starting from the top. 3. Validation of the target is complete when the validation count reaches the allowa-ble validation count or all correct links of the target are recovered Here the allowable validation count indicates how many candidate links users can recovery targeting requirements is independent of the recovery targeting source code files. Therefore, we can determine the recall and precision for both targeting require-ments and targeting source code files. Recall, precision and F-measure (comprehen-sive measure of recall and precision) are defined as Because the correct links are known, all experiments were fully automated. When der of the requirement name. However, the target order affects the accuracy when the targeting source code files in experiments, we tried using two kinds of orders: the best order (descending order of the highest relevance score of the candidate links) and the worst order (ascending order of the highest relevance score of the candidate links). 
Figure 6 shows the experimental results for the recall and precision for each target where the horizontal axis indicates the allo wable validation count and the vertical axis targets are source code files and the allowable validation count is two. 4.2 First Experiment: Recovering by the Similarity-Based Method First, we recovered links using only the similarity-based method, which used the simi-larity-based score to sort candidate links. Based on the results in Table 1, we can an-swer the first research question. RQ1: How Accurately Can We Recover Li nks by the Similari ty-Based Method? The similarity-based method recovered links with a recall of 60.2% and a precision of 41.1%. This accuracy is not sufficiently high. However, 42.1% of the recovered cor-fore, the similarity-based method can cover the weakness of the log-based method. 4.3 Second Experiment: Recovering by the Combined Method To confirm the effectiveness of combining the similarity-based method with the log-based method, we recovered links by using the combined method, which used both the similarity-based score and the log-based score. In all graphs of Figure 6, the com-bined method provides improved results compared to the similarity-based method. Thus, we can answer the second research question based on the results in Table 1. RQ2: How Much does the Addition of the Log-Based Method Improve the Recovery Accuracy? Adding the log-based method improved the recall by an 11.0 percent point (60.2% to 71.2%) and the precision by a 10.7 percent point (41.1% to 51.8%). Then, the F-measure was improved by 0.111 (0.488 to 0.599). Moreover, the average similarity-based score of links recovered newly by the combined method is 0.227, whereas the Therefore, the log-based method can also cover the weakness of the similarity-based method. 4.4 Third Experiment: Effectiveness of Link Recommendations We recovered links by using the combined method with link recommendations to evaluate the effectiveness. Then we tried using two kinds of orders: the best order and the worst order. In Figure 6, the method with link recommendations is superior to that without link recommendations for all conditions except when the targets are require-ments and the allowable validation count is one. 
When targeting requirements, the link recommendation becomes effective from the second presented candidate link because th e first presented link is not recommended ommendation is effective from the first presented link excepting for the first targeted has already been validated when targeting different source code files. Therefore, when targeting source code files, the targeting order affects the accuracy because the pres-entation order depends on the validation results of other source code files. Thus, the experiments can answer the third research question. RQ3: How Much Does the Addition of Link Recommendations Improve the Recovery Accuracy? The link recommendation improved the recall by a 9.2 percent point (71.2% to best order. Then, the F-measure was improved by 0.119 (0.599 to 0.718). On the other hand, when using the worst order, the effectiveness decreased in comparison with using the best order. Hence, the link recommendation is most effective when the vali-dated correct link with the high relevance score recommends the unvalidated correct link with the low relevance score. Therefore, when we put on emphasis on the accura-cy, we should preferentially target source code files that have candidate links with the high relevance score. In the experiment, we recovered many additional links that have low relevance scores by applying the link recommendation. 4.5 Threats to Validity The fact that we validated our method by applying to only one software product is a threat to the external validity. The improvement in accuracy depends on the quality of the revision messages and software structure because our method employs the confi-guration management log and call relationships. Thus, we should evaluate the rela-tionship between these factors for other software and the effectiveness of our method. 
In our evaluation, we independently conducted the recovery targeting requirements and the recovery targeting source code files. However, in an actual application, users the accuracy of the recovering links, which is a threat to the internal validity. There-fore, we should conduct an experiment with random targeting in the future. 
Additionally, our method uses user feedback to improve the accuracy, which may impact of the environment for real applications of our method. ings suggest, we should improve usability of our tool because validation of the candi-date links takes significant costs. 
M X der et al. conducted a controlled experiment with 52 subjects performing real were with and the other half were without traceability [1]. They showed that on aver-age subjects with traceability perform 21% faster and create 60% more correct solu-tions. Their empirical study affirms the usefulness of requirements traceability links. 
Blaauboer et al. have investigated how project managers make a decision on adopt-ing requirements traceability [5]. They validated the factors relevant for the decision and found five dominant factors: development organization awareness, customer awareness, return on investment, stakeholder preferences, and process flow. 
Some studies have compared the representation between requirements and source Here we propose extended method based on the method using the VSM [2]. 
Chen et al. proposed an approach that combines three supporting techniques, Regu-lar Expression, Key Phrases, and Clustering, with the VSM to improve the traceability contrast, our component techniques are independent of the representation similarity. 
Wang et al. proposed a feature location ap proach that supports multi-faceted inter-active program exploration [9]. Feature Loca tion is a technique similar to recovering requirements traceability links for targeting requirements. Their approach automati-cally extracts multiple syntactic and semantic facets from candidate program ele-require users only to validate correctness of candidate links. 
Ghabi et al. proposed an approach to validate links through call relationships within filtering by call relationships all at once, whereas we use only correct links validated by users and interactively apply the link recommendation by call relationships. We have proposed a traceability recovery method that extends the similarity-based using the configuration management log. The second is link recommendations using user feedback and the call relationships. We applied our method to an actual product and recovered links between 192 requirements and 694 source code files, confirming the effectiveness of applying two elemental techniques simultaneously. In the future, the applicability of other code relationships for link recommendations. 
