 The increasing prevalence of sensors and mobile devices has led to an explosive increase of the scale of spatio-temporal data in the form of trajectories. A trajectory aggregate query , as a fun-damental functionality for measuring trajectory data, aims to re-trieve the statistics of trajectories passing a user-specified spatio-temporal region. A large-scale spatio-temporal database with big disk-resident data takes very long time to produce exact answers to such queries. Hence, approximate query processing with a guar-anteed error bound is a promising solution in many scenarios with stringent response-time requirements. In this paper, we study the problem of approximate query processing for trajectory aggregate queries. We show that it boils down to the distinct value estima-tion problem, which has been proven to be very hard with pow-erful negative results given that no index is built. By utilizing the well-established spatio-temporal index and introducing an in-verted index to trajectory data, we are able to design random index sampling (RIS) algorithm to estimate the answers with a guaran-teed error bound. To further improve system scalability, we extend RIS algorithm to concurrent random index sampling (CRIS) algo-rithm to process a number of trajectory aggregate queries arriving concurrently with overlapping spatio-temporal query regions. To demonstrate the efficacy and efficiency of our sampling and esti-mation methods, we applied them in a real large-scale user trajec-tory database collected from a cellular service provider in China. Our extensive evaluation results indicate that both RIS and CRIS outperform exhaustive search for single and concurrent trajectory aggregate queries by two orders of magnitude in terms of the query processing time, while preserving a relative error ratio lower than 10%, with only 1% search cost of the exhaustive search method. H.2.4 [ Database Management ]: Systems  X  Query processing; H.4.0 [ Information Systems and Applications ]: General Algorithms, Experimentation.
  X  Spatio-temporal databases, trajectory aggregate query, sampling, approximate query processing
A trajectory stands for a sequential time-stamped geo-locations in a three dimensional spatio-temporal space. In reality, a trajectory may contain a variety of attributes, for example, a taxi GPS trajec-tory has the instant or average velocity, trajectory length, occupa-tion indicator, etc. [36]; A Flickr user X  X  trajectory may infer users X  sequential activities, (e.g., what he/she has done) from the mul-timedia contents attached to the locations (e.g., text, images and videos). These trajectory data facilitate many emerging applica-tions including urban planning [36, 19], spatio-temporal data min-ing [21, 15], and various location-based services [33, 20]. A tra-jectory aggregate query , as a fundamental functionality of spatial-jectories passing a user-specified spatio-temporal region [4, 8]. A typical trajectory aggregate query is  X  X he total number of taxi tra-jectories with speed greater than 5 miles per hour in New York City during 2013 X .

The increasing prevalence of sensors and mobile devices, such as GPS set on cars or smart phones carried by people, and the fast development of location-acquisition technologies have led to an explosive increase of the scale of spatio-temporal databases in the form of trajectories, which generates new challenges, namely, how to efficiently process numerous trajectory aggregate queries in large-scale trajectory databases.
 Various spatio-temporal indexing techniques, such as augmented R-tree [24], multi-version R-tree [30, 31], and grid-based index [5], have been proposed to divide the spatio-temporal space into in-dices and facilitate the access to spatio-temporal data. These spatio-temporal indices are of hierarchical structure, namely, mul-tiple adjacent index nodes in a lower level are aggregated to an index node in a higher level. When processing spatio-temporal queries, the index nodes are typically browsed in a top-down man-ner. Many spatio-temporal aggregate queries, such as counting the total spatio-temporal records, can be answered by aggregating the information maintained in index nodes at the higher levels to avoid accessing the raw spatio-temporal data. However, for a trajectory aggregate query, maintaining the statistical trajectory information on index nodes does not work. The reason is that a trajectory ag-gregate query aims to find the number of distinct trajectories in a spatio-temporal query region. To determine whether two index nodes contain some trajectories in common, the trajectory IDs must be recorded in every index node. Using such an index structure makes no difference from the brute-forcing. Thus, to produce the exact answer to a trajectory aggregate query, a non-avoidable brute-force search has to be performed, which takes very long time when the spatio-temporal query region covers a large amount of disk-resident data. As a result, approximate query processing becomes a promising solution in many scenarios with stringent response-time requirements, which provides (reasonably accurate) approximate answers.

In this paper, we make the first attempt to investigate the problem of approximate query processing for trajectory aggregate queries. By introducing an inverted index to trajectory data, we design R andom I ndex S ampling (RIS) algorithm to estimate the answers with guaranteed error bounds. To further improve system scalabil-ity, we design C oncurrent R andom I ndex S ampling (CRIS) algo-rithm to process a number of trajectory aggregate queries arriving concurrently with overlapping spatio-temporal query regions. We highlight our contributions as follows.
The remainder of this paper is organized as follows. Section 2 discusses related work. We define our problem in Section 3. In Sections 4 and 5, we present our proposed RIS and CRIS algo-rithms, respectively. Section 6 analyzes the performance of RIS and CRIS algorithms. Section 7 describes some generalizations of our algorithms. Finally, we conclude this paper in Section 8.
We make the first attempt to employ sampling techniques to im-prove the effectiveness in processing trajectory aggregate queries in large-scale spatio-temporal databases, with the aim to signifi-cantly reduce the query processing time while preserving certain estimation accuracy. In this section, we discuss three topics that are closely related to our work and highlight the differences from them, including (1) trajectory data management, (2) distinct value estimation, and (3) concurrent query processing.
Trajectory queries. As moving object trajectories have been collected in a massive scale due to the advancement of sensor technologies like satellite, RFID, GPS, and mobile cellular net-works, the query processing of trajectory databases has been paid much attention. Trajectory queries aim to evaluate various spatio-temporal relationships among spatial data objects, such as regions, points, and trajectories [8]. The trajectory queries can be gener-ally classified into two main categories: range (or window) queries and nearest-neighbor queries. Range queries retrieve trajectories passing a given spatio-temporal region [4, 8] or search spatio-temporal regions which are frequently passed by trajectories [16, 18]. Nearest-neighbor queries ask for the top-k nearest-neighbor trajectories to a specified point or trajectory [13, 32]. In this pa-per, we particularly focus on a sub-category of the trajectory range queries, namely, a trajectory aggregate query, which returns the statistics (e.g., counts, sum, or average) of all distinct trajectories in the spatio-temporal query region. Traditional methods to handle trajectory queries are through spatio-temporal indices, as discussed below.

Executing trajectory queries using database indices. It is im-portant to utilize the appropriate indexing techniques for trajec-tory data to improve the efficiency and effectiveness of process-ing trajectory queries. The trajectory database has unique require-ments to the index techniques because of its spatio-temporal data characteristics [8]. The state-of-the-art trajectory indexing tech-niques can be grouped into three categories, including augmented R-tree, multi-version R-tree, and grid-based index. (1) An aug-mented R-tree employs R-trees over the 3D spatio-temporal space, e.g., Spatio-Temporal R-tree (STR-tree) and TB-tree (Trajectory Bundle tree) [24]. (2) A multi-version R-tree builds multiple struc-tures of R-trees. For each time stamp, an R-tree is created, and R-trees for different time stamps are indexed, e.g., historical R-tree (HR-tree) [30] and multi-version B-trees and 3D R-trees (MV3R-trees) [31]. (3) A grid-based index divides the spatial dimension into grids using Quad-trees [9] or KD-trees [1], and then builds a separate temporal index for each grid, e.g., multiple time-split B-tree (MTSB-trees) [37] and Scalable and Efficient Trajectory Index (SETI) [5] to divide the spatio-temporal space into indices and fa-cilitate the spatio-temporal data access.

However, as elaborated in Section 1, to produce the exact an-swers to a trajectory aggregate query, a non-avoidable brute-force search has to be performed, which takes very long time when the spatio-temporal query region covers a large amount of disk-resident data. As a result, approximate query processing becomes a promis-ing solution for trajectory aggregate queries in many scenarios with stringent response-time requirements. In a spatio-temporal database indexed by one of the index structures, we propose to es-timate the answers to the trajectory aggregate queries by sampling a limited number of index leaf nodes. Our proposed random index sampling (RIS) algorithm can significantly reduce the query pro-cessing time while preserving certain estimation accuracy. More-over, RIS algorithm can be applied (and is orthogonal) upon various trajectory indexing methods.
In a column of a large table with each entry filled with a value with no index built, distinct value estimation problem aims to de-sign a scalable approach to generate accurate estimation to the number of distinct values, with limited space or time resources. When time is a major constraint, random sampling is the only ap-proach, which collects samples from the table, and estimates the total number of distinct values. Unfortunately, the existing works Figure 1: A trajectory aggregate query q returning the num-ber of distinct trajectories in the spatio-temporal query region depicted in the cuboid. r 1 , r 2 , and r 3 are three trajectories. show powerful negative results [6, 7, 14, 23] that no estimator can guarantee small error across all input distributions, unless it exam-ines a large fraction of the input data. On the other hand, when space is a primary concern, scanning the entire table is allowed, synopses based approaches [2, 12, 17] yield reasonably accurate es-timation to the number of distinct values. Our trajectory aggregate query problem boils down to the distinct value estimation prob-lem with stringent time constraint, when sampling is performed upon spatio-temporal points of trajectories, with the trajectory IDs viewed as the  X  X istinct values X . To tackle this seemingly unsolv-able problem, we in this paper employ spatio-temporal index and inverted index to allow obtaining the probability of each trajectory being collected while sampling, thus enabling the design of unbi-ased estimator for the number of trajectories with bounded variance and confidence interval.
A database, especially a large-scale spatio-temporal database, usually has to deal with numerous concurrent queries from a large number of users. Thus, it is important and desirable to process these concurrent queries through exploiting a shared execution paradigm to avoid redundant computations and save the computational cost. In general, there are mainly three shared execution paradigms. (1) Multi-query optimization. This technique detects and re-uses common sub-expressions among queries by operating on batches of queries only during the optimization phase and materializing shared intermediate results at the cost of memory [27]. (2) Simulta-neous pipelining. This paradigm extracts identical sub-plans from concurrent queries, executes only one of them and sends the results to the rest simultaneously [25]; however, it is limited to common sub-plans, that is, it is not applicable to the case that two queries have similar sub-plans but with different selection predicates. (3) Global query plans. This paradigm utilizes shared operators (with fine granularity) rather than sub-plans (with coarser granularity) to increase sharing opportunities, in which a single shared operator can evaluate two queries sharing a similar plan simultaneously [25]. In this paper, we apply the global query plans paradigm to utilize the sharing opportunities, the key challenge of which is to decom-pose the operators (i.e., sampling) into shared sub-operators and reconstruct the results for all concurrent trajectory range queries. We employ stratified sampling and sample reuse to solve the prob-lem. (See Section 5 for more details.)
In this section, we clarify key terms used in the paper and for-mally define the objective of approximate query processing for tra-Notation Description Q = { q 1 ,  X  X  X  ,q M } , Q j  X  Q , 1  X  j  X  Q 0 = { q 0 1 ,  X  X  X  ,q 0 M 0 } , Q 0 i  X  Q 0 , 1  X  i  X  M q , q 0 q is a trajectory aggregate query.
R q = { R q 1 ,  X  X  X  ,R q n } R q is the set of n index leaf nodes
B B is the sampling budget (i.e., the  X 
R q t , 1  X  t  X  B  X  R q t is the t -th sampled index leaf k q r The number of index leaf nodes in
N q ,  X  N q N q is the number of trajectories that jectory aggregate queries. Table 1 provides the notations and ter-minologies used in this paper.
As discussed in Section 1, to produce exact answers to a trajec-tory aggregate query q , a non-avoidable brute-force search has to be performed, which takes very long time when the spatio-temporal
Note that there are many spatio-temporal index structures in the literature [3, 11], and our random index sampling algorithms can be applied (and is orthogonal) to different indexing methods. query region covers big disk-resident data. In this paper, we em-ploy sampling methods to perform approximate query processing for trajectory aggregate queries with guaranteed error bounds. Problem definition. Given a trajectory aggregate query q in a large-scale trajectory database, the database returns the total num-ber of distinct trajectories N q in q  X  X  spatio-temporal query region, with certain attribute constraints. Suppose q  X  X  query region cov-ers n spatio-temporal index leaf nodes R q = { R q 1 ,  X  X  X  ,R aim to sample and search B index leaf nodes (where B n ), {  X 
R 1 ,  X  X  X  , rate estimator  X  N q that converges to N q , and for any &gt; 0 and 0 &lt;  X   X  1 , a certain confidence interval is guaranteed as Pr ( |  X  N q  X  N q | &gt; )  X   X  .
In this section, we introduce our proposed random index sam-pling (RIS) algorithm to sample index leaf nodes in the spatio-temporal query region of a trajectory aggregate query q , and design an unbiased estimator to estimate the answer to q , with provable bounds on the confidence interval.
RIS algorithm works in three stages as follows, inverted indexing stage, sampling stage, and estimating stage.
 Inverted indexing stage. An inverted index [38] is an index data structure storing a mapping from content, such as numbers or words, to its locations. We build an inverted index for the trajec-tory data, where each record represents a trajectory and all index leaf nodes the trajectory traverses (as shown in Figure 2). Given a trajectory aggregate query q , we denote k q r as the number of index leaf nodes that a trajectory r goes through in q  X  X  spatio-temporal query region. k q r can be quickly obtained by checking the record of r in the inverted index. It will be clear shortly that k probability of a trajectory r being sampled in sampling stage and k is an important variable to design estimator to the answer of q . Sampling stage. Let B denote the sampling budget, i.e., the max-imum number of index leaf nodes allowed to collect. In our analy-sis, we assume that B is always sufficiently large. We uniformly at random pick up B index leaf nodes from the leaf node set covered by q  X  X  spatio-temporal query region, i.e., R q , with replacement Thus, each index leaf node in R q has an equal probability of 1 /n being sampled. Then, we scan the sampled index leaf nodes and find the trajectories of our interest, namely, those matching the tra-jectory attribute constraints of q . If a sampled index leaf node is chosen more than once, we only perform one exhaustive search on it. Hence, as shown in Figure 2, we obtain a list of sampled index leaf nodes, {  X  R q 1 ,  X  X  X  ,  X  R q B } , from the population space R that a sample  X  R q t  X  R q represents both the index leaf node and the trajectory set in it, where we will interchangeably use these two meanings of  X  R q t in the rest of the paper ( 1  X  t  X  B ).
Various statistics of a sampled index leaf node  X  R q t can be repre-sented as functions of  X  R q t ( 1  X  t  X  B ). For instance, the number of distinct trajectories that match the query contraints of q can be viewed as a mapping g q : R q  X  N from a trajectory set  X  r  X   X  R q t , the number of index leaf nodes that r traverses in R
Note that in general q  X  X  query region is much larger than the in-dex leaf node. Hence, for simplicity, we consider all trajectories in an index leaf node R q i traverse q  X  X  query region, if q partially or completely covers R q i in the spatio-temporal space. On the other hand, when the query region of q is small, exhaustive search can be directly applied to obtain q  X  X  exact answer.
 Lng Lat query q ST-indexed data Data Indexing Structure 
Sampling and Estimation k , is proportional to the probability that the trajectory r being sam-pled by randomly picking up an index leaf node from R q . Define a mapping f q : R q  X  R + as N q t = f q (  X  R q t ) = P r  X  where  X  R q t  X  q represents the trajectory set in  X  R q t attribute constraints of q . It is clear that the ground-truth answer for the trajectory aggregate query q , namely, the total number of distinct trajectories in R q , is N q = P n i =1 f q ( R q shown in Figure 2) after a trajectory r is obtained from  X  the number of index leaf nodes r traverses in R q , i.e., k found by checking the inverted index.
 Estimating stage. Using RIS, Theorem 1 presents that the proba-bility of each trajectory being sampled is proportional to the num-ber of index leaf nodes it traverses in R q .
 Pr ( r ) of each trajectory r  X  R q  X  q being sampled using RIS algorithm is Pr ( r ) = k q r /n , where R q = { R q 1 ,  X  X  X  ,R
P ROOF . Each index leaf node R q i ( 1  X  i  X  n ) has an equal probability Pr ( R q i ) = 1 /n to be chosen. The conditional proba-bility of each trajectory r being sampled given that R q i is Pr ( r | R q i ) = 1 , if r  X  R q i ; and Pr ( r | R q plying the law of total probability yields the probability of r being sampled as Pr ( r ) = P n i =1 Pr ( R q i ) Pr ( r | R q i
In the next subsection, we develop an unbiased estimator to es-timate the total number of distinct trajectories that match the query constraints of q , using the samples {  X  R 1 q ,  X  X  X  ,  X  R algorithm.
An estimator is a function of a sequence of observations that outputs an estimate of an unknown population parameter. Below, we present an asymptotically unbiased estimator of N q .
Unbiased estimator. We aim to estimate the total number N distinct trajectories that match the query constraints of q . We define an estimator  X  N q in Theorem 2.

T HEOREM 2 (E STIMATOR TO N q ). With a sampling bud-get B , RIS algorithm collects B sampled index leaf nodes {  X 
R 1 ,  X  X  X  , Equation (1) is the asymptotically unbiased estimator of N
P ROOF . Since each  X  R q t is chosen uniformly at random from the same population space R q , f q (  X  R q t )  X  X  are all independent and fol-low the same distribution, and thus have the same expectation as E [ f q (  X  R q t )] =  X  = P n i =1 f q ( R q i ) /n = N q of the expectation, E [  X  N q ] = N q .

Sampling Budget Analysis. Under a certain trajectory index structure, such as Quad-tree and B-tree, all the trajectory records and indices are stored as regular files. Thus, the size of an index tem. For example, on Hadoop Distributed File System (HDFS), the block file size is 64MB, and when in-block index is built, a smaller memory page size (e.g., 4KB) is used [34]. As a result, given that each trajecotory record takes roughly a constant amount of space, e.g., 100B, the number of distinct trajectories in an index leaf node is bounded, e.g., by 4 KB/ 100 B = 40 , and we denote this upper bound as  X  . Hence, for a trajectory aggregate query q , f holds. Theorem 3 below determines the sampling budget B needed to achieve a certan estimation accuracy.

T HEOREM 3. The estimator  X  N q (Equation (1)) guarantees that for any &gt; 0 and 0 &lt;  X   X  1 , tories in an index leaf node.

P ROOF . Recall that each sample  X  R q t  X  R q is drawn uniformly at random from R q . Hence, random variables f q (  X  R q t dent and identically distributed, and they follow the same distribu-tion. Given that each f q (  X  R q )  X   X  holds, the following bound holds by applying Hoeffding X  X  inequality [28], Then, by letting the right hand side (in Equation (3)) be smaller than or equal to  X  , we obtain B  X  ln (2 / X  )  X  2 n 2 2 2 as the minimum budget needed to guarantee the confidence interval in Equation (2).
It is clear that to achieve a certain confidence interval, governed by and  X  , the minimum sampling budget needed satisfies B  X   X  and B  X  n 2 .
The proposed RIS algorithm properly deals with a single tra-jectory aggregate query with a guaranteed estimation error bound. However, when it comes to queries in a large-scale trajectory database management system, e.g., user mobility data from car-jectory range queries come concurrently. These queries may over-lap in spatio-temporal query regions, as well as ranges of attribute constraints. As illustrated in Figure 3(a), two concurrent queries q and q 2 arrive concurrently and overlap with each other in the spatio-temporal space.
 A naive method for handling concurrent queries is to perform RIS algorithm individually for each query. However, by reusing the samples obtained in the overlapping space among queries, the estimation accuracy can be significantly improved. In this sec-tion, we extend RIS algorithm to concurrent random index sam-pling (CRIS) algorithm, that performs stratified sampling and sam-ple reuse on concurrent trajectory aggregate queries. Our theoreti-cal results show that CRIS algorithm can achieve higher estimation accuracy for each concurrent trajectory aggregate query, with less sampling budget than simply running RIS algorithm for each query. Below, we first formally define the problem of concurrent overlap-ping queries, and then present our CRIS algorithm.
Two queries q 1 and q 2 are concurrent, if the database system pro-cesses them at the same time (i.e., they arrive at the database system or are dispatched from a query buffer at the same moment). Their spatio-temporal query regions may overlap, as well as ranges of tra-jectory attributes, such as average speed, trajectory length, etc. In the rest of the paper, we will use concurrent overlapping queries to represent concurrent queries with overlapping spatio-temporal con-straints. Figure 3(a) shows an example of two concurrent overlap-ping queries. Now, we formally define the problem of concurrent overlapping queries as follows.

Concurrent overlapping queries. Given M &gt; 1 concur-rent overlapping queries, Q = { q 1 ,  X  X  X  ,q M } , with required es-timation accuracy guarantees i &gt; 0 and 0 &lt;  X  i  X  1 for i  X  X  1 ,  X  X  X  ,M } . The goal is to provide estimations to the numbers of trajectories, N q 1 ,  X  X  X  ,N q M , with guaranteed confidence inter-to reuse the index leaf nodes sampled from overlapping regions of concurrent queries and improve the estimation accuracy over that of running RIS algorithm on each individual query.

Concurrent random index sampling. We propose CRIS al-gorithm to deal with concurrent overlapping queries. Given M concurrent trajectory aggregate queries, Q = { q 1 ,  X  X  X  ,q q 0 = q 1  X  X  X  X  X  q M be the entire spatio-temporal region Q cov-ers. Different from RIS algorithm, the basic idea behind CRIS al-gorithm is that we first divide q 0 into M 0  X  M non-overlapping all queries q i  X  X  ( 1  X  i  X  M ). Each q 0 j corresponds to an intersec-tion of a subset of queries Q j  X  Q . Then, CRIS samples index leaf nodes from the leaf node set R 0 j of each q 0 j with sampling budget B j ( 1  X  j  X  M 0 ), where B 0 j is porportionally allocated with re-spect to the number of index leaf nodes in q 0 j . Eventually, for each region q 0 j , CRIS algorithm collects B 0 j index leaf nodes, denoted as  X  R j = { leaf nodes are exhaustively searched for trajectories matching the attribute constraints of queries in Q . We prove that such design of CRIS reduces the estimation variance and the needed sampling budget over that of running RIS algorithm independently on each query q i . Now, we use two concurrent overlapping queries to show how CRIS algorithm works. Given two concurrent overlapping queries, q and q 2 as shown in Figure 3(a). The goal is to provide estima-tions to the numbers of distinct trajectories, N q 1 guaranteed estimation confidence interval, Pr ( |  X  N q )  X   X  1 and Pr ( |  X  N q 2  X  N q 2 | &gt; 2 )  X   X  2 . CRIS algorithm consists of three stages as follows.
 Stratification Stage. The entire spatio-temporal space, defined as q 0 = q 1  X  q 2 is divided into three non-overlapping queries, i.e., Q 0 = { q 0 1 ,q 0 2 ,q 0 3 } , such that q 0 3 := q 1  X  q 2 q  X  q 3 . Moreover, we denote R 0 1 , R 0 2 , and R 0 3 as the corresponding non-overlapping leaf node sets, as illustrated in Figure 3(b). Hence, q (resp. q 2 ) is divided into two strata, i.e., q 1 = q 0 1 q Sampling Stage. Based on Theorem 3, there exist lower bounds B 1 and B 2 on sampling budgets for q 1 and q 2 to guarantee the esti-mation accuracy, defined by 1 , 2 ,  X  1 , and  X  2 . Then, each stratum q is sampled individually with a sampling budget B 0 j proportional to n 0 j as Then, three sample sets, i.e., {  X  R q drawn uniformly at random from leaf node sets R 0 1 , R 0 respectively (See Figure 3(c)).
 Estimating Stage. The three sample sets are observations used to estimate N q 1 and N q 2 . By similar proof for Theorem 2,  X  N 2 in Equation (5) and Equation (6) are proven to be the asymp-totically unbiased estimators of N q 1 and N q 2 .  X   X 
In next subsection, we prove that for two concurrent overlapping queries, CRIS algorithm outperforms RIS algorithm with smaller estimation variance and less sampling budget.
Given concurrent queries Q = { q 1 ,  X  X  X  ,q M } , the entire spatio-temporal region of those queries is denoted as q 0 =  X  q  X  Q partitions q 0 into non-overlapping spatio-temporal regions, so each region represents an intersection of a unique subset of queries in Q . Taking the partition as stratification for concurrent queries, we randomly sample index leaf nodes from each region, and reuse the samples to estimate the answers of queries that cover that region. Below we elaborate the details of stratifying q 0 and performing sampling and estimations. The detailed CRIS algorithm is sum-marized in Algorithm 1.

Stratification. We divide q 0 into M 0  X  M non-overlapping queries by the boundaries of q i  X  X , i.e., Q 0 = { q 0 1 ,  X  X  X  ,q that q 0 =  X  q 0  X  Q 0 q 0 holds. Let Q j  X  Q be a subset of Q with the size as 1  X  | Q j |  X  M , and  X  Q j = Q  X  Q j be the complementary set of Q j with the size as |  X  Q j | = M  X  X  Q j | . Each q  X  0  X   X  Q j q 0 with 1  X  j  X  M 0 corresponds to a region that only covers the intersection of all regions in Q j , but not any region in  X  Q , as shown in Figure 3(a). Denote the index leaf node set of q as R 0 j with n 0 j index leaf nodes. R 0 j  X  X  are non-overlapping with each other. Let Q 0 i  X  Q 0 with 1  X  i  X  M be a subset of Q into strata, i.e., Q 0 i , which enables us to perform sampling on each q . Note that every index leaf node in the population is assigned to only one stratum and no index leaf node can be excluded. Algorithm 1 Concurrent random index sampling (CRIS) algorithm 5: Keep the non-overlapping region set Q 0 = { q 0 1 ,  X  X  X  ,q 6: Generate non-overlapping leaf node sets {R 0 1 ,  X  X  X  , R
Sampling on strata. From Theorem 3, the estimation accuracy requirement i and  X  i , with 1  X  i  X  M , determines the sam-pling budget B i needed for each q i . Then, the leaf node set R of the stratum q 0 j is sampled independently with a sampling budget B j  X  n 0 j , namely, proportionate allocation is employed to ensure that the sampling budget fraction in each stratum q 0 i is proportional to n 0 j . To be precise, for each query q i , stratum q 0 samples from q 0 j repeatedly for each q i  X  Q j , with a total budget of  X  B samples from q 0 j and allow sample reuse when performing estima-tions for different q i  X  Q j . Obviously, B 0 j &lt;  X  B
Estimator Design. After the sampling process, a total of M sample sets are drawn randomly from leaf node sets R 0 1 ,  X  X  X  , R They are expressed as These sample sets are observations for estimating N q 1 ,  X  X  X  ,N Below we first present the asymptotically unbiased estimator of N i in Theorem 4. Then, we discuss the corresponding estimation accuracy.

T HEOREM 4. Using CRIS algorithm,  X  N q i in Equation (7) is the asymptotically unbiased estimator of N q i .
P ROOF . Since each  X  R q the same population space R 0 j , f q i (  X  R q independent and follow the same distribution. Thus, they have the same expectation as E [ f q i (  X  R q the linearity of the expectation, we prove E [  X  N q i ] = N 1  X  i  X  M .
 Performance comparison to RIS algorithm.
 T HEOREM 5. For M &gt; 1 concurrent overlapping queries, CRIS algorithm achieves lower estimation variance with less sam-pling budget than RIS algorithm.

P ROOF . Consider M concurrent overlapping queries Q = { q 1 ,  X  X  X  ,q M } , with accuracy requirements i &gt; 0 and 0 &lt;  X  1 , i  X  { 1 ,  X  X  X  ,M } . Below, we prove (1) CRIS requires less num-ber of samples than individually applying RIS; (2) for the estima-tion accuracy of each query q  X  Q , CRIS always outperforms RIS. (1) Sampling budget. By Theorem 3, the sampling budgets B ,  X  X  X  ,B M of M queries in Q can be obtained. With sample reuse, the total budget spent using CRIS algorithm P (2) Estimation accuracy. Given a query q  X  Q , CRIS divides q into M q  X  1 non-overlapping spatio-temporal regions (strata), q with 1  X  j  X  M q , with each q 0 j covering n 0 j index leaf nodes. Denote R q and R 0 j as the index leaf node sets of q and q tively. We now prove that given the same sampling budget B , the estimation variances (when using RIS and CRIS algorithms) follow V ar [  X  N CRIS q ]  X  V ar [  X  N RIS q ] .

Recall that each sample  X  R q t  X  X  q is drawn uniformly at random from R q . Hence, for RIS, each random variable f q (  X  R the same distribution with the expectation  X  = E [ f q (  X  variance as V ar [ f q (  X  R q t )] = 1 n P n i =1 ( f q variance of the estimator  X  N RIS q (Equation (1)) is computed as V ar [  X  N RIS q ] = V ar hand, the variance of  X  N CRIS q (Equation (7)) can be written as V ar [  X  N CRIS q ] = n From the above two variances, we obtain V ar [  X  N RIS q ]  X  V ar [  X  N CRIS q ] = n Hence, we proved that CRIS always acheives a lower estimation variance than RIS. In this section, we conduct extensive experiments to evaluate our RIS and CRIS algorithms in a large-scale user trajectory dataset from a leading cellular network service provider in China. We first introduce our dataset and configurations of the spatio-temporal database system. Then, we provide comprehensive comparison re-sults between our RIS and CRIS algorithms and E xhaustive S earch (ES) method. The evaluation results demonstrate that RIS and CRIS algorithms can reduce the query processing time by two or-ders of magnitude, while preserving a relative error ratio lower than 10%, with only 1% search cost of ES method.
The trajectory dataset is a collection of mobile broadband (MBB) data in a large city in eastern China, with an urban area of about 400 square miles and three million people. The dataset was col-lected for eight days at the end of 2010, and it represents trajecto-ries of 109,914 3G users. When a user X  X  3G service is enabled, the 3G device periodically reports its location by probing the nearby base stations. Moreover, once a user is using 3G data service, e.g., browsing websites or playing online games, the data exchanged with 3G network are also recorded 3 . We consider each user as a single trajectory. Each record in our database is represented as a spatio-temporal point of a user, where in total more than 400 mil-lion ( 407 , 040 , 083 ) records were obtained. Each record has four core attributes including trajectory ID , longitude , latitude and time . For each user (trajectory), there are eighty-two attributes associ-ated, including the number of spatio-temporal points, time duration (seconds), spatial range (in square miles), activity frequency (num-ber of points per hour), trajectory length (in miles), average speed, total data usage (in Bytes), etc. Figure 4 shows the trajectory distri-butions over four attributes. In the experiments, we consider a tra-jectory aggregate query returning the number of distinct trajectories in a spatio-temporal query range, with certain attribute constraints. The dataset takes 3 TB storage space in the database system. The underlying spatio-temporal data storage system is based on Clost [29] and the query system is built on top of Spark [35], a MapReduce-like in-memory cluster computing system. The system runs on a cluster with three machines. Each machine has 24 Intel X5670 2.93GHz processors and 94GB memory. All machines run on Suse Linux Enterprise Server 11. Hadoop 0.20.2-cdh3u6 and Spark-0.7.3 are selected as the running platform.
We perform two sets of experiments for single and concurrent trajectory aggregate queries to evaluate the efficiency of RIS and CRIS algorithms, respectively. Note that in a 3G network, a user can be located without users X  GPS service enabled, since 3G network can locate a user by the signal strength between the device and the nearby base stations.
In the experiments, we set the side length of the trajectory aggre-gate queries as 18 miles, and temporal range as all eight days, and uniformly at random generate 500 trajectory aggregate queries with the same query range size. We use Quad-tree and B-tree to index the trajectory data with different granularities, i.e., dividing the data into n = 6 , 889 (7k), n = 13 , 410 (13k), n = 23 , 481 (23k) index leaf nodes, respectively. For each granularity, we perform ES and RIS to estimate the total number of distinct trajectories, where we change the sampling budget ratio a = B/n from 0.1% to 25.6%, i.e., the ratio between the number of sampled index leaf nodes and the total number of leaf nodes. Given a randomly generated query, we perform RIS sampling and estimation 200 times for each sam-pling budget ratio.
 To evaluate the estimation accuracy of random index sampling, Figure 5(a) shows the normalized mean square error (NMSE) between our estimation results using RIS and the ground truth. NMSE [26] is a normalized measure of the dispersion of the es-timates, defined as From Equation (8), an estimation with NMSE larger than 1 is not acceptable. From Figure 5(a), we observe that as the sampling bud-get increases, the average NMSE decreases quickly. For the same sampling budget ratio, smaller index leaf nodes (i.e., with larger n ) lead to smaller NMSE, because smaller index leaf nodes lead to smaller variances of the number of distinct trajectories among in-dex leaf nodes. Define the relative error ratio of an estimation as the normalized difference from the ground-truth, i.e., b = (  X  Figure 5(b) shows the box plot of the relative error ratios. For each sampling budget ratio, three boxes are drawn for different granu-larities. Box plots display differences between populations, where the spacing between the different parts of the box helps indicate the degree of dispersion (spread) and skewness in the data, and identify outliers. The bottom and top of the box are always the first and third quartiles, and the band inside the box is always the second quar-tile (the median). The lowest datum is still within 1.5 interquartile range (IQR) of the lower quartile, and the highest datum is still within 1.5 IQR of the upper quartile [10]. Any data not included between the whiskers should be plotted as an outlier with a marker  X  +  X . We observe that the estimation converges to the ground truth as the sampling budget increases. Note that when the sampling bud-get ratio reaches 1%, the estimation error ratios become lower than 10%. Moreover, the dispersion of the estimated numbers validates the unbiasedness of the designed estimator (Equation (1)).
To evaluate the time efficiency of our RIS algorithm, Figure 5(c) shows the processing time of using ES and RIS. When ES is used, the processing time is more than 110 seconds (with a slight differ-ence for different granularities), where RIS only needs on average 2 to 17 seconds, with two orders of magnitude time reduction. The total time reduction ratio is defined as a ratio of the reduced pro-cessing time to ES X  X  processing time . Figure 5(d) shows the to-tal time reduction ratio of RIS, which indicates the power of RIS, namely, a reduction ratio from 85% to 98%.
To evaluate the performance of CRIS, we randomly generate concurrent queries and compare the time-efficiency and estimation accuracy with RIS and ES algorithms. Our results demonstrate that CRIS improves the performance significantly over that of ES and running RIS independently.

We generate three concurrent queries { q 1 ,q 2 ,q 3 } for 500 times with the following configuration. The spatial side lengths of q and q 3 are 18 miles, 15 miles, and 12 miles, respectively. In time dimension, they all span for four days, i.e., from day 1 to day 4 for q 1 , from day 3 to day 6 for q 2 , and from day 5 to day 8 for q We only consider a single index granularity as n = 23 , 481 (23k) index leaf nodes using Quad-tree and B-tree. To answer q and q 3 , we perform ES, RIS, and CRIS, with the sampling budget ratio a = B/N varying from 0.1% to 25.6%, and compare their performance, in terms of the estimation accuracy, processing time, and time reduction ratio. Again, given three randomly generated concurrent queries, we run 200 times for RIS and CRIS for each sampling budget ratio.

Figure 6(a) presents the average normalized mean square error (NMSE) of our estimations using RIS and CRIS. CRIS indicates lower NMSE values for all concurrent queries q 1 , q 2 , and q over, as the sampling budget ratio increases, NMSE decreases for both RIS and CRIS. The box plots in Figure 6(b) show the dis-tributions of the relative error ratios for q 1 , q 2 , and q the estimations by both RIS and CRIS algorithms converge to the ground-truth when the sampling budget ratio increases. In addition, given the same sampling budget ratio, CRIS has higher estimation accuracy than that of RIS. When the sampling budget ratio reaches 1%, the estimation error ratios are within 10%.

Moreover, Table 2 provides the numbers of sampled index leaf nodes collected by RIS and CRIS for different sampling budget ra-tios. We observe that CRIS requires much smaller number of sam-ples than RIS by applying the overlapping sample reuse. Thus, the query processing time of CRIS is much smaller than that of RIS. As shown in Figure 6(c), comparing to ES (taking 226 seconds), RIS needs 5 to 26 seconds and CRIS only needs 4 to 17 seconds on average. Hence, CRIS reduces the processing time over RIS (c) Processing time Table 2: Numbers of sampled indices required by RIS vs CRIS. Sample Rate (%) 0.1 0.2 0.4 0.8 1.6 3.2 6.4 12.8 25.6 Samples (RIS) 35 69 139 278 555 1,111 2,221 4,443 8,885
Samples (CRIS) 21 42 84 167 334 669 1,337 2,675 5,350 by 20% to 34.6%. When considering the time reduction rate, Fig-ure 6(d) shows that RIS and CRIS reduce the processing time over exhaustive search by 88% to 97% and 92% to 98%, respectively.
Throughout this paper, we take counting distinct trajectories in a spatio-temporal region as an example of trajectory aggregate queries. Our RIS and CRIS algorithms are in fact generic to other trajectory aggregate queries, such as sum and average. We briefly discuss how our sampling and estimation algorithms can be applied to these queries by adjusting the mapping function on an index leaf node. Due to the limited space, we introduce the unbiased estima-tors and omit the detailed proof and convergence analysis.
Sum. A typical sum aggregation query is  X  X he total length of all trajectories with speed greater than 5 miles per hour in New York City during 2013 X . Let ` r denote the length (in miles) of a trajectory r . Given an index leaf node R q i with 1  X  i  X  n , Theorem 2, it is easy to prove that  X  ` q in Equation (9) is the asymp-totically unbiased estimator of ` q .
Average. An average query is  X  X he average trajectory length of all trajectories with speed greater than 5 miles per hour in New York City during 2013 X . L q = ` q /N q is thus the exact answer, where N q is the number of distinct trajectories with speed greater than 5 miles per hour in New York City during 2013. The asymptotically unbiased estimator  X  L q is presented in Equation (10), which can be proven by the ratio form of the law of large numbers (Theorem 17.2.1 on p.426 in [22]).
Large-scale trajectory data create challenges in processing tra-jectory aggregate queries with stringent response-time constraints. Exhaustively brute-forcing the query space to get an exact an-swer is usually too time-consuming. Given a well-indexed trajec-tory database, in this paper, we develop random index sampling (RIS) algorithm that randomly samples a small number of index leaf nodes and the associated trajectories to estimate the answer to the trajectory aggregate query, with guaranteed estimation er-ror bounds. Moreover, for concurrent trajectory aggregate queries with overlapping spatio-temporal query regions, we design concur-rent random index sampling (CRIS) algorithm using stratified sam-pling and overlapping sample reuse that achieves higher estimation accuracy with less sampling budgets than that of using RIS algo-rithm independently. We evaluated our RIS and CRIS algorithms using a large-scale user trajectory dataset (with 3TB data) collected from a cellular service provider in China. Our extensive evaluation results show that RIS and CRIS algorithms outperform the exhaus-tive search algorithm for single and concurrent trajectory aggregate queries by two orders of magnitude in terms of processing time, while preserving a relative error ratio lower than 10%, with only 1% search cost of the exhaustive search algorithm.
Yanhua Li and Zhi-Li Zhang were supported in part by NSF grants CNS-1117536, CRI-1305237, CNS-1411636, DoD DTRA grant HDTRA1-14-1-0040 and ARO MURI Award W911NF-12-1-0385. Jia Zeng was supported in part by NSFC grants No. 61373092 and 61033013, Natural Science Foundation of the Jiangsu Higher Education Institutions of China No. 12KJA520004, and Collaborative Innovation Center of Novel Software Technol-ogy and Industrialization. [1] J. L. Bentley. Multidimensional binary search trees used for [2] K. Beyer, P. J. Haas, B. Reinwald, Y. Sismanis, and [3] C. B X hm, S. Berchtold, and D. A. Keim. Searching in [4] Y. Cai, K. A. Hua, G. Cao, and T. Xu. Real-time processing [5] V. P. Chakka, A. Everspaugh, and J. M. Patel. Indexing Large (c) Processing time [6] M. Charikar, S. Chaudhuri, R. Motwani, and V. Narasayya. [7] S. Chaudhuri, R. Motwani, and V. Narasayya. Random [8] K. Deng, K. Xie, K. Zheng, and X. Zhou. Trajectory [9] R. A. Finkel and J. L. Bentley. Quad trees a data structure for [10] M. Frigge, D. C. Hoaglin, and B. Iglewicz. Some [11] V. Gaede and O. G X nther. Multidimensional access methods. [12] P. B. Gibbons. Distinct sampling for highly-accurate answers [13] R. H. G X ting, T. Behr, and J. Xu. Efficient k-nearest neighbor [14] P. J. Haas, J. F. Naughton, S. Seshadri, and L. Stokes. [15] Y. Huang, F. Zhu, M. Yuan, K. Deng, Y. Li, B. Ni, W. Dai, [16] H. Jeung, M. L. Yiu, X. Zhou, C. S. Jensen, and H. T. Shen. [17] D. M. Kane, J. Nelson, and D. P. Woodruff. An optimal [18] J.-G. Lee, J. Han, and K.-Y. Whang. Trajectory clustering: A [19] Y. Li, J. Luo, C.-Y. Chow, K.-L. Chan, Y. Ding, and [20] Y. Li, M. Steiner, J. Bao, L. Wang, and T. Zhu. Region [21] Z. Li, B. Ding, J. Han, and R. Kays. Swarm: Mining relaxed [22] S. Meyn and R. L. Tweedie. Markov Chains and Stochastic [23] F. Olken. Random sampling from databases . PhD thesis, [24] D. Pfoser, C. S. Jensen, and Y. Theodoridis. Novel [25] I. Psaroudakis, M. Athanassoulis, and A. Ailamaki. Sharing [26] B. Ribeiro and D. Towsley. Estimating and sampling graphs [27] T. K. Sellis. Multiple-query optimization. ACM TODS , [28] S. Shalev-Shwartz and S. Ben-David. Understanding [29] H. Tan, W. Luo, and L. M. Ni. Clost: a hadoop-based storage [30] Y. Tao and D. Papadias. Efficient historical r-trees. In [31] Y. Tao and D. Papadias. MV3R-Tree: A spatio-temporal [32] C. Xu, Y. Gu, L. Chen, J. Qiao, and G. Yu. Interval reverse [33] J. Yuan, Y. Zheng, L. Zhang, X. Xie, and G. Sun. Where to [34] M. Yuan, K. Deng, J. Zeng, Y. Li, B. Ni, X. He, F. Wang, [35] M. Zaharia, M. Chowdhury, M. J. Franklin, S. Shenker, and [36] Y. Zheng, Y. Liu, J. Yuan, and X. Xie. Urban computing with [37] P. Zhou, D. Zhang, B. Salzberg, G. Cooperman, and [38] J. Zobel, A. Moffat, and K. Ramamohanarao. Inverted files
