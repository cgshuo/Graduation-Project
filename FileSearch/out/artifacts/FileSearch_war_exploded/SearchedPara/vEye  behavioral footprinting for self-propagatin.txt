 Xuxian Jiang  X  Xingquan Zhu Abstract With unprecedented speed, virulence, and sophistication, self-propagating worms remain as one of the most severe threats to information systems and Internet in general. In order to mitigate the threat, efficient mechanisms are needed to accurately profile and detect the worms before or during their outbreaks. Particularly, deriving a worm X  X  unique signatures, or fingerprints, is of the first priority to achieve this goal. One of the most popular approaches is to use content-based signatures, which characterize a worm by extracting its unique information payload. In practice, such content-based signatures, unfortunately, suffer from numerous disadvantages, such as vulnerable to content mutation attacks or not appli-cable for polymorphic worms. In this paper, we propose a new behavioral footprinting (BF) approach that nicely complements the state-of-the-art content-based signature approaches and allows users to detect and profile self-propagating worms from the unique worm behav-ioral perspective. More specifically, our behavioral footprinting method uniquely captures a worm X  X  dynamic infection sequences (e.g., probing, exploitation, and replication) by model-ing each interaction step as a behavior phenotype and denoting a complete infection process as a chained sequence. We argue that a self-propagating worm X  X  inherent behaviors or infec-tion patterns can be detected and characterized by using sequence alignment tools, where patterns shared by the infection sequences will imply the behavioral footprints of the worm. A systematic platform called vEye has been built to validate the proposed design with either  X  X ive X  or historical worms, where a number of real-world infection sequences are used to build worm behavioral footprints. Experimental comparisons with existing content-based fingerprints will demonstrate the uniqueness and effectiveness of the proposed behavior footprints in self-propagating worm detection and profiling.
 Keywords Information systems  X  Network security  X  Worm detection  X  Behavioral footprinting  X  Sequence alignment 1 Introduction Recent development in computer networking and information technologies have made scien-tific institutes, commercial enterprises, and government agencies heavily rely on networked information systems for effective information collection, dissemination, and digestion. What come along with the great benefits of the power of networking are the great challenges of ensuring the reliability and the security of the system such that each components should func-tion properly and malicious entities should be identified and isolated, as soon as possible, such that the damages incurred can be minimized. This general goal leads to two lines of research activities [ 7 , 33 ]: (1) identifying unauthorized network access, commonly referred to as net-work intrusion detection [ 21 , 32 , 38 , 40 ]; and (2) recognizing suspicious information payload While the former has become one of the major concerns for content sensitive information systems, such as financial and government applications, malware detection (such as virus and worm detection) has received a lot of attentions from both academia and industry, due to the severe impact malware may have on the information systems as well as end-users.
As one of the most significant threats of network malware, worms have recently drawn a lot of attentions because of their increased virulence, speed, and sophistication of succes-sive Internet-wide worm outbreaks. For example, it was estimated that CodeRed worms had infected roughly 360,000 hosts within 14 h [ 25 ] while it took Slammer worms 10 min to infect more than 90% of vulnerable hosts or roughly 75,000 hosts [ 24 ]. Additionally, vari-ous types of malicious payloads have been, to some extent, integrated into worms, such as back-doors in CodeRed and MSBlaster worms, mail-relays in SoBig, MyDoom, and NetSky worms, and denial-of-service attack capabilities in MSBlaster and Slapper worms. What X  X  even worse is that worms keep evolving and they are becoming more sophisticated with not only polymorphic or metamorphic content, but also the integration of multiple infection vectors [ 52 ], cross-platform spreading capabilities, as well as built-in support of advanced code-obfuscation techniques or self-protection mechanisms that can thwart or even prevent forensic analysis [ 1 ]. All these  X  X dvances X  render worm detection and profiling a significant challenge for secured networking of information systems.

While worms constantly impose challenges, the pace of worm detection and character-ization have been, unfortunately, lag far behind. For years, the main approaches of worm detection, classification, and mitigation have been advanced slowly [ 18 , 39 ], and state-of-the-art solutions still crucially rely on good worm signatures to ensure the success of the worm detection. Typical intrusion detection systems, including recent honeypots techniques [ 46 ], are deployed in an ad-hoc manner with purposes of (early) detecting new worms. Once the worm is captured, skilled security professionals manually characterize the worm and extract its content fingerprint (in terms of specific payload information the world delivers), an unique or potentially recurring content byte sequence from the worm sample, as the sig-nature. The signature is updated to various anti-virus software or firewall devices to contain subsequent worm infections. Recent systems such as EarlyBird [ 39 ], Autograph [ 18 ], and HoneyComb [ 20 ] make one step further to automatically extract worm content fingerprints by detecting and screening the most-recurring byte sequences or the longest common substring within suspected network traffic. Though such approach has demonstrated success to some extent [ 18 , 20 , 29 , 39 ], several challenges [ 30 , 34 , 48 ] still remain:  X  Content evasion attack. The content fingerprinting approach is susceptible to content- X  Encrypted traffic. Content signatures work well for un- X  X ncrypted X  content. By design,  X  Signature preciseness. The most frequently recurred content blocks within inspected net-
To address the above challenges, more precisely, to capture the dynamic evolving natures of the self-propagating worms, we introduce, in this paper, a behavioral footprinting principle for worm detection. This is considered fundamentally different from the existing content-based worm detection approaches in the sense that our detection is based on the worm behav-ior instead of the payload information a worm delivers. The employment of the behavioral footprinting for worm characterization ensures our solution to complement to the state-of-the-art content-based approaches, such that worms can be detected through two orthogonal dimensions: content and behavior perspectives. To further validate the concepts and assert the effectiveness of the proposed approach, we will address the design and the implementation of a systematic platform vEye for real-world worm detection and profiling. 1 We believe the major contributions of our work are threefold:
Firstly, the proposed behavioral footprinting principle uniquely complements to existing approaches that leverage content-based fingerprints for worm detection and profiling. More specifically, content fingerprinting extracts one or a few static unique byte sequences based on collected worm samples or worm-relevant traffic whereas behavioral footprinting essen-tially captures dynamic inherent infection behavior of worms (e.g., probing, exploitation, and replication). The feasibility of the proposed approach is based on following observa-tions: (1) worm traffic differs from normal traffic in nature. Intended to be self-propagating, a malicious worm misuses or exploits the faulty service(s) in a way which is differentiable from other normal requests; (2) different worms also differ in their ways in selecting faulty service(s), probing target victims, exploiting vulnerabilities, replicating themselves, or car-rying malicious payloads. Experiments with several real-world worms clearly demonstrate the effectiveness of behavioral footprints for worm detection even without performing deep payload analysis, a big advantage over regular content-based approach.
Secondly, we propose a biologically inspired approach to transfer a worm X  X  infection process into a sequence, and then employ sequence alignment algorithm to extract  X  X oot X  infection sequence as the worm-profiling signature. By presenting each step within a worm X  X  infection process as the behavioral phenotype and a complete infection process as a chained sequence, the sequence contains vulnerability-specific exploitations and worm-specific idio-syncrasies in propagation. Moreover, the temporal ordering of behavioral phenotypes reflects the intrinsic dependency of infection steps (Sect. 2 ). With a number of infection sequences, advanced sequence analysis techniques can be used to accurately and robustly extract the worm-specific behavioral footprints. Based on our experience, the footprints of most self-propagating worms can be derived with only several infection sequences. Also shown in Sect. 4.4.3 , the proposed algorithm is capable of combating sophisticated worms which might cloak authentic or even forge behavioral phenotypes.

Thirdly, we present the design and implementation of vEye, which is not only capable of validating the proposed approach on real-world data environments, but also can act as a generic testbed or playground for other worm detection algorithms. vEye has two compo-nents: a honeyfarm-style worm trap network and a virtual worm analysis network. The worm trap network is deployed to capture  X  X ive X  worms while the worm analysis network enables safe experiments with worms, including historical ones. All experiments with encountered real-world worms clearly demonstrate the existence of unique behavioral footprints, which are different from normal requests to corresponding vulnerable services.

The whole manuscript is structured as follows: Sect. 2 describes the proposed behavioral footprinting principle with an focus on why and how it can be used for worm detection and profiling. Section 3 addresses the design and implementation issues of the vEye system. The effectiveness of behavioral footprints is evaluated in Sect. 4 . We discuss possible limitations of the proposed efforts and related challenges in Sect. 5 , and Sect. 6 reviews recent work and re-examines the uniqueness of our approach. Finally, we conclude in Sect. 7 . 2 Behavioral footprinting for worm detection and profiling Different from the existing content-based footprint approaches which investigate information payload for worm identification and profiling, the theme of the proposed behavioral foot-printing is to capture worms through their unique behavioral activities. Such an advocation of the behavioral footprinting raises the following three major concerns.  X  What are worm behavioral footprints?  X  Do such behavioral footprints commonly exist?  X  How to capture and extract such behavioral footprints? We articulate, in this section, our solutions in resolving each of the above concerns. We will first address the notion of the proposed behavioral footprints. Then, we briefly discuss the rationale on why behavioral footprints can be used for worm detection and profiling. Later, we propose an advanced behavioral footprint extraction algorithm. 2.1 Behavioral footprints 2.1.1 Staged view of infection In short, the propagation of worms from a worm-infected node to an innocent node can be broken down into three common phases [ 22 , 23 , 35 , 43 , 52 ](Fig. 1 ):
Phase-I: Target selection and probing . Through simple strategies like random or biased address scanning, a worm node during attempts to pick up a victim for infection. An ICMP echo request packet or a TCP SYN probe has been observed to be used for testing the  X  X ive-ness X  of a chosen target. Additional packets might be used to check the existence of a certain vulnerable service.

Phase-II: Exploitation . Once the worm node discovers a particular vulnerability in the victim node, it sends exploitation packet(s). 2 Successful exploitation results in the execution of a specifically crafted code carried within the exploitation packet(s).

Phase-III: Replication . Due to various constraints imposed by the vulnerability for exploi-tation, the initially executed code in a victim is often just a portion of the worm code. But the partial code is usually programmed such that it can contact infecters for downloading the intact worm copy, from which the worm is locally installed and activated in the victim node and is capable of infecting other innocent nodes.

These three phases reflect the relative temporal ordering of interaction steps within a suc-cessful worm infection. It should be noted that the ordering relationship also reflects their intrinsic dependencies: (1) a worm usually will not attempt to exploit a victim if no positive response is received (e.g., a TCP connection can not be established or an ICMP echo reply is not received); and (2) only a successful exploitation can lead to the worm replication. Also note that the worm exploitation traffic is different from the normal traffic as it misuses the faulty services and further leads to additional replication activities, which should not even exist within regular traffic.

Figure 2 pictorially demonstrates an example infection of the MSBlaster worm [ 23 ], which is captured by our vEye worm trap network (Sect. 3.1 ) on 28 August 2003. As we can see, a TCP connection handshake on port 135, an interface for the DCOM RPC service in Win-dows-related platforms, is implicitly used by the infecter to check the reachability of the selected target (Phase I). Upon the establishment, the infecter sends malicious code (Phase II) which exploits the known RPC-DCOM vulnerability [ 23 ] and contains a specially crafted shell-code. A successful execution of the shell-code binds a shell service on TCP port 4444, which is immediately connected by the infecter (Phase-III) to send instructions on how to download the worm replica, i.e., msblast.exe . From the Fig. 2 ,wecannoticethat tftp protocol is leveraged for worm downloading. If the exploitation in Phase-II is not successful, the shell on 4444 / TCP will not be remotely activated to receive the worm replica. Also note that such activity on 4444 / TCP and the ensuing tftp transmission certainly should not exist within the normal access to the DCOM-RPC service. 2.1.2 Behavioral phenotype and footprint representation If we denote the steps exhibited in the staged view as worm behavioral phenotypes 3 and a complete infection process as a chained sequence of behavioral phenotypes, such sequence contains worm-intrinsic footprints which are manifested during one infection. Certain char-acteristics of the worm (e.g., abused vulnerability, working exploitation, and adopted prop-agation mechanism) are inherently embedded within it.

Our worm behavioral footprint extraction algorithm is motivated by sequence analysis techniques, which have been extensively applied in Bioinformatics. A common and impor-nucleotide DNA and/or protein sequences to find certain pattern(s)( X  X otif X ), i.e., specific combinations of the sequence letter, commonly exist in most underlying sequences. Each DNA sequence consists of four alphabet letters, whereas a protein sequence consists of 20 different amino acids, i.e. 20 alphabet letters. Similarly, if we can consider each possible behavioral phenotypes during the worm infection as an alphabet letter, the worm footprint exposed by an infection process of MSBlaster worms can be represented as follow: The letters in the above footprint denote either TCP flows with different control bits (S, A, R) or UDP/ICMP flows (U/I). The subscripts denote different flows. For example, or  X   X 
S A 2 4 represents the second step (SYN and ACK bits set) in a normal 3-way TCP hand-shaking procedure. Without ambiguity, a unique subsequence can be further shortened as a single character. For example, a TCP 3-way handshake sequence (e.g., S i previous sequence) could be simply defined as C i (more in Sect. 4 ).

We point out that each character in the alphabet set is a conceptual-level notation and its main purpose is to capture the uniqueness of a particular worm-related packet with a tuple of a number of fields. For example, considering the scenario where we have a log file with a complete worm infection session. If we alternatively present the worm infection sequence as an array LOG [ n ] ,where n denotes the number of packets in the infection session, we can simply use LOG [ i ] as an alphabet letter representing the i th packet in the infection session. Such notation is sufficient in presenting all packets in the worm infection session. In other words, even for a new behavior exhibited in the j th packet that may not be met before, we can always use the general notation LOG [ j ] to represent it.

In addition, each alphabet letter is considered sound in the sense that it represents a tuple with a number of fields and each field is used to capture one unique meaningful aspect of the related worm packet. In the above example, every character is a tuple of several fields: the char-acter representing a specific TCP flow has four fields &lt; TCP , source _ port , dest _ port , TCP tions, the source ports (e.g., the port 4581, 4599, 1552 in S 1 , S 2 , vary with different infection processes while the destination ports are usually fixed (e.g., the port 135, 4444, 69 in S 1 , S 2 , source port number) in every initial flow is usually included in the final footprints. 5
For each character, the number of fields might not be fixed and could be extended to contain other meaningful information such as the packet length or relative timing from the previous one (more in Sect. 5 ). Similar to the situation where different content fingerprints may be chosen by different researchers for the same worm, different behavioral footprints worm by different researchers due to different understandings or purposes. Based on our experience, current selection of fields is able to accurately characterize most encountered worms. For example, the previous abstracted flow sequence precisely captures the tempo-rally ordered infection process of MSBlaster worms: initially, a TCP connection is made to the 135 / TCP port on the victim and the exploitation code is sent over to create a listening shell on 4444 / TCP , which is instructed to transfer a copy of worm using tftp . Finally, these connections are shutdown and the infection process is complete.

Figure 2 further suggests that worm traffic differs from normal traffic significantly, which indicates a low false positive rate if worm-characterizing footprints were identified. More-over, based on (1) the consequence of a successful worm infection that switches the victim from operating as a server to behave as a client and send outgoing infection traffic, and (2) the fact that different worms usually differ in the target faulty services, exploitation means, replication idiosyncrasies, and payloads, we argue that these behavioral footprints could be leveraged as the worm-characterizing signature. Note that behavioral footprints are differ-ent from content fingerprints because they are not affected by actual packet payloads where content signatures are extracted. The advantage of not relying on the deep payload content analysis provides desirable features such as the robustness to content-based mutation attacks (Sect. 4.4.1 ) and the applicability to worms whose traffic is covered by advanced encryption schemes (Sect. 4.4.2 ). 2.2 Advanced footprint analysis The above transformation denotes a worm infection process as a set of sequences, the chal-lenge remaining is to devise a robust algorithm to extract footprints of advanced worms which might cloak authentic or even forge behavioral phenotypes (e.g., arbitrary insertion of irrel-evant phenotypes or functionally equivalent mutation of relevant ones). In this subsection, we propose an algorithm to combat these worms. Our algorithm operates over a collection of infection sequences caused by the same worm. 6 A pairwise comparison is firstly performed to derive their relative similarities with each other. Based on their similarities, a phylogenetic tree is built to guide the final stage of multiple sequence alignment to expose and extract the most fundamental or  X  X oot X  footprints. 2.2.1 Pairwise comparison Given two sequences F 1 = x 1 x 2  X  X  X  x n and F 2 = y 1 y 2  X  X  X  y m , a pairwise comparison or alignment algorithm is primarily used to align these two sequences. Based on a pre-defined scoring matrix (e.g., a match yields 1 while a mismatch yields 0), the alignment algorithm inserts gaps, if necessary, to achieve maximum alignment of the two sequences. The maxi-penalty, p ). The similarity and gap penalty are defined as a part of the scoring matrix and might be specific to applicable scenarios. A global alignment scheme obtains the optimal global alignment between two sequences while a local alignment scheme looks for the best alignment between subsequences of them. There are two corresponding well-known dynami-cal programming algorithms, i.e., Needleman X  X unsch algorithm [ 10 ] and Smith X  X aterman algorithm [ 10 ]. In our scheme, the Needleman X  X unsch algorithm is primarily used to achieve optimal global alignment among multiple sequences (Sect. 2.2.3 ) while the Smith X  X aterman algorithm is applied to obtain optimal local alignment between a pair of sequences.
The idea in Needleman X  X unsch algorithm is to build up an optimal alignment using pre-vious solutions or optimal alignments of smaller subsequences. A matrix M , indexed by i and j with one index for each sequence, is iteratively constructed. The cell M ( i , j ) is the score of the best alignment between the initial segment x 1 x 2  X  X  X  x i ofxupto x i and the initial Then, the matrix is iteratively filled from top left to bottom right based on Eq. ( 1 ).
Each case represents an option how current M ( i , j ) cell is derived from one of the other most bottom right cell is calculated, the choices taken at each cell starting from the most bottom right one are traced back so that a optimal global alignment is derived. One example alignment applying Needleman X  X unsch algorithm is shown in Fig. 3 .

Smith X  X aterman algorithm works similarly except that Eq. ( 1 ) is modified for local align-ment purpose. Particularly, one more case is added to reflect the possibility starting a new ative calculation of Eq. ( 1 ). The traceback is not performed from the most bottom right cell, but from the cell with the maximum value. 7
If we associate a metric (e.g., number of matches) to the best alignment between sub-sequences of F 1 and F 2 , the metric can be used to indicate the similarity among the two sequences. As such, Smith X  X aterman alignment is used in the following as a scoring mech-anism to build the relevant phylogenetic tree from a number of infection sequences. 2.2.2 Phylogenetic tree construction A phylogenetic tree is originally proposed to depict the evolutionary relationships of a group of life organisms. Here we are building the phylogenetic tree to extract the most funda-mental footprint subsequences that are embedded within a number of related sequences F k , k = 1  X  X  X  n . Some of the sequences might be explicitly mutated by inserting irrelevant subse-quences or replacing some subsequence with another functionally equivalent string. A classic algorithm called UPGMA [ 10 ] has been applied to construct such a tree. Within the algo-rithm, each sequence F k is initially considered as a cluster C k . These clusters are iteratively grouped within the most related one so that, eventually, there is only one cluster left. The relatedness or similarity between two clusters C i and C j is defined as d ij : where C i and C j denote the number of sequences in clusters C i and C j .Thevalueof d pq is derived based on the Smith X  X aterman scoring algorithm. The clustering algorithm is further described as follows: PhylogeneticTreeConstruction ( F k , k = 1  X  X  X  n ) 1 C  X  X  X ; T  X  X  X  2 for each sequence F i i  X  1 .. n 3 do 4 Assign a cluster C i  X  X  F i } 5 and add it into C  X  C C i 6 Define a leaf N i in T for F i 7 for each any other sequence F j , j  X  i + 1  X  X  X  n 8 do 9 Calculate the similarity between F i and F j 10 d ij  X  Smith-Waterman ( F i , F j ) 11 while C = 1 12 do Determine the two clusters C i and C j 13 s.t. d ij is maximum 14 Define a new cluster C k = C i C j 15 and calculate d kl for all l 16 Remove C i and C j from C , i.e., C  X  C  X  C i  X  C j 17 Add C k to C , i.e., C  X  C C k 18 Add a parent node N k to T with children N i and N j 19 return T
The calculation in d kl in step 15 can be conveniently performed based on following equa-tion:
The time and space complexity of the algorithm is O ( n 2 ) , since there are n  X  1 iterations, with O ( n ) steps in each one. 2.2.3 Multiple sequence alignment The phylogenetic tree is used to categorize the worm footprint sequences and guide the actual alignment of multiple sequences. Within the generated tree T the leaves contain the raw footprint sequences while intermediate nodes represent the sequences of their children nodes. A simple post-order tree traversal algorithm (shown below) can be recursively applied to construct the representative sequences until the root of the tree T is reached. MultipleSequenceAlignment ( T : Phylogeneti cT r ee ) 1 if T = NULL 2 then MultipleSequenceAlignment ( T . lef t ) ; 3 MultipleSequenceAlignment ( T . right ) ; 4 if T . lef t = NULL AND T . right = NULL 5 then T . sequence  X  6 Needleman  X  Wunsch ( T . lef t , T . right ) The actual sequence construction is based on the global alignment alignment, i.e., Needleman X  X unsch algorithm (Sect. 2.2.1 ). An example run of the algorithm is illustrated in Fig. 4 . The sequence shown at the root of the tree is extracted as the characterizing footprint for inspected worms.

Though current algorithm is able to accurately and reliably extract worm footprints (Sect. 4 ), it is possible that other data mining methods [ 10 ], as well as our previous work on sequential pattern mining across multiple sequences [ 60 ] can be applied to extract represen-tative sequence patterns. 3 vEye system design and implementation The above algorithm design provides a unique way to analyze worms based on their behav-ioral footprints. From the system perspective, our remaining challenge is how to build a generic platform for safe collection of real-world worm infection sequences in supporting the above data processing process. In this section, we describe a vEye system, which we built to collect target sequences of either  X  X ive X  or other historical worms. An operational view of vEye is shown in Fig. 5 , which consists of two major components, a distributed worm trap network and a worm analysis network. In the worm trap network, a number of distributed redirectors ( H 1and R 2 in the figure) forward unsolicited traffic heading dark address space to a centralized vEye center, where honeypots. 8 are deployed as normal systems under infec-tion. Once a honeypot is infected, the worm sample could later be safely unleashed within a confined virtual environment to collect more infection sequences. Other historical worms like Lion worms or Slapper worms can also be re-examined through such environment (described in Sect. 4 ). 3.1 Worm trap network The worm trap network is built to capture  X  X ive X  worms and collect their infection sequences. There are two main design rationals.

Rational I: Honeypot services on dark address space: vEye explicitly exploits the exis-tence of  X  X ark address space X  where there is no legitimate communication traffic. Honeypots deployed on these dark address spaces appear as normal systems susceptible to worm infec-tions. Because of suspicious nature of incoming traffic and significantly reduced traffic load, such approach has advantages over regular traffic engineering approach like Autofocus [ 12 ]. We note that dark address space has been leveraged for other different purposes. For example,  X  X etwork Telescope X  [ 27 ] attempts to passively monitor the traffic in dark address space and infer various malicious activities [ 26 ];  X  X nternet motion sensor X  (IMS) [ 3 ] supports limited interaction with incoming traffic for better understanding and monitoring globally scoped threats. Focusing on un-cut behaviors of self-propagating worms, vEye enables full-interac-tion with infecting worms by deploying high-interaction honeypot services on those spare IP addresses. However, due to the associated risks and potentially damaging worm behavior, these honeypots need to be confined within a controllable environment (e.g., VMware [ 51 ] or UML [ 9 ] virtual machines) and the relevant traffic needs to be subjected for additional logging, filtering, and scrubbing. An in-depth analysis of honeypots is not the focus of this paper and interested readers are referred to [ 14 , 36 , 46 ] for details.

Rational II: Off-Site and Distributed Worm Capturing: Though high-interaction honeypots are able to  X  X aturally X  interact with incoming worms, broad visibility needs to be acquired to quickly trap worms. Observing unused IP addresses only at a single site may either miss the early stage of a worm X  X  spread or even possibly avoided by biased address scanning (e.g., local subnet preference in selecting victims for infection). A distributed (e.g., multi-site or even cross-domain) deployment not only enriches the sampling diversity to observe worm X  X  behavior, but also significantly reduces the risks being detected or avoided by smart worms or attackers. However, major challenges include the feasibility and operation overhead of such approach.

More specifically, a naive aggregation scheme with multi-site or cross-domain deploy-ment still hosts in-site attack occurrences, and bears the burden of distributed management. The possible consequence that these in-site honeypots will be taken full control by malicious worms leads to various administration, privacy, and security concerns. Moreover, a distrib-uted deployment and operation of honeypots make it difficult for a judicious and consistent management. vEye enables off-site attack occurrences by creating virtual presences among participating networks while physically hosting corresponding honeypots in the vEye center. By further offering additional mechanisms to mitigate associated risks (e.g., throttling or possibly scrub-bing), vEye is much more viable than the simple aggregation scheme.

The implementation is based on our earlier Collapsar [ 14 ] system, which consists of three major entities: A redirector is deployed within the dark address, intercepts unsolicited traffic, and forwards them via GRE tunneling to a corresponding virtual honeypot within the vEye center. The virtual honeypot is hosted with available VM implementations (VMware [ 51 ] and UML [ 9 ]) to accept these traffic and behave like normal hosts under infection. A trans-parent bridge  X  X its X  in the middle and mediates the traffic between the redirector and virtual honeypot. It can also be used to collect active worm samples and their infection sequences.
There exist two main types of redirectors. A router-based redirector mainly involves con-figuring the router to enable the GRE tunneling for an allocated dark address block. A host-based redirector enables Proxy ARP and forwards the traffic to the vEye center. Within vEye center, regular systems (e.g., RedHat Linux 7.2/8.0 and Windows XP Home Edition) and services (e.g., Apache/IIS, DNS, and Sendmail) are hosted. The bridge component is imple-mented as an UML virtual machine running the bridging software ( http://bridge.sf.net/ ). The outgoing packets is further scrubbed through an open-source in-line Snort prototype, i.e., snort-inline [ 44 ]. 3.2 Worm analysis network Once a worm sample is captured, it needs to be further investigated. Skilled security special-ists usually scrutinize the worm sample content to extract unique static content fingerprints. For our purpose, we need to distill dynamic infection sequences as representative footprints. The worm analysis network is explicitly designed to safely reproduce and collect a num-ber of possibly destructive infection sequences. Leveraging recent advances in virtualization techniques, vEye creates a confined virtual environment (shown as the CVEs in Fig. 5 ) with possibly hundreds of even thousands of vulnerable nodes. The inspected worm is expected to propagate freely within the confined environment without affecting outside innocent hosts. In the following, we describe major aspects in enabling such confined virtual environment.
Full-system virtualization . Worms replicate themselves by remotely exploiting certain vulnerabilities in operating systems or application services without any human interactions. To support real-world worms, the worm analysis network needs to provide a native environ-ment for worms to propagate: (1) the same real-world services are running inside with the same vulnerabilities; and (2) worms use the same attack vectors to probe, infect, and com-promise them. vEye adopts full-system virtualization provided by VMware [ 51 ]andUML [ 9 ] and naturally supports real services (e.g., Apache, Sendmail, or DNS).

Though convenient and efficient than a raw machine, a virtual node based on full-system emulation could still occupy considerable physical resources. For example, a full-system image of Red-Hat 9 . 0 / 7 . 2 requires approximately 1 G / 700 M disk space and a naive scheme running an experiment with 100 such virtual nodes could take at least 100 G / 70 G disk space. Considering the fact that most worms are simply spreading across the same platform via the same remotely exploitable vulnerability, each virtual node can be accordingly optimized to remove unrelated services. For example, an original system image based on Red Hat 7 . 2 can be reduced to an image of 32 M providing the Apache web server, which is exploited by the Linux Slapper worm [ 35 ] in September 2002. As a result, we have successfully experimented it on a hierarchical topology with 1,500 virtual nodes. As shown in Sect. 4 , such scale greatly helps to exhibit a multi-vector worm X  X  polymorphic infection behaviors.

Network virtualization . Self-propagating worms usually contain malicious payloads which should be safely quarantined from reaching other innocent hosts. In order to confine these traffic without unnecessarily restricting the worm experiments, a confined virtual environ-ment is built to have its own IP address space, which is orthogonal to current Internet address assignment. A link-layer communication virtualization mechanism is specially designed to intercept and transport traffic generated from some virtual machine to another. As such, the communication containing damaging worm traffic can be strictly confined within the virtual environment.
 More specifically, the link-layer communication virtualization mechanism is illustrated in Fig. 6 . Each virtual machine will be equipped with at least one virtual NIC device and differ-ent virtual machines communicate with each other through UDP tunneling. Further, virtual switches are created to perform UDP tunneling, which serves as the link-layer  X  X arrier X  of VM traffic. Since a virtual switch runs below the virtual NIC, from the perspective of VMs, the UDP tunnels are the  X  X ables X  (hardware) connecting the VMs and they are untamperable from inside a VM. This design differentiates our technique from other virtual networking techniques [ 42 , 47 ] and is critical to the strict confinement feature of the worm analysis net-work in vEye. Also, the user-level implementation of our network virtualization methods brings significant deployability and topology flexibility. Interested readers are referred to [ 15 ] for more details. 4 Experimental comparisons In this section, we first describe vEye in trapping active worms and analyzing other historical worms. Then, we derive those worms X  behavioral footprints and demonstrate the differences between worms and normal traffic. After that, we present the effectiveness and accuracy of behavioral footprints for worm detection by using a real-world infection trace, along with the comparison with content-based fingerprints. Finally, we examine the robustness of behav-ioral footprints under three different attacks: a content-mutation attack, a traffic-encryption attack, and a behavior-polymorphism attack. 4.1 Trapping and analyzing self-propagating worms We first started the prototype of the worm trap network on February 2003 and an initial deployment without the worm analysis network was implemented on August 2003. Three redirectors are deployed in different Ethernet-based production networks and forward traffic to the vEye worm trap network, which is located in another Ethernet LAN. Interestingly, right after the initial deployment, vEye is able to successfully capture one instance of the MSBlaster worms. Later in August 2004, we implemented the worm analysis network and further provided three more production networks: one local subnet network, one wireless LAN, and one DSL network. The DSL network is located in another administrative domain. The local subnet network with eight IP addresses is located together with the vEye center and there is no need to forward traffic for them. The virtual honeypots in the vEye center run a variety of commodity operating systems, including RedHat Linux 7.2/8.0, Windows XP Home Edition, FreeBSD 4.2, and Solaris 8.0. All of traffic communicating with these honeypots are fully logged through the tcpdump tool.

A number of active worm infections have been successfully captured and recorded. Table 1 contains four representatives and their individual capture dates. Note that due to the limited scale of our current vEye deployment, it is less likely to capture all of Internet worms which are active during the propagation, particularly at the early stage. However, it did happen to capture Sasser worm on the first day (1 May 2004) of outbreak.

With the worm analysis network, we also re-examine other three historical real-world worms (Table 2 ): Ramen worms, Lion worms, and Slapper worms. The Ramen worm is a multi-vector worm, which is able to exploit three different vulnerable services: 9 LPRng (CVE-2000-0917), wu-ftpd (CVE-2000-0573), and rpc.statd (CVE-2000-0666). Each worm is unleashed within an individual virtual environment and the infection processes are col-lected by the tcpdump tool. In next subsection, we describe how behavioral footprints are derived from these collected log files. 4.2 Behavioral footprints extraction With collected tcpdump log files, the first step is to extract flow sequences relevant to worm infections. A tool named sneeze is initially designed for this purpose. Later, it is extended for worm detection with extracted behavioral footprints (Sect. 4.3 ). All TCP/UDP/ICMP flow sequences contained within the log are extracted and additional packet reassembly or re-ordering is also performed, if necessary. These TCP/UDP/ICMP sequences are separated with respect to each address pair and are further ordered based on the associated time-stamp. The duration and payload size of each flow is also calculated by sneeze.

An example output from sneeze is shown in Fig. 7 . The trace input is related to an complete infection process of the Sasser worm, which is captured by the worm trap network of vEye on 1 May 2004.

Note that Sneeze is able to track TCP states when analyzing related TCP flows. Particu-larly, within TCP flows, any TCP control packet with SYN, ACK, FIN, or RST bit turned on are contained within the resulting infection sequence. The TCP data packets (though ACK bit turned on) are usually ignored. However, as discussed in Sect. 5 , additional protocol com-pliance analysis and vulnerability-related information can be applied here to further enrich the accuracy and effectiveness of footprints. Current prototype does not have such support. For UDP and ICMP flows, they are also recorded within the sequence.
 By considering each interaction as the behavioral phenotype, the algorithm described in Sect. 2 is applied on these multiple interaction sequences to extract representative behavioral footprints. Based on the algorithm, the footprints of examined worms are shown in Tables 1 and 2 . 10 The letters in the footprints denote either TCP flows with different control bits or UDP/ICMP flows. However, the same letter in different footprints may have different field contents such as the destination port number.

It is encouraging to note that behavioral footprints can effectively characterize all of these examined worms. Moreover, most footprints can be extracted by just aligning two infection sequences. 11 The footprint of MSBlaster worm has been pictorially shown in Fig 2 .Wel-chia worms 12 are similar to MSBlaster worms except that an initial ICMP probing packet is generated before actual infection and the second TCP connection ( the honeypot with a connect-back shell-code. We show its footprint in Fig. 8 . Enbiei worms exhibit the same footprint with MSBlaster worms though they have different file names and payloads. Sasser worms (shown in Fig. 9 )usethe ftp protocol ( replica and the ftp command uses PORT primitive to initiate another reverse connect-back activity ( C 4 ). It should be noted that all of these behavior should not be exhibited within normal access to corresponding services.

Ta b l e 2 shows the footprints of three historical worms re-examined through the worm anal-ysis network. The Ramen worm is a multi-vector worm, which has three infection vectors (IVs). By simultaneously deploying corresponding vulnerable servers within the same con-fined environment, all of these three different infection sequences can be collected through one experiment. It should be noted that the Ramen worm has a flawed exploitation on the second IV, i.e., wu-ftpd vulnerability (CVE-2000-0573), which could not result in a success infection. The footprints of Ramen worms from different infection vectors are also visualized in Fig. 10 . It is interesting to note that an initial TCP control packet with SYN and FIN bits ( S 1 ) set, source port being 21, and destination port being 21, is used to probe the victim. Other two examined worms, lion worms and Slapper worms, have only one infection vector. Their behavioral footprints are shown in Figs. 11 and 12 , respectively. We will revisit the footprints of Slapper worms in more details in Sect. 4.4 . 4.3 Worm detection with behavioral footprints After the worm footprint extraction, we further apply them to detect potential worm propaga-tion embedded within a full tcpdump trace which is publicly available and downloaded from the Collapsar project [ 14 ], The log is related to the infection of a Windows XP node on 27 November 2004. To demonstrate the uniqueness of the proposed behavioral footprints, we first apply a popular open-source content-based IDS, i.e., Snort, to detect possible intrusions. Then our own tool, named Sneeze, is applied and the results are reported in Fig. 13 . Ta b l e 3 reports the results of Snort. It performs reasonably well in recognizing various RPC DCOM buffer overflow attempts, and reporting lots of alerts for  X  X CMP PING CyberKit 2.2 Windows X , which correspond to the probing traffic from Welchia worms. However, these alerts are distinct alerts even though they might be caused by a single worm infection process. The result from sneeze is shown in Fig. 13 . Sneeze accurately detects all three successful worm propagations and two unsuccessful worm propagations (which are not reported in reports four alerts for  X  X FTP GET X . Based on the sneeze output, one is related to the Enbiei worm, one is related to the MSBlaster worm, and the other two is related to the Welchia worm, which uses one tftp session for file DLLHOST . exe (the worm payload) and another tftp session for SV C H OST . exe (a tftpd daemon).

Based on the comparison, Snort generates alerts for each packet it monitors and does not correlate the relevant alerts into one single attack sequence. In contrast, Sneeze generates the report by inherently combining related events based on the behavioral footprints. Such corre-lation of alerts is due to the inherent temporal ordering among interaction steps represented by the behavioral footprints. 4.4 The robustness investigation Previous subsections clearly show the feasibility and effectiveness of proposed behavioral footprinting approach. In the following, we further examine its robustness against different types of mutation attacks. 4.4.1 A content-mutation attack As mentioned in Sect. 1 , the effectiveness of content fingerprint relies on the condition that the content should remain invariant. However, behavioral footprints do no rely on the actual payload.

In this experiment, we examine the content signature used in Snort to detect Slapper worms. There are two relevant signatures, as shown in Table 4 . To demonstrate its effec-tiveness, a worm analysis network with 100 virtual nodes is instantiated and an instance of Slapper worm is introduced into the environment. A tcpdump trace file containing the infection of Slapper worms is randomly collected.
 The Snort reports two alerts on the log file with the message  X  X ISC OpenSSL Worm Traffic X  and five alerts for  X  X EB-MISC Bad HTTP/1.1 Request X . With a simple muta-tion replacing the string  X  X ERM=xterm X  in the Slapper worm with  X  X ERM=linux X  and  X  X ET/HTTP/1.1 X  the banner grabbing routine with  X  X ET/HTTP/10 X , another virtual envi-ronment with the same node and topology specification is created to experiment the modified Slapper worm. No alert is generated from any collected worm propagation traces. Recent work [ 49 ] has also confirmed the in-effectiveness of content fingerprints under content muta-tion attacks.
However in both cases, sneeze is able to spot the same behavioral sequences of Slap-per worms as summarized in Table 2 : firstly, it opens a normal TCP connection ( C 1 F 1 against port 80 checking the reachability of remote host; Then, it issues an invalid HTTP GET request ( C 2 grab the server banner and query the version of web server; Later on, it further establishes 20 simultaneous plain TCP connections ( 22 i = 3 C i , opened without any payload and never shutdown) on 443 port in order to create two identical fresh processes (e.g., heap layout) in the intended Apache web server to handle ensuing two SSL negotiation connections. The first SSL connection ( C 23 ) exploits the buffer overflow in OpenSSL package to reveal the location of heap, which is placed in the attack buffer of second SSL connection exploita-tion. The second SSL connection ( C 24 ; containing the first content signature used in Snort) re-triggers the buffer overflow with correct heap addresses and causes the overwriting of a GOT entry for free () library call, which is invoked to execute the shell-code. The shell-code searches all open file descriptors corresponding to the second SSL connection and re-uses that file descriptor for sending over the a uuencoded 13 replica of worm source. As such, the port 443, which is commonly used in HTTPS for establishing a secure socket connection, is abused and a simple analysis on the SSL header will immediately reveal anomaly once it is used for worm replica transfer. However, without relying on the protocol anomaly analysis, the footprint shown in Table 2 is already able to accurately detect Slapper worms due to the idiosyncrasies of exploiting the vulnerabilities. 4.4.2 A traffic-encryption attack The previous experiment demonstrates the robustness against an example content mutation attack. In this experiment, we further show its applicability when the whole worm traffic is encrypted. The original Slapper worm is propagated through the transmission of a uuencoded version of the unencrypted worm source code. To encrypt the worm traffic, a new Slapper variant is first instructed to encrypt the worm source file before propagation and then it is instructed to decrypt the file before actually compiling it and executing the generated binary in the infected victim. N -Gram analysis (counting the frequency of n -length combinations of bytes) is performed over two collected infection instances: one is related to the original worm with transfer of unencrypted worm source (shown in Fig. 14 ) and another is based on the trace corresponding to the transfer with encrypted source (shown in Fig. 15 ).
Though N -Gram analysis on the original Slapper worm trace does show several com-mon strings with much higher frequency of occurrence than other strings. However, it is interesting to note that these strings are not adopted as the signature in Snort. Instead, the signature used in Snort  X  X ERM=xterm X  only happens twice within the N -Gram analysis. It confirms our argument in Sect. 1 that most-recurring content blocks are not necessarily suitable for signature purpose. Once the transmission is encrypted, almost every string have equal probability of occurrence. However, The sequence C 1 F 1 exhibits within the infection process, which demonstrates potentially better robustness of behavioral footprinting over content fingerprinting. 4.4.3 A behavior-polymorphism attack Previous two experiments demonstrate the robustness of worm footprints against content-mutation attacks. In this experiment, we further examine the robustness against behavior-polymorphism attacks as, by design, the proposed advanced sequence techniques in Sect. 2.2 take into consideration this type of attack.

Instead of following exactly the sequence shown in its authentic footprint, certain irrele-vant sequences are introduced to avoid the detection. The polymorphic behavior model works as follows: arbitrary number of abnormal or normal connections can be initiated from the infecter to the vulnerable server (not the reverse direction) such as ICMP/TCP/UDP flows between any two steps exhibited within current footprint. However, original sequences, par-ticularly, their temporal orders, are still maintained since we consider they are either inherent for successful exploitation (the preparation of the 20 open TCP connections ensuring the same heap and stack layouts within the two following SSL connections; the preparation of the first SSL connection for reliable exploitation and execution of the shell-code in second SSL connection) or belong to the worm idiosyncrasy (the first two TCP connections probing the reachability and querying the vulnerable Apache server version).

A worm analysis network with 1,500 virtual nodes is constructed and all of successful infection processes are selected for sequence analysis. For readability, Fig. 16 only shows the phylogenetic tree built from collected traces with 20 infection instances. As we can see, the tree construction and multiple sequence algorithm is able to successfully extract the previous sequence:  X  C 1  X  F 1  X  potential gaps inserted due to behavioral polymorphisms. The number in the leaf nodes are the sequence number from 1 to 20. The number in intermediate nodes show internal nor-malized representation ( [ 0 , 1 ] ) measuring similarity based on the Smith-Waterman algorithm (Sect. 2.2.1 ). Lower number means more similar among involved two clusters. The penalty used for each gap through the algorithm is p = X  2 and the scoring matrix used for the Smith X  X aterman is 5 Discussion While the above analysis and experimental comparisons demonstrated a great success of concerns and challenges in regarding the existence and accuracy of footprints. In the fol-lowing, we specifically address the challenges raised by either behavior-polymorphic worms (Sect. 5.1 ) or behavior-camouflaged worms (Sect. 5.2 ). Behavior-polymorphic worms will generate many appearances so that a single footprint is just marginally effective. On the other hand, Behavior-camouflaged worms cloak their footprints within normal traffic so that no defining footprint exists. 5.1 Behavior-polymorphic worms A behavioral-polymorphic worm could have different appearances in exposed infection sequences. Based on the number of vulnerabilities exploited for worm propagation, this type of worm is categorized as single-vector worms as well as multi-vector worms.
A single-vector worm only exploits a single infection vector. Even though polymorphic behaviors can be introduced, certain behavioral invariants will still be exhibited due to the restriction of a specific vulnerability on its successful exploitation. One example is related to the OpenSSL heap-based buffer overflow exploited by the Slapper worm. As described in [ 35 ], the overflow is used twice by the worm to achieve reliable infection. The first OpenS-SL exploitation only attempts to locate the over-writable heap address within the vulner-first exploitation, the acquired heap address is patched in the attack buffer within the sec-ond OpenSSL exploitation. It is expected that this two-phase exploitation enables a reliable infection. However, it has one more pre-condition that the two Apache processes handling these two exploitation connections should have the same heap layout. To guarantee that, the worm first exhausts the Apache X  X  pool of servers before actual exploitation. The exhaustion is achieved by opening a succession of 20 connections 14 so that two fresh Apache processes can be spawned to handle the two exploitation connections. As such, a reliable Slapper worm infection using the single vector requires a series of resource-exhausting TCP connections and two additional exploitations. Moreover, these behavioral invariants will be essentially reflected as an invariant subsequence in the final footprints. We examined one such example in Sect. 4.4.3 .

A multi-vector worm is able to propagate by exploiting multiple different vulnerabilities which might make the footprinting approach much more challenging. However, notice that a worm usually has only a limited number of infection vectors: Ramen worms have three infection vectors and Welchia worms only have two infection vectors. Also if re-examined from the clustering algorithm (Sect. 2.2.2 ) which builds a phylogenetic tree, the tree will expose multiple sub-trees each of which corresponds to a sub-worm propagating with only one infection vector. In fact, if we decompose the multi-vector worm as the combination of several different sub-worms and each sub-worm has only one infection vector, the footprints for the multi-vector worm would be a combination of each individual sub-worm footprint. One such example was illustrated in Sect. 4.2 .

Another variant of a multi-vector worm is the upgradeable worm which is able to upgrade itself with new or potential unknown infection vectors. This type of worm essentially spawns an arms race between network defenders and attackers. As such, there exists a time window of vulnerability for new footprint extraction. However, this is true for any general signature-based approach. 5.2 Behavior-camouflaged worms Based on the number of (TCP/UDP/ICMP) flows necessary for a worm infection, this type of worm can be similarly categorized into single-flow worms and multi-flow worms.
A single-flow worm [ 24 , 25 ] represents the (possibly minority but the most hyper-spread-ing) type of worm which requires a single TCP connection [ 25 ] or a single UDP packet [ 24 ] for a successful propagation. The proposed algorithm is not capable of accurately character-izing the worm because there is only one flow and the flow itself is not able to be differentiated from other regular flows. However, if we study the vulnerability exploited to propagate such worm or perform additional protocol anomaly analysis on exploited service(s), the infor-mation critical for discerning worm flows from other regular flows is readily available. For example, with respect to the vulnerability in MS SQL servers which are exploited by the Slammer worm, a single UDP packet with destination port 1434, packet type 4, and size larger than 60 bytes 15 is able to trigger the buffer overflow. The extensible nature in adding additional fields to form a refined sequence provides great convenience in integrating such information.

A multi-flow worm needs several steps for a successful infection and each step is dis-guised as a normal traffic flow [ 19 ]. However, consider again the restrictions imposed by the vulnerability for a successful exploitation, certain behavioral invariants will be exhibited for a successful infection. Using the previous MS SQL vulnerability as a example, the exploita-tion must exhibit a UDP packet on port 1434 with type 4 and packet size of larger than 60 bytes. More interestingly, as demonstrated in Shield [ 53 ] and worm vaccine [ 2 ], such exploi-tation process can be further precisely modeled as a state machine to capture the exploitation attempt. Also considering the fundamental behavioral turn-over of infected victim nodes, enhanced behavioral footprints can still accurately detect this type of worm.

Therefore, refining representative sequences with extensible fields can improve the accu-racy of worm footprints. However, over-refinement might result in unnecessary false neg-atives or false positives. For example, a strict sequence with additional fields stating the Slammer worm with UDP packet type 4 and size of 376 bytes might give better accuracy in identifying the worm infection. In the meantime, it might be avoided by simply adding one more garbage byte during the infection. A relaxed sequence without any additional field might result in high false positive rate. Similar to current practice in selecting and verifying suitable content signatures by highly-skilled professionals, we argue that the extraction of behavioral footprints also requires comparable security expertise and a rigorous selection and verification procedure. Encouragingly, our experience does show that most real-world worms would rather easily expose their behavioral footprints. With its own great potential and without the need for a costly deep payload analysis, the behavioral footprinting approach warrants further exploration. 6 Related work The problem of worm detection was largely addressed by two types of approaches: anomaly niques to identify abnormal data points which render themselves significantly from others; whereas the latter depends on identified worm signature to assess and discover data entities and activities similar to the predefined signatures. Generally, the former approaches suffer from high false positive rate in worm detection, and because they are not proposed to accu-rately characterize infecting worms, we will not discuss anomaly detection-related work here. Interested readers may refer to related literatures [ 16 , 54 ] for details.

In the following subsections, we mainly examine related work on worm profiling and detection as well as worm capture and analysis. 6.1 Worm profiling and detection Worms can be characterized through worm-inherent signatures. There exist different signa-ture schemes with different accuracy and complexity. In the following, we examine from different perspectives: content-based fingerprints, vulnerability-specific signatures, and traf-fic-based worm profiling and detection.

Content-based fingerprints . Among various signature schemes, content-based signature is the most widely adopted due to its relative accuracy and simplicity. Once a worm sample is collected, an unique or potentially recurring content byte sequence within worm-relevant files or traffic is extracted as the signature. It is largely a manual process which could potentially take considerable time like several weeks to extract and evaluate a signature.

A number of automated approaches are proposed to alleviate this burden and minimize the time for extracting a signature. An early work by Kephart and Arnold [ 17 ] is to extract signatures for general viruses by allowing them to infect known  X  X ecoy X  programs in a con-trolled environment. A variety of heuristics are proposed to identify invariant code strings among the infected regions of the decoy based on the input of a number of infection instances. However, it requires the existence of a controlled environment to monitor a known instance of a virus and focuses on the infection of local programs not remote nodes.

Recent systems like EarlyBird [ 39 ], Autograph [ 18 ], and HoneyComb [ 20 ] are also pro-posed to automatically extract the most-recurring byte sequences or the longest common substrings within sampled or possible pre-filtered network traffic. Such byte sequences or substrings are considered as the content fingerprints of worms. As shown in Sect. 4 ,most-recurring byte sequences in the worm traffic are not necessarily suitable as worm signatures and they are also vulnerable to various mutation attacks [ 49 ]. This paper proposes another dimension, i.e., behavioral footprinting, for worm detection and characterization. Unlike the content-based fingerprinting, behavior-based footprinting correctly captures the whole infection process which is unique to the propagation of a particular worm and can not be reflected by the content signature scheme. Paralleling our work, another different behav-ior-based approach [ 11 ] is also proposed. However, it focuses on the tree-like propagation among infected nodes and examines similar payload from one machine to another. Instead, we emphasize one complete infection process without further reliance on the traffic payload. Advanced sequence analysis algorithm is also proposed to accurately and reliably extract worm-characterizing footprints, which is not addressed in [ 11 ].

Vulnerability-specific signatures. Another interesting approach is termed as vulnerabil-ity-specific signatures [ 53 ] that match known exploitable vulnerabilities in system softwares or applications. Being aware of protocol semantics, this approach derives a vulnerability-specific state machine and is able to catch and thus filter incoming exploitation attempts. The behavioral footprint scheme does not require the knowledge of protocol semantic and is proposed to capture the whole infection sequence. However, as discussed in Sect. 5 , vulner-ability-specific knowledge can enrich the accuracy of worm-characterizing footprints.
Traffic-based worm profiling and detection. The third related area is the use of traffic-based methods [ 6 , 13 , 37 ] to profile and detect worms. For example, Rajab et al. [ 37 ]aims at reconstructing the actual sequence of host infections based on the history of scans from unique hosts as observed by a network telescope [ 27 ]. Our approach is different in its unique focus on the detailed steps involved only within an infection session.

Gu et al. [ 13 ] proposes a destination-source correlation (DSC) algorithm for worm detec-tion. The DSC algorithm has two phases: the first phase detects the general worm infection-like pattern while the second phase checks the abnormal outgoing scan rate for suspicious hosts observed in the first phase. Note that the first phase mainly uses the common pattern exhibited in most worms for the detection. As a result, it can not pinpoint the specifics of the detected worm and thus is inappropriate for detailed worm characterization. Similarly, based on the insight that a worm-infected host will likely exhibit abnormal behavior in the observed outgoing connection degree, Bo et al. [ 6 ] proposes a connection degree-based approach for worm detection without the detailed knowledge of the specific worm. In comparison, our approach instead aims at reconstructing the unique worm infection footprints in each worm propagation, which is useful for worm characterization and profiling purposes. 6.2 Worm capture and analysis Passive monitoring-based worm capture. A number of systems have been built to monitor or sense globally-scoped threats such as network telescope [ 27 ], Internet motion sensor [ 3 ], iSink [ 57 ] and DOMINO [ 56 ] etc. Network telescope [ 27 ] is among the first to take advanta-ges of the dark address space and passively monitor the traffic sent to it. Without legitimate traffic, the dark address space has shown an interesting perspective in detecting global-scale security incidents including worm activities. Internet motion sensor [ 3 ] has a distributed black-hole monitoring infrastructure to similarly receive unsolicited traffic. In addition, a lightweight active responder is built to provide certain interactivity with incoming traffic, which is then classified by calculating the MD 5 checksum on the traffic payload. Both iSink and DOMINO have similar components with active responders. Favoring broad visibility, these systems only support limited interaction with unsolicited traffic. vEye takes another different approach and sacrifices broad visibility for infection behavioral fidelity. More spe-cifically, high-interaction honeypots in vEye enables full-interaction with incoming traffic and appear as normal systems susceptible to worm infections. As such, unknown or even zero-day worms could be potentially captured by vEye.

Active monitoring-based worm capture. Recently, there have been significant advances in honeypot systems and their applications [ 4 , 8 , 14 , 36 , 50 ]. Among the most notable are Honeyd [ 36 ], Collapsar [ 14 ], and Potemkin [ 50 ]. Honeyd is a highly scalable and efficient framework for low-interaction virtual honeypots while both Collapsar and Potemkin are honeyfarms that deploy VM-based high-interaction honeypots with distributed presences. A nice combi-nation [ 4 ] proposes a two-layer architecture: low-interaction honeypots as front-end content filters and high-interaction honeypots running back-end services. A hand-off mechanism can glue them together to balance the performance and scalability. Though such architecture is not specifically proposed for trapping worms, it can be certainly leveraged to improve vEye X  X  scalability and performance.

Testbed-based worm analysis .Wormtestbedssuchas[ 45 , 55 , 59 ] provides interesting ven-ues to investigate low-level worm behaviors such as probing, exploitation, and propagation. With a pool of physical machines in a number of sites, the DETER testbed [ 45 ]isableto provide each researcher with a virtually dedicated experiment environment in an efficient on-demand fashion. In the current practice, the granularity of resource allocation is often one physical node. Due to all-software virtualization implementation, the worm analysis network of vEye enables quick recovery, traffic confinement, and experiment convenience particularly for iterative worm experiments. Note that anti-virus industry has similar testbed for in-house private malware analysis [ 55 , 59 ]. However, due to the lack of public access, the worm analysis network of vEye is locally developed to re-produce and collect authentic infection sequences. To the best of our knowledge, we are not aware of similar virtual worm-experimenting plat-forms that (1) can be widely deployable on general-purpose infrastructures; and (2) is able to quickly and resource-efficiently create hundreds or even thousands of virtual nodes. 7Conclusion In this paper, we addressed the problem of network worm detection and profiling from both algorithm design and system implementation perspectives. Different from existing static content-based signature approach, where worm evolving or self-propagation may lead to changing content information and consequently make it difficult, if not impossible, for con-tent-based signatures to detect such worms, we have proposed a behavioral footprinting approach to capture a worm X  X  dynamic infection profiles, including probing, exploitation, and propagation. Behavioral footprinting models each single infection step as a behavior phenotype and denotes the whole infection process as a sequence chain. Such a modeling process ensures that we can collect a certain number of sequences from specific worms, and then employ efficient data mining tools to accurately and reliably extract worm footprints.
In order to validate the effectiveness of the proposed behavioral footprinting principle in worm capturing and profiling, we have implemented a system framework X  X Eye X  X o collect authentic infection sequences of real-world worms, which are either  X  X ive X  ones captured through the distributed worm trap network, or other historical ones experienced through the worm analysis network. The experimental comparison with existing content-based signatures asserted the effectiveness of the proposed behavioral footprinting for worm detection and characterization.

The novel feature that distinguished the proposed from others is two-fold. First, the pro-posed behavioral footprinting approach captures a worm X  X  dynamic properties by using behavior phenotype, such that extensive data mining tools (in addition to the sequence alignment algorithms adopted in our system) can be used to discover accurate behavioral footprints for different types of worms. In addition, the proposed vEye system provides a real-world platform for data mining practitioners and security investigators to practice worm capturing and profiling. Future research issues may include:  X  Automated worm footprinting. Current footprint extraction algorithm needs a number of  X  Generic worm footprints. Experience with a significant portion of real-world worms References
