 We consider data exchange for XML documents: given source and target schemas, a mapping between them, and a document con-forming to the source schema, construct a target document and an-swer target queries in a way that is consistent with source infor-mation. The problem has primarily been studied in the relational context, in which data-exchange systems have also been built.
Since many XML documents are stored in relations, it is natural to consider using a relational system for XML data exchange. How-ever, there is a complexity mismatch between query answering in relational and XML data exchange, which indicates that restrictions have to be imposed on XML schemas and mappings, and on XML shredding schemes, to make the use of relational systems possible.
We isolate a set of fi ve requirements that must be ful fi lled in order to have a faithful representation of the XML data-exchange problem by a relational translation. We then demonstrate that these requirements naturally suggest the inlining technique for data-exchange tasks. Our key contribution is to provide shredding algo-rithms for schemas, documents, mappings and queries, and demon-strate that they enable us to correctly perform XML data-exchange tasks using a relational system.

Data exchange is the problem of fi nding an instance of a target schema, given an instance of a source schema and a schema map-ping, that is, a speci fi cation of the relationship between the source and the target. Such a target instance should correctly represent in-formation from the source instance under the constraints imposed by the target schema, and should allow one to evaluate queries on the target instance in a way that is semantically consistent with the source data. The problem has received much attention in the past few years, with several surveys already available [21, 9, 8].
The general setting of data exchange is this:
We have fi xed source and target schemas, an instance S of the source schema, and a mapping M that speci fi es the relationship between the source and the target schemas. The goal is to con-struct an instance T of the target schema, based on the source and the mapping, and answer queries against the target data in a way consistent with the source data.

The mappings rarely specify the target instance completely, that is, for each source S and mapping M , there could be multiple target instances T 1 , T 2 ,... that satisfy the conditions of the map-ping. Such instances are called solutions . The notion of query answering has to account for their non-uniqueness. Typically, one tries to compute certain answers CERTAIN M ( Q, S ) , i.e., answers independent of a particular solution chosen. If Q produces re-lations, these are usually de fi ned as must be produced by evaluating some query  X  not necessarily Q but perhaps its rewriting Q rewr over a particular solution T , so that Q
Thus, the key tasks in data exchange are: (a) choosing a partic-ular solution T among {T 1 , T 2 ,... } to materialize, and (b) fi nding a way of producing query answers over that solution by running a rewritten query Q rewr over it. Usually one builds a so-called univer-sal solution [12, 8]; these solutions behave particularly nicely with respect to query answering.

These basics of data exchange are independent of a particular model of data. Most research on data exchange, however, occurred in the relational context [12, 13, 21, 8] or slight extensions [32, 18]; the fi rst paper that attempted to extend relational results to the XML context was [6], and a few followups have since appeared [4, 3]. They all concentrate on the algorithmic aspects of query answering and constructing solutions, with the main goal of isolating tractable cases. The problem these papers do not address is how XML data exchange can be implemented ?
Previous work on algorithms for XML data exchange has tacitly assumed that one uses a native XML DBMS such as [19]. How-ever, this is not the only (and perhaps not even the most common) route: XML documents are often stored in relational DBMSs. Note that it is natural and in many cases desirable to be able to use the established relational technology to solve the considerably more re-cent and not as well understood XML data-exchange task. In fact, many ETL products claim that they handle XML data simply by producing relational translations (known as shredding [22]). This leads to a two-step approach: The approach seems very natural, but the key question is whether it will work correctly . That is, are we guaranteed to have the same result as we would have gotten had we implemented a native XML data-exchange system? We answer this question in this paper.
To state more precisely the main question addressed in this paper, assume that we have a translation  X  (  X  ) that can be applied to (a) XML schemas, (b) XML documents, (c) XML schema mappings, and (d) XML queries. Then the concept of correctness of such a translation is shown below:
XML : source S Relations :  X  ( S )
That is, suppose we start with an XML document S and an XML schema mapping M . In a native system, we would materialize some solution T over which we could answer queries Q .
 But now we want a relational system to do the job. So we shred S into  X  ( S ) and then apply to  X  ( S ) the translation of the mapping  X  ( M ) to get a solution  X  which itself is a shredding of an XML solution  X  so that the answer to Q could be reconstructed from the result of the query  X  ( Q ) over that relational solution.
The idea seems simple and natural on the surface, but starts look-ing challenging once we look deeper into it. Before even attempting to show that the relational translation faithfully represents the XML data-exchange problem, we need to address the following.
Complexity mismatch . Without restrictions, there cannot be a
Which shredding scheme to use? There are several, that can
Target constraints . In relational data exchange, constraints in tar-
As for the complexity issue, the work on the theory of XML data exchange has identi fi ed a class of mappings for which ef fi cient query answering is possible [6, 4, 3]. The schemas (say, DTDs), have rules of the form db  X  book  X  , book  X  author  X  subject (we shall give a formal de fi nition later), and the mappings trans-form patterns satis fi ed over the source into patterns satis fi ed over targets. Observe that these mappings (just as nested-relational tgds [15, 27]) are strictly more expressive than relational tgds; see the Related-Work section for a discussion.

This restriction suggests a relational representation to use. Going with the edge representation [14] is problematic: fi rst, each edge in an XML pattern used in a mapping will result in a join in the rela-tional translation, making it inef fi cient, and second, enforcing even a simple schema structure under that representation takes us out of the class of target constraints that relational data-exchange systems can handle. Veri fi ably correct translations based on numerical en-codings [30, 33] will necessarily involve numerical and/or ordering constraints in relational translations of mappings, and this is some-thing that relational data exchange cannot handle at the moment [21, 8] (beyond simple ordering constraints [2]).

One translation scheme however that fi ts in well with restrictions identi fi ed in [6, 4, 3] is the inlining scheme. It works very well for DTDs of the  X  X ight X  shape, and its output schemas involve only acyclic constraints, which is perfect for data-exchange scenarios. Desiderata for the translation We now formulate some basic re-quirements for the translation  X  , in order to be able to achieve our goals described in the diagram above. 1 We need the following: Requirement 1: translation of schemas A translation  X  ( D ) that, Requirement 2: translation of documents A translation  X  D Requirement 3: translation of queries For a DTD D , a trans-Requirement 4: translation of mappings For a mapping M be-Requirement 5: query answering For (analogs of) conjunctive
Satisfaction of these fi ve requirements would guarantee that we have a correct relational translation of an XML data-exchange problem, which would guarantee correct evaluation of queries. The
In the next sections we formalize each desideratum.
We cannot require the equivalence, as relational solutions are open to adding new tuples and thus cannot always be translations of trees; we shall discuss this later. relational approach to XML data exchange, which we propose in this paper, satis fi es all the fi ve requirements.

For the choice of the query language, one has to be careful since the de fi nition of certain answers depends on the output of the queries. We consider two classes of conjunctive queries over trees. The fi rst is tree patterns that output tuples of attribute values. These are the queries most commonly considered in XML data ex-change [6, 4, 3] because for them we can de fi ne certain answers as the usual intersection CERTAIN M ( Q, S )= ond is a simple XML-to-XML query language from whose queries output trees . It is essentially the positive fragment of FLWR ex-pressions of XQuery [31]. For outputs which are XML trees, the intersection operator is no longer meaningful for de fi ning certain answers. Instead, we use recent results of [11] that show how to de fi ne and compute certain answers for XML-to-XML queries. Contributions We provide a relational approach to solve two of the most important problems of XML data-exchange settings: ma-terializing solutions and answering queries. Our speci fi c contribu-tions are as follows. First, we introduce an architecture for XML data exchange using relational vehicles, with a focus on correct evaluation of (analogs of) conjunctive queries on XML data. Sec-ond, we identify a class of XML schema mappings and a shredding mechanism that allows us to overcome the complexity mismatch. Third, we provide algorithms for relational translation of schemas, XML documents, schema mappings, and queries in our proposed architecture. Finally, we prove the correctness of the translations: namely, we show that they satisfy the above fi ve requirements, and thus enable us to use relational data exchange systems for XML data-exchange tasks. Since the computational complexity of our proposed algorithms is quite low, and their correctness has been es-tablished, we believe this paper makes a case for using relational technology for provably correct XML data exchange.
 Related work In recent years, signi fi cant effort has been devoted to developing high-performance XML database systems, and to build-ing tools for data exchange. One major direction of the XML effort is the  X  X elational approach X , which uses relational DBMSs to store and query XML data. Documents could be translated into rela-tional tuples using either a  X  X TD-aware X  translation [29, 28] or a  X  X chemaless X  translation. The latter translations include the edge [14] and the node [33] representations of the data. Indexes could be prebuilt on the data to improve performance in relational query processing, see, e.g., [30, 33]. Constraints arising in the translation are sometimes dealt with explicitly [7, 23]. See [17] for a survey of the relational approach to answering XML queries.

The work on data exchange concentrated primarily on relations, see [8, 21] for surveys and [26, 27] for system descriptions. Map-pings for the XML data exchange problem were studied in [6, 4]; it was noticed there that the complexity of many tasks in XML data exchange is higher than for their relational analogs, which suggests that restrictions must be imposed for a relational implementation. The problem of exchanging XML data was also studied in [15, 27], which give translations of documents and DTDs into nested-relational schemas, and then show how to perform XML data ex-change under this translation. Most RDBMSs, however, do not provide support for nested relational schemas, and, thus, speci fi c machinery has to be developed in order to implement this transla-tion under a strictly relational setting. Moreover, XML mappings considered in this paper are strictly more expressive than nested-relational mappings, and every nested-relational data exchange set-ting can be ef fi ciently transformed into an equivalent XML data exchange setting. Thus, the results of this paper may aid towards the development of a relational implementation for both XML and nested-relational data exchange.
 Outline Key de fi nitions are given in Section 2. Section 3 provides translations of schemas and documents and shows that they ful fi ll Requirements 1 and 2. Section 4 states the main concepts of rela-tional and XML data exchange. Section 5 provides translations of mappings and queries, and shows that Requirements 3, 4, and 5 are ful fi lled. Section 6 studies queries that output XML trees. Relational schemas and constraints. A relational schema , or just schema , is a fi nite set R = { R 1 ,...,R k } of relation symbols, possibly with a set of integrity constraints ( dependencies ). Con-straints used most often in data exchange are equality-and tuple-generating dependencies [12, 21, 8], but for our purposes it will suf fi ce to consider only keys and foreign keys . If R is a relation over attributes U , and X is a set of attributes, then X is a key of R if no two tuples of R coincide on X -attributes (that is, for all tuples t 1 ,t 2  X  R with t 1 # = t 2 we have  X  X ( t 1 If R 1 and R 2 are relations over sets of attributes U 1 and U spectively, then an inclusion constraint R 1 [ X ]  X  R 2 [ Y ] , where X  X  U 1 and Y  X  U 2 are of the same cardinality, holds when  X 
X ( R 1 )  X   X  Y ( R 2 ) . We further say that a foreign key on the at-tributes of R 1 [ X ]  X  FK R 2 [ Y ] holds if the inclusion constraint R [ X ]  X  R 2 [ Y ] holds, and Y is a key of R 2 .

With each set of keys and foreign keys, we associate a graph in which we put an edge between attributes A and B if there is a con-straint R 1 [ X ]  X  FK R 2 [ Y ] with A  X  X and B  X  Y . If this graph is acyclic, we say that the set of constraints is acyclic . A schema is acyclic if its constraints are acyclic. In data exchange, one often uses a more technical notion of weak acyclicity: it includes some cyclic schemas for which the chase procedure still terminates. For us, however, the simple concept of acyclicity will suf fi ce, as our translations of schemas only produce acyclic constraints. XML documents and DTDs Assume that we have the follow-ing disjoint countably in fi nite sets: El of element names, Att of attribute names, and Str of possible values of string-valued at-tributes. All attribute names start with the symbol @ . An XML tree is a fi nite rooted directed tree T =( N, G ) , where N is the set of nodes and G is the set of edges, together with 1. a labeling function  X  : N  X  El ; 2. attribute-value assignments, which are partial functions 3. an ordering on the children of every node.

A DTD D over El with a distinguished symbol r (for the root) and a set of attributes Att consists of a mapping P D from El to regular expressions over El  X  { r } , usually written as productions %  X  e if P D ( % )= e , and a mapping A D from El to 2 Att signs a (possibly empty) set of attributes to each element type. For notational convenience, we always assume that attributes come in some order, just like in the relational case: attributes in tuples come in some order so we can write R ( a 1 ,...,a n ) . Likewise, we shall describe an % labeled tree node with n attributes as % ( a
A tree T conforms to a DTD D (written as T | = D ) if its root is labeled r , the set of attributes for a node labeled % is A labels of the children of such a node, read from left to right, form a string in the language of P D ( % ) .
 A class of DTDs In this paper we consider a restriction on DTDs called nested-relational DTDs [1, 6], a class of DTDs that natu-rally represent nested relational schemas such as the ones used by the Clio data-exchange system [26]. The reason for using them is that outside of this class, it is very easy to construct instances of XML data-exchange problems that will exhibit coNP-hardness of answering conjunctive queries (which are known to be tractable in practically all instances of relational data exchange), see [6].
A DTD D is non-recursive if the graph G ( D ) de fi ned as { ( % , % % is mentioned in P ( % ) } is acyclic. A non-recursive DTD D is nested-relational if all rules of D are of the form l  X   X  where all the l i  X  X  are distinct, and each  X  l i is one of l From now on, unless otherwise noted, all DTDs are assumed to be nested-relational. We also assume, without loss of generality, that the graph G ( D ) is not a directed acyclic graph (DAG) but a tree. (One can always unfold a DAG into a tree by tagging occurrences of element types with the types of their predecessors.) E XAMPLE 2.1. Figure 1(a) shows an example of an XML tree. In the Figure, the node identi fi ers precede the corresponding labels of each node in T ; we omit the attribute names and only show the attribute values of each node. In addition, Figure 1(b) shows an example of a nested relational DTD. Moreover, it is easy to see that the tree T of Figure 1(a) conforms to D . !
We now review the inlining technique [28], provide a precise de fi nition of the translation, and show that it satis fi es our Require-ments 1 and 2 . The main idea of inlining is that separate relations are created for the root and each element type that appears under a star, and other element types are inlined in the relations corre-sponding to their  X  X earest appropriate ancestor X . Each relation for an element type has an ID attribute that is a key, as well as (for non-root) a  X  X arent-ID X  attribute that is a foreign key pointing to the  X  X earest appropriate ancestor X  of that element in the document. All the attributes of a given element type in the DTD become at-tributes in the relation corresponding to that element type when such a relation exists, or otherwise become attributes in the relation for the  X  X earest appropriate ancestor X  of the given element type.
We begin with a formal de fi nition of the nearest appropriate an-cestor for the element types used in D . Given a nested-relational DTD D =( P D ,A D ,r ) , we  X  X ark X  in G ( D ) each element type that occurs under a star in P D . In addition, we mark the root ele-ment type in G ( D ) . Then, for a given element type % , we de fi ne the nearest appropriate ancestor of % , denoted by  X  ( % ) , as the closest marked element type % " in the path from the root element to % in the graph G ( D ) . The inlining schema generation is formally captured by means of the procedure I NL S CHEMA below.

E XAMPLE 3.1. Consider again DTD D in Figure 1(b). The relational schema I NL S CHEMA ( D ) is as follows: Keys are underlined; we also have the following foreign Procedure I NL S CHEMA ( D ) Input : A nested relational DTD D .

Output : A relational schema S D and a set of integrity
Set S D =  X  and  X  D =  X  for each marked element type % of D : endfor for each relation R ! in S D : endfor add to  X  D the dependency (stating the uniqueness of the root) return ( S D ,  X  D ) keys: R book ( rID )  X  FK R r ( rID ) and R author ( bookID )  X  R book ( bookID ) . ! The following shows that our Requirement 1 is satis fi ed.
P ROPOSITION 3.2. For every nested relational DTD D , the output of I NL S CHEMA ( D ) is an acyclic relational schema. Shredding of XML documents. We now move to the shredding procedure. Given the inlining I NL S CHEMA ( D ) =( S D ,  X  DTD D , and an XML tree T conforming to D , we use the algo-rithm I NL D OC to shred T into an instance of the relational schema S
D that satis fi es the constraints in  X  D . Let us fi rst explain this translation by means of an example.

E XAMPLE 3.3. Recall tree T from Figure 1(a) and DTD D from Figure 1(b). Figure 2 shows relations R book and R author the shredding of T . !
To present the algorithm, we de fi ne the nearest appropriate an-cestor  X  ( n ) of a node n of an XML document T that conforms to a DTD D , as follows. Mark each node n of T such that  X  ( n ) is starred in D , as well as the root of T . Then  X  ( n ) is the closest marked node n " that belongs to the path from the root to n . In the following algorithm, and for the remainder of the paper, we denote by id n the relational element representing the node n of a tree T . id id id Procedure I NL D OC ( T, D )
Input : A nested relational DTD D and an XML tree T that
Output : A relational instance of the schema I NL S CHEMA for each marked node n of T : endfor return I The following proposition shows our Requirement 2 is satis fi ed.
P ROPOSITION 3.4. Let D be a DTD, and T an XML tree such that T | = D . Then I NL D OC ( T, D ) is an instance of the schema computed by I NL S CHEMA ( D ) .
We now quickly review the basics of relational data exchange and introduce XML schema mappings that guarantee tractable query answering.
 Relational Data Exchange A schema mapping M is a triple (
S , T ,  X  ) , where S is a source schema, T =( T ,  X  T ) is a target schema with a set of constraints  X  T , and  X  is a set of source-to-target dependencies that specify how the source and the target are related. Most commonly these are given as source-to-target tuple generating dependencies (st-tgds): where  X  and  X  are conjunctions of relational atoms over S respectively.

In data-exchange literature, one normally considers instances with two types of values: constants and nulls. Instances S of the source schema S consist only of constant values, and nulls are used to populate target instances T when some values are unknown.
An instance T of T (which may contain both constants and nulls) is called a solution for an instance S of S under M , or an M -each tuple  X  a such that  X  (  X  a ) is true in S , there is a tuple S OL M ( S ) (or S OL ( S ) if M is understood).
 Certain answers and canonical universal solution The main dif-fi culty in answering a query Q against the target schema is that there could be many possible solutions for a given source. Thus, for query answering in data exchange one normally uses the notion of certain answers, that is, answers that do not depend on a particu-lar solution. Formally, for a source S and a mapping M , we de fi ne CERTAIN M ( Q, S ) as
Building all solutions is impractical (or even impossible), so it is important to fi nd a particular solution T 0  X  S OL M ( S ) , and a rewriting Q rewr of Q , so that CERTAIN M ( Q, S )= Q rewr
Universal solutions were identi fi ed in [12] as the preferred solu-tions in data exchange. Over them, every positive query can be an-swered, with a particularly simple rewriting: after Q is evaluated on a universal solution T 0 , tuples containing null values are discarded. Even among universal solutions there are ones that are most com-monly materialized in data-exchange systems, such as the canoni-cal solution C AN S OL M ( S ) , computed by applying the chase pro-cedure with constraints  X  and  X  T to the source instance S . If all the constraints in  X  T are acyclic (in fact, even a weaker notion suf fi ces), such a chase terminates and computes C AN S OL polynomial time [12].

Note that our Requirement 4 relates universal solutions in rela-tional and XML data exchange; in particular, we do not insist on working with the canonical solutions, and others, such as the core [13] or the algorithmic constructions of [25] can be used as well. Towards XML schema mappings: patterns To de fi ne XML schema mappings, we need the notions of schemas and source-to-target dependencies. The notion of schema is well understood in the XML context. Our dependencies, as in [6, 4, 3] will be based on tree patterns . Patterns are de fi ned inductively as follows: in a pattern. The semantics is de fi ned with respect to a node of a tree and to a valuation of all the variables of a pattern as attribute v when  X  x is interpreted as  X  a . It is de fi ned as follows: nessed at the root.

E XAMPLE 4.1. Consider tree T from Figure 1(a), and the tree pattern  X  ( x, y )= r [ book ( x )[ author [ name ( y )]]] , which fi nds books together with the names of their authors. Then it is easy to see that T | =  X  (  X  X lgorithm Design X  , Tardos ) . In fact, evaluation of  X  ( x, y ) over T returns the tuples (  X  X lgorithm Design X  , Tardos ), (  X  X lgorithm Design X  , Kleinberg ), and (  X  X lgebra X  , Hungerford ). !
Given a DTD D and a tree pattern  X  , we say that  X  is compatible with D if there exists a tree T that conforms to D and a tuple of attribute values  X  a such that T | =  X  (  X  a ) . In general, checking com-patibility of patterns with DTDs is NP-complete [10], but for the DTDs we consider here it can be easily done in polynomial time.
E XAMPLE 4.2.[Example 4.1 continued] The pattern  X  ( x, y ) is compatible with the DTD D of Figure 1(b). On the other hand, the pattern  X  " ( x )= r [ author ( x )] is not, because no tree consistent with D can have a child of r labeled as author , or an author -labeled node with an attribute. !
Remark More general patterns have been considered in the liter-ature [5, 24, 10, 4, 3]; in particular, they may involve descendant navigation, wild cards for labels, and sibling order. However, [6, 4, 3] showed that with these features added, query answering in data exchange becomes intractable even for very simple queries. In fact, the restrictions we use in our de fi nition were identi fi ed in [6] as essential for tractability of query answering. Note that the same restriction was imposed to queries when transforming XML data into nested-relational schemas [15, 27].
 XML schema mappings As our descriptions of XML schemas we shall use DTDs (since for complex schemas, query answering in data exchange is known to be intractable [6], and DTDs will suf-fi ce to capture all the known tractable cases). Source-to-target con-straints will be given via patterns.

Formally, an XML schema mapping is a triple M = ( D S ,D T ,  X  ) , where D S is the source (nested relational) DTD, D
T is the target (nested relational) DTD, and  X  is a set of XML source-to-target dependencies [6], or XML stds, of form where  X  and  X  " are tree patterns compatible with D S and D spectively.

As in the relational case, target trees may contain nulls to account for values not speci fi ed by mappings. Given a tree T that conforms to D S , a tree T " (over constants and nulls) is an M -solution for T if T " conforms to D T , and the pair ( T, T " ) satis fi es all the de-pendencies (2) from  X  . The latter means that for every tuple  X  a of  X  b of attribute values from T " such that T " satis fi es  X  of all M -solutions for T is denoted by S OL M ( T ) .

E XAMPLE 4.3. Consider the data-exchange scenario ( D, D T , M ) given by the DTDs D and D T of Figures 1(b) and 3(b), respectively, and where M is speci fi ed by the dependency r [ book ( x )[ author [ name ( y )]]]  X  that restructures book-author pairs as writer-work. It can be shown that the XML tree T " in Figure 3(a) is an M -solution for T . !
We now provide algorithms for implementing XML data ex-change via relational translations. Since we have already shown how to translate DTDs and documents, we need to present trans-lations of stds of mappings and queries. Both of them are based on translating patterns into relational conjunctive queries. We fi rst concentrate on that translation. Then we show how to extend it easily to mappings and queries, and prove the correctness of the translations. This will complete our program of using a relational system for XML data exchange in a semantically correct way. Inlining tree patterns. The key ingredient in our algorithms is a translation of patterns  X  compatible with a DTD D into a conjunctive query I NL P ATTERN (  X  , D ) over the relational schema I
NL S CHEMA ( D ) . Very roughly, it can be viewed as this: 1. View a pattern  X  (  X  x ) as a tree T  X  in which some attribute 2. Compute the relational database I NL D OC ( T  X  ,D ) (which 3. View I NL D OC ( T  X  ,D ) as a tableau of a conjunctive query; The algorithm is actually more complicated because I NL D cannot be used in Step 2; we shall explain shortly why.
Towards de fi ning I NL P ATTERN , observe that each tree pattern  X  (  X  x ) can be viewed as an XML document T  X  (  X  x ) , in which both values and variables can be used as attribute values. It is de fi ned in-attribute values, and if  X  is % (  X  x )[  X  1 (  X  x 1 ) ,...,  X  of T  X  is labeled % and has  X  x as attribute values. It also has k chil-dren, with the subtrees rooted at them being T  X  1 (  X  x 1 )
However, even for a pattern  X  (  X  x ) compatible with a DTD D , we may not be able to de fi ne its inlining as the inlining of T because T  X  (  X  x ) need not conform to D . For example, if a DTD has a rule r  X  ab and we have a pattern r [ a ] , it is compatible with D , but T r [ a ] does not conform to D , as it is missing a b -node. Hence, the procedure I NL D OC cannot be used  X  X s-is X  in our algorithm. Nevertheless, we can still mark the nodes of T  X  (  X  x ) with respect to D and de fi ne the nearest appropriate ancestor exactly as it has been done previously. Intuitively, the procedure I NL P ATTERN each node of T  X  (  X  x ) into a different predicate, and then joins these predicates using the nearest appropriate ancestor.
 Procedure I NL P ATTERN (  X  , D ) Input : A DTD D , a tree pattern  X  (  X  x ) compatible with D .
Output : Conjunctive query over I NL S CHEMA ( D ). for each node v of T  X  (  X  x ) of form % (  X  x v ) : endfor return Note that the compatibility of  X  with D ensures that I
NL P ATTERN is well de fi ned. That is, (1) every attribute formula nodes v, v "  X  T  X  (  X  x ) , if v " is a child of v , then  X  ( v Correctness. Given a pattern  X  (  X  x ) , the evaluation of  X  on a tree T is  X  ( T )= {  X  a | T | =  X  (  X  a ) } . The following proposition shows the correctness of I NL P ATTERN .

P ROPOSITION 5.1. Given a nested relational DTD D , a pat-tern  X  compatible with D , and a tree T that conforms to D , we have  X  ( T )= I NL P ATTERN (  X  , D ) Conjunctive queries over trees. We use the language that is es-sentially conjunctive queries over trees [6, 16, 10] with navigation along the child axis.

The language CTQ is obtained by closing patterns under con-junction and existential quanti fi cation: where  X  is a fully speci fi ed tree-pattern formula. The seman-tics is straightforward, given the semantics of patterns de fi ned above: Q (  X  a )  X  Q " (  X  b ) is true iff both Q (  X  a ) and Q of Q on a tree T is denoted by Q ( T ) .

We say that a query Q is compatible with the DTD D if every pattern used in it is compatible with D .

The inlining of queries Q compatible with D is given by the recursive algorithm I NL Q UERY below.
 Procedure I NL Q UERY ( Q , D ) Input : A DTD D , a query Q compatible with D .

Output : A conjunctive query over I NL S CHEMA ( D ) . if Q =  X  then else if Q = Q 1  X  Q 2 then else if Q =  X  xQ 1 then
Now we show that every query Q in CTQ can be computed by its inlining on the inlining of its input (assuming, of course, com-patibility with a DTD). In other words, Requirement 3 is satis fi ed.
T HEOREM 5.2. Given a DTD D , a tree T that conforms to it, and a compatible query Q , we have Inlining XML schema mappings We use our transformation of tree patterns to de fi ne the procedure I NL M AP , that, given source and target DTDs D S and D T , transforms an XML mapping M into a relational mapping I NL M AP ( M , D S , D T ) speci fi ed with a set of source-to-target tuple generating dependencies.
 Correctness While one could be tempted to ask for a translation that preserves all solutions, such a result need not hold. The rela-tional mapping I NL M AP uses null values to represent the shredded Procedure I NL M AP ( M , D S , D T )
Input : An XML mapping M from a source DTD D S to a Output : A relational mapping from I NL S CHEMA ( D S ) to
Set I NL M AP ( M ,D S ,D T ) :=  X  for dependency  X  (  X  x )  X  X  X   X  z  X  " (  X  x,  X  z ) in M do { I NL Q UERY (  X  , D S )(  X  x )  X  X  X   X  z I NL Q UERY (  X  " end return I NL M AP ( M ,D S ,D T ) nodes of XML trees, and thus we should only consider solutions whose null values have not been renamed. However, relational so-lutions are open to renaming of nulls. This intuition can be for-malized by means of the universal solutions, which are the most general among all solutions, and thus do not permit null renam-ing. Furthermore, one typically materializes a universal solution, as these solutions contain all the information needed to compute certain answers of conjunctive queries. This motivates the restric-tion of our Requirement 4 to universal solutions.

The theorem below shows that parts (a) and (b) of Requirement 4 hold. Note that in part (b), relational universal solutions are only required to contain a shredding of an XML universal solution. This is because relational solutions are also open to adding arbitrary tu-ples, which need not re fl ect a tree structure of an XML document.
T HEOREM 5.3. a) Let M =( D S ,D T ,  X  ) be an XML schema mapping and T an XML document that conforms to D S . If T " is an M -universal solution for T , then its inlining I
NL D OC ( T " ,D T ) is an I NL M AP ( M ,D S ,D T ) -universal solution for I NL D OC ( T, D S ) . b) Let M =( D S ,D T ,  X  ) be an XML schema map-ping, and T an XML document that conforms to D S . Then for every I NL M AP ( M ,D S ,D T ) -universal solution R for I
NL D OC ( T, D S ) there exists an M -universal solution T I NL D OC ( T " ,D T ) is contained in R .
 Answering XML queries using relational data exchange. The semantics of query answering in data exchange, both relational and XML [12, 21, 8, 6, 4], is de fi ned by means of certain answers. That is, given a schema mapping M =( D S ,D T ,  X  ) , a tree T that conforms to D S , and a conjunctive tree query Q that is compatible with D T , the certain answers of Q for T under M , denoted by CERTAIN M ( Q, T ) , is the set of tuples that belong to the evaluation of Q over every possible M -solution for T , that is, is an M -solution for T } . Note that our queries return sets of tuples, so we can talk about the intersection operator.

It was shown in [6, 4] that, for conjunctive tree queries and map-pings using nested-relational DTDs, computing certain answers for a given source tree T is solvable in polynomial time. Thus, for the classes of mappings and queries we consider, there is no complex-ity mismatch between relational and XML data exchange. The next theorem shows that our translation is correct with respect to query answering, that is, our Requirement 5 is satis fi ed.

T HEOREM 5.4. Let M =( D S ,D T ,  X  ) be an XML schema mapping. Then, for every XML tree T that satis fi es D S for every conjunctive tree query Q , the certain answers of Q for T under M and the certain answers of I NL Q UERY ( Q, D T I NL D OC ( T, D S ) over I NL M AP ( M ,D S ,D T ) coincide:
This result, combined with the standard procedure of evaluating conjunctive queries in relational data exchange, also gives us an algorithm for computing certain answers.
 C OROLLARY 5.5. Under the conditions of Theorem 5.4, CERTAIN M ( Q, T ) can be obtained by the following procedure: 1. run I NL Q UERY ( Q, D T ) on an I NL M AP ( M ,D S ,D 2. discard all tuples that contain null values.
Up to now, we have only considered queries that output tuples of attribute values. In this section, we shall focus on proper XML-to-XML query languages, that is, queries that output XML trees.
Some immediate questions arise when dealing with these for-malisms in a data exchange context. Let M =( D S ,D T ,  X  ) be an XML schema mapping, T be a tree conforming to D S , and Q be an XML-to-XML query. Since the evaluation of Q over T returns an XML tree, we cannot de fi ne certain answers as is a solution for T } , since the meaning of the intersection operator for XML documents is not clear.

To overcome this problem, we use recent results from [11] which showed how to de fi ne certain answers for queries returning XML trees, and how to use them in data exchange context. The key idea of [11] is to use tree patterns to de fi ne information contained in doc-uments, and to use them to represent compactly the certain knowl-edge from the collection {Q ( T " )) | T " is a solution for T } . More precisely, if  X  is a set of tree patterns which are matched by every tree Q ( T " ) , we look for a small set  X  0 of patterns that is equivalent to  X  as a description of certain answers. By equivalence we mean that a tree matches every pattern in  X  iff it matches every pattern create a tree with nulls, which we then view as the certain answer.
We shall not need additional details of the construction; instead we shall use a result from [11] that tells us how certain answers can be computed for a speci fi c XML-to-XML query language. The lan-guage, called TQL (to be de fi ned shortly), is inspired by XQuery X  X  FLWR expressions, and is restricted to positive features (i.e., no negation). The key result from [11] is the following: P ROPOSITION 6.1 ([11]). Let M =( D S ,D T ,  X  ) be an XML schema mapping, Q a TQL query, and T a tree that con-forms to D S . If T " is an M -universal solution for T , then CERTAIN M ( Q, T )= Q ( T " ) .

Given this result, we now do the following. We provide a formal de fi nition of the TQL language of [11], which can express XML-to-XML analogs of relational conjunctive queries. We then show how to adapt the machinery we have previously developed for eval-uating certain asnwers over a universal solution. Note that for this new translation, a TQL query Q returning trees needs to be trans-lated into a set of relational queries generating views that de fi ne the shredding of the tree Q ( T ) . 6.1 TQL queries
TQL queries [11] are inspired by the FLWR (for-let-where-return) expressions of XQuery [31], but they only use positive fea-pattern and q (  X  x ) is a query that de fi nes a forest expression. For-mally, the syntax of forest expressions is where % ranges over node labels,  X  a over constant attribute values, and  X  x etc are tuples of variables.

A TQL query Q is an expression of the form r [ q ] , where q is a forest expression without variables. To de fi ne the semantics of this language, we fi rst de fi ne inductively the forest [[ q (  X  x )]] a valuation v of all variables in  X  x as attribute values. We use the of attributes  X  a , and f is the forest of subtrees below the root. [[ for  X  (  X  a,  X  x,  X  y ) return q " (  X  x,  X  y )]] T,v For a tree T and a query Q = r [ q ] , the evaluation Q ( T ) of Q over T is de fi ned as the tree r [[[ q ]] T ] , i.e., the forest [[ q ]]
E XAMPLE 6.2. Recall the tree T from fi gure 1(a). The tree T from fi gure 3(a) can also be obtained as the transformation Q ( T ) resulting from the evaluation of a TQL query Q over T , where Q = r [ q ] , and q is de fi ned as For the sake of readability, we use the / operator to denote the child axis in tree patterns. ! 6.2 Inlining TQL queries
If Q is a TQL query, then, to be able to de fi ne its inlining trans-lation, we need to specify a DTD for trees Q ( T ) . Note that TQL queries de fi ne the shape of their outputs, and at the same time do not put restrictions on the number of appearances of labels. Hence it is natural to de fi ne the DTD for outputs of Q as a starred DTD D
Q , whose shape is determined by Q , and where each element type except the root occurs under the Kleene star.

More precisely, for a forest expression q , we de fi ne a forest F inductively as follows: F  X  is the empty forest; F ! [ q ! ] F we let T Q = r [ F q ] .

Then D Q is a non-recursive DTD that has a rule p  X  c  X  1 for each node p in T Q with children labelled c 1 ,...,c n we require that D Q be acyclic and we assume without loss of gen-erality that G ( D Q ) is a tree.

E XAMPLE 6.3.[Example 6.2 continued] Recall query Q = r [ q ] . Then, T Q is the XML tree given by r [ writer [ name , work ]] , and thus D Q contains productions r  X  writer  X  , writer  X  name  X  work  X  , name  X  ( and work  X  ( . !
Before showing the algorithm I NL TQL, we need to introduce some features that will be used in the algorithm. Consider again query (3) and DTD D Q in examples 6.2 and 6.3. For each pair of attributes that satisfy r / book ( x ) / author / name ( y ) , the query Q creates a subtree writer [ name ( y ) , work ( x )] in the tree Q ( T ) . Thus, the relational translation would need to create one tuple in the relations corresponding to writer , name and work for each pair of attributes x, y that satisfy the relational translation of the pattern r / book ( x ) / author / name ( y ) in the instance I NL
Thus, in the relational translation we need a way to associate each particular writer wih a particular name and work . One pos-sible way of doing this is by creating a (Skolem) function f that associates with each pair ( name , work ) a unique identi fi er for the corresponding writer . Thus, the function f must be de fi ned in such a way that f ( book , name ) is different for each different pair ( name , work ) . We enforce this requirement by letting each term f (  X  a ) represent a distinct constant c f (  X  a ) .

We will de fi ne our translation algorithm inductively. The key procedure TQL STEP for the inductive step is described below. Its inputs, in addition to a query and a DTD, include a conjunctive query corresponding to the conjunction of patterns in the query, and a function term corresponding to the parent in the tree Q ( T ) (for example, when creating views for relation R work , we would is illustrated by the example below.

E XAMPLE 6.4.[Example 6.3 continued] Assume that query Q = r [ q ] of examples 6.2 and 6.3 is posed over T under schema D . The following views de fi ne the translation for Q :
Notice how each tuple in relations R name and R work is set to ref-erence the correct tuple in relation R writer . ! Procedure TQL STEP ( Q , D ,  X  , t )
Input : A forest expression q (  X  x ) , a DTD D , a conjunctive
Output : A set of views over I NL S CHEMA ( D Q ) . if q (  X  x ) ::= ( then else if q (  X  x ) ::= q " (  X  x " ) ,q "" (  X  x "" ) then else if q (  X  x ) ::= % (  X  a,  X  x " )[ q " (  X  x "" )] then else if q (  X  x ) ::= for  X  (  X  a,  X  x,  X  y ) return q " To de fi ne the inlining translation I NL TQL, we simply need a Skolem term for the root of the tree, as the basis for the inductive procedure TQL STEP .
 Procedure I NL TQL ( Q , D ) Input : A TQL query Q = r [ q ] and a DTD D .
 Output : A set of views over I NL S CHEMA ( D Q ) .

Create a 0-ary function f r . return TQL STEP ( Q, D,  X  ,f r ())
A TQL query Q is compatible with a DTD D if all the patterns used in Q are compatible with D . The following proposition shows that I NL TQL satis fi es an analog of requirement 3 for queries that outputs trees.

P ROPOSITION 6.5. Given a DTD D , a TQL query Q compat-ible with D , and and a tree T that conforms to D , we have that I
NL D OC ( Q ( T ) ,D Q )= I NL TQL ( Q, D )( I NL D OC ( T )) , up to re-naming of nulls.

That is, the set of views I NL TQL ( Q, D ) applied to the inlining of T yields the same answer as the inlining of Q ( T ) . Translating relations back into XML
To complete the translation, we need an algorithm to publish back the relational data as an XML document. This is done by means of the algorithm P UB R EL . We say that an instance I of I NL S CHEMA ( D ) D -represents a tree T that conforms to D if I = I NL D OC ( T, D ) .
 Procedure P UB R EL ( D , I )
Input : A DTD D and an instance I that D -represents some
Output : An XML tree T that is D -represented by I . for each node % of G ( D ) , traversed as Depth-fi rst-search do endfor return T
This algorithm will only work for relational instances that rep-resent shredded documents. The following proposition shows its correctness.

P ROPOSITION 6.6. Given a DTD D and a rela-tional instance I of I NL S CHEMA ( D ) , it is the case that I
NL D OC ( P UB R EL ( D, I )) = I . 6.3 TQL queries in XML data exchange
Combining the previously mentioned result in [11] with the correctness of the algorithms we presented we conclude that re-quirements 1-5 are satis fi ed for data exchange with XML-to-XML queries:
T HEOREM 6.7. Let M =( D S ,D T ,  X  ) be an XML schema mapping. Then, for every XML tree T that satis fi es D S and for every TQL query Q , the certain answers of Q for T under M and the certain answers of I NL TQL ( Q, D T ) for I NL D OC ( T, D I NL M AP ( M ,D S ,D T ) coincide: Remark : The notion of certain answers naturally (component-wise) extends to queries computing multiple relations.

Theorem 6.7 and Proposition 6.6 give us a way of computing CERTAIN M ( Q, T ) . First, compute materializing views I NL TQL ( Q, D T ) over the canonical solution for I NL D OC ( T, D S ) and then use the procedure P UB R output it as the tree CERTAIN M ( Q, T ) .
Our technique provides a relational approach to solve two of the most important problems of XML data-exchange settings: materi-alizing solutions and answering queries. The diagram below sum-marizes this. In a pure XML setting, we can start with a document T and use a mapping M to fi nd a (universal) solution T " which we can then answer a query Q to produce certain answers. T R I
Using the translation I NL D OC of documents, we generate a relational instance R , on which the translation of the mapping I
NL M AP ( M ) generates a universal solution R " univ . This solution is a shredding, via I NL D OC , of a universal XML solution, and also conforms to the shredding of source DTD. Finally, we apply the standard technique [12] for evaluating queries in relational data ex-change to the query translation I NL Q UERY ( Q ) or I NL produce the correct answers, in the latter case with the possibility of using P UB R EL to publish back the results into XML.
Implementing our proposed algorithms for use in practical sys-tems would be straightforward using their speci fi cations given in this paper. A natural next step is to evaluate XML data-exchange systems using relational data storage and implementations of our algorithms. We are currently working on this direction.
We fi nish with a remark about the possibility of allowing opera-tors ? and + in DTDs, as well as a choice operator for representing multiple choices. We say that a non-recursive DTD D is an ex-tended nested relational DTD if all rules of D are of the form %  X   X  % 0 ...  X  % m , or %  X  % 0 + ... + % m , where all the % distinct, and each  X  % i is one of % i , % i ? , %  X  i or % for % | ( and % + for %%  X  ).

The procedure I NL S CHEMA can be extended to these DTDs. For each element % that is under the operator ? , the transformation cre-ates a special relation % that references the relation of the nearest ap-propriate ancestor of % . Furthermore, the transformation for a rule of the form % 1  X  % + 2 can be de fi ned by including a dependency that ensures that there is at least one tuple in the relation R tuple in R ! 1 . Finally, for the choice operator %  X  % 0 the transformation would create one relation R ! for each possible choice of % 0 ,..., % m . Then, it is possible to extend all the proce-dures in a way that still satis fi es requirements 1-5 under extended nested relational DTDs.
