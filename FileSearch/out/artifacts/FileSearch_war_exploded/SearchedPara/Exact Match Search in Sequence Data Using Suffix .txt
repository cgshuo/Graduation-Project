 We study suitable indexing techni ques to support efficient exact match search in large biological sequence databases. We propose a suffix tree (ST) representation, called STA-DF, as an alternative to the array representation of ST (STA) proposed in [7] and utilized in [18]. To study the performance of STA and STA-DF, we develop a memory efficient ST-based Exact Match (STEM) search algorithm. We im plemented STEM and both representations of ST and conduc ted extensive experiments. Our results indicate that the STA and STA-DF representations are very similar in construction time, storage utilization, and search time using STEM. In terms of the access patterns by STEM, our results show that compared to STA, the STA-DF representation exhibits better spatial and sequen tial locality of reference. This suggests that STA-DF would requi re less number of disk I/Os, and hence is more amenable to efficient and scalable disk-based computation. E.1 [ Data Structures ]: Trees; H.3.1 [ Content Analysis and Indexing ]: Indexing Methods; H.3.3 [ Information Search and Retrieval ]: Search Process; J.3 [ Life and Medical Sciences ]: Biology and Genetics Algorithms, Design, Performance. Bioinformatics, Indexing, Seque nce Databases, Suffix Trees. The amount of biological data be ing generated is growing at phenomenal rates. This has resu lted in enormous volumes of biological datasets which include sequences, expression arrays, search, mining, and integrative understanding, require the ability to search datasets of long sequences for particular sequence patterns, expressed as queries. C onventional search techniques are inadequate in such applications and the demand for more efficient search capability is increasing. Th erefore, new techniques must be developed to support such applica tions. This is a major motivation of our work in this paper. From biological point of view a basic task over sequence data is that: given a query sequence, find all similar (above a user-specified th reshold) strings in a sequence database. In case the dataset dealt with includes nucleotide sequences, this search can rev eal important information about possible existence of an evolutionary relationship (homology) between an input query sequen ce and its similar DNA sequences. In the case of protein sequences, finding sequences (of proteins which are already in the database) which are similar to a protein sequence expressed as a query ma y help in approximation of the biochemical function of the query protein. From computational point of view, the searching probl em can be defined as follows. Given a sequence database T = { s 1 , s 2, .... , sequence, and a query string P , find all substrings in T which are the error ratio . Exact match problem is a special case of this problem where k = 0. We consider the problem of efficient exact match search in large sequence databases. While this is an important problem for bioinformatics applications even when the data fits in the memory [9], an ultimate goal would be to carry the results to an efficient disk-based solution for both exact and approximate match problem. Sequential scan of the database, which is used in BLAST [1, 2] suffers from large number of disk I/Os. In this context investigating suitable i ndex structures is essential. Recently there has been an increasing interest in using suffix tree (ST) index structures for text/s equences. While the goal of most studies in this area has been the development of efficient disk-based ST construction algorithms, the proposed solutions are mainly evaluated based on the maximum size of the text they can index, the time required to construc t the ST index, and the size of the index. In this paper, we focus on the memory-based model. As a first step, we study the performance of the exact match search for two alternative approaches. One approach is using a suffix tree (ST) based index and the other is ba sed on sequential scan of the database, similar to the one used in BLAST. The experimental results show that for queries of practical length, the ST-based solution has superior performance. Next, we take a closer look at the STA representation proposed in [7]. We propose an alternative suffix tree representation (S TA-DF) together with a corresponding construction algorithm. The results of our experiments show that STA and STA-DF have similar construction and search times unde r the memory-based model. In terms of locality of references under the memory-base model, our experimental results indicate that STA-DF is better than STA, and hence is more promising for the disk-based model. An extension of the proposed ideas and techni ques to a disk-based model is underway. The rest of the paper is organi zed as follows. Section 2 reviews related work. In Section 3 we introduce our exact match search algorithm STEM, which uses a ST i ndex. In Section 4, we report our experimental results of comp aring two alternative approaches for exact match searching. In Section 5, we present in more detail the STA representation. In Sec tion 6, we introduce our STA-DF representation of the suffix tree and the underlying ST construction algorithm, PWODF. Sec tion 7 contains the results of the experimental comparison of STA and STA-DF and their analysis. Section 8 includes conc luding remarks and future work. Given a text T and a query pattern P, there are three approaches in general for solving the exact match problem: no preprocessing, preprocess the query pattern P, or preprocess the text T. The result match P. The no preprocessing approach, also called naive method, aligns the left end of P with the left end of T and then compares the characters of P and T, going from left to right until a mismatch is found or P is exha usted. Then P is shifted one position to the right and the compar ison process is repeated. This is the simplest method to unde rstand and implement, but is inefficient and does not scale up. There are many known algorithms based on preprocessing of query, most notably the Knuth-Morris-Pratt algorithm [ 13 ], the Boyer-Moore algorithm [ 5] and its Apostolico-Giancarlo version [ 4 ]. BLAST (Basic Local Alignment Search Tool) [1, 2] is a popular search tool for biologists. It performs a preproce ssing of the query pattern P as follows. First, all disjoint substrings, called words , of some predefined length l of P are used to build a finite automaton (FA). Then text T is sequentially run through the FA. If the process reaches a final state, an exact ma tch is found in T with one of the query words. A disadvantage of this approach is that the query preprocessing time is incurred by the user when the query is posed. In the third approach, we may for instance build a suffix tree (ST) index as the result of preprocessing of text T. An advantage of this approach is that the ST construction is independent of users X  queries, and is done offline. As a result, the time for ST construction is not incurred by the user. In this work, we focus on ST indexes. Figure 1 shows the suffix tree for the text T= AGAGAGCTT$. It should be noted that the figure is a high-level, graphical illustration of the ST and does not reflect the underlying representation of the ST. The numbers in squares are used to enumerate th e nodes. Each edge is labeled with the corresponding characters fro m T. The labels with arrows are to be read from left to right. The number below each leaf node gives the starting position in T at which we can find a substring indicated by the labels of the edges from the root to that leaf node. The ST serves as an index to a sequential, non-divisible data and supports many bioinformatics applications [9]. A popular suffix tree construction algorithm is the Ukkonen X  X  algorithm [19]. This algorithm is easier to implement, compared to other popular proposals [16, 20]. Also this algorithm provides a basis for proving bounds. The limita tion of all these linear time algorithms is that they are memory-based and cannot be used for large sequences. Hunt et al. [11] makes an observation that the major bottleneck of the Ukkonen X  X  algorithm is the use of suffix links, which resulted in more random accesses, and propose a construction algorithm which elimin ates the use of suffix links. The idea of partitioning of the input sequences is also introduced in [11]. Giegerich et al. [7] proposed a space-efficient, array representation of ST, to which we refer as suffix tree array (or STA, for short) and a ST construction algorithm called wotdeager which is O(n 2 ) in the worst case and O(nlog n), on average. The wotdeager algorithm is more localized and requires less disk space for the suffix tree. The standard representation of suffix trees stores nodes with child and sibling pointers. In the worst case this would require 32n bytes storage space, where n is the size of the text to be indexed. The wotdeager representation on the other hand does not explicitly st ore the sibling pointers. Also, this representation stores only th e first child of a node (explained in detail in Section 5). This reduces the required space to 12n bytes in the worst case and 8.5n bytes in the average case [7]. Using the STA representation and the wotdeager algorithm, Tata et al. [18] introduced a partitioning technique and a buffer management strategy. This resulte d in the development of a top-down disk-based (TDD) ST cons truction technique using which for the first time a suffix tree was constructed on the entire human genome, which has more than three billion characters. This demonstrated that their implementation of the wotdeager algorithm with O(n 2 ) time is far superior than [11] and linear time algorithms such as [19], both for the disk and memory-based models as it is more cache efficient. In this section, we introduce our ST-based Exact Match search algorithm (STEM). This algorithm, shown in Figure 2, takes a suffix tree index ST, a text T, a nd a query pattern P as inputs and returns the set of all starting pos itions of substrings in T that match P. To illustrate the STEM algorithm, consider the text T and the ST given in Figure 1 and assume we search for P = AGAG. The edge from ST root to node 2 has a label AG and it matches the first two characters in P (Figure 2, step 4). Thus, ans_root is set to node 2 , and p_pntr is set to 0+2 = 2 (step 6). Since currently p_pntr is less than the size of P, we execute step 4 again. Now, the label on the outgoing edge from node 2 (the current ans_root ) to node 6 (i.e., X  X G X ) matches a prefix of P starting at position p_pntr = 2. Thus, ans_root is set to node 6 , and p_pntr is set to 2+2 = 4 (step Because ans_root is not null , we invoke phase II of STEM with answer subtree rooted at node 6 must be reached in order to compute all starting positions of P in T. The leaf nodes of node 6 are node 12 and node 13 , and the corresponding starting positions of P in T returned by STEM are T[0] and T[2]. Algorithm STEM (Text T, Suffix Tree ST, Pattern P) In general, since for the exact match search, there is no requirement about the order in which the starting positions in the text are discovered, a depth-first traversal of answer subtree (phase II) is preferred compared to the breath-first traversal. There are two reasons for this preference. First, the depth-first traversal uses the available main memory space more efficiently. In a depth-first traversal, the additional main memory needed for storing the intermediate results of phase II is proportional to the depth of the answer sub-tree, i.e., the number of nodes on the longest branch. A breath-first traversal of answer subtree requires the same time, as both visit the same collection S of internal and leaf nodes in phase II to complete the search. However, breadth-first traversal requires much more memory in general, depending on the maximum number of nodes in S that are at the same level in ST. The choice of depth-first over breadth-first is more crucial when considering protein sequen ces which have larger alphabet than DNA sequences, resulting in suffix trees with larger fan-outs. Second, the depth-first traversal is easier to implement than breadth-first. While tree traversal in the first approach could be implemented elegantly using r ecursion, manipulation of the intermediate results in the br eadth-first approach is more involved. For these reasons, we use breadth-first traversal in phase I in our STEM algorithm and use depth-first traversal in phase II. In this section, we study the various aspects of exact match search techniques which perform preprocessing, that is, preprocessing the text T and preprocessing the query pattern P, both under the memory-based model. For the  X  X reprocessing the text X  approach, we consider a suffix tree-based a pproach and implemented the ST construction algorithm proposed in [8], which uses the STA suffix tree representation. The suffix tree search algorithm is an implementation of the STEM algor ithm (Figure 2). For the second approach, i.e., preprocessing the query, we use the Deterministic Finite Automaton (DFA) algorithm because of its similarity to the BLAST approach for finding the seeds, which are basically exact word matches which BLAST ex tends later to approximate matches. Our implementation of the DFA algorithm is based on the work in [6], but rather than considering one query sequence, we build the DFA for all query sequences (the words). In our experiments we have considered, as the text, the complete genome Escherichia coli O157:H7 [21], which is a DNA sequence of 5,498,450 characters over the alphabet {A, C, G, T}. We will refer to this sequence as T3. The query sequences are randomly generated strings over th e same alphabet. To study the effect of the query length on the s earch time, we have considered queries with lengths 3, 5, 7, 9, 11, 13, and 15 characters. These query lengths in fact correspond to the word size that BLAST uses. To study the scalability with respect to the number of queries, we considered sets of 1000, 3000, and 5000 queries. As a result, we generated 21 query sets and gave them proper names to refer to. For example, an input query set named n5_3000 contains 3000 query sequences of length 5 characters each, where n denotes the nucleotide alphabet. As in BLAST, we assume all query sequences (the words) are of the same length. For all the experiments in this paper, we used an IBM desktop computer with Intel Pentium 4 @ 2.4 GHz as the clock speed, 120GB HDD, and 768 MB of RAM, on Linux kernel 2.4.20-30.9. The result of the experiments is shown in Figure 3. As mentioned earlier, the search time for DFA includes the query preprocessing time, which is incurred by the user, while STEM does not incur this cost. The comparison of the STEM and DFA algorithms leads to some interesting observations. As shown in Figure 3 (a), for query sequence lengths greater th an a threshold value, STEM algorithm produces the results faster than the DFA algorithm. The decrease of STEM search time when increasing the query length is because, in general, for each subsequent character in query P, phase I of STEM will traverse to a lower level in the suffix tree, effectively pruning many unrelated parts of the ST. Thus, increasing the length of the query results in a smaller size of the answer subtree, i.e., a smaller number of ST leaf nodes to be visited in phase II. For the DFA algorithm, increasing the query length in the same scenario has the opposite effect, i.e., it leads to an increase in the search time. There are two reasons for this. First, the time needed for building the DFA increases, since the number of states in the DFA increases when the word length increases. Second, th e time for running the text T through the DFA also increases, since there are more transitions to follow to reach a final state. Figure 3(b) zooms into the shaded area of (a). It can be seen that increasing the query length results in converging the search time by STEM for different number of queries. On the other hand, increasing the query length has the opposite effect for DFA search time (Figure 3 (a)). While the above comparisons show the superiority of the suffix tree-based approach over the FA approach, currently used in BLAST, the experiments were conducted in the memory-based model. The amount of data curren tly stored in biological sequence databases dictates an obvious nece ssity for a disk-based solution. The effectiveness of a disk-based solution will be determined by two factors: the number of disk accesses and the locality of these accesses. While the FA-based approach performs a sequential scan of the text T (i.e., good locality), it has to read the whole text (i.e., redundant I/O operations). On the other hand, the ST-based approach reduces the number of disk I/Os by reading only relevant parts of the ST index and the text itself, as indicated also in Figure 3 (a). Considering the disk-based model, the locality of the disk accesses for the ST-based approach is very important, especially for the ST accesses, since the ST size is approximately an order of magnitude larger than the size of the text [18]. This is our motivation in this work to study access patterns of STEM using the STA representation of ST and in the alternative representation STA-DF, which we propose in this paper. There are several suffix tree repr esentations proposed, including: Patricia tree-based [17], linked lis t and hash table representations based on the suffix tree construction algorithm in [16], suffix array and augmented suffix array [ 14], LC-trie [3], suffix binary search tree and suffix AVL tree [12]. As introduced earlier, Giegerich et al. [7] proposed a new ST representation in form of a linear array of integers, which we called STA (for Suffix Tree Array). We decided to use it as a benchmark for the following reas ons. First, it is suitable for efficient disk-based suffix tree construction algorithms over long texts, as shown in [18]. Second, it is space efficient, compared to other ST representations. Third, as shown in [7], it allows efficient exact match search in memory-based model, compared to some alternative representations. We next review some concepts and definitions for STA, taken from [7]. contains the position i in text T at which we can find the string denoted by the edge labels from the root to s . For example, for leaf node 15 in Figure 1, we have that l (15)={3}. For a branching node u in a ST, the leaf set of u is defined based on the leaf sets of rooted at u }. For instance, for node 8 in Figure 1, its leaf set would be l (8)={ l (14), l (15)}={1,3}. There is a total order defined on the nodes in the tree, as follows. For any pair of nodes v and w which are children of the same node u , we define v w have that node 6 p node 8, since min l (6) = 0 &lt; min l (8) =1. For plus the size of the edge that leads to the parent of v . For example, lp (8) = 1+1=2. The notion of left pointer is defined so that we can retrieve the edge labels in a suffix tree in constant time. T = AGAGAGCTT$ shown in Figure 1. A branchin cent STA branching node, PWODF evaluates the fi rstchild recursively. As elements. The first element contains the left pointer value ( lp ) of u and two additional bits, called the rightmost bit and the leaf bit . If branching node at this level. This is represented in Figure 4 by the superscript R in the corresponding elements. For every branching node, the leaf bit is always set to false . In the second STA element, which is allocated for a branching node u , we store the firstchild pointer. It points to the position in STA at which the 4, branching node 2 is stored in the first two STA elements, STA[0] and STA[1]. Its first child is branching node 6 (see Figure 1). Hence, the value in the s econd element (i.e., STA[1] = 8) allocated for node 2 points to position STA[8], which is the first of the two STA elements that st ore node 6. The arrows above the STA in Figure 4 just emphasize these pointers for illustration purposes only. A leaf node in ST o ccupies a single element. In it, we store the same information as in the first element allocated for a branching node: the left pointer value, the leaf bit (always set to true), and the rightmost bit. The leaf nodes in Figure 4 are shown in grey. For the STA in Figure 4, it records branching node 2 in the first two STA elements, branch ing node 3 is recorded in the next two elements, leaf node 1 is recorded in STA[4], etc. To illustrate the STEM search, we consider a f memory buffer to store the ST elem ents (Figure 4). The ST blocks are read from disk and placed into this buffer. The goal is to find a suitable ST representation that has good locality of reference for the STEM algorithm. There ar e three types of locality of reference: temporal, spatial, and sequential. While the temporal locality is not relevant to trav ersing the ST nodes, sequential and spatial localities are important fo r two reasons. First, during the traversal of ST by the STEM sear ch algorithm, there will be cases in which we need to read a node in ST again, after it has been read previously. We refer to such cases as backjumps . The backjump size is defined as i  X  j (in number of STA elements), where i is the current STA element, j is the next element in the STA to which the search refers, and i &gt; j . Reducing the backjump size translates to a higher probab ility that the element backjumped to is still in the memory. Second, good sequential and spatial localities will allow double buffering (i.e., pre-fetching) and a simpler buffer replacement strategy (e.g., LRU). In order to improve spatial and sequential locality we tailor the ST representation to the nature of the STEM algorithm. Considering the fact that most of the STEM search time is spent in phase II, we propose an alternative depth X  X irst ST representation, called STA-DF. The proposed construction algorithm, shown in Figure 5, for STA-DF representation is called PWODF (Partition and Write Ordered Depth-First), which is a variant of the PWOTD construction algorithm [18]. The difference between PWOTD a nd PWODF is in the order in which the two algorithms evaluate and record the ST nodes in the corresponding suffix tree representa tion. For all branching nodes, PWOTD first evaluates all its children nodes and then picks the firstchild (w.r.t. p ) to be evaluated next. On the other hand, for a Algorithm PWODF ( text T, prefixlen ) Phase1 : 
Phase2 : For each partition do the f ollowing: can be seen from Figure 5 in Phase I of PWODF we partition the input text based ters (similar to PWOTD). Partitioning enables us to generate smaller, disjoint parts of the suffix tree which can be built and managed independently of each other. This reduces the main memory requirements of the algorithm. However, the cost of partitioning increases linearly with prefixlen . See [18] for details of the PWOTD construction algorithm. For the same text T = AGAGAGCTT$, Figure 6 shows the order (by node enumeration) in which t stored in the STA-DF, and Figure 7 shows the STA-DF representation of the ST. In Figure 7, the first two STA-DF elements records the branching node 1, the next two elements records branching node 2, the forth element in STA-DF records the leaf node 3, etc. The diffe rences between STA and STA-DF representations of the suffix tree result from the different order in which the nodes are recorded and visited. Since STA-DF is a branching node is stored immediately after the second element allocated to the current branching node. For example, the firstchild of node 1 (the first branching node stored in STA-DF) is node 2, the firstchild of node 2 is node 3, and they are stored sequentially in STA-DF. We note that the pointer in the second element for a branching node in the STA representation is redundant. In STA-DF we use th e second element to store a pointer to the right sibling . For example, in Figure 6, branching node 1 has node 6 as its right sibling. Hence in the pointe store the position in STA-DF where node 6 is recorded (i.e. position 7). The other information st ored in the two elements in STA-DF is the same as that in STA. For leaf nodes, we store the same information as in STA. For leaf nodes, there is no need to explicitly store a pointer to the right sibling. A leaf node takes only one element as in STA and does not have any children to be recorded in STA-DF immediately (or anywhere else) in the suffix tree. Thus, the right sibling of a leaf node is stored immediately next to the leaf node itself in STA-DF. It should be noted that the changes introduced in STA-DF do not result in any change in the number of array elements, or the space required for storing STA-DF, compared to STA. We have perfo are our STA-DF representation to the original STA representation in various aspects. In the first set of expe riments, we study the time of the PWOTD and PWODF algorithms, as well as the STEM search time using th e STA and STA-DF, under the memory-based model. In the second set of experiments, we study the STEM access pattern for the alternative suffix tree representations. To compare the construction time of STA and STA-DF, we conducted extensive experiments for DNA sequences of var size to be indexed. Sequence T1 is Haloarc chromosome II [21], and sequence T2 is Homo sapiens chromosome 7, WGA: 47166 contig 47166 [21]. Sequence T3 is the E.coli sequence introduced and used in Section 4. Table 1 shows the construction times, according to which we can see that PWOTD and PWODF algorithms ha ve similar performance for memory X  X ased model, since they only differ in the order of traversing and storing the ST node s. We also remark that the construction times for larger sequences (see Section 8) are comparable and consistent w ith those reported in [18]. In this expe STA-DF and STA representations of the suffix tree built for T3 sequence ( E. coli ) in our pre experiment. To compare the STEM search time for the two alternative suffix tree representati ons, we p (a subset of the 21 query sets me ntioned in Section 4) against the E.coli DNA sequence. The results are presented in Table 2 (in milliseconds). As can be seen , the two alternative ST representations have similar performance in the memory-based model. This is because the number of operations to be performed is similar. The slight advantage of STA-DF (more evident for shorter queries) is a result of the explicit knowledge in phase II of STEM about the position of th e firstchild in STA-DF. 
Approach # of queries 3 7 11 15 STEM STEM+ hile the search time is the same under the memory-based W model, in this experiment we study the locality of referenc exhibited by STEM for the two alternative representations. Sinc for large texts, the corresponding ST inde memory, studying its access patterns sheds light on the expected number of disk I/Os when extending this technique to disk-based model. To investigate the differences in the access patterns of STEM+STA and STEM+STA-D F, we used the ST representations of T1 created before in Section 7.1, to search for exact matches for the query P = TAGCC. While phase I of STEM results in a similar access pattern, phase II (where most of the search time for long texts and rela tively short queries is spent) highlights a difference in the locality of references by the two representations (Figure 8). The x-axis in Figure 8 represents the ordered in time sequence of all STEM phase II suffix tree access events, which are required to answer query P. The y-axis indicates the ST position read in a particular access operation. The graph suggests a possible advantage of the STA-DF representation over the STA alternative in terms of spatial and sequential locality of reference. It can be seen that the sizes of backjumps are smaller for STA-DF compared to STA. Such a difference will be important for a disk-based solution, since backjumps of smaller size are more desired, as explained before. The figure also illustrates that STEM requires fewer number of STA-DF accesses, compared to STEM+STA. This is because for each branching node u in phase II, STEM saves a read by knowing exactly where in STA-DF the first child of u is recorded. To further investigate the difference in locality distribution. For example, in Figur e 11, we observe an increase in the number of STA-DF backjumps that are of size 10 elements or smaller (Bin 1), compared to the same size STA backjumps. For the rest of the bins, there is a significant decrease in the number of backjumps in STA-DF compared to the corresponding bins for STA backjumps. The number of STA-DF backjumps of size 10-10 2 elements (Bin 2) is around 3 times smaller than STA in the same bin. The superiority of STA-DF becomes more evident for larger bins. For the larger backjumps, e.g. of size 10 5 elements or more (Bin 6), STA-DF reduces by almost 5 times the number of backjumps, compared to original STA representation. In our implementations of STA and STA-DF representations, each element is of size 4 bytes, as in [7]. For Bin 6 which holds backjumps of size more than 50 blocks (assuming 8KB block) which is equal shown in Figure 8, we performed the following experiment. We posed four queries P 1 = A, P 2 = C, P 3 = G, and P 4 = T against T1, T2, and T3, using the corresponding STA and STA-DF representations. For each combination of query, text, and ST representation, we have recorded the number of backjumps observed and their sizes (in the number of ST elements). The reason for choosing the shortest possible query length is to ensure that the results will be representative for the whole suffix trees. Based on the backjump size, we classified the backjumps into 6 bins, as follows: Bin 1: 0 X 10 elements; Bin 2: 10 X 10 Bin 3: 10 2  X 10 3 elements; Bin 4 :10 3  X 10 4 elements; Bin5 : 10 and Bin 6 for distances larger than 10 5 elements.
 In Figures 9, 10, and 11 we show the average (w.r.t. the four queries) bin distribution of white) and STA-DF (in black) representations for the three DNA sequences considered in our expe riments. For clarity we have used logarithmic scale for the y-axis. The first observation we make is that for a given text, the total number of backjumps is the same for the two representations. This is because both STA and STA-DF represents the same suffix tree. The second observation is that, as can be seen from these figures the proposed STA-DF representation leads to smaller size backjumps compared to the original STA representation proposed in [7] and used in [18]. While the total number of backjumps is the same for both representations, the backjump bin distribution for STA-DF tends to have smaller size backjumps, compared to the STA backjump STA-DF, compared to 78 backjumps using STA. Considering T1, T2 and T3 backjump distribution for bins 2 to 6, we see that using STA-DF reduces the number of backjumps by approximately 70% compared to STA. Based on these observations our ST A-DF representation is more promising for the disk-based co mputation. The gain using STA-DF will be even bigger for longer input sequences for which there will be an increase in the backju mp sizes. In such scenario, the reduced size of the backjumps achieved using STA-DF will result in better locality of reference, l eading to smaller number of buffer and cache misses, and hence more efficient I/O operations. In this paper, we studied memory-based exact match searching in large biological sequence data. While this capability is needed in many current applications, an ultim ate goal of this research would be to provide a basis for a disk-based computation model of exact and approximate match problems, when the data sequences do not fit into the main memory. We proposed a suffix tree-based exact match search algorithm (STEM). We compared the search times for two alternative algorithms: (1) STEM, using a suffix tree, which takes the approach  X  X reprocessing the text X , and (2) DFA, using a deterministic finite automaton, which takes the approach  X  X reprocessing the query. X  The latter is similar to the one currently used in BLAST for findi ng the seeds. The results of our experiment under the memory-based model show that in terms of execution time, for queries of pr actical length, STEM outperforms the DFA algorithm. STEM also exhibits better scalability with respect to the number of query sequences. In order to minimize the number of I/O operations in the disk-based model, we investigated ways to optimize locality of references made by STEM on th e suffix tree index. We proposed [11] x [12] nd [13] V.R. Pratt. Fast pattern [14] ber and G. Myers. Su ffix arrays: a new method for [15] ine and [19] struction of suffix-trees. In [20] [21] ww.ncbi.nlm.nih.gov  X  the NCBI web site. Last an alternative representation of the suffix tree, called STA-DF, and presented the corresponding suffix tree construction algorithm, which we called PWODF. Because of locality of references, we expect that PWODF to be more efficient under the disk-based model, a subject that is currently under investigation. We compared PWODF with the suffix tree representation STA [7] and its corresponding construction algorithm PWOTD [18]. The results show that the two cons truction algorithms have similar performance under the memory-based model. They also indi that our memory-based implementations are as efficient as TD The construction times for a DNA sequence of size 50 million characters, using our implemen tations of PWOTD and PWODF algorithms are 130 and 142 seconds, respectively. The construction time reported in [18] is 121 seconds for a DNA sequence of the same size. Also, the search time of STEM is the same for the two ST representati ons in the memory-based model. This is concluded from our experi mental results which show that STEM coupled with STA-DF exhibits shorter backjumps and hence better locality, compared to STEM coupled with STA. On the basis of these observations, we believe that STA-DF to be more promising for an efficient and scalable disk-based computation. Another future work is devel oping efficient partitioning schemes for disk-based model of suffix tree construction algorithm and evaluating different buffering strategies. More work is required to address these issues towards supporting approximate search for the di sk-based computation model. For some applications, such as OASIS [15], a breadth-first traversal of the ST is required. We plan to explore the opportunities for a breadth-first variant (STA-BF) of the of ST representation and evaluate th e performance of the corresponding suffix tree construction and exact match searching algorithms. This work was supported in pa rt by Natural Sciences and Engineering Research Council (NSERC) of Canada, and by ENCS, Concordia University. The authors would like to thank Dr. C. Baker for his helpful discussion and the anonymous reviewers for their useful comments. [1] S.F. Altschul S.F., W. Gish, W. Miller, E.W. Myers, and D.J. [2] S. F. Altschul, T. L. Madden, A. A. Schaeer, J. Zhang, Z. [3] A. Andersson and S. Nilsson. Efficient implementation of [4] A. Apostolico and R. Giancarlo. The Boyer-Moore-Galil [5] R.S. Boyer and J.S . Moore. A fast string searching [6] Christian Charras and Thierry Lecroq. ESMAJ: Exact String [7] R. Giegerich, S. Kurtz, and J. Stoye. Efficient [8] R. Giegerich, S. Kurtz, [9] D. Gusfield. Algorithms on strings, trees and sequences: [10] R. Nigel Horspool . Practical Fast Searching in Strings. In [16] E.M. McCreight. A Space-economical Suffix T [17] D. R. Morrison. PATRICIA -Practical Algorithm to [18] S. Tata, R.A. Hankins, and J. Patel. Practical Suffix Tree 
