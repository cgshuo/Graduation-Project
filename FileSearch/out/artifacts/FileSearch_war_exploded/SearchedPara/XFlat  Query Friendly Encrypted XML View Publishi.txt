 With XML becoming the standard of information exchange and representation over the Internet, more and more large corporations and organizations publish their data in the form of XML. This trend also raises a challenge on how to protect the security of the published data, especially when the data are sensitive. the publish scenario poses more challenges, where the data owner loses control over view relies on the cryptographic technol ogy to combine the access control specifica-visiting the accessible parts in the XML document assigned by the access control specifications. problem of this method lies in repetitive encryption and the extra space cost when the access specification rules as a whole. The encryption process takes a bottom up way. For example, if the accessibility of one sub-tree t 1 is different from that of the parent example, the XPath evaluation over the s ecurity XML view needs to decrypt the en-problem is that the method does not provide the user X  X  specific schema, while the study [1] shows that the exposure of the full document schema may lead to the infor-mation leakage.
 limitations of the current methods, this paper proposes a method called XFlat to pub-lish a query friendly XML view. In summary, our contributions are as follows: z Proposes a method to generate the encrypted XML view. XFlat decomposes a z Proposes a method to evaluate the query over the encrypted XML view. XFlat z Proves that our method meets the security requirement and implements the 
The rest of paper is organized as follows: section 2 describes some preliminary knowledge; section 3 proposes XML published view generation method; section 4 discusses the method to evaluate query over the XML view; section 5 shows the ex-perimental results, section 6 reviews the related works; section 7 concludes the whole paper and discusses the future work. 2.1 XML Security Access Specification ments/attributes by XPath expression [4 ,10]. The access control specifications also element node depends on the explicit assignment or the accessibility of the nearest ancestor if not assigned. object is an XPath (discussed in 2.2) expression in the XML, Condition takes the form read / Write , the Sign =(+,-) of the authorization can be positive (allow access) or nega-tive (forbid access). 2.2 Overview of the Published XML View Fig. 1 illustrates the framework of view generation and query evaluation. In our ap-proach, a security published XML view is generated from XML document, DTD, a published XML view is composed of three layers, namely schema layer containing the user specific schemas, metadata layer containing the relationship among the sub-trees and the encrypted data layer for the sub-trees. sponding keys securely. When user U wants to query the XML view, U needs to sub-mit the keys first. System receives the keys, decrypts and exposes the schema infor-mation to U . User U formulates the XPath based on the schema information. The XPath is evaluated over the decrypted accessible parts of the XML view. users U ={ u 1 ,.. u m }, how to generate the encrypted XML view which meets the follow-ing requirements: the security of the protected data; the specific schema for each user and the minimized space cost and query evaluation cost over the published XML views? The whole process to publish the security XML view is illustrated with the following example. Example 1. Consider each insurance company needs to generate a report and publish this report to a well-known server every month. A fragment of DTD and the related XML of the report is illustrated in Fig. 1. The document conforming to a DTD con-sists of a list of Customers ( Customer *), each customer with children nodes describ-list of sub Categories of insurance. situation of companies, the staffs in other companies want to share some common data, and customers want to know the reputation of each insurance company. Example 2. Access control policies for users in group A and in group B over the in-surance report of Fig. 1 can be specified as follows: Notice that rule 2 will override rule 1 on the customer when the condition of rule 2 is satisfied. 3.1 The LST and the User Specific Schema z The Local Similarity Sub-Tree gion similarity to handle the XML document tree, we decompose the XML tree into a set of sub-trees with the same accessibility on each node in the sub-tree. Formally, the sub-tree can be defined as: user u is a sub-tree in the XML document tree T =( N , E ), where user u can access each with one id which is unique in the whole tree and generated randomly for the purpose of the security. The whole sub-tree is also assigned with one randomly generated unique id. Local similarity sub-tree is shortened as LST in the following. R 1 denotes a child LST of T 1 . original XML tree in the whole. The link relationship to other LST in LST L 1 includes (3, L 2 ), (3, L 3 ). XML tree. In the first visit of each node n in this traversal, we can determine Acc ( n ) and p belong to one LST, or else, node n is marked as the root of one new LST. In the second visit of each node n , we remove the whole sub-tree rooted with node n as one LST if node n is marked with the root and Acc ( n ) is True. In this process, we need to generate the random unique id for each node and for each LST. z Virtual Accessible Tree and User Specific Schema from the node denoted by nid to the root node of LST denoted by tid according to the If there are more than one top LST, we add one virtual LST L 3 with the link to all top LST and L 3 is called the root LST; or else the only top LST is called the root LST. one circle belong to one LST. The dotted lines among the trees represent the relation-ship among the sub-trees. XFlat is XPath based rather than DTD based [1], while the interaction between XPath and DTD entails the un-decidable problem, we generate the user specified DTD not only from the full document DTD and the access control specifications, but also from the current XML document instance. In order to capture the accessibility of the ele-ment type in the DTD, we give the following definition. Definition 4. (The production rule with the accessibility on sub elements type). Given duction rule with the accessibility on sub elements type. A  X   X  for p , where node p is the parent node of node n , A is the element type for the node p . The accessibility mark on element type e for node n can be obtained with the following rules, where the left column denotes the current accessibility of element type e , the top row denotes the accessibility of the current node n . accessOnType ( e )=Y accessOnType ( e )=Y accessOnType ( e )=C accessOnType ( e )=C accessOnType ( e )=C accessOnType ( e )=C accessOnType ( e )=N accessOnType ( e )=C accessOnType ( e )=N type, we derive the user specific schema recursively. That is, as for each element type Type ( e )= C ; recursively find the first accessible element nodes under the element e and replace the element e with the accessible elements in the case of accessOnType ( e )= N . Example 3. the user specified DTD for the users in group A and group B (in Example the validated XML view contains only one element Report.
 3.2 The Merging LST definition 2 with the same accessibility of each node for multiple users. However, the increase of the users and related access specification rules also lead to more LST with the smaller size, which indicates that the increase size of relationship between LST. relationship between the LST, we propose the merging cost model for two LST. L )/ Cost ( L 1 , L 2 ). trees generated. The benefit of the merging can be defined as the number of nodes which belong to both LST. With the merging cost model, we can generate the LST for merging operation between L 1 and L 2 . If the relative benefit exceeds the given thresh-old, we merge two LST together. We repeat the merging process until no two LST can be merged. LST for two users can be described as in Fig. 7, where k 1 is the key owned by staff in group A , and k 2 owned by the user in group B . The relative cost of merging the LST rooted with node 1 for two groups is 7/2. If the threshold for the relative merging cost is set 0.5, four LST are obtained from the original XML tree in a whole. crypt the content of LST? Without the loss of generalization, suppose authorized user A and B are assigned with key k a and k b respectively, we adopt the idea of intermedi-ate key [2] to solve the problem. System generates a key k which can be used in the decrypt the encrypted LST. User B with k b can do it similarly. 3.3 The Whole Framework of the View Generation The final published XML view is composed of three layers, namely schema layer, metadata layer and encrypted data layer. The schema for the published XML view can be described as: each user enclosed by &lt; user &gt;. The schema can be generated with the method in sec-tion 3.1 and will be protected by the encryption in the final XML view. 
The metadata layer enclosed by &lt; Metadata &gt; contains the relationship among the encrypted LST and the intermediate keys for the LST which can be accessed by user encoded by &lt; user &gt;. The link information is also encrypted for the purpose of security. The relation among LST is established from the node enclosed by &lt; FromID &gt; in LST enclosed by &lt; FromSubTreeID &gt; to the root node of LST enclosed by &lt; toSubTreeID &gt;. The intermediate key for each LST is enclosed by &lt; Intermediatekey &gt;. LST. The encrypted data for one sub-tree are enclosed by &lt; CipherText &gt;. In order to distinguish different sub-trees for the metadata layer, we assign each LST with a ran-domly unique ID enclosed by &lt; TreeID &gt;. Given an encrypted published XML view, the authorized user can query the XML view with the given key. Different from the existing methods, the query evaluation needs to consider the underlying flat structure of LST. down fashion. System accepts an XPath and the key, decrypts top LST and evaluates process, we locate the LST L 1 from the metadata layer in the XML view and decrypt L , and evaluate the rest of XPath in L 1 . Such a process will not stop until the XPath has been processed. This method supports the decryption on demand strategy. That is, not all LST are needed to be decrypted in query evaluation. This method works effi-ciently on the axis {/} in XPath. However, the basic method incurs unnecessary cost in the decryption cost in the case of the un-deterministic operators in the XPath, such as ancestor-descendant relation {//} or the wildcards {*}. and reduce the search space. With the top down evaluation strategy, the key problem unnecessary decryption of LST. We use the similar idea in [11, 13] to handle this problem. Both XPath and DTD are translated into tree automata. We define a produc-tion operation over the XPath tree automata and DTD automata. The final form is tree automata with the explicit element in each state transition rule, which can be regarded as the optimized form of XPath in the presence of DTD. lustrated in the following figures: we decrypt the schema information with the key, the schema can be represented by tree automata; we make the production operation between the tree automata for XPath and the tree automata for DTD; The final tree automata can be evaluated directly on the decrypted LST; If another LST is needed in the evaluation, we locate that LST from the metadata layer of the view and evaluate the tree automata further in the decrypted LS T. If the terminal state of the tree auto-mata is reached, we know that the XML meet the requirement of the XPath, and re-turn the current nodes to the user. 5.1 Security Discussion Dan Suciu et al define security property on encrypted XML view in [2]. We discuss the security of the XML view generated by XFlat with the same criteria. Property 1. Suppose t is an XML document, P is a set of access control specifications, and t 0 is the generated XML view in XFlat. As for user s i with key k i
Since XFlat encrypts and stores sub-trees in a sequential way, some one may argue it is possible for an attacker to replace or remove one LST in the XML view. In the case of the replacement of an encrypted sub-tree, the replacement of the encrypted sub-tree will tree, we can not locate the corresponding encrypted sub-tree from the randomly gener-ated id reference stored in the metadata layer, which also raises an exception. In sum-mary, the query evaluation over XML view generated in XFlat terminates abnormally on the replacement and removals of any parts in the final XML view. 5.2 Performance Study We generate test data sets by XMark (http://monetdb.cwi.nl/) and the XML generator with NASA DTD(http://www.cs.washington.edu/research/xmldatasets), and generate the XPath set by the XPath generator [12]. The experiments runs on the Dell Optiplex 260 with CPU 2GHz and 512 MB RAM. The programming language is Java on Win-dows 2000 with JDK 1.31. We make extensive experiments on the encrypted XML view generation and the query evaluation over the encrypted XML published view. 
The XML data set is generated by XMark with factor from 0.001 to 0.005. We gen-erate 10, 20, 30, 40, 50 XPaths using XPath generator with d =0.05, w =0.05, p =0.05, where d , w , p denote for the possibility ratio of {//,*,[]} in the final XPath. The access control specifications are constructed from the generated XPath set. Each 5 XPath are The XPath evaluation set is selected from the generated XPath set. The encryption method we used is AES with the key size 128 (http://www.bouncycastle.org/). 
We mainly compare the work of XFlat and the nested method. We focus on the space and time cost in the XML view construction, and the time cost over the en-crypted XML view generated from the different methods. Since the result on the NASA data set shows the same trend as that on the data from XMark, only the results on XMark are reported. 
The left part in the Fig 9 shows the time cost in the XML view generation used in the nested encryption method and XFlat(merged) method. Since the length of the encrypted string and the time of the initialization of AES engine in nested method are much higher shows the result of the space cost of the generated XML view. Although XFlat intro-duce the cost of the metadata between the LST, the size of the generated XML by XFlat matically fills the original plain string to a certain size. The experiments also show that times of the encryption when the number of access rules used in view generation is less. method. We observe that XFlat with DTD consideration is much faster than that of the Nested method and XFlat without DTD. With the consideration of the DTD, less LST is needed to be decrypted in the evaluation process than those in the other methods. Most of XML security research efforts focus on the security techniques at the server side, where any accesses to the data should be via the security layer in the data server. How to express the access control specificatio n in XML is discussed in XACL [6]. The query evaluation over the security XML document is studied in [3]. The granular-ity of access, access-control inheritance, over riding, and conflict resolution have been studied for XML in [4, 5]. XML security view. The user specific DTD is derived from the access control specifi-PTIME[1]. However, the work also has done on the server side, which indicates the work [1] face different problems from that of XFlat. For example, no query rewriting merged dynamically. In addition, the access control specification is XPath-based in XFlat rather than DTD-based in [1]. authorized user with keys. The works include an extension of XQuery to express to access control specifications and a protected tree model for security XML document. cryption, which lead to the high cost of query evaluation. in a bottom-up fashion is discussed in [10]. The evaluation strategy in a top-down be expressed in some kind of the automata. The production of the automata can be used as the optimized form of XPath. However, the XPath evaluation in our paper runs at the granularity of sub-trees. In our paper, a method called XFlat is proposed to implement the access control specifications over XML document. XFlat not only guarantees the security of the XML view, but also improves the query evaluation efficiency over the XML view. Experimental results illustrate the effectiveness of our method. Future work includes the inference information detection of the published XML view. 
