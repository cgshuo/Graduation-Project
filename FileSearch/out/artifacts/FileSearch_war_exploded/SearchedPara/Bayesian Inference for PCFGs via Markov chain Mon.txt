 The standard methods for inferring the parameters of probabilistic models in computational linguistics are based on the principle of maximum-likelihood esti-mation; for example, the parameters of Probabilistic Context-Free Grammars (PCFGs) are typically es-timated from strings of terminals using the Inside-Outside (IO) algorithm, an instance of the Ex-pectation Maximization (EM) procedure (Lari and Young, 1990). However, much recent work in ma-chine learning and statistics has turned away from maximum-likelihood in favor of Bayesian methods, and there is increasing interest in Bayesian methods in computational linguistics as well (Finkel et al., 2006). This paper presents two Markov chain Monte Carlo (MCMC) algorithms for inferring PCFGs and their parses from strings alone. These can be viewed as Bayesian alternatives to the IO algorithm.
The goal of Bayesian inference is to compute a distribution over plausible parameter values. This  X  X osterior X  distribution is obtained by combining the likelihood with a  X  X rior X  distribution P(  X  ) over pa-rameter values  X  . In the case of PCFG inference  X  is the vector of rule probabilities, and the prior might assert a preference for a sparse grammar (see be-low). The posterior probability of each value of  X  is given by Bayes X  rule:
In principle Equation 1 defines the posterior prob-ability of any value of  X  , but computing this may not be tractable analytically or numerically. For this reason a variety of methods have been developed to support approximate Bayesian inference. One of the most popular methods is Markov chain Monte Carlo (MCMC), in which a Markov chain is used to sam-ple from the posterior distribution.

This paper presents two new MCMC algorithms for inferring the posterior distribution over parses and rule probabilities given a corpus of strings. The first algorithm is a component-wise Gibbs sampler which is very similar in spirit to the EM algo-rithm, drawing parse trees conditioned on the cur-rent parameter values and then sampling the param-eters conditioned on the current set of parse trees. The second algorithm is a component-wise Hastings sampler that  X  X ollapses X  the probabilistic model, in-tegrating over the rule probabilities of the PCFG, with the goal of speeding convergence. Both algo-rithms use an efficient dynamic programming tech-nique to sample parse trees.

Given their usefulness in other disciplines, we believe that Bayesian methods like these are likely to be of general utility in computational linguis-tics as well. As a simple illustrative example, we use these methods to infer morphological parses for verbs from Sesotho, a southern Bantu language with agglutinating morphology. Our results illustrate that Bayesian inference using a prior that favors sparsity can produce linguistically reasonable analyses in sit-uations in which EM does not.
 The rest of this paper is structured as follows. The next section introduces the background for our paper, summarizing the key ideas behind PCFGs, Bayesian inference, and MCMC. Section 3 intro-duces our first MCMC algorithm, a Gibbs sampler for PCFGs. Section 4 describes an algorithm for sampling trees from the distribution over trees de-fined by a PCFG. Section 5 shows how to integrate out the rule weight parameters  X  in a PCFG, allow-ing us to sample directly from the posterior distribu-tion over parses for a corpus of strings. Finally, Sec-tion 6 illustrates these methods in learning Sesotho morphology. 2.1 Probabilistic context-free grammars Let G = ( T, N, S, R ) be a Context-Free Grammar in Chomsky normal form with no useless produc-tions, where T is a finite set of terminal symbols , N is a finite set of nonterminal symbols (disjoint from T ), S  X  N is a distinguished nonterminal called the start symbol , and R is a finite set of productions of the form A  X  B C or A  X  w , where A, B, C  X  N and w  X  T . In what follows we use  X  as a variable ranging over ( N  X  N )  X  T .

A Probabilistic Context-Free Grammar ( G,  X  ) is a pair consisting of a context-free grammar G and a real-valued vector  X  of length | R | indexed by pro-ductions, where  X  associated with the production A  X   X   X  R . We require that  X  A  X  N , P A
A PCFG ( G,  X  ) defines a probability distribution over trees t as follows: where t is generated by G and f of times the production r = A  X   X   X  R is used in the derivation of t . If G does not generate t let P
G ( t |  X  ) = 0 the sequence of terminals labeling its leaves. The probability of a string w  X  T + of terminals is the sum of the probability of all trees with yield w , i.e.: 2.2 Bayesian inference for PCFGs Given a corpus of strings w = ( w each w CFG G , we would like to be able to infer the pro-duction probabilities  X  that best describe that corpus. Taking w to be our data, we can apply Bayes X  rule (Equation 1) to obtain: Using t to denote a sequence of parse trees for w , we can compute the joint posterior distribution over t and  X  , and then marginalize over t , with P(  X  | w ) = t P( t ,  X  | w ) and  X  is given by: with P( w 2.3 Dirichlet priors The first step towards computing the posterior dis-tribution is to define a prior on  X  . We take P(  X  ) to be a product of Dirichlet distributions, with one dis-tribution for each non-terminal A  X  N . The prior is parameterized by a positive real valued vector  X  indexed by productions R , so each production prob-ability  X  eter  X  with left-hand side A , and let  X  the component subvectors of  X  and  X  respectively indexed by productions in R P
D (  X  |  X  ) where  X  is the generalized factorial function and C (  X  ) is a normalization constant that does not de-pend on  X 
Dirichlet priors are useful because they are con-jugate to the distribution over trees defined by a PCFG. This means that the posterior distribution on  X  given a set of parse trees, P(  X  | t ,  X  ) , is also a Dirichlet distribution. Applying Bayes X  rule, which is a Dirichlet distribution with parameters f ( t ) +  X  , where f ( t ) is the vector of production counts in t indexed by r  X  R . We can thus write: which makes it clear that the production counts com-bine directly with the parameters of the prior. 2.4 Markov chain Monte Carlo Having defined a prior on  X  , the posterior distribu-tion over t and  X  is fully determined by a corpus w . Unfortunately, computing the posterior probabil-ity of even a single choice of t and  X  is intractable, as evaluating the normalizing constant for this dis-tribution requires summing over all possible parses for the entire corpus and all sets of production prob-abilities. Nonetheless, it is possible to define al-gorithms that sample from this distribution using Markov chain Monte Carlo (MCMC).

MCMC algorithms construct a Markov chain whose states s  X  S are the objects we wish to sam-ple. The state space S is typically astronomically large  X  in our case, the state space includes all pos-sible parses of the entire training corpus w  X  and scheme guaranteed to converge to the desired distri-bution  X  ( s ) (in our case, the posterior distribution). We  X  X un X  the Markov chain (i.e., starting in initial state s ple state s ability that the Markov chain is in a particular state, P( s i ) , converging to  X  ( s i ) as i  X  X  X  .

After the chain has run long enough for it to ap-proach its stationary distribution, the expectation E  X  [ f ] approximated by the average of that function over the set of sample states produced by the algorithm. For example, in our case, given samples ( t i = 1 , . . . ,  X  produced by an MCMC algorithm, we can estimate  X  as
The remainder of this paper presents two MCMC algorithms for PCFGs. Both algorithms proceed by setting the initial state of the Markov chain to a guess for ( t ,  X  ) and then sampling successive states using a particular transition matrix. The key difference be-twen the two algorithms is the form of the transition matrix they assume. The Gibbs sampler (Geman and Geman, 1984) is one of the simplest MCMC methods, in which tran-sitions between states of the Markov chain result from sampling each component of the state condi-tioned on the current value of all other variables. In our case, this means alternating between sampling from two distributions: Thus every two steps we generate a new sample of t and  X  . This alternation between parsing and up-dating  X  is reminiscent of the EM algorithm, with Figure 1: A Bayes net representation of dependen-cies among the variables in a PCFG. the Expectation step replaced by sampling t and the Maximization step replaced by sampling  X  .

The dependencies among variables in a PCFG are depicted graphically in Figure 1, which makes clear that the Gibbs sampler is highly parallelizable (just like the EM algorithm). Specifically, the parses t are independent given  X  and so can be sampled in parallel from the following distribution as described in the next section.

We make use of the fact that the posterior is a product of independent Dirichlet distributions in or-der to sample  X  from P probabilities  X  sampled from a Dirchlet distibution with parameters
A = f A ( t ) +  X  A sampling  X  = (  X  bution with parameters  X  = (  X  simplest being sampling x tribution for j = 1 , . . . , m and then setting  X  x / P m k =1 x k (Gentle, 2003). This section completes the description of the Gibbs sampler for ( t ,  X  ) by describing a dynamic program-ming algorithm for sampling trees from the set of parses for a string generated by a PCFG. This al-gorithm appears fairly widely known: it was de-scribed by Goodman (1998) and Finkel et al (2006) and used by Ding et al (2005), and is very simi-lar to other dynamic programming algorithms for CFGs, so we only summarize it here. The algo-rithm consists of two steps. The first step con-structs a standard  X  X nside X  table or chart, as used in the Inside-Outside algorithm for PCFGs (Lari and Young, 1990). The second step involves a recursion from larger to smaller strings, sampling from the productions that expand each string and construct-ing the corresponding tree in a top-down fashion.
In this section we take w to be a string of terminal symbols w = ( w and define w string from w ( T, N, A, R ) , i.e., a CFG just like G except that the start symbol has been replaced with A , so, P is the probability of a tree t whose root node is la-beled A and P ties of all trees whose root nodes are labeled A with yield w .

The Inside algorithm takes as input a PCFG ( G,  X  ) and a string w = w 0 ,n and constructs a ta-ble with entries p i &lt; k  X  n , where p A,i,k = P G probability of A rewriting to w are recursively defined below, and computed by enu-merating all feasible i, k and A in any order such that all smaller values of k  X  i are enumerated before any larger values. p for all A, B, C  X  N and 0  X  i &lt; j &lt; k  X  n . At the end of the Inside algorithm, P
The second step of the sampling algorithm uses the function S AMPLE , which returns a sample from P
G ( t | w,  X  ) table p terminal A  X  N and a pair of string positions 0  X  i &lt; k  X  n and returns a tree drawn from P selecting the production A  X  B C to expand the A , and then recursively calling itself to expand B and C respectively. function S AMPLE ( A, i, k ) : if k  X  i = 1 then return T REE ( A, w ( j, B, C ) = M ULTI ( A, i, k ) return T REE ( A, S AMPLE ( B, i, j ) , S AMPLE ( C, j, k )) In this pseudo-code, T REE is a function that con-structs unary or binary tree nodes respectively, and M
ULTI is a function that produces samples from a multinomial distribution over the possible  X  X plit X  positions j and nonterminal children B and C , where:
P( j, B, C ) = The Gibbs sampler described in Section 3 has the disadvantage that each sample of  X  re-quires reparsing the training corpus w . In this section, we describe a component-wise Hastings algorithm for sampling directly from P( t | w ,  X  ) , marginalizing over the produc-tion probabilities  X  . Transitions between states are produced by sampling parses t t i = ( t 1 , . . . , t i  X  1 , t i +1 , . . . , t n ) of parses for w Marginalizing over  X  effectively means that the production probabilities are updated after each sentence is parsed, so it is reasonable to expect that this algorithm will converge faster than the Gibbs sampler described earlier. While the sampler does not explicitly provide samples of  X  , the results outlined in Sections 2.3 and 3 can be used to sample the posterior distribution over  X  for each sample of t if required.
 Let P  X  be the probability simplex for  X  . Then by inte-grating over the posterior Dirichlet distributions we have: where C was defined in Equation 2. Because we are marginalizing over  X  , the trees t dent upon one another. Intuitively, this is because w how some other string w
We can use Equation 3 to compute the conditional probability P( t Now, if we could sample from we could construct a Gibbs sampler whose states were the parse trees t . Unfortunately, we don X  X  even know if there is an efficient algorithm for calculat-ing P( w gorithm for this distribution.

Fortunately, this difficulty is not fatal. A Hast-ings sampler for a probability distribution  X  ( s ) is an MCMC algorithm that makes use of a proposal distribution Q ( s  X  | s ) from which it draws samples, and uses an acceptance/rejection scheme to define a transition kernel with the desired distribution  X  ( s ) . Specifically, given the current state s , a sample s  X  6 = s drawn from Q ( s  X  | s ) is accepted as the next state with probability and with probability 1  X  A ( s, s  X  ) the proposal is re-jected and the next state is the current state s .
We use a component-wise proposal distribution, generating new proposed values for t chosen at random. Our proposal distribution is the posterior distribution over parse trees generated by the PCFG with grammar G and production proba-bilities  X   X  , where  X   X  is chosen based on the current t sampler is as follows. First, we compute  X   X  from t tion 4. Finally, we accept the proposal t  X  old parse t A ( t i , t  X  i ) = min The key advantage of the Hastings sampler over the Gibbs sampler here is that because the acceptance probability is a ratio of probabilities, the difficult to compute P( w the numerator and denominator, and hence is not re-quired. The P ( w for both the numerator and the denominator since our proposal distribution can only generate trees for which w
All that remains is to specify the production prob-abilities  X   X  of the proposal distribution P( t  X  While the acceptance rule used in the Hastings algorithm ensures that it produces samples from P( t i | w i , t  X  i ,  X  ) with any proposal grammar  X   X  which all productions have nonzero probability, the algorithm is more efficient (i.e., fewer proposals are rejected) if the proposal distribution is close to the distribution to be sampled.

Given the observations above about the corre-spondence between terms in P( t relative frequency of the corresponding productions in t  X  i , we set  X   X  to the expected value E[  X  | t  X  i ,  X  ]  X  given t As stated in the introduction, the primary contribu-tion of this paper is introducing MCMC methods for Bayesian inference to computational linguistics. Bayesian inference using MCMC is a technique of generic utility, much like Expectation-Maximization and other general inference techniques, and we be-lieve that it belongs in every computational linguist X  X  toolbox alongside these other techniques.

Inferring a PCFG to describe the syntac-tic structure of a natural language is an obvi-ous application of grammar inference techniques, and it is well-known that PCFG inference us-ing maximum-likelihood techniques such as the Inside-Outside (IO) algorithm, a dynamic program-ming Expectation-Maximization (EM) algorithm for PCFGs, performs extremely poorly on such tasks. We have applied the Bayesian MCMC methods de-scribed here to such problems and obtain results very similar to those produced using IO. We be-lieve that the primary reason why both IO and the Bayesian methods perform so poorly on this task is that simple PCFGs are not accurate models of English syntactic structure. We know that PCFGs Figure 2: A Dirichlet prior  X  on a binomial parame-ter  X  trated around 0 . that represent only major phrasal categories ignore a wide variety of lexical and syntactic dependen-cies in natural language. State-of-the-art systems for unsupervised syntactic structure induction sys-tem uses models that are very different to these kinds of PCFGs (Klein and Manning, 2004; Smith and
Our goal in this section is modest: we aim merely to provide an illustrative example of Bayesian infer-ence using MCMC. As Figure 2 shows, when the Dirichlet prior parameter  X  probability P trated around 0. This ability to bias the sampler toward sparse grammars (i.e., grammars in which many productions have probabilities close to 0) is useful when we attempt to identify relevant produc-tions from a much larger set of possible productions via parameter estimation.

The Bantu language Sesotho is a richly agglutina-tive language, in which verbs consist of a sequence of morphemes, including optional Subject Markers (
SM ), Tense ( T ), Object Markers ( OM ), Mood ( M and derivational affixes as well as the obligatory Verb stem ( V ), as shown in the following example: We used an implementation of the Hastings sampler described in Section 5 to infer morphological parses t for a corpus w of 2,283 unsegmented Sesotho verb types extracted from the Sesotho corpus avail-able from C HILDES (MacWhinney and Snow, 1985; Demuth, 1992). We chose this corpus because the words have been morphologically segmented manu-ally, making it possible for us to evaluate the mor-phological parses produced by our system. We con-structed a CFG G containing the following produc-tions together with productions expanding the pretermi-nals SM , T , OM , V and M to each of the 16,350 dis-tinct substrings occuring anywhere in the corpus, producting a grammar with 81,755 productions in all. In effect, G encodes the basic morphologi-cal structure of the Sesotho verb (ignoring factors such as derivation morphology and irregular forms), but provides no information about the phonological identity of the morphemes.
 Note that G actually generates a finite language. However, G parameterizes the probability distribu-tion over the strings it generates in a manner that would be difficult to succintly characterize except in terms of the productions given above. Moreover, with approximately 20 times more productions than training strings, each string is highly ambiguous and estimation is highly underconstrained, so it provides an excellent test-bed for sparse priors.

We estimated the morphological parses t in two ways. First, we ran the IO algorithm initialized with a uniform initial estimate  X  an estimate of the MLE  X   X  , and then computed the Viterbi parses  X  t of the training corpus w with respect to the PCFG ( G,  X   X  ) . Second, we ran the Hastings sampler initialized with trees sampled from ( G,  X  with several different values for the parameters of the prior. We experimented with a number of tech-niques for speeding convergence of both the IO and Hastings algorithms, and two of these were particu-larly effective on this problem. Annealing, i.e., us-perature X  parameter starting around 5 and slowly ad-justed toward 1, sped the convergence of both algo-rithms. We ran both algorithms for several thousand iterations over the corpus, and both seemed to con-verge fairly quickly once  X  was set to 1.  X  X ittering X  the initial estimate of  X  used in the IO algorithm also sped its convergence.

The IO algorithm converges to a solution where  X 
Word  X  V = 1 , and every string w  X  w is analysed as a single morpheme V . (In fact, in this grammar P( w i |  X  ) is the empirical probability of w i , and it is easy to prove that this  X  is the MLE).

The samples t produced by the Hastings algo-rithm depend on the parameters of the Dirichlet prior. We set  X  ductions r . We found that for  X  &gt; 10  X  2 the sam-ples produced by the Hastings algorithm were the same trivial analyses as those produced by the IO algorithm, but as  X  was reduced below this t be-gan to exhibit nontrivial structure. We evaluated the quality of the segmentations in the morpholog-ical analyses t in terms of unlabeled precision, re-call, f-score and exact match (the fraction of words correctly segmented into morphemes; we ignored morpheme labels because the manual morphological analyses contain many morpheme labels that we did not include in G ). Figure 3 contains a plot of how these quantities vary with  X  ; obtaining an f-score of 0.75 and an exact word match accuracy of 0.54 at are both 0). Note that we obtained good results as  X  was varied over several orders of magnitude, so the actual value of  X  is not critical. Thus in this appli-cation the ability to prefer sparse grammars enables us to find linguistically meaningful analyses. This ability to find linguistically meaningful structure is relatively rare in our experience with unsupervised PCFG induction.

We also experimented with a version of IO modi-fied to perform Bayesian MAP estimation, where the Maximization step of the IO procedure is replaced with Bayesian inference using a Dirichlet prior, i.e., where the rule probabilities  X  ( k ) at iteration k are es-timated using: Clearly such an approach is very closely related to the Bayesian procedures presented in this article, Figure 3: Accuracy of morphological segmentations of Sesotho verbs proposed by the Hastings algo-rithms as a function of Dirichlet prior parameter  X  . F-score, precision and recall are unlabeled mor-pheme scores, while Exact is the fraction of words correctly segmented. and in some circumstances this may be a useful estimator. However, in our experiments with the Sesotho data above we found that for the small val-ues of  X  necessary to obtain a sparse solution,the expected rule count E[ f than 1  X   X  . Thus on the next iteration  X  ing in there being no parse whatsoever for many of the strings in the training data. Variational Bayesian techniques offer a systematic way of dealing with these problems, but we leave this for further work. This paper has described basic algorithms for per-forming Bayesian inference over PCFGs given ter-minal strings. We presented two Markov chain Monte Carlo algorithms (a Gibbs and a Hastings sampling algorithm) for sampling from the posterior distribution over parse trees given a corpus of their yields and a Dirichlet product prior over the produc-tion probabilities. As a component of these algo-rithms we described an efficient dynamic program-ming algorithm for sampling trees from a PCFG which is useful in its own right. We used these sampling algorithms to infer morphological analy-ses of Sesotho verbs given their strings (a task on which the standard Maximum Likelihood estimator returns a trivial and linguistically uninteresting so-lution), achieving 0.75 unlabeled morpheme f-score and 0.54 exact word match accuracy. Thus this is one of the few cases we are aware of in which a PCFG estimation procedure returns linguistically meaningful structure. We attribute this to the ability of the Bayesian prior to prefer sparse grammars.
We expect that these algorithms will be of inter-est to the computational linguistics community both because a Bayesian approach to PCFG estimation is more flexible than the Maximum Likelihood meth-ods that currently dominate the field (c.f., the use of a prior as a bias towards sparse solutions), and because these techniques provide essential building blocks for more complex models.

