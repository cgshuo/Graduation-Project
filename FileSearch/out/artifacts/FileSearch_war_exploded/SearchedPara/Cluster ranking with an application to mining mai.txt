 Ziv Bar-Yossef  X  Ido Guy  X  Ronny Lempel  X  Yo X lle S. Maarek  X  Vladimir Soroka Abstract We initiate the study of a new clustering framework, called cluster ranking . orders the clusters by their strength . To this end, we introduce a novel strength measure for clusters X  X he integrated cohesion  X  X hich is applicable to arbitrary weighted networks. We then present a new cluster ranking algorithm, called C-Rank. We provide extensive theoretical and empirical analysis of C-Rank and show that it is likely to have high precision and recall. A main component of C-Rank is a heuristic algorithm for finding sparse vertex separators. At the core of this algorithm is a new connection between vertex betweenness and multicommodity flow. Our experiments focus on mining mailbox networks . A mailbox network is an egocentric social network, consisting of contacts with whom an individual exchanges email. Edges between contacts represent the frequency of their co X  X ccurrence on message headers. C-Rank is well suited to mine such networks, since they are abundant with overlapping communities of highly variable strengths. We demonstrate the effectiveness of C-Rank on the Enron data set, consisting of 130 mailbox networks.
 Keywords Clustering  X  Ranking  X  Communities  X  Social networks  X  Social network analysis  X  Graph algorithms 1 Introduction Cluster ranking: Clustering and community identification in networks is a vast area of study, spanning over multiple disciplines, such as computer science, sociology, physics, and biology. While the literature is abundant with diverse clustering methods, most of them fall within the same framework [ 23 ]: given a network G , find a partition of G that optimizes a predetermined objective function. The various approaches differ in the types of partitions considered (e.g., flat clustering vs. hierarchical clustering), in the assumptions made on the network (e.g., weighted vs. unweighted networks), in the choice of the objective function (e.g., k -means, normalized cuts), and in the techniques used to solve the optimization problem (e.g., agglomerative vs. divisive).

When clustering large networks, clustering algorithms frequently produce masses of clus-ters. This phenomenon is magnified when employing  X  X uzzy X  or  X  X oft X  clustering methods, which partition the network into overlapping clusters. These tend to generate numerous clus-ters even on small networks. The abundance of clusters may make the results hard to digest and interpret. Moreover, typically only a small portion of the clusters are interesting or mea-ningful, giving rise to a  X  X eedle in a haystack X  problem: how to select the important clusters from the masses of results returned?
In order to address the above difficulties, we propose a new clustering framework, called cluster ranking .Givena cluster strength measure , which assigns a  X  X trength score X  to every subset of nodes, and given a maximality criterion , which determines which sets of nodes are sufficiently  X  X omprehensive X  to be considered self-contained (rather than parts of larger clusters), a cluster ranking algorithm outputs the maximal clusters in the network, ordered by their strength. The ranking provides information that is usually not conveyed by traditional clustering: which clusters are more important than others. This information can be used, for instance, to quickly single out the most significant clusters. Similarly to search algorithms in information retrieval, cluster ranking algorithms are measured by precision and recall .Our new clustering framework is described in Sect. 3 .
 Cluster strength measure: A crucial ingredient in the new framework is the choice of a suitable cluster strength measure. A proper definition of such a measure turns out to be a major challenge. Even for unweighted networks, there is no consensus on how to measure quality of a cluster or of a clustering [ 9 , 24 ].

We propose a novel cluster strength measure X  X he integrated cohesion  X  X hich is applicable to arbitrary weighted networks. To define this measure, we first define the cohesion of unweighted clusters. Several notions of edge separators [ 13 , 19 , 24 , 35 , 40 ]have been used in the past to capture how  X  X ohesive X  an unweighted cluster is. We observe that also vertex separators can be used to measure cohesion, while being more effective in detecting overlapping clusters.

Extending cohesion to capture strength of weighted clusters is tricky, since edge weights have to be taken into account as well. A standard approach for handling edge weights is  X  X hresholding X : one determines a threshold T , and transforms the weighted network into an unweighted network, by keeping only the edges whose weight exceeds the threshold T .We show that standard thresholding is insufficient for measuring strength of weighted clusters. We then introduce integrated cohesion as an effective measure of strength for weighted clusters. The integrated cohesion of a cluster is the sum of the cohesion scores of all the unweighted clusters obtained by applying all possible thresholds to the given weighted cluster. Our new cluster strength measures are discussed in Sect. 4 . Cluster ranking algorithm: Having set up the new framework, we present C-Rank: a cluster ranking algorithm. C-Rank is designed to work for networks with arbitrary pairwise similarity weights. The network X  X  nodes are assumed neither to belong to a metric space nor to conform particular an overlapping clustering algorithm.

C-Rank works in three phases. First, it identifies a list of candidate clusters. Then, it ranks these candidates by their integrated cohesion. Finally, it eliminates redundant clusters X  X nes that are non-maximal.

At the core of C-Rank is a hierarchical overlapping clustering procedure, which constructs a hierarchy of overlapping clusters in unweighted networks. This procedure may be of inde-pendent interest. Given a network G , the procedure finds a sparse vertex separator in G ,and uses the separator to split the network into a collection of overlapping clusters. The procedure then recurses on each of the clusters, until reaching cliques or singletons. Interestingly, the hierarchy produced by the procedure may be a DAG (directed acyclic graph), rather than a tree. We provide rigorous theoretical analysis of this procedure and show that it is guaranteed to find all maximal clusters in G (note that other soft clustering algorithms may not have this guarantee and are thus less useful in our framework). The procedure may run in exponential time in the worst-case X  X n unavoidable artifact of the quest for overlapping clusters. Yet, we show that its running time is only polynomial in the output length. In practice, it took C-Rank several minutes to cluster networks consisting of more than a thousand nodes on a standard laptop PC.

Given a weighted network, C-Rank produces candidate clusters by transforming the net-work into multiple unweighted networks using a gradually increasing threshold. The hie-unweighted networks. Full details of the algorithm are given in Sect. 5 .
 Finding sparse vertex separators: A fundamental ingredient of the precedure for building a hierarchy of clusters in unweighted networks is the detection of sparse vertex separators. In the general case, the problem is NP-hard [ 6 ], yet some approximation algorithms exist for finding sparse vertex separators, while making use of semi-definite programming [ 10 , 29 ]. As solving a semi-definite programming problem can be very computationally expensive, these algorithms are not always practical. We thus propose a different heuristic method for finding sparse vertex separators, which is based on multicommodity flow.

In order to find a sparse vertex separator, we show a connection between sparse ver-tex separators and vertex congestion in multicommodity flow: the congestion on the most congested node under a multicommodity flow provides an approximation of the sparsest vertex separator. The proof is based on an extension of an argument that appears in the work of Leighton and Rao [ 29 ]. This result leads to a heuristic algorithm for finding a sparse ver-tex separator by iteratively removing the most congested nodes from the network until the network decomposes into two or more components.

Finding the optimal multicommodity flow requires solving a linear programming problem, which is computationally expensive. We thus find instead the most congested nodes under a specific multicommodity flow X  X he shortest paths multicommodity flow. It was empirically shown that for many networks the value of this flow is close to the value of the optimal multicommodity flow [ 35 ]. The advantage of using a shortest path flow is that the most congested nodes can be found using a dynamic programming algorithm, which is relatively algorithm, we point out a connection, which, to the best of our knowledge, has not been known before, between edge and vertex betweenness and the congestion on edges and nodes in a multicommodity flow. This connection may be of independent interest. Section 6 describes in detail our method for finding sparse vertex separators.
 Mailbox networks: We demonstrate the efficacy of the novel framework and of the C-Rank algorithm in a new domain: clustering mailbox networks. A mailbox network is an  X  X gocen-tric X  social network [ 38 , 47 ] X  X  network centered around a root individual. Unlike global  X  X ociocentric X  networks [ 18 ], it provides the subjective viewpoint of an individual on her social environment. A mailbox network is generated by mining messages in an individual X  X  mailbox. Actors in this network are the individual X  X  group of contacts. The weight of an edge connecting two actors is the number of messages on whose header both actors appear (either as co-recipients, or as a sender and a recipient). This weight represents the strength of the ties between the two actors from the individual X  X  perspective. Mailbox networks are typically abundant with overlapping communities of variable strengths, and thus C-Rank is highly suitable for them.

Automatically discovering communities within mailbox networks could be beneficial in various applications. In email and personal information management systems, the knowledge of one X  X  favorite communities could support the automation of a variety of features such as automatic completion of groups when entering multiple recipients, detection of missing or redundant recipients, suggestion of additional contacts given a certain topic, etc. Email communities might also help in spam filtering by identifying  X  X pam groups X  [ 5 ] and possibly in enhancing the management of blocked lists. In the intelligence domain, communities can evidence gangs or potential criminal groups around known criminals.
 Experimental results: We evaluated C-Rank on our own mailboxes as well as on about 130 mailbox networks generated from the Enron data set [ 27 ]. To evaluate the quality of C-Rank, we adapted the popular edge betweenness clustering algorithm of Girvan and Newman [ 19 ] to the cluster ranking framework, and compared the two algorithms. We found that C-Rank dominates the edge betweenness algorithm under almost any metric. We also evaluated the robustness of C-Rank under random removal of data, and found it to be quite resilient. These results are presented in Sect. 7 .

To the best of our knowledge, there is no other work that explicitly deals with cluster ranking or with cluster strength measures. Yet, cluster strength measures can be sometimes derived from the objective functions that clustering algorithms try to optimize and, conversely, our cluster ranking algorithm is in particular a soft clustering algorithm. We will thus compare our algorithm to other clustering algorithms. In addition, we will discuss other works that are related to the analysis of email networks. 2 Related work 2.1 Clustering The literature on data clustering algorithms typically refers to two major types of cluste-point belongs to exactly one cluster and thus clusters do not overlap. Hierarchical clustering creates a hierarchy of clusters, which is normally specified as a tree. Hierarchical cluste-ring algorithms can be agglomerative or divisive. Agglomerative algorithms (e.g., single link [ 25 ]) create the hierarchy bottom-up, while divisive algorithms (e.g., the edge between-ness algorithm [ 19 ]) work top-down.
 with multiple clusters with different confidence probabilities. Fuzzy clustering can be used in particular to generate overlapping clusters. Our algorithm is a divisive soft hierarchical clustering algorithm.

Unfortunately, there is no single, widely acceptable, definition for clustering and there is no standard quality metric for clusterings. In fact, many of the common clustering methods are known to work badly in some situations (cf. [ 9 , 24 ]). Kleinberg [ 26 ] showed that this situation is not a coincidence, as no clustering metric can consistently satisfy three simple and natural properties. Many of the known measures are suited for restricted scenarios, such as model-based clustering or clustering of metric space data points. In what follows, we briefly review some of the prominent families of clustering algorithms.
 Clustering of metric space data points: Some clustering algorithms assume the data points lie in a metric space, where a proper distance function that satisfies the triangle inequality distances among the nodes within clusters (e.g., minimum diameter) or between the nodes and the cluster centroids (e.g., sum-of-squares). Some of these methods assume the number of desired clusters is given as a parameter, others try to minimize the number of clusters, while maintaining high value of the objective function.

One of the most common and simple algorithms for clustering points in a metric space centroid is nearest. The centroid is determined as the average (mean) of all the cluster X  X  points. The process stops when some convergence criterion is met, usually that the location means (cf. [ 7 ]) X  X  soft clustering variant of k -means X  X ssigns to each data point degrees of associations to clusters. The centroid of a cluster is then defined as the average of all points, weighted by their degree of association to the cluster.

Our clustering algorithm works on edge-weighted networks that may induce a distance between the network X  X  nodes. However, as we consider completely arbitrary edge weights, this distance does not necessarily satisfy the triangle inequality. Thus, metric space methods are too restrictive for our use.
 Graph-theoretic clustering: Our work presents measures and algorithms for clustering, which are based on graph theory. Generally, a graph-theoretic clustering method refers to the points as nodes in a graph, whose edges (and their weights for a weighted graph) are determined by the similarity between the corresponding nodes. A variety of measures and methods for clustering are based on graph theory.

Many of the graph-theoretic methods use the notion of edge separators (a.k.a. edge cuts) to measure the quality of clustering and clusters. An edge separator is a subset of the network X  X  edges whose removal from the network decomposes it into disconnected components. The density of the sparsest edge separator in a cluster is used as a measure of its quality: the more dense this sparsest cut is, the better is the cluster. The underlying idea is that a sparse edge separator means the cluster can easily  X  X reak X  into parts, and is thus not very good. The various methods, some of which are described below, differ in the way the density of edge separators is defined.
The simplest measure of density for edge separators is their size . Under this measure, the sparsest cut is the min cut. As demonstrated by Kannan et al. [ 24 ] (see also Sect. 4 ), min cuts are not good in measuring cluster strength, as cohesive, yet sparse, clusters may be considered weak, while non-cohesive, yet dense, clusters may be considered strong.
Sinclair and Jerrum [ 42 ] defined the conductance of a cluster C = ( V C , E C ) as connect nodes in S with nodes in  X  S . Under this measure, a cut is dense only if the number of edges crossing the cut is high relative to the number of edges within the two sides of the cut. This measure overcomes the caveats of the min cut measure and works well for unweighted networks (see [ 24 ]), but cannot be easily extended to work as well for weighted networks. For example, a cut consisting of a single edge of high weight will be considered dense under this metric. Calculating conductance is computationally expensive (exponential in the number of nodes in the cluster) and it is usually approximated by the spectral gap of the cluster X  X  Laplacian matrix. Edge expansion and sparsest cuts [ 29 ] are two similar measures, which Shi and Malik present another variant, called normalized cuts [ 40 ], in which the density of a cut is defined as:
We u s e vertex separators , rather than edge separators, for measuring the quality of clusters in unweighted networks. While typically being as effective as edge separators in measuring cohesion, vertex separators are more convenient for detecting overlapping clusters. Neither edge separators nor vertex separators are sufficient for capturing the quality of clusters in weighted networks.We therefore introduce the notion of integrated cohesion to measure strength of clusters in such networks. See Section 4 for details.

The most common method for clustering in social network analysis relies on a metric called edge betweenness , due to Girvan and Newman [ 19 ]. The betweenness of an edge is determined by the number of shortest paths that cross it, where shortest paths are considered for all different pairs of nodes in the graph. Specifically, if there are k shortest paths between a pair of nodes, each path contributes 1 k to the betweenness of the edges it passes through. The underlying principle of the algorithm is that edges with high betweenness are the ones that separate clusters. The divisive hierarchical clustering algorithm works as follows: as long as the graph is connected, it finds the edge with highest betweenness value and removes it from the graph. When the graph decomposes, the two connected components are set as children of the original graph in the hierarchy of clusters and the algorithm recurses on each of them. The process stops when reaching singletons.

As previous methods discussed, the edge betweenness measure is also based on the concept of edge separators and is thus less suitable for networks with overlapping clusters. Newman [ 34 ] gave a version of the edge betweenness algorithm that can be applied to obtain hard clustering of weighted networks.

Our algorithm uses an analogous metric to edge betweenness, called vertex betweenness point out a relation, which is new to the best of our knowledge, between edge and vertex betweenness and multicommodity flow. In Sect. 7 we experimentally compare our algorithm to the edge betweenness algorithm for weighted networks. optimal partition that is derived from the hierarchy. To this end, Newman and Girvan [ 35 ] use a measure called modularity , which evaluates the total quality of a partitional clustering. For a given partition of the graph into clusters, modularity considers the number of intra cluster edges relative to their expected number in a random graph with the same degree distribution.
 a cluster to identify strong communities on the Web. For each node in a cluster, they calculate the ratio between intra cluster edges and inter cluster edges. The strength of the cluster is set as the minimum ratio over all cluster X  X  nodes.

The modularity measure, as well as the relative neighborhoods measure, are not purely based on the intrinsic properties of the cluster. Rather, they also depend on the cluster X  X  environment, i.e., its connectivity to the rest of the network. This leads to undesirable effects in certain cases and especially in weighted networks, where even a single highly weighted edge going out of the cluster can significantly reduce its strength.

Several recent articles [ 4 , 28 , 36 ] address clustering of overlapping communities using graph-theoretic methods, however they focus on unweighted networks only.
 Model-based clustering: Model-based clustering assumes the data points are generated according to a finite mixture of underlying probability distributions. In finite mixture models, each component probability distribution corresponds to a cluster. Determining the number of clusters and choosing an appropriate clustering method can be recast as a statistical model choice problem (cf. [ 15 , 16 , 31 ]).

Several works use model-based methods to create a clustering with overlaps. Banfield and Raftery [ 3 ] suggest supporting cluster overlap by allowing some of the features to be common to all clusters. Their proposed method is suitable for Gaussian and non-Gaussian models. Segal et al. [ 39 ] present a probabilistic model for overlapping clustering of genes into processes in which they take part. It seeks for maximizing likelihood over constant variance Gaussians. Banerjee et al. [ 2 ] generalize this method to work with any regular exponential family distribution, making it applicable for a wide class of clustering distance functions.
Model-based clustering is too restrictive to be used in our work, as we consider completely arbitrary edge weights. Thus, we cannot make any assumptions that associate the data with probabilistic models.
 Information-theoretic clustering: Pereira et al. [ 37 ](seealso,[ 43  X  45 ]) initiated the  X  X nfor-mation bottleneck X  approach to clustering. Exploiting rate distortion theory from information theory and  X  X eterministic annealing X  from statistical mechanics, this approach leads to soft algorithm.

The clustering produced in the information bottleneck approach is one that on the one hand maximizes intra-cluster similarity and on the other hand minimizes the mutual infor-mation between clusters and data points. The clustering algorithm maintains a  X  X emperature X  parameter that controls the tradeoff between the two objectives: at low temperatures, the algo-rithm favors low mutual information to high intra-cluster similarity, leading to relatively large and non-cohesive clusters; at high temperatures, the algorithm favors high intra-cluster simi-larity to low mutual information, leading to smaller tightly cohesive clusters. By gradually shifting from low temperatures to high temperatures, the information bottleneck algorithms obtain divisive hierarchical soft clustering. This is very similar to what is happening in our algorithm, where the shifting temperature is equivalent to our sliding weight threshold.
The main difference between our algorithm and the information bottleneck algorithms is the measure of cluster strength (or intra-cluster similarity). Roughly speaking, in the infor-mation bottleneck approach intra-cluster similarity is measured as the total weight of edges within a cluster, normalized by the confidence levels within which nodes are assigned to the cluster. Note that this similarity measure is indifferent to the distribution of weights among the intra-cluster edges. This may lead to anomalies in certain cases. For example, a cluster that consists of two large cliques, all of whose edges are of low weight, and that are connec-ted by a single edge of a very high weight, is likely to be regarded as a strong cluster in the information bottleneck approach and as a poor cluster in our approach. 2.2 Communities in Email networks Several works study communities in email networks. Tyler et al. [ 46 ] mine communities in sociocentric email networks, i.e., ones extracted from the viewpoint of an organization X  X  mail server. By repeatedly applying the edge betweenness algorithm, they practically create a variation of a fuzzy clustering algorithm.

Fisher and Dourish [ 12 ]andFisher[ 11 ] study egocentric mailbox networks as we do, yet they detect communities by manual inspection and not by an automatic algorithm.

Boykin and Roychowdhury [ 5 ] mine communities in mailbox networks in order to detect  X  X pam communities X . Their clustering algorithm, however, is too coarse to reveal the overall community structure of the network. They essentially analyze the connected components of the graph, trying to predict if they represent a normal community or a spam community by the clustering coefficient of the community.

Farnham et al. [ 8 ] create a mailbox-based visualization of a user X  X  social network. As part of the visualization, they present a partition of the user X  X  contacts into groups based on their co-occurrence on email headers. To this end, they make use of a hierarchical agglomerative clustering algorithm.

McCallum et al. [ 32 ] cluster email messages in an individual X  X  mailbox, based on their text content, rather than on the message headers. 3 Cluster ranking framework Throughout, G = ( V G , E G ) is an undirected network and n =| V G | is the number of nodes in G . G has no parallel edges, yet self loop edges are allowed. Every edge e  X  E G is associated with a non-negative weight w( e ) . The weight represents the strength of the tie between the two connected nodes. The self loop weight represents the intrinsic  X  X mportance X  of the corresponding node. If u and v are not connected by an edge, we implicitly assume w( u ,v) = 0. In the special case all edge weights are 1, G is called an unweighted network. Note that edge weights can be arbitrary, and in particular need not correspond to a metric. The first basic ingredient of the cluster ranking framework is the following: Definition 1 ( cluster strength measure) A cluster strength measure is a function  X  , mapping networks to non-negative real values.  X ( C ) is the cluster strength of a network C . Intuitively,  X ( C ) represents how  X  X trong X  C is as a cluster. There could be many possible realizations of this definition, depending on the properties of a cluster viewed as making it  X  X trong X . One simple example is the clique strength measure for unweighted networks. This measure takes on only Boolean values: a network C is of strength 1 if it is a clique, and is of strength 0 otherwise. Under this measure, then, only cliques are considered clusters. In Sect. 4 we propose a new strength measure that suits weighted networks with overlapping clusters.

Cluster strength is an intrinsic property of the network C . Typically, C is a subset of a larger network G . The cluster strength depends only on the internal connectivity within C and not on how C is connected to the rest of the network G . Nevertheless, cluster strength by itself is clearly insufficient to represent the  X  X esired X  clusters in a network. For example, a small clique A , which is embedded in a larger clique B , is strong under the clique strength measure, but is evidently not very interesting, because it is simply an integral part of the larger clique. In order to capture these redundant clusters, we introduce the second basic ingredient of the framework: Definition 2 ( maximality criterion) Let G = ( V G , E G ) beanetwork.A maximality criterion is a Boolean function, mapping subsets of V G to { 0 , 1 } . All the subsets that are mapped to 1 are called maximal and all the subsets that are mapped to 0 are called non-maximal . A natural maximality criterion in the cliques example maps a set C to 1 if and only if it is a clique and not contained in any other clique. The maximal clusters in this case are the maximal cliques in G .
 We can now state the cluster ranking problem: The cluster ranking problem, as stated, could be a hard optimization problem. One immediate difficulty is that the number of maximal clusters may be very large, so just outputting them may take a long time. We thus measure the performance of ranking algorithms not only relative to the input length but also relative to the output length (the so called  X  X nput-output complexity X ). A more serious problem is that typically the computational problem itself given network C might be intractable. It follows that in reality we cannot expect a ranking algorithm to provide an exact solution to the ranking problem. A typical ranking algorithm may include on its list non-maximal clusters and/or may miss some maximal clusters. We thus adapt information retrieval metrics to evaluate the quality of cluster ranking algorithms.
For a network G and for a ranking algorithm A ,let A ( G ) be the list of clusters returned by A when given G as input. Let I ( G ) denote the  X  X deal X  desired output of A , i.e., the list of all maximal clusters in G . Our metrics try to quantify the difference between A ( G ) and I ( G ) .

The recall of A is the fraction of maximal clusters output by A :
The precision of A is the fraction of maximal clusters among the clusters output by A : 4 New cluster strength measure and maximality criterion In this section we develop a new measure of cluster strength and a corresponding maximality criterion. Our measure is quite general, and in particular is suited for finding overlapping clusters in networks with arbitrary weights. 4.1 Unweighted networks We start with the simpler case of unweighted networks. In such networks, two nodes are  X  X atisfied X  being in the same cluster if and only if they are connected by an edge. Satisfied pairs of nodes wish to keep the cluster intact, while unsatisfied pairs want to break it apart. A strong cluster is one which is  X  X ohesive X  in the sense that no decomposition of the cluster into pieces will create more satisfaction than keeping the cluster undivided.

The above intuition has been formalized via various notions of graph partitioning, such as neighborhoods [ 13 ]. The underlying principle in all these approaches is the same: a network is cohesive if and only if it does not have any  X  X eak X  edge separator (a.k.a. edge cut). An edge separator is a subset of the network X  X  edges whose removal from the network makes the network disconnected. The above approaches differ in the way they measure the  X  X eakness X  of the edge separator.

An edge separator induces a natural decomposition of the network into disjoint parts. Edge separators are less natural for detecting overlapping clusters within the network. A simple example for this is illustrated in Figure 1 . Here, we have two cliques of size n that overlap in a single node. The partition induced by any weak edge separator will assign the overlapping node to one of the two cliques, while we would clearly like to assign the node to both cliques.
To address the above difficulty, we resort to vertex separators , rather than edge separators, for measuring the cohesion of unweighted networks. A vertex separator is a subset of the network X  X  nodes whose removal leaves the network disconnected. In the example network above, the single node in which the two cliques overlap is a vertex separator. Intuitively, a network is cohesive if and only if it is robust to removal of nodes, i.e., it does not have a small vertex separator that separates the network into large pieces.

Formally, a vertex separator of an undirected and unweighted network C = ( V C , E C ) is a subset S of V C s.t. the network induced on V C \ S (i.e., the network obtained from C by removing S and all its incident edges) is disconnected. A partition induced by a vertex separator S is a partition of V C \ S into two disjoint sets A and B s.t. no edge in E
C connects A and B . Note that the same separator may induce multiple different parti-(cf. [ 1 , 10 ]): Definition 3 ( network cohesion) Let C = ( V C , E C ) be an unweighted network. The cohesion of C is: where the minimum is over all vertex separators S of C and over all partitions of C induced by small and A and B are both large. That is, under the above definition, a network C is cohesive if and only if it cannot be broken into large pieces by removing a small number of nodes from the network. The fact that the two pieces are large is important, because it may be easy to cut off a small part from a network, even if the network is cohesive, e.g., by isolating a single leaf node. The cohesion of a network takes on values between 0 (for disconnected networks) and 1 (for cliques).

We note that vertex separators are not always perfect for capturing cohesion. For example, a network consisting of two cliques of size n ,wherethe i -th node in one clique is connected to the i -th node in the other clique, has no small vertex separators, but naturally decomposes into the two cliques. This may hint that there is no  X  X erfect X  measure that captures cohesion of all networks, similarly to the impossibility of defining a measure of clustering that satisfies simple axioms [ 26 ].

Computing the cohesion of a network is an NP-hard optimization problem [ 6 ]. Yet, it can be approximated in polynomial time [ 10 , 29 ]. In this paper we use a faster heuristic flow-based approximation of network cohesion, which is described in Sect. 6 . 4.2 Weighted networks In weighted networks cohesion is no longer the sole factor determining cluster strength. Edge weights should be taken into account as well. For example, a clique of size n all of whose edges are of weight 1 and a clique of size n all of whose edges are of weight 100 are equally cohesive. Yet, clearly the latter clique is  X  X tronger X  than the former. How do we then combine cohesion and edge weights into a single strength measure?
One of the popular methods for dealing with weighted networks is  X  X hresholding X  (see, e.g., [ 36 ]): given a weighted network C , one selects a weight threshold T  X  0, and transforms C into an unweighted network C T by changing all the weights that are greater than T to 1 and all the weights that are at most T to 0. C is then clustered by simply clustering C T . This approach, though, is too coarse, especially in the presence of overlapping clusters. To illustrate the problem, consider the example network depicted in Fig. 2 . In this example, we have two nested cliques. A smaller clique A all of whose edges are of weight 10 is nested within a larger clique B , whose other edges are of weight 1. Clearly, both A and B are clusters of interest, yet any choice of a single threshold results in the loss of at least one of them. If 1, then B is lost.

Our crucial observation is that in order to determine the strength of a weighted network, we should not fix a single weight threshold, but rather consider all possible weight thresholds simultaneously . A strong cluster is one that has high cohesion under many different thresholds. Formally, this is captured by the following measure: Definition 4 ( integrated network cohesion) Let C be a weighted network. The integrated cohesion of C is defined as: k . Similarly, the integrated cohesion of a singleton whose self loop weight is k is also k . Although integrated cohesion is defined as a continuous infinite sum, in practice: (1) It is always finite, as for all thresholds T that are greater than the maximum edge weight, C T is an empty graph, and thus cohesion ( C T ) = 0. (2) It can be computed by summing up a finite number of cohesion values. The only weight thresholds in which the induced unweighted network can change are the distinct edge weights of C . Therefore, by summing up at most | E
C | cohesion scores, one can compute the integrated cohesion. 4.3 Maximality criteria We now define maximality criteria for weighted and unweighted networks.
 Unweighted networks: In order to define maximality in unweighted networks, we first discuss the notion of cluster subsumption . Our maximal clusters will be the ones that are not subsumed by any other cluster.

Let us begin with a motivating example. Consider the two clusters depicted in Fig. 3 .The larger cluster D is the union of two overlapping cliques D 1 , D 2 of size n each, whose overlap is of size k . The smaller cluster C is a union of two overlapping cliques C 1 , C 2 of size n / 2 with the overlap between D 1 and D 2 . It can be checked that C is more cohesive than D ,yet clearly C is  X  X ninteresting X , since it is an integral part of D . We would like then to say that D subsumes C , and thus C cannot be maximal. In fact, in this example C is not unique. Any union of a subset of D 1 with a subset of D 2 whose overlap coincides with D 1  X  D 2 will give a cluster, which is more cohesive than D , but is subsumed by D .

What really makes D subsume C in the above example? If we break up D into its natural clusters D 1 and D 2 ,thenalso C breaks up into different pieces ( C 1 and C 2 ). That is, the partition of D induces a partition of C . In fact, it can be argued that every time a partition of some set A into clusters induces a partition of a subset B  X  A into clusters, then A subsumes B . In order to formally define subsumption, we introduce some terminology: Definition 5 ( covers) Let V beaset.A cover of V is a collection of subsets V 1 ,..., V k  X  V whose union is V : k i = 1 V i = V . Note that sets participating in a cover, unlike a partition, can overlap. The cover is called trivial , if at least one of V 1 ,..., V k equals V .Givenasubset V  X  V , the cover of V induced by V 1 ,..., V k is V 1 = V 1  X  V ,..., V k = V k  X  V .
Vertex separators not only provide us with a robust notion of network cohesion, but they also enable us to break up networks into their  X  X atural X  top-level clusters: Definition 6 ( vertex separator cover) Let G = ( V G , E G ) be an unweighted network and let S be a vertex separator of G .Let A 1 ,..., A k be the k connected components of G \ S .The S-cover of G is S  X  A 1 , S  X  A 2 ,..., S  X  A k .
 Note that the clusters participating in a vertex separator cover overlap, because all of them vertex separator of both D and C . The corresponding covers of D and C are D 1 , D 2 and C , C 2 , respectively. We can now define subsumption: Definition 7 ( subsumption) Let C D be two clusters in an unweighted network G . D is said to subsume C , if there exists a sparsest vertex separator S of D , whose corresponding cover induces a non-trivial cover of C .
 In the example above D subsumes C , because the cover corresponding to the sparsest vertex separator of D is D 1 , D 2 , and this cover induces the non-trivial cover C 1 , C 2 of C .
Two remarks are in order: 1. The notion of subsumption does not properly handle cliques, because the vertex separator We can now define maximality in unweighted networks: Definition 8 ( maximality in unweighted networks) Let G = ( V G , E G ) be an unweighted network. A subset C  X  V G is called maximal , if it is not subsumed by any other subset of V In the example network depicted in Fig. 3 , the cluster C cannot be maximal, because it is subsumed by the cluster D .

Using  X  -subsumption rather than subsumption, we could define a corresponding notion of  X  -maximality . For simplicity of exposition, our presentation focuses on standard maximality (  X  = 0).

We would like to show that the above maximality criterion captures natural types of clusters: Lemma 9 Let G be an unweighted network. Then, the connected components of G and the maximal cliques in G are maximal.
 Proof We start with the connected components. Let C be a connected component of G .If G itself is connected, then C = G , and the whole network is always maximal, because it is simply not a proper subset of any other subset of G . Suppose, then, that G is disconnected. Let D be any subset of G that strictly contains C .Since C is a connected component, D must be disconnected. It follows that the sparsest vertex separator of D is empty and the cover corresponding to this separator consists of the connected components of D . C must be one of these components, and thus the cover induced on C by the vertex separator cover is trivial. We conclude that D does not subsume C . As this holds for every D that strictly contains C , C is maximal.

Let C be now a maximal clique in G .If C = G , we are done, so suppose C is a proper subset of G .Let D be any subset of G that strictly contains C . D cannot be a clique, because C is a maximal clique. Let S be the sparsest vertex separator of D ,let A 1 ,..., A k be the connected components of D \ S ,andlet D 1 = S  X  A 1 ,..., D k = S  X  A k be a vertex separator cover of D .Since D is not a clique, then k  X  2. Let C 1 = C  X  D 1 ,..., C k = C  X  D k be the cover of C induced by D 1 ,..., D k . We next argue that there must be an i  X  X  1 ,..., k } s.t. C  X  D i .

Suppose, to reach a contradiction, that C is not a subset of any of D 1 ,..., D k . It follows that C must intersect at least two sets among A 1 ,..., A k . Suppose, for example, C  X  A 1 = X  and C  X  A 2 = X  .Let u be any node in C  X  A 1 and let v be any node in C  X  A 2 .Since A 1 , A 2 are different connected components of D \ S ,then u and v are not connected by an edge in G . On the other hand, both u and v belong to C , contradicting the fact C is a clique.
We conclude that C  X  D i for some i . Hence, C i = C , implying C 1 ,..., C k is a trivial cover of C , and thus C is not subsumed by D . Since this holds for all subsets D of G that strictly contain C , C is maximal.
 Weighted networks: Having defined maximality in unweighted networks, it is quite straight-forward to extend the definition to weighted networks: Definition 10 ( maximality in weighted networks) Let G = ( V G , E G ) be a weighted network. A subset C  X  V G is called maximal , if there exists at least one threshold T  X  0, for which C is maximal in the unweighted network G T .
 In the example network depicted in Fig. 3 , if the edges of the cluster C are all of weight 10 and the rest of the edges in the cluster D are of weight 1, then C is now maximal, because it is maximal in the unweighted network G T ,forall T  X  X  1 , 10 ) .
 Remark 11 A common pattern in social networks is the  X  X nion pattern X  [ 12 ]: a sequence of nested clusters, each of which is only slightly stronger than the cluster it is contained in. This pattern characterizes, for instance, the collaboration within projects: most of the interaction occurs within a core team of project members, while larger circles of consultants are only peripherally involved. The different layers of an  X  X nion X  give rise to clusters that are all maximal. Nevertheless, it is clear that not all of them are of interest. This motivates us to search for clusters that are not just maximal but are rather maximal by a margin . We say that a cluster C is maximal by a margin , if there exists an interval [ T 1 , T 2 ] ,where T  X  ( 1 + ) T 1 ,s.t. C is maximal in G T ,forall T  X  X  T 1 , T 2 ] . For instance, if in the network depicted in Fig. 3 , the weight of edges in C is 1 . 1 rather than 10, then C is maximal in G T , is not maximal, if this margin is greater than 0 . 1. 5 The C-Rank algorithm weighted networks. C-Rank consists of three major phases: (1) identification of candidate maximal clusters. 5.1 Candidate identification in unweighted networks We start with the description of a candidate identification algorithm for unweighted networks. In Sect. 5.2 , we build on this algorithm to identify candidate clusters in weighted networks. Our candidate identification procedure (see Fig. 4 ) finds the sparsest vertex separator of the given network, uses its induced cover to split the network into overlapping clusters, and then recurses on the clusters. The recursion stops when reaching cliques or singletons, since they cannot be further partitioned. If more than one vertex separator exists, one of them is chosen arbitrarily.

As the procedure detects overlapping clusters, it may encounter the same cluster more than once. For example, if clusters C and C overlap, then a cluster within the intersection C  X  C may be detected both at the recursive call on C and at the recursive call on C . Our procedure therefore checks that a cluster is not already on the list, before recursively processing it. This guarantees that the procedure does not perform redundant work.

The procedure not only produces a list of maximal clusters from the given network G , but also implicitly organizes them in a hierarchy , similarly to hierarchical clustering. The difference is that here, due to the overlapping clusters, the hierarchy is not necessarily a tree, but is rather a DAG (directed acyclic graph). The root of the hierarchy is the whole network G and its leaves are either singletons or cliques. Each cluster in the hierarchy is covered by its child clusters. We call such a hierarchy a hierarchical overlapping clustering . Example run: Figure 5 shows an example run of the above procedure on a simple 5-node network. The procedure first detects S ={ c , d } as the sparsest vertex separator of the network and removes it from the network. The resulting connected components are A 1 ={ a , b } and A 2 ={ e } . The procedure adds S to each of the connected components, obtaining the two example, because both of these clusters are cliques.
 Analysis: We next analyze the quality and the performance of the algorithm. We start by showing that the algorithm is guaranteed to have an ultimate recall of 1: Lemma 12 Given an unweighted network G, C-Rank outputs all the maximal clusters in G. Proof Suppose, to reach a contradiction, there exists a maximal cluster C , which is not output by C-Rank. That is, C does not belong to the hierarchy of overlapping clusters constructed by the algorithm. C is clearly a subset of the root of the hierarchy (the whole network G ). It cannot be a subset of any of the leaves of the hierarchy, because each of these leaves is either a singleton (which has no proper subsets) or a clique (all of whose proper subsets are non-maximal). We conclude that there must be some internal node D in the hierarchy s.t. C  X  D but C is not contained in any of the children of D .

Let D 1 ,..., D k be the children of D in the hierarchy. D 1 ,..., D k form a vertex separator cover of D .Let C 1 = C  X  D 1 ,..., C k = C  X  D k be the cover of C induced by D 1 ,..., D k . that C 1 ,..., C k is a non-trivial cover of C , and thus C is subsumed by D . This contradicts our assumption that C is maximal.
 The analysis above establishes that C-Rank has ultimate recall. But what about precision? How likely is C-Rank to output clusters that are non-maximal? When C-Rank splits a cluster C into sub-clusters C 1 ,..., C k using a vertex separator, C 1 ,..., C k are not subsumed by C . If C is maximal, then C 1 ,..., C k are likely to be maximal too. However, this intuition does not always work, as C 1 ,..., C k may be subsumed by subsets of C . This situation, though, rarely happens. We do not have theoretical guarantees about the precision of C-Rank, but we provide empirical evidence in Section 7 that its precision is reasonable.
 The performance of C-Rank is directly related to the number of clusters it produces. Clearly, since the number of maximal clusters can be exponential in the size of the input network G , then C-Rank may run for an exponential amount of time. However, when the list of maximal clusters is short, then C-Rank will also run more quickly: Lemma 13 Suppose that on a given network G C-Rank outputs a list of m candidate clusters C ,..., C m . Then, C-Rank runs in O ( m of time needed to compute the sparsest vertex separator of a network of size n. Proof For each cluster C i output by C-Rank, C-Rank performs the following tasks: (1) testing using BFS); (4) iterating over the connected components of C i \ S and checking whether each time for each cluster C i is O ( r ( | C i | ) +| C i | 2 ) .

Recall that finding the sparsest vertex separator of a network is NP-hard. Hence, in a naive implementation of C-Rank, r ( n ) will be exponential in n , which is of course unacceptable. Therefore, C-Rank does not compute exact sparsest separators, but rather approximate spar-sest separators. These separators are computable in O ( n 4 ) time. The approximation procedure is described in Sect. 6 . 5.2 Candidate identification in weighted networks The simplest way to extract all maximal clusters from a weighted network G = ( V G , E G ) is the following. We enumerate all possible thresholds T (there are at most | E G | such thre-sholds), compute G T , and output all the maximal clusters in G T using the procedure un-weightedCRank. This guarantees that we output all maximal clusters of G , and hence obtain ultimate recall.

The above brute force enumeration could be very time-consuming, since we need to make up to | E G | calls to unweightedCRank, and each call is made over the entire network G . Furthermore, this approach tends to be wasteful, as we may identify the same clusters again and again under different thresholds. For example, a maximal clique all of whose edges are of weight T will be discovered at all thresholds T &lt; T . A natural question is then whether we can trade the ultimate recall guarantee for better performance?
To this end, we make the following observation. What is the reason for a cluster C to be maximal at G T , for some threshold T , while not being maximal at G T ,forall T &lt; T ?This can happen only if for every T &lt; T , there exists a cluster D C that subsumes C at G T , but does not subsume it anymore at G T .If D itself was maximal at G T , then the algorithm should have identified D at that time. This gives us an opportunity for large savings in running time. For every threshold T , after having identified the maximal clusters at G T ,wedonot need to search the entire network for new maximal clusters at the subsequent threshold, but rather only within the maximal clusters of G T . This limits our search space and also enables faster advancement of thresholds.

In practice, our algorithm does not even search within all the maximal clusters, but rather only within the most cohesive ones. Note that the efficiency gains of this approach may come at the price of compromising the ultimate recall guarantee of the algorithm, because we may miss clusters that are subsumed by non-maximal clusters or by noncohesive clusters. The procedure for identifying candidate clusters in weighted networks is depicted in Fig. 6 . Given a network G , the procedure sets a threshold T to be the minimum edge weight in G and computes the unweighted network G T under this threshold. Note that G T has the same edges as G , except for the minimum weight edges that are eliminated. The procedure then finds the maximal clusters in G T and adds them to the list of candidate clusters. Next, the procedure recursively searches for more clusters within the clusters of G T whose cohesion exceeds the cohesion threshold  X  .

The first call to the procedure (i.e., with the original network G ) slightly differs from subsequent recursive calls: the threshold T is set to be 0 and not the minimum edge weight. This guarantees that the first unweighted network processed is G 0 , which has exactly the same edges as G .

The recursion stops when reaching a cluster C and a threshold T s.t. C T cannot be further partitioned into sub-clusters by the procedure that identifies unweighted clusters. This means that C T must be either a clique or a singleton, and thus C is either a homogeneous clique (i.e., a clique all of whose edges are of the same weight) or a singleton.
 Example run: Figures 7 and 8 show an example run of the above procedure on a 5-node network G . The procedure applies a threshold of T = 0 and obtains the unweighted network G 0 depicted in Fig. 7 b. The procedure then finds unweighted clusters in G 0 , resulting in edge weight in this cluster is 2, and thus the procedure applies a threshold T = 2, resulting in the unweighted network depicted in Fig. 8 b. This network breaks into the two clusters { a , b , c } and { d } . More recursive calls are made on these clusters, and we focus on the one made on { a , b , c } (Fig. 8 c). The minimum edge weight this time is T = 5 and thus the resulting unweighted network is the one depicted in Fig. 8 d. Note that the network now consists of singletons only, and therefore the recursion stops. The final list of clusters that C-Rank, because they are not maximal. Setting the threshold: The above procedure chooses a threshold T that equals the minimum edge weight in the given network G . If the network has many distinct edge weights and the gaps between them are small, the procedure may need to make many recursive calls, each time eliminating only a small number of edges from the network.

In order to speed up the performance of the procedure on such networks, we select the threshold T differently. Let w 1 ,...,w t be the distinct edge weights in G , ordered from smallest to largest. T is set to be the smallest weight that is significantly smaller than the subsequent weight. Formally, let  X &gt; 0bethe weight gap parameter and let i  X  be the first i  X  X  1 ,..., t  X  1 } ,s.t. w i ( 1 +  X )  X  w i + 1 . T is set to be w i  X  . 5.3 Candidate ranking At its second phase, C-Rank computes the integrated cohesion of each one of the candidate clusters and ranks them accordingly. The main thing to note is that calculating the integrated cohesion of a cluster C requires computing the cohesion of C T for k values of the threshold T ,where k is the number of distinct edge weights in C . Thus, each such calculation requires 5.4 Candidate elimination The third and last phase of C-Rank consists of eliminating non-maximal clusters from the ranked list of clusters. Testing maximality directly is hard, since to check whether a cluster C is maximal or not, we would need to compare C against all its supersets D C . Each comparison entails testing whether D subsumes C under each one of the possible thresholds T . This process requires exponential enumeration, and moreover every single subsumption test may be prohibitive, since D may have an exponential number of sparsest (or close to sparsest) vertex separators.
 Our candidate elimination procedure, therefore, makes two relaxations. First, each cluster C is compared not against all its possible supersets, but rather only against supersets that also belong to the list of candidates. This significantly reduces the search space and makes the enumeration only polynomial in the number of candidates.
Given a candidate cluster D that strictly contains a candidate cluster C ,wedonottest directly whether D subsumes C under at least one threshold T . We rather simply compare is the maximality margin), we declare D as subsuming C . The idea is that if D subsumes C at G T ,then D is at least (and usually more) cohesive than C in G T . Since cohesion is monotone, D is also expected to be more cohesive than C at G T for all T &lt; T .Thisislikely to make the integrated cohesion of D higher (or at least not much lower) than the integrated cohesion of C .

The above is of course a heuristic, and we may thus misclassify some non-maximal clusters as maximal and vice versa, affecting precision and recall. We evaluate the overall recall and precision of the algorithm in Sect. 7 . 6 Finding sparse vertex separators via vertex betweenness We next address the issue of how to efficiently find sparse vertex separators in unweighted networks. As mentioned above, finding the sparsest vertex separator is NP-hard, yet a sepa-rator whose sparsity is at most O ( time [ 10 ]. Nevertheless, the approximation algorithm is based on semi-definite programming, which can be quite inefficient to solve in practice. We therefore opt for a heuristic estimate of the sparsest separator via network flow. 6.1 Relating cohesion and vertex congestion We start by giving some definitions related to network flow and congestion.

Let G = ( V G , E G ) be a directed, edge-weighted, and strongly connected graph, where n =| V G | .A uniform demand multicommodity flow ( UMFP )on G is a flow f that routes a unit of commodity from every node u  X  V G to every other node v  X  V G .Thereareno capacity constraints on the flow; that is, an arbitrary amount of total flow (summed over all commodities) can be routed over any edge. Formally, we denote by P u v the set of all simple paths from u to v in G and P = u = v P u v .Theflow f is defined as a function from P to R + that satisfies
The congestion on a vertex v  X  V G due to flow f , denoted VC f (v) , is the total amount of flow routed through that vertex. Paths that start or end at v contribute half of their flow to the congestion of v : where the first summation is over paths in which v is an internal node.
 Proposition 14 If n  X  2 and if f is a uniform demand multicommodity flow on G, then for each v  X  V G , VC f (v)  X  1 .
 Proof Since f is a uniform demand flow, each vertex is the endpoint of paths whose total flow is 2  X  ( n  X  1 ) and thus the congestion on each vertex is at least n  X  1  X  1.
The congestion on an edge e = ( u ,v) (where u ,v  X  V G ) due to flow f , denoted EC f ( e ) , is the total amount of flow routed through that edge, normalized by the weight of the edge, w( e ) :
The vertex (resp., edge) congestion on the network due to f , denoted VC f ( G ) edge congestion ) on the network is defined as the minimum vertex (resp., edge) congestion over all flows: VC ( G ) = min f VC f ( G ) (resp., EC ( G ) = min f EC f ( G ) ). Remark 15 The standard way to define a flow is actually different. A flow is defined as a mapping from edges to R + , rather than from P to R + . Moreover, the flow must satisfy the capacity constraints and the value of the flow is defined as the minimum percentage of the demands, satisfied by the flow. It can be shown that the two definitions are equivalent and that the value of the optimal flow essentially equals the inverse of the minimum edge congestion. See Sinclair X  X  work [ 41 ] for more details.
 Let ( U , U c ) be a partition of G into two non-empty, disjoint, and complementary sets. The edge separator, U , U c , is the set of edges directed from U to U c . The sparsity of an edge separator in a UMFP is defined as the weight of the separator normalized by the product of the sizes of U and U c : where w( U , U c ) = e  X  U , U c w( e ) is the weight of the separator and the summation is over edges directed from U to U c .The sparsest edge separator of the network, denoted as  X ( G ) , is the edge separator of minimum sparsity. Leighton and Rao [ 29 ] showed the following relationship between the sparsest edge separator and the minimum edge congestion: Theorem 16 ( Leighton X  X ao)
Our goal is to show a similar relationship between vertex separators and minimum vertex congestion in undirected and unweighted networks. To this end, we use the following trans-formation, 1 which we denote as  X  : given an undirected, unweighted, and connected graph G = ( V G , E G ) , we will produce a directed and weighted graph  X ( G ) = G  X  = ( V G  X  , E G  X  ) where and Figure 9 demonstrates the operation of  X  on a simple graph G .
 Lemma 17 Fo r e a c h U M F P f  X  on G  X  , there exists a UMFP f on G, such that Proof First, we define P  X  , io as the set of all simple paths in G  X  , which start at a node u in and end at a node v out ,where u = v Next,wedefine  X  : P  X  , io  X  P as a function mapping simple paths in G  X  that belong to P  X  , io to simple paths in G in the following way: one source in P  X  , io that is mapped to it by  X  .

Now, given a uniform demand multicommodity flow f  X  on G  X  , we will construct f as a uniform demand multicommodity flow on G in the following way: Note that since (1) f  X  passes a unit of commodity in total on all paths between each ordered pair of vertices s , t  X  V  X  G s.t. s = t , and particularly it passes a unit of commodity between each s , t s.t. s = u in and t = v out and (2) each path in P has exactly one source in P  X  that is mapped to it by  X  ,then f must pass a unit of commodity between each pair of vertices u ,v  X  V G s.t. u = v .
 From the way f was constructed, it follows that for each v  X  V G As the above inequality holds for each v  X  V G , we get the desired result.
 Corollary 18 Lemma 19 For each UMFP f on G, there exists a UMFP f  X  on G  X  , such that Proof We will define four functions  X  ii , X  io , X  oi , X  oo : P  X  P  X  mapping simple paths in G to simple paths in G  X  in the following way. Let p = (v 1 ,v 2 ,...,v k ) be a path in G ,where v  X  V G and v 1 = v k . Then,
In other words,  X  ii , X  io , X  oi , X  oo map each path from u to v in G to four paths in G  X  u ,v  X  V G and for each x , y  X  X  in , out } , every path in P  X  from u x to v y has exactly one source in P that is mapped to it by  X  xy .

Now, given a uniform demand multicommodity flow f on G , we will construct f  X  as a uniform demand multicommodity flow on G  X  in the following way:  X  v  X  V G , f  X  (v in ,v out ) = 1 , f  X  (v out ,v in ) = 1 , otherwise , f  X  ( p  X  ) = 0 .

Note that from the first rule for constructing f  X  and since (1) f passes a unit of commodity in total on all paths between each ordered pair of vertices u ,v  X  V G s.t. u = v and (2) each must pass a unit of commodity between each pair of the form ( u x ,v y ) s.t. x , y  X  X  in , out } and u = v . Then, taking into account the second rule for constructing f  X  , we get that f  X  satisfies all the demands.

As the congestion on all edges whose weight equals  X  is 0 by definition, the edge conges-tion on G  X  due to f  X  derives from the congestion on the edges of the form (v in ,v out ) .From the way f  X  was constructed, it can be easily seen that Using Proposition 14 ,weget are the only edges in G  X  whose congestion is greater than 0, we get the desired result. Corollary 20 Lemma 21 G  X  is strongly connected.
 Proof First, it is clear from the definition of G  X  that there is a path from v pin to v out and from v out to v in for each v  X  V G . Then, given an ordered pair of vertices ( u x , v y ) ,where x , y  X  X  in , out } and u = v , the path from u x to v y will be built based on the path from u to v in G . The latter must exist as G is connected.

We showed a tight relation between the minimum vertex congestion in G and the minimum edge congestion in G  X  , but in order to relate Theorem 16 to vertex separators, we also need to find the relation between the sparsest vertex separator in G and the sparsest edge separator in G  X  .

To this end, we use a slightly different definition for the sparsity of a vertex separator than the one used in Sect. 4 (we relate the two definitions later in this section). Let S beavertex separator in G , which induces a partition of V G \ S into A and B . The sparsity of S is
We now define  X  as a function mapping vertex separators in G to finite-weight edge separators in G  X  as follows. Let S ={ s 1 ,..., s l } ( l  X  1) be a vertex separator in G ,which where l + q + r = n . Then, B Lemma 22 The function  X  is a one-to-one mapping from the vertex separators in G onto the finite-weight edge separators in G  X  .
 Proof First, we will show that the range of  X  consists of finite-weight edge separators only. To this end, we will examine the edges directed from U ={ A in  X  A out  X  S in } to U c = {
S out  X  B in  X  B out } . No edges are directed from A in towards U c as by definition of G  X  ,all outgoing edges from A in are directed to A out  X  U . No edges are directed from A out towards U c as by definition of G  X  , such edges would have been possible only towards B in ,however as S separates A and B in G , such edges do not exist in G  X  . Hence, the only edges from U to U c are edges from S in and by definition of G  X  , such edges can only be directed towards S out . As all edges from S in to S out are of finite weight, the total weight of the separator is finite. The fact that  X  is a one-to-one mapping follows directly from the definition of  X  .
Finally, we will show that every finite-weight edge separator in G  X  has a vertex separator in G that is mapped to it by  X  . Given a finite-weight edge separator U , U c , we will show a corresponding vertex separator { S , A , B } in G .As U , U c has finite weight, all edges from U to U c must be of weight 1, i.e., directed from v in to v out . We will define S ={ v : (v in ,v out )  X  U , U c } . Note that since G  X  is strongly connected and since U and U C are not empty, each edge separator U , U c must contain at least one edge directed from U to U c and thus S is non-empty. As no edges of the form (v out ,v in ) can be directed from U to U , there are no other vertices u  X  V G \ S s.t. u in and u out are on opposite sides of the cut (
U , U c ) . Hence, we can define A ={ v :{ v in ,v out } X  U } and B ={ v :{ v in ,v out } X  U c } . Note that S  X  A = X  , S  X  B = X  , A  X  B = X  ,and S  X  A  X  B = V G . Note also that no edge can connect a node u  X  A with a node v  X  B , as there would then be an infinite-weighted edge from u out  X  U to v in  X  U c . Hence, { S , A , B } is a vertex separator in G , for which  X ( S , A , B ) = U , U c .
 Lemma 23 Proof In the proof of the previous lemma, we showed that the edges from U ={ A in  X  A out  X  S of edges from S in to S out is | S | and since the weight of each such edge is equal to 1, we get w(
U , U c ) =| S | . Putting the last equation in the formula for  X ( U , U c ) and considering the fact that | U |= 2 | A |+| S | and | U c |= 2 | B |+| S | , we get the desired result. Lemma 24 Proof From the fact that  X  is a one-to-one mapping from the vertex separators in G onto the finite-weight edge separators in G  X  (Lemma 22 ), and from the fact that it preserves the value of sparsity (Lemma 23 ), it follows that the value of the sparsest vertex separator of G is equal to the value of the sparsest edge separator of G  X  (which must derive from a finite-weight edge separator).
 Theorem 25 Proof Corollary 20 ties the minimum vertex congestion in G with the minimum edge conges-tion in G  X  . Then, Lemma 24 ties the sparsest vertex separator of G with the sparsest edge separator of G  X  . Using these two relations with Theorem 16 for G  X  ,wegetthedesired result.

As noted above, we used a slightly different definition for the sparsity of vertex separators than the one used in Sect. 4 . We now relate the two definitions: Lemma 26 Proof Feige et al. [ 10 ] used the following definition for the sparsity of a vertex separator:  X  ( S , A , B ) = | S | ( | and thus thus we get As this result is valid for any vertex separator { S , A , B } , we get the desired relationship. Corollary 27
In our algorithm (Sect. 5 ), we used a normalized version of the congestion on a vertex v  X  V G due to flow f : Note that this definition of normalized congestion is different from the definition we used so far in two manners: (1) paths that begin or end with v do not contribute anything to the congestion X  X s the demands are uniform, each vertex is the endpoint of paths whose total amount of flow is 2 ( n  X  1 ) . (2) The congestion is normalized by its highest possible value, 2 , and thus assumes values in NC f ( G ) and NC ( G ) are defined analogously to VC f ( G ) and VC ( G ) .
 Lemma 28 Proof The following relationship between NC ( G ) and VC ( G ) follows from the definition of normalized congestion: The result follows from using the above equation with Corollary 27 . 6.2 Estimating vertex congestion via vertex betweenness A shortest path multicommodity flow , f sp , is one that splits the single unit of commodity routed from u to v evenly among all the shortest paths from u to v . For example, consider the graph depicted in Fig. 11 a. There are two shortest paths from vertex a to vertex e : ace and ade . Hence, the shortest path flow, f sp ,givesvalueof 1 2 to each of these paths. As the graph is undirected, the shortest paths from e to a are, symmetrically, eca and eda . Thus, f ( eca ) = f sp ( eda ) = 1 vertices are of adjacent vertices, and thus there is a single shortest path connecting them (the one that goes through the connecting edge). Hence, the flow value of these paths is 1 (e.g: f ( ab ) = 1, f sp ( ca ) = 1). The value of f sp for the rest of the paths in the graph is 0.
The normalized vertex betweenness of a network G , denoted nvb ( G ) , is the normalized congestion on G due to the shortest path flow: While it is not guaranteed that the shortest path flow achieves the minimum congestion (i.e., Furthermore, vertex betweenness can be computed in O ( | V G || E G | ) time using dynamic pro-gramming [ 33 ]. 2 We therefore adopt normalized vertex betweenness as means for estimating the cohesion of networks. Specifically, in our experiments we measure the cohesion of a network G as 1  X  nvb ( G ) .

We saw how to use vertex betweenness to measure the cohesion of a network, but how do we use it to find a sparse separator? We employ a simple algorithm (see Fig. 10 ), which computes the nvb separator of a network. The algorithm is an adaptation of Girvan and Newman X  X  algorithm [ 19 ] for finding edge separators via edge betweenness. Given a network G , the algorithm initializes the separator to the empty set. It then repeatedly executes the following steps, until the network becomes disconnected. The algorithm calculates the nvb of each node in the network, and adds the node v  X  with highest nvb to S . When there are several nodes with maximum nvb , v  X  is chosen to be the one with smallest id. The algorithm then removes v  X  and all its incident edges from the network. Note that the nvb values are re-computed at each iteration of the loop.

Figure 11 shows an example run of the above algorithm on a 5-node network. The nodes c and d have the maximum nvb values ( 1 6 )and c is chosen to be removed (Fig. 11 a), since it has a smaller id. After removing c and recalculating nvb values, d turns out to be the node of highest nvb value ( 2 3 ) and is thus removed (Fig. 11 b). The network is then decomposed into the network.
As the process of finding the node with highest nvb value might repeat O ( | V G | ) times in heuristic algorithm and thus it is not guaranteed that it finds the sparsest vertex separator. 7 Experiments 7.1 Experimental setup We tested C-Rank on our own mailboxes as well as on the Enron email data set, 3 which consists of 150 mailboxes of Enron employees. The data set contains more than 500,000 messages, mostly sent along the years 2000 X 2002.

Given a mailbox, we constructed two corresponding networks X  X n inbox network and an outbox network  X  X s follows. First, we cleaned the data, by removing duplicate messages, merging alias addresses, and ignoring messages that did not include the mailbox X  X  owner as an explicit sender or recipient. We then split the messages into  X  X utgoing X  and  X  X ncoming X . All the incoming messages were used to construct the inbox network and all the outgoing messages were used to construct the outbox network. The inbox (resp., outbox) network consists of all contacts that appear on headers of incoming (resp., outgoing) messages, exclu-ding the mailbox X  X  owner. Two contacts are connected by an edge if and only if they appear on at least one message header together. The weight of the edge is the number of message headers on which they co-occur. The self loop weight of a contact is the number of message headers on which it appears.

We ran C-Rank with the following parameters: (1) maximality margin = 0 . 75; (2) subsumption parameter  X  = 0; (3) cohesion threshold  X  = 1; (4) weight gap  X  = 0 . 75. In most of the experiments, we ignored the self loop weights altogether, in order to focus on the non-singleton communities, which are less trivial to find and rank.
 We enforced a hard time limit of 3,600 s on the execution of C-Rank on each mailbox. C-Rank was unable to finish its execution on 19 of the 150 mailboxes by this time limit, and thus these mailboxes were excluded from the data set. We ran the experiments on Intel Pentium 4 2.8 GHz processor workstations with 2 GB of RAM.

Evaluating clustering results automatically is a difficult task. Our situation is even more complicated, because there is no benchmark cluster ranking algorithm to which we could compare C-Rank. We thus created such a benchmark from the widely used edge betweenness hierarchical clustering algorithm of Girvans and Newman [ 19 ] (In fact, we used Newman X  X  variant of the algorithm [ 34 ], which is adapted to weighted networks). The benchmark algo-rithm, which we call EB-Rank, is identical to C-Rank, except that it generates its candidate clusters using the edge betweenness algorithm. The ranking and candidate elimination phases of EB-Rank are identical to those of C-Rank. 7.2 Results Anecdotal results: In order to give a feel of the communities produced by C-Rank, we Enron employee. Figure 12 shows the top ten non-singleton communities in the inbox of Ziv Bar-Yossef. The example demonstrates that the strong communities output by the algorithm are indeed meaningful, as the owner could easily attach a title to each one of them. This list consists of few overlapping communities, since Ziv X  X  research projects tend to be separated and have very few common participants.

Figure 13 shows the top ten communities output for the inbox of Ido Guy, including singleton communities. This example demonstrates that singleton communities can blend well with non-singleton communities and that they do not necessarily dominate the list of strong communities. In fact, Ido X  X  list is quite diverse in terms of community sizes, ranging from singletons to groups of over ten participants. The workplace-related communities are highly overlapping, corresponding to different projects with overlapping teams or to different sub-groups within the same project.

Figure 14 a presents a graphical visualization of the top ten non-singleton communities in the inbox of Eric Bass, an Enron employee. This graph demonstrates that C-Rank is able to reveal quite intricate structures of overlapping communities.
 To complete the picture, Fig. 14 b shows the top ten communities in the inbox of Eric Bass, including singleton communities. The description of each community was detected by inspecting the content of the messages. Enron data set statistics: Next, we present some statistical data about the results of C-Rank on the 131 mailboxes of the Enron data set. Figure 15 shows the distribution of outbox and inbox network sizes (number of nodes). The networks were ordered by size from smallest to largest, and split into ten deciles. The height of the bar at each decile represents the median size of networks belonging to this decile. The graph indicates that the mailboxes are of highly variable sizes, while inboxes are significantly larger than outboxes. Some mailboxes at the top decile consist of thousands of nodes each.

Figure 16 analyzes the running time of C-Rank on the mailboxes on which it finished its execution by the time limit. For each decile of the networks, when ordered by size, the median running time in seconds is given. The graph clearly exhibits the exponential running time behavior of C-Rank. Yet, we note that C-Rank was able to run on networks of 1,075 nodes in about 3 min, since the running time depends not only on the network size, but also on the  X  X ntricacy X  of the community structure of the network and on the number of communities found.

Figure 17 provides evidence of the prominence of  X  X ingletons X  in the data set. A  X  X ingleton message X  is one that has only one sender or one recipient, apart from the mail-box X  X  owner. Such a message contributes only to the self loop weight of the corresponding sender/recipient. Figure 17 a shows that about 80% of the outgoing messages and 50% of the incoming messages, regardless of the mailbox size, were singletons. This huge density of singleton messages necessarily affected also the results of C-Rank. Indeed, 70 to 90% of the outbox communities and 20 to 65% of the inbox communities detected by C-Rank were singleton communities (Fig. 17 b). We conclude that the high density of singleton communi-ties should be attributed to the nature of the data set, rather than to biases of C-Rank. Since singletons are easy to handle separately, in the rest of our experiments, we eliminated the self loops from the network, and thus focused only on the analysis of non-singleton communities.
Figure 18 depicts the distribution of community sizes output by C-Rank. For each mailbox, we ordered all the output communities by their size, split them into ten deciles, and calculated the median community size in each decile. We then plotted for each decile the median of these median values, over all mailboxes. The results demonstrate that C-Rank is not biased towards small communities, as one may suspect initially. The median community size at the top decile, for example, was about 20 contacts! Comparison with EB-Rank: We now describe a set of experiments that compare the results of C-Rank with the results of EB-Rank (the edge betweenness based algorithm) on the Enron data set. Figure 19 compares the numbers of maximal communities identified by the two algorithms. For each decile of the mailboxes, when ordered by network size, we plotted the median number of maximal communities identified in that decile. The results clearly indicate that C-Rank is able to discover many more maximal communities than EB-Rank. example, the number of inbox communities found by C-Rank was about five times larger than the number of communities identified by EB-Rank. This difference underscores the advantage of overlapping clustering over partitional clustering, at least in this application domain.

In Fig. 20 we compare the precisions of C-Rank and EB-Rank. Precision was calculated as follows. For each mailbox, we compared the number of communities eventually output by the algorithm (after elimination of non-maximal communities) to the number of communities precision of the algorithm on this mailbox. We then ordered the networks by size, and split The results shown in the graph demonstrate that precision goes down with network size. The explanation is quite simple: large networks tend to be richer in complex community patterns, and  X  X nions X  (see Sect. 4.3 ) in particular. Such patterns give rise to a large number of non-maximal communities, some of which are selected in the first phase of the algorithm. Most of these communities are filtered at the elimination phase of the algorithm. Surprisingly, although C-Rank outputs many more communities than EB-Rank, its precision is comparable and even better than that of EB-Rank.
Figure 21 compares the relative recall of C-Rank and EB-Rank. For each mailbox, we calculated the recall of algorithm A relative to algorithm B as follows. We compared the two lists L A and L B of communities output by A and by B, respectively, when running on this mailbox. Intuitively, the recall of A relative to B should be the fraction of the communities in
L B that also appear in L A .However,evenwhenAandBdetectthesamecommunity,they may have slightly different  X  X ersions X  of that community, differing in a few nodes. Therefore, when searching the list L A for a community C that shows up on the list L B , we did not look for an exact copy of C , but rather for a community C that is  X  X omparable X  to C . Formally, we say that C is comparable to C ,if C  X  C and intcohesion ( C )( 1 + )  X  intcohesion ( C ) , where is the maximality margin. The recall of A relative to B on the specific mailbox was then calculated as the fraction of the communities in L B , for which we found a comparable community in L A .

After calculating the recall for each mailbox, we ordered the networks by their size, split into ten deciles, and plotted the median recall at each decile. The results prove that the recall of C-Rank relative to EB-Rank is significantly higher than the recall of EB-Rank relative to C-Rank. The difference even becomes higher for larger networks. This experiment stresses again the advantage of using C-Rank, which can detect overlapping communities, to EB-Rank, which is a partitional hierarchical clustering algorithm.

The previous experiments showed that C-Rank is much more successful than EB-Rank in detecting many maximal communities. However, is it possible that these extra communities are all weak, and if we focus only on the strong communities then the two algorithms are comparable? In order to explore this possibility, we compared the strength scores of the com-munities output by the two algorithms. For each mailbox and for each k = 5 , 10 , 15 ,..., m , where m is the minimum number of communities output by the two algorithms on this mail-box, we calculated the median integrated cohesion of the top k communities on each of the two output lists. For each k and for each algorithm, we then plotted the median score over all networks for which m  X  k (see Fig. 22 ). These results indicate that C-Rank not only finds more maximal communities overall, but also finds better communities. This phenomenon is consistent across inbox and outbox and across different values of k .
 Robustness experiments: One indication of a good clustering algorithm is that it is robust to small changes in the data. In order to test the robustness of C-Rank, we compared the communities it output when running over on the entire Enron data set to the communities it output when running over a sample of the data. (Fig. 23 ) For this experiment, we focused only on sufficiently large mailboxes: ones in which the number of messages was at least 500. Overall, we used 36 outboxes and 41 inboxes in this experiment. For each such mailbox, we constructed three networks: one that was constructed using all the messages in the mailbox, one that was constructed using 80% randomly chosen messages from the mailbox, and one that was constructed using 20% randomly chosen messages from the mailbox. (The latter two networks were constructed five times each, and the results presented here are the medians over these five trials.) For each of the two latter networks, and for each p = 10% , 20% ,..., 100%, we calculated the recall of the top k = p  X  m communities output by C-Rank on this network (where m is the total number of communities output on this network) relative to the top k communities output by C-Rank when running on the first, complete, network. For each p ,we then calculated the median recall over all networks. This value, which we call  X  X ecall@p X , captures how well C-Rank was able to detect the strong communities of the mailbox, when running over only a portion of the data in the mailbox.

The results indicate that C-Rank is rather resilient to random removal of data. On the networks built over 80% of the data, C-Rank was able to maintain a recall of about 90% across all values of p . When running on a mere 20% of the data, C-Rank was still able to maintain reasonable recall of 45% at the top decile and 20% at the bottom decile. To sum up, we believe that the above experiments provide convincing evidence that C-Rank is able to achieve high recall values (i.e., covering many of the maximal clusters in the network), while maintaining a relatively high precision. C-Rank is completely superior to EB-Rank, which is based on the very popular edge betweenness clustering algorithm. C-Rank is also robust to random removal of data, attesting to its quality. 8 Conclusions We presented the cluster ranking problem as a novel framework for clustering. We then proposed integrated cohesion as a new strength measure for clusters. We designed C-Rank: a cluster ranking algorithm that detects and ranks overlapping clusters in arbitrary weighted networks. We demonstrated the effectiveness of the framework and the algorithm by ranking clusters in egocentric mailbox networks.

Finding a sparse vertex separator is an important part of C-Rank. To this end, we proposed a heuristic algorithm, which is based on a new connection between vertex betweenness and multicommodity flow.

An interesting problem following this work is whether one can design an efficient cluster ranking algorithm, which given an integer k , finds the top k maximal clusters directly, without computing the full list of maximal clusters. Such an algorithm could be much more efficient than C-Rank, when the list of maximal clusters is very long. We believe that finding the top k clusters exactly is NP-hard, yet finding some  X  X ood X  k clusters may be feasible to do. Addressing this question is left for future work.
 References Author Biography
