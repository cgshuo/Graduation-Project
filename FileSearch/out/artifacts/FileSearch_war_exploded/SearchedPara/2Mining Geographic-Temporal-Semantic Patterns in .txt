 Many applications, such as navigational planning services, traffic management, and location-based advertisement, have been developed for the rapidly growing location-based services market. Due to the various requirements of these applications, for ex-ample, system efficiency and marketing efficacy, accurately predicting the next location to which a mobile user may move is essential. Given a set of locations, which may be application dependent and predetermined, the location prediction technique identifies the next location a user is most likely to visit. Intuitively, the process of location pre-diction is very similar to location recommendation. Consequently, many existing works [Ge et al. 2010, 2011; Liu et al. 2010; Zhuang et al. 2011; Zheng et al. 2009b, 2009c] directly adopt a location recommender as their location prediction model. However, these recommenders recommend locations using a nonreal-time estimation process, that is, current movements of users are NOT taken into consideration in making the recommendations. We argue that, apart from location recommendation, the problem of next location prediction focuses on inferring the next location that a user will visit. In fact, people do not solely visit locations because these locations are interesting to them. They also go to places because they have to do something, for example, for work, transportation, etc. However, conventional location recommendation methods aim to suggest a new location (or more precisely a place) in which a user may be interested [Zheng et al. 2010a, 2010c, 2011; Zheng and Zhou 2011]. In other words, the location recommendation method only cares about interests of users, while the next location prediction method cares about intentions of users. On the basis of our observations, we categorize users X  intentions into three classes.  X  Geographic-triggered Intentions ( GI ), refer to the specific geographical locations vis-ited by users. These kinds of intentions reflect the reasons why a user travels from one location to another location. For example, as shown in Figure 1, given two con-secutive metro stations X and Y, we can predict metro station Y as the next location for those users who are currently at metro station X (see Trajectory 1 ).  X  Temporal-triggered Intentions ( TI ), refer to the relationship between locations and temporal information. These kinds of intentions reflect the reasons why a user visits and leaves a location at a certain time. As shown in Figure 1, the user tends to go back home in the evenings and leave home in the morning based on Temporal-triggered
Intentions (see Trajectory 3 ).  X  Semantic-triggered Intentions ( SI ), refer to the  X  X eneral X  geographical consequence of locations visited by users. These kinds of intentions reflect the reasons why users travel from some locations to other locations. For example, if users always go for a meal after they leave their workplaces, we can predict locations that contain many restaurants as the next location for those users who are currently leaving school (see Trajectory 2 in Figure 1).

Corresponding to the three kinds of intentions, movements of users can be viewed as a contexture of the behaviors that are motivated by the aforementioned three kinds of intentions. In other words, the movement of people from one location to another may be triggered by multiple intentions, inclusive of GI , TI, and SI . However, existing techniques for predicting the next location of a user primarily focus on analyzing Geographic-triggered Intentions only. To extract the significant movements motivated by Geographic-triggered Intentions , the existing methods usually mine the frequent sequences of locations (i.e., geographical points/regions) from user trajectories. Due to the geographical binding of exact locations, these prediction techniques are only applicable to movements that are motivated by Geographic-triggered Intentions .For example, let us suppose that Trajectory 1 and Trajectory 2 in Figure 2(a) are historical trajectories and Trajectory 3 depicts the current movement of a mobile user. Assume that Trajectory 3 is new with respect to the historical trajectory database. As there is no movement pattern similar to the current movement, traditional prediction techniques will suffer the low applicability problem (i.e., no pattern is applicable for predicting the current movement of the user).
 Several works addressed the frequent movements motivated by Temporal-triggered Intentions [Giannotti et al. 2006; Monereale et al. 2009]. Unfortunately, these works only roughly calculate the transition time while disregarding the  X  X tay time X  and the  X  X rrival time X . Moreover, the frequent movements motivated by Semantic-triggered Intentions are still not taken into consideration in the representation of users X  behav-iors. This leads to the problem of low precision (i.e., the making of inaccurate location predictions). In Figure 2(b), it can be seen that both Trajectory 1 and Trajectory 2 conse-quently visit Location A and Location C. Suppose the transition time from A to C of the two trajectories are approximated, it is clear that the destinations of Trajectory 1 and Trajectory 2 are quite different. Trajectory 3 and Trajectory 2 share the same semantic tags, that is, from School to Bank. Thus, we observe that Trajectory 2 and Trajectory 3 can be denoted by the same sequence, that is, School  X  Bank  X  Hospital. As the seman-tic annotations of user behaviors exhibited in Trajectory 2 and Trajectory 3 are quite the same, it is therefore more reasonable to consult Trajectory 3 in order to make predictions about Trajectory 2 .

On the basis of the observations prompted by the preceding examples, we propose a novel approach called Geographic-Temporal-Semantic-based Location Prediction (GTS-LP) that predicts next locations of users based on the three kinds of intentions. As shown in Eq. (1), given a set of users U and a set of locations L , the problem of location prediction can be formulated as an estimation of the probability of a given user visiting a given location based on his/her current movement. Hence, location prediction can be addressed as a historical movement matching prob-lem. In addition, the question of how to extract significant movements to support the prediction based on heterogeneous moving intentions is also a critical and challenging issue. To support location prediction based on historical movements of users triggered by GI , TI, and SI , we design a novel frequent pattern, called GTS pattern, to match current movements of users. In pattern mining, the fundamental issue is to identify and efficiently extract representative patterns from the heterogeneous trajectories of users. The extraction of representative patterns is important because those patterns have a direct impact on the efficacy of the prediction task. As mentioned earlier, con-sidering only movement that is triggered by GI does not work well. However, there is no existing work on the mining of frequent patterns that deals with all behaviors triggered by GI , TI, and SI . Moreover, there is no location prediction model that makes predictions based on historical movements of users triggered by GI , TI, and SI .
To address the aforementioned problem, we explore movements of users triggered by GI , TI, and SI , and seek representative trajectory patterns from moving inten-tions of the users. In contrast to conventional location prediction techniques that are based solely on the trajectories motivated by geographic-triggered intentions ,wealso utilize trajectories motivated by temporal-triggered intentions and semantic-triggered intentions to predict the next location. Our GTS-LP approach follows the user-based collaborative filtering framework that comprises (1) an offline frequent pattern min-ing module (called GTS pattern mining ), and (2) an online location prediction module (called GTS-based location prediction ). Figure 3 shows the flow of processing in GTS-LP . To discover GTS patterns for prediction of the next location, GTS pattern mining explores all the semantic, geographical, and temporal aspects of the mobile user activ-ities being captured in the trajectories. The GTS pattern mining module includes two main steps: (i) GTS pattern discovery X  X he extraction of individual frequent behaviors of users in the forms of GI, TI, and SI trajectories; and (ii) GTS similarity calculation X  the calculation of similarity based on their individual GTS patterns. Since the main idea underlying the user-based collaborative filtering framework is the prediction of behavior of a user in accordance with similar behaviors of users, user similarity plays a crucial role in the prediction model. As shown in Figure 3, discovered GTS patterns of each user are utilized in the construction of a pattern tree in order to support efficient GTS-based location prediction. In the online module, we propose a scoring function to evaluate the probability of a location that may be the next location. Again, we consider not only the geographic property but also semantic and temporal properties for the scoring function. To make a prediction, the location with the highest score is predicted as the next location the user will visit.

This research makes a number of significant contributions, which are summarized as follows.  X  X e propose a novel approach named GTS-LP for mining and prediction of mobile users X  movement behavior. The problems and ideas resolved and proposed, respec-tively, in GTS-LP have not been explored previously in the research community.  X  X e define a new frequent pattern, called GTS pattern, to represent mobile users X  frequent movements in terms of Geographic-triggered, Temporal-triggered, and
Semantic-triggered Intentions.  X  X e develop a data mining algorithm, called GTSP-Miner, to discover GTS patterns.
It comprises two modules X  X  parameterless hierarchical clustering algorithm for mining frequent semantic locations and a probabilistic model for discovering the temporal interval of a location.  X  X e develop a new index structure based on a prefix tree to represent GTS patterns in a compact form in order to facilitate efficient prediction computation.  X  X o sustain user-based collaborative filtering, we utilize the discovered individual
GTS patterns for each pair of users to obtain similitude of the users.  X  X n the basis of the GTS patterns, we propose a novel location prediction strategy that takes into account all Geographic-triggered, Temporal-triggered, and Semantic-triggered Intentions to predict next location of a user.  X  X e use various real datasets to evaluate the performance of our proposal in a se-ries of experiments. The results show that our proposed framework significantly outperforms other location prediction techniques in terms of precision and coverage. The remainder of this article is organized as follows. We briefly review related work in Section 2 and describe our proposed GTS pattern mining and GTS pattern tree construction approach in Section 3. Next, our proposed GTS similarity calculation and GTS score calculation methods are detailed in Sections 4 and 5, respectively. The performance of our proposal in an empirical evaluation study is discussed in Section 6. Finally, conclusions and directions for future work are given in Section 7. The problem of predicting the next location to which a mobile user will move has received much research interest in recent years. Prediction techniques developed for this problem domain can be broken down into two steps: (i) user behavior mining and (ii) prediction model building. In the user behavior mining step, there are two viewpoints for illustrating movements of users X  X amely, random walk and frequent pattern. Researchers who utilize random walk to model movements of users believe that most movements of users follow some random regulation. Jiang et al. [2009] studied the trajectories of 50 taxicabs and found that the trajectories move according to the L  X  evy flight behavior. This finding can be used to model and predict the movement of taxicabs. However, it is obvious that the movement of taxicabs can reflect only a tiny part of human mobility. Accordingly, Gonz  X  alez et al. [2008] studied 100,000 trajectories provided by 206 mobile users. They found that the L  X  evy flight behavior could not explain mobility of users well but the radius of gyration for each user could be considered for user mobility modeling. Song et al. [2010] discussed several random walk behaviors for modeling and classifying movements of users. They concluded that only 93% of short-term mobility of users can be predicted. In other words, random-walk-based predictors do NOT work well for long-term trajectory prediction.

Conversely, several data mining researchers believe that human mobility is not always random. They believe that regular pathing can be used in the prediction of the next movement of a user. To extract the regular part from movements of users, three kinds of frequent patterns can be utilized: (i) mobile sequential pattern [Yavas et al. 2005; Morzy 2006, 2007; Jeung et al. 2008], (ii) spatial-temporal sequential pattern [Monereale et al. 2009; Li et al. 2011], and (iii) semantic-geographic pattern [Alvares et al. 2007; Eagle and Pentland 2009; Bogorny et al. 2009; Noulas et al. 2011]. The mobile sequential pattern considers a trajectory as a sequence of locations and thus uses the sequential frequent patterns mined from a historical set of trajectories. Jeung et al. [2008] proposed an innovative approach to forecast the future locations of a user that consists of combining predefined motion functions with the movement patterns of the user. The motion functions capture object movements as sophisticated mathematical formulas of linear or nonlinear models. To discover mobile sequential patterns, the movement patterns are extracted by means of a modified version of the Apriori algorithm. Yavas et al. [2005] and Morzy [2006] proposed several methods in which modified versions of the Apriori algorithm are used to generate association rules for an individual user. Such rules can reflect frequent co-occurrences of locations in the movement of an individual user, that is, the places users always visit in one movement. In order to select the rule used for the prediction, they take into consideration the notions of support and confidence. The support of each candidate is computed by a distance based on the notion of string alignment. Morzy [2007] subsequently used a modified version of the PrefixSpan algorithm [Pei et al. 2001] to discover frequent movements of users. Such a pattern can not only reflect co-occurrence of locations but also the consequence of location, that is, the place users always visit after visiting somewhere else.

To improve the mobile sequential pattern, it is argued that the temporal information in the spatial-temporal sequential pattern reflects crucial human mobility and thus ex-ploits the frequent temporal behavior of mobile users. Giannotti et al. [2006] proposed a kind of spatial-temporal sequential pattern, called T-pattern, which contains two kinds of moving intentions X  X eographic-triggered Intentions and Temporal-triggered Intentions. A T-pattern is a sequential pattern extended with a temporal property (i.e., travel time). To discover the temporal patterns, Giannotti et al. [2006] proposed an effective strategy to map temporal information in the space R n and to discover the dense hypercube from the R n space. Li et al. [2011] proposed two kinds of tra-jectory patterns X  X  periodic behavior pattern and a swarm pattern X  X nd developed a reference location-based method for mining periodic behavior patterns. The reference location-based method detects the reference locations, discovers the periods in complex movements, and then finds periodic patterns using hierarchical clustering. They also developed an efficient method for mining swarm patterns in which flexible moving object clusters are uncovered by relaxing the popularly enforced collective movement constraints.
 As mentioned in the Introduction, many behaviors of users are semantic-triggered. This means that the preceding user behavior mining methods can only partially reflect movements of users. With regards to the reflection of semantic-triggered movement, Alvares et al. [2007] and Bogorny et al. [2009] are some of the studies on semantic trajectory data mining that have appeared in the literature. Alvares et al. [2007] pro-posed to explore the geographic and semantic properties by mining semantic trajectory patterns from location histories of mobile users. First, they discover the stops of each trajectory and map these stops to semantic landmarks. They then apply a sequential pattern mining algorithm to this sequence dataset to obtain frequent patterns, namely, semantic trajectory patterns, to represent the frequent semantic behaviors of mobile users. Bogorny et al. [2009] take hierarchical geographic and semantic properties into consideration in order to discover patterns that are more interesting. However, because the notion of stops in these works only takes the aspect of  X  X tay X  into account rather than the positions of these stops in geographic space, many unknown stops are gener-ated. For example, as shown in Figure 4, stop 1 c , stop 2 c , and stop 3 b are not associated with any semantic landmark and are thus marked as Unknown. Hence, Trajectory 1 is transformed to the sequence &lt; School, Park, Unknown, Restaurant &gt; . From Figure 4, it is clear that stop 1 c is near a Restaurant. Thus, by taking into account the geometric distribution of these stops, stop 1 c and stop 1 d are grouped together such that Trajectory 1 is transformed to the sequence &lt; School, Park, Restaurant &gt; . Existing studies on user location prediction could be classified into three categories: (1) those using only a user X  X  own data, (2) those using the data generated by crowds, and (3) hybrid methods using both kinds of data. In the first category of studies, they utilize only a user X  X  own data to predict the next location and focus only on historical movements of users, such as some trajectory simulations [Jiang et al. 2008; Gonz  X  alez et al. 2008; Eagle and Pentland 2009; Song et al. 2010]. In Eagle and Pentland [2009], the prediction model is based on an eigenvector space to model regular movement of users for predicting next location modeling. However, such a prediction model does not consider historical movements of users. It always leads to low coverage of prediction. For example, even though the user has visited many locations, there must be some places the user has never been. As a result, the prediction model is not applicable for predicting the locations the user and his friends have never been to before. Hence, the methods using only a user X  X  own data usually do not work well in dealing with the location prediction problem.

The second category of studies consider only the datasets generated by crowds for next location prediction modeling, based on approaches such as some probability dis-tribution models [Backstrom et al. 2010; Noulas et al. 2011] or location recommenders [Ge et al. 2010, 2011; Liu et al. 2010; Zhuang et al. 2011, 2012]. In Backstrom et al. [2010], the prediction model is based on a social-spatial approximation which utilizes current GPS coordinates of the user X  X  friends to estimate the GPS coordinate of the user. In Zhuang et al. [2011], the recommender leverages the rich context signals on the mobile device (i.e., user and sensory context, such as user click-through, geoloca-tion, and time) to rank the location tailored to the user X  X  preference. However, these kinds of recommenders do NOT consider current movement of users. It leads to low precision in prediction. For example, even though the user frequently visits a gym, the probability for him to visit the gym after visiting the swimming pool must be very low. However, if we use these recommenders for predicting next location of users, the gym is usually predicted as next location of the user after he visits a swimming pool. As the result, those historical-oriented methods usually do NOT work well for dealing with the location prediction problem.

The third category of studies precisely predicts the next location of users using hy-brid approaches [Monereale et al. 2009; Ying et al. 2011; Wei et al. 2012; Xue et al. 2013]. Monereale et al. [2009] have proposed a hybrid method which not only considers a user X  X  own data (his/her current movement) but also utilizes the data generated by crowds. The prediction extracts T-patterns [Giannotti et al. 2006] from trajectory of users to match the current movement of a user. As mentioned earlier, the T-patterns are mined for representing Geographic-triggered Intentions and Temporal-triggered Intentions. In other words, the prediction can NOT deal with the next location moti-vated by Semantic-triggered Intentions. To address this issue, Ying et al. [2011] have proposed a novel prediction model by matching the current movement of a user to discovered semantic trajectory patterns [Bogorny et al. 2009]. However, the prediction model focuses only on movements of users motivated by Semantic-triggered Intentions and Geographic-triggered Intentions. Consequently, the prediction model can NOT deal with the problem of predicting the next location motivated by Temporal-triggered Intentions. In this section, we propose a new type of pattern, called GTS (Geographic-Temporal-Semantic) pattern , to represent users X  frequent movement behaviors by considering all the three kinds of user intentions mentioned previously, that is, geographic-triggered, temporal-triggered, and semantic-triggered intentions. In contrast to the conventional frequent pattern, which can only represent one part of the three kinds of intentions, we take into account the semantic and temporal properties in trajectories to illustrate movements of users. As shown in Figure 5, we first detect stay locations from trajecto-ries of users; then, we transform each trajectory to a GTS trajectory. We call this step GTS coding. We also developed a data mining method, called GTSP-Miner , to discover GTS patterns from transformed GTS trajectories and, to make the prediction phase efficient, we adopted a prefix tree, called GTS pattern tree, to compactly represent a collection of GTS patterns.
 In this section, we explain how each trajectory is transformed to a GTS trajectory. Un-like some traditional location prediction models that predict predetermined locations, we prefer to predict application-dependent locations because predetermined locations are always independent from the distribution of the trajectories. In the illustration shown in Figure 6, predetermined locations cover only one trajectory. Consequently, no location prediction model can deal with such a situation. In addition, we argue that most of the activities carried out by a mobile user are usually performed when the user stops. For example, a user may stop at a caf  X  e to have coffee. As mentioned earlier, the goal of this study is to support location-based services. Therefore, in this article, we focus only on predicting where a user will go to and stay. Thus, to detect application-dependent locations, we first detect the stay points of individual users, after which we apply a clustering algorithm on stay points of all users and group them as locations. 3.1.1. Stay Point Detection. Similar to the approach taken by Zheng et al. [2010b], we consider a stay location to be a region where many users stay. Thus, before carrying out stay location detection, we first detect the regions, called stay points, where a user has stayed. In Zheng et al. X  X  approach, only velocity (i.e., time and distance) is considered as a factor of  X  X tay X . However, we argue that direction change is also an important factor for detecting where the user stays. The extraction of a stay point is controlled by three parameters X  X  time threshold (  X  ), a distance threshold (  X  ), and a direction change threshold (  X  ). Formally, a single stay point s can be regarded as a virtual location characterized by a group of consecutive GPS points G ={ p m , p m + 1 ,..., p n } such that: (1) Distance(p m ,p i )  X   X  , (2) Time Difference(p m ,p n )  X   X  ,and (3) Direction Difference(p i ,p i + 1 )  X   X  , where  X  m &lt; i  X  n . A stay point s is conditioned by G ,  X  ,  X  , and  X  , respectively repre-senting the average latitude and longitude of the collection G , and the timestamp of p m and p n represents arrival and leaving times of a user on s . As illustrated in Figure 6, p1  X  p2  X  X  X  X  X  X  p10 forms a GPS trajectory and a stay point can be constructed by points { p4, p5, p6, p7 } . Clearly, if we avoid the direction change factor, another stay point may be constructed by points { p1, p2, p3 } . However, such  X  X tay X  behavior would be obtained due to traffic events, such as a traffic jam or traffic signals. In other words, such a stay point is not a semantic-related region. Therefore, it is necessary to take into account direction change at the stay point. 3.1.2. Grouping Stay Points. To discover the region where most people will stay, we make use of these stay points to form stay locations. We could perform a density-based clustering algorithm on the stay points to detect the stay locations. However, the number of stay points may not reflect the popularity of a region where most people will stay, as it will be affected by the duration of the trajectory log and the liveliness of the user. However, we expect that the location we find will be where many users have stayed. Thus, to deal with this problem, we use the P-DBSCAN algorithm [Joshi et al. 2009] with these stay points to form stay locations. Unlike traditional density-based algorithms, P-DBSCAN determines the density by the number of people instead of by the number of points. For example, in Figure 7 (in which the different shapes represent different users), the traditional density-based algorithms would determine both the density of Figure 7(a) and that of Figure 7(b) to be 14; but P-DBSCAN determines the density of Figure 7(a) to be three and that of Figure 7(b) to be one. Intuitively, after stay points are detected from a trajectory, the trajectory can be trans-formed to a sequence of stay points. Thus, we transform each trajectory into a stay point sequence after stay point detection. The trajectory p1  X  p2  X  X  X  X  X  X  p10, in Figure 6, for example, is transformed to s1  X  s2. To represent the moving behaviors X  X I, TI, and SI X  X e perform GTS coding on each stay point sequence to transform it into a GTS trajectory. The GTS coding comprises three parts: location tagging, semantic tagging, and temporal tagging. 3.2.1. Location Tagging. As mentioned in the location detection section, a stay location is determined by clustering stay points. This means that each stay point corresponds to exactly one stay location. Generally, the location represents the region in which the stay point lies. Therefore, to represent the moving behaviors that are motivated by GI, we tag each stay point by its location ID. Thus, we transform each stay point sequence into a stay location sequence. For example, the stay point sequence s1  X  s2 in Figure 8 is transformed to location sequence location2  X  location5. 3.2.2. Semantic Tagging. We use a POI database and the activity label of the trajectory to calculate the probability of each semantic tag to each stay point. The POI database is a customized spatial database that stores the semantic category of landmarks col-lected from Google Maps (alternatively, a gazetteer can be used as a general-purpose POI database for this operation.) In our POI database, we store landmarks, their geographic scopes, and the associated semantic tag(s). In this article, we use some general categories of the landmarks as their semantic tags. Since we need to precisely represent the possibility of each semantic tag for a user in the location, we still use the stay point of a trajectory to determine the semantic tags of the location that is passed by the trajectory. Thus, we construct a semantic vector for each stay point according to the landmarks falling in the stay point. As mentioned earlier, the semantic tag of a landmark for a user is always related to the activity (or purpose) of his/her trajectory. We utilize the co-occurrences of the activity label of the trajectory and the semantic tags of the landmarks to design the semantic vector for a stay point as follows. label tl , the probability of the semantic tag st in a stay point of the trajectory is
Pr( st ) = where T tl is the collection of trajectories with activity label tl , which are collected from the LBSN Web site, and T st is the collection of trajectories, which are retrieved by the query term tl from the LBSN Web site.
 that of the landmark Restaurant A is  X  X estaurant X . Suppose that the activity label of the trajectory is  X  X hopping X  and there are four unique landmark categories,  X  X estaurant X ,  X  X chool X ,  X  X ark X , and  X  X ank X , in a POI database. This means that the semantic vec-tor would be represented as &lt; Pr(Restaurant) , Pr(School) , Pr(Park) , Pr(Bank) &gt; . Next, suppose that the number of query results is as shown in Table I, and the number of trajectories with the label  X  X hopping X  is 12000. Since s1 overlaps the landmarks Restaurant A and Bank, the semantic vector of s1 is calculated as &lt; 3000/12000, 0, 0, 1000/12000 &gt; .
 It is possible that a stay point overlaps none of the landmarks. For example, in Figure 8, there is no landmark overlapping s2. In this case, we consider all possible reasons why the user may stay. Thus, we assign the vector &lt; 3000/12000, 1/12000, 10/12000, 1000/12000 &gt; to s2. After assigning semantic tags to the stay points, a stay point sequence can be transformed to a sequence of semanticwise stay points. For example, the location sequence location2  X  location5 is transformed to (loca-tion2, &lt; 3000/12000, 0, 0, 1000/12000 &gt; )  X  (location5, &lt; 3000/12000, 1/12000, 10/12000, 1000/12000 &gt; ). 3.2.3. Temporal Tagging. Finally, we use the stay location to which the stay point be-longs to represent the geographic and semantic properties. In addition, the arrival and departure times on the stay point are used to represent the temporal information. This representation is called GTS trajectory. In Figure 8, for example, the sequence (location2, &lt; 3000/12000, 0, 0, 1000/12000 &gt; )  X  (location5, &lt; 3000/12000, 1/12000, 10/12000, 1000/12000 &gt; ) can be transformed to (Location2, [p4.T p7.T], &lt; 3000/12000, 0, 0, 1000/12000 &gt; )  X  (Location5, [p8.T p10.T], &lt; 3000/12000, 1/12000, 10/12000, 1000/12000 &gt; ), where pi.T denotes the timestamp of pi  X  1  X  i  X  10. Here, for the sake of readability, we represent each GTS trajectory as (Location ID, [Stay time], &lt; semantic ample, the GTS trajectory (Location2, [p4.T p7.T], &lt; 3000/12000, 0, 0, 1000/12000 &gt; )  X  (Location5, [p8.T p10.T], &lt; 3000/12000, 1/12000, 10/12000, 1000/12000 &gt; ) can be represented as (Location2, [p7.T-p4.T], &lt; 3000/12000, 0, 0, 1000/12000 &gt; ) [p8.T-p7.T] (Location5, [p10.T-p8.T], &lt; 3000/12000, 1/12000, 10/12000, 1000/12000 &gt; ). After GTS coding, each trajectory is transformed to a GTS trajectory, which contains geographic, temporal, and semantic properties. On the basis of these GTS trajectories, the GTS pattern is abstracted using aggregating support, as formally stated by the following definition.

Definition 3.3 ( s-Containment (  X  s ) ). Given a GTS trajectory T1 with length n, a GTS trajectory T2 with length m (where n  X  m), a semantic vector threshold  X  v , a stay time threshold  X  s , and transition time threshold  X  t , we say that T1 is s-contained in T2, denoted T1  X  s T2, if and only if there exists a sequence of integers 0  X  i 0 &lt;...&lt; i n  X  m such that: (1) T1(k).Location ID = T2(i k ). Location ID, (2) Cosine (T1(k).Semantic Vector, T2(i k ).Semantic Vector)  X   X  v , (3) |T1(k).Stay Time  X  T2(i k ).Stay Time|  X   X  s , (4) |(T1(k), T1(k + 1)).Transition Time  X  (T2(i k ), T2(i k + 1 )).Transition Time|  X   X  t , where  X  1  X  k  X  n.

Example 3.4 . Given a GTS trajectory T1 = (Loc1, [5], &lt; 0.1, 0.0, 0.9 &gt; ) [15] (Loc9, &lt; at 0.5, stay time threshold  X  s set at one, and transition time threshold  X  t set at 10, we get: (1) T1(1).Location ID = T2(1).Location ID = Loc1 and T1(2).Location ID = T2(3). (2) Cosine (T1(1).Semantic Vector, T2(1).Semantic Vector) = Cosine ( &lt; 0.1, 0.0, 0.9 &gt; , (3) |T1(1).Stay Time  X  T2(1).Stay Time| = |5  X  5|  X   X  s = 1 and |T1(2).Stay Time (4) |(T1(1), T1(2)).Transition Time  X  (T2(1), T2(3)).Transition Time| =| 15  X  (6 + 5 + Hence, T1  X  s T2 holds.

Definition 3.5 ( s-Support, Frequent GTS Trajectory ). Given a GTS trajectory set D , a stay time threshold  X  s , transition time threshold  X  t , and a minimum support  X  m ,we define the s-support of a GTS trajectory T as and say that T is frequent in D if s-support(T)  X   X  m .
 Example 3.6 . Given a GTS trajectory set D consisting of two GTS trajectories, vector threshold  X  v set at 0.5, stay time threshold  X  s set at one, transition time thresh-old  X  t set at 10, and minimum support  X  m set at 0.3, with T = (Loc1, [5], &lt; 0.0, 0.2, 0.8 &gt; ) [6] (Loc7, [5], &lt; 0.1, 0.9, 0.0 &gt; ), we get: (1) T  X  sT1, (2) T  X  sT2.
 Hence, the s-support( T )is0.5and T is frequent.

However, the GTS trajectory set can have highly dispersed temporal information and semantic vector values, resulting in all the frequent GTS trajectory being highly redundant. For example, given the GTS trajectory (Loc1, [5], &lt; 0.1, 0.0, 0.9 &gt; ) [15] (Loc9, &lt; 0.1, 0.4, 0.5 &gt; ), it can be seen that the stay time of Loc1 in these two trajectories are both [5]. Similarly, the stay time of Loc9 in these two trajectories are very close. Thus, we can use an interval to aggregate and to represent the stay time and transition time. Moreover, the semantic vectors of Loc1 for the two trajectories are very similar and so are the semantic vectors of Loc9 for the two trajectories. Thus, we can use the mean of the semantic vectors to represent the semantic vectors. Accordingly, the two GTS trajectories may be aggregated and represented as (Loc1, [5 5], &lt; 0.05, 0.1, 0.85 &gt; )[15 20] (Loc9, [7 8], &lt; 0.1, 0.45, 0.45 &gt; ).
 trajectory T1 and a sequence T that uses the time interval instead of the temporal part of GTS trajectory, we say that T1 semantic-temporally belongs to T, denoted T1  X 
ST T,ifandonlyif (1) T1(k).Location ID = T(k). Location ID, (2) Cosine (T1(k).Semantic Vector, T2(k).Semantic Vector)  X   X  v , (3) T1(k).Stay Time  X  T(k).Stay Time Interval, (4) (T1(k), T1(k + 1)).Transition Time  X  (T2(k), T2(k + 1)).Transition Time Interval, where  X  1  X  k  X  n.
 [6 8], &lt; 0.0, 0.55, 0.45 &gt; ), we get (1) T1(1).Location ID = T(1). Location ID = Loc1 and T1(2).Location ID = T(2). Location (2) Cosine (T1(1).Semantic Vector, T(1).Semantic Vector) = Cosine ( &lt; 0.1, 0.0, 0.9 &gt; , (3) T1(1).Stay Time = 5  X  T(1).Stay Time Interval = [5 5] and T1(2).Stay Time = 7  X  (4) (T1(1), T1(2)).Transition Time = 15  X  (T(1), T(2)).Transition Time Interval = [15 Hence, T1  X  T Tholds.
 threskhold  X  s , transition time threshold  X  t , and a minimum support  X  m , we define the s-aggregating-support of a GTS sequence S as and say that S is a frequent in D if s-aggregating-support( S )  X   X  m .
 Example 3.10 . Given a GTS trajectory set D consisting of two GTS trajectories, vector threshold  X  v set at 0.5, stay time threshold  X  s set at one, transition time threshold  X  set at 10, and minimum support  X  m set at 0.3, with S = (Loc1, [5 6], &lt; 0.0, 0.2, 0.8 &gt; ) [14 22] (Loc9, [7 8], &lt; 0.1, 0.5, 0.4 &gt; ), we get: (1) S  X  s T1, (2) S  X  s T2.
 Hence, the s-aggregating-support( S )is1.0and S is frequent.

From the previous definition, it is easy to see that the value of s-aggregating-support is proportional to the length of time interval in the discovered patterns. In particular, setting s-aggregating-support with a large value will result in a long and imprecise time interval for most discovered patterns. Thus, how to determine the time interval is an important issue in temporal pattern mining. Fortunately, additional information, such as semantic and geographic information, can be utilized for time interval detec-tion. We argue that the stay time and the transition time are related to the semantic information of the locations because the semantic information can be used to ascertain the  X  X urpose X  of the stay or transit between the locations. Moreover, in probability theory, the exponential distribution [Papoulis and Pillai 2002; Ross 2004] describes the time between events in a Poisson process, that is, a process in which events occur continuously and independently at a constant average rate. Therefore, we can treat the  X  X eave X  and  X  X rrive X  events as Poisson processes, and the stay time and the transition time can be modeled by an exponential distribution. In statistics, a confidence interval [Papoulis and Pillai 2002; Ross 2004] is used to indicate the reliability of an estimate, which is determined by the significance level [Papoulis and Pillai 2002; Ross 2004].
L EMMA 3.11. If the assumption that the stay time and the transition time can be modeled by exponential distribution holds, we can use the confidence interval of the mean of the exponential distribution to represent the possible interval of stay time (or transition time). Given a significance level  X  and stay time (or transition time) X 1 , X ,..., X locations), the stay time interval of the stay time corresponding to the user staying in the location (or transiting between the two locations) is given as where  X  2 p , X  is the 100(1  X  p ) percentile of the chi-squared distribution with  X  degrees of freedom.

P ROOF . Since the  X  X eave X  and  X  X rrive X  events are Poisson processes, the stay time and the transition time can be modeled by exponential distribution. If X 1 , X 2 ,..., X n are independent exponential random variables, each having mean  X  , then the MLE of  X  is the simple mean n i = 1 X i / n .

Since n i = 1 X i is a gamma random variable with parameter (n, 1/  X  ), this in turn implies that Hence, for any  X   X  (0, 1) That is equivalent to Hence, a 100(1- X  ) percent confidence interval for  X  is Thus, we can say that there is a 100(1  X   X  ) percent confidence to support the stay time corresponding to the user staying in the location (or transiting between the two locations) in the interval. The lemma thus holds.

We use Table II as an example dataset to explain how to calculate the confidence interval. There are five GTS trajectories; let us calculate the stay time interval for Loc7. Two trajectories contain Loc7 (i.e., n = 5), and we suppose that their semantic vectors are similar. If we let the significance level be 10% (i.e.,  X  = 0.1), then we 2(3 + 1 + 3 + 1 + 3)/3.94] = [1.20, 5.58].
 sequence P is a GTS pattern if and only if (1) s-aggregating-support( P )  X   X  m . (2) P (k).stay time interval is the confidence interval of the stay time of the locations (3) ( P (k), P (k + 1)).transition time interval is the confidence interval of the transition where  X  1  X  k  X  n. As shown in the preceding definitions, GTS patterns must be mined from the GTS tra-jectory set. To the best our knowledge, there is no existing pattern discovery algorithm that can be directly applied to the GTS trajectory set to discover GTS patterns. There-fore, we propose a novel algorithm called GTSP-Miner (Figure 9) that discovers GTS patterns from GTS trajectory sets. The design of this algorithm follows the pattern growth strategy [Pei et al. 2001].

First, single locations are discovered (Figure 9, line 2). For each single location discovered, we use the semantic property to divide the input GTS trajectory set into several small GTS trajectory sets, denoted D  X  , and each D  X  is given a representative semantic vector (Figure 9, lines 3 and 4). For each small GTS trajectory set obtained by considering the semantic property, we use the stay time to divide it into several smaller GTS trajectory sets, denoted D  X  X  X  , and each D  X  X  X  is given a representative stay time interval (Figure 9, lines 5 and 6). For each small GTS trajectory set obtained by considering stay time information, there are two cases. One case is the initial case (k = 0), for which we use the frequent single location, representative semantic vector, and representative stay time interval to obtain the GTS pattern P  X  with length 1, and further consider P  X  and D  X  X  X  as inputs to the GTSP-Miner algorithm (Figure 9, lines 7 X 11). Another is the recursive case, for which we use the transition time to divide the GTS trajectory set into several smaller GTS trajectory sets, denoted D  X  X  X  X  .Each D  X  X  X  X  has a representative transition time interval (Figure 9, lines 12 and 13). For each small GTS trajectory set obtained by considering the stay time information, we use the input GTS pattern P with length k, the frequent single location, the representative semantic vector, the representative stay time interval, and the representative transition time interval to obtain the GTS pattern P  X  with length k + 1, and further consider P  X  and D  X  X  X  X  as inputs to the GTSP-Miner algorithm (Figure 9, lines 14 X 17).
 The three subroutines, ProjBySemantic , ProjByStayTime, and ProjByTransition-Time are the core of GTSP-Miner . Thus, we describe them in detail next. 3.4.1. ProjBySemantic. This subroutine is used to discover the frequent semantic vec-tors of a single frequent location in a GTS trajectory set and to divide that GTS tra-jectory set using the frequent semantic vectors discovered. The problem can be viewed as a problem of clustering GTS trajectories by frequent semantic vector clusters. Thus, we propose a new clustering algorithm to cluster GTS trajectories using frequent se-mantic vector clusters. Using the dataset in Table II as an example, if we set minimum support  X  m as 0.4, we find that locations Loc1, Loc5, Loc7, and Loc9 are frequent. Then, we perform the ProjBySemantic subroutine on D for location Loc1 to extract the se-mantic information as a vector set. Further, we consider the vector set as input and the cosine similarity as the similarity between two vectors to obtain the clusters by applying hierarchical clustering.

The traditional hierarchical clustering algorithm needs a user-specified threshold to split clusters. As shown in Figure 10, if we use threshold one to obtain clusters, the 0.0, 0.5 &gt; } . Since we set the minimum support  X  m as 0.4, we only consider clusters in which the number of vectors is greater than or equal to two. This means that only meanings, our algorithm automatically determines the cluster threshold such that the number of frequent clusters is maximized.

We use the top-down strategy (i.e., we initially treat all vectors as a cluster) to split a cluster into several smaller clusters by increasing the similarity threshold while simultaneously counting the number of vectors in each cluster. Thus, we also can determine the number of frequent clusters. Using linear search, we can easily determine the optimum threshold and frequent clusters. The central of a frequent cluster is called the reprehensive semantic vector. For each frequent cluster of location l with central v , we obtain the ( l, v )-projected GTS trajectory dataset. This dataset consists of three parts X  X uffix GTS trajectory, stay time sequence, and transition time sequence. For example, the dataset in Table II becomes the (Loc1, &lt; 0.05, 0.2, 0.75 &gt; )-projected GTS trajectory dataset shown in Table III.
 3.4.2. ProjByStayTime. This subroutine is used to obtain the frequent stay time interval of a single frequent semantic vector from the ( l, v )-projected GTS trajectory set and to divide the projected GTS trajectory set by the stay time interval. In fact, both stay time and transition time are only parts of the temporal property. As mentioned earlier, an effective strategy is to use a probabilistic exponential distribution to model it. On the basis of the probabilistic exponential distribution, we can easily extract the confidence interval of the stay time. If we use the data in Table III as an example and set the stay time significance level  X  s as 0.2, we get the 0.1 percentile  X  2 0 . 1 , 4 = 1.064 and the 2(6 + 6) / 1.064] = [3.09, 22.56]. It can be seen that the interval contains two points, [6] and [6], and the minimum support  X  m is set at 0 . 4(0 . 4  X  5 = 2). Hence, it is a frequent interval. Therefore, the pattern (Loc1, [3.09, 22.56], &lt; 0.05, 0.2, 0.75 &gt; ) will be mined and the ( l, s, v )-projected GTS trajectory dataset is obtained as shown in Table IV. Since the length of the pattern is one, there is no prefix pattern. The ProjByTransitionTime projected GTS trajectory dataset is considered as input to the next iteration. Note that it is trivial to see that the interval size is inversely proportional to the significance level. To represent the stay time and transition time precisely, we may set the significance level a higher value. 3.4.3. ProjByTransitionTime. This subroutine is used to obtain the frequent transition time interval between two frequent locations from the ( l, s, v )-projected GTS trajectory set and to divide the projected GTS trajectory set by the stay time interval. Similarly, suppose we execute the GTSP-Miner algorithm on the (Loc1, [3.09, 22.56], &lt; 0.05, 0.2, 0.75 &gt; )-projected GTS trajectory dataset, as shown in Table IV. After the ProjBySe-mantic and ProjByStayTime step, the (Loc1, [3.09, 22.56], &lt; 0.05, 0.2, 0.75 &gt; ) (Loc9, [3.86, 28.20], &lt; 0.1, 0.4, 0.5 &gt; )-projected GTS trajectory dataset is obtained, as shown in Table V. To determine the frequent transition time interval from locations Loc1 to Loc9 in T1 and T3, we first aggregate all the transition times from locations Loc1 to Loc9 in T1 and T3, respectively. We then extract the confidence interval of the transition time. For example, if we set the transition time significance level  X  t as 0.4 for Table V, we get interval is calculated as [2(11 + 13) / 5.99, 2(11 + 13) / 1.65] = [8.01, 29.09]. The interval contains two points, [11] and [13], and the minimum support  X  m issetat0 . 4(0 . 4  X  5 = 2). Hence, it is a frequent interval. Thus, the GTS pattern (Loc1, [3.09, 22.56], &lt; 0.05, 0.2, here we consider the  X  X ransition X  to be a different type of Poisson process from  X  X tay X ; therefore, we give another significance level for the transition time interval. It can be seen that there is no suffix GTS trajectory in the projected GTS trajectory dataset. Thus, the recursion will stop in this iteration.
 After discovering all of the GTS patterns, to make the prediction phase efficient, we adopt a prefix tree, called the GTS pattern tree, to compactly represent a collection of GTS patterns. (Hereafter the path of a GTS pattern tree indicates a decision rule.) The GTS-Tree is a kind of decision tree in which each node v consists of six elements X  location, stay time interval, transition time interval, semantic vector, support, and child links. Moreover, as mentioned earlier, the matching strategy in our prediction model is the most recent location matching strategy. Thus, we build the tree by reversing the order of the patterns and inserting the reversed patterns into the tree as a path. To simplify the structure of the tree, we merge redundant paths. The patterns mined for the dataset in Table II are displayed in Table VI. There are four redundant paths:  X  , they will be merged as (root) X (Loc9, [3.86, 28.20], &lt; 0.1, 0.4, 0.5 &gt; ). Similarly, the two nodes in the tree can be merged as a single node if and only if (1) they have a common prefix, (2) their locations are the same, (3) their semantic vectors are similar (  X   X  v ), (4) their temporal intervals (both stay time interval and transition time interval) Since the tree is used in location prediction, a path with a single element is meaningless. Therefore, we remove all paths that have a single element. The GTS-Tree is constructed as illustrated in Figure 11. As mentioned earlier, the main idea underlying a user-based collaborative filtering framework is the prediction of behavior of a user from similar behaviors of users. Therefore, similarity plays a crucial role in the prediction model. We argue that each user X  X  pattern tree represents his/her behavior, which is his/her frequent activity. Intuitively, the next location of a mobile user can be predicted not only from his/her own past movement behavior but also from that of other mobile users that exhibit sim-ilar semantic behaviors. In this section, we describe the similarity between two mobile users based on their GTS pattern trees. We first propose GTS similarity to measure the similarity between two paths of two different GTS pattern trees. We then extend the GTS similarity to measure the similarity between two users.

Given two paths for two different GTS pattern trees, we argue that they are more similar when they have more common parts. Thus, we first detect the longest common location path to represent the geographical common part. (For example, in Figure 12, the longest common location path is (Loc1) X (Loc9).) We then calculate the semantic similarity between two paths corresponding to the longest common location path. Next, we define the semantic similarity of two nodes according to the cosine similarity of their semantic vectors. For example, the semantic similarity in Figure 12 is given by Thus, the semantic similarity is 1.0 + 0.0 = 1.0. Finally, we calculate the temporal similarity between two paths corresponding to the longest common location path. We then define the semantic similarity of two nodes according to the proportion of the intersection of their stay time intervals to the union of their stay time intervals. In Figure 12, the temporal similarity is ([3.09, 22.56]  X  [3.09, 22.56])/([3.09, 22.56]  X  [3.09, 22.56]) + ([3.86, 28.20]  X  [4.14, 20.00])/([3.86, 28.20]  X  [4.14, 20.00]). Thus, the semantic similarity is 1.0 + 0.65 = 1.65. Accordingly, the similarity of the two paths is 1.0 + 1.65 = 2.65.

Since a path in the GTS pattern tree represents one of real-world moving behaviors of a user, we consider the similarity between two users in terms of the similarity of paths in their GTS pattern trees. When there is a strong similarity between the paths in the GTS pattern trees of two users, the location prediction model predicts their next locations as the same location. Since a GTS pattern tree may possibly possess several paths, we ex-tend GTS similarity to measure two GTS pattern trees. Let S U ={ M 1 , M 2 ,..., M m } and S V ={ M 1 , M 2 ,..., M n } be the sets of paths in the GTS pattern trees corre-sponding to users U and V , respectively. The user similarity between U and V is defined by Eq. (6).
 In this section, we explain how to predict the next stay location of a mobile user based on his/her current movement and his/her and similar GTS pattern trees of users. We argue that a GTS pattern tree provides the geographic, semantic, and temporal properties of most mobile users. Thus, for a given trajectory, we compute the best matching score of all the admissible paths in the pattern tree. For a mobile user who follows a trajectory T , we can detect all of the stay points and try to match them to a path in the pattern tree. Moreover, since our matching strategy is the most recent location matching strategy and the tree is constructed in a reverse pattern, we match the older stay point to the deeper node.

As shown in Figure 13, for a mobile user who follows a trajectory T ,his/hermost recent stay point s2 has already reached node (Loc7, [1.69, 8.18], &lt; 0.1, 0.83, 0.07 &gt; ), that is, the GPS coordinate stay point is close to stay location Loc1. Since the transition time interval between node (Loc7, [1.69, 8.18], &lt; 0.1, 0.83, 0.07 &gt; ) and node (Loc1, [4.89, 35.72], &lt; 0.5, 0.1, 0.4 &gt; ) is [7.34, 26.67], we seek the previous stay point from the 7.34 to the 26.67 time unit before GPS log. Based on a part of the log, we seek the stay point and match the stay point to child node (Loc7, [1.69, 8.18], &lt; 0.1, 0.83, 0.07 &gt; ). In this way, we can match most of the recent stay points of trajectory T to a path in the tree. We can then compute the matching score between these stay points and the path by summing all of the local scores in the path. For example, in Figure 13, the matching score between trajectory T and the leftmost path in the GTS pattern tree is the summation of the local scores of node (Loc7, [1.69, 8.18], &lt; 0.1, 0.83, 0.07 &gt; )and node (Loc1, [4.89, 35.72], &lt; 0.5, 0.1, 0.4 &gt; ). This local score is called nodeScore, and it indicates the goodness of a node with rerpect to a stay point. It measures the level of possibility of a node containing the stay point in a trajectory. We define the nodeScore to compute the average score of geographic behavior, semantic behavior, and temporal behavior as follows.
Here n is the node of the path in the GTS pattern tree, s is the stay point of current movement of the user, and  X  1 +  X  2 +  X  3 = 1. We define the GeographicScore of a node according to the spatial distance between the stay point and the spatial region of the location of the node specified by the following three different possible cases.  X  X he stay point is located in the region. In this, the optimal case, the GeographicScore is equal to the support value of the node.  X  X he stay point is near to the region. In this case, we define the distance  X  between the stay point and the region to be smaller than the radius r of the region. The GeographicScore is defined as follows.
  X  X he stay point is far away from the region. In this case, we define the distance between the stay point and the region to be greater than the radius of the region.
The GeographicScore is thus equal to 0. We define the SemanticScore of a node according to the cosine similarity between the semantic vector V 1 of the stay point and the semantic vector V 2 of the node as follows.
Here, the value of each dimension of the semantic vector of the stay point is consid-ered to be the proportion of the representing POI category, and the similarity between the semantic vector of the stay point and the semantic vector of the node is considered to be the cosine similarity of two semantic vectors. For example, in Figure 14, there are four POIs with the semantic B and C, respectively, and they are close to the stay point. The semantic vector of the stay point can be assigned as &lt; 0/4, 3/4, 1/4 &gt; . The is 0 . 4  X  0 . 96 = 0 . 384.
 We define the TemporalScore of a node according to the temporal distance between the stay point and the node specified by the following three different possible cases.  X  X he stay time of the stay point belongs to the same stay time interval as the node:
In this case, the TemporalScore is equal to the support value of the node.  X  X he stay time of the stay point is approximated to the stay time interval of the node:
In this case, we define the difference between the stay time of the stay point and the stay time interval of the node to be smaller than the range of the stay time interval  X  of the region. The TemporalScore is defined as follows.
  X  X he stay time of the stay point is NOT approximated to the stay time interval of the node: In this case, we define the difference between the stay time of the stay point and the stay time interval of the node to be greater than the range of the stay time interval  X  of the region. The TemporalScore is thus equal to zero.

For example, in Figure 15, the user stays around the stay point for 1.1 time units. The range of the stay time interval  X  of the region is 8 . 18  X  1 . 69 = 6 . 49 and the difference between the stay time of the stay point and the stay time interval of the node is | 1 . 1  X  1 . 69 |= 0 . 59  X  6 . 49; hence, the TemporalScore is calculated using Eq. (10). The TemporalScore is 0 . 4  X  (1  X  0 . 59 / 6 . 49) = 0 . 364.

By traversing all paths in the GTS pattern tree of all users, the score of each path can be obtained as the summation of all nodeScores in the path. Each path obtained represents the most likely route of the user according to his/her own GTS pattern tree. Since a GTS pattern tree is built by reversing the order of patterns and inserting the reversed patterns into the tree as a path, the first node (i.e., the stump node of the tree) in each path can be used in the making of a prediction. Accordingly, we can use the average user similarity to evaluate the possibility score that a particular location will be the location to which the user will move. Given a user u and a location l , we define the possibility score of l as follows: where U(l) is the set of users for which the first node in the path with the highest score is l . Accordingly, given a user-location pair, we can compute the possibility score of a location that the user will move to. Thus, we can make a next location prediction for current movement of a user by predicting the location as the one with the highest score. In this section, we report on the results of a series of experiments conducted to eval-uate the performance of our proposed next location prediction system using two real trajectory datasets crawled from two well-known trip-sharing Web sites X  X veryTrail and Bikely. All the experiments were conducted using Java JDK 1.6 on an Intel Quad Core CPU Q6600 2.40 GHz computer with 1GB of memory running Microsoft Win-dows XP. We first present the data preparation for the two crawled real datasets and then introduce the evaluation methodology. Finally, we present our results, followed by discussions. In this section, we detail the two real datasets used for examining our proposed method. Although there exist some widely used trajectory datasets such as GeoLife Trajectory Dataset (http://research.microsoft.com/en-us/downloads/b16d359d-d164-469e-9fd4-daa38f2b2e13/default.aspx) or T-Drive Taxi Trajectroies (http://research.microsoft.com/ apps/pubs/?id = 152883), these datasets lack semantic-related information. Conse-quently, these trajectory datasets do not fit for our experimental evaluation. Fortu-nately, some GPS-sharing Web sites, like EveryTrail (http://www.everytrail.com/) and Bikely (http://www.bikely.com/), not only provide GPS-sharing service for users but also allow users to tag some semantic terms on their uploaded trajectory. Accordingly, we crawled from EveryTrail and Bikely to make up two real datasets for our experimental evaluation. 6.1.1. EveryTrail Dataset. EveryTrail (http://www.everytrail.com/) is a trip-sharing and social networking Web site on which users can upload, share, and find trips. Every-Trail allows users to upload GPS logs and photos within a trip. Users can also label an activity on a trip. While EveryTrail provides a public API that enables other ap-plications to integrate with its service, some functionalities in the API are broken. For this reason, we used the API to support Web page crawling in order to get all the data we needed. We consider the  X  X tay X  to be an important fact in location prediction. However, there are many trips on EveryTrail, such as biking, flying, and hiking, in which the activities involve no stay. The users that follow such trips do not  X  X tay X  any-where. Therefore, we only selected trips comprising the kinds of activities from which we could obtain stay points. Using this rationale, we obtained 116,179 trips from 11 selected activities X  X pecifically, backpacking, driving, geocaching, ice skating, motor-cycling, relaxation, romantic getaway, sightseeing, snowshoeing, walking, and other. These trips were provided by 35,153 mobile users. For each mobile user, we randomly selected 70% of the trips from his/her trips dataset as our training dataset, and used the remaining trips to form our testing dataset. 6.1.2. Bikely Dataset. Bikely (http://www.bikely.com/) is also a trip-sharing Web site on which users can upload and share trip information. Bikely allows users to upload GPS logs within a trip and tag a trip using semantic terms. Bikely does not provide a public API for other applications to integrate with its service. For this reason, we had to crawl the site X  X  Web pages to get all the data we needed. As with EveryTrail, there are many trips on Bikely, such as training and offroad, in which no stay is involved. The users that follow such trips do not  X  X tay X  anywhere that has semantic meaning. Therefore, we selected only those trips with several kinds of tags for which we could obtain stay points. Using this rationale, we obtained 89,578 trips for 10 selected tags X  X pecifically, commute, recreational, onroad, smooth, not bike, low traffic, urban, rural, scenic, and touring. These trips were provided by 4,196 mobile users. For each mobile user, we randomly selected 70% of the trips from his/her trips dataset as our training dataset, and used the remaining trips to form our testing dataset. The following are the main measurements used in our experimental evaluation. The Precision, Coverage, and F-measure are defined, respectively, by Eqs. (12), (13), and (14), where p + and p  X  indicate the number of correct predictions and incorrect predic-tions, respectively, and | R | indicates the total number of trajectories. In addition, we used the average improvement rate to measure the percentage by which our proposed method outperforms other methods. The average improvement rate is defined by Eq. (15), in which m ours and m baseline are the measured results of our proposed method and that of the compared baseline method, respectively.

The experiments were divided into two groups: (i) internal evaluation; and (ii) exter-nal comparison. The internal evaluation group focused on evaluation of various param-eter settings for our GTS-LP framework. Table VII summarizes the major parameters in our prediction model and their default values. We first evaluated the precision of our proposed GTS-based location prediction under various settings for parameters re-lated to GTSP-Miner (i.e.,  X  s ,  X  t ,and  X  m ). We then compared the proposed nodeScore with various parameter settings (i.e.,  X  1 ,  X  2 , and  X  3 ) in terms of precision. For exter-nal comparison, we evaluated our proposed GTS-LP against the collaborative location recommendations model [Zheng et al. 2010a], spatial-social approximation [Backstrom et al. 2010], and WhereNext [Monereale et al. 2009] in terms of precision, coverage, and F-measure by varying parameters such as minimum support threshold and the training data proportion. In this experiment, we evaluated the efficiency of GTSP-Miner for various dataset sizes. We used a semi-simulation strategy to generate bigger datasets. First, we gen-erated a synthetic user and randomly selected between two and 20 trips of real users as the synthetic user X  X  trips. Figure 16(a) shows the resulting dataset simulated from the EveryTrail dataset. As can be seen in Figure 16(a), the training time increased exponentially as the size of the dataset increased. This is reasonable for training high-quality models to make precise predictions. Figure 16(a) shows that, unlike the training time, the testing time, that is, the time for online prediction, linearly increased as the size of the dataset increased. This is also reasonable as more requests cost more in terms of time. In fact, in the real application, this step was panelized and sped up to constant time. Figure 16 shows that the resulting dataset simulated from the Bikely dataset was similar to that simulated from the EveryTrail dataset. Since the Bikely dataset was smaller than the EveryTrail dataset, the dataset simulated from the Bikely dataset was also small, as shown in Figure 16(b). It can also be seen that the training time increased exponentially as the size of the dataset increased, while the testing time increased linearly as the size of the dataset increased. 6.4.1. EveryTrail Dataset. In this experiment, we evaluated the precision of our approach under various parameter settings for GTSP-Miner based on the EveryTrail dataset. In the experiment, the default values of weights for nodeScore (  X  1 ,  X  2 , and  X  3 ) were set at 0.5, 0.3, and 0.2, respectively. In Figure 17(a), the highest precision occurs for parameter settings  X  v , = 0.5 and  X  s = 0.3. However, we also observed that the resulting precision for parameter settings  X  v , = 0.5 and  X  s = 0.3 were very close to the highest precision achieved. In Figure 17(b), the highest precision occurs for parameter settings  X  v = 0.5 and  X  t = 0.4. Both Figure 17(a) and Figure 17(b) show that the highest precision occurred when the semantic similarity threshold was set at 0.5. The optimal setting for the significance level of the stay time interval was smaller than that of the transition time interval. This signifies that the stay time interval should be more centralized than the transition time interval and also that they are always determined by different probabilistic distributions. This result strongly proves that movements of users are partially motivated by Geographic-triggered, Temporal-triggered, and Semantic-triggered Intentions. 6.4.2. Bikely Dataset. In this experiment, we evaluated the precision of our approach under various parameter settings for GTSP-Miner based on the Bikely dataset. The default values for the weights of nodeScore (  X  1 ,  X  2 , and  X  3 )weresetat0.5,0.3,and 0.2, respectively. In Figure 18(a), the highest precision occurs for parameter settings  X  , = 0.5 and  X  s = 0.2. On the basis of this observation and the result shown in Figure 17(a), the default values for  X  v and  X  s were set at 0.5 and 0.2, respectively. In Figure 18(b), the highest precision occurs for parameter settings  X  v = 0.5 and  X  t = 0.4. Both Figure 18(a) and Figure 18(b) show that the highest precision occurred when the semantic similarity threshold was set at 0.5. This observation along with the result shown in Figure 17(b) strongly supports our default settings. Similarly, as also shown by Figure 17, the optimal significance level of the stay time interval was smaller than that of the transition time interval. This result strongly proves that it is necessary to consider the temporal property as the transition time and the stay time, respectively. 6.5.1. EveryTrail Dataset. In this experiment, we evaluated our approach under various parameter settings in terms of Precision based on the EveryTrail dataset. As can be seen in Figure 19(a), the Precision of our method improved when  X  1 was increased, that is, higher precision was achieved when we gave more weight to geographic be-haviors, with the highest precision occurring for parameter settings  X  1 = 0.5 and  X  iors are the most essential property, the semantic-and temporal-triggered behaviors still potentially have an effect on predicting the next movement. We also observed that the Precision does not increase monotonically as  X  2 increases, that is, as more weight is assigned to SemanticScore , the precision does not necessarily increase. This contradicts our assumption that considering semantic-triggered behaviors will improve the precision of prediction. We believe that this is because the temporal-triggered be-haviors still potentially have an effect on predicting the next movement. On the basis of this observation, we set the default values for  X  1 ,  X  2 , and  X  3 at 0.5, 0.3, and 0.2, respectively. As shown in Figure 19(b), the Precision of our method improved when the minimum support increased, that is, higher precision was achieved when we fo-cused on more frequent behaviors, and the highest precision occurred for the following parameter settings: minimum support = 3%,  X  1 , = 0.5,  X  2 = 0.3, and  X  3 = 0.2 (i.e., when all the geographic-triggered, temporal-triggered, and semantic-triggered behav-iors were taken into consideration). We also observed that the Precision was worst, on average, when we set  X  1 = 1 (i.e., when only the geographic property was taken into consideration). 6.5.2. Bikely Dataset. In this experiment, we evaluated our approach under various parameter settings in terms of Precision based on the Bikely dataset. Figure 20(a) shows that a similar result to that of Figure 19(a) was obtained X  X he Precision of our method improved when  X  1 was increased, that is, higher precision was achieved when more weight was given to geographic behaviors, with the highest precision occurring for parameter settings  X  1 = 0.5 and  X  2 = 0.3 (i.e.,  X  3 = 0.2). This result strongly supports the default value of  X  1 ,  X  2 , and  X  3 being set at 0.5, 0.3, and 0.2, respectively. However, from Figure 20(b), it can be seen that the Precision of our method decreased when the minimum support increased, that is, higher precision was achieved when we mined more patterns, and the highest precision occurred for the following parameter settings: minimum support = 0.5%,  X  1 , = 0.5,  X  2 = 0.3, and  X  3 = 0.2 (i.e., when all the geographic-triggered, temporal-triggered, and semantic-triggered behaviors were taken into consideration). This is because the average number of trips per user in the Bikely dataset is larger than that of the EveryTrail dataset. When minimum support is decreased, many significant patterns can still be mined from the Bikely dataset. We also observed that the Precision was worst, on average, for  X  1 = 1 (i.e., when only the geographic property was taken into consideration).
 6.6.1. EveryTrail Dataset. In this experiment, we analyzed the precision, coverage, and F-measure of the prediction techniques X  X pecifically, the collaborative location rec-ommendations model [Zheng et al. 2010a], spatial-social approximation [Backstrom et al. 2010], WhereNext [Monereale et al. 2009], and our GTS-LP approach X  X or var-ious minimum support thresholds. Since collaborative location recommendation and spatial-social approximation are not pattern-based prediction models, they do not need the minimum support parameter to mine frequent behavior of users. Therefore, the two models give a constant result under various minimum support settings. Figure 21 shows that GTS-LP performed marginally better than collaborative location recom-mendation in terms of precision, coverage, and F-measure, but significantly outper-formed WhereNext and spatial-social approximation for those measures. This is because GTS-LP and collaborative location recommendation both utilize a user-based collabo-rative filtering framework for their prediction model. The user-based collaborative fil-tering framework makes the prediction more precise and able to deal with trajectories that cannot be predicted. The difference between our method and collaborative location recommendation is that our method considers all the geographic-triggered, temporal-triggered, and semantic-triggered behaviors. Therefore, our method is more precise. For these two reasons, the precision, coverage, and F-measure improved. The average improvement rates of GTS-LP over WhereNext were 63.17% for precision, 555.03% for coverage, and 383.62% for F-measure. The average improvement rates of GTS-LP over collaborative location recommendation were 29.40% for precision, 0% for coverage, and 7% for F-measure. The average improvement rates of GTS-LP over spatial-social ap-proximation were 3% for precision, 366.88% for coverage, and 198.68% for F-measure. 6.6.2. Bikely Dataset. In this experiment, we analyzed the precision, coverage, and F-measure of the prediction techniques examined X  X pecifically, the collaborative loca-tion recommendations model [Zheng et al. 2010a], WhereNext [Monereale et al. 2009], and our GTS-LP approach X  X or various minimum support thresholds. Since Bikely (http://www.bikely.com/) does not provide a social networking service, spatial-social ap-proximation cannot work on its dataset. In addition, because collaborative location recommendation is not a pattern-based prediction model, it does not need the mini-mum support parameter to mine frequent behaviors of users. Therefore, collaborative location recommendation gives a constant result under various minimum support set-tings. Figure 22 shows that GTS-LP was marginally better than collaborative location recommendation in terms of precision, coverage, and F-measure, but significantly out-performed WhereNext for those measures.

As in the previous experiment, this occurred because GTS-LP and collaborative location recommendation both utilize a user-based collaborative filtering framework in their prediction model. The user-based collaborative filtering framework makes the prediction more precise and able to deal with trajectories that cannot be predicted. The difference between our method and collaborative location recommendation is that our method takes into consideration all the geographic-triggered, temporal-triggered, and semantic-triggered behaviors in the prediction of the next location of a user. This results in our method being able to comprehensively deal with all types of movement of a user. Thus, the precision, coverage, and F-measure are improved. The average improvement rates of GTS-LP over WhereNext were 41.48% for precision, 788.90% for coverage, and 415.19% for F-measure. The average improvement rates of GTS-LP over collaborative location recommendation were 3.3% for precision, 23.58% for coverage, and 13.44% for F-measure. 6.7.1. EveryTrail Dataset. In this experiment, we analyzed the precision, coverage, and F-measure of the prediction techniques examined X  X hat is, the collaborative location recommendations model [Zheng et al. 2010a], spatial-social approximation [Backstrom et al. 2010], WhereNext [Monereale et al. 2009], and our GTS-LP approach for vari-ous training data proportions. The training data proportion refers to the proportion of the dataset we used to train the prediction model. For example, when we set the training proportion at 70%, 70% of the trajectories were treated as training data, and the remaining 30% were treated as testing data. Figure 23 shows that the precision of GTS-LP was sensitive to training proportion. This is because GTS-LP takes into consideration all the geographic-triggered, temporal-triggered, and semantic-triggered behaviors in its computation of nodeScore . When the training data is deficient, it not only damages the geographic property, but also lacks semantic and temporal prop-erties. We also observed that GTS-LP marginally outperformed collaborative location recommendation and spatial-social approximation in terms of coverage and F-measure, but significantly outperformed WhereNext for those measures. On average, the im-provement rate was still reasonable. The average improvement rates for GTS-LP over WhereNext were 60.17% for precision, 19.78% for coverage, and 40.78% for F-measure. The average improvement rates for GTS-LP over collaborative location recommenda-tion were 12.67% for precision, 4.97% for coverage, and 8.9% for F-measure. The aver-age improvement rates for GTS-LP over spatial-social approximation were 47.34% for precision, 544.22% for coverage, and 284.24% for F-measure. 6.7.2. Bikely Dataset. In this experiment, we analyzed the precision, coverage, and F-measure of the prediction techniques examined X  X hat is, the collaborative loca-tion recommendations model [Zheng et al. 2010], WhereNext [Monereale et al. 2009], and our GTS-LP approach X  X or various training data proportions. Since Bikely (http://www.bikely.com/) does not provide a social networking service, spatial-social ap-proximation could work on its dataset. Figure 24 shows that the precision of GTS-LP was not sensitive to training proportion. This result contradicts the observation made in the case of the EveryTrail dataset. This is because the average number of trips per user in the Bikely dataset is greater than that of the EveryTrail dataset. When the size of the training dataset decreases, there are still many significant patterns to be mined from the Bikely dataset. It can also be seen that GTS-LP marginally outperformed collaborative location recommendation and WhereNext in terms of precision, coverage, and F-measure. On average, the improvement rate was quite reasonable. The average improvement rates for GTS-LP over WhereNext were 53.58% for precision, 26.46% for coverage, and 39.31% for F-measure. The average improvement rates for GTS-LP over collaborative location recommendation were 24.5% for precision, 82.65% for coverage, and 48.4% for F-measure. In this article, we defined a new kind of frequent pattern, namely GTS pattern, which takes into account moving behaviors of users motivated by Geographic-triggered , Temporal-triggered, and Semantic-triggered Intentions . On the basis of GTS pattern, we proposed a novel user-based collaborative filtering framework called GTS-LP to predict the next location of a mobile user for applications such as location-based ser-vices. The core of our prediction module is a novel prediction strategy that evaluates the score of the next stay location for a given mobile user by mining the moving be-haviors of users in terms of the geographic, temporal, and semantic properties. To the best of our knowledge, this is the first work that focuses on next location prediction by mining trajectory data that takes into consideration all the geographic, temporal, and semantic moving behaviors of users. Through a series of experiments, we validated our proposal and showed that our approach gives excellent performance under various conditions and also outperforms state-of-the-art approaches such as collaborative lo-cation recommendation [Zheng et al. 2010a], spatial-social approximation [Backstrom et al. 2010], and WhereNext [Monereale et al. 2009] in terms of precision, coverage, and F-measure. For future work, we will explore designing more advanced methods to further enhance the quality of location prediction systems for various location-based service applications. Besides, since our prediction model considers all of the geographic, temporal, and semantic properties of users X  moving behaviors, a number of parameters corresponding to these properties are used in the model. As the next step, we will also try to simplify the parameters to reduce the complexity of the model.

