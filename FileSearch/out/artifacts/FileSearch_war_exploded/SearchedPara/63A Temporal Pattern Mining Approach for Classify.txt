 IYAD BATAL, HAMED VALIZADEGAN, GREGORY F. COOPER, Advances in data collection and data storage technologies have led to the emergence of complex multivariate temporal datasets, where data instances are traces of complex behaviors characterized by multiple time series. Such data appear in a wide variety of domains, such as healthcare [Hauskrecht et al. 2010; Sacchi et al. 2007; Ho et al. 2003], sensor measurements [Jain et al. 2004], intrusion detection [Lee et al. 2000], motion capture [Li et al. 2009], environmental monitoring [Papadimitriou et al. 2005], and many more. Designing algorithms capable of learning from such complex data is one of the most challenging topics of data mining research.

This work primarily focuses on developing methods for analyzing electronic health records (EHRs). Each record in the data consists of multiple time series of clinical variables collected for a specific patient, such as laboratory test results, medication or-ders, and physiological parameters. The record may also provide information about the patient X  X  diseases, surgical interventions, and their outcomes. Learning classification models from this data is extremely useful for patient monitoring, outcome prediction, and decision support.

The task of temporal modeling in EHR data is very challenging because the data is multivariate and the time series for clinical variables are acquired asynchronously, which means they are measured at different time moments and are irregularly sam-pled in time. Therefore, most times series classification methods (e.g., hidden Markov model [Rabiner 1989] or recurrent neural network [Rojas 1996]), time series simi-larity measures (e.g., Euclidean distance or dynamic time warping [Ratanamahatana and Keogh 2005]), and time series feature extraction methods (e.g., discrete Fourier transform, discrete wavelet transform [Batal and Hauskrecht 2009], or singular value decomposition [Weng and Shen 2008]) cannot be directly applied to EHR data. This article proposes a temporal pattern mining approach for analyzing EHR data. The key step is defining a language that can adequately represent the temporal dimen-sion of the data. We rely on temporal abstractions [Shahar 1997] and temporal logic [Allen 1984] to define patterns able to describe temporal interactions among multiple time series. This allows us to define complex temporal patterns like  X  X he administration of heparin precedes a decreasing trend in platelet counts X .

After defining temporal patterns, we need an algorithm for mining patterns that are important to describe and predict the studied medical condition. Our approach adopts the frequent pattern mining paradigm. Unlike the existing approaches that find all frequent temporal patterns in an unsupervised setting [Villafane et al. 2000; shan Kam and chee-Fu 2000; Hoppner 2003; Papapetrou et al. 2005; Moerchen 2006; Winarko and Roddick 2007; Wu and Chen 2007; Sacchi et al. 2007; Moskovitch and Shahar 2009], we are interested in those patterns that are important for the classification task. We present the Minimal Predictive Temporal Patterns (MPTP) framework, which relies on a statistical test to effectively filter out nonpredictive and spurious temporal patterns.
We demonstrate the usefulness of our framework on the real-world clinical task of predicting patients who are at risk of developing heparin-induced thrombocytopenia (HIT), a life threatening condition that may develop in patients treated with heparin. We show that incorporating the temporal dimension is crucial for this task. In addition, we show that the MPTP framework provides useful features for classification and can be beneficial for knowledge discovery because it returns a small set of discriminative temporal patterns that are easy to analyze by a domain expert. Finally, we show that mining MPTPs is more efficient than mining all frequent temporal patterns.
Our main contributions are summarized as follows.  X  X e propose a novel temporal pattern mining approach for classifying complex EHR data.  X  X e extend our minimal predictive patterns framework [Batal and Hauskrecht 2010] to the temporal domain.  X  X e present an efficient mining algorithm that integrates pattern selection and fre-quent pattern mining.

The rest of the article is organized as follows. Section 2 describes the problem and briefly outlines our approach for solving it. Section 3 defines temporal abstraction and temporal patterns. Section 4 describes an algorithm for mining frequent temporal pat-terns and techniques we propose for improving its efficiency. Section 5 discusses the problem of pattern selection, its challenges, and the deficiencies of the current methods. Section 6 introduces the concept of minimal predictive temporal patterns (MPTP) for selecting the classification patterns. Section 7 describes how to incorporate MPTP se-lection within frequent temporal pattern mining and introduces pruning techniques to speed up the mining. Section 8 illustrates how to obtain a feature-vector representation of the data. Section 9 compares our approach with several baselines on the clinical task of predicting patients who are at risk of heparin-induced thrombocytopenia. Finally, Section 10 discusses related work and Section 11 concludes.
 Let D ={ &lt; x i , y i &gt; } be a dataset such that x i  X  X is the electronic health record for patient i up to some time t i ,and y i  X  Y is a class label associated with a medical condition at time t i . Figure 1 shows a graphical illustration of an EHR instance with three clinical temporal variables.

Our objective is to learn a function f : X  X  Y that can predict accurately the class labels for future patients. Learning f directly from X is very difficult because the instances consist of multiple irregularly sampled time series of different length. There-fore, we want to apply a transformation  X  : X  X  X that maps each EHR instance x i to a fixed-size feature vector x i while preserving the predictive temporal characteristics of x as much as possible. One approach is to apply a static transformation and represent the data using a predefined set of features and their values [Hauskrecht et al. 2010]. Examples of such features are  X  X ost recent creatinine measurement X ,  X  X ost recent creatinine trend X ,  X  X aximum cholesterol measurement X , etc. Our approach is different and we learn transformation  X  from the data using temporal pattern mining ( dynamic transformation ). This is done by applying the following steps. (1) Convert the time series variables into a higher-level description using temporal (2) Mine the minimal predictive temporal patterns . (3) Transform each EHR instance x i to a binary vector x i , where every feature in x i
After applying this transformation, we can use a standard machine learning method function f . The goal of temporal abstraction [Shahar 1997] is to transform the time series for all clinical variables to a high-level qualitative form. More specifically, each clinical variable (e.g., series of white blood cell counts) is transformed into an interval-based time b i to time e i and is the abstraction alphabet that represents a finite set of all permitted abstractions.

The most common types of clinical variables in EHR data are medication adminis-trations and laboratory results.  X  Medication variables are usually already represented in an interval-based format and specify the time interval during which a patient was taking a specific medication.
For these variables, we simply use abstractions that indicate whether the patient is on the medication: ={ ON , OFF } .
  X  Lab variables are usually numerical time series 1 that specify the patient X  X  laboratory results over time. For these variables, we use two types of temporal abstractions. (1) Trend abstraction that uses the following abstractions: decreasing ( D ), steady ( S ), (2) Value abstraction that uses the following abstractions: very low ( VL ), low ( L ), nor-
Figure 2 shows the trend and value abstractions on a time series of platelet counts of a patient. Let a state be an abstraction for a specific variable. For example, state E : V i = D represents a decreasing trend in the values of temporal variable V i . We sometimes use the shorthand notation D i to denote this state, where the subscript indicates that D is abstracted from the i th variable. Let a state interval be a state that holds during an interval. We denote by ( E , b i , e i ) the realization of state E in a data instance, where E starts at time b i and ends at time e i .

Definition 3.1 . A state sequence is a series of state intervals, where the state inter-vals are ordered according to their start times. 2
Note that we do not require e i to be less than b i + 1 , because the states are obtained from multiple temporal variables and their intervals may overlap.

After abstracting all temporal variables, we represent every instance (i.e., patient) in the database as a state sequence. We will use the terms instance and state sequence interchangeably hereafter. Allen X  X  temporal logic [Allen 1984] describes the relations for any pair of state intervals using 13 possible relations (see Figure 3). However, it suffices to use the following seven relations X  before , meets , overlaps , is-finished-by , contains , starts ,and equals  X  X ecause the other relations are simply their inverses. Allen X  X  relations have been used by most work on mining time interval data [shan Kam and chee-Fu 2000; Hoppner 2003; Papapetrou et al. 2005; Winarko and Roddick 2007; Moskovitch and Shahar 2009]. Most of Allen X  X  relations require equality of one or two of the intervals end points. That is, there is only a slight difference between overlaps , is-finished-by , contains , starts ,and equals relations. Hence, when the time information in the data is noisy (not precise), which is the case in EHR data, using Allen X  X  relations may cause the problem of pattern fragmentation [Moerchen 2006]. Therefore we opt to use only two temporal relations, before ( b )and co-occurs ( c ), which we define as follows.
 Given two state intervals E i and E j : In order to obtain temporal descriptions of the data, we combine basic states using tem-poral relations to form temporal patterns. Previously, we saw that the relation between two states can be either before ( b )or co-occurs ( c ). In order to define relations between k states, we adopt Hoppner X  X  representation of temporal patterns [Hoppner 2003].
Definition 3.2 . A temporal pattern is defined as P = ( S 1 ,..., S k , R ), where S i is the i th state of the pattern and R is an upper triangular matrix that defines the temporal relations between each state and all of its following states.
 The size of pattern P is the number of states it contains. If size( P ) = k ,wesaythat P is a k-pattern . Hence, a single state is a 1-pattern (a singleton ). We also denote the space of all temporal patterns of arbitrary size by TP .

Figure 4 graphically illustrates a 4-pattern with states A 1 , B 2 , C 3 , B 1 , where the states are abstractions of temporal variables V 1 , V 2 ,and V 3 using abstraction alphabet ={ A , B , C } . The half matrix on the right represents the temporal relations between every state and the states that follow it. For example, the second state B 2 is before the fourth state B 1 : R 2 , 4 = b .

Interesting patterns are usually limited in their temporal extensions, that is, it would not be interesting to use the before relation to relate states that are temporally very far away from each other. Therefore, the definition of temporal patterns usually comes with a specification of a window size that defines the maximum pattern duration [Moerchen 2006; Hoppner 2003; Mannila et al. 1997].

In this article, we are interested in the patient monitoring task, where we have the electronic health record for patient x i up to time t i , and we want to decide whether or not patient x i is developing a medical condition that we should alert physicians about. In this task, recent measurements of the clinical variables of x i (close to t i ) are usually more predictive than distant measurements, as was shown by Valko and Hauskrecht [2010]. The approach taken in this article is to define windows of fixed width that end at t i for every patient x i and only mine temporal patterns that can be observed inside these windows.
 within a specific window. We say that pattern P = ( S 1 ,..., S k , R ) occurs in T (or that P covers T ), denoted as P  X  T , if there is an injective mapping  X  from the states of P to the state intervals of T such that
Notice that checking the existence of a temporal pattern in a state sequence requires (1) matching all k states of the patterns and (2) checking that all k ( k  X  1) / 2 temporal relations are satisfied.

Definition 3.4 .P = ( S 1 ,..., S k noted as P  X  P ,if k 1 &lt; k 2 and there is an injective mapping  X  from the states of P to the states of P such that For example, pattern ( A 1 , C 3 , R 1 , 2 = b ) is a subpattern of the pattern in Figure 4. If P is a subpattern of P ,wesaythat P is a superpattern of P .

Definition 3.5 . The support of temporal pattern P in database D is the number of instances in D that contain P .
Note that the support definition satisfies the Apriori property [Agrawal and Srikant 1994]. We define a rule to be of the form P  X  y , where P is a temporal pattern and y is a specific value of the target class variable Y . We say that rule P  X  y is a subrule of rule P  X  y if P  X  P and y = y .

Definition 3.6 . The confidence of rule P  X  y is the proportion of instances from class y in all instances covered by P . where D y denotes all instances in D that belong to class y.

Note that the confidence of rule R : P  X  y is the maximum likelihood estimation of the probability that an instance covered by P belongs to class y .If R is a predictive rule of class y , we expect its confidence to be larger than the prior probability of y in the data. In this section, we present our proposed algorithm for mining frequent temporal pat-terns. We chose to utilize the class information and mine frequent temporal patterns for each class label separately using local minimum supports as opposed to mining fre-quent temporal patterns from the entire data using a single global minimum support. The approach is reasonable when pattern mining is applied in the supervised setting because (1) for unbalanced data, mining frequent patterns using a global minimum support threshold may result in missing many important patterns in the rare classes and (2) mining patterns that are frequent in one of the classes (hence potentially pre-dictive for that class) is more efficient than mining patterns that are globally frequent. 3
The mining algorithm takes as input D y : the state sequences from class y and  X  y : a user-specified local minimum support threshold. It outputs all frequent temporal patterns in D y . The mining algorithm performs an Apriori-like level-wise search [Agrawal and Srikant 1994]. It first scans the database to find all frequent 1-patterns . Then for each level k , the algorithm performs the following two phases to obtain the frequent ( k + 1)-patterns . (1) The candidate generation phase. Generate candidate ( k + 1) -patterns from the fre-(2) The counting phase. Obtain the frequent ( k + 1)-patterns by removing candidates This process repeats until no more frequent patterns can be found.

In the following, we describe in details the candidate generation algorithm and tech-niques we propose for improving the efficiency of candidate generation and counting. We generate a candidate ( k + 1)-pattern by adding a new state (1-pattern )tothe beginning of a frequent k-pattern . 4 Let us assume that we are extending pattern P = ( S 1 ,..., S k , R ) with state S ne w in order to generate candidates of the form R , j for i  X  X  1 ,..., k  X  1 } X  j  X  X  i + 1 ,..., k } . This way, we know that every candidate P of this form is a superpattern of P : P  X  P .

In order to fully define a candidate, we still need to specify the temporal relations { 2 ,..., k + 1 } . Since we have two possible temporal relations ( before and co-occurs ), there are 2 k possible ways to specify the missing relations. That is, 2 k possible candidates can be generated when adding a new state to a k-pattern .Let L denote all possible states (1-patterns )andlet F k denote the frequent k-patterns , generating the ( k + 1)-candidates naively in this fashion results in 2 k  X | L | X | F k | different candidates.
This large number of candidates makes the mining algorithm computationally very expensive and limits its scalability. Next, we describe the concept of incoherent patterns and introduce a method that smartly generates fewer candidates without missing any valid temporal pattern from the result.
Definition 4.1 . A temporal pattern P is incoherent if there does not exist any valid state sequence that contains P .

Clearly, we do not have to generate and count incoherent candidates because we know that they will have zero support in the dataset. We introduce the following two propositions to avoid generating incoherent candidates when specifying the relations R , i in candidates of the form P P ROPOSITION 4.2. P = ( S 1 ,..., S k + 1 , R ) is incoherent if R 1 , i = c and states S 1 and S i belong to the same temporal variable.
 Two states from the same variable cannot co-occur because temporal abstraction seg-ments each variable into non-overlapping state intervals.

P ROOF . Let us assume that there exists a state sequence T = ( E 1 , b 1 , e 1 ) ,..., ( E intervals of T . The definition of temporal patterns and the fact that state inter-vals in T are ordered by their start values implies that the matching state inter-R contradiction. Therefore, there is no state sequence that contains P .
 Example 4.4 . Assume we want to extend pattern P = ( A 1 , B 2 , C 3 , B 1 , R )in Figure 4 with state C 2 to generate candidates of the form ( C 2 , A 1 , B 2 , C 3 , B 1 , R ). The relation between the new state C 2 and the first state A 1 is allowed to be either before or co-occurs : R 1 , 2 = b or R 1 , 2 = c . However, according to Proposition 4.2, C 2 cannot co-occur with B 2 because they both belong to temporal variable V 2 ( R 1 , 3 = c ). Also, according to Proposition 4.3, C 2 cannot co-occur with C 3 ( R 1 , 4 = c ) because C 2 is before B 2 ( R 1 , 3 = b )and B 2 should start before C 3 . For the same reason, C 2 cannot co-occur with B 1 ( R 1 , 5 = c ). By removing incoherent patterns, we reduce the number of candidates that result from adding C 2 to 4-pattern P from 2 4 = 16 to only 2.
T HEOREM 4.5. There are at most k + 1 coherent candidates that result from extending a k-pattern with a new state.

P ROOF . We know that every candidate P = ( S 1 ,..., S k + 1 , R ) corresponds to a specific assignment of R 1 , i  X  X  b , c } for i  X  2 ,... k + 1. When we assign the temporal relations, once a relation becomes before , all the following relations have to be before as well, according to Proposition 4.3. We can see that the relations can be co-occurs in the beginning of the pattern, but once we see a before relation at point q  X  X  2 ,..., k + 1 } in the pattern, all subsequent relations ( i &gt; q ) should be before as well. Therefore, the total number of coherent candidates cannot be more than k + 1, which is the total number of different combinations of consecutive co-occurs relations followed by consecutive before relations.

In some cases, the number of coherent candidates is less than k + 1. Assume that there are some states in P that belong to the same variable as state S 1 .Let S j be the first such state ( j  X  k + 1). According to Proposition 4.2, R 1 , j = c . In this case, the number of coherent candidates is j  X  1 &lt; k + 1.

C OROLLARY 4.6. Let L denote all possible states and let F k denote all frequent k-patterns. The number of coherent ( k + 1) -candidates is always less or equal to ( k + 1)  X | L | X | F
So far, we described how to generate coherent candidates by appending singletons to the beginning of frequent temporal patterns. However, we do not have to count all coherent candidates, because some of them may be guaranteed not to be frequent. To filter out such candidates, we apply Apriori pruning [Agrawal and Srikant 1994], which removes any candidate ( k + 1)-pattern if it contains an infrequent k-subpattern . Even after eliminating incoherent candidates and applying Apriori pruning, the mining algorithm is still computationally expensive, because for every candidate, we need to scan the entire database in the counting phase to check whether or not it is a frequent pattern. The question we try to answer in this section is whether we can omit portions of the database that are guaranteed to not contain the candidate we want to count. The proposed solution is inspired by Zaki [2000] who introduced the vertical format for itemset mining and later extended it to sequential pattern mining [Zaki 2001].
Let us associate every frequent pattern P with a list of identifiers for all state sequences in D y that contain P .
 Clearly, sup ( P , D y ) =| P . id -list | .

Definition 4.7 . The potential id-list ( pid -list ) of pattern P is the intersection of the id-lists of its subpatterns.
 P ROPOSITION 4.8.  X  P  X  TP : P . id-list  X  P . pid-list
P ROOF . Assume T i is a state sequence in the database such that P  X  T i . By def-inition, i  X  P . id -list . We know that T i must contain all subpatterns of P accord-ing to the Apriori property:  X  S  X  P : S  X  T i . Therefore,  X  S  X  P : i  X  S . id -list = X  i  X  X  X  Note that for itemset mining, P . pid -list is always equal to P . id -list [Zaki 2000]. However, this is not true for time-interval temporal patterns. As an example, suppose Figure 5. T i contains all subpatterns of P and hence i  X  P . pid -list . However, T i does not contain P (there is no mapping  X  that satisfies definition 3.3); hence i  X  P . id -list .
Putting it all together, we compute the id-lists in the counting phase (based on the true matches) and the pid-lists in the candidate generation phase. The key idea is that when we count a candidate, we only need to check the state sequences in its pid-list because
This offers a lot of computational savings, since the pid-lists get smaller as the size of the patterns increases, making the counting phase much faster.

Algorithm 1 shows the candidate generation algorithm. After generating coherent candidates (line 3), we apply Apriori pruning (lines 5 and 6). In our implementation, we hash all patterns in F k , so that searching for the k -subpatterns of the candidate in F k requires only k operations. Now that we found all k -subpatterns, we simply intersect their id-lists to compute the pid-list of the candidate (line 7). Note that the cost of the intersection is linear because the id-lists are always sorted according to the order of the instances in the database. Line 8 is used for mining the minimal predictive temporal patterns and will be explained later in Section 7. Finally, line 9 applies an additional pruning to remove candidates that are guaranteed not to be frequent according to the following implication of Proposition 4.8. Applying frequent temporal pattern mining on data usually results in a very large number of patterns, most of which may be unimportant for the classification task. Using all of these patterns as features can hurt the classification performance due to the curse of dimensionality. Therefore, it is important to develop effective methods to select a small subset of patterns that are likely to improve the classification performance.
The task of pattern selection is more challenging than the well-studied task of feature selection due to the nested structure of patterns: if P is frequent, all instances covered by P are also covered by all of its subpatterns, which are also in the result of the frequent pattern mining method. This nested structure causes the problem of spurious patterns , which we will illustrate in the following.
Definition 5.1 . A temporal pattern P is a spurious pattern if P is predictive when evaluated by itself, but it is redundant given one of its subpatterns.

Example 5.2 . Assume that having very low platelet counts (PLT) is an important risk factor for heparin-induced thrombocytopenia (HIT). If we denote pattern PLT = VL by P , we expect conf ( P  X  HIT ) to be much higher than the HIT prior in the data. Now assume that there is no causal relation between the patient X  X  potassium (K) level and his risk of HIT, so a pattern like K = N (normal potassium) does not change our belief about the presence of HIT. If we combine these two patterns, for example P : K = N before PLT = VL , we expect that conf ( P  X  HIT )  X  conf ( P  X  HIT ). The intuition behind this is that the instances covered by P can be seen as a random subsample of the instances covered by P . So if the proportion of HIT cases in P is relatively high, we expect the proportion of HIT cases in P to be high as well [Batal and Hauskrecht 2010].
The problem is that if we examine P by itself, we may falsely conclude that it is a good predictor of HIT, where in fact this happens only because P contains the real predictive pattern P . Having such spurious patterns in the mining results is undesirable for classi-fication because it leads to many redundant and highly correlated features. It is also un-desirable for knowledge discovery because spurious patterns can easily overwhelm the domain expert and prevent him/her from understanding the real causalities in the data. The most common way to select patterns for classification is the two-phase approach, which generates all frequent patterns in the first phase and then selects the top k discriminative patterns in the second phase. This approach has been used for itemset-based classification [Cheng et al. 2007; Li et al. 2001], for sequence classification [Exar-chos et al. 2008; Tseng and Lee 2005], and for graph classification [Deshpande et al. 2005]. However, the two-phase approach is not very effective because when frequent patterns are evaluated individually in the second phase, there is a high risk of selecting spurious patterns because they look predictive using most interestingness measures [Geng and Hamilton 2006]. One way to partially overcome this problem is to apply an iterative forward pattern selection method [Cheng et al. 2007]. However, such meth-ods are computationally very expensive when applied on large number of frequent patterns.

Having discussed these problems, we propose the minimal predictive temporal patterns framework for selecting predictive and nonspurious temporal patterns for classification. Definition 6.1 . A frequent temporal pattern P is a Minimal Predictive Temporal Pattern ( MPTP ) for class y if P predicts y significantly better than all of its subpatterns. The MPTP definition prefers simple patterns over more complex patterns (the Occam X  X  Razor principal), because pattern P is not an MPTP if its effect on the class distribution can be explained by a simpler pattern that covers a larger population.
In order to complete the definition, we define the MPTP statistical significance test and explain how to address the issue of multiple hypothesis testing. Assume we want to check whether temporal pattern P is an MPTP for class y . Suppose that P covers N instances in the entire database D and covers N y instances in D y (the instances from class y ). Let  X   X  best be the highest confidence achieved by any subrule of P  X  y .
Let us denote the true underlying probability of observing y in group P by  X  .We define the null hypothesis H 0 to be  X  =  X   X  best . That is, H 0 says that N y is generated from N according to the binomial distribution with probability  X   X  best . The alternative hypothesis H 1 says that  X &gt;  X   X  best (a one-sided statistical test). We compute the p-value of the MPTP significance test as follows. This p-value can be interpreted as the probability of observing N y or more instances of class y outofthe N instances covered by P if the true underlying probability is  X   X  best . If the p-value is smaller than a significance level  X  (e.g., p-value &lt; 0 . 01), then the null hypothesis H 0 is very unlikely. In this case, we reject H 0 in favor of H 1 , which says that P  X  y is significantly more predictive than all its subrules, hence P is an MPTP.
This statistical test can filter out many spurious patterns. Going back to Example 5.2, we do not expect spurious pattern P : K = N before PLT = VL to be an MPTP, because it does not predict HIT significantly better that the real pattern: PLT = VL . When testing the significance of multiple patterns in parallel, it is possible that some patterns will pass the significance test just by chance (false positives). This is a concern for all pattern mining techniques that rely on statistical tests.

In order to tackle this problem, the significance level should be adjusted by the number of tests performed during the mining. The simplest way is the Bonferroni correction [Shaffer 1995], which divides the significance level  X  by the number of tests performed. However, this approach is very conservative (with large type II error) when the number of tests is large, making it unsuitable for pattern mining. In this work, we adopt the FDR (false discovery rate) technique [Benjamini and Hochberg 1995], which directly controls the expected proportion of false discoveries in the result (type I error). FDR is a simple method for estimating the rejection region so that the false discovery significant. We apply FDR to post-process all potential MPTP (patterns satisfying the MPTP significance test) and select the ones that satisfy the FDR criteria. The algorithm in Section 4 describes how to mine all frequent temporal patterns for class y using D y . In this section, we explain how to mine minimal predictive temporal patterns for class y . Our algorithm is integrated with frequent pattern mining in order to directly mine the MPTP set, as opposed to mining all frequent patterns first and then selecting MPTP, as in the two-phase approach. To do this, the algorithm requires another input, D  X  y , which is the instances in the database D that do not belong to class y : D  X  y = D  X  D y .
 The process of testing whether temporal pattern P is an MPTP is not trivial, because the definition demands checking P against all its subpatterns. That is, for a k-pattern , we need to compare it with all of its 2 k  X  1 subpatterns!
In order to avoid this inefficiency, we associate every frequent pattern P with two values. (1) P . mcs (maximum confidence of subpatterns) is the maximum confidence of all (2) P . mc (maximum confidence) is the maximum confidence of P and all of its subpat-Note that P.mcs is what we need to perform the MPTP significance test for pattern P . However, we need a way to compute P . mcs without having to access all subpatterns. The idea is that we can re-express P . mcs for any k-pattern using the maximum confidence values of its ( k  X  1)-subpatterns .

This leads to a simple dynamic programming type of algorithm for computing these two values. Initially, for every frequent 1 -patterns P ,weset P . mcs to be the prior probability of class y in the data and compute P . mc using Equation (2). In the candidate generation phase, we compute mcs for a new candidate k-pattern using the mc values of its ( k  X  1) -subpatterns according to Equation (3) (Algorithm 1: line 8). Then, we compute the mc values for the frequent k-patterns in the counting phase and repeat the process for the next levels.

The algorithm for extracting the MPTP of size k from the frequent k-patterns is outlined in Algorithm 2. For every frequent pattern P , we compute P.mc (line 5). Then we add P to the MPTP set if it satisfies the MPTP significance test (lines 6 and 7). In this section, we illustrate how integrating MPTP selection with frequent temporal pattern mining helps with pruning the search space (i.e., speeding up the mining). We say that temporal pattern P is pruned if we do not explore any of its superpatterns. Frequent pattern mining relies only on the support information to prune infrequent patterns according to the Apriori property. That is, all patterns that are not frequent are pruned because their superpatterns are guaranteed not to be frequent.

In the following, we present two pruning techniques that can utilize the predictive-ness of patterns to further prune the search space. The first technique is lossless , while the second is lossy . 7.2.1. Lossless Pruning. This section describes a lossless pruning technique that can prune parts of the search space without missing any MPTP. The idea is to prune pattern P if we guarantee that none of P  X  X  superpatterns will be an MPTP. However, since the algorithm is applied in a level-wise fashion, we do not know the class distribution in the superpatterns of P . To overcome this difficulty, we define the optimal superpattern of P , denoted as P  X  , to be a hypothetical pattern that covers all and only the instances of generate any superpattern that predicts y better than P  X  . Now, we prune P if P  X  is not an MPTP with respect to P . mc (the highest confidence achieved by P and its subpatterns). This pruning is outlined in Algorithm 2: (lines 9 and 10). Note that this pruning is guaranteed to not miss any MPTP.
 7.2.2. Lossy Pruning. This section describes a lossy pruning technique that speeds up the mining at the risk of missing some MPTPs. We refer to the patterns mined with the lossy pruning as A-MPTP ( approximated MPTP ). The idea is to prune pattern P if it does not show any sign of being more predictive than its subpatterns. To do this, we simply perform the MPTP significance test, but at a higher significance level  X  2 than the significance level used in the original MPTP significance test:  X  2  X  [  X , 1]. If P does not satisfy the test with respect to  X  2 , we prune P . We call  X  2 the pruning significance level.

Note that  X  2 is a parameter that controls the trade-off between efficiency and com-pleteness. So if we set  X  2 = 1, we do not perform any lossy pruning. On the other end of the spectrum, if we set  X  2 =  X  , we prune every non-MPTP pattern, which leads to very aggressive pruning!
Example 7.1 . Assume that temporal pattern P covers 25 instances of class y and 15 instances that are not from class y and that the maximum confidence for P  X  X  subpat-terns is P . mcs = 0 . 65. If we apply the lossy pruning using pruning significance level  X   X  : Pr binom ( x  X  25; 40 , 0 . 65) = 0 . 69 &gt; 0 . 5. After we mine the MPTPs from each class label separately, we take the union of these patterns, denoted by , to define the classification features. To do this, we transform each EHR instance x i into a binary vector x i of size equal to | | , where x i , j corresponds to a specific MPTP P j and its value is 1 if P j occurs in x i ; and 0 otherwise. Once the data is transformed to this binary representation, we can apply standard machine learning algorithms (e.g., SVM, decision tree, na  X   X ve Bayes, or logistic regression) to learn the classification model.
 In this section, we test and present results of our temporal pattern mining approach on the problem of predicting patients who are at risk of developing heparin-induced thrombocytopenia (HIT) [Warkentin 2000]. HIT is a pro-thrombotic disorder induced by heparin exposure with subsequent thrombocytopenia (low platelets in the blood) and associated thrombosis (blood clot). It is a life-threatening condition if it is not detected and managed properly. Hence, it is extremely important to detect the onset of the condition. We use data acquired from a database that contains 4,281 electronic health records of postcardiac surgical patients [Hauskrecht et al. 2010]. From this database, we selected 220 instances of patients who were considered by physicians to be at risk of HIT and 220 instances of patients without the risk of HIT. The patients at risk of HIT were selected using information about the heparin platelet factor 4 antibody (HPF4) test orders. The HPF4 test is ordered for a patient when a physician suspects the patient is developing HIT and hence it is a good surrogate of the HIT-risk label. The HIT-risk instances include clinical information up to the time HFP4 was ordered. The negative ( no HIT-risk ) instances were selected randomly from the remaining patients. These instances include clinical information up to some randomly selected time.

For every instance, we consider the following five clinical variables: platelet counts (PLT), activated partial thromboplastin time (APTT), white blood cell counts (WBC), hemoglobin (Hgb), and heparin orders. PLT, APTT, WBC, and Hgb are numerical time series and we segment them using trend and value abstractions (Section 3.1). Heparin orders are already in an interval-based format that specifies the time period the patient was on heparin. We set the window size of temporal patterns to be the last five days of every patient record. In this section, we test the ability of our methods to represent and capture tempo-ral patterns important for predicting HIT. We compare our methods, MPTP ,andits approximate version, A-MPTP , to the following baselines. (1) Last values. The features are the most recent value of each clinical variable. For (2) Last abs. The features are the most recent trend and value abstractions of each clin-(3) TP all. The features are all frequent temporal patterns (without applying pattern (4) TP IG. The features are the top 100 frequent temporal patterns according to infor-(5) TP chi. The features are the frequent temporal patterns that are statistically sig-
The first two methods (1 X 2) are atemporal and do not rely on any temporal ordering when constructing their features. On the other hand, methods 3 X 5 use temporal pat-terns that are built using temporal abstractions and temporal logic. However, unlike MPTP and A-MPTP , they select the patterns using standard feature selection methods without considering the nested structure of the patterns.

We set the significance level  X  = 0 . 01 for MPTP and A-MPTP , and we set the pruning significance level  X  2 = 0 . 5for A-MPTP (see Section 7.2.2). We set the local minimum supports to 10% of the number of instances in the class for all compared methods.
We judged the quality of the different feature representations in terms of their induced classification performance. More specifically, we use the features extracted by each method to build an SVM classifier and evaluate its performance using the classification accuracy and the area under the ROC curve (AUC).

In addition, we compared our methods to MBST (model-based search tree) [Fan et al. 2008], a recently proposed method that combines frequent pattern mining and decision tree induction. MBST builds the decision tree as follows: for each node (1) invoke a frequent pattern mining algorithm, (2) select the most discriminative pattern according to IG, (3) divide the data into two subsets X  X ne containing the pattern and the other not X  X nd (4) repeat the process recursively on the two subsets. We extend this method to temporal pattern mining and refer to it in the results as to TP MBST .Wesetthe invocation minimum support to be 10%, that is, at each node of the tree, the algorithm mines temporal patterns that appear in more than 10% of the instances in that node.
Table I shows the classification accuracy and the AUC for each of the methods. All classification results are reported using averages obtained via 10-folds cross validation.
The results show that temporal features generated using temporal abstractions and temporal logic are beneficial for predicting HIT, since they outperformed methods based on atemporal features. The results also show that the MPTP and A-MPTP are the best performing methods. Note that although the temporal patterns generated by TP all , TP IG ,and TP chi subsume or overlap MPTP and A-MPTP patterns, they also in-clude many irrelevant and spurious patterns that negatively effect their classification performance.

Figure 6 shows the classification accuracy of the temporal pattern mining methods under different minimum support values. We did not include TP MBST because it is very inefficient when the minimum support is low. 5 We can see that MPTP and A-MPTP consistently outperform the other methods under different settings of minimum support. In order for a pattern mining method to be useful for knowledge discovery, the method should provide the user with a small set of understandable patterns that are able to capture the important information in the data.

Figure 7 compares the number of temporal patterns (on a logarithmic scale) that are extracted by TP all , TP chi , MPTP ,and A-MPTP under different minimum support thresholds. Notice that the number of frequent temporal patterns ( TP all ) exponen-tially blows up when we decrease the minimum support. Also notice that TP chi does not help much in reducing the number of patterns, even though it applies the FDR correction. For example, when the minimum support is 5%, TP chi outputs 1,842 tem-poral patterns that are statistically significant! This clearly illustrates the spurious patterns problem that we discussed in Section 5.1.

On the other hand, the number of MPTPs is much lower than the number of temporal patterns extracted by the other methods, and it is less sensitive to the minimum support. For example, when the minimum support is 5%, the number of MPTPs is about two orders of magnitude less than the total number of frequent patterns.
Finally, notice that the number of A-MPTPs may, in some cases, be higher than the number of MPTPs. The reason for this is that A-MPTP performs less hypothesis testing during the mining (due to its aggressive pruning); hence FDR is less aggressive with A-MPTPs than with MPTPs.

Table II shows the top five MPTPs according to the p-value of the binomial statistical test, measuring the improvement in the predictive power of the pattern with respect to the HIT prior in the dataset. Rules R 1 , R 2 ,and R 3 describe the main patterns used to detect HIT and are in agreement with the current HIT detection guidelines [Warkentin 2000]. Rule R 4 relates the risk of HIT with high values of APTT (activated partial thromboplastin time). This relation is not obvious from the HIT detection guidelines. However, it has been recently discussed in the literature [Pendelton et al. 2006]. Finally, R 5 suggests that the risk of HIT correlates with having high WBC values. We currently do not know if it is a spurious or an important pattern. Hence this rule requires further investigation. In this section, we study the effect of the different techniques we proposed for improving the efficiency of temporal pattern mining. We compare the running time of the following methods. (1) TP Apriori. Mine the frequent temporal patterns using the standard Apriori (2) TP id-lists. Mine the frequent temporal patterns using the id-list format to speed (3) MPTP. Mine the MPTP set using the id-list format and apply the lossless pruning (4) A-MPTP. Mine the approximated MPTP set using the id-list format and apply both To make the comparison fair, all methods apply the techniques we propose in Section 4.2 to avoid generating incoherent candidates. Note that if we do not remove incoherent candidates, the execution time for all methods greatly increases. The experiments were conducted on a Dell Precision T7500 machine with an Intel Xeon 3GHz CPU and 16GB of RAM. All algorithms are implemented in MATLAB.

Figure 8 shows the execution times (on a logarithmic scale) of the preceding methods using different minimum support thresholds. We can see that using the id-list format greatly improves the efficiency of frequent temporal pattern mining as compared to the standard Apriori algorithm. For example, when the minimum support is 10%, TP id-lists is more than six times faster than TP Apriori .

Notice that the execution time of frequent temporal pattern mining (both TP Apriori and TP id-lists ) blows up when the minimum support is low. On the other hand, MPTP controls the mining complexity, and the execution time increases much slower than frequent pattern mining when the minimum support decreases. Finally, notice that A-MPTP is the most efficient method. For example, when the minimum support is 5%, A-MPTP is around four times faster than MPTP , twenty times faster than TP id-lists , and sixty times faster than TP Apriori . The results reported so far show the performance of several temporal pattern mining methods when the window size is fixed to be the last five days of the patient records. Here, we examine the effect of changing the window size on the methods X  performance. In Figure 9, we vary the window size from three days to nine days and show the classification accuracy (left), the number of patterns (center), and the execution time (right) of the compared methods.

Note that when we increase the window size beyond five days, the classification accuracy for most methods slightly decreases. 6 This shows that for our task, temporal patterns that are recent (close to the decision point) are more predictive than the ones that are distant. Also, note that increasing the window size increases the number of patterns in the result and also increases the execution time. The reason being that the search space of frequent temporal patterns becomes larger. Finally, note that our methods ( MPTP and A-MPTP ) maintain their advantages over the competing methods for the different settings of the window size. The integration of classification and pattern mining has recently attracted a lot of interest in data mining research and has been successfully applied to static data [Cheng et al. 2007; Batal and Hauskrecht 2010], graph data [Deshpande et al. 2005], and sequence data [Tseng and Lee 2005; Exarchos et al. 2008; Ifrim and Wiuf 2011]. This work proposes a pattern-based classification framework for complex multivariate time series data, such as the one encountered in electronic health record systems.
Our work relies on temporal abstractions [Shahar 1997] as a preprocessing step to convert numeric time series into time interval state sequences. The problem of mining temporal patterns from time interval data is a relatively young research field. Most of the techniques are extensions of sequential pattern mining methods [Agrawal and Srikant 1995; Zaki 2001; Pei et al. 2001; Yan et al. 2003; yen Lin and yin Lee 2005] for handling time interval data. 7
Villafane et al. [2000] is one of the earliest works in this area and proposed a method for discovering only containment relationships from interval time series. [shan Kam and chee-Fu 2000] were the first to propose using Allen X  X  relations [Allen 1984] for defining temporal patterns. Their patterns follow a nested representation which only allows concatenation of temporal relations on the right-hand side of the pattern. How-ever, this representation is ambiguous (the same situation in the data can be described using several patterns).

Hoppner [2003] was the first to propose a non-ambiguous representation by ex-plicitly defining all k ( k  X  1) / 2 pairwise relations for a temporal k-pattern . We adopt Hoppner X  X  representation in our work. Papapetrou et al. [2005] used the same pattern format as Hoppner [2003] and proposed the Hybrid-DFS algorithm which uses a tree-based enumeration algorithm like the one introduced in Bayardo [1998]. Winarko and Roddick [2007] also used the same pattern format as Hoppner [2003] and proposed the ARMADA algorithm, which extends a sequential pattern mining algorithm called MEMISP [yen Lin and yin Lee 2005] to mine time interval temporal patterns.
Moerchen [2006] proposed the TSKR representation as an alternative to Allen X  X  relations and used a modification of the CloSpan algorithm [Yan et al. 2003] to mine such patterns. Wu and Chen [2007] proposed converting interval state sequences into sequences of interval boundaries (the start and end of each state) and mining sequential patterns from those sequences. Their algorithm is a modification of PrefixSpan [Pei et al. 2001] that adds constraints to ensure that the mined patterns correspond to valid interval patterns. In Sacchi et al. [2007], the user is required to define beforehand a set of complex patterns of interest. The system then mines temporal association rules that combine these user-defined patterns using the precedes relation that the paper introduced.

All related work on mining time interval temporal patterns [Villafane et al. 2000; shan Kam and chee-Fu 2000; Hoppner 2003; Papapetrou et al. 2005; Winarko and Roddick 2007; Moerchen 2006; Wu and Chen 2007; Sacchi et al. 2007; Moskovitch and Shahar 2009] have been applied in an unsupervised setting to mine temporal association rules. On the other hand, our work focuses on applying temporal pattern mining in the supervised setting in order to mine predictive and nonspurious temporal patterns and use them as features for classification. Modern hospitals and healthcare institutes collect huge amounts of data about their pa-tients, including laboratory test results, medication orders, diagnoses, and so on. Those who deal with such data know that there is a widening gap between data collection and data utilization. Thus, it is very important to develop data mining techniques capable of automatically extracting useful knowledge to support clinical decision making in various diagnostic and patient-management tasks.

This work proposes a pattern mining approach for learning classification models from multivariate temporal data, such as the data encountered in electronic health record systems. Our approach relies on temporal abstractions and temporal pattern mining to construct the classification features. We also propose the minimal predictive temporal patterns framework and present an efficient mining algorithm. We believe the proposed method is a promising candidate for many applications in the medical field, such as patient monitoring and clinical decision support.
