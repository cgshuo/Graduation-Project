 Most spontaneous speech contains disfluencies such as partial words, filled pauses (e.g.,  X  X h X ,  X  X m X ,  X  X uh X ), explicit editing terms (e.g.,  X  X  mean X ), par-enthetical asides and repairs. Of these, repairs pose particularly difficult problems for parsing and related Natural Language Processing (NLP) tasks. This paper presents a model of disfluency detec-tion based on the noisy channel framework, which specifically targets the repair disfluencies. By com-bining language models and using an appropriate loss function in a log-linear reranker we are able to achieve f-scores which are higher than previously re-ported.

Often in natural language processing algorithms, more data is more important than better algorithms (Brill and Banko, 2001). It is this insight that drives the first part of the work described in this paper. This paper investigates how we can use language models trained on large corpora to increase repair detection accuracy performance.
 There are three main innovations in this paper. First, we investigate the use of a variety of language models trained from text or speech corpora of vari-ous genres and sizes. The largest available language models are based on written text: we investigate the effect of written text language models as opposed to language models based on speech transcripts. Sec-ond, we develop a new set of reranker features ex-plicitly designed to capture important properties of speech repairs. Many of these features are lexically grounded and provide a large performance increase. Third, we utilise a loss function, approximate ex-pected f-score, that explicitly targets the asymmetric evaluation metrics used in the disfluency detection task. We explain how to optimise this loss func-tion, and show that this leads to a marked improve-ment in disfluency detection. This is consistent with Jansche (2005) and Smith and Eisner (2006), who observed similar improvements when using approx-imate f-score loss for other problems. Similarly we introduce a loss function based on the edit-f-score in our domain. 703
Together, these three improvements are enough to boost detection performance to a higher f-score than previously reported in literature. Zhang et al. (2006) investigate the use of  X  X ltra large feature spaces X  as an aid for disfluency detection. Using over 19 mil-lion features, they report a final f-score in this task of 0 . 820 . Operating on the same body of text (Switch-board), our work leads to an f-score of 0 . 838 , this is a 9% relative improvement in residual f-score.
The remainder of this paper is structured as fol-lows. First in Section 2 we describe related work. Then in Section 3 we present some background on disfluencies and their structure. Section 4 describes appropriate evaluation techniques. In Section 5 we describe the noisy channel model we are using. The next three sections describe the new additions: Sec-tion 6 describe the corpora used for language mod-els, Section 7 describes features used in the log-linear model employed by the reranker and Section 8 describes appropriate loss functions which are criti-cal for our approach. We evaluate the new model in Section 9. Section 10 draws up a conclusion. A number of different techniques have been pro-posed for automatic disfluency detection. Schuler et al. (2010) propose a Hierarchical Hidden Markov Model approach; this is a statistical approach which builds up a syntactic analysis of the sentence and marks those subtrees which it considers to be made up of disfluent material. Although they are inter-ested not only in disfluency but also a syntactic anal-ysis of the utterance, including the disfluencies be-ing analysed, their model X  X  final f-score for disflu-ency detection is lower than that of other models.
Snover et al. (2004) investigate the use of purely lexical features combined with part-of-speech tags to detect disfluencies. This approach is compared to approaches which use primarily prosodic cues, and appears to perform equally well. However, the au-thors note that this model finds it difficult to identify disfluencies which by themselves are very fluent. As we will see later, the individual components of a dis-fluency do not have to be disfluent by themselves. This can occur when a speaker edits her speech for meaning-related reasons, rather than errors that arise from performance. The edit repairs which are the fo-cus of our work typically have this characteristic.
Noisy channel models have done well on the dis-fluency detection task in the past; the work of John-son and Charniak (2004) first explores such an ap-proach. Johnson et al. (2004) adds some hand-written rules to the noisy channel model and use a maximum entropy approach, providing results com-parable to Zhang et al. (2006), which are state-of-the art results.

Kahn et al. (2005) investigated the role of prosodic cues in disfluency detection, although the main focus of their work was accurately recovering and parsing a fluent version of the sentence. They report a 0 . 782 f-score for disfluency detection. We follow the definitions of Shriberg (1994) regard-ing speech disfluencies. She identifies and defines three distinct parts of a speech disfluency, referred to as the reparandum , the interregnum and the re-pair . Consider the following utterance: The reparandum to Boston is the part of the utterance that is  X  X dited out X ; the interregnum uh, I mean is a filled pause, which need not always be present; and the repair to Denver replaces the reparandum.
Shriberg and Stolcke (1998) studied the location and distribution of repairs in the Switchboard cor-pus (Godfrey and Holliman, 1997), the primary cor-pus for speech disfluency research, but did not pro-pose an actual model of repairs. They found that the overall distribution of speech disfluencies in a large corpus can be fit well by a model that uses only in-formation on a very local level. Our model, as ex-plained in section 5, follows from this observation.
As our domain of interest we use the Switchboard corpus. This is a large corpus consisting of tran-scribed telephone conversations between two part-ners. In the Treebank III (Marcus et al., 1999) cor-pus there is annotation available for the Switchboard corpus, which annotates which parts of utterances are in a reparandum, interregnum or repair. 704 Disfluency detection systems like the one described here identify a subset of the word tokens in each transcribed utterance as  X  X dited X  or disfluent. Per-haps the simplest way to evaluate such systems is to calculate the accuracy of labelling they produce, i.e., the fraction of words that are correctly labelled (i.e., either  X  X dited X  or  X  X ot edited X ). However, as Charniak and Johnson (2001) observe, because only 5.9% of words in the Switchboard corpus are  X  X dited X , the trivial baseline classifier which assigns all words the  X  X ot edited X  label achieves a labelling accuracy of 94.1%.

Because the labelling accuracy of the trivial base-line classifier is so high, it is standard to use a dif-ferent evaluation metric that focuses more on the de-tection of  X  X dited X  words. We follow Charniak and Johnson (2001) and report the f-score of our disflu-ency detection system. The f-score f is: where g is the number of  X  X dited X  words in the gold test corpus, e is the number of  X  X dited X  words pro-posed by the system on that corpus, and c is the num-ber of the  X  X dited X  words proposed by the system that are in fact correct. A perfect classifier which correctly labels every word achieves an f-score of 1, while the trivial baseline classifiers which label every word as  X  X dited X  or  X  X ot edited X  respectively achieve a very low f-score.

Informally, the f-score metric focuses more on the  X  X dited X  words than it does on the  X  X ot edited X  words. As we will see in section 8, this has implica-tions for the choice of loss function used to train the classifier. Following Johnson and Charniak (2004), we use a noisy channel model to propose a 25-best list of possible speech disfluency analyses. The choice of this model is driven by the observation that the re-pairs frequently seem to be a  X  X ough copy X  of the reparandum, often incorporating the same or very similar words in roughly the same word order. That is, they seem to involve  X  X rossed X  dependencies be-tween the reparandum and the repair. Example (3) shows the crossing dependencies. As this exam-ple also shows, the repair often contains many of the same words that appear in the reparandum. In fact, in our Switchboard training corpus we found that 62reparandum also appeared in the associated repair, 5.1 Informal Description Given an observed sentence Y we wish to find the most likely source sentence  X  X , where In our model the unobserved X is a substring of the complete utterance Y .

Noisy-channel models are used in a similar way in statistical speech recognition and machine trans-lation. The language model assigns a probability P ( X ) to the string X , which is a substring of the observed utterance Y . The channel model P ( Y | X ) generates the utterance Y , which is a potentially dis-fluent version of the source sentence X . A repair can potentially begin before any word of X . When a repair has begun, the channel model incrementally processes the succeeding words from the start of the repair. Before each succeeding word either the re-pair can end or else a sequence of words can be in-serted in the reparandum. At the end of each re-pair, a (possibly null) interregnum is appended to the reparandum.

We will look at these two components in the next two Sections in more detail. 5.2 Language Model Informally, the task of language model component of the noisy channel model is to assess fluency of the sentence with disfluency removed. Ideally we would like to have a model which assigns a very high probability to disfluency-free utterances and a lower probability to utterances still containing dis-fluencies. For computational complexity reasons, as described in the next section, inside the noisy chan-nel model we use a bigram language model. This 705 bigram language model is trained on the fluent ver-sion of the Switchboard corpus (training section).
We realise that a bigram model might not be able to capture more complex language behaviour. This motivates our investigation of a range of additional language models, which are used to define features used in the log-linear reranker as described below. 5.3 Channel Model The intuition motivating the channel model design is that the words inserted into the reparandum are very closely related to those in the repair. Indeed, in our training data we find that 62% of the words in the reparandum are exact copies of words in the repair; this identity is strong evidence of a repair. The channel model is designed so that exact copy reparandum words will have high probability.
Because these repair structures can involve an un-bounded number of crossed dependencies, they can-not be described by a context-free or finite-state grammar. This motivates the use of a more expres-sive formalism to describe these repair structures.
We assume that X is a substring of Y , i.e., that the source sentence can be obtained by deleting words from Y , so for a fixed observed utterance Y there are only a finite number of possible source sen-tences. However, the number of possible source sen-tences, X , grows exponentially with the length of Y , so exhaustive search is infeasible. Tree Adjoining Grammars (TAG) provide a systematic way of for-malising the channel model, and their polynomial-time dynamic programming parsing algorithms can be used to search for likely repairs, at least when used with simple language models like a bigram language model. In this paper we first identify the 25 most likely analyses of each sentence using the TAG channel model together with a bigram lan-guage model.

Further details of the noisy channel model can be found in Johnson and Charniak (2004). 5.4 Reranker To improve performance over the standard noisy channel model we use a reranker, as previously sug-gest by Johnson and Charniak (2004). We rerank a 25-best list of analyses. This choice is motivated by an oracle experiment we performed, probing for the location of the best analysis in a 100-best list. This experiment shows that in 99 . 5% of the cases the best analysis is located within the first 25, and indicates that an f-score of 0 . 958 should be achievable as the upper bound on a model using the first 25 best anal-yses. We therefore use the top 25 analyses from the noisy channel model in the remainder of this paper and use a reranker to choose the most suitable can-didate among these. We would like to use additional data to model the fluent part of spoken language. However, the Switchboard corpus is one of the largest widely-available disfluency-annotated speech corpora. It is reasonable to believe that for effective disfluency de-tection Switchboard is not large enough and more text can provide better analyses. Schwartz et al. (1994), although not focusing on disfluency detec-tion, show that using written language data for mod-elling spoken language can improve performance. We turn to three other bodies of text and investi-gate the use of these corpora for our task, disfluency detection. We will describe these corpora in detail here.

The predictions made by several language models are likely to be strongly correlated, even if the lan-guage models are trained on different corpora. This motivates the choice for log-linear learners, which are built to handle features which are not necessar-ily independent. We incorporate information from the external language models by defining a reranker feature for each external language model. The value of this feature is the log probability assigned by the language model to the candidate underlying fluent substring X
For each of our corpora (including Switchboard) we built a 4-gram language model with Kneser-Ney smoothing (Kneser and Ney, 1995). For each analy-sis we calculate the probability under that language model for the candidate underlying fluent substring X . We use this log probability as a feature in the reranker. We use the SRILM toolkit (Stolcke, 2002) both for estimating the model from the training cor-pus as well as for computing the probabilities of the underlying fluent sentences X of the different anal-ysis.

As previously described, Switchboard is our pri-706 mary corpus for our model. The language model part of the noisy channel model already uses a bi-gram language model based on Switchboard, but in the reranker we would like to also use 4-grams for reranking. Directly using Switchboard to build a 4-gram language model is slightly problematic. When we use the training data of Switchboard both for lan-guage fluency prediction and the same training data also for the loss function, the reranker will overesti-mate the weight associated with the feature derived from the Switchboard language model, since the flu-ent sentence itself is part of the language model training data. We solve this by dividing the Switch-board training data into 20 folds. For each fold we use the 19 other folds to construct a language model and then score the utterance in this fold with that language model.

The largest widely-available corpus for language modelling is the Web 1T 5-gram corpus (Brants and Franz, 2006). This data set, collected by Google Inc., contains English word n -grams and their ob-served frequency counts. Frequency counts are pro-duced from this billion-token corpus of web text. an ongoing debate in the scientific community of the use of this corpus for serious language modelling.
The Gigaword Corpus (Graff and Cieri, 2003) is a large body of newswire text. The corpus con-tains 1 . 6  X  10 9 tokens, however fluent newswire text is not necessarily of the same domain as disfluency removed speech.
 The Fisher corpora Part I (David et al., 2004) and Part II (David et al., 2005) are large bodies of tran-scribed text. Unlike Switchboard there is no disflu-ency annotation available for Fisher. Together the two Fisher corpora consist of 2 . 2  X  10 7 tokens. The log-linear reranker, which rescores the 25-best lists produced by the noisy-channel model, can also include additional features besides the noisy-channel log probabilities. As we show below, these additional features can make a substantial improve-ment to disfluency detection performance. Our reranker incorporates two kinds of features. The first are log-probabilities of various scores computed by the noisy-channel model and the external language models. We only include features which occur at least 5 times in our training data.

The noisy channel and language model features consist of: 1. LMP: 4 features indicating the probabilities of 2. NCLogP: The Log Probability of the entire 3. LogFom: This feature is the log of the  X  X ig-4. NCTransOdd: We include as a feature parts of
The boolean indicator features consist of the fol-lowing 3 groups of features operating on words and their edit status; the latter indicated by one of three possible flags: when the word is not part of a dis-fluency or E when it is part of the reparandum or I when it is part of the interregnum. 1. CopyFlags X Y: When there is an exact copy 2. WordsFlags L n R: This feature records the 3. SentenceEdgeFlags B L: This feature indi-
We give the following analysis as an example: The language model features are the probability calculated over the fluent part. NCLogP, Log-Fom and NCTransOdd are present with their asso-ciated value. The following binary flags are present: CopyFlags 1 0 (E ) WordsFlags:0:1:0 (but E) WordsFlags:0:1:0 (but ) WordsFlags:1:1:0 (E but ) WordsFlags:1:1:0 ( that ) WordsFlags:0:2:0 (but E but ) etc. 2 SentenceEdgeFlags:0:1 (E) SentenceEdgeFlags:0:2 (E ) SentenceEdgeFlags:0:3 (E )
These three kinds of boolean indicator features to-gether constitute the extended feature set . We formalise the reranker training procedure as fol-lows. We are given a training corpus T containing information about n possibly disfluent sentences. For the i th sentence T specifies the sequence of words x bellings produced by the noisy channel model, as well as the correct  X  X dited X  labelling y  X 
We are also given a vector f = ( f of feature functions , where each f sequence x and an  X  X dit X  labelling y for x to a real value f we write f ( x, y ) = ( f interpret a vector w = ( w weights as defining a conditional probability distri-bution over a candidate set Y of  X  X dited X  labellings for a string x as follows:
We estimate the feature weights w from the train-ing data T by finding a feature weight vector b w that optimises a regularised objective function: Here  X  is the regulariser weight and L function . We investigate two different loss functions in this paper. LogLoss is the negative log conditional likelihood of the training data: Optimising LogLoss finds the b w that define (regu-larised) conditional Maximum Entropy models.
It turns out that optimising LogLoss yields sub-optimal weight vectors b w here. LogLoss is a sym-metric loss function (i.e., each mistake is equally weighted), while our f-score evaluation metric weights  X  X dited X  labels more highly, as explained in section 4. Because our data is so skewed (i.e.,  X  X dited X  words are comparatively infrequent), we can improve performance by using an asymmetric loss function.

Inspired by our evaluation metric, we devised an approximate expected f-score loss function FLoss . This approximation assumes that the expectations approximately distribute over the division: see Jan-sche (2005) and Smith and Eisner (2006) for other approximations to expected f-score and methods for optimising them. We experimented with other asym-metric loss functions (e.g., the expected error rate) and found that they gave very similar results.
An advantage of FLoss is that it and its deriva-tives with respect to w (which are required for numerical optimisation) are easy to calculate ex-actly. For example, the expected number of correct  X  X dited X  words is: and c in y given the gold labelling y  X  . The derivatives of FLoss are:  X  FLoss T where:  X  E  X  E[ e ] / X  X  j is given by a similar formula. We follow Charniak and Johnson (2001) and split the corpus into main training data, held-out train-ing data and test data as follows: main training con-sisted of all sw [ 23 ]  X  .dps files, held-out training con-sisted of all sw4 [ 5-9 ]  X  .dps files and test consisted of all sw4 [ 0-1 ]  X  .dps files. However, we follow (John-son and Charniak, 2004) in deleting all partial words and punctuation from the training and test data (they argued that this is more realistic in a speech process-ing application).

Table 1 shows the results for the different models on held-out data. To avoid over-fitting on the test data, we present the f-scores over held-out training data instead of test data. We used the held-out data to select the best-performing set of reranker features, which consisted of features for all of the language models plus the extended (i.e., indicator) features, and used this model to analyse the test data. The f-score of this model on test data was 0.838. In this table, the set of Extended Features is defined as all the boolean features as described in Section 7.
We first observe that adding different external lan-guage models does increase the final score. The difference between the external language models is relatively small, although the differences in choice are several orders of magnitude. Despite the pu-tative noise in the corpus, a language model built on Google X  X  Web1T data seems to perform very well. Only the model where Switchboard 4-grams are used scores slightly lower, we explain this be-cause the internal bigram model of the noisy chan-nel model is already trained on Switchboard and so this model adds less new information to the reranker than the other models do.

Including additional features to describe the prob-lem space is very productive. Indeed the best per-forming model is the model which has all extended features and all language model features. The dif-ferences among the different language models when extended features are present are relatively small. We assume that much of the information expressed in the language models overlaps with the lexical fea-tures.

We find that using a loss function related to our evaluation metric, rather than optimising LogLoss , consistently improves edit-word f-score. The stan-dard LogLoss function, which estimates the  X  X ax-imum entropy X  model, consistently performs worse than the loss function minimising expected errors.
The best performing model (Base + Ext. Feat. + All LM, using expected f-score loss) scores an f-score of 0.838 on test data . The results as indicated by the f-score outperform state-of-the-art models re-709 0 . 776 0 . 791 0 . 771 0 . 797 0 . 777 0 . 797 0 . 781 0 . 798 0 . 827 0 . 828 0 . 841 0 . 856 0 . 843 0 . 852 0 . 843 0 . 850 0 . 841 0.857 ported in literature operating on identical data, even though we use vastly less features than other do. We have described a disfluency detection algorithm which we believe improves upon current state-of-the-art competitors. This model is based on a noisy channel model which scores putative analyses with a language model; its channel model is inspired by the observation that reparandum and repair are of-ten very similar. As Johnson and Charniak (2004) noted, although this model performs well, a log-linear reranker can be used to increase performance.
We built language models from a variety of speech and non-speech corpora, and examine the ef-fect they have on disfluency detection. We use lan-guage models derived from different larger corpora effectively in a maximum reranker setting. We show that the actual choice for a language model seems to be less relevant and newswire text can be used equally well for modelling fluent speech.

We describe different features to improve disflu-ency detection even further. Especially these fea-tures seem to boost performance significantly.
Finally we investigate the effect of different loss functions. We observe that using a loss function di-rectly optimising our interest yields a performance increase which is at least at large as the effect of us-ing very large language models.

We obtained an f-score which outperforms other models reported in literature operating on identical data, even though we use vastly fewer features than others do.
 This work was supported was supported under Aus-tralian Research Council X  X  Discovery Projects fund-ing scheme (project number DP110102593) and by the Australian Research Council as part of the Thinking Head Project the Thinking Head Project, ARC/NHMRC Special Research Initiative Grant # TS0669874. We thank the anonymous reviewers for their helpful comments.
 tium , Philadelphia. 710
