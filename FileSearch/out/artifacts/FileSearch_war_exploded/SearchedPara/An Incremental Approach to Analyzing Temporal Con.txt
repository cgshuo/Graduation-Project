 Recently, the fast-changing business environment requires workflow management systems (WfMSs) to have the ability to incrementally analyze workflow process mod-processes [1-2]. To assure the correctness of executing workflow processes, the anal-verification of structural errors after changes are made has been recognized by workflow communities for a long time and different approaches have been developed [1-4]. In the literature, dynamic verification of temporal correctness after changes has not been fully investigated. The existing methods [5-9] can only answer whether there are temporal violations but they suffer from the following weaknesses: (1) They assume that there is only one single workflow process and there are no re-source dependencies. However, multiple workflow processes may execute concur-rently under resource dependencies in a workflow management system in practice. (2) The changes are limited to simple editing operations on activities. However, it workflow process is deleted or modified. None of them can deal with such cases. (3) They are less efficient because they n eed to repeatedly investigate and calculate all of the processes after any change are made. In case of large-scale process models, they analyze temporal constraints inefficiently and cannot respond to users quickly. 
In this paper, we present an incremental approach based on the sprouting graphs [9, change regions before the change and the new change regions after the change are generated by comparing the structures of the old and new TWF-nets. Here, change regions are the parts of the TWF-nets containing all the transitions directly or indirect-tained efficiently with no need to calculate the whole new TWF-nets. It only needs to examine the change regions of TWF-nets and can check temporal violations by ana-lyzing sprouting graph. Finally, temporal violations are checked based on the updated sprouting graph and the paths with violation are reported to designers. 
This paper and the work in [9] are both based on the formalism foundation -issues. The work in [9] focuses on dynamic checking temporal violations at run-time paper aims to deal with incremental analysis of temporal violations at build-time. 
Compared with the existing methods [1-9], the main contributions of this paper are summarized as follows: (2) We adopt the change regions of TWF-nets to deal with the complex situations of 2.1 TWF-Nets In this paper, Petri net [2, 4, 9] is used to formalize workflow processes. Definition 1. (WF-net): A PN is called a workflow net (WF-net) if and only if: 1) PN has two special places:  X  and  X  . Place  X  is a source and  X   X  =  X  ;  X  is a sink and where: 1) { P , T , F } is a WF-net; which is used to represent the minimum firing time and the maximum firing time, respectively. In the paper, TWF-net is based on the weak semantics of time PN, in which the firing of transitions can be freely chosen by decisions local to them, and independently from time and the actual firing time of t , respectively. We have s + l  X  ) ( t  X   X  s + u . WfMSs and there are resource dependencies among them. We assume that the FCFS activity is enabled first. We use a resource place p r to denote the shared resource and initial marking. An example of TWF-net is shown in Fig.1, whose description is presented in 2.2 Temporal Constraints Temporal constraints, e.g. assigned deadlines , usually are set explicitly by the process poral constraints mainly include [6-9]: upper bound, lower bound and fixed-time. 
For the sake of simplification, we use relative temporal constraints as the canonical starts. fied and has the possibility of being violated. 2.3 Sprouting Graphs of TWF-Nets Definition 3. (Sprouting graph) [9,10]: A sprouting graph of a TWF-net W is defined as pair (Path_set, Time_set). Path_set is a set of paths. Time_set is a set of time inter-vals and each time interval in Time_set represents the time that the corresponding path in Path_set spends. If the i th path in the set of paths is  X  , then the i th time in-terval of the set of time intervals is  X  as well. is the time interval of t . In a sprouting graph, an arc and its input/output nodes correspond to a transition and its input/output places. The set of time intervals of its input node is the possible ena-nodes include the paths of instances executing before and after its corresponding tran-sition. 
Sprouting graph not only has a more compact representation than a traditional So that we can check the temporal violations of workflow processes and find out the violation paths. Then, the designers can try to correct the execution of the activities in the path, e.g., to shorten the execution time of activities to solve violations [9]. 
Note that if TWF-net includes a loop structure, we transform it to a sequence of transition by approximating the number of loops in building sprouting graph. 
For example, these two processes are specified as the Fig. 1. Based on [9], we con-struct the sprouting graph as shown in Fig. 2. The time and path sets of its nodes are shown in Table 1. Based on the sprouting graphs, we can check temporal constraints on TWF-nets. time set of the output nodes of the arc corresponding to t j is TFS j , respectively. we check if Y is before X where X = s , Y =[ a -d, b -c ]. pairs, then it is completely violated . Otherwise, it is partly satisfied and has the possi-bility of being violated. Recently, the revolution of business always causes the dynamic changes of workflow processes. When workflows are more and more complex, it is necessary to develop ability is incremental analysis. discussed in [9]. However, in reality a large scale workflow may contain hundreds or thousands of data-intensive and computation-intensive activities or sub-processes. Unfortunately, the construction of sprouting graphs of TWF-nets suffers from expo-nential complexity. Hence, the checking work is inefficient in terms of time and route nets of transaction instances in the pr ocesses, especially when the TWF-nets are changed frequently at build-time. 
Based on the above discussion, the formal statement of problems we focus on is de-scribed as follows: Given a TWF-net W which contains multiple processes { W 1 , W 2 ,..., W belong to different processes in W . When some changes of W are made in an incremen-tal way, how can we efficiently maintain the sprouting graphs of TWF-nets without analyzing the whole TWF-nets and check the potential temporal violations? Given a specific change on a TWF-net, we can locate the regions of the old and new TWF-nets containing all the transitions and places affected by the changes directly or indirectly [2].
 Definition 4. (New and old change regions): Assume the old TWF-net before the F T Algorithm 1: Construct Change Regions Input: The old and new TWF-nets TWF 1 and TWF 2 Output: The new change and old change regions NS  X  NT . Step 3: For every N k repeat the following sub-steps: N N  X  N parts { TWF 2 -c TWF obtained by deleting the uninfluenced parts from TWF 1 . 
The key of Algorithm 1 is to get the different parts between the old and new TWF-nets by comparing them. Then, we locate the temporal source and sink places. The extension is repeated until no more adjacent nodes are added. During the extension, if two newly generated components share some common nodes, then they should be complexity of the Algorithm 1 is O( n 1 n 2 ). The procedure of maintaining sprouting graphs after changes is presented in Algo-rithm 2. Algorithm 2: Maintaining Sprouting Graph Input: the old sprouting graph OSG Output: the updated sprouting graph USG the first one denoted as Px , and delete it from the set. If the set is null, the Algorithm ends. Step 4: If Px has no any resource dependencies with another processes, go to Step 3. go to Step 5. update the nodes affected in OSG , go to Step 3. Step 6: Return the updated sprouting graph denoted as USG. Assume that there are n transitions and m places in change regions of TWF 2 , the time complexity of the Algorithm 2 is O( nm 2 ). reuse the checking procedure in our earlier wo rk [9]. If there is any temporal valida-tion, we return the paths information in the sprouting graphs to guide the designers to modify them. 6.1 Case Specification The production of a cell phone is mainly composed of two processes, i.e., production of electronic main board and production of peripheral parts. The first process is com-posed of requirement analysis to final production. The second one is composed of marketing to final production. The two processes execute concurrently. And there are two activities in each process which share a human resource (head engineer). lowing temporal constraints are specified. units after writing a technical document begins. (2) D R ( t 23 , t 19 )  X  9: Manufacturing of electronic main board ends no more than 9 time units after writing a technical document of peripheral parts begins. 
Based on [9], we construct the sprouting graph as shown in Fig.2 and Table 1. Note that there are no any temporal violations at the current state for the appropriate design of the activities of the logic and execution time. 6.2 Analysis in the Incremental Way After some time, in order to quicken the speed to release products into the market, the In an incremental way the designers may try some possible changes of models to only are changed one time, and two parts of them are made as shown in Fig.3. 
Firstly, we obtain two change regions 1 and 2 in the old TWF-net, and two corres-ponding change regions 1 X  and 2 X  in the new TWF-net as shown in Fig. 3. Secondly, dark nodes are updated and the rest ones remain unchanged with Fig. 2. The time and path sets of whose updated nodes are shown in Table 3. {[14,18], [14,19]}, respectively. Then, four ordered pairs are obtained: &lt;[4,5], fied. pened [9]. 7.1 Comparison by Several Test Cases Compared with the approach in [9], our a pproach can effectively maintain the sprout-graph will have to be recomputed, and this is identical with the approach in [9], i.e., having the same number of nodes to be recomputed. In the best case where the changes are made at the end of the graph, only the latter part of sprouting graph will have to be recomputed. In a real application there are often some changes made in the middle parts and thus we can expect it can always outperform the approach in [9]. 
In order to quantitatively analyzing performance of our approach, we compare it based on TWF-nets and randomly modified on some parts (regions). The criterion of comparison is the number of nodes in sprouting graph needed to update after changes. As we can see, our approach dramatically decreases the complexity of analyzing. Especially, with the increasing number of services increasing and the augmenting complexity of models, our approach is more efficient than the approach in [9]. 
Note that we can check more than one temporal constraint by using the same up-dated sprouting graph. The detailed example is illustrated in the Section 6. Thus, our approach is scalable, i.e., we do not have to create a new sprouting graph for checking a new temporal constraint. Our approach has higher efficiency especially when it deals with large numbers of temporal constraints. 7.2 Validation by Uppaal checking of real-time systems, and its typical application areas include real-time con-trollers and communication protocols. 
Firstly, we transform the TWF-nets to equivalent Timed Automata (TA) model local clock x , and some integer parameters. Secondly, we construct two TA observers in which the temporal constraints are denoted as the guard conditions labeled with the corresponding edges. Thirdly, both the transformed TA models and queries for tem-results are returned to indicate whether the temporal constraints are satisfied. 
For each case in Table 4, the results of Uppaal are consistent with the results from our approach, so that the correctness of our solution is proved. Incremental analysis gives designers some warnings or messages which assist them check temporal violations. Our approach can dynamically check the temporal con-straints of multiple workflow processes with resource dependencies, and considers the complex situations of modifying TWF-nets more than simply editing operations and can check the temporal violations efficiently. Furthermore, this approach is applicable and efficient in terms of time and space. the run-time of workflow instances, how to handle the model changes of TWF-nets needs further research. 2) In some cases a resource is allowed to execute concurrently. Acknowledgments. This work was supported by the National Natural Science Foun-dation of China under Grant No. 61004109. 
