 PIVOT is an important relational operation that allows data in rows to be exchanged for columns. Although most current relational database management systems support PIVOT-type operations, to date a purely formal, algebraic character-ization of PIVOT has been lacking. In this paper, we present a characterization in terms of extended relational algebra operators  X  (transpose), optimal tuple merge). This enables us to (1) draw parallels with PIVOT and existing operators employed in Dynamic Data Mapping Systems (DDMS), (2) formally characterize invertible PIVOT instances, and (3) provide complexity re-sults for PIVOT-type operations. These contributions are an important part of ongoing work on formal models for relational OLAP.
 F.2.2 [ Analysis of Algorithms and Problem Complex-ity ]: Nonnumerical Algorithms and Problems X  Computa-tions on discrete structures ; H.2.3 [ Languages ]: [Query languages]; H.2.1 [ Logical Design ]: [Data models] Algorithms, Languages Data Mapping, Data Modeling, exRA, Extended RA, FIRA, Federated Interoperable RA, OLAP, PIVOT, UNPIVOT
PIVOT is an important relational operation that allows data in rows to be exchanged for columns. Figure 1 shows an example of the PIVOT operation from [2], as well as the inverse operation, UNPIVOT. These operations have impor-tant applications in both data modeling and OLAP [2, 9]. Most current Relational DBMS (RDBMS), such as SQL Server, Oracle, and DB2, support PIVOT-type operations. Recently, work has been undertaken to move PIVOT op-erations  X  X nside X  the RDBMS for better optimization and execution strategies [2]. However, to date a purely for-mal, algebraic characterization of PIVOT and UNPIVOT has been lacking. One reason for this is that many input re-lations contain  X  X onflicts X  that interfere with PIVOT-type operations. For example, if the first table in Figure 1 con-tained the conflicting tuple  X   X  nmr , 5/10 , neg  X   X , the result of a PIVOT (without the ability to aggregate on the Result column values) would be undetermined.

In Cunningham et. al. 2004 [2], it is stated that there is no formal mechanism to characterize data-preserving, in-vertible input instances. To address this problem, they re-strict the pivot column to a list of fixed values and utilize CHECK constraints to verify well-foundedness. An alterna-tive approach is also discussed whereby a collapsing function (commonly aggregation) is employed in case of any conflict-ing data. For our example, the Result column does not naturally lend itself to aggregation, so the latter approach will not work.

However, a similar problem has been addressed in another context utilizing a different approach. In particular, recent work by Wyss and Robertson on Dynamic Data Mapping (DDM) provides a relational algebra for dynamic data re-structuring [8]. Using this approach, instead of restricting the generality of PIVOT-type restructuring operations, such operations can be broken down into atomic sub-operations which are fully compatible with the relational model. Figure 2 shows relevant extended RA operations used in dynamic data mapping (based on [8]). Note that in this context, both PIVOT and UNPIVOT can be simulated with a sequence of DDM operations. In particular, PIVOT comprises the op-erations shown in parts (1), (2), (3), and (4) of the diagram, and UNPIVOT comprises the operations shown in parts (4), (5), (6), and (1). The algebra from which the operations in Figure 2 are taken is termed Federated Interoperable Rela-tional Algebra , or FIRA.

The contributions of this paper are as follows.
In this section, we propose a restricted variant of FIRA and show that PIVOT-type operations can be naturally phrased within this variant. This enables us to characterize invertible PIVOT input instances, as well as give important theoretical results concerning the complexity of generalized PIVOT operations. Also, future work based on nice opti-mization properties of FIRA will enable clean, logical query rewriting for the purposes of supporting PIVOT naturally within RDBMS engines [1].
We assume standard relational definitions of schema, tu-ple, relation, as given in (for example) [6]. For this paper, we assume both data and schema elements are alphanumeric strings. This is natural in most RDBMS and enables us to focus on the action of the operators. 1
Furthermore, our notation for tuples may need additional clarification. In the canonical relational model, given rela-tion schema R and instance r , tuples t  X  r are defined for attributes X  X  R exclusively. Due to the dynamic nature of the algebra presented here, it is convenient to abuse this notation, and stipulate t [ X ] =  X  for t  X  r , X 6 X  R . This enables cleaner definitions of the operators presented below. Semantically, this notation can be underpinned by the Fed-erated Data Model of [8]. Additionally, we will sometimes represent tuples as  X  a 1 : v 1 , ..., a n : v n  X  .
For the purposes of this paper, our extended RA (simply denoted exRA ) consists of the usual six RA operations  X  (re-name),  X  (projection),  X  (selection),  X  (Cartesian product),  X  (set union), and  X  (set difference), plus five new opera-tors denoted  X  (relational transpose), (unique optimal tuple merge),  X  (metadata demotion), and  X  (column dereference).

Examples of the new exRA operations are given in Figure 2. Formal definitions follow. Where possible, we follow the notation of [8], however the algebra presented here operates on relations (as opposed to sets of relations, as in [8]).
Relational transpose, denoted  X  , promotes a column of data to attribute values, filling the new columns with data from a second input column. This operation is depicted in Figure 2 (1)  X  (2). Formally, we define  X  as follows. Definition 2.1 Let R ( A 1 , ..., A n , B, C ) be a relation schema. For any in-stance, r of R such that  X  B ( r )  X  R =  X  , we define the Trans-pose of C on B of r ,  X  B C ( r ), as follows. For each t  X  r , corresponding s  X   X  B C ( r ) is defined as: Note the appearance of a dynamic well-definedness condition in this definition, namely  X  B ( r )  X  R =  X  . This condition is similar to (for example) the stipulation that schemas must match in a set union. However, the condition cannot be checked until runtime (unlike in canonical RA). The drop projection, input relation. In RA, of exRA, this operation cannot uniformly be simulated using  X , since schemas in exRA may dynamically depend on input instances. An example of the drop projection is given in Figure 2 (2)  X  (3).
 Definition 2.2 Let R be a relation schema. For any instance, r of R and attributes A 1 , ..., A n  X  R , we define
The goal of the optimal tuple merge operation,  X  , is to decrease the sparsity of input relations by  X  X erging X  appro-priate tuples. The main problems with this operator (and PIVOT-type operations in general) is that there may be more than one way to merge tuples in an input relation. Unfortunately, this remains true even if we employ natural notions of optimal merged output, such as  X  X inimal number of tuples in merged relation. X  Definition 2.3 1. Let R be a relation schema and r an instance of R . 2. Let R be a relation schema and r an instance of R . Let Definition 2.4 1. Let R be a relation schema and r 1 and r 2 two instances 2. Let R be a relation schema and r 1 and r 2 two instances
To see what can go wrong with the notion of an optimal merge, note that the relation { X  a,  X  X  ,  X  X  X  , b  X  ,  X  X  X  , c  X  X  has two distinct optimal merges. Thus, for our algebraic merge op-erator to be deterministic and well-defined, we must enforce uniqueness.
 Definition 2.5 (Optimal Tuple Merge Operator) Let R be a relation schema and r an instance of R . Then the unique optimal tuple merge of r , denoted  X  ( r ) is as follows.  X  ( r ) := Here,  X  R refers to the empty relation of schema R .
An example of the  X  operation is depicted in Figure 2 (3)  X  (4). In section 3.2, we give a O ( | r | 3 ) algorithm for determining whether there is a unique optimal tuple merge for an input instance (and finding it if so).
In exRA, we allow the demotion of relational attributes to data. Metadata demotion is depicted in Figure 2 (4)  X  (5). In a demotion, a new column is added to the relation, con-taining attribute values. Formally, the operation is under-pinned by the following definition.
 Definition 2.6 Let R ( A 1 , A 2 , ..., A n ) be a relation schema and r an instance of R . Let y be a fixed domain element, y 6 X  R . Then the metadata demotion corresponding to r , denoted  X  y ( r ) is:
Finally, exRA contains an operator that  X  X ereferences X  a column of data as metadata, yielding a  X  X rojection X  of the input relation that varies on a per tuple basis. This operation is depicted in Figure 2 (5)  X  (6). Formally, the column dereference operation  X  is defined as follows. Definition 2.7 Let R ( A 1 , ..., A n , B ) be a relation schema and r an instance of R . Let z be a fixed domain element, z 6 X  R . Then the dereference of r by B , denoted  X  z B ( r ), is obtained as follows. For input tuple t  X  r and X  X  R  X  { z } , we construct s  X   X 
B ( r ) as:
Recall that we are abusing notation to assume t [ X ] =  X  when X  X   X  B ( r ) but X 6 X  R .

Also note that in a column dereference, the user must specify a fixed output name for the new column of deref-erenced values. This new schema value should not conflict with existing schema values.
For this paper, the main point of developing the extended relational algebra exRA is to enable the formal definition of PIVOT and UNPIVOT as sequences of exRA operations. Our definitions of these operations are based on the behavior and notation as described in [2].
 Definition 2.8 1. Let R ( A 1 , ..., A n , B, C ) be a relation schema and r an 2. Let R ( A 1 , ..., A n , B 1 , ..., B m ) be a relation schema and
As stated previously, one approach in [2] is to avoid PIVOT conflicts by explicitly specifying pivot values from the input data. Our PIVOT operation is more general in that pivot values need not be explicitly specified. If specific pivot val-ues are desired, the PIVOT can be preceded with an appro-priate selection operation.

The alternative approach employed in [2] is to include an aggregate function in a PIVOT operation. Although the version of exRA presented here does not contain group by and aggregation, future versions will contain this ability, as discussed in [1]. However, note that including aggregation in a PIVOT will render the PIVOT un-invertible in most cases.
In this section, we use exRA to prove some important re-sults concerning the complexity of computing well-defined PIVOT operations. Our main result is that  X  can be com-puted in time O ( | r | 3 ) for an input relation r (and in fact in This result is somewhat surprising given the characteriza-tion in the next section.
Optimal tuple merges for a relation are, in general, diffi-cult to find. By this, we mean that the problem of finding an optimal tuple merge counterpart for an arbitrary input re-lation belongs to the well-known class of NP-complete prob-lems. Before proving this, we first state the Tuple Merge Decision and Optimal Tuple Merge problems more formally. Definition 3.1 1. The Tuple Merge Decision (TMD) problem is: given a 2. The Optimal Tuple Merge (OTM) problem is simply Theorem 3.1 Let R be a relation schema, r an instance of R , and n a natural number. Then the problem of determining whether r has a merge of size n is NP-complete.
 Proof: We will exhibit a class of schemas and associated instances for which the problem of deciding whether a merge of size n exists is equivalent to finding a solution to the known NP-Complete decision problem Hitting Set [3]. For an illus-tration of the technique, see Figure 3. In Figure 3, (a) shows a positive example and (b) shows a negative example.
Hitting Set involves a finite set X = { 1 , ..., m } and a col-lection of sets C 1 , ..., C k  X  X . In addition, we are given a natural number p  X  m . Hitting Set asks: is there a set X 0  X  X where | X 0 | = p and for all j , 1  X  j  X  k , C j  X  X
Given an instance of Hitting Set as specified above, con-sider schema S = { N, B, C 1 , ..., C k } . 3 Consider an instance s of S , containing: 1. m tuples E i :=  X  N : i, B :  X  , C 1 : x 1 , ..., C k : x 2. k tuples C q :=  X  N :  X  , B : 0 , C 1 :  X  , ..., C q : 1 , ..., C 3. m  X  p tuples B l :=  X  N :  X  , B : l, C 1 :  X  , ..., C k
Given this schema and instance, choosing n = m gives the reduction of OTM to Hitting Set. We claim there is a merge of s of size n = m exactly in case there is a hitting set for the C i of size p .

To see this, note that any merge of s will be of size  X  m since none of the E i tuples can be merged with each other (they all differ on the N component).

Additionally, because the B component of the B l tuples is distinct from the B component of the C q tuples, no B l
We will overload the names  X  C 1  X  through  X  C k  X  to denote both the subsets of X as well as the corresponding column attributes of the relation we are constructing so that the exposition is clearer.
C
C tuple can merge with any C q tuple. However, the B l tuples can merge with the E i tuples. Assume this is done, leaving m  X  ( m  X  n ) = p E i tuples unmerged with B l  X  X  that need to be merged with the C q tuples.

It should be clear that, by definition, a C q can only merge with an E i in case i  X  C q ; hence we can see that all remain-ing E i tuples will be merged exactly in case there is at least one Hitting Set of size n for the C q sets. (This Hitting Set will in fact be given as the set of N components of the E tuples that merged with the C q tuples).

This shows that a merge of size n of s determines a hitting set of size p . Conversely, a hitting set of size p will clearly determine a merge of the relation of size n , using the same setup as above. Hence, TMD is at least as difficult as Hitting Set.

On the other hand, T M D is in NP. The easiest way to see this involves the idea of a merge-mapping . Given relation instance r of schema R , and natural number n , an n -merge-mapping for r is a mapping from the tuples of r into { 1 , ..., n } that describes a merge of r of size n (tuples mapped to the same number are to be merged). Suppose we have an instance r and a natural number n , and we guess an n -merge-mapping for r . In this case, we can verify whether the mapping indeed describes a well-defined merge of r of size n in time O ( | r |  X  n ) by attempting to build the merge as described by the mapping. Thus, TMD is solvable in NP.
 Corollary 3.1 Optimal Tuple Merge is NP-hard.
 Proof: If we can determine whether a relation has a merge of size n in time T ( n ), we can find such a merge in time O ( | R | T ( n )  X  n ). Thus, a polynomial-time solution to TMD gives a polynomial-time solution to OTM, since we need only de-termine the least number in { 1 , ..., | R |} for which a merge exists, and then compute such a merge.

On the face of it, these results would seem to bode poorly for efficient implementations of  X  . However, in case an in-stance r has a unique optimal merge, it can be efficiently computed. In fact, there is a O ( | R | 3 ) algorithm for deter-mining whether input relation R has a unique optimal merge and (if so) computing it, which we establish in the next sec-tion.
Although Theorem 3.1 would appear to be seriously lim-iting in terms of the viability of the  X  operator, there is a broad class of input relations which admit a unique optimal merge. Furthermore, the characterization of this class gives a polynomial-time algorithm for computing  X  .
 Proposition 3.1 Let R be a relation schema and r an instance of R . Then r has a unique non-trivial optimal merge exactly in case the following condition holds: Proof: Both directions are reasonably straightforward using proof by contradiction. We will show the condition is sufficient to guarantee a unique merge; the other direction uses similar reasoning.

Let R be a relation schema and r an instance of R . Sup-pose the condition holds but there are at least two distinct non-trivial optimal merges of r , namely s and s 0 . Since s and s 0 are both non-trivial (in particular not empty) and op-timal, yet distinct, there are tuples t, x 1 , ..., x n , y such that t s = t x 1  X   X   X  x n  X  s and t s 0 = t y 1  X   X   X  y s . There are two cases to consider.
 Corollary 3.2 Given relation schema R and instance r , we can determine if a unique optimal merge for r exists (and compute it if so) using O ( | r | 3 ) tuple comparisons as follows. The initial result relation is simply the input relation.

The idea is that at each stage in the computation we will examine three tuples, t 1 , t 2 , and t 3 . If the three tuples violate the above the condition, terminate and return the empty relation. If the three tuples are mergeable, remove all three and replace them by their merge. Otherwise, continue with the next three tuples until all triples of tuples have been examined. (Note that we will need to be somewhat clever about picking tuples to achieve the O ( | r | 3 ) running time.)
Using similar ideas to those in the previous section, there is a natural characterization of invertible PIVOT instances. First, we need a precise definition of what is meant by  X  X n-vertible X  PIVOT instance.
 Definition 3.2 Let R ( A 1 , ..., A n , B, C ) be a relation schema and r an in-stance of R . We say r is PIVOT-invertible iff
In a nutshell, Definition 3.2 states that the transposed  X  X ore X  of a PIVOT operation has a non-empty unique opti-mal tuple merge. In this case, we can  X  X ndo X  the PIVOT and obtain our original relation, as follows.
 Proposition 3.2 Let R ( A 1 , ..., A n , B, C ) be a relation schema and r an in-stance of R . Suppose  X  B ( r )  X  R =  X  and also that r is PIVOT-invertible. Then Proof: Note that for our running example, this is exactly the sequence of exRA operations depicted in Figure 2. For-mally, let r 0 := PIVOT C for B ( r ) 6 =  X  happens exactly in case  X  ( r 0 which is to say there is a unique optimal merge of r 0 . This plus the condition  X  B ( r )  X  R =  X  ensures we can undo the merge using  X  and  X  and return to the original relation using  X  and  X  appropriately.

Furthermore, we have the following elegant semantic char-acterization of a broad class of PIVOT-invertible instances. Proposition 3.3 Let R ( A 1 , ..., A n , B, C ) be a relation schema and r an in-stance of R . Suppose { A 1 , ..., A n , B } is a superkey for r . Then r is PIVOT-invertible.
 Proof: Suppose R ( A 1 , ..., A n , B, C ) is a relation schema such that the condition holds. Let r be an instance of R and r 0 :=  X  B,C (  X  B C ( r )). Assume that r 0 6 =  X  .

Since the { A 1 , ...A n , C } components uniquely identify tu-ples in r , there will be at most one distinct C value in r for every group of distinct A 1 , ..., A n , B values. Consider r . Let  X  B ( r ) = { X  b 1  X  , ...,  X  b m  X  X  . Then the schema of r is { b 1 , ..., b m }  X  { A 1 , ..., A n } . We can partition r relations r 0 1 , ..., r 0 k based on distinct A 1 , ..., A each of these partitions, at most one tuple has a non-null b component, which means each partition can be fully merged in exactly one way, resulting in one tuple for each r 0 i gether we will have k tuples in  X  ( r 0 ) as a result ( k 6 = 0).
As a corollary, if we know in advance that appropriate columns form a superkey, we can form the unique optimal merge by partitioning (basically sorting), in time O ( | r |  X  log( | r | )). Since we can check keyness also in time O ( | r |  X  log( | r | )), this gives us a highly efficient check for PIVOT-invertibility in many cases. In case { A 1 , ..., A n , B } turns out not to be a superkey, we can revert to the method of Section 3.2.
Throughout the paper we have indicated how our work dovetails with [2] and [8].
 The original tuple merge operator appears in work on SchemaSQL, specifically [4] and (in more detail) in [5]. How-ever, for relations (as opposed to just pairs of tuples), the SchemaSQL merge operation differs significantly from ours. There is no notion of  X  X ptimal merge X  in the SchemaSQL lit-erature, rather the behavior of the included merge operator is left nondeterministic. The implementation of SchemaSQL merge as given in [5] relies on an implicit ordering of tuples in the input relation. In contrast, our  X  operator is fully deterministic and always provides a single output relation having appropriate schema as a result.

There are many directions for future work on exRA. First, properties of exRA can be investigated, such as indepen-dence and atomicity of the additional operators. Also, bet-ter algorithms for detecting and computing unique optimal tuple merges no doubt exist, and techniques such as hill-climbing or dynamic programming could be fruitfully em-ployed in implementing  X  . Furthermore, we are investigat-ing the addition of a generalized group by / aggregation operator to exRA, which may in fact enable OLAP opera-tions involving cube representations to be formalized in a similar way as PIVOT. In general, exRA provides a solid foundation for ongoing work on formal models for OLAP and data modeling.
Thanks goes to the anonymous CIKM reviewers for advice on creating this draft. Also, Fulya Erdinc and other mem-bers of the IU Database Lab have given invaluable feedback on previous drafts. [1] Fulya Erdinc and Catharine M. Wyss. Intrinsic, [2] Conor Cunningham, C  X esar A. Galindo-Legaria, and [3] M. R. Garey and D. S. Johnson. Computers and [4] L. V. S. Lakshmanan, F. Sadri, and I. N.
 [5] L. V. S. Lakshmanan, F. Sadri, and I. N.
 [6] Raghu Ramakrishnan and Johannes Gehrke. Database [7] Edward L. Robertson and Catharine M. Wyss.
 [8] Catharine M. Wyss and Edward L. Robertson.
 [9] Andrew Witkowski, Srikanth Bellamkonda, Tolga
