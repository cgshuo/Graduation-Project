 A subsequence is a sequence of symbols that i s derived by removing some symbols from another sequence. A subsequence maintains the order among the remaining symbols. These symbols belong to a collection called alphabet . Subsequence search is equivalent to searching for regular expressions of the type .  X  q 1 .  X  q 2 .  X  ... .  X  q l .  X  ,where the subsequence is q 1 q 2 ...q l . For example,  X  X bc X  is a subsequence of string  X  X cbc X . Finding subsequences in a database is an important problem for many applications, e.g. , Automatic Speech Recognition (ASR) sy stem or Optical Character Recognition (OCR) system. These systems can recognize a subsequence of the actual data. Hence, a subsequence search on the database of possible values can be useful.

As an example application, we consider tw o scenarios related to ASR. A voice call can be recorded and stored as an audio file ( e.g. , a .wav file). When this file is transcribed into a text file, some noise is added durin g the transcription because many words are not recognized by the ASR system [1]. Similarly, when numbers are transcribed, many digits are missed during the transcription, but the ASR preserves the sequence of these numbers, e.g. , a phone number 9878281823 may be transcribed as 9878213.

Scenario 1: When a call (fixed line/mob ile) is made, a CDR (Call Data Record) is generated by the switch that contains the information about  X  X ho is calling whom X , time, duration of the call, etc. To track the activities of suspected individuals, the Police of ABC city has decided to record the calls made/received by these individuals. These recordings may have important information, such as, the phone numbers of other po-tential associates, in addition to the person to whom the call was made. Based on these numbers, the police would like to trace all the calls made/received from these numbers. This can help the Police identify the social circle of these suspected individuals. Scenario 2: A call is made to a call center. The customer gives her name and Social Security Number (SSN). Due to noise the call receiver does not understand some digits in the number. Even though a few digits are missing from the SSN, the receiver wants to pull the record from the database with the use of customer name and partial SSN.
In both the scenarios, it is desired that we get the tuples that have the transcribed text as a subsequence. The database of strings (phone numbers in the first case, and SSNs in the second case) is dynamic, i.e. , tuples can be inserted or deleted from the database. Since the database can be large, it is important that the index is disk resident and does not require the whole index to be stored in main memory.
 In this paper we address the problem of efficiently finding subsequences in databases. We develop two index structures based on trie and bitmap to solve this problem. Our index based on trie uses an augmented suffix tree to encode strings in the database. Both indices are designed for large databases and are thus disk-resident and not limited by memory availability. The second index consists of a set of bitmaps over the data. Each search accesses only a subset of the bitmaps depending upon the query sub-sequence. To demonstrate the merits and demerits of these index structures we have implemented both index structures and analyzed them empirically.

The rest of the paper is organized as fo llows. In Section 2 we formally define the problem of subsequence search in databases. We explain our index structures in section 3 and 4. Experimental results are presented in Section 5. We summarize some related work in Section 6, and finally section 7 concludes the paper. We now formally define the problem of subsequence search. Consider a table T with n tuples and an attribute A of type string, i.e. , a sequence of characters. The char-acters that make up these strings are taken from a finite alphabet, , of cardinality k . Furthermore, let m be the maximum length of the attribute for any given tuple. We are interested in the following regular expression match query. Given a sequence of l characters (from ), where l  X  m , find all tuples in T where this sequence occurs in the attribute A , possibly with intervening characters. Thus, given a query se-quence: q 1 ,q 2 ,  X  X  X  ,q l , the goal is to identify all tuples that match the regular expres-strings like  X  X bcd X ,  X  X dbc X ,  X  X dbec X  satisfy the query and should be returned. Table 1 summarizes different notations used throughout this paper.

One approach could to be check each tuple individually, e.g. ,usingKMP[2].How-ever, such approaches will take at least order O ( n ) time as each tuple has to be pro-cessed separately. To handle large databases, the index needs to be disk-resident. The index should also be able to handle dynamic databases where new tuples can be inserted and existing tuples can be deleted. In the further sections, we will describe our proposed index structures which solve this problem while being disk-resident. Our solutions can also handle dynamic databases. Our first solution is based upon the following observation. Suppose the input subse-quence consists of a, b, c (in that order). An intuitive solution for finding matching tu-ples is to process each tuple at a time. For a given tuple, we begin by finding the first occurrence of a . If none is found, we reject the tuple. If we find a then we search for the first occurrence of b in the remaining substring, and so on. This simple approach is guaranteed to be correct, however searching each tuple individually is very inefficient. In order to speed up the search, we exploit a trie index over the table. Trie structures have been popular for string searching. We modify this structure to make it suitable for our problem. In the following subsections, we will describe the structure of our trie-based index and how search and updates are done. 3.1 Structure Each node in the index tree represents a symbol from the alphabet. The edges in the tree represent the sequence in which two symbols occur in the database. Consider a sample table with two attributes: a tuple id and a string attribute with characters from the set { a, b, c } , shown in Table 2. Given this data, we construct our index tree as shown in Figure 1. Each path from the root to a leaf represents a tuple in the database. Each node is labeled with a symbol from the tuple.

Level of a node is defined by its depth in the tree. The root has level 0 . Each node also has a position assigned to it which represents its position in that level, i.e. , its position in the insert sequence for that level. E.g., in Figure 1, at level 2, nodes are inserted in this order:  X  X  X  of tuple 1,  X  X  X  of tuple 2,  X  X  X  of tuple 3,  X  X  X  of tuple 4,  X  X  X  of tuple 5, and then  X  X  X  of tuple 6. Positions ar e assigned accordingly. We represent a node as node(x, y) ,where x represents the level and y represents its position. Node positions are also used when storing data on the disk.
 Definition 1. Fresh-occurrence of a symbol in a subtree is defined as occurrence of a symbol in the subtree when none of its ancestors in the subtree has the same symbol except for the subtree root.
 In figure 1, fresh occurrences of  X  X  X  at the root are node(2, 3) , node(2, 6) ,and node(1, 3) . Note that node(2, 5) is not included since node(1, 3) is its ancestor and has the same symbol. Similarly, fresh-occurence of  X  X  X  at node(1, 3) is node(2, 5) .
Each node is augmented with two 2-dimensional arrays, namely firstOccur and las-tOccur , which stores the first and last fresh-occurrence of each symbol at each level in its subtree, respectively. Notice that there can be many fresh-occurrences of a sym-bol at the same level. However, firstOccur and lastOccur only track the first and last fresh-occurrences of them. In Figure 1, at root, firstOccur of  X  X  X  would be node(1, 3) at level 1 and node(2, 3) at level 2, and, lastOccur will be node(1, 3) and node(2, 6) at level 1 and 2 respectively. Each node also maintains next , a pointer to the next fresh-occurrence of the same symbol in the same level. This is useful to traverse all the nodes with the same symbol from firstOccur to lastOccur . Hence, firstOccur , lastOc-cur and next are sufficient to find all the fresh-occurrences of a symbol at a given level. At root, if we want to traverse all the fresh-occurrences of  X  X  X  at level 2, we do it like this: firstOccur of root tells  X  X  X  occurs at node(2, 3) , lastOccur tells that  X  X  X  occurs at node(2, 6) . So, we go to node(2, 3) ,thenwegoto node(2, 3).next which is node(2, 6) . Since, this is the last fresh-occurrence w e stop here. Table 4 summarizes the fields maintained by a node. From figure 1, we see that firstOccur and lastOccur at the root of the tree stores the first and the last occurrences of each symbol at all three subsequent levels. Similarly, node(1, 3) stores data for two levels. By choosing such data structure, we ensure that at each level, the size of each node is constant. This helps in the storage and retrieval of node data on disk.

At each node, we also store a list of tuple ids that fall in the subtree rooted at that node. For this, we maintain a link-list of IDs. Nodes store startTupleID and endTupleID pointers to this list. For example, at node(1, 2) , startTupleID and endTupleID will be 2 and 3 respectively. Now if the regular expression is satisfied at this node, we simply return all the nodes from 2 to 3 in the IDList. This means that all tuples ids from 2 to 3 in the list have common prefix, which is  X  X  X . 3.2 Search The search for tuples matching the query seque nce  X  X cb X  begins at the root. At the root, we find that  X  X  X  is present at node(1, 1) ,and node(2, 2) . Thus, all the tuples in these at these nodes. We find that  X  X  X  is present at node(2, 6) only. Consequently, we search for  X  X  X  in this subtree. We find that  X  X  X  is present only at node(3, 1) . All tuple ids that are stored in the subtree rooted at this node constitute the answer to the query. In this case, it will be the tuple with id 6. Algorithm 1 explains the search process formally.
To explain the use of next , we consider a search for subsequence  X  X b X . At root, we check firstOccur , and find that c is present at node(1, 3) and node(2, 3) . Figure 1 explains step by step how the search is conducted. First, we go to node(1, 3) and search for  X  X  X . We find that  X  X  X  is present at node(2, 4) , so we output ID 4. Then we search for  X  X  X  at node(2, 3) . We find that there is no  X  X  X  in its subtree. We check lastOccur of root and find that node(2, 3) was not the last fresh-occurrence of  X  X  X  at that level, so we go to the next of node(2, 3) , i.e. , node(2, 6) . We search for  X  X  X  at this node and find a  X  X  X  at node(3, 1) . So, we output ID 6. Since this is the last occurrence of  X  X  X , we stop here. Notice that we never searched for  X  X  X  at node(2, 5) . This is because, search at node(1, 3) was sufficient as that was first occurrence of  X  X  X . As data size increases, such cases of pruning of nodes will increase, improving performance of this index.

Due to space limitations, we omit the algorithms for insert and delete of a tuple in the index.
 Algorithm 1. S EARCH (Var[] regex , Node root ) 3.3 Analysis Space: There are m +1 levels in the tree. firstOccur and lastOccur of each node are 2 dimensional arrays with each row representing each symbols from the alphabet and each column representing different leve ls in the subtree. Thus, each node will have a maximum size of O ( mk ) . In the worst case, there can be O ( nm ) nodes, where n is the number of tuples in the table. So, in the worst case, the space required would be O ( nm 2 k ) . However, in practice, many tuples will share common prefixes. As tu-ples start sharing common prefixes, space re quirement will decrease. When all possible symbol combinations are added to the database ( i.e. , a full tree), there will be a total of O ( n ) nodes in the tree. Hence, the space requirement will be O ( nmk ) .
 Search Time: In worst case, the search time would be O ( nl ) . This is because at each level there can be at most O ( n ) nodes, and we have to go through O ( l ) levels to satisfy the subsequence. Tree based index structures have the property of representing data in a concise way which makes it fast to search and access the desired data. However, these indices can have complex ways to traverse and also to store data on disk. Bitmap indices enjoy a very simplistic structure which are fast and easy to implement. Even though bitmap indices are very simplistic, one should be careful in designing these indices correctly.
As a naive attempt at using bitmaps to solve this problem, consider a simple set of bitmaps { B c 1 c 2 | c 1  X  ,c 2  X  } . In other words, we maintain k 2 bitmaps each of which corresponds to the occurrence of a pair of characters in order. The i th bit in the bitmap B ab is 1 if the i th tuple contains  X  X  X  followed by  X  X  X , and otherwise it is 0. Given this set of bitmaps, we may try to find all tuples matching the query  X  X bc X  by taking the bit-wise AND of the three bitmaps: B ab &amp; B bc &amp; B ac . However, this can lead to incorrect results as seen from the tuple:  X  X acb  X . It is clear that this sequence satisfies the conditions for the three bitmaps, but it does not contain the query sequence.
In this section we propose an alternative solution to the subsequence search problem using bitmap indices. The next subsection describes our bitmap based index and its use to search for subsequences. 4.1 Proposed Solution Since space is not a constraint, we propose to maintain a large number of bitmaps: {
B c 1 c 2 ij | c 1 ,c 2  X  , 0  X  i&lt;j&lt;m } . Each bitmap corresponds to the occurrence of a pair of characters at given positions, where c 1 and c 2 are characters from the alphabet ,and i and j are possible locations, where 0  X  i&lt;j&lt;m . If in a tuple, characters c 1 and c 2 appear at positions i and j respectively, then the bit corresponding to that tuple in index B c 1 c 2 ij is set to 1, otherwise it is 0. Thus, we have k 2 m 2 bitmaps, each of length n bits. Note that while this seems to be a large number of bitmaps, we expect that there will be many zeros in the bitmaps which could then be effectively compressed using an encoding scheme such as [3].

To see how these bitmaps can be used to find the answer to a query, consider the query sequence  X  X bc X . It is clear that any sequence that contains this sequence must have bits 1 at least in the following two bitmaps: B abij , B bcjk where 0  X  i&lt;j&lt;k&lt;m . Thus, to identify the set of tuples that satisfy the query we need to take a bitwise-AND of pairs of bitmap for a given value of i, j, and k and then take the bitwise-OR of each of these results. In other words, we compute the following bitmap: All tuples that correspond to the bits set to 1 in this result are tuples that must contain the query sequence. For larger sequences, we apply the same technique, i.e. , in general to search for the query sequence q 1 ,q 2 ,  X  X  X  ,q l , we compute the following bitmap: The number of AND and OR operations is given by: m C l  X  1 OR operations and m C l  X  1 ( l  X  1) AND operations.

For example, for Table 3, the bitmap indices will look something like this: &lt;2, 3, 1, 2&gt; 1 0 0 0 0 &lt;2, 3, 1, 3&gt; 1 1 0 0 0 &lt;2, 3, 1, 4&gt; 1 0 0 0 0 &lt;2, 3, 1, 6&gt; 1 0 0 0 0 &lt;2, 3, 1, 7&gt; 1 1 0 0 0 &lt;2, 3, 3, 4&gt; 0 0 0 1 0 ..... Searching for  X 233 X  will first require to fin d all possible combinations for positions of  X 2 X ,  X 3 X  and  X 3 X  in the attribute. Among different combinations for positions of symbols, we have (1, 2, 3), (1, 3, 7), (3, 4, 6), and so on. Now, we first take ANDs: (1,2,3): &lt;2,3,1,2&gt; AND &lt;3,3,2,3&gt; : 10000 (1,3,7): &lt;2,3,1,3&gt; AND &lt;3,3,3,7&gt; : 11000 (3,4,6): &lt;2,3,3,4&gt; AND &lt;3,3,4,6&gt; : 00010 Next the OR of these bitmaps is computed yielding 11010. This means that the tuples with TupleID 1,2, and 4 satisfy the regular expression. Since we have not calculated all the combinations, we can not say anything about other tuples. Upon completing the calculation, we will find that the output bitmap will be 11110, hence tuple 5 does not satisfy the regular expression. Therefore, the output IDs will be 1, 2, 5, 3. 4.2 Analysis Space: As explained before, there will be O ( m 2 k 2 ) bitmaps, and s ince each bitmap required is: O ( nm 2 k 2 ) . To search for a subsequence of length l , we will need to use ( l  X  1)  X  ( m  X  l +1)  X  ( m  X  l +2) / 2 bitmap indices.
 Time: For one AND or OR operation between 2 b itmaps, we need O(n) time. Now, for a particular combination of locations, we do l  X  1 AND operations. And we take OR of each such combination of l ocations. Now there are m C l such combinations. Therefore, time required is O ( n  X  l  X  m C l ) . To establish the effectiveness of the proposed indices, we implement both indices and a naive approach. To evaluate the efficiency of the proposed indices, we run three sets of experiments. First set of experiments demonstrates the disk usage and index creation time of the indices. Secondly, wedemonstrate the effect of data set size on the time and disk I/O required in subsequence search. And finally, we demonstrate the effect of query size (subsequence length, l ) on search time and disk I/O.

In all experimental results, time is reported in milliseconds and disk usage is reported in megabytes. We implement the index structures in C. The experiments are run on an Intel Xeon, 3.0 GHz machine with 2 x 512MB (266MHz) RAM and PATA, 7200 RPM, 8.5ms average read time disks running Linux.
 Na X ve Approach: In naive approach, we take each tuple one by one, and we parse it sequentially. For example, when searching for { .  X  X  a { .  X  X  b { .  X  X  c { .  X  X  ,wetakeatuple, and search for a in it. If we do not find a in the tuple, it is discarded else we search for b in the remainder substring, and so on. 5.1 Setup Storage Organization: We now discuss how these indices are stored on disk. The node data for each level of the tree are stored in a separate file. To add a new node at a given level, it is appended to the corresponding level file. If the data of a node need to be modified, we modify the entry in place in the file. We can know the node X  X  start position in the file simply by knowing i and level. Since each node, node(x, y) , can be identified by values of x and y , all the pointers are actually stored in the form of node position at the corresponding level, i.e. , firstOccur , lastOccur , next and parent keep positions of nodes in it X  X  level. as that is always known. IDList is stored in a separate file. Whenever a new ID needs to be added, it is appended to the end of the file. Again, location of ID in IDList file is used as pointer values. Using this approach, we do not need to keep the whole index structure in memory. We can read a node on a need to know basis. For the bitmap index, each bitmap is stored in a separate file. For every 8 new tuples, 1 byte is added to each of the bitmap files. For naive approach, we store data in text form. Each tuple is followed by new line.
 Data Sets: We use a synthetic dataset for the experiments. To simulate US phone num-bers (of the form xxx-xxx-xxxx), we generate 10 digit numbers randomly. We generate them in a set of 3, 3 and 4 digits. In other words, we generate 2 sets of 3 digit numbers, and 1 set of 4 digit numbers (namely T1, T2 and T3). A phone number is generated by picking one number from each set. All the phone numbers generate d are unique. Please note that both indices will work even if there are duplicate entries. Table 5 shows size of T1, T2 and T3 for each dataset.
 Buffer Manager: In order to simulate the effect of buffering, we use a buffer manager of size 1MB. For trie -based index, only buffer size of data is kept in main memory for each level. This means, on an average, memory used will be approximately ( m +1) times the buffer size. For bitmap and na X ve a pproach, cache hits will not occur these ap-proaches as data is read sequencially. Thus, we simply assign (m+1) buffer size memory to them. Buffer Manager estimates the amount of I/O done to read index data from the disk to execute a subsequence search.
 Queries: For each dataset, we pick a number, and search for its subsequences. The subsequence length varies between 6 and 10. There are 2 variables we change when running the queries, a) Dataset size, i.e. , number of tuples b) Regular expression length. 5.2 Results We now discuss the results of our experiments. As mentioned before, we have mainly three set of experiments to evaluate the fid elity of our proposed index structures. Now, we describe the setup of each set of the experi ments and the results of the experiments. Index Size and Create Time: Figure 2 shows the effect of dataset size on the size of index structure. As the dataset size increases, the trie-based index becomes saturated , i.e. , the index tree tends towards a full binary tree. As a result, number of new nodes required to insert a new tuple decreases as the dataset size increases. Thus, the size of the index tree does not increase rapidly. On the other hand, the bitmap index size increases linearly with the dataset size. Th is is because the size of each bitmap depends only on the number of tuples in the dataset. Figure 3 shows the effect of number of tuples on the total time to create the indices. Since there is no index structure for the naive approach, we do not show it in this figure. Even though the increase in the data size decreases the number of new nodes required per insert, existing nodes will still have to be updated to accommodate new nodes (for example, firstOccur and lastOccur of existing nodes will be modified). This results in higher creation time for the index tree. However as the dataset size increases, time required per insert decreases. The time required for creating the bitmap index is much less due to its simplistic structure. Effect of Dataset Size on Search: In order to understand how our proposed index structures scale for large databases, we demonstrate the effect of dataset size on search time and disk I/O. We increase the dataset size to as large as 40 million so that we could evaluate the indices for large databases. For each dataset, we search for a subsequence of length 8. Figure 4 and 5 demonstrate the effect of the dataset size (number of tuples) on disk I/O and query time required for searching a subsequence, respectively. Bitmap indices increase linearly with the dataset size. Thus, disk I/O and search time both increase linearly. Naive approach shows similar trend. However, the trie based data structure does not exhibit a similar growth rate. The trie structure saturates as dataset size increases. Thus, the number of extra nodes required to read does not increase as much, resulting in small disk IO and search time.
 Effect of Query Size on Search: In many applications, accuracy of transcribed se-quence can be different. Hence, its important to understand how these indices behave when subsequence length changes. Figure 6 an d 7 show the effect of subsequence length on disk I/O and time, respectively. As discussed before, a query of length l requires ( l  X  1)  X  ( m  X  l +1)  X  ( m  X  l +2) / 2 bitmaps. Thus disk I/O in bitmap index is maximum for regular expression length 5. After this overhead keeps decreasing. As ex-pected, for the naive scheme, time and I/O are largely unaffected by the subsequence length. For trie-based index, as the subseque nce length increases, the movement be-tween different levels is constrained. For example, when searching for 12345, we look for  X 1 X  at levels from 1 to 5. On the other hand, if we search for 1234567, then  X 1 X  will be searched at levels 1, 2 and 3. Hence, th e disk overhead is expected to decrease as subsequence length increases. These exp ectations are met in the experiment results.
From our experimental results, we see that both indices based on bitmap and trie are effective for large subsequence searches. The index based on trie is orders of magnitude effective even for short subsequences. Our i ndices scale for large databases while using acceptable amount of disk. There are two broad approaches for processing regular expression queries. One is to create a deterministic finite automaton and pass each tuple through it. This approach does not scale as each tuple has to be processe d separately. Also the number of state in the DFA can be exponentially large. Second approach is to preprocess the data ([4 X 6]) and construct an index structure, which is used to process regular expression queries.
The trie datastructure[7] has been a popular index structure for string searching [4, 8, 9]. [4] showed how regular expressions can be searched using the Patricia Tree. The time complexities of their index are quite efficient. However, this index is suit-able only if the entire trie fits into main memory, which may not be feasible for large databases. Another problem with this index is that it works only for a static databases. Our indices are both efficient and can handle dynamic databases as well. [10] extends the pattern expressions to parameterized pattern queries . The paper in-troduces the concept of variables to express regular expressions, which makes it more concise and allows additional constraints. [11] proposes an R*-tree based index for fast subsequence search in time-series databases. They use a different definition of subse-quence matching. Given two strings, S and Q , the subsequence matching problem is that the distance between S and Q should be within a static value .

FREE [12] uses a multigram index for searching regular expressions. It selects fre-quent grams, and indexes them. This index is used to find tuples which may potentially satisfy the regular expression, and then those tuples are searched. However, For this technique to yield good results, the grams should be powerful, which may not be the case in many applications like ASR.

The RE-Tree [6] tries to address the opposite problem. Given a database of many REs and a string, the proposed solution finds all REs that satisfy the given string. RE-tree is a height balanced tree in which each node st ores an automaton (number of states in these automata are bounded). In this paper, we considered the problem of searching subsequences in databases. We showed that the problem is important for many applications. We presented two disk-based index structures for this problem which scale to large databases. These indices not only work for static databases, they work for dynamic databases as well which allows inserts and deletes of tuples. We evaluated the efficiency of these indices by implementing them and comparing them on v arious aspects. We showed that our index structures are efficient and scale to large databases. We also showed that our indices can be efficiently stored on disk.
 Acknowledgements. The work in this paper is supported by National Science Foun-dation grants IIS-1017990 and IIS-09168724.

