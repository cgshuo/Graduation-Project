 Neural models have recently gained popularity for Natural Language Processing (NLP) tasks (Gold-berg, 2015; Collobert and Weston, 2008; Cho, 2015). For sentence classification, in particular, Convolution Neural Networks (CNN) have realized impressive performance (Kim, 2014; Zhang and Wallace, 2015). These models operate over word embeddings , i.e., dense, low dimensional vector rep-resentations of words that aim to capture salient se-mantic and syntactic properties (Collobert and We-ston, 2008).
 An important consideration for such models is the specification of the word embeddings. Several op-tions exist. For example, Kalchbrenner et al. (2014) initialize word vectors to random low-dimensional vectors to be fit during training, while Johnson and Zhang (2014) use fixed, one-hot encodings for each word. By contrast, Kim (2014) initializes word vectors to those estimated via the word2vec model trained on 100 billion words of Google News (Mikolov et al., 2013); these are then up-dated during training. Initializing embeddings to pre-trained word vectors is intuitively appealing be-cause it allows transfer of learned distributional se-mantics. This has allowed a relatively simple CNN architecture to achieve remarkably strong results. Many pre-trained word embeddings are now read-ily available on the web, induced using different models, corpora, and processing steps. Different embeddings may encode different aspects of lan-guage (Pad  X  o and Lapata, 2007; Erk and Pad  X  o, 2008; Levy and Goldberg, 2014): those based on bag-of-words (BoW) statistics tend to capture associations ( doctor and hospital ), while embeddings based on dependency-parses encode similarity in terms of use ( doctor and surgeon ). It is natural to consider how these embeddings might be combined to improve NLP models in general and CNNs in particular. Contributions. We propose MGNC-CNN, a novel, simple, scalable CNN architecture that can accom-modate multiple off-the-shelf embeddings of vari-able sizes. Our model treats different word em-beddings as distinct groups, and applies CNNs in-dependently to each, thus generating corresponding feature vectors (one per embedding) which are then concatenated at the classification layer. Inspired by prior work exploiting regularization to encode struc-ture for NLP tasks (Yogatama and Smith, 2014; Wal-lace et al., 2015), we impose different regularization penalties on weights for features generated from the respective word embedding sets.
 Our approach enjoys the following advantages com-pared to the only existing comparable model (Yin and Sch  X  utze, 2015): (i) It can leverage diverse, read-ily available word embeddings with different dimen-sions, thus providing flexibility. (ii) It is compar-atively simple, and does not, for example, require mutual learning or pre-training . (iii) It is an order of magnitude more efficient in terms of training time. Prior work has considered combining latent repre-sentations of words that capture syntactic and se-mantic properties (Van de Cruys et al., 2011), and in-ducing multi-modal embeddings (Bruni et al., 2012) for general NLP tasks. And recently, Luo et al. (2014) proposed a framework that combines mul-tiple word embeddings to measure text similarity, however their focus was not on classification. More similar to our work, Yin and Sch  X  utze (2015) proposed MVCNN for sentence classification. This CNN-based architecture accepts multiple word em-beddings as inputs. These are then treated as sepa-rate  X  X hannels X , analogous to RGB channels in im-ages. Filters consider all channels simultaneously. MVCNN achieved state-of-the-art performance on multiple sentence classification tasks. However, this model has practical drawbacks. (i) MVCNN re-quires that input word embeddings have the same dimensionality. Thus to incorporate a second set of word vectors trained on a corpus (or using a model) of interest, one needs to either find embeddings that happen to have a set number of dimensions or to es-timate embeddings from scratch. (ii) The model is complex, both in terms of implementation and run-time. Indeed, this model requires pre-training and mutual-learning and requires days of training time, whereas the simple architecture we propose requires on the order of an hour (and is easy to implement). We first review standard one-layer CNN (which ex-ploits a single set of embeddings) for sentence clas-sification (Kim, 2014), and then propose our aug-mentations, which exploit multiple embedding sets. Basic CNN. In this model we first replace each word in a sentence with its vector representation, result-ing in a sentence matrix A  X  R s  X  d , where s is the (zero-padded) sentence length, and d is the dimen-sionality of the embeddings. We apply a convolu-tion operation between linear filters with parameters w 1 , w 2 ,..., w k and the sentence matrix. For each w ter i across A , considering  X  X ocal regions X  of h ad-jacent rows at a time. At each local region, we per-form element-wise multiplication and then take the element-wise sum between the filter and the (flat-tened) sub-matrix of A , producing a scalar. We do this for each sub-region of A that the filter spans, re-sulting in a feature map vector c i  X  R ( s  X  h +1)  X  1 . We can use multiple filter sizes with different heights, and for each filter size we can have multiple fil-ters. Thus the model comprises k weight vectors w 1 , w 2 ,... w k , each of which is associated with an instantiation of a specific filter size. These in turn generate corresponding feature maps c 1 , c 2 ,... c k with dimensions varying with filter size. A 1-max pooling operation is applied to each feature map, extracting the largest number o i from each feature map i . Finally, we combine all o i together to form a feature vector o  X  R k to be fed through a softmax function for classification. We regularize weights at this level in two ways. (1) Dropout , in which we randomly set elements in o to zero during the train-ing phase with probability p , and multiply p with the parameters trained in o at test time. (2) An l2 norm penalty, for which we set a threshold  X  for the l2 norm of o during training; if this is exceeded, we rescale the vector accordingly. For more details, see (Zhang and Wallace, 2015).
 MG-CNN. Assuming we have m word embeddings with corresponding dimensions d 1 ,d 2 ,...d m , we can simply treat each word embedding independently. In this case, the input to the CNN comprises mul-tiple sentence matrices A 1 , A 2 ,... A m , where each A l  X  R s  X  d l may have its own width d l . We then ap-ply different groups of filters { w 1 } , { w 2 } ,... { w independently to each A l , where { w l } denotes the set of filters for A l . As in basic CNN, { w l } may have multiple filter sizes, and multiple filters of each size may be introduced. At the classification layer we then obtain a feature vector o l for each embed-ding set, and we can simply concatenate these to-gether to form the final feature vector o to feed into the softmax function, where o = o 1  X  o 2 ...  X  o m . This representation contains feature vectors gener-ated from all sets of embeddings under considera-tion. We call this method multiple group CNN (MG-CNN). Here groups refer to the features generated from different embeddings. Note that this differs from  X  X ulti-channel X  models because at the convo-lution layer we use different filters on each word em-bedding matrix independently, whereas in a standard multi-channel approach each filter would consider all channels simultaneously and generate a scalar from all channels at each local region. As above, we impose a max l2 norm constraint on the final feature vector o for regularization. Figure 1 illustrates this approach.
 MGNC-CNN . We propose an augmentation of MG-CNN, Multi-Group Norm Constraint CNN (MGNC-CNN), which differs in its regularization strategy. Specifically, in this variant we impose grouped reg-ularization constraints, independently regularizing subcomponents o l derived from the respective em-beddings, i.e., we impose separate max norm con-straints  X  l for each o l (where l again indexes em-bedding sets); these  X  l hyper-parameters are to be tuned on a validation set. Intuitively, this method aims to better capitalize on features derived from word embeddings that capture discriminative prop-erties of text for the task at hand by penalizing larger weight estimates for features derived from less dis-criminative embeddings. 4.1 Datasets Stanford Sentiment Treebank Stanford Sentiment Treebank (SST) (Socher et al., 2013). This concerns predicting movie review sentiment. Two datasets are derived from this corpus: (1) SST-1 , containing five classes: very negative , negative , neutral , posi-tive , and very positive . (2) SST-2 , which has only two classes: negative and positive . For both, we re-move phrases of length less than 4 from the training set. 1 Subj (Pang and Lee, 2004). The aim here is to classify sentences as either subjective or objective . This comprises 5000 instances of each. TREC (Li and Roth, 2002). A question classification dataset containing six classes: abbreviation , entity , descrip-tion , human , location and numeric . There are 5500 training and 500 test instances. Irony (Wallace et al., 2014). This dataset contains 16,006 sentences from reddit labeled as ironic (or not). The dataset is imbalanced (relatively few sentences are ironic). Thus before training, we under-sampled negative in-stances to make classes sizes equal. Note that for this dataset we report the Area Under Curve (AUC), rather than accuracy, because it is imbalanced. 4.2 Pre-trained Word Embeddings We consider three sets of word embeddings for our experiments: (i) word2vec 2 is trained on 100 billion tokens of Google News dataset; (ii) GloVe (Pen-word-word co-occurrence statistics from Common Crawl (840B tokens); and (iii) syntactic word embedding trained on dependency-parsed corpora. These three embedding sets happen to all be 300-dimensional, but our model could accommodate ar-bitrary and variable sizes.
 We pre-trained our own syntactic embeddings fol-lowing (Levy and Goldberg, 2014). We parsed the ukWaC corpus (Baroni et al., 2009) using the Stanford Dependency Parser v3.5.2 with Stanford Dependencies (Chen and Manning, 2014) and ex-tracted (word, relation+context) pairs from parse trees. We  X  X ollapsed X  nodes with prepositions and notated inverse relations separately, e.g.,  X  X og barks X  emits two tuples: (barks, nsubj dog) and that appear fewer than 100 times, resulting in  X  173k words and 1M contexts. We trained 300d vectors us-4.3 Setup We compared our proposed approaches to a stan-dard CNN that exploits a single set of word em-beddings (Kim, 2014). We also compared to a baseline of simply concatenating embeddings for each word to form long vector inputs. We re-fer to this as Concatenation-CNN C-CNN . For all multiple embedding approaches (C-CNN, MG-CNN and MGNC-CNN), we explored two com-bined sets of embedding: word2vec+Glove, and word2vec+syntactic, and one three sets of embed-ding: word2vec+Glove+syntactic. For all models, we tuned the l2 norm constraint  X  over the range { tiations of MGNC-CNN in which we exploited two embeddings, we tuned both  X  1 , and  X  2 ; where we used three embedding sets, we tuned  X  1 , X  2 and  X  3 . We used standard train/test splits for those datasets that had them. Otherwise, we performed 10-fold cross validation, creating nested development sets with which to tune hyperparameters. For all exper-iments we used filters sizes of 3, 4 and 5 and we created 100 feature maps for each filter size. We applied 1 max-pooling and dropout (rate: 0.5) at the classification layer. For training we used back-propagation in mini-batches and used AdaDelta as the stochastic gradient descent (SGD) update rule, and set mini-batch size as 50. In this work, we treat word embeddings as part of the parameters of the model, and update them as well during training. In all our experiments, we only tuned the max norm constraint(s), fixing all other hyperparameters. 4.4 Results and Discussion We repeated each experiment 10 times and report the mean and ranges across these. This replication is important because training is stochastic and thus introduces variance in performance (Zhang and Wal-lace, 2015). Results are shown in Table 1, and the corresponding best norm constraint value is shown in Table 2. We also show results on Subj , SST-1 and SST-2 achieved by the more complex model of (Yin and Sch  X  utze, 2015) for comparison; this represents the state-of-the-art on the three datasets other than TREC.
 We can see that MGNC-CNN and MG-CNN al-ways outperform baseline methods (including C-CNN), and MGNC-CNN is usually better than MG-CNN . And on the Subj dataset, MG-CNN ac-tually achieves slightly better results than (Yin and Sch  X  utze, 2015), with far less complexity and re-quired training time (MGNC-CNN performs com-parably, although no better, here). On the TREC dataset, the best-ever accuracy we are aware of is 96.0% (Mou et al., 2015), which falls within the range of the result of our MGNC-CNN model with three word embeddings. On the irony dataset, our model with three embeddings achieves 4% improve-ment (in terms of AUC) compared to the baseline model.
 On SST-1 and SST-2 , our model performs slightly worse than (Yin and Sch  X  utze, 2015). However, we again note that their performance is achieved using a much more complex model which involves pre-training and mutual-learning steps. This model takes days to train, whereas our model requires on the or-der of an hour.
 We note that the method proposed by Astudillo et al. (2015) is able to accommodate multiple embed-ding sets with different dimensions by projecting the original word embeddings into a lower-dimensional space. However, this work requires training the op-timal projection matrix on laebled data first, which again incurs large overhead.
 Of course, our model also has its own limitations: in MGNC-CNN, we need to tune the norm constraint hyperparameter for all the word embeddings. As the number of word embedding increases, this will in-crease the running time. However, this tuning pro-cedure is embarrassingly parallel. We have proposed MGNC-CNN: a simple, flexible CNN architecture for sentence classification that can exploit multiple, variable sized word embeddings. We demonstrated that this consistently achieves bet-ter results than a baseline architecture that exploits only a single set of word embeddings, and also a naive concatenation approach to capitalizing on multiple embeddings. Furthermore, our results are comparable to those achieved with a recently pro-posed model (Yin and Sch  X  utze, 2015) that is much more complex. However, our simple model is easy to implement and requires an order of magnitude less training time. Furthermore, our model is much more flexible than previous approaches, because it can accommodate variable-size word embeddings. This work was supported in part by the Army Re-search Office (grant W911NF-14-1-0442) and by The Foundation for Science and Technology, Portu-gal (grant UTAP-EXPL/EEIESS/0031/2014). This work was also made possible by the support of the Texas Advanced Computer Center (TACC) at UT Austin.
