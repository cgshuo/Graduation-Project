 1. Introduction
The user interface for a data capture tool is typically designed to be easy to use by users who are knowl-edgeable in the application domain. For example, a great deal of effort goes into making sure that the user interface of medical software can be understood by clinicians and other medical staff. However, if the same users want to run queries over the data that is captured by this software, there are generally only two options available: have someone write a special query interface, or use SQL to express queries against the database schema. The first option requires developer time and effort, and the second option presents two challenges: (1) the user must learn SQL and (2) the user must understand the semantics of the data based on the structure and names that appear in the schema (perhaps with additional documentation, e.g., in a data dictionary). It is possible for someone to be well-versed in clinical terminology and medical procedure, but not have the skill to use SQL. More than that, the physical database, as described in the schema, may bear little resemblance to the structure and names of the data fields as they appear in the user interface. We would like to leverage the effort that goes into making useful user interfaces to create a query interface that can be used by expert users.
Our research has two primary goals. First, we want to use the user interface of the software tool that creates the data directly as the conceptual model for users, and allow the users to express queries against the resulting conceptual model. Second, we want to provide a mechanism that accommodates a broad range of physical database designs but hides that complexity from the users of the new query interfaces. Our GUi As View (Guava) framework achieves both of these goals by allowing users to pose queries effectively against the user interface and then rewriting the query into an equivalent form that one can execute against the physical database.

In this paper, we introduce the Guava conceptual model, describe how Guava creates a query interface and processes queries, and formally define the transformation operators that can appear in the channel. The remainder of this paper is organized as follows. Section 2 provides the motivation for this work. The Guava framework and conceptual model is presented in Section 3 . The process for writing queries in Guava is described in Section 4 . Section 5 formally defines the transformation channel, the Guava artifact that handles all communication between the user interface (and query interface) and the underlying database. Section 6 introduces ways to extend the channel as well as make it more efficient. Section 7 briefly discusses related work, and the paper concludes with a discussion of contributions and future work in Sections 8 and 9 , respectively. 2. Motivation
The development of Guava is motivated by our work with the Clinical Outcomes Research Initiative (CORI) [1] . CORI seeks to improve the practice of endoscopy by conducting retrospective studies on de-iden-tified patient data (i.e., endoscopy reports). To this end, CORI develops and distributes a software reporting tool that allows the clinician to enter data that describes endoscopic procedures and then generates endoscopy reports suitable for inclusion in the patient medical record. Endoscopy reports from nearly 70 sites across the US are being compiled by CORI in a data warehouse on an ongoing basis.

CORI supports a number of data analysts who conduct various retrospective studies. A retrospective study is an attempt to study data that has already been collected for other purposes  X  in this case, the reports that have been collected through the CORI software by physicians over the course of patient care. Each study requires that the analyst select an appropriate subset of the reports in the warehouse, classify the source data for analysis in a statistical package.

Before they can perform a study over the data in a data warehouse, the analyst must first understand the data and schema. Understanding a database can be arbitrarily difficult, and the CORI warehouse is no excep-tion; the database was designed for speed and space concerns and not human readability. The table and col-umn names do not give hints as to the meaning of their contents. The analysts have a data dictionary that was written by a database developer, but that developer has long since left the organization. The dictionary has long been neglected and now no longer reflects the contents of the warehouse, and none of the current devel-opers have the expertise, time, or specific knowledge about the warehouse to update it.

There are two additional reasons why it is difficult for the CORI analysts to query the data. One is that the native format of the data in the CORI software X  X  database is in a generic format, where all data is stored as key-attribute-value triples, and where data that corresponds to a number of different entity classes are stored make it useful to the studies. Pivoting refers to the process of taking data out of a generic layout and into the more familiar structure where attribute names are part of the schema (columns) rather than in the data. The situation where a schema is generic but the desired schema is not is called schematic heterogeneity [8] . Some effort [6] has been devoted to adding features to the SQL query language that support higher-order functions such as variables that range over columns or tables. The resulting language solves the schematic heterogeneity problem, but is difficult for database experts  X  let alone ordinary users  X  to master.

The second problem encountered by the analysts is that the data in the CORI database is encoded. Some integer, such as  X  X 0 X  X , representing the index of a radio list or drop-down. For another example, the database stores a single integer that was the bitmask of the values of many Boolean values, such as the answers to a collection of checkboxes. Thus, the structure of the data and schema in the CORI database differs significantly from what the analysts need to perform studies.

To solve these problems, the same expert that put together the original data dictionary also assembled a program that separated and pivoted the data into tables in a non-generic format and decoded some of the data, as well as filtered out any records that contained errors. This program resulted in a data warehouse that the CORI analysts could use without needing to perform queries any more complicated than conjunctive que-ries. However, since the author of the program is no longer available and no one knows exactly how it runs  X  the exact semantics of that program are now lost. CORI would like to rewrite the program from scratch, but a fundamental problem still remains. CORI would be charging technical personnel  X  with no knowledge of how studies work  X  with the task of transforming and cleaning the data, two processes that can have profound impact on the data X  X  semantics.

In short, the CORI analysts suffer from the following problems that affect the efficiency of their work and the reliability of their studies:  X  the analysts need a comprehensive understanding of the contents of the data warehouse, but both the data and the schema are arcane,  X  the primary data repository has a generic data structure and encoded data values, which makes querying difficult, if not impossible, and  X  fixing either of the previous problems requires time from and communication with the development staff, and puts decisions that affect the semantics of the data in the hands of people who do not themselves run studies and thus may not appreciate the semantics.

The Guava architecture [14] solves these problems in two ways. First, Guava takes the original user inter-face for any forms-based application and creates a query interface that resembles it. We assume that, because
CORI analysts are domain experts and can understand clinical terminology, they can understand the data-entry forms in the CORI software. So, creating a query interface that looks just like the forms that the phy-sician used to enter the data gives the analyst an interface that can be learned quickly. Second, Guava allows developers and database professionals to express the relationship between two database schemas as a sequence of high-level operations, each with formal semantics. Unlike existing technologies such as Extract-Transform-
Load (ETL) [15] , these operations are bi-directional and can handle all traffic between a user interface and its physical database, allowing for flexibility in physical design while hiding the complexity from the analysts.
With Guava, analysts can knowledgeably perform queries without ever contacting technical personnel, regardless of the complexity of the physical database. 3. Introduction to guava and the conceptual model of the user interface
This section introduces the GUi As View (Guava) framework. As opposed to the typical case ( Fig. 1 a) where users must either use SQL or a custom, separately-designed query interface to access the data, the query
Guava automatically generates a g -tree from the user interface controls based on our extensions to an inte-grated development environment. Next, Guava translates a g -tree into a simple relational table structure with what we call a natural schema . Finally, a database designer can transform the natural schema into the underlying physical database schema by instantiating our database operators. A collection of these operators form a channel that transforms the natural schema into the desired physical schema (at DB design time) and transforms simple queries from the application-UI-based query interface from the natural schema to the phys-ical schema (at run time).

The Guava framework seeks to exploit the hierarchical nature of forms-based user interfaces to provide a simple representation of its information. Fig. 2 shows an example user interface that is hierarchical; the con-trols on each screen form a hierarchy based on the  X  X  X ontains X  X  relationship, and the forms of an application are structured as a hierarchy because each form is launched from an event on another, save for the form that button of the form on the left. Guava then uses this simple representation to create a query interface that resembles the original user interface. The rest of this section explains the steps that Guava uses to generate a g -tree.

A Guava-tree ( g -tree) represents the information present on a user interface, including the relationships between forms. Also of interest are the context elements for the controls, such as the control X  X  type (e.g., text box or checkbox), its default value, and its text. A control X  X  text may be simple to find for checkboxes and group boxes, where the text is simply part of the control, but is often harder to find for text boxes and drop-down lists where the text is actually in an adjacent label. These context elements are informative for any-one using the application, and for users that want to query the data.

Formally, a g -tree is a tree with a set of nodes N and a set of edges E such that:  X  Each n 2 N is labeled with one of the values Entity , Attribute , Container ,or Control .  X  Each n 2 N has an attribute Name whose value is unique in the tree.  X  Each n 2 N has a partial function h : String ) String that associates context element names with the value of that context element for the control.  X  Each e 2 E is labeled with one of the values Contains , Single-launch ,or Multiple-launch .
To illustrate the context element function h in action, consider the check box on the first form in Fig. 2 .It node associated with that check box, the function h is defined as follows:  X  h ( X  X  ControlText  X  X ) =  X  X  Procedure Completed  X  X   X  h ( X  X  DefaultValue  X  X ) =  X  X  False  X  X   X  h ( X  X  Size  X  X ) =  X  X (100,10) X  X   X  h ( X  X  Location  X  X ) =  X  X (10,90) X  X 
Each type of control supports its own set of context elements. Some context elements, such as size and loca-(in this case, text boxes).

In addition, every attribute node a in a g -tree has a domain, denoted as Domain ( a ). The domain of a can be one of the following:  X  Any subset of one of the standard atomic data type domains, including Boolean, Integer, Real, and String.  X  A reference to an entity node e , coupled with a view expression v . This relationship is denoted as Domain ( a )= EntitySet ( e ).
 The view expression v produces a string representation of an entity. Formally, v is a function v : Nodes !
String that takes as input a subset of the attribute nodes that are descendants of an entity node (without going through another entity node) and produces a user-friendly representation of the referenced entity. For instance, if the view expression is the function v ( FirstName , LastName )= X  X  LastName , FirstName  X  X , then in that control you will see values that look like  X  X  X homas, Bob X  X  when in fact the control stores an arcane object ID value referencing a row in another table.

We also define the following useful functions over g -trees:  X  For any g -tree g , rootnode ( g ) is the root node of the g -tree. tually, since n represents a control on a form, Entity ( n ) is the node corresponding to that form. By defini-tion, Entity ( n )= n if n is an entity node.  X  For any entity node e , Attributes ( e ) is the collection of attribute nodes that are descendants of e without following a path through another entity node. Conceptually, since e represents a form, Attributes ( e ) repre-sents all of the controls on that form that display data elements. e is the root node of a g -tree.

Translating a user interface into a g -tree is straightforward. Each form in the user interface becomes an entity node, each data-bound control becomes an attribute node, each container control (such as a group box) becomes a container node, and everything else becomes a control node. The name of each node is derived from the name the developer gives the control in the application code. If one form or control c another control c 2 (e.g., a group box containing a text box), a Contains edge is drawn from the node for c to the node for c 2 . If a control launches another form, but the new form merely contains more details about the first form, a Single-Launch edge is drawn from the control to the form. If, instead, the new form allows creation of several instances for each instance of the first form, a Multiple-Launch edge is drawn.
Fig. 3 shows the g -tree that corresponds to the UI in Fig. 2 . The parent form turns into the root of the tree, its group boxes are its children, and the controls in the group boxes become child nodes of the group box nodes. The child form also becomes a node, and is a child node of the control that launched it. The edge is labeled as single-launch because the child and parent forms share a one-to-one relationship; there is no new/edit/delete functionality in the parent form and only a single button launches the form.
Notice that not every g -tree corresponds to a working user interface. For instance, a single-launch edge leading to an attribute node does not make sense, because that implies clicking a button launches a text box or a checkbox, not another form. We define a g -tree to be valid if it satisfies these properties:  X  The root node of the tree is of type Entity .  X  The in-edge for all non-root Entity nodes is of type Single-launch or Multiple-launch .  X  The in-edge for all non-Entity nodes is of type Contains .  X  The out-edges for all Entity nodes are of type Contains .

In Guava, we generate what we call a natural schema , a relational schema where each form corresponds to a single table using the following algorithm:
Algorithm 1. To translate a valid g -tree ( N , E ) into its natural database schema:  X  For each Entity node n 2 N , create a table with name n . Name , and add a column called id , an artificially-generated primary key.  X  For each Entity node n 2 N that is not the root node, let p = Parent ( e ). If n  X  X  in-edge is of type Single-a new column ( n . Name ). fk and a foreign key from the new column to ( p . Name ). id .  X  For each Attribute node a 2 N , let p = Entity ( a ). Create a column named a . Name in p  X  X  table. If a has domain EntitySet ( e ) for some node e , then set the new column X  X  domain to be the domain of artificially-generated keys, and create a foreign key from a to e . id . Otherwise, set the domain of the new column to Domain ( a ).

Fig. 4 a shows the result of running Algorithm 1 on the g -tree in Fig. 3 , and is consequently the natural schema corresponding to the forms in Fig. 2 . The natural schema can also serve as the schema of the under-lying physical database; however, it is more likely that the schema on disk will be significantly different, to accommodate physical design issues such as retrieval and update speed. Fig. 4 b shows a possible physical data-base schema that contains the same data as Fig. 4 a, but after transformation by a channel, to be discussed in
Section 5 . 4. Queries in Guava
The Guava query interface is graphical in nature, and resembles the original interface very closely, as shown in Fig. 5 a. Because a g -tree contains all of the context information for an application, Guava uses it to gen-the forms just as they would the original user interface. The user specifies which attributes to return by right rows by filling in data into the various data fields, similar to QBE [19] . Unlike QBE, the user does not need to specify any kind of join conditions, since the joins are implied by the relationships between forms. This inter-text of the forms or in a table.

Other query interfaces are also possible, such as one that exposes the controls in an entire application in a single tree as shown in Fig. 5 b, so long as the context elements for each node are available to the user. The the box next to that control X  X  name in the tree. The context of each control, as well as the interface to specify conditions, can be viewed in a separate window. The user can also search the tree for data controls; the inter-face takes a search term and finds all occurrences of the term in the context elements for each control. The interface highlights and expands each matching control, and lists the context elements that matched the term.
Guava takes the query as specified by the user and translates it into relational algebra against the natural schema. The first step in this process is to accumulate the query into a data structure.

Definition. A decorated g -tree is a g -tree where, to each entity and attribute node, we attach two additional pieces of data:  X  A boolean value Print representing the user X  X  decision to return the value of the attribute (or ID for the entity), similar to the print flag in QBE.  X  A boolean function Condition in the form of Node h Value where Value is any constant value, Node is the current node, and h is any of the standard six comparison operators. The function can also be a conjunction of such expressions, or True to indicate that there is no filter for that node.

Intuitively, Guava constructs a decorated g -tree by taking the specified print statements and filtering con-ditions from the query interface and attaching them to the node in the g -tree representing the control on which they were found. We construct the formal definition of a query in the Guava architecture as follows: is anything other than  X  X  true  X  X .

Definition. A Guava query over a g -tree g is a forest of g-subtrees of g where all of the following is true: (1) One of the g -trees g is set aside as a  X  X  X istinguished X  X  tree, and g is pruned. (2) Every other tree t in the forest can be associated with an attribute node a in another tree where (3) No two trees are associated with the same attribute node in the same tree. (4) The associations between trees forms a tree. In other words, if we were to take each associated attri-(5) At least one of the nodes in the forest has a boolean print value set to  X  X  X rue X  X .

In addition, the query also provides a function U that takes entity nodes in the forest and maps them to a unique name. We need this function because the subtrees in the forest may overlap, so we need some way to disambiguate different instances of the same entity nodes.
 rated g -tree, q is the relational renaming operator and V is the conjunction of all boolean condition expres-sions in Attributes ( e ) and that of e itself. With this machinery in place, we can translate a Guava query into relational algebra.

Algorithm 2. To translate a Guava query q over g -tree g into relational algebra expressed against the natural schema of g : (1) Begin with the root node r of the distinguished g -subtree in the query. Set TQ = SingleTableQuery ( r ). (2) Also, if Print ( r )= True , set TP ={ U ( r ). ID }. Otherwise, set TP = ; . (3) Traverse the subtree in depth-first fashion, visiting the children of each node in any order. (4) For each entity node e found with a Single-Launch in-edge, set TQ = TQ ffl (5) For each entity node e found with a Multiple-Launch in-edge, set TQ = TQ ffl (6) For each entity node e found with Print ( e )= True , set TP = TP [ { U ( e ). ID }. (7) For each attribute node a found that is associated with another g -subtree with root node e by relation-(8) For each attribute node a found with Print ( a )= True , set TP = TP [ { U ( Parent ( a )).( a . Name )}. (9) Once traversal of the entire forest is complete, return p
By construction, we see that the resulting query language is equivalent to relational algebra restricted to the following:  X  T for any table in the natural schema  X  Exp 1 ffl Exp 2 only if there is a foreign key from Exp 2to Exp 1  X  p C ( Exp ) for any collection of columns  X  r C h V ( Exp ) for any column C , value V , and comparator h
In other words, the Guava query language is equivalent in expressive power to single-statement conjunctive queries where joins are restricted to foreign keys and selection can use any of the six comparators to relate a column against a constant, but not a column against another column. 5. Guava channels: formal foundations
The Guava back-end allows queries expressed against the natural schema to be processed against an under-lying physical database whose schema may be different. Our approach is to define database transformation operators that allow a database designer the freedom to structure the physical database as he or she chooses.
In the formal definition that we present here, instances of these operators provide automatic generation of the physical database schema, as well as automatic translation of the data input from the user interface for storage in the physical database. The operators are invertible, so they also describe how to translate the physical data back into the natural schema to make it available for query processing.

Table 1 lists the transformation operators that Guava provides, with a short description. The parameters required to instantiate each database transformation operator are present in Table 2 . Table 3 formally describes how each operator transforms a schema and an instance of a database. Each operator takes a schema or database instance as input, and produces a schema or database instance as output. The operator definitions use the following notation:  X  Tables : The set of tables in the schema  X  Cols ( T ): The set of columns in the schema for table T  X  inst ( T ): The instance of table T  X  Name ( D ): The name of the column or table D , returned as a data value  X  A subscript of  X  X  X n X  X , such as inst in , refers to the input of the operator  X  A subscript of  X  X  X ut X  X , such as inst out , refers to the output of the operator  X  Anything in boldface is a set  X  LOJ refers to a left-outer join
The operators defined in Table 3 have an inverse operator, as shown in Table 4 . A DB designer can specify the sequence of operators necessary to transform the natural schema associated with the user interface into the stored DB. Once the sequence of transformation operators is specified, we show that the stored database instance can be transformed into an instance of the natural schema, using the sequence of inverse operators in reverse order.

Definition. A cell is an instantiation of a database operator with specific input parameters provided. A cell includes an instantiation of the operator X  X  inverse. As shown in Table 4 , some parameters for the inverse operator in a cell are taken from the input parameters to the operator in this cell. Thus, a cell provides a mechanism to  X  X  X emember X  X  specific details of the original transform operator. For example, the HPartition to apply a cell in reverse is to apply the inverse operator.

Theorem 1. Given a cell with operator O from Table 1 with specific parameters P and the inverse operator O from Table 1 with parameters P 0 as shown in Table 4 ,S=O schema S and its instance D on which the operator O is valid. Note that O(P) (as well as O tiated operator that can then be applied to either a schema or an instance.

Proof. The claim is true for Apply and Rename because the particular functions (shown as f in Table 3 ) are invertible and defined for all input (from the natural schema). The fact that the claim is true for the remaining operators follows from their definitions in relational algebra as shown in Table 3 . h
Definition. A channel is a sequence of cells, as shown in Fig. 6 . We use the notation O inverse of O i ( P i ) (the inverse was shown as O 0 ( P 0
O 1 ( P 1 ), and C 1 = O 1 ( P 1 ) 1 ... O n ( P n ) 1 . We use the notation C (reverse) application of the cells in forward (reverse) order. Similarly, we use C the application of a forward or reverse data transformation. C is a valid channel for a schema S and instance
The following theorem guarantees that the original fully materialized natural schema is equivalent to the data returned from the physical database associated with a valid channel. This provides the foundation for query processing in Guava.

Theorem 2. Given a schema S with instance D, and a channel C that is valid on S and D, S  X  C
Proof. The proof follows from the fact that each cell in the channel represents an invertible function and the composition of invertible functions is invertible. Note, we expect that each operator in a channel to be total with respect to the input data that appear as input when using the channel in the forward direction. Thus, the function f used with the Apply operator must be defined for all values that can appear in the relevant attri-butes and the HPartition operator must have an input table name in Ts can appear in the column upon which the HPartition is based. h 6. Extending the Guava channel
The formal definition of a channel as described in the previous section assumes that there is a full database instance  X  whose schema is the natural schema  X  materialized somewhere, and that communication to and from the physical database is done an entire database instance at a time. More than that, each channel oper-ator materializes the entire database instance as well. This view of the channel works well for defining the semantics of each operator, but has serious practical limitations. For instance, it does not make sense to make a small update to the natural schema instance, then have that update propagate to the physical database by re-transforming the entire instance through the channel. Also, the operators listed in Tables 1 X 3 do not represent every possible transformation that one may want to perform between the UI and the physical database. We describe in this section the directions we are taking in implementing a channel in a prototype implementation.
In the first section, we describe how to implement the channel in a more efficient way; in the second section, we add new capabilities to the channel by defining new operators. 6.1. New channel pathways
If one looks at a typical forms-based application, communication between its user interface and its physical database generally consists of the following:  X  Retrieval of a small collection of data, for display in a single form  X  thus corresponding to a single row in one table in the natural schema.  X  Retrieval of a larger collection of data to match a search criteria, such as searching for patients by last name.  X  Inserts, updates, or deletes to information from a single form.

The first two of these actions take a query against the physical database, then take the data that is returned and transform it into a format for display in a form  X  in essence, putting the data into the natural schema. The third action is really like a single DML statement (e.g., INSERT) against the natural schema that the appli-cation middleware translates into (possibly multiple) DML statements against the physical schema.
With these use cases as motivation, we define a new schematic for a channel with three additional pathways ( Fig. 7 ). Unlike the previous version of the channel as shown in Fig. 6 , this version of the channel does not contain an inverse of each operator in each cell. Instead, the three new pathways (Update, Query, and Results) handle all communication between the natural schema and the physical database in both directions, so the inverse operators are not necessary. This version treats the natural schema as an updatable view of the data in the physical database. There may be some query results stored locally in the application while it is being viewed or updated, but for the most part, there is never a fully-materialized natural schema instance, nor a fully-materialized intermediate instance.

Our intent is to support queries, DDL and DML statements addressing the natural schema by modifying the query, DDL and DML statements in each cell. More than that, our goal is to do so on the inbound path (from the natural schema) as much as possible, requiring that the outbound results be transformed minimally in the cell if at all.

One new pathway through the five-pathway channel (marked as  X  X  X pdate X  X  in Fig. 7 ) takes updates in the form of DML or even DDL statements against the natural schema and translates them into DML or DDL against the physical database. In formal terms, if C data of a channel on an update statement, D is an instance of a database in the natural schema, and U is an update issued against D then we intend to prove:
The remaining pair of new pathways (marked as  X  X  X uery X  X  and  X  X  X esults X  X  in Fig. 7 ) works on queries and their results. The query pathway takes the relational algebra output from algorithm 2 as input, then transforms the query into a query over the physical schema. The result pathway then takes the query answer and transforms it into a result that is equivalent to having run the original query against the natural schema. Again, in formal terms, if C data is the action of a channel on data, C query of a channel on a query result, D is an instance of a database in the natural schema, and Q is a query against the natural schema, then we intend to show that:
These two properties ensure that the user sees the natural schema as if it were the real database, when it is in fact merely a view of the physical database. Property (1) says that an update against the natural schema will appear to the user as if the update were being performed on a materialized instance of the natural schema, when in fact Guava translates the update and runs it against the physical database. Property (2) guarantees that when the user issues a query against the natural schema, the answer appears to have been run against a materialize natural schema instance. Fig. 8 shows these two properties graphically.

For some database transformation operators, we are able to modify queries so that they deliver the query answer in the proper form without any additional processing of the results. For instance, the HMerge oper-additional processing necessary to make the query answer consistent with the original query, so the results pathway of HMerge does nothing.

However, other operators require some additional processing in the results pathway. The unpivot oper-ator is able to transform the query into an equivalent form using a number of left outer joins, but the of the unpivot operator in just one pass of the data, assuming the data is sorted; even with the sort pro-cedure, this algorithm can be orders of magnitude faster than the outer joins. So, in the case of unpivot, it is more efficient overall to produce a simpler query and allow the result pathway to process the result efficiently.
 The Apply operator may or may not require results processing, depending on the function it uses ( Fig. 9 c).
For such functions, the only way to produce an equivalent query result is to rely on the results pathway to transform the query answer by applying the inverse function on the data to produce the data that the user expects.

Our prototype of Guava implements the five-pathway channel. We are currently working on extending the definitions of the eight transformation operators to the update, query, and result pathways. 6.2. Semantic operators and the split channel
Consider the following actions:  X  Adorn: Add additional columns containing environment information, such as system time or user name, and specify whether these values are to be updated either any time the row is updated or only when the row is inserted.  X  Audit: Add temporal capabilities to the database, so that no information is ever deleted  X  rather than update or delete any rows, deprecate old rows and add new ones to reflect inserts and updates.  X  ColumnEquate: Assert that two different columns, possibly from different tables, always hold the same value, implying that one of the columns may be dropped without losing information.  X  TableAssert: Assert that the objects stored in one table are a subset of the objects in another table.  X  CheckConstraint: Define a condition that must be true before an instance of a form can be accepted/ committed.

These actions are considered part of the realm of business logic , which developers often consider a separate activity to user interface design, and thus possibly outside of the reach of Guava. However, it makes sense to model these actions as part of the channel because each of these actions alters schema, DML/DDL, queries and results just like the transformation operators. None of these actions can be represented using only the eight transformation operators in Table 1 . Thus, each of these actions can be considered as a new channel operator in its own right, with actions defined for all five pathways. We call these new actions semantic operators .

The semantic operators are also similar to the transformation operators in that they are invertible, though not in the same way. The transformation operators are closed under inverse according to Table 4 , meaning that the inverse of a transformation operator is also a transformation operator. The semantic operators are  X  X  X nvertible X  X  in the sense that they can be undone; for instance, Adorn can be undone by projecting away extra columns, and ColumnEquate can be undone by re-duplicating the column data in question. It is unlikely that the inverses of semantic operators should be allowed as channel operators. The  X  X  X nverse X  X  of Adorn is, effec-tively, the relational Project operator, which is lossy and not invertible on its own.

There is another major difference that separates the semantic from the transformation operators. The trans-formation operators are intended to be invisible to the users of both the user interface and the query interface.
Said another way, if two applications have the same user interface but different transformation operators in their channels, the user would not know the difference. The semantic operators, on the other hand, represent effect each of the semantic operators can have on the query interface. Because the semantic operators are visible in the query interface, their effects should not be undone in the same way as the transformation operators  X  another reason why we do not worry about inverting the operators at this time.

Fig. 10 gives an example where the Endoscopy table in the natural schema has been affected by three semantic operators  X  an Audit operator, an Adorn operator adding the value of the user name that created the entry, and a ColumnEquate on the Severity attribute stating that it holds the same value as the Recent
Outcome field in the Patient table. These three operators manifest themselves in the query interface, with the Audit and Adorn adding extra query fields and the ColumnEquate appearing as a help bubble that can be clicked to show the referenced form.

To allow for the semantic operators to affect the query interface while leaving the transformation operators hidden, we plan to split the channel into two segments: a visible segment that contains the semantic operators, and an invisible segment that contains the transformation operators. We place the visible segment closest to the natural schema to reduce the depth into the channel that one must search to find all such operators.
The final version of the channel, with all five pathways and split into two segments, is shown in Fig. 11 . 7. Related work
Our Pivot, Unpivot, HMerge, and HPartition operators are adapted from Lakshmanan, et al. [6] . Our work differs in its approach. Whereas SchemaSQL allows the user (i.e., the query writer) to express queries in the presence of schematic heterogeneity, Guava presents the user with a simple query language over a simple view of his or her data that mirrors a user interface. Guava then uses the transformations chosen during database design to transform the query and the query answer, as appropriate, including transformations that introduce schematic heterogeneity.

There are several approaches that model a user interface as a tree structure and view the associated data as an XML document, including XAML [16] , XUL [18] , and XForms [17] . These XML-based approaches are similar in spirit to Guava but they are limited to describing a single form at a time; there is no automated sup-port for describing the relationship among forms other than by using a programming language.
The Guava channel allows the database designer to describe how to transform a natural relational schema (that arises from the hierarchical g -tree) to other relational schemas. So Guava offers an approach different from the typical XML shredding approaches [4] to choosing a relational database schema to store XML data.
Rather than starting with the UI and generating the back end as Guava does, a Ruby on Rails scaffold [12] starts with the database and generates a UI that performs queries and updates. That is, Ruby on Rails makes it easy to start with what we call the natural schema and then generate a user interface. The Rails framework provides no support for schematic heterogeneity. One approach to application development would be to start with the natural schema and use Ruby on Rails (or a similar tool) to generate a user interface and then use Guava to generate the back-end.

Several projects have studied the relationship between forms and data. For instance, Rollinson and Roberts [11] describe how to represent the semantics of a forms-based interface in a conceptual modeling language.
The applications they consider are limited to ones where the UI and the database are closely related, perhaps even where the UI is semi-automatically generated from the database.

The Natural Forms Query Language [5] allows users to write forms that serve as the interface to an under-lying database, both for updates and for queries. The relationship between NFQL forms and the underlying database is established using name matching, vocabulary analysis and user-guided heuristics. With Guava, one can have far more difference between the structure of the forms and the database than NFQL; for instance, Guava can support a generic schema (using the unpivot operator) and a temporal database (using the audit operator). Also, Guava artifacts are generated from a UI implemented in various languages, allow-ing the developer the freedom to choose the UI implementation language.

In general, our Guava framework offers one approach to information transformation and is thus related to some aspects of the decades of work in information integration. We comment on a few specific efforts here.
Miller et al. [9] have considered ways to help the user identify mappings between data sources in the presence of schematic heterogeneity, e.g., by using data in various ways. In Guava, we are working in the context of a single database and we ask the database designer to generate the mappings by describing a channel. If two or more database systems had been designed using Guava and the user were able to indicate correspondences between two user interfaces, then perhaps we could exploit the definitions of the respective channels to con-struct the mapping between the two data sources.

Because the natural schema operates like a view over a physical database, Guava channels offer a new solu-tion to the view update problem [3] . Existing solutions, including new approaches [2] , usually focus on updates through views defined by SPJ queries. Guava does not have a channel operator that can do an arbitrary join.
However, some of the Guava operators, including pivot and unpivot, are not covered by the existing view update literature.
 Larson et al. [7] considered the problem of attribute and values equivalences extensively. We introduce the
Apply operator to handle attribute transformations. The COIN project [13] focuses on describing attributes with context elements, such as units. Guava captures context information about each user interface control, such as the label that appears on the screen. We do not focus specifically on the kind of context elements con-sidered in the COIN project, such as units for a value, but such context elements could be easily incorporated in Guava.

Guava offers an alternative to the classical extract-transform-load processing associated with a data ware-house [15] . In fact, Guava was motivated by the difficulties experienced by CORI analysts when trying to understand the data warehouse schema well enough to extract data for their queries. The contribution of
Guava is it allows users to express queries against the natural schema, with context elements from the user interface, rather than against the data warehouse schema.

Finally, our work is not addressing the problem of automatic schema matching [10] but perhaps suggests the possibility of trying to match user interfaces directly and then rely on the corresponding channels to deter-mine the mappings between schemas. Also, if we succeed in extending Guava to propagate user interface changes to the stored database schema, we will likely have a detailed description of how one schema (from an earlier version of the software) matches new versions. 8. Discussion
Guava hides the data transformation process from analysts, while simultaneously giving them powerful of the software, as the CORI analysts are, the query interface to the data will already be familiar. As a result, we expect that the time it takes to create and execute studies over data from a Guava application to be greatly reduced. By eliminating the developer from the study process, analysts can be sure that the data they see in a query result is exactly the data that was originally entered. We expect that this assurance, combined with being able to see the context of the data as it was entered, will translate into analysts being able to provide study results that more closely match the necessary semantic and quality requirements of the studies in less time, which could then translate into results such as better patient care.

In addition to the time saved due to not being involved in the analysts X  querying processes, there are several additional ways that Guava reduces the burden on software developers. Some products, such as Ruby on
Rails [12] , save development time by creating an in-memory data access layer and semi-automatically creating links to the underlying database. Guava goes two steps further, first by automatically generating the data access layer (the natural schema) and second by giving much more flexibility in the relationship between that layer and the database. That flexibility comes in the form of pivots, application of functions, and semantic and temporal features offered by the operators. Thus Guava provides more of the plumbing that is necessary to create a data-centric application, and allows for more options for constructing the physical database. 9. Conclusions and future work
This paper defines the initial, formal framework for supporting Guava where we use the user interface, directly, as a conceptual model. The query interface, automatically created from the specification of the user interface, allows a user to create queries in a familiar environment similar to that of the original application.
Queries from the interface are translated into a subset of select-project-join relational algebra. The database operators, instantiated in a channel, precisely describe the transformations that take place between the natural schema and the desired, stored database schema. Using the channel, Guava allows users of both the original user interface and the query interface to interact with data without ever needing to know the structure of the physical data, providing logical data independence.

Our Guava implementation extends a subset of the forms controls in the Microsoft Visual Studio develop-ment environment to automatically generate the g -tree and corresponding natural schema. We are currently implementing the operators shown in Tables 3 and 5 in the channel. We are considering additional operators as necessary. We are also currently implementing a graphical channel builder tool.

We have defined the Guava query language, and are developing query optimization strategies. We are look-ing into ways that we can extend the expressive power of the query language to include arbitrary joins and set operators. We plan to develop a user-friendly interface that allows the user to express queries against a visual display that looks like the original user interface.

Although our work was prompted by the need to describe the relationship between the user interface and the stored, generic database typically used by forms-based reporting tools, we believe that the database oper-ators introduced here can be used more generally. As one part of that work, we will define the conditions under which a channel is valid for a particular schema and instance. We will formally define the operators defined in Table 5 as part of that work as well. Finally, we will consider how to modify the Guava framework to accommodate modifications to the UI. We hope to propagate the desired changes to the g -tree and its nat-ural schema through the channel to the physical database.
 Acknowledgements This work is supported in part by Collins Medical Trust, by DHHS NIH National Institute of Diabetes
Digestive and Kidney Diseases No. 5-R33-DK061778-03 awarded to Oregon Health &amp; Science University (OHSU), and by NSF grant No. 0534762.

References
