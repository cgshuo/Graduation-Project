 A group of friends located at their working places may want to plan a trip to visit a shopping center, have dinner at a restaurant, watch a movie at a theater, and then finally return to their homes with the minimum total trip distance. For a group of spatially dispersed users a group trip planning (GTP) query returns points of interests (POIs) of different types such as a shopping center, a restaurant and a movie theater that minimize the aggregate trip distance for the group. The aggregate trip distance could be the sum or maximum of the trip distances of all users in the group, where the users travel from their source locations via the jointly visited POIs to their indi-vidual destinations. In this paper, we develop both optimal and ap-proximation algorithms for GTP queries for both Euclidean space and road networks . Processing GTP queries in real time is a compu-tational challenge as trips involve POIs of multiple types and com-putation of aggregate trip distances. We develop novel techniques to refine the POI search space for a GTP query based on geomet-ric properties of ellipses, which in turn significantly reduces the number of aggregate trip distance computations. An extensive set of experiments on a real and synthetic datasets shows that our ap-proach outperforms the most competitive approach on an average by three orders of magnitude in terms of processing time. The proliferation of social networking sites enables friends and families to remain connected virtually at all times. Since physi-cal meetups are equally important for maintaining and fostering relationships, location-based social networking applications offer a range of services for groups such as finding a nearest meeting place or sending alerts if friends are nearby. In the near future, we envi-sion an application that would enable a group to plan a trip with the minimum aggregate trip distance for visiting multiple types of points of interests (POIs) such as a shopping center, a restaurant and a movie theater. Trip planning for a single user has been stud-ied in the literature [4, 13, 24] due to its wide range of applications. In this paper, we address group trip planing (GTP) queries and its variants that allow a group to compute a trip that minimizes the total or maximum travel cost for the group members.
 c  X 
Given a set of source-destination pairs for a group of users and their required types of POIs, a GTP query returns a POI for each type that together minimize the aggregate trip distance. The group may specify the order of visiting POI types (e.g., a restaurant after a shopping center) or keep it flexible. A group may be also inter-ested in finding k sets of POIs that provide the k smallest aggregate trip distances in order to select the set based on other parameters such as budget, food or movie preference. In this paper, we develop efficient algorithms for kGTP queries that apply to both Euclidean spaces and road networks.

The aggregate trip distance is the sum of the trip distances of all users in the group, where each user X  X  trip starts from the user X  X  source location, goes through POIs one after another, and ends at the user X  X  destination. Figure 1 shows an example of a GTP query for k = 1 in a road network, where a group of three users with their source destination pairs ( s 1 , d 1 ) , ( s 2 , d 2 (shown in blue lines) through two POIs ( p and q ) of different types, that minimizes the total travel distance. On the other hand, if group members use a shared vehicle to travel the common part of the trip via the POIs, the aggregate trip distance is the sum of the trip distance from the first to the last POI and the trip distances for each individual group member to travel from their source locations to the first POI and from the last POI to their destinations.
Sometimes a group member who is located far away from the other members in the group may need to travel a much longer dis-tance, if the POIs are close to other group members. In such a sce-nario, instead of minimizing the total travel distance, the group may want to find the set of POIs that minimize the maximum trip dis-tance for the group. Our k GTP algorithms work for all these vari-ants of aggregate functions, i.e., for minimizing both the total and maximum trip distance of a group.

A k GTP query has been introduced in [8], where the authors have developed k GTP algorithms for the Euclidean space . However, the developed algorithm in [8] requires significant time (17 minutes on commodity hardware) to find four trips by processing a single GTP query for only three types of POIs and with a group size of 8. Moreover, in a real-life scenario the movement of users is restricted to road networks and processing queries in road networks involve complex distance computations. It is not obvious to extend the al-gorithm in [8] for road networks. To overcome these limitations, we propose efficient algorithms that are one to three orders of magni-tudes faster than the algorithm in [8] and can evaluate k GTP queries in a few seconds for both Euclidean space and road networks .
The major challenge to process k GTP queries efficiently depends on identifying POIs from a huge POI database that minimize the aggregate trip distance. The key idea of our approach comes from efficient POI pruning strategies to limit the search space to a smaller elliptical area. We prove that the refined search space can be an el-liptical region with foci at two centroids of source and destination locations, respectively, and the major axis of the ellipse is equal to the average of computed k th smallest total trip distance for the initial POI set. The smaller search space only requires access to a small number of POIs, which reduces the number of aggregate distance computations and incurs less I/Os and computational cost. Though elliptical properties have been explored in the literature [4, 13, 14, 24, 28] to prune POIs, these pruning techniques are not ap-plicable for k GTP queries. We develop a novel pruning technique, which is the base to process k GTP queries in real time. Further, we propose an efficient aggregate trip distance computation technique by exploiting an optimal substructure property of trips.

Based on the developed elliptical punning strategies, we propose range-based and incremental algorithms to evaluate k GTP queries. The key difference between these two algorithms is in the way they retrieve POIs from the database. The range-based algorithm exe-cutes a range query to retrieve POIs within the elliptical search space and finds the optimal k GTP query answer from those re-trieved candidate POIs. On the other hand, the incremental k GTP algorithm retrieves the group nearest POIs with respect to two cen-troids of source and destination locations and gradually refines the search space. Specifically, with the incremental retrieval of a POI, the aggregate trip distance becomes smaller or remains same, and the elliptical search space whose major axis is equal to the average aggregate trip distance is updated; the search for POIs ends when all POIs within the elliptical region have been retrieved.
Computing the answer for a trip planning query has been shown as an NP-hard problem if the order of visiting POI types is not spec-ified [4, 13, 24]. For a large scale POI set and a large group size, our proposed optimal algorithms cannot compute answers for non ordered kGTP queries in a reasonable time. To further minimize the processing overhead in such a case, we propose an approxima-tion algorithm based on our incremental k GTP algorithm that can trade accuracy for efficiency. We develop a technique to derive the lower and upper bound of the accuracy for the computed k GTP an-swers. Using our approximation algorithm, the group can set any value for the approximation ratio, where an approximation ratio of 1 represents the exact query answer.

We have conducted extensive experimental study using both real and synthetic datasets. Our solutions outperform our benchmark approach by one to three orders of magnitude in terms of both pro-cessing and I/O overhead. Similar to other spatial query types [23], experiments show that our incremental approach performs better than the range based technique for k GTP queries.

In summary, the contributions of this paper are as follows: Query processing in spatial databases has been extensively stud-ied in the forms of nearest neighbor (NN), group nearest neigh-bor (GNN), route/path planning, and trip planning (TP) queries in both Euclidean space and road networks. Most of these techniques assume that POIs are indexed using R -tree [6] or its variant R tree [2]. A k NN query [11, 20] and a k GNN query [10, 18, 19, 25, 27] return k POIs that have the k smallest distances with respect to a single user and a group of users, respectively.

A GNN query is different from a GTP query as in a GNN query, group members meet at a single POI and the aggregate distance is measured with respect to the POI and current locations of group members, whereas in a GTP query, group members visit POIs of different types and the aggregate distance is measured with respect to POIs and sets of source and destination locations of group mem-bers. The minimum bounding method (MBM) proposed in [19] vis-its R -tree nodes in order of the minimum aggregate distance from all query points and only visits the nodes that may contain candi-date POIs. We use MBM for evaluating GNN queries in finding an initial set of POIs in our approach.

Generalized traveling salesman problems, trip and route plan-ning queries have been addressed in the literature [3, 4, 12, 13, 16, 17, 21, 22, 24, 26], where a single user visits POIs of different types with the minimum travel distance. Li et al. [13] have pro-posed approximation algorithms to find a trip that minimizes the total travel distance. In [24], Sharifzadeh et al. have developed al-gorithms to find a route with the minimum length passing through a set of POIs in a particular order from the source location of a user. Chen et al. [4] have proposed a multi-rule partial sequenced route (MRPSR) that provides a uniform framework to evaluate both of the above mentioned trip planning variants [13, 24]. All these exist-ing techniques assume a single user , and thus are not applicable for a group. Evaluating trips for each group members independently until k trips for the group with the k smallest aggregate trip dis-tances have been identified would be an exhaustive search on the database and incur extremely high processing overhead.

Recently, Hashem et al. [8] have proposed a method to compute k GTP queries in the Euclidean space. However, the proposed algo-rithm is not scalable and efficient enough to answer k GTP queries in real time (e.g., computing four best trips involving two POI types and 16 group members require 16 minutes on commodity hard-ware!). Another major limitation of their approach is that it uses in-dependent R -tree for each POI type, and a real California dataset [1] comprising of 63 categories require 63 different R -trees, which is not practical. Moreover, computing k GTP queries for a road net-work involve complex distance computations and thus we cannot extend the algorithm in [8] for road networks as it would make the query processing overhead even worse. In this paper, we propose an efficient solution that can evaluate a k GTP query and its variants in a few seconds for both Euclidean space and road networks.
The key idea of our efficient algorithm is the novel search space refinement technique based on geometric properties of ellipses. Though there exist pruning techniques [4, 13, 14, 24] that refine the search space as an elliptical area for other variants of spatial queries, the novelty of our technique is how we set foci and signif-icantly reduce the length of the major axis of the ellipse for pro-cessing k GTP queries. In [4, 13, 24], the authors simply show that any POI outside an ellipse with foci at the user X  X  source and desti-nation, respectively and the major axis equal to the user X  X  trip dis-tance based on retrieved POIs can be pruned. In [14], the authors refine the search space as an ellipse for GNN queries, where the foci are the locations of any two group members and the major axis equals to the smallest total distance of group members from retrieved POIs. Thus, the length of the major axis (i.e., the area of the ellipse) increases with the increase of the group size. We set the foci of the ellipse at geometric centroid of source and destination locations of group members, respectively and the length of the ma-jor axis as the average trip distance of group members, which is n (group size) times less than that of the state-of-the-art technique. Let O represent a set of POIs in a two-dimensional space, T = { t , t 2 ,..., t m } represent a set of m POI types, p t i represent the loca-tion of a POI of a type t i . For two point locations p and q , Function Dist ( p , q ) returns the distance between p and q , where the distance can be measured in the Euclidean space or road networks. The Eu-clidean distance is measured as the length of the line connecting p and q . On the other hand, the road network distance is measured as the length of the shortest path between p and q on a given road network G = ( V , E , W ) , where each vertex v  X  V represents a road junction, each edge ( u , v )  X  E represents a direct path connecting u and v , and each weight w u , v  X  W represents the length of the direct path represented by the edge ( u , v ) .

Let s i and d i represent source and destination locations, respec-tively, of a user u i . For a set of POIs of m types, { p the trip distance of a user u i is computed as Dist ( s  X  gregate functions SUM and MAX that minimize total and maximum trip distance of group members, respectively.

For an aggregate function f = SUM , the aggregate trip distance of a group U = { u 1 , u 2 ,..., u n } for a given set of POIs from m types, { p t 1 , p t 2 ,..., p t m } , vary depending on whether group mem-bers share a vehicle for the common part of the trip or not. If group members travel independently then the aggregate trip distance is computed as  X  n i = 1 Dist ( s i , p t 1 ) + n  X  (  X   X  i = 1 Dist ( p t m , d i ) . If group members share a vehicle for the com-mon part of the trip then the aggregate trip distance is computed as some of the group members share a vehicle for the common path or some part of the common path, the computation of the ag-gregate trip distance can be adjusted accordingly. On the other hand, for f = MAX , the aggregate trip distance is computed as max n i = 1 { Dist ( s i , p t 1 )+  X  m  X  1 j = 1 Dist ( p
The order of visiting POIs can be specified by the group. If the group fixes the order of visiting POIs, e.g., a shopping center be-fore a restaurant then a movie theater, then the query is called an ordered GTP query . If the order of visiting POIs is kept partially or fully flexible, e.g., a shopping center and a restaurant can be visited in any order, then the query is called a non ordered GTP query . For the ordered GTP query, the aggregate trip distance for a POI set consisting of a POI from each required type is computed accord-ing to the specified order, whereas for the non ordered GTP query, the aggregate trip distance is computed for every possible order of POI types, and the minimum of these aggregate trip distances is considered as the aggregate trip distance for the POI set.
A group may be interested in k trips and selects one based on other factors such as budget, or preference. A k GTP query is for-mally defined as follows: D EFINITION 1. ( k Group Trip Planning ( k GTP) Queries). Given a set of n source locations S = { s 1 , s 2 ,..., s responding destination locations D = { d 1 , d 2 ,..., d n members, a set of POI types T = { t 1 , t 2 ,..., t m } , an aggregate func-tion f , and k, the kGTP query returns k sets of POIs that have the k smallest values for aggregate trip distances, where each POI set includes m POIs { p t 1 , p t 2 ,..., p t m } , and the group members travel from their source locations via the jointly visited POIs to their in-dividual destinations.

Note that group members may use transports of varying speed and need different time to travel the same distance. In this paper, we assume that users who arrive earlier at any POI can wait for others and we leave the synchronization of users in terms of time as a future scope of our work. We assume a client-server architecture, where the client is the user that acts as a coordinator for the group and the server is the LSP that evaluates k GTP queries. Every group member sends her source and destination locations to the coordinator and the coordinator sends the query along with source and destination locations of the group members to the LSP. The coordinator communicates with the LSP via mobile networks or the Internet. The POIs are indexed using an R  X  -tree on the LSP X  X  database. An important benefit of our ap-proach is that it does not need any modification in the existing in-dexing methods used to process other types of spatial queries. The road network is maintained in a graph structure. The LSP evaluates the query and returns the answer to the coordinator, who forwards the answer to other group members. In this section, we propose optimal and approximation algorithms to process k GTP queries. The key idea comes from the refine-ment of the search space based on elliptical properties. We present two straightforward techniques (Lemmas 5.1 and 5.2) to refine the search space using multiple ellipses for an aggregate function SUM . The smaller search space causes less POI retrievals from the database and avoids the computation of trips through a large num-ber of POIs, which significantly reduces both I/O and computa-tional overhead. By exploiting geometric properties, we develop a novel and an efficient pruning technique (Lemma 5.4) to refine the search space to a single ellipse, where the foci of the ellipse are the centroids of the source and destination locations, respectively, and the major axis of the ellipse is equal to the average of k total trip distance computed based on current set of retrieved POIs from the database. Based on the proposed refinement of the search space, we develop our range based and incremental algorithms to process k GTP queries in Sections 5.1 and 5.2, respectively.
In our straightforward pruning techniques, the POI search space is refined using an individual or a total trip distance computed based on current set of retrieved POIs from the database. The following two lemmas refine the search space by integrating n individual el-lipses:
L EMMA 5.1. Let AT Dist [ k ] be the k th smallest total trip dis-tance of the group computed based on current set of retrieved POIs from the database, and E i represent an ellipse with foci at s d and the major axis equal to T Dist i [ k ] , where T Dist dividual trip distance of user u i in AT Dist [ k ] . A POI or an R node can be pruned if it is located outside  X  n i = 1 E i
P ROOF . Let a POI or an R  X  -tree node p be located outside i = 1 E i . According to elliptical property, since p is located outside E , the trip distance of each user u i via p , i.e., the trip distance from s to d i via p is greater than T Dist i [ k ] . Thus, the total trip distance of a group of n users via p is greater than  X  n i = 1 T Dist know AT Dist [ k ] &lt; =  X  n i = 1 T Dist i [ k ] . Thus p located outside  X  can be pruned as p cannot further minimize AT Dist [ k ] .
L EMMA 5.2. Let E i avg represent an ellipse with foci at s d and the major axis equal to AT Dist [ k ] n , where AT Dist [ k ] is the k smallest aggregate trip distance of the group computed based on current set of retrieved POIs from the database for f = SUM and n is group size. A POI or an R  X  -tree node can be pruned if the POI or the R  X  -tree node is located outside  X  n i = 1 E i avg
P ROOF . Let a POI or an R  X  -tree node p be located outside i = 1 E i avg . According to elliptical property, since p is located out-side E i avg , the trip distance of a user u i via p , i.e., the trip distance tance of a group of n users via p is greater than AT Dist [ k ] and can be pruned as p cannot further minimize AT Dist [ k ] .

Consider an example scenario for a group size n = 3, where { s , s 2 , s 3 } represent sources, { d 1 , d 2 , d 3 } represent destinations, and { p 1 , p 0 1 , p 2 } represent retrieved POIs from the database. Fig-ures 2 (a) and (b) use Lemmas 5.1 and 5.2, respectively to refine the search space. Any POI that falls outside of E E 1 avg  X  E 2 avg  X  E 3 avg can be safely pruned, as it cannot further min-imize the current aggregate trip distance for SUM . Note that we use Lemma 5.2 when the distance between every source-destination pair is less than or equal to AT Dist [ k ] / n .

Intuitively, if source destinations pairs are spread far away and the overlaps among the ellipses are small, then the integrated area of n ellipses may cover a large portion of the full space. To ad-dress this limitation, we develop an efficient technique to bound the search space using a single ellipse. In a straightforward way to refine the search space, we can select any source destination pair as foci and set the major axis length of the ellipse equal to the k total trip distance computed based on current set of retrieved POIs from the database. In this case, the length of the major axis would increase with the increase of group size and sparse distribution of source destination pairs. In this paper, we reduce the length of the major axis from the k th total trip distance to the average of the k total trip distance.

We first prove the geometric property stated in Lemma 5.3, and then use this property to give a tight bound for the refined search space in Lemma 5.4.

L EMMA 5.3. Let { l 1 , l 2 ,..., l n } represent a set of n locations, l the geometric centroid of { l 1 , l 2 ,..., l n } in the Euclidean space, p a POI or an R  X  -tree node, and Dist ( .,. ) return the Euclidean distance between two points. Then we have  X  n i = 1 Dist ( l i , p )  X  n  X  Dist ( l
P ROOF . Let ( x i , y i ) and ( x c , y c ) represent coordinates for a loca-tion l i and l c , respectively, in the two-dimensional space. Assume Figure 4: For aggregate function SUM , (a) POIs retrieval, (b) I/O, and (c) processing overhead for different bounds. that L be a line perpendicular to the line connecting l c passes through p . Without loss of generality, Figure 3 shows a sce-nario for n = 3. The distance from l i to L is denoted with d
Let the equation of the line L be: ax + by + c = 0, where a , b , and c are constants. Thus, d l i can be expressed as follows:
Since Dist ( l i , p )  X  d l i , when summing up for n distances, we have  X  Since Dist ( l c , p ) = 1  X  have  X  n i = 1 Dist ( l i , p )  X  n  X  Dist ( l c , p ) .

L EMMA 5.4. Let s c and d c represent geometric centroids for sets of source and destination locations { s 1 , s { d 1 , d 2 ,..., d n } , respectively, in the Euclidean space and AT Dist [ k ] represent k th smallest aggregate trip distance computed based on current set of retrieved POIs from the database for f = SUM . A POI or an R  X  -tree node can be pruned if the POI or the R  X  -tree node is located outside an ellipse E c avg whose foci are s c and d major axis is equal to AT Dist [ k ] / n.
 P ROOF . According to Lemma 5.3, for an arbitrary POI or an R -tree node p we have  X  n i = 1 Dist ( s i , p )  X  n  X  Dist ( s  X  i = 1 Dist ( d i , p )  X  n  X  Dist ( d c , p ) . When summing up, we have From elliptical property, we know that the distance between two foci via a point located outside the ellipse is greater than the length of the major axis of the ellipse. Thus for a POI or an R  X  p located outside of E c avg , we have Finally, from Equations 3 and 4, we have The aggregate trip distance can be measured in both Euclidean space and road networks. Lemma 5.3 assumes that Dist ( .,. ) func-tion returns Euclidean distance between two points. Thus, for Eu-clidean space, from Equation 5, we can conclude that a POI or an R -tree node p 0 located outside E c avg can be pruned as the aggre-gate trip distance via p 0 is greater than AT Dist [ k ] .
For road networks, AT Dist [ k ] is measured in terms of road net-work distance and the left part of Equation 5 represents Euclidean distance. According to Euclidean distance property, the road net-work distance between two points is greater or equal to the Eu-clidean distance of those points. Thus, Equation 5 also holds if Dist ( .,. ) function returns road network distance between two points and a POI or an R  X  -tree node p 0 located outside E c avg as it cannot further minimize AT Dist [ k ] .

In summary, according to Lemma 5.1, all POIs that are inside the boundary computed as the union of n ellipses with foci ( s and major axis T Dist i [ k ] , need to be considered in a k GTP query. According to Lemma 5.2, the POIs that are inside the boundary computed as the union of n ellipses with foci ( s i jor axis AT Dist [ k ] / n , need to be retrieved for k GTP computation. On the other hand, according to Lemma 5.4, we only need to re-trieve POIs that are inside the ellipse with foci ( s c , d axis AT Dist [ k ] / n . Figure 2(c) uses Lemma 5.4 to refine the search space. Thus, any of the three bounds (Lemma 5.1, Lemma 5.2, and Lemma 5.4) can be considered independently to refine the search region. Alternatively, one can use intersection region of all the three bounds to define the search region for candidate POIs for the an-swer of a k GTP query.
 We have performed an empirical study (Figure 4) on a retrieved POI set and observed that the number of POIs contained in the search region, and the required number of I/Os and time to retrieve these POIs, are much less for Lemma 5.4 (Bound 3) than the other two Bounds (Lemma 5.1-Bound 1 and Lemma 5.2-Bound 2). We have also observed that if we combine all three bounds (i.e., Bound 4), we see that the number of POIs retrieval and I/Os are approxi-mately equal for both Bound 3 and Bound 4 while Bound 4 incurs slightly higher processing overhead. So apparently, we gain no ben-efit using Bound 4 (all bounds combined) in terms of POIs and I/Os rather incur higher processing overhead. Hence, we use Lemma 5.4 (Bound 3) as our bound to refine the search space.

For f = MAX , Lemma 5.4 can be modified in terms of the length of the major axis, which is set to AT Dist [ k ] instead of AT Dist [ k ] / n. From Equation 3, we observe that the average trip distance of group members via any POI p , i.e., 1 n  X   X  n i = 1 ( Dist ( s i greater than or equal to Dist ( s c , p )+ Dist ( d c , p ) .
Since for a POI or an R  X  -tree node p 0 located outside E tance via p 0 is greater than or equal to the average trip distance of group members, the maximum trip distance via p 0 is greater than AT Dist [ k ] . Thus, p 0 can be safely pruned for both Euclidean space and road networks. Note that the k th maximum trip distance rep-resents an individual user X  X  trip distance whereas the k th distance represents the summation of trip distances of group mem-bers. Thus, increasing the length of the major axis from the average of the k th smallest total trip distance to the k th smallest maximum trip distance changes the area of the refined search region slightly. In our first approach, we propose a range query based optimal k GTP algorithm that works in three steps. First, the algorithm re-trieves a set of POIs using a heuristic. Second, based on the initial set of POIs, the algorithm refines the search space and executes a range query to retrieve POIs inside the refined search space. Finally, the algorithm applies a dynamic programming to find the optimal answer for a k GTP query from the reduced set of candidate POIs.
Algorithm 1 shows the steps of our range based algorithm for k GTP queries. The algorithm takes a set of n source locations S = { s 1 , s 2 ,..., s n } , n destination locations D = { d category set T = { t 1 , t 2 ,..., t m } , and the number of required small-est trips k . The output of the algorithm is a set A [ 1 .. k ] of trips with k smallest aggregate trip distances.

The algorithm first finds an initial set of POIs that includes at least k possible trips using Function FindInitialSet . For this pur-pose, any heuristic that retrieves POIs containing the required num-ber of trips can be applied. We use heuristics based on the group nearest neighbors of source and destination locations [8] to retrieve the initial POIs.

After retrieving the initial set IA of POIs, Function Re f ineSearch bounds the search space as a smaller region that includes POIs for k trips with the smallest aggregate trip distances. We use Lemma 5.4 for this purpose. Though for a non ordered k GTP query, Re f ineSearch considers different orders of POI types to determine the current k th smallest aggregate trip distance AT Dist [ k ] , intu-itively the probability is high that AT Dist [ k ] for a non ordered k GTP query would be smaller than that of an ordered k GTP query. Note that a smaller AT Dist [ k ] represents a smaller POI search space.
After deriving the required search space SA , the algorithm exe-cutes a range query by using Function RangeQuery and retrieves all POIs of required types specified in T = { t 1 , t 2 ,..., t inside the range SA . Finally, the algorithm runs a dynamic program-ming using Function Re f ineAnswer to find k trips with the k small-est aggregate trip distances from the retrieved set of POIs. Algorithm 1 : Range_ k GTP( S , D , T , k )
Re f ineAnswer runs a dynamic programming algorithm over the retrieved candidate POIs in CA to determine k POI sets with k smallest aggregate trip distances. For space constraint, we only dis-cuss the dynamic programming algorithm of ordered k GTP queries for f = SUM . A trip distance table M consisting of m columns (for m types) of cells (where each cell represents a POI) is maintained for this purpose. Each table cell M j t i stores k optimal partial trip dis-tances starting from source locations, visiting one POI of each type t (1  X  l &lt; i ) and ending at the POI p j t i , the j th POI of type t
For each POI p j t 1 , we calculate optimal distances as the sum of distances from all source locations to p j t 1 . Then for each POI p of intermediate columns, we calculate k optimal distances using stored optimal distances at column t i  X  1 of M and distances of p from POIs of type t i  X  1 . We keep k minimum such distances. Finally, for each POI p j t m at the last column, we compute k optimal distances using three distances: (i) stored optimal distances at column t (ii) distances of p j t m from POIs of type t m  X  1 , and (iii) distance of p m from all destination locations. Finally, we select k optimal trip distances among all trip distances of last column POIs.

For non ordered k GTP queries for f = SUM , the above process is repeated for every possible set of order types and thus, cannot compute the answer in reasonable time for a large scale POI dataset and a large group size. To overcome this limitation, we develop an incremental k GTP algorithm that can compute both exact and approximate answers with reduced processing overhead. We develop an incremental algorithm to evaluate k GTP queries. The algorithm updates the refined POI search space with the in-cremental retrieval of POIs until the k GTP query answer has been identified. Since the refined search space continuously decreases or remains same, this incremental approach only accesses neces-sary POIs that are required to find the optimal answer, whereas, the range based approach may need to access some extra POIs because the required search space is bounded based on an initial POI set. An additional benefit of our incremental algorithm is that it can also approximate k GTP query answers with accuracy guarantee. When POI dataset and group size are large, an approximation algorithm is a good choice for processing non ordered k GTP queries (an NP hard problem) with reduced processing overhead.

The algorithm allows a group to specify the required bound for the accuracy according to the requirement of the group. For exam-ple, if users specify that they are happy with a trip taking at most 20% more travel distance than the optimal trip, then the algorithm stops as soon as they satisfy the answer with the required quality specified by the user. We define accuracy meter Q as the ratio of upper bound and lower bound of the k th smallest aggregate trip distance. For example, if the optimal aggregate trip distance for a group is 100 and users want the guarantee that their reported an-swer should not be higher than 150, then they will set Q as 1.5. If Q = 1, the algorithm returns optimal k GTP answers. The algorithm incrementally retrieves group nearest POIs with re-spect to source centroid s c and destination centroid d c d are computed as  X  n i = 1 s i / n and  X  n i = 1 d i / n , respectively. We com-pute the k th smallest aggregate trip distance AT Dist [ k ] from the set of already retrieved POIs from the database, which act as an upper bound of the k th smallest aggregate trip distance computed on all POIs in the database.

On the other hand, to compute the lower bound of the k th aggregate trip distance, we exploit the available information from the already retrieved group nearest POIs with respect to s Without loss of generality, assume that at any stage of the execution of the algorithm, j group nearest POIs with respect to s c have been retrieved. Assume that E j represents an ellipse with foci s and d c and the major axis equal to d min ( p ) , i.e., the distance from s to d c via the j th group nearest POI p . At this stage of execution, we know locations of all POIs inside E j as the distance from s d via any POI inside E j is less than the length of the major axis of E and has been already retrieved from the database before p .
According to Lemma 5.4, we can infer that the aggregate trip distance for S and D via any POI outside E j is greater than d Thus, n  X  d min ( p ) and d min ( p ) represent lower bounds of the k smallest total and maximum trip distance computed on all POIs in the database, respectively. Once the lower bound equals to or greater than the upper bound (i.e., AT Dist [ k ] ), the optimal answer for the k GTP query has been found.
 Algorithm 2 : Inc_ k GTP( S , D , T , k , Q ) Algorithm 2 shows the pseudocode for the incremental algorithm for processing k GTP queries for aggregate function f = The input to the algorithm are a set of n source locations S = { s , s 2 ,..., s n } , n destination locations D = { d 1 , d set T = { t 1 , t 2 ,..., t m } , the number of required trips k , and an accu-racy meter Q . The output of the algorithm is a set of k trips, A [ 1 .. k ] , that satisfy Q . Thus, A [ j ] stores the set of POIs of required types that provide j th smallest total trip distance equal to or less than AT Dist [ j ] / Q , for 1 &lt; = j &lt; = k .

The algorithm adopts the best-first search technique to incremen-tally retrieve POIs/ R  X  -tree nodes in the increasing order of total dis-tance of those POIs/nodes from two centroids s c and d c . It main-tains a priority queue Q p that is ordered based on the minimum total distance that is ordered based on dmin ( p )(= Dist ( s Dist ( d c , p )) for a POI/node p from s c and d c .

To remind the reader, the distance d min ( p ) , i.e., the aggregate dis-tance of the last retrieved POI/node from Q p to s c and d the lower bound of the k th smallest aggregate trip distance. The dis-tance d min ( p ) increases with the retrieval of POIs/nodes from Q Hence, after retrieving every POI/node, d min ( p ) is updated.
On the other hand the upper bound AT Dist [ k ] is initialized as and does not change until A includes at least k POIs of a type in T and at least one POI of remaining types in T , which is checked us-ing Function Include ( P , T , k ) . If yes, the algorithm determines trips with k smallest aggregate trip distances using Function Com pTri p . If Include ( P , T , k ) returns 0, the algorithm continues the retrieval of new POIs from the database.

Before dequeuing a new POI/node, the algorithm checks whether the current set of trips satisfy the condition for Q , i.e., d AT Dist [ k ] / ( Q  X  n ) . If the condition is true, the algorithm returns those trips as answers, otherwise dequeues a new element from Q p and updates d min ( p ) . If the dequeued element is a POI, Func-tion U pdtTri p checks whether it is possible to further minimize AT Dist [ k ] by computing new trips via the last dequeued POI. The process repeats until the accuracy of computed trips in A satisfy the required accuracy specified by the group.

For f = MAX , the algorithm works in a similar way to Algo-replaced with AT Dist [ k ] / Q .

Since the proof of correctness for our algorithm is similar to the proof of our pruning technique, we omit it for the space constraint. Our proposed incremental k GTP algorithm can be adapted to pro-cess two other variants: private k GTP queries and moving k GTP queries. We briefly discuss the adaptation procedures of these queries. However, since these problems are orthogonal to our main focus of the paper we leave the detail study as our future scope.
A Private k GTP Query : In a private k GTP query, users do not disclose their source and destination locations to the LSP for pri-vacy reasons [5, 7, 9]. The coordinator of the group sends s instead of actual source and destination locations to the LSP and re-trieves a set of group nearest POIs with respect to s c and d the set includes at least k POIs of a type in T and at least one POI of remaining types in T . From the retrieved set of POIs, the coor-dinator computes the lower and upper bounds of k th aggregate trip distance with respect to source and destination locations of group members and checks whether the required quality of identified k trips have been satisfied. If yes, the coordinator forward the k GTP query answer to group members. Otherwise, the coordinator con-tinues retrieving more group nearest POIs from the LSP until k trips with required accuracy have been identified.

A Moving k GTP Query : A moving k GTP query continuously returns k POI sets with k smallest aggregate trip distances for a moving group. A group may request a k GTP query to the LSP with respect to current locations of group members and then the query answer may invalidate when group members start to move due to change of road traffic [15]. A straightforward approach to solve this problem requires reevaluation of a k GTP query for every location update from group members, which will incur high pro-cessing overhead. To efficiently process moving k GTP queries, we can exploit one interesting property, i.e., the elliptical bound of the returned POI set, of our incremental approach. Since the coordi-nator has complete knowledge about all POIs inside this elliptical bound, which we call the known region, for any change of location of group members, the coordinator can validate whether it is possi-ble to update answer from the available POIs. Specifically, as long as the refined search region (Lemma 5.4) with respect to changed locations remain inside the known region, the k GTP query answer can be identified from available POIs without contacting the LSP. We evaluate the performance of our two proposed k GTP query pro-cessing algorithms: (i) range based group trip planning (R-GTP) and (ii) incremental group trip planning (I-GTP). We first compare our approach with the existing hierarchical approach for group trip planning (GTP-HA) [8] in the Euclidian space. Since the GTP-HA approach is not scalable and is not easily adaptable for road net-works, we devise a naive approach for group trip planning (N-GTP) and compare our approaches with N-GTP by varying a wide range of parameters.
 Instead of using multiple R  X  -trees (as used in [8]), we use a single R -tree to process k GTP queries using N-GTP. However, we have not applied any pruning technique to refine the search space. Af-ter retrieving POIs, for an ordered k GTP query N-GTP computes the distances from every source location to each retrieved POI of first type, distances among intermediary POIs (e.g., distances from each POI of the second type to each POI of the third type), and dis-tances from each POI of the last type to every destination location. In the next step, N-GTP determines the k POI sets with k smallest aggregate trip distances as ordered k GTP query answers by using a dynamic programming algorithm over the retrieved POIs. For a non ordered k GTP query, the above process is repeated for every possible order of POI types and k POI sets that provide k smallest aggregate trip distances are selected as non ordered k GTP query answers.

We have evaluated our algorithms in both Euclidean and road network dataspaces using real and synthetic datasets. For real dataset, we use California [1] datasets. The POI set contains 87635 POIs of 63 different categories. The road network has 21048 nodes and 21693 edges. For synthetic datasets, we generate POIs in the dataspace using uniform and Zipfian distributions. All the datas-paces are normalized into 1000x1000 sq. units. We use an R -tree to index POIs and keep in-memory graph data structure to store the road network.

To evaluate our algorithms for k GTP queries in a wide range of settings, in our experiments, we vary the following parameters: (i) the group size n , (ii) the number of trips k , (iii) the number of POI types m in a trip, and (iii) the query area M , i.e., the minimum bounding rectangle covering the source and destination locations. To evaluate our approximation algorithm for k GTP queries, we vary the quality parameter Q . Table 1 summarizes the parameter names, their ranges, and default values used in our experiments.
In all experiments, we estimate the processing time and I/O to measure the efficiency of our algorithms. In each set of experi-ments, we run the experiment for 100 trip planning queries and present the average result. We run all experiments using a computer with Intel Core i5 2.30 GHz CPU and 4GB RAM. We compare our R-GTP and I-GTP algorithms with the existing GTP-HA in the Euclidian space. Figure 5 shows the I/O cost and processing time of R-GTP, I-GTP, and GTP-HA for aggregate func-tion SUM (a-b) and MAX (c-d) for different group sizes. We ob-Figure 5: Effect of group size n for SUM (a-b) and MAX (c-d) in Euclidean space using California dataset serve that for SUM, both of our approaches take less than a second to process a GTP query for any group size. On the other hand GTP-HA takes 5.5 to 39 minutes to process a single GTP query. For MAX, our approaches take 0.3 to 2.7 seconds, whereas GTP-HA takes 1.3 to 20 minutes to process a GTP query. Experimental re-sults show that our approaches are on average three orders of mag-nitude faster and require two orders of magnitude less I/Os than GTP-HA. Figure 6: Effect of data set size d s for SUM with uniform (a-b) and Zipfian (c-d) distributions, and for MAX with uniform (e-f) and Zipfian (g-h) distributions
We also compare our approaches with GTP-HA by varying the dataset sizes for both uniform and Zipfian distributions (Figure 6). Experimental results show that both R-GTP and I-GTP take less than a second to process a GTP query for any dataset size. On the other hand, for a dataset size of 5K GTP-HA takes on average 14 minutes to process a single GTP query, and the processing time increases to 90 minutes for the dataset size of 20K.

GTP-HA can only process a GTP query within a reasonable time when the number of POI types is 2. Our experimental results also show that for three POI types, even for a group size of 8, GTP-HA takes 17 minutes to run a single GTP query, which is not practi-cal. Moreover, we could not run GTP-HA for a higher value of m (&gt;3) for prohibitively expensive computational cost. By using syn-thetic datasets, we have also shown that GTP-HA is not scalable for a large dataset. Therefore, for the next set of experiments, we compare our approach with N-GTP. In these sets of experiments, we evaluate our proposed algorithms for processing k GTP queries and compare these with our naive ap-proach N-GTP, in both Euclidean and road network dataspaces. Figure 7: Effect of varying n (a-b), k (c-d), m (e-f), and M (g-h), for k GTP processing in Euclidean space Effect of n: In this set of experiments, we vary the number of users n in the group and measure I/O and processing time for process-ing k GTP queries for R-GTP, I-GTP, and N-GTP algorithms. Fig-ures 7(a) and (b) show I/Os and processing time, respectively, for all three approaches. We observe that N-GTP incurs at least one order of magnitude more I/Os and takes at least two orders of mag-nitude more processing time than both range based, R-GTP and incremental I-GTP algorithms. This significant performance gain comes from the efficient elliptical pruning strategies of our pro-posed approaches. We also observe that I-GTP algorithm performs sightly better than R-GTP algorithm as I-GTP only access POIs that are essential for answering k GTP queries, whereas the R-GTP algorithm uses an estimated upper bound to retrieve the POIs.
Effect of k: In this set of experiments, we vary the required an-swer set size k and compare the performance of our approaches with the naive approach. Figure 7 shows that our approaches sig-nificantly outperform N-GTP for all k . Also, we see that I/Os and processing time slightly increase with the increase of k for both R-GTP and I-GTP. Moreover, we observe that R-GTP outperforms I-GTP slightly in terms of processing time as for a large k I-GTP requires more computational steps after every POI retrieval.
Effect of m: Figures 7 (e) and (f) show the performance of our algorithms for varying the number of types m . The results show that for any number of types both of our proposed approaches, R-GTP and I-GTP, outperform N-GTP by at least an order in terms of I/O and two orders in terms of processing time. We observe that both of our approaches are scalable as I/O and processing time grows linearly with the increase of m .

Effect of M: Figures 7 (g) and (h) show the comparison of re-quired I/Os and processing time in all three approaches by varying the query area. We see from the figures that for both R-GTP and I-GTP, I/Os and processing time increase with the increase of query area, as for a larger query area both approaches need to consider more POIs while computing k trips for a GTP query. On the other hand, since N-GTP retrieves all the POIs irrespective of the query area, processing time remains same for any query area. Both of our approaches outperform N-GTP queries significantly for all M .
Effect of dataset size: To show the effect of dataset size, we run experiments using synthetic datasets generated using uniform and Zipfian distributions. Figures 8 (a)-(b) and (c)-(d) show the com-parison of required I/Os and processing time in all three approaches by varying the dataset size using uniform and Zipfian distributions, respectively. For both distributions, I/Os and processing time of N-Figure 8: Effect of dataset size using uniform (a-b) and Zipfian (c-d) distributions in Euclidean space GTP increase sharply with the increase of dataset size, whereas, for both R-GTP and I-GTP, I/Os and processing time increase slightly with the increase of dataset size. Thus, both of our approaches are scalable with respect to dataset size and distributions, and I-GTP takes less I/Os and processing time than that of R-GTP as I-GTP only accesses POIs that are essential for answering k GTP queries. Figure 9: Effect of varying n (a-b), k (c-d), m (e-f), and M (g-h), on k GTP processing in road networks In this set of experiments, we evaluate the performance of all three approaches R-GTP, I-GTP, and N-GTP in road networks. Figures 9 (a)-(h) show I/O cost and processing time by varying different parameters. We observe that in all cases the results show similar trends to that of the Euclidean space.
 Figures 9 (a) and (b) show that I/Os and processing time of both R-GTP and I-GTP slightly increase with the increase of group size as they need to access more POIs for the k trips. We also observe that both R-GTP and I-GTP take at least two orders of magnitude less processing time and incur 5 times less I/O than N-GTP. We see that I-GTP performs slightly better in terms of I/O than R-GTP due to its tighter bound in the incremental retrieval process.
Figures 9 (c) and (d) show the comparison of three approaches in terms of I/Os and processing cost, respectively, by varying k . Though I/Os for both R-GTP and I-GTP slightly increase with the increase of k , the processing time for all approaches remain almost constant for different values of k . Our approaches take at least two orders of magnitude less processing time than the naive approach.
We vary the number of types m and present the results in Fig-ures 9 (e) and (f). Though I/O cost increases with the increase of m , the overall processing time of both R-GTP and I-GTP is at least two orders of magnitude less than that of N-GTP. Hence, both of our approaches are scalable for a higher value of m .

Figures 9 (g) and (h) show I/Os and processing time, respec-tively, of all approaches for varying query area. We see that for both R-GTP and I-GTP I/O cost increases with the increase of the query space area, and for a large query area they need to retrieve a higher number of POIs. Both of our approaches outperform N-GTP by 1-2 orders of magnitude in terms of overall query processing time.
In summary, we see that I-GTP takes less I/Os than R-GTP, while processing time of R-GTP is slightly better than I-GTP especially when parameter values are large. This is because the incremental updates of I-GTP incur a slightly higher processing overhead. In Section 3, we see that the aggregate trip distance for pends on whether group members share a vehicle for the common part of the trip or not. In all the above experiments, we assume that group members travel independently. We have also run experiments for the scenario where all group members share a vehicle for the common part of the trip. The results show that for the shared sce-nario the processing time and I/O are slightly smaller than that of non-shared scenario as in the former trip distance is smaller com-pared to that of the later case, which results in a smaller search region for the shared query. In the above set of experiments, we assume a fixed order of POI types. We have also run experiments for flexible order (i.e., non-ordered) POI types where the group can visit POIs in any order. Due to space constrained, we only show the I/Os and processing time by varying dataset size generated using uniform and Zipfian distributions (Figure 10). Figures show that in all methods, I/Os and processing time are higher than that of ordered k GTP queries, which is expected as we need to check different orders of POIs to find the optimal answer. Since our pruning method limits the search region to a smaller area containing a small number of POIs, the query processing time is always within an acceptable limit. Figure 10: Effect of data set size d s for SUM with uniform (a-b) and Zipfian (c-d) distributions for non-ordered k GTP queries Figure 11: Effect of varying n and Q for k GTP processing in Euclidean space (a-b) and road networks (c-d)
Computing the answer for a non-ordered trip planning query has been shown as an NP-hard problem. Thus, to efficiently process k GTP queries for a large data set and for a large group size, we pro-pose an approximation based incremental approach (I-GTP) that can trade efficiency with accuracy. To show the tradeoff between accuracy and efficiency, we vary the quality parameter Q as 1.0, 1.25, 1.5, 1.75, and 2.0, where 1.0 represents the exact/optimal an-swer whereas 2.0 means that the returned trip distance is guaranteed to be not more than twice of the optimal trip.
We run experiments by varying different parameters. For the brevity of the presentation, we show only results of varying the number of users n in the group (Figures 11 (a-b) for Euclidean space and Figures 11 (c-d) for road networks). We see that both I/O cost and the processing time decrease with the increase of Q . We have observed that the processing time for Q = 2 . 0 is approxi-mately 2 times less than the processing time for Q = 1 . 0. Figure 12: Effect of dataset size for uniform (a-b) and Zipfian (c-d) distributions for aggregate function MAX We have run experiments for aggregate function MAX that min-imizes the maximum trip distance of all users. The results show similar trends to that of SUM . For space constraints, we present the results for dataset size variation with uniform and Zipfian distribu-tions, which signify the scalability of our approaches.

Figure 12 shows the comparison of three approaches for process-ing k GTP queries for aggregate function MAX by varying dataset size. For uniform distribution, Figures 12 (a) and (b) show I/Os and processing time, respectively. We observe that with the increase of dataset size both I/Os and processing time sharply increases for N-GTP, whereas, for both R-GTP and I-GTP, I/Os and processing time slightly increases with increase of dataset size. I-GTP takes less number of I/Os than R-GTP, whereas, I-GTP has higher processing times than R-GTP because of the incremental updates. The results for Zipfian distribution (Figures 12 (c-d)) show similar trends to that of uniform distribution. In this paper, we have proposed efficient solutions for k group trip planning ( k GTP) queries and its variants that enable a group of users to plan a trip starting from different source locations, visit-ing different types of POIs, and ending at different destination lo-cations. Our approach overcomes limitations of the state-of-the-art methods. To solve k GTP queries efficiently, we have developed a novel technique to refine the POI search space, and proposed two algorithms: a range based and an incremental algorithms that both process k GTP queries with reduced computational and I/O over-head. In addition, we have developed an approximation based in-cremental algorithm that can trade off the efficiency with the ac-curacy of the answer. Our extensive experiments with real and syn-thetic datasets show that our approaches outperform the benchmark approach by one to three orders of magnitude in terms of both pro-cessing and I/O overhead. In the future, we aim to consider other factors such as cost, POI popularity, user preference in addition to the distance to identify the best trips for the group.
