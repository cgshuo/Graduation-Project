 We focus on collaborative filtering dealing with self-organ izing communities, host mobility, wireless access, and ad-hoc co m-munications. In such a domain, knowledge representation and users profiling can be hard; remote servers can be often unreachable due to client mobility; and feedback ratings co l-lected during random connections to other users X  ad-hoc de-vices can be useless, because of natural differences between human beings. Our approach is based on so called Affin-ity Networks , and on a novel system, called MobHinter , that epidemically spreads recommendations through spontaneou s similarities between users. Main results of our study are tw o fold: firstly, we show how to reach comparable recommenda-tion accuracies in the mobile domain as well as in a complete knowledge scenario; secondly, we propose epidemic collabo -rative strategies that can reduce rapidly and realisticall y the cold start problem.
 H.3.3 [ Information Storage and Retrieval ]: Information Search and Retrieval X  Information filtering ; C.2.4 [ Computer-Communication Networks ]: Distributed Systems X  Dis-tributed applications ; J.4 [ Computer Applications ]: So-cial and Behavioral Sciences X  Sociology Algorithms, Design, Measurement Recommender Systems, Social Collaborative Filtering, Ad-Hoc Networks
Social Networking services and self-organized communi-ties are rapidly filling the Web with innovative and highly popular data-driven applications. Most of these applicati ons are based on data sharing, and even if architectural models vary from rigid client/server implementations to pure peer -to-peer systems, users are invited to join a given commu-nity and distribute their own files, like photos (e.g. Flickr ), videos (e.g., YouTube, Joost), music (e.g., Emule, Gnutell a), blogs, personal data, and other information even just for being connected to other people (e.g., eBlogger, MySpace, Facebook).

Moreover, users can communicate each other by means of a broader and broader set of short and wide range wireless network interfaces (e.g., Bluetooth, Wi-Fi, Wi-Max, GSM, UMTS). Some analysts [1] expect that these applications will finally increase 3G data traffic. Nevertheless, there is a n increasingly influential opposite trend, because ad-hoc co m-munications can be exploited to collect relevant informati on during ordinary off-line user X  X  activity, and/or when WAN connectivity is difficult (e.g., in the underground, in the ai r-plane), expensive, or simply superfluous. In addition, smar t vehicles have embedded computers, that are going to host vehicular computing and networking solutions addressed to safer driving, dynamic route planning, and a new generation of entertainment applications.

In such a scenario, adaptive recommendation systems can play a leading role for reducing information overload, and f or filtering out useless information. Unfortunately, there ar e a number of drawbacks that make many approaches unfit to run. Firstly, knowledge representation can be hard, becaus e (1) it is difficult to trace a user X  X  profile if she/he accesses s er-vices presenting different identities and pseudonyms, and ( 2) flexible and less expressive languages based on user-defined tags (e.g., folksonomy) are preferred instead of rigid, eve n if exhaustive, taxonomies.

Secondly, mobile devices can be unable to access the Inter-net or a remote server. Therefore, the adopted architectura l model should allow the recommendation system to operate in autonomy.

Thirdly, when the user X  X  device is able to connect to other hosts in the proximity via ad-hoc connections, it grants ac-cess to a very limited portion of the broader community and to a small subset of all the available data. More signifi-cantly, information coming from random  X  X endez vous X  can result uninteresting for a user, accordingly to her/his own preferences. This is an issue for collaborative filtering, b e-cause neighbors should be selected for similarities, and no assumption of this kind can be done on users that are in a context-free proximity.
 Contributions and Road Map
Our proposal is based on a connection oriented collabora-tive filtering approach that strongly mitigates domain repr e-sentation X  X  problems. Hence, after a brief survey on relate d works (Section 2), we introduce Affinity Networks in Section 3. This model represents a similarity graph that links users each other using a configurable affinity threshold. Section 4 presents MobHinter that allows the mobile device to identify affinity network neighbors from random ad-hoc communica-tions. Collected information is used to incrementally refin e locally calculated predictions, with no need of interactin g with a remote server or accessing the Internet. Using a sim-ulated environment and the well known MovieLens dataset, in Section 5 we show how recommendation accuracies ex-perimented in the mobile domain, with sparse and incom-plete knowledge, are comparable to predictions resulting i n a scenario with complete knowledge available. Moreover, we empirically prove how epidemic filtering strategies greatl y reduce the cold start problem. Finally, we point out some practical observations in Section 6.
To authors knowledge, there has been few experience in designing collaborative filtering systems in distributed e nvi-ronments such as mobile ad-hoc networks.

A first attempt to deal with a decentralized environment is proposed in [2] where products and services are suggested in a marketplace populated by mobile customers. In the environment assistant agents act as peers serving the mo-bile customers. When a neighbor is looking for suggestions it broadcasts a query containing a vector with its votes on products and recommendations. When a peer receives the voting vector it calculates the proximity with the cached previous messages: if the proximity is higher than a thresh-old, then the peer send back the cached voting vector. If the proximity measure is lower, the query voting vector is broadcasted further to other peers.

In the PocketLens project [3] a collaborative filtering al-gorithm for finding neighbors in a peer-to-peer environment is proposed. The authors evaluate the algorithm in different architecture for finding neighbors: Central, Random, and Transitive Architectures. The two last architectures are d is-tributed. In particular in the Transitive Architecture the most similar neighbors are incrementally discovered each time a new user is encountered. This approach is compa-rable to our proposal. In fact, the Transitive Architecture maintains a queue of  X  X eighbor X  X  neighbors X . The intuition is that if you are one of my best neighbors, then it is likely that your neighbors are good for me as well. However, differ-ently from our approach the data concerning neighbors are not locally maintained. If some of the neighbor X  X  neighbors are off line while building the model, they are substituted with a pool of quality neighbors. What is also relevant for our approach in the PocketLens project is that in the peer-to-peer context the algorithm achieves an acceptable quali ty level with a minimum number of neighbors required.
Another work investigating both the issue of the avail-ability of data needed to make predictions and the underly-ing social aspects of recommender systems is the one from Mirza et al. [4]. They start from the assumption that a recommender, in an indirect way, has the goal of bringing people together. Thus they propose a framework based on a mathematical model of the social network implicit in rec-ommendation. Studying typical recommender dataset they found underlying graph structures. Therefore they analyse recommenders in term of jumping connections. Their goal is to propose a model able to calculate the minimum number of rating constraints and of jumps -between users and between users and artifacts -needed to generate accurate recommen-dations. However they do not contextualize the problem in distributed and sparse environments, so the problem of find-ing recommendations in ad-hoc and decentralized networks still remains open.

Castanos and Boyer [5] propose a collaborative filtering model which is totally distributed. Each peer of the network owns the users X  public profiles. The goal of their algorithm i s to build a group profile for every active user representing th e preference of a virtual community of interests. The group profile is generated on the basis of the other public profiles similar to the public profile of the user. The group profile can also be stored on the user device, thus predictions can run locally when the user does not want to share her prefer-ences. They have computed the MAE by simulating arrivals of peers by progressively adding new profiles, and they got predictions as good as using PocketLens algorithm.
The work of Splinder et al. [6] deals specifically with col-laborative mobile ad-hoc networks. They introduce the no-tion of shared social context in order to help their distributed collaborative filtering system to establish similarity rel ation-ship between copresent users. The assumption behind their proposal is that if two users attend the same event, as arts festival events, it is likely that they have similar interes ts. Thus, without computing prior similarity, predictions are based on the set of users sharing at least one item, that is an event/location they have consumed during the same period of time. However this approach does not work in context where users are copresent by chance, such as on the subway, or on the bus, etc.

Another proposal is Tribler [7, 8], a personalized peer-to-peer television system that automatically recommends, records and downloads content from peers in a social net-work. This system is based on the concept of buddy tables and provides a distributed algorithm, called BuddyCast , to spread in the network the ratings database. Even though Tribler proposes a mechanism comparable to our proposal, there are some distinctive differences. In particular, in Tri-bler a user can mark a discovered node as a friend by way of the interface, implementing a sort of list of favorite use rs. This explicit declaration of friendship does not involve an y topological property of the spontaneous similarity networ k. On the contrary, our proposal exploits implicit properties of the affinity networks, in order to implement an incremental and epidemic algorithm to spread ratings in a mobile com-munity. Further approaches have been proposed in litera-ture, like P ipeCF scheme using a Distributed Hash Table in order to spread ratings information [9, 10], or the V ineyard [11] system where a set of independent recommender com-ponents co-operate in a given domain. In a mobile scenario, other proposals can be found in [12, 13].
In order to model our domain in a more formal way, we S = { s 1 , s 2 , . . . , s l } (e.g., pictures, videos, songs, favorite restaurants, . . . ). In many domains, we may assume that a feedback rating function is defined: rate : U  X  S  X  R , where R is a set of allowed rating values (e.g., R = 1 , . . . , 5). We assume a bijection between users and nodes in the system, hence the user u i denotes both the i-th node and the i-th user. We define P ( S ) as the power set of S , i.e. the set of all subsets of S . The function f : U  X  X  ( S ) maps users to objects of the entire collection (i.e., S n i =1 f ( u other words, f ( u i ) is the set of items user u i is related to; for instance, in a file sharing applications f ( u i ) can be the set of files u i is storing, as well as for a video streaming service f ( u i ) can be the set of channels or podcasts u subscribed to. In the peculiar domain that we investigate in this paper, an object is mapped to a user if such a user assigned a rate to the given object; i.e.,  X  u i  X  U  X  X  X  s rate( u i , s k ) is defined  X  X  X  s k  X  f ( u i ).

To take advantage of the power of users relationships, we need to evaluate the affinity among users. For this purpose, we first introduce the affinity function Aff : U 2  X  [0 , 1], that returns a similarity evaluation for any pair of users.
This function is subject to the following properties: 1. Aff ( u i , u j ) must be computable using information that 2. Aff ( u i , u i ) = 1; 3. Aff ( u i , u j ) = 0 means that, due to their knowledge of
Affinities can be estimated taking into account many pa-rameters: resources in common, similar behaviors, compa-rable ratings assigned to items, and so on.

Now we introduce the idea of  X  X ffinity Network X  that is represented by a graph G  X  = ( U, E ) such as: As an instance of a previous successfully study adopting Affinity Networks, we analysed the Gnutella file sharing net-work in our works [14, 15]. Observe that a P2P system rep-resents a difficult domain with many points in common with the mobile ad-hoc scenario discussed in this paper. In fact, there is not a central repository or a trusted third party tha t can collect profiles and ratings, and available content de-scription is very poor (sometimes only file names and paths are used), and often misleading. Moreover, prediction accu -racy estimation is complicated because users do not usually rate items.

Our previous analysis on the Gnutella network, lead to the identification of the Small World phenomenon in those pe-culiar Affinity Graphs. This means that observed networks showed small mean-shortest paths, and significantly high clustering coefficients. Such evidence depicts the Gnutella network as a set of strongly interconnected clusters, repre -senting spontaneous thematic communities of users sharing kindred files. This has been exploited during the design of DeHinter [14], a P2P recommendation module recently im-plemented and integrated to Limewire [16].
In a domain where ratings are available and feedbacks are largely returned by the users of the community, we can ex-ploit them in order to find affinities. Even if one of the many well known similarity functions can be defined (e.g., Pearso n [17] or Spearman [18] correlations), we use a computational inexpensive measure calculated as the percentage of simi-lar feedbacks that two users assigned to a common set of objects: Aff ( u i , u j ) = where F ij = f ( u i )  X  f ( u j ) is the set of files that both u and u j rated, max R and min R are respectively the highest and the lowest value that can be used to rate an object. Notice that this formula is a generalized version of the one described in [14].

In order to improve readability of the paper and to give an example how recommendations can be triggered according to our approach based on affinity networks, we present a toy domain in the following paragraphs.

Let us suppose a set of three users U = { u x , u y , u z collection of five objects S = { s a , s b , s c , s d , s objects accordingly their own preferences and tastes, that are reported in Table 1.
 Table 1: Three users rated five different objects In this case, we have that max R = 5, F xy = { s b , s c } , F calculated with Equation (2) are shown.

If we set threshold  X  = 0 . 5, only users u x and u z will be connected in the affinity network. The idea is to spread ratings through affinity links, filtering out feedbacks comin g from distant users. Our approach aims to exploit word-of-mouth behaviors in such networks, accepting implicit sug-gestions coming from neighbors and neighbors-of-neighbor s with higher probability than receiving positive informati on coming from users that are some hops away in the affinity network. For instance, neither s e will be suggested to u nor s c to u z .
The mobility scenario has its own peculiar issues. Even if we can assume an  X  X mniscient X  server that stores and main-tains all the knowledge provided for in our community, we need to grant a high level of autonomy to each host. In fact, in order to make our approach as much general as possible, we allow the user to walk around, and to meet other users at random. Only devices in the proximity can exchange in-formation, but we cannot claim that this provides a natural filtering based on the social contexts, because we are not assuming anything about the reasons why they are there in that moment, in contrast with other authors (e.g., [6]).
When a device is able to connect to the Internet, the user can access the rest of the community, and public his/her own data, profile and preferences. Searches and lookups can be managed by a central directory service, or in a Peer-to-Peer manner (e.g., by flooding or by means of a DHT based over-lay network). If each peer u i accesses the status of its affinity network X  X  neighbors, then it can calculate predictions ove r an object s k using one of the many collaborative filtering algorithms known in the literature. Given an affinity graph G , let U i be the set of neighbors of u i . This means that if u j is a neighbor of u i , then they are similar according the affinity function (2), i.e., Aff ( u i , u j ) &gt;  X  . Furthermore, node u i may store all neighbors X  referred items and ratings. Hence, if we define the list of feedback ratings of u i as a set of pairs (object identifier, rating), then the user can keep the following information: where, for the sake of simplicity, r ik = rate ( u i , s k scenario we can say that peers share a uniform range of ratings and that the status of node u i is very limited, be-cause many data can be retrieved run-time contacting on-line neighbors. Therefore, u i needs to keep references to its neighbors U i , and list F r i .

In our experiments, in order to generate a prediction p for an object s k analyzing ratings available to u i , we used a slightly modified version of a well known user based nearest neighbor algorithm [19]: where r i and r j are, respectively, the average rating of u and of neighbor u j . Notice that the algorithm differs from its classical application for two aspects: (i) Equation (2) is u sed as affinity function instead of Pearson correlation. This im-plies that (ii) the number of nearest neighbors can differ for every user depending on how many neighbors are connected in the affinity network. Of course, other statistical and not statistical approaches could be used to generate predictio ns, but this is out of the scope of this paper. MobHinter is an epidemic protocol that can be applied even when only ad-hoc communications are available during a relatively bi g period of time. The statistical approaches used to calculat e affinities and to generate predictions are not the core of the presented proposal.

If mobile devices cannot access the Internet and they can-not contact directly their neighbors in the affinity network, then the prediction simply cannot be calculated. Our hy-pothesis is that each node u i can start with an empty set of neighbors, i.e., U i =  X  . We suppose that for each neigh-bor u j  X  U i , the node stores also its list of ratings F r Moreover, u i maintains a list of known hosts Kn i , which is a cache of nodes encountered during u i  X  X  walks. Again, for each node u z  X  Kn i , list F r z is stored as well.
When a device u x finds another device u y in the proximity, a handshake phase is started: u x and u y exchange each other their identities, their feedback ratings lists F r x and F r their neighbors lists U x and U y , and their Known hosts lists Kn x and Kn y . Then, both ad-hoc nodes can calculate the affinity function in autonomy. If they find that Aff( u x  X  , then they can add a new node in their neighbors list; i.e., U x = U x  X  u y and U y = U y  X  u x . Otherwise, they simply update their known hosts list; i.e., Kn x = Kn x  X  u y and Kn y = Kn y  X  u x . Since affinity function is symmetrical, we are sure that both nodes will have the same results.
Trivially, we can foresee an approximately long cold start phase. Nevertheless, MobHinter exploits social networkin g style Word-of-Mouth strategies in order to spread neighbor -hood information across the discovered links of the affinity network. In fact, if node u x is not a neighbor of u y , it can happen that a similarity is found with one of his/her neighbors in U y , or with one of known nodes in cache Kn It is important to observe that, after the first ad-hoc ses-sion, few or no other ad-hoc interactions are needed. This is very important because a node can be out of sight in a few seconds after handshake. All the predictions and the affini-ties are calculated in autonomy with available data. In the following, we list three different spreading strategies. Fo r improving readability, only actions at u x side are described, because u y behaves symmetrically.
 PREF u x keeps F r y and discards U y and Kn y .
 NEIGH u x keeps F r y and U y , and discards Kn y . KN-NEIGH u x keeps F r y , U y and Kn y .
 Predictions are calculated again after each meeting using Equation (4), considering all the neighbors in U x and their ratings. The three strategies are increasingly more expen-sive in terms of bandwidth consumption, status storage, and computational resources usage. We want to analyze if the latter strategies are scalable in terms of the number of iter a-tions, and if cold start mitigation worths the overhead. Suc h a simulative evaluation is provided in the next section, whi le a discussion on other practical issues is given in Section 6.
The best results that could be acquired for a given recom-mendation algorithm is reached when the system has com-plete knowledge about objects, users and users X  preference s usually expressed by feedback ratings. Devices using Mob-Hinter move into a disconnected environment, where epi-demic dissemination of information is critical before accu rate recommendations can be triggered to the user. This process is simulated through a set of iterations that mimic meetings between users. This evaluation is made of two phases: 1. Run the adopted user-based neighbor recommender 2. Run the same recommendation system in a fully dis-Aims of this evaluation is three-fold: (1) to estimate how many interactions are needed before converging to optimal values, accordingly to the three different strategies descr ibed in the previous section; (2) to estimate overhead w.r.t. the capacity of a modern mobile device; and (3) to analyze the scalability of the approach.
 For all our experiments we refer to the dataset of Movie-Lens developed at the University of Minnesota. It is com-posed of a number of randomly selected users enough to obtain 100,000 ratings from the database (considering only users that had rated 20 or more movies). It can be rep-resented as a sparse user-movie matrix with 943 users and 1,682 movies, with the rating values represented in the ma-trix as an integer value from 1 to 5. The sparsity level is,
In order to evaluate the accuracy of the predictions, we adopted two well known accuracy metrics: the Mean Abso-lute Error (MAE) and the Root Mean Square Error (RMSE). MAE measures the average absolute deviation between a predicted rating and the user X  X  true rating. RMSE, that squares the error before summing it, emphasizes on large errors, that is, it amplifies the contributions of egregious er-rors, both false positives ( X  trust busters  X ) and false negatives ( X  missed opportunities  X ).

Accordingly to Sarwar et al. [20], a recommender sys-tem based on nearest neighbor algorithms may be unable to make any item recommendations for a particular user, if the data set is too sparse. As a result the accuracy of recom-mendations may be poor, and the estimation of preferences may well be undefined, when asked to estimate a preference for an item for which no preference is expressed in the user neighborhood. This situation occurs with high thresholds that limit too much the neighborhood. In this case, if we consider only estimations that are defined by the algorithm, we can have an unfair good result. To go around this prob-lem, we decided that when the estimation is undefined by the algorithm, the final resulting estimation is the average of other preference scores from that user (we use a sort of  X  default voting  X  reflecting neutral preferences of the user).
To make an evaluation that includes all the data set, we used the k-fold cross-validation, with k = 10. In this eval-uation, the ratings set is partitioned in 10 samples. Of the 10 samples, a single sample is retained as the testing set , and the remaining 9 samples are used as training set . This validation is repeated 10 times, ensuring that all ratings a re used for testing. The results are then averaged to produce a single estimation.
 tive filtering engine for Java. It is a very flexible framework , MAE
Figure 1: MAE in a complete knowledge scenario with most of the common collaborative filtering approaches available. It also provides a way to evaluate the accuracy of recommendation algorithms, including metrics as MAE and RMSE. We evaluated the prediction of ratings for the entire Movie-Lens data set, with the assumption that each node can find its neighbors in the affinity network and run the user-based neighbor algorithm as reported in Equation (4). Differently with the standard version of such formula, we considered neighbors of u i that satisfy Equation (1), and not a constant number of nearest neighbors. We tested three different sim-ilarity functions, including Pearson correlation, Spearm an correlation and the affinity function defined in Equation (2). The tested thresholds were in a scale from 0.1 to 1.0. The results for MAE are shown in Figure 1, and the results for RMSE have a similar behavior, with the best results for Spearman and Pearson correlation at 0.25, and the best re-sults for function in Equation (2) at 0.75.

We found that the affinity function defined in Equation (2) produces best results (MAE of 0 . 7577 and RMSE of 0 . 9617) in correspondance with the optimal threshold  X  = 0 . 75. Af-ter analysing the optimal scenario made of a static fully connected affinity network, and with completely available knowledge, we estimated MAE and RMSE lower bounds, that are terms of reference for the ad-hoc experimental setu p.
In the previous section we individuated the correlation function and the threshold  X  that minimize MAE and RMSE in the reference scenario for a given user-based neighbor re c-ommender system. In the following, we will present a simu-lative framework in order to model the dynamics of a pop-ulation of mobile devices that interact each others through ad-hoc meetings. In this way, they share their local knowl-edge for producing personalized advices. We assume that each device starts without any a priori knowledge about the domain or the population of users. Afterward, it starts a discovery phase during which the device explores the world looking for new nodes. During this explorative phase we suppose that it does not access to the Internet or to any other remote server. Its only knowledge comes from ran-dom meetings. The device is able to exchange data only through ad-hoc communications.

The simulation is composed by a sequence of iterative steps that model random meetings between users. If n is the number of users under observations, at each step, we simu-late n/ 2 random meetings between different pairs ( u i , u peers. At last, for a node is not possible to meet more than one other host in a single iterative step.

The state of a user u i , i.e., the amount of data the user has to store, is composed by two sets: (1) the set of ratings F r i (see 3) and the set of neighbors U i . Of course, we have that U i =  X  at the beginning of the simulation. When users u i and u j meet each other, they can run one of the three selected strategies: PREF , NEIGH and KN-NEIGH .

In our simulation, we performed 80 iterative steps and, at each iteration, we computed for all PREF , NEIGH and KN-NEIGH strategies the MAE and RMSE accuracy metrics, under the evaluation framework discussed in Section 5.1. In all the simulations, we used the affinity function defined in Equation (2) with threshold  X  = 0 . 75. Figure 2 and Figure 3 show observed results, respectively, for the MAE and RMSE metrics. MAE Figure 2: MAE estimation in the ad-hoc scenario
The Optimal Scenario line marks the value reached in the reference fully connected model (i.e., 0.757 for MAE and 0.961 for RMSE). In both figures is evident that the PREF strategy converges very slowly toward the lower bound be-cause of the spreading of information is relied only to direc t meetings. Exchanging the neighbors list U i allows an epi-demic form of ratings distribution that strongly improves accuracy of prediction. In fact, for the NEIGH strategy we can reach results comparable to the complete knowledge one in 50 iterative steps (e.g., MAE=0.768 and RMSE=0.99). Moreover, sharing of known hosts list Kn i , considered with strategy KN-NEIGH , allows to maximize the epidemic dif-fusion of data and permits to obtains good results after only 25 random meetings (e.g., MAE=0.758 and RMSE=0.962).
The process of neighbors discovery is showed in Figure 4. At each iteration, we computed the average number of neighbors stored by users, i.e., avg ( | U i | ), and the standard deviation stdev (for clarity reasons in Figure 4 we show only stdev for the KN-NEIGH strategy).

Very interestingly, even if there is an appreciable differ-ence between KN-NEIGH and NEIGH strategies, this is not comparable to the difference observed between NEIGH RMSE
Figure 3: RMSE estimation in the ad-hoc scenario Average Number of Neighbors Figure 4: Average number of neighbors in the ad-hoc scenario and PREF approaches. Our interpretation is that, as ob-served in many social networking analysis, the neighbors of my neighbors are likely to be my neighbors (also known as the triangulation property). Hence, epidemic distribu-tion of ratings is greatly enhanced if information are sprea d though affinity links. Conversely, known hosts that are not my neighbors, have limited probability to be neighbors of my neighbors, especially in a sparse dataset like MovieLens . Nevertheless, if two users take into account Kn lists, trust busters and missed opportunities can be reduced in fewer steps.
Considering a simulative scenario with a population of 943 users, a collection of 1,682, and 80 iterative steps that emulate 80 sequential random meetings for each user X  X  de-vice, Figures 2 and 3 show also how many ad-hoc commu-nications are needed before predicting approximately ac-curate recommendations. In fact, after 20 iterative steps (i.e., each device has met about 2% of the entire popula-tion), on average, we have that 0 . 757 &lt; MAE &lt; 0 . 763 and 0 . 961 &lt; RMSE &lt; 0 . 97 when NEIGH strategy is used, and that 0 . 757 &lt; MAE &lt; 0 . 759 and 0 . 961 &lt; RMSE &lt; 0 . 964, when KN-NEIGH is adopted instead. Furthermore, after 50 iterative steps (i.e., each device has met about 5% of the Table 3: Parameters for the Estimation of the Spa-tial Overhead MovieLens population), KN-NEIGH strategy makes MAE and RMSE converge to optimal minimum values.

Hence, in order to understand if the overhead is viable with modern mobile devices in terms of their available ca-pacity and to evaluate scalability of the system, we need to estimate step by step the average device X  X  status in terms of memory occupancy. Focusing again on the MovieLens dataset, we can define | u i | , | s k | and | rate ( u i tively, the size in bit of a user X  X  identifier, an object ident ifier and a rate (see Table 3).

The status of a MobHinter node u i is made of the fol-lowing elements: F r i , U i , and Kn i . The neighbors list and known hosts cache grows differently accordingly to the adopted strategy. It is important to recall that for each node u j in U i or in Kn i , we need to store the node X  X  identi-fier (i.e., | u j | bit), and ratings list F r j (i.e.,  X  ( s the device consumes | s k | + | rate ( u i , s k ) | ).
Focusing on iterative steps from 20th to 50th, for each different strategies, we have an average status for device as in Table 4.

Of course, PREF is the less expensive in terms of mem-ory consumption, but the reader should observe that after 50 iterative steps, the average status of MobHinter node be-having accordingly to KN-NEIGH is about 60 KB, which is widely practical for actual mobile devices. Furthermore, t his status size can represent an upper bound, because (as ex-plained in the following section) we avoid to let indefinitel y grow the lists; in fact, in the case study we showed that af-ter an average of 50 random meetings, recommendations are accurate as well as in the optimal scenario.
In the previous sections we proved that MobHinter con-verges quickly to optimal recommendation predictions even if only random ad-hoc meetings are considered. MobHin-ter X  X  field of applicability is very wide, and it includes mov ie selection, tourist attraction suggestion, personalized r estau-rant advices, and so on. Real world applications have pros and cons that go beyond simulative frameworks, and that cannot be realistically considered in a simplified model. In the following, we state some of the most relevant issues that may arise.
 Synchronization : Even if we proved the practicality of our approach in a very extreme domain where nodes meet each other only using ad-hoc connections, we can realisti-cally consider the existence of a remote service that can be accessed when Internet is available. During synchronizati on with such a service, a node can merge information collected during the ad-hoc phase with new information related to ge-ographically remote users. When online, the device is able t o refine the personalized predictions previously obtained, f or example, accessing to content-based data repositories, do wn-loading more specific information about items and users, re-calculating affinities according to more accurate data. Even if very relevant to a practical implementation of MobHinter , these engineering issues are out of the scope of the paper. Privacy and profile control : A MobHinter node has com-plete control over its user X  X  profile and over recommendatio n calculations and predictions. In fact, every device collec ts all the information it needs for estimating ratings for unknown objects, and it has to exchange such information with other nodes. This greatly protects user X  X  privacy, because even during a synchronization with a remote service, it has to pul l all the data needed for calculation, by means of a (decentral -ized) directory system, e.g., for example, an user can query the system looking for potential neighbors that matches his preferences according a given affinity threshold. This can be executed, for example, by flooding the searches, or us-ing a Distributed Hash Table overlay network that allows structured and scalable Peer-to-Peer systems. During this process, the user can mask himself behind a presented iden-tity with no relationships with the real entity. The identit y is characterized in terms of a set of preferences, and she/he can decide which information to be publicly available. Pseudonyms -many identities -one entity problem : The reader can question if a massive usage of pseudonyms can add noise to the recommendation system. Even if this problem must be carefully analyzed before estimating the real degree of its potential impact, we can adopt a straight-forward solution for filtering out redundant identities. Be -cause Equation (4) is not significantly affected by popularit y factors, a device can simply discard neighbors and/or known hosts with identical ratings lists, assuming that this is an ev-idence of a replicated identity.
 Lists size issue : As shown in Figure 4, the size of the neighbors list, as well as the known nodes lists, can be very large in some cases, and in a real scenario with undefined number of users it can even grow indefinitely. In Section 5.3 we discussed how introduced overhead is not a problem with modern mobile devices, but anyway the problem can be tricky in some cases. This issue can be avoided just intro-ducing a smart strategy for limiting the size of these lists, without removing very relevant references. Some prelimi-nary results in this direction show that limiting the size of the neighbors list does not present significant implication s in accuracy loss. In order to maintain the performance of the algorithms, it is necessary to choose a good strategy to discard neighbors when the list is at its maximum size, and recommendation predictions are very close to optimal accuracy. One good strategy for neighbors list is to keep the nodes with higher affinity value, discarding the hosts that have the lowest values. About the known hosts list, it should have limited size too, but as the cache of known hosts is maintained mainly to mitigate the cold start prob-lem, then the adopted strategy is less critical. However, it is possible to compare behaviors of the system when different strategies are implemented, e.g., LRU, MRU, random dele-tions, and so on. For brevity reasons, this analysis has not been included in this version of the paper.
In this paper we focused on collaborative filtering tech-niques in mobile ad-hoc networks where spontaneous affinity relations are derived and exploited in order to push person-alized suggestions by way of direct meetings between users. We referred to a scenario where devices exchange informa-tion with users in the proximity without accessing to any remote online directory services. We proposed epidemic col -laborative strategies to spread ratings over self-organiz ed communities of users. We simulated the ad-hoc environ-ment and we found that the proposed approach converges very quickly to the prediction accuracy measured in the ref-erence domain with an acceptable overhead.

The implementation and the evaluation of a prototype for experiment the MobHinter framework in a real scenario. This work has been partially supported by the MIUR within the  X  X ROFILES X  project (PRIN) and by the Torino Wire-less Foundation within the X  X D-PVR X  X roject. Panisson has been supported by the  X  X WS Mobility Program X  founded by the CRT Foundation. [1] M. Reardon,  X  X obile communities could fill 3g pipes, X  [2] A. Tveit,  X  X eer-to-peer based recommendations for [3] B. N. Miller, J. A. Konstan, and J. Riedl,  X  X ocketlens: [4] B. J. Mirza, B. J. Keller, and N. Ramakrishnan, [5] S. Castagnos and A. Boyer,  X  X odeling preferences in a [6] A. de Spindler, M. C. Norrie, and M. Grossniklaus, [7] J. A. Pouwelse, P. Garbacki, J. Wang, A. Bakker, [8] J. Pouwelse, P. Garbacki, J. Wang, A. Bakker, [9] B. Xie, P. Han, and R. Shen,  X  X ipecf: a scalable [10] P. Han, B. Xie, F. Yang, and R. Shen,  X  X  scalable p2p [11] T. Oka, H. Morikawa, and T. Aoayama,  X  X ineyard : A [12] B. N. Miller, I. Albert, S. K. Lam, J. A. Konstan, and [13] K. Chorianopoulos,  X  X ersonalized and mobile digital [14] G. Ruffo, R. Schifanella, and E. Ghiringhello,  X  X  [15] G. Ruffo and R. Schifanella,  X  X valuating peer-to-peer [16] A. Panisson, G. Ruffo, and R. Schifanella,  X  X -hinter: a [17] P. Resnick, N. Iacovou, M. Suchak, P. Bergstrom, and [18] J. L. Herlocker, J. A. Konstan, L. G. Terveen, and [19] J. Schafer, D. Frankowski, J. Herlocker, and S. Sen, [20] B. Sarwar, G. Karypis, J. Konstan, and J. Reidl,
