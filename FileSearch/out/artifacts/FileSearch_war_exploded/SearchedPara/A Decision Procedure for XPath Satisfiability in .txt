 XPath [1] is a query language used to navigate the node or node set in XML files. As a sub-language of XSLT, XQuery et al ., XPath has been widely used in XML query, transformation and update. containment problem or to converting it into the homomorphism problem among XPath trees in order to exploit EXPTime or PTime approximate algorithms [2,4-6]. problem for XPath, and is considered to be far from tight than the latter [8]. presence of XML Schema [11], the Node Identity Constraint (NIC), which is common in XPath 2.0, was discussed and a method for deciding the satisfiability of TPQ (Tree and Fan discussed sibling axes in the presence of XML Schema [13]. checking the unsatisfiability for a main class of XPaths under this common situation. 
In this paper, we intend to design algorithms on deciding the satisfiability for a set or without choice are considered. Our major contributions are as follows:  X 
A framework based on automaton techniques, named SAT-DTD , is proposed to (simple API for DTD) events derived from  X  , to decide the satisfiability for P .  X 
Based on the framework SAT-DTD , an algorithm, named SAT-DTD_C , is proposed to identify direct and indirect conflict of XML elements caused by DTD choice and to decide the unsatisfiability of XPath queries caused by the conflict.  X 
The complexities of the above algorithms are analyzed, and the experimental results demonstrate the correctness and the efficiency of our techniques. concepts. Section 3 and 4 describe SAT-DTD and SAT-DTD_C respectively. Section 5 indicates potential optimization points. Section 6 concludes this paper. 2.1 DTD Algorithms based on the subset could be easily extended on DTD that further contains attribute-list declarations. DTD document (e.g. Fig.1(a)) declares the content model for each XML element. content model complex. There are many representations of content model in practice. model tree (e.g. Fig.1(b)) in order to assist in validating XML document. [4] proposed a kind of DTD graph (e.g. Fig.1(c)) to simplify the DTD. We can see that DTD graph partial but detailed view. So we combine these two models to represent DTD. Definition 1. Given a DTD document  X  , the corresponding DTD Graph is a directed &lt;&gt; X  represents that the element corresponding to n element corresponding to n 1 in  X  . T =( N , C ), where bf NN N = X  is the node set, and C is the edge set. Each branch nN  X  , if n is the operand of n 1 in decl e . 2.2 XPath in tree pattern [2] or in automaton [7,9,15]. We choose the latter to describe a set of events to drive the automaton. Now we briefly introduce some related concepts. is the nested path expression of p . A
Fig.3 shows the corresponding automaton of XPath /a//*[c]//e. Circles in the figure represented by line with arrow and crewel with arrow, respectively. 
Suppose that set Preds contains all top level predicat es appearing in a set of XPath the following indices are further added to some kinds of the NFA states.  X  matches the main path expression of p , then p  X  LR( s );  X  pred &gt;  X  LP( s );  X  pred  X  LB( s ). (details are to be discussed in section 4), more indices are added to the NFA:  X  pred , then t  X  LS( s );  X  on the location step corresponding to parent , then p  X  LAPS( s );  X  in pred , then &lt; q , pred &gt;  X  LFPS( s ). constructed from the to-be-decided XPath set to decide the XPath satisfiability. 3.1 SAD Events Currently four kinds of SAD events have been defined: startDTDDocument ( ), element name. First the DTD document is read and parsed into a DTD graph, and then the graph is converted into a tree for the convenience of issuing SAD events. Definition 5. Given a DTD document  X  and the corresponding DTD graph G , we can create the corresponding DTD tree T from G : 1) if G is a tree, then T = G ; 2) if G is a DAG, then T is the expanded tree of G constructed as below: ii) if Q is empty, then the construction completes. Else, take a node v' out of the iii) repeat ii). 3) if G contains a circle, then we can deduce from the set of 
After converting a DTD graph to a DTD tree, we can depth-first traverse the DTD tree to issue SAD events. For instance, Fig.4 shows the corresponding DTD tree expanded from the DTD graph in Fig.1(c) and its SAD endElementDecl , endDTDDocument respectively, the parameter a followed by SE and EE is the element name. This figure omits the content model information. 3.2 SAD Events Handling: Deciding Satisfiability The execution process of NFA is defined by the handling rules on SAD events. This procedure without considering DTD choice. 3.2.1 State Transition 3.2.2 Deciding the Satisfiability of Main Path Expression (6)~(7) in SE event handler of algorithm 1) (see line (4)~(5) in SE event handler of algorithm 1) 3.2.3 Predicates Evaluation Definition 6. Given a DTD  X  and an XPath p , pred is a predicate of p , e is the general expression in pred . Suppose that D is the set of XML documents conforming to  X  . e is satisfiable if there exists d  X  D so that the evaluation of e in d is true. evaluatePred ( pred , q ) uses a bottom-up approach to evaluate the validity of pred . In line (4) of algorithm 2, e  X  X  satisfiability is decided by evaluating func (...), e.g. not ( Q ), its satisfiability is opposite to the parameter Q . 
In EE event handler, if current NFA backtracking state s is a branch state, then get each predicate pred from LB( s ), and reset the next predicate evaluation. 3.2.4 Multiple Match Multiple match is difficult for XSIEQ [15], an XPath query engine on XML stream. It also occurs in deciding XPath satisfiability. one location step ls of p may match more than one DTD elements in different depths. point . the evaluation among predicates on multiple match occurrence point or the evaluation latter case for example. Suppose that multiple match occurrence point ls matches two of sync, and may falsely evaluate the satisfiability of the whole XPath expression p . Proof (briefly) . It can be inferred from the definition of XPath satisfiability. and main path expression fragment /e cannot be satisfied simultaneously. cannot occur in the same XML document simultaneously. To simplify the statement, in this section we use the term node (in DTD tree) instead of element (in DTD). 4.1 Conflict and XPath Unsatisfiability between other nodes is indirect conflict . and sufficient condition of direct conflict between nodes. n recent binary operator ancestor, such as ','. n conflicts. influencing XPath satisfiability. conflicts in any two of the above node sets 1) and 2), p is unsatisfiable. 4.2 Deciding XPath Unsatisfiability Caused by Conflict BS trees. Algorithm 3 gives the decision procedure for XPath satisfiability in the presence of the node conflicts caused by DTD choice are identified to decide the unsatisfiabilty of XPath expressions according to theorem 3. The operations in algorithm 3 are as follows: 
In SE event handler, nodes for each corresponding XPath expr ession beforehand. (line(8)~(11)); 2) promote operation: when reaching result states or leaf states, the corresponding XPath expression is matched. Find all the corresponding APS and FPS states (line (13)~(16)). A same XPath can be matched more than once, so it can be promoted multiple times. 
In EE event handler, 1) clear operation: when backtrack ing to APS, FPS or branch states, clean matched nodes (line(5)~(6), (13)) to prepare for the next decision. 2) check operation: when backtracking to branch state s (line(7)), for each XPath p (line(11)~(12)). through experiments. 5.1 Analysis on the Complexity of SAT-DTD Algorithms According to the conclusion in [8], for the XPath with descendent axes and predicates, the complexity of its satisfiability decision is PTIME only if DTD does not contain choice; and the complexity is NP-complete for arbitrary DTD. 5.1.1 Complexity of SAT-DTD Algorithm without Considering DTD Choice The time complexity of building an automaton from XPath queries is polynomial-time complexity of SAT-DTD (see algorithm 1). Proof. Assume every time all states participate in state transition, then the maximum upper bound of predicate computation complexity is O ( m  X  x q  X  op  X  q ). 
On each multiple match occurrence point, every predicate and the main path complexity is O (( m  X  x q  X  op  X  q l + m  X  x )  X  u ). 
From theorem 4 we can see that multiple match has a great impact on the efficiency except that an XPath expression contains ''//*''. 5.1.2 Complexity of SAT-DTD_C Algorithm model is l , then the complexity of deciding node conflict is O ( w  X  l 2 ) . Theorem 5 gives the extra complexity of runtime SAT-DTD_C compared with SAT-DTD without considering DTD choice. 5.2 Optimization on SAT-DTD_C Algorithm the exponent. It can be optimized in the following aspects.  X  those exclude '|', the complexity of SAT-DTD_C will not exceed SAT-DTD without considering DTD choice.  X 
From the observation we see that the complexity of SAT-DTD_C is mainly caused reduce the complexity of SAT-DTD_C .  X 
Filter out those XPath expressions with high q l and x q , ignore them. 5.3 Correctness Checking Experiments Ordinary DTD documents contain only a small portion of operator '|', making the experiments focused on it more difficult to carry out. The experiments discussed in this sub-section focus on the correctness, that is, whether SAT-DTD can present a correct decision of XPath satisfiability. Table.1 shows some evaluation results in common circumstances. The DTD document used in this experiment is a fragment in XMark [17] the XPath satisfiability in typical circumstances with wildcards and descendent axes. practical systems, in the meantime we will consider more factors that influence XPath Foundation of China under Grant No. 60673126. 
