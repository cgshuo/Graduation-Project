 Dmitriy Zheleznyakov  X  An increasing number of applications rely on RDF, OWL 2, and SPARQL for storing and querying data. SPARQL, however, is not targeted towards end-users, and suitable query interfaces are needed. Faceted search is a prominent approach for end-user data access, and several RDF-based faceted search systems have been devel-oped. There is, however, a lack of rigorous theoretical underpinning for faceted search in the context of RDF and OWL 2. In this pa-per, we provide such solid foundations. We formalise faceted inter-faces for this context, identify a fragment of first-order logic captur-ing the underlying queries, and study the complexity of answering such queries for RDF and OWL 2 profiles. We then study interface generation and update, and devise efficiently implementable algo-rithms. Finally, we have implemented and tested our faceted search algorithms for scalability, with encouraging results.
 H.4.m [ Information Systems Applications ]: Miscellaneous; I.2.4 [ Artificial Intelligence ]: Knowledge Representation Formalisms and Methods Faceted search; Ontology; OWL 2; RDF; SPARQL; Algorithms
The Resource Description Framework (RDF) is the W3C rec-ommendation graph data model for representing information about Web resources, and SPARQL is the standard language for querying RDF. In the last ten years, we have witnessed a constant growth in the amount of available RDF data, and an increasing number of ap-plications are relying on RDF and SPARQL for storing, publishing, and querying data. The functionality of many such applications is enhanced by an OWL 2 ontology: a set of first-order sentences that are used to provide background knowledge about the application Research supported by the Royal Society, the EPSRC projects Score! and MaSI 3 , and the EU FP7 project  X  X ptique X  (n. 318338).
Email: marenas@ing.puc.cl Email: first.middle.lastname@cs.ox.ac.uk domain and enrich query answers with information not explicitly given in the RDF data.

Although the growing popularity of RDF, OWL 2, and SPARQL has been accompanied by the development of better and better query answering engines, writing SPARQL queries is not well-suited for the majority of users. Thus, an important challenge is the devel-opment of simple yet powerful query interfaces that capture well-defined fragments of SPARQL.

Faceted search is a prominent approach for querying document collections where users can narrow down the search results by pro-gressively applying filters, called facets [1]. A facet typically con-sists of a property (e.g.,  X  X ender X  or  X  X ccupation X  when querying documents about people) and a set of possible string values (e.g.,  X  X emale X  or  X  X esearch X ), and documents in the collection are anno-tated with property-value pairs. During faceted search users itera-tively select facet values and the documents annotated according to the selection are returned as the search result.

Several authors have proposed faceted search for querying doc-ument collections annotated with RDF, and a number of systems have been developed, e.g. [2 X 10]. The theoretical underpinnings of faceted search in the context of semantic technologies, however, have received less attention [11 X 13]. In particular, the following key questions have not been satisfactorily addressed (see related work section). (Q1) What fragments of SPARQL can be naturally captured using (Q2) What is the complexity of answering such queries? (Q3) What does it mean to generate and interactively update an
Questions 1 and 2 correspond to the study of expressive power and complexity of query languages in the context of faceted search. These are central topics in data management and addressing them is a key requirement to develop information systems that can pro-vide correctness, robustness, scalability, and extensibility guaran-tees. Furthermore, update (Question 3) is a key task in information systems where query formulation is fundamentally interactive. Our first goal is to answer these questions, thus providing rigorous and solid foundations for faceted search over RDF data.

Furthermore, existing works have focused mostly on RDF, thus essentially disregarding the role of OWL 2 ontologies. We see this as an important limitation. Ontological axioms can be used to en-rich query answers with implicit information, thus enhancing the search for relevant documents. Moreover, they provide schema-level structure, which can be exploited to improve faceted inter-faces. Finally, RDF-based faceted search systems are data-centric, and hence cannot be exploited to browse large ontologies or to for-mulate meaningful queries at the schema level. Our second aim is to address this limitation and provide a framework for faceted search that is also applicable to the wider setting of OWL 2.
We use  X  X ocument X  to refer to any resource referenced by a URI. ( 1 ) A ( x )  X  R ( x,y 1 )  X  B ( y 1 )  X  R ( x,y 2 )  X  B ( y ( 2 ) R ( x,y )  X  S ( x,y ) , ( 3 ) A ( x )  X  X  X  y. [ R ( x,y )  X  B ( y )] , ( 4 ) A ( x )  X  x  X  a, ( 5 ) R ( x,y )  X  S ( y,z )  X  T ( x,z ) , ( 6 ) A ( x )  X  B ( x ) , ( 7 ) A ( x )  X  B ( x )  X  C ( x ) , ( 8 ) R ( x,y )  X  A ( x ) , ( 9 ) A ( x )  X  R ( x,y )  X  B ( y ) , ( 10 ) A ( x )  X  R ( x,a ) , ( 11 ) R ( x,a )  X  B ( x ) , ( 12 ) R ( x,y )  X  A ( y ) , ( 13 ) R ( x,y )  X  S ( y,x ) , ( 14 ) R ( x,y )  X  B ( y )  X  A ( x )
In Section 3 we formalise faceted interfaces that are tailored to-wards RDF and OWL 2 and which capture the key functionality im-plemented in existing faceted search systems. Our interfaces cap-ture both the combination of facets displayed during search, and the facet values selected by users. In this way, an interface encodes both a query, whose answers constitute the current search results, and the facet values available for further selection. Analogously to existing work on RDF-based faceted search and in contrast to traditional faceted search, our notion of interface allows users to  X  X avigate X  across interconnected collections of documents and establish filters to each of them. Furthermore, it abstracts from considerations spe-cific to GUI design (e.g., facet and value ranking), while at the same time reflecting the core functionality of existing systems.
In Section 4 we study the expressivity and complexity of faceted queries : queries encoded by faceted interfaces. To this end, we identify a fragment of first-order logic that is sufficient to cap-ture such queries, and study the complexity of query answering in the presence of OWL 2 ontologies. Since OWL 2 reasoning can be computationally expensive and hence significantly affect sys-tems X  performance and robustness, we focus on ontologies in the OWL 2 profiles [14]: language fragments with favorable computa-tional properties. For each of these profiles we establish tight com-plexity bounds and propose practical query answering algorithms.
In Section 5 we study interface generation and update. Exist-ing techniques for RDF are based on exploration of the underlying RDF graph. In this way, by generating facets according to the RDF graph, systems can guide users in the formulation of  X  X eaningful X  queries. We lift this approach by proposing a graph-based repre-sentation of OWL 2 ontologies and their logical entailments for the purpose of faceted navigation. Then, we characterise what it means for an interface to conform to an ontology, in the sense that ev-ery facet and facet value in the interface is justified by an edge in the graph (and hence by an entailment of the ontology). Finally, we propose generic interface generation and update algorithms that rely on the information in the graph, and show tractability of these tasks for ontologies in the OWL 2 profiles.

In Section 6 we present a faceted search platform that provides functionality for generating and updating interfaces based on our algorithms in Section 5. Our platform relies on an external triple store with OWL 2 reasoning capabilities, and it is compatible with faceted search GUIs, as well as with text search engines for retriev-ing documents from keywords. We have tested the scalability of our platform using different triple stores, with encouraging results. As proof of concept, we have integrated our platform in a faceted search system that bundles the triple store JRDFox, the search en-gine Lucene, and our own faceted search GUI.
We use standard notions from first-order logic. We assume pair-wise disjoint infinite sets of constants C , unary predicates UP , and binary predicates BP . A signature is a subset of C  X  UP  X  BP . We treat equality  X  as an ordinary predicate in BP , and assume that any set of formulae contains the axioms of equality for its sig-nature. We treat &gt; as a special symbol in UP , which is used to represent a tautology. W.l.o.g. we assume all formulae to be recti-fied; that is, no variable appears free and quantified in a first-order formula  X  , and every variable is quantified at most once in  X  . The set of free variables of a formula  X  is denoted as fvar (  X  ) .
A fact is a ground atom and a dataset is a finite set of facts. A rule is a sentence of the form  X  x  X  z [  X  ( x , z )  X   X  y  X  ( x , y )] , where x , z , and y are pairwise disjoint tuples of variables, the body  X  ( x , z ) is a conjunction of atoms with variables in x  X  z , and the head  X  y  X  ( x , y ) is an existentially quantified non-empty conjunction of atoms  X  ( x , y ) with variables in x  X  y . Universal quantifiers are omitted. The restriction of  X  ( x , y ) being non-empty ensures sat-isfiability of any set of rules and facts, which makes query results meaningful. A rule is Datalog if its head has at most one atom and all variables are universally quantified.

OWL 2 defines three profiles : weaker languages with favourable computational properties [14]. Each profile ontology can be nor-malised as rules and facts using the correspondence of OWL 2 and first-order logic and a variant of the structural transformation. Thus, we see an ontology as a finite set of rules and facts. Table 1 specifies the rules allowed in these profiles. An ontology with only sentences from Table 1 is (i) RL if it has no rules of Type (3); (ii) EL if it does not contain rules (1), (9), and (13); and (iii) QL if it does not contain rules (1), (4), (5), (7), (9)-(11), and (14).
Let V be a signature, at ( V ) the set of equality-free and constant-free atoms over V , and eq ( V ) the set of atoms x  X  c with x a vari-able and c a constant from V . A positive existential query (PEQ) Q ( x ) is a formula with free variables x , constructed using  X  ,  X  and  X  from atoms in at ( V )  X  eq ( V ) . A PEQ Q is monadic if fvar ( Q ) is a singleton, and it is a conjunctive query (CQ) if it is  X  -free.
We consider two different semantics for query answering. Under the classical semantics , a tuple t of constants is an answer to Q ( x ) w.r.t. an ontology O if O | = Q ( t ) . Under the active domain seman-tics , t is an answer to Q w.r.t. O if there is a tuple t from O such that O | =  X  ( t , t 0 ) , where  X  ( x , y ) is the formula ob-tained from Q by removing all quantifiers. The evaluation problem under classical (resp. active domain) semantics is to decide, given a tuple of constants t , a PEQ Q and an ontology O in a language L , whether t is an answer to Q w.r.t. O under the given semantics. The classical semantics is the default in first-order logic, whereas active domain is the default semantics of the SPARQL entailment regimes [15]. The latter can be seen as an approximation of the former (an active domain answer is also an answer under classical semantics, but not vice versa). The difference between both semantics mani-fests itself only in the presence of existentially quantified rules and queries; thus, both semantics coincide if either the input ontology is Datalog, or if all variables in the input query are free.
In this section, we formalise a notion of a faceted interface , which provides a rigorous foundation for faceted search over RDF graphs enhanced with OWL 2 ontologies. To motivate our defini-tions, we will use an example based on an excerpt of DBpedia. Our goal is to find US presidents who graduated from Harvard or Georgetown and have a child who graduated from Stanford. E XAMPLE 1. The document URIs d tr and d bc for Theodore Roosevelt and Bill Clinton are annotated with the category  X  X resi-dent X . Roosevelt X  X  son Kermit d kr and Clinton X  X  daughter Chelsea d cc are categorised as  X  X erson X . The document URIs for George-town d g , Harvard d h , and Stanford d s are categorised under  X  X ni-versity X , and the USA d us and UK d uk as  X  X ountry X . These annota-tions are given in RDF and correspond to the following facts:
Note that the profiles provide the special concept  X  , which is im-material to query answering over satisfiable profile ontologies.
Specific information about documents is represented by liter-als. For example, Theodore Roosevelt X  X  date of birth is encoded as dateOfBirth ( d tr , 1858-10-27 ) . Most importantly, documents are also annotated with other documents; such annotations are rep-resented in RDF and correspond to the following facts: citiz ( d tr ,d us ) citiz ( d bc ,d us ) child ( d tr ,d grad ( d tr ,d h ) grad ( d bc ,d g ) grad ( d kr ,d h ) grad ( d Finally, DBpedia can be extended with ontological rules, which are exploited to describe the meaning of the predicates and constants in the vocabulary. Consider for example the rules given next: Rules (1) and (2) define US presidents as those with US national-ity. Rule (3) specifies the domain and range of grad . Finally, (4) mandates that each person has a (maybe unspecified) nationality.
Analogously to traditional faceted search, we represent facets as pairs of a predicate (or facet name) and a set of values. In the con-text of RDF, however, documents can be used to annotate other documents, and thus annotations form a graph, rather than a tree. Thus, facet values can be either document URIs or literals. Ex-amples of facet names are the relations  X  grad  X  and  X  dateOfBirth  X , and example values are documents such as  X  d s  X  and literals such as  X 1858-10-27 X . Selection of multiple values within a facet can be in-terpreted conjunctively or disjunctively, and hence we distinguish between conjunctive and disjunctive facets. We also distinguish a special facet type , whose values are categories (i.e., unary predi-cates) rather than documents or literals. Finally, a special value any denotes the set of all values compatible with the facet name. D EFINITION 2. Let type and any be symbols not occurring in C  X  UP  X  BP . A facet is a pair ( X,  X   X ) , with  X  X  X { X  ,  X  X  ,  X  a non-empty set, and either (i) X = type and  X   X  UP , or (ii) X  X  BP , any  X   X  and either  X   X  C  X  X  any } or  X   X  UP  X  X  any } . A facet of the form ( X,  X   X ) is conjunctive , and a facet of the form ( X,  X   X ) is disjunctive . In a facet F = ( X,  X   X ) , X is the facet name , denoted by F | 1 , and  X  contains the facet values and it is denoted by F | E XAMPLE 3. The following facets are relevant to our example. F 1 = ( type ,  X  X  USpres , Country } ) , F 2 = ( child ,  X  X  any ,d kr ,d cc } ) ,F 3 = ( grad ,  X  X  any ,d F 4 = ( citiz ,  X { any ,d us ,d uk } ) ,F 5 = ( citiz ,  X  X  any ,d The disjunctive facet F 1 can be exploited to select the categories to which the relevant documents belong. Facet F 2 can be used to narrow down search results to those individuals with children; fur-thermore, the value any can be used to state that we are not looking for any specific child. The intuition behind F 3 , F 4 , and F lar; note, however, that facet F 4 is conjunctive.
We next move on to the definition of a faceted interface, which encodes both a query (whose answers determine the search results) and the choices of facet values available for further refinement.
D EFINITION 4. A basic faceted interface (BFI) is a pair ( F,  X ) , with F a facet and  X   X  F | 2 the set of selected values . The set of faceted interfaces (or interfaces, for short) is given by the following grammar, where I 0 and I 1 = ( F,  X ) are BFIs and F | 1  X  BP :
A BFI encodes user choices for a specific facet, e.g., the BFI ( F 1 , { USpres } ) selects the documents categorised as US presidents. BFIs are put together in paths : sequences of nested facets that cap-ture navigation between sets of documents. Documents are anno-tated with other documents by means of binary relations (e.g., child connects parents to their children); thus, nesting ( I the BFI I 1 to have a binary relation as facet name. With nesting we can capture queries such as  X  X eople with a child who gradu-ated from Stanford X  by using the interface ( F 2 , { any } ) / ( F which first selects people having (any) children and then those chil-dren with a Stanford degree. Finally, two types of branching can be applied: ( path 1  X  path 2 ) indicates that search results must satisfy the conditions specified by both path 1 and path 2 , while ( path path 2 ) indicates that they must satisfy those in path 1
E XAMPLE 5. Consider the following interface I ex , which is vi-sualised in our system as in Figure 1. ( F 1 , { USpres } )  X  ( F 3 , { d h ,d g } )  X  ( F 2 , { any } ) / ( F The interface consists of three paths connected by  X  -branching. The first path selects US presidents. The second path selects grad-uates of Harvard or Georgetown. The third path selects individu-als with a child who is a Stanford graduate. Since paths are com-bined conjunctively their constraints apply simultaneously. Thus, we obtain the US presidents who graduated from either Harvard or Georgetown and who have a child who graduated from Stanford.
The query encoded by the selected values in an interface is for-mally specified in terms of first-order logic as given next.
D EFINITION 6. Let I be an interface, and let each x w  X  { 0 , 1 ,..., 9 ,  X }  X  be a variable. The query of I is the formula Q [ I ] = J I,x  X  ,x 0 K , with one free variable x  X  , defined as in Table 2. Our semantics assigns to each interface a PEQ with one free vari-able. For each facet F we have J ( F,  X  ) ,v,x w K = &gt; ( v ) , indicating that no restriction is imposed by F if no value is selected. BFIs with a type -facet are interpreted as the conjunction (disjunction) of unary atoms over the same variable. BFIs having as facet name a binary predicate result in either an atom whose second argument is existentially quantified (if any is selected), or in a conjunction (dis-junction) of binary atoms having a variable as second argument that must be equal to a constant or belong to a unary predicate. Branch-ing ( path 1  X  path 2 ) with  X  X  X { X  ,  X  X  is interpreted by constructing the conjunction (disjunction) of the queries for each path more, if for some path i we have that J path i ,v,x w K = &gt; ( v ) , indi-cating that no value from the facets occurring in path i is selected, then path i is ignored. Finally, nesting involves a  X  X hift X  of variable from the parent BFI to the nested subexpression.
 E XAMPLE 7. Interface I ex encodes the following query:
Q ex ( x ) = USpres ( x )  X   X  y 1 ( grad ( x,y 1 )  X  y 1  X  d If we consider only facts, the answer is empty (e.g., no document is categorised as  X  X S president X ). If we also consider the ontology rules, however, we obtain d bc (i.e., Bill Clinton) as an answer.
Our notion of interface motivates the class of faceted queries , i.e., PEQs that can be captured by some faceted interface.
D EFINITION 8. A first-order formula  X  is a faceted query if there exists a faceted interface I such that  X  and Q [ I ] are iden-tical modulo renaming of variables.

Note that our notion of interface abstracts from several consid-erations that are critical to GUI design. For instance, our notion is insensitive to the order of BFIs composed by  X  -or  X  -branch-ing, as well as to the order of facet values (which are carefully ranked in practice). Furthermore, we model type -facet values as  X  X lat X , whereas in applications categories are organised hierarchi-cally. Although these issues are important from a front-end per-spective, they are immaterial to our technical results.
The interface in Example 5 finds presidents (such as Bill Clinton) who graduated from either Harvard or Georgetown and have chil-dren who graduated from Stanford. If we want to know who these children are (i.e., see Chelsea Clinton as an answer), we must pro-vide refocussing (or pivoting ) functionality [9, 10]. We next extend faceted interfaces to allow for such functionality.
 D EFINITION 9. Let focus be a symbol not occurring in C  X  UP  X  BP . An extended basic faceted interface (EBFI) is either a BFI or a pair ( F,  X   X  { focus } ) , where ( F,  X ) is a BFI and F | 1  X  BP . Moreover, the set of extended faceted interfaces (EFIs) is defined by the same grammar given in Definition 5, but where I is a BFI and I 1 = ( F,  X ) is an EBFI with F | 1  X  BP . Finally, each EFI I must have at most one occurrence of the symbol focus .
The special value focus is used to change the free variable of the query Q , which determines the kinds of objects returned as an-swers. Thus, refocussing is used over a facet that generates new variables in the query, which by Table 2 requires that F |
The query encoded by an extended interface can be specified in terms of first-order logic as given next.

D EFINITION 10. Let I be an EFI and J I,x  X  ,x 0 K be a formula defined by the extension of Table 2 with the rules in Table 3. Then the query of I is the formula Q [ I ] defined as follows:
Q [ I ] = Finally, a formula  X  is an extended faceted query if there is an EFI I s.t.  X  and Q [ I ] are identical modulo renaming of variables.
For example, consider the following EFI I , which is focused on the children of the US presidents: ( F 1 , { USpres } )  X  ( F 3 , { d h ,d g } )  X  ( F 2 , { focus } ) / ( F Then, Q [ I ] is obtained from Q ex ( x ) in Example 7 by first dropping the existential quantifier  X  z from Q ex ( x ) , and then adding the exis-tential quantifier  X  x to the resulting query, thus obtaining Q The answer to Q ex ( z ) is precisely d cc (Chelsea Clinton).
Each time a user selects a facet value to refine the search results, a faceted search system must compute the answers to a query. Thus, query evaluation is a key reasoning problem for the development of efficient and robust faceted search systems.

As discussed in Section 3, faceted queries are monadic positive existential queries resulting from the selection of facet values in an interface. By standard results for relational databases, PEQ evalu-ation is an NP-hard problem, even if we restrict ourselves to CQs and ontologies consisting of just a dataset.

Our main result is that, in contrast to PEQs (and even CQs), faceted query evaluation over datasets is tractable; furthermore, the problem remains tractable in most cases if we consider ontologies belonging to the OWL 2 profiles. Our tractability results concern Algorithm 1: A NSWER -FQ: Faceted Queries over Datasets combined complexity , which takes into account the size of the en-tire input (i.e., ontological rules, RDF data and queries).
The rationale behind our tractability result is that PEQs originat-ing from faceted interfaces are of a rather restricted shape, which is determined by Table 2 in Section 3. A closer look at the table reveals that variables in a faceted query can be arranged in a tree with root x  X  and where each variable x w.i is a child of x
D EFINITION 11. Let Q ( x ) be a monadic PEQ. The graph of Q is the smallest directed graph G Q with a node for each variable in Q and a directed edge ( y,y 0 ) for each atom R ( y,y ring in Q where R is different from  X  . Moreover, Q is tree-shaped if (i) G Q is a (possibly empty) directed tree rooted at x ; (ii) for each edge ( y,y 0 ) there is at most one binary atom in Q of the form R ( y,y 0 ) .
 Note that query Q ex ( x ) in Example 7 is tree-shaped. The second observation in Table 2 is that disjunction in a faceted query origi-nates from either a disjunctive facet or from  X  -branching between paths. In either case, disjunctive subqueries are monadic tree-shaped PEQs. These observations are summarised as follows:
P ROPOSITION 12. Every faceted query Q is a monadic tree-shaped PEQ with the following property: if  X  = (  X  1  X   X  subformula of Q , then fvar (  X  1 ) = fvar (  X  2 ) = { x } for some x .
We next show how the restricted shape of faceted queries can be exploited to make query answering more efficient. We start by providing a polynomial algorithm for answering faceted queries over datasets. The key observation is that the disjunctive subqueries  X  =  X  1  X   X  2 in the input query Q can be evaluated w.r.t. the input dataset in a  X  X ottom-up X  fashion . To answer one such  X  , we solve  X  1 and  X  2 independently and  X  X tore X  the answers as facts in the dataset using a fresh unary predicate C  X  uniquely associated to  X  .
E XAMPLE 13. Query Q ex can be answered over the dataset in our running example as follows. First, solve the subquery  X  asking for graduates from either Harvard or Georgetown; each disjunct is a tree-shaped CQ, and we obtain B. Clinton, T. Roosevelt and K. Roosevelt as answers. Then, extend the dataset with facts C C ( d tr ) and C  X  ( d kr ) over a fresh predicate C  X  . Finally, rewrite Q ex by replacing  X  ( x ) with C  X  ( x ) and answer the rewritten query over the extended dataset. We obtain the empty set of answers since no document is explicitly categorised as US president.
 Algorithm 2: A NSWER -FQ-A CTIVE
Algorithm 1 implements these ideas. The algorithm relies on a specialised algorithm A NSWER -T REE -CQ to answer (monadic) tree-shaped CQs, which is used as a  X  X lack box X . The following theorem establishes correctness of our algorithm.
 T HEOREM 14. Algorithm 1 computes all answers to Q w.r.t. D .
Thus, faceted queries can be evaluated in polynomial time with an oracle for the evaluation of tree-shaped CQs. By a classic result, acyclic CQs (and hence also tree-shaped CQs as in Def. 11) can be answered in polynomial time [16]. Thus, tractability tree-shaped CQ evaluation transfers to the evaluation of faceted queries.
C OROLLARY 15. Faceted query evaluation over datasets is fea-sible in polynomial time.

In what follows we study query answering over ontologies (and not just datasets) under both active domain and classical semantics.
In practice, queries over ontology-enhanced RDF data are typi-cally represented in SPARQL and executed using off-the-shelf rea-soning engines with SPARQL support. The specification of SPARQL under entailment regimes [15] is based on active domain semantics, which requires existentially quantified variables in the query Q to map to actual constants in the input ontology O . In this case, we can answer queries using Algorithm 2, which first computes the dataset D of all facts entailed by O and then answers Q w.r.t. the dataset D . The correctness of Algorithm 2 follows directly from Theorem 14 and the following proposition.

P ROPOSITION 16. Let Q be a PEQ, let O be an ontology, and let D be the set of all facts  X  such that O | =  X  . Then, the active domain answers to Q w.r.t. O and w.r.t. D coincide.

Fact entailment is tractable for all the OWL 2 profiles; thus, by committing to the active domain semantics of SPARQL we can achieve tractability without emasculating the ontology language.
T HEOREM 17. Active domain evaluation of faceted queries is in P TIME w.r.t. all normative OWL 2 profiles. Furthermore, it is P
TIME -complete w.r.t. the EL and RL profiles.
Classical and active domain semantics coincide if we restrict our-selves to Datalog ontologies. Thus, Algorithm 2 can also be used for query answering under classical semantics if the input ontology is Datalog. An immediate consequence is that our results in Theo-rem 17 transfer to OWL 2 RL ontologies under classical semantics.
In contrast to RL, the EL and QL profiles can capture existen-tially quantified knowledge and hence active domain and classi-cal semantics may diverge for queries with existentially quantified variables. To deal with EL ontologies, we exploit techniques de-veloped for the combined approach to query answering [17, 18]. These techniques are currently applicable to guarded EL ontolo-gies, i.e., EL ontologies without axioms of Type (5). The idea is to rewrite rules of Type (3) in Table 1 into Datalog by Skolemising existentially quantified variables into fresh constants.
D EFINITION 18. Let O be in EL. The ontology  X ( O ) is ob-tained from O by replacing each rule A ( x )  X  X  X  y. [ R ( x,y )  X  B ( y )] with A ( x )  X  P ( x,c R,B ) ,P ( x,y )  X  R ( x,y ) , P ( x,y )  X  B ( y ) , where P is a fresh predicate and c R,B is a globally fresh constant uniquely associated with R and B .

Although this transformation strengthens the ontology, it pre-serves the entailment of facts [17]. The following theorem estab-lishes that the evaluation of faceted queries is also preserved.
T HEOREM 19. Let Q be a faceted query, O a guarded EL on-tology, and c a constant in O . Then, O | = Q ( c ) iff  X ( O ) | = Q ( c ) .
Thus, we can answer faceted queries over an EL ontology O by applying Algorithm 2 to  X ( O ) . Since  X  is a linear transforma-tion and  X ( O ) is an RL ontology, we can conclude tractability of faceted query evaluation for EL (a result consistent with existing results for acyclic CQs in EL [19]). In contrast, the evaluation of acyclic CQs is already NP-hard for OWL 2 QL [20] and we can show that faceted query evaluation is NP-complete for OWL 2 QL. The following theorem summarises our results.

T HEOREM 20. Faceted query evaluation under classical seman-tics is (i) P TIME -complete for RL and guarded EL ontologies; and (ii) NP -complete for QL ontologies.
We conclude by arguing that the refocussing functionality does not increase complexity of query evaluation. PEQs obtained from EFIs satisfy Proposition 12, with the only difference that the cor-responding query graph is no longer rooted in the answer variable. Algorithm 1 can be extended to prove that Corollary 15 also holds for extended faceted queries. From this, and using the same tech-niques as in the proofs of Theorems 17 and 20, we obtain that:
P ROPOSITION 21. Extended faceted query evaluation under classical semantics is (i) P TIME -complete for RL and guarded EL; and (ii) NP -complete for QL. Moreover, active domain evaluation of extended faceted queries is in P TIME w.r.t. all normative OWL 2 profiles, and it is P TIME -complete for RL and EL.
Faceted navigation is an interactive process. Starting with an initial interface generated from a keyword search, users  X  X ick X  or  X  X ntick X  facet values and the system reacts by updating both search results (query answers) and facets available for further navigation.
E XAMPLE 22. Consider the interactive construction of our ex-ample interface I ex . Navigation starts with the following interface with no selected value, which may have been generated as a re-sponse to a keyword search (facets F i are given in Example 3): We may then select the category USpres in F 1 , which narrows down the search to US presidents. In response, the system may construct the following new interface I 1 : Interface I 1 incorporates the required filter on US presidents. Fur-thermore, it no longer includes facet F 5 since US presidents have only US nationality and hence any filter over this facet becomes redundant. Next, we select Harvard and Georgetown in facet F which narrows down the search to US presidents with either a Har-vard or Georgetown degree and yields the following interface: Next, we select any in facet F 2 to look for presidents with children. In response, the system constructs the following interface: I = ( F 1 , { USpres } )  X  ( F 3 , { d h ,d g } )  X  ( F 2 , { any } ) / ( F Interface I 3 provides a nested BFI ( F 3 ,  X  ) , which allows us to se-lect the university that children of US presidents attended. We pick Stanford, and the system finally constructs I ex .

We next propose interface generation and update algorithms that are  X  X uided X  by the (explicit and implicit) information in O . Our algorithms are based on the same principle: each element of the initial interface (resp. each change in response to an action) must be  X  X ustified X  by an entailment in O . In this way, by exploring the ontology, we guide users in the formulation of meaningful queries.
There is an inherent degree of non-determinism in faceted navi-gation: if a user selects a facet value, it is unclear whether the next facet generated by the system should be conjunctive or disjunctive, and whether it should be incorporated in the interface by means of conjunctive or disjunctive branching. In applications, however, different values in a facet are typically interpreted disjunctively, whereas constraints imposed by different facets are interpreted con-junctively. Thus, to resolve such ambiguities and devise fully de-terministic algorithms, we focus on a restricted class of interfaces where conjunctive facets and disjunctive branching are disallowed.
D EFINITION 23. A faceted interface I is simple if all facets oc-curring in I are disjunctive, and it does not contain sub-interfaces of the form ( path 1  X  path 2 ) .
We capture the facets that are relevant to an ontology O in what we call a facet graph . The graph can be seen as a concise represen-tation of O , and our interface generation and update algorithms are parameterised by such graph rather than by O itself.

The nodes of a facet graph are possible facet values (unary pred-icates and constants), and edges are labelled with possible facet names (binary predicates and type ). The key property of a facet graph is that every X -labelled edge ( v,w ) is justified by a rule or fact entailed by O which  X  X emantically relates X  v to w via X . We distinguish three kinds of semantic relations: existential , where X is a binary predicate and (each instance of) v must be X -related to (an instance of) w in the models of O ; universal , where (each instance of) v is X -related only to (instances of) w in the models of O ; and typing where X = type , and (the constant) v is entailed to be an instance of (the unary predicate) w .

D EFINITION 24. A facet graph for O is a directed labelled multi-graph G having as nodes unary predicates or constants from O and s.t. each edge is labelled with a binary predicate from O or type . Each edge e is justified by a fact or rule  X  e s.t. O | =  X  of the form given next, where c,d are constants, A,B unary predi-cates and R a binary predicate: (i) if e is c R  X  X  X  d , then  X  e is of the form (ii) if e is c R  X  X  X  A , then  X  e is a rule of the form (iii) if e is A R  X  X  X  c , then  X  e is a rule of either of the form (iv) if e is A R  X  X  X  B , then  X  e is a rule of the form
A ( x )  X  X  X  y. [ R ( x,y )  X  B ( y )] or A ( x )  X  R ( x,y )  X  B ( y ); (v) if e is c type  X  X  X  X  A , then  X  e = A ( c ) .

Moreover, range G ( R ) denotes the set of nodes in G with an in-coming R -labelled edge.
 The first (resp. second) option for each  X  e in (i) -(iv) encodes the existential (resp. universal) R -relation between nodes in e , whereas (v) encodes typing. A graph may not contain all justifiable edges, but rather those that are deemed relevant to the given application.
E XAMPLE 25. Recall our ontology in Example 1. A facet graph may contain nodes for d bc (Bill Clinton) and d cc (Chelsea Clin-ton), as well as for predicates such as USpres and Univ . Exam-ple edges are: (i) a child -edge linking d bc to d cc tified by the fact child ( d bc ,d cc ) ; (ii) a citiz -edge from Person to Country justified by Rule (4) ; and (iii) a grad -edge from d Univ since d cc graduated from Stanford and hence the ontology entails Person ( d cc )  X  X  X  y. ( grad ( d cc ,y )  X  Univ ( y )) . It follows from the following proposition that facet graph compu-tation can be efficiently implemented. In practice, the graph can be precomputed when first loading data and ontology, stored in RDF, and accessed using SPARQL queries. In this way, reasoning tasks associated to faceted search are performed offline.

P ROPOSITION 26. Checking whether a directed labelled multi-graph is a facet graph for O is feasible in polynomial time if O is in any of the OWL 2 profiles.

To realise the idea of ontology-guided faceted navigation, we re-quire that interfaces conform to the facet graph, in the sense that the presence of every facet and value in the interface is supported by a graph edge. In this way, we ensure that interfaces mimic the struc-ture of (and implicit information in) the ontology and the interface does not contain irrelevant (combinations of) facets. Since a given facet or value can occur in many different places in an interface, we need a mechanism for unambiguously referring to each element in the interface. To this end, we introduce an alternative representa-tion of interfaces in the form of a tree. This representation will also be instrumental to our notions of update in Section 5.3.
D EFINITION 27. The node-labelled tree tree ( I ) = ( N,E, X  ) of a simple EFI I is recursively defined as follows. (i) If I is an EBFI, then N = {  X  } , E =  X  , and  X  (  X  ) = I . (ii) If I = ( I 0  X  I 1 ) where tree ( I i ) = ( N i ,E i (iii) If I = ( I 0 /I 1 ) , where tree ( I 1 ) = ( N 1 ,E A position in I is a pair ( w,v ) where w is a node in tree ( I ) with label an EBFI ( F,  X ) and v  X  F | 2  X  X  focus } .
 We can now define conformance of an interface to a facet graph. D EFINITION 28. Let G be a facet graph for O and I a simple EFI. Let ( w 1 ,v 1 ) and ( w 2 ,v 2 ) be distinct positions in I , where  X  ( w i ) in tree ( I ) is ( F i ,  X  i ) and F i | 1 = X i ( w 2 ,v 2 ) is justified by ( w 1 ,v 1 ) in G if w 1 is the least ancestor of w 2 in tree ( I ) with  X  ( w 1 ) 6 =  X  and one of the following holds: (i) there is an X 2 -labelled edge from v 1 to v 2 ; or (ii) v Algorithm 3: C REATE I NTERFACE there is an X 2 -labelled edge from some u  X  range G ( X 1 (iii) v 2 = any and v 1 has an outgoing X 2 -edge; or (iv) v any and u has an outgoing X 2 -edge for some u  X  range G ( X
Interface I conforms to G if for each position ( w,v ) in I , one of the following holds: (i) there is no ancestor w 0 of w in tree ( I ) with  X  ( w ) 6 =  X  ; or (ii) there is a position ( w 0 ,v ( F 0 ,  X  0 ) , v 0  X   X  0 and ( w,v ) is justified by ( w 0 ,v
Intuitively, ( w 2 ,v 2 ) is justified by ( w 1 ,v 1 ) if there is an edge from v 1 to v 2 labelled with the facet name X 2 of F 2 . This indicates that there is an entailment in O that justifies the appearance of v given v 1 and X 2 . Our definition, however, must also consider that v can be any , which indicates that any value reachable by using the facet name X 1 of facet F 1 can be used to justify v 2 . Analogously, v can also be any , in which case it is enough to use v 1 to justify any value reachable by using the facet name X 2 .
Algorithm 3 shows how a fresh interface can be generated from a starting set mS of nodes in a facet graph G . The algorithm starts by grouping all unary predicates categorising the constants in S in a BFI (Lines 1-2). Then, for each binary predicate R and each v  X  S , the algorithm collects the nodes w with an incoming R -edge from v and groups them in sets  X  and  X  0 depending on whether they are constants or unary predicates (Lines 3-7). All constants in  X  (resp. predicates in  X  0 ) are put together in a BFI with facet name R , which is coupled to the interface using  X  -branching (Lines 8-9).
Algorithm 3 can be directly exploited to generate an initial inter-face from a set of keywords. A faceted search backend would first compute an initial set D of documents relevant to the keywords (e.g., using a text search engine), and then generate an initial in-terface by calling Algorithm 3 with input D and a facet graph for O . The resulting interface I has no selected facet values or nested facets, which reflects that I constitutes the starting point to naviga-tion. Furthermore, I is conformant to the input graph G .
P ROPOSITION 29. On input G and S , Algorithm 3 outputs a simple interface that conforms to G .
The initial interface where no facet value has been yet selected marks the start of the navigation process. User actions on an inter-face can be seen as elementary  X  X icking X  and  X  X nticking X  operations on facet values that result in another interface. We define these ac-tions by exploiting the tree representation of interfaces (c.f. Defini-tion 27). We start with the ticking operation.
 D EFINITION 30. The action T ICK is applicable to a simple EFI I , a position ( w,v ) in I , and a facet graph G for O under the following preconditions: (i) v is not selected in  X  ( w ) and (ii) if an ancestor w 0 of w in tree ( I ) is labelled with an EBFI ( F  X  6 =  X  . The result is the interface computed by Algorithm 4. Algorithm 4: T ICK Algorithm 5: U NTICK
Algorithm T ICK starts by checking whether the value v is focus , in which case it adds v to  X  and removes all other occurrences of focus in I (Lines 1-2). Otherwise, it generates a fresh EFI I from I by adding v to  X  (Line 4), and constructs a new EFI I that collects all the values adjacent to v in G (Line 5). Notice that if v = any , then the value v itself is not considered; instead, v is replaced by the values in G with an incoming F | 1 -labelled edge. Finally, Algorithm T ICK includes in I 1 the navigation alternatives encoded in I 2 by considering two cases. If w is a leaf in tree ( I then we incorporate I 2 via nesting by replacing  X  ( w ) in I (  X  ( w ) /I 2 ) (Line 7); otherwise, w has a nested child w 0 in tree ( I in which case the navigation alternatives encoded in I 2 are included in w 0 by replacing  X  ( w 0) in I 1 with (  X  ( w 0)  X  I 2
P ROPOSITION 31. Assume that I , ( w,v ) and G are as in Def-inition 30. If I conforms to G , then T ICK ( I, ( w,v ) ,G ) is a simple EFI that also conforms to G .

We next define the unticking operation. Intuitively, when untick-ing a value v in a given position of an interface all values that were justified by v (and only by v ) should also be unticked. In particu-lar, we say that ( w 2 ,v 2 ) is uniquely justified by ( w ( w 2 ,v 2 ) is justified by ( w 1 ,v 1 ) in G and ( w 2 ,v 2 in G by any pair other than ( w 1 ,v 1 ) .
 D EFINITION 32. The action U NTICK is applicable to a simple EFI I , a position ( w,v ) in I and a facet graph G for an ontology O , if v  X   X  with ( F,  X ) the label of w in tree ( I ) . The result is the interface computed by Algorithm 5 .

Algorithm U NTICK considers two cases depending on what kind of value v is unticked. If v is focus , then the value is simply unse-lected (Line 1). Otherwise, not only  X  must be replaced in I with  X  \{ v } , but also all the positions in I that are uniquely justified by ( w,v ) have to be unticked (Lines 2-5). Unticking propagates recursively along the tree of I since positions deeper down the tree could ultimately be affected. Finally, the algorithm makes sure that no selected value remains  X  X isconnected X  with the rest (Lines 7-9).
P ROPOSITION 33. Assume that I , ( w,v ) and G are as in Defi-nition 32. If I conforms to G , then U NTICK ( I, ( w,v ) ,G ) is a sim-ple EFI that also conforms to G .
An important issue in the design of faceted interfaces is to avoid the overload of users with redundant facets or facet values. Intu-itively, an (unselected) facet value v is redundant if selecting v ei-ther leads to a  X  X ead end X  (i.e., an empty set of answers) or it does not have an effect on query answers. Then, a faceted interface is minimal if none of its component BFIs contains redundant values.
D EFINITION 34. Let I be a simple EFI and G a facet graph for O . Then I is minimal w.r.t. G if for each position ( w,v ) in I s.t. T ICK is applicable to I , ( w,v ) and G , the following holds: (i) Q [ T ICK ( I, ( w,v ) ,G )] has non empty answers w.r.t. O ; and (ii) the answers to Q [ T ICK ( I, ( w,v ) ,G )] w.r.t. O are different from the answers to Q [ I ] w.r.t. O .

Note that the transition from interface I 0 to I 1 in Example 22 involves a minimisation step. The BFI in I 0 involving F 5 since ticking a value will either not affect the search results (if any or d us is ticked) or yield an empty set of answers (if d
To avoid overwhelming users with irrelevant information, our system minimises the output of Alg. 4 before showing it to the user. Our system  X  X uns X  each possible expansion of a EFI in the background by calling the reasoning engine, and prunes all facet values that do not change query answers, or make them empty.
We have developed a faceted search platform providing the fol-lowing main functionality: (i) computation of facet graphs from an ontology; (ii) interface generation from facet graphs; and (iii) inter-face update in response to user actions. Our platform relies on an external triple store for querying and OWL reasoning.
 In our implementation, facet graphs are represented in RDF: each R -labelled edge from v to w is stored as a triple ( v,R,w ) . A graph G can be either loaded from an existing RDF document, or con-structed from (the facts entailed by) the ontology O by adding ad-ditional edges. The kinds of relevant additional edges are described by means of customisable rules, and the edges themselves are com-puted by materialisation of such rules. Furthermore, our platform implements Algorithm 3 for generating interfaces, Algorithms 4 and 5 for interface update, and strategies for interface minimisa-tion. Our algorithms can operate both under the assumption that the facet graph G is explicitly materialised, or it is defined virtually using rules and then generated  X  X n the fly X  as needed.

We have implemented a proof-of-concept system, called SemFacet , that bundles our platform with JRDFox 3 as triple store, Lucene for keyword search, and an HTML 5 GUI [21]. The system X  X  architec-ture is given in Figure 2(c). Our system is available online.
Performance of our platform critically depends on the follow-ing parameters of the underlying triple store, which can be esti-mated empirically by benchmarking the triple store over the dataset of interest: (i) t [ run query ] : time to execute an atomic query; and (ii) t [ look up ] : time to iterate over query results.
Interface generation (Algorithm 3) requires computing all triples ( v,w,u ) in the facet graph G for each v in the input nodes S , and then iterating over the results to compose the interface. Thus, to estimate the cost of interface generation ( t CI ), we can use Alg. 6 instead of Alg. 3. We assume constant time for the call to C
I NTERFACE . The cost can then be estimated as follows: t CI = ( | S | X  t [ run query ]) + (#[ answers ]  X  t [ look up ]) . (5) In this expression, #[ answers ] is the union of all sets Triples each v  X  S . In the worst-case, #[ answers ] is | G | , whereas in the best-case it corresponds to | S | . For improved efficiency, our plat-form implements a variation of Algorithm 6 where facets are com-puted lazily: facet names are computed first, and values are com-puted  X  X n demand X  when users click on a facet. For this, we mod-ify the query in Line 3 such that ? y is the only answer variable. Then, #[ answers ] is estimated as follows, where the number of facet names corresponds to the number of different edge labels in G , and the number of facet values to the number of nodes: #[ answers ] naive = O (#[ facet names ])  X  O (#[ facet values ]) , #[ answers ] lazy = O (#[ facet names ]) .
 The cost t CI in (5) can also be used to estimate the cost of interface updates. The Algorithm for ticking (Sec. 5.3) can be seen as a vari-ant of Alg. 6 with S the set of values relevant to the tick. In the case of unticking, the worst-case cost is estimated as k  X  t CI number of selected values in the interface. Indeed, k measures the worst-case number of recursive calls to U NTICK (Alg. 5), whereas t
CI estimates the cost of a single recursive call.
To estimate the parameters t [ run query ] and t [ look up ] , thus also estimating the cost t CI of interface generation, we have conducted experiments over a fragment of DBpedia enriched with OWL 2 RL rules and we have used JRDFox, Stardog ( http://stardog. com/ ) and Sesame ( http://www.openrdf.org/ ). All experiments were conducted on a MacBook Pro laptop with OS X 10.8.5, 2.4 GHz Intel Core i5 processor, and 8GB 1333 MHz DDR3 memory. Since triple stores such as JRDFox operate in main memory, and we wanted to test our algorithms on stock hardware, we considered a fragment that covers 20% of DBpedia ( 3 . 5 million triples) and which can be loaded using 8GB of RAM. Each experiment was executed 100 times it total, and we measured average and median running time for each experiment. Since results never differ in more than 5% for a single experiment, we report only average times.
Results are summarised in Figures 2(a) and 2(b). Figure 2(a) es-timates #[ answers ]  X  t [ look up ] by measuring time required to it-erate over an answer set of a given size. In turn, Figure 2(b) esti-mates | S | X  t [ run query ] by computing the times required for the triple store to answer a given number of atomic queries. We can make the following observations: (i) The time needed to iterate over query results is small in comparison to query execution times; for example, to execute 10 , 000 queries, JRDFox requires 0 . 498 s , whereas to iterate over 10 , 000 answers it requires 0 . 002 s . This should be taken into account when optimising interface generation. (ii) In some triple stores (i.e., Stardog and Sesame), iteration and query answering times do not grow linearly, and they have to be de-termined empirically. In contrast, JRDFox shows linear behaviour.
We first discuss query execution times. To generate the initial in-terface, the size of S is determined by the number of relevant results returned by the search engine from keywords. If the ranking algo-rithm of the search engine produces high quality results, one can establish a cap on S . As shown in Figure 2(b), obtaining a reason-able cap is important since query execution is expensive. For ex-ample with a cap of 1 , 000 results in S , JRDFox would execute the queries necessary for interface generation almost instantaneously.
Concerning iteration times over query results, JRDFox could perform this task in 0 . 2 s for 1 million results and 2 s for 10 mil-lion. We were not even able to conduct experiments with 10 million answers over Stardog and Sesame since loading the data in our ma-chine consumed all RAM and system behavior became unstable. The facet graph for the whole of DBpedia contains 24 million facet values and 1 , 843 facet names [4]. JRDFox would require 5 s in the worst-case to iterate through that many values using the exhaustive algorithm. When computing interfaces lazily, all triple stores would complete the required iteration over facet names instantaneously.
The design of visual interfaces for querying ontologies has re-ceived significant attention in recent years. Existing systems typi-cally support query formulation by exploiting either a form of con-trolled natural language (e.g., Quelo [22]), or different graphical representations for queries (e.g., SEWASIE [23], iSPARQL [24], OntoVQL [25], Wonder [26], or the OptiqueVQS [27], or other ap-proaches, including interactive exploration of [28].

Faceted search over RDF has also attracted a great deal of at-tention. Developed systems include mSpace [5], /facet [7], Piggy Bank [8], Tabulator [2], gFacet [6], Humboldt [9], Parallax [10], Longwell [29], faceted DBpedia [4], X-ENS [3], Broccoli [30], and others [31 X 33]. The functionalities provided by these systems in-clude navigation through different sets of documents, refocussing, and interface minimisation via elimination of dead-ends.
These works are primarily systems-oriented and their main focus is on improving user experience, development of ranking functions and value grouping heuristics [11, 13], and backend optimisation via indexing schemes [4, 34]. Our framework was inspired by the capabilities of existing systems, and covers their main functionali-ties. Since our aim was to study the fundamental properties of query languages and update tasks, our framework abstracts from (and is compatible with) usability, ranking, and indexing considerations.
The expressivity of the query languages supported by existing systems is discussed in the literature mostly verbally, which makes it difficult to determine the underpinning SPARQL fragment. Most systems seem to support some form of conjunctive queries (e.g., see [11, 13]), and disjunction is present only in a limited form [3, 4]. The approach of [12] allows for conjunction, disjunction, and other operators, e.g., negation, thus, they cover a wider fragment of SPARQL than we do. At the same time, [12] is orthogonal to other faceted search approaches for RDF, including ours: their facet val-ues are possible queries rather than (set of) documents, and a selec-tion of a facet value corresponds to a syntactic query transformation rather than to setting a filter on a set of documents. Expressiveness of this approach is determined by the expressiveness of queries that are allowed to be used as facet values.

When query languages have not been formalised, the complexity of query answering was not addressed. The common assumption is that user selections in an interface are compiled in SPARQL [12] or Prolog [7], and executed by a query evaluation engine over the un-derlying RDF data. Complexity considerations are, however, criti-cal when RDF data is enhanced with OWL 2 reasoning. This setting was not addressed by existing systems, where ontological axioms are limited to class and property hierarchies [7, 11], and reasoning plays little or no role. Interface generation and update mechanisms are mostly informally described. A common approach is to gen-erate and update interfaces from the RDF data graphs. Since we generate interfaces from facet graphs that subsume RDF datasets, we see our approach as a generalisation of existing work. Finally, scalability of faceted search systems over large RDF datasets is an important concern [4, 34]. Since facet graphs can be much larger than the underlying RDF datasets, scalability becomes even more critical in our setting. Our experiments, however, suggest that our approach is feasible in practice.

The works closest to ours are [11 X 13]. The query language in [13] is formalised using CQs, whereas the language in [11] (also con-junctive) is introduced via set operations. These works, however, do not study the complexity of query answering, and ontological reasoning is also not considered. We can also find notions of facet trees and graphs in the literature [7, 11, 13, 29, 35]. These repre-sent combinations of (possibly nested) facets displayed in a GUI as a tree or a graph, and they depend on both search results and front-end considerations. We see our notions of interface and facet graph as GUI-independent generalisation of existing notions since our graphs are derived from ontologies and independently from search results. Finally, the  X  X avigation graph X  of [12] defines nav-igation links at the syntactic level as query transformations, rather than semantic relations between sets and objects, as in our case.
In this paper, we have established theoretical foundations for faceted search in the context of RDF and OWL 2. Our results sug-gest many problems for future work, such as exploring extensions of our update algorithms beyond simple interfaces. Concerning sys-tem design, substantial work is needed to improve GUI design, es-pecially with respect to refocussing. We are also planning to bench-mark our platform on real-world applications. [1] D. Tunkelang. Faceted Search . Morgan &amp; Claypool [2] T. Berners-Lee, J. Hollenbach, K. Lu, J. Presbrey, [3] P. Fafalios and Y. Tzitzikas. X-ENS: Semantic Enrichment [4] R. Hahn, C. Bizer, C. Sahnwaldt, C. Herta, S. Robinson, [5] m.c. schraefel, D. A. Smith, A. Owens, A. Russell, [6] P. Heim, J. Ziegler, and S. Lohmann. gFacet: A Browser for [7] M. Hildebrand, J. van Ossenbruggen, and L. Hardman. [8] D. Huynh, S. Mazzocchi, and D. R. Karger. Piggy Bank: [9] G. Kobilarov and I. Dickinson. Humboldt: Exploring [10] D. F. Huynh and D. R. Karger. Parallax and Companion: [11] E. Oren, R. Delbru, and S. Decker. Extending Faceted [12] S. Ferr X  and A. Hermann. Semantic Search: Reconciling [13] A. Wagner, G. Ladwig, and T. Tran. Browsing-oriented [14] B. Motik, B. Cuenca Grau, I. Horrocks, Z. Wu, A. Fokoue, [15] W3C: SPARQL 1.1 Entailment Regimes . [16] M. Yannakakis. Algorithms for Acyclic Database Schemes. [17] G. Stefanoni, B. Motik, and I. Horrocks. Introducing [18] R. Kontchakov, C. Lutz, D. Toman, F. Wolter, and [19] M. Bienvenu, M. Ortiz, M. Simkus, and G. Xiao. Tractable [20] S. Kikot, R. Kontchakov, and M. Zakharyaschev. On [21] M. Arenas, B. Cuenca Grau, E. Kharlamov, S. Marciuska, [22] E. Franconi, P. Guagliardo, M. Trevisan, and S. Tessaris. [23] D. Beneventano, S. Bergamaschi, F. Guerra, and [25] A. Fadhil and V. Haarslev. OntoVQL: A Graphical Query [26] D. Calvanese, C. M. Keet, W. Nutt, M. Rodriguez-Muro, [27] A. Soylu, M. Giese, E. Jim X nez-Ruiz, E. Kharlamov, [28] N. Manolis and Y. Tzitzikas. Interactive Exploration of [29] C. Veres, K. Johansen, and A. L. Opdahl. Browsing and [30] H. Bast, F. B X urle, B. Buchhold, and E. Hau X mann. Easy [31] O. Suominen, K. Viljanen, and E. Hyv X nen. User-Centric [32] P. Haase, D. M. Herzig, M. A. Musen, and T. Tran. [33] S. Buschbeck, A. Jameson, R. Troncy, H. Khrouf, [34] H. Bast and B. Buchhold. An Index for Efficient Semantic [35] P. Heim, T. Ertl, and J. Ziegler. Facet Graphs: Complex
