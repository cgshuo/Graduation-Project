 In this paper, we demonstrate the FusionDB system; an ex-tended relational database engine for managing conflicts in small-science databases. In small sciences, groups X  X ach con-sists of few scientists X  X ay share and exchange parts of their own databases among each other to foster collaboration. The goal of such sharing, especially when done at early stages of the discovery process, is not to build a warehouse or a uni-fied schema, instead the goal is to compare and verify results, detect and assess conflicts, and possibly modify or re-design the discovery process. FusionDB is designed to meet the re-quirements and address the challenges of such sharing model. We will demonstrate the key functionalities of FusionDB in-cluding: (1) Detecting conflicts using a rule-based model over heterogeneous schemas, (2) Assessing conflicts and providing probabilistic estimates for values X  correctness, (3) Extended querying capabilities in the presence of conflicts, and (4) Pro-viding curation operations to help scientists resolve and in-vestigate conflicts according to different priorities. FusionDB is realized on top of PostgreSQL DBMS.
 H.2.1 [ Database Management ]: Logical Design X  Data models, Schema and subschema Conflict management; databases; scientific data.
Database management systems play a key role in support-ing scientific applications in various domains such as in bi-ology, chemistry, physics, and earth and ocean sciences. In these applications, most discoveries and innovations are not driven by centralized processing, instead, they are fueled by small sciences where many small-scale groups of scientists are conducting their own experiments, collecting measurements, and storing their own data in local databases. Then, related groups working on the same (or similar) objects/subjects may collaborate by exchanging and sharing parts of their own data with each other. Such collaboration and sharing of data can be done at early stages of the discovery process with the aim for comparing and verifying results with each other, detect-ing and assessing conflicts as early as possible, and possibly refining experimental setups or adjusting parameters. These goals are different from those of traditional data integration systems, e.g., [10, 12, 7, 11], that aim for building a unified and consistent warehouse. Thus, the system requirements and desired functionalities in small-science data sharing can-not be fulfilled using existing data integration systems.
Sharing data in small sciences involve several novel and unique data management challenges w.r.t conflict manage-ment and resolution for several reasons: (1) Scientific databases inherently contain conflicts that cannot be avoided or eliminated. This is because there no single authority for curating the data, different in-terpretations and observations may lead to different values, and different scientists may have different beliefs about their data. Therefore, trying to create a single consistent instance over the shared data X  as in the traditional data integration systems, e.g., [7, 11, 8, 4] X  may not be applicable. (2) Availability of conflicting data for analysis and querying. Although conflicting data may sometimes lead to confusion, scientists do prefer to have all the data available X  even if conflicting X  X or analysis, querying, and comparison with other values. Therefore, discarding conflicting data as early as possible outside the database system X  X s in update exchange systems, e.g., [6, 5, 9] X  is not desirable as it causes the lose of valuable information before even doing any anal-ysis over the data. (3) Ability to automatically assess conflicts and pro-vide recommendations. Scientists are of great need for au-tomatic mechanisms for detecting possible conflicts, assessing them, and probably providing evidence-based recommenda-tions on which values are more likely to be correct (or wrong). Moreover, if a scientist wants to investigate conflicts, then which ones have higher priorities to start with? Certainly, different scientists may have different priorities. Delegating these tasks to end-users X  X s in current conflict-resolution tech-niques, e.g., [5, 8, 9] X  is usually an overwhelming and error-prone task.

In this paper, we demonstrate FusionDB system; an ex-tended relational database management system for support-ing data sharing in small sciences. In Figure 1, we illustrate the underlying sharing model where one site S host , e.g., a small scientific lab, may collect a set of databases, denoted by D , D 2 , ..., D k , from several other collaborating sites. Each of these databases has its own structure (schema) and they will all be stored locally at site S host along with S host database D host . Each database D i provided by site S i only a small subset of the database at that site. In the model, any site can be a host and may receive data from other sites, and in this case each host should run a separate instance of FusionDB system. FusionDB manages the collected datasets and provides the following key novel functionalities: (1) Rule-based Conflict Detection: FusionDB allows the host site, e.g., S host in our example, to define a set of rules, called matching rules , for matching records and val-ues. These rules will guide the system to automatically find the records that should compare with each other (entity res-olution), how they should compare (comparison mechanism), and how to measure the degree of conflict if exists (quantify-ing the degree of conflict). (2) Conflict Assessment: If conflicts exist, then a cru-cial task is to predict and estimate X  X ith a certain degree of confidence X  which among the conflicting values are er-roneous and which ones are correct. FusionDB provides a conflict assessment mechanism using a probabilistic model and integrates it in query processing. (3) Curation Mechanisms for Conflict Resolution: FusionDB enables scientists to prioritize the existing conflicts for possible resolution or further investigation. We provide different curation operators for different prioritization, e.g., conflicts that affect the largest number of queries are the ones to investigate first, or conflicts with the least degree of mismatch are the ones to resolve first. (4) Conflict-aware Query Processing: FusionDB extends the relational query operators to offer conflict-aware querying capabilities, e.g., users can query only non-conflicting tuples, can specify thresholds to eliminate tuples above a certain degree of conflicts, and can propagate the conflict information along with their queries answers.
In this section, we briefly highlight the four novel function-alities offered by FusionDB. All what is needed from end-users to utilize the functionalities of FusionDB is to define the matching rules introduced in Section 2.1.
In order to detect conflicts, the system needs first to know which tuples represent the same object and hence should be compared with each other. Moreover, the system should know how to compare these tuples, e.g., which fields to match and using which functions. These tasks are not straightfor-ward especially under heterogeneous schemas. Automated schema mapping and entity resolution techniques, e.g., [11, 8, 10], usually require user X  X  intervention, at some point, to validate the mappings and correct mismatches. In FusionDB, we deploy a generic and simple user-driven rule-based model to perform the above tasks using the new Create Matching Rule command introduced to SQL as follows: Figure 2 illustrates an example of defining a matching rule between two tables storing gene information. In the example, two tuples are comparable to each other if they have the same IDs (the Where clause), and to decide whether they are matching or not, the names of the genes are compared using function NameMatch() , while the gene functions are compared using function FunctionMatch() . Note that fields do not have to be one-to-one match as illustrated in the gene function comparison.
FusionDB estimates, with a certain degree of confidence, which among the conflicting values are the erroneous ones and which are the correct ones. This estimation does not only help scientists in resolving conflicts by providing use-ful hints, but it also enables integrating these estimations in query processing even before resolving the conflicts.
FusionDB computes a degree of confidence, called correct-ness support , at two granularities, tuple-level and attribute-level. The correctness support of a given tuple r is defined as CorrSupp ( r ) = r m /r n , where r m is the number of tuples compatible with r , while r n is the total number of tuples com-parable with r . The example in Figure 3 illustrates the main idea. Assume that we have 4 tuples r 1 , r 2 , r 3 , and r are comparable to each other w.r.t function F () according to the graph depicted in Figure 3(a), e.g., r 1 is comparable to the other three tuples while r 2 , for example, is comparable to r 1 and r 4 only. Assume that according to the matching rules defined in the system, r 1 is conflicting with the other tuples X  X s indicated by dashed lines in Figure 3(b) X  while the other tuples are compatible X  X s indicated by double lines in Figure 3(b). From Figure 3(b), we observe that r 1 is not supported by any other tuples, and hence its CorrSupp( r 1 = 0/3 , while r 4 , for example, is supported by 2 tuples out of the 3 comparable tuples, and hence CorrSupp( r 4 ) = 2/3 . The other tuples have correctness support of 1/2.
 The attribute-level correctness support is defined as CorrSupp ( r.c ) = 1  X  r x c /r n , where r x c is the number of tuples conflicting with r because of r.c , i.e., there is a func-tion F i that takes r.c as input and returns a non-zero value, and r n is as defined before. In contrast to the tuple-level correctness support, the attribute-level support enables the query engine to dynamically compute the correctness support based on only the attributes touched by the query, instead of the entire record (See Section 2.4).
FusionDB provides several curation operators that help sci-entists resolve and investigate conflicts. The database may contain many conflicting tuples, and the question is: which among these conflicts to investigate first? FusionDB offers the following operators:  X  ReportConflicts  X ( R ) : Where given a relation R  X  which can be an output from a select statement X  report for each tuple t  X  R all conflicting tuples with t . ReportConflicts operator reports along with the conflicting tuples, the reasons of the conflict, e.g., which comparison function(s) have failed, and the conflicting score.  X  PrioritizeConflicts  X ([ X ( R ) | ALL ] , sort type, direction ) : Where the first parameter is either a subset of the conflicts that users want to focus on (they are defined using the ReportConflicts operator) or all the conflicts in the database (using the ALL keyword). The sort type parameter specifies how to sort the conflicts. FusionDB offers three types of sorting criteria: (1) SCORE  X  X here conflicts are sorted based on their scores, (2) CNT  X  X here conflicting tuples are sorted based on how many other tuples they conflict with, and (3) POPULARITY  X  X here conflicting tuples are sorted based on how many queries they appear in. The last parameter in PrioritizeConflicts operator specifies the sorting direction, i.e., ascending or descending.
FusionDB extends the querying mechanism to seamlessly integrate the conflict information into query processing. Two  X  X onceptual X  attributes have been added to each tuple in the database, namely CorreSupp and RelCorrSupp . CorreSupp is of type double and represents the tuple-level correctness support, while RelCorrSupp is of type array[double] and rep-resents all the attribute-level correctness supports for the give tuple. These attributes are not actually materialized in the database, but can be referenced in the select statement like regular attributes. The other extension provided by Fu-sionDB is the automatic propagation of the attribute-level CorrSupp values along with the queries X  X  answers, i.e., each attribute value gets annotated with is CorrSupp value. For SPJ (select-project-join) queries, each value gets annotated with a single CorrSupp value, while in the case of aggregation, duplicate elimination, and set operators, each value may get annotated with an array of CorrSupp values resulted from merging multiple identical tuples into one.
We demonstrate the features of FusionDB over a set of publically-available biological databases. More specifically, we will use Genobase , EcoCyc , PortEco , and ColiBase . Each dataset has its own schema for storing gene-related informa-tion of E.coli. organism. All datasets store information for about 4,100 genes (for a single strain), however, they are not all identical and there are many conflicts in the overlapped information. In the demonstration, we treat one dataset, e.g., Genebase , as the host database, and the others will be the sharing-sites databases. And then, we will illustrate, through a Java-enabled GUI, the functionalities presented in Section 2.
As highlighted in Section 1, the goals and motivation for data sharing in small sciences are unique, which makes state-of-art techniques fall short in managing conflicts in small-science databases. For example, data integration systems, e.g., [7, 8, 12], along with their involved technologies in schema mapping [11, 10, 4], entity resolution [12, 3], ETL (Extract-Transform-Load) techniques [2, 3], and data ware-housing [1], aim for creating a single consistent instance of the database and they try to resolve conflicts before building the integrated version of the data. Update-Exchange systems [6, 5, 9] resolve conflicts outside the DBMS and try to keep the database instance at each site consistent. Hence, conflicting data are not available for future analysis or querying.
