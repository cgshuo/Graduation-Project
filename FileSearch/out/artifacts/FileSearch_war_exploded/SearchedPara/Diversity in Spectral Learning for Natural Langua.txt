 It has been long identified in NLP that a diverse set of solutions from a decoder can be reranked or re-combined in order to improve the accuracy in var-ious problems (Henderson and Brill, 1999). Such problems include machine translation (Macherey and Och, 2007), syntactic parsing (Charniak and Johnson, 2005; Sagae and Lavie, 2006; Fossum and Knight, 2009; Zhang et al., 2009; Petrov, 2010; Choe et al., 2015) and others (Van Halteren et al., 2001).

The main argument behind the use of such a di-verse set of solutions (such as k -best list of parses for a natural language sentence) is the hope that each solution in the set is mostly correct. There-fore, recombination or reranking of solutions in that set will further optimize the choice of a solu-tion, combining together the information from all solutions.

In this paper, we explore another angle for the use of a set of parse tree predictions, where all pre-dictions are made for the same sentence. More specifically, we describe techniques to exploit di-versity with spectral learning algorithms for natu-ral language parsing. Spectral techniques and the method of moments have been recently used for various problems in natural language processing, including parsing, topic modeling and the deriva-tion of word embeddings (Luque et al., 2012; Co-hen et al., 2013; Stratos et al., 2014; Dhillon et al., 2015; Rastogi et al., 2015; Nguyen et al., 2015; Lu et al., 2015).
 Cohen et al. (2013) showed how to estimate an L-PCFG using spectral techniques, and showed that such estimation outperforms the expectation-maximization algorithm (Matsuzaki et al., 2005). Their result still lags behind state of the art in natu-ral language parsing, with methods such as coarse-to-fine (Petrov et al., 2006).

We further advance the accuracy of natural lan-guage parsing with spectral techniques and L-PCFGs, yielding a result that outperforms the orig-inal Berkeley parser from Petrov and Klein (2007). Instead of exploiting diversity from a k -best list from a single model, we estimate multiple models, where the underlying features are perturbed with several perturbation schemes. Each such model, during test time, yields a single parse, and all parses are then used together in several ways to select a single best parse.

The main contributions of this paper are two-fold. First, we present an algorithm for estimating L-PCFGs, akin to the spectral algorithm of Cohen et al. (2012), but simpler to understand and imple-ment. This algorithm has value for readers who are interested in learning more about spectral al-gorithms  X  it demonstrates some of the core ideas in spectral learning in a rather intuitive way. In addition, this algorithm leads to sparse grammar estimates and compact models.

Second, we describe how a diverse set of predic-tors can be used with spectral learning techniques. Our approach relies on adding noise to the feature functions that help the spectral algorithm compute the latent states. Our noise schemes are similar to those described by Wang et al. (2013). We add noise to the whole training data, then train a model using our algorithm (or other spectral algorithms; Cohen et al., 2013), and repeat this process mul-tiple times. We then use the set of parses we get from all models in a recombination step.
 The rest of the paper is organized as follows. In  X  2 we describe notation and background about L-PCFG parsing. In  X  3 we describe our new spec-tral algorithm for estimating L-PCFGs. It is based on similar intuitions as older spectral algorithms for L-PCFGs. In  X  4 we describe the various noise schemes we use with our spectral algorithm and the spectral algorithm of Cohen et al. (2013). In  X  5 we describe how to decode with multiple mod-els, each arising from a different noise setting. In  X  6 we describe our experiments with natural lan-guage parsing for English and German. We denote by [ n ] the set of integers { 1 ,...,n } . For a statement  X  , we denote by [[ X ]] its indicator function, with values 0 when the assertion is false and 1 when it is true.

An L-PCFG is a 5-tuple ( N , I , P ,m,n ) where:  X  N is the set of nonterminal symbols in the  X  [ m ] is the set of possible hidden states.  X  [ n ] is the set of possible words.  X  For all a  X  I , b  X  N , c  X  N , h 1 ,h 2 ,h 3  X   X  For all a  X  P , h  X  [ m ] , x  X  [ n ] , we have a
Latent-variable PCFGs are essentially equiv-alent to probabilistic regular tree grammars (PRTGs; Knight and Graehl, 2005) where the righthand side trees are of depth 1. With gen-eral PRTGs, the righthand side can be of arbitrary depth, where the leaf nodes of these trees corre-spond to latent states in the L-PCFG formulation Figure 1: The inside tree (left) and outside tree (right) for the nonterminal VP in the parse tree (S (NP (D the) (N dog)) (VP (V saw) (NP (D the) (N woman)))). above and the internal nodes of these trees corre-spond to interminal symbols in the L-PCFG for-mulation.

Two important concepts that will be used throughout of the paper are that of an  X  X nside tree X  and an  X  X utside tree. X  Given a tree, the inside tree for a node contains the entire subtree below that node; the outside tree contains everything in the tree excluding the inside tree. See Figure 1 for an example. Given a grammar, we denote the space of inside trees by T and the space of outside trees by O . We assume two feature functions,  X  : T  X  R d and  X  : O  X  R d 0 , mapping inside and outside trees, respectively, to a real vector. Our training the root of tree, 0 otherwise. These are obtained by splitting all trees in the training set into inside and outside trees at each node in each tree. We
This matrix is an empirical estimate for the cross-covariance matrix between the inside trees and the outside trees of a given nonterminal a . An inside tree and an outside tree are conditionally in-dependent according to the L-PCFG model, when the latent state at their connecting point is known. This means that the latent state can be identified by finding patterns that co-occur together in in-side and outside trees  X  it is the only random vari-able that can explain such correlations. As such, Figure 2: The clustering estimation algorithm for L-PCFGs. if we reduce the dimensions of  X  a using singu-lar value decomposition (SVD), we essentially get representations for the inside trees and the outside trees that correspond to the latent states.
This intuition leads to the algorithm that appears in Figure 2. The algorithm we describe takes as in-put training data, in the form of a treebank, decom-posed into inside and outside trees at each node in each tree in the training set.

The algorithm first performs SVD for each of the set of inside and outside trees for all nontermi-used in various contexts in NLP, mostly to derive representations for words (Dhillon et al., 2015; Rastogi et al., 2015). The algorithm then takes the representations induced by the SVD step, and clusters them  X  we use k -means to do the clus-tering. Finally, it maps each SVD representation to a cluster, and as a result, gets a cluster identi-fier for each node in each tree in the training data. These clusters are now treated as latent states that are  X  X bserved. X  We subsequently follow up with frequency count maximum likelihood estimate to estimate the probabilities of each parameter in the L-PCFG.

Consider for example the estimation of rules of the form a  X  x . Following the clustering step we obtain for each nonterminal a and latent state h a set of rules of the form a [ h ]  X  x . Each such in-stance comes from a single training example of a lexical rule. Next, we compute the probability of the rule a [ h ]  X  x by counting how many times that rule appears in the training instances, and nor-malize by the total count of a [ h ] in the training instances. Similarly, we compute probabilities for binary rules of the form a  X  bc .

The features that we use for  X  and  X  are sim-ilar to those used in Cohen et al. (2013). These features look at the local neighborhood surround-ing a given node. More specifically, we indicate the following information with the inside features (throughout these definitions assume that a  X  bc is at the root of the inside tree t ):  X  The pair of nonterminals ( a,b ) . E.g., for the  X  The pair ( a,c ) . E.g., (VP, NP).  X  The rule a  X  bc . E.g., VP  X  V NP.  X  The rule a  X  bc paired with the rule at the  X  The rule a  X  bc paired with the rule at the  X  The head part-of-speech of t paired with a .  X  The number of words dominated by t paired
In the case of an inside tree consisting of a sin-gle rule a  X  x the feature vector simply indicates the identity of that rule.

For the outside features, we use:  X  The rule above the foot node. E.g., for the  X  The two-level and three-level rule fragments  X  The label of the foot node, together with the  X  The label of the foot node, together with the  X  The part-of-speech of the first head word  X  The width of the spans to the left and to the Other Spectral Algorithms The SVD step on the  X  a matrix is pivotal to many algorithms, and has been used in the past for other L-PCFG esti-mation algorithms. Cohen et al. (2012) used it for developing a spectral algorithm that identifies the parameters of the L-PCFG up to a linear transfor-mation. Their algorithm generalizes the work of Hsu et al. (2009) and Bailly et al. (2010).
Cohen and Collins (2014) also developed an al-gorithm that makes use of an SVD step on the inside-outside. It relies on the idea of  X  X ivot features X   X  features that uniquely identify latent states.

Louis and Cohen (2015) used a clustering al-gorithm that resembles ours but does not sepa-rate inside trees from outside trees or follows up with a singular value decomposition step. Their algorithm was applied to both L-PCFGs and lin-ear context-free rewriting systems. Their applica-tion was the analysis of hierarchical structure of conversations in online forums.

In our preliminary experiments, we found out that the clustering algorithm by itself performs worse than the spectral algorithm of Cohen et al. (2013). We believe that the reason is two-fold: (a) k -means finds a local maximum during clustering; (b) we do hard clustering instead of soft cluster-ing. However, we detected that the clustering algo-rithm gives a more diverse set of solutions, when the features are perturbed. As such, in the next sections, we explain how to perturb the models we get from the clustering algorithm (and the spectral algorithm) in order to improve the accuracy of the clustering and spectral algorithms. It has been shown that a diverse set of predictions can be used to help improve decoder accuracy for various problems in NLP (Henderson and Brill, 1999). Usually a k -best list from a single model is used to exploit model diversity. Instead, we es-timate multiple models, where the underlying fea-tures are filtered with various noising schemes.
We try three different types of noise schemes for the algorithm in Figure 2: Dropout noise: Let  X   X  [0 , 1] . We set each el-ement in the feature vectors  X  ( t ) and  X  ( o ) to 0 with probability  X  .
 Gaussian (additive): Let  X  &gt; 0 . For each x ( i ) , Gaussian (multiplicative): Let  X  &gt; 0 . For each x ( i )  X  (1 +  X  ) , where  X  is coordinate-wise mul-tiplication.

Note the distinction between the dropout noise and the Gaussian noise schemes: the first is per-formed on the feature vectors before the SVD step, and the second is performed after the SVD step. It is not feasible to add Gaussian noise prior to the SVD step, since the matrix  X  a will no longer be sparse, and its SVD computation will be computa-tionally demanding.

Our use of dropout noise here is inspired by  X  X ropout X  as is used in neural network training, where various connections between units in the neural network are dropped during training in or-der to avoid overfitting of these units to the data (Srivastava et al., 2014).

The three schemes we described were also used by Wang et al. (2013) to train log-linear models. Wang et al. X  X  goal was to prevent overfitting by introducing this noise schemes as additional reg-ularizer terms, but without explicitly changing the training data. We do filter the data through these noise schemes, and show in  X  6 that all of these noise schemes do not improve the performance of our estimation on their own. However, when mul-tiple models are created with these noise schemes, and then combined together, we get an improved performance. As such, our approach is related to the one of Petrov (2010), who builds a commit-tee of latent-variable PCFGs in order to improve a natural language parser.

We also use these perturbation schemes to cre-ate multiple models for the algorithm of Cohen et al. (2012). The dropout scheme stays the same, but for the Gaussian noising schemes, we follow a slightly different procedure. After noising the pro-jections of the inside and outside feature functions we get from the SVD step, we use these projected noised features as a new set of inside and outside feature functions, and re-run the spectral algorithm of Cohen et al. (2012) on them.

We are required to add this extra SVD step be-cause the spectral algorithm of Cohen et al. as-sumes the existence of linearly transformed pa-rameter estimates, where the parameters of each nonterminal a is linearly transformed by unknown invertible matrices. These matrices cancel out when the inside-outside algorithm is run with the spectral estimate output. In order to ensure that these matrices still exactly cancel out, we have to follow with another SVD step as described above. The latter SVD step is performed on a dense  X  a  X  number of latent states) is much smaller than d or Let G 1 ,...,G p be a set of L-PCFG grammars. In  X  6, we create such models using the noising tech-niques described above. The question that remains is how to combine these models together to get a single best output parse tree given an input sen-tence.

With L-PCFGs, decoding a single sentence re-quires marginalizing out the latent states to find the best skeletal tree 2 for a given string. Let s be a sentence. We define t ( G i ,s ) to be the output tree according to minimum Bayes risk decoding. This means we follow Goodman (1996), who uses dy-namic programming to compute the tree that maxi-mizes the sum of all marginals of all nonterminals in the output tree. Each marginal, for each span  X  a,i,j  X  (where a is a nonterminal and i and j are endpoints in the sentence), is computed by using the inside-outside algorithm.
In addition, let  X  ( a,i,j | G k ,s ) be the marginal, as computed by the inside-outside algorithm, for the span  X  a,i,j  X  with grammar G k for string s . We use the notation  X  a,i,j  X   X  t to denote that a span  X  a,i,j  X  is in a tree t .

We suggest the following three ways for decod-ing with multiple models G 1 ,...,G p : Maximal tree coverage: Using dynamic pro-gramming, we return the tree that is the solution to: t  X  = arg max
This implies that we find the tree that maximizes its coverage with respect to all other trees that are decoded using G 1 ,...,G p .
 Maximal marginal coverage: Using dynamic programming, we return the tree that is the solution to:
This is similar to maximal tree coverage, only in-stead of considering just the single decoded tree for each model among G 1 ,...,G p , we make our decoding  X  X ofter, X  and rely on the marginals that each model gives.
 MaxEnt reranking: We train a MaxEnt reranker on a training set that includes outputs from mul-tiple models, and then, during testing time, de-code with each of the models, and use the trained reranker to select one of the parses. We use the
As we see later in  X  6, it is sometimes possible to extract more information from the training data by using a network, or a hierarchy of the above tree combination methods. For example, we get our best result for parsing by first using MaxEnt with several subsets of the models, and then combining the output of these MaxEnt models using maximal tree coverage. Figure 3: F 1 scores of noisy models. Each data point gives the F 1 accuracy of a single model on the development set, based on the legend. The x -axis enumerates the models (80 in total for each noise scheme). In this section, we describe parsing experiments with two languages: English and German. 6.1 Results for English For our English parsing experiments, we use a standard setup. More specifically, we use the Penn WSJ treebank (Marcus et al., 1993) for our experi-ments, with sections 2 X 21 as the training data, and section 22 used as the development data. Section 23 is used as the final test set. We binarize the trees in training data, but transform them back be-fore evaluating them.

For efficiency, we use a base PCFG without latent states to prune marginals which receive a value less than 0 . 00005 in the dynamic pro-gramming chart. The parser takes part-of-speech tagged sentences as input. We tag all datasets us-ing Turbo Tagger (Martins et al., 2010), trained on sections 2 X 21. We use the F 1 measure according to the PARSEVAL metric (Black et al., 1991) for the evaluation.
 Preliminary experiments We first experiment with the number of latent states for the clustering algorithm without perturbations. We use k = 100 for the SVD step. Whenever we need to cluster a set of points, we run the k -means algorithm 10 times with random restarts and choose the clus-tering result with the lowest objective value. On section 22, the clustering algorithm achieves the following results ( F 1 measure): m = 8 : 84.30%, m = 16 : 85.98%, m = 24 : 86.48%, m = 32 : 85.84%, m = 36 : 86.05%, m = 40 : 85.43%. As we increase the number of states, performance improves, but plateaus at m = 24 . For the rest of our experiments, both with the spectral algorithm of Cohen et al. (2012) and the clustering algorithm presented in this paper, we use m = 24 .
 Compact models One of the advantage of the clustering algorithm is that it leads to much more compact models. The number of nonzero param-eters with m = 24 for the clustering algorithm is approximately 97K, while the spectral algorithms lead to a significantly larger number of nonzero parameters with the same number of latent states: approximately 54 million.
 Oracle experiments To what extent do we get a diverse set of solutions from the different mod-els we estimate? This question can be answered by testing the oracle accuracy in the different settings. For each type of noising scheme, we generated 80 models, 20 for each  X   X  { 0 . 05 , 0 . 1 , 0 . 15 , 0 . 2 } . Each noisy model by itself lags behind the best model (see Figure 3). However, when choosing the best tree among these models, the additively-noised models get an oracle accuracy of 95.91% on section 22; the multiplicatively-noised models get an oracle accuracy of 95.81%; and the dropout-noised models get an oracle accuracy of 96.03%. Finally all models combined get an oracle accu-racy of 96.67%. We found out that these oracle scores are comparable to the one Charniak and Johnson (2005) report.

We also tested our oracle results, comparing the spectral algorithm of Cohen et al. (2013) to the clustering algorithm. We generated 20 mod-els for each type of noising scheme, 5 for each models were smoothed, their oracle accuracy was lower than the accuracy of the clustering algo-The best figure in each algorithm block is in boldface. ideas: (i) that noising acts as a regularizer, and has a similar role to backoff smoothing, as we see be-low; and (ii) the noisy estimation for the clustering algorithm produces a more diverse set of parses than that produced with the spectral algorithm. Table 2: Results on section 23 (English). The first three results (Best) are taken with the best model in each corresponding block in Table 1. The last three results (Hier) use a hierarchy of the above tree combination methods in each block. It com-bines all MaxEnt results using the maximal tree coverage (see text).

It is also important to note that the high ora-cle accuracy is not just the result of k -means not finding the global maximum for the clustering ob-jective. If we just run the clustering algorithms with 80 models as before, without perturbing the features, the oracle accuracy is 95.82%, which is lower than the oracle accuracy with the additive and dropout perturbed models. To add to this, we see below that perturbing the training set with the spectral algorithm of Cohen et al. improves the ac-curacy of the spectral algorithm. Since the spectral algorithm of Cohen et al. does not maximize any objective locally, it shows that the role of the per-turbations we use is important.
 Results Results on the development set are given in Table 1 with our three decoding methods. We present the results from three algorithms: the clustering algorithm and the spectral algorithms
It seems that dropout noise for the spectral algo-rithm acts as a regularizer, similarly to the back-off smoothing techniques that are used in Cohen et al. (2013). This is evident from the two spectral algorithm blocks in Table 1, where dropout noise does not substantially improve the smoothed spec-tral model (Cohen et al. report accuracy of 88.53% with smoothed spectral model for m = 24 without noise)  X  the accuracy is 88.64% X 88.71% X 89.47%, but the accuracy substantially improves for the un-smoothed spectral model, where dropout brings an accuracy of 86.47% up to 89.52%.

All three blocks in Table 1 demonstrate that decoding with the MaxEnt reranker performs the best. Also it is interesting to note that our results continue to improve when combining the output of previous combination steps further. The best re-sult on section 22 is achieved when we combine, using maximal tree coverage, all MaxEnt outputs of the clustering algorithm (the first block in Ta-best figure in each algorithm block is in boldface. ble 1). This yields a 90.68% F 1 accuracy. This is also the best result we get on the test set (section 23), 90.18%. See Table 2 for results on section 23.
Our results are comparable to state-of-the-art results for parsing. For example, Sagae and Lavie (2006), Fossum and Knight (2009) and Zhang et al. (2009) report an accuracy of 93.2%-93.3% us-ing parsing recombination; Shindo et al. (2012) report an accuracy of 92.4 F 1 using a Bayesian tree substitution grammar; Petrov (2010) reports an accuracy of 92.0% using product of L-PCFGs; Charniak and Johnson (2005) report accuracy of 91.4 using a discriminative reranking model; Car-reras et al. (2008) report 91.1 F 1 accuracy for a discriminative, perceptron-trained model; Petrov and Klein (2007) report an accuracy of 90.1 F 1 . Collins (2003) reports an accuracy of 88.2 F 1 . 6.2 Results for German For the German experiments, we used the NEGRA corpus (Skut et al., 1997). We use the same setup as in Petrov (2010), and use the first 18,602 sen-tences as a training set, the next 1,000 sentences as a development set and the last 1,000 sentences as a test set. This corresponds to an 80%-10%-10% split of the treebank.

Our German experiments follow the same set-ting as in our English experiments. For the clus-tering algorithm we generated 80 models, 20 for each  X   X  { 0 . 05 , 0 . 1 , 0 . 15 , 0 . 2 } . For the spectral algorithm, we generate 20 models, 5 for each  X  .
For the reranking experiment, we had to modify the BLLIP parser (Charniak and Johnson, 2005) to use the head features from the German tree-bank. We based our modifications on the docu-mentation for the NEGRA corpus (our modifica-tions are based mostly on mapping of nontermi-nals to coarse syntactic categories).
 Preliminary experiments For German, we also experiment with the number of latent states. On the development set, we observe that the F 1 mea-sure is: 75.04% for m = 8 , 73.44% for m = 16 and 70.84% for m = 24 . For the rest of our experi-ments, we fix the number of latent states at m = 8 . Table 4: Results on the test set for the German data. The first three results (Best) are taken with the best model in each corresponding block in Ta-ble 3. The last three results (Hier) use a hierarchy of the above tree combination methods.
 Oracle experiments The additively-noised models get an oracle accuracy of 90.58% on the development set; the multiplicatively-noised models get an oracle accuracy of 90.47%; and the dropout-noised models get an oracle accuracy of 90.69%. Finally all models combined get an oracle accuracy of 92.38%.

We compared our oracle results to those given by the spectral algorithm of Cohen et al. (2013). With 20 models for each type of noising scheme, all spectral models combined achieve an oracle ac-curacy of 83.45%. The clustering algorithm gets the oracle score of 90.12% when using the same number of models.
 Results Results on the development set and on the test set are given in Table 3 and Table 4 re-spectively.
Like English, in all three blocks in Table 3, de-coding with the MaxEnt reranking performs the best. Our results continue to improve when fur-ther combining the output of previous combina-tion steps. The best result of 82.04% on the devel-opment set is achieved when we combine, using maximal tree coverage, all MaxEnt outputs of the clustering algorithm (the first block in Table 3). This also leads to the best result of 83.38% on the test set. See Table 4 for results on the test set.
Our results are comparable to state-of-the-art results for German parsing. For example, Petrov (2010) reports an accuracy of 84.5% using prod-uct of L-PCFGs; Petrov and Klein (2007) report an accuracy of 80.1 F 1 ; and Dubey (2005) reports an accuracy of 76.3 F 1 . From a theoretical point of view, one of the great advantages of spectral learning techniques for latent-variable models is that they yield consis-tent parameter estimates. Our clustering algorithm for L-PCFG estimation breaks this, but there is a work-around to obtain an algorithm which would be statistically consistent.

The main reason that our algorithm is not a con-sistent estimator is that it relies on k -means clus-tering, which maximizes a non-convex objective using hard clustering steps. The k -means algo-rithm can be viewed as  X  X ard EM X  for a Gaussian mixture model (GMM), where each latent state is associated with one of the mixture components in the GMM. This means that instead of following up with k -means, we could have identified the param-eters and the posteriors for a GMM, where the ob-servations correspond to the vectors that we clus-ter. There are now algorithms, some of which are spectral, that aim to solve this estimation problem with theoretical guarantees (Vempala and Wang, 2004; Kannan et al., 2005; Moitra and Valiant, 2010).

With theoretical guarantees on the correctness of the posteriors from this step, the subsequent use of maximum likelihood estimation step could yield consistent parameter estimates. The con-sistency guarantees will largely depend on the amount of information that exists in the base fea-ture functions about the latent states according to the L-PCFG model. We presented a novel estimation algorithm for latent-variable PCFGs. This algorithm is based on clustering of continuous tree representations, and it also leads to sparse grammar estimates and compact models. We also showed how to get a diverse set of parse tree predictions with this algo-rithm and also older spectral algorithms. Each pre-diction in the set is made by training an L-PCFG model after perturbing the underlying features that estimation algorithm uses from the training data. We showed that such a diverse set of predictions can be used to improve the parsing accuracy of En-glish and German.
 The authors would like to thank David McClosky for his help with running the BLLIP parser and the three anonymous reviewers for their helpful com-ments. This research was supported by an EPSRC grant (EP/L02411X/1).

