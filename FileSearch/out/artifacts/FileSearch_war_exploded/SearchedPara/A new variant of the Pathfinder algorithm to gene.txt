 1. Introduction
The goal of generating schematic visualizations for scientific domain analysis has been pursued since several decades ago and different approaches have been used to put it into effect ( Borner, Chen, &amp; Boyack, 2003; Buz-ydlowski, 2002; Chen, 1999; Lin, White, &amp; Buzydlowski, 2003; White, 2003 ). Their good performance have made the size of the tackled domain progressively increase, with the final aim of being able to represent the largest possible one, the World ( Boyack, Klavans, &amp; Borner, 2005; Leydesdorff, 2004b; Leydesdorff, 2004a; Samoylenko, Chao, Liu, &amp; Chen, 2006 ).

In 1998, Chen (1998a, 1998b) was the first researcher to bring forth the use of Pathfinder Networks (PFNETs) in citation analysis. Since then, it has been used for the study and representation of minor domains or scientific community. In 2004, Moya-Anego  X  n et al. (2004) proposed the combination of PFNET and ISI categories cocitation, making possible the depicting and analysis of large scientific domains in an easy way.
The scientific community is understood in the terms put forth by Hjorland and Albrechtsen (1995) , as the tation analysis). The new technique is based on the use of thematic classification since categories taken from the ISI X  X CR are considered as entities of cocitation and units of measure ( Moya-Anego  X  n et al., 2005; Moya-which represents a social network of the existing relations and processed through social network analysis: the graph is pruned by means of the Pathfinder algorithm ( Dearholt &amp; Schvaneveldt, 1990 ) to get a PFNET, keep-ing just the most salient relations, and the resulting graph is graphically represented using a graph drawing algorithm, Kamada X  X awai ( Kamada &amp; Kawai, 1989 ).

So, once an appropriate methodology has been designed to graphically represent very large scientific domains, the next challenge is to build them in a very small amount of time, allowing us to generate the sci-entograms on line. If this goal is finally achieved, these kinds of visual science maps could be used to design an information retrieval system, composing an Atlas of Science as the one that is being implemented by Felix de
Moya X  X  Scimago research group for the IberoAmerican scientific production
The key problem to generate scientograms of large scientific domains by means of the Pathfinder algorithm is the great time and space complexity it requires. As we will see later, the pruning it applies is based on elim-pute a progressive series of q matrices D i of dimension n entities (graph nodes) considering paths comprised by as much q links. Moreover, their computation requires the use of an additional series of q auxiliary matrices W order to achieve an appropriate pruning in large scientific domains keeping only the most salient links, the resulting time and space complexity of the Pathfinder algorithm are O( n we come up to the undesired conclusion that the run time of the algorithm is prohibitive to generate the maps on-line.

We should note that a previous attempt was made in this aim by Guerrero-Bote et al., which recently pro-posed an improved variant of the original Pathfinder algorithm, called Binary Pathfinder ( Guerrero-Bote, allow us to generate the maps  X  X  X n the fly X  X  since, for values of n around 250, as those handled in our very large domains, the run of the Binary Pathfinder takes several seconds, and this amount of time is then increased by that corresponding to Kamada X  X awai X  X  layout algorithm.

In this contribution, we introduce Fast Pathfinder , a new Pathfinder variant taking as a base a classical algorithm in graph theory, Floyd X  X arshall X  X  ( Cormen, Leiserson, Rivest, &amp; Stein, 2001 ), to compute the shortest paths in the graph in a different way. Thanks to that and to the fact that we fix the value of q to n 1, we are able to reduce the time complexity of the original algorithm in one order of magnitude,
O( n 3 ), which is a killer advantage when applied to the generation of scientograms for large scientific domains.
Moreover, the new algorithm has a much simpler structure than Binary Pathfinder, since it only requires three loops wrapping two simple operations, as well as it only requires two squared matrices to operate. An exper-imental comparison will be developed using large networks from real-world domains corresponding to the sci-entific production of different countries to show the good performance of the new proposal in comparison with both the original and the Binary Pathfinder.
 To do so, the paper is structured as follows. Section 2 briefly reviews the original Pathfinder and the Binary
Pathfinder algorithms. The new proposal is introduced in Section 3 , together with a detailed analysis of its advantages in terms of speed, memory saving and simplicity. Section 4 collects the experiments developed to test Fast Pathfinder. Finally, some concluding remarks are pointed out in Section 5 . 2. Preliminaries
This section is devoted to introduce the preliminaries needed to achieve a good understanding of our pro-posal. With this aim, the next two subsections respectively describe the original Pathfinder and the Binary
Pathfinder algorithms. 2.1. The Pathfinder algorithm
Pathfinder was introduced by Dearholt and Schvaneveldt as a technique to choose the shortest links in a network in the field of social networks ( Dearholt &amp; Schvaneveldt, 1990 ). The result of the Pathfinder proce-dure is a pruned network called PFNET  X  which is either a directed or undirected graph depending on the fact that the original similarity matrix is symmetrical or not  X  that only keeps those links which do not violate the triangle inequality stating that the direct distance between two nodes must be lesser than or equal to the dis-tance between them passing through any group of intermediate nodes. As said by its creators, PFNETs pro-vide unique representations of the underlying structure for domains in which objective measures of distance are available ( Schvaneveldt, 1990 ).

The Pathfinder algorithm is based on two main parameters: 1. r 2 [1, 1 ], which defines the adaptive metric, the Minkowski r-metric , considered to measure the distance between two network nodes not directly connected:
When r takes value 1, the Minkowski metric results in the sum of the link weights; when it takes value 2, it becomes the usual Euclidean metric; and when r tends to 1 , the path weight is the same as the maximum weight associated with any link along the path. 2. q 2 [2, n 1] (with n being the number of nodes in the network), which limits the number of links in the paths for which the triangle inequality is ensured in the final PFNET. Hence, every path connecting two nodes that violate the triangle inequality, having an associated Minkowski distance greater than any other path between the same two nodes composed of up to q links, will be removed.

Note that r = 1 and q = n 1 are the common parameter values when Pathfinder is used for large domains scientogram generation. These values are very advantageous for large network pruning ( Chen, 2004 ).
To build a PFNET, two different kinds of auxiliary matrices are used:  X  W i jk , which stores the minimum cost to go from node j to node k by following exactly i links. This matrix is computed recursively using matrix W i 1 jk ,with W 1 being the original weight matrix.  X  D i jk , which stores the minimum cost to go from node j to node k by following any path in the network com-posed of i or less links. This matrix is computed recursively using matrices W The original Pathfinder algorithm pseudocode is shown in Fig. 1 .

Notice that the algorithm has a time complexity order O( q  X  n matrices W i and D i . Each of the latter matrices stores n them in each step. Finally, an additional loop of n steps is needed to compute each component of W in line 1 of the algorithm. As the maximum possible value for q is n 1, Pathfinder has a time complexity of O( n 4 ) in that case.

On the other hand, the resulting space is thus of complexity O( q  X  n need to build q matrices W i and other q matrices D i , as seen above. 2.2. The Binary Pathfinder algorithm
Guerrero-Bote et al. (2006) recently proposed the Binary Pathfinder algorithm, an improved variant of the original Pathfinder aiming at reducing its time and space complexity. Binary Pathfinder takes the following two aspects as a base to put this improvement into effect: 1. The only matrix in the series of D i that is actually needed for the algorithm to operate is the last one, D be compared with the initial weight matrix W 1 . The remainder are not necessary. 2. The matrices D i can be directly generated from two previous ones in the same way as done for the consec-utive W i matrices: D i + j = D i x D j .

Hence, the authors demonstrated that the distance matrix D couple of nodes can be calculated from D i and D j as follows: subsection.

Thanks to the latter, a new Pathfinder algorithm was designed which does not need to compute every D matrix, i  X  1 ; ... ; q , but can make larger steps. Taking the procedure to transform an integer number to bin-ary as a base (that is the inspiration for the algorithm X  X  name), Guerrero-Bote et al. X  X  Binary Pathfinder reduces the task to calculating just log( q ) matrices, those corresponding to indices being powers of 2: D
D , D 4 , D 8 , ...

The Binary Pathfinder algorithm pseudocode is shown in Fig. 2 . Notice that the principle loop reduces the number of steps of the original Pathfinder from q to log q . Therefore, the time complexity of the new Binary
Pathfinder variant becomes O(log q  X  n 3 ) instead of O( q  X  n on real cases are shown in Guerrero-Bote et al. (2006) and in Section 4 of the current paper. On the other hand, the space complexity is even more significantly reduced, as only two squared matrices to compute D in each step, another matrix to store the final distance values D weights are required, instead of 2  X  q matrices W i and D 3. Fast Pathfinder
As we have seen in the previous section, the Binary Pathfinder approach is able to achieve an important speed up of the Pathfinder algorithm. Unfortunately, this time complexity reduction, although significant, is not enough for the aim of generating scientograms of very large scientific domains in an on-line fashion since, for values of n around 250 and for q = n 1, the run of the Binary Pathfinder still takes several seconds (see Section 4 ).

In this section, we introduce Fast Pathfinder , a new variant of the Pathfinder algorithm which tries to solve the latter problem. To do so, we first analyze the underlying idea of this approach, which is based on the use of classical algorithms in graph theory for shortest path computation. In fact, the new variant is based on the idea that a PFNET can be obtained with a Shortest Path algorithm when q = n 1. Then, we introduce the Fast Pathfinder X  X  pseudocode and analyze its main advantages and its only disadvantage. 3.1. Underlying idea: graph shortest path computation algorithms
As we need to fix the value of q to n 1, the triangle inequality is verified for the best path between any couple of nodes in the graph, thus the problem becomes a shortest path problem. This is why we can replace steps 1 X 3 in the original Pathfinder algorithm (see Fig. 1 ) to achieve the same result in less computation time.
When analyzing the operation mode of this algorithm from a computer science point of view, one can recog-nize that what it does is nothing but computing a distance matrix D paths (regarding the Minkowski r -metric) between any pair of network nodes comprised by up to n 1 links, and then comparing the latter values to the original weights in matrix W belong to the PFNET.

To do so, it applies the classical dynamic programming approach in algorithm theory ( Cormen et al., 2001 ) in order to ensure the obtaining of the optimal solution for the graph shortest path problem. Dynamic programming ( Dreyfus, 1965 ) constitutes the practical embodiment of the Bellman X  X  principle of optimality ( Bellman &amp; Kalaba, 1965 ) through a clever ( X  X  X oon walking X  X  type) technique for computing optimal sequen-tial-decisions by a forward-looking, backward-recursive search. Hence, the Pathfinder algorithm is a direct instance of the latter algorithmic methodology, that applies the usual bottom-up approach based on a progres-the partial decisions made in the previous ones. This results in the Pathfinder algorithm structure where, to build the matrices W i and D i of dimension n 2 in each of the n 1 steps, an additional loop of size n is required to check all the possible choices of crossing a link for the shortest path computation between two nodes. All of the latter defines the O( n 4 ) time complexity.

Notice that Binary Pathfinder keeps the same algorithmic approach than the original Pathfinder version, and the improvement introduced is due to the fact that it smartly reduces the number of steps in the outer loop needed to compute the same distance matrix D n 1 while still satisfying the Bellman X  X  principle of optimality.

Hence, as seen in Binary Pathfinder, the only two matrices that are finally needed to obtain the PFNET as a result of pruning the original network are D n 1 and W 1 . As we know that D matrix when q = n 1, we can borrow alternative (and quicker ways) to compute it from the classical algo-rithms, respectively called Floyd X  X arshall  X  X  and Dijkstra  X  X  and also based on the dynamic programming approach, that are able to compute all the shortest paths of length up to n 1 links (according to an Euclidean metric) in a cubic time complexity. The adaptation of Floyd X  X arshall X  X  algorithm to the computation of the
D n 1 matrix for a PFNET using the Minkowski r -metric is thus the base of our new Fast Pathfinder proposal. 3.1.1. Floyd X  X arshall X  X  shortest path algorithm
Floyd X  X arshall X  X  algorithm ( Floyd, 1962; Warshall, 1962 ) is a dynamic programming algorithm giving the shortest paths between any source node and any destination node in a directed graph in cubic time. The algo-rithm computes, for each pair of nodes i and j , the minimum weight among all paths between them, storing it into a distance matrix D = d ij . The weight of a path between two nodes is the sum of costs of the links in that path. Additionally, a predecessor matrix P can be used to retrieve the links composing the shortest paths themselves, where p ij corresponds to the index of the last node included in the optimal path from i to j .
The basic Floyd X  X arshall X  X  algorithm pseudocode is shown in Fig. 3 . When the predecessor matrix is to be computed, it becomes the pseudocode shown in Fig. 4 .

It is very simple to check that both variants of the algorithm have a time complexity of O( n 3.1.2. Dijkstra X  X  shortest path algorithm
Dijkstra X  X  algorithm ( Dijkstra, 1959 ) is both a greedy and a dynamic programming algorithm that solves the single-source shortest path problem for a directed graph with nonnegative link weights. As in Floyd X  X ar-shall X  X  technique, the cost of a path between two nodes is the sum of costs of the links in that path. The algo-rithm gives the costs of the shortest paths from a single, fixed node s to all the other nodes in the graph in quadratic time. To retrieve the paths, it uses the same kind of predecessor data structure (an array p , in this case) than Floyd X  X harshall X  X  algorithm (see the previous subsection). In order to get the all-pairs shortest paths, there is a need to wrap Dijkstra X  X  algorithm into a linear loop for all the graph nodes, thus resulting in a time complexity of O( n 3 ).

Dijkstra X  X  algorithm pseudocode is shown in Fig. 5 , where V [ G ] is the set of graph nodes, F is a set of unvis-ited nodes by the algorithm, and u = EXTRACT MIN ( F ) returns the node u with the lowest distance value in F and removes that node from it. On the other hand, E is the set of already visited nodes. In its simplest implementation, a normal array is used to store the links, and thus operation EXTRACT-the number of the s node links. As the maximum number of links for any node in the graph is n 1, the max-imum time complexity becomes O( n 2 ).

We should also notice that there are more efficient implementations of Dijkstra X  X  algorithm for the case of sparse graphs with a number of links significantly lower than n form of an adjacency list and using more advanced data structures than a simple list. With a heap in the
EXTRACT-MIN function, the time complexity becomes O(( m + n )  X  log n ). When a Fibonacci heap is consid-ered, it becomes O( m + n  X  log n ). 3.2. Structure of Fast Pathfinder
Taking into account what has been explained in the latter subsection, Floyd X  X arshall X  X  algorithm has been selected to substitute the costly computation of matrix D algorithm is not as well suited to do so. The reasons are mainly related to the structure of the graphs and the greater simplicity of the Floyd X  X arshall X  X  algorithm implementation and will be detailed at the end of this section.

Since working with Floyd X  X arshall X  X  algorithm we are able to build this matrix in cubic time and we avoid the need to compute the temporary matrices W i and D i , the substitution is much more effective. To do so, there is a need to only perform one trivial change to the pseudocode shown in Section 3 : the Minkowski r -metric has to be used to compute the path lengths. In this way, we can directly substitute the three first lines of the Path-finder algorithm in Fig. 1 by the five lines of the basic Floyd X  X arshall X  X  pseudocode in Fig. 3 , with the pre-vious adaptation. The resulting Fast Pathfinder pseudocode is shown in Fig. 6 .

Since the shortest path computation procedure has an O( n takes time O( n 2 ), the algorithm will have a time complexity of O( n
Besides, notice that the computation of the predecessor matrix is not needed and the algorithm only requires to store two square matrices to operate ( W and D ).
 On the other hand, there is another alternative for the PFNET link selection (lines 6 X 8). Actually, by using
Floyd X  X arshall X  X  algorithm for the shortest path computation, there is not a need to compare the distance matrix D to the original weight matrix W to select the PFNET links, but those links can be directly extracted from the predecessor matrix P . In this second way, we used this matrix as an adjacency matrix to improve the speed of the computation. At the start of the algorithm, each link is considered belonging to a possible shortest path, thus to the PFNET, so the corresponding component in P is set to true . Then, each time the distance d corresponding component in the matrix is set to false . The final value of P indicates exactly those links that must be preserved. Hence, we don X  X  need to take matrix W into account to select the links for the PFNET. The pseudocode of this second Fast Pathfinder algorithm variant is shown in Fig. 7 .

This second way of selecting the PFNET links has also an O( n the former version because of the computation time needed to generate the predecessor matrix. We will exper-imentally check this assumption in the next section.

Concerning its space complexity, it is the same than the former, since it also requires to store two square matrices to operate: D , the same that the other variant, and the predecessor matrix P (in the place of the weight matrix W ).

Finally, we should also note that two new variants could also be designed in case Dijkstra X  X  algorithm would have been considered instead of Floyd X  X arshall for the shortest path matrix computation. Besides, at first sight, it could seem that a lower time complexity Fast Pathfinder could be obtained proceeding in that way by means of the advanced implementation of the former algorithm based on the use of the Fibonacci heap.

However, we have decided not to consider Dijkstra X  X  variants due to two main reasons. On the one hand, it is well known in algorithm theory that Dijkstra X  X  algorithm is quicker than Floyd X  X arshall X  X  for the case of sparse graphs, i.e., when the number of links in the graph j A j tends to the number of nodes n , while the opposite holds for dense graphs, i.e., when j A j! n 2 . Since the graphs resulting from cocitation matrices associated to large scientific domains are actually  X  X  X mall worlds X  X  ( Watts &amp; Strogatz, 1998; Watts, 2004 ), they are very dense and thus Floyd X  X arshall X  X  proposal is the best choice. On the other hand, the use of the latter variant is also beneficial since it results in a simpler implementation of the Fast Pathfinder algorithm. 3.3. Main advantages and disadvantage of Fast Pathfinder
In summary, the Fast Pathfinder proposal introduced in the current contribution based on Floyd X  X ar-shall X  X  shortest path algorithm has the two following advantages associated: 1. Speed Increase: Thanks to the change in the shortest path distance matrix computation, we are able to reduce the time complexity of the original algorithm in one order of magnitude when q is fixed to n 1, from O( n 4 )toO( n 3 ), which is a great advantage when applied to large networks and, specifically, for the generation of scientograms of large scientific domains. In this way, it is also significantly lower than the quickest Pathfinder variant, Binary Pathfinder (O(log n  X  n 2. Simplicity: Moreover, the new algorithm has a much simpler structure than the previous approach reducing the original Pathfinder run time, Binary Pathfinder, since it only requires three loops wrapping two simple operations. On the other hand, Fast Pathfinder significantly reduces the space complexity since it only requires two square matrices to operate instead of the 2  X  n 1 ones needed by the original algorithm and the four ones by Binary Pathfinder.

On the other hand, its only disadvantage with respect to Binary Pathfinder is that while in our case the value of the parameter q is always fixed to n 1, the latter algorithm allows any possible value for q .Of course, this restricts the generic applicability of Fast Pathfinder, but we should remind that it has been spe-cifically proposed for the on-line generation of large scientific domain visual maps. Note also that any valid value for the second main parameter r can be considered. 4. Experimental results
In the current section, some experiments will be developed to test the actual run time improvement obtained by our proposal, and to empirically prove that it always achieves the same result as the original algorithm. To test the run time improvement, we have compared our two Fast Pathfinder proposals, the one considering the same link selection procedure than Pathfinder, and the other making use of the prede-cessor matrix for this task (see Section 3.2 ), with respect to the current state-of-the-art Pathfinder variants, the original algorithm and Binary Pathfinder. To do so, since the aim to propose this algorithm was to use it for the design of scientograms of large scientific domains, we have applied the four algorithms to 20 real networks of this kind, obtained from the JCR category cocitation information available at the Scimago research group X  X  Atlas of Science ( http://www.atlasofscience.net/ ). Their sizes range from 212 to 263 nodes, and from 8485 to 23430 links. Notice that, the link weights in this graph correspond to similarities instead of distance measurements 2 .

In order to do a fair comparison, the original and Binary Pathfinder implementations considered are the same ones used by the Binary Pathfinder X  X  authors. Our two Fast Pathfinder variants have also been imple-mented in C. The four algorithms have been compiled with the GNU GCC compiler with the -O3 option, under the Linux operating system, and run in an Intel dual-core Pentium 3.4 GHz computer with 2 GB of memory. Pathfinder parameters have been set to q = n 1 (when considered) and r = 1 , the typical values in large domain scientogram design. Fifty independent runs have been performed for each algorithm and each network, and the global run time has been divided by 50 for each, in order to obtain more precise statistics (notice that, although the algorithms are deterministic, the measurement of the run time values can have small fluctuations in some cases, so this is a most robust procedure).

The results obtained are shown in Table 1 , where the run times are expressed in milliseconds. As expected, both Fast Pathfinder variants cleary outperform the original Pathfinder algorithm in terms of run time, being around 450 times quicker, and what is more important, they are significantly quicker than the Binary Path-finder, reducing its run time in the order of around 23 times for the predecessor-based variant and around 27 times for the other. In this way, it can be seen how we were right in the assumption that the Fast Pathfinder variant not making use of the predecessor matrix is slightly faster (approximately a 10%) than the other ver-sion not requiring the computation of such data structure.

The most important conclusion we can draw from this experimental study is that, using our new Fast Path-finder proposal, we are able to generate real scientograms of very large scientific domains in around 166 ms in the worst case (Argentina (2005) domain), while the current state-of-the-art approach, Binary Pathfinder, required more than 2 s in the best case (Cuba (2004)) and more than 5.5 s in the worst one (Mexico (2005)). This constitutes a great step ahead since this time reduction allows us to properly combine this prun-ing algorithm with the Kamada X  X awai layout technique, thus being able to generate these kinds of sciento-grams in real time.

Our second experiment concerns the comparison of the visual science maps obtained by the fastest variant of Fast Pathfinder (without using the predecessor matrix) with those obtained by the Binary Pathfinder algo-rithm. This is to empirically prove that the two algorithms give exactly the same results. To do so, we have written a bash script able to generate 1 X 000 X 000 random matrices, from size 3 to 500, containing integral or real numbers (two options selected randomly), and used as the cocitation matrices of virtual social networks.
The goal was to compare edge by edge the results provided by the two considered algorithms. Only symmetric matrices were considered in this experiment and the parameters were set to q = n 1 and r = 1 . In conclu-sion, during this long empirical experiment, no networks were found where a single edge differs from the Bin-ary and the Fast Pathfinder algorithm X  X  results. For instance, the comparison of the results obtained by the two algorithms on a 500-nodes map is shown in Fig. 8 .
 5. Concluding remarks
In this paper, we have presented a new variant of the Pathfinder algorithm, to be used as a network pruning algorithm for the generation of visual representations of very large scientific domains, aiming to decrease its actual run time. Taking the classical Floyd X  X arshall X  X  graph shortest path algorithm as a base, we have been able to reduce the original Pathfinder time complexity in one order of magnitude, from O( n also clearly outperforming the state-of-the-art variant in terms of run time (Binary Pathfinder, O(log n  X  n
The new algorithm has also a much simpler structure than the Binary Pathfinder, while maintaining the ori-ginal Pathfinder X  X  r parameterization ( q must be fixed to n 1 in the current application) and saving a great amount of memory.
The experimental comparison developed using 20 large networks from real-world domains has demon-strated the capability of the new proposal to generate scientograms of very large scientific domains in real time.
 Acknowledgements
We would like to thank Dr. Vicente Guerrero-Bote, from the University of Extremadura, Spain, for providing us with his Binary Pathfinder X  X  code. We also would like to thank the anonymous reviewers for their interesting comments and suggestions, which has allowed us to improve the quality of the contribution. References
