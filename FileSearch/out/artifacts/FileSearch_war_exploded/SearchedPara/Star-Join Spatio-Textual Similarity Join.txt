 Location-based services have attracted significant attention due to modern mobile phones equipped with GPS devices. These services generate large amounts of spatio-textual data which contain both spatial location and textual descriptions. Since a spatio-textual object may have different representa-tions, possibly because of deviations of GPS or different user descriptions, it calls for efficient methods to integrate spatio-textual data from different sources. In this paper we study a new research problem called spatio-textual similarity join: given two sets of spatio-textual objects, we find the simi-lar object pairs. To the best of our knowledge, we are the first to study this problem. We make the following contri-butions: (1) We develop a filter-and-refine framework and devise several efficient algorithms. We first generate spatial and textual signatures for the objects and build inverted in-dex on top of these signatures. Then we generate candidate pairs using the inverted lists of signatures. Finally we refine the candidates and generate the final result. (2) We study how to generate high-quality signatures for spatial informa-tion. We develop an MBR-prefix based signature to prune large numbers of dissimilar object pairs. (3) Experimental results on real and synthetic datasets show that our algo-rithms achieve high performance and scale well.
 H.2.8 [ Database Applications ]: Spatial databases and GIS; H.3.3 [ Information Search and Retrieval ] Algorithms, Experimentation, Performance Spatio-Textual, Similarity Join, MBR-Prefix
With the near ubiquity of global position systems (GPS) in smartphones, location-based services (LBS) have recently attracted significant attentions from both academic and in-dustrial community. These services generate large amounts of spatio-textual data which contain both geographical lo-cation and textual description. As a spatio-textual object may have different representations, possibly because of de-viations of GPS or different user descriptions, it calls for efficient methods to correlate the spatio-textual data from different sources. For example, Google Map 1 generates the detailed information of points of interests (e.g., hotels and restaurants) by integrating the relevant data from multiple sources. Factual 2 extracts spatio-textual information from the user-generated data to generate new points of interest. In this paper, we study a new research problem, called spatio-textual objects with a spatial region and textual de-scriptions, it finds all similar object pairs. Two objects are similar if their spatial similarity and textual similarity are larger than given thresholds. In this paper, we use Jaccard coefficient as an example to quantify the spatial similarity and textual similarity and our techniques can be easily ex-tended to support other similarity functions. StarJoin has many real applications. One example is Tuan800 3 , a famous information integration service which integrates discount in-formation from various group-on websites. Each discount message is associated with a spatial range and some key-word descriptions. Since different group-on websites may contain many similar discount messages, it is very impor-tant to perform a similarity join on the datasets so as to eliminate redundant ones for improving user experiences.
There are some recent studies on spatial join [12, 9, 13, 3] and string similarity join [4, 1]. Although we can extend their methods to support our problem, they are rather inef-ficient as they only use spatial pruning or textual pruning, and may generate large numbers of intermediate results. To address this limitation and improve the performance, we de-velop a filter-and-refine framework. First we generate spatial and textual signatures for the objects and build inverted in-dexes to avoid redundant computations. Next we use the signatures to find candidate pairs whose signatures are sim-ilar enough. Finally we verify the candidates to get the final answers. We propose several algorithms by organizing spa-tial and textual signatures in different ways. In addition, we propose an MBR-Prefix filter technique to generate high-quality signatures. For each object, it selects a subregion of the object as a spatial signature to substitute the entire h ttp://maps.google.com http://www.factual.com http://www.tuan800.com region. We also prove that the selected subregion is mini-m ized. To summarize, we make the following contributions: (1) We study a new research problem called Spatio-textual Similarity Join. We explore a filter-and-refine framework and propose efficient algorithms which can prune large num-bers of dissimilar objects. (2) We develop an MBR-Prefix based signature which uses subregions of objects as signatures to support spatial prun-ing. We prove that the selected subregion is minimized. (3) We have conducted extensive experiments on real and synthetic datasets. Experimental results show that our meth-ods achieve high performance and scale well.
We first formulate the problem of spatio-textual similarity join in Section 2.1, and then introduce prefix filter property in Section 2.2.
Consider two collections of objects R = { r 1 , r 2 ..., r S = { s 1 , s 2 ..., s m } . Each object r (or s ) includes a spatial region M r and textual description T r . In this paper we use Minimum Bounding Rectangle (MBR) to capture the spatial information, denoted by M r = [ r bl , r tr ], where r ( r bl .x, r bl .y ) is the bottom-left point and r tr = ( r tr is the top-right point. We use a set of tokens to capture the textual description, denoted by T r = { t 1 , t 2 , . . . , t describes an object (e.g., { Hotel, Pizza } ) or users X  interests (e.g., { Seaside, Delivery } ). As tokens may have different importance, we assign each token t i with a weight w ( t i inverse document frequency idf ).

To quantify the similarity between two objects, we use the well-known Jaccard as an example to evaluate the spatial similarity ( S Jac ) and textual similarity ( T Jac ). Our tech-niques can be easily extended to support other functions. Due to space constraints, we do not discuss the details.
Definition 1 (Spatial Jaccard). Given two objects r and s , their spatial Jaccard similarity ( S Jac ) is defined as: where || is the size of an MBR.

Definition 2 (Textual Jaccard). Given two objects r and s , their textual Jaccard similarity ( T Jac ) is defined as: where w ( t ) is the weight of token t .

Two objects r and s are similar if they satisfy (1) Spatial constraint: their spatial Jaccard similarity is larger than a spatial similarity threshold  X  s , i.e., S Jac ( r, s ) &gt;  X  Textual constraint: their textual Jaccard similarity is larger than a textual similarity threshold  X  t , i.e., T Jac ( r, s ) &gt;  X  We formulate the spatio-textual similarity join problem.
Definition 3 (Spatio-Textual Similarity Join). Given two collections of objects R = { r 1 , r 2 ..., r n } , S = { s and two similarity thresholds  X  s and  X  t , a spatial-textual sim-ilarity join finds all similar pairs ( r i , s j ) where S  X  and T Jac ( r i , s j ) &gt;  X  t . 40 30 20 10 0 Figure 1: An example of spatio-textual objects
E xample 1. Consider the ten objects in Figure 1. Sup-pose  X  s = 0 . 6 and  X  t = 0 . 7. For object pair ( r 1 , r R 1 = [(10 , 30) , (24 , 37)] and R 3 = [(11 , 29) , (26 , 36)], S 0 . 676. Thus, r 1 and r 3 are not similar since 0 . 676 &lt;  X  Discussions: For ease of presentation, we suppose R = S and our techniques can be easily extended to the case R6 = S .
Prefix filter [4] is a widely used method for solving string similarity join problem. Its basic idea is that if the similarity of two token sets is larger than a given threshold, they should share enough common tokens. Consider two token sets T r and T s . When w ( t i ) = 1, according to [4], if T Jac ( T  X  , then |T r  X  X  s | &gt;  X  t  X |T r | X  X  X   X  t  X |T r | X  + 1. Based on this property, we first sort all the tokens according to a global order, e.g., idf . For each token set T , we generate its prefix by deleting last  X   X  t |T| X  tokens. If any two objects are similar, they must have common tokens in their prefixes. We extend it to the case w ( t i ) 6 = 1. We first sort objects in the descending order of weights. Since |T r  X  X  s | &gt;  X  P i =1 w ( t i ), then we generate prefix by deleting the last k tokens which satisfy P common tokens in their prefixes will be taken as candidates.
In this section, we propose a filter-and-refine framework (Section 3.1) and devise five filtering algorithms (Section 3.2).
To avoid enumerating every object pair, we introduce an incremental signature-based framework. We scan the ob-jects in order and maintain index for all the objects that have been visited. The framework includes three steps: Filter: For the current object r , we generate its signature Sig ( r ) and use it to probe the inverted index for candidates. In this paper, the signatures should satisfy the following Index Update: After finding all the candidates of object r , we insert Sig ( r ) to the current index.
 Refine: We refine all the candidate pairs and check whether they satisfy spatial and textual constraints simultaneous.
We now discuss how to generate spatial and textual sig-natures and how to organize these signatures. 1 2 3 4 S ignature Generation: Given an object r , we use its token prefix T r as its textual signature (Section 2.2), de-noted by Sig T ( r ). To estimate the region of an object, we partition the space into grids and associate each ob-ject r with the grids it intersects, denoted as G r . Simi-lar to textual prefix filter property, we can generate spa-tial signatures as follows. Given an object r , we first sort grids in G r based on a global order. Then we delete last k grids which satisfy P r and s are similar, they at least share one common grid in their spatial signatures as stated in Lemma 1.

Lemma 1. Given two objects r and s , Sig S ( r ) and Sig S are spatial signatures of r and s . If S Jac ( r, s ) &gt;  X  Sig S ( r )  X  Sig S ( s ) 6 =  X  .
 Signature Organization: We study how to organize these signatures and discuss six possible solutions. (1) Spatial Only: We only use the spatial signatures to build inverted index. Each entry in the index is a grid which maintains a list of objects overlapping with the grid. (2) Textual Only: We only use the textual signatures to build inverted index. Each entry in the index is a token which keeps a list of objects containing the token. Obviously, these two methods are ineffective since they only use a single constraint to prune candidates. (3) Spatial and Textual Separately: We build inverted index for spatial and textual signatures separately. The al-gorithm is illustrated in Figure 2( a ). For the current object r , we generate its spatial signature Sig S ( r ) and textual sig-nature Sig T ( r ). For each grid g  X  Sig S ( r ), we use it to probe the corresponding spatial inverted index and add all
Figure 3: MBR-Prefix filtering technique:  X  s  X  0 . 5 t he objects in these lists to spatial candidate set C S . Mean-while, for each token t  X  Sig T ( r ), we scan the corresponding textual inverted list and add the objects to textual candidate set C T . Then the intersection of C S and C T will be taken as the candidates. Notice that this method is not efficient since the process of spatial and textual filtering is independent. (4) First-spatial-then-textual: We can build a two-layer index. If the spatial index is arranged at the top layer, the index is called first-spatial-then-textual (Figure 2( b )). Given an object r , we first generate its spatial signature Sig and textual signature Sig T ( r ). The top layer is the grids in Sig S ( r ) and the bottom layer is the inverted lists for tokens in Sig T ( r ). To find the candidates of r , for each grid g in Sig S ( r ) and each token t in Sig T ( r ), if t is in the inverted index of g , the objects in the corresponding inverted lists are candidates. Similarly we can update the index for object r . (5) First-textual-then-spatial: If the textual index is arranged at the top layer, the index is called first-textual-then-spatial. In Figure 2( c ), we illustrate the algorithm. Given an object r , we first generate its spatial signature Sig S ( r ) and textual signatures Sig T ( r ). For each token t in Sig T ( r ) and grid g in Sig S ( r ), if g is in the inverted index of token t , the objects in the corresponding inverted list are candidates. Similarly we can update the index for object r .
The grid based spatial filter has a limitation that the filter-ing power relies largely on grid granularity. To address this problem, we propose an MBR-Prefix based filtering tech-nique which uses more accurate spatial information to gen-erate signatures. According to prefix filter property, two ob-jects are similar in space only if they have enough overlap. Thus, we only need to keep specific subregion of an object. To illustrate the idea clearly, we first introduce some con-cepts: MBR-Prefix , Representative MBR-Prefix and Minimum MBR-Prefix .
 Definition 4. ( MBR-Prefix , Representative MBR-Prefix and Minimum MBR-Prefix ) Given an object r , any subregion of M r is called an MBR-Prefix of r . An MBR-Prefix M p is called a representative MBR-Prefix of r , if for any object s which satisfies S Jac ( r, s ) &gt;  X  M p  X  X  s 6 =  X  . The representative MBR-Prefix with the minimum size is called the Minimum MBR-Prefix .

Now we discuss how to generate the minimum MBR-Prefix in three cases:  X  s &lt; 0 . 5,  X  s = 0 . 5 and  X  s &gt; 0 . 5. Case 1 - X  s &lt; 0 . 5 : Consider the MBR of object r , denoted
Figure 4: MBR-Prefix filtering technique:  X  s &gt; 0 . 5 d enoted by width ( height ). Let Line( r bl , r tl ) denote the left line of the MBR, i.e., the line from the bottom-left point to the top-left point. Let L  X   X  line with distance  X  s  X  width . Similarly we can define the right line, the bottom line, and the top line. Let L  X   X  s the parallel line of the right line with distance  X  s  X  width . Let L  X   X  s and L  X   X  s respectively denote the parallel lines of the top line and the bottom line with distance  X  s  X  height .
These four lines generate four intersections e r bl , e r e r , and divide M r into nine regions ( R 1  X  R 9 ) as illus-trated in Figure 3 where we omit width and height in the figure for concise illustration. Notice that the size of the re-gion on the left of L  X   X  s is  X  s  X |M r | , and we use M to denote this region. For any object s which is similar to r , we have |M s  X  X  r | &gt;  X  s  X |M r | . Thus, there must be at least one point of s falling into the area on the right secting part of r and s can not be larger than  X  s  X |M r | ). Thus, M r \M ( R 1  X  R 4  X  R 7 ) is a representative MBR-Prefix M now prove that their intersection area, i.e., M R 5 , is the min-imum MBR-Prefix of r .

Lemma 2. Given an object r , if  X  s &lt; 0 . 5 then M R 5 minimum MBR-Prefix of r.

Recall the algorithms in Section 3.2, for each object r , we use all the grids which have overlap with the entire M as its spatial signature. According to Lemma 2, only those objects intersecting with M R 5 can be similar to r . Then we only need to keep grids intersecting with M R 5 as spatial signature, denoted as G p r . Take the separated algorithm as an example. When coming an object r , for any object s that has been visited, if r is similar to s , r must have overlap with at least one grid in G p s , i.e., G r  X  X  p s 6 =  X  . Thus we can take the objects in the inverted list of each grid in G as candidates in terms of spatial constraints. After finding all the candidates of r , we update the index by inserting its MBR-Prefix into the inverted lists of G p r .
 Case 2 - X  s = 0 . 5 : As shown in Figure 3, line L  X   X  s L s coincide with each other, and so do line L L to the former case, we can use point p as its minimum MBR-Prefix to represent the entire MBR. All the objects without intersection with p can be pruned.
 Case 3 - X  s &gt; 0 . 5 : Notice that when  X  s increases, line L and line L  X   X  smaller. Especially, when  X  s &gt; 0 . 5, line L  X   X  s moves to the right side of line L  X   X  case, we can also use the center of R 5 to represent the whole area and all the objects covering this point will be taken as candidates. However, this bound is not tight. For example, consider the MBR-Prefix M R 2  X  R 3  X  R 5  X  R 6 . Though it covers point p , it cannot be a candidate since |M R 2  X  R 3  X  R  X  |M r | X   X  s |M r | . To this end, we propose new techniques for  X  s &gt; 0 . 5.

First if  X  s &gt; 0 . 5 then M R 1 , M R 3 , M R 7 and M R representative MBR-Prefixes of r as formalized in Lemma 3. Lemma 3. Given an object r , if  X  s &gt; 0 . 5 , M R 1 , M M R 7 and M R 9 are representative MBR-Prefixes of r . According to Lemma 3, s must have overlap with regions R , R 3 , R 7 and R 9 of r simultaneously. Suppose p 1 , p 3 are four points of s falling in R 1 , R 3 , R 7 and R 9 as shown in Figure 4. Obviously, M ( p 7 , p 3 )  X  X  s since p 7 and p two inner points of s . Thus, we have an intuition that M must cover some subregions of r . We can use this property to improve the MBR-Prefix. To illustrate our idea more clearly, we introduce some new concepts, called Coverage MBR-Prefix and Maximum-Coverage MBR-Prefix .
 Definition 5. ( Coverage MBR-Prefix and Maximum-Coverage MBR-Prefix ) Given an object r , an MBR-Prefix M p of r is called a Coverage MBR-Prefix of r , if for any ob-ject s satisfying S Jac ( r, s ) &gt;  X  s , we have M p  X  X  all these Coverage MBR-Prefixes, we call the largest one as the Maximum-Coverage MBR-Prefix.
 We now prove that if  X  s &gt; 0 . 5, M R 5 is the Maximum-Coverage MBR-Prefix of r as stated in Lemma 4.

Lemma 4. Given an object r , if  X  s &gt; 0 . 5 , M R 5 Maximum-Coverage MBR-Prefix of r .

According to Lemma 4, only the objects entirely cover-ing M R 5 can be candidates. That is, the pivotal points e r these four points are actually determined by two x-coordinates and two y-coordinates since adjacent points have the same x-coordinate or y-coordinate. If we utilize the order of coordi-nates while building index, then only two points are needed for locating M R 5 . Suppose the objects are sorted according to x-coordinate of the right line previously. For each ob-ject r , we only need to keep the grids which intersect with dex based method as an example. When coming an object r , for any object s that have been visited, according to the analysis above, if r is similar to s , r must cover the sig-nature of s , that is G r contains G p s . Thus we can take the objects in the inverted list of each grid in G r as candidates in terms of spatial constraints. Notice that we do not need to scan the entire inverted list. Based on the definition of maximum coverage MBR-prefix, r must totally cover M r 5 list, we only need to scan the objects between Line( e r br and Line( r br , r tr ). After finding all the candidates of r , we need insert its MBR-Prefix into the inverted lists of G p
We conducted extensive experiments on two datasets to evaluate our proposed techniques. Datasets and Experimental Environment: We use two datasets: CN and Twitter (Table 1). Twitter is a real dataset. We crawled 10 million tweets with region and textual in-formation from Twitter. CN is a synthetic dataset which combines the MBRs of China and publications in DBLP randomly. All the algorithms were implemented in C++ and run on a Linux machine with an Intel(R) Xeon(R) CPU X5670 @ 2.93GHz and 48GB memory.
We evaluate the five signature schemes, spatial only ( SpaOnly ), textual only ( TextOnly ), spatial and textual separate ( STsep ), first-spatial-then-textual ( ST ), first-textual-then-spatial ( TS ), in Section 3 by varying  X  s and  X  t . Figures 5 and Figure 6 show the results. Since SpaOnly was much slower than other methods, we omitted it in the figures. ST and TS almost had the same performance and outperformed significantly than other methods.
We evaluate MBR-Prefix based filtering techniques. Fig-ures 7 and 8 show the results. The algorithms with + denote the improved algorithm by incorporating MBR-Prefix. We can observe that the MBR-Prefix technique significantly im-proved the performance of original algorithms. Spatial Join: Many methods have been proposed to study the spatial join problem [3, 12, 8]. [3] used R-tree like struc-ture [7] to organize spatial data. [12] used hash methods by partitioning the space into grids. [8] gave a survey about existing spatial join techniques.
 String Similarity Join: Recently there are many studies on string similarity joins [2, 14, 10].
 Spatial Keyword Search: There are many studies on spa-tial keyword search [6, 5, 11] which integrated inverted in-dexes and R-tree to support spatial keyword search.
Figure 7: MBR-Prefix vs Non-MBR-Prefix (  X  s )
Figure 8: MBR-Prefix vs Non-MBR-Prefix (  X  t )
In this paper, we study a new research problem called spatio-textual similarity join. We devise a filter-and-refine framework and propose several possible solutions. We fur-ther develop an MBR-Prefix based filtering techniqueExper-iments show that our methods achieve high performance.
This work was partly supported by the National Natu-ral Science Foundation of China under Grant No. 61003004, the National Grand Fundamental Research 973 Program of China under Grant No. 2011CB302206, a project of Ts-inghua University under Grant No. 20111081073, and the  X  X ExT Research Center X  funded by MDA, Singapore, under the Grant No. WBS:R-252-300-001-490.
