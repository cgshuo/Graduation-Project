 P2P computing technique has been thought of as a powerful paradigm for data sharing, and peer-based data management has attracted great interests from database community. A large number of P2P systems have been proposed in recent years, which can be roughly classified into two categories: structured (e.g., DHTs [12] and BATON [7]) and unstructured (e.g., Gnutella [4]). Structured P2P systems simplify object lookup as they tightly control both data placement a nd overlay topology. However, such systems destroy data locality and require high ma intenance cost in a dynamic environment. In reality, most of P2P systems are unstructured overlay [4], and therefore we focus the search problem on unstructured P2P systems only in this work.

Most of recent researches dedicate to imple menting content-based query processing, which is especially important to users for making decisions, mining data or searching similar multimedia data over the Internet. Since unstructured P2P system is a fully decentralized network, each user has no p rior knowledge of wh ich nodes contain the desired answers. Hence, the primary problem in this case is not only the processing of similarity queries in high-dimensi onal data spaces at each node, but also the way to form a partial knowledge of the data distribution of the network for routing queries to promising nodes, instead of selecting neighbors blindly. In this paper, we focus on how similarity query in high-dimensional s paces can be supported in unstructured P2P systems. To the best of our knowledge, the high-dimensional search over unstructured P2P systems has received relatively little attention compared with structured ones, and the main contributions of this paper are as follows:  X  We design an efficient index mechanism, named Linking Identical Neighborly Par- X  We implement our proposed scheme and conduct experiments over a set of syn-The rest of this paper is organized as follows: Section 2 reviews the related work. Section 3 presents the structure and algorithms of LINP. In Section 4, we present the experimental study. Section 5 summarizes this work. To avoid blindly flooding queries with the whole network, routing schemes are designed to guide a search to only a fraction of node population. In [10], documents are assigned to each node whose identifier is equal to the hash value of terms in the document, and hence nodes can intersect the inverted lists of the query terms to find desired documents. Instead of using Bloom Filter, Crespo et al . [6] introduced the no tion of Routing Indices that gives a promising  X  X irection X  towards relevant documents. Obviously, the cost of the above approaches grows proportionally with corpus size and node number.
Recently, some researches aim at merging th e merits of both unstructured and struc-tured P2P systems. Structella [2] employe d Pastry-based broadcast mechanism [11] to flood user queries in Gnutella. Hence, the m aintenance cost is low since no network constraint is obeyed and lots of duplicate query messages are avoided since nodes are guaranteed to be visited only once. In PIERSearch [8], a Gnutella-liked system is re-sponsible for finding highly replicated items, while DHTs for locating rare items. How-ever, these P2P systems are still for matching-based search instead of content-based search. On the other side, by drawing the inspiration from the indexing technique in the database research, many indexing appro aches were invented. P-tree [5] indexes the data range of peers to process one-dimensional range queries on Chord [12], while BATON [7] organizes all nodes into a B+-tree and therefore the range search can be naturally supported.

The proposed LINP approach distinguishes itself at three aspects: First, the LINP is more suitable for real-life P2P applications, since it does not depend on any spe-cific overlay structure or global indices; Second, the LINP enables peers to efficiently handle similarity queries in high-dimensi onal data spaces by conquering the problem of dimensional curse; Finally, the LINP is computationally efficient for maintenance issue, which keeps the efficiency of query processi ng and the P2P network scalable against the peer population and dynamism. 3.1 Space Partitioning Since the unstructured P2P system is decentralized, the space partitioning mechanism must be autonomic and also computationally efficient as the network is dynamic. Hence we employ the Vector Approximation file (VA-file) approach [13] to split space, which independently divides a high-dimensional space into 2 b partitions where b is the total number of bits. A number of bits b i is assigned to each dimension, which is split into 2 b i equal segments. Each partition, termed vector approximation (VA), has a bit represen-tation of length b that approximates all data belongi ng to it. Thus a high-dimensional data set is represented by an array of VAs. Figure 1(a) shows that a 2-dimensional space is divided into 16 partitions and data d 5 and d 7 are represented by the same VA  X 0111 X .

There are two reasons for us to adopt the VAs as the data summary at peers: first, it will not suffer from dimensionality curse and outperform sequential scan in high-dimensional spaces while other indexing techniques fail, when dimensionality exceeds a certain threshold [13]; and second, it is of extremely computational efficiency in terms of maintenance issue as peers join or quit the P2P network. In other words, when a new partition appears, it will be simply appe nded to the partition array without any other computational cost. Naturally we can utilize the space partitioning scheme to solve our first problem. However, with partitions, we can only query each individual peer, but cannot query the P2P network since peers have no complete knowledge of the data distribution of the whole network. The next section will present how LINP can solve the second problem. 3.2 Linking Identical Neighborly Partitions The basic idea of the Linking Identical Neighborly Partitions (LINP) is to form a knowl-edge of the data distribution at the surroundi ng peers by linking the identical partitions of neighbor peers together. The LINP scheme uses partitions as indexing item and is organized as an inverted index. Each entry is a binary tuple &lt; id , list &gt; ,where id denotes the bit representation of the partition and list is a linking list that contains routing infor-mation. Each item of list is also a binary tuple &lt; peer id , soi &gt; ,where peer id refers to the identifier of the current peer who is exchanging the partitions with other peers, soi is an integer specifying the number o f hops from the owner p eer of the partition id to the current location (i.e., soi is used for the maintenance of the LINP by specifying the maximum propagation horizon soi max of a partition).

In Figure 1(b), consider that the joining sequence of peers is P 1 , P 3 and P 2 .When P 3 joins, it will exchange its LINP with P 1 .Then P 3 has the knowledge of two partitions  X 0001 X  and  X 1100 X  and their soi values are 1 for they are propagated by one hop from P 1 to P 3 .When P 2 joins, it will obtain the knowle dge of four partiti ons  X 1101 X ,  X 0111 X ,  X 1100 X  and  X 0001 X  from P 3 ,butthe soi values of the first two cells are 1 and the last two are 2. This is because, for each hop, the soi value of each partition is increased by 1. Thus each peer controls the scope of propagating the knowledge of any partition, by comparing its current soi value with the threshold soi max .

The LINP has two important features. Fir st, each peer only consider the data dis-tribution of its neighbors, instead of inde xing the actual owner of any partition. For example, in Figure 2 ( soi max =2 ), P 5 knows of P 4 having the knowledge of the partition  X 1101 X , instead of the actual owner P 3 . The rationale is that when any peer receives a query, it will determine to which neighbor(s) the desired partitions can be found. Second, using partitions as the content s ummarization can reduce the size of the LINP since different data belonging to the s ame partition can be absorbed. For example, P  X  X  LINP contains 5 entries that actually include 10 data objects under the constraint of soi max =2 . Therefore the size of the LINP is half that of directly indexing each individual data.

Based on the above observations, we can observe that the most important property of the LINP is that through exchanging par titions with neighbor peers, each peer forms a partial knowledge of the data distribution at its surrounding peers. Thus peers can route similarity queries to promising neighbor peers purposefully, rather than by blindly propagating queries.
 3.3 Constructing LINP The construction of the LINP takes place at the time when a peer enters the P2P net-work. The information exchanged between peers is an array of triple &lt; id , peer id , soi &gt; . Suppose that a peer P joins the network, and its neighbors are P 1 , ..., P n , the process of building the LINP is as follows: 1. P first initializes its LINP. Then it requests neighbor peers P 1 , ..., P n for their 2. Upon receiving the &lt; id , peer id , soi &gt; array from a neighbor P i , P first checks 3. P checks the soi value of each item of each partition link to determine which parti-
When a peer joins the network, it first requests its neighbors X  LINPs because a new path may occur between some peers bridged by it and the LINPs of all neighbors need to be updated through the newcomer. Further, through checking and updating the soi value of each partition at each hop, the infinite propagation of a partition X  X  information in a loop of peers can be avoided. 3.4 Updating LINP The updating operation of the LINP is triggered by peer joining, departure, failure or data change. For peer joining we have discussed above.
 Peer Leave/Failure. Peer leave and failure follow the si milar maintenance procedure except for the way of detecting a peer X  X  leave. We first describe the process of updating LINP in terms of peer departure. Suppose that a peer P departs from the network and a typical updating procedure is as follows: 1. P notifies all neighbors P 1 , ..., P n about its leave and quits the network. 2. If a neighbor P i receives the notification from P , it will remove all index items 3. After removing some index items, if the list of a partition link l becomes empty, 4. If the list of any partition link is not empty, then stop updating.

For peer failure, the steps 1 and 2 should be replaced by: P periodically polls neigh-bors P 1 , ..., P n to detect whether a neighbor quits the network. If a neighbor P i does not respond for a period, then P regards P i as failure and execute steps 3 and 4, to update the LINPs of its own and neighbors.
 Data change. Another possible event that triggers the updating operation of the LINP is data change at peers. There are two cases for a peer P changing its content: partition(s) emerging or disappearing. In the first case, when a neighbor P i receives the tuples &lt; id, P.peer id, soi &gt; from P , it executes the step 2 of the algorithm of constructing LINP to update its LINP. Then P i propagates all tuples &lt;id,P i .peer id, soi &gt; that do not appear in its LINP and whose soi valueislessthan soi max to its neighbors recursively, till soi max is reached. In the second case, P i runs the steps 3 and 4 of the above algorithm of peer departure to update the LINPs of its own and its neighbor peers. 3.5 Similarity Search Without loss of generality, for convenience, we assume the data space is a d -dimensional unit hypercube, and the Euclidean distance function is used for measuring the similarity of pairs of data points, although other metric distance functions can be used. We only present the range search algorithm as KNN query algorithm is similar.
 Range Search. Given a range query q and its search radius r , suppose node P is now processing q . The LINP range search performs the following steps: 1. P sequentially scans each partition link l in the LINP and calculates the lower 2. P scans all data objects belonging to each candidate partition in partition q and 3. The TTL (Time-to-Live) value of q is decreased by 1. If the neighbor q is not empty 4. If the result q is not empty, directly return the result q to the query peer. We build a simulator to evaluate the performance of similarity search by using the pro-posed LINP technique over a large-scale network with 1024 nodes and the network topology is power-law that is generated acco rding to the PLOD algorithm [9] with av-erage outdegree of 4.07. The simulator is written by JAVA SDK 1.4, and all experiments are performed on a Linux Server that has an Intel Xeon 2.8GHz Processor and 1.5GB main memory. In the simulation, we use Gnutella-based search manner as the base-line to compare with our proposed scheme. The reason is that there is no similar work on supporting similarity search in unstructured P2P networks. For evaluation metrics, we are interested in recall (the percentage of an swers returned), ratio of distance error, query time and coverage (the percentage of peers probed).

We conduct experiments on both synthetic and real life datasets, e.g. 32 dimensional color histograms [1]. However, due to space constraint, we will only report results on synthetic datasets here. Results from real life datasets mirror the result of the synthetic datasets closely. To examine the effects of v arious factors on the performance of LINP, we generate a typical 20-dimensional dataset using the data generator of [3] which has 1M objects distributed in 10 clusters in subs paces of different orientations and dimen-sions. Then we randomly choose 1,000 data objects for each peer. All similarity queries are generated in terms of the data distribution. For range queries, the search radii are varied from 0.05 to 0.1; and for k NN queries, the values of k are varied from 5 to 50. Each query is randomly initiated from any node in the network. For each measurement, we report the average results over 500 similarity queries.

There is an intrinsic parameter of the LINP scheme to generate the index, which is the number of partitions, i.e. the number of bits for VA-file. When the number of bits increases, the recall rate reduces. Becau se the LINP only store the information of neighborly peers with identical partitions, i f there are more partitions, some partitions may fall in the query range but not exist in the LINP. In extreme case, if we treat the whole space as a single partition, the LINP works exactly same as Gnutella as it has links to all neighbors. However we should not ignore another goal that is to minimize the number of the peers involved into the query processing. This is very important to unstructured P2P systems for its efficiency and scalability against the peer population and dynamism. The optimal bit number is a tr adeoff between recall and coverage. Due to the space constraint, we omit the details of experimental results here. According to the results, we set the number of bits for each dimension 5 as a default value for the clarity of presentation.

We evaluate the effectiveness of the proposed LINP scheme with Gnutella on the performance of range search. Notice that, although LINP and Gnutella are running on the same network infrastructure, queries are conducted on different paths for two meth-ods since the LINP has an additional routing index. The experimental results are shown in Figure 3.
Figure 3(a) and Figure 3(b) show that whe n the TTL value is less than 4, the recall of the LINP is better than that of Gnutella , although Gnutella accesses more peers than the LINP. As the number of TTL increases, the Gnutella floods the query to more and more peers in the network, and finally almost covers the whole network when the TTL is 6. Although the Gnutella retrieves more answers than the LINP approaches, it has to pay higher query cost. Clearly, when the soi value is set as 3, the LINP gets 95% recall rate by only access 60% of peers, wh ich is much less than those of Gnutella. On the other side, for the LINP, both recal l and coverage increase greatly as the soi value increases. The reason is that, in the LINP mechanism, the number of links to the neighboring peers is determined by the soi ,e.g.when soi is equal to 1, the LINP only stores the link to directly connected peers which have the identical partitions. With the large value of soi , each peer stores more informa tion about the neighboring peers which have the potential query answers. The L INP can easily access such peers with the links in the local index. Thus a good soi value can improve the system performance greatly. In a real-life P2P system, query time is typically the most important issue that users concern about. We next evaluate the query time that the system requests to answer the similarity query. In our simulation we assume that each peer has enough bandwidth to relay similarity queries and no network congestion occurs. Figure 3(c) shows the results of the query time for Gnutella and LINP. When the TTL value increases, the query time of all approaches increases, as they have to access more peers and conduct the query on the certain nodes. Gnutella yields worst performance in all cases, as it floods the query to all neighbors at each step. Though Gnutella can retrieve more answers for a large TTL, the tradeoff is higher query processing cost.

Finally, from the experimental results, we can observe that the system performance is more preferable under the constraints of soi max =3 than those of soi max =1 or soi max =2 , i.e. the recall rate is closer to that of Gnutella, but much lower cost.
We also test the performance of k NN search. Since both Gnutella and LINP may not access all the peers due to the restriction of TTL, we can only get approximate k NN in this case. As expected, though the result quality of Gnutella is better than that of the LINP, the query cost of Gnutella is much higher than that of the LINP, e.g. the LINP achieves similar query quality while its cost is 50% better. Due to the space constraint, we omitted the details in this paper. In this paper, we have addressed the high-dimensional similarity query problem in un-structured P2P systems. To this end, we proposed the LINP index scheme, which not only enables peers to efficiently handle simila rity queries in high-dimensional spaces, but also efficiently routes to desired neighbor s. Additionally, the LINP structure can be easily generated and maintained locally, thus avoids a large amount of computation and communication costs, which makes the P2P network scalable against the peer popula-tion and dynamism.

