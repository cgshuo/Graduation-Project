 The method of assigning labels to the nodes of the XML tree is called a labeling scheme. Based on the labels only, both ordered and un-ordered queries can be processed without accessing the original XML file. One more important point for the labeling scheme is the label update cost in inserting or deleting a node into or from the XML tree. All the current labeling schemes have high update cost, therefore in this paper we propose a novel quaternary encoding approach for the labeling schemes. Based on this encoding approach, we need not re-label any existing nodes when the update is performed. Extensive experimental results on the XML datasets illustrate that our QED works much better than the existing labeling schemes on the label updates when considering either the number of nodes or the time for re-labeling. H.2.4 [ Database Management ]: Systems  X  Query processing Algorithms, Performance. Dynamic XML, Labeling scheme, Update, Quaternary. As a standard to represent and exchange data on the web, XML [7] has gained a lot of attention from both research and enterprise areas. Presently there is a lot of interest in query processing over XML that conforms to an ordered tree-structured data model. There are two main techniques, viz. structural index and labeling (numbering) scheme, to facilitate the XML queries. The structural index approaches [10, 14, 15] can help to traverse the hierarchy of XML, but this traversal is costly. The labeling scheme approaches [1, 2, 21] require smaller storage space, yet they can efficiently determine the ancestor-descendant (A-D) and parent-child (P-C) relationships between any two elements of the XML. In this paper, we focus on the labeling schemes. If the XML is static, the current labelling schemes can efficiently process different queries. However if the XML is dynamically changed, how to efficiently update the labels of the labelling schemes becomes to an important issue. As we know, the elements in the XML are intrinsically ordered, which is referred as document order (the element sequence in the XML). The relative order of two paragraphs in the XML is important because the order may influence the semantics, thus the standard XML query languages (e.g., XPath[5] and XQuery [6]) require the output of queries to be in document order by default. Hence it is very important to maintain the document order when the XML is updated. Though some researches [3, 8, 17, 18, 19, 21] have been done to maintain the document order in updating, the update costs of these approaches are still expensive. Therefore in this paper we focus on how to efficiently update the XML. The main contributions of this paper are summarized as follows:  X  We propose a novel dynamic quaternary encoding (called QED) that can be applied to different labeling schemes.  X  QED completely avoids the re-labeling when the XML is updated.  X  We conduct comprehensive experiments to demonstrate the benefits of our QED over the previous approaches. The rest of the paper is organized as follows. Section 2 reviews the related work. We propose our dynamic quaternary encoding in Section 3. The most important part of this paper is Section 4, in which we show that the approach proposed in this paper is much more efficient than the existing schemes in processing updates. The experimental results are illustrated in Section 5, and we conclude in Section 6. In this section, we present three families of labeling schemes, viz. containment [2, 13, 24], prefix [1, 8, 17, 19] and prime [21]. Zhang et al [24] use a labeling scheme in which every node is assigned three values:  X  start  X  ,  X  end  X  and  X  level  X  . For any two u.end. In other words, the interval of v is contained in the interval of u. Node u is a parent of node v iff u is an ancestor of v and v.level  X  u.level = 1. For instance, in Figure 1,  X  5,6,3  X  is a child of  X  2,7,2  X  since interval [5, 6] is contained in interval [2, 7] and levels 3  X  2 = 1. Although the containment scheme is efficient to determine the ancestor-descendant relationship, the insertion of a node will lead to a re-labeling of all the ancestor nodes of this inserted node and all the nodes after this inserted node in document order (if we do not re-label, not only can not the document order be maintained, but the containment scheme can not work correctly to determine the A-D etc. relationships). This problem may be alleviated if the interval size is increased with values unused [13]. However, large interval size wastes a lot of numbers which causes the increase of storage, while small interval size is easy to lead to re-labeling. To solve the re-labeling problem, [3] uses Float-point values for the  X  start  X  and  X  end  X  of the intervals. It seems that Float-point solves the re-labeling problem [19]. But in practice, the Float-point is represented in a computer with a fixed number of bits [3, 19]. As a result, only 18 nodes can be inserted at a fixed place [3] since [3] uses the consecutive integer values at the initial labeling. Even if [3] uses values with large gaps, it still can not avoid the re-labeling due to the float-point precision. In fact, Float-point is equivalent to the method in [13] that some values are unused at the beginning. Therefore, using real values instead of integers only provides limited benefit for the node updating [19, 21]. In the prefix labeling scheme, the label of a node is that its parent  X  s label (prefix) concatenates its own (self) label. For any two nodes u and v, u is an ancestor of v iff label(u) is a prefix of label(v). Node u is a parent of node v iff label(v) has no prefix when removing label(u) from the left side of label(v). DeweyID [19] labels the n th child of a node with an integer n, and this n should be concatenated to the prefix (its parent  X  s label) and delimiter (e.g.  X  .  X  ) to form the complete label of this child node. In practice, DeweyID uses UTF8 [23] to process the delimiter. [8] uses Binary Strings (BinaryString) to label the XML tree. When a node is inserted, DeweyID [19] and BinaryString [8] both need to re-label the sibling nodes after this inserted node and the descendants of these siblings to maintain the document order. [11] is also based on binary strings, but it is dynamic. However [11] still can not completely avoid the re-labeling due to the overflow problem (see Example 3.2). OrdPath [17] is similar to DeweyID, but it only uses the odd numbers at the initial labeling. When the XML tree is updated, it uses the even number between two odd numbers to concatenate another odd number. When the sizes of the OrdPath codes overflow (see Example 3.2 in Section 3 for more details about the overflow problem), it must re-label all the existing nodes. [9] is similar to OrdPath [17] and [9] is not as compact as OrdPath. Wu et al [21] use Prime numbers to label XML trees. The root node is labeled with  X  1  X  (integer). Based on a top-down approach, each node is given a unique prime number (self_label) and the label of each node is the product of its parent node  X  s label (parent_label) and its own self_label. For any two nodes u and v, u is an ancestor of v iff label(v) mod label(u) = 0. Node u is a parent of node v iff label(v)/self_label(v) = label(u). Prime [21] uses SC (Simultaneous Congruence) values in Chinese Remainder Theorem [4] to determine the document order, i.e. SC mod self_label = document order. When the order is changed, Prime needs to re-calculate the SC values instead of re-labeling. Although Prime supports order-sensitive updates without any re-labeling of the existing nodes, it needs to re-calculate the SC values based on the new ordering of nodes. The re-calculation is very time consuming. All the current labeling schemes except Prime can not completely avoid the re-labeling in updates (OrdPath will encounter the overflow problem). Though Prime can completely avoid re-labeling, it needs to re-calculate the SC values which is much more expensive than re-labeling. Therefore the main objective of this paper is to dramatically decrease the update costs and completely avoid the re-labeling (see Sections 4.1, 5.1 and 5.2). In this section, we elaborate our Quaternary Encoding for Dynamic XML data (QED) which supports label insertion without re-labeling or re-calculation (see Section 4.1). For the containment scheme shown in Figure 1 (Section 2.1), the  X  start  X  and  X  end  X  values are from 1 to 16. These decimal numbers can be encoded in binary codes with fixed length, called FixedLength (FixedLength column of Table 1) or with variable length, called VarLength (VarLength column of Table 1). Definition 3.1 (Quaternary code) Four numbers  X  0  X  ,  X  1  X  ,  X  2  X  and  X  3  X  are used in the code and each number is stored with two bits, i.e.  X  00  X  ,  X  01  X  ,  X  10  X  and  X  11  X  .
 Definition 3.2 (QED code) QED code is a quaternary code. The are used in the QED code itself. Now let us discuss how to encode the  X  start  X  s and  X  end  X  s (1-16) using our QED encoding (16 is only an example for the tree in Figure 1; our QED encoding can be applied to any other numbers; see the formal algorithm in Section 3.1). The following steps show the details of how to get the QED codes in Table 1 and these steps are examples for the formal algorithms in Section 3.1. Step 1: In the encoding of the 16 numbers, we suppose there is one more number before number 1, say number 0, and one more number after number 16, say number 17. Float-point, DeweyID, OrdPath, Prime, FixedLength and 
VarLength are all existing schemes. QED-PREFIX and QED (with all fonts capitalized) are schemes proposed in this paper. Step 2: The (1/3) th number is encoded with  X  2  X  , and the (2/3) number is encoded with  X  3  X  . The (1/3) th number is number 6 , which is calculated in this way, 6 = round(0+(17  X  0)/3). The (2/3) th number is number 11 (11 = round(0+(17  X  0)  X  2/3)). Step 3: The (1/3) th and (2/3) th numbers between number 0 and number 6 are number 2 (2 = round(0+(6  X  0)/3)) and number 4 (4 = round(0+(6  X  0)  X  2/3)). The QED code of number 0 (left code) is now empty with size 0 and the QED code of number 6 (right code) is now  X  2  X  with size 1 (here 1 refers to 2 bits). This is Case (a) where the left code size is smaller than the right code size . In this case, the (1/3) th code is that we change the last symbol of the right code to  X  1  X  and concatenate one more  X  2  X  , i.e. the code of (2/3) th code is that we change the last symbol of the right code to  X  1  X  and concatenate one more  X  3  X  , i.e. the code of number 4 is  X  13  X  (  X  2  X   X   X  1  X  and  X  1  X   X   X  3  X   X   X  13  X  ). Step 4: The (1/3) th and (2/3) th numbers between numbers 6 and 11 are numbers 8 (8 = round(6+(11  X  6)/3)) and 9 (9 = round(6+(11  X  6)  X  2/3)). The QED code of number 6 (left code) is  X  2  X  with size 1 (here 1 refers to 2 bits) and the code of number 11 (right code) is  X  3  X  with size 1 (here 1 refers to 2 bits). This is Case (b) where the left code size is larger than or equal to the right code size . In this case, the (1/3) th code is that we directly concatenate one more  X  2  X  after the left code, i.e. the code of number 8 is  X  22  X  (  X  2  X   X   X  2  X   X   X  22  X  ), and the (2/3) th code is that we directly concatenate one more  X  3  X  after the left code, i.e. the code of number 9 is  X  23  X  (  X  2  X   X   X  3  X   X   X  23  X  ). Step 5: The (1/3) th and (2/3) th numbers between numbers 11 and 17 are numbers 13 (13 = round(11+(17  X  11)/3)) and 15 (15 = round(11+(17  X  11)  X  2/3)). The code of number 11 (left code) is  X  3  X  with size 1 and the code of number 17 (right code) is empty now with size 0. This is still Case (b) . Therefore the QED code of number 13 is  X  32  X  (  X  3  X   X   X  2  X   X   X  32  X  ), and the code of number 15 is  X  33  X  (  X  3  X   X   X  3  X   X   X  33  X  ). In this way, all the numbers will be encoded. Finally we need to discard the codes for numbers 0 and 17 since they do not exist actually. It should be noted that Step 1 is not compulsory, but with Step 1 the total code size is smaller . It should be noted also that if the (2/3) th number exactly refers to the (1/3) th number, the code for the (2/3) th number will not appear since this number has already been encoded with the (1/3) th code. With the following example illustration for the total code size, the formal size analysis in Section 3.2 will be easier to understand. Example 3.1 Table 1 shows that VarLength has smaller total code size than FixedLength. However, we also need to store the size of each VarLength code, e.g., the size of  X  10000  X  is 5. We need to store this 5 using fixed length of bits (  X  101  X  ; 3 bits). The sizes of other codes should also be stored using fixed length of bits (3 bits), therefore the total code size for VarLength is 3  X  bits which is larger than the bits required by FixedLength. Example 3.2 The size of each VarLength code is stored with fixed length (e.g. 3), therefore if many nodes are inserted into the XML tree, the fixed length size (e.g. 3) is not enough for the new labels, then we have to re-label all the existing nodes. Even if we increase the size 3 to a larger number, it still can not completely avoid the re-labeling, and it will waste the storage space. This is called the overflow problem in this paper. Similarly FixedLength and OrdPath [17] will encounter the overflow problem. Example 3.3 On the other hand, our QED uses the separator  X  0  X  (2 bits) to separate different codes instead of storing the sizes of the codes. For example,  X  1120120  X  will be separated to  X  112  X  and  X  12  X  . Therefore the size of our QED is 2  X  16+76=108 bits. Each size code of VarLength is stored with 3 bits, and this 3 will increase as the number of nodes increases, but the size 2 (bits) of our separator  X  0  X  will never increase. More important, we will never encounter the overflow problem in this way. The most important feature of our QED is that it is based on the lexicographical order (for efficient updates in Section 4.1). Definition 3.3 (Lexicographical order  X  ) Given two Quaternary codes C A and C B , C A is lexicographically equal to C iff they are exactly the same. C A is said to be lexicographically smaller than C B (C A  X  C B ) iff (a)  X  0  X   X   X  1  X   X   X  2  X   X   X  3  X  , or (b) compare C A and C B symbol by symbol from left to right. If (c) C A is a prefix of C B . Theorem 3.1 Our QED codes are lexicographically ordered but not numerically ordered.
 Example 3.4 The QED codes in Table 1 are lexicographically ordered from top to bottom. For example,  X  132  X   X   X  2  X  because the comparison is from left to right, and the 1 st symbol of  X  132  X  is  X  232  X  because  X  23  X  is a prefix of  X  232  X  . When we replace the  X  start  X  s and  X  end  X  s (1-16) in Figure 1 with our QED codes, and based on the lexicographical comparison, a QED containment scheme is formed. Algorithm 1: GetOneThirdAndTwoThirdCodes ( Left_Code, Right_Code ) Input: QED codes Left_Code, Right_Code, and Left_Code  X  Right_Code Output: QED codes: Code_AtOneThirdPos, Code_AtTwoThirdPos, such that Left_Code  X 
Code_AtOneThirdPos  X  Code_AtTwoThirdPos  X  Right_Code 1: get the sizes of Left_Code and Right_Code 2: if Left_Code and Right_Code are both empty 3: then Code_AtOneThirdPos =  X  2  X  4: Code_AtTwoThirdPos =  X  3  X  5: else //the below  X  means concatenation 6: if size(Left_Code) &lt; size(Right_Code) //case (a) 7: then Temp_Code = the Right_Code with the last 9: Code_AtOneThirdPos = Temp_Code  X   X  2  X  10: Code_AtTwoThirdPos = Temp_Code  X   X  3  X  11: else if size(Left_Code)  X  size(Right_Code) //case (b) 12: then Code_AtOneThirdPos = Left_Code  X   X  2  X  13: Code_AtTwoThirdPos = Left_Code  X   X  3  X  Algorithm 2: Encoding ( TN ) Input: A positive integer TN
Output: The QED codes for numbers 1 to TN 1: suppose there is one more number before the first number, called number 0 , and one more number after the last number, called number ( TN +1) 2: SubEncoding (codeArr, 0, TN +1) 3: discard the 0 th and ( TN +1) th elements of the array codeArr 
Procedure SubEncoding ( codeArr , P L , P R ) /*SubEncoding is a recursive procedure; codeArr is an array, P the left position, and P R is the right position*/ 4: P M1 = P L +round((P R -P L )/3) (P M1 is the (1/3) 5: P M2 = P L +round((P R -P L )  X  2/3) (P M2 is the (2/3) 6: if P L  X  P R 7: then GetOneThirdAndTwoThirdCodes(codeArr[P L ], 9: then codeArr[P M1 ]=Code_AtOneThirdPos //from line 7 11: then codeArr[P M2 ]=Code_AtTwoThirdPos //from line 7 13: then SubEncoding(codeArr, P L , P M1 ) 14: SubEncoding(codeArr, P M1 , P M2 ) 15: SubEncoding(codeArr, P M2 , P R ) Algorithm 1 and Algorithm 2 are a summary of Step 1 to Step 5 (in the previous page) which can be used to encode any total number (not only 16). Here we do not explain them in detail. In this section, we analyze the size required by Prime, Float-point, FixedLength, VarLength and our QED. The  X  D  X  and  X  N  X  are respectively used to denote the maximal depth and the number of nodes of an XML tree. Prime According to the size analysis of Prime in [21], the size required to store all the nodes in the XML tree is: Float-point According to [3], each float-point number is stored with 64 bits, thus the size of Float-point: FixedLength The size of FixedLength is: VarLength For VarLength, one number 1 is stored with one bit (see VarLength column of Table 1), two numbers 2 and 3 are stored with 2 bits, four numbers 4, 5, 6 and 7 are stored with 3 bits,  X  X  X  , thus the total size of VarLength is: n (4) Since the number of nodes is N, the number of  X  start  X  s and  X  end  X  s is 2N which should be equal to 1 2 2 2 2 1 1 0 -= +  X   X   X  + + However 2N is an even number and can not be equal to 1 2 1 -We assume that there are 2N+1 numbers. After getting the VarLength codes, we can discard one number, i.e. 2N numbers are left. There is only a constant difference between 2N and 2N+1, thus we assume that 2N+1= 1 2 1 -+ n , then formula (4) becomes: 1 ) 1 log( 2 ) 1 log( 2 + + + + N N N (5) Note that formula (5) is a little larger than the actural size required by VarLength. We need to store the size of each  X  start  X  and  X  end  X  . A fixed-length number is used to store the size of the VarLength code. this size, the bits required are )) 2 log(log( N , then the total bits required to store the sizes of VarLength codes are total size of VarLength is: QED When considering our QED, it has two numbers 6 and 11 stored with size 1 (2 bits), 6 numbers 2, 4, 8, 9, 13 and 15 stored with size 2 (2 bits),  X  X  X  , therefore its size is: We assume +  X  +  X  = ) 3 2 ( ) 3 2 ( 2 1 0 N 1 3 ) 3 2 ( 1 -=  X  +  X   X   X  sides are even numbers), then formula (7) becomes to: When considering the separator (  X  0  X  ) size 2 2  X  N , the total label size of our QED is: It can be seen that VarLength has larger label size than FixedLength. Prime has larger size than VarLength. To make the size of Float-point smaller than VarLength, N should be grossly larger than 2 64 , but generally speaking, an XML file can not have so many nodes. That is to say, Float-point has larger label size than VarLength. If N&gt;2 64 , 64 bits are not enough to store the Float-point values. When N=1, the size of our QED is 1.6 times of that of VarLength; when ] 7 , 2 [  X  N , the multiple is between 1.16 and 1.28; when the size of our QED is only a little larger than the size of VarLength. Also we need to consider the  X  level  X  size for the containment schemes which is )) log(log( ) log( D D N + and should be added into formulas (2), (3), (6) and (9) to form the total label sizes of these schemes. Note that for simplicity, we omit the ceiling functions on the log functions in all the formulas. Property 3.1 Our QED is orthogonal to specific labeling schemes, thus it can be applied to all the labeling schemes or other applications which need to maintain the order.
 Our QED encoding can be applied to the prefix scheme and prime scheme also to maintain the document order. When QED is applied to prefix, we call it QED-PREFIX. Example 3.5 Figure 4 shows that we apply QED to the prefix scheme. The root has 4 children. To encode 4 numbers based on only one sibling, its self_label is  X  2  X  . For the prefix scheme, the delimiter  X  .  X  can not be stored together with the numbers in the implementation to separate different components.
 For our QED encoding, we use the following approach to process the delimiters. We use one separator  X  0  X  as the delimiter to separate different components of a label ( e.g. separate  X  12  X  and 4), and use two consecutive separators  X  00  X  as the separator to separate different labels ( e.g. separate  X  12.2  X  and  X  12.3  X  ). We can apply our QED to the prime labeling scheme also to record the document order. But because Prime employs the modular and division operations to determine the ancestor-descendant etc. relationships, its query efficiency is quite bad. Thus we do not discuss in detail how QED is applied to Prime. Similarly we can and it is better to apply our QED to the P-Containment scheme proposed in [12] to completely avoid re-labeling. In Section 4.1, we show that our QED has much cheaper update cost. Section 4.2 analyzes the case for the frequent update. The deletion of a node will not affect the ordering of the nodes in the XML tree. Thus in this section, we only discuss the insertion. Algorithm 3 is similar to Algorithm 1, and their difference is marked in Figure 5 with italic fonts. Based on Algorithm 3, we can avoid the re-labeling. As the QED codes are long which can not be put in Figures 6, we still use decimal numbers in Figure 6 stored using our QED codes. Refer to Table 1 for the mappings between the decimal numbers and our QED codes. We use an example to show how Algorithm 3 works. Example 4.1 When inserting node  X  a  X  (see Figure 6), we should insert a number between the  X  start  X  of the parent  X  1  X  (Left_Code) traditional approach, we can not insert a number between  X  1  X  and  X  2  X  , and we must re-label the nodes. However, when referring to Table 1, our QED codes for  X  1  X  and  X  2  X  are  X  112  X  and  X  12  X  . Based on the GetInsertedCode algorithm, we insert a value between  X  112  X  and  X  12  X  , then the  X  start  X  value of the inserted node  X  a  X  is  X  113  X  (see lines 5-8 of the GetInsertedCode algorithm in Figure 5). The  X  end  X  value of node  X  a  X  is an insertion between 5). Obviously,  X  112  X   X   X  113  X   X   X  1132  X   X   X  12  X  lexicographically. We need not re-label any existing nodes, but we can keep the containment scheme working correctly. Algorithm 3: GetInsertedCode Input: Left_Code, Right_Code 
Output: Inserted_Code, such that Left_Code  X  Inserted_Code  X  Right_Code lexicographically. 1: get the sizes of Left_Code and Right_Code 2: if size(Left_Code) &lt; size(Right_Code) 3: then Inserted_Code = (the Right_Code with the last 5: else if size(Left_Code) &gt; size(Right_Code) 6: if the last symbol of Left_Code is  X  2  X  7: then Inserted_Code = the Left_Code with the 9: else if the last symbol of Left_Code is  X  3  X  10: then Inserted_Code = Left_Code  X   X  2  X  11: else if size(Left_Code) = size(Right_Code) 12: then Inserted_Code = Left_Code  X   X  2  X  Theorem 4.1 Algorithm 3 guarantees that infinite number of QED codes can be inserted between any two consecutive QED codes with the orders kept and without any re-encoding of the existing numbers.
 Based on Theorem 4.1, the insertions of nodes  X  b  X  ,  X  c  X  and  X  d  X  will not cause any re-labeling also. After insertion, the level illustration), but the level value of node  X  d  X  is 3. Now let us study the updates based on other schemes. Example 4.2 For the containment schemes FixedLength and VarLength, when  X  a  X  is inserted into the XML tree in Figure 6, all need to be added with 2. The  X  end  X  value of the root will be  X  18  X  after update. It is similar for  X  b  X  ,  X  c  X  and  X  d  X  . Example 4.3 For the prefix schemes, our QED-PREFIX also need not re-label any existing nodes. DeweyID has to re-label all the sibling nodes after the inserted node and the descendants of these following sibling nodes. For Prime, the insertion of nodes will make the document order change (the orders of the nodes after this inserted node should all be added with 1), therefore Prime has to re-calculate the SC values. Sometimes Float-point [3] and OrdPath [17] also need not re-label the nodes. Sections 5.1 and 5.2 are the update performance comparisons among Float-point, OrdPath and our approach. The size analysis in Section 3.2 is based on the initial labeling of the XML. Our encoding algorithm (see Figure 3) is step by step insertions of nodes uniformly at different places. Therefore if a sequence of nodes are inserted randomly at different places of the XML, the size analysis in Section 3.2 is still valid. For the case that nodes are always inserted at a fixed place of the XML, the size of our QED increases quickly. [8] proves that any deterministic labeling scheme which does not re-label nodes must in the worst case assign labels of size Omega(N). Our QED can not escape from this claim also, i.e. the label size of our QED increases linearly in the worst case. OrdPath [17] also has this skewed insertion problem. [18] uses B-tree to balance the update and lookup performance which can be used to process this skewed insertion problem. The skewed insertion is not an emphasis of this paper. In this paper, we mainly focus on how to completely avoid the re-labeling. In this section, we evaluate and compare the performance of different labeling schemes. All the schemes are implemented in Java and all the experiments are carried out on a 3.0 GHz Pentium 4 processor with 1 GB RAM running Windows XP Professional. Table 2 shows the characteristics of the test datasets. D1, D2 and D3 are from [16], D5 and D6 are from [20], and all of them are real-world XML data. D4 is a benchmark generated by XMark [22]. Static XML is not the emphasis of this paper. However, we also test how our QED works on the static XML data which shows that our QED works not worse even in the static environment of XML (its label sizes are small in the six datasets shown in Table 2 and its query performance is not worse). For the dynamic XML, in Section 5.1 we show that our QED works much better compared to the existing labeling schemes except OrdPath and Float-point. Although it seems that OrdPath and Float-point also work well in the intermittent insertions, the wide update performance difference between OrdPath and our QED-PREFIX, and between Float-point and our QED can be seen from Section 5.2, where frequent updates are performed. OrdPath and our QED-PREFIX are prefix schemes. Float-point, FixedLength, VarLength, and our QED are containment schemes. We select one XML file Hamlet in D2 to test the update performance (it is similar for other XML files). Hamlet has 5 act elements. We test the following six cases: inserting an act before act[1], inserting an act between act[1] and act[2],  X  X  X  , inserting an act between act[4] and act[5], and inserting an act after act[5]. Figure 7(a) shows the number of nodes for re-labeling when applying different labeling schemes. FixedLength and VarLength have the same number of nodes to re-label in all the six cases. For case 1, 6596 (total 6636) nodes need to be re-labeled. For Prime, the number of SC values that are required to re-calculate is counted in Figure 7(a). Because Prime uses each SC value for every five labels [21], the number of SC values required to re-calculate is 1/5 of the number of nodes required by FixedLength and VarLength to re-label. Note that it is impossible to use a single SC value for all the nodes in the XML since the SC value will be too large. In all the six cases, OrdPath1 (without overflow here), OrdPath2 (without overflow here), our QED-PREFIX, Float-point (less than 18 nodes), and our QED need not re-label any existing nodes. Next we study the time required to re-label nodes or re-calculate SC values. Figure 7(b) shows that the time required by Prime to re-calculate the SC values is much larger (more than 202 times; sum time of Case 1 to Case 6) than the time required by FixedLength and VarLength to re-label the nodes. Prime theoretically is a good scheme in updating order-sensitive nodes, but it is not practicable. In contrast, our QED-PREFIX and QED need less than 0.001 second (processing time) for the insertion in all the 6 cases. The processing time of FixedLength or VarLength is at least 84 times of that of QED-PREFIX and QED even if we assume that our QED needs 0.001 second for the update (in fact, it will be much larger than 84 times; see Section 5.2). It can be seen that OrdPath1, OrdPath2 and Float-point also need less than 0.001 second for the update. This is because only several nodes are inserted into the XML. The update performance difference among OrdPath, Float-point and our approach can be seen in Section 5.2 where frequent insertions are executed. When intermittent nodes are inserted into the XML, Prime, FixedLength and VarLength have much larger update time, thus it will be a disaster for them to update the XML with frequent and tiny insertions, which makes them impossible to answer any queries in either the uniformly frequent or skewed frequent insertion environment. In this section, we mainly compare the update performance between OrdPath and our QED-PREFIX, and between Float-point and our QED. Section 5.2.1 discusses the case that frequent insertions are randomly at different places of the XML. Section 5.2.2 discusses the worst case that frequent insertions are always at a fixed place of the XML. In this section, we test the uniformly distributed frequent insertions. The Hamlet file has totally 6636 nodes. We insert 6635 nodes between every two consecutive nodes of the 6636 nodes. Based on the new file after insertion, we insert another 13270 nodes between any two consecutive nodes. We repeat this kind of insertion 6 times. After the 6 th time insertion, the node number in Hamlet is 424641 that is 63.99 times of the original node number. The first two time insertions and the first four time insertions respectively will not cause OrdPath [17] (without overflow) and Float-point [3] (less than 18 nodes at a fixed place) to re-label the existing nodes. Even without re-labeling, Figure 8(a) shows that the update time of OrdPath is still at least 529 times of that of our QED-PREFIX and Figure 8(b) shows that the update time of Float-point is 386 times of that of our QED. OrdPath and Float-point have much larger update time because they need the addition and division operations to get the numbers between two numbers which are very expensive. On the other hand, our QED-PREFIX and QED only need to modify the last quaternary number (two bits) of the neighbor label to get the label of the inserted node which is much cheaper. At the 3 rd time insertion, OrdPath needs to re-label all the existing nodes, and at the 5 th and 6 th time insertions, Float-point needs to re-label all the existing nodes. The re-labeling time of OrdPath and Float-point is at least 2492 times of that of our QED-PREFIX and QED (see Figures 8(a) and 8(b)). In this section, we test the case that nodes are always inserted at a fixed place of the Hamlet XML. Figure 9 shows the re-labeling time (the update time without re-labeling in skewed frequent insertions is similar to the update time shown in Figure 8). For OrdPath (OrdPath1 and OrdPath2) [17], after inserting 163 nodes at the fixed place, it needs to re-label 5 times. The re-labeling time of OrdPath is at least 8126 times of that of our QED-PREFIX (see Figure 9(a)). When every 18 nodes are inserted at the fixed place of the XML, Float-point [3] needs to re-label. The update time of Float-point is 34383 times of that of our QED after 199 nodes are inserted (see Figure 9(b)). The very large update time makes OrdPath and Float-point unsuitable to answer queries no matter in the uniformly or in the skewed frequent insertion environment. This means even if we do not use any skeweness processing technique, our QED still works the best to answer queries in the environment that frequent insertions are executed. For the frequent update, our QED-PREFIX and QED have much cheaper update cost than OrdPath and Float-point. (a) OrdPath1&amp;2 vs QED-PREFIX (a) OrdPath1&amp;2 vs QED-PREFIX In this paper, we have proposed a novel Dynamic Quaternary Encoding (QED) approach for the labeling schemes. This encoding approach is orthogonal to specific labeling schemes, therefore it can be applied broadly to different labeling shemes, e.g. containment, prefix and prime schemes, to maintain the document order when the XML is updated. The QED (or QED-PREFIX) proposed in this paper completely (no overflow) avoids the re-labeling in XML update. When a node is inserted, our QED (or QED-PREFIX) only needs to modify the last quaternary number (two bits) of the neighbor label to get the label of the inserted node which is very easy and cheap compared to Float-point (or OrdPath). The experimental results show that our QED (or QED-PREFIX) encoding is the only approach which supports frequent insertions efficiently. [1] S. Abiteboul, H. Kaplan, and T. Milo. Compact labeling [2] R. Agrawal, A. Borgida, and H.V. Jagadish. Efficient [3] T. Amagasa, M. Yoshikawa, and S. Uemura. QRS: A Robust [4] J.A. Anderson and J.M. Bell. Number Theory with [5] A. Berglund, S. Boag, D. Chamberlin, M. F. Fernandez, M. [6] S. Boag, D. Chamberlin, M. F. Fernandez, D. Florescu, J. [7] T. Bray, J. Paoli, C. M. Sperberg-McQueen, E. Maler, and F. [8] E. Cohen, H. Kaplan, and T. Milo. Labeling Dynamic XML [9] M. Duong and Y. Zhang. A New Labeling Scheme for [10] R. Goldman and J. Widom. DataGuides: Enabling Query [11] C. Li and T.W. Ling. An Improved Prefix Labeling Scheme: [12] C. Li, T.W. Ling, J. Lu, and T. Yu. On Reducing [13] Q. Li and B. Moon. Indexing and Querying XML Data for [14] J. McHugh, S. Abiteboul, R. Goldman, D. Quass, and J. [15] S. Nestorov, J.D. Ullman, J.L. Wiener, and S.S. Chawathe. [16] NIAGARA Experimental Data. Available at: [17] P.E. O'Neil, E.J. O'Neil, S. Pal, I. Cseri, G. Schaller, and N. [18] A. Silberstein, H. He, K. Yi, and J. Yang. BOXes: Efficient [19] I. Tatarinov, S. Viglas, K.S. Beyer, J. Shanmugasundaram, [20] University of Washington XML Repository. Available at: [21] X. Wu, M.L. Lee, and W. Hsu. A Prime Number Labeling [22] XMark  X  An XML Benchmark Project. Available at: [23] F. Yergeau. UTF8: A Transformation Format of ISO 10646. [24] C. Zhang, et al. On Supporting Containment Queries in 
