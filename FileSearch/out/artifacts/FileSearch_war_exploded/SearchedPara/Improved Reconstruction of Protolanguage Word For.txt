 A central problem in diachronic linguistics is the re-construction of ancient languages from their modern descendants (Campbell, 1998). Here, we consider the problem of reconstructing phonological forms, given a known linguistic phylogeny and known cog-nate groups. For example, Figure 1 (a) shows a col-lection of word forms in several Oceanic languages, all meaning to cry . The ancestral form in this case has been presumed to be / taNis / in Blust (1993). We are interested in models which take as input many such word tuples, each representing a cognate group, along with a language tree, and induce word forms for hidden ancestral languages.

The traditional approach to this problem has been the comparative method , in which reconstructions are done manually using assumptions about the rel-ative probability of different kinds of sound change (Hock, 1986). There has been work attempting to automate part (Durham and Rogers, 1969; Eastlack, 1977; Lowe and Mazaudon, 1994; Covington, 1998; Kondrak, 2002) or all of the process (Oakes, 2000; Bouchard-C  X  ot  X  e et al., 2008). However, previous au-tomated methods have been unable to leverage three important ideas a linguist would employ. We ad-dress these omissions here, resulting in a more pow-erful method for automatically reconstructing an-cient protolanguages.

First, linguists triangulate reconstructions from many languages, while past work has been lim-ited to small numbers of languages. For example, Oakes (2000) used four languages to reconstruct Proto-Malayo-Javanic (PMJ) and Bouchard-C  X  ot  X  e et al. (2008) used two languages to reconstruct Clas-sical Latin (La). We revisit these small datasets and show that our method significantly outperforms these previous systems. However, we also show that our method can be applied to a much larger data set (Greenhill et al., 2008), reconstructing Proto-Oceanic (POc) from 64 modern languages. In ad-dition, performance improves with more languages, which was not the case for previous methods.
Second, linguists exploit knowledge of phonolog-ical universals. For example, small changes in vowel height or consonant place are more likely than large changes, and much more likely than change to ar-bitrarily different phonemes. In a statistical system, one could imagine either manually encoding or auto-matically inferring such preferences. We show that both strategies are effective.

Finally, linguists consider not only how languages change, but also how they are internally consistent. Past models described how sounds do (or, more of-ten, do not) change between nodes in the tree. To borrow broad terminology from the Optimality The-ory literature (Prince and Smolensky, 1993), such models incorporated faithfulness features, captur-ing the ways in which successive forms remained similar to one another. However, each language has certain regular phonotactic patterns which con-strain these changes. We encode such patterns us-ing markedness features, characterizing the internal phonotactic structure of each language. Faithfulness and markedness play roles analogous to the channel and language models of a noisy-channel system. We show that markedness features improve reconstruc-tion, and can be used efficiently. Our focus in this section is on describing the prop-erties of the two previous systems for reconstruct-ing ancient word forms to which we compare our method. Citations for other related work, such as similar approaches to using faithfulness and marked-ness features, appear in the body of the paper.
In Oakes (2000), the word forms in a given pro-tolanguage are reconstructed using a Viterbi multi-alignment between a small number of its descendant languages. The alignment is computed using hand-set parameters. Deterministic rules characterizing changes between pairs of observed languages are ex-tracted from the alignment when their frequency is higher than a threshold, and a proto-phoneme inven-tory is built using linguistically motivated rules and parsimony. A reconstruction of each observed word is first proposed independently for each language. If at least two reconstructions agree, a majority vote is taken, otherwise no reconstruction is proposed. This approach has several limitations. First, it is not tractable for larger trees, since the time complexity of their multi-alignment algorithm grows exponen-tially in the number of languages. Second, deter-ministic rules, while elegant in theory, are not robust to noise: even in experiments with only four daugh-ter languages, a large fraction of the words could not be reconstructed.

In Bouchard-C  X  ot  X  e et al. (2008), a stochastic model of sound change is used and reconstructions are in-ferred by performing probabilistic inference over an evolutionary tree expressing the relationships be-tween languages. The model does not support gener-alizations across languages, and has no way to cap-ture phonotactic regularities within languages. As a consequence, the resulting method does not scale to large phylogenies. The work we present here ad-dresses both of these issues, with a richer model and faster inference allowing improved reconstruc-tion and increased scale. We start this section by introducing some notation. Let  X  be a tree of languages, such as the examples in Figure 3 (c-e). In such a tree, the modern lan-guages, whose word forms will be observed, are the leaves of  X  . All internal nodes, particularly the root, are languages whose word forms are not observed. Let L denote all languages, modern and otherwise. All word forms are assumed to be strings  X   X  in the International Phonological Alphabet (IPA). 1
We assume that word forms evolve along the branches of the tree  X  . However, it is not the case that each cognate set exists in each modern lan-guage. Formally, we assume there to be a known list of C cognate sets. For each c  X  { 1 , . . . , C } let L ( c ) denote the subset of modern languages that have a word form in the c -th cognate set. For each set c  X  { 1 , . . . , C } and each language `  X  L ( c ) , we denote the modern word form by w c` . For cognate set c , only the minimal subtree  X  ( c ) containing L ( c and the root is relevant to the reconstruction infer-ence problem for that set.

From a high-level perspective, the generative pro-cess is quite simple. Let c be the index of the cur-rent cognate set, with topology  X  ( c ) . First, a word is generated for the root of  X  ( c ) using an (initially unknown) root language model (distribution over strings). The other nodes of the tree are drawn incre-mentally as follows: for each edge `  X  ` 0 in  X  ( c ) use a branch-specific distribution over changes in strings to generate the word at node ` 0 .

In the remainder of this section, we clarify the ex-act form of the conditional distributions over string changes, the distribution over strings at the root, and the parameterization of this process. 3.1 Markedness and Faithfulness In Optimality Theory (OT) (Prince and Smolensky, 1993), two types of constraints influence the selec-tion of a realized output given an input form: faith-fulness and markedness constraints. Faithfulness en-courages similarity between the input and output while markedness favors well-formed output.
Viewed from this perspective, previous computa-tional approaches to reconstruction are based almost exclusively on faithfulness, expressed through a mu-tation model. Only the words in the language at the root of the tree, if any, are explicitly encouraged to be well-formed. In contrast, we incorporate con-straints on markedness for each language with both general and branch-specific constraints on faithful-ness. This is done using a lexicalized stochastic string transducer (Varadarajan et al., 2008).
We now make precise the conditional distribu-tions over pairs of evolving strings, referring to Fig-ure 1 (b-d). Consider a language ` 0 evolving to ` for cognate set c . Assume we have a word form x = w cl 0 . The generative process for producing y = w cl works as follows. First, we consider x to be composed of characters x 1 x 2 . . . x n , with the first and last being a special boundary symbol x created. The process generates y = y 1 y 2 . . . y n in n chunks y i  X   X   X  , i  X  { 1 , . . . , n } , one for each x The y i  X  X  may be a single character, multiple charac-ters, or even empty. In the example shown, all three of these cases occur.

To generate y i , we define a mutation Markov chain that incrementally adds zero or more charac-ters to an initially empty y i . First, we decide whether the current phoneme in the top word t = x i will be deleted, in which case y i = as in the example of / s / being deleted. If t is not deleted, we chose a sin-gle substitution character in the bottom word. This is the case both when / a / is unchanged and when / N / substitutes to / n /. We write S =  X   X  {  X  } for this set of outcomes, where  X  is the special outcome indi-cating deletion. Importantly, the probabilities of this multinomial can depend on both the previous char-acter generated so far (i.e. the rightmost character p of y i  X  1 ) and the current character in the previous generation string ( t ). As we will see shortly, this al-lows modelling markedness and faithfulness at every branch, jointly. This multinomial decision acts as the initial distribution of the mutation Markov chain.
We consider insertions only if a deletion was not selected in the first step. Here, we draw from a multinomial over S , where this time the special out-come  X  corresponds to stopping insertions, and the other elements of S correspond to symbols that are appended to y i . In this case, the conditioning envi-ronment is t = x i and the current rightmost symbol p in y i . Insertions continue until  X  is selected. In the example, we follow the substitution of / N / to / n / with an insertion of / g /, followed by a decision to stop that y i . We will use  X  S,t,p,` and  X  I,t,p,` to denote the probabilities over the substitution and insertion decisions in the current branch ` 0  X  ` .

A similar process generates the word at the root ` of a tree, treating this word as a single string y 1 generated from a dummy ancestor t this case, only the insertion probabilities matter, and we separately parameterize these probabilities with  X 
R,t,p,` . There is no actual dependence on t at the root, but this formulation allows us to unify the pa- X   X  { R, S, I } . 3.2 Parameterization Instead of directly estimating the transition proba-bilities of the mutation Markov chain (as the param-eters of a collection of multinomial distributions) we express them as the output of a log-linear model. We used the following feature templates:
OPERATION identifies whether an operation in the mutation Markov chain is an insertion, a deletion, a substitution, a self-substitution (i.e. of the form x  X  y, x = y ), or the end of an insertion event. Examples in Figure 1 (d): 1 [ Subst ] and 1 [ Insert ] .
MARKEDNESS consists of language-specific n-gram indicator functions for all symbols in  X  . Only unigram and bigram features are used for computa-tional reasons, but we show in Section 5 that this already captures important constraints. Examples in Figure 1 (d): the bigram indicator 1 [ (n g)@Kw ] (Kw stands for Kwara X  X e, a language of the Solomon Islands), the unigram indicators 1 [ (n)@Kw ] and 1 [ (g)@Kw ] .

FAITHFULNESS consists of indicators for muta-tion events of the form 1 [ x  X  y ] , where x  X   X  , y  X  S . Examples: 1 [ N  X  n ] , 1 [ N  X  n@Kw ] .
Feature templates similar to these can be found for instance in Dreyer et al. (2008) and Chen (2003), in the context of string-to-string transduction. Note also the connection with stochastic OT (Goldwater and Johnson, 2003; Wilson, 2006), where a log-linear model mediates markedness and faithfulness of the production of an output form from an under-lying input form. 3.3 Parameter sharing Data sparsity is a significant challenge in protolan-guage reconstruction. While the experiments we present here use an order of magnitude more lan-guages than previous computational approaches, the increase in observed data also brings with it addi-tional unknowns in the form of intermediate pro-tolanguages. Since there is one set of parameters for each language, adding more data is not sufficient for increasing the quality of the reconstruction: we show in Section 5.2 that adding extra languages can actually hurt reconstruction using previous methods. It is therefore important to share parameters across different branches in the tree in order to benefit from having observations from more languages.

As an example of useful parameter sharing, con-sider the faithfulness features 1 [ /p/  X  /b/ ] and 1 [ /p/  X  /r/ ] , which are indicator functions for the appearance of two substitutions for /p/. We would like the model to learn that the former event (a sim-ple voicing change) should be preferred over the lat-ter. In Bouchard-C  X  ot  X  e et al. (2008), this has to be learned for each branch in the tree. The difficulty is that not all branches will have enough information to learn this preference, meaning that we need to de-fine the model in such a way that it can generalize across languages.

We used the following technique to address this problem: we augment the sufficient statistics of Bouchard-C  X  ot  X  e et al. (2008) to include the current language (or language at the bottom of the current branch) and use a single, global weight vector in-stead of a set of branch-specific weights. Gener-alization across branches is then achieved by using features that ignore ` , while branch-specific features depend on ` .

For instance, in Figure 1 (d), 1 [ N  X  n ] is an example of a universal (global) feature shared across all branches while 1 [ N  X  n@Kw ] is branch-specific. Similarly, all of the features in OPERA -versal and branch-specific versions. 3.4 Objective function Concretely, the transition probabilities of the muta-tion and root generation are given by: where  X   X  S , f : { S, I, R } X   X   X   X   X  L  X  S  X  R k is the sufficient statistics or feature function,  X  X  ,  X  X  denotes inner product and  X   X  R k is a weight vector. Here, k is the dimensionality of the feature space of the log-linear model. In the terminology of exponen-tial families, Z and  X  are the normalization function and reference measure respectively: Here,  X  is used to handle boundary conditions. We will also need the following notation: let P ity models described in Section 3.1 (with transition probabilities given by the above log-linear model), I ( c ) , the set of internal (non-leaf) nodes in  X  ( c ) , pa( ` ) , the parent of language ` , r( c ) , the root of jective function as follows:
The second term is a standard L 2 regularization penalty (we used  X  2 = 1 ). Learning is done using a Monte Carlo variant of the Expectation-Maximization (EM) algorithm (Demp-ster et al., 1977). The M step is convex and com-puted using L-BFGS (Liu et al., 1989); but the E step is intractable (Lunter et al., 2003), so we used a Markov chain Monte Carlo (MCMC) approxima-tion (Tierney, 1994). At E step t = 1 , 2 , . . . , we simulated the chain for O ( t ) iterations; this regime is necessary for convergence (Jank, 2005).

In the E step, the inference problem is to com-pute an expectation under the posterior over strings in a protolanguage given observed word forms at the leaves of the tree. The typical approach in biology or historical linguistics (Holmes and Bruno, 2001; Bouchard-C  X  ot  X  e et al., 2008) is to use Gibbs sam-pling, where the entire string at a single node in the tree is sampled, conditioned on its parent and chil-dren. This sampling domain is shown in Figure 1 (e), where the middle word is completely resampled but adjacent words are fixed. We will call this method Single Sequence Resampling (SSR). While concep-tually simple, this approach suffers from problems in large trees (Holmes and Bruno, 2001). Con-sequently, we use a different MCMC procedure, called Ancestry Resampling (AR) that alleviates the mixing problems (Figure 1 (f)). This method was originally introduced for biological applications (Bouchard-C  X  ot  X  e et al., 2009), but commonalities be-tween the biological and linguistic cases make it possible to use it in our model.

Concretely, the problem with SSR arises when the tree under consideration is large or unbalanced. In this case, it can take a long time for information from the observed languages to propagate to the root of the tree. Indeed, samples at the root will ini-tially be independent of the observations. AR ad-dresses this problem by resampling one thin vertical slice of all sequences at a time, called an ancestry. For the precise definition, see Bouchard-C  X  ot  X  e et al. (2009). Slices condition on observed data, avoiding the problems mentioned above, and can propagate information rapidly across the tree. We performed a comprehensive set of experiments to test the new method for reconstruction outlined above. In Section 5.1, we analyze in isolation the effects of varying the set of features, the number of observed languages, the topology, and the number of iterations of EM. In Section 5.2 we compare per-formance to an oracle and to three other systems.
Evaluation of all methods was done by computing the Levenshtein distance (Levenshtein, 1966) be-tween the reconstruction produced by each method and the reconstruction produced by linguists. We averaged this distance across reconstructed words to report a single number for each method. We show in Table 2 the average word length in each corpus; note that the Latin average is much larger, giving an explanation to the higher errors in the Romance dataset. The statistical significance of all perfor-mance differences are assessed using a paired t-test with significance level of 0.05. 5.1 Evaluating system performance We used the Austronesian Basic Vocabulary Database (Greenhill et al., 2008) as the basis for a series of experiments used to evaluate the per-formance of our system and the factors relevant to its success. The database includes partial cognacy judgments and IPA transcriptions, as well as a few reconstructed protolanguages. A reconstruction of Proto-Oceanic (POc) originally developed by Blust (1993) using the comparative method was the basis for evaluation.

We used the cognate information provided in the database, automatically constructing a global tree 2 and set of subtrees from the cognate set in-dicator matrix M ( `, c ) = 1 [ `  X  L ( c )] , c  X  { 1 , . . . , C } , `  X  L . For constructing the global tree, we used the implementation of neighbor joining in the Phylip package (Felsenstein, 1989). We used a distance based on cognates overlap, d c ( ` 1 , ` 2 ) = P samples and formed an accurate (90%) consensus tree. The tree obtained is not binary, but the AR inference algorithm scales linearly in the branching factor of the tree (in contrast, SSR scales exponen-tially (Lunter et al., 2003)).

The first claim we verified experimentally is that having more observed languages aids reconstruction of protolanguages. To test this hypothesis we added observed modern languages in increasing order of distance d c to the target reconstruction of POc so that the languages that are most useful for POc re-construction are added first. This prevents the ef-fects of adding a close language after several distant ones being confused with an improvement produced by increasing the number of languages.

The results are reported in Figure 2 (a). They con-firm that large-scale inference is desirable for au-tomatic protolanguage reconstruction: reconstruc-tion improved statistically significantly with each in-crease except from 32 to 64 languages, where the average edit distance improvement was 0.05.
We then conducted a number of experiments in-tended to assess the robustness of the system, and to identify the contribution made by different factors it incorporates. First, we ran the system with 20 dif-ferent random seeds to assess the stability of the so-lutions found. In each case, learning was stable and accuracy improved during training. See Figure 2 (b).
Next, we found that all of the following ablations significantly hurt reconstruction: using a flat tree (in which all languages are equidistant from the recon-structed root and from each other) instead of the con-sensus tree, dropping the markedness features, drop-ping the faithfulness features, and disabling sharing across branches. The results of these experiments are shown in Table 1.

For comparison, we also included in the same table the performance of a semi-supervised system trained by K -fold validation. The system was ran to the system as observations in the graphical model for each run. It is semi-supervised in the sense that gold reconstruction for many internal nodes are not available in the dataset (for example the common an-cestor of Kwara X  X e (Kw.) and Lau in Figure 3 (b)), so they are still not filled. 3
Figure 3 (b) shows the results of a concrete run over 32 languages, zooming in to a pair of the Solomonic languages and the cognate set from Fig-ure 1 (a). In the example shown, the reconstruc-tion is as good as the ORACLE (described in Sec-tion 5.2), though off by one character (the final / s / is not present in any of the 32 inputs and therefore is not reconstructed). In (a), diagrams show, for both the global and the local (Kwara X  X e) features, the expectations of each substitution superimposed on an IPA sound chart, as well as a list of the top changes. Darker lines indicate higher counts. This run did not use natural class constraints, but it can be seen that linguistically plausible substitutions are learned. The global features prefer a range of voic-ing changes, manner changes, adjacent vowel mo-tion, and so on, including mutations like / s / to / h / which are common but poorly represented in a naive attribute-based natural class scheme. On the other hand, the features local to the language Kwara X  X e pick out the subset of these changes which are ac-tive in that branch, such as / s /  X  / t / fortition. 5.2 Comparisons against other methods The first two competing methods, PRAGUE and BCLKG , are described in Oakes (2000) and Bouchard-C  X  ot  X  e et al. (2008) respectively and sum-marized in Section 1. Neither approach scales well to large datasets. In the first case, the bottleneck is the complexity of computing multi-alignments with-out guide trees and the vanishing probability that in-dependent reconstructions agree. In the second case, the problem comes from the unregularized prolifera-tion of parameters and slow mixing of the inference algorithm. For this reason, we built a third baseline that scales well in large datasets.

This third baseline, CENTROID , computes the centroid of the observed word forms in Leven-shtein distance. Let L ( x, y ) denote the Lev-enshtein distance between word forms x and y . Ideally, we would like the baseline to return argmin { y 1 , . . . , y | O | } is the set of observed word forms. Note that the optimum is not changed if we restrict the minimization to be taken on x  X   X ( O )  X  such that m  X  | x |  X  M where m = min i | y i | , M = max in O . Even with this restriction, this optimization is intractable. As an approximation, we considered only strings built by at most k contiguous substrings taken from the word forms in O . If k = 1 , then it is equivalent to taking the min over x  X  O . At the other end of the spectrum, if k = M , it is exact. This scheme is exponential in k , but since words are relatively short, we found that k = 2 often finds the same solution as higher values of k . The difference was in all the cases not statistically significant, so we report the approximation k = 2 in what follows. We also compared against an oracle, denoted OR -ACLE , which returns argmin y  X  O L ( y, x  X  ) , where x  X  is the target reconstruction. We will denote it by OR -ACLE . This is superior to picking a single closest language to be used for all word forms, but it is pos-sible for systems to perform better than the oracle since it has to return one of the observed word forms.
We performed the comparison against Oakes (2000) and Bouchard-C  X  ot  X  e et al. (2008) on the same dataset and experimental conditions as those used in the respective papers (see Table 2). Note that the setup of Bouchard-C  X  ot  X  e et al. (2008) provides super-vision (half of the Latin word forms are provided); all of the other comparisons are performed in a com-pletely unsupervised manner.

The PMJ dataset was compiled by Nothofer (1975), who also reconstructed the corresponding protolanguage. Since PRAGUE is not guaranteed to return a reconstruction for each cognate set, only 55 word forms could be directly compared to our sys-tem. We restricted comparison to this subset of the data. This favors PRAGUE since the system only pro-poses a reconstruction when it is certain. Still, our system outperformed PRAGUE , with an average dis-tance of 1.60 compared to 2.02 for PRAGUE . The difference is marginally significant, p = 0 . 06 , partly due to the small number of word forms involved.
We also exceeded the performance of BCLKG on the Romance dataset. Our system X  X  reconstruction had an edit distance of 3.02 to the truth against 3.10 for BCLKG . However, this difference was not signifi-cant ( p = 0 . 15 ). We think this is because of the high level of noise in the data (the Romance dataset is the only dataset we consider that was automatically con-structed rather than curated by linguists). A second factor contributing to this small difference may be that the the experimental setup of BCLKG used very few languages, while the performance of our system improves markedly with more languages.
We conducted another experiment to verify this by running both systems in larger trees. Because the Romance dataset had only three modern languages transcribed in IPA, we used the Austronesian dataset to perform the test. The results were all significant in this setup: while our method went from an edit dis-tance of 2.01 to 1.79 in the 4-to-8 languages exper-iment described in Section 5.1, BCLKG went from 3.30 to 3.38. This suggests that more languages can actually hurt systems that do not support parameter sharing.
 Since we have shown evidence that PRAGUE and BCLKG do not scale well to large datasets, we also compared against ORACLE and CENTROID in a large-scale setting. Specifically, we compare to the experimental setup on 64 modern languages used to reconstruct POc described before. Encouragingly, while the system X  X  average distance (1.49) does not attain that of the ORACLE (1.13), we significantly outperform the CENTROID baseline (1.79). 5.3 Incorporating prior linguistic knowledge The model also supports the addition of prior lin-guistic knowledge. This takes the form of feature templates with more internal structure. We per-formed experiments with an additional feature tem-plate: STRUCT-FAITHFULNESS is a structured version of FAITHFULNESS , replacing x and y with their natu-ral classes N  X  ( x ) and N  X  ( y ) where  X  indexes types of classes, ranging over { manner, place, phonation, isOral, isCentral, height, backness, roundedness } . This feature set is reminiscent of the featurized rep-resentation of Kondrak (2000).

We compared the performance of the system with and without STRUCT -FAITHFULNESS to check if the algorithm can recover the structure of natural classes in an unsupervised fashion. We found that with 2 or 4 observed languages, FAITHFULNESS under-trees, the difference was not significant. FAITH -FULNESS even slightly outperformed its structured cousin with 16 observed languages. By enriching our model to include important fea-tures like markedness, and by scaling up to much larger data sets than were previously possible, we obtained substantial improvements in reconstruc-tion quality, giving the best results on past data sets. While many more complex phenomena are still unmodeled, from reduplication to borrowing to chained sound shifts, the current approach signifi-cantly increases the power, accuracy, and efficiency of automatic reconstruction.
 We would like to thank Anna Rafferty and our re-viewers for their comments. This work was sup-ported by a NSERC fellowship to the first author and NSF grant number BCS-0631518 to the second au-thor.
