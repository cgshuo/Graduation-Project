 1. Introduction
The Business Process Execution Language (WS-BPEL [1]) is the current standard language for Web service composition. Its design is centered around the notion of business process used as glue between interacting services. Following the recursive nature of software composition [2], services are composed into processes, which themselves can be consumed as services.
From a syntactical perspective, the service abstraction assumed by BPEL is the one provided by the Web service description language (WSDL). WSDL-based services expose a set of operations using two interaction patterns: synchronous invocation through remote procedure calls, and asynchronous interactions via messaging. These two patterns are directly reflected in the composition mechanisms supported by the BPEL language.

Recently, a different kind of service abstraction (based on the REpresentational State Transfer  X  REST  X  architectural style [3]) has appeared, challenging the assumptions made by the BPEL language. This emerging technology involves a rediscovery of the original design principles of the World Wide Web [4] to provide a new abstraction for publishing information and giv-ing remote access to application systems: the resource. This abstraction provides the foundation for so-called RESTful Web services [5]. It can be directly mapped to the interaction primitives found in the HTTP standard protocol, making it easy to publish existing Web applications as services by  X  as a first approximation  X  replacing HTML pages with data payloads for-matted in  X  X  X lain old X  XML (POX) [6].

Since a very large number of service providers are switching to REST [7,8] in order to make it easier for clients to consume their Web service APIs and thus grow a larger user community, it becomes important to study how this wealth of new ser-vices [9] can be reused by means of composition. The composition of RESTful Web services is also often associated with so-called Web 2.0 Mashups [10,11] . Emerging Web 2.0 APIs have gained a large following, since they use REST to manage the complexity and reduce the effort of scraping data out of plain HTML Web pages [12]. They have become popular with the mashup building community, where these services and data sources are combined and reused in novel and unexpected ways [13].

Since most RESTful Web services are not described using the standard Web service description language (WSDL), it is not possible to reuse existing languages and tools that require the presence of WSDL interface contracts. A consensus still needs to be reached in terms of how to describe the interface of such RESTful Web services. Many specific description languages for RESTful Web services  X  e.g., the Web Application Description Language (WADL [14]), the Web Resource
Description Language (WRDL [15]), Norm X  X  Service Description Language (NSDL [16]), or simply the Web Description Lan-guage (WDL [17]), and others  X  have been proposed in the past few years. As we are going to show, it is also possible to use the new HTTP binding of the latest version of the Web service description language (WSDL 2.0). In practice, most existing APIs still rely on human-oriented documentation, which includes interactive examples to help developers learn how to use a particular service. For resources represented using XML, a schema definition is often referenced from the documentation.

This unclear situation makes it challenging to define a composition language for REST as it is currently not yet pos-sible to assume that a particular service description language will gain widespread acceptance. Thus, in this paper we do not rely upon the presence of a specific description language. Similar to the BPEL simplification presented in [18], our approach is independent from the chosen service description language. We propose BPEL extensions that directly map to the resource abstraction and natively support the corresponding interaction mechanisms and invocation pat-terns [19].

In this paper, we assess how this new RESTful Web service abstraction impacts the assumptions made during the design of the BPEL language. For example, REST requires clients to interact with many resources identified by URIs [20]. BPEL in-stead assumes to interact with services bound to a few fixed communication endpoints. Thus, it does not handle well the we identify the need for research on novel composition languages better tailored to support the specific properties and con-straints of the REST architectural style [21,22] .

Considering the differences between the two styles [23,24] , another contribution of this paper is to show that pro-cess-based composition languages can be applied to compose RESTful Web services in addition to  X  X  X raditional X  WSDL-based ones. This is important, as we claim that native support for composing RESTful Web services has become a requirement that modern service composition languages can no longer ignore. Still, it is also important to keep the exist-ing support for composing WSDL-based services. The BPEL for REST extensions we introduce enable processes to natively invoke RESTful Web service APIs and to publish a view over their execution state through a RESTful Web service inter-existing ones (R and S).

The rest of this paper is structured as follows: The motivation for our work is presented in Section 2. We continue in Sec-tion 3 giving some background on RESTful Web services and outlining the challenges involved in composing this novel kind of services. In Section 4, we introduce the extensions to the BPEL language. The design of a BPEL for REST engine reference architecture is outlined in Section 5. An example of how to apply BPEL for REST to an electronic commerce scenario is de-source and the process abstractions more in depth. Related work is presented in Section 8, before the paper is concluded in Section 9.
 2. Motivation
A first motivation for the research presented in this paper can be found reading the specification of the WS-BPEL 2.0 stan-dard, clearly stating one of the most important design decisions of the language [1, Section 3] :
The WS-BPEL process model is layered on top of the service model defined by WSDL 1.1. [ ... ] Both the process and its partners are exposed as WSDL services.

This choice introduces a tight coupling between the BPEL and the WSDL languages. More in detail, BPEL uses the partner link type construct to tie together pairs of matching WSDL port types . Thus, all incoming and outgoing interactions of a process with external services must go through a WSDL interface. Whereas this originally was seen as a promising approach to effec-tively deal with the heterogeneity of the services to be composed, over time this constraint has spawned a set of extensions to the BPEL language. For example, BPEL-SPE [25] for processes invoking other sub-processes, BPEL4People [26] for interac-tion with human operators, or  X  more recently  X  BPEL-DT [27] for data intensive applications; BPEL4Chor [28] for modeling choreographies and their participants; BPEL4JOB [29] with fault handling extensions and the added support for job submis-three new BPEL activities for invoking stateful WSRF-based Grid services. Finally, BPEL decouple the two languages in the context of message-oriented interactions. Along the same direction, in this paper we pro-pose yet another extension to make BPEL natively support the composition of RESTful Web services.

Existing efforts towards enabling the composition of RESTful Web services with plain BPEL without extensions revolve around the new WSDL 2.0 HTTP binding. To argue against this approach, we could use the argument that WS-BPEL 2.0 does not (yet) support WSDL 2.0, but instead it has been designed targeting its predecessor WSDL 1.1. Ignoring the differences between WSDL 1.1 and 2.0, Fig. 2 a shows that it would be possible to wrap a RESTful Web service behind a WSDL document using the newly introduced HTTP binding [31]. This binding enables the BPEL process to send and receive data over the HTTP protocol without using the SOAP message format. Thus, it would appear that the problem of composing RESTful Web services with BPEL has already been solved, at least concerning the support for their invocation. Nevertheless, this solution is not satisfactory.

From a theoretical perspective, this approach hides the resource abstraction and the corresponding RESTful interaction primitives behind a service-oriented abstraction. As we are going to discuss, the composition mechanisms (i.e., synchronous and asynchronous message exchange) provided by WSDL do not match the semantics of a  X  X  X ET X ,  X  X  X UT X ,  X  X  X OST X , or  X  X  X ELETE X  used to invoke a service and native support for publishing the state of BPEL processes as resources from a process would be beneficial ( Fig. 2 b).

In practice, WSDL 2.0 is not yet widely deployed, especially to describe existing RESTful Web services, and there is very little evidence that this will change in the future. Thus, the burden of recreating a WSDL description wrapping the RESTful
Web service is shifted from the service provider to the BPEL developer [35]. Whenever the underlying RESTful Web service is updated, all clients must update their copy of the corresponding WSDL document. This contradicts existing best practices suggesting that the contract describing a service interface should be maintained by the service provider and not by the con-sumers of a service. 3. Composing RESTful Web services
In this section, we present the design principles and constraints of the REST architectural style [3] and introduce the no-tion of composite RESTful Web service. For each principle, we discuss how it challenges the standard BPEL composition lan-guage. To address these challenges we have designed the language extensions presented in the rest of the paper. More information on REST and Resource-oriented architectures can be found in [4,5,32,36,37,23] .
 Resource addressing through URI  X  The interface of a RESTful Web service consists of a set of resources, identified by
URIs. URIs give a unique address identifier to make specific resources globally accessible [20]. To invoke a RESTful Web service clients need to be able to interact with a variable set of URIs, which are not always known in advance and may require some form of dynamic discovery. Thus, late binding plays a major role in RESTful Web service composition and BPEL for REST should support the dynamic binding to URI addresses that become known only at run-time. Providers of for REST should support the specification of how the state of arbitrary resources may evolve so that processes can be used to implement the state transition logic of composite resources [38].

Uniform interface  X  Once a resource has been identified, the set of operations that can be applied to it is fixed by design to the same four methods (or verbs): PUT, GET, POST, and DELETE. These CRUD-like operations apply to all resources with similar semantics, even if in some cases not every operation can be meaningful. Each of these methods is invoked on a resource using a synchronous HTTP request X  X esponse interaction round.

Self-descriptive messages  X  Services provide multiple representations for a given resource so that clients can negotiate to use the most suitable format and encoding of the information. This valuable flexibility makes it difficult to statically determine the actual data type of a given HTTP response payload. In some cases, also the assumption of dealing with XML data [39] may not hold when accessing resources represented in other, more lightweight, formats such as the Java-
Script Object Notation (JSON [40]). Thus, the assumption that BPEL variables may only contain SOAP message payloads or, in general, XML data, may no longer apply when using them to store resource representations. Also, it should be possible to serve the state of a composite resource  X  implemented using a BPEL process  X  represented using alternative formats, adapted to the context of each client.In addition to content-type negotiation, REST uses meta-data to control many prop-erties of the interaction, such as client and server authentication, access control, data compression, and caching. Thus, it should not only be possible to specify from a BPEL process the method and the URI of an HTTP request, but also to control the meta-data associated with it. Programmatic access to the HTTP request and response headers is therefore a require-ment for the BPEL for REST extensions.

Hypermedia as the engine of application state  X  Whereas every interaction is kept stateless using self-contained of the interaction can be embedded in the representation of a resource as hyperlinks. These are dynamically discovered and followed interactively by clients that are guided by the RESTful Web service along a correct interaction path. From this principle, it follows that resource URIs may be dynamically generated by a service and embedded into resource rep-resentations. Thus, BPEL for REST should provide a mechanism for processes to generate new resource URIs and to send these back to their clients. Also, the language should enable processes to extract URIs from response messages and pro-vide constructs for performing the late binding of invocation activities to dynamically discovered target resource URIs. 4. BPEL for REST extensions
The extensions to BPEL for composing RESTful Web services are of three different kinds. First, BPEL processes should per-form a direct invocation of RESTful Web service. Second, a view of the execution state of a BPEL process should be published as a resource. Third, the execution semantics of some BPEL constructs needs to be revised to fit with the REST design prin-related to the REST design principles. 4.1. Invoking RESTful Web services
To invoke a RESTful Web service from a BPEL process, we propose to add the following four activities: &lt; &lt; put &gt;, &lt; delete &gt;.

As summarized in Fig. 3 , the four activities use the uri can be a constant value, but also be computed out of data stored in the process variables. This way, parameter values can be interpolated into the URI for GET requests. Additionally, a variable may store the complete target URI to be invoked. With this simple extension, BPEL for REST supports dynamic late binding to invoke resource URIs that are only known at runtime. The only constraint on the URI is that it should address a resource using the HTTP or the HTTPS schemes.
Following the convention of the existing BPEL &lt; invoke in variables that are referenced from the corresponding request activities, there is no request payload as these REST primitives operate on the resource URI only. For &lt; the response attribute is optional, as some services may return an empty payload when invoked using these two methods. Only the &lt; post &gt; activity requires both request and response attributes to be set.

The meta-data sent with the HTTP request headers can be specified using the &lt; tional response _ headers attribute.

Similar to standard BPEL &lt; invoke &gt; activities, also &lt; managed by the BPEL engine and do not raise a fault. However, if necessary they may also be handled using the construct. If a variable to store the response headers is specified in the to store the status code of the response, listed among the header fields with the name fault handler. 4.2. Publishing processes as RESTful Web services
To declaratively publish resources from a BPEL process we introduce the &lt; construct allows processes to dynamically publish resources to clients depending on whether their declarations are reached by the execution of the BPEL process. Once the control flow of a process reaches the &lt;
URI is published and clients may start issuing requests to it. Once execution leaves the top-most elements in a BPEL process never go out of scope. They become visible to clients as soon as the BPEL process is deployed for execution. Resource declarations can be nested. The URI of nested resources is computed by concatenating their uri attribute with the usual path ( / ) separator.

Like the BPEL &lt; scope &gt;, a &lt; resource &gt; may contain a set of &lt; source found at a given uri . These state variables are only accessible from the BPEL code found within the resource declaration.

Similar to the BPEL &lt; pick &gt; construct, the &lt; resource cess receives the corresponding HTTP request. As opposed to &lt; handlers, the request handlers found within a &lt; resource are: &lt; onGet &gt;, &lt; onPost &gt;, &lt; onPut &gt;, and &lt; resource using such verb should be implicitly answered by the BPEL engine with HTTP status code 405 (Method not allowed).
At least one request handler must be included in a resource declaration and a handler for a given method may appear at most once.

Another difference with &lt; pick &gt; is that there is no limit on the number of times one such handler may be concurrently parallel a GET request on a resource declared from within the process, the execution of the corresponding handler will not be serialized and should be repeated for each request. To ensure that GET requests on a resource are indeed safe , the onGet request handler has read-only access to the state variables of the corresponding resource. As we have pre-viously discussed, only POST requests are not meant to be idempotent . Only the &lt; access to the resource state variables should be guaranteed.

The behavior of the process within a request handler can be specified using the normal BPEL structured activities (i.e., &lt; sequence &gt;, &lt; if &gt;, &lt; flow &gt;, &lt; while &gt;, etc.). However, control-flow are not supported.

To access the data sent by clients with the request payload, a pre-defined variable called $ in the scope of the request handler. Likewise, a variable called $ quest headers.

Results can be sent back to clients using the BPEL for REST &lt; headers can be set using the same header construct introduced for the previously described RESTful invocation extensions. inlining a reference to the $ variable in the body of the element). Whereas at least one ents over the same HTTP connection multiple data items as they are computed by the BPEL process). In this case, only the first respond element should specify the HTTP code and the headers of the response. The following ones, should only con-tain the payload to be appended. The connection with the client will be closed after the last respond activity does not need to be placed at the end of the request handler, as the handler execution may continue even after the final response has been sent to the client. 4.3. Minor BPEL extensions and changes
To complete the support for composing RESTful Web services, in this section we discuss a few minor extensions and small to identify processes that make use of them as specified in [1, Section 5.1] .
 cution moves out of their declaration scope, exit has only an effect on the state of the top-level resources, which would otherwise remain accessible to clients even after the normal execution of the process has completed.
Given the absence of an explicitly defined interface description for RESTful Web services, and the lack of strong typing constraints on the data to be exchanged, BPEL for REST is a dynamically typed language. Thus, static typing of &lt; declarations becomes optional [1, SA025] . The attribute messageType while the type or element attributes may still be used in the presence of an XML schema description for the RESTful
Web service. 5. Reference architecture
In this section, we discuss the impact of the proposed BPEL for REST extensions on the architecture of a BPEL engine. The extensions can be integrated into existing BPEL execution engines using available extensibility mechanisms.
RESTful service down to an HTTP request X  X esponse interaction bound to the specified URI of the remote service provider.
Concerning the management of the state of a composite resource, the proposed extension can be implemented reusing existing state management mechanisms already present in any BPEL engine, because the state of a composite resource is stored using standard BPEL variables. The publishing of composite resources and their URIs can be managed with a serv-let-like mechanism deployed together with the BPEL engine in the corresponding application server container. The servlet devoted to resource publishing in the front-end of the engine handles HTTP requests from clients by routing them to the requests with the corresponding process instance as well as the transfer of the data computed in a process request handler back to the client waiting for the response. 6. Example
After having introduced the BPEL for REST extensions and presented how they can be implemented, in this section we show how the extensions can be applied in practice to compose RESTful Web services in the context of the e-Commerce sce-nario illustrated in Fig. 7 .

The scenario involves the collaboration between a shop service, several product catalog services, a payment service, and a shipping service. Clients can browse product catalogs and request price quotes. If they agree with the offered quotes, they forward them to the shop service to place an order. Once an order has been created, clients may add or remove line items from it and check the total value of the order computed by the shop service (which may offer additional discounts). Clients may confirm an order by uploading the associated payment information. Once an order has been confirmed it can no longer be modified by clients. The shipping service periodically polls the shop service for confirmed orders, gathers their corre-through the shop service and may also cancel an order as long as it has not yet been shipped. The shop should refund the payment if the canceled order was already confirmed.

Each service exposes a RESTful API, featuring the resources and the methods listed in Table 1 . The table defines the semantics of each method applied to each resource with the given parameters. In the following we give a more detailed description of how the services interact. This interaction can be implemented using the BPEL for REST code for the shop ser-vice found in the Appendix .

New orders are created using POST/order and are assigned a unique oid . This is used by clients to retrieve infor-mation about them, i.e., the list of ordered items ( GET/order/item amount ). To order specific items, clients may use a POST/order/item tained from the product catalog service. The shop service will retrieve the corresponding information (the product, the price, and the ordered quantity) and store the item  X  identified with a unique iid  X  as part of the state of the order. Clients can remove ordered items using a DELETE/order/item with the payment information ( POST/order/payment ), the shop service contacts the payment service to charge the order X  X  amount to the customer (also with a POST/payment for the particular order). If this interaction succeeds, the order becomes confirmed. Its items can no longer be mod-ified by clients and the shipping service can proceed with the shipment. To do so, the shipper service periodically performs a GET /order/confirmed request to download the confirmed orders from the shop service and handle their shipment. Once an order has been shipped, its state is updated with a the shipping service. Clients may cancel their orders as long as they have not yet been shipped. Canceling a con-firmed order will cause the shop service to send a DELETE/payment the amount charged to the customer.

The order resource published by the shop service follows the state machine shown in Fig. 8 . State transitions are triggered by specific requests from clients of the shop service. This state machine can be implemented with a BPEL process that uses and language constructs referring to the code found in the Appendix .

Lines 1 X 9 declare the state variables of a purchase order managed by the shop service BPEL process. These are: oid , the shipment tracking information (set by the shipping service); amount , the total value of the order.
The POST handler starting on line 1 initializes a new order resource by first checking the validity of the submitted cus-tomer information. Once the state of the resource has been initialized with the &lt; following respond activity informs the client of the oid of the newly created order resource. Invalid requests are answered with HTTP status code 400 (Bad Request).
 be ordered. To do so, the process publishes the /item resource and declares its state variables (lines 35 X 39). The following
POST request handler, receives a product quote URL from the customer and uses it to GET the corresponding product infor-state can transition to  X  X  X eady X  (line 50).

Lines 61 X 79 show the GET request handler for the item resource. Depending on whether the iid referring to a specific requested item cannot be found, a 404 status code is returned.

The POST request handler for the /order/payment is found on lines 107 X 135. It first computes the amount to be paid from the list of items associated with the order. Then it forwards the payment information received from the client to the payment service (line 115). It uses the catch construct to detect whether the payment has been successful. In this case, it updates the order X  X  state to  X  X  X onfirmed X  and notifies the client about it (lines 117 X 127). The following instead is used to forward to the client the erroneous response returned by the payment service. Once the payment has been completed successfully, the process exits the loop on line 137, publishing the the /order/payment and the other resources declared within the loop X  X  scope. Thus, it is no longer possible to modify the line items of a confirmed order and once an order becomes confirmed, the shipping service can update it with the shipment tracking information, as shown in the PUT request handler in lines 140 X 150.

The GET request handler for the /order/amount is implemented twice, depending on the state of the order. Lines 94 X  103 show that  X  as long as the order can be modified by clients  X  the amount must be computed from the line items infor-mation before it can be returned. Once the state of the order changes to  X  X  X onfirmed X , the requested amount can be directly returned by reading the cached value in the amount variable (lines 154 X 158).

Finally, lines 165 X 200 implement the order cancellation state transition triggered by a DELETE request on the shipped order (line 167). The refund of the payment is implemented in lines 171 X 187, where a DELETE successfully refund the payment. 7. Discussion
The main design decision of the BPEL for REST extensions is to enable developers to compose services at the level of abstraction defined by REST. Thus, the language is extended with activities that reflect the RESTful interaction primitives and give direct support for composition of resources. In this context, it is important to discuss the relationship between the concept of business process and the resource abstraction.

With BPEL for REST, the resource construct enables a process to declaratively publish an arbitrary set of resources. Also, the state transition logic of a specific resource can be realized using a business process, which defines under which condi-tions the resource should change state and how it should react to client requests. Thus, as we have shown in the example, using BPEL for REST is possible to define a relationship between the state of a BPEL process instance and the state of its resources.

The lifecycle of a BPEL process instance begins with the receipt of a message triggering the execution of an instantiating tive. During execution, all messages exchanged are correlated with a particular process instance based on their content and on the correlation sets declared in the process. Execution of a process instance proceeds until it reaches an cution has completed.
 may read its current state using GET requests, update its state using PUT requests, and discard it using DELETE requests.
BPEL for REST does not impose any constraint on whether resources are instantiated as part of the process execution or whether new process instances are created upon a particular request to a published resource. Both approaches are sup-code is deployed for execution, no matter whether a process instance has yet been started. If a resource is declared from scope. By introducing this distinction between top-level and local resource declarations, BPEL for REST supports a pure re-form interface and can be instantiated multiple times. Nevertheless, BPEL processes can also be instantiated using standard Web service.

In BPEL for REST, the state of a resource is manipulated using its attached request handlers. A new resource instance is created by initializing the resource state variables from within the &lt; ents identify a specific resource instance, in the simplest case, an HTTP Cookie can be automatically generated by the
BPEL engine handling PUT requests. The engine may intercept responses carrying the HTTP status code 201 (Created) and add the cookie with a unique identifier. Clients will send the cookie for all future interactions (e.g., GET, PUT, and DELETE) with the resource URI and the engine will use the cookie to correlate the requests with the correct state of the resource instance.

As proposed in [38], a cookie-free solution based on URI rewriting that involves the template-based generation of re-source identifiers is also possible. This would work as follows: given a top-level URI resource (e.g., is answered with a 201 (Created) status code, the engine emits a instance URI /order/i . Nested resource URIs are still constructed by concatenating their also interleave the resource instance identifier. A GET request to the original resource URI all active resource instances published by the active processes.

Similar to how HTTP sessions management is transparently supported by most existing Web development languages and infrastructures, the choice between these (or other) request correlation mechanisms should not affect the design of the lan-guage. This way, the most suitable correlation mechanism can be chosen when a process is deployed for execution. 8. Related work This paper builds upon many research contributions within the area of Web service composition languages [41,42] .
One of the first proposals for using BPEL to model the internal state of resources can be found in [38]. To do so, BPEL scopes are used to represent different states of a resource and POST requests trigger the transition between different scopes. GET, PUT, and DELETE are mapped to &lt; onMessage the BPEL variables declared within the currently active scope. The XPath language embedded in BPEL is extended with functions to compute URI addresses. Unlike the extensions presented in this paper, the resulting  X  X  X esource-oriented X  BPEL does not support the invocation and the composition of external RESTful Web services, but only the publishing of a BPEL process as a resource (or, more precisely, the implementation of a resource state transition logic using BPEL).
 Using a RESTful API for a workflow engine to publish the execution state of workflow instances has been proposed by [43]. (SWAP [45]), originally proposed by the Workflow Management Coalition (WfMC) in 1998. More recently, the idea of map-ping the state of a workflow instance to a  X  X  X esource X -like abstraction, as defined by the WS-Resource Framework has been explored in [46].
 BPEL light [18] advocates to decouple BPEL from WSDL by identifying the BPEL activities that are closely dependent on
WSDL abstractions and subsuming them with a generic messaging construct (the &lt; composition of RESTful Web services.

Bite [47] (or the IBM Project Zero assembly flow language) can be seen as a simplified variant of BPEL with a reduced set of activities specifically targeting the development of collaborative Web application workflows [48]. Similar to BPEL for REST, the language supports the invocation of RESTful Web services and the corresponding runtime allows to automatically pub-action primitives, as those are abstracted in one &lt; invoke clients may access their state under different representations in compliance with the REST uniform interface principle (e.g., the PUT verb is not supported).
 From a practical standpoint, ad-hoc support for invoking RESTful Web services is currently being discussed for some
BPEL engines and development environments [35]. Within the Apache Orchestration Director Engine (ODE) project, a pro-posal for RESTful BPEL extension has been recently published. store the required metadata and bindings to URIs. The ability of publishing resources is provided through extensions of the &lt; support for REST. Existing BPEL &lt; invoke &gt; and &lt; engine to transform external REST interactions so that they can be handled from existing BPEL constructs [49]. This way  X  for example  X  existing BPEL processes can be deployed to be started with a GET request issued from a Web browser. BPEL interact with traditional WSDL-based services. Thus, developers of BPEL processes can work at a level of abstraction more suitable to resource composition. 9. Conclusion
As REST gains traction and the number of published RESTful Web service APIs grows, it becomes important to under-stand how the concept of business process can be applied as the glue to compose  X  X  X esources X  in addition to traditional  X  X  X ervices X . In this paper, we have proposed an extension to the WS-BPEL standard process modeling language to support the native composition of RESTful Web services. The extensions promote the resource abstraction to become a first-class language construct. This way, the interaction primitives (GET, POST, PUT, and DELETE) stemming from the REST uniform interface principle can be directly used from within a BPEL process as new service invocation activities. A RESTful Web service APIs can also be implemented using BPEL with the proposed declarative constructs for publishing resources as a view over the process variables. With a detailed example, we have applied the proposed extensions to an e-Commerce scenario, showing how BPEL for REST can be used in practice to specify the behavior of a composite resource. A description of the design of a reference architecture to implement the proposed extensions on top of a generic BPEL engine is also included.
 Acknowledgements This work is partially supported by the EU-IST-FP7-215605 (RESERVOIR) project. The author would also like to thank
Monica Frisoni, Domenico Bianculli, Tammo van Lessen, and the anonymous reviewers of the BPM2008 Conference for their invaluable comments.
 Appendix. Sample code
The following code gives the BPEL for REST implementation of the example scenario described in Section 6. To enhance the readability of the XML code, we highlight the BPEL for REST extension activities in with the rest XML namespace corresponding to the extension. Also, to save space we have taken some liberty with the syn-interpolation is indicated by prefixing the name of variables with the $ sign.
References
