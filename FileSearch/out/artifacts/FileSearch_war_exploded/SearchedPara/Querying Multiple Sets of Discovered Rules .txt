
Rule mining is an important data mining task that has been applied to numerous real-world applications. Often a rule mining system generates a large number of rules and only a small subset of them is really useful in applications. Although there exist some systems allowing the user to query the discovered rules, they are less suitable for complex ad hoc querying of multiple data mining rulebases to retrieve interesting rules. In this paper, we propose a new powerful rule query language Rule-QL for querying multiple rulebases that is modeled after SQL and has rigorous theoretical foundations of a rule-based calculus. In particular, we first propose a/ule-based calculus RC based on the first-order logic, and then present the language Rule-QL that is at least as expressive as the safe fragment of RC. We also propose a number of efficient query evaluation techniques for Rule-QL and test them experimentally on some representative queries to demonstrate the feasibility of Rule-QL. 
Data mining queries, rulebases, association rules, query languages, query evaluation. 
Rule mining is one of the central tasks of data mining. Rules can be utilized to gain a better understanding of the application domain, and to take actions to one's advantage. However, the number of rules generated from a dataset by some of the rule mining algorithms is often very large, in thousands or tens of thousands [4,13,15,16,17,20,21,24]. Making sense of such a large number of rules presents a significant challenge. Past research has shown that most of the rules are actually not useful or interesting for specific applications [ 15,16,17,20,21,24]. 
To help the user find interesting rules from a set of discovered rules, several methods have been proposed. One of them is data mining queries [ 10,14,15,18,23,28], which allow the user to focus asking appropriate queries. Although there have been several proposals reported in the literature on how to define data mining queries, all of them have one common basis: they use first-order logic to let the user specify what kinds of rules the querying system should retrieve from the rulebase of discovered rules. not made or distributed for profit or commercial advantage and that requires prior specific permission and/or a fee. SIGKDD '02, July 23-26, 2002, Edmonton, Alberta, Canada. Copyright 2002 ACM 1-58113-567-X/02/0007...$5.00. 
However, as will be discussed in Section 2, all authors focus on querying a single rulebase at a time and therefore restrict their query languages to particular fragments of first-order logic. It is important to expand previously proposed data mining query languages to the fu//set of first-order logic expressions operating on multiple rulebases because many practically important data mining queries naturally require multiple rulebases or at least a join of a rulebase with itself. Some examples of such queries are:  X  In a rulebase of newly discovered rules, find exceptions (unexpected refinements [20,25]) for the set of previously discovered rules (stored in a separate rulebase).  X  Find minimal rules in a rulebase. A minimal rule is a most general rule: its left-hand-side (LHS) and right-hand-side (RHS) do not contain the left-hand-side and the right-hand-side of any other rule in the rulebase respectively. Although this query operates on a single rulebase, it requires a join of the rulebase to itself, as will be shown later.  X  Find rules that were stable over the last 6 months, assuming that the mined rules for each month are stored in a separate rulebase. This type of queries is important as data mining is increasingly used in the production mode. In such situations, the user often wants to see the changing behavior of the rules over a number of time periods [17]. Stable rules are those rules whose confidences and/or supports do not change significantly over time. Similarly, it is also useful to find rules whose confidences and/or supports are "growing" or "diminishing" over time, as they may indicate trends. In this paper, we propose a more powerful rule query language 
Rule-QL that allows the user to query multiple rulebases. Each rulebase typically contains rules mined from a different dataset. first-order logic', (FOL) expressions. To ground Rule-QL in a sound theory, we first introduce a logic-based calculus RC defined of RC expressions. Then we introduce Rule-QL that is at least as expressive as the safe fragment of RC. We also introduce additional constructs in Rule-QL to increase its expressive power and make it more useful as SQL is more expressive than relational calculi. We also study processing of Rule-QL queries and present efficient query processing methods. We tested these methods on a number of typical queries and report the performance results that clearly indicate the feasibility of Rule-QL. 
Chicago, liub@cs.uic.edu. constructs that go beyond the scope of this paper. on a theoretically sound rule-based calculus RC supporting queries on multiple rulebases. 
QL. presentation of performance results. 
Like templates, MSQL's query conditions can be checked using the information contained in each rule itself, e.g., support, confidence, rule length, items in LHS/RHS. That is, condition checking on each rule is independent of other rules. Furthermore, it can only operate on one rulebase at a time. In contrast to 
MSQL, Rule-QL operates on multiple rulebases at a time and can also support queries expressing inter-relationships of rules. 
In [3], Agrawal et al reported a language for querying shapes of history. The shapes of history refer to ups and downs of supports or confidences of a rule over a number of time periods. This language enables one to define the behavior shapes of the rules that s/he is interested in. For example, one may want to find rules whose support increases in one time period and then falls down. 
This is different from our work, as [3] presents not a general query language for rules, but only for shapes. It is related to our work as we also allow querying rulebases mined from different time periods. Moreover, we introduce statistical procedures to find various statistically interesting rules. Only using ups and downs to express the change of a rule lacks statistical foundation. relational database. The purpose is to retrieve rules containing a given subset of items in their LHS or RHS. Rule-QL is more expressive and more efficient as rules can be represented more naturally as sets (rather than relational tables), and a more suitable index of inverted lists can be used to access them. 
Another related research is the subjective and objective interestingness of data mining rules [4,12,16,17,20,21,24,25,29]. 
In subjective interestingness, [16,20,21,24,25] propose several methods for finding unexpected rules. These approaches first ask the user to specify his/her existing knowledge about the domain. 
The system then finds those unexpected rules by comparing the user's knowledge with the discovered rules. These methods are different from our query language. In fact, we will show that the task of finding unexpected rules can be formulated just as a query in Rule-QL. For objective interestingness, [12,26] present and review a number of methods for ranking rules according to different measures. Such operations can also be done in Rule-QL by issuing appropriate queries. 
In summary, there have been several excellent proposals made on how to query rulebases. However, nobody developed a data mining query language on multiple rulebases that supports a full set of first-order logic expressions. 
In this section we introduce a rule-based calculus RC that provides a theoretical basis for the rule query language Rule-QL presented in this paper. be specific, we assume that each rulebase contains association rules defined on some set of transactions T over the itemset I [2]. 
However, our approach is not limited to association rules and can also be applied to a broader set of rules. The vocabulary of the rule-based calculus RC is defined over  X  Rulebases Rt, R~ .... Rn.  X  A set of constants from the itemset I and a set of real numbers (to define restrictions on confidence and support). 
Rule-based variables rl, r2, ... (also called rule variables) defined over rulebases Rl, R~ .... Rn.  X  Functions LHS and RHS that map association rules into  X  Relational operators C,_.C.., ~, ~, and = defined on itemsets An atomic formula of RC has one of the following forms:  X  R(r), where R is a rulebase and r a rule-based variable. * a op 13, or a op const, where tt and 15 are functions LHS(r) or 
RHS(r), const is a set of items (e.g. {milk, bread}) and op is o y op 8 or Top const, where T and 8 are functions CONF(r) or relational operators &lt;, &gt;_, &gt;, &lt;, --. A set of well-formed formulae in RC is obtained from atomic formulae in a standard way as it is done in first-order logic by taking the closure of conjunction, disjunction, negation and universal and existential quantification operators. Safety of RC formulae is defined similarly to the safety of relational calculus formulae [1]. More specifically, we first define a safe-range normal form (SRNF) in the same way as [1] does. Then, SRNF formula in a very similar way with certain modifications pertaining to rulebases and rules. In particular, range restricted variables of a RC formula ~0 are defined recursively as rr(to) = 1. r, if ~0 is R(r), where R is a rulebase 2. r, if ~0 has LHS(r) = consh and RI-IS(r) = const2 where consh and const2 are sets of items 3. rr(.~) U r, if ~ =--~ A RHS(r) = LIRHS(s) A LHS(r) = 
LIRHS(t) 2 and s E rr(v ) A t ~ rr(v); rr(e ) otherwise. 4. rr(91 ) U rr(~o2), if~p = et A ~02 5. rr(~ol) ~ rr( X 2), if ~ =  X 1 V ~02 6. ~,if  X is-~. 7. rr(v)-rifq~ -=(3r) eandr E rr(~,); free variables of ~a.Finally, a RC query is defined as {r[  X }, where  X  is a safe RC formula having only one flee rule-based variable r. 
The semantics of formula  X  is defined in usual model-theoretic terms, where R1, R2, .... R, are interpreted as sets of (association) =, and functions LHS, RHS, CONF and SUP are interpreted in the standard way. The semantics of query {r I  X } is also defined as in the relational case, where we use rulebases instead of databases. 
Throughout this section, we emphasize similarities between the rule-based calculus RC and the classical tuple relational calculus. 
However, there are significant differences between the two languages. First of all, RC deals with rules and rulebases that 2 The notation LIRHS denotes "either LHS or RHS." constitute totally different concepts from relations. Secondly, RC supports several rule-specific constructs, such as functions LHS, RHS, CONF, SUP, and containment operators on itemsets, such as C,C, ~, ~, etc. Finally, as was pointed out in Section 2, RC significantly differs from previously proposed data mining query languages in that it supports multiple rulebases and the full set of FOL expressions over these rulebases. We would also like to point out that we introduced only the most basic constructs in RC trying to keep the language simple. Clearly, we could also add additional operators to the calculus, making it more expressive. For example, we could add functions SIZE_OF specifying the length of a rule, arithmetic operators over real numbers (in order to do arithmetic over confidences and supports of rules) and union and intersection operations over itemsets (and thus be able to express additional queries in RC). Instead of defining these constructs, we decided to keep the language RC simple and introduce some of these extra constructs in the query language Rule-QL that is based on RC. We next present some examples of RC queries. We assume that the rules are defined over the standard market basket rulebase (MB) over the items of groceries that is typically considered in the literature on association rules. Query 1: Find all the association rules referring to milk and cereal in the body (or LHS) and having confidence over 90%. This simple query can easily be expressed in the languages of [15,28]. However, the rest of the queries presented in this section cannot be expressed in these languages because they either operate on multiple rulebases or require quantification over some other rule-based variables, as is the case with the following query. Query 2: Find minimal association rules, i.e., the rules whose 
LHS and RHS cannot be reduced further. Query 3: Find all the rules from rulebase NEWRULES that are exceptions of some of the previously discovered rules 
OLDR ULES. Query 4: Find all the rules that were held over the last 3 months with confidence at least 60% (we assume that a separate rulebase MONTHi exists for each month i). 
One of the major features of calculus RC is that its queries are generally defined over multiple rulebases, as we can see in Queries 3 and 4. Therefore, RC is more expressive than previously introduced data mining query languages, such as templates and MSQL, that operate on a single rulebase. 
In this section, we take calculus RC as a theoretical foundation for the data mining query language Rule-QL. In particular, we 54 introduce a SQL-like syntax that can express all RCqueries and also add several additional operators and functions to the language in order to make Rule-QL more expressive and versatile. Some examples of these constructs are functions SIZE_OF, MAX, MIN, 
AVG and COUNT, clauses GROUP BY, HAVING and ORDER, and the operator UNION. In our presentation of Rule-QL, we start with a basic version of the language and then introduce more advanced features. The structure of a basic Rule-QL query is 
The FROM clause above specifies one or several rulebases R, Rl, are the rule variables defined over these rulebases. The SELECT clause selects one variable (over its corresponding rulebase R) that satisfies the conditions of the WHERE clause. In addition, optional function FUNCT specifies various aggregation operations over the resulting set of rules. Some examples of function FUNCT are  X  COUNT: counts the number of rules in the answer to a query.  X  AVG_CONF, AVG_SUP, AVG_SIZE: they determine the  X  MAX_SUP, MA,X~CONF, MAX_SIZE, MIN_SUP, 
Finally, the Conditional_Expression in the WHERE clause is defined as follows. A simple condition is defined as  X  LIRHS(r) op LIRHS(s) or LIRHS(r) op const, where LIRHS(r)  X  Rule_funct(r) rel_op const or Rule funct(r) rel_op  X  Item funct(1) rel_op const or Item_funct(1) rel_op  X  EXISTS (&lt;RuleQuery&gt;), where Rule_Query is an arbitrary  X  r [NOT] IN &lt;Rule_Query&gt;, where r is a rule and Rule_Query 
A complex Conditional_Expression is defined in terms of simple conditional expressions in the same way as it is done in SQL as a disjunction of conjunctive clauses that also support negations [5]. 
We next give some examples of the basic Rule-QL queries, starting with the queries introduced in Section 3. 
Query 1. Simple selection with a single rulebase and a single 
Query 2. Minimal rules: Find every rule from the set of mined We can also define maximal rules in Rule-QL in a similar way. 
Unlike a minimal rule that constitutes a most general rule in a mlebase, a maximal rule constitutes a most specific rule, i.e., its 
LHS and RHS are not contained in the LHS and the RHS of any other rule respectively. 
Query 3. Unexpected rules (exceptions): Given a set of mined 
Query 4. Strong rules over time: Find rules existing in all past 6 
Additional features of Rule-QL include support for statistical functions, the UNION operator, and support for GROUP BY, HAVING and ORDER clauses. We present these features now. 
Statistical functions: Rule-QL supports various statistical functions on confidences and supports of rules, including:  X  STABLE_RULES(r1 ..... rn): This fimction takes the rules rl 4. If an aggregation function is specified in the SELECT clause, This conceptual strategy is obviously very inefficient. We present a much more efficient query evaluation method in this section. However, by no means, we claim that the proposed techniques are the most efficient ones. We believe that subsequent work will produce more efficient Rule-QL query evaluation methods. Query evaluation algorithms need to retrieve rules from one or more rulehases. This can he achieved either by scanning (some) rulebases or accessing specific rules in the rulebases through indexes. We use the combination of both methods in Rule-QL. Below, we discuss the indexing schemes used in Rule-QL. In Rule-QL, we use two kinds of indexing, i.e., inverted lists and B+ trees. Inverted lists are used to index rules using their items, while B+ trees are used to index the supports and confidences of the rules. Below, we discuss the inverted lists indexing. B+ trees will not be described, as they are well known. Inverted lists: Inverted lists are a common indexing method used in text information retrieval [9,30], where each document is regarded as a set of keywords or items. This indexing was shown to be superior to many other indexing schemes for text retrieval [30]. They are very efficient for set-oriented operations and also items. Query operations in Rule-QL are mainly set-oriented. Thus, inverted lists are a suitable indexing technique for rules. Inverted lists indexing works as follows: Assume we have a set of rules R = {rl, r2, ..., rm}, and each rule has a unique identifier (ID). We can index the LHS and/or the RHS of the rules according to the needs. Inverted lists index [9] has two parts: a vocabulary, containing all the distinct items in the set of rules (LHS or RHS); and for each distinct item an (inverted) list storing the IDs of the rules containing the item. Queries are evaluated by fetching the inverted lists of the query items, and then processing them for various needs. For example, to search for the supersets (i.e., CONTAINED_IN) of a constant set {a, b, c} on the LHS of We now start query evaluation with the simple case where only a single rule variable appears in the WHERE clause (note that this implies that the query involves only a single rulebase). Moreover, we consider only conjunctive queries (conditions are connected by conjuncts in WHERE) 3. To illustrate our query evaluation strategy, consider the following single conjunctive query: This query can be evaluated in the following 3 ways: can be reduced to the union of conjunctive queries as in SQL [RG00]. 1. We can scan the entire Rulebase, check the conditions on each 2. We can utilize the inverted lists to access only those rules in 3. We can use B+ trees as indexes on the supports of the rules in Each query evaluation plan has its strengths and weaknesses depending on the size of the Rulebase, the corresponding indexes, and the nature of the expressions in the WHERE clause. Since methods (1) and (3) are straightforward, we will focus in the rest of the section on the second method that evaluates the CONTAINED EQ_IN predicates. Note that CONTAINED_IN, CONTAINS, CONTAINS_EQ and EQUAL are similar to CONTAINED_EQ_IN, and can be handled in the same way. The algorithm for evaluating expression S CONTAINED_EQ_IN LJRHS(r), where S is a constant itemset and LIRHS represents LHS or RHS of a rule, is presented in Figure 1. The algorithm the smallest set as the candidate answer set, AnswerSet (line I and 2). It then performs intersection simultaneously with the rest of some other optimizations can also be used [6]. For simplicity, we do not include them in the algorithm. 
Algorithm: findSuperSets(S, LIRHS, R) 
I Retrieve the LIRHS inverted lists of R for all items in S; 2 Sort all the retrieved lists by size; 3 AnswerSet ~-the smallest list (or se0; 5 sti ~-1, where i represents every retrieved list except the 4 for each element e a AnswerSet do 6 for every other list L~ in increasing order by size do 7 Perform a binary search for e in Li between st~ and 8 If e is not found then Remove e from AnswerSet end 9 st~ &lt;--the value of current location of the binary search 10 end 11 end A related expression is LIRI-IS(r) CONTAINED_EQ_IN S. This condition is more complex to process because we are unable to directly use the index on L[RHS of the rulebase, R. There are two options: (1) scan the rules in R and for each rule we check the LIRHS of the rules in R. Which option to take depends on the of S is small, and thus the number of subsets is not too large. If (of course, we need to generate all subsets of S). For each subset Si of S, we evaluate the expression LHS(r) EQUAL Si. The algorithm for handling LHS(r) EQUAL St (called findEqualSets) is similar to findSuperSets except that findEqualSets needs to check equality after the if-statement of line Remove e from AnswerSet end'. As we will see in Section 6, that IfB = O then there is no arc between rl and r2 are evaluated as follows: Casel: We use indexing to compute LIRHS(rl) EQUAL LIRHS(r2). The specific algorithm evaluates-tO is described below. We check the other conditions in B after each pair of rules are identified. Case2: We use indexing to compute LIRHS(rl) CONTAINED_IN LIRHS(r2 ) or LIRHS(rl) CONTAINED EQ_IN LIRHS(r2) and check the other conditions in B after each pair of rules from RI and R2 are found. The algorithms that evaluate this condition, evaluate---~ and evaluate4-, are described below. 
Case3: We use indexing on one condition, and check the rest. The algorithm, evaluate  X ::~, for evaluating this condition is also outlined below. In query evaluation, we first evaluate the unary conditions in the 
WHERE clause and then proceed to the evaluation of the binary conditions described in Cases 1-3 above. Below, we present our evaluation method using the graph. 
In general, query conditions involving two rule variables are analogous to join operations in relational databases. We also call them join operations. They are relatively expensive to evaluate. 
However, in many cases, we do not need full join of rulebases to evaluate Rule-QL queries. We show that an efficient evaluation method exists fur a special class of queries whose query graph forms a tree, if the direction of each edge is removed, with the selection variable (from the SELECT clause) being its root. The be ignored, as it does not affect the final answer. We believe that queries of this kind are the most common queries in practice. Figure 2 shows an example. Figure 2(a) is the original graph, and 
Figure 2(b) is the undirected graph after the direction of each edge is removed, rl is the selection variable. Note that each rule variable is also attached with its Rulebase (or its domain). (a). Original graph (b). Undirected graph Figure 3 presents the overall algorithm for evaluating a tree query. 
Each node of the tree has a set of rules associated with the node that initially comes from the rulebase associated with the rule variable for the node. We traverse all the nodes of the tree in the post-order and recalculate the sets of rules for each node based on the conditions B associated with the edges between the nodes. 
More specifically, starting from each leaf node N, we work upward using the edge between the parent node P of N and N. We assume that we have already evaluated the set of rules associated with node N and we now compute the set of rules for node P using the conditions B for the edge P-N. After the edge P-N is evaluated, it is deleted. If P does not have any child node, it becomes a leaf node, and it is handled in the same way upward. 
The process goes on until it reaches the root node and all the algorithm traverses the tree only once. 
Algorithm evaluateTreeO 2 while Q not empty do 3 select a node N from Q; /* N is not deleted from Q yet */ 4 ifNhas no child node then 5 if N has no parent node then /* Reached the root */ 6 Q6-Q-{N}; 7 else evaluateEdge(P-N); /* P is the only parent of N */ 8 Remove edge P-N; 9 Q6-Qu {P}; 10 end Algorithm: evaluate-~(LIRHS 1, P, LIRHS2, N) 
I AnswerSet ~ P; 2 for each rule r in P do 3 Retrieve the LIRHS2 inverted lists of rulebase N for all 4 Sort all the retrieved lists by size; 5 FOUND 6-false; 6 sti 6-I, where i represents every retrieved list except 7 for each element e in the smallest list do 8 for every other list Li in increasing order by size do 9 binary search for e in Li between sti and IL~I; 10 if e is found then FOUND 6-true 11 else remove e from AnswerSet; 12 FOUND 6-false; 13 st~ ~--the value of current location of the binary 14 end 15 if FOUND then exit for-loop end 16 end 17 end 
Figure 4: Find rules in P whose LIRHS has an LIRHS superset the rules in N and for each rule r it utilizes the procedure findSuperSets(LlRHS(r), LJRHS, P) to determine such supersets. We do not present algorithm evaluater-as it is a straightforward extension of the algorithm findSuperSets from Figure 1. One simple optimization tofindSuperSets, however, is to skip a rule in P (or R in Figure 1) if it is already in the answer set. If the direction of the edge in the original graph is P ~ N, the corresponding evaluation algorithm evaluate~ is very similar to algorithm evaluates presented in Figure 4 with one modification: is P  X :&gt; N, the procedure evaluate ~ can handle it similarly. It is easy to see that findSuperSets, findEqualSets and evaluate--&gt; are correct. We now state that our overall algorithm for evaluating a tree query in Figure 3 is correct. Theorem: The evaluateTree algorithm is correct. Proof: We only need to show that a tree with only two levels can produce the required result at the parent node. The figure below When a tree with multiple levels, the situation is the same, as the algorithm in Figure 3 works upward and deletes edges along the way. For the 2-level tree above, we process the edges one by one. Let remaining rules in P have corresponding rules in Nl that satisfy the conditions of edge P-Ni. We then process P-N2, which reduces the set of rules in P fimher. The remaining rules in P must now also satisfy the conditions of edge P-N2. Since we only reduce the size of P but not Nl, the remaining rules in P still meet the conditions of P-N~. This goes on until we finish P-N~. Clearly, after P-Nk, all the remaining rules in P satisfy the conditions associated with P-Nb ..., and P-Nk. It is important to note that not all the edges are evaluated, but that does not matter because none of them is our selection-variable. Only P is a possible selection variable. After the set of rules in P are decided, we can work upward in the same fashion if P is not the root to obtain the correct answer at the root. We now discuss why the overall algorithm in Figure 3 is efficient. If we do not start from edges connected to leaf nodes and work upward, but from other edges, we may need to evaluate each edge multiple times. For example, in Figure 2(b), if we first work on the edge rl-r2 and then on edge r2-r4, we reduce the rules in r2 and r4. However, some of the rules in rl may not be valid any more because the effect ofr2-r4 evaluation needs to be propagated to all related edges. Thus, we need to evaluate rl-r2 again. In general, the propagation effect can be very serious, which results in the same edge being evaluated multiple times. In contrast, if we traverse the tree in post-order, we do not need to re-visit any edges as after being processed, the low-level nodes do not affect the final results at the root. We now turn to the general case when the query graph contains cycles. In such cases, we can handle those sub-graphs that are trees in the same way, and those edges in the cycles using traditional join operations. Figure 5 shows an example graph (rl is SELECT r 1 FROM M1 rl, M2 r2, M3 r3, M4 r4, M5 r5, M6 r6 WHERE LHS(rl) EQUAL LHS(r2) AND rl r2 r3~ ) ) ~ ~ r4 r5 r6 query serves as a stress test of Rule-QL as it involves 6 rulebases and a large number of itemset comparison operations. Note that the STABLERULES predicate in Query 5 is implemented using the Chi-square test [7] in our system. The execution times of these queries are presented in Figure 7. Each execution time is the average result of 10 runs of the query, and includes the time for reading in rulebase(s) and the time for building appropriate indices (mainly inverted lists). Also, we kept the indices in the main memory. This is reasonable with modem computers, as the number of mined rules is usually moderately large compared with the number of tuples in a relational database. Our experiments were carried on a Pentium III 800 PC with 500MB of memory. For each query, we vary the number of rules in each rulebase from 10,000 to 100,000 (10k-100k). All the rules are mined from a dataset generated using the IBM data generator [2], which is commonly used in evaluating association rule mining algorithms. For our experiments, we first generate a large number of rules using a low minimum support. For each individual experiment we randomly select some rules to obtain the required number of rules for the experiment. 10 Figure 7: Execution times (in see.) of the 5 representative queries 
We next discuss how each query is evaluated and the results of our experiments. 
Query 1. This query is evaluated using the algorithm in Figure 1 with additional checks on support, confidence and rule LHS size. From Figure 7, we observe that this query can be executed extremely efficiently. 
Query 2. This query involves heavier computation than the first one due to the nested query. Each nested query finds one subset of the LHS of r on the LHS of a rule r'. The query is processed by looping on each rule in Rulebase and computing LIRHS(r) CONTAINED_EQ_IN S using the technique from Section 5.2. 
The index on Rulebase is built only once for all the nested queries. Frona Figure 7, we can see that the execution is extremely fast even with a large number of rules and relatively straightforward implementation of nested queries. 
Query 3. In this set of experiments, we fix the number of expected rules to 20, as the user usually could not provide many expected rules. This query is processed directly using the algorithm in Figure 4. From Figure 7, it can be seen that the executions ate very efficient, and scale up roughly linearly with the number of rules in Rulebase. It is easy to see that as the number of expected rules increases, the execution time also grows linearly (not shown in Figure 7). 
Query 4. In this experiment, each rulebase has the same set of rules, and their confidences are all more than 60%. This means that there is no reduction in the number of rules in each operation. Thus, it represents the worst-case scenario. This query is evaluated using the algorithms findEqualSets and 
