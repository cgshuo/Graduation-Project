 With the development of information scien ce and information society, an increas-ing number of information on the internet is stored with XML format. Given the fact that XML is becoming the standard in exchanging and representing data, how to extract accurate information i n an effective and efficient way from XML documents has become an important issue a rousing much interest of researchers. A query language for XML, such as XQuery, can be used to extract data from XML documents. XQuery, operating effect ively with the structure, can convey complex semantic meaning in the query, a nd therefore can retrieve precisely the desired results. However, if the user wants to use XQuery to search information efficiently, he needs to possess sufficient knowledge about XQuery and the struc-ture of the XML document. It is, hence, apparent that this method is not a good choice for the beginning users.
 Though a variety of research attempts have been made to further explore XQuery, all of their research results fail to settle the problem of complexity of the query syntax.

As the search for technological development, information retrieval(IR)style keyword search on the web has made great achievements. Keyword search is a proven user friendly way of querying HTML documents in the World Wide Web. It allows users to find the information by inputting some keywords. Inspired by this, it is desirable to support keyword search in XML database. It is a very convenient way to query XML databases since it allows users to pose queries without the knowledge of complex query languages and database schema.
Based on the above situation, XML ke yword search in recent years has become a hot research area with a good many papers published and great achievements scored. In this paper, we survey the search semantics and the algorithms pre-sented in several representative papers.With the introduction of these papers, the readers could understand the main research stream of XML keyword search in recent years, as is shown in Table 1.

The research findings of XML keyword search can be generalized from three dimensions: We will introduce some papers X  main ideas in each dimensions. The efficiency and effectiveness are both important measures for XML keyword search. Every semantic for XML keyword search should consider these measures. Efficiency often means one method X  X  time c ost and space cost. Effectiveness often reflect the meaningfulness of the return result,in the other words, effectiveness can map the results matching degree of user X  X  search intention. Some semantics have been proposed to improve these areas. In this section,we introduce some classical methods based on these semantics. 2.1 XKeyword XKeyword[16]: Being part of the early research results, XKeyword provides efficient keyword proximity queries for large XML graph databases. This paper adopts the concept that a keyword proximity query is a set of keywords and the results are trees of XML fragments( called Target Objects )thatcontainall the keywords. In order to achieve quick response, XKeyword builds a set of connections,which precompute particu lar path and tree connections on the TSS graph. In this way, the XML data can be stored efficiently to allow the quick discovery of connections among elements that contain keywords; besides, the cost of computing the full presentation graph is very high. Hence, XKsearch adopts an on-demand execution method,where the execution is guided according to the users navigation. Another crucial problem that the result should be meaningful to the user and can not contain too much irrelevant information has been resolved by XKeyword. XKeyword associates a m inimal piece of information,called Target Object ,to each node and displays the target objects instead of the nodes in the results, in this way to make sure the meaningfulness of the result. XKeyword avoids producing duplicate results by employing a smart execution algorithm. 2.2 XSEarch XSEarch[11]: is a search engine for XML, it developed a syntax for search queries that is suitable for a naive user and facilitates a fine-granularity search. XSEarch presents excellent query semanti cs. It defines three search terms l:k , l: , :k . If an interior node n wants to satisfies one of the search terms, it should be fixed model. Thinking about the eff ectiveness of the return results, XSEarch presents a relation which can be used t o determine whether a pair of nodes is meaningfully related. T | n 1 ,n 2 denotes the shortest undirected path between node n 1 and node n 2 consists of the paths from the lowest common ancestor of n 1 and n 2 to n 1 and n 2 , then paper[11]defined that n and n are interconnected if one of the following conditions holds: XSEarch also developed a suitable ranking mechanism that takes into account the effectiveness of XML keyword search. we will introduce this ranking sematic in section 2. In order to improve the effici ency of XSEarch, interconnection index and path index are defined.
 2.3 SLCA SLCA[2]: SLCA means Smallest Lowest Common Ancestor semantics. A key-word search using the SLCA semantics returns nodes in the XML data that satisfy the following two conditions:(1) the subtrees rooted at the nodes contain all the keywords,and(2)the nodes do not have any proper descendant node that satisfies condition(1).
 Example 1: In the Figure 1,we put a query list X  X utombo,position X , then the SLCA is  X  X layer X  with the Dewey id [0.2.4.0]. The answer to the keyword search is the subtree rooted at the  X  X alyer X  node with id 0.2.4.0.This result is a better answer than the ssubtrees rooted at  X  X layers X  or  X  X eam X .

In the paper[2], two efficient algorithms, Indexed Lookup Eager and Scan Eager are designed for keyword search in X ML documents according to the SLCA semantics. In this paper, XML documen t is treated as a common tree, and the nodes in the XML tree use Dewey numbers as the id, as is showed in Figure 1. The Indexed Lookup Eager algorithm is based on four properties of SLCA, one of these properties is: The next algorithm is Scan Eager which is a variant of Index Lookup Eager Algorithm.When keyword search includes at least one low frequency keyword along with high frequency keywords,then the Scan Eager can be efficiently used. 2.4 CVLCA CVLCA[8]: In the above, we have introduced three semantics which improved the efficiency and effectiveness of XML keyword search. But it is not difficult to find that they sometimes return meaningle ss result or incomplete of answers. In order to improve the above situation, VLCA and Compact VLCA are proposed in the paper[8]. VLCA not only eliminates redundant LCAs but also retrieve relevant answers filtered out wrongly,a nd thus improves both accuracy and com-pleteness of keyword search. The definition of Homogenous/Heterogenous and MDC(Meaningful Dewey Code) are proposed,they are both important defini-tions for CVLCA . In paper[8] the compac t connected trees rooted CVLCAs are treated as the answers of keyword querie s. Moreover, the paper presents an op-timization technique for acceleratin g the computation of CVLCAs and device an efficient stack-based algorithm to iden tify the meaningfu l compact connected trees. 2.5 MaxMatch MaxMatch[4]: In view of the above-mentioned situation, paper[4] proposes an axiomatic framework that includes two intuitive and non-trivial properties: monotonicity and consistency , with respect to data and query. Data/Query Monotonicity describes how the number of query results should change upon an update to the data or query. Data/Query Consistency describes how the content of query results should change upon an update to the data or query. These properties are non-trival, non-redundant, and satisfactory. MaxMatch ,a novel semantics for identifying relevant matches and an efficient algorithm to realize this semantics, have been introduced in paper[4] which satisfies all prop-erties and returns the filtered fragments root at SLCA nodes after pruning the uninteresting nodes. To our knowledge, paper[4] is the first work on reasoning about and evaluating XML keyword search strategies using a formal axiomatic framework. 2.6 RTF RTF(Relaxed Tightest Fragments): From the section above, we can learn that a contributor-based filter mechanism in the MaxMatch algorithm is pro-posed. Analysis of paper[6], however, shows that the contributor-based filtering mechanism is not enough to filter out all the uninteresting nodes based on the SLCA. Besides, only focusing the SLCA related fragments is not enough for XML keywordsearcheither.Theybothsuffer false Positive example and Redundancy problem . Considering these situations, In paper [6] proposes a framework of re-trieving meaningful fragments rooted at not only the SLCA nodes but also all of the LCA nodes.The concept of Relaxed Tightest fragment (RTF) is proposed to represent the basic result for the X ML keyword search. Then the concept of valid contributor is defined as the following: The rule 1 aims to overcome the false positive problem,and rule 2 is used to overcome the redundancy problem.By taking into account the label and the content of a node, the children of a node could be classified as valid contributors and non-contributors. paper [6] also introduces an algorithm based on ValidRTF. As was introduced above, XML keyword search provided a simple way to query XML database. However, this kind of simple query format may not be precise and returns too many results,this can bring inconvenience to the users. To address this problem, some method s were proposed in recent years. One proposed way is to first compute the query results and then rank them; another method[14] infers the return node type by analyzing keyword match patters; XReal[7] were proposed recently,which utilized the statics of underlying XML data. In this section we will introduce all of the semantics. 3.1 XRANK XRANK[10]: XRANK[10] tries to solve the problem of efficiently producing ranked results for keyword search ove r hyperlinked XML documents.In order to define specific ranking function,the desired properties for ranking functions over hyperlinked XML documents are proposed firstly. There are three desired properties that ranking function should take into account: Result Specificity, Keyword Proximity and Hyperlink Awareness. Result specificity means that the ranking function should rank more specific results higher than less specific re-sults. Some functions respect to different content are well defined in the paper. is computed as follows.
 The overall ranking is the sum of ranks with respect to each query keyword.
Besides, the ElemRank which is a measure of the objective importance of an XML element is proposed in the paper[10]. The algorithm for Computing ElemRank is as follows: e ( v )= forward containment edges,and reverse co ntainment edges,respectively. Based on the above definition, two algorithms are designed to rank result for XML keywordsearchqueries: DIL query processing algorithm and RDIL query pro-cessing algorithm. DIL (Dewey Inverted List) only stores the IDs of elements that directly contain the keyword, its size is likely to be much smaller the size of the naive inverted list. XRANK system for ranked keyword search over XML documents is designed based on all the content mentioned above. 3.2 XSEEK XSEEK[3]: Ranking semantics may help users quickly find the information they want to find. But the challenge what appropriate data nodes to be returned has not addressed by the ranking semantics. To solve this problem, paper[3] pro-posed some definitions ,algorithms and one XSEEK system. The first guideline of the XSEEK system is to differentiate nodes representing entities from nodes representing attributes,and generate return nodes.when the schema is available, all the node categories are defined as follows: 1. A node represents an entity if it corresponds to a *-node in the DTD 2. A node denotes an attribute if it dose not correspond to a *-node, and only 3. A node is a connection node if it represents neither an entity nor an attribute. The second guideline of XSEEK system is to take keyword macth patterns into consideration,by classfying keywords into two categories: search predicates and return nodes .The data nodes that match return nodes are output based on their node categories: attributes,entit ies and connection nodes. On the basis of the above-mentioned semantics, paper[ 3] presents the algorithms that process keyword search on XML data and achieve the semantics efficiently. 3.3 XReal XReal[7]: With the increasing attention paid to the study of the effectiveness and ranking semantic of XML keyword search, some problems and approaches are put forward. One of the new proposal is about the effectiveness and ranking mechanism in term of result relevan ce summarized as three issues in[7]: Inspired by the important role of data statics in IR-ranking,[7]maintains and exploits two important basic statics terms, i.e. (1) XML TF(term frequency) f a,k : The number of occurrences of a keyword k in a given data node ainXML data,(2) XML DF(document frequency) f T k : the number of T-types nodes that contain keyword k in their subtrees in XML data. Then three guidelines of the search for node type T are defined: 1. T is related to every query keyword, 2. T should be informative enough, 3. T should not be overwhelming. By incorpo-rating the above guidelines, we define C for ( T,q ),which is the confidence of node type T to be search for node type: The function of the confidence of a node type T to be a desired type to search via is also designed.A novel relevance-oriented ranking scheme called XML TF*IDF similarity which can capture the hierarchical structure of XML and resolve Ambiguity1-3 in a heuristic way is introduced, and based on the above defi-nitiona keyword search engine prototype called XReal is implemented.The algo-rithm of XReal is defined in two steps: first step is data processing and index construction ; then the second step is keyword search and ranking the results. XBridge[22]: For common users, each result type implies a possible search type (Promising Result Types) from the retrieved data . The process to deter-mine the promising result type contains three steps:(1) First, computing all query results individually and classifying them, (2)then the score of each type is computed by a proposed ranking function,(3)finally, the type with the highest score is chosen as the promising result type.

Two algorithms are defined for deciding promising type to the query. The main procedure of the algorithms is as follows: (1) first, the corresponding dis-tinct paths of each term in the query should be determined by the given key-word query.(2)then, we can obtain all res ult types where each type is a distinct label path from the root node to the lowest connected node on its query tem-plate.(3) After that, we compute the score for each result by calling a ranking function.(4)finally, the result type with highest score will be considered as the promising type to query. Based on the abo ve contented, the search engine pro-totype called XBridge is implemented . From the previous section,we can learn that various ranking schemes have been proposed to assess the relevance of quer y results so that users can focus on the ones that are deemed to be highly relevant. However,because of the ambiguity of search semantics, it is impossible to design a ranking semantics that always perfectly gauges query result relevance with respect to users X  intentions,besides, a user may would like to investigate,compare multiple relevant results for infor-mation discovery and decision making. To compensate the inaccuracy of ranking functions and help the user differentiate multiple results, snippet, promising re-sult types,and result differentiation a re researched during recent years. In this section,we will introduce these semantics. 5.1 Snippet Snippet[15]: Most text search engine uses snippets to complement ranking scheme in order to effectively handle user searches. Today, some researches on result exploration of snippets are also under way. Paper[15] is the first paper which tries to carry out research on the area. Four goals are identified for a good result snippet: (1) Self-contained. a query result snippet should be self-contained so that the user can understand it.(2)Distinguishable A snippet should make the corresponding query result distinguishable from the snippets of other query re-sults so that the users can differentiate them with little effort. (3) Representative Snippets. Therefore, the users can grasp the essence of the result from its snippet. (4) Small. A query result snippet should be small so that the user can quickly browse several snippets. The most significant information in the query result that should be selected into a snippet in a snippet information list is identified to meet the first three goals. To satisfy the four requirements, paper[15] designs and implements a novel algorithm to effici ently generate inf ormative yet small snippets. 5.2 Result Differentiation(XRed) XRed[23]: As we can learn from above, snippets highlight the most dominant features in the results. Without considering the relationships among results, the snippets are not helpful to compare and differentiate multiple results.
In paper[23], some techniques for comparison and differentiation of structured search results are proposed. An algorithm takes as input a set of structured re-sults, and outputs a Differentiation Feature Set(DFS) for each result to highlight their differences within a size bound. Three desiderata for DFS are discussed: (1) limited size, small size of query results (2)reasonable summary. Otherwise,the differences shown in DFSs do not reflect the actual differences between the cor-responding query results.(3)maximal diff erentiation. For su mmarizing query re-sults, the DFS should appease two rules: (1) Dominance Ordered (2) Distribution Preserved.

The DFS construction problem is proved to be a NP-hard problem. Due to the NP-hardness of the DFS construction problem,two local optimality crite-ria are proposed: single-swap optimality and multi-swap optimality, then two efficient algorithms for ac hieving these criteria ar e designed. XReD system is implemented which satisfies all definitions are mentioned above. To verify the effectiveness and efficien cy of these approaches we have introduced above, some experiments were designed. all experiments were conducted on a 1.66HZ Intel Core Dou CPU machine with 2GB RAM running Windows XP.
 The algorithms were implemented in Java and the parsing of the XML files was performed using the SAX API of the Xerces Java Parser.We choose some of algorithms for our experiments. We com pare these approaches X  efficient, effec-tiveness. DBLP is used as the test database. The size of the data is 389M. 6.1 Effectiveness As we said above , effectiveness is the matc h X  X  degree of users X  search intention. To get a fairly objective view of user search intentions in real world, we organize ten persons and tell them some basic information about DBLP XML database. all of the people are asked to write ten to twenty queries and their desired information that can satisfies their sea rch intention. For example, the Fig.2. shows one people X  X  example.

We divide the ten subjects into two groups,whose testing results will be queried with five different methods,and then a comparison will be done to find the matching degree between the returne d results and their search intentions. Each method will be correspondingly graded with points ranging from one to five according to the satisfaction of the subjects. Finally, the average mark of each method as a group is given after the above operation is carried out by the subjects. The results are showed in Figure 2.

From the figure, we can find that the XReal and XBridge do well then the others. XReal decides the search for node and search via node before calculating the results. XBridge propose a new method of predicting the result type for XML keyword queries. Different semantic o f approach cause different effectiveness. 6.2 Efficiency TheefficiencyofXMLkeywordsearchref ers to the time cost of the search step. We evaluate the efficiency of SLCA, XSeek, CVLCA, XReal, XBridge respec-tively and know that the time costs of various queries vary with the structure of XML database. In this section, we divide the selected fifteen queries into three groups and record the time cost of each query. Next, we compute the average time cost for each corresponding query with a specific method as a group. The following Figure.3 shows the time cost of each method.

According Figure.3, we can see the effic iency of these algorithms. We can infer that the algorithms want to get better effectiveness, it may loose the efficiency of keyword search.

From above, we learn some chosen algorithms X  compare. And learn some knowledge about the efficiency and effectiveness of XML keyword search. This paper starts from the introduction of a couple of representative papers and gives a brief explanation of representative semantics and algorithms. It can be concluded that the research of XML keyword search gradually shares many features with the text keyword search, which facilitate the search. As for the future works, existing methods mostly concentrate on retrieval on inverted lists in XML keyword search. Management of efficient indexes is usually not taken into account. There should be efficient mechanism to use B+ tree or other indexing methods to perform search efficiently. Another improvement can be supporting update in XML documents. This is important especially in XML documents which are frequently updated. Finally, another important future work would consider keyword query alternation and suggestion in XML keyword search. An example of this would be modifying  X  Schwarzeneger California governor  X  to  X  Schwarzenegger California governo r  X  to correct the typo. In general a well query-alternation tool is needed for the practical application of XML keyword search platform.

