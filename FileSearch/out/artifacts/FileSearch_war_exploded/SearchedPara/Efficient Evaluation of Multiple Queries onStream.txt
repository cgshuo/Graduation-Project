 The recent emergence of XML [1] as a de facto standard for information rep-resentation and data exchange over the web has led to an increased interest in using more expressive subscription/filtering mechanisms that exploit both the structure and the content of XML documents. Evaluating XML queries, such as XPath [2] and XQuery [3], is thus widely studied both in traditional database management systems and in stream model for web applications. Figure 1 gives an XML document and its DOM tree, which acts as an example of our work.
Recently, many research works [4,5,6,7,8,9,10] focus on answering queries on streamed XML data, which has to be analyzed in real-time and by one pass. In the push-based model [5, 4], XML streams are broadcasted to multiple clients, which must evaluate continuous, sophistic ated queries (as opposed to simple, sin-gle path specifications) with limited memory capacity and processing power. In the pull-based model [6,7,8,9,10], such as publish-subscribe or event notification systems, XML streams are disseminated to subscribers, but a larger number of registered queries pose heavy workload on the server. Hence, expediting multiple queries on XML streams is the core technical challenge.
 In order to reduce processing overhead, Hole-Filler model is proposed in [11]. In the model, a hole represents a placeholder into which another rooted subtree (a fragment), called a filler, could be positioned to complete the tree. In this way, infinite XML streams turn out to be a sequence of XML fragments, and queries on parts of XML data require less memory and processing time, without having to wait for the entire XML document to be received and materialized. Furthermore, changes to XML data may pose less overhead by sending only fragments corresponding to the changes, instead of sending the entire document.
However, to the best of our knowledge, there is no work for evaluating mul-tiple queries on streamed XML fragments so far. In XFrag [4] and XFPro [12], XML fragments can only be evaluated under simple, single queries. While other research work [6,7,8,9,10] consider problems on a stream of XML tuples, not XML fragments, and can not avoid  X  X edundant X  operations caused by fragments.
In this paper, we present an efficient framework and a set of techniques for processing multiple XPath queries over streamed XML fragments. As compared to the existing work on supporting XPath/XQuery over streamed XML frag-ments, we make the following contributions: (i)we propose techniques for en-abling the transformation from multiple XPath expressions to optimized query plan. We model the query expressions using tid+ tree and apply a series of prun-ing policies, which enable further analysis and optimizations by eliminating the  X  X edundant X  path evaluations. (ii)based on tid+ tree, we present a novel index structure, termed FQ-Index, which supports the efficient processing of multiple queries (including simple path queries and twig path queries) for streamed XML fragments by indexing both the queries and the fragments. (iii)based on FQ-Index, we address the main algorithms of query evaluation in M-XFPro, which is able to both reduce the memory cost as well as avoid redundant matchings by recording only query related fragments. Note that, we assume the query ends cannot reconstruct the entire XML data before processing the queries.
The rest of this paper is organized as follows. Section 2 introduces Hole-Filler model as the base for our XML fragments. Section 3 gives a detailed statement of our multiple query processing framework. Section 4 shows experimental results from our implementation and reflects the processing efficiency of our framework. Our conclusions are contained in Section 5.
 In our approach, we adopt the hole-filler model [11] to correlate XML fragments with each other. We assume that XML stream begins with finite XML documents and runs on as and when new elements are added into the documents or updates occur upon the existing elements.

Given an XML document tree T d =( V d , E d , X  d , root d ,Did ), a filler T f = ( V f , E f , X  f , root f ,fid,tsid ) is a subtree of XML document associating a fid and a tsid ,where V f , E f ,  X  f is the subset of node set V d ,edgeset E d and element type set  X  d respectively, and root f (  X  V f )is the root element of the subtree; a hole H is an empty node v (  X  V d ) assigned with a unique hid and a tsid , into which a filler with the same fid value could be positioned to complete the tree. Note that the filler can in turn have holes in it, which will be filled by other fillers. We can reconstruct the original XML document by substituting holes with the corresponding fillers at the destination as it was in the source. In this paper, we assume that XML documents have been fragmented already. Fragmenting algorithm is stated in [13] and omitted here. Figure 2 gives two fragments of the document in Figure 1.

In order to summarize the structure of XML fragments, tag structure [11] is exploited to provide structural information (including fragmentation informa-tion) for XML and capture all the valid paths. A tag structure T S =( V t , E t , root t , X  t , T YP E t ) is itself structurally a valid XML fragment with the highest priority, where V t is a set of tag nodes in XML document, E t is a set of edges,  X  t is a set of tsid s identifying the tag nodes in XML document, and T YP E t is a set of tag node type. Tag structure can be generated according to XML Schema or DTD, and also can be obtained when fragmenting an XML document with-out DTD. The DTD and the corresponding tag structure of the XML document (given in Figure 1) are depicted in Figure 3. Based on the Hole-Filler model, we have proposed M-XFPro, a system aimed at providing efficient evaluation for multiple queries over streamed XML frag-ments. In this section, we first introduce tid+ tree for rewriting the queries for XML fragments, and describe the pruning policies to eliminate  X  X edundant X  path evaluations. Then we present our novel FQ-Index for processing streamed XML fragments based on optimized tid+ tree .Wepresentthemainmatching algorithms for query handling with FQ-Index at last. 3.1 Tid+ Tree Construction In our earlier framework [12], we propose tid tree to represent the structural patterns in an XPath query. Each navigation step in an XPath is mapped to a tree node labelled with a tag code, which encodes the tsid and  X  X YPE X  together. For  X  F iller = true  X , we set the end of the tag code with  X 1 X , otherwise we set it with  X 0 X . As for tsid, we separate it from the  X  X YPE X  code by a dot. By checking the end of the code, we can easily tell subroot nodes (i.e. the root of a filler) from subelement nodes (i.e. the node that locates in a filler but is not the root of the subtree).

We expand the concept of tid tree into tid+ tree to represent multiple query expressions and enable further analysis and optimizations on query operations.
Given a collection of XPath expressions P = { p 1 ,p 2 ,  X  X  X  ,p n } , we map multiple queries into a single tree, noted as tid+ tree , by defining root t as a special root node, which allows for conjunctive conditions at the root level. Parent-child relationship is represented by a single arrow, while ancestor-descendant relationship is represented by a double arrow. And the output of each query q i is depicted by a single arrow and marked with the ID of q i .Inorderto distinguish between the nodes that represent a tag code and the nodes that represent an atomic predicate, we represent nodes of tag code with circles and values of predicate with rectangles. The operators (such as &lt; , &gt; ,  X  ,  X  ,=) and boolean connectors are represented with diamonds. Note that the common prefixes of all the queries are shared.

Figure 4 shows an example of such a tid+ tree, representing three queries on the XML document described in Section 1, where Query 1 and Query 2 share the common prefix  X  /co mm ondities/vendor  X  (i.e. / 1 . 1 / 1 . 2). Since  X  na m e  X  X n Query 2 corresponds to two tsids in the tag structure, we enumerate all the possible tsids in the tid+ tree such that Query 2 has two output arrows.

Since tid+ tree is the base for FQ-Index to install multiple XPath expressions into the indexing structure, the optimization of tid+ tree impacts both the space and performance of the index. We now introduce two kinds of optimizations on tid+ tree to eliminate the redundant operations as early as possible. Duplication Pruning. Given an XPath p , we define a simple subexpression s the tid tree of p , such that each v i istheparentnodeof v i +1 (1  X  i&lt;n )andthe label of each v i (except perhaps for v 1 ) is prefixed only by  X / X . Definition 1. Given a collection of XPath expressions P = { p 1 ,p 2 ,  X  X  X  ,p n } , subexpression s is a common subexpression if more than one tid tree of p i con-tains s . If a common subexpression is also a simple subexpression, we define it as a simple common subexpression. A common subexpression s is defined as a maximal common subexpression if no other longer common subexpression in the tid+ tree of P contains s .
 Common subexpressions degrades the performance significantly, especially when the workload has many similar queries. Since the common prefixes of all the queries are shared in tid+ tree, we consider optimizing tid+ tree by grouping all the common subexpressions in the structure navigation.

In order to extract the common subexpressions, we have to find out the struc-tural relationship shared among the queries. By taking advantage of tag struc-ture, we can replace  X // X  in tid+ tree with the corresponding structure consisting of  X / X  and expand  X * X  in tid+ tree to speci fy query execution. As for twig pat-tern query, we add the subroot nodes involved in the branch expression into the tid+ tree if the testing node and the branch expression belong to different fragments. In this way, common subexpressions turn out to be simple common subexpressions, and all the possible duplicated expressions can be pruned off.
Figure 5(a) presents the tid+ tree in Figure 4 after eliminating  X // X  and  X * X  based on tag structure, where the dashed regions enclose the subexpression (i.e. the subexpression (i.e. / 1 . 1 / 2 . 1 / 4 . 0) shared by Query 1 , Query 2 and Query 3 .Sincetidnode5 . 1in Query 1 has a predicate, which is not included in the other two queries, we treat the tid node 5 . 1in Query 1 as a different node and exclude it in the common subexpression. Note that Figure 5(a) captures all the maximal common subexpressions among the queries. The optimized tid+ tree after pruning off the duplicated subexpressions is presented in Figure 5(b). Dependence Pruning. Before we describe the dependence pruning policy for tid+ tree, we first introduce some definitions of operation dependence. Definition 2. Given any pair of nodes in a tid+ tree &lt;n 1 , n 2 &gt; , if the query result of n 2 is valid only if the query result of n 1 is valid, n 2 is defined as dependent on n 1 .Weuseadirectededge e =( n 1 ,n 2 ) to imply the dependence between n 1 and n 2 .
 Definition 3. Given any pair of nodes in a tid+ tree &lt;n 1 , n 2 &gt; , we say that n 2 is subsumption dependent on n 1 if: (i) n 2 is dependent on n 1 , and (ii) the query result of n 2 is a subset of the query result of n 1 .
 In streaming XML fragment model, operation dependence usually occurs when the query results to preceding query node and successive query node are in the same fragment(here we are not considering predicates), since the fragments with the same tsid share the same structure so that any fragment matching the preceding node also matches the successive one. In most cases, the dependence operation can be eliminated by removing the successive query nodes.
When the query node involve predicates, if the result set of predicate p 2 is a subset of that of predicate p 1 , we refer to p 2 as subsumption dependent on p . Subsumption-free queries are intuitively queries that do not contain  X  X edun-dancies X . Some queries can be rewritten to be subsumption-free, by eliminating redundant portions.

Much of our analysis focuses on pruning off operation dependencies on tid nodes caused by fragmentation to eliminate  X  X edundant X  structural evaluations. Since tag structure guarantees that the fragments with the same tsid share the same structure, we keep all the subroot nodes and delete the subelement nodes which have no predicates and are not the leaf nodes in tid+ tree. According to tag code, subroot nodes ended with  X 1 X  are kept in the tid+ tree while subelement nodes ended with  X 0 X  and without predicate nodes in their children are removed. Thus the original tid+ tree becomes an optimized tid+ tree.
 Figure 6(a) shows the operation dependence in the optimized tid+ tree in Figure 5(b), where tid node 4 depends on tid node 2 and is referred to as a dependent node. We use dashed arrows to represent operation dependencies, and dashed rectangles for dependent nodes. Figure 6(b) shows the optimized tid+ tree after pruning off the operation dependencies. 3.2 FQ-Index Scheme Our FQ-Index is a hybrid index structure, which indexes both the queries and fragments on the basis of optimized tid+ tree. An FQ-Index consists of two key components: (1) a query index (denoted by Q I ), constructed by tid+ tree to facilitate the detection of query matchings in the input XML fragments; and (2) a filler table (denoted by FT ), which stores the information about each XML fragment. Both of the components share a hash table for subroot nodes in tid+ tree. We now describe each of these two components in detail.
 Query Index. Query index is generated from optimized tid+ tree before processing to keep track of the query steps that are supposed to match next. Let denote the subroot nodes in optimized tid+ tree. Query index Q I of P for each t is a 4-tuple list. Each item in the query list for t i is a 4-tuple ( query id set, predecessor, successor, predicate ), denoted as q-tuple ,where:  X  Query id set represents the queries in set P that share the same predicate,  X  Predecessor refers to the tag code of the fragment in tid+ tree corresponding  X  Successor refers to the tag code of the fragment in tid+ tree corresponding  X  Predicate is the branch expression of twig path queries in tid+ tree.
Predecessor and successor in each item keep track of the query steps, while predicate keeps the reference of branch expressions. With the help of query id set, we can avoid duplicate evaluations shared by multiple queries. Since subroot nodes indicate the tsids of the fragments involved in the queries, we can directly access the relative query steps by the corresponding entry of the hash table when a fragment arrives. Figure 7 presents the query index converted from the optimized tid+ tree(  X  X ll X  represents all of the queries in set P ) in Figure 6(b). Filler Table. As fragments in the original document may arrive in any order and query expressions may contain predicates at any level in the XML tree, it is necessary to keep track of the parent-child links between the various fragments. We maintain the fragments X  information in filler table at each entry of the hash table when processing arrived fragments. Since the structural information corre-sponds to a small part of the actual data in the XML fragment, the rest of which is not relevant in producing the result, we discard the fragments corresponding to intermediate steps to save space cost.

The filler table FT contains one row for each fragment. Each row in FT is to true , false , undecided (  X  ), or a result fragment corresponding to q i in set P . While the former three values are possible in intermediate steps that do not produce a result, the latter is possible in the terminal steps in the tid+ tree branch. Figure 7 shows the construction of filler table.

With the hash table, the filler table and the query index cooperate together as FQ-Index. Taking advantage of the query index, we can quickly inquire the parent fragment by matching the same holeid in the predecessor X  X  FT .Inthis way, filler table enhances the performance by only maintaining the information of fragments that will contribute to the results. Thus FQ-Index efficiently sup-ports the online evaluation of multiple queries over streamed XML fragments, including both simple path queries and twig pattern queries. 3.3 Query Handling In this section, we address the main algorithms of query evaluation in M-XFPro. The basic idea of the matching algorithms is as follows. We use the query index Q I to detect the occurrence of matching tsids as the input fragments stream in, since before we record the structrual information of a fragment, it needs to verify if the preceding operation has excluded its parent fragment due to either predicate failure or due to exclusion of its ancestor.

For example, Query 1: /commodities/vendor[name= X  X al-Mart X  X //item [ m a -ke = X  HP  X  X  is a twig pattern query with two atomic predicates, while Query 2: /commodities/vendor[name= X  X rice-Mart X  X //item[make= X  X BM X  X  is a similar query just with different predicates. When the  X  X ommodities X  fragment with tsid  X 1 X , filler id  X 0 X  and hole ids  X 1, 21, 41 X  arrives, the FT to the en-filler can be discarded as it is no more needed to produce the result and the hole filler association is already captured. This results in memory conserva-tion on the fly. When the  X  X endor X  fragment with tsid  X 2 X , fillerid  X 1 X , holeid  X 2 , 3 ,  X  X  X  , 20 X  and  X  X ame=Wal-Mart X  arrives, the FT to the entry 2 is updated fillerid  X 2 X  arrives, only after determine that the filler matches the predicate of Query 1 [ m ake = X  HP ], the fragment can be regarded as the query result of Query 1 . Taking advantage of Q I ,itwon X  X bemixedupwiththeresultof Query 2 [ m ake = X  I BM ]sincethe Predecessor has excluded its parent fragments. Algorithm 1. startElement() We implement the callback functions startElement() and endElement() of SAX interface when parsing each XML fragment. In algorithm 1, if an element is a subroot node, the information of the corresponding fragment in which it falls will be captured and loaded into FT. Similar operation is performed when encountering the element representing a hole. The variable relevant T ag will be set to true if the element is query related. In algorithm 2, parent fragment and predicate fragment of the filler containing the element are inquired, and tag value of the corresponding f-tuple is set to true in case both kinds of the above fragments are valid. Child fragments need to be trigged as well, for some early arrived fragments may be set to  X   X   X  and waiting for their parent fragments. Algorithm 2. endElement() In this section, we present the results of performance evaluation of various algo-rithms over queries with different types, depths and document sizes on the same platform. We consider the following algorithms: (1) M-XFPro, (2)Du-XFPro, i.e. M-XFPro based on tid+ tree without dependence pruning, (3)De-XFPro, i.e. M-XFPro based on tid+ tree without duplication pruning. All the experiments are run on a PC with 2 . 6GHz CPU, 512M memory. Data sets are generated by the xmlgen program [14]. We have written an XML fragmenter that fragments an XML document into filler fragments to produce an XML stream, based on the tag structure defining the fragmentation layout. And we implemented a query generator that takes the DTD as input and creates sets of XPath queries of different types and depths.

In figure 8(a) three kinds of processing strategies over various query num-bers are tested and compared. The numbers of queries in each set are 1,2,10 respectively. From the result, we can conclude that dependence pruning and du-plication pruning in M-XFPro play an important role in efficiently evaluating multiple queries. In the following experiments, we fix the query number and test other properties of the queries. Figure 8(b) shows the performance on dif-ferent types of queries: (1)simple path queries only involving  X / X , denoted as Q 1 (2)simple path queries involving  X * X  or  X // X , denoted as Q 2 (3)twig pattern queries with value predicates, denoted as Q 3 . We can see that for any query type, M-XFPro outperforms its counterparts, and query types do not bring in exceptions, i.e. query performance doesn X  X  vary much on different query types. For simplicity, but without losing generality, we only test twig queries in the next two set of experiments. Figure 8(c) shows the impacts of various query depths. Considering the depth of the XML documents generated by xmlgen, we design three query sets of depth 3, 5 and 7 respectively. As is shown in the figure, when the depth increases, the processing time of De-XFPro and Du-XFPro in-creases due to the increased path steps. While with duplication and dependence pruning, M-XFPro greatly reduces path steps, furthermore time cost of deep queries is much less than short queries, since fragment processing is much faster. Figure 8(d) shows the influence of different document size: 5M, 10M and 15M. In this paper, we have proposed a framework and a set of techniques for process-ing multiple XPath queries over streamed XML fragments. We first model the multiple queries into tid+ tree, which helps to transform queries on element nodes to queries on XML fragments and serves as the base for analyzing  X  X edun-dant X  operations caused by common subexpression and operation dependence. Based on optimized tid+ tree after duplication pruning and dependence prun-ing, FQ-Index is proposed to index both the queries and fragments by sharing a hash table for tid nodes, which supports not only simple path queries, but also twig pattern queries. Our experimental results over multiple XPath expressions with different properties have clearly demonstrated the benefits of our approach. Acknowledgments. This research was partially supported by the National Nat-ural Science Foundation of China (Grant No. 60273079 and 60573089) and Spe-cialized Research Fund for the Doctoral Program of Higher Education (SRFDP).
