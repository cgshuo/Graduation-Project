 In this paper, we study the task of grounding lin-guistic analysis in control applications such as com-puter games. In these applications, an agent attempts to optimize a utility function (e.g., game score) by learning to select situation-appropriate actions. In complex domains, finding a winning strategy is chal-lenging even for humans. Therefore, human players typically rely on manuals and guides that describe promising tactics and provide general advice about the underlying task. Surprisingly, such textual infor-mation has never been utilized in control algorithms despite its potential to greatly improve performance. Consider for instance the text shown in Figure 1. This is an excerpt from the user manual of the game Civilization II. 2 This text describes game locations where the action  X  X uild-city X  can be effectively ap-plied. A stochastic player that does not have access to this text would have to gain this knowledge the hard way: it would repeatedly attempt this action in a myriad of states, thereby learning the characteri-zation of promising state-action pairs based on the observed game outcomes. In games with large state spaces, long planning horizons, and high-branching factors, this approach can be prohibitively slow and ineffective. An algorithm with access to the text, however, could learn correlations between words in the text and game attributes  X  e.g., the word  X  X iver X  and places with rivers in the game  X  thus leveraging strategies described in text to better select actions.
The key technical challenge in leveraging textual knowledge is to automatically extract relevant infor-mation from text and incorporate it effectively into a control algorithm. Approaching this task in a super-vised framework, as is common in traditional infor-mation extraction, is inherently difficult. Since the game X  X  state space is extremely large, and the states that will be encountered during game play cannot be known a priori, it is impractical to manually anno-tate the information that would be relevant to those states. Instead, we propose to learn text analysis based on a feedback signal inherent to the control application, such as game score.
Our general setup consists of a game in a stochas-tic environment, where the goal of the player is to maximize a given utility function R ( s ) at state s . We follow a common formulation that has been the basis of several successful applications of machine learning to games. The player X  X  behavior is deter-mined by an action-value function Q ( s,a ) that as-sesses the goodness of an action a in a given state s based on the features of s and a . This function is learned based solely on the utility R ( s ) collected via simulated game-play in a Monte-Carlo framework.
An obvious way to enrich the model with textual information is to augment the action-value function with word features in addition to state and action features. However, adding all the words in the docu-ment is unlikely to help since only a small fraction of the text is relevant for a given state. Moreover, even when the relevant sentence is known, the mapping between raw text and the action-state representation may not be apparent. This representation gap can be bridged by inducing a predicate structure on the sentence X  X .g., by identifying words that describe actions, and those that describe state attributes.
In this paper, we propose a method for learning an action-value function augmented with linguistic fea-tures, while simultaneously modeling sentence rele-vance and predicate structure. We employ a multi-layer neural network where the hidden layers rep-resent sentence relevance and predicate parsing de-cisions. Despite the added complexity, all the pa-rameters of this non-linear model can be effectively learned via Monte-Carlo simulations.

We test our method on the strategy game Civiliza-tion II, a notoriously challenging game with an im-mense action space. 3 As a source of knowledge for guiding our model, we use the official game man-ual. As a baseline, we employ a similar Monte-Carlo search based player which does not have ac-cess to textual information. We demonstrate that the linguistically-informed player significantly outper-forms the baseline in terms of number of games won. Moreover, we show that modeling the deeper lin-guistic structure of sentences further improves per-formance. In full-length games, our algorithm yields a 27% improvement over a language unaware base-line, and wins over 78% of games against the built-in, hand-crafted AI of Civilization II. 4 Our work fits into the broad area of grounded lan-guage acquisition where the goal is to learn linguis-tic analysis from a situated context (Oates, 2001; Siskind, 2001; Yu and Ballard, 2004; Fleischman and Roy, 2005; Mooney, 2008a; Mooney, 2008b; Branavan et al., 2009; Vogel and Jurafsky, 2010). Within this line of work, we are most closely related to reinforcement learning approaches that learn lan-guage by proactively interacting with an external en-vironment (Branavan et al., 2009; Branavan et al., 2010; Vogel and Jurafsky, 2010). Like the above models, we use environment feedback (in the form of a utility function) as the main source of supervi-sion. The key difference, however, is in the language interpretation task itself. Previous work has focused on the interpretation of instruction text where input documents specify a set of actions to be executed in the environment. In contrast, game manuals provide high-level advice but do not directly describe the correct actions for every potential game state. More-over, these documents are long, and use rich vocabu-laries with complex grammatical constructions. We do not aim to perform a comprehensive interpreta-tion of such documents. Rather, our focus is on lan-guage analysis that is sufficiently detailed to help the underlying control task.

The area of language analysis situated in a game domain has been studied in the past (Eisenstein et al., 2009). Their method, however, is different both in terms of the target interpretation task, and the su-pervision signal it learns from. They aim to learn the rules of a given game, such as which moves are valid, given documents describing the rules. Our goal is more open ended, in that we aim to learn winning game strategies. Furthermore, Eisenstein et al. (2009) rely on a different source of supervision  X  game traces collected a priori. For complex games, like the one considered in this paper, collecting such game traces is prohibitively expensive. Therefore our approach learns by actively playing the game. Our method operates within the Monte-Carlo search framework (Tesauro and Galperin, 1996), which has been successfully applied to complex computer games such as Go, Poker, Scrabble, multi-player card games, and real-time strategy games, among others (Gelly et al., 2006; Tesauro and Galperin, 1996; Billings et al., 1999; Sheppard, 2002; Sch  X  afer, 2008; Sturtevant, 2008; Balla and Fern, 2009). Since Monte-Carlo search forms the foundation of our approach, we briefly describe it in this section. Game Representation The game is defined by a large Markov Decision Process  X  S,A,T,R  X  . Here S is the set of possible states, A is the space of legal actions, and T ( s 0 | s,a ) is a stochastic state transition function where s,s 0  X  S and a  X  A . Specifically, a state encodes attributes of the game world, such as available resources and city locations. At each step of the game, a player executes an action a which causes the current state s to change to a new state s 0 according to the transition function T ( s 0 | s,a ) . While this function is not known a priori, the pro-gram encoding the game can be viewed as a black box from which transitions can be sampled. Finally, a given utility function R ( s )  X  R captures the like-lihood of winning the game from state s (e.g., an intermediate game score).
 Monte-Carlo Search Algorithm The goal of the Monte-Carlo search algorithm is to dynamically se-lect the best action for the current state s t . This se-lection is based on the results of multiple roll-outs which measure the outcome of a sequence of ac-tions in a simulated game  X  e.g., simulations played against the game X  X  built-in AI. Specifically, starting at state s t , the algorithm repeatedly selects and exe-cutes actions, sampling state transitions from T . On game completion at time  X  , we measure the final utility R ( s  X  ) . 5 The actual game action is then se-lected as the one corresponding to the roll-out with the best final utility. See Algorithm 1 for details.
The success of Monte-Carlo search is based on its ability to make a fast, local estimate of the ac-Algorithm 1: The general Monte-Carlo algorithm. tion quality at each step of the roll-outs. States and actions are evaluated by an action-value func-tion Q ( s,a ) , which is an estimate of the expected outcome of action a in state s . This action-value function is used to guide action selection during the roll-outs. While actions are usually selected to max-imize the action-value function, sometimes other ac-tions are also randomly explored in case they are more valuable than predicted by the current estimate of Q ( s,a ) . As the accuracy of Q ( s,a ) improves, the quality of action selection improves and vice versa, in a cycle of continual improvement (Sutton and Barto, 1998).

In many games, it is sufficient to maintain a dis-tinct action-value for each unique state and action in a large search tree. However, when the branch-ing factor is large it is usually beneficial to approx-imate the action-value function, so that the value of many related states and actions can be learned from a reasonably small number of simulations (Sil-ver, 2009). One successful approach is to model the action-value function as a linear combination of state and action attributes (Silver et al., 2008): Here ~ f ( s,a )  X  R n is a real-valued feature function, and ~w is a weight vector. We take a similar approach here, except that our feature function includes latent structure which models language.

The parameters ~w of Q ( s,a ) are learned based on feedback from the roll-out simulations. Specifically, the parameters are updated by stochastic gradient descent by comparing the current predicted Q ( s,a ) against the observed utility at the end of each roll-out. We provide details on parameter estimation in the context of our model in Section 4.2.

The roll-outs themselves are fully guided by the action-value function. At every step of the simula-tion, actions are selected by an -greedy strategy: with probability an action is selected uniformly at random; otherwise the action is selected greed-ily to maximize the current action-value function, arg max a Q ( s,a ) . In this section we describe how we inform the simulation-based player with information automat-ically extracted from text  X  in terms of both model structure and parameter estimation. 4.1 Model Structure To inform action selection with the advice provided in game manuals, we modify the action-value func-tion Q ( s,a ) to take into account words of the doc-ument in addition to state and action information. Conditioning Q ( s,a ) on all the words in the docu-ment is unlikely to be effective since only a small fraction of the document provides guidance relevant to the current state, while the remainder of the text is likely to be irrelevant. Since this information is not known a priori, we model the decision about a sentence X  X  relevance to the current state as a hid-den variable. Moreover, to fully utilize the infor-mation presented in a sentence, the model identifies the words that describe actions and those that de-scribe state attributes , discriminating them from the rest of the sentence. As with the relevance decision, we model this labeling using hidden variables.
As shown in Figure 2, our model is a four layer neural network. The input layer ~x represents the current state s , candidate action a , and document d . The second layer consists of two disjoint sets of units ~y and ~z which encode the sentence-relevance and predicate-labeling decisions respectively. Each of these sets of units operates as a stochastic 1 -of-n softmax selection layer (Bridle, 1990) where only a single unit is activated. The activation function for units in this layer is the standard softmax function: where y i is the i th hidden unit of ~y , and ~u i is the weight vector corresponding to y i . Given this acti-vation function, the second layer effectively models sentence relevance and predicate labeling decisions via log-linear distributions, the details of which are described below.

The third feature layer ~ f of the neural network is deterministically computed given the active units y i and z j of the softmax layers, and the values of the input layer. Each unit in this layer corresponds to a fixed feature function f k ( s t ,a t ,d,y i ,z j )  X  R nally the output layer encodes the action-value func-tion Q ( s,a,d ) , which now also depends on the doc-ument d , as a weighted linear combination of the units of the feature layer: where ~w is the weight vector.
 Modeling Sentence Relevance Given a strategy document d , we wish to identify a sentence y i that is most relevant to the current game state s t and ac-tion a t . This relevance decision is modeled as a log-linear distribution over sentences as follows: Here  X  ( y i ,s t ,a t ,d )  X  R n is a feature function, and ~u are the parameters we need to estimate.
 Modeling Predicate Structure Our goal here is to label the words of a sentence as either action-description , state-description or background . Since these word label assignments are likely to be mu-tually dependent, we model predicate labeling as a sequence prediction task. These dependencies do not necessarily follow the order of words in a sen-tence, and are best expressed in terms of a syn-tactic tree. For example, words corresponding to state-description tend to be descendants of action-description words. Therefore, we label words in de-pendency order  X  i.e., starting at the root of a given dependency tree, and proceeding to the leaves. This allows a word X  X  label decision to condition on the label of the corresponding dependency tree parent.
Given sentence y i and its dependency parse q i , we model the distribution over predicate labels ~e i as: Here e j is the predicate label of the j th word being labeled, and ~e 1: j  X  1 is the partial predicate labeling constructed so far for sentence y i .

In the second layer of the neural network, the units ~z represent a predicate labeling ~e i of every sen-tence y i  X  d . However, our intention is to incorpo-rate, into action-value function Q , information from only the most relevant sentence. Thus, in practice, we only perform a predicate labeling of the sentence selected by the relevance component of the model.
Given the sentence selected as relevant and its predicate labeling, the output layer of the network can now explicitly learn the correlations between textual information, and game states and actions  X  for example, between the word  X  X rassland X  in Fig-ure 1, and the action of building a city. This allows our method to leverage the automatically extracted textual information to improve game play. 4.2 Parameter Estimation Learning in our method is performed in an online fashion: at each game state s t , the algorithm per-forms a simulated game roll-out, observes the out-come of the game, and updates the parameters ~u , ~v and ~w of the action-value function Q ( s t ,a t ,d ) . These three steps are repeated a fixed number of times at each actual game state. The information from these roll-outs is used to select the actual game action. The algorithm re-learns Q ( s t ,a t ,d ) for ev-ery new game state s t . This specializes the action-value function to the subgame starting from s t .
Since our model is a non-linear approximation of the underlying action-value function of the game, we learn model parameters by applying non-linear regression to the observed final utilities from the simulated roll-outs. Specifically, we adjust the pa-rameters by stochastic gradient descent, to mini-mize the mean-squared error between the action-value Q ( s,a ) and the final utility R ( s  X  ) for each observed game state s and action a . The resulting update to model parameters  X  is of the form: where  X  is a learning rate parameter.

This minimization is performed via standard error backpropagation (Bryson and Ho, 1969; Rumelhart et al., 1986), which results in the following online updates for the output layer parameters ~w : where  X  w is the learning rate, and Q = Q ( s,a,d ) . The corresponding updates for the sentence rele-vance and predicate labeling parameters ~u and ~v are: We apply our model to playing the turn-based strat-egy game, Civilization II. We use the official man-ual 6 of the game as the source of textual strategy advice for the language aware algorithms.

Civilization II is a multi-player game set on a grid-based map of the world. Each grid location repre-sents a tile of either land or sea, and has various resources and terrain attributes. For example, land tiles can have hills with rivers running through them. In addition to multiple cities, each player controls various units  X  e.g., settlers and explorers. Games are won by gaining control of the entire world map. In our experiments, we consider a two-player game of Civilization II on a grid of 1000 squares, where we play against the built-in AI player.
 Game States and Actions We define the game state of Civilization II to be the map of the world, the at-tributes of each map tile, and the attributes of each player X  X  cities and units. Some examples of the at-tributes of states and actions are shown in Figure 3. The space of possible actions for a given city or unit is known given the current game state. The actions of a player X  X  cities and units combine to form the ac-tion space of that player. In our experiments, on av-erage a player controls approximately 18 units, and each unit can take one of 15 actions. This results in a very large action space for the game  X  i.e., 10 21 . To effectively deal with this large action space, we assume that given the state, the actions of a single unit are independent of the actions of all other units of the same player.
 Utility Function The Monte-Carlo algorithm uses the utility function to evaluate the outcomes of simulated game roll-outs. In the typical application of the algorithm, the final game outcome is used as the utility function (Tesauro and Galperin, 1996). Given the complexity of Civilization II, running sim-ulation roll-outs until game completion is impracti-cal. The game, however, provides each player with a game score , which is a noisy indication of how well they are currently playing. Since we are playing a two-player game, we use the ratio of the game score of the two players as our utility function.
 Features The sentence relevance features ~  X  and the action-value function features ~ f consider the at-tributes of the game state and action, and the words of the sentence. Some of these features compute text overlap between the words of the sentence, and text labels present in the game. The feature function ~  X  used for predicate labeling on the other hand oper-ates only on a given sentence and its dependency parse. It computes features which are the Carte-sian product of the candidate predicate label with word attributes such as type, part-of-speech tag, and dependency parse information. Overall, ~ f , ~  X  and ~  X  compute approximately 306,800, 158,500, and 7,900 features respectively. Figure 3 shows some examples of these features. Datasets We use the official game manual for Civi-lization II as our strategy guide. This manual uses a large vocabulary of 3638 words, and is composed of 2083 sentences, each on average 16.9 words long. Experimental Framework To apply our method to the Civilization II game, we use the game X  X  open source implementation Freeciv . 7 We instrument the game to allow our method to programmatically mea-sure the current state of the game and to execute game actions. The Stanford parser (de Marneffe et al., 2006) was used to generate the dependency parse information for sentences in the game manual.
Across all experiments, we start the game at the same initial state and run it for 100 steps. At each step, we perform 500 Monte-Carlo roll-outs. Each roll-out is run for 20 simulated game steps before halting the simulation and evaluating the outcome. For our method, and for each of the baselines, we run 200 independent games in the above manner, with evaluations averaged across the 200 runs. We use the same experimental settings across all meth-ods, and all model parameters are initialized to zero.
The test environment consisted of typical PCs with single Intel Core i7 CPUs (4 hyper-threaded cores each), with the algorithms executing 8 simula-tion roll-outs in parallel. In this setup, a single game of 100 steps runs in approximately 1.5 hours. Evaluation Metrics We wish to evaluate two as-pects of our method: how well it leverages tex-tual information to improve game play, and the ac-curacy of the linguistic analysis it produces. We evaluate the first aspect by comparing our method against various baselines in terms of the percent-age of games won against the built-in AI of Freeciv. This AI is a fixed algorithm designed using exten-sive knowledge of the game, with the intention of challenging human players. As such, it provides a good open-reference baseline. Since full games can last for multiple days, we compute the percentage of games won within the first 100 game steps as our pri-mary evaluation. To confirm that performance under this evaluation is meaningful, we also compute the percentage of full games won over 50 independent runs, where each game is run to completion. Method % Win % Loss Std. Err.
 Random 0 100  X  Built-in AI 0 0  X  Game only 17.3 5.3  X  2.7 Sentence relevance 46.7 2.8  X  3.5 Full model 53.7 5.9  X  3.5 Random text 40.3 4.3  X  3.4 Latent variable 26.1 3.7  X  3.1 Game performance As shown in Table 1, our lan-guage aware Monte-Carlo algorithm substantially outperforms several baselines  X  on average winning 53.7% of all games within the first 100 steps. The dismal performance, on the other hand, of both the random baseline and the game X  X  own built-in AI (playing against itself) is an indicator of the diffi-culty of the task. This evaluation is an underesti-mate since it assumes that any game not won within the first 100 steps is a loss. As shown in Table 2, our method wins over 78% of full length games.

To characterize the contribution of the language components to our model X  X  performance, we com-pare our method against two ablative baselines. The first of these, game-only , does not take advantage of any textual information. It attempts to model the action value function Q ( s,a ) only in terms of the attributes of the game state and action. The per-formance of this baseline  X  a win rate of 17.3%  X  effectively confirms the benefit of automatically ex-tracted textual information in the context of our task. The second ablative baseline, sentence-relevance , is identical to our model, but lacks the predicate label-ing component. This method wins 46.7% of games, showing that while identifying the text relevant to the current game state is essential, a deeper struc-tural analysis of the extracted text provides substan-tial benefits.

One possible explanation for the improved perfor-mance of our method is that the non-linear approx-imation simply models game characteristics better, rather than modeling textual information. We di-rectly test this possibility with two additional base-lines. The first, random-text , is identical to our full model, but is given a document containing random text. We generate this text by randomly permut-ing the word locations of the actual game manual, thereby maintaining the document X  X  overall statisti-cal properties. The second baseline, latent variable , extends the linear action-value function Q ( s,a ) of the game only baseline with a set of latent variables  X  i.e., it is a four layer neural network, where the sec-ond layer X  X  units are activated only based on game information. As shown in Table 1 both of these base-lines significantly underperform with respect to our model, confirming the benefit of automatically ex-tracted textual information in the context of this task. Sentence Relevance Figure 4 shows examples of the sentence relevance decisions produced by our method. To evaluate the accuracy of these decisions, we ideally require a ground-truth relevance annota-tion of the game X  X  user manual. This however, is impractical since the relevance decision is depen-dent on the game context, and is hence specific to each time step of each game instance. Therefore, for the purposes of this evaluation, we modify the game manual by adding to it sentences randomly selected from the Wall Street Journal corpus (Marcus et al., 1993)  X  sentences that are highly unlikely to be rel-evant to game play. We then evaluate the accuracy with which sentences from the original manual are picked as relevant.

In this evaluation, our method achieves an average accuracy of 71.8%. Given that our model only has to differentiate between the game manual text and the Wall Street Journal, this number may seem disap-pointing. Furthermore, as can be seen from Figure 5, the sentence relevance accuracy varies widely as the game progresses, with a high average of 94.2% dur-ing the initial 25 game steps.

In reality, this pattern of high initial accuracy fol-lowed by a lower average is not entirely surprising: the official game manual for Civilization II is writ-ten for first time players. As such, it focuses on the initial portion of the game, providing little strategy advice relevant to subsequence game play. 8 If this is the reason for the observed sentence relevance trend, we would also expect the final layer of the neural network to emphasize game features over text fea-tures after the first 25 steps of the game. This is indeed the case, as can be seen from Figure 6.
To further test this hypothesis, we perform an ex-periment where the first 50 steps of the game are played using our full model, and the subsequent 50 steps are played without using any textual informa-tion. This hybrid method performs as well as our full model, achieving a 53.3% win rate, confirm-ing that textual information is most useful during the initial phase of the game. This shows that our method is able to accurately identify relevant sen-tences when the information they contain is most pertinent to game play.
 Predicate Labeling Figure 4 shows examples of the predicate structure output of our model. We eval-uate the accuracy of this labeling by comparing it against a gold-standard annotation of the game man-ual. Table 3 shows the performance of our method in terms of how accurately it labels words as state , action or background , and also how accurately it dif-ferentiates between state and action words. In ad-dition to showing a performance improvement over the random baseline, these results display two clear trends: first, under both evaluations, labeling accu-racy is higher during the initial stages of the game. This is to be expected since the model relies heav-ily on textual features only during the beginning of the game (see Figure 6). Second, the model clearly performs better in differentiating between state and action words, rather than in the three-way labeling.
To verify the usefulness of our method X  X  predi-cate labeling, we perform a final set of experiments where predicate labels are selected uniformly at ran-dom within our full model. This random labeling results in a win rate of 44%  X  a performance similar to the sentence relevance model which uses no pred-icate information. This confirms that our method is able identify a predicate structure which, while noisy, provides information relevant to game play. Method S/A/B S/A Random labeling 33.3% 50.0% Model, first 100 steps 45.1% 78.9% Model, first 25 steps 48.0% 92.7% Figure 7 shows examples of how this textual infor-mation is grounded in the game, by way of the asso-ciations learned between words and game attributes in the final layer of the full model. In this paper we presented a novel approach for improving the performance of control applications by automatically leveraging high-level guidance ex-pressed in text documents. Our model, which op-erates in the Monte-Carlo framework, jointly learns to identify text relevant to a given game state in ad-dition to learning game strategies guided by the se-lected text. We show that this approach substantially outperforms language-unaware alternatives while learning only from environment feedback.
 The authors acknowledge the support of the NSF (CAREER grant IIS-0448168, grant IIS-0835652), DARPA Machine Reading Program (FA8750-09-C-0172) and the Microsoft Research New Faculty Fellowship. Thanks to Michael Collins, Tommi Jaakkola, Leslie Kaelbling, Nate Kushman, Sasha Rush, Luke Zettlemoyer, the MIT NLP group, and the ACL reviewers for their suggestions and com-ments. Any opinions, findings, conclusions, or rec-ommendations expressed in this paper are those of the authors, and do not necessarily reflect the views of the funding organizations.
