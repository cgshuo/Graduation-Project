 Probabilistic synchronous context-free grammars (PSCFGs) define weighted production rules that are automatically learned from parallel training data. As in classical CFGs, these rules make use of nontermi-nal symbols to generalize beyond lexical modeling of sentences. In MT, this permits translation and re-ordering to be conditioned on more abstract notions of context. For example, represents the discontiguous translation of the French words  X  X e X  and  X  X as X  to  X  X o not X , in the con-text of the labeled nonterminal symbol  X  X B X  (rep-resenting syntactic category  X  X erb X ). Translation with PSCFGs is typically expressed as the problem of finding the maximum-weighted derivation consis-tent with the source sentence, where the scores are defined (at least in part) by R -valued weights asso-ciated with the rules. A PSCFG derivation is a syn-chronous parse tree.

Defining the translation function as finding the best derivation has the unfortunate side effect of forcing differently-derived versions of the same tar-get sentence to compete with each other. In other words, the true score of each translation is  X  X rag-mented X  across many derivations, so that each trans-lation X  X  most probable derivation is the only one that matters. The more Bayesian approach of finding the most probable translation (integrating out the derivations) instantiates an NP-hard inference prob-lem even for simple word-based models (Knight, 1999); for grammar-based translation it is known as the consensus problem (Casacuberta and de la Higuera, 2000; Sima X  X n, 2002).

With weights interpreted as probabilities, the maximum-weighted derivation is the maximum a posteriori (MAP) derivation: where f is the source sentence, e ranges over tar-get sentences, and d ranges over PSCFG deriva-tions (synchronous trees). This is often described as an approximation to the most probable transla-tion, argmax will describe a technique that aims to find the most probable equivalence class of unlabeled derivations, rather than a single labeled derivation, reducing the fragmentation problem. Solving this problem ex-actly is still an NP-hard consensus problem, but we provide approximations that build on well-known PSCFG decoding methods. Our model falls some-where between PSCFGs that extract nonterminal symbols from parse trees and treat them as part of the derivation (Zollmann and Venugopal, 2006) and unlabeled hierarchical structures (Chiang, 2005); we treat nonterminal labels as random variables chosen at each node, with each (unlabeled) rule express-ing  X  X references X  for particular nonterminal labels, learned from data.

The paper is organized as follows. In Section 2, we summarize the use of PSCFG grammars for translation. We describe our model (Section 3). Section 4 explains the preference-related calcula-tions, and Section 5 addresses decoding. Experi-mental results using preference grammars in a log-linear translation model are presented for two stan-dard Chinese-to-English tasks in Section 6. We re-view related work (Section 7) and conclude. Probabilistic synchronous context-free grammars (PSCFGs) are defined by a source terminal set (source vocabulary) T S , a target terminal set (target vocabulary) T T , a shared nonterminal set N and a set R of rules of the form: X  X  X   X , X ,w  X  where  X  X  X  X  is a labeled nonterminal referred to as the left-hand-side of the rule.  X   X   X  ( N  X  X  S )  X  is the source side of the rule.  X   X   X  ( N  X  X  T )  X  is the target side of the rule.  X  w  X  [0 ,  X  ) is a nonnegative real-valued weight assigned to the rule.
 For visual clarity, we will use the # character to sep-arate the source side of the rule  X  from the target side  X  . PSCFG rules also have an implied one-to-one mapping between nonterminal symbols in  X  and nonterminals symbols in  X  . Chiang (2005), Zoll-mann and Venugopal (2006) and Galley et al. (2006) all use parameterizations of this PSCFG formalism 1 .
Given a source sentence f and a PSCFG G , the translation task can be expressed similarly to mono-lingual parsing with a PCFG. We aim to find the most likely derivation d of the input source sentence and read off the English translation, identified by composing  X  from each rule used in the derivation. This search for the most likely translation under the MAP approximation can be defined as: where tgt( d ) is the target-side yield of a derivation d , and D ( G ) is the set of G  X  X  derivations. Using an n -gram language model to score derivations and rule labels to constraint the rules that form derivations, we define p ( d ) as log-linear model in terms of the rules r  X  X  used in d as: p i ( d ) = p where ~  X  =  X  0  X  X  X   X  m +1 are weights that reflect the relative importance of features in the model. The features include the n -gram language model (LM) score of the target yield sequence, a collection of m rule feature functions h i : R  X  R  X  0 , and a  X  X yn-tax X  feature that (redundantly) requires every non-terminal token to be expanded by a rule with that nonterminal on its left-hand side. freq( r ; d ) denotes the frequency of the rule r in the derivation d . Note that  X  m +1 can be effectively ignored when p syn is defined as in Equation 3. Z ( ~  X  ) is a normalization constant that does not need to be computed during search under the argmax search criterion in Equa-tion 1. Feature weights ~  X  are trained discrimina-tively in concert with the language model weight to maximize the BLEU (Papineni et al., 2002) au-tomatic evaluation metric via Minimum Error Rate Training (MERT) (Och, 2003).

We use the open-source PSCFG rule extraction framework and decoder from Zollmann et al. (2008) as the framework for our experiments. The asymp-totic runtime of this decoder is: where K is the maximum number of nonterminal symbols per rule, | f | the source sentence length, and n is the order of the n -gram LM that is used to com-pute p LM . This constant factor in Equation 4 arises from the dynamic programming item structure used to perform search under this model. Using notation from Chiang (2007), the corresponding item struc-ture is: where X is the nonterminal label of a derivation, i,j define a span in the source sentence, and q (  X  ) main-tains state required to compute p LM (  X  ) . Under the MAP criterion we can discard derivations of lower weight that share this item structure, but in practice we often require additional lossy pruning to limit the number of items produced. The Syntax-Augmented MT model of Zollmann and Venugopal (2006), for instance, produces a very large nonterminal set us-ing  X  X lash X  (NP/NN  X  the great ) and  X  X lus X  labels (NP+VB  X  she went ) to assign syntactically mo-tivated labels for rules whose target words do not correspond to constituents in phrase structure parse trees. These labels lead to fragmentation of prob-ability across many derivations for the same target sentence, worsening the impact of the MAP approx-imation. In this work we address the increased frag-mentation resulting from rules with labeled nonter-minals compared to unlabeled rules (Chiang, 2005). We extend the PSCFG formalism to include soft  X  X a-bel preferences X  for unlabeled rules that correspond to alternative labelings that have been encountered in training data for the unlabeled rule form. These preferences, estimated via relative frequency counts from rule occurrence data, are used to estimate the feature p syn ( d ) , the probability that an unlabeled derivation can be generated under traditional syn-tactic constraints. In classic PSCFG, p syn ( d ) en-forces a hard syntactic constraint (Equation 3). In our approach, label preferences influence the value of 3.1 Motivating example Consider the following labeled Chinese-to-English PSCFG rules: (4) S  X  (  X   X  VB (3) S  X  (  X   X  VP (2) SBAR  X  (  X   X  VP (1) FRAG  X  (  X   X  AUX (8) VB  X  m # eat (1) VP  X  m # eat (1) NP  X  m # eat (10) NN  X  m # dish where the numbers are frequencies of the rule from the training corpus. In classical PSCFG we can think of the nonterminals mentioned in the rules as hard constraints on which rules can be used to expand a particular node; e.g., a VP can only be expanded by a VP rule. In Equation 2, p syn ( d ) explicitly enforces this hard constraint. Instead, we propose softening these constraints. In the rules below, labels are rep-resented as soft preferences. (10) X  X  (  X   X  X (10) X  X  m # eat (10) X  X  m # dish Each unlabeled form of the rule has an associated distribution over labels for the nonterminals refer-enced in the rule; the labels are random variables H i , with H 0 the left-hand-side label. These un-labeled rule forms are simply packed representa-tions of the original labeled PSCFG rules. In ad-dition to the usual features h i ( r ) for each rule, esti-mated based on unlabeled rule frequencies, we now have label preference distributions. These are esti-mated as relative frequencies from the labelings of the base, unlabeled rule. Our primary contribution is how we compute p syn ( d )  X  X he probability that an unlabeled derivation adheres to traditional syn-tactic constraints X  X or derivations built from prefer-ence grammar rules. By using p syn ( d ) as a feature in the log-linear model, we allow the MERT frame-work to evaluate the importance of syntactic struc-ture relative to other features.

The example rules above highlight the potential for p syn ( d ) to affect the choice of translation. The translation of the Chinese word sequence (  X   X  m can be performed by expanding the non-terminal in the rule  X  X  place where I can X 1  X  with either  X  X at X  or  X  X ish. X  A hierarchical system (Chi-ang, 2005) would allow either expansion, relying on features like p LM to select the best translation since both expansions occurred the same number of times in the data.
 A richly-labeled PSCFG as in Zollmann and Venugopal (2006) would immediately reject the rule generating  X  X ish X  due to hard label matching con-straints, but would produce three identical, compet-ing derivations. Two of these derivations would pro-duce S as a root symbol, while one derivation would produce SBAR. The two S-labeled derivations com-pete, rather than reinforce the choice of the word  X  X at, X  which they both make. They will also com-pete for consideration by any decoder that prunes derivations to keep runtime down.

The rule preferences indicate that VB and VP are both valid labels for the rule translating to  X  X at X , and both of these labels are compatible with the argu-ments expected by  X  X  place where I can X 1  X . Al-ternatively,  X  X ish X  produces a NN label which is not compatible with the arguments of this higher-up rule. We design p syn ( d ) to reflect compatibility between two rules (one expanding a right-hand side nonterminal in the other), based on label preference distributions. 3.2 Formal definition Probabilistic synchronous context-free preference grammars are defined as PSCFGs with the follow-ing additional elements:  X  H : a set of implicit labels, not to be confused  X   X  : H X  X  , a function that associates each im- X  For each rule r , we define a probability distri-
When N , H are defined to include just a single generic symbol as in (Chiang, 2005), we produce the unlabeled grammar discussed above. In this work, we define  X  N = { S,X }  X  H = { NP , DT , NN  X  X  X } = N SAMT where N corresponds to the generic labels of Chi-ang (2005) and H corresponds to the syntactically motivated SAMT labels from (Zollmann and Venu-gopal, 2006), and  X  maps all elements of H to X . We will use hargs( r ) to denote the set of all ~ h =  X  h for the rule with nonzero preference probability.
The preference distributions p pref from each rule used in d are used to compute p syn ( d ) as described next. Let us view a derivation d as a collection of nonter-minal tokens n j , j  X  { 1 ,..., | d |} . Each n j takes an explicit label in N . The score p syn ( d ) is a product, with one factor per n j in the derivation d : Each  X  j factor considers the two rules that n j partic-ipates in. We will refer to the rule above nonterminal token n j as r and the rule that expands nonterminal token j as r j .
The intuition is that derivations in which these two rules agree (at each j ) about the implicit label for n j , in H are preferable to derivations in which they do not. Rather than making a decision about the implicit label, we want to reward p syn when r and r consistency is an inner product of preference distri-butions: This is not quite the whole story, because p pref (  X | r ) is defined as a joint distribution of all the implicit labels within a rule; the implicit labels are not in-dependent of each other. Indeed, we want the im-plicit labels within each rule to be mutually consis-tent, i.e., to correspond to one of the rule X  X  preferred labelings, for both hargs( r ) and hargs( r ) .
Our approach to calculating p syn within the dy-namic programming algorithm is to recursively cal-culate preferences for each chart item based on (a) the smaller items used to construct the item and (b) the rule that permits combination of the smaller items into the larger one. We describe how the pref-erences for chart items are calculated. Let a chart item be denoted [ X,i,j,u,... ] where X  X  N and i and j are positions in the source sentence, and (where possible X -refinement labels. We will refer to it below as the left-hand-side preference distribution . Additional information (such as language model state) may also be included; it is not relevant here.
The simplest case is for a nonterminal token n j that has no nonterminal children. Here the left-hand-side preference distribution is simply given by and we define the p syn factor to be  X  j = 1 .
Now consider the dynamic programming step of combining an already-built item [ X,i,j,u,... ] rooted by explicit nonterminal X , spanning source sentence positions i to j , with left-hand-side prefer-ence distribution u , to build a larger item rooted by Y through a rule r = Y  X  X   X X 1  X  0 , X X 1  X  0 ,w  X  with preferences p pref (  X  | r ) . 2 The new item will have signature [ Y,i  X  X   X  | ,j + |  X  0 | ,v,... ] . The left-hand-side preferences v for the new item are calculated as follows: v ( h ) =  X  v ( h ) = Renormalizing keeps the preference vectors on the same scale as those in the rules. The p syn factor  X  , which is factored into the value of the new item, is calculated as: so that the value considered for the new item is w  X   X   X  ... , where factors relating to p LM , for example, may also be included. Coming back to our example, if we let r be the leaf rule producing  X  X at X  at shared nonterminal n 1 , we generate an item with: u =  X  u ( VB ) = 0 . 8 ,u ( VP ) = 0 . 1 ,u ( NP ) = 0 . 1  X  Combining this item with X  X   X  (  X   X  X 1 # a place where I can X 1  X  as r generates a new target item with translation  X  X  place where I can eat X ,  X  2 = 0 . 9 and v as calculated in Fig. 1. In contrast,  X  2 = 0 for the derivation where r is the leaf rule that produces  X  X ish X .

This calculation can be seen as a kind of single-pass, bottom-up message passing inference method embedded within the usual dynamic programming search. As defined above, accurately computing p syn ( d ) re-quires extending the chart item structure with u . For models that use the n -gram LM feature, the item structure would be: Since u effectively summarizes the choice of rules in a derivation, this extension would partition the search space further . To prevent this partitioning, we follow the approach of Venugopal et al. (2007). We keep track of u for the best performing derivation from the set of derivations that share [ X,i,j,q (  X  )] in a first-pass decoding. In a second top-down pass similar to Huang and Chiang (2007), we can recal-culate p syn ( d ) for alternative derivations in the hy-pergraph; potentially correcting search errors made in the first pass.

We face another significant practical challenge during decoding. In real data conditions, the size of the preference vector for a single rule can be very high, especially for rules that include multiple non-terminal symbols that are located on the left and right boundaries of  X  . For example, the Chinese-to-English rule X  X   X  X 1  X  X 2 # X 1  X  X  X 2  X  has over 24K elements in hargs( r ) when learned for the medium-sized NIST task used below. In order to limit the explosive growth of nonterminals during decoding for both memory and runtime reasons, we define the following label pruning parameters:  X   X  R : This parameter limits the size of hargs( r ) to the  X  R top-scoring preferences, defaulting other values to zero.  X   X  L : This parameter is the same as  X  R but applied only to rules with no nonterminals. The stricter of  X  L and  X  R is applied if both thresholds apply.  X   X  P : This parameter limits the number labels in item preference vectors (Equation 8) to the  X  P most likely labels during decoding, defaulting other preferences to zero. We evaluate our preference grammar model on small (IWSLT) and medium (NIST) data Chinese-to-English translation tasks (described in Table 1). IWSLT is a limited domain, limited resource task (Paul, 2006), while NIST is a broadcast news task with wide genre and domain coverage. We use a subset of the full training data (67M words of En-glish text) from the annual NIST MT Evaluation. Development corpora are used to train model pa-rameters via MERT. We use a variant of MERT that prefers sparse solutions where  X  i = 0 for as many features as possible. At each MERT iteration, a sub-set of features  X  are assigned 0 weight and optimiza-tion is repeated. If the resulting BLEU score is not lower, these features are left at zero.

All systems are built on the SAMT framework described in Zollmann et al. (2008), using a tri-gram LM during search and the full-order LM dur-ing a second hypergraph rescoring pass. Reorder-ing limits are set to 10 words for all systems. Prun-ing parameters during decoding limit the number of derivations at each source span to 300.

The system  X  X ier. X  uses a grammar with a single nonterminal label as in Chiang (2005). The system  X  X yntax X  applies the grammar from Zollmann and Venugopal (2006) that generates a large number of syntactically motivated nonterminal labels. For the NIST task, rare rules are discarded based on their frequency in the training data. Purely lexical rules (that include no terminal symbols) that occur less than 2 times, or non-lexical rules that occur less than 4 times are discarded.

IWSLT task: We evaluate the preference gram-mar system  X  X ref. X  with parameters  X  R = 100 ,  X  to Hier. and Syntax are shown in Table 2. Auto-matic evaluation results using the preference gram-mar translation model are positive. The preference grammar system shows improvements over both the Hier. and Syntax based systems on both unseen eval-uation sets IWSLT 2007 and 2008. The improve-ments are clearest on the BLEU metric (matching the MERT training criteria). On 2007 test data, Pref. shows a 1.2-point improvement over Hier., while on the 2008 data, there is a 0.6-point improve-ment. For the IWSLT task, we report additional au-tomatic evaluation metrics that generally rank the Pref. system higher than Hier. and Syntax. As a fur-ther confirmation, our feature selection based MERT chooses to retain  X  m +1 in the model. While the IWSLT results are promising, we perform a more complete evaluation on the NIST translation task.
NIST task : This task generates much larger rule preference vectors than the IWSLT task simply due to the size of the training corpora. We build sys-tems with both  X  R = 100 , 10 varying  X  P . Vary-ing  X  P isolates the relative impact of propagating alternative nonterminal labels within the preference grammar model.  X  L = 5 for all NIST systems. Pa-rameters  X  are trained via MERT on the  X  R = 100 ,  X  preference grammar and baseline system are shown in Table 3, along with translation times on the test corpus. We also report length penalties to show that improvements are not simply due to better tuning of output length.
 The preference grammar systems outperform the Hier. baseline by 0.5 points on development data, and upto 0.8 points on unseen test data. While sys-tems with  X  R = 100 take significantly longer to translate the test data than Hier., setting  X  R = 10 takes approximately as long as the Syntax based sys-tem but produces better slightly better results (0.3 points).

The improvements in translation quality with the preference grammar are encouraging, but how much of this improvement can simply be attributed to MERT finding a better local optimum for parame-ters  X  ? To answer this question, we use parameters  X  system to run a purely hierarchical system, denoted decoding. While almost half of the improvement comes from better parameters learned via MERT for the preference grammar systems, 0.5 points can be still be attributed purely to the feature p syn . In addi-tion, MERT does not set parameter  X  m +1 to 0, cor-roborating the value of the p syn feature again. Note system which was trained via MERT without p syn . This highlights the local nature of MERT parameter search, but also points to the possibility that train-ing with the feature p syn produced a more diverse derivation space, resulting in better parameters  X  . We see a very small improvement (0.1 point) by al-lowing the runtime propagation of more than 1 non-terminal label in the left-hand side posterior distribu-tion, but the improvement doesn X  X  extend to  X  P = 5 . Improved integration of the feature p syn ( d ) into de-coding might help to widen this gap. There have been significant efforts in the both the monolingual parsing and machine translation liter-ature to address the impact of the MAP approxi-mation and the choice of labels in their respective models; we survey the work most closely related to our approach. May and Knight (2006) extract n -best lists containing unique translations rather than unique derivations, while Kumar and Byrne (2004) use the Minimum Bayes Risk decision rule to se-lect the lowest risk (highest BLEU score) translation rather than derivation from an n-best list. Tromble et al. (2008) extend this work to lattice structures. All of these approaches only marginalize over alter-native candidate derivations generated by a MAP-driven decoding process. More recently, work by Blunsom et al. (2007) propose a purely discrimina-tive model whose decoding step approximates the selection of the most likely translation via beam search. Matsusaki et al. (2005) and Petrov et al. (2006) propose automatically learning annotations that add information to categories to improve mono-lingual parsing quality. Since the parsing task re-quires selecting the most non-annotated tree, the an-notations add an additional level of structure that must be marginalized during search. They demon-strate improvements in parse quality only when a variational approximation is used to select the most likely unannotated tree rather than simply stripping annotations from the MAP annotated tree. In our work, we focused on approximating the selection of the most likely unlabeled derivation during search, rather than as a post-processing operation; the meth-ods described above might improve this approxima-tion, at some computational expense. We have proposed a novel grammar formalism that replaces hard syntactic constraints with  X  X oft X  pref-erences. These preferences are used to compute a machine translation feature ( p syn ( d ) ) that scores un-labeled derivations, taking into account traditional syntactic constraints. Representing syntactic con-straints as a feature allows MERT to train the cor-responding weight for this feature relative to others in the model, allowing systems to learn the relative importance of labels for particular resource and lan-guage scenarios as well as for alternative approaches to labeling PSCFG rules.

This approach takes a step toward addressing the fragmentation problems of decoding based on maximum-weighted derivations, by summing the contributions of compatible label configurations rather than forcing them to compete. We have sug-gested an efficient technique to approximate p syn ( d ) that takes advantage of a natural factoring of deriva-tion scores. Our approach results in improvements in translation quality on small and medium resource translation tasks. In future work we plan to focus on methods to improve on the integration of the p syn ( d ) feature during decoding and techniques that allow us consider more of the search space through less prun-ing.
 We appreciate helpful comments from three anony-mous reviewers. Venugopal and Zollmann were sup-ported by a Google Research Award. Smith was sup-ported by NSF grant IIS-0836431.
