 Many data stream monitoring applications involve rank queries and hence a number of ef fi cient evaluation algorithms are proposed re-cently. Most of these techniques assume that rank queries are exe-cuted directly over the whole data space. However, we observe that many applications often require to perform clustering over the data streams before rank queries are run on each cluster.

To address the problem, we propose a novel algorithm for in-tegral clustering and ranking processing and we refer to such in-tegrated queries as cluster-based rank queries . The algorithm in-cludes two phases, namely the online phase which maintains the required data structures and statistics, and the query phase which uses these data structures to process queries. Extensive experiments indicate that the proposed algorithm is ef fi cient in both space con-sumption and query processing.
 H.2.8 [ Information Systems ]: Database Management X  Database applications [Data mining] Algorithms, Experimentation, Performance multidimensional data stream, rank query, clustering, sliding win-dow
A conventional rank query over data streams is de fi ned as, given a rank r and a data stream D ,to fi nd the rank r data element among the data within a window with size N over the data stream (slid-ing window model), or within the whole data stream (landmark model). Rank queries over data streams have many applications, including sensor network monitoring, network management, stock monitoring, and web applications, etc, and hence it attracts many researchers X  attention in recent years [5, 6, 8, 2].

In data stream environments, rank queries are always studied in the form of quantile computation. Consider a data set DS data elements are sorted according to a monotonic order. An approximate  X  -quantile query over DS is said to be the element with the rank between (  X   X   X  ) N and (  X  +  X  ) N . Among all the techniques proposed for quantile computations over data streams, GK algorithm[5] is perhaps the most widely used due to its ease of understanding and use. Based on it, many improvements are intro-duced. Particularly, Xuemin Lin et al.[8] fi rst studied the problem of rank query over sliding window, GK algorithm was used as a ba-sic component in their new algorithm. Greenwald[6] also extends their previous work to sensor networks and proposes merging algo-rithm and compressing algorithm for GK-summaries[5].

While the conventional rank query de fi nition has its applicability, many applications require more complex rank queries. In particu-lar, it is often of interest to perform a rank query on a clustering of the data, i.e. to fi nd the rank r element within each cluster.
Example: Consider an online shopping website, the transaction records constitute a data stream. One might be interested to study the distribution of the ages of different categories of buyers for a particularly hot product. To do so, one has to perform online clus-tering on the pro fi les of the buyers who have purchased this product and perform a rank query on the buyers X  ages over each of these clusters.

We refer to this type of query as cluster-based rank query .Asa naive solution, one can evaluate such queries by performing cluster-ing on the streams followed by running a rank query on each clus-ter. However, after investigation, we fi nd such a two-step approach is inef fi cient in both time and space. Basically, we have to keep all the tuples in the clustering step and run the rank query on these tuples in the second step. Therefore, we propose new techniques to process both clustering and ranking in one integral step. Such an integration of clustering and ranking is non-trivial. The main should be maintained in the cluster level. A new data structure that can keep both clustering statistics and ranking statistics at the same time is needed. This data structure should support query answer-ing with high clustering quality, precision guarantee, and minimum space and time consumption.

In [7], Li et al. present a technique called ClusterRank, which also partitions the data into K clusters and do rank query on each partition. This work differs from ours mainly in two aspects. First, ClusterRank is proposed for traditional database systems, which cannot be readily applied for handling data streams. Second, Clus-terRank focuses on exact top-k queries, while our approach can return elements with any rank under a precision of  X N . A cluster-based rank query Q can be de fi ned formally as follows:
A cluster-based rank query is that given a tuple n, C ,K,R,r for every sliding window with size n , cluster the data elements in the window into K clusters based on the set of clustering attributes C and return the rank r data element from each cluster based on the ranking attribute R .

In typical application scenarios, it is desirable to allow users to issue cluster-based rank queries with different rank r and window size n at anytime. Therefore, we have to continuously maintain generate the result promptly when a user issue a query. Therefore, the processing of queries can be naturally divided into two phases: the online phase, which maintains compacted statistics, and the query phase, which produces the rank results when a query comes.
Below, we summarize the symbols which will be used in the rest of our paper in Table 1.
 Symbol Comments D A multidimensional data stream X =[ x 1 , ..., x d ] A data element with d dimensions X i A data element with timestamp i N Maximum sliding window size
R The ranking attribute  X  Guaranteed error precision
C Clustering attributes c The number of clustering attributes
K The number of clusters  X  Rank query parameter,  X   X  [0 , 1] n Rank query window, n  X  N
M The number of tuples in level-0 bucket  X  Control the number of buckets in each level L Highest level number B Largest GK-summary size
We d e fi ne a new data structure named Cluster based Quantile summaries (CQ). CQ is maintained for each cluster rather than for the global data stream. Before introducing this data structure, we have to de fi ne two other data structures fi rst, namely PCF (Partial Cluster Feature) and GK-summary(i).

De fi nition 1. Partial Cluster Feature (PCF( c, C )) A Partial Clus-ter Feature PCF ( c, C ) for a data stream D ,isde fi ned as a 2  X  (  X   X  X  X   X 
CF 2 x , C is the set of clustering attributes.  X   X  X  X   X 
CF 2 x and data elements from D , and
The center of the PCF X c is de fi ned as: X c = with the same clustering attributes can be merged together. Con-sidering two PCFs, PCF1 = (  X   X  X  X   X  CF 1 x 2 ), merge these two PCFs can result in a PCF = (  X   X  X  X   X  CF 2 x 2 ,CF 1 x 1 +
De fi nition 2. GK-summary(i) A GK-summary(i) for D, is a quan-tile summary maintained by GK-algorithm on its i-dimension. In our multi-dimensional data stream environment, user can specify any attribute to do a rank query.

De fi nition 3. Cluster based Quantile summary (CQ) ACQ n is the number of elements in this CQ. PCF is the n elements X  partial cluster feature. Both GK  X  summary ( i ) and List ( i ) used to represent the ranking attribute, GK  X  summary ( i ) culated from List ( i ) . t is the time stamp of the most recent data element in the CQ.
Operation 1. CQ Updating 1. This operation will be executed when one wants to add a new tuple into a CQ structure. This op-eration includes updating the PCF synopsis, incrementing n and setting t as the time stamp of the new tuple. Furthermore, the i th attribute of the new tuple is inserted into List ( i )
Operation 2. CQ Updating 2. This operation calculates GK-summary ( i ) over List ( i ) . After this operation, List ( i ) and set free.

Operation 3. CQ Merging. Merging of CQ synopses is used to improve query performance and bound the memory usage. Sup-pose we have two CQ synopses: and and we need to merge them into CQ synopsis CQ =( n, P CF, GK summary, List, t ) . Firstly, partial cluster feature in CQ 2 are merged together. Then two GK-summaries are merged us-ing the GK-merge algorithm. List is set to be empty. n = n and t = max ( t 1 ,t 2 ) .
This section presents a time-and space-ef fi cient algorithm for continuous CQ synopses maintenance. The algorithm maintains a number of buckets, which are organized into a multi-level struc-described as follows: 1. Initially, there are only level-0 buckets and, at any given time, 2. When we  X  X nsert X  a tuple into an active bucket, we do not
Figure 1: Multi-Level Bucket Processing for CQ Maintaining 3. When the active bucket is full, update operation 2 is exe-5. There are at most L bucket levels, when the number of level-
Figure 1 gives an overview of our algorithm. There are L levels of buckets. Buckets at higher levels provides summaries of older tuples. Each bucket in level l , is created by merging two buckets at level l  X  1 .
Figure 2 shows the functionality of our algorithm. Newly com-the active bucket is full, we compute the GK-summaries for each CQ synopsis by traversing the linked list of the ranking attribute oldest constructed buckets will be merged into one level i +1 (Lines 19-22). We have to merge the 2 K CQs into K CQs. Since there are 2 K virtual points, weighted K-means algorithm cannot be used here. Therefore, we employ Furthest Point algorithm [4]. The GK-summaries are also merged accordingly. GK-summaries in the new merged CQ synopsis have bounded size ( B +1) . If the bound is exceeded, GK-compress algorithm is used (line 21).
User can issue rank queries at any time. The input parameters are (  X , n ) , where  X  (  X   X  (0 , 1]) is the query quantile and n ( n speci fi es the query window size.

When a query arrives, a temporal mature bucket B current is cal-culated from the current active bucket. Based the window size we can deduce all the buckets that are involved in answering the query in the various levels. Speci fi cally, we have to deduce of the query window. Then, an operation of clustering the buck-After clustering, GK-summaries belonging to the same cluster are merged together. The fi nal bucket B final can be used to answer the query. Lastly, based on the parameter  X  , the  X  -quantile data element in each cluster is returned together with cluster X  X  informa-tion, including center, radius and data elements X  number. Figure 2: Multi-Level Bucket Processing CQ Maintaining Al-gorithm
We brie fl y give the theoretical analysis of various properties of our algorithm here, including the precision guarantee, space com-plexity, and time complexity.

T HEOREM 1. The algorithm always produces an  X  -approximate result for a rank query when the query window size n satis fi es T HEOREM 2. At any time, the algorithm requires a space of T HEOREM 3. The online phase of our algorithm runs in time. The query phase of our algorithm runs in time ( T is the iterator time for K-means algorithm).
 For the simplicity reason, we omit the detailed proofs here.
Since there is no existing solution for cluster-based rank queries in a data stream environment, we use a naive solution called CLUGK (a) Maximum Window N (M Tu-ples) algorithm for comparison. CLUGK algorithm simply combines CLUStream algorithm[1] and GK algorithm[5] in a two-step fash-ion. In the following experiments, we focus on the comparisons of space complexity and query ef fi ciency between CLUGK algorithm and the algorithm we proposed.
 Our experiments are conducted on a Laptop with a 1.83GHz CPU and 2GB of RAM, which runs Windows XP operating sys-tem. All the algorithms are implemented in C++.

In the experiments, we use the data generator proposed in [3] ing attributes and ranking attribute are independently created. For each cluster, the generator maintains an underlying data model, which contains a fi xed number of Gaussian distributions one for each clustering attribute. The means and variances of these Gaus-sian distribution models are uniformly sampled from the intervals [-5, 5] and [0.7, 1.5] respectively. When generating a new tuple, a data model is fi rst selected and then the values for the clustering attributes are generated following the Gaussian distributions. The ranking attribute is generated by another Gaussian data model.
First we measure the space complexity of our algorithm. To obtain a more comprehensive understanding, we conduct several groups of experiments by comparing our algorithm with CLUGK algorithm. In these experiments, we want to measure the space complexity of our algorithm under different N and M , so other parameters such as c , K ,  X  are set to be fi xed values.
Figure 3(a) and 3(b) show these experiments. Both fi gures show that our algorithm is much more space-ef fi cient than CLUGK al-gorithm. As the maximum sliding window increases, the space complexity of our algorithm increases very slowly, which suggests our algorithm has good scalability over parameter N .
Now we present the results on query ef fi ciency. The query ef-fi ciency is measured by the latency from the query arrival to the results are produced. In data stream processing, this latency should be minimized to achieve real-time response. We compare our query algorithm with CLUGK algorithm X  X  of fl ine part with several groups of experiments. Again, we fi x some parameters which are less rele-vant, such as N , K , and c . The other three parameters n be varied.

Figure 3(c) and 3(d) show the results of the query ef fi ciency com-parisons. In Figure 3(c), we set the query window n to 1 M tuples and vary parameters M and  X  . From which we can see that, for different settings of M and  X  , our algorithm always performs much better than CLUGK algorithm. Now we set M and  X  to their de-fault values (i.e. M = 2000 ,  X  =0 . 025 ) and vary query window n . Figure 3(d) presents the query-ef fi ciency comparisons based on different query window sizes. We can conclude from this fi gure that our algorithm converges much faster than CLUGK algorithm.
In this paper, we have studied the problem of integral clustering and ranking processing over data streams and we call such queries as cluster-based rank queries . We observed that a simple integra-tion of existing clustering and ranking techniques is inadequate to solve the problem. Hence we proposed a Multi-Level Bucket Pro-cessing algorithm for ef fi cient cluster-based rank query processing. The algorithm could produce  X  -approximate query answers with low space and time consumption. Experiments showed that our algorithm provided high throughput data processing and ef fi cient rank query answering.
The project was supported in part by the National Science Foun-dation of China (NSFC Grant No. 60603044 and 60803003) and by Chang-Jiang Scholars and Innovative Research Grant (IRT0652) at Zhejiang University. [1] C. C. Aggarwal, J. Han, J. Wang, and P. S. Yu. A framework [2] G. Cormode, F. Korn, S. Muthukrishnan, and D. Srivastava. [3] F. Farnstrom, J. Lewis, and C. Elkan. Scalability for [4] T. F. Gonzalez. Clustering to minimize the maximum [5] M. Greenwald and S. Khanna. Space-ef fi cient online [6] M. Greenwald and S. Khanna. Power-conserving [7] C. Li, M. Wang, L. Lim, H. Wang, and K. C.-C. Chang. [8] X. Lin, H. Lu, J. Xu, and J. X. Yu. Continuously maintaining
