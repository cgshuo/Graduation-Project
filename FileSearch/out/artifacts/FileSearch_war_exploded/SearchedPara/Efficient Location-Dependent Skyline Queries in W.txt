 The ever growing popularity of mobile devices and rapid advent of wireless technolo-gy have given rise to a new class of mobile services, i.e., location-based services (LBS). LBS enable users of mobile devices equipped with GPS to search for facilities such as car-parks, shops and restaurants close to their route. In general, mobile clients send location-dependent queries to an LBS server from where the corresponding loca-tion-related information is returned as query results. Conventional location-dependent queries (e.g., range query and k nearest neighbor query) purely focus on the proximity of objects and hence may not be sufficient for some complex decision-making appli-cations that involve both spatial proximity and non-spatial attributes of objects. Moti-vated by this observation, a new type of location-dependent queries called location-dependent skyline query ( LDSQ ) was recently proposed [1, 2]. LDSQ synthesizes the properties of both location-dependent query and skyline query. Specifically, an LDSQ involves a mobile client q and a set of spatial objects S , with each object in S having a objects that are not location-dependently dominated by others. Here, an object t is said than u and at the same time t dominates u with respect to P . 
Different from conventional location-dependent queries, LDSQ is able to provide a skyline-like spatial search service in that both the proximity and non-spatial attributes the location of query point, the result of an LDSQ is closely relevant to the location of the LDSQ . To answer LDSQ s, a typical client/server scheme is employed in [1, 2], the LBS server through a GSM/3G/Wi-Fi service provider and the LBS server is re-sponsible for processing each LDSQ . While conceptually correct, the client/server scheme may suffer serious scalability problems caused by the ever growing number of mobile devices and the sharply increasin g query loads [3]. A promising solution to the above problem is the wireless broadcast model [3, 4]. In this model, the LBS serv-er, acting as a broadcast server, periodically  X  X ushes X  data to mobile clients over the wireless broadcast channel, and the mobile clients tune in the broadcast channel and process their queries locally. The main advant age of the broadcast model is that it can support an arbitrary number of users/queries, since no query processing takes place at the LBS server and the network capacity is a constant factor and not affected by the number of mobile clients. 
Motivated by scalability challenges faced in the conventional client/server scheme, we study the problem of LDSQ processing in wireless broadcast environments in this paper. To the best of our knowledge, it is the first effort to process LDSQ in the wire-less broadcast model. The linear property of wireless broadcast media and limited battery life of mobile clients make this problem particularly interesting and challeng-ing. Our contributions can be summarized as follows: 1) we propose a novel air data organization scheme for answering LDSQ s in wireless broadcast environments; 2) we develop an energy-efficient search algorithm for LDSQ s based on the proposed data organization scheme; and 3) we evaluate the performance of the proposed method. The rest of this paper is organized as follows. Section 2 reviews related work. Section 3 defines the problem studied in this work. Section 4 presents the processing tech-niques for LDSQ s in wireless broadcast environments. Section 5 evaluates our method through extensive experiments, and Section 6 concludes this paper. then discuss techniques for location-dependent query processing in wireless broadcast environments. 
The skyline operator was introduced into the database community by Borzsonyi et al. [5]. Since then a large number of algorithms have been proposed for conventional skyline queries [6-10]. As an extension of the conventional skyline query, location-dependent skyline query ( LDSQ ) was first proposed in [1]. LDSQ integrates skyline query with location-dependent query to provide a skyline-like spatial search service. In the literature [1], the concept of valid scope was formulated to address the valida-LDSQ processing in a client/server scheme. Furthermore, Xiao et al. [2] proposed a novel LDSQ processing method based on peer-to-peer sharing, which leverages query results cached in the neighboring peers to improve the query performance. The main difference between [1, 2] and our work is they employ a client/server scheme while this paper processes LDSQ in the wireless broadcast model. 
Location-dependent queries in wireless broadcast environments have been investi-gated in recent years [11-14]. The related work mainly focuses on range queries and k NN queries. Literatures [11] construct a linear index structure based on Hilbert Curve for range query processing. Bugra et al. [12] exploit k NN query processing in sequential-access R-trees. They evaluate the effect of different broadcast organiza-tions on the tuning time, and propose the use of histograms to enhance the pruning capabilities of the search algorithms. The distributed spatial index (DSI) [13] is pro-posed for supporting both range and k NN queries. The basic idea of DSI is to divide the whole data objects into multiple frames and associate with each frame an index table. The index table maintains information regarding to the Hilbert-Curve values of data objects to be broadcast with specific waiting interval from the current frame. Kyriakos et al. [14] present the Broadcast Grid Index (BGI) method, which is suitable for both snapshot and continuous spatial queries. BGI indexes the data with a regular grid, which partitions data space into square cells of equal size. The abovementioned methods purely focus on the proximity of objects and hence are not suitable for LDSQ in which both spatial and non-spatial attributes of objects must be considered simulta-neously as search criteria. Let S be the set of spatial objects stored at the LBS server and every object t  X  S has point q where d (.) denotes a distance metric obeying the triangle inequality. As a mo-formally define the LDSQ and related concepts. Definition 1 ( Location-Dependent Dominance  X   X  ) : Given two spatial objects t , u L ( q ))  X  d ( L ( u ), L ( q )). dependent skyline of q . Definition 3 ( LDSQ ) : An LDSQ is to find the location-dependent skyline over a giv-en set of spatial objects with respect to a given query point. Based on the above definitions, we know that lsk ( S , q ) depends not only on the data set S but is closely related to the location of q . It has been proved in [1] that for any to  X  X  X  X  X  X   X  and not location-dependently dominated by any other objects of S with prove the following theorem. Theorem 1 . For any query point q, lsk ( S , q ) = sk ( S ) +  X  (  X  X  X  X  X  X   X  , q ) holds. Theorem 1 is self-evident by the above definitions, so its proof is omitted. By Theorem 1, answering an LDSQ with respect to a query point q can be transformed (i.e., sk ( S ) can be obtained in advance by executing any regular skyline algorithm over S at the LBS server). Consequently, the crucial issue of answering an LDSQ is to how to compute  X  (  X  X  X  X  X  X   X  , q ) efficiently. Further, we can prove the following theo-rem. k  X  ds ( t ) then t  X  lsk ( S , q ). k proved. 
Theorem 2 provides an insight into how we judge whether an object in  X  X  X  X  X  X   X  be-longs to lsk ( S , q ) for a given query point q . The wireless broadcast model leverages the computational capabilities of mobile server is only responsible for organizing and broadcasting data. To process LDSQ in wireless broadcast environments, the following two issues should be addressed: 1) how to organize the broadcast cycle at the LBS server end, and 2) how to design the pose a novel air data organization scheme in Section 4.1. Then, in Section 4.2 we present an efficient algorithm for processing LDSQ s at the client side. 4.1 Air Data Organization Scheme In this subsection, we propose a novel air data organization scheme, called air scheme based on classification and Z-order curve ( ASCZ ). Considering the fact that sk ( S ) is using a regular skyline algorithm in the LBS server. Then, Z-order curve is leveraged the objects of  X  X  X  X  X  X   X  and clusters them in blocks to facilitate efficient dominance tests and space pruning [10]. Further, these ordered objects are divided into m  X  k dis- X  X  m ceded by a complete sk ( S ), and sk ( S ) is repeated m times in a broadcast cycle. fixed number of packet  X  X he smallest unit of message transfer in network, similar to the page concept in conventional storage systems. All buckets are typically assumed to be of the same size for convenience and uniformity. In ASCZ , a set of contiguous buckets storing a complete sk ( S ) is called a determinable segment while a set of con-objects, each segment contains some extra index information to help locate the desig-nated data segment and assist the space pruning in answering LDSQ s. Fig. 1 shows the detailed structures of a determinable segment and a pending segment. The first packet of a data segment provides general control information and is called header packet. 
As shown in Fig. 1(a), the header packet of a determinable segment contains (i) type (indentifying data segment type, i.e., determinable segment or pending segment), consecutive pending segments preceded by a complete determinable segment and the number m of determinable segments per broadcast cycle, and (vi) the offset next-p to the beginning of the next determinable segment. Similarly, the header packet of a pending segment, shown in Fig. 1(b), contains (i) type (indentifying data segment minimum bounding rectangle of  X  X   X   X  X  X  X   X  , (iii) number , i.e., the object number of  X  X   X   X  X  X  X   X  , (iv) the offset next-p to the beginning of the next determinable segment, (v) the offset near-p to the beginning of the next pending segment. In addition, a bit ( D-bit ) is set for each object in pending segments. For an object t in a pending segment, if set as 1; otherwise, its D-bit is set as 0. The organization structure of ASCZ is benefi-cial to answering LDSQs in broadcast environments because it facilitates efficient dominance tests and the space pruning, as we will illustrate in detail in the sequel. 4.2 The Proposed Method One na X ve solution for processing LDSQ s in the wireless broadcast model is that each downloaded, and then computes the requested LDSQ locally by means of an existing LDSQ processing algorithm based on client/server scheme, such as  X  -scanning algo-rithm [1]. Clearly, the na X ve solution leads to a long tuning time and very high memo-ry requirements at mobile clients, which are prohibitively expensive. Note that mobile devices often have much smaller RAM memory than desktop or laptop computers. More importantly, only a fraction of this memory is available to applications. To re-medy the deficiency of the na X ve solution, mobile clients should be able to tune selec-tively based on the characteristics of the aforementioned ASCZ and only buffer those objects which are likely to be location-dependent skyline objects. 
To provide energy conservation, a smart mobile device is designed to support two operation modes: active mode (i.e., listen mode) and doze mode (i.e., the power con-serving mode). The ratio of power consumption in the active mode to that in the doze mode is 5,000 [3]. Motivated by this observation, in this subsection, we propose directly obtained from broadcast channel. To compute lsk ( S , q ), the mobile client only needs to find those objects in  X  X  X  X  X  X   X  not location-dependently dominated by any objects of S (i.e.,  X  (  X  X  X  X  X  X   X  , q )) according to Theorem 1. The proposed EESMPR adopts a three-phase processing strategy, i.e., initialization, pruning and refinement, to achieve this goal. 
In the initialization phase, the main task is to locate the next earliest determinable segment ( NED segment , for short) to download sk ( S ). Specifically, when a mobile client receives an LDSQ request, it tunes into the broadcast channel and then retrieves the offset next-p , which points to the NED segment . Once next-p is downloaded, the mobile client immediately switches to the doze mode for saving power until the NED segment arrives. When the NED segment arrives, the mobile client downloads the whole NED segment from the broadcast channel into its own memory space, and then be described in detail. For ease of presentation, we call these pending segments ap-pearing behind the NED segment but before the reappearance of the NED segment in the next broadcast cycle waiting pending segments . For each waiting pending seg-ment , the pruning and refining operations are executed at the pruning and refinement phases, which are critical parts of EESMPR . Specifically, for each waiting pending segment , the pruning phase is first employed to check if the segment can be pruned directly. For those waiting pending segments that are not be pruned directly, the re-finement phase is responsible for location-dependent dominance tests to find those not location-dependently dominated objects. Clearly, efficient space pruning and loca-tion-dependent dominance tests are vital for EESMPR . 
In order to efficiently judge whether a waiting pending segment can be directly pruned, we have the following theorem, which leverages two distance metrics, i.e., Mindist ( . ) and Maxdist ( . ). Given a query point q and a minimum bounding rectangle MBR , Mindist ( q , MBR ) is defined by 0 when q is inside MBR or on the perimeter of MBR ; otherwise Mindist ( q , MBR ) is the minimum distance between q and MBR. Si-milarly, we simply define Maxdist ( q , MBR ) as the maximum distance between q and MBR in this paper. 
Theorem 3 shows if the minimum distance between q and MBR (  X  X   X   X  X  X  X   X  ) is greater than the maximum distance between q and MBR ( sk ( S )), then the pending segment  X  X  directly pruned. Compared with the conventional method based on expensive loca-tion-dependent dominance tests, the space pruning method based on Theorem 3 only needs to simply compute two distances. 
Fig. 2 depicts the two different cases satisfying and unsatisfying the pruning condi-tion in Theorem 3. The case satisfying the pruning condition of Theorem 3 is shown can be directly pruned according to Theorem 3. Fig. 2(b) shows the other case where the minimum distance between query point q and MBR (  X  X   X   X  X  X  X   X  ) (i.e., the yellow line segment) is less than the maximum distance between q and MBR ( sk ( S )) (i.e., the blue line segment). That is, the pruning condition of Theorem 3 is not satisfied in Fig. 2(b). Therefore, the pending segment  X  X   X   X  X  X  X   X  cannot be directly pruned in the case and the refinement processing is required. The refinement processing is responsible for loca-tion-dependent dominance tests to find all location-dependent skyline objects from those waiting pending segments, which cannot be pruned directly. Because location-dependent dominance test is an expensive operation, it is important for the refinement phase to efficiently reduce the number of executing location-dependent dominance directly). We have the following lemma through analysis. k  X  sk ( S ). which means that  X  t  X  X  X   X   X  X  X  X   X  , t is not location-dependently dominated by any k  X  sk ( S ). The proof is completed. By Lemma 1, we can easily prove the following Theorem 4. Mindist ( q , MBR ( sk ( S ))) and the D-bit of t is 0, then t  X  lsk ( S , q ). self-evident by Lemma 1 that t is not location-dependently dominated by any k  X  sk ( S ). Then, we need to prove t is not location-dependently dominated by any k  X  X  X  X  X  X  X   X  . Since the D-bit of t is 0, t is not dominated by any k  X  X  X  X  X  X  X   X  according to the definition of D-bit . Thus, t is not location-dependently dominated by any k  X  X  X  X  X  X  X   X  by the definition of location-dependent dominance . In sum, t is not loca-not location-dependently dominated by any k  X  S . The proof is completed. 
Based on Theorem 4, for those waiting pending segments not be pruned directly phase only need to execute location-dependent dominance tests for those objects whose D-bit s are 1. To facilitate location-dependent dominance tests, EESMPR together with the distances between these objects and the mobile client (i.e., query &lt; t values in the temple-list . 
For each k  X  X  X   X   X  X  X  X   X  violating the conditions in Theorems 3 and 4, location-dependent dominance test is done based on the temple-list according to the following two cases: 1) if k is location-dependently dominated by any object in the temple-list , it the temple-list location-dependently dominated by k , if exist, are dropped, as we de-pict formally in Algorithm 1. 
As shown in Algorithm 1, these objects satisfying the conditions listed in Theorem 4 (lines 2-4 in Algorithm 1) are processe d according to the abovementioned case 2. For those objects unsatisfying the conditions in Theorem 4, location-dependent do-minance test is done by Theorem 2 (lines 7-11 and lines 14-18 in Algorithm 1). The function MaintenanceList () is responsible for inserting an object into the temple-list in ascending order of distance values and deleting those objects in the temple-list location-dependently dominated by the object. The formalized description of Mainte-nanceList () is given in Algorithm 2. Assume that a mobile client ( MC ) receives an LDSQ request. Now, we formalize EESMPR in Algorithm 3. In this section, we evaluate the performance of the proposed method ( EESMPR ) through extensive experiments. Similar to other works in the literature, the perfor-mance metrics of concern in this paper are the tuning time and the access latency . In what follows, we will first describe the experimental settings and then present the simulation results. 5.1 Experiment Settings Following the empirical study in [1], we use two real datasets, namely School and NBA , to evaluate the proposed method. The spatial attributes of School represent the 2D geographical coordinates of schools in United States. Each school object has six non-spatial attributes, which are generated randomly. NBA contains 13 non-spatial dimensionalities, which corresponds to the statistics of one NBA player X  X  perfor-mance in 13aspects. The spatial 2D attributes of NBA are generated uniformly. In anti-correlated distribution. 
A mobile client initiates LDSQ s continuously. The tuning time and the access la-tency for a single execution of LDSQ are measured independently and the location of the mobile client is updated randomly every time a new LDSQ is invoked. The expe-rimental results are the average tuning time and access latency over the total runs of all LDSQ s. Due to the lack of comparable baseline methods, our simulation experi-ments mainly focus on evaluating the impact of different parameter settings over the performance of the proposed method. Table 1 summarizes the main parameters and their settings. In each experiment we vary a single parameter, while setting the re-maining ones to fixed values. 5.2 Simulation Results Fig. 3 depicts the access latency as a function of k under m =1, 2, 4, 6, 8, 10. Accord-ing to EESMFR , the access latency T access of a single execution of LDSQ mainly con-( ing a determinable segment and  X   X  X  X  X  X  X  X  X  X  X  represents the needed time of broadcasting a pending segment. It is easy to see T bcast =  X  X  X   X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X   X  X  X  X  X  X  X   X  X  X  X  X  X  X  X  X  X  . Note that the size of a pending segment is affected by m and k when the size of data access latency on School dataset is greater than that on NBA dataset. This is because the much larger number of objects in School dataset causes the longer T bcast . We can also see from Fig. 3 that the access latency increases with k for fixed m , and the rising rate of the access latency become much higher when m is greater. This is not surpris-ing because the increment of k causes the increase of the number of pending segments in a broadcast cycle, and then the increase of the number of pending segments leads to the corresponding growth in header information. In a nutshell, the growth of k causes the increase of T bcast and the increase of m will accelerate the increase of the number of pending segments. Fig. 3(a) shows that the maximum access latency is reached at m =1 for School dataset. This is because T probe is equal to  X   X  X  X  X  X  X  X   X  when m =1. Another observation is T access gradually decreases when m grows from 1 to 4 and become the shows the maximum and minimum access latency are obtained when m =10 and m =2 for NBA dataset respectively. We use the number of packets monitored by the mobile client to measure the tuning time because the tuning time is in direct proportion to the number of monitored pack-ets. Fig. 4 plots the tuning time as a function of m when the other parameters are set to their default values. As we expect, the tuning time decreases with the increase of m . being pruned. Fig. 5 depicts the number of the pruned pending segments as a function of k for m =2 and m =6, respectively, using School dataset. We can see from Fig. 5 that the number of the pruned pending segments increases with k . The reason is the same as the one for Fig. 4. Finally, we study the effect of l on the access latency and tuning time. Fig. 6 illustrates the access latency as a function of l . The results show that the the impact on the length of the broadcast cycle is very limited compared with the size of the dataset itself, and thus the effect of l on the access latency is almost negligible. Fig. 7 shows the tuning time as a function of l . As we expect, the tuning time decreas-time becomes slow with the increase of l . This is not surprising because the fine-condition when l increases to a certain point. A distinguishing feature of the wireless broadcast model is  X  X ne-transmission, infinite-share X , which results in almost unlimited scalability. Motivated by the ever growing number We propose a novel air data organization scheme based on classification and Z-order curves. conduct extensive experiments and comprehensive performance analysis, which demon-strate the effectiveness and efficiency of our method. Acknowledgment. This work is supported by the NSF of China (No. 61170174, 61370205) and Tianjin Training plan of University Innovation Team (No.TD12-5016  X  . 
