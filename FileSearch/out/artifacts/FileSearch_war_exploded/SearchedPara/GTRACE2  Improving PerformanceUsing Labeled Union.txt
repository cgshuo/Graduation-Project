 Studies on data mining have established many approaches for finding charac-teristic patterns from various structured data. Graph Mining [5,12,9], which efficiently mines all subgraphs appearin g more frequently than a given thresh-old from a set of graphs, focuses on the topological relations between vertices in the graphs. Although the major methods for Graph Mining are quite effi-cient in practice, they require much com putation time to mine complex frequent subgraphs due to the NP-completeness of subgraph isomorphism matching [4]. Accordingly, these conventional methods are not suitable for complex graphs such as graph sequences.

However, graph sequences can be used t o model objects for many real world applications. For example, a human network can be represented as a graph where each human and each relationship betw een two humans correspond to a vertex and an edge, respectively. If a human joins (or leaves) the community in the human network, the numbers of vertices and edges in the gra ph increase (or decrease). Similarly, a gene network cons isting of genes and their interactions produces a graph sequence in the course of their evolutionary history by acquiring new genes, deleting genes, and mutating genes.

Recently, much attention has been given to frequent pattern mining from graph sequences [6,2,1,7]. Figure 1 (a) shows an example of a graph sequence consisting of 4 steps where each contains vertices denoted by 5 unique IDs. In [6], we proposed a new method, called GTRACE (G raph TRA nsformation sequenCE mining), for mining frequent patterns as shown in Fig. 1 (b) from graph sequences under the assumption that the change in each graph is gradual, and applied it to graph sequences generated from the Enron dataset. Although GTRACE is tractable for the Enron graph sequences containing about 7 steps and 100 unique IDs, it is intractable for g raph sequences containing more steps and unique IDs than those in the Enron graph sequences.

In this paper, we propose a method to improve the efficiency of GTRACE mining frequent patterns called FTSs (F requent T ransformation S ubsequences) from graph sequences. Our performance study shows that the proposed method is efficient and scalable for mining both long and large graph sequence patterns, and is some orders of magnitude faster than GTRACE. Although this paper focuses on undirected graphs where only the vertices have labels, the proposed method is applicable to both directed graph and undirected graphs where the edges also have labels without loss of generality. In this section, we briefly review a compila tion used to compactly represent graph sequences in GTRACE. Figur e 1 (a) shows an example of a graph sequence. The graph g ( j ) is the j -th labeled graph in the sequ ence. The problem we address in this paper is how to mine patterns that appear more frequently than a given threshold from a set of graph sequences. In [6], we proposed transformation rules to represent graph sequences compactly under the assumption that  X  X he change over adjacent graphs is gradual X . In other word, only a small part of the graph changes between two successive graphs g ( j ) and g ( j +1) in a graph sequence, while the other parts remain unchanged. In t he aforementioned human networks and the gene networks, these assumptions cer tainly hold, since most of the changes of the vertices are progressive over succe ssive steps. The direct representation of a graph sequence is not compact, because many parts of a graph remain unchanged over several steps and are therefore redundant in the representation. On the other hand, a graph sequence is co mpactly represented by introducing a representation of graph transformation based on rules of insertion, deletion, and relabeling of vertices and edges under the assumption of gradual changes.
A labeled graph g is represented as g =( V, E, L, f ), where V = { v 1 ,  X  X  X  ,v z } is a set of vertices, E = { ( v, v ) | ( v, v )  X  V  X  V } is a set of edges, and L is edges and labels of g , respectively. A graph sequence is represented as d = g (1) g (2)  X  X  X  g ( n ) , where the superscript integer of each g is the ordered step in the graph sequence. We assume that each vertex v is mutually distinct from the others in any g ( j ) and keeps a unique ID id ( v )in d . We define the set of unique Example 1. In the human network mentioned in Section 1, each person has a unique ID, and his/her gender is an example of a vertex label.
 To compactly represent a graph sequence, we focus on the differences between two successive graphs g ( j ) and g ( j +1) in the sequence.
 Definition 1. Given a graph sequence d = g (1)  X  X  X  g ( n ) , each graph g ( j ) in d is called an  X  X nterstate X . Moreover, The differences between the graphs g ( j ) and g g sequence d is represented by the interpolations as d = s (1) s (2)  X  X  X  s ( n  X  1) . The order of interstates represents the order of graphs in a sequence. On the other hand, the order of intrastates is the order of graphs in the artificial interpolation, and there can be various interpolations between the graphs g ( j ) and g ( j +1) .We limit the interpolations to be compact and unambiguous by choosing one with the shortest length in ter ms of graph edit distance.
 Definition 2. Let a transformation of a graph by insertion, deletion or relabel-ing of a vertex or an edge be a unit, and let each unit have edit distance 1. An tion in which the edit distance between any two successive intrastates is 1, and in which the edit distance between any two intrastates is minimum.
 The transformation is represented by the following  X  X ransformation rule (TR) X . Definition 3. A transformation rule (TR) which transforms g ( j,k ) to g ( j,k +1)  X  tr is a transformation type which is either insertion, deletion, or relabeling  X  o jk is an element in ID V ( d )  X  ID E ( d ) to be transformed, and  X  l jk  X  L is a label to be assigned to the vertex by the transformation. For the sake of simplicity, we denote the transformation rule by omitting the subscripts of o jk and l jk except in the case of ambiguity. We introduced five TRs defined in Table 1. In summary, we give the following definition of a trans-formation sequence.
 sequence X . Moreover, a graph sequence d = g (1)  X  X  X  g ( n ) is represented by an  X  X nterstate transformation sequence X  seq ( d )= seq ( s (1) )  X  X  X  seq ( s ( n  X  1) ) .
The notation of the intrastate transformation sequence is far more compact than the original graph based representation, since only differences between two successive intrastates appear in the sequ ence. In addition, computing a sequence of TRs based on differences between two gra phs is solvable in linear time, because all vertices have unique IDs.
 Example 2. In Fig. 2 (a), a graph sequence is represented by a sequence of in-sertions and deletions of ve rtices and edges as shown in Fig. 2 (b). The sequence In this section, we briefly review how GTRACE mines frequent transformation subsequences (FTSs) from a given set of graph sequences. To mine FTSs from a set of compiled graph sequences, we define an inclusion relation between trans-formation sequences. When a transformation sequence seq ( d ) includes another transformation sequence seq ( d ), it is denoted by seq ( d ) % seq ( d ) whose detail definition is provided in [6].

As mentioned in [6], to mine FTSs consisting of mutually relevant vertices only, we define the relevancy between uniqu e IDs of vertices and edges as follows. Definition 5. Unique IDs in d = g (1)  X  X  X  g ( n ) are relevant one another, and d is called a  X  X elevant graph sequence X , if the union graph g u ( d ) of d is a connected graph. We define the union graph of d to be g u ( d )=( V u ,E u ) where This union graph of the transformation sequence seq ( d ) is also defined similar to Definition 5.

Given a set of data DB = { id, d | d = g (1)  X  X  X  g ( n ) } , the support value  X  ( seq ( d )) of a transformation subsequence seq ( d ) is defined to be We call a transformation subsequence whose support value is greater than or equal to a minimum support threshold  X  a  X  X requent transformation subse-quence (FTS) X . The anti-monotonicity of this support value holds. That is, if our mining problem as follows.
 Problem 1. Given a dataset DB = { id, d | d = g (1) g (2)  X  X  X  g ( n ) } and a mini-mum support threshold  X  as the input, enumerate all relevant FTSs (rFTSs). To enumerate all rFTSs efficiently, GTRACE first generates a union graph for each graph sequence in DB based on the definition of a union graph. Subsequently, all connected frequent subgraphs in these union graphs are enumerated by using the conventional Graph Mining algorithm. At each time the algorithm outputs a con-nected frequent subgraph, an altered version of PrefixSpan [10] is called to mine rFTSs from transformation subsequences generated by the following projection. Definition 6. Given a graph sequence id, d  X  DB and a connected graph g , we define a function  X  proj 1  X  X oproject seq ( d ) to its subsequences. AdataID id is attached to each transformation subsequence produced by the projection to calculate the exact support value of each rFTS, since multiple transformation subsequences ar e produced from a graph sequence id, d in the projection. Since the union graph of an rFTS is also frequent in the union graphs of all id, d  X  DB , we can enumerate all rFTSs fro m the projected transforma-tion subsequences if all connected frequent subgraphs among the union graphs of all id, d are given.
 Example 3. Given the graph sequence d in Fig. 3 (a), seq ( d ) is represented by g ( d ) is depicted in Fig. 3 (b). Given a graph g which is a subgraph of g u ( d )as shown in Fig. 3 (d), one of transformation sequences in proj 1 ( id, seq ( d ) ,g )is where this subsequence matches with the underlined rules in seq ( d ). Figure 4 shows an algorithm for enumerating all rFTSs F from DB . First, a set G u of the union graphs of graph sequences DB is generated in Line 2. Assuming that the function call  X  X requentSubgraphMiner X  [8] repeatedly and exhaustively outputs connected frequent subgraphs g in G u one at a time in Line 3, FTSMiner, which is the altered PrefixSpan [10,6], is called in Line 5 with the transformation sequences projected in Line 4 to mine rFTSs from proj 1 ( DB, g ). Finally, rFTSs mined from proj 1 ( DB, g )= isomorphic to g , are added to F in Line 6. These processes are continued until the connected frequent subgraph g is exhausted in FrequentSubgraphMiner. We have implemented FrequentSubgraphMiner using AcGM [8] which is one of the conventional Graph Mining methods. Most of the computation time of GTRACE is used to run the altered PrefixSpan. The reason why the PrefixSpan used in GTRACE needs so much computation time is as follows. Let G u and g be a set of union graphs of all id, d  X  DB and a frequent connected subgraph mined by FrequentSubgraphMiner from G u , respectively. The union graphs in G u are often dense even if each interstate in graph sequences is sparse, since a union graph in G u is generated by superim-posing interstates in a graph sequence. In addition, since the union graph of a graph sequence is a graph with no labels, there exist many injective functions V ( g )  X  V ( g u ) between g and a dense union graph g u ( d )  X  G u such that g is a subgraph of g u ( d ). Therefore, many pr ojected transformation subsequences are produced from the graph g and one graph sequence d such that g is a subgraph of g u ( d ) according to the definition of projection.
To reduce the number of transformation subsequences produced by the pro-jection, we redefine the union graph as follows: Definition 7. We redefine a union graph of d as g u ( d )=( V u ,E u ,L  X  X  l + } ,f u ) such that where V u and E u are given by Eqs. (1) and (2), respectively. L is a set of vertex labels in d , f is a function to assign vertex label l  X  L to each vertex in interstates in d ,and l + /  X  L .
 The union graph defined here is a labeled graph, although the union graph defined in Section 3 is an unlabeled graph. So, we call the union graph we have defined here a labeled union graph. A label assigned to each vertex in the labeled union graph is determined by E q. (3). If the vertices with unique ID o in interstates in d always have the identical label l  X  L ,avertex o in the labeled union graph of d has the label l .Otherwise,thevertex o has a label l + such that l Example 4. Figure 5 shows a union graph and a labeled union graph generated from the same graph sequence. Since two vertices with unique ID 1 in the graph sequence d have different labels, the corresponding vertex in the labeled union graph has a label l + .
 As mentioned in Section 3, GTRACE generates union graphs of all graph se-quences in DB and mines all frequent connected subgraph patterns using AcGM. In this process, AcGM checks whether a pattern is included in each union graph. Since vertices with label l + in a labeled union graph should match any vertex in a pattern, the subgraph isomorphism test used in AcGM is altered as follows. Given two graphs g ( V, E, L, f )and g ( V ,E ,L ,f ), g is a subgraph of g ,ifthere exists an injective function  X  : V  X  V that satisfies the following conditions for  X  v, v 1 ,v 2  X  V . 1. (  X  ( v 1 ) , X  ( v 2 ))  X  E ,if( v 1 ,v 2 )  X  E ,and 2. f (  X  ( v )) = f ( v )or f (  X  ( v )) = l + .
 By integrating the definition of the labeled union graph and the subgraph iso-morphism test with GTRACE, we propose a new method called GTRACE2 to mine all rFTSs from graph sequences. According to the following lemma, we reduce the computation time to mine all rFTSs from graph sequences.
 Lemma 1. If g 1 is an unlabeled graph generated by removing all labels from a labeled graph g 2 to be used as input of projection in GTRACE2, then where proj 1 and proj 2 are functions to project a graph sequence in GTRACE there must exists a transformation sequence id 1 ,seq ( d 1 )  X  proj 1 ( id 1 ,d ,g 1 ) such that id 1 = id 2 and seq ( d 2 ) % seq ( d 1 ) . Therefore, the average number of TRs in transformation sequences in  X  id,d  X  DB proj 2 ( id, d ,g 2 ) is less than or equal to the average number of TRs in transformation sequences in  X  The proof of Lemma 1 is omitted due to the lack of space, but an example is given in Example 5. As shown in the experiments in [10], the computation time to run PrefixSpan is proportional to the number of sequences in its input, and it increases exponentially when the a verage number of items in the sequences increases. According to Lemma 1, since t he number of transformation sequences generated by the projection in GTRACE2 usually decreases and the average number of TRs in the transformation se quences usually beco meslessthaninthe original GTRACE, the computation time for running the altered PrefixSpan in GTRACE2 is reduced.
 Example 5. The graph sequence 1 ,d at the center of Fig. 5 is represented as union graph are shown in Fig. 5. Given the graph g 1 shown in Fig. 6 (a) as input of the projection in GTRACE, two vertices in g 1 correspond to vertices with unique IDs 1 and 2 or vertices with unique IDs 1 and 3 in the union graph g u ( d ). Therefore, proj 1 ( 1 ,d ,g 1 )is On the other hand, given the graph g 2 shown in Fig. 6 (b) as input of the projection in GTRACE2, proj 2 ( 1 ,d ,g 2 )is since two vertices with unique ID 1 and 2 in the input graph g 2 correspond to vertices with unique IDs 1 and 2 in the labeled union graph g u ( d ), respec-g ( d )= g in Definition 8. The proposed method was implemented i n C++. The experiments were executed on an HP xw4600 with an Intel Core 2 8600 3.33 GHz processor and 2 GB of main memory and running Windows XP. The performance of the proposed method was evaluated using both artificial and real world graph sequence data. Due to the lack of space, we report the experiments using the real world data. To assess the practicality of the proposed method, it was applied to the Enron Email Dataset [3]. We assigned a unique ID to each person participating in email communication, and assigned an edge to a pair communicating via email on a particular day, thereby obtaining a daily graph g ( j ) . In addition, one of the vertex labels { CEO, Employee, Director, Manager, Lawyer, President, Trader, Vice President } was assigned to each vertex. We then obtained a set of weekly graph sequence data DB . The total number of weeks, i.e. , number of sequences, was 123. We randomly sampled | ID V ( d ) | (= 1  X  182) persons to form DB .
Table 2 shows the computation times [sec] to run GTRACE and GTRACE2, total computation times [sec] to run the altered PrefixSpan, the numbers of frequent connected subgraphs mined by AcGM, the average numbers of trans-formation sequences in proj i ( DB, g ), and the average numbers of transformation sequences in proj i ( DB, g ) obtained for various numbers of unique IDs (persons) |
ID V ( d ) | , minimum support  X  , and numbers of interstates n in each graph se-quence of the dataset. All the other parameters were set to the default values indicated at the bottom of the table. Thus, the dataset with the default values as contained 123 graph sequences each consisting of 182 persons (unique IDs) and 7 interstates. The parameter n =5, 6, or 7 indicates that each sequence d in DB consists of 5, 6, or 7 steps (interstates) from Monday to Friday, Saturday, or Sunday, respectively. When the required computation time exceeds two hours or a memory overflow occurs, the results are indicated by  X - X .

The upper, lower left, and lower right parts of the table show experimental results with regard to the number of persons (unique IDs), the minimum sup-port threshold, and the number of interstates in graph sequences in the graph sequence database, respectively. The t able indicates that GTRACE proved in-tractable for the graph sequence datase t generated from the default values, althought the proposed method GTRACE2 is tractable with respect to the database. In addition, the computation times for both GTRACE and GTRACE2 are exponential with respect to the increases of the number of | ID V ( d ) | and the number of interstates in the graph sequence database and with respect to the decrease of the minimum support threshold. The main reason that the compu-tation time increases is the increase in the number of frequent patterns. The computation times for GTRACE2 are much smaller than those for GTRACE, although the number of times to call the altered PrefixSpan increases. Most of computation time of GTRACE is used running the altered PrefixSpan. As shown in [10], the computation time of PrefixSpan is proportional to the number of sequences in its input and increase exponentially with respect to the average number of items in sequences in its input. The scalability of GTRACE2 comes from reducing the number of tran sformation sequences and the number of TRs in transformation sequences in the projected database by using the labeled union graph proposed in Section 4. GTRACE2 is practical, because it can be applied to graph sequences that are both longer and larger than those to which GTRACE can be applied. In this paper, we proposed a method to improve GTRACE which mines a set of relevant frequent transformation subsequences (rFTSs) from given graph se-quences by defining the labeled union graph. We developed a graph sequence mining program GTRACE2, and confirmed its efficiency and practical per-formance through computational experiments using artificial and real world datasets. Our performance study showed that the proposed method is some orders of magnitude faster than the conventional method, and is efficient and scalable for mining both long and larg e graph sequence patterns. Recently, we have proposed a method for mining another class of frequent patterns, called FRISSs (Frequent, Relevant, and Induced Subgraph Subsequences), from graph sequence [7]. The principle proposed in this paper using labeled graphs can be applied to the method. In real applications, it is hard to enumerate usefule and interesting FTSs which are exactly included in graph sequences. In future work, we plan to extend GTRACE2 to mine FTSs which are approximately included in graph sequences by using sliding windows and time constraints proposed in [11].
