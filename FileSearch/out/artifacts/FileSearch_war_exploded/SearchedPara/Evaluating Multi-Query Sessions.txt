 The standard system-based evaluation paradigm has focused on assessing the performance of retrieval systems in serving the best results for a single query. Real users, however, often begin an interaction with a search engine with a sufficiently under-specified query that they will need to reformulate be-fore they find what they are looking for. In this work we con-sider the problem of evaluating retrieval systems over test collections of multi-query sessions. We propose two families of measures: a model-free family that makes no assumption about the user X  X  behavior over a session, and a model-based family with a simple model of user interactions over the ses-sion. In both cases we generalize traditional evaluation met-rics such as average precision to multi-query session evalua-tion. We demonstrate the behavior of the proposed metrics by using the new TREC 2010 Session track collection and simulations over the TREC-9 Query track collection. Categories and Subject Descriptors: H.3.4 [Informa-tion Storage and Retrieval] Performance Evaluation General Terms: Experimentation, Measurement Keywords: information retrieval, test collections, evalua-tion, sessions
Evaluation measures play a critical role in the develop-ment of retrieval systems, both as measures in compara-tive evaluation experiments and as objective functions for optimizing system effectiveness. The standard evaluation paradigm has focused on assessing the performance of re-trieval systems in serving the best results for a single query, for varying definitions of  X  X est X : for ad hoc tasks, the most relevant results; for diversity tasks, the results that do the best job of covering a space of information needs; for known-item tasks, the single document the user is looking for. There are many test collections for repeatable experiments on these tasks, and dozens of evaluation measures assessing different aspects of task effectiveness.

Real users, however, often begin an interaction with a search engine with a query that they will need to reformulate one or more times before they find what they are looking for. Early studies on web search query logs showed that half of all Web users reformulated their initial query: 52% of the users in 1997 Excite data set, 45% of the users in the 2001 Excite dataset [15].

The standard evaluation paradigm of single-query test col-lections seems unable to assess the effectiveness of retrieval systems over sequences of query reformulations. Interactive evaluation has been employed as an alternative. In inter-active evaluation the user is part of the evaluation cycle and freely interacts with the results of a retrieval system. Measures such as instance recal l [11] and session discounted cumulative gain [6] have been proposed to capture the ef-fectiveness of systems in these settings. Even though an interactive evaluation paradigm can better capture the ac-tual user experience, it is both noisy due to the high degrees of freedom of user interactions and expensive due to its low reusability and need for many test subjects. Furthermore, conducting interactive comparative evaluation experiments is by no means an easy task.

The TREC 2010 Session track [7] proposed an experiment for the evaluation of retrieval systems over multi-query ses-sions. We defined a session as a sequence of reformulations in the service of satisfying a general information need, and constructed a test collection of two query reformulations (an initial and a follow-up query) for each of 150 information needs. This collection makes compromises for simplicity and tractability, but it provides a starting point for investigation of questions about test collection-based session evaluation.
In addition to a test collection, new evaluation measures are necessary as well. Traditional evaluation measures only capture per-query effectiveness; they are not necessarily ap-propriate for evaluating the effectiveness of a retrieval sys-tem over a multi-query session. While one could evaluate results for each query in the session in isolation, it may not be the case that the system is serving results for each query independently. Doing so would lose potentially valuable in-formation about the ability of the system to provide results for the session as a unit, and thus reduce our ability to op-timize system performance across sessions.

Due to the lack of appropriate measures J  X  arvelin et al. [6] extended the normalized discounted cumulative gain (nDCG) measure to a measure that considers multi-query sessions. The measure X  X alled normalized session discounted cumula-tive gain (nsDCG) X  X iscounts documents that appear lower in the ranked list for a given query as well as documents that appear after more query reformulations. In a sense the new model incorporates a cost for reformulating a query as well as scanning down a ranked list.

The nsDCG measure is computed as follows: for each query in a series of reformulations, DCG is computed in isolation of all other queries in the series. Each DCG is then discounted by a function of the position q of the query in the series. The measure can evaluate the effectiveness of retrieval systems over multiple queries in an interactive retrieval scenario, in which a user moves down a ranked list of documents and at some rank reformulates the query. Since the reformulation points are known (from observing the users), DCG is computed at those points for each query and at the stopping point for the last reformulation. In a test collection of static sessions, however, reformulation points are unknown. Using nsDCG requires the selection of a fixed reformulation cut-off, which clearly does not reflect the fact that different retrieval results may trigger different user behavior. Further, the measure does not model early abandonment of a query session; our TREC session collec-tion comes with a fixed number of reformulations, but a user may choose to abandon the session before reaching the last reformulation (either due to satisfaction or due to frus-tration). A multi-query session measure should be able to model such behavior.

Yang and Lad [16] overcame the need to define a fixed reformulation point by defining a session measure as an ex-pectation over a set of possible browsing paths. Based on this they proposed a measure of expected utility for a multi-query information distillation task. Given a series of m re-formulations the proposed measure accounts for all possible browsing paths that end in the k th reformulation. Each path has a certain probability to be realized by a user. To define the probability of a user following a certain path Yang and Lad [16] follow the rank biased precision (RBP) frame-work [10], replacing RBP X  X  stopping condition with a refor-mulation condition. The utility of each path is a function of the relevance and novelty of the returned documents being considered. The system effectiveness is then defined as the expected utility calculated over the aforementioned proba-bilistic space of browsing paths. Though the expected utility solves the problem of variable reformulation points, it still does not allow early abandonment of the query session.
In this work we consider the problem of evaluating re-trieval systems over test collections of static multi-query ses-sions. We propose two families of measures: one that makes no assumptions about the user X  X  behavior over a session, and another with a simple model of user interactions over the session. In the latter case we provide a general frame-work to accommodate different models of user interactions in the course of a session, avoiding predefined reformulation cut-offs and allowing early abandonment. In both cases we generalize traditional evaluation measures such as average precision to multi-query session evaluation.
We define a session test collection as one with a set of top-ics, each of which consist of a description of an information need and a static sequence of m title queries (an initial query Table 1: Example rankings (document IDs and rel-evance judgments) for three queries q 1 , 1 ,q 1 , 2 ,q 1 a session for topic number 1. Here we assume all documents are unique. and m  X  1 reformulations), and judgments of the relevance of documents to the topics. For simplicity, we assume that all reformulations are directed towards a single information need, so there is a global set of relevant documents of size R . 1 This definition is similar to those used by J  X  arvelin et al. [6] and Yang &amp; Lad [16], and it is essentially the defi-nition used for the TREC 2010 Session track in the case of specification and generalization reformulations [7].
Following Cooper in his proposal for the expected search length measure [5], we assume a user stepping down the ranked list of results until some decision point. To this we add an additional possible action: the decision point can be either a stopping point for the search, or a point at which the user reformulates their query. Thus, a user experiences results by either moving down a ranking (i.e. moving from rank k to rank k + 1 in ranking r i ) or to the top of the next ranking by reformulating ( i.e. moving from rank k in ranking r i to rank 1 in ranking r i +1 .).

Consider the example in Table 1. A user with a certain information need formulates a query and submits it to a re-trieval system. The retrieval system returns a ranked list of documents, r 1 =( d 1 ,d 2 , ..., d 10 , ... ). Suppose the user X  X  first decision point occurs at document d 5 . After seeing that document, the user decides to reformulate the original query and resubmit it to the retrieval system. The retrieval system responds with a second ranked list of documents, r =( d 1 ,d 1 , ..., d 10 , ... ). The user reads the documents once again from top to bottom and abandons the session. If we only consider the documents the user has examined over the session of reformulations then a final composite ranked list, cl , can be composed: cl =( d 1 ,d 2 ,...,d 5 ,d 1 ,d 2 ,d
Given the relevance of the documents in the composite ranked list cl , any traditional evaluation measure can be calculated in the usual manner. We may require assump-tions about the relevance of duplicates, e.g. if d 1 and d the same relevant document, how they should count towards the evaluation measure; we will consider these in Section 5.
In practice users X  information needs may change during a search session and over time [1]; assuming it is fixed is a modeling assumption we make for tractability. Some of our measures require this assumption, but it can be relaxed for other measures. The composite list cl is the outcome of a series of decisions. We define a path  X  through the results as a series of decisions to either move down a ranking, reformulate and start at the top of the next ranking, or abandon the search. We assume that at least one document X  X he first one X  X s viewed in each ranking. A path of length k is a path that results in k documents viewed. We denote the set of unique paths of length k as  X  k , and the set of all unique paths as  X . A path can be represented as a series of actions, e.g.  X  = { down , down , ..., reformulate , down , ..., abandon } ;asaseries of document IDs viewed, e.g.  X  = cl above; or as a series of ranks at which reformulations or abandonment occurred, e.g.  X  = { 5 , ... } . The three are equivalent in the sense of providing complete information about the series of decisions; the last, being most compact, is the one we will use.
Different paths result in different documents being seen, and in many cases different numbers of relevant documents. Precision after k documents viewed may result in very differ-ent values depending on the path chosen: a user that views 10 documents in r 1 (the relevance of which is shown in Ta-ble 1), experiences 0 precision, while one that reformulates immediately after the first document in r 1 and steps down r until rank 9 experiences precision of 5 / 10. In an interactive evaluation scenario where real users interact with the ranked list of documents returned by a retrieval system, the point at which a user decides either to reformulate their previous query or to abandon the search can be explicitly recorded by observation, or implicitly inferred by looking at (for in-stance) the last clicked document. In batch laboratory ex-periments with static sessions, however, the reformulation and stopping points are undefined X  X here is no user from which to record them. This presents a challenge for defining evaluation measures.

In this work we propose evaluating static sessions by sum-marizing evaluation results over all paths through the re-sults. We will consider two directions: one a  X  X odel-free X  approach inspired by interpolated precision and recall, the other a model-based approach that explicitly defines prob-abilities for certain actions, then averages over paths. In both approaches we would like to make as few assumptions as possible about the reasons a user reformulates.
The number of possible paths grows fairly fast. Consider a path of length k ending in reformulation number j .For example, the paths of length 4 ending at reformulation 2 are { d 1 ,d 2 ,d 3 ,d 1 } , { d 1 ,d 2 ,d 1 ,d 2 } ,and { d 1 ,d given k and j , we can count the number of possible paths as follows: imagine a ranking as a list of k documents, then place j  X  1 reformulation points between any two documents in that list. The number of different places we can insert them is length k that end at reformulation j .

The total number of paths of length k is: This is the definition of elements in the Bernoulli triangle. Its rate of growth is unknown, but it is O ( k 2 )for m =2and approaches 2 k  X  1 as m increases to k . The total number of paths of any length is |  X  | = Table 2: Relevant document counts for different paths of length k ending at ranking j from the ex-ample in Table 1.

On the other hand, if we only consider paths that end at reformulation j but continue down ranked list r j indefinitely, the number is more manageable. We can enumerate these by simply iterating over stopping points k 1 =1 ... | r 1 for each of those over stopping points k 2 =1 ... | r 2 | on. Within the ( j  X  1)st loop,  X  = { k 1 , ..., k k  X  1 } to that point. This takes | r 1 | X | r 2 | X  X  X  X  X | r m  X  1 | time, which, while not exactly fast, is at least manageable.
Our first goal is to develop a method for evaluating the effectiveness of a system over a set of reformulations mak-ing no assumptions about when or why users reformulate. The approach is inspired by interpolated precision: there is no formal user model behind interpolated precision, but it reduces the full evaluation data (precision at every rank) to a manageable set while still providing useful intuition about system performance, particularly when plotted against re-call values. Likewise, there is no formal user model behind these measures, but they give some intuition while greatly reducing the amount of evaluation data, which as we saw above grows exponentially.

Consider all paths of length k that end at reformulation j . On each of those paths the user will see a certain number of relevant documents. Let us define a set of relevant counts rR @ j, k as the set of counts of relevant documents seen on all such paths. 2 In the example in Table 1, there is only one possible way for a user to see 4 documents without reformu-lating, and none of those documents are relevant; therefore rR @1 , 4= { 0 } . There are three ways for a user to see 4 documents over two queries: { d 1 ,d 2 ,d 3 ,d 1 } ; { d 1 { d 1 ,d 1 ,d 2 ,d 3 } . These paths have 1, 2, and 3 relevant docu-ments respectively. Therefore rR @2 , 4= { 1 , 2 , 3 } .Allsets rR for j =1 .. 3and k =1 .. 5areshowninTable2;thesize of a set is
We can then define session versions of precision and recall by dividing the relevant counts rR @ j, k by k (for precision) or R (for recall). We will call these rPC @ j, k and rRC @ j, k . This gives the session generalization to precision and recall: precision and recall for each possible path through the re-sults. In traditional systems-based evaluation there is only one possible path of length k , and precision/recall for that path is identical to precision/recall at rank k .
Precision is sometimes interpolated to a particular recall point r by finding the first rank at which recall r is achieved, then taking the maximum of all precisions at that rank or deeper. Let us consider an analogous process for sessions by defining precision at a particular recall point in a particular
We use boldface to denote sets and italics to denote scalars. Figure 1: Reformulation precision-recall surface for the example in Table 1. Figure 2: Reformulation precision-recall cross-sections of Figure 1 for the example in Table 1. Note that these are not precision-recall curves for the three rankings independently. reformulation. At recall 1 /R in r 2 , there is a set of possible by a user looking at k =1 , 2 , 3 , ... documents in ranking 1, then reformulating and looking at the first document in Now we will define sP C @ r, j as the maximum value of the set of possible precisions at the first rank in r j at which recall r is achieved. This reduces the amount of data to m precision values (with m being the number of queries in the static session) that reflect the best possible effectiveness a user could experience. Note that this is not interpolation in the traditional sense. sP C @1 /R, 2 may still be less than sP C @2 /R, 2, which is not possible in the usual definition.
Once we have computed sP C @ r, j for each r and j ,wecan plot a X  X recision-recall surface X  over reformulations. Figure 1 shows the surface for the example in Table 1 with R =20 under the assumption that all relevant documents in rank-ing 3 are unique (meaning there are five additional relevant documents that were not retrieved). We can see that pre-cision increases with both recall and reformulation number, suggesting that the system is doing a better job with the later queries. (It may be easier to read cross-sections of the surface. They are shown in Figure 2.)
Finally, just as average precision is computed as the area under the precision-recall curve, we can define a model-free  X  X ession average precision X  ( sAP ) as the the volume under Table 3: Session average precisions for different per-mutations of the three ranked lists in Table 1. A system is rewarded for finding more relevant docu-ments in earlier queries. the precision-recall surface. An expression for sAP is: where sP C @ r, j is the max of the set of all possible preci-sions at the first point in r j at which recall r is achieved. Computing sP C @ r, j canbedonewiththe O ( n m ) approach described in Section 2.2: 3 within the j th loop, calculate pre-cision and recall r over the documents on the path to that point; if precision is greater than the current known maxi-mum for sP C @ r, j ,update sP C @ r, j to that precision. In this example the volume under the surface is 0 . 261. To test whether sAP follows our intuition that it should be greater when more relevant documents are found for earlier queries, we calculate it for each permutation of the three rankings in our example. The results are shown in Table 3.
In the previous section we extended three traditional eval-uation measures to the case of multi-query session collections in a model-free fashion. The session-based system measures capture the optimal contribution of a system to answer an information need over an entire session. In this section we look at the problem from a user perspective.

Note that our definition of sP C in the previous section takes the maximum value of a set. We could instead take the expected value; this has the advantage of using all of the data as well as not assuming that a user will have the optimal experience with the system. However, taking such an expectation requires a probability distribution over paths; formulating such a distribution requires a user model 4 .
To simplify the space of all possible browsing paths we follow the user model described in Section 2: a user steps down a ranked list of documents until some decision point. It is important that any realization of the distribution over possible paths allows for paths that end before the last re-formulation in the static collection. Then, if  X  is the set of all possible browsing paths that follow the simple user model described earlier, P (  X  ) the probability of a certain path  X   X   X , and M  X  a measure over the path  X  ,thenwe define a session based measure as the expectation
There is also an O ( nm ) dynamic programming approach, but we have not included it in this paper for reasons of space.
A uniform distribution would not work, since most of the paths are very long and therefore have approximately zero precision.
As noted in Section 2, we can express a path  X  as a set of reformulation points.Let us therefore formulate P (  X  = { k 1 ,k 2 , ..., k i } ) as a joint probability distribution of a user abandoning the session at reformulation i , while reformu-lating at positions not include k i , the abandonment cut-off at ranking i ,inthe probability. For the sake of generalizing traditional mea-sures, we will assume that once the user arrives at the i th reformulation, they continue down that ranking as far as necessary to compute the measure.
 We express the probability of a path  X  as,
Here we introduce a simplifying assumption: the reformu-lation position is independent across the ranked lists 1 ..r Then P ( In general, we could make each reformulation point depen-dent on the reformulation number and possibly even on the relevance of documents in the ranking; in this work we have elected to keep them independent for simplicity.

For the realization of the probability distribution over dif-ferent browsing paths we follow Moffat and Zobel [10] in their definition of ranked biased precision and use two geo-metric distributions. The first gives the probability that the i th reformulation is the last; it has an adjustable parameter p reform representing the probability that the user reformu-lates again from their current query. They will only arrive at reformulation i if they reformulate i  X  1times,so: Similarly, the second distribution gives the probability that the k th rank is a stopping or reformulation point with ad-justable parameter p down . A user will arrive at rank k only after deciding to progress down k  X  1times,so: The probability of a path is then
Our definition of P ( r i ) may give non-zero probability to a path that is not valid for a particular collection of static sessions, e.g. one that ends at some point past the last ( m th) reformulation in the collection. To address this, we will trun-cate the distribution P ( r i ) and renormalize it to ensure that the probabilities to stop at different reformulations sum to 1. To do this we simply renormalize the probabilities from 1to m by Pr { r  X  r i } =1  X  p m reform .Thatis, We could similarly truncate and renormalize P ( k j ). How-ever, paths that extend beyond the last retrieved document for a reformulation (typically ranks beyond 1000) will have very low probability and thus they will not contribute in any significant way in the calculation of a measure.
Given a measure M  X  to be computed over the documents viewed on a particular path  X  along with the probability dis-tribution over all paths  X   X   X , we can define a session mea-sure as the expectation of M  X  over the probabilistic space of paths.
Let us consider a path-averaging generalization to preci-sion at cut-off k . First define PC @ k (  X  ) as the precision of the first k documents experienced on path  X  . Then: PC @ k (  X  ) is the total proportion of relevant documents at ranks 1 ..k 1 in r 1 ,1 ..k 2 in r 2 ,andsoon.

PC @ k (  X  )= 1 where k i , the abandonment cut-off at ranking i ,isequalto k  X  ( k 1 + k 2 +  X  X  X  + k i  X  1 ). Plugging that into the expression for E [ PC @ k ] completes the formula.

Similarly, the expectations of recall after k documents can be computed as where and k i is defined as above.

A path-averaging generalization to average precision is: where AP (  X  ) is the average precision of the concatenated list of documents on path  X  .

We can continue to define any measure this way. We will conclude with a path-averaging generalization to nDCG: where nDCG @ k (  X  ) is the nDCG@k of the concatenated list.
All of the above formulations involve summing over paths  X  . In general, summing a function f (  X  )overallpathscan be expressed in a brute-force way as: Note that computing it involves on the order of | r 1 | X |  X  X  X  X | r m  X  1 | = O ( n m )steps.
A running time of O ( n m ) is manageable, but it is not fast, especially as m grows. Since our model for these mea-sures is fully probabilistic, a faster alternative approach to estimating them uses simulation. A Monte Carlo simulation method allows the estimation of a measure via repeated ran-dom sampling. Running a Monte Carlo experiment requires defining a domain of possible inputs, generating inputs ran-domly from the domain using specific probability distribu-tions, performing a deterministic computation using the in-puts, and finally aggregating the results of the individual computations into the final result.

In the case of the user-model based measures proposed above, the input space is the ranking r i at which the user abandons the query and the reformulation cut-offs at all previous queries { k 1 , ..., k i  X  1 } .

Each of the above path-averaging measures can be thought as the expected outcome of the following random experi-ment: 1. Sample the last reformulation r i from P ( r j ). 2. Sample ( k 1 ,k 2 , ..., k i  X  1 ) i.i.d. from P ( k 3. Create a ranked list of documents by concatenating 4. Output measure M over that ranked list.
 This random experiment defines one round of the Monte Carlo experiment. Executing the first two steps requires sampling from a geometric distribution. This can be easily performed assuming access to an algorithm that generates pseudo-random numbers uniformly distributed in the inter-val (0 , 1). Regarding the distribution of the last reformula-tion, since it is renormalized, we can first partition the inter-val (0 , 1) to ((0 ..P ( r 1 )) , ( P ( r 1 ) ..P ( r 1 )+ P ( r P ( r m ) .. 1)). We then use the random number generator to obtain a number in (0 , 1), and output j if this number is in the j -th partition. In the case of the cut-off distribution the same process can be followed. As mentioned earlier we did not renormalize this distribution and thus the last partition does not end in 1, however renormalization can be easily per-formed in the case of Monte Carlo by simply rejecting any sample larger than the upper bound of the last partition.
Repeating the process above B times and averaging the results gives an estimate of the expectation of measure M . For most purposes B = 1000 (which will usually be much less than n m ) should be sufficient; we explore the errors in estimates due to B in Section 6.
Our measures to this point make a strong assumption: that retrieval systems return unique documents for each query reformulation. Under this assumption, the concate-nated ranked list of documents cl which corresponds to a certain browsing path  X  resembles a typical ranked list of document in the standard evaluation paradigm. We cer-tainly do not expect this assumption to hold in real systems; it is likely that documents retrieved for a second query will overlap with those retrieved for the first. When relaxing this assumption,we need to consider how these duplicate docu-ments should be treated from the perspective of the evalua-tion measure.

The first question raised is whether documents repeated in ranked lists for subsequent reformulations have any value for auser. J  X  arvelin et al. [6] noticed that in an empirical inter-active search study conducted by Price et al. [12] searchers overlooked documents in early queries but recognized them in later reformulations. Due to this, the proposed sDCG measure does not give any special treatment to duplicate relevant documents; it considers them relevant regardless of the number of times they have been seen before.

But measures with a recall component (such as average precision or recall at k ) cannot count duplicates in a sound way. Since there are multiple possible paths through the results, and these paths could have duplicate relevant doc-uments, it is possible that more than R relevant documents could be observed along any given path. The computed measure may exceed the desired maximum value of 1.
We can instead consider duplicate documents nonrelevant in all cases. This has certain implications as well. For one, penalizing a retrieval system for returning duplicate doc-uments may lead to systems that are less transparent to their users. Imagine a user that reformulates a query and expects to see previously observed relevant documents at higher ranks than before. If they are not there, the user may question whether the system can ever be useful to them.
Furthermore, by definition the expected measures reward a retrieval system that respond in an optimal way to a pop-ulation of users. These different users may very well follow different browsing paths. In an actual retrieval setup, a sys-tem can infer whether a document has been observed by a user (e.g. by observing the users X  clicks). In the case of a batch experiment, however, a certain document may be a duplicate for one user but not for another, depending on the browsing path each one of them has followed. This informa-tion is hidden in the parameters of the particular evaluation measure (which simulates the population of users). Tak-ing these parameters into account a system could respond optimally by removing the expected duplicate documents. However, the need of such an in ference process and a rank-ing function that accounts for the average browsing path is just an artifact of the batch nature of experiments. A retrieval system running in the real world will not need to employ such an algorithm.

Yang and Lad [16] take an approach in between the two ex-tremes. Although they did not explicitly consider the prob-lem of exact duplicates, the proposed measure is a measure of information novelty over multi-query sessions and thus it takes the typical approach other novelty measures take [4] by defining information nuggets and discounting documents that contain the same relevant information nugget.
In this work we consider an alternative treatment of du-plicates inspired by Sakai X  X  compressed ranked lists [14] and Yilmaz &amp; Aslam X  X  inducedAP [17]. When considering a path  X  out of the population of all paths, we construct the con-catenated list cl that corresponds to this path. We then walk down the concatenated list and simply remove dupli-cate documents, effectively pushing subsequent documents
The measure by Yang and Lad [16] was proposed for the task of information distillation and thus it operates over passages instead of documents; the same approach however could be used for the case of documents. one rank up. This way, we neither penalize systems for re-peating information possibly useful to the user, nor do we push unnecessary complexity to the retrieval system side. Further, the measures still re ward the retrieval of new rele-vant documents. Note here that such an approach assumes that a system ranks documents independent of each other in a ranked list (probabilistic ranking principle [13]). If this is not true, i.e. if ranking a document depends on previ-ously ranked documents and the retrieval system is agnostic to our removal policy then this may also lead to unsound evaluation.
In this section we demonstrate the behavior of the pro-posed measures. There is currently no  X  X old standard X  for session evaluation measures; our goal in this section is to evaluate whether our measures provide information about system effectiveness over a session and whether they cap-ture different attributes of performance in a similar way to traditional precision, recall, and average precision. We will compare our measures to the session nDCG measure pro-posed by J  X  arvelin et al., though we consider none of these, nor any other measure, to be the one true session measure.
We use two collections towards these goals: (a) the TREC 2010 Session track collection [7], and (b) the TREC-8 (1999) Query track collection [2]. Though the latter is not a collec-tion of multi-query sessions, we will find it useful to explore properties of our measures. Both of these collections are described in more detail below.

The instantiation of session nDCG@k we use is calculated as follows: we start by concatenating the top k results from each ranked list of results in the session. For each rank i in the concatenated list, we compute the discounted gain as where b is a log base typically chosen to be 2. These are the summands of DCG as implemented by Burges et al. [3] and used by many others. We then apply an additional discount to documents retrieved for later reformulations. For rank i between 1 and k , there is no discount. For rank i between k +1 and 2 k , the discount is 1 / log bq (2 + ( bq  X  1)), where bq is the log base. In general, if the document at rank i came from the j th reformulation, then Session DCG is then the sum over sDG @ i with j = ( i  X  1) /k ,and m the length of the session. We use bq = 4. This implementation resolves a problem present in the original definition by J  X  arvelin et al. [6] by which docu-ments in top positions of an earlier ranked list are penalized more than documents in later ranked lists.

As with the standard definition of DCG, we can also com-pute an  X  X deal X  score based on an optimal ranking of docu-ments in decreasing order of relevance to the query and then normalize sDCG by that ideal score to obtain nsDCG@k. nsDCG@k essentially assumes a specific browsing path: ranks 1 through k in each subsequent ranked list, thereby giving a path of length mk . Therefore, we set the cut-offs of our expected session measures to mk (with the excep-tion of AP). For the computation of the expected session measures the parameter p down is set to 0.8 following the recommendation by Zhang et al. [18]; in expectation, users stop at rank 5. The parameter p reform is set arbitrarily to 0.5 .With m = 2 reformulations, the probability of a user stopping at the first reformulation is then 67% and mov-ing to the next reformulation 33%, which is not far off the percentage of users reformulating their initial queries in the Excite logs [15].
The Session track collection consists of a set of 150 two-query sessions (initial query followed by one reformulation). Out of the 150 sessions, 136 were judged. The judged 136 topics include 47 for which the reformulation involves greater specification of the information need, 42 for which the re-formulation involves more generalization, and 47 for which the information need  X  X rifts X  slightly. In the case of spec-ification and generalization, both the initial query and its reformulation represent the same information need, while in the case of drifting the two queries in the session represent two different (but related) information needs. Given that some of the proposed session measures make the assump-tion of a single information need per session X  X hese are the recall-based measures such as AP and recall at cutoff k  X  X e drop the 47 drifting sessions from our experiments.
Each participating group submitted runs consisting of three ranked lists of documents: RL1 ranked results for the initial query; RL2 ranked results for the query reformulation indepen-RL3 ranked results for the que ry reformulation when the Thus, each submission consists of two pairs of runs over the two-query session: RL1  X  RL2, and RL1  X  RL3. The document corpus was the ClueWeb09 collection. Judging was based on a shallow depth-10 pool from all submitted ranked lists. Kanoulas et al. detail the collection further [7].
Figure 3 shows example precision-recall surfaces for two submissions, CengageS10R3 [9] and RMITBase [8]. In both cases there is a moderate improvement in performance from the first query to the second. The decrease in precision is rapid in both, but slightly less so in RMITBase. As a result, though CengageS10R3 starts out with higher precisions at lower recalls, the model-free mean sAP sareclose: 0 . 240 and 0 . 225 respectively. In general, these surfaces, like tradi-tional precision-recall curves, provide a good sense of relative effectiveness differences between systems and where in the ranking they occur.

We use the submitted RL1 and RL2 runs (27 submissions in total) to compare the proposed model-based measures with normalized session DCG. nsDCG is computed at cut-off 10. We compute all measures in Section 2 with cut-off 2  X  10 = 20 (to ensure the same number of documents are used). Scatter plots of nsDCG@10 versus expected session nDCG@20 (esnDCG), PC@20 (esPC), RC@20 (esRC), and AP (esAP) are shown in Figure 4. Each point in the plot corresponds to a participant X  X  RL1  X  RL2 submission; mea-sures are averaged over 89 topics. The strongest correlation and AP (esAP) for the four plots from left to right and top to bottom. is between esnDCG and snDCG (as expected). Interestingly, esAP strongly disagrees with snDCG; this demonstrates that esAP measures different aspects of system effectiveness over sessions than snDCG. Table 4 shows  X  correlations between all the expected measures as well as the model-free sAP; overall the correlations are within the range expected for these measures with a relatively small number of input sys-tems. They are high relative to random orderings, but low enough that it is clear that all the measures are capturing different aspects of effectiveness. esAP and sAP do not cor-relate very well, but recall that sAP is based on maximums while esAP is based on averages.
The Query track [2] was an effort to understand the system-query-topic interaction often observed in IR experiments, Table 4: Kendall X  X  tau correlation across the four expected session measures and sAP. where certain systems perform well for certain queries but under-perform for others. A set of 50 topics (topics 51-100 from the TREC-1 collection) was provided to participants; they responded with a set of queries for each topic. The con-structed queries were in one of the following forms, (a) very short: 2-4 words based on the topic and few relevance judg-ments; (b) sentences: 1-2 sentences using the topic and few relevant documents; (c) sentences+feedback: 1-2 sentences using only the relevant documents; and (d) weighted terms. Overall 23 query sets were produced, each consisting of 50 queries corresponding to the 50 topics of TREC-1. Partici-pants ran their retrieval systems over each of the query sets and submitted results for each system for each query set. We use subsets of the 23 query sets and the submitted runs to simulate query sessions.

The goal of our first experiment is to empirically verify that the proposed measures reward early retrieval of relevant documents in the session. In this experiment we simulate four sets of session retrieval algorithms over 50 two-query sessions. The first simulated algorithm ( X  X ood X  X  X  X ood X ) per-forms well on both the initial query and its reformulation in a hypothetical query session; the second ( X  X ood X  X  X  X ad X ) performs well on the initial query but not on its reformu-lation, the third ( X  X ad X  X  X  X ood X ) does not perform well on the initial query but does on its reformulation, and the last ( X  X ad X  X  X  X ad X ) does not perform well on either queries.
To simulate these algorithms, we note that the systems participating in the Query track performed particularly well on short queries (with an average MAP of 0.227), while they did not perform well on the sentence-feedback queries (av-erage MAP of 0.146) [2]. Taking this into consideration we simulate the best algorithm using runs over two short formu-lations of the same query. In particular, the nine runs over the query set named INQ1a with simulated reformulation results from the nine runs over query set INQ1b (with aver-age MAP equal to 0.110 and 0.127 respectively, as computed by trec_eval ) simulated a set of systems performing well both over the initial query of a hypothetical session and its reformulation. We simulate the worst system by runs over two sentence-feedback formulations. In particular the runs over query set INQ3a with reformulations being the runs over query set INQ3b (with average MAP 0.078 and 0.072 respectively) simulated a set of systems that performed well neither over the initial nor over the reformulated query. The other two combinations X  X NQ1a to INQ3b and INQ3a to INQ1b X  X imulated medium performance systems. 6
What we expect to observe in this simulation is that ses-sion measures reward the  X  X ood X  X  X  X ood X  simulated systems the most, followed by the  X  X ood X  X  X  X ad X , the  X  X ad X  X  X  X ood X  and finally the  X  X ad X  X  X  X ad X  systems. Table 5 shows the av-
The query sets INQ1a, INQ1b, INQ3a, INQ3b were man-ually constructed by students at UMass Amherst [2].  X  X ood X  X  X  X ood X  0.378 0.036 0.122 Table 5: esPC@20, esRC@20, and esAP, each aver-aged over nine Query track systems simulating four session retrieval systems. erage mean session scores produced by three of the expected session measures over the four simulated sets of retrieval al-gorithms. The results verify the behavior of the proposed measures. This is the exact same behavior we observed for the sAP measure in Table 3.

We conclude by testing the accuracy of the Monte Carlo method in computing the expected session measures. We simulated a two-query session by randomly selecting two sets of query formulations and their corresponding runs and forming a session from those. We run our O ( n m )exactal-gorithm along with the Monte Carlo method. For the latter we use B = 10, B = 100 and B = 1000 trials. The results are illustrated in the left-hand plot in Figure 5, showing the high accuracy of the Monte Carlo simulation even with as few as 10 repetitions. Obviously, the accuracy of the method depends on the length of the session together with the set parameters p down and p reform . We did not test for different parameters, however we did repeat the same process over 3-query sessions. The results are illustrated at the right-hand side plot in Figure 5. There is somewhat more variance but even with B = 10 the results are very accurate.
In this work we considered the problem of evaluating re-trieval systems over static query sessions. In our effort to make as few assumptions about user behavior over a ses-sion as possible, we proposed two families of measures: a model-free family inspired by interpolated precision, and a model-based family with a simple model of user interaction described by paths through ranked results. With a novel ses-sion test collection and a session collection simulated from existing data, we showed that the measure behaviors cor-respond to our intuitions about their traditional counter-parts as well as our intuitions about systems that are able to find more relevant documents for queries earlier in the session. The measures capture different aspects of system performance, and also capture different aspects than what is captured by the prima ry alternative, snDCG.

They are surely other ways to generalize traditional eval-uation measures and paradigms to session evaluation than those we have presented. Our goal with this work is to de-fine measures as intuitively as possible while keeping models of user behavior simple. In the future we will want to con-sider explicit models of when and why users reformulate: is it based on the relevance of the documents they see? Does it depend on how many times they have already reformulated? Are they willing to go deeper down the ranking for a later reformulation than an earlier one?
There are many cases we have not explicitly considered.  X  X rifting X  information needs, which were part of the TREC 2010 Session track, may require special treatment for eval-B = 100 and B = 1000 , for 2 and 3 query sessions. uation since the set of relevant documents can change as the need drifts. Furthermore, there are many examples of sessions in which a query and its results serve to guide the user in selecting future queries rather than immediately pro-vide relevant documents; while we can apply our measures to these types of sessions, they are clearly not designed to measure a system X  X  effectiveness at completing them.
Deeper understanding of session measures and their rela-tionship to the user experience will come from future work on session test collections, application to  X  X eal X  sessions in query log data, and extensive experimentation and analysis. We plan to continue all these lines of research in the future. We gratefully acknowledge the support provided by the European Commission grant FP7-PEOPLE-2009-IIF-254562 and FP7/2007-2013-270082 and by the University of Delaware Research Foundation (UDRF).
