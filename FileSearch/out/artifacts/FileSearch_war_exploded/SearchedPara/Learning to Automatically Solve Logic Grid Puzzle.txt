 Understanding natural language to solve problems be it algebraic word problems (Kushman et al., 2014; Hosseini et al., 2014) or questions from bi-ology texts (Berant et al., 2014; Kim et al., 2011), has attracted a lot of research interest over the past few decades. For NLP, these problems are of par-ticular interest as they are concise, yet rich in in-formation. In this paper, we attempt to solve an-other problem of this kind, known as Logic Grid Puzzle. Problem.1 shows an example of the same. Puzzle problems in the same spirit as the previ-ously mentioned science problems, do not restrict the vocabulary; they use everyday language and have diverse background stories. The puzzle prob-lems, however, are unique in their requirement of high precision understanding of the text. For a puzzle problem, the solution is never in the text and requires involved reasoning. Moreover, one needs to correctly understand each of the given clues to successfully solve a problem. Another in-teresting property is that only a small core of the world knowledge, noticeably spatial, temporal and knowledge related to numbers, is crucial to solve these problems.

A logic grid puzzle contains a set of categories and an equal number of elements in each category. And the goal is to find out which elements are linked together based on a series of given clues. Each element is used only once. Each puzzle has a unique solution and can be solved using logical reasoning. A logic grid puzzle is called a ( n,m ) -puzzle if it contains n categories and each category has m elements. For the example in Problem.1, there are three categories, namely clients, prices, masseuses and each category has four elements which are shown in the respective columns. A to-tal of five clues are given in free text and the goal is to find the members of the four tuples, where each tuple shall contain exactly one element from each category such that all the members in a tuple are linked together.

To solve such a puzzle problem, it is crucial to understand the clues (for example,  X  X annah paid more than Teri X  X  client. X ). Each clue talks about a set of entities (for example,  X  X annah X ,  X  X lient X ,  X  X erry X ) and their relations ( X  X  greater-than rela-tion between Hannah and the client of Terry on the basis of payment X ). Our system, L OGICIA , learns to discover these entities and the underly-ing semantics of the relations that exist between them. Once the relations are discovered, a pair of Answer Set Programming (ASP) (Baral, 2003) rules are created. The reasoning module takes these ASP rules as input and finds a group con-figuration that satisfies all the clues. L OGICIA has  X  X nowledge X  about a fixed set of predicates which models different relations that hold between enti-ties in a puzzle world. Clues in the puzzle text that are converted into ASP rules, use these predi-cates as building blocks. In this research, our goal is to build a system which can automatically do this conversion and then reason over it to find the solution. The set of predicates that the reasoning model is aware of is not sufficient to represent all logic grid puzzles. The family of logic grid puz-zles is broad and contains variety of clues. Our future work involves dealing with such a diverse set of relations. In this work we assume that the relations in Table 1 are sufficient to represent the clues. Following are some examples of clues that cannot be modeled using the predicates in Table 1.  X  Esther X  X  brother X  X  seat is at one end of the  X  The writer of Lifetime Ambition has a first  X  Edward was two places behind Salim in one  X  Performers who finished in the top three
The rest of the paper is organized as follows: in section 2, we describe the representation of a puzzle problem in ASP and delineate how it helps in reasoning; in section 3, we present our novel method for learning to automatically translate a logic problem described in natural language to its ASP counterpart. In section 4, we describe the re-lated works. In section 5, we discuss the detailed experimental evaluation of our system. Finally, section 6 concludes our paper. Answer Set Programming (ASP) (Baral, 2003; Lifschitz, 1999; Gelfond and Lifschitz, 1991) has been used to represent a puzzle and reason over it. This choice is facilitated by the two important reasons: 1) non-monotonic reasoning may occur in a puzzle (Nagy and Allwein, 2004) and 2) ASP constructs greatly simplify the reasoning module, as we will see in this section. We now briefly de-scribe a part of ASP. Our discussion is informal. For a detailed account of the language, readers are referred to (Baral, 2003). 2.1 Answer Set Programming An answer set program is a collection of rules of the form, L 0 | ... | L k :-L k +1 ,...,L m , not L m +1 ,..., not L where each of the L i  X  X  is a literal in the sense of a classical logic. Intuitively, the above rule means that if L k +1 ,...,L m are to be true and if L m +1 ,...,L n can be safely assumed to be false then at least one of L 0 ,...,L k must be true. The left-hand side of an ASP rule is called the head and the right-hand side is called the body . A rule with no head is often referred to as a constraint . A rule with empty body is referred to as a fact and written as, Example The above program represents the knowledge that  X  X ost birds fly X . If we add the following rule ( fact ) to the program, the answer set of the program will contain the belief that penguins can fly, { bird ( penguin ) , fly ( penguin ) } . However, adding one more fact,  X  ab ( penguin ) .  X , to convey that the penguin is an abnormal bird, will change the belief that the pen-guin can fly and correspondingly the answer set, { bird ( penguin ) ,ab ( penguin ) } , will not contain the fact, fly ( penguin ) .
 Choice Rule m { p ( X ) : q ( X ) } n :  X  L 1 ,...,L k ,..., not L n . Rules of this type allow inclusion in the program X  X  answer sets of arbitrary collections S of atoms of the form p ( t ) such that, m  X | S | X  n and if p ( t )  X  S then q ( t ) belongs to the corresponding answer set. 2.2 Representing Puzzle Entities A ( m,n ) -puzzle problem contains m categories and n elements in each category. The term  X  X uz-zle entity X  is used to refer to any of them. Each category is assigned an unique index, denoted by the predicate cindex/ 1 (the number after the  X / X  denotes the arity of the predicate). The predicate etype/ 2 captures this association. Each element is represented, by the element/ 2 predicate which connects a category index to its element. The pred-icate eindex/ 1 , denotes the tuple indices. The fol-lowing blocks of code shows the representation of the entities for the puzzle in Problem.1. 2.3 Representing Solution Solution to a logic grid puzzle is a set of tu-ples containing related elements. The tuple/ 3 predicate captures this tuple membership infor-mation of the elements. For example, the fact, tuple (2 , 1 ,aimee ) , states that the element aimee from the category with index 1 is in the tuple 2 . The rel/m predicate captures all the elements in a tuple for a ( m,n ) -puzzle and is defined using the tuple/ 3 predicate. 2.4 Domain Constraints In the proposed approach, the logic grid puzzle problem is solved as a constraint satisfaction prob-lem. Given a puzzle problem the goal is to enu-merate over all possible configurations of tuple/ 3 , and select the one which does not violate the con-straints specified in the clues. However, 1) each tuple in a logic grid puzzle will contain exactly one element from each category and 2) an element will belong to exactly one tuple. These constraints come from the specification of a puzzle problem and will hold irrespective of the problem instance. Following blocks of code show an elegant repre-sentation of these domain constraints in ASP along with the enumeration. 2.5 Representing clues Each clue describes some entities and the relations that hold between them. In its simplest form, the relations will suggest if the entities are linked to-gether or not. However, the underlying semantics of such relations can be deep such as the one in clue 5 of Problem.1. There are different ways to express the same relation that holds between en-tities. For example, in Problem.1, the possessive relation has been used to express the linking be-tween clients and masseuses; and the word paid expresses the linking between the clients and the prices. Depending on the puzzles the phrases that are used to express the relations will vary and it is crucial to identify their underlying semantics to solve the problems in systematic way.

In the current version, the reasoning module has knowledge of a selected set of relations and the translation module tries to represent the clue as a conjunction of these relations. All these relations and their underlying meanings are described in ta-ble 1. In this subsection, we describe the represen-tation of a clue in terms of these relations in ASP and show how it is used by the reasoning module. In the next section, we present our approach to au-tomate this translation.

Let us consider the clues and their representa-tion from Problem.1: [1] Hannah paid more than Teri X  X  client. The first rule clue 1 evaluates to true (will be in the answer set) if the element from category 1 with value hannah is linked to some element from cat-egory 2 which has a higher value than the element from its own category which is linked to an ele-ment from category 1 which is linked to teri from category 3 . Since the desired solution must sat-isfy the relations described in the clue, the second ASP rule is added. A rule of this form that does not have a head is known as a constraint and the program must satisfy it to have an answer set. As the reasoning module enumerates over all possi-ble configurations, in some cases the clue 1 will not hold and subsequently those branches will be pruned. Similar constraints will be added for all clues. In the below, we show some more exam-ples. A configuration which satisfies all the clue constraints and the domain constraints described in the previous section, will be accepted as the so-lution to the puzzle. [2] Nancy X  X  client, Hannah and Ginger were all different clients. [3] Hannah was either the person who paid $180 or Lynda X  X  client. To automate the translation of a clue to the pair of ASP rules, the translation module needs to identify the entities that are present in the clue, their category and their value; and the underly-ing interpretations of all the relations that hold between them. Once all the relation instances { R 1 ( arg 1 ,...,arg p the clue are identified, the ASP representation of the clue is generated in the following way: clue :  X  R 1 ( arg 1 ...,arg p The entity classification problem for logic grid puzzles poses several challenges. First, the exis-tence of a wide variety in the set of entities. Enti-ties can be names of objects, time related to some event, numbers, dates, currency, some form of ID etc. And it is not necessary that the entities in puz-zles are nouns. It can be verbs, adjectives etc. Sec-ond and of paramount important, the  X  X ategory X  of a puzzle  X  X lement X  is specific to a puzzle prob-lem. Same element may have different category in different problems. Also, a constituent in a clue which refers to an entity in a particular prob-lem may not refer to an entity in another problem. We formalize this problem in this section and pro-pose one approach to solve the problem. Next, we discuss the method that is used to extract re-lations from clues. To the best of our knowledge, this type of entity classification problem has never been studied before.
Relation Interpretation 3.1 Entity Classification The entity classification problem is defined as fol-lows: Problem description Given m categories C 1 , ..., C m and a text T , each category C i , 1  X  i  X  m , contains a collection of elements E i and an op-tional textual description d i . The goal is to find the class information of all the constituents in the text T . Each category contributes two classes, where one of them represents the category itself and the other represents an instance of that category. Also, a constituent may not refer to any category or any instance of it, in that case the class of that con-stituent is null . So, there are a total 2 m +1 classes and a constituent will take one value from them. Example In the puzzle of Problem.1, there are 3 categories with, C 1 = { Aimee, Freda, Ginger, Hannah } , C 2 = { $150, $160, $170, $180 } , C 3 = { Lynda, Nancy, Terry, Whiteney } and d 1 =  X  X lients X , d 2 =  X  X rices X , d 3 =  X  X asseuses X . The text T , is the concatenation of all clues. In the last clue, there are a total 5 entities, namely  X  X an-nah X ,  X  X erson X ,  X $180 X ,  X  X ydia X , X  X lient X  and the corresponding classes are  X  X nstance of C 1  X ,  X  X n-stance of C 1  X ,  X  X nstance of C 2  X ,  X  X nstance of C 3  X  and  X  X nstance of C 1  X  respectively. The remaining constituents in that clue have the class value null . The constituent  X  X lients X  in the fourth clue refers to the category C 1 .
 Our approach We model the Entity Classifi-cation problem as a decoding query on Pairwise Markov Network (Koller and Friedman, 2009; Kindermann et al., 1980; Zhang et al., 2001). A pairwise Markov network over a graph H , is asso-ciated with a set of node potentials {  X  ( X i ) : i = 1 ,...,n } and a set of edge potentials {  X  ( X i ,X j ) : ( X i ,X j )  X  H} . Each node X i  X  H , represents a random variable. Here, each X i can take value from the set { 1 ... 2 m + 1 } , denoting the class of the corresponding constituent in the text T .
In our implementation, the node potential cap-tures the chances of that node to be classified as one of the possible categories without being af-fected by the given text T . And the edge poten-tials captures hints from the context in T for clas-sification. After constructing the pairwise Markov network, a decoding query is issued to obtain the configuration that maximizes the joint probabil-ity distribution of the pairwise Markov network in consideration. The proposed approach is inspired by the following two observations: 1) to find the class of a constituent one needs some background knowledge; 2) however, background knowledge is not sufficient on its own, one also needs to under-stand the text to properly identify the class of each constituent. For example, let us consider the word  X  X erson X  in clue 5 of Problem.1. Just skimming through the categories, one can discover that the word  X  X erson X  is very unlikely to be a instance of the category  X  X rices X , which is from her knowl-edge about those constituents. However a proper disambiguation may face an issue here as there are two different categories of human beings. To prop-erly classify the word  X  X erson X  it is necessary to go through the text.

The following paragraphs describe the con-struction of the grah H , and the algorithm that is used in the computation of associated set of node potentials and edge potentials.
 Construction of the graph While constructing the graph, we assign a label, L , to each edge in H which will be used in the edge potential compu-tation. Let D G denotes the dependency graph of the text T obtained from the Stanford dependency parser (Chen and Manning, 2014) and dep ( v 1 ,v 2 ) denotes the grammatical relation between ( v 1 ,v 2 )  X  D G . Then the graph, H , is constructed as fol-lows: 1. Create a node in H for each constituent w j in 2. Add an edge ( X i ,X j ) to H if the correspond-3. Add an edge between a pair of nodes 4. Create a node for each element and category 5. If ( X i ,X j )  X  H and L ( X i ,X j ) = Determining Node potentials For each element in the m category, a set of naive regular-expression based taggers are used to detect it X  X  type (For ex-ample,  X  X m-pm time X ). Each element type maps to a WordNet (Miller, 1995) representative (For example,  X  X ime unit#n X ). For each constituent w a similarity score, sim ( w , c ), is calculated to each class c  X  X  1 ... 2 m + 1 } , in the following way:  X  Class c is denoting instance of some category C
Similarity scores are computed between the tex-tual description of the constituent to both the
WordNet representative of E i and the textual description d i using the HSO WordNet similar-ity algorithm (Hirst and St-Onge, 1998). The similarity score, sim ( w , c ), is chosen to be the maximum of them.  X  Class c is denoting a category C i : sim ( w , c ) is assigned the value of HSO Similarity between the textual description and d i .  X  Class c is null : In this case similarity is calcu-lated using the following formula: sim ( w,null ) = MAX HSO  X  max where MAX HSO denotes the maximum similar-ity score returned by HSO algorithm, which is 16.
Node potential for each node X i  X  H , corre-sponding to the constituent w j , are then calculated by, Determining Edge potentials For each edge in the graph H , the edge potential,  X  ( X i , X j ) is cal-culated using the following formula,
In the training phase, each entity in a clue is tagged with its respective class. The probability values are then calculated from the training dataset using simple count. 3.2 Learning To Extract Relations The goal here is to identify all the relations R ( arg 1 ,...,arg p ) that are present in a clue, where each relation belongs to the logical vocabulary described in Table 1 . This problem is known as Complex relation extraction (McDonald et al., 2005; Bach and Badaskar, 2007; Fundel et al., 2007; Zhou et al., 2014). The common approach for solving the Complex relation extraction prob-lem is to first find the relation between each pair of entities and then discover the complex relations from binary ones using the definition of each rela-tion.

Figure 1 depicts the scenario. The goal is to identify the relation possDiff ( E 1 , E 2 , E 3) , where E 1 , E 2 ,E 3 are constituents having a non-null class value. However instead of identifying posDiff ( E 1 , E 2 ,E 3) directly, first the relation Figure 1: Binary representation of the relation possDiff between each pair of entities will be identified. If the relations { posDiff arg posDiff arg ( E 1 ,E 3 ) } are identified, the extraction module will infer that posDiff ( E 1 ,E 2 ,E 3) holds. In a similar manner, a set of total 39 binary relations are created for all the relations described in Table 1.

In the training phase, all the relations and their respective arguments in each clue are given. Using this supervision, we have built a Maxi-mum Entropy based model (Berger et al., 1996; Della Pietra et al., 1997) to classify the relation between a pair of entities present in a clue. Max-imum entropy classifier has been successfully ap-plied in many natural language processing appli-cations (Charniak, 2000; Chieu and Ng, 2002; Ratnaparkhi and others, 1996) and allows the in-clusion of various sources of information without necessarily assuming any independence between the features. In this model, the conditional proba-bility distribution is given by: where the denominator is the normalization term and the parameter  X  i correspond to the weight for the feature f i . Features in Maximum Entropy model are functions from context and classes to the set of real numbers. A detailed description of the model or parameter estimation method used -Generalized Iterative Scaling, can be found at (Darroch and Ratcliff, 1972).

Table 2 describes the features that are used in the classification task. Here, path ( E 1 ,E 2 ) de-notes all the words that occur in the path(s) con-necting E 1 and E 2 in the dependency graph of the clue.
 Feature Set Class of E 1 and E 2
All the grammatical relations between the words in path ( E 1 ,E 2 ) All the adjectives and adverbs in path ( E 1 ,E 2 ) . POS tags of all the words in path ( E 1 ,E 2 ) TypeMatched = [[class of E 1 = class of E 2 ]] Is E 1 Numeric = [[class of E 1 is Numeric ]] Is E 2 Numeric = [[class of E 2 is Numeric ]]
All the words that appears in the following grammatical relations advmod , amod , cop , det with the words in path ( E 1 ,E 2 ) . hasNegativeWord = [[  X  w  X  path ( E 1 ,E 2 ) s.t. w has a neg relation starting with it.]] Table 2: Features used in the classification task
The relation between each pair of entities in a clue is the one which maximizes the conditional probability in equation (1). 3.2.1 Missing Entity In the case of comparative relations in Table 1, such as greaterThan , the basis of the compar-ison can be hidden. For example, in clue 1 of the example problem, the two entities,  X  X annah X  and  X  X lient X  have been compared on the basis of  X  X rice X , however there is no constituent in the clue which refers to an element from that category. The basis of comparison is hidden in this case and is implied by the word  X  X aid X . In the current imple-mentation, the translation module does not handle this case. For puzzles that contain only one cate-gory consisting of numeric elements, the transla-tion module goes with the obvious choice. This is part of our future work. There has been a significant amount of work on the representation of puzzle problems in a formal lan-guage (Gelfond and Kahl, 2014; Baral, 2003; Ce-lik et al., 2009). However, there has not been any work that can automatically solve a logic grid puz-zle. The latest work (Baral and Dzifcak, 2012) on this problem, assumes that the entities in a clue are given and the authors manually simplify the sen-tences for translation. Furthermore their represen-tation of logic grid puzzles does not consider the category of a variable in the formal representation i.e. uses element/ 1 and tuple/ 2 predicates and thus cannot solve puzzles containing more than one numeric categories.

In the same work (Baral and Dzifcak, 2012), the authors propose to use a semantic parser to do the translation. This method works well for simple sentences such as  X  X onna dale does not have green fleece X  however it faces several challenges while dealing with real world puzzle sentences. The difficulty arises due to the restrictions enforced in the translation models used by the existing se-mantic parsers. Traditional semantic parsers (Vo et al., 2015; Zettlemoyer and Collins, 2005) as-sign meanings to each word in a dictionary and combine the meaning of the words to character-ize the complete sentence. A phrase structure grammar formalism such as Combinatory Cate-gorial Grammar (Steedman and Baldridge, 2011; Vo et al., 2015; Zettlemoyer and Collins, 2005), Context Free Grammar (Aho and Ullman, 1972; Wong and Mooney, 2006), is normally used to ob-tain the way words combine with each other. In the training phase, the semantic parser learns the meanings of words given a corpus of &lt; sentence, meaning &gt; pairs and stores them in a dictionary. During translation, the semantic parser uses those learned meanings to obtain the meaning of the sen-tence. Firstly, for the puzzle problems the mean-ing of the words changes drastically depending on the puzzle. A word may be an entity in one puz-zle, but, in a different problem it might not be an entity or might belong to a different category alto-gether. Thus a learned dictionary may not be use-ful while translating clues in a new puzzle. Sec-ondly, in puzzles relations are normally expressed by phrases. For example, in the clue  X  X he per-son who played at Eden Gardens played for In-dia X , the phrases  X  X layed at X  and  X  X layed for X  are used to express two different relations. Thus, us-ing a model that assigns meaning to each word may not be suitable here. Finally, it is difficult to identify the participants of a relation with a parse tree generated following a phrase structure gram-mar. For example, consider the parse tree of the clue  X  X he person who trekked for 8 miles started at Bull Creek X . Even though, the relation  X  X tarted at X  takes the word  X  X erson X  and  X  X ull Creek X  as its input, it receives the entire phrase  X  X he person who trekked for 8 miles X  as its argument along with the other input  X  X ull Creek X .
 The entity classification problem studied in this Figure 2: Parse tree of an example sentence in Combinatory categorial grammar research shares many similarity with Named En-tity Recognition (Nadeau and Sekine, 2007; Zhou and Su, 2002) and the Word Sense disambiguation (Stevenson and Wilks, 2003; Sanderson, 1994) task. However, our work has a major difference; in the entity classification problem, the class of an entity varies with the problem and does not belong to a known closed set, whereas for the other two problems the possible classes are pre-specified. Dataset To evaluate our method we have built a dataset of logic grid puzzles along with their correct solutions. A total of 150 problems are collected from logic-puzzles.org . Out of them 100 problems are fully annotated with the entities and the relations information. The remain-ing 50 puzzles do not have any annotation except their solution. The set of annotated puzzles con-tain a total of 467 clues, 5687 words, 1681 entities and 862 relations. The set of 50 puzzles contain a total of 222 clues with 2604 words.
 Tasks We evaluate L OGICIA on three tasks: 1) puzzle solving; 2) entity classification; and 3) re-lation extraction. We use the percentage of correct answers as the evaluation metric for all the three tasks. In case of a logic grid puzzle solving, an answer is considered correct if it exactly matches the solution of that puzzle.
 Training-Testing Out of the 100 annotated puz-zle problems 50 are used as training samples and remaining 50 puzzles are used in testing. The set of 50 unannotated puzzles are used solely for the task of testing puzzle solving. Total 1766 960 450 50 Correct 1502 922 854 410 365 37 Percentage 85.05% 96.04% 88.95% 90.90% 81.11% 74% Results Table 3 &amp; 4 shows the efficacy of our approach in solving logic grid puzzles with the se-lected set of relations. L OGICIA is able to classify the constituents with 85 . 05% accuracy and is able to solve 71 problems out of the 100 test puzzles. It should be noted that puzzle problems requires precise understanding of the text and to obtain the correct solution of a puzzle problem all the entities and their relations in the puzzle need to be identi-fied. Columns 2 and 3 in Table 3 compares the per-formance on relation extraction when it is used in conjunction with the entity classification and when it directly uses the annotated entity.

Total Correct Percentage 50 34 68% Table 4: Accuracy on unannotated 50 test puzzle problems.
 Error Analysis The errors in entity classifica-tion falls into two major categories. In the first category, more knowledge of similarity is needed than what is currently obtained from the WordNet. Consider for example, the categories are  X  X lass number X  and  X  X lass size X  and the constituent is  X 20 students X . Even though the constituent is closer to  X  X lass size X , standard WordNet based similarity methods are unable to provide such in-formation. In the second category, the WordNet similarity of the constituent to one of the classes is quite high due to their position in the WordNet hierarchy; however with respect to the particular problem the constituent is not an entity. The re-lation extraction task performs fairly well, how-ever the binary relation classification task does not jointly consider the relation between all the enti-ties and because of that if one of the necessary bi-nary relation of a complex relation is misclassified, the extraction of the entire relation gets affected. This paper presents a novel approach for solving logic grid puzzle. To the best of our knowledge, this is a novel work with respect to the fact that that it can automatically solve a given logic grid puzzle.
 There are several advantages of our approach. The inclusion of knowledge in terms of a vocab-ulary of relations makes it scalable. For puzzles which make use of a different set of constraints, such as  X  X ynda sat on an even numbered position  X , can be easily integrated into the vocabulary and the system can then be trained to identify those relations for new puzzles. Also, the proposed ap-proach separates the representation from reason-ing. The translation module only identifies the re-lation and their arguments; it is not aware of the meaning of those relations. The reasoning mod-ule, on the other hand, knows the definition of each relation and subsequently prunes those possibili-ties when relations appearing in a clue does not hold. This separation of representation from rea-soning allows the system to deal with the complex relations that appear in a clue.

There are a few practical and theoretical issues which need to be addressed. One of those is up-dating the logical vocabulary in a scalable manner. Logic grid puzzle is a wide family of puzzles and it will require more knowledge of relations than what is currently available. Another challenge that needs to be addressed is the computation of simi-larity between complex concepts such as  X  X ize of class X  and  X 20 students X . Also, the case of  X  X iss-ing entity X  (3.2) needs to be modeled properly. This work is the first step towards further under-standing these important issues.
 We thank NSF for the DataNet Federation Consor-tium grant OCI-0940841 and ONR for their grant N00014-13-1-0334 for partially supporting this re-search.
