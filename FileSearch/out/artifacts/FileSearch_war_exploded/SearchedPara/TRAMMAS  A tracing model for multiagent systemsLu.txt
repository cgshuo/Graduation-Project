 1. Introduction
Due to their flexible and adaptative behavior, multiagent systems are commonly applied to solve co mplex problems in dynamic and distributed environments. This is not only due to agents X  individual features (like autonomy, reactivity or reasoning power), but also to their capability to communicate , cooperate and coordinate with other agents in the multiagent system in order to fulfill their goals.
In fact, it is this social behavior, more than their individual capabil-itiesasagents,whatmakesmultiagentsystemssopowerful.Social abstractions such as teams, norms, social commitments or trust are the key to face complex situations using multiagent systems.
In Mafik and Pechoucek (2004) , refer to the necessary knowledge to give support to all these social abstractions as social knowledge ,and they also point that it plays an important role in increasing the efficiency in highly decentralized multiagent systems. Traditionally, these social abstractions are mostly incorporated to the multiagent system at user level; this is, from the multiagent application itself, by means of messages among agents or blackboard systems, without any specific support from the multiagent platform. These traditional methods may be easy to implement; however, each agent X  X  social knowledge depends almost completely on the rest of the agents in the multiagent system actively informing of what they are doing, which has some major problems. First, it can lead to excessive overhead in some agents, specially in situations where agents have to send their information to many other agents because of not being able to determine which of them are really interested in receiving it.
Second, it can also be difficult to trust the information provided directly by other agents using messages. This is usually solved by considering that agents are benevolent, but this may not be true in open multiagent systems. And third ,itisverydifficulttoincorporate high level social abstractions, which usually require indirect interac-tion or coordination, using traditional messages, which are a direct way of communication. This weak integration of high level social abstractions is also mentioned as an important flaw by Bordini et al. (2007) .

This work proposes the use of event tracing as a way to provide indirect interaction and coordination in multiagent systems, which can be later used to give support to high level social abstractions. In particular, this document introduces TRAMMAS, an abstract event
TRAce Model for MultiAgent Systems which lets all the entities in the multiagent system share trace information, both at run time and by means of historic information (trace log files).

Applications which extract information from the system at run time are already considered in the field of event driven architectures ( Luckham, 2001 ). Also, the idea of a standard tracing system available for processes in a system already exists in the field of operating systems, for example, in the case of the POSIX standard ( IEEE, 2004 ). However, event tracing facilities are usually conceived in the field of multiagent systems as debugging tools to help in the system X  X  validation and verification processes. Thus, generated events are destined to be understood by a human observer rather than to be used by agents or other entities in the multiagent system.
The TRAMMAS model is proposed to provide a standardized, trace-based support for indirect communication which may be used by any entity in a multiagent system, not only by agents. In order to do so, the model has adopted the taxonomy published by
Omicini et al. (2008) , which is based on two main abstractions: agents and artifacts. On the one hand, agents are autonomous, proactive entities that encapsulate control and are in charge of the goals/tasks that altogether define and determine the whole multiagent system behavior. On the other hand, artifacts are those passive, reactive entities in charge of the services and functions that make individual agents work together in a multia-gent system. According to this vision, both agents and artifacts are considered as tracing entities by the model. More over, the model also supports aggregations of agents or agents and artifacts. As a consequence, any entity in the multiagent system, as well as the multiagent platform itself are also considered susceptible of generating trace events.

The proposed model is based on the publish/subscribe software pattern, which allows subscribers to filter events attending to attributes (content-based filtering). Unlike in some publication/ subscription patterns, such as the well-known observer pattern, the presented trace event model does not require publishers to be aware of which subscribers they have or to which information they are subscribed. The proposed model does not rely on a single, centralized broker, but on a distributed manager, which is in charge of coordinating the event tracing process. This avoids excessive centralization which may lead to bottle necks and poorly scalable systems.

This paper also presents an architectural design, compatible with the TRAMMAS model, which proposes all the tracing information to be offered as tracing services. As with traditional services, entities in the multiagent system have to request these tracing services when they are interested in receiving tracing information. The architecture is designed to integrate the model within a generic multiagent platform.
 The rest of this paper is structured as follows: First of all,
Section 2 reviews previous work carried out by different authors in the fields of event tracing and indirect interaction in multiagent systems. Then, Section 3 reviews generic requirements of a tracing system, which were taken into account when developing the TRAMMAS model, which is described in Section 4. Section 5 presents an architectural design which allows for the incorpora-tion of the model to a multiagent platform. Section 6 presents an example of an agent-based GPS system with certain information needs, where TRAMMAS is compared with other techniques which are not based on event tracing. Finally, Section 7 comments the conclusions of this work, as well as some future lines of work. 2. Related work
There is a need in multiagent systems for indirect ways of interaction and coordination and different research efforts have been carried out in order to satisfy these needs. However, most existing work on event tracing is mainly focused on debugging rather than on the field of agent interaction and communication. This section is divided in two parts. First, Section 2.1 will review existing work in the field of event tracing in multiagent systems and second, Section 2.2 will review related work focused on indirect interaction and communication. 2.1. Tracing in multiagent systems
Event tracing facilities in multiagent systems are usually conceived as debugging tools to help in the validation and verification processes. It is also usual to use these tracing tools as a help for those users which have to understand how the multiagent system works. Thus, generated events are destined to be understood by a human observer who would probably use them to debug or to validate the multiagent system and tracing facilities are mostly human-oriented in order to let multiagent system users work in a more efficient and also convenient way. One of the most popular tracing facilities of MAS is the Sniffer Agent provided by JADE ( Bellifemine et al., 2007 ). This tool keeps tracking of all of the messages sent or received by agents in the system and allows the user/administrator/developer to examine their content. These messages can be stored in a log file to be examined after the application has stopped running, so that the MAS can also be traced off-line. JADE also provides an Introspec-tor Agent, which can be used to examine the life cycle of any agent in the system, its behaviors and the messages it has sent or received.

Both the Sniffer agent and the Introspector Agent make use of the Event Notification Service (ENS), provided by JADE itself. Agents running over JADE can request the AMS to sniff the activity of other agents or the platform itself in order to be notified each time an event occur. Events managed by the ENS are classified into four main groups: life-cycle related events, mes-sage transfer protocol related events, agent messaging events and agent internals related events. The event set provided by the ENS cannot be modified dynamically, in the sense that agents cannot publish new event types for other agents to request them to the ENS. Also, since JADE does not support agent aggregations nor artifacts, only agents are susceptible of generating or receiving trace events.
 JADEX ( Pokahr and Braubach, 2007 ) provides a Conversation Center, which allows a user to send messages directly to any agent while it is executing and to receive answers to those messages from a user-friendly interface. It also provides a DF Browser to track services offered by any agent in the platform at run time and a BDI Tracer which can be used to visualize the internal processes of an agent while it is executing and show causal dependencies among agents X  beliefs, goals and plans. Apart from these facilities, JADEX also incorporates a Remote Agent, which provides access to some of JADE X  X  tracing facilities, like the Agent Introspector and the Sniffer Agent.

The JACK (2008) multiagent platform does not provide a sniffer agent, but it supports monitoring communication among agents by means of Agent Interaction Diagrams. It also provides other introspecting tools with different functionalities: a Design Tracing Tool, to view internal details of JACK applications during execu-tion, and a Plan Tracing Tool, to display and trace the execution of plans and the events that handle them. JACK also provides debugging tools that work at a lower level of abstraction in order to debug the multiagent system in a more exhaustive way: Audit Logging, Generic Debugging/Agent Debugging.
 Other examples of tracing facilities provided by platforms is ZEUS X  Society Viewer ( Collis et al., 1998 ) which, apart from showing organizational inter-relationships among agents in the system, it can also show messages exchanged among agents. ZEUS also provides an Agent Viewer, which allows the user/ administrator to monitor and change the internal state of the agent, its actions, used resources, etc. JASON ( Bordini and H  X  ubner, 2007 ; Bordini et al., 2005 ) provides its Mind Inspector Tool, to examine the internal state of agents across the distributed system when they are running in debugging mode.

Apart from those tools provided b y multiagent platforms them-selves, there are many tracing facilities provided by third party developers. This is the case of Java Sniffer ( Tichy  X  and Slechta, 2006 ), developed by Rockwell Automatio n,astandalonejavaapplication based on JADE X  X  Sniffer Agent which is able to connect to a running
JADE system in order to track messages among agents, to reason about them and to show them to th e user from different points of view. Another third party tool based on JADE X  X  Sniffer Agent is
ACLAnalyser ( Botia et al., 2004 ), which intercepts messages inter-changed by agents during the execution of the application and stores them in a relational database. After the execution, this message database can be inspected to detect social pathologies in the MAS.
Later work by the same authors ( Botia et al., 2007 )combineresults obtained with ACLAnalyser with data mining techniques to help in the MAS debuggi ng process.

MAMSY, the management tool presented by Sanchez-Anguix et al. (2009) lets the system administrator monitorize and manage a MAS running over the Magentix multiagent platform ( Alberola et al., 2007 ). MAMSY provides graphical tools to interact with the MAS and visualize its internal state at run time, including not only nodes and agents, but also organizational units. It also provides a message tracing tool, similar way to
JADE X  X  Sniffer Agent, which lets the system administrator visua-lize message interchange among agents.

In Ndumu et al. (1999) , the authors describe an advanced visualization tools suite for MAS developed with ZEUS, although the authors also claim these tools could be used with other platforms (more precisely, with CommonKADS). The developed suite allows for inspecting message interchange among agents in a society, display-ing graphically the different tasks in the society and its execution state, examining and modifying the internal state of any of the agents in the system and comparing statistics not only for individual agents, but also for agent societies. It also allows for the graphical display of the different tasks in the society and their execution states, examin-ing and modifying the internal state of any of the agents in the system and comparing statistics not only for individual agents, but also for agent societies.

Tracking messages has also been used by Padgham et al. (2005) , which comments an ampliation of the Prometheus meth-odology and the related design tool to help the designer to detect protocol violations by tracing conversations among agents in the system and to detect plan selection inconsistencies.

Lam and Barber (2005a) present an iterative method based on tracing multiagent applications to help the user understanding the way those applications internally work. Lam et al. also present a Tracer Tool which implements the described Tracing Method.
The Tracer Tool can be applied to any agent system implementa-tion, regardless of agent or system architecture, providing it is able to interface with Java X  X  logging API (directly or via a CORBA interface). Results obtained with this method were presented by
Lam and Barber (2005b) . Bosse et al. (2008) present a combina-tion of this Tracer Tool with a Temporal Trace Language (TTL)
Checker presented by Bosse et al. (2006) . This TTL Checker enables the automated verification of complex dynamic proper-ties against execution traces.

As it can be appreciated, although there is also important work carried out by third party develo pers, many multiagent platforms provide their own tracing facilities. However, even these tracing facilities which were not designed by platform developer teams are usually designed for a specific multiagent platform. Also, most of this work is focused on human users, rather than agents. There is not a standard, general tracing mechanism which lets agents and other entities in the system trace each other as they execute like the one provided by POSIX for processes. 2.2. Indirect interaction and communication
The problem of giving support to additional ways of indirect communication and coordination has already been addressed by other authors using overhearing techniques. Overhearing is nor-mally defined as an  X  X ndirect interaction whereby an agent receives information for which it is not addressee X  ( Legras and
Tessier, 2003 ; Kaminka et al., 2002 ; Dignum et al., 2004 ). This techniques have already been used, among others, in order to maintain social situational and organizational awareness ( Rossi et al., 2004 ), to allow team organization ( Legras Onera, 2002 ;
Legras and Tessier, 2003 ), to monitor teams in a non-intrusive way ( Kaminka et al., 2002 ) and to develop advising systems ( Aiello et al., 2002 ; Busetta et al., 2002 ).

Most of the work in overhearing is modeled and implemented using message broadcasting. This is a very straightforward way to do it, but it does not address the relationship between indirect interaction and the environment. However, using broadcasting to perform overhearing is contradictory, since the definition of overhearing, as well as the overhearer role defined for multi-party dialogues in Malouf (1995) , implies that the sender is not always aware of who is receiving its messages, apart from the specified receivers (this is, who are the overhearers). Using broadcasting makes the difference between the overhearer and the message receiver disappear, since both require to be directly contacted by the sender. Overhearing by broadcasting has also the additional flaw of making it impossible to model sending mes-sages to unknown agents which enter an open system unless these new agents inform of their arrival, which reduces the possibilities of the overhearing model.
 Outside the field of overhearing, the environment is claimed by
Weyns et al. (2007) as a first class abstraction, complementary to agents in the system and, at the same time, independent from them, since it provides the surrounding conditions for agents to exist, as well as an exploitable design abstr action for building multiagent system applications. As pointed out by Platon et al. (2005) and
Saunier et al. (2006) , the environment should give support to both direct and indirect interactions in multiagent systems and thus, overhearing should be managed by the environment in order to save this gap between the overhearer and the sender.

Platon et al. (2005) propose a model of environment which supports not only direct communication, but also overhearing without broadcasting. The proposed model considers also non-agent entities present in the multiagent system. In a similar way,
Saunier et al. (2006) introduce a model for the environment, which considers not only agents, but also objects (non-agents) and messages. This model lets agents carry out an active percep-tion of their environment, determining after a symbolic data analysis which data are interesting and discarding the rest.
However, objects are seen in this model only as entities which generate overhearing information, never as overhearers.
Unlike reviewed work about event tracing in multiagent systems, overhearing techniques are focused in providing infor-mation to agents. However, overhearing only considers indirectly receiving regular agent-to-agent messages, which usually do not reflect actions carried out by entities in the system (agents or not), nor by changes in the visible state of these entities. 3. Requirements
This section presents a summary of the requirements which were taken into account when developing the presented model for tracing systems. These requirements can be classified into three groups: functional, efficiency and security requirements. A more detailed description of these requirements can be found in
Bu  X  rdalo et al. (2009) . 3.1. Functional requirements
Any entity in the multiagent system should be able to generate and receive trace events in a non-exclusive way at run time.
Events are delivered to entities as they are generated and they must be able to order chronologically any trace event sequence it may receive. In order to let entities work with both historical and run time information, both on-line and off-line tracing must be supported. In on-line tracing, events are delivered to entities as they are generated. In contrast, in off-line tracing, events gener-ated by entities are not delivered to running entities, but stored in a log file, which can be later opened and processed. Both tracing modes must not be exclusive, meaning that it must be possible for the events generated anywhere in the system to be delivered to some entities while also being stored in some log files. 3.2. Efficiency requirements
Event tracing must be optimized in order to minimize the amount of consumed resources, as well as the overhead it may produce to the multiagent system. Thus, each entity should be able to limit the maximum amount of resources to be allocated to receive events. In the same way, entities must be able to decide which trace events to receive, and only those trace events which are to be delivered to any entity must be retrieved. In order to do so, it must be possible to classify trace events in different classes or types attending to the information which they represent. It must be possible for entities to dynamically define new event types at run time and, as a consequence, an up-to-date list of available traceable event types and which entities generate them must be available to all entities in the multiagent system. Finally, in order to avoid being a bottle neck for the multiagent system, the support of event tracing must be as decentralized as possible. 3.3. Security requirements
Letting tracing entities trace each other X  X  activity has obvious security issues, specially in open multiagent systems. In order to address these issues, each entity must be able to decide which other entities in the system can receive its events, either by means of a direct authorization or by letting other entity in the system decide in its name. Special circumstances, like normative environments, where certain entities have to be able to access to trace events generated by other entities even without an explicit authorization of the origin entity, must also be addressed. Finally, any trace event being generated in the multiagent system must be susceptible of being traced, independently of the privacy rules defined by each entity. 4. The TRAMMAS model
The lack of a standard mechanism which gives support to indirect interaction based on trace events, like the one proposed by the POSIX standard, usually forces developers to design and implement indirect interaction mechanisms as a part of the multiagent application, which makes agent X  X  internal logic more complex and agent applications more difficult to maintain.
This section presents TRAMMAS, a platform independent trace model for tracing events in multiagent systems, considering the set of requirements previously described in Section 3, which objective is providing multiagent systems with a mechanism for indirect interaction and communication. Once incorporated to a multiagent system, either at platform or user level, this trace model would let agents and other entities in the system generate and receive trace events generated by other entities in the system. Also, human developers/operators can use these tracing events in order to trace the multiagent system in order to debug it or to verify its functioning.

From the viewpoint of this model, a multiagent system can be considered to be formed by a set of tracing entities which are susceptible of generating and/or receiving certain information related to their activity as trace events . Events generated by a tracing entity are recorded and delivered to other tracing entities, so that they can retrieve and process all that information in order to fulfill their corresponding goals. The rest of the section will describe in more detail the TRAMMAS model. 4.1. Trace event
This model defines a trace event as a piece of data representing an action which has taken place during the execution of an agent or any other component of the multiagent system. Trace events are generated each time the execution flow of an application reaches certain instructions (tracing points) in its source code.
This model defines the following common attributes for each event:
Event type : Trace events can be classified according to the nature of the information which they represent. This event type is necessary for tracing entities in order to be able to interpret the rest of the data attached to the trace event.
Time stamp : Global time at which the event took place, necessary to be able to chronologically sort events produced anywhere in the multiagent system.
 Origin entity : The tracing entity which originated the event.
Attached data : Additional data which could be necessary to correctly interpret the trace event. The amount and type of these data will depend on the event type. Some trace events may not need any additional information.
 Attending to the origin entity which generates them, trace events can be classified:
Domain independent trace events : These trace events are generated by the multiagent platform itself and thus, they can be present in any multiagent system. Examples of domain independent trace events could be new agent in the platform or new service request .

Domain dependent trace events : These trace events are designed as a part of the multiagent system, in order to give support to its specific needs. Within a virtual market, an example of domain dependent trace event could be sold product .

Trace events can be processed or even combined in order to generate compound trace events, which can be used to represent more complex information. Both domain dependent and domain independent trace events can also be classified into simple and compound. For instance, within a virtual market, a compound event like transaction done could be the result of combining simple trace events sold product and paid product . 4.2. Tracing entities
In this model, a tracing entity is defined as any component of the multiagent system or the multiagent platform which is able to generate or receive tracing information. Thus, from the point of view of the tracing process, any multiagent system is seen as a set of tracing entities. In this trace model, tracing entities can be classified into three main groups:
Agents : Agents are all those autonomous and proactive entities which define the multiagent system behavior. This category includes not only all of the individual application agents in the multiagent system, but also those which may be part of the multiagent platform.

Artifacts : Artifacts are all those passive elements in the multiagent system which are susceptible of generating events at run time or receiving them as an input ( Omicini et al., 2008 ). Artifacts model elements of the multiagent syste m such as databases, resources modeled as web services, physical sensors and actuators and so on. Two or more artifacts can be combined in order to perform more complex tasks and they are also susceptive of generating or receiving trace events as a tracing individual. From the point of view of the tracing system, these combinations of artifacts are also modeled as single artifacts.

Aggregations : If the multiagent system supports aggregations of agents (or agents and artifacts), such as organizational units ( Argente et al., 2009 ), then such aggregations are modeled by the tracing system as a single tracing entities, in the sense that trace events can be generated from or delivered to these entities as tracing individuals.

From the point of view of the model, the multiagent platform can be seen as a set of agents and artifacts. Therefore, elements of the multiagent platform are also susceptible of generating and receiving trace events as any other element in the multiagent system. 4.3. Tracing roles
Any tracing entity in the multiagent system is able to play two different roles related to the tracing process (or tracing roles ): event source ( ES )and event receiver ( ER ). ES entities are those which generate trace events as they execute, while ER entities are those which receive these events. The relation between ES and ER entities is many to many: it is possible for events generated by an ES entity to be received by many ER entities, a swellasitisalsopossibleforan ER entity to receive events from mul tiple ES entities simultaneously.
These two tracing roles are not ex clusive and any tracing entity can play one or both of them at the same time. Regarding to the time when tracing entities can start and stop playing these roles, there are important differences between agents or agent aggregations and artifacts. On the one hand, agents a nd aggregations can start or stop playing any of these roles dynamically according to their current state. On the other hand, artifacts, which are passive/reactive entities, have to adopt the corresponding roles at design time.

The model considers a third tracing role, the Trace Manager (TM) role. The TM role is responsible for controlling and coordinating the entire tracing process: registering t racing entities and event types, as well as giving support to the selective event tracing and security models, further explained in Sections 4.4 and 4.5. This means that there must be at least one tracing entity playing this role in order to give support to all these necessary features. The TM role can be played by a single entity or by a set of different entities in the multi-agent platform at the same time, acting coordinately, even in different nodes of the multiagent system.

When a tracing entity is playing the ER tracing role, the tracing system provides it with a stream ,whichcanbeseenasaspecial mailbox where trace events are stored before the ER retrieves them.
Streams can either be pieces of memory (in on-line tracing) or log files (in off-line tracing). In both cases, the ER entity which owns the stream can limit its size in order not to overload its resources. In addition, the model defines a set of full policies in order to let tracing entities decide what to do with incoming trace events if the stream gets full: stop delivering events to the stream, overwriting previously delivered events in chronological order or flushing events to a log file:
Trace until full : When the tracing stream becomes full, the tracing system stops delivering trace events to that stream and informs the corresponding tracing entity by means of a specific trace event.

Trace loop : When the tracing stream becomes full, the tracing system starts overwriting previously delivered trace events in chronological order, starting from those which were generated first, and informs the corresponding tracing entity by means of a specific trace event.

Trace flush : When the tracing stream becomes full, the tracing system flushes all events to a log file and continues delivering trace events to the stream after informing the corresponding tracing entity.

Trace until full and trace loop policies are specific for on-line tracing, while trace flush is a specific policy for off-line tracing.
Fig. 1 shows all the interactions among ES and ER. In parti-cular, it can be seen how trace events are generated in ES entities before arriving to ER entities, while the TM controls the entire process, interacting with ES and ER entities. 4.4. Selective event tracing
The model defines a subscription protocol based on trace event types which helps reducing as muc h as possible the overhead which tracing information can cause to th e multiagent sys tem. ER entities must subscribe to those trace event s types which they are interested in. In the same way, once an ER entity is not interested in receiving events of a type to which it had prev iously subscribed, the ER entity may unsubscribe from them. As a consequence, only trace events of those types to which at least one ER has previously subscribed are generated and ER entities do not receive any tracing information in which they are not interested in.

Each ES entity has to publish which tracing information it can provide in order to give support to this subscription mechanism at run time. In Fig. 1 it can be seen how ES entities request the TM to publish and unpublished those trac e events they can provide. It can also be appreciated how ER entities are able look for available trace events as well as they can also subscribe and unsubscribe at run time. 4.5. Security
When an ES entity publishes its trace events, it has also to specify which roles and/or entities in the multiagent system are authorized to receive such events. In this way, ES entities decide which ER entities can receive their trace events. This is defined as direct authorization . When an ER entity wants to receive events of a specific event type which come from a specific ES, it has to be authorized as an entity or it has to be able to assume one of the authorized roles. ER entities which are authorized to receive trace events from certain ES entity can also authorize other roles or entities to receive the same trace events. This is defined as authorization by delegation . In this way, the TM maintains an authorization graph for each event type which is being offered by each ES. This authorization graph is dynamic, since tracing entities can add and remove authorizations at run time. When an authorization, direct or by delegation is removed, all those delegated authorizations which depended on the removed one are also removed.

The direct authorization mechanism has the advantage of being conceptually simple; however, asking for an authorization each time an ER entity needs to trace an ES entity can cause an important overhead to ES entities, which may receive too many authorization requests. Authorization by delegation can help reducing the overhead this authorization mechanism can cause to some ES entities while still keeping the security model con-ceptually simple.

The tracing system does not control which entities can assume each role in order to receive trace events of a specific event type or to add and remove authorizations. The model relies on the multiagent platform to provide the necessary security mechan-isms to prevent agents from assuming unappropriated roles.
Fig. 2 shows an UML-like diagram, where all of the model concepts and relationships commented in Section 4 are repre-sented in a formal way. 5. Tracing system architecture
This section describes a generic architecture by which it is possible to incorporate the TRAMMAS model to a multiagent system. In particular, the architecture has been designed to be integrated within a generic multiagent platform by following a service-oriented approach, with the final goals of taking full advantage of the model and to address efficiency and scalability issues. Once the model is implemented within a real multiagent platform, it can be referred to as the Tracing System, that is, the part of the platform in charge of making it possible that entities running on the platform can trace each other.

The architecture considers the same tracing entities than the model (agents, artifacts and aggregations), and it also considers such tracing entities able to play the Event Source ( ES ) and Event Receiver ( ER ) tracing roles. According to the model, agents and aggregations will be able to dynamically adopt and abandon such tracing roles at run time, while artifacts will be designed to statically play one of them, or both, and they will not be able to change this at run time. The architecture proposes the ES entities to offer their respective tracing information in the form of tracing services , which would be requested by the ER entities that were interested in (and also authorized to) receiving such information. Tracing services are described in Section 5.1.

The Trace Manager role is considered by the architecture to be played by the multiagent platform itself. This is accomplished by incorporating the functionality related to this role into the plat-form, in the form of an extra component called the Trace Manager. Depending on the platform, the Trace Manager may be designed as a single component or as a set of components, possibly distributed among the platform nodes. The Trace Man-ager component is further described in Section 5.2.

Besides incorporating the Trace Manager functionality, the architecture also proposes the platform to be the entity which generates the domain independent trace events, or more pre-cisely, the entity which offers the domain independent tracing services to the rest of tracing entities in the multiagent system. This has two main implications. First, the platform will need to be instrumented at the source code level, in order to generate the trace events corresponding to each domain independent tracing service. And second, the generation of such events at the platform level will allow for the production of tracing information that would not be available otherwise, because of being internal to the platform (e.g., changes in an agent X  X  life cycle). In general, the generation of domain independent tracing information at the platform level presents several advantages, with the most impor-tant being efficiency and reliability.

The architecture has been designed to be included in a generic multiagent platform, with no specific requirements other than the support of very general concepts such as  X  X gent X  or  X  X ervice X .
For example, if the platform does not supports artifacts or aggre-gations, then the tracing system will not be able to support them as tracing entities, without any other negative effect. On the contrary, having some features available on the platform could make the Tracing System to be easier to implement. For example, if a general authorization scheme is already implanted on the platform, then the Tracing System may be able to use it directly, without the need of implementing its own. In any case, the incorporation of the architecture to the platform will need the availability of the platform X  X  source code, in order to both implementing the Trace Manager and performing the instrumen-tation which will generate the domain independent trace events. 5.1. Tracing services
Event types described in Section 4 are modeled in the architecture as tracing services . Tracing services are special services which are offered by tracing entities to share their trace events, in a similar way to traditional services. Each tracing entity may offer a set of tracing services, corresponding to the different event types which the tracing entity generates. In the same way as trace events in the model, tracing services can be classified attending to the tracing entity which offers them. Tracing services can also be compound, like trace events in the model, in order to provide more complex tracing information.
When a tracing entity wants to offer any tracing information, it must publish the corresponding tracing service so that other tracing entities can request it if they are interested in its trace events. When a tracing entity does not want to receive certain trace events anymore it only has to cancel the request to the corresponding tracing service. Domain Independent Tracing Services are offered by the multiagent platform and Domain Dependent Tracing Services are offered by tracing entities.
As with traditional services, when tracing services are pub-lished, it is also published which agent roles or tracing entities are authorized to request the service. In this way, when a tracing entity wants to request a tracing service, it has to be previously authorized directly or it has to be able to assume an authorized role. Authorizations for a tracing service can be added and removed at run time by the tracing entity which published it by means of updating the corresponding published data on that tracing service. Tracing entities which have assumed a role which is authorized to request a tracing service, can also authorize other roles to request the service. 5.2. The Trace Manager
As previously commented, the Trace Manager is not a single component, but a set of components integrated within the multiagent platform, which work together to coordinate the entire tracing process. Trace Manager functions can be divided into four modules, each of which can be carried out by one or more components in the multiagent platform, even in different nodes in the platform:
Trace entity module ( TEM ): Module in charge of registering and managing all the tracing entities.

Tracing services module ( TSM ): Module in charge of registering and managing all of the tracing services offered by ES entities.
Subscription module ( SUBM ): Module in charge of storing and managing subscriptions to each tracing service and ES entity.
Authorization module ( AM ): Module in charge of storing and managing the authorization graph for each tracing service and ES.
 Fig. 3 shows how tracing entities interact with the Trace Manager depending on the tracing role that they are playing. These interactions are detailed below:
Publish/unpublish service : When an ES entity wants to share its trace events it has to publish the corresponding tracing services before any other entity can request that information.
Published tracing services are stored in the TSM. When the ES does not want to offer a tracing service anymore, it has to remove the publication. If the tracing service is the first one offered by the ES entity, then this ES is internally registered in the TEM.

Add/remove direct authorization : ES entities which have pub-lished a tracing service can specify which roles have to be assumed by ER entities in order to request that tracing service.
ES entities add and remove direct authorizations for each of the tracing services which they provide and the corresponding authorization graph is stored in the AM.

Add/remove delegated authorization : ER entities which have assumed a role which authorizes them to request a tracing service can also authorize other roles to request that tracing service. In the same way, ER entities can remove those delegated authorizations which they previously added. Mod-ifications in the corresponding authorization tree are regis-tered in the AM.

Look up for service : ER entities can look up in the TSM to know which tracing services are available and which ES entities offer them before requesting any tracing information.

Request service/cancel request : ER entities which want to receive certain trace events from an ES have to request the corresponding tracing service to the Trace Manager. The Trace
Manager verifies against the AM that the ER entity has authorization for that tracing service before adding the sub-scription to the SUBM. When an ER entity does not want to receive events corresponding to a specific tracing service, it has to cancel the request of that service and the corresponding subscription is also deleted in the SUBM. If the ER entity which requests the tracing service was not subscribed to any other tracing service, then this entity is internally registered and listed in the TEM. In the same way, when an ER entity cancels all of its requests, it is internally removed from the TEM. As a consequence, only those trace events for which there is at least one tracing service request in the SUBM are recorded.

Fig. 3 shows how some of the modules can interact among them in certain circumstances. The first time a tracing entity requests or publishes a tracing service, the SUBM or the TSM registers that entity in the TEM module. In the similar way, when a tracing entity unpublishes a tracing service or modifies its corresponding authorization graph, it may be necessary to cancel subscriptions to that tracing service for certain tracing entities. 6. Example
This section will present an example of multiagent system, where different techniques are used to share information among agents. Theoretical costs of transmitting the necessary informa-tion can be used as a measure of the efficiency and scalability of each technique and so, they are studied in the best and worst case for each technique.

Let us consider an agent-based GPS system which, apart from suggesting the best route to get to a destination, it lets vehicles share certain information about the state of the road so that other vehicles can find the best route to their destination or modify it if necessary. For instance, important decreases in the speed of vehicles may be indicative of a traffic jam, a change in the direction may be indicative of a blocking of the way, and so on.
Fig. 4 shows an example of road map, with some nodes ( A  X  F ) connected among them by different roads. In each node there is a station with an agent which receives data from vehicles about the state of its adjacent roads and can also sends recommendations to vehicles about the best route to get to their destination. Each on board device also has an agent in charge of sending, receiving and processing information from the different stations. In the figure, vehicles 1 X 5 departed from different origins to different destina-tions and have initially been suggested an initial route by the
GPS system. Initial routes for each vehicle are also shown in the bottom of the figure. In this case, there is a trouble in the road between A and C which forces vehicles 1 and 2 to reduce their speed dramatically. The on board GPS system of these two vehicles informs adjacent nodes (nodes A and C ) about this decrease in the speed, and the stations in nodes A and C should inform to those vehicles which have the road between A and C in their route so that they are aware of the problem and can make an appropriate decision: find a different way to their destination, go back home or, at least, being alert and avoid having an accident.
From now on, the example will only take consider the transmission of relevant information from stations in each node to those vehicles which may be interested. The internal reasoning process by which stations receive information from vehicles and determine that there is a traffic jam in a road or that a road is closed is out of scope of this work. The road map will be con-sidered to be in a general situation where there are n cars in the system and there is a total amount of n rem remarkable situations to be reported to vehicles on the road.

The rest of the section will explain different strategies to solve the problem of sharing all this information among the different vehicles and stations. Two different solutions have been consid-ered: One based on broadcasting information to all vehicles and one based on an event tracing system like the one presented in this paper.

For the solution based on broadcasting, it will be considered that there is a service, available for agents in nodes, in charge of registering agents in the system (like the AMS in FIPA). As a consequence, for each of the n rem remarkable situations, each station would have to ask the service for agents in the market (this implies a message from the station agent to the service provider to ask for the existing agents and the corresponding answer from the service provider to the station agent). After that, the station agent would have to actively send a message to all vehicle agents in the system each time a remarkable situation is detected. Considering the number of vehicles previously specified, the number of messages sent to inform about all of the remark-able situations would be n msg  X  X  2  X  n cars  X  n n rem . This solution would not only cause unnecessary information traffic, since messages are sent to vehicles which may not be interested in that information, but also would cause overhead in these non interested vehicle agents, which would also have to process this extra information. In Fig. 4 , vehicles 4 and 5 would be informed of a problem in the road between A and C , although none of them had it in its route.

To solve this problem using an event tracing system like the one presented in this paper, station agents have to publish data relating to their adjacent roads as tracing services. So, for each adjacent road, station agents publish a tracing service. Vehicles interested in a road request the corresponding tracing service to one of the stations which provides it and, from that moment, they receive a trace event each time a remarkable situation is detected. In this case, no messages are sent, but trace events. For each remarkable situation, the total amount of trace events trans-mitted ( n t _ events ) would be the number of cars which are inter-ested in that road and requested the corresponding tracing service. In a system where k rem remarkable situations have taken place, the number of trace events transmitted would be ested in a road, no trace events are generated and so, the amount of information transmitted is reduced to that which is strictly necessary. Also, since stations do not have to know which vehicles are interested in their adjacent roads, their internal logic remains simple, unlike in previously shown solutions.

Table 1 shows the number of transmissions (either messages or trace events) as a function of the number of remarkable situations observed in the system. The number of transmissions in the worst case is in the same order for both techniques. However, the best case is constant for event tracing while it is higher using broadcasting. Also, event tracing simplifies station agents X  internal logic, since they only have to process data sent as they drive by vehicle agents and do not have to send the information to all vehicles each time a remarkable situation takes place. Also, vehicle agents can decide about which roads they want to keep informed, which is less overheading for them, since they do not have to process unrequired information about roads they are not going to drive through or roads they have already passed. In the same way, station agents do not have to spend resources in sending data to vehicles which do not need it.
Theoretical results show that event tracing provides a way to coordinate different vehicles without having to contact directly with none of them. The amount of information interchanged among agents in the system is reduced to the minimum neces-sary, which makes the system more efficient and scalable. Station agents X  internal logic keeps as simple as possible, which makes the multiagent system be also easier to develop and maintain. 7. Conclusions and further work
This paper presents TRAMMAS, an abstract model of an event tracing system for multiagent systems. Unlike most traditional tracing systems, the presented model is not only conceived as a helping tool for multiagent system developers or administrators, but also as an additional indirect communication mechanism which lets agents and other entities in the system generate trace events, as well as receiving events generated by other entities.
By allowing trace event interchange not only among single agents, but also among non-agent entities (modeled as artifacts) and aggregations of agents and artifacts, the proposed model provides a more flexible support for indirect interaction and coordination than message-guided approaches like overhearing.
As a consequence, the incorporation of the model to a multiagent system can improve the way in which entities in the multiagent system perceive each other and their environment, which in turn improves the way in which high level social abstractions can be developed and incorporated to the multiagent system.

Along with the trace model, a generic architecture has also been presented. This architecture lets concepts and mechanisms described by the model be incorporated to a multiagent system at the platform level, not only because it is more efficient and flexible than incorporating them at application level, but also because it makes tracing information more reliable, since it has been generated by the multiagent platform itself.

It would also be possible to design a different architecture which were less integrated within the platform and did not required instrumenting the platform source code. However, providing trace event support only at application level would make it very difficult to provide domain independent trace events support, at least in a reliable and efficient way.

Finally, an example where different techniques and strategies have been used to transmit the necessary information among agents has been presented. The analysis performed for each of these techniques shows that event tracing can help reducing the amount of unnecessary information which has to be transmitted and processed, while keeping agents X  internal logic as simple as possible and thus, contributing to the scalability and feasibility of multiagent systems.

The trace model presented in this paper has been integrated with the next version of the multiagent platform MAGENTIX, in order to be able test it in a real multiagent system and to compare results using event tracing with other techniques. Currently, the trace model is also being integrated with the multiagent platform SPADE ( Gregori et al., 2006 ).
 References
