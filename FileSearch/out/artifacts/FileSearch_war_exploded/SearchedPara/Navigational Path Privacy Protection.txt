 Navigationa lpa thque ry,oneofthemostpopu larloca tion-based services (LBSs), determines a route from a source to a destination on a road network. However, issuing path queries to some non-trustworthy service providers may pose privacy threats to the users. For instance, given a query requesting for a path from a residen-tial address to a psychiatrist, some adversaries may deduce  X  X ho is related to what disease X . In this paper, we present an obfus-cator framework that reduces the likelihood of path queries being revealed, while supporting different user privacy protection needs and retaining query evaluation efficiency. The framework consists of two major components, namely, an obfuscator and an obfus-cated path query processor . The former formulates obfuscated path queries by intermixing true and fake sources and destinations and the latter facilitates efficient evaluation of the obfuscated path queries in an LBS server. The framework supports three types of obfuscated path queries, namely, independent obfuscated path query , shared obfuscated path query ,and anti-collusion obfuscated path query . Our proposal strikes a balance between privacy pro-tection strength and query processing overheads, while enhancing privacy protection against collusion attacks. Finally, we validate the proposed ideas and evaluate the performance of our framework based on an extensive set of empirical experiments.
 H.2.4 [ Database Management ]: Systems -Query processing ; H.2.7 [ Database Management ]: Database Administration -Security, in-tegrity, and protection Algorithms, Performance, Security
Digital maps and geo-positioning technologies have produced a profound effect on the advancement of location-based applica-tions. Today, the use of location-based services (LBSs), through which we can quickly access location related information (e.g., lo-cal news, weather, and traffic conditions) and can perform route planning and object search, has become a part of our daily life. Among them, navigational path search forms an important class of LBS applications (e.g., main functionality provided by MapQuest and GoogleMap). A user may request the navigational information from an LBS server on the Internet, which computes a path based on some well-developed shortest path algorithms (e.g., Dijkstra X  X  or A* algorithm) and then returns the result path to the user.
Nevertheless, current use of navigational services poses a pri-vacy threat to the users who have to release to the LBS server their sources and destinations in order to search for a path. Notice that source and destination addresses provide a lot of clues to derive in-formation regarding the users. Consider that Alice, whose home is located at  X 119, Blair Ave, Sunnyvale, CA X , wants to visit a neu-ropsychiatric at  X 112, Edwards Ave, San Jose, CA X . She requests for the driving direction from her home to the clinic via a naviga-tional query Q ( s, t ) that contains her home address as s and the clinic address as t to the LBS server. A returned navigational path is depicted in Figure 1(a). It would not be difficult for adversaries to exploit public information such as voter registration list and yel-low pages to re-identify Alice who has submitted the query and conjecture that Alice wants to visit a neuropsychiatric based on the query. By accumulating further queries issued with the same source/destination address and other relevant information, the in-vasion into one X  X  privacy could be far more extensive.

Recently, privacy protection has drawn extensive research in-terests and led to interesting results. However, most existing re-search efforts dedicated to location privacy aim at not exposing exact user locations. In contrast, navigational path privacy ,which concerns the exposure of both source and destination locations in path queries, has not been addressed. In this paper, we argue that existing solutions for protecting location privacy, including land-mark [7, 25], cloaking [5, 12, 18] and obfuscation [2], cannot be borrowed to protect path privacy, as they would sacrifice the result correctness and performance. First, the landmark approach would replace both the source and the destination of a path query Q with other locations, thus resulting in another path query Q An example is shown in Figure 1(b) where both s and t are changed to two new landmarks s and t , respectively. Nevertheless, the re-trieved path cannot even connect s to t . The cloaking approach would suppress the detail of addresses, e.g., discarding the street number from an exact address. As shown in Figure 1(c), both source s and destination t are cloaked into locations at the street level. As a result, the navigational servers may likely pick an arbi-trary point as an imprecise address to perform the path search. For instance,  X  X l Camino Real X  runs through several cities in Bay Area and the error introduced by cloaking at street level is simply unac-(c) The cloaking approach ceptable since a completely irrelevant path could be returned. By the obfuscation approach, a path query is mixed with a number of dummy path queries. As exemplified in Figure 1(d), a path query set , { Q ( s o ,t o ) ,Q ( s, t ) } , that mixes a dummy query Q the real one Q ( s, t ) , would be sent to the server, which will eval-uate all of them and return a set of paths, naturally including the requested navigational path. Consequently, the user needs to filter out redundant paths returned due to the fake queries. Thus, path privacy is preserved at the expense of additional bandwidth con-sumption and processing overhead.

In a nutshell, a new approach for path query privacy protection is needed. As we analyzed, the new approach, subject to users X  per-sonal needs of privacy protection, should return the required result paths efficiently. In this paper, we develop a path privacy protection framework, based on the idea of obfuscated path query , which can strike a balance between the search efficiency and level of path pri-vacy protection to support different users X  privacy protection needs.
The main idea of the proposed framework is to obfuscate a path query by injecting some fake sources and destinations. In brief, an obfuscated path query Q ( S, T ) represents a set of path queries {
Q ( s, t ) | s  X  S  X  t  X  T } . Replacing a given path query Q with an obfuscated path query Q ( S, T ) (where ( s, t )  X  can address the privacy issue as the real path query cannot be easily figured out from a large number of possible path queries implied by
Q ( S, T ) . Notice that our technique is different from the above-mentioned obfuscation techniques since an obfuscated path query that includes a set of sources S and destinations T is processed as one single query . Through adjusting the sizes of S and T ,thelevel of privacy protection with respect to the original path query can be controlled. Path query obfuscation is achieved by means of a middle-tier trustworthy obfuscation server sitting between a client and a non-trustworthy LBS server. The obfuscation server (i.e., the obfuscator) functions like an anonymizer or a certificate authority that allows a client to obtain services from the server. It obfuscates given path queries with various optimization techniques that can reduce the obfuscation overhead, and then submits the obfuscated path queries to the server. It also filters the path results returned from the server to send each user his/her requested path.
It is straightforward to obfuscate path queries individually. How-ever, processing a large number of obfuscated path queries, each of which represents a path query, will degrade the LBS server per-formance. Thus, we develop several optimization techniques for evaluating obfuscated path queries to reduce the processing over-head. A natural idea to address this performance issue is to share the processing cost among multiple path queries. We consider two strategies to facilitate sharing so as to reduce the processing over-head without sacrificing the privacy protection. First, we obfuscate k path queries { Q ( s i ,t i ) | 1  X  i  X  k } into a shared obfuscate path query , Q ( S, T ) , with processing overhead among multiple path queries. While improv-ing the performance, shared obfuscated path query, however, opens a door to collusion attack . Consider an obfuscated query that contains some queries submitte d by dishonest clients and a true path query (e.g. Alice X  X  query). If those dishonest clients share their original path queries with the server, it becomes easier for the server to find out the true path query. To remedy this problem, we introduce anti-collusion path query obfuscation that extends shared obfuscated path query and supports privacy protection against col-lusion. Second, we exploit the locality of path queries and devise efficient obfuscated path query algorithms.

We implement our algorithms and conduct an extensive simu-lation study. In summary, we make the following important con-tributions in this paper. First, we identify the path privacy threats that arise in popular navigational services, through the disclosure of the source and the destination to a server. Second, we propose a set of path query obfuscation algorithms, i.e., the core compo-nent of obfuscator, to generate obfuscated path queries, and devise anti-collusion obfuscated path query to prevent a path query from being revealed in the presence of collusion attack. Third, we de-sign efficient obfuscated query search and evaluation algorithms for multi-source multi-destination path queries, making use of the spatial correlation of obfuscated locations. Finally, we implement the algorithms and conduct an extensive set of experiments to eval-uate the performance of the proposed framework.

The remainder of this paper is organized as follows. Section 2 presents the preliminaries of our work, including the presentation of road network, the definitions of the path query and obfuscated path query and related properties. Section 3 details obfuscated path query processing framework and discusses the functionalities of main components, i.e., obfuscator and obfuscated path query pro-cessor. Section 4 evaluates the system performance and Section 5 reviews existing work in privacy protection. Finally, Section 6 con-cludes this paper.
In this section, we introduce path queries on a road network, present the concept of obfuscated path queries, and discuss how the use of obfuscated path queries can protect path privacy.
Without loss of generality, a road network is modeled as a weigh-ted graph, G ( V, E ) , where road segments are represented by a set of edges, E , and the endpoints of edges are represented by a set of nodes, V . Each edge ( v i ,v j )  X  E linking a node v i  X  v  X  V is associated with a non-negative distance, d ( v i ,v represents the traveling distance, traveling time or other cost for the road segment. A path from a source node s to a destination node t is represented by a sequence of edges ( s, v 1 ) , ( v 1 ,v 2 and the path distance is the sum of the distances of the involving edges, path from s to t , denoted by P ( s, t ) , is a path with its distance, represented by || s, t || , being the smallest among all possible paths from s to t . Given a road network G ( V, E ) , a source s and a desti-nation t , a path query Q ( s, t ) evaluated on G returns P
Each node represents one location in the geographical space. Is-s to another node t , implying certain relationship between peo-ple/business associated with s and t . Furthermore, a user is very likely to take the returned path P ( t, s ) , and the information leak-age may threaten personal safety. To address this privacy concern, we introduce obfuscated path query, as a key technique for path pri-vacy protection. Each obfuscated path query Q ( S, T ) mixes s and t of a path query Q ( s, t ) with some fake locations, and represents a set of path queries with their sources and destinations included in S and T , respectively, i.e., Q ( S, T )= Take Alice X  X  Q ( s A ,t A ) as an example. An obfuscated path query Q ( S A ,T A ) can be formulated with S A = { s A ,s 1 } and T { t A ,t 1 ,t 2 } as depicted in Figure 2(a).

Next, we quantify the power of the obfuscation in protecting path privacy as breach probab ility in Definition 1. For the case of Q (
S A ,T A ) , the probability that Q ( s A ,t A ) is revealed is When the sizes of S and/or T increase, the breach probability that Q ( s, t ) can be revealed from Q ( S, T ) is decreased.
 D EFINITION 1. Breach Probability . Assume that a path query Q ( s, t ) is obfuscated into an obfuscated path query Q ( S, T that s  X  S and t  X  T . The breach probab ility is the p robability that Q ( s, t ) can be revealed from Q ( S, T ) , i.e., 1
From the efficient path query processing point of view, we should reduce the sizes of S and/or T in an obfuscated path query in order to improve the search performance. Consequently, there arises a need to strike a balance between the privacy and perfor-mance issues. In this work, we analyze the nature of path query processing in road network and propose query processing optimiza-tion techniques that can effectively reduce the processing overhead while retaining large | S | and | T | . Typically, a path query Q on G is evaluated based on some well-known search algorithms, like Dijkstra X  X  algorithm. Basically, Dijkstra X  X  algorithm forms a spanning tree rooted at s and gradually expands the search space until t is reached. The processing cost is bounded by the size/area of a subgraph covered by the spanning tree, assuming that nodes and their edges are clustered [19]. With s as the center and the dis-tance from s to t as the radius of a search area, the cost would be O ( || s, t || 2 ) .

Dijkstra X  X  algorithm is extensible to search paths from a source s to multiple destinations by forming a spanning tree rooted at s to cover all the destinations. Suppose that T is a set of destinations, from s to multiple destinations incurs a search cost similar to or slightly more expensive than that of searching a path from s to one destination. Based on this, the overall processing cost of an obfus-cated path query is O ( observation, we balance the power of path privacy protection and the processing cost by setting appropriate | S | and | T | but naive setting is to keep | S | small and to select fake destinations not farther than || s, t || with respect to s .
In this subsection, we consider three variants of obfuscated path queries, namely, independent obfuscated path query , shared ob-fuscated path query and anti-collusion obfuscated path query .As the required levels of privacy protection is subject to users X  needs, our design allows each user to specify his/her preferred obfuscation power in terms of his/her minimum sizes of S and T of the resulted obfuscated path query, denoted by f S and f T , respectively. The larger f S and f T are set, the larger S and T will be formed and the stronger a protection will be resulted in. In fact, the setting of f (or f T ) provides additional protection against user re-identification. Based on our example, if Alice sets her f S to 1 and f T to breach probability of her obfuscated path query that includes one source and six destinations will be 1 1  X  6 ,thesameas f S f
T =3 . However, adversaries can deduce from the obfuscated path query that the single user is likely to be Alice and she plans to go to one of the six possible destinations. Since this paper focuses on path privacy protection, we only consider the product of |
T | that affects the breach probability of user path query.
Given a set of path queries, an intuitive approach is to obfus-cate each of them into an obfuscated path query, i.e., independent obfuscated path query as defined in Definition 2.

D EFINITION 2. Independent Obfuscated Path Query . Given k path queries, Q ( s 1 ,t 1 ) ,  X  X  X  Q ( s k ,t k ) and their corresponding protection settings ( f S 1 ,f T 1 ) ,  X  X  X  ( f S k ,f T k fuscated path queries, Q ( S 1 ,T 1 ) ,  X  X  X Q ( S k ,T k such that s i  X  S i and t i  X  T i while | S i | = f S i and with 1  X  i  X  k .

Taking k path queries as a unit, we can measure the strength of privacy protection offered by independent obfuscated path query path queries can be revealed from the independent obfuscated path queries, i.e., is O ( path queries, e.g., Alice X  X  Q ( s A ,t A ) and Bob X  X  Q ( s independent obfuscated path queries, namely Q ( S A ,T ( S B ,T B ) , are formed, with S A = { s A ,s 1 } , T A = { t S
B = { s B ,s 2 } and T B = { t B ,t 3 } , as shown in Figures 2(a) and 2(b), respectively. The breach probability that Q disclosed is 1 2  X  3 = 1 6 ,andthat Q ( s B ,t B ) is revealed is . Hence, the breach probability to disclose both Q ( s A Q ( s B ,t B ) is 1 6  X  1 4 = 1 24 . While the destinations are closely located, the processing overhead is proportional to the total num-ber of sources (i.e., 4 ) for both of the independent obfuscated path queries.
Due to a large number of fake path queries, independent ob-fuscated queries incur a high processing overhead. To reduce the overhead while retaining a strong protection on path privacy, we propose shared obfuscated path query, as defined in Definition 3. The basic idea behind shared obfuscated path query is to obfus-cate multiple path queries into one obfuscated path query. We assume for simplicity that the sources and destinations of all k path queries involved in shared obfuscated path queries are distinct. That means given any two path queries Q ( s i ,t i ) i = j  X  s i = s j  X  t i = t j where 1  X  i, j  X  k .

D EFINITION 3. Shared Obfuscated Path Query . Given k Q (
S, T ) is formulated such that { s 1 ,  X  X  X  s k } X  S and {  X 
Since the major motivation to form a shared obfuscated path query is to reduce the processing cost without affecting the privacy protection, the following two conditions must hold. (c) A shared obfuscated path query, Q ( { s A ,s B ,s 1 } , { t ,t B ,t 2 ,t 3 } ) 1. No weaker protection . A shared obfuscated path query Q ( 2. Reduced processing overhead . The processing overhead These two requirements and the definition of shared obfuscated path query provide a useful guidance in terms of how to group path queries into shared obfuscated path queries. A detailed clus-tering algorithm is presented in Section 3. Reconsider Alice X  X  and Bob X  X  path queries. Rather than generating two independent ob-fuscated path queries, Alice X  X  Q ( s A ,t A ) and Bob X  X  Q be obfuscated into a shared obfuscated path query Q ( S, T S = { s A ,s B ,s 1 } and T = { t A ,t B ,t 1 ,t 2 } as in Figure 2(c). The breach probability is then 2 3  X  4  X  1 2  X  3 = 1 36 , smaller than by independent obfuscated path query. Meanwhile, the processing cost of the shared obfuscated path query that incurs fewer sources is reasonably lower than that of independent obfuscated path queries.
L EMMA 1. A shared obfuscated path query Q ( S, T ) that is formulated based on k path queries can off er breach probab ility of ( k ! Proof .Given Q ( S, T ) , there are a total of | S | X | T | The probability to identify all k real path queries is
Shared obfuscated path query implicitly assumes that all k users are honest and they do not know other path queries involved in the shared obfuscated path query. Consider a worst case scenario in which all other ( k  X  1 ) users are impersonated by adversaries that collude with the LBS server, and the obfuscator submits a shared obfuscated path query which includes all the k path queries submit-ted. Then, adversaries who have the full knowledge of their path queries and the shared obfuscated path query can identify a path query issued from the honest user with the breach probability of  X  ` expected value in Lemma 1. To guarantee  X  X o weaker protection X  condition in the presence of a collu sion attack, we propose and for-mulate anti-collusion obfuscated path query, as in Definition 4. D EFINITION 4. Anti-Collusion Ob fuscated Path Query .
 Given k path queries, Q ( s 1 ,t 1 ) ,  X  X  X  Q ( s k ,t k ) path query Q ( S, T ) is formulated such that { s 1 ,  X  X  X  { t 1 ,  X  X  X  t k } X  T , | S | X  ( k  X  1) + max 1  X  i  X  k f S i , and ( k
Anti-collusion obfuscated path query is extended from shared obfuscated path query by including additional ( k  X  1 ) sources and ( k  X  1 ) destinations. Thus, its br each probability, e ven under the worst case scenario (i.e., k  X  1 out of k users collude with the server), is still better than that of independent obfuscated path query (i.e.,  X  X o weaker protection X  condition is satisfied). Lemma 2 pro-vides the detailed proof. Following our Alice and Bob example, an anti-collusion obfuscated path query can be formed as shown in Figure 2(d) with S = { s A ,s B ,s 1 ,s 2 } and T = { t A Compared with shared obfuscated query, S includes ( k  X  1 k =2 ) more sources (i.e., s 2 )and T includes ( k  X  1 ) more desti-nations (i.e., t 1 ). Consequently, the br each probability under collu-sion attacks, 1!  X  the two independent obfuscated path queries.

L EMMA 2. Anti-collusion obfuscated path query Q ( S, T ) stronger than, that offered by the shared obfuscated path query in the presence of collusion attack.
 Proof . A collision attack occurs when adversaries know x out of k path queries with 1  X  x  X  k  X  1 . Notice that we do not con-sider trivial cases where x =0 or x = k , meaning that none or all involved path queries are from the adversaries. Instead of guess-ing k queries, the adversaries only need to locate k  X  out of ( | S | X  x )  X  ( | T | X  x ) queries. In this case, the breach probability that the remaining path query can be revealed is x )! ` k  X  1 , and hence the breath probability offered by anti-collusion obfuscated path query is not higher than that of independent obfus-cated path query.

Similar to shared obfuscated path query, anti-collusion obfus-cated path query must also meet the reduced processing overhead requirement. Any path queries that cannot be obfuscated into shared obfuscated path queries can be obfuscated independently. Thus, the provision of independent obfuscated path queries together with shared and anti-collusion obfuscated path queries allows for com-plementary approaches for path privacy protection.
In this section, we detail the obfuscated path query framework, which includes a path query obfuscator that formulates obfuscated path queries based on user path queries and an obfuscated path query processor that efficiently determine candidate paths for ob-fuscated path queries.
Our obfuscated path query framework is based on the client-obfuscator-server model as depicted in Figure 3, which offers sev-eral advantages. First, clients only need to trust a single entity, i.e., the obfuscator. Although the obfuscator could become the single point of attack or performance bottleneck, a trusted third party is very often assumed in the field of security [3, 18]. Second, cen-tralized obfuscation based on the obfuscator is expected to pro-vide a high obfuscation efficiency. Third, complicated obfuscation logic, such as determining fake sources and destinations that needs knowledge of underlying networks, is hidden from the clients. Last but not the least, it offers a stronger privacy protection as clients do not directly communicate with the server and their path queries are obfuscated and anonymized to the server.

There are three main components, namely, path query obfusca-tor , obfuscated path query processor and candidate result path fil-ter , as illustrated in Figure 3. Path query obfuscator and candidate result path filter in the obfuscator obfuscates path queries and per-forms candidate result path filtering, respectively. Obfuscated path query processor is installed in LBS server for efficient obfuscated path query evaluation.

Each client, u i , sends his/her query Q ( s i ,t i ) along with a pro-tection settings f S i and f T i as a request u i , ( s i to the obfuscator. The communication channel between each client and the obfuscator is secured so that every request is not exposed to parties other than the obfuscator and the corresponding client. In the obfuscator, the received queries are obfuscated by the path query obfuscator into obfuscated path queries, which could be (i) independent obfuscated path query, (ii) shared obfuscated path query, or (iii) anti-collusion obfuscated path query, as previously defined. Then, the obfuscated path queries are sent to the LBS server for processing. In the mean time, the requests are maintained for later result path filtering. Since finding fake sources and destinations for path query obfuscation requires the knowledge of the underly-ing road network, we assume the path query obfuscator maintains a simple road map (e.g., Tiger/Line [24]). Different from sophisti-cated one maintained in the LBS server, this road map does not con-tain real-time traffic information, or the driving directions needed for path search. We leave the detailed discussion of the path obfus-cation algorithm to Section 3.2.

Upon receiving obfuscated path queries, the LBS server evalu-ates the queries. In order to efficiently evaluate obfuscated path queries, an obfuscated path query processor is devised, with effi-cient multi-source multi-destination path search algorithms, as dis-cussed in Section 3.3. After evaluation, result paths are returned to the obfuscator. Finally, those paths are screened by the candidate result path filter and the requested paths are returned to the corre-sponding clients. Thereafter, the satisfied requests are immediately discarded in the obfuscator, for the sake of security.
The function of path query obfuscation, within the path query obfuscator, is to obfuscate path queries so that the path privacy is protected and the path search efficiency can be maintained. We assume that the obfuscator periodically receives a set of requests. Though it is straightforward to obfuscate all the requests into a shared/anti-collusion obfuscated path query, it does not necessarily guarantee a reduced processing cost. Instead, we attempt to cluster path queries into several groups and obfuscate individual groups into obfuscated path queries. Recall that query processing over-head of O ( size of S and maximum distance between sources and destinations. The logic of our obfuscation algorithm is thus based on two steps, clustering and obfuscating . A high-level logic of the algorithm is depicted in Figure 4. Given a set of requests ( I ), each of which is expressed as u, ( s, t ) , ( f S ,f T ) ,itfirstclustersqueriesin disjoint groups S by PathQueryClustering algorithm (line 1), with each request in I only included in one group. Next, it obfuscates queries in each path query group R into an obfuscated path query based on Obfuscating algorithm (line 2-3). We detail these two al-gorithms in the following.

A straightforward approach to cluster path queries based on their sources is to determine their network distances and construct a graph of sources. In this graph, sources are nodes, paths linking sources are edges, and path distances are distances for edges. Then, finding groups of sources can be addressed as the well-known set-cover problem. However, this approach is very inefficient as set-cover problem is NP-complete and determining the distances be-tween sources in a road network to construct a graph is expensive.
We adopt an alternative approach, by approximating path query clustering to alleviate obfuscation overhead. The main idea is to pre-partition the original road network G into l disjointed subnet-works g i ( i  X  [1 ,l ] ) and within each subnetwork, all nodes are connected. We assume that nodes are close to each other if they are co-located in the same subnetwork. Based on this, PathQueryClus-tering algorithm groups path queries with sources located within the same subnetwork, as depicted in Figure 5. It assigns a set each subnetwork g k . Then, it locates for each path query, the cor-responding subnetwork g i that contains its source, and associates the query with S i (line 2-3). After all path queries are examined, those non-empty path query groups are returned (line 4). As the sizes of subnetworks determine the maximal distance between two sources that will be included in an obfuscated path query, it has a direct impact on the query processing cost and its impact will be further evaluated in Section 4.
In our current implementation, we partition a network recur-sively using geometric approach [8] and Kernighan-Lin algorithm (KL algorithm) [13]. The former coarsely partitions a network into two subnetworks by dividing the nodes spatially and the latter fine tunes those two partitioned netwo rks by exchanging nodes between them such that nodes within each pa rtition are conn ected. The pro-cess continues until l subnetworks are formed. Since binary parti-tioning is used, l is set to 2 r ,where r is the number of recursions. The larger the value of l is, the smaller the average size of the sub-networks is resulted, which in turn generates more clusters, each including fewer path queries whose sources are closely located.
Right after the path queries are clustered, each cluster of path queries is obfuscated to an obfuscated path query Q ( S, T Obfuscating algorithm, as outlined in Figure 6. The algorithm determines the required number of sources and destinations, i.e., |
S | and | T | , and generates fake sources and destinations as needed. Determining | S | and | T | . Given a cluster of k requests (i.e., ( s of a shared obfuscated path query Q ( S, T ) . Under the no weaker protection requirement that i.e., k ! imum sizes for S and T . According to Definition 3, | S | should not be less than max i f S i and max i f T i , respectively. As a smaller | S | indicates more saving of the processing overhead, we fix | S | to max i f S i . The next issue is how to determinate servatively, | T | is bounded by path query is not expected to generate more path queries than in-dependent obfuscated path query. Therefore, the bound of the min-imal value of | T | is [ max i f T i , monotonic to | T | that a larger | T | results in a larger value of for a fixed k . By using a binary search, we determine the minimal |
T | so that  X  X o weaker protection X  requirement can be fulfilled.
If there is a need to protect against collusion attack, an anti-collusion obfuscated path query is formed for each cluster, with the derivation of | S | and | T | pretty much the same as that for shared ob-fuscated path query. The only difference is that | S | and be increased by ( k  X  1 ) as in Definition 4. When a cluster only in-cludes one single path query (i.e., k =1 ), an individual obfuscated path query is formed with | S | = f S 1 and | T | = f T 1 Generating fake sources and destinations . After the sizes of S and T are determined, the next step is to generate fake sources s and destinations t . This is very challenging because we need to generate the fake sources/destinations in a way such that (i) those fake sources/destinations cannot be easily identified; and (ii) the extra processing overhead caused by those fake queries is not sig-nificant. In what follows, we consider some possible approaches.
A simple approach is to select nodes from the road network ran-domly as s and/or t . However, this random selection without con-(a) Concurrent Dijkstra X  X  alg. sidering the distance between s and t may deteriorate the per-formance which is highly dependent on || s ,t || .Rather,wemay select the nodes close to s i and t i in order to reduce the distance between them. However, in presence of collusion, adversaries can easily filter out those fake locations if they know what are around.
Taking both the processing cost and the potential collusion at-tack into consideration, we generate fake sources following the distributions of the real sources specified by the users, denoted by set S R = { s | u, ( s, t ) , ( f S ,f T )  X  X } where R ter of requests. We first determine a centroid node, denoted as c , with more or less equal distance to all the nodes in S get the average distance d between nodes of S R and c , i.e., d tances to c are close to d as the fake sources. This approach makes sure all the sources to be included in S (including all fake and real sources) are roughly located in the border of an area centered at c with d as their distances to a centroid and hence it can effectively prevent fake sources from being revealed (e.g., via an outlier detec-tion [9]). In addition, those closely located nodes are less likely to incur a larger query processing overhead and hence the processing cost can be improved. The destinations of an obfuscated path query can be generated in the same fashion. For the case k =1 , indepen-dent obfuscated path query is formulated. We randomly pick a node close to source/destination. Using it as centroid, we generate fake sources/destinations around.
An obfuscated path query Q ( S, T ) involves | S | sources and destinations. The LBS server can invoke any shortest path algo-rithm to process a path query for each Q ( s, t ) with ( s, t T . However, as mentioned before, Q ( s, t ) and Q ( ( s ,t )  X  S  X  T ) with s close to s very likely traverse a similar por-tion of the road network. Thus, processing the queries individually results in duplicate scans of the road network and high processing overhead. Instead, processing of Q ( s, t ) and Q ( s ,t shared. We thus design an obfuscated path query processor to eval-uate path queries concurrently, so that loaded disk page of network data can be used by multiple path searches simultaneously.
We consider Dijsktra X  X  and A* algorithms, both of which are de-signed for general path query that contains a single source and a single destination. We extend them in this paper to handle obfus-cated queries that contain multiple path queries, as detailed below. Concurrent Dijkstra X  X  algorithm . If the path searches started at nearby sources are concurrently executed, loaded disk pages can be used to facilitate different searches at the same time and hence the I/O cost can be reduced. To illustrate this concurrent search, an ex-ample trace for Alice X  X  obfuscated path query (i.e., S = { and T = { t A ,t 1 ,t 2 } ) is shown in Figure 7(a). Starting from s and s 1 , the expansion of the spanning tree of the two threads will visit similar edges at the same time. As such, processing an ob-fuscated path query introduces almost no extra cost over process-ing the original path query. Based on this idea, concurrent Dijk-stra X  X  algorithm is developed. Searches started at different sources are placed in the same priority queue as different threads. Then, a thread with the minimum expansion with respect to the source is chosen to expand the search scope. A thread terminates when it reaches all the destinations. T he search for an obfuscated path query completes when all the threads terminate.
 Multi-path A* algorithm . In many cases, Dijkstra X  X  algorithm suffers from high processing costs to expand a large search space and A* algorithm was proposed to reduce the search space and im-prove the performance via heuristic distances (typically Euclidean distances). For every node v being visited, it makes a conserva-tive estimation of the remaining distance to the destination t , i.e., the Euclidean distances between v and t , and uses that anticipated path distance to sort the access order of nodes. Logically, it can be easily extended to conduct multiple path searches by consider-ing the smallest Euclidean distance to destinations. However, for a large number of destinations, the computation overhead of Eu-clidean distance between the nodes and destinations is not negligi-ble. To alleviate the computational cost, we bound the destinations and represent them using a minimum bounding rectangle in this work. The distance between a node v being visited and the des-tination is calculated as follows. If v is outside the rectangle, we use the Euclidean distance between v to the closest point on the boundary of the rectangle as the heuristic distance. Otherwise, v must be inside the rectangle, and the minimal distance between v and destinations is used as the heuristic distance. An example is shown in Figure 7(b). The rectangle bounds all the destinations (i.e., t 1 ,t 2 ,t A ). As nodes a , b and c are outside the rectangle, the distances between them and the rectangle are taken as the heuris-tic distance. The multi-path A* algorithm completes when all the paths to all the destinations are found.
 Concurrent Multi-path A* algorithm . Concurrent multi-path A* algorithm takes advantage of both concurrent execution and the use of heuristic distances. It arranges the execution order of different search threads based on the anticipated path distances to the desti-nations. The search completes when all the threads terminate. Since all these approaches are based on best-first strategy, we gen-eralize them into an ObfuscatedPathSearch algorithm as outlined in Figure 8. By default, it performs concurrent multi-path A* al-gorithm. Initially, a priority queue H is initialized with entries v,  X , e, p, s , each representing one thread (line 1-2). Here, v rep-resents a pending node to be visited, its distance from the source node s is  X  , and its estimated Euclidean distance to destinations is e , with p keeping track of those visited nodes that contribute to the path from the source s to the destination. For presentation con-venience, we use the source node s to indicate the thread (that is denoted by  X  afterwards).

In H , all the entries are ordered in ascending order of the esti-mated distances between sources and destinations, i.e.,  X  each iteration, the top entry v,  X , e, p,  X  with minimal  X  examined (line 3-10). In case that node v has been visited by the same thread  X  , which is possible as a node can be reached via differ-ent paths, the detailed examination on v is skipped (line 5). When v is a destination, the path from the source to that destination is found. All the nodes recorded in p form the result path, and are collected in P  X  (line 7). Thereafter, all the immediate neighbors of v , denoted as w , are explored and inserted into H for later exam-ination (line 12-13). Here,  X  + d ( v, w ) and dist ( w, T the accumulated distances from source  X  to w and the Euclidean distance from w to all destinations. Once all the paths for a thread are found, the search for the thread completes (line 9-10). If all threads complete, the whole search completes (line 9). Then, all result (candidate) paths are output (line 14-15). The Obfuscated-PathSearch algorithm is generic and can be adapted to implement any particular search algorithm mentioned above. For example, it can be specialized to implement concurrent Dijkstra X  X  algorithm by setting all dist ( w, T ) (line 10) to zeroes and to implement multi-path A* algorithm via replacing S with only one source.
In this section, we evaluate the performance of our framework via simulation. Our simulator consists of a path query generator, a path query obfuscator and an obfuscated path query processor. All of them are developed in GNU C++. This evaluation mainly measures the performance of our proposed obfuscation algorithm and obfuscated path query algorithms in terms of (i) breach rate and (ii) total processing time . Breach rate is measured as the ra-tio of number of true path queries revealed to total number of true path queries. Here, we experiment adversaries to reconstruct path queries by randomly picking sources and destinations from obfus-cated path queries. Total processing time measures the time spent in obfuscation and query processing for all experimented queries. In the evaluation, we use real networks of two cities, namely Oldenburg (OL) and San Joaquin County (TG), obtained from [23]. OL and TG contain 6k and 18k nodes, respectively. In our exper-iments, the path query generator generates 1000 path queries and the sources of path queries are uniformly distributed in the network. The corresponding destinations are picked randomly and the source and destination of a path query is around 0 . 1 of the network diam-eter apart. To support query processing, we index these networks on disk based on CCAM storage scheme [19] and we maintain an LRU cache of 50 pages to buffer recently accessed disk pages. In the evaluation, we conducted all the experiments on a Linux 2.6.9 server with Intel Xeon 3.2GHz CPU and 4GB RAM.

Based on these settings, we evaluate the impact of protection set-tings, f S and f T , that affect the breach probability and search per-formance. We vary them from 5 up to 25 . Also, we study the per-formance of various obfuscated path queries, namely, independent obfuscated path query ( independent ), shared obfuscated path query ( shared ) and anti-collusion obfuscated path query ( anti-collusion ). Among them, independent is the baseline. In our approach, shared and anti-collusion rely on partitioned network to perform path query clustering. We evaluate the size of subnetworks that varies from 1 / 16 to 1 / 128 of the original network size, with 1 / 32 being the default. Finally we examine the performance of various obfus-cated path query algorithms, namely, multi-path Dijkstra X  X  algo-rithm ( Dijkstra ), concurrent Dijkstra X  X  algorithm ( C-Dijkstra ), multi-path A* algorithm ( MPA* ) and concurrent multi-path A* algorithm ( C-MPA* ). Table 1 summarizes all the experimental settings. In the following, we first study the impact of protection settings f and f T , then evaluate the factor of subnetwork sizes, and finally examine different search algorithms.
 In the first set of experiments, we study the impact of f on system performance. In the first step, we fix subnetwork size at 1 / 32 and use Dijkstra as the default search algorithm. We vary f S from 5 up to 25 with a step of 5 and set f T equal to f assume that adversaries know the number of path queries involved in an obfuscated path query and they try to reconstruct a path query by randomly picking pairs of sources and destinations from each obfuscated path query. The breach rate is estimated as the ratio of true path queries found by adversaries among those reconstructed path queries to the total number of true path queries (i.e., 1000). A smaller breach rate implies a stronger privacy protection. Figure 9 shows the breach rate obtained by varying f Consistent with our expectation, there is a drop in breach rate with increased f S ( f T ) since more fake sources/destinations (thus fake path queries) are involved in the obfuscated path queries. How-ever, we can observe obvious differences among the three types of obfuscated path queries. Independent incurs a higher breach rate than shared and anti-collusion for all f S ( f T ) evaluated. This is because shared and anti-collusion involve more sources and desti-nations. The likelihood of picking a pair of matched true source and destination to reconstruct a true path queries is much lower. Due to this reason, anti-collusion further improves the breach rates because of additional ( k  X  1 ) fake sources and ( k  X  1 ) fake destina-tions (where k is the number of participated path queries). Besides, we can observe that the breach rates obtained from different net-works, OL and TG, are very similar since breach rate depends on the number of sources and destinations involved in the obfuscated path query but not the experimented networks.

Next, we examine the impact of f S ( f T ) on total processing time, which is the sum of path query obfuscation time and query pro-cessing time for all the experimented queries. When f S ( f creases, more sources and destina tions are included which results in a longer processing time. Figure 10 depicts the results that the total processing times for all types of obfuscated path query rise with growth of f S ( f T ). We can see that independent incurs longer total processing time than shared and anti-collusion . Notice that due to the smaller network size, query processing based on OL incurs a much shorter processing time, compared with that of TG.
Independent , due to a large total number of sources and desti-nations involved, performs the worst, as shown in Figure 11. As anti-collusion involves more sources and destinations (thus effec-tively more path queries) than shared , the total processing time of anti-collusion is longer than that of shared . Figure 12 shows the number of obfuscated path queries obtained from the 1000 path queries. It is obvious that shared and anti-collusion obfuscated path queries can effectively cut down the number of obfuscated path queries. That means, instead of executing a large number of obfuscated path queries, shared and anti-collusion result in much fewer queries. More importantly, they are derived by grouping path queries with closely located sour ces. This grouping implicitly en-ables additional query optimization such that many disk accesses can be shared among different path searches. Again, the number of sources and destinations is independent of the network size. Thus, OL and TG result in the same numbers of path queries and obfus-cated path queries. Compared with independent , both shared and anti-collusion spend more obfuscation time. However, the obfus-cation time is only a small factor in the total processing time (as shown in Figure 10), because obfus cation does not involve exhaus-tive network traversal.
Shared and anti-collusion obfuscated path queries are formed by grouping path queries with their sources closely located. In our approach, the grouping is based on subnetworks. We investigate the performance with respect to the size of subnetworks, ranging from 1 / 16 , 1 / 32 , 1 / 64 ,to 1 / 128 of the original network size. For smaller networks, the sources of those grouped path queries are close. We experiment with f S ( f T )fixedat10and Dijkstra as the default obfuscated path query algorithm. The results in terms of breach rate and total processing time are shown in Figures 13 and 14, respectively.
As shown in Figure 13, the breach rates of all obfuscated path queries are almost invariant to the subnetwork sizes. The breach rates of shared and anti-collusion obfuscated path queries are lower than that of independent obfuscated path query as previously ex-plained. Next, from Figure 14, we can observe that the decrease of subnetwork sizes improves the performance (i.e., lower processing time) as path queries with closely located sources are obfuscated. This improves the query processing performance. Moreover, the obfuscation times are not affected by subnetwork sizes.
Finally, we study various proposed path search algorithms. In this experiment, we obfuscate path queries based on f S ( f the subnetwork size fixed at 10 and 1 / 32 , respectively. The perfor-mance of different algorithms is plotted in Figure 15. Notice that the breach rate is independent on the search algorithm and thus it is not reported here. It is observed that MPA* ( C-MPA* ) always performs better than Dijkstra ( C-Dijkstra ) due to the use of heuristic distances to prune the search space. Also, we can see that concurrent path search can reduce the processing time. Thus, C-Dijkstra outperforms Di-jkstra as C-MPA* does over MPA* . Interestingly, independent obfus-cated path queries evaluated using MPA* and C-MPA* outperform others. This is because for independent obfuscated path query, fake destinations are picked around the true destination. As a result, those destinations are closely located. Thus, MPA* and C-MPA* can effectively prune the search space. On the contrary, shared and anti-collusion obfuscated path queries are optimized based on the assumption of Dijsktra . They may group path queries with desti-nations far apart and hence the path query obfuscation optimiza-tion is expected to further improve the performance of MPA* and C-MPA* . Finally, MPA* is observed to be performing a bit better than C-MPA* for TG. For C-MPA* , a single heap is used to support multiple path searches so that its size and its operation costs in-creases when a larger network like TG is experimented. Besides, due to a smaller search space covered by both MPA* and C-MPA* and a cache that shortens the data access latency, MPA* slightly outperforms C-MPA* .
Privacy is an important part of human right. Special care is re-quired to prevent private information from being exposed and mis-used. Other than legislation [15] and privacy policy [20] that gov-ern how user data are to be used and managed, earlier works in privacy protection were mainly based on anonymity. The main ob-jective is to keep individuals from being re-identified in data pub-lishing, e.g., release of microdata about patient records to data min-ing scientists. A representative concept is k -anonymity [22]. It removes or replaces individual identifiers (e.g., name and social security number) with quasi-identifiers [21] in such a way that k records corresponding to k users share identical quasi-identifier. Consequently, each user cannot be identified from other k Extending k -anonymity, other notions such as l -diversity [17] and t -closeness [16] are proposed to improve privacy protection and to minimize the information loss.

In the context of LBSs, users need to provide detailed location information in order to receive  X  X ocation-dependent X  services. The concern of location privacy arises and has been receiving attentions from the research community. Thus far, the attention is on how to prevent the locations of individuals from being revealed through accessing LBSs provided by semi-trusted service providers. In ad-dition to those discussed earlier, namely, landmarks [7, 25], cloak-ing [5, 12, 18], obfuscation [2], mix-zones [1] and blind evalua-tion [4, 14] have been proposed. With blind evaluation, data and queries are encrypted so that LBS servers can provide approximate results with respect to encrypted queries without decrypting the queries. However, the encryption is query-dependent. Although many techniques have been proposed to protect location privacy in LBSs, they are not suitable for path privacy protection, as explained earlier. Besides, existing works focus on spatial queries that search objects in an Euclidean space, while our work is for path queries on a road network. Other than location privacy, protection of user movement path privacy [6, 26] has also been studied recently to prevent a user trajectory from being disclosed from a sequence of user locations reported over time.

Path privacy considers a differen t privacy threat arisen in navi-gational search. Without loss of generality, we assume that the lo-cations of corresponding users and business are fixed and known to the public. Yet, the association between source and destination ex-pressed by a path query needs to be protected. Treating the source and destination of a path query as a tuple, path privacy protection problem appears somewhat similar to data publishing. However, techniques for data publishing usually anonymize all records of-fline and they avoid introducing fake records to minimize informa-tion loss. In contrast, for path privacy, we obfuscate path query on-line. Moreover, obfuscating path query requires knowledge of the underlying spatial network. In our approach, we introduce a no-tion of obfuscated path query. Our research goal is to strike a good balance between privacy protection and extra workload incurred by sharing obfuscated path queries among multiple users.
 Finding shortest paths in a network has been studied for long. Over the past decade, advanced techniques for improving short-est path searches were proposed such as HPEV [10] and HiTi [11]. They precalculate and materialize shortest paths for each fragmented subnetworks. Upon a path query, the shortest path between a source and a destination is reconstructed by those fragmented shortest paths. However, these techniques incur high storage overhead, and short-est path precomputation and maintenance costs. Thus, primitive work such as Dijkstra X  X  algorithm and its variant A* algorithm are still commonly used for single-pair shortest path search.
Navigational path search, one of the most popular location-based services, returns a path from a source to a destination on a road net-work. However, expressing the search interest of a user to a semi-trusted server raises a privacy concern. For instance, when Alice sends a query to a navigational server for a path from her home to a clinic, adversaries can deduce her identity and possible activities based on the home and clinic addresses. While the requested paths should be produced, the protection for the path queries is needed.
To address this problem, we develop a framework based on the idea of obfuscated path queries that mix some extra fake sources and destinations to path queries. Each individual path query can be simply obfuscated as an independent obfuscated path query, but this incurs high processing overhead. Thus, we devise shared ob-fuscated path query that shares an obfuscated path query among multiple path queries. This sharing may still have to bear a risk of collusion attack, which occurs when some path queries are issued by adversaries. Based on the known path queries and obfuscated path queries, the likelihood for a path query involved in shared ob-fuscated path being revealed is increased. To address this, we pro-pose anti-collusion obfuscated path query and discuss the system issues about the selection of fake sources and destinations. Besides, to alleviate the processing overhead, we devise multi-source multi-destination path search algorithms to search paths concurrently and the use of heuristic distances to prune unneeded search space.
We evaluate our framework based on simulation. The experi-ment results indicate that shared and anti-collusion obfuscated path queries can ensure the privacy protection and improve the path search performance, compared w ith independent obfuscated path query. Meanwhile, concurrent path searches through source clus-tering can reduce the query processing overhead.
Ken Lee and Wang-Chien Lee were supported in part by the Na-tional Science Foundation under Grant no. IIS-0534343 and CNS-0626709. Hong Va Leong was supported in part by the Hong Kong Research Grant Council under Grant number HKBU 1/05C.
