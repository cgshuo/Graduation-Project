 REGULAR PAPER Gong Chen  X  Xindong Wu  X  Xingquan Zhu  X  Abdullah N. Arslan  X  Yu H e Abstract This paper defines a challenging problem of pattern matching between a pattern P and a text T , with wildcards and length constraints, and designs an pattern matching problem, the user can specify the constraints on the number of wildcards between each two consecutive letters of P and the constraints on the length of each matching substring in T . We design a complete algorithm, SAIL 1 between the user-specified maximum and minimum numbers of wildcards allowed between two consecutive letters in P .
 Keywords String matching  X  Wildcards  X  Constraints 1 Introduction Not only has pattern matching with wildcards attracted many theoretical studies but it owns a significant impact on many real-world applications such as text in-dexing and biological sequence analysis.  X  Text indexing . The Internet is awash with an abundance of textual information  X  Sequence analysis . The DNA sequence TATA is a common promoter that of-and research from theoretical complexity analysis has provided many solutions to solve different kinds of problems. Among them, Fischer and Paterson [ 4 ]were the first who generalized pattern matching with wildcards: given a pattern P and improvements in terms of time complexity have been proposed, but the following problems are still open. 1. Complex local constraints When searching for occurrences of a pattern P in 2. Global length constraints In many situations, the user may want to constrain ing in this paper.
 [7, 8]. The following left alignment shows one occurrence.
 the above right alignment. Since the length of the matching substring in which P alignment does not show an occurrence of P in T.
 existing research efforts and can be used to deal with Example 1, and propose an and the range of the length of a matching substring in which the pattern occurs. vey on related research efforts and analyzes their differences from our problem. Section 3 presents our problem statement. Section 4 describes the design of our algorithm, SAIL, and provides a running example. Section 5 analyzes the correct-ness and complexity of SAIL. Section 6 discusses the feasibility of applying some common approaches to our problem. Section 7 draws our conclusions. 2 Related work  X  can match any letter in a given alphabet. The objective of their work was to find number of  X  s, between every two consecutive letters in P . Several improvements a slightly different problem, where instead of fixing the number of  X  s between two consecutive letters in P and T, they fixed the total number of  X  sin P .The disadvantage of these problem definitions is that the number of  X  s is a constant but not a range. This limits flexibilities for the user X  X  queries.
 enough flexibilities to control their queries.
 by the fly (followed-by) operator. For example, we may try a query  X  X ice fly fog X  which means mice followed by fog, separated by at most g (a user-defined con-proposed an algorithm for string matching with a sequence of wildcards. They the text are returned. The number of  X  s between P and Q is in the range of [0, matching with variable-length don X  X  cares based on edit distances and dynamic programming. The work in [ 10 ] is the closest to our problem in this paper, but P  X  number of all possible occurrences is in fact exponential, for example, it can be its efficiency becomes a problem.
 of  X  s in every occurrence is not bounded. We consider a challenging problem that the range of  X  s number between every two consecutive letters in the pattern can range of  X  s is just a local constraint for a query pattern and the user may also want to specify a range for the total length of each matching substring in which the pattern occurs. So we also take global length constraints into consideration. 3 Problem statement Definition 1 Given  X  minLen and maxLen, the minimum and maximum length constraints for a T X  X  n  X  1, 0  X  j  X  m  X  1, i 1. t i j = p j , 2. min j  X  1  X  i j  X  i j  X  1  X  1  X  max j  X  1 , 3. minLen  X  i m  X  1  X  i 0 + 1  X  maxLen , t straint and the third condition is a global constraint .
 Problem 1 Our objective is to find the maximum number of occurrences of P in j  X  m  X  1 ) and as soon as there exists one occurrence of P in T when T is being scanned from left to right it will be returned.
 p (0  X  j  X  m  X  1) one-off condition. We call the condition that as soon as there exists one occurrence of P in T when T is being scanned the occurrence will be returned online condition. Under the above two conditions, an occurrence of P that can maximize the total number of occurrences of P in T is an optimal occur-by  X  i j .
 one-off condition. Therefore, P occurs only once in T.
 in T can be used to match the occurrence of P for more than once, the number of 0 , 1 ,..., m  X  2 ) . Thus, an efficient algorithm for returning all occurrences of P user is more interested in how frequently each of the candidate shopping patterns appear. If the number of occurrences of a pattern in the transaction database is customer buys, in the temporal order of item a , item b , item c and item c ;and P can be treated as a candidate shopping pattern. The user is interested in how it is unreasonable to count P twice in T. Also, when the user uses a web search more frequently P occurs in one document, the higher the rank of the document in the returned document list. It is obvious that when we count the number of occurrences of pattern P (abc) in a document T (abcc), it makes sense to count each occurrence for only once. 4 Algorithm design 4.1 Issues for considerations two important issues into consideration to design SAIL: 1. Online searching SAIL should output an occurrence of the given pattern as 2. Optimization Under the one-off condition, SAIL should determine which oc-phase .Inthe forward phase , SAIL sequentially scans the input of T for possible p ( j = 0,1,..., m  X  1) X  X  positions in T and constructs a search table, as shown in be used again.
 resolve two important issues: (1) how SAIL constructs every cell of the search The answers will be provided by the following procedures of SAIL. 3. SAIL keeps searching seed positions of every pattern letter p j till one seed Definition 2 Seed position  X  X hen j = 0, position i is a seed position of p j if t i = p j ;and  X  X hen1  X  j  X  m  X  1, if t i = p j and  X  a seed position h of p j  X  1 such that both global and local constraints to provide a complete description of SAIL. 4.2 Proposed algorithm That is, SAIL conducts search by using the technique in the previous subsection under length constraints.
 used in an optimal occurrence of P; range[j].min = min j and range[j].max = max j  X  i as long as there exists an optimal occurrence of P in T. pos[0, ..., m-1][0, ..., len-1] will be explained when it is used.
 it is simply a condition-check which can be seen from pseudo codes in the figures to follow, we will omit the description for checking this condition. GET O PT O CC to locate one optimal occurrence of P in T if there exists one for some position i .
 of possible positions of p[0] by considering the global constraints. The range is ning process, as we have discussed in the above subsection. The FORWARD PHASE one or several occurrences exist, the BACKWARD PHASE chooses an optimal one and stores the corresponding optimal positions in occurrence[]. Finally, PROCE -DURE OUTPUT outputs the occurrence[].
 it is the key to understand these two phases. By lines 1 X 4 of GET O PT O CC ,we  X  1] comes, pos[0, ..., m  X  1][0, ..., len  X  1] are initialized to 0s. Definition 3 Seed position (with global constraints)  X  X hen1  X  j  X  m  X  1, if t[i] = p [j] and  X  a seed position h of p [j  X  1] such SAIL should further check by line 8 to make sure that there exists at least one  X  1][end-start] is set to 1 and flagOfOcc is set to true, the BACKWARD PHASE is triggered to output an optimal occurrence by line 11 of the FORWARD PHASE and SAIL searches backward to register the optimal position of other pattern letters smallest position within the local constraints (lines 7 X 9) to guarantee optimum. 4.3 A running example In this subsection, we show how SAIL works with a running example where P , T and constraints are given as follows.
 Example 2 p[0...4] = [babac];t[0 . . . 22] = [cccccbabbbfadacbbabeacc]; range[0]. min = 0, range[0].max = 3; range[1].min = 0, range[1].max = 4; range[2].min = 1, range[2].max = 1; range[3].min = 0, range[3].max = 3; minLen = 11; maxLen = 14.
 = p [ m  X  1], so position 0 is checked first by PROCEDURE GET O PT O CC .Before SAIL conducts the FORWARD PHASE , maxLen(14) and minLen(11) are used to positions 1, 2, 3 and 4 in T .
 PROCEDURE GET O PT O CC , start=1 and startLimit=4. So p [0] X  X  possible position = condition of line 8 of FORWARD PHASE in this case. Therefore, no occurrence include position 5 and there would be an (optimal) occurrence { 5,6,9,11,14 } for position 14 .
 ([ start , startLimit ]). In the FORWARD PHASE , SAIL checks every position from is a seed position of p [0] (by line 2 of FORWARD PHASE ). Therefore, pos[0][8  X  t [10] is different from p [ j ]( j = 0,...,4).
 condition in Definition 3 is satisfied. So SAIL goes through lines 5 X 8 of FORWARD  X  start], pos[0][9  X  start] and pos[0][8  X  start]. As long as one of them is 1, the satisfy the local constraints between p [0] and p [1].Bylines1and4of FORWARD p [3] is at position 11, thus pos[3][11  X  start] will not be set to 1. set to 1. Similarly, SAIL checks pos[2][11  X  start] for p [3]. Since pos[2][11  X  start] = 1, pos[3][13  X  start] will not be set to 1.
  X  start]. As a result, pos[4][14  X  start] cannot be set to 1.
 to 1 since there exists one seed position of p [1](pos[1][13  X  start] = 1). corresponding cells in pos[][] are set to 1. Once pos[4][21  X  start] is set to 1, the BACKWARD PHASE is triggered by line 11 of the FORWARD PHASE and line as p [4] X  X  optimal position by line 3. Then pos[3][20  X  start,...,17  X  start] are checked (due to the local constraints range[3].min = 0, range[3].max = 3) and the smallest k for which pos[3][k  X  start] is 1 will be chosen as p [3] X  X  optimal position by lines 5 X 8 of BACKWARD PHASE . In this case, position 17 is chosen selected as an optimal occurrence of the pattern.
 elements (marked as * in Table 2) of T are never considered for further matching again. Once pos[4][22  X  start] is set to 1, the BACKWARD PHASE is triggered. It showninTable 3 , except the one that has been selected, { 8, 11, 15, 17, 21 } .As 22 one-off condition. This is why SAIL does not select any occurrence in Table 3 as an optimal occurrence for position 21 . 5Analysis 5.1 Correctness and completeness To demonstrate the correctness and completeness of SAIL, we need to prove four dition is omitted in the proofs.
 Lemma 1 Given an appearance of the last pattern letter p[m  X  1] at position end, Procedure getOptOcc takes into account all possible occurrences of P in T constraints.
 Proof Given minLen and maxLen, and an appearance of p [ m  X  1] at position end , the range of possible positions of p [0] is: this range. In PROCEDURE GET O PT O CC , SAIL checks this through the following procedures: By line 3 of PROCEDURE GET O PT O CC , we guarantee that checks the next appearance of p [ m  X  1].
 maxLen+1), end-minLen+1]. In addition, by line 5 of PROCEDURE GET O PT O CC , SAIL scans from start to end . Therefore, the maxLen and minLen constraints are satisfied. All possible occurrences under the global constraints have been taken into consideration.
 t[i 0 ], start i  X  i be set to 1 where 0  X  j  X  m  X  1 and this sequence has been marked in the form of pos[0][i 0  X  start] = 1, pos[k][i k  X  start] = 1.
 i  X  i i  X  i by line 9 of the FORWARD PHASE .When k =3,4,..., j , a similar proof can be made. Therefore, Lemma 2 is true.
 Lemma 3 In the FORWARD PHASE , when pos[j][i  X  start], 0  X  j  X  m  X  1 ,is i &lt; i, 1  X  k  X  j  X  1 ,p[0] = t[i i  X  i  X  start] = 1 and pos[j][i  X  start] = 1.
 Proof We prove this lemma by contradiction. Assume when pos[ j ][ i -start], 0  X  j  X  m  X  1, is set to 1,  X  a sequence i in Lemma 3, but at least one element i r of this sequence has not been marked. set to 1 by line 3 of the FORWARD PHASE . Lemma 3.
 i 1  X  range [ r  X  1 ] . max . Then, this sequence i conditions in Lemma 3, which contradicts our assumption at the beginning of this proof.
 Lemma 4 In the BACKWARD PHASE , one optimal occurrence of P in T is selected and stored into occurrence[].
 BACKWARD PHASE had selected any of these three occurrences, the only occur-becomes impossible. When position 21 is selected as p [4] X  X  position in Table 1 , the BACKWARD PHASE does not select positions 20, 13 and 9 as the positions of within the local constraints.
 Proof To be succinct, when we say x can consume y, it means that p [ j  X  1] = 1  X  j  X  m  X  1.
 1] X  X  position to consume.
 consume i j  X  1 .Since and thus, and therefore, Therefore, i j can consume i j  X  1 or some positions i j  X  1 after i j  X  1 . the claim is trivially true.
 consume. Since and thus, Since and therefore, is achieved. This case does not exist at all.
 is trivially true.
 trivially true. whichever i j consumes will not affect the fact that i j can always consume the has consumed i j  X  1 , i j will consume i j  X  1 . The claim is trivially true. claim is trivially true.
 tion is not decreased. The claim is true.
 1  X  j  X  m  X  1, Lemma 4 is true.
 Claim 1 Given a possible position of p [ m  X  1], end ,if  X  one optimal occurrence of P in T with p [ m  X  1] at end, Procedure getOptOcc will output it. Proof Given a position of p [ m  X  1], end , with Lemma 1, occurrences satisfying the global constraints will not be omitted by PROCEDURE GET O PT O CC . Since an 1 ] . min  X  i has p [ m  X  1] at the position end by the condition of Claim 1.
 i ,..., i 1  X  k  X  m  X  2, p [0] = t [ i i  X  i [ i -start] = 1 and pos[ m  X  1][end-start] = 1 by Lemma 3. This means that all pos-sible occurrences are considered during the BACKWARD PHASE including optimal occurrences. (Among these occurrences, the BACKWARD PHASE should choose an optimal occurrence.) Lemma 4, occurrence[] stores an optimal occurrence. By line 9 of PROCEDURE GET O PT O CC , it outputs occurrence[].
 T will be checked by PROCEDURE GET O PT O CC . With Claim 1, if there exists one optimal occurrence for the appearance of p [ m  X  1], it will be output. Our Therefore, correctness and completeness of SAIL have been proved. 5.2 Complexity We assume a generic one-processor, random access machine (RAM) model of computation as our implementation technology. A constant amount of time is re-quired to execute every time every line of our pseudo code. 9 DURE GET O PT O CC .In GET O PT O CC , since lines 1 X 4 can be done in a constant time, the dominant factor is the execution time of loop 5 X 9.
 j  X  m  X  1), are the same and the number of letters between p is max j . Thus, by lines 1 and 7 of the FORWARD PHASE , the time complexity of the FORWARD PHASE is O ( mg ) where m is P  X  X  length and g is the max { max k  X  min k } (0  X  k  X  m  X  2).
 PHASE is O ( mg ) . PROCEDURE OUTPUT can be done in O ( m ) .
 PHASE is executed for every position between start and end . The difference be-tween start and end can be as large as maxLen. We use l to denote maxLen. Thus, for a possible p m  X  1  X  X  position end ,the FORWARD PHASE can run as many times PUT run at most once. Thus, the time complexity of PROCEDURE GET O PT O CC is O ( lmg ) .
 overhead for scanning T is involved. Also, getOptOcc can run as many as k times, search table). 6 Discussions approaches on our research problem defined in Section 3. When the one-off con-the text repeatedly (without the one-off condition), which may not be meaningful to narrow down their search results. Furthermore, we can design a finite automa-local constraints where g is the maximum number of wildcards allowed between any two consecutive letters in the pattern. However, if we also want to incorpo-rate the global length constraints and the one-off condition, then this approach increases the number of necessary states exponentially because there are expo-this approach does not offer a tractable solution.
 tern matching problem to a parsing problem for context free languages. This time we need exponentially many production rules because the symbols of the occur-rences can interleave.
 it cannot provide a tractable solution for our pattern matching problem. 7 Conclusions wildcards, where complex local constraints and global length constraints are in-tegrated. With the proposed approach, a search engine can provide the users with different consecutive pattern letters and controlling the length of each matching substring. We have solved the problem with a fast algorithm, SAIL, whose time m is the length of P ,and g is the maximum difference between the user-specified maximum and minimum numbers of wildcards allowed between two consecutive letters in P . In summary, we believe that the proposed constrained string match-ing problem and the SAIL algorithm will attract more theoretical studies and have a practical significance for many real-world applications like text indexing, se-quence analysis and sequential pattern mining.
 String Matching/onlineSmApplet.html . We invite the readers to try it and provide feedback.
 References
