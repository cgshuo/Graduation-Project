 Inductiv e databases tightly integrate databases with data mining. The key ideas are that data and patterns (or mod-els) are handled in the same way and that an inductiv e query language allows the user to query and manipulate the pat-terns (or models) of interest.
 This paper prop oses a simple and abstract model for induc-tive databases. We describ e the basic formalism, a simple but fairly powerful inductiv e query language, some basics of reasoning for query optimization, and discuss some memory organization and implemen tation issues.
 inductiv e databases, inductiv e querying, constrain t-based mining Ever since the start of the  X eld of data mining, it has been realized that the data mining process should be supp orted by database technology . In recen t years, this idea has been formalized in the concept of inductiv e databases [28]. In-ductiv e databases are databases that, in addition to data, also contain patterns, i.e., generalizations extracted from the data. Within the inductiv e database framew ork knowledge disco very in databases is modelled as an interactiv e process in which users can query data as well as patterns. To this aim a so-called inductiv e query language is used. A number of specialized inductiv e query languages have been prop osed and implemen ted, e.g., MINE RULE [35], MSQL [29], DMQL [22] and XMine [10]. Most of these in-ductiv e query languages extend an existing database query (SQL or XML) language with some primitiv es to supp ort data mining. The combination of a data mining algorithm (usually some varian t of Apriori [1]) with a language such as SQL o X ers some interesting querying abilities. Other re-searc hers have argued that data mining primitiv es should be as close as possible to those of traditional query languages [20; 6].
 The work on inductiv e query languages has been comple-mented by several approac hes to constrain t based mining [3; 23; 24; 38; 31; 16]. Constrain t based mining provides the user with certain primitiv es (such as frequency and syntactic constrain ts) to specify the patterns of interest. This line of researc h has focussed on disco vering useful constrain ts that can be processed e X cien tly.
 Despite these many interesting contributions, we are still far away from a deep understanding of inductiv e databases. It appears to the author that several importan t comp onen ts of inductiv e databases (such as traditional databases and constrain t based mining techniques) are already well under-stood, but that the overall picture is still unclear. Indeed, with a few notable exceptions [5; 28; 18; 16], few works have addressed architectural or design issues in inductiv e databases. A simple theory that gives a clear answ er to simple questions such as "What is an inductiv e database?" and "What is the functionalit y of an inductiv e database?" seems to be missing and yet of central importance to the further developmen t of this idea.
 Although it is probably too early to give a  X nal answ er to the above questions, this paper wants to contribute a partial answ er to this question that is grounded in database theory and logic. The answ er consists of a simple but fairly power-ful inductiv e database concept that clearly exempli X es the nature as well as the functionalit y of an inductiv e database. In form ulating this answ er, we start from  X rst principles rather than from complex state-of-the-art techniques and algorithms, so that we do not get lost in technical details and are, we hope, able to address the true design issues in inductiv e databases. The resulting design does not pretend to be realistic and is  X  from a practical perspectiv e  X  overly simple. It is merely mean t to give insigh t into the possible nature and prop erties of inductiv e databases and these prin-ciples are generally applicable. One speci X c context in which they are successfully being applied is that of the molecular feature miner MolF ea [13; 31], in which the user can query for molecular patterns or fragmen ts of interest using primi-tives such as frequency and generalit y.
 The paper is organized as follows: Section 2 introduces the data and pattern comp onen ts of inductiv e databases and illustrates them using MolF ea; Section 3 introduces the in-ductiv e query language for specifying patterns of interest; in Section 4 it is shown how queries can be used to cre-ate, update and modify data and pattern sets; Section 5 is concerned with reasoning about queries with the aim of query evaluation and optimization; Section 6 contains some ideas and challenges concerned with memory organization and data structures, and  X nally , in Section 7, we conclude. Inductiv e databases do not only store data but also pat-terns: the patterns are  X rst class objects. Thus an induc-tive database I ( D ; P ) consists of a data comp onen t D and SIGKDD Explorations. Volume 4, Issue 2 -page 69 a pattern comp onen t P . We assume that both the data and the pattern comp onen ts D and P are sets of sets. This assumption is motiv ated by an analogy with traditional re-lational databases. A relational database can be considered a set of relations where each relation is a set of tuples. So, relational databases are -as our data comp onen t -sets of sets. The assumption is further justi X ed because in data mining one is often coping with di X eren t data sets. Indeed, one distinguishes the training from the test set, the set of positiv es from the set of negativ es, the set of instances in a given cluster, the correctly classi X ed examples from the incorrectly classi X ed ones, etc. This justi X es the assumption that D is a collection of data sets. Each data set D 2 D con-tains di X eren t examples or instances, which will be denoted by e or i .
 Everything that was said about the data comp onen t also ap-plies to the pattern comp onen t. Indeed, during the knowl-edge disco very process, one will often work with di X eren t sets of patterns, each of which may reside in the inductiv e database. These di X eren t sets may corresp ond to di X eren t hypotheses constructed on di X eren t data sets during cross-validation, to hypotheses constructed under various param-eter settings (e.g., levels of frequency), to user supplied pat-terns, post-pro cessed patterns, etc. Pattern sets will be de-noted by P and their elemen ts, i.e., the patterns, by p; p In order to illustrate the key concepts of our inductiv e database design, we will emplo y the pattern domain of strings. This pattern domain, as many of the other ideas presen ted in this paper, are motiv ated by the domain speci X c inductiv e database MolF ea [31]. We will therefore  X rst brie X  X  review the MolF ea setting and then abstract from MolF ea in de X n-ing the pattern domain of strings. At the same time, we hope that the MolF ea experiences and setting will convince the reader of the practical relev ance of the presen ted induc-tive database concepts.
 MolF ea is a domain speci X c inductiv e database for mining features of interest in sets of molecules. The examples in MolF ea are thus molecules, and the patterns are molecu-lar fragmen ts. More speci X cally , in [31] we emplo yed the 2D (graph) structure of molecules, and linear sequences of atoms and bonds as fragmen ts. An example molecule named Azidoth ymidine (AZT), a commonly used drug against HIV, is illustrated in Figure 1. Two interesting molecular frag-ments disco vered using MolF ea are: In these fragmen ts, 'C' , 'N' , 'Cl' , etc. denote elemen ts 1 , and '-' denotes a single bond, '=' a double bond, '#' a triple bond, and ':' an aromatic bond. The two fragmen ts occur in AZT because there exist labelled paths in the graph AZT that corresp ond to these fragmen ts.
 Let us now introduce the string pattern domain, which is an abstraction of MolF ea. This pattern domain should also be useful for other applications in bioinformatics involving, e.g., DNA/RNA or proteins. In the string pattern domain, exam-ples as well as patterns are strings expressed in a language L  X  over an alphab et  X . Furthermore, a pattern p matc hes or covers an example e if and only if p is a substring of e , i.e. the symbols of p occur at consecutiv e positions in e . An 1 Elemen ts involved in aromatic bonds are written in lower-case.
 example toy database in this context could be: Instead of using the pattern domain of strings, one could also emplo y other domains such as the data miner's favorite item sets. Then, if I is the set of items considered, examples e as well as patterns p are subsets of I . Data and pattern sets are then sets of item-sets. One of the crucial reasons behind the success of relational databases is that relational query languages, such as the re-lational algebra, are fairly powerful but yet reasonably sim-What should an inductiv e query language look like? We will assume that the result of an inductiv e query is either a pattern set or a data set. This assumption guaran tees the so-called closur e prop erty [28; 6]. The closure prop erty is again justi X ed by analogy with relational databases, where the result of a query is always a relation; one can argue that the reason for the success of relational algebra was due to the closure prop erty and not to its inheren t strength. Given that we distinguish data sets from pattern sets, we need two types of queries: those that generate data sets and those that generate pattern sets. Queries that start from both data sets as well as pattern sets are sometimes called cross-over operations [6].
 Motiv ated by the use of logic for both databases and con-strain t based mining as well as by the intimate relationship between logic and set theory , we prop ose to use logic to design inductiv e query languages. Using logic should facil-itate the de X nition of the seman tics of the query language, 2 It is easy to give examples of queries that one cannot express using relational algebra; just consider aggregates. Thus having simple examples that fall outside the query lan-guage does not necessarily mean that the language is fatally  X  X wed.
 SIGKDD Explorations. Volume 4, Issue 2 -page 70 should allow to reason about queries and their execution, and should also result in declarativ e querying possibilities. In our example inductiv e query language, we allow for queries q that either contain no variables or contain exactly one vari-able  X  as in q (  X  ). Queries without variables will be inter-preted as true or false; queries q (  X  ) with a single variable  X  will be interpreted as sets f i j q ( i ) is true g ; queries with two or more variables are not allowed. Let us now de X ne a sim-ple though powerful query language (inspired on MolF ea) for our inductiv e database. Again, we wish to stress that the list of primitiv es sketched is by no means exhaustiv e, it is mean t for illustrativ e purp oses and it can easily be extended with other primitiv es, with other pattern domains (such as item sets [1], episo des [34], Datalog queries [12], etc.), and even with primitiv es for other data mining tasks (such as clustering [42]). So, within the sketched language, we can form ulate the fol-lowing queries: 3 If desired, one migh t also use = ) and () . The data mining primitiv es are an extension of those em-ployed in the MolF ea system for mining molecular features [31]. The key di X erences are that MolF ea does not supp ort the set orien ted primitiv es and that it only allows for con-junctiv e queries. Here, arbitrary boolean queries are sup-ported.
 Notice that even though the inductiv e query language is simple, the range of queries that can be expressed is quite large. Two features are especially importan t and distin-guish our language from other ones: the use of arbitrary boolean queries (introduced in [16]) and the abilit y to for-mulate minim um as well as maxim um frequency constrain ts over multiple data sets (introduced in [13]). For building e X cien t query solvers, it is crucial that the key primitiv es (frequency and generalit y) satisfy the monotonicit y or anti-monotonicit y prop erty 4 . A constrain t c is anti-monotonic (resp. monotonic ) w.r.t. generalit y whenev er (resp. ( g 2 sol ( c )) ! ( s 2 sol ( c ))). Anti-monotonic (resp. monotonic) constrain ts have the prop erty that whenev er a pattern s satis X es the constrain t, all its generalizations (resp. specializations) will also satisfy the constrain t. The basic anti-monotonic constrain ts in our framew ork are: (  X  4 p and f req (  X ; D )  X  m , the basic monotonic ones are ( p  X  ) and f req (  X ; D )  X  m . Furthermore the negation of a monotonic constrain t is anti-monotonic and vice versa. It would be relativ ely straigh tforw ard to extend our language and solvers with other primitiv es that are monotonic or anti-monotonic. One importan t challenge for inductiv e querying concerns the use of primitiv es that are neither monotonic nor anti-monotonic (cf. [40]). As an example constrain t consider acc (  X ; D pos ; D neg )  X  0 : 8. The answ er set of this constrain t contains all patterns  X  that have a minim um accuracy of 80 per cent on the data sets D pos and D neg . Here, we could de X ne the accuracy as (provided that the frequencies are not equal to 0). E X cien tly evaluating queries within inductiv e database lan-guages such as IL is one of the most importan t challenges in inductiv e databases. From a logical point of view, in-ductiv e database queries can -as their traditional coun ter parts -be decomp osed into their constituen ts, which cor-respond -for IL -to the primitiv es outlined above. The 4 Interesting varian ts and extensions of these notions are studied in a recen t paper by [40].
 SIGKDD Explorations. Volume 4, Issue 2 -page 71 problem is then to combine them in such a way that 1) the available solvers can compute the answ ers, and 2) the com-putational resources needed in this process are minimized. To illustrate this problem, consider the query ( f req (  X ; D )  X  t ) ^ ( f req (  X ; E )  X  t e ). There are various ways of  X nding the solution set to this query . First, one could compute ( f req (  X ; D )  X  t d ) and then remo ve those elemen ts not satis-fying ( f req (  X ; E )  X  t e ) (or the other way around). Secondly , one could compute the answ ers to each of the conjuncts in-dependen tly and then compute the intersection. Thirdly one could compute the result using the overall conjunction di-rectly (e.g., using a level wise searc h using the conjunction as the constrain t). Whic h of these is to be preferred will de-pend on the data sets, thresholds and algorithms available. The problem of deciding among these is similar to that in traditional query optimization. It seems therefore likely that similar solutions could work as well. One migh t e.g. want to use a cost estimates for comparing di X eren t execution plans for a given query . It remains -so far -an open question as to what cost estimates would be useful and appropriate for inductiv e queries. At the same time, it should be clear that reasoning about inductiv e queries (cf. Section 5) and e X cien t data structures and memory organization (cf. Sec-tion 6) will be of key importance to develop e X cien t query solvers. So far, we have mainly addressed architectural and querying aspects of inductiv e databases. We have not yet addressed how to create and modify an inductiv e database. Again, it is useful to exploit the analogy with existing databases to the maximal possible exten t. As in SQL, we therefore use cre-ation, deletion and update operations as well as regular sets and view sets. This results in the operations sketched below, which are also inspired by ongoing work on the MineR ULE system by Rosa Meo (personal comm unication). Again, we assume a perfect symmetry among the data and the pattern comp onen ts. So even though we only list the operations on the data comp onen t, every operation on the data has an equiv alent one on patterns. create data set D as q D : inserts the new data set D ob-create view data set D as q D : inserts the new virtual data delete data set D : deletes the (view or regular) data set update data set D (add j delete) q D : either adds or deletes The provided operations are similar to those supp orted in a relational database. First, the result of an inductiv e data query can be stored into a new data set. Second, one can also de X ne virtual or view data sets. View data sets behave as views in a relational database. Basically , the de X ning query is stored (and possibly materialized as well), and the data set can be queried just as if it were a normal set. Changes or updates to the data and pattern sets after the introduction of the view are dynamically re X  X cted in the view data set. Updates on views can be complex. Thirdly , it is possible to delete and modify a data set. Of course, in any possible realistic inductiv e database more complex update operations will be available.
 Whereas the sketched operations are unsurprising for the data comp onen t, they are less straigh tforw ard when applied to the pattern comp onen t. Let us illustrate and motiv ate the key concepts on our inductiv e toy-database. Assume the following statemen ts are given: create data set D 4 as (  X  2 D 3 ) ^ ( a 4  X  ) ; create pattern view P 2 as ( b 4  X  ) ^ f req (  X ; D 4 )  X  2; update data set D 4 delete f abbc g ; This sequence of commands has the following e X ects on our database: This example illustrates a form of incremen tal data mining where changes to the underlying data sets have an imme-diate e X ect on the de X ned pattern sets. This is realized through the use of pattern views. The use of pattern views is interesting from a practical perspectiv e. Indeed, it is easy to imagine a basket analysis scenario where one always wants to query the patterns that hold in the transaction data of the last week. Dealing e X cien tly with such incremen tal data mining and pattern views seems an importan t challenge for data mining. An example of that illustrates some of the issues in pattern view main tenance, is presen ted in Section 6.2. A theory of inductiv e databases can only be useful if it o X ers the possibilit y to reason about data mining and its processes. This section explores the possibilities of our logical view for reasoning about query evaluation and optimization. Such reasoning processes must start from logical axioms. The reason why a logical axiomatization of constructs in the language are useful is given by the following two prop erties: P1 For all queries q 1 and q 2 we have ( q 1 = ) q 2 ) if and only P2 For all queries q 1 and q 2 we have ( q 1 () q 2 ) if and only These prop erties state that logical implication or entailmen t among queries directly corresp onds to the subset relation among its answ er sets.
 For the sketched inductiv e query language, the axioms listed below should be useful. The list is only mean t to illustrate SIGKDD Explorations. Volume 4, Issue 2 -page 72 the kind of axioms that query optimizers could use. Study-ing alternativ e axiomatizations and their prop erties remains an importan t topic for further researc h. In this context, Calders and Paredaens have recen tly contributed an inter-esting axiomatization of frequen t sets, cf. [9].
 A1 an axiomatization of  X nite sets; A2 an axiomatization of the partial order 4 , i.e. re X  X xivit y, A3 an axiomatization of the total order  X  for numbers; A4 For all data sets D 1 ; D 2 and patterns p : D 1  X  D 2 A5 For all patterns p 1 ; p 2 and data sets D : p 1 4 p 2 The axioms A1 could be used for reasoning about the rela-tionships among the various sets in the inductiv e database and queries. The axioms A3 are intended to supp ort rea-soning about the numerical thresholds in the frequency con-strain ts. The axioms A4 and A5 specify the monotonicit y prop erties of f req for both of its argumen ts. The above axioms can be used in a variety of di X eren t ways. Let us illustrate these on some represen tativ e examples. Consider queries q 3 and q 4 such that A1-5 j = q 3 = ) q q and q 4 could be f req (  X ; D )  X  3 and f req (  X ; D )  X  2, or alternativ ely f req (  X ; D )  X  m and f req (  X ; D [ E )  X  m . The following situations can be imagined, cf. [2]. Notice that the very same observ ations and situations apply to queries that return data sets. Furthermore, this type of reasoning is also required to e X ectiv ely handle the pattern views introduced earlier. Logical reasoning could be used to decide when and how to update materialized views. In this context, one migh t  X  by analogy to the traditional view update problem in databases  X  also consider the pattern view update problem. The pattern view update problem consists of deciding how the underlying data and pattern sets need to be updated to insert or delete a pattern to/from the pattern view. This corresp onds to a kind of what if questions. E X cien t data structures and memory managemen t are cru-cial for database theory . Therefore, we also discuss some of the memory managemen t issues and challenges for inductiv e databases. First, at the level of the data and pattern comp onen t, it will be useful to keep track of the subset relation. Indeed, when sets D 1 and D 2 are presen t in the data base and D D , this fact should be represen ted explicitly . Storing these prop erties in a systematic way amoun ts to represen ting the whole structure of the data and pattern comp onen t. This will be useful in the context of query optimization. Also, other facts about the relationship among di X eren t pattern sets may be useful (e.g., when one pattern set is a condensed represen tation of another one, cf. below).
 Secondly , it will be useful to explicitly represen t the lation among the patterns in the pattern set, especially for pattern sets that are irregular w.r.t. the 4 relation (e.g., when they are not convex or represen table by border sets, cf. below). Explicitly represen ting the 4 relation will al-low the inductiv e database managemen t system to optimize queries of the type (  X  2 P ) ^ q (  X  ) where P is a pattern set and q a query in the language IL introduced above. Using the internal represen tation of 4 , the constrain t  X  2 P can be pushed into the solver. E.g., if q (  X  ) = ( f req (  X ; D )  X  m ), a varian t of the level wise algorithm could e X cien tly gen-erate as candidates only those elemen ts that belong to P . The alternativ e would be to searc h the space of all patterns, and then  X lter out those that do not belong to P . For ill-structured or small pattern sets this form of post-pro cessing is likely to be less e X cien t, cf. also [24]. It is not only importan t to develop e X cien t data structures for represen ting pattern sets, but also to devise operations on these data structures. Such operations would directly im-plemen t the primitiv e constrain ts and the logical operations in the inductiv e database language. Thus they could serve as the elemen tary operations (a kind of algebra) for query evaluation as well as query optimization. Furthermore, the intermediate pattern sets could be cached for further use in interactiv e querying sessions. To illustrate this point, let us assume that pattern sets are represen ted using a directed acyclic graph; Figure 2 shows a graph corresp onding to the materialized pattern set P 2 = f b; ab; bb; bc; abb; bbc; abbc g for the pattern view ( b  X   X  ) ^ f req (  X ; D 4 )  X  2, where D initially f aabbcc; abbc; abc g 5 . In a pattern graph, nodes cor-respond to patterns and edges to the gener alization relation. The labels of the nodes denote prop erties of the patterns. The most importan t prop erty is the mem bership  X  X g with values "+" and "-". The label "+" (resp. "-") denotes that the corresp onding pattern belongs (resp. does not belong) to the pattern set represen ted by the graph. So, a pattern graph may also contain information about patterns outside the pattern set it represen ts, e.g. a 2 P 2 because of the la-5 Usually , one would not emplo y graph structures for these purp oses, but some special purp ose tree structure such as FP-trees [24] for item sets or version space trees for string patterns [16]. However, in order to simplify the exposition and to focuss on the key ideas, we choose graphs rather than these more complex data structures.
 SIGKDD Explorations. Volume 4, Issue 2 -page 73 bel "-". Furthermore, from Figure 2, one can directly read that b belongs to P 2 and also that (within P 2 ) it has three minimal specializations, i.e. ab; bb and bc . This kind of in-formation should be useful when searc hing for patterns in P that satisfy certain constrain ts (cf. Section 6.1). The other labels on the nodes represen ting a pattern denote coverage information. Indeed, the second label in a node encodes the indexes of the examples (here in D 4 = f e 1 ; e 2 ; e 4 g ) that are covered by the pattern, the third one, those (in D 4 ) that are not covered, where "*" denotes the empt y set. E.g., bb covers e 1 and e 2 but not e 4 . Given data structures such as pattern graphs, an inductiv e database language can be im-plemen ted using operations on these data structures. As an example consider the pattern graph operations " [ " ; " \ " and "  X  " corresp onding to the logical operations " ^ " ; " _ " and " : " 6 . These operations would compute the union, intersec-tion or di X erence of two pattern graphs. They are useful to decomp ose queries of the form q 1 ^ q 2 ; q 1 _ q 2 and q Indeed, these queries can be answ ered by  X rst computing the pattern graphs w.r.t. q 1 and q 2 and then performing the appropriate operation on the resulting pattern graphs. Other operations that are likely to be useful could manipu-late the labels of the nodes in a pattern graph. The labels w.r.t. coverage could be modi X ed in order to re X  X ct an up-date in the pattern view (e.g., as the result of deleting or adding an elemen t of the set D 4 used in the de X nition of the pattern view). In addition, updates to the underlying data set would also trigger changes in the mem bership la-bel. Interesting and challenging situations occur when new nodes need to be inserted in the pattern graph as the result of an update. (At this point, the reader may want to inves-tigate the e X ect of deleting the elemen t abbc from D 4 on the pattern graph.) Pattern graphs and their operations are not only useful in the context of query evaluation and optimization, they can also be emplo yed for optimizing interactiv e querying ses-sions. Indeed, the intermediate results of one inductiv e query can often serve to optimize the computation of the answ er to the next query .
 As far as the author is aware, pattern graphs -in the form presen ted above -have not yet been used within the  X eld of data mining. Nevertheless, there exist some interesting data structures, such as FP-trees [24; 40] and version space trees [16] that are typically constructed while evaluating the query and that contain several of the comp onen ts sketched above. One of the remaining challenges -that we are cur-rently studying for version space trees -is to develop e X cien t implemen tations of the pattern set operations. It is sometimes possible to represen t pattern sets using con-densed represen tations. A condensed represen tation R ( P ) of a pattern set P is a subset R ( P )  X  P such that the original pattern set P can be reconstructed from R ( P ) 7 . So, R ( P ) 6 Ideally , an operation implemen ting the complemen t of a pattern graph would also be provided to compute the an-swers to a query : q on the basis of the pattern graph. How-ever, the resulting pattern graphs would be extremely large (in the case of strings even in X nitely large) and therefore impractical. Furthermore, in many cases, as in traditional databases, queries of the form : q will not be safe. 7 Some condensed represen tations require that additional in-formation (such as exact frequencies) can be reconstructed encodes all relev ant information about P in a more compact, i.e. condensed, manner. In the literature one can distinguish two types of condensed represen tations. On the one hand, there are local condensed represen tations, based on prop er-ties of the individual patterns; on the other hand, there are global condensed represen tations based on the prop erties of the complete pattern set.
 Examples of local condensed represen tations include free item sets, closed item sets,  X  -free item sets, etc. See e.g. [8; 39; 41] for more details. An item set I is e.g. free w.r.t. to a data set if and only if there is no rule of the form i ) i 2 that is valid on the data set where i 1 ; i 2 are two disjoin t subsets of I . Local condensed represen tations allow one to eliminate redundan t patterns from the searc h space as well as from the solutions. Various algorithms working with local condensed represen tations have been published in the literature, e.g. [7; 39; 41; 8].
 Global represen tations are often orien ted towards represen t-ing the border sets, that is the minimal and maximal ele-ments in the set w.r.t. the partial order 4 . More formally , let max ( P ) = f p 2 P j :9 q 2 P : p 4 q g , i.e. max ( P ) contains the maximally speci X c elemen ts in P , and de X ne min ( P ) dually , i.e. min ( P ) = f p 2 P j :9 q 2 P : q 4 p g , i.e. min ( P ) contains the maximally general or minimally speci X c elemen ts in P . We can then also de X ne the borders of a pattern set P : S ( P ) = max ( P ) and G ( P ) = min ( P ) 8 . The interesting point about borders is that they can be used as condensed represen tations. It has been shown [13] that queries q that are a conjunction of anti-monotonic and monotonic constrain ts are version spaces. This means that they are completely characterized by their sets S ( q ) and G ( q ), i.e. q = f p j 9 s 2 S ( q ) ; g 2 G ( q ) : g 4 p 4 s g . On our earlier example, the reader may want to verify that the pattern set P 2 = f b; ab; bb; bc; abb; bbc; abbc g represen ted in as well. Other condensed represen tations require only that the original set (with or without additional information) can be appro ximated [30]. 8 Sometimes one also uses negativ e borders [34], they contain patterns not belonging to the pattern set P but are in a sense closest (w.r.t. the generalit y relation). E.g. the S  X  ( P ) border w.r.t. a minim um frequency threshold contains the maximally general elemen ts that are strictly more speci X c than an elemen t in S ( P ).
 SIGKDD Explorations. Volume 4, Issue 2 -page 74 the pattern graph is completely characterized by G ( P 2 ) = min ( P 2 ) = f b g and S ( P 2 ) = max ( P 2 ) = f abbc g . Within the  X eld of data mining the use of border sets has been introduced in [34], who prop ose to keep track of the set S ( P ) for anti-monotonic constrain ts, and within machine learning there is the well-kno wn work of [37; 36] on version spaces. In the past few years, a number of algorithms have been published that focuss on the e X cien t computation of these border sets in the context of data mining, see e.g. [4; 26; 31; 21; 17; 11]. One of the most recen t and exciting results is that by [17], who basically show how some local and global condensed represen tations can be integrated us-ing version spaces.
 Whereas our earlier results stated that the solution set of a conjunctiv e query involving anti-monotonic and monotonic constrain ts can be represen ted using a single version space, our more recen t results [14; 16] state that the answ er set of any boolean query over anti-monotonic and monotonic con-strain ts can be represen ted as the union of di X eren t version spaces. To see why this is the case, rewrite the query in a disjunctiv e normal form. Each conjunction with the dis-junctiv e normal form will then involve monotonic and anti-monotonic constrain ts. Hence, the earlier result applies and the conjunction can be represen ted as a version space, and the original set as the union of such version spaces. This result in turn leads to some interesting questions such as "What is the minimal number of version spaces needed to represen t the answ ers to an inductiv e query?". This last question is answ ered in [16]. In the same paper, version space trees are introduced. These combine ideas from pat-tern graphs and version spaces for the pattern domain of strings. It seems possible to adapt these ideas to FP-trees [24].
 Finally , we mention also that operations such as union and intersection on condensed represen tations have been inves-tigated, cf. [26; 32; 14]. Despite the fact that the presen tation of our inductiv e database framew ork has been quite informal and presen ted in the con-text of string data, there is signi X can t evidence that the line of researc h sketched in this paper is fruitful from the the-oretical as well as from the practical point of view. Much of the presen t evidence comes from the MolF ea system for molecular feature mining, which has e X ectiv ely been used in a number of real-life applications involving large and com-plex data sets such as the HIV-data set which contains over 40 000 comp ounds [31]. Furthermore systems based on the same principles as MolF ea have been developed. These in-clude DualMiner by [11] for item sets, ProF ea [15] for ana-lyzing the secondary structure of proteins, MineSeqLog [33] for mining logical (i.e. structured) sequences and Version Space Trees [16].
 Nevertheless, there are several importan t limitations of the prop osed design. It only addresses local pattern mining tasks 9 , does not accoun t for primitiv es that are neither anti-monotonic nor monotonic (such as e.g. accuracy), ignores probabilistic issues, etc. Despite these limitations the au-thor hopes that the framew ork inspires some further devel-9 [25] distinguish local patterns from global models. Global models are models about a data set as a whole, whereas local patterns are statemen ts about a (local) subset of the data. opmen ts in inductiv e databases.
 This work was partly supp orted by the ESPRIT FET project cInQ. The author is grateful to Heikki Mannila for several suggestions for impro vemen t concerning this paper, to Man-fred Jaeger, Stefan Kramer, Sau Dan Lee, and Heikki Man-nila for an exciting collab oration on inductiv e querying, and to the cInQ partners for inspiring discussions, in particular to Jean-F rancois Boulicaut, Rosa Meo, Mika Klemettinen, and Pier Luca Lanzi. [1] R. Agra wal, T. Imielinski, A. Swami. Mining associa-[2] E. Baralis, G. Psaila. Incremen tal Re X nemen t of Min-[3] R. Bayardo, (Ed.) Special Issue on Constrain t-Based [4] R. Bayardo. E X cien tly mining long patterns from [5] Jean-F rancois Boulicaut, Mika Klemettinen, Heikki [6] J-F. Boulicaut, M. Klemettinen, H. Mannila. Modeling [7] Jean Francois Boulicaut, habilitation thesis, INSA-[8] J-F. Boulicaut, A. Bykowski, C. Rigotti. Free-sets: a [9] Toon Calders and Jan Paredaens, Axiomatization of [10] D. Braga, A. Campi, A., Ceri, S, Lanzi, P., Klemetti-SIGKDD Explorations. Volume 4, Issue 2 -page 75 [11] C. Bucila, J. Gehrk e, D. Kifer, W. White. DualMiner: [12] L. Dehasp e, H. Toivonen. Disco very of Frequen t Data-[13] L. De Raedt, S. Kramer, The level wise version space al-[14] L. De Raedt. Query evaluation and optimisation in in-[15] L. De Raedt, S. Kramer. Inductiv e databases for bio-[16] L. De Raedt, M. Jaeger, S.D. Lee, H. Mannila. A theory [17] A. Giacometti, D. Lauren t and C. Diop. Condensed [18] F. Giannotti, G. Manco: Querying Inductiv e Databases [19] B. Goethals, J. Van den Bussc he. On supp orting in-[20] Bart Goethals, Jan Van den Bussc he: A priori versus [21] D. Gunopulos, H. Mannila, S. Saluja: Disco vering All [22] J. Han, Y. Fu, K. Koperski, W. Wang, and O. Zaiane, [23] J. Han, L. V. S. Lakshmanan, and R. T. Ng, Constrain t-[24] J. Han, J. Pei, and Y. Yin. Mining frequen t patterns [25] D. Hand, H. Mannila, P. Smyth. Principles of data min-[26] H. Hirsh. Generalizing Version Spaces. Machine Learn-[27] H. Hirsh. Theoretical underpinnings of versionspaes. In [28] T. Imielinski and H. Mannila. A database perspectiv e [29] Tomasz Imielinski and Aash u Virmani. MSQL: A Query [30] Baptiste Jeudy and Jean-F ran X cois Boulicaut. Optimiza-[31] S. Kramer, L. De Raedt, C. Helma. Molecular Feature [32] T. Lau, S. Wolfman, P. Domingos, D.S. Weld, Program-[33] S.D. Lee, L. De Raedt. Mining logical sequences in Mi-[34] H. Mannila and H. Toivonen, Levelwise searc h and bor-[35] R. Meo, G. Psaila and S. Ceri, An extension to SQL for [36] C. Mellish. The description identi X cation algorithm. [37] T. Mitc hell. Generalization as Searc h, Arti X cial Intel li-[38] R. T. Ng, L. V.S. Lakshmanan, J. Han, and A. Pang. [39] N. Pasquier, Y. Bastide, R. Taouil, and L. Lakhal. Ef-[40] J. Pei, J. Han. Constrain t frequen t pattern mining: SIGKDD Explorations. Volume 4, Issue 2 -page 76 [41] J. Pei, J. Han, and R. Mao. Closet: An e X cien t algo-[42] A. K. H. Tung, J. Han, L. V. S. Lakshmanan, and R. T.
