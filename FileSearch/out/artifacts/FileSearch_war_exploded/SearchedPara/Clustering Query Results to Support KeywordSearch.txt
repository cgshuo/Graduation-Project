 Keyword search is a popular technique for retrieving information from tree data on the web. Keyword search has attracted a lot of attention as a querying tech-nique in recent years because it frees th e user from the need of learning the syntax of a complex query language and the schema of the data sources.
There are two major drawbacks of XML keyword search systems [8, 10]. The first one is that there are usually numerous candidate results which match the keyword queries. This is due to the fact that keyword queries are inherently imprecise and cannot express structural constraints. The second drawback is that the answer of keyword queries may contai n different types of meaningful results even though the user is interested in only some of them. For example, consider the query Q = { Advanced, Database, Systems } on the XML document of Figure 1, which represents a university database recording courses and seminars ( Q is considered on the XML tree T of Figure 1 as the running example). There are courses with title  X  X dvanced Database Systems X  and a seminar whose topic also contains all the query keywords. Usually, the search systems do not group results and interleave in the answer results representing different concepts.
Result filtering [6, 13, 14] and ranking [4, 11, 12] have been proposed to ad-dress the problem of the large number of candidate results. The answers provided by these semantics are not satisfactory since still a large number of results may qualify to be in the answer and the quality of ranking is low [12]. Further, without disambiguation of the results, the users may still need to examine a large num-ber of results which are not of interest to them. We propose applying clustering techniques to the results to overcome the previous problems. The main idea is that if the results can be clustered effect ively with respect to the semantics they represent, the users can only examine th e clusters which are of interest to them. Clustering has been used as an alternativ e method of retrieving results in infor-mation retrieval [5, 15]. Unfortunately, the techniques applied for clustering web search results are not directly applicable to XML keyword search results because XML documents are structured and the granularity of clustering is different.
In this paper, we introduce a three-level methodology for clustering the results of keyword queries on XML data. The clusters at every level are nested within the clusters of the higher level. The clust ers of the first level consist of structural patterns of the keyword query results which provide alternative interpretations of the query results. Further, we define two relations,  X  and  X  dph on patterns to determine the clusters at the second level (named classes) and the third level (named collections) of clu stering, respectively.

In order to facilitate user navigation through the clusters, we also provide ranking for the clusters. Patterns within the same class are ranked with respect to their sizes. Classes which are nested withi n the same collection a nd the collections are organized into graphs using the  X  dph and  X  pph relations, respectively. The edges in the graphs represent a partial order on the clusters and this partial order is exploited to produce a ranking for the clusters of the graph. We designed an efficient algorithm to implement our clustering methodology. We run experiments on two datasets and showed that the clusters defined by our methodology can be computed efficiently and the clusterin g of the keyword search results helps the users to effectively retrieve the relevant ones. We model XML documents as ordered node labeled trees. Nodes represent ele-ments and attributes. Edges represent ele ment to element and element to attribute relationships. The nodes may also have a content which is text. We allow keywords to match both the content and the label of a node. We say that a node n contains keyword k if the content of n contains k or is labeled as k. If n contains keyword k then, node n is an instance of k.

Keyword queries are embedded to XML trees. An instance of a query Q on an XML tree T is an embedding of Q to T (i.e., a function from Q to the nodes of T that maps every keyword k in Q to an instance of k in T ).
 Definition 1. Let Q be a query, T be an XML tree, and I be an instance of Q on T .The instance tree (IT) of I is the minimum subtree S of T such that: (a) S is rooted at the root of T and comprises all the nodes of I , and (b) every node n in S is annotated by the keywords which are mapped by I to n .The minimum connected tree (MCT) of I is the minimum subtree of S that comprises the nodes of I .
 Consider our running example, Figures 2(a) and (b) show the IT and the MCT, respectively, of the instance { ( Advanced, 12) , ( Database, 25) , ( Systems, 25) } of Q on T . In the figures, the annotation of the nodes is shown between square brackets by the nodes. The root of the MCT is the Lowest Common Ancestor (LCA) of the nodes of the instance in T .
 An IT of an instance of a query Q on an XML tree T is also called IT of Q on T. Several previous approaches return sets of LCAs as answers to the user. In our approach, the result set of a query Q on an XML tree T is defined to be the set of ITs of Q on T. An IT is much of a richer construct than an LCA in terms of the information it provides as it shows both: (a) how the keyword instances are combined under their LCA to form an MCT, and (b) how the LCA is linked to the root of the XML tree.

An alternative view to keyword search involves clustering the results using structural and semantic information [8, 10]. In this paper, we elaborate on an approach which clusters the results at different levels of granularity and then, exploits user input to navigate among the clusters in order to retrieve the relevant results.
 Our approach clusters results in three diff erent levels. The clusters at the lowest level partition the results. Clusters in higher levels contain clusters from lower levels. Every cluster has a representative. The users can navigate through the system by selecting clusters initially at the top level and by drilling down to their nested clusters and finally to the res ults. The selection of clusters at every level is facilitated by the ranking of the relevant clusters which is provided to the user.
 Patterns. Different ITs are not usually of particular interest to the user as query results as long as they match the keywords in the same way and they share the same structural and semantic properties. Therefore, we use patterns (defined next) for clustering the results at the first level of our clustering scheme. Definition 2. A pattern P of a query Q on an XML tree T is a tree which is isomorphic (including the annotations) to an IT of Q on T .TheMCTofa pattern P refers to P without the path that links the LCA of the annotated nodes to the root of P .

A pattern has all the information of an IT except the physical location of that one in the XML tree. At the first clu stering level, a cluster has a pattern as the representative and comprises all the ITs which comply with this pattern. Patterns are used as representatives for clusters at all levels. For our running example, Figure 3 shows four patterns (out of 32 in total) for our running exam-ple. Pattern P 2 has two ITs which comply with it: the IT of the query instance { ( Advanced, 8) , ( Database, 8) , ( Systems, 8) } and the IT of the query instance { ( Advanced, 10) , ( Database, 10) , ( Systems, 10) } .
 Classes. Different patterns can be similar in the sense that they match the keywords in the same way; they have the same root-to-annotated-node paths and they have the same LCA. These patterns are semantically very close since they only differ in the way they combine keyword instances to form partial LCAs. We put such patterns in the same cluster to form the second level of clustering, named classes. We formally introduce classes using the concept of the  X  relation which is defined next.
 Definition 3. Let P and P be two patterns of a query on an XML tree. We say that P  X  P if all of the following holds: (a) the root-to-LCA-path of P and P are the same, and (b) for every keyword in the query, the LCA-to-keyword instance path in P and P is the same.
 Definition 4. Given the set of patterns of a query Q on an XML tree T ,a class of Q on T is an equivalence class of patterns with respect to the  X  relation.
Figure 4 shows four patterns. One can see that these patterns form a class in our running example.

We call size of a pattern P the number of edges in P. A pattern with the smallest size is chosen as a representativ e of a class (in case of a tie, a represen-tative is chosen randomly among the patterns with the smallest size). We denote the representative of a cluster C (which is always a pattern) as repr ( C ) . Collections. The  X  relation identifies similariti es between patterns by detecting identical path subpatterns between these patterns. However, similarities between patterns can also be identified by detecting common path subpatterns in a more relaxed way in the sense that the paths of one pattern can be embedded to the paths of another pattern. Embedding a path p 1 intoapath p 2 means that the edges of p 1 are mapped to sequences of edges in p 2 . That is, an edge in p 1 is viewed not as a child but as a descendant relationship between its nodes. We capture this type of similarity between patterns using the concepts of descendant path homomorphism and  X  dph relation. We then use the  X  dph relation to define the third level of clustering, and to cluster classes into collections. Definition 5. Let p 1 and p 2 be two pattern paths whose last nodes have the same label and are annotated by the same keyword. There is a descendant path homomorphism from p 1 to p 2 iff there is a function dph from the nodes of p 1 to the nodes of p 2 such that: (a) for every node n in p 1 , n and dph ( n ) have the same labels. (b) if n is a child of n in p 1 , dph ( n ) is a descendant of dph ( n ) in p 2 .
For instance, in Figure 5, the path courses/course/title[ Database ] of pat-tern P 4 has a descendant path homomorphism to courses/course/ prerequisite/course/title[ Database ] of pattern P 8 . Similarly, the path courses/course/title[ Advanced ] of P 4 has a descendant path homomor-phism to courses/course/title[ Advanced ] of P 8 since they are identical.
We use the concept of descendant path homomorphism to define the  X  dph relation.
 Definition 6. Let P and P be two patterns of a query Q on an XML tree. P  X  (a) P and P share the same root-to-LCA path. (b) for every keyword k in Q, the path from the LCA to the node annotated by
Consider the patterns P 4 and P 8 of Figure 5. As one can see, P 4  X  dph P 8 since for each one of the keywords advanced, database, systems, the path from courses to the node annotated by this keyword has a descendant path homo-morphism to a path in the MCT of P 8 .
 We now use  X  dph to introduce the notion of collection.
 Definition 7. Consider the set of classes of a query on an XML tree. Let R be the set of class representatives. A collection is a set L of classes which contains exactly: (a) a class C whose representative is a minimal element in R w.r.t.  X  dph , and (b) all the classes C such that repr ( C )
That is, for L and C, we have that  X  C  X  L, C = C ,repr ( C )  X  dph repr ( C ) and for every class C  X  L, repr ( C )  X  dph repr ( C )and repr ( C )  X  dph repr ( C ) . Clearly, repr ( C ) is the least element in the set of representatives of classes in L with respect to  X  dph . We define the representative of collection L to be the representative of class C. That is, repr ( L )= repr ( C ) .

There are as many collections for Q on T as there are minimal elements in the set of class representatives R w.r.t.  X  dph . Note that the collections can overlap. However, they cannot overlap on a representative class (a class whose representative is also the representative o f a collection). Therefore, no collection can be included into a nother collection.
 Navigation among Clusters. We now explain how the user proceeds in order to find the relevant results of a query. In order to facilitate this process, we provide techniques for ranking the clusters: all collections are ranked at the top level, classes are ranked within coll ections, and patterns are ranked within classes.
 Within a class, the patterns are ranked based on their size in ascending order. Patterns of the same size have the same rank. If the size of a pattern is smaller than the size of another pattern in the same class, it is assumed to be more relevant to the query as it more closely r elates the query keyword instances.
The  X  dph relation is used to rank the classes within a collection. As Definition 7 determines, the representative of a co llection is the least element in the set of representatives of classes in t he collection with respect to  X  dph . Therefore, every collection is a rooted DAG where the nod es correspond to classes and the direct edges correspond to  X  dph relation between the representatives of the classes. Thereisanedgefrom C 1 to class C 2 if repr ( C 1 )  X  dph repr ( C 2 ). The class of the representative of the collection is the unique source of the DAG. We rank the classes within a collection so that the total order of the rank complies with the partial order defined by the DAG.

Collections are also organized into graphs in order to provide an ordering of them. For this purpose, we define another type of relation called partial path homomorphism relation (  X  pph ).
 Definition 8. Let P and P be two patterns of a query on an XML tree, and p and p be root-to-annotated-node paths of P and P whose last nodes are anno-tated by the same keyword. We say P  X  pph P iff there is a function pph from the nodes of p to the nodes of p such that: (a) the root of P in p is mapped by pph to the root of P in p , (b) the root of the MCT of P in p is mapped by pph to a node which is a (c) for every node n in p , n and pph ( n ) have the same labels, and (d) if n 2 is a child of n 1 in p , pph ( n 2 ) is a child of pph ( n 1 ) in p . For our running example, Figure 6 shows two patterns, P 3 and P 4 where P of the keywords because its MCT root is deeper in the XML tree.

The  X  pph relation is used to construct a graph of collections in which the nodes represent the collections . There is an edge from collection L to collection L if repr ( L )  X  pph repr ( L ). The collections are order ed in accordance with the partial order obtained from the graph.
 Our implementation of the proposed clustering approach consists of two com-ponents. The first one is the pattern generation component which generates the query patterns (that is, the first level of clustering) and their associated ITs. We use the PatternStack algorithm [1] for this purpose. PatternStack takes as input a keyword query and the inverted lists of the keyword instances for the query keywords. The second component of our implementation constructs the classes and the collections by performing the nece ssary relation checks. It also compares collections, and constructs the final graph of collections for user navigation.
We exploit the transivity property of the  X  relation (  X  is an equivalance relation) to make the computation faster. Because of this property, it suffices to check for the existence of  X  between a pattern and the representative of a class to decide if a pattern is a member of the class.

The outline of our algorithm is given in Algorithm 1. It takes as input the patterns produced by the PatternStack algorithm and updates the classes and collections, or constructs new ones. In lines 1-8, a pattern P cur is compared with every collection representative that has the same root-to-MCT-path. There is no need to compare with the rest of the collections as both the  X  dph and  X  relations have this structural requirement. After the checks are completed, all the modified collections are examined by DiscoverMergeCollections to discover if there are any new collections. If the re is a new collection, it is compared with the rest of the collections in terms of  X  pph to update G collection (graph of collections with edges representing the  X  pph relation). In addition, if there are
Algorithm 1. Algorithm for constructing the clusters multiple collections which have P cur as their representative, these collections are merged.

The function Check (lines 10-21) checks if a pattern under consideration belongs to a given collection. The patte rn is compared with every class of a collection. Edges are added to the G L graph appropriately between the class of the new pattern and the previously constructed classes to reflect the  X  dph relation. Because of space constraints, the details of the data structures that are used and of the implementation of DiscoverMergeCollections are omitted. We performed experiments to assess the efficiency of our clustering algorithm and also, the retrieval effectivenes s of our clustering methodology.
We use the Mondial and Sigmod datasets for the experiments 1 .Theexperi-ments were conducted on a 2.9 GHz Intel Core i7 machine with 3 GB memory running Ubuntu. 5.1 Metrics We adapted the reach time metric [5, 8] to assess the retrieval effectiveness. This metric is used to quantify the time spent by a user to locate a relevant result (a pattern in our case). The reach time for a specific pattern is proportional to the number of elements that the user needs to examine while locating a relevant pattern through the clustering levels. The formal definition is given by Equation 1where n k is the number of patterns the user examines at the k-th step and l is the number of steps ( l = 3 in our approach, since there are only three levels of clustering) that the user needs to take. Since the collections can overlap, there might be several paths leading to a relevant pattern. We consider the shortest path to this pattern to compute its reach time. We report the average reach time for a query over all of the relevant patterns for that query. 5.2 Effectiveness of Retrieval We run the queries of Table 1 over Mondial and Sigmod databases. Figure 7 shows the reach time values measured for each query. According to these values, our clustering methodology almost always allows the user to find the relevant result in the first collection that they examine. This is because of the fact that  X  pph pushes down collections which contains less meaningful patterns to the lower ranks. In addition, within the collections, the ordering of the classes ob-tained from their graph organization also ranks lower the classes with patterns which have a looser connection bet ween their keyword instances.
We present the number of patterns and the resulting number of collections for each query in Figure 8. Note that, the y-axis is in logarithmic scale. As one can see, even in the maximum case, the nu mber of generated collections is less then 20 (query M 5, which has 107 matching patterns). We can claim that the number of generated collections is reasonable and since it is significantly smaller than the number of patterns, examining the collections and drilling down to a specific collection would be more conven ient for users than a flat interface. 5.3 Efficiency We present the computation times of our algorithm for each query of Table 1 in Figure 9. Most of the execution times are smaller than 1 second even though further optimizations can be done for the computation. The response time of the system is comparable to those of real life applications. Keyword search on XML is a complicated task since XML does not usually follow a strict schema. Several papers proposed filtering and ranking semantics for finding results which are relevant to the query and ranking them with respect to their relevancy, respectively. Filter ing semantics, such as Smallest LCA [13], Exclusive LCA [4], Meaningful LCA [7] and VLCA [6] filters out results that do not follow some rules which are based on structural and/or semantic properties of the results. Ranking semantics exploits different statistical measures [2 X 4, 12] and semantic features [1].

Recently, different studies addressed t he problems of keyword ambiguity and the multitude of results. XReal [2] proposed approaches to find the user intented result type for keyword queries. XSeek [9] addressed the problem of deciding upon the nodes to be included in the results. XMean [8], and Liu and Chen [10] address the problem of clustering XML keyword search results. XMean [8] introduced the conceptually related entity nodes as their semantics. Patterns are used to define clusters for the results. A hierarchy of clusters is also introduced in [8] by applying some relaxations to the patterns. Liu and Chen [10] clusters the results by using the types of keyword instance nodes (i.e., entity or attribute). In this paper, we addressed the problem of clustering the keyword search re-sults on XML data. We proposed a multi-level clustering methodology to cluster results which represent similar structural and semantic features. To this end, we introduced different relations based on homomorphisms. Our experiments show that our clustering methodology co mputes the clusters very efficiently and effectively supports the user in retrieving the relevant results.

As future work, we aim to investigate the diversification aspect of our clus-tering methodology in order to produce diverse ranked lists of the results.
