 The problem of finding frequent patterns from graph-based datasets is an important one that finds applications in drug disco very , pro-tein structure analysis, XML querying, and social netw ork analysis among others. In this paper we propose a frame work to mine fre-quent lar ge-scale structures, formally defined as frequent topolo g-ical structur es , from graph datasets. Key elements of our frame-work include, fast algorithms for disco vering frequent topological patterns based on the well kno wn notion of a topological minor , al-gorithms for specifying and pushing constraints deep into the min-ing process for disco vering constrained topological patterns, and mechanisms for specifying approximate matches when disco vering frequent topological patterns in noisy datasets. We demonstrate the viability and scalability of the proposed algorithms on real and syn-thetic datasets and also discuss the use of the frame work to disco ver meaningful topological structures from protein structure data. Categorization and Subject Descriptions: H.2.8 [Database Ap-plications]: Data Mining General Terms: Algorithms Keyw ords: Graph mining, topological minor , frequent graph pat-tern
Recently , there has been a lot of interest in mining frequent pat-terns from structur ed or semi-structur ed datasets, and a majority of research in this area has focused on developing efficient algo-rithms for mining frequently occurring (connected) subgraphs [4, 6, 13, 8]. Ho we ver, in man y real world applications, such as bi-ology , social netw orks, and telecommunication, lar ge-scale struc-tur es , which pro vide high-le vel topological information of graphs, can be very important to pro vide key insights into the underlying datasets. For instance, the disco very of non-local or tertiary struc-tural information is an important problem in protein structure anal-ysis. Similarly , in the analysis of social or communication net-works, the direct connection between a pair of nodes is often not the focus, instead, the patterns where several nodes are connected through a set of independent paths are of greater interest. Ho we ver, Cop yright 2005 ACM 1-59593-135-X/05/0008 ... $ 5.00. such frequent lar ge-scale structures can be very hard to disco ver using current frequent subgraph mining approaches [4, 6, 13, 8]. This is not only because the subgraphs sharing these kind of struc-tures can be infrequent (i.e. the traditional anti-monotone property does not hold), but also because the indi vidual subgraphs do not adequately represent such structures.

The main contrib ution of this paper is a frame work to mine fre-quent lar ge-scale structures from graphs. Our work is inspired by a well-established mathematical concept, topolo gical minor [1]. A topological minor of a graph is an abstraction that focuses on its structural information. Intuiti vely , such an abstraction is achie ved by replacing or contracting independent paths in a subgraph with indi vidual edges. We develop an efficient algorithm to enumerate frequent topological structures from graph datasets.

An important notion in our frame work is that of a relabeling function . Since often real datasets can be best represented as la-beled graphs when we replace independent paths in a subgraph with edges, the information labels on such paths are lost. Ho w-ever, in man y applications, summarized information about the con-tracted paths can be useful to cate gorize these topological struc-tures. Our frame work supports this notion through user -defined re-labeling functions to reco ver some degree of information loss from the contracted paths. Such a function maps an entire labeled path to a single edge label. In other words, an edge label carries the desired information about its corresponding contracted path.

To the best of our kno wledge, our work is the first to focus on the problem of mining frequent (lar ge-scale) topological structures. Ov erall, our frame work is also very flexible. It can be used for ap-proximate pattern mining , where the support for a frequent pattern does not depend on the exact matches, but instead relies on some form of a fuzzy matc hing [2, 7, 10]. The topological structures to-gether with relabeling functions pro vide a powerful mechanism to express various forms of fuzzy matches. We begin with some basic notations. The verte x set of a graph G is referred to as V ( G ) , and its edge set as E ( G ) . A path graph G is a sequence of vertices v 1 ; v 2 ; ; v k , where and f v i ; v i +1 g 2 E ( G ) . The vertices v 1 and v k and are called its ends , and v 2 ; v 3 ; ; v k 1 are the inner vertices of
P . Also, we define the number of inner vertices in a path as its length . In particular , a group of paths are independent if none of the paths have an inner verte x on another path. An y of such paths is called as an independent path . Note that the independent paths are the key tools to study topological structures of a graph.
Informally , a topolo gical minor of a graph is obtained by con-tracting the independent paths of one of its subgraphs into edges. For example, in Figure 1, X is a topological minor of Y since can be obtained by contracting the independent paths of G is a subgraph of Y . Clearly , contracting independent paths helps simplify a (sub)graph without compromising its topological infor -mation [1].

The formal definition of the topolo gical minor of a graph is as follo ws. A subdivision oper ation of a graph X , is to replace the edges of X with independent paths. A subdivision graph of a graph obtained by performing a subdi vision-operation of example, in Figure 1, the graph G is a subdi vision graph of Note that the subdi vision operation is basically an  X  X n verse X  of the path contraction operation. Further , the topological space of T ( X ) , is the collection of all its subdi visions graphs. If subdi vision graph G ( G 2 T ( X ) ) and G is a subgraph of another graph Y , then X is a topolo gical minor of Y . The vertices of which corresponds to the original vertices of Y are called branc h vertices .

Topolo gical structur es of a graph are deri ved from topological minors. Given two parameters, l and h; 0 l h , an ( l; h subdivision of a graph X , involv es replacing all edges of independent paths whose lengths are between l and h . An ( subdivision graph of X is a graph obtained by performing an ( subdi vision operation of X . For example, in Figure 1, G ( 0 ; 3 )-subdi vision graph of X . Similarly , we can define the ( topological space of X , T l;h ( X ) , to be the collection of all its ( l; h )-subdi visions graphs. If X has an ( l; h )-subdi vision graph ( G 2 T l;h ( X ) ) and G is a subgraph of another graph Y , then a ( l; h )-topolo gical minor , or a topological structure of fore, in Figure 1, X is a ( 0 ; 3 )-topological minor of Y the purpose of introducing the definition of topological structures of a graph is to control the compression ratio between a graph and its subdi vision graph.
Thus far, our discussion has focused on unlabeled graphs. One is often more interested in labeled graphs. We begin with the in-formal discussion of the topological structures on a labeled graph. Intuiti vely , the way to simplify a labeled graph is to remo ve all the inner vertices and edges of its independent labeled paths, and then connect their remaining labeled ends with an unlabeled edge. In Subsection 2.3, we will describe how to use relabeling functions to add labels to these contracted edges. Clearly , the main dif fer -ence between the topological structures on labeled graphs and on unlabeled graphs is that the verte x labels for the ends of contracted paths are still preserv ed.
Here, we will mainly focus on the verte x labeled graphs, where each verte x has a label. Note that our results and methods can be easily extended to (edge) labeled graphs. Given two parameters, l and h , the main dif ference between an ( l; h )-topological minor on labeled graph and unlabeled graph is the subdi vision operation. An ( l; h )-subdivision oper ation of a verte x labeled graph volv es replacing all edges of X with independent paths satisfying the follo wing conditions: 1) the path lengths are between the vertices (and edges) in the paths are labeled, and 3) the ends of these paths share the same verte x label as the corresponding ends of their original edges. The other concepts, i.e., the ( l; h graph, the ( l; h )-topological space, and ( l; h )-topological minors, are the same as in unlabeled graphs.

Assume we have a collection of graphs, denoted as D . Given two parameters l and h , and a graph G , the number of graphs in which have G as a ( l; h )-topological minor (also topological struc-ture) is referred to as the support of G .

D EFINITION 1. Given a collection of graphs, two par ameter s and h , and a thr eshold , a ( l; h )-topolo gical minor whose support is greater than or equal to is called
For example, in Figure 2, for l = 1 and h = 2 , the support of the graph G a is 3 in the dataset composing of G 1 , G 2 , G 3 for l = 0 and h = 1 , the support of the graph G a is only
Consider a path p = ( v 0 ; v 1 ; ; v k ) . Normally , when it is con-tracted in a topological structure, the only information left is its ends, v 0 and v k , with their verte x labels. Relabeling functions can preserv e important additional information from these contracted paths, in the form of labels for the corresponding edges in the topo-logical structure.

Formally , a relabeling function f : P ! L can be defined as a map from the set of all possible paths P to the new edge-label set for the topological structure L . A common type of relabeling functions is deri ved from the length of each independent path. For example, we can use the length of a contracted path to label its cor -responding edge. Formally , for a given path p = ( v 0 ; v f ( p ) = k 1 . Note that in this way, the edges in the topological structures become labeled.

Because of the space limitation, we will omit further discussion of relabeling function , including its implementation and its applica-tion for appr oximate pattern mining . We refer the interested readers to our technical report [5] for details.
Frequent topological structure mining is a generalization of fre-quent graph mining. Specifically , frequent sub-graphs for a verte x-labeled graph dataset can be mined as a special case of frequent topological structures: the ( 0 ; 0 )-topological minors. It should also be noted that frequent topological structures are also graphs. There-fore, mining frequent topological structures shares some similari-ties with mining frequent graphs.

Ho we ver, mining frequent topological structures is also quite dif-ferent from graph mining. Given two parameters l and h , the sup-port of a topological structure G depends on the definition of ( topological minor . Specifically , if G is a ( l; h )-topological minor of a graph D i in the graph dataset, we need to kno w if there is a subgraph H of D i and H is a ( l; h )-subdi vision graph of potentially involv es not only the subgraph isomorphism testing, but also the ( l; h )-subdi vision operation. In particular , counting support of topological structures is one of key issues in efficiently mining frequent topological structures, which we document here.
To tackle this problem, we use an incremental approach. Con-sider a topological structure G 0 that can be extended from another topological structure G by adding a new edge e , denoted as G [ f e g . To test if G 0 is a topological structure of a graph approach utilizes the information deri ved from G . In particular , such reuse is based on a uniform representation for a topological structure G and its corresponding subgraph in H . In the follo wing, we first establish such representation, and then discuss the details of how we count the support of a topological structure.
 Decomposition-based Repr esentation: Given l and h , let an ( l; h )-topological minor of H . This implies that there exists a subgraph Y of H , where Y is a ( l; h )-subdi vision graph of a subdi vision operation. To facilitate our discussion, we denote the subgraph Y together with an ( l; h )-subdi vision operation as an occurr ence of G . Here, Y is isomorphic to the graph obtained by performing the subdi vision operation on G . In the follo wing, we consider how we can express the occurrences of G explicitly .
We first decompose G as a collection of edges, i.e., G = f e f e 2 g [ f e k g . Based on the definition of the subdi vision oper -ation, each edge e i corresponds to an independent path in noted as ~ e i . Therefore, we can also decompose Y as a collection of independent paths, i.e., f ~ e 1 g [ f ~ e 2 g [ f ~ e decomposition as ~ Y . Clearly , the abo ve decomposition of be used to represent an occurrence of G in H . For example, in Fig-the topological structure, G 0 = f ( A; B ) ; ( B; C ) g .
The decomposition can be further represented in a very concise format. Consider G [ f e g which is also a ( l; h )-topological minor of H . Let S G;H = f ~ Y 1 ; ~ Y 2 ; ; ~ Y m g be all the occurrences of in H . We have the follo wing lemma.

L EMMA 1. The occurr ences of G [ f e g can be repr esented as ~ 1 [ f ~e g ; ; ~ i [ f ~e g Given a topological structure G 0 , we can decompose it as f e g , where G is called a parent of G 0 . For example, in Figure 3(b), we have G 0 = G [ f ( B; C ) g , where G = f ( A; B ) g . Lemma 1 suggests that occurrences of G 0 can be partially represented by the occurrences of its parent. Naturally , for each topological structure, we can build an occurr ence list to concisely record all of its occur -rences in the graph dataset by using the occurrence list of its parent. Note that a topological structure can have man y parents. Ho we ver, we only need one of its parents to build its occurrence list. The question of which one of these parents is chosen will be addressed in Subsection 3.2).

The concise representation of each occurrence in the occurrence list for a topological structure G [ f e g is as follo ws. Each oc-currence has a unique ID in the occurrence list, and the detailed information is a triple, ( ; ; ). Here, is the inde x of the graph in the dataset D where this occurrence appears, is the occurrence ID of this occurrence X  s parent, and is an independent path, corresponding to the edge e . For instance, Figure 3(c), illustrates a portion of the occurrence lists for three ( 1 ; 2 )-topological struc-tures, G , G 0 , and G 00 .
 Building the Occurr ence Lists: Clearly , the support of a topolog-ical structure can be easily deri ved from its occurrence list. There-fore, the problem of efficiently counting the support of a potential frequent topological structure boils down to building its occurrence list efficiently . Ho we ver, the nai ve solution can be very costly . For example, suppose we already have the occurrence list for G to build the occurrence lists for G [ f e g and G [ f e 0 g and e 0 are adjacent to the same verte x v in G . The nai ve method will build the occurrence lists for them independently . Specifically , for each of them, we need to go through all the occurrences of to find out all the independent paths corresponding to edge (path contraction). This, howe ver, involv es a lot of repetiti ve work, since each time we have to find all the independent paths start-ing from the branch verte x corresponding to v in each occurrence. Note that similar problems also need to be addressed in frequent subgraph mining algorithms [8].

In order to build the occurrence lists efficiently for the topologi-cal structures, we want to minimize the number of times the finding independent paths (discussed later) operation needs to be invoked. We also build occurrence lists in parallel when we invoke such an operation. To formally discuss our approach, we first introduce some notation.

Let us consider generating new frequent topological structures by extending an existing frequent topological structure G new edge. We classify these new edges in two cate gories: inner edges or outer edges. An inner edge connects two dis-adjacent vertices in the graph G , and an outer edge adds a new verte x into V ( G ) , and connects an existing verte x in V ( G ) with this new ver-tex. For a topological structure G , we denote [ G ] inner set of all inner edges of G , and [ G ] outer to be the set of all outer edges of G . We use [ G ] io to represent the union of [ G ] [ G ] outer . The significance of these two sets [ G ] outer is that the y record all the potential extensions of G . Finally , for an extended graph G [ f e g from G , we denote its occurrence list as e:occur rencel ist or ( G [ f e g ) :occur rencel ist .

The basic idea of our approach is as follo ws. For each topolog-ical structure G , we will maintain the occurrence list for each ex-tended graph G [ f e g where e 2 [ G ] io . We will sho w an optimiza-tion in next subsection to reduce the number of recorded occurrence lists. Here, we consider how we can build these lists for If e is an inner edge, we can have [ G [ f e g ] io [ G ] io fore, we need to simply cop y the occurrence lists for the edges in [ G ] io . Note that this is not a real cop y since not all occurrences for G [ f e 0 g , e 0 6 = e; e 0 2 [ G ] io can be extended to Essentially , this cop y is a Join operation, which will be discussed later . Further , if e is an outer edge, the new verte x generated by e will be lik ely to bring some new outer edges. Also, the exist-ing outer edges of G may become inner edges for G [ f e g this case, we will not only need to cop y these occurrence lists from G , but also need to build the occurrence lists for all the new outer edges adjacent to the new verte x.
 Finding Independent Paths: The sketch of the algorithm for find-ing all independent paths ( IndependentP ath subroutine) for an oc-currence ~ Y starting from a branch verte x s is as follo ws. Let the graph where this occurrence ~ Y appears. We perform a depth-first search (DFS) to enumerate these paths. There are two impor -tant issues we need to deal with. The first involv es maintaining the independent property , and the second involv es bounding the length of each path, specifically , the number of inner vertices, between and h . To deal with the first issue, we color the vertices in the oc-currence of G . Then, as we tra verse the graph G starting from the branch verte x s , we keep coloring the visited vertices. If we meet any colored verte x, we need to trace back since the path has become not independent. When we found an independent path (the number of inner vertices) bounded by l and h , we will record this path. Note that the tracing back operation is associated with un-coloring the visited verte x.
 Key Operations: In the follo wing, we formally introduce the two key operations mentioned earlier , which are the Join operation and the ExtendOuterEdg es operation. The two operations are sketched in Figure 4. Assume G is generated by adding an outer edge parent. The procedure ExtendOuterEdg es will scan the entire list of occurrences of G (the first for eac h loop in ExtendOuterEdg es ). For each occurrence, let p:to be its branch verte x corresponding to the newly added verte x for G . This procedure will find all the inde-pendent paths beginning from this branch verte x (the second for e-ach loop in ExtendOuterEdg es ). Specifically , such functionality is achie ved by the subroutine IndependentP ath just introduced. Each independent path generated abo ve corresponds to a new outer edge for the topological structure G , and the occurrence lists for these new outer edges are built by adding these independent paths (im-plemented by insertOccurr ence ). Finally , ExtendOuterEdg es will return all the new edges which are frequent with respect to the given support level.

The new topological structure, G [ f e g , will inherit more in-formation from its parent G through the procedure Join . The Join operation will filter the occurrence lists for each edge in generate all the inner edges. It will also filter all the outer edges adjacent with the vertices in V ( G ) for G [ f e g (implemented by the nested for eac h loops in Join ). The essential part of the Join operation is to test if, after extending the new edge e , the paths in the occurrences are still independent. This is done by the routine ( Independent invoked from Join ). For bre vity , the details of its im-plementation are omitted.
 Figur e 4: Support Counting Pr ocedur es for Mining Topological Structur es Our approach mines frequent topological structures in two phases. In the first phase, we mine all the frequent topological structures which are trees, and are referred to as frequent tree-topolo gical structur es . In the second phase, for each tree-topological structure T , we mine frequent graph-topolo gical structur es which have their spanning tree. The tree-topological structures are graphs with-out cycles, and the graph-topological structures are graphs with at least one cycle. Note, this two-phased procedure has been proposed and used for efficiently mining frequent subgraphs [13, 3]. Our algorithm is sketched in Figure 5. The mining procedure VT reeTS corresponds to the first phase, and the mining procedure VGr aphTS corresponds to the second phase. To generate frequent tree-topological structures, for each tree T , we use the mechanisms introduced in GAST ON [8] to determine which edges in [ T ] outer are valid ex-tensions. The valid extensions can also help to enumerate all fre-quent tree-topological structures without replication. Specifically , the procedure ValidExtension (in voked by VT reeTS in the for eac h loop) pro vides the abo ve mechanism. The frequent graph-topological structures are enumerated by adding a subset of inner edges in [ T ] inner to each frequent tree-topological structure T . In our algo-rithm, the procedure CanonicalExtension (in voked by VGr aphTS in the for eac h loop) applies hashing and graph isomorphism test to avoid duplicating graph-topological structures.
 Figur e 5: Algorithm Framew ork for Mining Topological Struc-tur es
Disco very of lipids binding sites has been long kno wn as a very challenging, but important, task for the biologists [9]. In this study , we use our new tool to search potential protein-lipid binding sites in an important class of proteins -membrane proteins, which are belie ved to account for approximately 20-30% of all protein se-quences.
 The dataset we use is deri ved from the protein data bank (PDB). We use a set of six membrane proteins kno wn to bind with car -diolipins (CL): 1KB1, 1KQF , 1M3X, 1OKC, 1V54, and 1OGV . Amino acids as nodes in the graph (20 labels) and edges between nodes are dra wn if two amino acids are within 3 : 5  X  A . There are kno wn to be 20 naturally occurring amino acids and these serv e as node labels. In order to find the structural motifs that can serv e as binding site for a CL head group, we used only the rele vant parts of proteins that are kno wn to be local to CL molecule. Such a struc-ture typically contains around 30 35 amino acids (number of nodes per graph). Note that several membrane proteins we use con-tain more than one CL molecule. Therefore, the total number of CL binding regions that we used to find protein-lipid binding sites is (number of graphs).

Table 1 summarizes the results on mining this dataset using our tool. Note that TSMiner at l = 0 and h = 0 is simply a connected subgraph mining tool (same results as with Gaston). For this pa-rameter setting, one can only find patterns till the support level is Table 1: Number of Lar ge Patter ns Disco vered by TSMiner Figur e 6: Fr equent Topological Structur es Disco vered by TSMiner 3 , and the lar gest one found contains at most 6 verte xes. Ho we ver, upon varying the value of the parameters, we find lar ge triangles with support 5 and 6, along with lar ge rectangles, and topological structures containing 5 or more verte xes. At support 3, with re-lax ed l and h , we found a number of lar ge topological structures, containing more than 9 verte xes, and 9 edges. Figure 6 sho ws two such lar ge topological structures disco vered by our toolkit. Also, such lar ge patterns cannot be found by MotifMiner [10, 11]. The topological structures consist lar gely of polar (N, T, S), char ged (K) and aromatic (W) residues which is in agreement with recent ad-vances in the understanding of such proteins within the biophysics community[9]. The structure we find is lar ger than any kno wn mo-tifs for CL binding sites in such proteins and also seems to par -tially span the membrane bridging components of the protein which seems quite novel according to domain experts.
In this section, we will study the performance of our new algo-rithm, TSMiner , focusing on the follo wing two issues: the scala-bility of the algorithm, how the parameters, l , h , and the support level , affect the performance. A more complete experimental evaluation is documented in our technical report [5]. We have implemented TSMiner in C++. The evaluation studies were con-ducted on a 2.66 GHz Pentium 4 machine with 1GB main memory , running Linux Mandrak e 10.1.
 Datasets: Our experiments used both synthetic and real datasets, containing verte x labeled graphs, i.e., the edge labels were not con-sidered. The synthetic datasets were generated from the graph gen-erator pro vided by Kuramochi and Karypis at the Uni versity of Minnesota. In our experiments, we fix ed the average number of edges, T = 20 , the total number of potentially frequent subgraphs, L = 200 , the average number of edges in each potentially frequent subgraph, I = 5 , and we vary V , the total of verte x labels, to be between 5 and 20. The real dataset was originally used for the Pre-Figur e 7: (a)V arying Support (D10kV20) (b) Varying Dataset Size (D*kV20, Sup=20%) Figur e 8: Chemical340 (a)No. of Patter ns(V arying Support) (b)Running Time(V arying Support) dicti ve Toxicology Ev aluation Challenge [12]. It contains a total of 340 chemical compounds. For each compound, the atoms corre-spond to the vertices of the graph, and the bonds between the atoms are mapped to the edges of the graph. For simplicity , we refer this dataset as Chemical340 .
 Scalability: For the scalability study , we rely on the synthetic datasets. In Figure 7(a), we vary the support threshold from high to low, and run our algorithm on datasets containing 10 ; 000 As we would expect, as the support level reduces, the running time increases. Also, we can observ e that as h increases ( l same), the running time increases. This is also expected as the number of (potential) frequent topological patterns increases as we relax the condition on the length of the independent paths. From Figures 7(b), we see that TSMiner scales reasonably well (close to linear) as we increase the size of the dataset. Note that the TSMiner with parameters l = 0 , h = 0 is essentially a frequent connected subgraph mining tool for verte x labeled graphs. For such cases, we did a comparison with the state-of-art subgraph mining tool gSpan [13]. Our results sho w that our implementation is slo wer by a factor of 1.6. We belie ve this is a reasonable result, given that we offer additional functionality and do not specifically optimize for subgraph mining.
 Impact of Varying l and h : In this study , we are interested in the number of patterns being generated by our new algorithm and its running time respect to the parameters l and h . Figure 8 (a) and (b) sho w the total number of patterns being disco vered and the running time of TSMiner at dif ferent support levels, as we increase keep l to be 1 on the real dataset Chemical340 .
In this paper , we have presented a novel frame work for mining topological patterns in graph datasets. Based on the well kno wn no-tion of a topological minor , we have designed efficient algorithms for mining such patterns. Additionally , our frame work supports the notion of a user -defined relabeling function, which can be used to specify constraints and fuzzy matching criteria [5]. We have demonstrated the effecti veness and scalability of the proposed al-gorithms on real and synthetic datasets. We have also reported on a case study where the frame work has been used to identify topolog-ical structures from membrane protein structure data.
This work is funded in part by NSF grants CCF-0234273, CCF-0130437, CNS-0203846, CAREER IIS-0347662, and DOE grant DE-FG02-04ER25611. We thank Martin Caf fre y for pointing us to the problem domain for the case study . [1] Reinhard Diestel. Gr aph Theory . Springer -Verlag, 2000. [2] H. Hofer , C. Bor gelt, and M. R. Berthold. Lar ge scale mining [3] Jun Huan, Wei Wang, Jan Prins, and Jiong Yang. Spin: [4] Akihiro Inokuchi, Takashi Washio, and Hiroshi Motoda. [5] Ruoming Jin, Chao Wang, Dimitrii Polshak ov, Srini vasan [6] Michihiro Kuramochi and Geor ge Karypis. Frequent [7] Thorsen Meinl, Christian Bor gelt, Michael R. Berthold, and [8] Sie gfried Nijssen and Joost N. Kok. A quickstart in frequent [9] H Palsdottir and C Hunte. Lipids in membrane protein [10] S. Parthasarathy and M. Coatne y. Efficient disco very of [11] D. Polshak ov, K. Marsolo, and S. Parthasarathy . Mining [12] A. Srini vasan, R.D. King, S.H. Muggleton, and [13] Xifeng Yan and Jia wei Han. gspan: Graph-based
