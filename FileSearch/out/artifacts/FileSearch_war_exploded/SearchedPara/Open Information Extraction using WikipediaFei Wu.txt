
Information-extraction (IE) systems seek to distill semantic relations from natural-language text, but most systems use super-vised learning of relation-specific examples and are thus limited by the availability of training data. Open IE systems such as
TextRunner, on the other hand, aim to handle the unbounded number of relations found on the Web. But how well can these open systems perform?
This paper presents WOE , an open IE system which improves dramatically on TextRunner X  X  precision and recall. The key to WOE  X  X  per-formance is a novel form of self-supervised learning for open extractors  X  using heuris-tic matches between Wikipedia infobox at-tribute values and corresponding sentences to construct training data. Like TextRunner,
WOE  X  X  extractor eschews lexicalized features and handles an unbounded set of semantic relations. WOE can operate in two modes: when restricted to POS tag features, it runs as quickly as TextRunner, but when set to use dependency-parse features its precision and recall rise even higher. The problem of information-extraction (IE), gen-erating relational data from natural-language text, has received increasing attention in recent years. A large, high-quality repository of extracted tu-ples can potentially benefit a wide range of NLP tasks such as question answering, ontology learn-ing, and summarization. The vast majority of IE work uses supervised learning of relation-specific examples. For example, the WebKB project (Craven et al., 1998) used labeled exam-ples of the courses-taught-by relation to in-duce rules for identifying additional instances of the relation. While these methods can achieve high precision and recall, they are limited by the availability of training data and are unlikely to scale to the thousands of relations found in text on the Web.

An alternative paradigm, Open IE, pioneered by the TextRunner system (Banko et al., 2007) and the  X  X reemptive IE X  in (Shinyama and Sekine, 2006), aims to handle an unbounded number of relations and run quickly enough to process Web-scale corpora. Domain independence is achieved by extracting the relation name as well as its two arguments. Most open IE systems use self-supervised learning, in which automatic heuristics generate labeled data for training the extractor. For example, TextRunner uses a small set of hand-written rules to heuristically label training exam-ples from sentences in the Penn Treebank.
 This paper presents WOE (Wikipedia-based Open Extractor), the first system that au-tonomously transfers knowledge from random ed-itors X  effort of collaboratively editing Wikipedia to train an open information extractor. Specifically, WOE generates relation-specific training examples by matching Infobox 1 attribute values to corre-sponding sentences (as done in Kylin (Wu and Weld, 2007) and Luchs (Hoffmann et al., 2010)), but WOE abstracts these examples to relation-independent training data to learn an unlexical-ized extractor, akin to that of TextRunner. WOE can operate in two modes: when restricted to shallow features like part-of-speech (POS) tags, it runs as quickly as Textrunner, but when set to use dependency-parse features its precision and recall rise even higher. We present a thorough experi-mental evaluation, making the following contribu-tions:  X  We present WOE , a new approach to open IE  X  Using the same learning algorithm and fea- X  The biggest win arises from using parser fea-An open information extractor is a function from a document, d , to a set of triples, { X  arg 1 , rel , arg 2  X  X  , where the arg s are noun phrases and rel is a textual fragment indicat-ing an implicit, semantic relation between the two noun phrases. The extractor should produce one triple for every relation stated explicitly in the text, but is not required to infer implicit facts. In this paper, we assume that all relational instances are stated within a single sentence. Note the dif-ference between open IE and the traditional ap-proaches ( e.g. , as in WebKB), where the task is to decide whether some pre-defined relation holds between (two) arguments in the sentence.

We wish to learn an open extractor without di-rect supervision , i.e. without annotated training examples or hand-crafted patterns. Our input is Wikipedia, a collaboratively-constructed encyclo-pedia 2 . As output, WOE produces an unlexicalized and relation-independent open extractor. Our ob-jective is an extractor which generalizes beyond Wikipedia, handling other corpora such as the gen-eral Web. The key idea underlying WOE is the automatic construction of training examples by heuristically matching Wikipedia infobox values and corre-sponding text; these examples are used to generate an unlexicalized, relation-independent (open) ex-tractor. As shown in Figure 1, WOE has three main components: preprocessor, matcher, and learner. 3.1 Preprocessor The preprocessor converts the raw Wikipedia text into a sequence of sentences, attaches NLP anno-tations, and builds synonym sets for key entities. The resulting data is fed to the matcher, described in Section 3.2, which generates the training set. Sentence Splitting: The preprocessor first renders each Wikipedia article into HTML, then splits the article into sentences using OpenNLP.
 NLP Annotation: As we discuss fully in Sec-tion 4 (Experiments), we consider several varia-tions of our system; one version, WOE parse , uses parser-based features, while another, WOE pos , uses shallow features like POS tags, which may be more quickly computed. Depending on which version is being trained, the preprocessor uses OpenNLP to supply POS tags and NP-chunk an-notations  X  or uses the Stanford Parser to create a dependency parse. When parsing, we force the hy-perlinked anchor texts to be a single token by con-necting the words with an underscore; this trans-formation improves parsing performance in many cases.
 Compiling Synonyms: As a final step, the pre-processor builds sets of synonyms to help the matcher find sentences that correspond to infobox relations. This is useful because Wikipedia edi-tors frequently use multiple names for an entity; for example, in the article titled  X  X niversity of Washington X  the token  X  X W X  is widely used to refer the university. Additionally, attribute values are often described differently within the infobox than they are in surrounding text. Without knowl-edge of these synonyms, it is impossible to con-struct good matches. Following (Wu and Weld, 2007; Nakayama and Nishio, 2008), the prepro-cessor uses Wikipedia redirection pages and back-ward links to automatically construct synonym sets. Redirection pages are a natural choice, be-cause they explicitly encode synonyms; for ex-ample,  X  X SA X  is redirected to the article on the  X  X nited States. X  Backward links for a Wiki-pedia entity such as the  X  X assachusetts Institute of Technology X  are hyperlinks pointing to this entity from other articles; the anchor text of such links ( e.g. ,  X  X IT X ) forms another source of synonyms. 3.2 Matcher The matcher constructs training data for the learner component by heuristically matching attribute-value pairs from Wikipedia articles con-taining infoboxes with corresponding sentences in the article. Given the article on  X  X tanford Univer-sity, X  for example, the matcher should associate  X  established , 1891  X  with the sentence  X  X he university was founded in 1891 by . . .  X  Given a Wikipedia page with an infobox, the matcher iter-ates through all its attributes looking for a unique sentence that contains references to both the sub-ject of the article and the attribute value; these noun phrases will be annotated arg 1 and arg 2 in the training set. The matcher considers a sen-tence to contain the attribute value if the value or its synonym is present. Matching the article sub-ject, however, is more involved.
 Matching Primary Entities: In order to match shorthand terms like  X  X IT X  with more complete names, the matcher uses an ordered set of heuris-tics like those of (Wu and Weld, 2007; Nguyen et al., 2007):  X  Full match: strings matching the full name of  X  Synonym set match: strings appearing in the  X  Partial match: strings matching a prefix or suf- X  Patterns of  X  X he &lt; type &gt;  X : The matcher first  X  The most frequent pronoun: The matcher as-
When there are multiple matches to the primary entity in a sentence, the matcher picks the one which is closest to the matched infobox attribute value in the parser dependency graph.
 Matching Sentences: The matcher seeks a unique sentence to match the attribute value. To produce the best training set, the matcher performs three filterings. First, it skips the attribute completely when multiple sentences mention the value or its synonym. Second, it rejects the sentence if the subject and/or attribute value are not heads of the noun phrases containing them. Third, it discards the sentence if the subject and the attribute value do not appear in the same clause (or in parent/child clauses) in the parse tree.

Since Wikipedia X  X  Wikimarkup language is se-mantically ambiguous, parsing infoboxes is sur-prisingly complex. Fortunately, DBpedia (Auer and Lehmann, 2007) provides a cleaned set of in-foboxes from 1,027,744 articles. The matcher uses this data for attribute values, generating a training dataset with a total of 301,962 labeled sentences. 3.3 Learning Extractors We learn two kinds of extractors, one ( WOE parse ) using features from dependency-parse trees and the other ( WOE pos ) limited to shallow features like POS tags. WOE parse uses a pattern learner to classify whether the shortest dependency path be-tween two noun phrases indicates a semantic rela-tion. In contrast, WOE pos (like TextRunner) trains a conditional random field (CRF) to output certain text between noun phrases when the text denotes such a relation. Neither extractor uses individual words or lexical information for features. 3.3.1 Extraction with Parser Features Despite some evidence that parser-based features have limited utility in IE (Jiang and Zhai, 2007), we hoped dependency paths would improve preci-sion on long sentences.
 Shortest Dependency Path as Relation: Unless otherwise noted, WOE uses the Stanford Parser to create dependencies in the  X  X ollapsedDepen-dency X  format. Dependencies involving preposi-tions, conjuncts as well as information about the referent of relative clauses are collapsed to get direct dependencies between content words. As noted in (de Marneffe and Manning, 2008), this collapsed format often yields simplified patterns which are useful for relation extraction. Consider the sentence:
The Stanford Parser dependencies are: where each atomic formula represents a binary de-pendence from dependent token to the governor token.

These dependencies form a directed graph,  X  V, E  X  , where each token is a vertex in V , and E is the set of dependencies. For any pair of tokens, such as  X  X an X  and  X  X erkeley X , we use the shortest connecting path to represent the possible relation between them:
Dan
We call such a path a corePath . While we will see that corePaths are useful for indicating when a relation exists between tokens, they don X  X  neces-sarily capture the semantics of that relation. For example, the path shown above doesn X  X  indicate the existence of negation! In order to capture the meaning of the relation, the learner augments the corePath into a tree by adding all adverbial and adjectival modifiers as well as dependencies like  X  X eg X  and  X  X uxpass X . We call the result an ex-pandPath as shown below: WOE traverses the expandPath with respect to the token orders in the original sentence when out-putting the final expression of rel .
 Building a Database of Patterns: For each of the 301,962 sentences selected and annotated by the matcher, the learner generates a corePath between the tokens denoting the subject and the infobox at-tribute value. Since we are interested in eventu-ally extracting  X  X ubject, relation, object X  triples, the learner rejects corePaths that don X  X  start with subject-like dependencies, such as nsubj , nsubj-pass , partmod and rcmod . This leads to a collec-tion of 259,046 corePaths.

To combat data sparsity and improve learn-ing performance, the learner further generalizes the corePaths in this set to create a smaller set of generalized-corePaths . The idea is to elimi-nate distinctions which are irrelevant for recog-nizing (domain-independent) relations. Lexical words in corePaths are replaced with their POS tags. Further, all Noun POS tags and  X  X RP X  are abstracted to  X  X  X , all Verb POS tags to  X  X  X , all Adverb POS tags to  X  X B X  and all Adjective POS tags to  X  X  X . The preposition dependencies such as  X  X rep in X  are generalized to  X  X rep X . Take the corePath  X  Dan Berkeley  X  for example, its generalized-corePath is  X  N a generalized-corePath an extraction pattern. In total, WOE builds a database (named DB p ) of 15,333 distinct patterns and each pattern p is asso-ciated with a frequency  X  the number of matching sentences containing p . Specifically, 185 patterns have f p  X  100 and 1929 patterns have f p  X  5 . Learning a Pattern Classifier: Given the large number of patterns in DB p , we assume few valid open extraction patterns are left behind. The learner builds a simple pattern classifier, named WOE parse , which checks whether the generalized-corePath from a test triple is present in DB p , and computes the normalized logarithmic frequency as the probability 3 : where f max (50,259 in this paper) is the maximal frequency of pattern in DB p , and f min (set 1 in this work) is the controlling threshold that deter-mines the minimal frequency of a valid pattern.
Take the previous sentence  X  Dan was not born in Berkeley  X  for example. WOE parse first identi-fies Dan as arg 1 and Berkeley as arg 2 based on NP-chunking. It then computes the corePath  X  Dan and abstracts to p = X  N N  X . It then queries DB p to retrieve the fre-quency f p = 29112 and assigns a probabil-ity of 0 . 95 . Finally, WOE parse traverses the triple X  X  expandPath to output the final expression  X  Dan, wasN otBornIn, Berkeley  X  . As shown in the experiments on three corpora, WOE parse achieves an F-measure which is between 72% to 91% greater than TextRunner X  X . 3.3.2 Extraction with Shallow Features WOE parse has a dramatic performance improve-ment over TextRunner. However, the improve-ment comes at the cost of speed  X  TextRunner proves performance, especially on recall. runs about 30 X faster by only using shallow fea-tures. Since high speed can be crucial when pro-cessing Web-scale corpora, we additionally learn a CRF extractor WOE pos based on shallow features like POS-tags. In both cases, however, we gen-erate training data from Wikipedia by matching sentences with infoboxes, while TextRunner used a small set of hand-written rules to label training examples from the Penn Treebank.
 We use the same matching sentence set behind DB p to generate positive examples for WOE pos . Specifically, for each matching sentence, we label the subject and infobox attribute value as arg 1 and arg 2 to serve as the ends of a linear CRF chain. Tokens involved in the expandPath are la-beled as rel . Negative examples are generated from random noun-phrase pairs in other sentences when their generalized-CorePaths are not in DB p .
WOE pos uses the same learning algorithm and selection of features as TextRunner: a two-order CRF chain model is trained with the Mallet pack-age (McCallum, 2002). WOE pos  X  X  features include POS-tags, regular expressions ( e.g. , for detecting capitalization, punctuation, etc. .), and conjunc-tions of features occurring in adjacent positions within six words to the left and to the right of the current word.

As shown in the experiments, WOE pos achieves an improved F-measure over TextRunner between 18% to 34% on three corpora, and this is mainly due to the increase on precision. We used three corpora for experiments: WSJ from Penn Treebank, Wikipedia, and the general Web. For each dataset, we randomly selected 300 sen-tences. Each sentence was examined by two peo-ple to label all reasonable triples. These candidate triples are mixed with pseudo-negative ones and submitted to Amazon Mechanical Turk for veri-fication. Each triple was examined by 5 Turk-ers. We mark a triple X  X  final label as positive when more than 3 Turkers marked them as positive. 4.1 Overall Performance Analysis In this section, we compare the overall perfor-mance of WOE parse , WOE pos and TextRunner (shared by the Turing Center at the University of Washington). In particular, we are going to answer the following questions: 1) How do these systems perform against each other? 2) How does perfor-mance vary w.r.t. sentence length? 3) How does extraction speed vary w.r.t. sentence length? Overall Performance Comparison The detailed P/R curves are shown in Figure 2. To have a close look, for each corpus, we ran-domly divided the 300 sentences into 5 groups and compared the best F-measures of three systems in Figure 3. We can see that:  X  WOE pos is better than TextRunner, especially  X  WOE parse achieves the best performance, es-
Note that we measure TextRunner X  X  precision &amp; recall differently than (Banko et al., 2007) did. Specifically, we compute the precision &amp; re-call based on all extractions, while Banko et al. counted only concrete triples where arg 1 is a proper noun, arg 2 is a proper noun or date, and Figure 3: WOE pos achieves an F-measure, which is between 18% and 34% better than TextRunner X  X . WOE parse achieves an improvement between 72% and 91% over TextRunner. The error bar indicates one standard deviation. the frequency of rel is over a threshold. Our ex-periments show that focussing on concrete triples generally improves precision at the expense of re-call. 4 Of course, one can apply a concreteness fil-ter to any open extractor in order to trade recall for precision.

The extraction errors by WOE parse can be cat-egorized into four classes. We illustrate them with the WSJ corpus. In total, WOE parse got 85 wrong extractions on WSJ, and they are caused by: 1) Incorrect arg 1 and/or arg 2 from NP-Chunking (18.6%); 2) A erroneous de-pendency parse from Stanford Parser (11.9%); 3) Inaccurate meaning (27.1%)  X  for exam-ple,  X  she, isN ominatedBy, P residentBush  X  is wrongly extracted from the sentence  X  X f she is nominated by President Bush ... X  5 ; 4) A pattern inapplicable for the test sentence (42.4%).
Note WOE parse is worse than WOE pos in the low recall region. This is mainly due to parsing er-rors (especially on long-distance dependencies), which misleads WOE parse to extract false high-confidence triples. WOE pos won X  X  suffer from such parsing errors. Therefore it has better precision on high-confidence extractions.

We noticed that TextRunner has a dip point in the low recall region. There are two typical errors responsible for this. A sample error of the first type is  X  Sources, sold, theCompany  X  extracted from the sentence  X  X ources said Figure 4: WOE parse  X  X  F-measure decreases more slowly with sentence length than WOE pos and Tex-tRunner, due to its better handling of difficult sen-tences using parser features. he sold the company X , where  X  X ources X  is wrongly treated as the subject of the object clause. A sample error of the second type is  X  thisY ear, willStarIn, theM ovie  X  extracted from the sentence  X  X oming up this year, Long will star in the new movie. X , where  X  X his year X  is wrongly treated as part of a compound subject. Taking the WSJ corpus for example, at the dip point with recall=0.002 and precision=0.059, these two types of errors account for 70% of all errors.
 Extraction Performance vs. Sentence Length
We tested how extractors X  performance varies with sentence length; the results are shown in Fig-ure 4. TextRunner and WOE pos have good perfor-mance on short sentences, but their performance deteriorates quickly as sentences get longer. This is because long sentences tend to have compli-cated and long-distance relations which are diffi-cult for shallow features to capture. In contrast, WOE parse  X  X  performance decreases more slowly w.r.t. sentence length. This is mainly because parser features are more useful for handling diffi-cult sentences and they help WOE parse to maintain a good recall with only moderate loss of precision. Extraction Speed vs. Sentence Length
We also tested the extraction speed of different extractors. We used Java for implementing the extractors, and tested on a Linux platform with a 2.4GHz CPU and 4G memory. On average, it takes WOE parse 0.679 seconds to process a sen-tence. For TextRunner and WOE pos , it only takes 0.022 seconds  X  30 X times faster. The detailed extraction speed vs. sentence length is in Figure 5, showing that TextRunner and WOE pos  X  X  extraction time grows approximately linearly with sentence length, while WOE parse  X  X  extraction time grows Figure 5: Textrnner and WOE pos  X  X  running time seems to grow linearly with sentence length, while WOE parse  X  X  time grows quadratically. quadratically ( R 2 = 0 . 935 ) due to its reliance on parsing. 4.2 Self-supervision with Wikipedia Results In this section, we consider how the process of matching Wikipedia infobox values to correspond-ing sentences results in better training data than the hand-written rules used by TextRunner.

To compare with TextRunner, we tested four different ways to generate training examples from Wikipedia for learning a CRF extractor. Specif-ically, positive and/or negative examples are se-lected by TextRunner X  X  hand-written rules ( tr for short), by WOE  X  X  heuristic of matching sentences with infoboxes ( w for short), or randomly ( r for short). We use CRF + h lar approach, where  X + X  means positive samples,  X - X  means negative samples, and h i  X  { tr , w , r } . In particular,  X  + w  X  results in 221,205 positive ex-amples based on the matching sentence set 6 . All extractors are trained using about the same num-ber of positive and negative examples. In contrast, TextRunner was trained with 91,687 positive ex-amples and 96,795 negative examples generated from the WSJ dataset in Penn Treebank.

The CRF extractors are trained using the same learning algorithm and feature selection as Tex-tRunner. The detailed P/R curves are in Fig-ure 6, showing that using WOE heuristics to la-bel positive examples gives the biggest perfor-mance boost. CRF + tr  X  tr (trained using TextRun-ner X  X  heuristics) is slightly worse than TextRunner. Most likely, this is because TextRunner X  X  heuris-tics rely on parse trees to label training examples, and the Stanford parse on Wikipedia is less accu-rate than the gold parse on WSJ. 4.3 Design Desiderata of WOE parse There are two interesting design choices in WOE parse : 1) whether to require arg 1 to appear 2) whether to allow corePaths to contain prepo-sitional phrase (PP) attachments (denoted as PPa ). We tested how they affect the extraction perfor-mance; the results are shown in Figure 7.

We can see that filtering PP attachments ( PPa ) gives a large precision boost with a noticeable loss in recall; enforcing a lexical ordering of relation precision with small loss in recall. Take the WSJ a precision of 0.792 (with recall of 0.558). By 0.773 (with recall of 0.595). By changing PPa to 0.642 (with recall of 0.687)  X  in particular, if we use gold parse, the precision decreases to 0.672 fault in WOE parse as a logical consequence of our preference for high precision over high recall. 4.3.1 Different parsing options We also tested how different parsing might ef-fect WOE parse  X  X  performance. We used three pars-ing options on the WSJ dataset: Stanford parsing, CJ50 parsing (Charniak and Johnson, 2005), and the gold parses from the Penn Treebank. The Stan-ford Parser is used to derive dependencies from CJ50 and gold parse trees. Figure 8 shows the detailed P/R curves. We can see that although today X  X  statistical parsers make errors, they have negligible effect on the accuracy of WOE . Open or Traditional Information Extraction: Most existing work on IE is relation-specific. Occurrence-statistical models (Agichtein and Gra-vano, 2000; M. Ciaramita, 2005), graphical mod-els (Peng and McCallum, 2004; Poon and Domin-gos, 2008), and kernel-based methods (Bunescu and R.Mooney, 2005) have been studied. Snow et al. (Snow et al., 2005) utilize WordNet to learn dependency path patterns for extracting the hypernym relation from text. Some seed-based frameworks are proposed for open-domain extrac-tion (Pasca, 2008; Davidov et al., 2007; Davi-dov and Rappoport, 2008). These works focus written rules used by TextRunner.
 Figure 7: Filtering prepositional phrase attachments (
PPa ) shows a strong boost to precision, and we see Figure 8: Although today X  X  statistical parsers make errors, they have negligible effect on the accuracy of WOE compared to operation on gold standard, human-annotated data. on identifying general relations such as class at-tributes, while open IE aims to extract relation instances from given sentences. Another seed-based system StatSnowball (Zhu et al., 2009) can perform both relation-specific and open IE by iteratively generating weighted extraction pat-terns. Different from WOE , StatSnowball only em-ploys shallow features and uses L1-normalization to weight patterns. Shinyama and Sekine pro-posed the  X  X reemptive IE X  framework to avoid relation-specificity (Shinyama and Sekine, 2006). They first group documents based on pairwise vector-space clustering, then apply an additional clustering to group entities based on documents clusters. The two clustering steps make it dif-ficult to meet the scalability requirement neces-sary to process the Web. Mintz et al. (Mintz et al., 2009) uses Freebase to provide distant su-pervision for relation extraction. They applied a similar heuristic by matching Freebase tuples with unstructured sentences (Wikipedia articles in their experiments) to create features for learning relation extractors. Matching Freebase with ar-bitrary sentences instead of matching Wikipedia infobox with corresponding Wikipedia articles will potentially increase the size of matched sen-tences at a cost of accuracy. Also, their learned extractors are relation-specific. Alan Akbik et al. (Akbik and Bro X , 2009) annotated 10,000 sen-tences parsed with LinkGrammar and selected 46 general linkpaths as patterns for relation extrac-tion. In contrast, WOE learns 15,333 general pat-terns based on an automatically annotated set of 301,962 Wikipedia sentences. The KNext sys-tem (Durme and Schubert, 2008) performs open knowledge extraction via significant heuristics. Its output is knowledge represented as logical state-ments instead of information represented as seg-mented text fragments.
 Information Extraction with Wikipedia: The YAGO system (Suchanek et al., 2007) extends WordNet using facts extracted from Wikipedia categories. It only targets a limited number of pre-defined relations. Nakayama et al. (Nakayama and Nishio, 2008) parse selected Wikipedia sentences and perform extraction over the phrase structure trees based on several handcrafted patterns. Wu and Weld proposed the K YLIN system (Wu and Weld, 2007; Wu et al., 2008) which has the same spirit of matching Wikipedia sentences with in-foboxes to learn CRF extractors. However, it only works for relations defined in Wikipedia in-foboxes.
 Shallow or Deep Parsing: Shallow features, like POS tags, enable fast extraction over large-scale corpora (Davidov et al., 2007; Banko et al., 2007). Deep features are derived from parse trees with the hope of training better extractors (Zhang et al., 2006; Zhao and Grishman, 2005; Bunescu and Mooney, 2005; Wang, 2008). Jiang and Zhai (Jiang and Zhai, 2007) did a systematic ex-ploration of the feature space for relation extrac-tion on the ACE corpus. Their results showed lim-ited advantage of parser features over shallow fea-tures for IE. However, our results imply that ab-stracted dependency path features are highly in-formative for open IE. There might be several rea-sons for the different observations. First, Jiang and Zhai X  X  results are tested for traditional IE where lo-cal lexicalized tokens might contain sufficient in-formation to trigger a correct classification. The situation is different when features are completely unlexicalized in open IE. Second, as they noted, many relations defined in the ACE corpus are short-range relations which are easier for shallow features to capture. In practical corpora like the general Web, many sentences contain complicated long-distance relations. As we have shown ex-perimentally, parser features are more powerful in handling such cases. This paper introduces WOE , a new approach to open IE that uses self-supervised learning over un-lexicalized features, based on a heuristic match between Wikipedia infoboxes and corresponding text. WOE can run in two modes: a CRF extrac-tor ( WOE pos ) trained with shallow features like POS tags; a pattern classfier ( WOE parse ) learned from dependency path patterns. Comparing with TextRunner, WOE pos runs at the same speed, but achieves an F-measure which is between 18% and 34% greater on three corpora; WOE parse achieves an F-measure which is between 72% and 91% higher than that of TextRunner, but runs about 30 X times slower due to the time required for parsing.
 Our experiments uncovered two sources of WOE  X  X  strong performance: 1) the Wikipedia heuristic is responsible for the bulk of WOE  X  X  im-proved accuracy, but 2) dependency-parse features are highly informative when performing unlexi-calized extraction. We note that this second con-clusion disagrees with the findings in (Jiang and Zhai, 2007).

In the future, we plan to run WOE over the bil-lion document CMU ClueWeb09 corpus to com-pile a giant knowledge base for distribution to the NLP community. There are several ways to further improve WOE  X  X  performance. Other data sources, such as Freebase, could be used to create an ad-ditional training dataset via self-supervision. For example, Mintz et al. consider all sentences con-taining both the subject and object of a Freebase record as matching sentences (Mintz et al., 2009); while they use this data to learn relation-specific extractors, one could also learn an open extrac-tor. We are also interested in merging lexical-ized and open extraction methods; the use of some domain-specific lexical features might help to im-prove WOE  X  X  practical performance, but the best way to do this is unclear. Finally, we wish to com-bine WOE parse with WOE pos ( e.g. , with voting) to produce a system which maximizes precision at low recall.
 We thank Oren Etzioni and Michele Banko from Turing Center at the University of Washington for providing the code of their software and useful dis-cussions. We also thank Alan Ritter, Mausam, Peng Dai, Raphael Hoffmann, Xiao Ling, Ste-fan Schoenmackers, Andrey Kolobov and Daniel Suskin for valuable comments. This material is based upon work supported by the WRF / TJ Cable Professorship, a gift from Google and by the Air Force Research Laboratory (AFRL) under prime contract no. FA8750-09-C-0181. Any opinions, findings, and conclusion or recommendations ex-pressed in this material are those of the author(s) and do not necessarily reflect the view of the Air Force Research Laboratory (AFRL).

