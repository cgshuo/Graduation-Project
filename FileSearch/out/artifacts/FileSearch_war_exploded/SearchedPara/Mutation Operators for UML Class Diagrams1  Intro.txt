 A conceptual schema (CS) de fi nes the general knowledge required by an information information (following the requirements) is a key factor in the successful development of the system, especially in a Model-driven environment context [ 2 ]. The development of a conceptual schema is an iterative process involving evaluation of the CS, its accuracy and its improvement from the evaluation results. Testing is a well-established technique that helps to accomplish this task. It provides a level of con product based on the coverage of the requirements achieved by the test cases. Object-Oriented Conceptual Schemas in a Model-driven environment [ 3 , 4 ], where one group of engineers (e.g. requirements engineers) speci fi (RM) from which the test scenarios with test cases (i.e. an executable concrete story of a user-system interaction and the expected result) are automatically generated. These test cases are then used to test the conceptual schemas in an early phase of software analysis and design. Since testing is performed to provide insight into the accuracy of a CS, we need to ensure the test suite quality (i.e. ability to reveal faults). Mutation testing assesses the quality of a test suite [ 5 ] using mutation operators to introduce small modi fi cations or mutations into the software artefact under test, e.g. CS. The arti fi cial faults can be created using a set of mutation operators to change (  X  mutate  X  ) some parts of the software artefact. Mutants can be classi First Order Mutants (FOM) and Higher Order Mutants (HOM) [ 6 ]. FOMs are generated by applying mutation operators only once. HOMs are generated by applying mutation operators more than once [ 5 ]. Assuming that the software artefact being mutated is syntactically correct, a mutation operator must produce a mutant that is also syntac-The ratio of detected mutants is known as the  X  mutation score effective the tests are in terms of fault detection. Approaches that employ mutation testing at higher levels of abstraction, especially on CS, are not common [ 5 ]. In Mutation testing the most critical activity is the adequate design of mutation presents the design of a set of mutation operators for Conceptual Schemas (CS) based on Uni fi ed Modelling Language (UML) Class Diagrams (CD) [ 7 ]. The main potential advantage of mutation operators is to describe precisely the mutants that can generate this paper are:  X  It provides a classi fi cation of 50 mutation operators for UML CD-based CS, which may be used in evaluating veri fi cation 1 and validation operators are mainly based on a defects classi fi cation reported previously [ 9 ].  X  It illustrates the application of an effective subset of 18 mutation operators, which generate only fi rst order mutants. These mutation operators were applied to three UML CD-based CS with the aim of showing their usefulness in evaluating testing approaches.
 The paper is organized as follows. Section 2 describes an UML CD-based CS. Section 3 reviews the defect types at the model level. Section 4 explains the design process of the mutation operators. Section 5 demonstrates the application of the operators in three CS. Section 6 summarizes related work. Finally Sect. 7 concludes. The aim of this work is to design mutation operators for evaluating the effectiveness of test cases in fi nding faults in a CS during the analysis and design of the software. The defects will be introduced by deliberately changing a UML CD-based CS, resulting in wrong behaviour possibly causing a failure. this paper a UML-based class diagram is used to represent such a CS. A class diagram (see Fig. 1 ) is the UML  X  s main building block that shows elements of the system at an abstract level (e.g. class, association class), their properties (ownedAttribute), rela-tionships (e.g. association and generalization) and operations. In UML an operation is speci fi ed by de fi ning pre-and post-conditions. Figure 1 shows an excerpt of the UML structure for a class diagram and highlights eight elements of interest for this work. Finally, mutation testing requires an executable CS for validating the behavioural aspects included in the CS structural elements. Therefore, we used the Action Lan-guage for Foundational UML (Alf [ 10 ]) and the virtual machine of Foundational UML (fUML [ 11 ]) as the execution environment for mutation testing. An important aspect when applying mutation testing to a CS is that the injected defect should represent common modelling errors. In previous work [ 5 ] we classi model defects reported in the literature and related the types of the defects with the CS quality goals affected by them. Table 1 summarizes the defect types for CS. modelled requirements are the main causes of a design model inaccuracy that can be detected basing on requirement testing. Inconsistency defects require comparing CS versions in order to fi nd them. Finally, ambiguous elements require of user (e.g. modeller, low-level designer) criteria for fi nding defects.
 defects (adding, deleting or changing elements) into modelling elements (see Fig. 1 in Sect. 2 ) of the original CS. A transformation rule that generates a mutant from the original model is known as a mutation operator. If the mutant is generated by applying only one mutation operator in the original CS, it is a fi the CS by using nested operators. For example, a CS that has been mutated by deleting a class has also evidently deleted associations, properties, constraints, operations and parameters associated with the deleted class. During execution each CS mutant Mi will of running CS for any test case in T, then the mutant Mi is said to be the original model (i.e. it is semantically identical to the original model although syntactically different) or the test set is inadequate to kill the mutant. To apply Mutation Analysis in the context of UML CD-based CS we need to formulate mutation operators for CS. Mutation is based on two fundamental hypotheses, namely, the Competent Programmer Hypothesis (CPH) and the Coupling Effect Hypothesis (CEH), both introduced by DeMillo et al. [ 13 ]. The CPH states that a program produced by a competent programmer is either correct or near the correct version. The CEH states that complex (or higher-order) mutants are coupled to simple detect a high percentage of the complex faults [ 14 ]. Consequently, we use the fol-lowing guiding principles [ 15 ]:  X  Mutation categories should model potential faults.  X  Only syntactically correct mutants should be generated  X  Only fi rst-order mutants should be generated. 4.1 Mutation Operators Categories There are several elements of a CS that can be subject to faults. The de operator set takes the intrinsic characteristics of a UML CD-based CS into consider-ation, where some UML elements are composed by other elements. They are thus divided into seven categories: (1) constraint operators, (2) association operators, (3) generalization operators, (4) class operators, (5) attribute operators, (6) operation operators, and (7) parameters operators. Each element-based group is then sub clas-si fi ed according to the three defect types of UML models (i.e. unnecessary, wrong or missing) [ 9 ]. However, as our research focuses on de fi evaluating testing approaches, the inconsistent and ambiguity defects are not addressed in this work because they generate a faulty CS that is detected without requiring execution (i.e. testing is not required). The faulty CS is not detected by comparing the model against the requirements. Inconsistency defects are detected by comparing models to detect contradictions between them. Ambiguity defect are detected by the modeller which fi nds that the representation of a concept in the model is unclear. So that twenty-one categories are obtained, such as Unnecessary Constraint (UCO), Wrong Constraint (WCO), Missing Constraint (MCO), Unnecessary Association (UAS), Wrong Association (WAS); Missing Association (MAS) and so on. Based on the UML meta-model (see Fig. 1 ) and the defects and faults reported in the literature evaluating testing approaches:  X  Mutating Classes: The attributes isAbstract and visibility can be mutated.  X  Mutating Class Attributes (i.e. Class Variables): The visibility, isDerived, and data type of the variables can be mutated.  X  Mutating Operations: The visibility and returned value type when the operation isQuery can be changed. Additionally, swapping compatible parameters in the de fi nition of an operation can be another operation mutant.  X  Mutating Parameters: The data type can be mutated.  X  Mutating Associations: The visibility, isDerived can be mutated. Additionally, swapping the member of the Association, the kind aggregation and multiplicity for the members of the Association can be mutated.  X  Mutating Generalization: swapping the member of the Generalization.  X  Mutating Constraints: Changes the constraints by mutating operators (arithmetic, conditional, and negation), references to class attributes, references to operations. These categories and the main element features give rise to 50 mutation operators (see Table 4 in Appendix). Each of the 50 mutant operators is represented by a three-letter acronym of its category and a sequential number within its category if it is necessary. Some of these operators resulted in a CS that is determined to be faulty without (i.e. testing is required). Some of them generate FOM and others HOM. Since we only focus in FOM, 18 mutation operators (see the mutation operators marked with Table 4 ) that can generate FOM were obtained through two iterations, as follows (see Fig. 3 ).
 First iteration (Exclude Equivalent and Non-valid Mutants).
 mutation operator (see Table 4 ).
 non-valid mutant, which can be detected at parser level. For example, the mutation operator MAS causes an association in a CS to be deleted, however, the constraints related with this association must be deleted in order to generate a valid mutant, otherwise this mutant will be detected by the parser and cannot be used for a testing process. We analysed the mutation operators that always generate a non-valid or equivalent mutant. These results are included in Table 4 as a restriction in the operator rule. These mutation operators are described as follows:  X  Adding duplicated elements (i.e. UCO1, UAS1, UAS2, UGE1, UCL1, UCL2,  X  A closer inspection of equivalent mutants generated by the WOP2 mutation oper- X  Changing a navigable association to a shared aggregation or vice versa (WAS2)  X  Changing an Association Class to a Class with two associations or vice versa The following operators could generate both and equivalent and non-valid mutants:  X  Changing the visibility kind of an attribute (WAT4) generates both equivalent and  X  Changing a class abstract or vice versa (WCL4) when it does not result in a fault  X  Adding extraneous elements to CS (i.e. UCO2, UAS3, UAS4, UGE2, UCL3, UCL4, UAT2 and UOP2) generate equivalent mutants. Apparently, these operators did not inject a fault into a CS due to the nature of the test suite: only expected elements are tested. So, any additional element will remain untested. However, the operator that adds a Parameter to an Operation (UPA2) has to be considered because this affects a CS element (operation) that is tested by the test suite and so can be killed. These operators require a structural coverage analysis to be detected. Finally, the operator that changes the order of the parameters in an operation (WOP1) generates a defect of inconsistency between the signatures of the CS operations and the operation calls from test cases. This defect affects the testing process more than the CS work. All the excluded operators generate mutants that require a static (without exe-cution) technique for detecting.
 Second Iteration (Exclude High Order Mutants). We next analysed each derivation rule and identi fi ed the mutation operators that generate FOM and those that can gen-erate HOM (see in Table 4 the relations between operators). Needless to say, if no other nested elements exist, this mutation operator also generates a FOM. For example, applying an operator to delete an operation (MOP) which has no parameters or related constraints generates a FOM. According to the CEH, the HOM are coupled to simple mutants (FOM) in such a way that a test data set that detects all FOM will detect a high percentage of the HOM. The operators that generate HOM are the following: WCO2, MOP, WCL2, WCL3, WCL4, WAT1, WAT2, WAT3, WOP3, MCL, MGE, MOP and MAT. We added restrictions to several of these operators in order to generate only FOM. Table 4 shows the 18 operators that we used in this work (marked with which were obtained as products of the described iterations. Figure 4 shows a partial view of a CS in which fi ve mutation operators have been applied. Four operators will generate valid mutants and the MPA operator will generate a non-valid FOM because there is a class attribute (i.e. product_name) that is related with the parameter (p_atr-product_name), therefore more changes (i.e. HOM) are required so as not to be detected by the parser. This CS is used in the literature to explain the development of a requirements model [ 19 ] which is used for our test case generation approach. This CS is included in our analysis in Sect. 5 . The quality of mutants depends fi rst on how well they re make and second on whether they can be injected into a CS in such a way that they can be used for mutation testing. In order to analyse the effectiveness of the mutation operators, we used three conceptual schemas and respective test suites, which are described below. 5.1 Conceptual Schemas Under Test We applied our mutation operators to three CS under test (CSUT) to evaluate the effectiveness of our mutation operators. These CS represent three kinds of systems: (i) the Super Stationery system (SS), which makes use of classes with attributes and derived attributes, associations and constraints but has no generalizations, (ii) an Expense Report management system (ER) that uses fewer classes and relations but more constraints, and lastly, (iii) the Sudoku Game (SG) system [ 20 ], which is more variant-rich than the other two CS including generalization relations, derived associ-ations and aggregations. The size of each CSUT is shown in Table 2 in terms of model elements.
 5.2 Mutant Generation We developed a mutation tool prototype [ 21 ] to generate and analyse FOMs by applying the 18 selected mutation operators. This tool is divided into three distinct parts: (a) calculate a mutants list, (b) generate the mutants previously calculated; and, (c) performing a syntactic analysis of the mutants. Figure 5 shows the number of valid and non-valid mutants generated by each mutation operator and CSUT.
 The number of valid mutants produced by the WCO8 is the highest of the three CS (13, 21 and 47 respectively). Operators like UPA2, WCO1, WCO4, WCO5, WCO6, WCO7, WCO8, WCO9, WAS2, WCL1 and WOP2 generated only valid mutants for the CSUTs. However, the WCO7 and WCO9 operators generated only 1 mutant for the CSUT of the Sudoku Game system, giving a total 528 valid mutants (195, 159 and 174 respectively) and 495 non-valid mutants (171, 174, 150 respectively). 5.3 Mutation Testing Results three CSUT. Test suites used in this study include tests checking all the CS class operations and constraints. Finally the data resulting from applying mutation analysis to the CS were collected by applying the following measures.
 For a conceptual schema CS and test suite T, M T let the total number of non-equivalent mutants generated for CS and M K (T) be the number of mutants killed by T. Mutation score for a test suite (MS (T) = M K (T)/M in mutation to measure the test suite effectiveness to kill mutants generated by applying all mutation operators. Where, non-equivalent mutants (M T the surviving mutants. The following measures, re fl ecting basic characteristics of mutation operators, were de fi ned to evaluate the usefulness of the mutation operators [ 18 ]. Table 3 summarizes results of these calculations.
  X  Contribution Factor of mutation operator MO (CF (MO) = M  X  Mutation Score of a mutation operator MO (MS (MO, T) = M  X  Impact Indicator of a mutation operator MO (II (MO, T) = MS (T)-((M For the SS, we ran 62 test cases. These test cases were executed against 206 mutated CS created by the mutation operators, killing 82 % of the mutants. In the case of the ER, we executed 88 test cases against 174 mutants created, killing 90 % of the mutants. For the case of the SG, we executed 90 test cases against 185 mutants, killing 74 %. Therefore 89 % of the mutation operators (16/18 operators) generate mutants that can detected by the test suites. More detailed information on the mutation results can be found at https://staq.dsic.upv.es/webstaq/mutuml/mutation_operators.htm . 5.4 Discussion The results in Table 3 show that the behaviour of the mutation operators may depend on some characteristics of the CS they are applied to (such as complexity of constraints, the number and type of elements included in the CS). However, the results suggest that some of these operators UPA2, WCO7, WCO9, WAS1, WCL1, WOP2, WPA, MCO, MAS, and MPA generated mutants that were relatively easy to detect by the provided test suites (the test suites had mutation scores of 100 %). Moreover, all the operators had a  X  positive  X  impact (column value II &gt; 0) in the test suite assessment results. This means that the test suite quality is overestimated when any of these operators is not used. An underestimation of test quality, especially when the test suite is under development, would force an improvement of the test suite, while its overestimation could compromise the quality of any testing performed by them. The mutation oper-ators WCO1, WCO3, WCO4, WCO5, WCO6, WCO8, WAS2 and WAS3 all having a low mutation score, should always be applied because they generate hard to detect mutants and their application would stimulate selection of high quality tests. WAS2 and WAS3 mutation operators suggest that there is a lack of use (test) in the test suite of the CS elements affected by these operators.
 Despite the mutation operator restrictions, all these mutation operators generated mutants in one or other of the three CS, these restrictions ensure that the mutants generated meet the condition  X  mutant has to be syntactically correct for mutation mutation testing is computationally expensive, so it is important to use a technique that reduces the computational cost, the restrictions included in the mutation operator rules avoid generating non-valid mutants (495 in total in the three CS), which has practical bene fi ts in the time saved in the mutation testing process. Additionally, the CEH states that complex (or higher-order) mutants are coupled to simple mutants (FOM) in such a way that a test data set that detects all FOM will detect a high percentage of the HOM. Mutation Testing has been widely studied since it was fi rst proposed in the 1970s by Hamlet [ 22 ] and DeMillo et al. [ 13 ]. In 2010, Jia and Harman [ 5 ] made a good survey of mutation techniques and also created a repository containing many interesting papers on mutation testing (last updated in 2014). This survey stated that mutation testing is mainly applied at the software implementation level (i.e. more than 50 % of survey State Machines [ 23 ], State Charts [ 24 ] and Activity Diagrams [ 25 ]. As far as we know, the idea of applying mutation testing to modify a UML CD-based CS and to assess the quality of test cases by checking how well they detect faults injected into a CS has not been explored to date in practice. However, some In the former [ 26 ], the author introduces nine mutation operators to apply manual mutations to the test suite provided for a UML/OCL-based design model instead of modifying the model, which is a different approach to that used in the present paper. In the latter [ 18 ], the author presents a classi fi cation of 16 mutation operators de constraints speci fi ed in OCL and used in UML/OCL-based design models. Constraints are among the CS elements covered by our approach. Dinh-Trong et al. [ 17 ] describe a set of mutation operators for a UML class diagram but do not include the restriction on generating valid mutants. Finally, Derezinska introduced a set of mutation operators which can be applied to the UML CD speci fi cation but which are evaluated at the code level (C ++) [ 16 ].
 work [ 9 ]. We also adapted some mutation operators proposed by Derezinska [ 16 ], Dinh-Trong et al. [ 17 ] and some operators for OCL constraints proposed by Strug [ 18 ]. Finally, in our approach the faults introduced include restrictions on generating only valid mutants for detecting in the CS at the analysis and design phases. This differs from current conventional mutation, in which the faults are introduced and detected at the code level. Mutation testing applied at the CS level can improve early development of high quality test suites (e.g. elements coverage) and can contribute to developing high quality systems (i.e. it meets requirements) especially in a model-driven context. In this paper we describe a mutation-testing based approach for UML CD-based CS level and report our recent work: (1) classifying a set initial of 50 mutation operators in the context of Conceptual Schemas based on a UML class diagram; (2) selecting and applying 18 mutation operators for FOM to evaluate the usefulness of the mutation operators in three CS. The main potential advantage of the de fi ned mutation operators is that can support a well-de fi ned, fault-injection process.
 ment characteristics of a UML CD-based CS and although some of the proposed operators perform syntactic changes at the constraints level, they are mainly focused (i.e. 41 of 50 operators) on the semantic changes of the high-level CD constructs. Our mutation operators are classi fi ed according to the element affected by the operator, injected defect type, and the action required by the mutation operator to generate valid mutants (syntactically correct). Since our purpose is to select mutation operators to be used to evaluate testing approaches, the selection process of mutation operators was they generated only equivalent mutants (e.g. UCO2, UAS3, UAS4) and non-valid mutants, (e.g. WCL4, UCO1, UAS1), which require a static technique (without CS execution) for detecting (e.g. syntax analysis or structural coverage analysis), and so are not useful for mutation testing. In the second iteration, we aimed to analyse the dependencies between different operators and to reduce the cost of applying mutation testing by selecting 18 mutation operators that generate only on the results obtained by applying the mutation testing, 56% (10/18) of our mutant operators generated a high number of killed mutants (score mutation = 100%). These results suggest that these operators generated mutants that are relatively easy to detect by the provided test suites. In the other case 44% (8/18) of the operators related to characteristics of associations (i.e. multiplicity and aggregation type) and constraints generated hard to detect mutants and their application would stimulate selection of high quality tests. However, the behaviour of the mutation operators may depend on the characteristics of the CS they are applied to, such as the number, element type and complexity of constraints.
 This study is a part of a more extensive research project, whose principal goal is to propose an approach for testing-based conceptual schema validation in a Model-Driven Environment. Future work will proceed to extend the test suite for stimulating the disabled behaviour detected in this mutation analysis. We hope to evaluate the use of HOMs and compare them with FOMs. Finally, the proposed mutation analysis will be performed on a signi fi cant number of CS.

