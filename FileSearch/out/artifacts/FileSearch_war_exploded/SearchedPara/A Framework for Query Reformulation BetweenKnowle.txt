 The problem of sharing data in peer-to-peer environment has received consid-erable attention in recent years. Two basic problems in the peer-based integra-tion system are: how to discover, express, and compose the mappings between peers [1, 2, 3], and how to exploit the mappings in order to answer queries posed to one peer [4, 5]. In [6], Tatarinov et al. develop techniques for pruning paths in the reformulation process and for minimizing the reformulated queries as they are created.

However, knowledge sharing in peer architectures has received very little at-tention. In [7], Calvanese considers t he problem of ontology-based query re-formulation between knowledge base peers. Based on the peer architecture, he proposes an algorithm, called computeWAT, to answer queries posed to the local peer by relying only on the two query answering services available at the peers. In [8], Mork adopts a description logic formalism to describe the transforma-tions between peers for knowledge sharing. He establishes a set of rules to build a hierarchy H . Based on H , the axiomatic and full reformulation algorithms are proposed. However, if a predicate can be unified with more than one node in H , neither axiomatic nor full reformulation algorithms can deal with it.
Based on the works in [7, 8], we propose a framework for query reformulation between knowledge base peers. We consider a mapping language based on a particular description logic that includes class connectors. Then we establish a set of rules to build graphs, which are classified into four sets. Based on them, our algorithms can handle the situation that a predicate is unified with more than one node in the graphs. The main contributions of this paper are as follows.  X  This paper establishes a set of rules to build graphs. Based on the rules, this  X  Based on the graph, this paper proposes the basic and extending reformula-
The paper is organized as follows. Section 2 presents the description logical formalism of knowledge base peers. Section 3 describes our query reformulation algorithms. We do extensive simulation and present the representative experi-mental results in section 4. Section 5 discusses related work. Section 6 concludes. Each knowledge-based peer contains a knowledge base K ,whichcomprisestwo components: a TBox and an ABox [9]. The peer exports a suitable schema S of K to the agents willing to use the peer, here called clients . Clients can ask to the peer only queries that are accepted by the peer. The peer answers such queries by exploiting inference from its knowledge base K . Apart from using its knowledge base K , each peer can be connected with other knowledge-based peers which can answer its queries accepted by them. Suitable mappings between the peers give the means to interpret the answers to queries posed to the remote peer. A knowledge-based peer system is formed by many peers sharing the domain of interpretation and the set of standard names.
 Definition 1. A knowledge base peer is a tuple of the form K P = &lt; K ,S,M &gt; where K is a knowledge base written in description logic (we do not consider functions in this paper); S is the schema which is the exported fragment of K , further S = &lt; C,P,A T ,C T &gt; where C is a set of classes, P is a set of properties, A
T is a set of logical axioms, C T is a set of class connectors and the set C is called S  X  X  terminology; M is a set of mapping assertions between peers.
Subclass axiom is used to explicitly construct class hierarchy. Components constraints, which include the first component (FCom) and the second compo-nent (SCom) axioms, are used in restrict ways in which the class is the first or second component of property. So component axiom includes FCom and SCom axioms. The only number restriction we consider is minimum cardinality (or mandatory participation), which asserts that every instance of a given class has a value for the indicated property. The participation includes the first par-ticipation component which is denoted by FPart and the second participation component which is denoted by SPart. So participation axiom includes FPart and SPart axioms. And we support disjoint axioms, which are used to indicate that two classes have no resources in common. We describe the restrictions these axioms place on an interpretation in table 1. In addition to atomic classes, we can define complex classes using class connectors based on set operations. These connectors place additional restrictio ns on which interpretations are valid as described in table 2.
 Definition 2. If A ( x )= B 1 ( x )  X  ...  X  B n ( x ), we call predicate A a conjunc-tive predicate. If A ( x )= B 1 ( x )  X  ...  X  B n ( x ), we call predicate A a disjunctive predicate.

We coordinate the schemata using mappings that provide additional axioms for logical mediation. In the spirit of Bernstein [10], a mapping is a schema extended to include a set of equivalences that relate the terminologies in S and T to the terminologies in M .
 Definition 3. A mapping M : S  X  T that relates S and T isaschema( &lt; C, P, A T ,C T &gt; ) augmented with two functions E P :( S.P  X  T .P )  X  M.P and E
C :( S.C M :  X  &lt;Q,R&gt;  X  E P : I ( Q )= I ( R )and  X  &lt;A,B&gt;  X  E C : I ( A )= I ( B ).
Furthermore, Mork [8] gives the definition of valid and minimal rewritings as follows.
 Definition 4. Given M : S  X  T ,aquery Q T (posed against T ) is a valid rewriting of Q S (posed against S ) if and only if the following two conditions hold: 1) I ( Q T )  X  I ( Q S ) for all valid interpretations of S , T ,and M . 2) The predicates appearing in the body of Q T are all equivalent to some predicate appearing in T  X  X  terminology.
 Definition 5. A minimal rewriting Q T is a valid rewriting of Q S such that whenever any predicate in the body Q T is removed, the result is not a valid rewriting of Q S . 3.1 Graph Generation Algorithm For any two peers S and T , there is a mapping M related to them. Before reformulating any queries between them , our graph generation algorithm (GGA) builds a graph according to the axioms in M , S and T . We call the graph building by the GGA algorithm the GGA graph, in which each node represents an atom. And each atom consists of a predicate (appearing in the mapping X  X  terminology) and an ordered list of arguments. These arguments can include variables (such as x ), wildcards (indicated using ), and constants (drawn from the universal resource namespace). We build the GGA graph using the following rules. Rule 1. If I ( A 1 )  X  I ( A )and A is an unary predicate, we have 1) A ( x )isthe parent node of A 1 ( x )if A 1 is an unary predicate; 2) A ( x ) is the parent node of A 1 ( x, )or A 1 ( ,x )if A 1 is a binary predicate. If A is a binary predicate, we have 1) A ( x, )or A ( ,x ) is the parent node of A 1 ( x )if A 1 is an unary predicate; 2) A ( x, )or A ( ,x ) is the parent node of A 1 ( x, )or A 1 ( ,x )if A 1 is a binary predicate.

From rule 1, the axioms in table 1 and table 2 can form the following graphs: 1) For each axiom B  X  C ,make C ( x ) a parent node of B ( x ); 2) For each axiom F Co m ( P )= C ,make C ( x ) a parent node of P ( x, ); 3) For each axiom SCo m ( P )= C ,make C ( x ) a parent node of P ( ,x ); 4) For each axiom M inCard F ( C, P ), make P ( x, ) a parent node of C ( x ); 5) For each axiom M inCard S ( C, P ), make P ( ,x ) a parent node of C ( x ); 6) If C = C 1  X  C 2  X  ...  X  C n and for any two predicates C i and C j , which have Dis j oint ( C i ,C j ), make each C i ( x ) a parent node of C ( x ); 7) If C = C 1  X  C 2  X  ...  X  C n and for any two predicates C i and C j , which have Dis j oint ( C i ,C j ), make C ( x ) a parent node of each C i ( x ).
Because the Subclass, FCom and SCom axioms have association, they form a set. And we call them SFS axioms. When we build the graph, we sort the SFS axioms in a topological order. Then those axioms generate the Ugraph, because their parent nodes are unary predicates. The rule for topologically sorting the SFS axioms is as follows.
 Rule 2. If a predicate A is in the front of a predicate B , one of the following two cases happens: 1) If they have association, the leaf node of predicate A is the parent node of predicate B ; 2) They have no association.

The disjunctive axioms in a knowledge base may have association. When we build the graph, we sort them in a topological order. Then those axioms generate a Dgraph, which come from disjunctive axioms. The rule for topologically sorting disjunctive axioms is as follows. Rule 3. If a disjunctive predicate A is in the front of a disjunctive predicate B , one of the following two cases happens: 1) If they have association, one of leaf node of disjunctive predicate A is the parent node of disjunctive predicate B ;2) They have no association.

Algorithm 1. GraphGenerationAlg(Axioms A s ,Graph G ,ClassC,Prop-erty P)
For each FPart or SPart axiom, the GGA algorithm generates an independent subgraph in Bgraph, whose parent node is binary predicate. For each conjunctive axiom, the GGA algorithm generates an independent subgraph in Cgraph, which comes from conjunctive predicate. For each class C  X  M.C ,ifitcannotbe unified with any node in the Ugraph, an independent node C ( x ) is added into the Ugraph. For each property P  X  M.P , if it can not be unified with any node in the Bgraph, an independent node P ( x, y ) is added into the Bgraph. Our graph generation algorithm is as shown in algorithm 1 3.2 Basic Reformulation Algorithm From the GGA algorithm, we know C ( x ) is the parent node of P ( x, )and P ( ,x ) in FCom and SCom axioms respectively. So the binary predicates only appear Algorithm 2. BasicQueryReformulation(Query Q, Graph G, Schema T) Algorithm 3. BasicAtomReformulation(Atom A, Graph G, Schema T) in the leaf nodes of the Ugraph. And we know P ( x, )or P ( ,x )isaparentof C ( x ) in the SPart or FPart axiom, the unary predicates only appear in the leaf nodes of the Bgraph. Because the atom of a leaf node can not be reformulated by the atoms of other nodes, the binary predicate need not unify with any node in the Ugraph. For the same reason, the unary predicate need not unify with any node in the Bgraph.
 Given a target schema T and a query Q , we consider each atom of Q in turn. For each atom, we find the corresponding nodes in the graph based on unification. An atom A unifies with a node N if they refer to the same predicate, and there exists a function f from the constants and variables in A s argument list to the variables in N s argument list. We define H N to be the subgraph in the Ugraph rooted at N ; H N contains N and all of N s descendants. Let n be a node in H
N .If n s predicate is an element of T s terminology, then f ( n ) is a rewriting of A : replace each variable in n s argument list with the corresponding constant or variable from A .
 At this point, we have a collection of partial rewritings, one for each atom. The final result is the cross-product of these partial rewritings, which is the function of ConjunctionAlgorithm(). The basic reformulation algorithm (BRA) is summarized in algorithm 2. The basic rule in the BRA algorithm is as follows. Rule 4. If a predicate A is conjunctive with a constant c, the result is the predicate. That is, A  X  c = A .
 Example 3.1. Consider the schemata in figure 1. Schema S contains three classes and two properties. Moreover, S asserts that the first component of S D is S B .Schema T contains one class and one property (and no axioms).
Let M be a mapping that asserts that S D is equivalent to T D (i.e., they are both equivalent to M D ) as proposed in [10]. This mapping also asserts that the first participation of M E , with respect to M F is 1. So TBox contains axioms F Co m ( S D )= S B and M inCard F ( M F ,M E ) = 1. Thus the GGA algorithm builds the graph as shown in figure 2 and figure 3.

Now, consider the query Q S ( x )  X  S B ( x ) ,S E ( x, ). In figure 2, the unifi-cation node of atom S B ( x )is M B ( x ), whose descendant node is M D ( ,x ) because of the FCom axiom in TBox. In figure 3, the unification node of atom S E ( x, )is M E ( x, ), whose descendant node is M F ( x ) because of the FPart axiom in TBox. From the BRA algorithm, a valid rewriting for Q S is Q T ( x )  X  T D ( ,x ) , T F ( x ). 3.3 Extending Reformulation Algorithm From the GGA algorithm, we know the conjunctive predicate only appears in the leaf node of the Cgraph. And in the subgraphs of the Dgraph, each leaf node is unified with a basic predicate. The extending reformulation algorithm (ERA) is shown in algorithm 4. Given a target schema T and a query Q , we consider each atom of Q in turn. For each conjunctive predicate, the ERA algorithm unifies it with the leaf node of each subgraph in the Cgraph. If an atom A ( x ) can unify anode N , the reformulation of A ( x ) is the cross-product of all elements of N  X  X  parent nodes. For each disjunctive predicate, the ERA algorithm unifies it with the non-leaf nodes of each subgraph in the Dgraph. If an atom B ( x ) can unify anode N , each descendent node is a valid reformulation of the atom B ( x ). For each basic predicate, the ERA algorithm unifies it with the leaf nodes of each subgraph in the Dgraph. In each subgraph, at most a node can be unified with it. If it can be unified with more than one node, its reformulation results are the cross-product of the predicates in different subgraphs.
 Example 3.2. Consider the schemata in figure 4. Schema S contains one con-cept. Schema T contains two concepts. The TBox includes three axioms: M AC = M A  X  M C , M C E = M C  X  M E and Dis j oint ( M A, M E ). Based on the GGA algorithm, we build the Dgraph as shown in figure 5 and figure 6.
Now, consider the query Q S ( x )  X  S C ( x ), neither T B nor T D can be used to answer the original query. However, from ERA algorithm, atom S C ( x ) can unify with two nodes in figure 5 and figure 6. In figure 5 the unification node of atom S C ( x )is M C ( x ), whose ascendent node is M AC ( x ). In fig-Algorithm 4. ExtendingQueryReformulation(Query Q, Graph G, Schema T) ure 6 the unification node of atom S C ( x )is M C ( x ), whose ascendent node is M C E ( x ). Thus, a valid rewriting for Q S is Q T ( x )  X  T B ( x ) , T D ( x )bythe ERA algorithm. 3.4 Discussion on the Proposed Algorithm In this paper, we propose a graph generation algorithm. Based on it, we pro-poses basic and extending reformulation algorithms, which rewrite each atom of Q
S independently. For each atom, the two algorithms search the corresponding subgraphs to find the unification node.
 Lemma. The GGA graph generated by the proposed algorithm is acycle.
 Proof. From the GGA algorithm, four kinds of subgraphs are generated. They are the Ugraph, Bgraph, Dgraph and Cgraph. Because each subgraph of the Bgraph and Cgraph is built by an axiom, there is no cycle in them.

Because binary predicates only appear in the leaf nodes, FCom and SCom axioms can not cause any cycle in the Ugraph. We assume that Subclass axioms cause a cycle ( A  X  X  X  B and B  X  X  X  A ) in the Ugraph. Because of A  X  X  X  B ,we have B  X  A from the rules. Because of B  X  X  X  A ,wehave A  X  B . However, because A  X  B and B  X  A , A is the same class as B. So the two nodes in the graph merge. Thus there is no cycle in the Ugraph.

We assume that disjunctive axioms cause a cycle ( A  X  X  X  B and B  X  X  X  A )in the Dgraph. Because of A  X  X  X  B ,wehave A = B  X  B 1 ...  X  B n from the rules. Algorithm 5. ExtendingAtomReformulation(Atom A, Graph G, Schema T) Then we have B  X  A . Because of B  X  X  X  A ,wehave B = A  X  A 1 ...  X  A n .Then we get A  X  B . However, B  X  A and A  X  B is impossible. So there is no cycle in the Dgraph. Thus the theorem follows.
 Theorem 1. Let S and T be schemata and let M : S  X  T be a mapping . Let Q
S be a conjunctive query expressed against S . The extending reformulation algorithm terminates.
 Proof. First, there are finite axioms in Q S . Second, each axiom in S has map-pings with finite axioms in T . Finally, there are no cycle in the GGA graph. So the extending reformulation algorithm terminates. Thus, the theorem follows. Theorem 2. Let S and T be schemata and let M : S  X  T be a mapping. Let Q S be a conjunctive query expressed against S .Let Q T be a minimal rewriting of Q
S expressed against T . After applying the extending reformulation algorithm to Q S , the output of the extending reformulation algorithm will contain Q T . Proof. Assume that Q T is a minimal rewriting of Q S not generated by the extending reformulation algorithm. Because Q S is a conjunctive query, for each atom A S  X  Q S ,thereexistssome q T  X  Q T which is satisfied with q T  X  A S . And each atom in Q T must be unified with a node in the graph. Otherwise Q T would not be a valid rewriting. We must now show that q T is generated by the ERA algorithm. There are the following three cases:
First, if q T is unified with an independent node in the graph, it is identified by the basic reformulation algorithm.

Second, if q T is unified with a node below A S in the graph, there are the following two cases: 1) If the graph is built by the axioms in the table 1, q T is identified by the basic reformulation algorithm. 2) If the graph is built by disjunctive axioms, q T is identified by the extending reformulation algorithm. In those cases, q T must only contain a single atom, or the minimal condition is violated.

Finally, if q T is the conjunctive of some predicates, there are the following two cases: 1) If A S is a conjunctive predicate, q T is the cross-product of all elements in G  X  &gt;parent ( A S ). 2) If A S is a basic predicate and it is unified with more than one node B i in the Dgraph, q T is the cross-product of the predicates in G  X  &gt;parent ( B reformulation algorithm.
 So for any q T  X  A S , the extending reformulation algorithm can generate q T . The assumption is wrong. Thus the theorem follows.

In [8], Mork gives a set of rules to build a hierarchy H . Based on it, he proposes the axiomatic and full reformulation algorithms to reformulate ontology-based conjunctive queries. And he gives the similar theorem as theorem 2. However, he only proves the first two cases in our theorem 2. Our knowledge base architecture is made up of two peers. They are related to university ontology. One is based on [11], the other is ours. Based on the peer ar-chitecture, we do extensive simulation experiments comparing the reformulation efficiency of the proposed algorithms with Mork X  X . The simulation system was tested on a Windows XP Pentium 4 PC running at 2.8 GHz with 1G of memory. During the experiments, we classify our BRA algorithm and Mork X  X  axiomatic reformulation algorithm into the same set, which is called basic set and denoted by BSet. We classify our ERA algorithm and Mork X  X  full reformulation algorithm into the same set, which is called extending set and denoted by ESet.
The simulation results are shown in Figure 7, from which we know the pro-posed algorithms have better performance than those of Mork X  X  for two reasons. First, for any atom A ( x ) in a conjunctive query, our BRA algorithm does as follows. The binary predicate is only unified with the nodes in the Bgraph, and the unary predicate is only unified with the nodes in the Ugraph. However, for any atom A ( x ), the axiomatic algorithm searches the whole hierarchy to find the unification node. So our BRA algorithm has better performance than that of axiomatic reformulation algorithm. Second, the algorithms in BSet are based on the algorithms in ESet. For each conjunctive predicate, the ERA algorithm unifies it with the leaf nodes of each subgraph in the Cgraph. For each disjunctive predicate, the ERA algorithm unifies it with the non-leaf nodes of each subgraph in the Dgraph. For each basic predicate, the ERA algorithm unifies it with the leaf nodes of each subgraph in the Dgraph. However, the full reformulation algo-rithm also searches the whole hierarchy to find the unification node. So our ERA algorithm has better performance than that of full reformulation algorithm. In [12], Calvanese addresses the fundamental problem of how to specify the map-ping between the global ontology and the local ontologies. He argues that for capturing such mapping in an appropriate way, the notion of query is a crucial one, since it is very likely that a concept in one ontology corresponds to a view over the other ontologies. As a result query processing in ontology integration systems is strongly related to view-base d query answering in data integration. In [13], information integration over ontology-based information sources is ob-tained through a mediator comprising an ontology and a set of articulations to the information sources. Information queries are addressed to the mediator whose task is to analyze each query into sub-queries, translate them into queries to appropriate sources, then merge the results to answer the original query.
Based on the peer-based knowledge system, Calvanese [7] investigates how to solve the so-called  X  X hat-To-Ask X  problem. And he shows that a solution to this problem exists in the case of peers based on a basic ontology language and provide an algorithm to compute it. In [8], Mork considers a mapping language based on a particular description logic that includes class constructors. Then he proposes a rule system to build hierarchy H . Based on it, he proposes axiomatic and full reformulation algorithms. However, the two algorithms search the whole hierarchy H to find the unification node. Furthermore, his algorithms can not deal with that a predicate can be unified with more than one node in H .
In this paper, we propose a graph generation algorithm, which classifies the graph into four sets. For the conjunctive queries, we propose the basic and ex-tending reformulation algorithms. For each atom, our algorithms only search the corresponding subgraphs to find the unification nodes. And our ERA algorithm can solve the problem that Mork X  X  algorithms meet. This paper researches on query reformulation between knowledge base peers. In this paper, we first consider a mapping language based on a particular description logic that includes class connectors. Then we propose a set of rules for building graphs. Because the axioms in a knowledge base have different properties, our graph generation algorithm classifies the generated graphs into four sets. For each kind of atom, our algorithms find the corresponding nodes in the subgraphs based on unification and reformulate it in a special way.

In the future, we will extend our research work to disjunctive queries. Also, we will study query answering in the case where the knowledge bases at the peers are mutually inconsistent, since this is of relevance in real domains. Acknowledgements. This work is supported by National Natural Science Foundation of China under Grant No. 60503038, 60473069, 60496325 and 60573092.

