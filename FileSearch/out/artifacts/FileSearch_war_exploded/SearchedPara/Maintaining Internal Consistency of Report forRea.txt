 Real-time data warehouses have been receivi ng more and more attention (e.g. [1, 2, 3, 4, 5, 6]) during the past few years, which is updated in as close to real time as possible [7]. However, OLAP and Query tools were initially designed to operate on top of static data, and they do not ensure that the data involve d is protected from being modified. There-fore, the report result may be negatively influenced by the underlying changing data. In real-time data warehouse environment, this can lead to inconsistent and confusing query results, which is called internal inconsistency of report [8].

Take the simple report in Fig. 1 for example. It includes a multi-pass SQL statement made up of many smaller SQL statements. All these SQL statements will sequentially operate on a set of temporary tables. There will be no problem when the data is static, but it is not the case when the underlying data changes while the first temp table is being created. Most database systems (including multi-version databases [9]) will return the data that was current at the point that the query started to run [8]. At 0:01, the INSERT statement into TEMP1 started to run and lasted for four seconds. Then the query to load data into TEMP2 began to run at second 6. This means that TEMP1 will contain data current as of 0:01, but for TEMP2, it will contain data current as of 0:06. Suppose that during those five seconds, a few large sales were registered, they will be included in the total dollar amount contained in TEMP2, but won X  X  be represented in the category-level data that is in TEMP1. So, when the data is brought together in the final SELECT statement, the total in TEMP2 will be larger than the sum of the categories in TEMP1, and then the total percentage number will be less than 100%. Obviously, this will lead to an incorrect report.

Multi-version database is a desirable approach to ensuring read consistency. How-ever, read consistency in multi-version database is only achieved on the level of single-pass SQL statement [9], which means that it can not be used to deal with the internal consistency of report that contains multi-pass SQL statement made up of many smaller SQL statements (see Fig.1). Moreover, mu lti-version database is not good at dealing with the query contention issue resulting from the real-time update and query. Tempo-ral model (e.g. [10]) is another one of the methods that can be used to solve the report inconsistency issue. However, keeping temporal data warehouses up-to-date is com-plex [11], and in some cases, the data warehouse may even become blocked due to the query contention issue resulting from performing queries on changing data.

We here propose a new layer-based view approach for appropriately and effectively maintaining report X  X  internal consistency, and at the same time avoiding query con-tention issue which is a hard work for other available methods. The concepts of layer, view and lock are introduced to effectively control read and write operations upon fact tables. The core idea is that, all the data involved in an OLAP query is read-locked and is not allowed to be updated until the query finishes its reading job, so as to maintain the internal consistency of report. When the data is read-locked, if there is confliction between read and write operations on certain layer, the write operation will be redi-rected to another layer to continue its work so as to avoid waiting time and maintain the consistency as well. To achieve this target, we will present in detail the mechanisms for layer generating and deleting, view gene rating and deleting, and lock applying and confliction resolving. Also the algorithm and an example of our approach will be given here. Compared with the other available methods, the advantage of our method is the avoiding of confliction between read and write operations upon fact tables, which means that there will be no waiting time any more and therefore desirable system performance can be achieved. Also, our method can be easily used in memory database. Unlike most of the multi-version databases, in which multi-version method is deeply integrated with the database systems, our method is completely independent of the type of database, which means that it can be used together with any database product.

The remainder of this paper is organized as follows: Section 2 gives the detailed description of layer-based view approach. Then we present experimental results in Sec-tion 3, followed by the discussion of the related work (Section 4). Finally, we give the discussion and conclusion in Section 5. In this section, the frequently used concepts will be defined first, followed by the de-scription of the mechanisms of our approach in detail. Finally, we will give the algo-rithm and an example of our approach. 2.1 Term and Definition Definition 1. Layer: A layer, denoted by  X  , is a table to store a set of records { r 0 ,r 1 , ... ,r n layers  X  A and  X  B ,  X  B is generated from  X  A ,wesay  X  B is the child of  X  A ,whichis denoted by  X  B  X  A , and  X  A is the parent of  X  B , which is denoted by  X  A  X   X  B . In real-time data cache, every fact table i s corresponded to one root layer. Every non-root layer, which is initially an empty table without any data when generated, has the same table structure as its parent layer.
 Definition 2. View: Let L = {  X  0 , X  1 , ... , X  m  X  1 } be a set of layers, and R = { r 0 ,r 1 , ... ,r n  X  1 } be a set of records, where r i  X   X  j , 0  X  i  X  n  X  1 and 0  X  j  X  m  X  1 .  X  ( v p )= r q , 0  X  p  X  n  X  1 and 0  X  q  X  n  X  1 .Herewesay  X  is composed of  X  0 , X  1 , ... , X  n  X  1 , and  X  j is a composing layer of  X  .
 A view defines the mapping between every record of itself and the records of its com-posing layers, from which OLAP tools get to know where the required data actually locate. There may be many views in the system, but the only view that can be seen by newly arrived OLAP queries is the  X  current view  X , which is denoted by  X  current .Af-ter OLAP queries get  X  current , they will use it during the whole reading process, even though the  X  X urrent view X  now may become  X  X ld view X  in the future. Definition 3. Area: Let R = { r 0 ,r 1 , ... ,r n } be the set of records that a layer  X  (or a view  X  ) contains. An area, denoted by  X  , is a subset of R .Herewesaythearea  X  is in the layer  X  (or in the view  X  ), which is denoted by  X   X   X  (or  X   X   X  ). Suppose there are  X ,  X  0 , X  1 , ... , X  n  X  1 ,where  X   X   X  ,  X  i  X   X  j , 0  X  i  X  n  X  1 , 0  X  j  X  m  X  1 and m is the number of layers. If, by the function  X  of  X  , the records in  X  are mapped to composing area of  X  .
 In order to better understand the concepts of layer, area and view, we give an exam-ple in Fig.2. As can be seen in Fig.2, View1 is composed of three layers, i.e. Layer1, Layer2 and Layer3. The three records in V iew1, which are what OLAP tools can see, are actually located in the three different layers. This is similar to the layer technology used in painting software (e.g. PhotoShop), where a photo is composed of many layers, and what we can see is the result of combining the objects in different layers together. This also explains why a table is called a layer in our paper. In Fig.2, there are four areas, where Area1  X  Layer1, Area2  X  Layer2, Area3  X  Layer3 and Area4  X  View1. Area1 contains one record, Ar ea2 contains three records, Area3 contains two records and Area4 contains three records.
 Definition 4. Lock: Alock  X  is used to lock certain area  X  so as to control the read and write operations upon  X  ,where  X   X   X  or  X   X   X  .  X  on (  X  ) and  X  of f (  X  ) mean placing locks on and removing locks from  X  respectively.
 Lock includes  X  read lock  X  X nd X  write lock  X  (see Table 1), and read lock has higher pri-ority than write lock. The former is assigned by system to the OLAP tools to protect the target area being read from being updated, and the latter is used to inform the other operations that the target area is being updated by write operation, or else it will proba-bly lead to the occurrence of inconsistency. Table 2 gives the compatibility relationship between read lock and write lock. Also a lo ck can be a virtual lock or an actual lock. A virtual lock is put on an area in a view, while the target object of an actual lock is an area in a layer. 2.2 Lock Mechanism Lock mechanism is responsible for the jobs such as lock applying, lock translating and lock confliction resolving, so as to effectively control the read and write operations upon the changing data to maintain the internal consistency of report.
 Lock applying. Only virtual lock can be applied by OLAP tools and data loading and updating tools, for what these tools can see in the first place are views instead of layers.  X  Read lock applying . The purpose of read lock is to declare the  X  X ccupation X  of  X  Write lock applying . Write lock is used by updating operation to express the in-Definition 5. Lock transforming: Suppose  X  is composed of  X  0 , X  1 , ... , X  n  X  1 ,where  X   X   X  ,  X  i  X   X  j , 0  X  i  X  n  X  1 , 0  X  j  X  m  X  1 and m is the number of layers. Lock transforming is the process of transforming the virtual lock on  X  into actual locks on  X  A view is composed of one or more layers, and therefore there is a need to transform the lock on it into one or more locks on layers. The following is an example to explain the transformation mechanism between virtual lock and actual lock.

In Fig. 3, View1 is composed of three layers, i.e. Layer1, Layer2 and Layer3. While what OLAP tools can see is View1, with the help of view definition, they will finally be  X  X uided X  to the three layers where the data actually locate. This also takes place for write operations. Now suppose that Lock0 is imposed on View1, which can be either a read lock or a write lock. Through the ana lysis of view definition, Lock0 is finally translated into three locks with Lock1 on the second record of Layer1, Lock2 on the first record of Layer2 and Lock3 on the third record of Layer3.
 Definition 6. Lock confliction If, according to the lock compatibility matrix in Table 2, two locks  X  on (  X  ) and  X  on (  X  ) are incompatible, we say that there is lock conflic-tion on  X  .
 Whenever there is lock confliction on  X  (  X   X   X  ), the write operation has to be redirected to another layer  X  child , which is a child layer of  X  .If  X  child does not exist, it will be generated automatically by system through the mechanism of layer generating. This process is called lock confliction resolving , during which, one important aspect is to maintain the transactional consiste ncy of the undergoing write operation. 2.3 Layer and View Mechanism Layer generating: The layer generating process is act ivated whenever the write oper-ation needs to be completed in another layer due to the lock confliction, and at the same time there is not one layer available for it. The newly generated layer has the same table structure as its parent layer, but is initially empty.
 Layer merging and deleting: In order to achieve better system performance, there is also a need to merge and delete layers under certain condition. Whenever the preset threshold is met, the layer merging process begins.
 View generating: Whenever there is updating again st the definition of a view, a new view containing the newest definition will be generated above the old one with the latter unchanged, and then the new view becomes  X  current . The reason for the generation of a new view when the definition of the current view is changed, is out of the consideration of avoiding the confliction between the read operation of OLAP tools and the write operation of updating against  X  current .
 View deleting: The process of view deleting begins when certain view is no longer used by OLAP tools, or it will lead to the depletion of system resources, because new views are generated constantly along the time. Sometimes the deleting process of views is also accompanied with the merging of layers. 2.4 The Algorithm for Layer-Based View Approach Based on the mechanisms described above, we can now implement the layer-based view approach. Fig. 4 shows the main algorithm for this method. The 5th and 12th lines are executed concurrently instead of sequentially with the help of multi-thread technology. In other words, the read process and the confliction resolving process go at the same time. And for every layer, the confliction resol ving process can also execute concurrently. The read operation will read the right now available data first so as to avoid the waiting time, and then read the previously write-locked but currently available data. Even though the transactional updating has to be assured to be finished when the undergoing write operation needs to be redirected to another layer during the confliction resolving process, the overall waiting time of read operation is still very little and usually can be neglected due to the adoption of mu lti-thread technology as is described above.

In the 7th line, if the undergoing write operation is a part of transactional updating, it can not be stopped until the transaction is finished. In the 8th and 21th lines, as far as  X  child is concerned, it may be the existing child layer of  X  or a newly generated child layer of  X  according to the different conditions, and it has the same table structure as  X  . 2.5 An Example of Layer-Based View Approach In order to better understand how our layer-based view approach works, we here give an example.
 As can be seen in Fig.5, at time T 1 , there is only one layer, i.e. Layer1 in the system. View1 (  X  current ) is composed of Layer1, and is also what OLAP tools can see at time T . We suppose that a query Q 1 has already read-locked all the records (i.e. v 1 , v 2 and v 3 ) of View1 before time T 1 , and it will not release its read locks until time T 3 . According to the knowledge about the lock transformation, the virtual read locks on v , v 2 and v 3 of View1, are transformed into the actual read locks on r 1 , r 2 and r 3 of Layer1. So r 1 , r 2 and r 3 of Layer1 are all read-locked. Then, at time T 1 , an update operation U 1 arrives at the system, expecting to update the records v 1 and v 2 of View1. Before starting the update work, U 1 must apply to the system for the virtual write locks on v 1 and v 2 . The virtual write locks will then be transformed into the actual write locks on r 1 and r 2 .However, r 1 and r 2 are already read-locked by Q 1 , and also in our method, read lock has higher priority to write lock, so the write lock application of U 1 fails due to the lock confliction. But U 1 will not wait for the read locks to be released, and it will be redirected to Layer2, the child layer of Layer1, to continue its job. In other words, U 1 will write the update results ( r 4 and r 5 ) into Layer2. Layer2 is automatically generated by the system to accommodate the write operation U 1 .After U 1 completes its work, the system will generate a new view, i.e. View2, to reflect the most recent data, and then View2 becomes  X  current . From now on, View2 is what OLAP tools can see, but View1 will not be deleted until Q 1 finishes its work.

Then, at time T 2 , another query Q 2 arrives at the system, and needs to read v 4 , v 5 and v 3 . Q 2 first applies virtual read locks on v 4 , v 5 and v 3 of View 2, which will be transformed into three actual locks, i.e. the actual read locks on r 4 and r 5 of Layer2, and the actual read lock on r 3 of Layer1. Read lock application will never fail, so Q 2 starts to read the locked records, and here we suppose that it will not release its read locks until the time T 3 .When Q 2 is undergoing its read work, another update operation U 2 arrives at the system, and expects to update the records v 5 and v 3 of View2. Its virtual write locks on v 5 and v 3 of View2 will be transformed into actual write locks, i.e. the lock on r 5 of Layer2 and the lock on r 3 of Layer1. Because r 3 of Layer1 is still read-locked, lock confliction occurs, and the system will redirect U 2 to Layer2, the child layer of Layer1, to do the update against r 3 . Similarly, update operation against r 5 will also be redirected to Layer3, the child layer of Layer2. After U 2 finishes its work, the system will generate a new view, i.e. View3, to present the most recent data, and then View3 becomes  X  current . From now on, View 3 is what OLAP tools can see, but View2 will not be deleted until Q 2 completes its work.
 At time T 3 , both Q 1 and Q 2 finish their reading job, an d release their read locks. During the whole reading process, data involved in Q 1 ( r 1 , r 2 and r 3 ) and that involved in Q 2 ( r 4 , r 5 and r 3 ) are never changed, so the internal consistency of report is well maintained. Also, when the reading work is undergoing, the update operations of U 1 and U 2 are not blocked, instead they perform their jobs smoothly and successfully. Now we report the performance evaluation of our method. The algorithms were im-plemented with C++. All the experiments are conducted on 4*2.4GHz CPU (double core), 32G memory HP Proliant DL585 Server running Windows Server 2003 and Ora-cle 10g (for operational system and data warehouse) and Oracle TimesTen In-Memory Database (for real-time data cache).
 We use TPC benchmark TPC-H to get the required datasets in our experiment. DB-GEN, a tool provided by TPC, is used here to generate the required datasets to popu-late the database in the data source. We ta ke real-time data cache [8] running Oracle TimesTen In-Memory Database to store all t he real-time data. The external data cache database is generally modeled identically to the data warehouse, but typically contains only the tables that are real-time. Also through JIM or RJIM system [8], we can seam-lessly combine the real-time data in the data cache and historical data in the data ware-house. With the help of Streams Components provided by Oracle 10g, it is easy to capture the change data in the data source and send them to the destination queue, from which they are dequeued to be integrated into the data caches.
 Performance ratio. In this experiment, we will show that our method can not only maintain report internal consistency, but also effectively avoid the contention between read and write operations so as to achieve desirable performance for both update and query. In order to show the influence of read and write operations upon system per-formance, we change the cont ention ratio (denoted by r ) between these two kinds of operations in the load. Fig. 6 (1) shows how the performance ratio t 1 /t 2 changes when varying the value of r from 0 to 100 % ,where t 1 denotes the total running time for the given update and query load L when not taking layer based view approach, and t 2 the total running time for L when taking our method. In Fig. 6 (1), we can see that when r equals 0, which means there is no read and write contention, the value of t 1 /t 2 is 0.99. In another word, under such circumstance, it will bring negative benefits, though only a few, when taking layer based view approach. This is due to the additional cost for layer management. However, benefits from our method will become more and more evident when the contention ratio r increases. As can be seen in Fig. 6 (1), the performance ratio is 5.3 when r equals 100 % .
 We also test our method under three different kinds of workloads, i.e., L 1 , L 2 and L . These workloads contain the same sequence of update and query operations with the same contention ratio, but feeding the system at different rates. The update and query operations in L 1 arrive at the slowest rate, and those in L 3 at the fastest rate. Fig. 6 (2) shows that our method can achieve much better performance ratio (the same as the definition above, i.e., t 1 /t 2 ) when arriving rate is faster. Since there will be much more contention between read and write operations within a given time window when increasing the arriving rate, it can be conc luded that our method can effectively deal with the query contention issue besides maintaining report internal consistency. Memory usage. In this experiment, we will show that our method can effectively man-age memory usage through the mechanism of layer merging and layer deleting. Fig. 7 (1) shows the memory usage when there is n o layer merging and deleting mechanism. In such case, more and more memory is used to support the continuously generated layers. Since there is no layer dropping mechanism, those layers without any use in the future still reside in memory, which wastes much memory space and is to exhaust the limited memory resource in the end. In contrast, the memory resource can be recycled (see Fig. 7 (2)) when there exists layer merging and deleting mechanism. In Fig. 7 (2), there are three turning point T 1 , T 2 and T 3 in the memory usage curve. At T 1 and T 3 ,the memory usage amounts to a predefined value M , layer merging process starts, which merges different layers into one if condition is met and drops many useless layers to release the memory. At T 2 , a lot of DELETE operations occurs in the system, which leads to the start of layer dropping process and much memory is recycled. Report X  X  internal consistency is an important issue for real-time OLAP. Temporal model (e.g. [10]) can be used to solve the problem, which enables analytical processing of detailed data based on a stable state at a specific time [11]. While research in temporal databases has grown immensely in recent y ears, only a few DWH research projects paid attention to such problem as temporal model. Until the work done by Bobert et al. in [10], most of the previous research ha s been concentrated on performance issues, rather than higher-level issues, such as conceptual modeling [12]. In [10], an approach is presented to model conceptual time consistency problems, in which all states that were not yet known by the system at specific point in time are consistently ignored, and thus enables timely consistent analyses.

Temporal model addresses the issue of supporting temporal information efficiently in data warehousing systems, however, keeping temporal data warehouses up-to-date is complex [11]. Usually, it is more appropriate to be used to deal with the temporal consistency problem brought by late-arriving data, than to be used to solve the problem of report X  X  internal consistency resulting from the continuous data integrating in the real-time data warehouse environment.

Another desirable way is to use an external real-time data cache, and at the same time without compromising report X  X  internal consistency, data latency, or the user experience [8]. However, there are problems with the method even with the help of JIM system. The most obvious one is that, in the real-time data warehouses environment, real-time data cache is continuously updated, and therefore th e  X  X ead X  operation of getting a snapshot for OLAP tools will undoubtedly conflict with the  X  X rite X  operation of data updating. If there are many concurrent users in the system, such confliction is to deteriorate system performance greatly. Such problem can not get resolved simply through adding more hardware to the system.

Multi-version database is a desirable method to maintain read consistency [9]. To some extent, our method is similar to multi-version database. However, there are still great differences between them. For example, our method can provide read consis-tency for multi-pass SQL statement, but it is hard for multi-version database. Also, our method is independent of DBMS and can be used in memory database. However, multi-version method is usually integrated into DBMS products, and can not be used in memory databases in some cases. Furthermore, our method can effectively deal with query contention issue besides maintaining report internal consistency, while multi-version database can not.

There are also some other methods available now, such as using a near real-time ap-proach and risk mitigation for true real-time [8]. In [13], a new method is presented, which raises the level of abstraction for th e use of replicated and cached data by al-lowing applications to state their data curre ncy and consistency requirements explic-itly and having the system take responsibility for producing results that meet those requirements. In this paper, we have revisited the issue of maintaining internal consistency of report for real-time OLAP. We propose a new method, called layer-based view, to effectively maintain report X  X  internal consistency in real-time data warehouses environment. Impor-tant concepts such as layer, view and lock are defined, and the related mechanism, espe-cially the layer generating mech anism, are discussed in detail. The advantages provided by layer-based view approach include no confliction between read and write operations, achievement of report X  X  internal consistency and faster response time for OLAP queries.
Important future research directions in this field will be the appropriate definition of threshold for layer merging process, and the application of the theory into the field of read-time data warehouses in business environment.

