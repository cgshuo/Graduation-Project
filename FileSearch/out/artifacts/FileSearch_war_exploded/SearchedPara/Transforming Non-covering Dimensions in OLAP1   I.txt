 According to OLAP council, a dimension is defi ned as  X  X  structural attribute of a cube systems are used to support decision-making processes by providing analytical opera-everywhere-defined mapping between two levels in previous multidimensional mod-els [4,5,6]; nowadays, many commercial OLAP systems require dimensions to be onto and covering so as to ensure proper pr e-aggregations and queries associated with meet the requirements and they could be self-into, non-onto or non-covering [3]. 
There are two ways to deal with these  X  X  rregular X  dimensions. One way is to pro-develop practical OLAP systems based on them. Another way is to devise some algo-dimensions in this paper, especially those for non-covering dimensions. Recently, some research work [3,10,11] has been done to solve the problem. In [3], formed structures by adding some marked elements to the domains of certain levels. However, the MakeCovering algorithm for transforming non-covering dimensions is too simple. If we use the algorithm to transform every non-covering dimension in the results may be gotten. We will discuss them in the following sections. In [10], Tapio proposed a new formal form for OLAP cube design, and some decomposition algo-structural sparsity resulting from inter-dimensional functional dependencies. How-mostly caused by non-normalized relationships between dimensions and facts; more-over, Tapio could not concern the possible non-normalization caused by the complex model to accommodate spatial values that exhibit partial containment relationships in dimensions, especially in some spatial dimensions. In addition, he offered some algo-tween the elements that need to be duplicated or moved. There are no further exten-sions to consider the four cases mentioned in this paper. Therefore, like those in [3], these algorithms would cause the same problems discussed above when transforming irregular dimensions. 
In this paper, based on the dimension model in our previous work [9], we first pre-have met in real-world applications, we define four types of non-covering dimensions that need to be transformed in different ways. Furthermore, we propose several algo-rithms to transform the four types of non-covering dimensions respectively. The algo-rithms are more powerful in dealing with irregular dimensions than those in previous tainly provide full support for transforming the four types of non-covering dimensions into covering ones correctly. 
The rest of the paper is organized as follows. Several irregular dimensions are for-mensions. In section 4, we propose some algorithms for transforming the four types of non-covering dimensions. Section 5 presents case study and defines a calling priority order for the algorithms we proposed. Finally, section 6 concludes the paper. In [9], we proposed a new multidimensional model, which can support both standard dimensions and irregular dimensions. In this section, based on the dimension model, covering and self-into dimensions. Especially, self-into dimensions tion relationship (AR) on D. The domain of d is defined as: dom(d)= all child levels of l i . 
As stated in [3], OLAP syst ems use a technique known as pre-aggregation to im-prove query performance. Moreover, summarizability is necessary for the use of pre-aggregated results. With summarizability, we can organize the pre-aggregated results in a reasonable dependency order, so that we can effectively perform analyzing opera-models, summarizability needs the mappings between levels to be covering, onto and self-onto. These concepts and thei r counter-parts are given below. e  X  dom( l b  X  a , then we say that h is self-onto in level l b  X  b onto mappings. Since we mainly concern the transforming of non-covering dimen-sions here, we assume that the self-into mappings in this paper are of the first type. This section will present four different types of non-covering dimensions, along with some figures to illustrate the differences in their structures. sions here, and call them type A, B, C and D respectively; we distinguish them mainly depending on the different cases of th e mapping between two adjacent levels. 
Fig.1 shows the schema structure of a non-covering dimension, in which the map-the different cases of the mapping between l 2 and l 3 . onto, then the dimension is of type A. For instance, the depot dimension in fig. 2 is of type A because  X  X hunyi depot X  in dom(GrainDepot) directly belongs to  X  X entral dom(SubCompany), and each sub-company belongs to  X  X entral Grain Company X . dom( l 2 ). For example, the location dimension in fig.3 is of type B, because  X  X eijing X  dom(County). (i.e. partial), then the dimension is of type C. There are two cases for the partial map-but has one in dom( l 4 ). Furthermore, we treat the second case as type D . especially non-covering dimensions, into well-formed dimensions that can be used in most multidimensional models. Moreover, these algorithms are much powerful in dealing with various non-covering dimensions by overcoming the deficiencies of the algorithms proposed by Pedersen in [3]. them respectively. For the location dimensio n,  X  X eijing X ,  X  X hongqing X  are duplicated sion is still acceptable. Whereas, for the de pot dimension,  X  X entral Grain Company X  formed depot dimension becomes confusing to analyzers because they think that sub-companies cannot be ranked together and compared with their parent company. Fur-Grain Company X  will be aggregated twice with different resulting values. However, if only  X  X hunyi depot X  is duplicated and added to dom(SubCompany) after being dimensions respectively.

From the discussions above, we could know that the MakeCovering algorithm is rithm MakeCovering could only deal with the dimensions in which the non-covering non-adjacent levels. 
The MakeCoveringB algorithm is the improved version of MakeCovering, and it is The algorithm works as follows. Given the arguments: dimension D and level l x (ini-covering w.r.t. l x , then those elements in dom(l n ) which cause the non-covering map-ping are found out and put in the set L in lines 6 and 7. In line 8, algorithm Adjust-However, the elements in L cannot be copied to the domains of other levels without being marked. Here we follow the marking method in [3], and use the prefix  X  X i- X  to mark the elements, where  X  X  X  denotes the rank of the level in the dimension hierarchy. ping higher up in the dimension D. (1) Procedure MakeCoveringB(D,l x ) (2) for each l m  X  Parent(l x ) do (3) begin (5) begin (8) AdjustMappingB(D,l x ,l n ,L) (11) end (12) MakeCoveringB(D, l m ) (13) end (1) Procedure AdjustMappingB(D,l p ,l top ,L) (2) for each l q in Parent(l p ) where l q '  X  l top do (3) begin (4) if l q = l top then (6) else (7) begin (8) dom(l q )=dom(l q )  X  {Mark(n)|n  X  L} (10) end (11) AdjustMappingB(D,l q ,l top ,L) (12) end 
Algorithm AdjustMappingB is shown in fig.5, where L contains the elements to be link every marked element  X  X ark(n) X  in dom(l p ) to the corresponding element  X  X  X  in linked to the corresponding marked elements in dom(l p ). Line 11 contains a recursive call to the algorithm on l q to process every level between l p and l top . 
In the two algorithms above, operations on sets are standard relational algebra op-elements are ordered in the same sequence by the elements in dom(y), then the com-can also be evaluated in time ) log ( n n  X  . CoveringB is recursively called at most once for each mapping between any two lev-algorithm AdjustMappingB, the maximum numbe r of the recursive calls is m(m-1)/2,  X  , and the normal case is ) log ( n mn  X  . Therefore, for MakeCoveringB, the worst case is ) log ( 4 n n m  X  and the normal case is ) log ( 3 n n m  X  . 
The correctness argument for algorithm Ma keCoveringB has two aspects: (1) each algorithm should only perform the transformations that are semantically correct, i.e., mension as with the old one. The correctness follows from Theorem 1, 2 and 3. Theorem 1. Algorithm AdjustMappingB terminates and the original aggregation se-mantics will not be changed in the resulting dimension. algorithm does nothing to the dimension and the theorem is obviously true. (2) Sup-pose the theorem holds true for the dimensions with height n. (3) Consider the dimen-perform the algorithm on a sub-dimension with height n, then according to the induc-tion hypothesis, the algorithm must terminate. As to the aggregation semantics, in the sponding elements in dom(l p ), and other links are kept untouched; this means that the mension. Moreover, the recursive call will perform the algorithm on a sub-dimension duction hypothesis. Theorem 2. Algorithm MakeCoveringB terminates and the resulting dimension is covering. Proof: By induction in the height of the dimension (similar to theorem 1, omitted). following holds true: for any e 1 , e 2  X  D, e 1  X  1 e 2  X  e 1  X  e 2 . Proof: By induction in the height of the dimension (similar to theorem 1, omitted). 
Theorem 3 ensures that the aggregation paths in dimension d are kept unchanged in the resulting dimension d 1 . Therefore, for each aggregation query Q on d, an aggrega-tion query Q 1 on d 1 can be found, such that Q  X  Q 1 . MakeCoveringA shown in fig.6, which works as follows. Given the arguments: di-algorithm AdjustMappingA by passing the arguments: D, l x , l n and F. AdjustMappingA is shown in fig.7. In the algorithm, if l q is not equal to l top , then AdjustMappingA adds the elements, which are extracted from F and belong to F are marked and added to the mapping  X  pq to establish the links between the marked elements in dom(l p ) and the corresponding marked elements in dom(l q ). 
After AdjustMappingA is executed, the marked elements in dom(l m ) are linked to to fix each non-covering mapping higher up in the dimension D. (1) Procedure MakeCoveringA(D,l x ) (2) for each l m  X  Parent(l x ) do (3) begin (5) begin (7) L={x|(x,n)  X  F} (8) AdjustMappingA(D, l x , l n ,F) (9)  X  xm =  X  xm  X  {(x,Mark(x))|for every x  X  L} (11) end (12) MakeCoveringA(D, l m ) (13) end 
Following previous reasoning and analyses, the worst-case complexity of algo-is the maximum size of the mappings between any pair of levels and m is the number of levels. For algorithm MakeCoveringA, the worst-case complexity is ) log ( 4 n n m  X  and the normal case (als o the usual case) is ) log ( 3 n n m  X  .
 The theorems related with the correctness of algorithms AdjustMappingA and rems 1 and we omit them here. (1) Procedure AdjustMappingA(D,l p ,l top ,F) (2) L={x|(x,n)  X  F} (3) for each l q in Parent(l p ) where l q '  X  l top do (4) begin (5) if l q = l top then (6)  X  pq =  X  pq  X  {(Mark(x), n)|for every (x,n)  X  F} (7) else (8) begin (9) dom(l q )=dom(l q )  X  {Mark(x)|x  X  L} (10)  X  pq =  X  pq  X  {(Mark(x),Mark(x))| for every x  X  L} (11) end (12) AdjustMappingA(D,l q ,l top ,F) (13) end Theorem 4 . Algorithm AdjustMappingA terminates and the original aggregation semantics will not be changed in the resulting dimension. Theorem 5 . Algorithm MakeCoveringA terminates and the resulting dimension is covering. following holds true: for any e 1 , e 2  X  D, e 1  X  1 e 2  X  e 1  X  e 2 . 
For the non-covering dimension of type C stated in previous section, we could first call algorithm MakeCoveringA to transform the non-covering mapping between l 2 mension can be transformed into covering one just by MakeCoveringA; otherwise, if rithm should also be called. 
For a dimension of type D, we should call algorithms MakeSelfOnto, MakeOnto the calling sequence is pending; we will discuss this problem in the next section. 
The MakeSelfOnto algorithm is shown in fig.8, and it works as follows. From line being marked, and they are removed from dom(l x ). In line 11 and line 12, the pairs in subtracted from the self-into mapping on dom(l x ). Line 15 is the recursive call to the algorithm on l n . The set V is used to ensure that the algorithm would not process one non-onto, and then need to be transformed by algorithm MakeOnto. Therefore, given a self-into dimension, after MakeSelfOnto is first executed on it, algorithm MakeOnto must be called immediately to deal with the non-onto mappings that might be caused by the marked elements in the domains of the lower levels. (1)Procedure MakeSelfOnto(D,l x ,V) (2)for each l n  X  Child(l x ) do (3) begin (4) F={(x,y)|(x,y)  X  X  xx and x X y} (5) P={x|(x,y)  X  F} (6) L={x|(n,x)  X  X  nx } (7) Q=P-L (8) H={(x,y)| (x,y)  X  F and x  X  Q} (9) dom(l n )=dom(l n )  X  {Mark(x)|x  X  Q} (10) dom(l x )=dom(l x )-Q (12)  X  nx =  X  nx  X  {(Mark(x),y)| for any (x, y)  X  H } (13) V=V  X  {l x } (14) if l n  X  V then (15) MakeSelfOnto(D, l n , V) (16) end 
Following the analyses of algorithm AdjustMappingB, the overall complexity of algorithm MakeSelfOnto is ) log ( n mn  X  because the set V ensures that the algorithm would transform each level once at most. The following theorems ensure the correct-ness of algorithm MakeSelfOnto. Their proofs are also omitted here. onto. lowing holds true: for any e 1 , e 2  X  D, e 1  X  1 e 2  X  e 1  X  e 2 . that MakeCoveringA should be called first; then, it depends on the transformed map-pings X  types whether MakeCoveringB should still be called in turn. Therefore, accord-dimension is in time ) log ( 4 n n m  X  , and the normal case is ) log ( 3 n n m  X  . For a non-covering dimension of type D, MakeSelfOnto, MakeOnto and Make-CoveringA (or MakeCoveringB) should be called. Following the complexity analyses mension is also in time ) log ( 4 n n m  X  , and the normal case is ) log ( 3 n n m  X  . plain the correctness of the algorithms we proposed; furthermore, we intend to define a calling priority order for the algorithms. The dimensions of type A and type B have been illustrated in section 3. The dimensions of Type C are similar to those of type D in transforming processes. proposed in previous section are employed to transform the dimension into a covering one. In addition to the theorems in section 4, the resulting dimension further verifies the correctness and effectiveness of these algorithms. 
According to the definition in section 3, we know that the location dimension is of type D. Moreover, according to the analyses in previous section, we should call algo-rithms MakeSelfOnto and MakeOnto to transform the dimension into a self-onto and onto dimension, and then only one of the MakeCoveringA and MakeCoveringB algo-rithms should be executed to transfor m the dimension into a covering one. 
In these algorithms, MakeSelfOnto should be called first to transform the self-into striction, the rest algorithms can be called in various sequences, which would lead to {MakeSelfOnto, MakeOnto, MakeCoveringA}, {MakeSelfOnto, MakeCoveringB, MakeOnto} and {MakeSelfOnto, MakeCoveringA, MakeOnto}. If the algorithms are executed in the first sequence, then  X  X 2-Beijing X  and  X  X 4-Yunyang X  will be added to after being marked, and thus it is in the same level as its child  X  X iangjin X ; this would dimension is also unacceptable. If we execut e these algorithms in the third sequence, then  X  X 4-Miyun X  and  X  X 4-Yunyang X  will be added to dom(City),  X  X 3-Jiangjin X  is added to dom(County),  X  X ehui X  is removed from dom(City) and  X  X 3-Dehui X  is added to dom(County). These processes seem reasonable and do not cause error aggregation Given the sequence: MakeSelfOnto, MakeCoveringA, MakeCoveringB, Make-Onto, based on the example and the discussion in previous section, we could conclude mension in fig.9, the calling sequence of the algorithms can be easily obtained accord-ing to this priority order. In this paper, we first formally defined several types of irregular dimensions based on the dimension model in [9]; especially, we mainly analyzed the characteristics of the four types of non-covering dimensions, which are never mentioned in previous work and need to be transformed into covering ones in different ways. Then, we extended the MakeCovering algorithm proposed by Pedersen to algorithm MakeCoveringB so as to deal with much complex non-covering hierarchies; moreover, we proposed two new algorithms: MakeCoveringA and MakeSelfOnto. Along with the MakeOnto into covering ones in proper combinations. Furthermore, we defined a calling priority order for them; along the sequence: MakeSelfOnto, MakeOnto, MakeCoveringB, MakeCoveringA, the priority decreases gradually. will investigate them further in future work , and we also plan to propose an algorithm transform them automatically. 
