 1. Introduction
With the transformation of the architecture from mainframes to client X  X erver models, information technology services have been rapidly developed and increased. The cloud computing concept represents a new paradigm shift in Internet-based services, providing highly scalable distributed computing plat-forms where computational resources are offered as a service, and hence consumers do not need to understand how it all works and can easily access various services via the Internet.

With advanced network technology, high speed bandwidth provision, and the popularity of smart phones, people can immedi-ately upload their work to the Internet at anytime and anywhere, as long as they have a network connection. This is also the most attractive feature of cloud computing, and it has dramatically changed the procedure to proces s traditional information.
Originally, cloud computing was not a Business to Business (B2B) model, but a Business to Consumer (B2C) model, which meant users could access and operate software and other services via the Internet. With the rapid development of cloud computing, however, more and more industries took cloud computing uses in business models into account. That is because cloud computing has fully utilized the virtualization technology that can give users high flexibility and extensibility, and consumers can increase the storage space or computation ability only if they can consult with their Internet service providers (ISPs). Hence, it is an important issue in resource management for the cloud system to allocate the virtual machines (VMs) and make the cloud computing system automatically manage the entity X  X  resources through the strate-gies of creating or collecting VMs and migration among the physical machines (PHs). ISPs will formally sign a contract, called a service level agreement (SLA), with consumers to determine the price of each level of service, the contracted content of which sometimes refers to certain performance metrics of resources, such as the performance of the CPU, the memory capacity, and the response time. ISPs can evaluate their applications to determine different prices according to these resource performance metrics, and they no longer need to find locations in which to store their application services. Instead, application services are now mana-ged by the cloud computing system to achieve efficiency through the distributed computation in VMs.

Resource management is alwa ys an important issue that is mostly applied in the form of some arrangement of working tasks, which have their own different usages in problem solving and resources, aiming at each kind of goal, is a demanding task. This research work focused on the application of Evolutionary Algorithms representation of some algorithms, the gene coding representation of
GA is more suitable in this work. Besides, numerous researchers have proposed genetic algorithms (GA s) to deal with optimization pro-blems, and the schema theorem for GA proposed by Holland (1975) illustrated that GA is a robust searching approach. We thus chose GA other EAs, such as the hybrid meta-heuristic algorithm, called evolution strategy (ES), proposed by Nissen et al. (2011) ,ascom-pared methods in future work. Following the principles first pre-(GA) is not only an adaptive heuri stic search algorithm assumed on the evolutionary ideas of natural selection and genetic, but also represents an intelligent exploitation of a random search in a vase search space. The main advantage of GA compared with other particular algorithm to solve a given problem. Feng et al. (2010) presented a method to select memb ers from different departments to resolve a manpower distribution problem by using an improved non-dominated sorting genetic a lgorithm (INSGA). However, GAs often consume a lot of time in order to find the global optimum ( De Jong, 2005; Preux and Talbi, 1999 ), and some studies have to improve the computation time of GAs.
 supervised machine learning meth od that recognizes patterns and analyzes data; it is mostly used for classification and regression analysis. The major difference between the SVR and traditional regression techniques is that the SVR employs the structural risk minimization (SRM) approach, rather than the empirical risk minimization (ERM) approach typically adopted in statistical learning. The SRM attempts to minimize an upper threshold on the generalization rather than minimize the training error, and is expected to perform better than the traditional ERM approach.
Furthermore, the SVR is a convex optimization, which guarantees literature, numerous researchers have adopted SVR to deal with classification and regression problems. Wu et al. (2004) used SVR to traffic flow, and weather conditions. Users can handle the overall schedule more efficiently with this method. In addition, Liu et al. (2006) compared three regression app roaches, including SVR, Back-propagation Neural Network, and Partial Least Squares, to predict the Cold Modulus of Silicon Ceramic, and the results showed that
SVR obtained better performance in terms of root mean square error than the other two methods.

This work aims to consider the efficiency and optimization of resource allocation in a cloud computing environment. An appli-cation service prediction module built with SVR is used to evaluate the number of resource utilization according to the SLA of each process. When new VMs are demanded, the system will consider the individual loading to proceed the prediction with
SVR. If the result needs to change the allocation strategies, the system will utilize GA at this stage to try its best to achieve the global deployment of the resources effectively, including creating or collecting VMs, to make sure that the proposed system can satisfy the SLA requested by the customers.

The remainder of this paper is organized as follows. Section 2 addresses the algorithm for the proposed resource allocation mechanism. The simulation results are given in Section 3 . Con-clusions are presented in Section 4 . 2. Resource management algorithm
Fig. 1 illustrates the architecture of the resource management scheme for cloud computing proposed in this work. An applica-tion service resource pool is used to collect all applications provided by Internet service providers (ISPs), and an application monitor is used to record the overall utilization of system resources. Furthermore, a physical machine resource pool is used to provide resources, CPU or Memory, for the hosts; and two look-up tables, including the remaining resource table and the resource utilization rate table, are used to assist in determining the strategies of increasing or decreasing the number of virtual machines (VMs) requested by each application service. Notably, an application service prediction module built with Support Vector Regressions (SVRs) is used to estimate the number of resource utilization according to the SLA of each process. Mean-while, a global resource allocation module applied with the genetic algorithm (GA) is utilized to redistribute the resources to the clients, including creating or collecting VMs, to make sure that the proposed system can satisfy the service level agreement (SLA) requested by the customers. 2.1. Application service prediction module
This module mainly estimates the resource requirements of the applications to remind the system to create or collect the VMs in accordance with the real Internet situation. In addition, a well-known time series predictor, namely SVR, is embedded in this module to evaluate the number of resource utilization according to the SLA of each process with the assistance of two lookup tables, including the remaining usable resource table, which records all related usable resources in the applications, and the each VM in the AP. With the above-mentioned methods, this module will determine whether the VMs should be increased or decreased for the requests from the application services. More description about the SVR approach will be provided in the next sub-section. 2.1.1. Support vector regression (SVR)
To solve a nonlinear regression or functional approximation problem, the SVR nonlinearly maps the input space into a high-dimensional feature space using an appropriate kernel represen-tation, such as polynomials and radial basis functions with Gaussian kernels. This approach is utilized to build a linear regression hyperplane in the feature space, which is nonlinear in the original input space. The parameters can then be derived by solving a quadratic programming problem with linear equality and inequality constraints ( Cortes and Vapnik, 1995 ). pair training data ( x i , y i ), i  X  1, y l , is given. The input x n -dimensional vectors, and the system response y i terms are continuous values. The SVR attempts to approximate the follow-ing function using data set D : fx , w  X  X  X  where b denotes the bias term, and the w i terms represent the subjects of learning. Furthermore, a mapping z  X  U ( x ) is selected in advance to map input vectors x into a higher-dimensional feature space F , which is spanned by a set of fixed functions j
By defining a linear loss function with the following e -insensitivity zone as illustrated in Fig. 2 : 9 y i f x i , w  X  X  9 e  X 
The w i terms in Eq. (1) can be estimated by minimizing the risk: R  X  1 2 J w J 2  X  C l where C denotes a user-chosen penalty parameter that deter-mines the trade-off between the training error and VC dimension of the SVR model. Significantly, the VC dimension is a scalar value
Eq. (3) can be further derived as the following constrained optimization problem: R w , n , n n  X  1 2 99 w 99 2  X  C l subject to constraints: y w T x i  X  b y i r e  X  x i x 8 &gt; &lt; &gt; : where x i and x n i denote the respective measurements above and below the zone with the radius e in Vapnik X  X  loss function as given in Eq. (2) .

Sch  X  olkopf et al. (2000) developed a modification of Vapnik X  X  original SVR algorithm, called n  X  X VR, and claimed that it can automatically minimize the radius e . Lagrange multiplier methods can be employed to demonstrate that the constrained optimiza-tion problem in Eqs. (4) and (5) maximizes the solution of the following equation: W a , a n  X  under constraints: 0 r a i n , a i r C l , i  X  1 , ... , l 8 &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &lt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; : where ( a i , a n i ) denotes one of l Lagrange multiplier pairs; C represents a regularization constant specified a priori ; n is a constant greater than or equal to zero, and k ( x i, , x j normally a Gaussian kernel or polynomial kernel.

The best nonlinear regression hyperfunction is then repre-sented as: f  X  x  X  X  where b denotes the optimal bias. 2.2. Resource allocation optimization module the Application Service Prediction module and two lookup tables, along with SLAs requested by the customer, to determine the number of VMs requested by each application service. GA is applied in this work to deal with the optimization problem, and the fitness function is designed in accordance with the actual cloud computing environment. 2.2.1. Genetic algorithm (GA)
We first transfer the VMs which are established in the physical machine into a binary code as the initial population, called chromosomes. Each element in the chromosome is either 0 or 1, and the higher fitness value will be kept to generate the next generation during the procedure of recombination and mutation.
The new generation will run the same steps as their parents did set fixed time interval to activate GA because the system will proceed the adjustment strategies according to the real-time demand of VMs. Once a new request of VM arrives, the system will run GA to adjust the overall allocation of the resources.
GA, a set of initial population is generated at random, and the chromosomes in matrix format, with n VMs, and m physical machines, as shown as Fig. 4 . A horizontal row stands for the location that each VM is allocated in a given physical machine, and a vertical column represents the distribution of each VM belonging to the specific physical machine. Notably, the sum of each element on the column should be less than or equal to the maximum resource which a physical machine can provide for the customers. For example, a 23  X  1 represents that the VM 2 is allocated in physical machine 3 (PH 3), and the sum a 13  X  a 23  X  a 33  X  y  X  a m 3 should be less than or equal to the maximum computing resources offered by PH 3, and the sum a 21  X  a 22  X  a 23 y a 2 n would be the dynamic adjustment strategy estimated by the Application Service Prediction module. matrix, a ij , is set to 0. Meanwhile, before GA is utilized in the initialization, the system will run SVR to evaluate the number of resource utilization according to the SLA of each process. The system has proceeded the allocation of VMs for each individual demand in the initialization step, and the operation of GA is to finely adjust the overall allocation to achieve better performance. 2.2.1.2. Fitness function. We first evaluate the resources of the follows, ^ u  X  ^ v  X  v for the supply side of the memory.

We then define a matching score c as follows, c  X  fa p u q = ^ u fb p v q = ^ v ,  X  11  X  where f ( x ) represents a penalty function, a p and b p, represents the demand of processors and memories that VM p requests, and u q and v q stands for the processors and memories that PH p supplies, respectively.

The design of fitness function is inspired by the theory of balanced supply and demand in economics to reflect the real business model. If the supply and the demand are at equilibrium, there is no penalty. If the demand is larger than the supply, it means the resources are insufficient, and the penalty will be added according to the level of the difference. However, if the supply is larger than the demand, the resources will be idled, but it does not affect the normal operation of the system and the level of penalty will be less than that above-mentioned case in which the demand is larger than the supply. Accordingly, the properties of the penalty function are enumerated as follows. First, if the demand is larger than the supply, the penalty will be approxi-mately increasing exponentially, as shown in the right part of
Fig. 5 . On the other hand, if the supply is larger than the demand, the penalty will be much lower than in the first situation just mentioned, and will be almost proportional to the difference between the demand and the supply. There is no penalty if both supply and demand are equal. To formulate a penalty function in accordance with the concepts of the above-mentioned properties, we first use the characteristic of the exponential function as shown in Eq. (12) , and then shift Eq. (12) downward by one unit as given by Eq. (13) . f  X  x  X  X  b e l x ,  X  12  X  f  X  x  X  X  b e l x 1 ,  X  13  X  where b is a preset penalty coefficient.

We make a further modification of Eq. (13) by turning over the left side of the Y -axis in Eq. (13) and adding a negative sign in the equation to reflect the characteristics of the penalty function. The penalty function can be modified as, f  X  x  X  X  b e l x l x 1 ,  X  14  X  where l represents a rotation coefficient.

However, we still have to overcome the large computation overhead during the process of the application of the GA. Hence, we simplify the evaluation function of Eq. (14) by ( Fig. 6 ), f  X  x  X  X  where b and g represent the predetermined penalty coefficient.
Next, we cumulate all the penalty functions collected from all the resources and obtain the cumulative penalty function as follows, E  X  where c i is the matching score defined in Eq. (11) .
For a better understanding how GA works in this work, we present an illustrative example. We assume that there are four physical machines, including PH 1 (CPU 4 GHz, Memory 8 G), PH 2 (CPU 6 GHz, Memory 10 G), PH 3 (CPU 6 GHz, Memory 8 G), and
PH 4 (CPU 4 GHz, Memory 8 G), and five virtual machines, including VM 1 (CPU 2 GHz, Memory 4 G), VM 2 (CPU 1.5 GHz, Memory 2 G), VM 3 (CPU 1 GHz, Memory 2 G), VM 4 (CPU 3 GHz,
Memory 8 G), and VM 5 (CPU 2 GHz, Memory 2 G). According to this setting, we can initialize the population as shown in Fig. 7 .
In Parent 1, the first column means that VM 1 and VM 3 are established in PH 1, the second column means that VM 2 are established in PH 2, and so on.

Next, we encode the chromosomes of the two parents into binary strings. From up to down and left to right, the Parent 1 and
Parent 2 can be represented as 10100010000001000001 and 01001000000001010100, respectively as shown in Table 1 . While b  X  10 and l  X  0.15, the fitness value can thus be 76.59 and 89.84. 2.2.1.3. Selection, recombination, and mutation. According to
Darwin X  X  theory of evolution, fitter individuals have a higher chance of surviving and spawning offspring. In this work, we adopt roulette wheel selection and one-point recombination as the recombination methods, respectively, and the recombination rate is 100%. To make sure that the sum of each column corresponds to the total VMs that can be allocated by a physical machine, we restrict each recombination occurring only in the same column as shown in Fig. 8 . Notably, we chose one-point recombination, which has lower overhead, as our recombination type because of the real-time demand of VMs in this work. We would take other recombination types into consideration without sacrificing the overall performance in future work. The mutation this work. A bit from the element in the matrix is chosen at random to perform the NOT operation on it. As shown in Fig. 9 , if we randomly choose a 21 as the mutation element, the bit will be transferred from 1 to 0. Besides, to make sure the sum in the be changed to 1, and the other bits in the same row will be transferred to 0 after the mutation operation. 2.2.1.4. Termination conditions. The population size is set to 20 in our experiment. The purpose of setting the termination conditions is to reduce the computing time and to avoid unnecessary evolution. conditions has been reached. The first is when a fixed number of generations, say one hundred, is reached. The second is when the cumulative penalty function as given in Eq. (16) for ten consecutive generationsisobserved.
 function of 80% parents is close to zero, or one individual reaches zero, the termination conditions would be met. Besides, if there are no other fitness values better than the existed ones after 10 consecutive generations, the system will stop running GA.
We found the probability of producing a better solution nearly reached to zero after the optimal solution has occurred for 10 times or more. We thus set this criterion to avoid more ineffective computation. Besides, our proposed SVR as a prediction mechan-ism solves the disadvantage of GA in higher computation com-plexity. Therefore, there is no high CPU-time consumption problem for the GA adopted in this work. 3. Simulation results
We first observed the difference between the non-optimized approach and the optimized approach proposed in this work. Six physical machines which were equipped with 8 GB RAM and 2 TB hard disks were used, and a simulation software installed in the Windows XP platform with Intel Core 2 Quad 3.2 GHz and 4 GB
RAM, CloudSim, was adopted in this work as the simulator of cloud infrastructures. The maximum number of VMs was set to 100. To reflect the characteristics of the real world, different complexities of service applications were designed to verify the feasibility and effectiveness of our proposed work.

Fig. 10 shows the accumulated counts of completed service applications in the form of a comparison between optimized and non-optimized approaches. Notably, our proposed SVR X  X A mechanism adopted the SVR technique as a predictor that can moderately assign VMs according to current network utilizations.
Additionally, a GA is applied to find out an optimized set of resource allocation strategies. The system that utilized GA with-out executing the prediction via SVR is denoted by NO SVR X  X A. NO SVR X  X A used random allocation in the initialization step of GA without allocating VMs in advance. The difference between
SVR X  X A and NO SVR X  X A is that NO SVR X  X A cannot determine if the distribution strategies of VMs need adjusting, and also cannot proceed local pre-allocation for individual demands in the initi-alization. Therefore, our approach can complete more service applications compared to the non-optimized method.

Fig. 11 shows the time consumption comparison between the optimized and non-optimized approaches for processing each service application. Obviously, with the help of the application service prediction module, the proposed approach can dynami-cally modify the requirement of the VMs and the resource allocation optimization module can effectively meet the require-ments of physical machines by using the GA. Because the system utilized SVR as a prediction mechanism before applying GA, the total waiting time of executing applications can be thus drama-tically decreased through allocating VMs in appropriate PHs in advance. Besides, our proposed SVR X  X A can proceed the opera-tion of local allocation in advance for individual demands in the initialization step of GA. Therefore, we can decrease the computa-tion complexity of GA and increase the overall performance. We realize that GA can obtain the optimal solution accurately, but the problem is that the traditional GA needs much time to converge, and this will be the main problem for real-time applications. That is the reason we combined SVR as a prediction mechanism to Total Time (ms) decease the computational times of GA, and the advantage of GA can be thus shown without affecting the overall performance in real-time systems. Thus, our proposed SVR X  X A mechanism can save much more time compared to the non-optimized method.
Next, we compared the proposed algorithm with other two representative resource allocation schemes in the literature, namely, efficiency resource management (ERM) ( Younge et al., 2010 ) and the dynamic resource allocation method based on the load of VMs on IaaS (DAIaS) ( Inomataetal.,2011 ). ERM provides efficient green enhancements within a scalable Cloud computing architecture. ERM tries to use small numbers of physical machines to meet the requirements requested by application providers. Thus, when a new VM is asked to be created, it will be built in the existing already opened physical machine, and another physical machine will not be used until all physical machines have exhausted their capacities. DAIaS is a scheme that enables users to dynamically increase or decrease one or more instances in accordance with the load and the conditions specified by the user. Ten physical machines equipped with 32 GB RAM and 4 TB hard disk were used. The maximum number of VMs was set to 400.
Fig. 12 represents the comparison of three resource allocation strategies in cloud computing, including DAIaS, ERM, and the proposed SVR X  X A algorithm. On the whole, our proposed SVR X  X A scheme achieves better performance in terms of response time than the other two methods. The response time is a dependent variable according the number of applications and the real requirement of each application. Our SVR X  X A is able to estimate the condition of each physical machine via the constructed tables, including the remaining usable resource table and the resource data to create or collect VMs through the application service prediction module in advance , to make up for the time consump-tion during the procedure of the GA X  X  evolution. However, the architecture of ERM only takes current existing physical machines into account, and tries not to make use of free ones. It may achieve SLA when we establish a number of VMs in physical machines. However, network congestion could occur as a result of too many requests for services from users, and this behavior will result in deteriorated response time. This is why ERM X  X  response time will be longer than that of DAIaS and SVR X  X A after our VMs according to the utilization rate of the physical machines and the Internet service requests. As long as the service requests increase, DAIaS incurs the overhead of migrating the users X  services while creating VMs, and this migration overhead could increase some response times accordingly.

The statistical analysis of the response time comparison for the three strategies is illustrated in Table 2 . The data collected from
Fig. 12 were analyzed by one-way repeated measure ANOVA method. At the 95% confidence level, it can be observed that there is significant difference among three strategies, and the proposed
SVR X  X A method has the best response time performance. 4. Conclusion
In this work, a resource allocation optimization system in a cloud computing environment is proposed. According to our experimental findings, the proposed approach, which employs an application service prediction module built with SVR, can estimate the number of resource utilization according to the
SLA of each process more accurately and efficiently than two other representative cloud resource allocation strategies found in the recent literature.

This work mainly examines the performance of EA, such as GA, applied in cloud computing. In this present stage, we only evaluated two resources, including CPU and RAM, and the experimental results showed the effectiveness of applying GA in the resource allocation of cloud computing. In future work, we will proceed more work focused on more resources, such as
Internet and the access of Auxiliary Memory to make our work more practical in real life applications. Total Tims (ms) 0 2 4 6 8 10 12 14 16 18 20 Response Time (ms)
GA can effectively adjust the resource allocation strategies and accomplish more applications in a limited time, compared with the non-optimized approach. In future work, we plan to modify the algorithms to decrease the calculation time in terms of the prediction process to improve the GA X  X  convergence speed. Acknowledgment of the Republic of China, Taiwan (Contract numbers NSC 99 X  2511-S-259-008-MY3 and 101 X 2622-E-259-001-CC3) for finan-cially supporting this research.
 References
