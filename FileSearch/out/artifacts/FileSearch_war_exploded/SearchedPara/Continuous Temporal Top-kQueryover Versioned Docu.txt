 Versioned documents are documents that may retain multiple versions as time processes. Versioned documents on the Web includes large-scale datasets of ver-sioned text such as archives of websites, wikis, blogs, micro-blogs, and business records, which have become abundant as the Internet evolves. Broadly speaking, objects continuously evolving during tim e can be treated as versioned documents as well, such as opinions from the same speakers, articles from the same authors, etc. Versioned documents can be used to support numerous applications such as analysis of financial market, public opinions, historical data, sensor data and other time-sensitive data. Thus querying versioned documents has been widely studied such [3,1,2,4]. We study the problem of continuous temporal top-k query over versioned documents. Because the problem can be widely adopted to many applications thus many related works were proposed about top-k query over ver-sioned document other temporal data sets [6,7,5,8]. Continuous temporal top-k retrieves the top-k objects that not only rank in top-k position in some time point but hold the position for at least a specific time period. In that case, our problem focuses on the sustainable ranking of the documents. Thus, both the ranking position and the time interval o f each version of the documents need to be considered.

Let q be the query submitted by a user to conduct a continuous temporal top-k search on a document set D .Query q is defined as q :( W , X ,k,r, X  ) . W denotes a set of keywords.  X  denotes to the query interval. q. X  =[ s, e ), which indicates that the query needs to find the results in D that are valid in q. X  . k denotes the number of results a top-k query needs to find and 0 &lt;k  X | D | . r is a relaxing factor that is specified by the user to indicate how frequently the documents needs to rank in top-k to become continuous temporal top-k results, and 0 &lt;r  X  1.  X  denotes to the set of weights of sub-intervals of  X  .
Let D be the target document sets. Given a query q , the continuous temporal top-k search finds the following document set: where  X  i is the weight of each atomic interval and m i =1if d is a top-k result in that atomic interval, otherwise m i =0.

We have the following contributions: (1) we define the problem for contin-uous temporal top-k query over versioned documents. (2) we propose a new algorithm called Interval Window based Algorithm (IWA). (3) we evaluate and demonstrate our method by a conducting a set of experiments. The basic idea of IWA is to modify NRA to support continuous temporal top-k search. In order to accomplish that, we modify the procedure of NRA by main-taining the lattice-based windows to gradually segment the continuous query space into sub-query spaces in the time d imension. Versions are treated as ob-jects of NRA. Postings are sorted accessed from the lists in parallel. A new posting ( v,p ) is access and the lower bound of the version v is updated. Then v is added to the windows set and the window set is maintained. After that, for each modified window: i) if less than k versions have been seen in the current window, the next window is checked; ii) if more than k versions have been seen, the lowest lower bound l of versions is extracted. The highest upper bound u of versions is extracted. iii) If the l  X  u , the window is marked as finalized . Finalized means that versions with top-k aggregated score (i.e., lower bound) of the win-dow have been found or current window no longer need to be maintained. This means top-k versions in this window have been determined and top-k results of each atomic intervals in this window can be derived. Then we check whether all the windows are marked as finalized .Iftheyare,top-k versions of each atomic in-terval have been determined, then continuous temporal top-k result of the query are generated. Otherwise the algorithm procedure goes back to the beginning. If all the postings have been visited and there are still non-finalized windows, we only check the finalized windows to see if continuous temporal top-k results can be generated with these windows. We evaluate the performance of our algorithms on the Wikipedia revision history data set. We randomly selected 7 sub-sets with different sizes ranging from 50 GBytes to 8 TBytes. We adopted the same form of inverted index proposed in [3]. The average length of posting list is 1 million in 1 TBytes data set and 10 million in the 8 TBytes data set. The baseline method we implemented is DAA [8]. We extend DAA to support our problem and refer to it as EDAA (extended DAA). We evaluated the performance and scalability of EDAA and IWA. 5 queries were chosen for each test instan ce. The result of each test instance is the average result of the 5 queries.
We tested the memory usage of EDAA and IWA. Figure 1(a) shows latency of a method as the query interval q. X  varies. When |  X  | becomes larger, both methods become more expensive since a larger p roblem space needs to be handled. IWA responds much faster than EDAA, and the growth of response time gets slower as length of |  X  | increases. Figure 1(b) shows the response time as k varies. Response time of both algorithms increase as k grows. EDAA is more time consuming and more sensitive to the growth of k , especially when k gets larger. Figure 1(c) plots the response time as a function of the size of the data set. EDAA is more sensitive to the size of posting lists. Figure 1(d) shows the response time of both methods as the query start time t b varies. It reveals the fact that IWA performs better than EDAA as the number of version grows. Figure 1(e) and 1(f) show the latency as the q. X  varies of extreme cases of the inputs. Comparing the results of 1(e) and 1(f) with previous results, we see that the advantage of IWA becomes more obvious as the complexity of query grows and the size of the data set increases.

In conclusion, IWA consistently outp erforms EDAA in terms of both memory the time consumption. IWA has lower latency and better scalability than EDAA, which makes it more suitable for real applications. We discussed the problem of continuous temporal top-k query. The problem is abstracted from the application scenarios that require to perform top-k queries on versioned documents considering the sustaining ranking position of objects and the weight of different intervals. We proposed the interval window based algorithm to solve this issue. We implemented the methods and tested our so-lutions in contrast to the baseline method on large-scale document sets, which were selected from Wikipedia with complete revision history from 2001 to 2013. Our experiment results show that IWA o utperforms the baseline method EDAA in all test cases.
 Acknowledgment. This work was supported by National Basic Research Pro-gram of China (973 Program) under Gra nt No.2011CB302302, Key S&amp;T Projects of Press and Publication under G rant No. GXTC-CZ-1015004/02, the Sup-port Program of the National  X 12th Five-Year-Plan X  of China under Grant No. 2012AA09A408 and Tsinghua University Initiative Scientific Research Program.
