 1. Introduction
The development of intelligent software agents keeps its emphasis on both arti interact with other agents and humans in order to solve their own problems. They may also behave in a cooperative manner and constitute systems called Multiagent Systems (MASs).
 2006 ) are taken into account.

The Semantic Web improves the current World Wide Web such that the web page content can be organized in a more structured way from diverse sources, process the information, and exchange the results.

In addition, autonomous agents can also evaluate semantic data and collaborate with semantically-de
Web, like semantic web services, by using content languages ( Kardas et al., 2009a ). Semantic web services can be simply de and automatic composition of web services, the capabilities of web services are de service providers can be achieved by employing agents and ontologies, as proposed in B is natural that methodologies are being applied to master the problem of de the observed problem domain ( Sprinkle et al., 2009 ), but they usually have little programming experience. Domain-speci indeed use visual notation.
 driven engineering (MDE) ( Schmidt, 2006 ). A DSML's graphical syntax offers bene domains. The development of DSML is usually driven by language model de abstractions from the domain which need to be de fi ned in order to re de fi ned with a metamodel. The additional parts of a language model are constraints that de modeling environment. This modeling environment can be generated automatically if dedicated software is used (e.g. MetaEdit functions for implementing the semantics of DSMLs within a speci semantics ( Bryant et al., 2011 ).
 for the development of MASs. Hence, in this paper, we fi rst introduce a DSML for MASs with both its syntax and semantics de de fi speci
Semantic web Enabled Agent Modeling Language (SEA_ML). Our concrete motivation for SEA_ML is to enable domain experts to model their own MASs on the Semantic Web without considering the limitations of using existing MAS development frameworks (e.g. JADE ( Bellifemine et al., 2001 ), JADEX ( Pokahr et al., 2005 )orJACK( Howden et al., 2001 )). 5 , respectively. Section 6 discusses the methodology proposed for the MAS development based on SEA_ML, including its example the paper and states the future work. 2. Abstract syntax SEA_ML's abstract syntax.
 de fi a metamodel which covers those meta-elements that belong to Semantic Web enabled MASs. Reengineering of that metamodel enabled on both modeling the internal agent architecture and MAS organization.
 When the SEA_ML's metamodel is overviewed, one can detect that one of the main elements within the metamodel is the Semantic
Web Agent (SWA). A SWA works within a Semantic Web Organization (SWO) and can interact with various services. Another meta-element is the Semantic Web Service (SWS) which represents a web service (except agent service) de platform's agents.
 another meta-element called the Semantic Service Matchmaker Agent (SSMatchmakerAgent) which is a SWA extension. This meta-based on its facts within the scope of its roles. A SWA can associate with one or more Roles and change its Role over time. Kardas et al. (2009a) .
 the Ecore diagrams extracted automatically from the metamodels de Foundation, 2006 ) and formally speci fi es the metamodels. These metamodels constitute the abstract syntax within our study. discussed in the related work section of this paper. Furthermore, more speci also supported in SEA_ML syntax with individual metamodels. In fact, proposing speci
For example, Hahn ( Hahn, 2008 ) also presented sub-metamodels for the Plan and Role aspects while the Environment view was with distinct sub-metamodels although such an approach is not very common in MAS DSML proposals. Due to the generality included within the agent internal viewpoint of SEA_ML like many other MAS DSMLs. syntax in addition to easy interpretation and usage by the developers. For instance, updating speci speci fi c needs in the future.

All of the SEA_ML viewpoints are discussed in detail in the follo wing subsections. In each viewpoint's diagram, the elements light gray come from those other viewpoints which are shown at the top or bottom of the element using viewpoint (see Fig. 1 ). 2.1. MAS viewpoint can have one or more Roles that represent the organization's aims like trading, education, medical issues, and so on. 2.2. Agent internal viewpoint on the known facts. Semantic Web Agents can be associated with more than one Role (multiple classi data mining agent ( Haag et al., 2004 ). In addition, it can stop working in one organization and start to work in another.
As previously mentioned, SEA_ML's abstract syntax supports both reactive and BDI agents. While BDI agents are supported by maintain information about the state of its environment but simply reacts to current perceptions. In fact, automaton that receives input, processes it and produces an output 2.3. Plan viewpoint Fig. 3 . Sending a message to another agent or querying an ontology are two examples of Action. functions or methods in the target language. 2.4. Role viewpoint model entity and should be specialized in the metamodel according to architectural and domain tasks. An ArchitectureRole de de fi different agents.
 As can be seen in Fig. 4 , we cover Role types and their relations, as required within the whole metamodel. For example, the
RegistrationRole , which is a type of ArchitectureRole , is a crucial role type for semantic service registration. Speci the Semantic Web Services. Finally, an OntologyMediatorRole can be used with an agent to handle ontologies. 2.5. Interaction viewpoint
This viewpoint focuses on agent communications and interactions in a MAS, and de some Message submissions each of which should have a message type (msgtype) such as inform, request, or acknowledgment. Speci 2002b ). The Interaction element extends the FIPAContractNet element. The FIPAContractNet represents the IEEE FIPA's speci interactions of agents, which apply the well-known  X  Contract Net Protocol activity diagram using this entity.
 2.6. Environment viewpoint time, in case the Environment has new knowledge from different resources.
 about the weather can be  X  It is 30 1 C  X  . An agent can take this information to its Belief-base. Later, the fact world's facts. 2.7. Agent  X  SWS interaction viewpoint appropriate service discovery, agreement with the selected service and execution of the service are all de Furthermore, the internal structure of SWS is modeled inside this viewpoint.

We consider MASs and SWSs as two standalone systems, which can however interact with each other to realize automatic service discovery, negotiation, and execution. The agents are able to perform tasks automatically (interaction with service pro and the tool will generate the required documents for this agent service, which conform to SWS advertisement and utilization speci fi cations.

When considering the decision making duties of agents, SemanticWebAgent s apply Plan s for performing their tasks. In order to
Semantic web service modeling approaches, e.g. OWL-S ( Martin et al., 2004 ), mostly describe services using three semantic and execution dynamics of the service. Finally, Physical Grounding de (a.k.a. IOPE ( Martin et al., 2004 )) de fi nitions used by these Semantic Web Service components are also de the OWLClass meta-entity (shown as ODMOWLClass in Fig. 7 ) from the OMG's ODM ( OMG, 2009 ) as the base class for the semantic
WebService concept is also included within the metamodel and associated with the grounding mechanism. 2.8. Ontology viewpoint fact or an agent's belief is an ontological entity and they are modeled as an extension of the ODM OWL Statement from ODM. 3. Concrete syntax concrete syntax which maps the abstract syntax elements of SEA_ML to their graphical notations. and can be used for the General Purpose Languages (GPLs) such as C not have detailed modeling as much as in Eclipse GMF ( The Eclipse Foundation, 2006 ). modeling.

MetaEdit  X  ( MetaCase, 1995 ) is another widely-known tool. It is an integrated tool which includes metamodeling and modeling environments for a single user or multi-users during the tool evolution. MetaEdit is also based on a strong background with the support of the MetaCase Company. However, it is neither an open source nor free. limited concrete syntax. For example, the symbols can only have a single geometrical MetaEdit  X  , this tool is not an open source and free.
 bene fi cial components whilst developing software models. The at the meta-meta level. The second and third components are mapping component provides the mapping between meta-elements and graphical facilities. The new platform can be executed, by concrete syntax and related set of graphical modeling tools ( Getir et al., 2011 ). an Ecore fi le. The graphical notations for MAS, Agent Internal, Agent SEA_ML.

We decided that the elements of the same type or elements which inherit from the same element have similar icons and similar
SS_AgreementPlan, and SS_ ExecutorPlan which inherit from the Plan entity by holding the same tint and ground and adding the background; it also holds the Role icon, as illustrated in Table 4 .
 are used during the process of developing GMF tools. During this process, icons are determined for both palettes and agent developers can design models for each viewpoint of the required MAS conforming to the concrete syntax of SEA_ML. metamodel and the remaining originates from the GUI tool itself. So, these controls are divided and discussed in two parts,
Constraints  X  and  X  Graphical Tool Facilities  X  . 3.1. Model constraints constraints can be classi fi ed as follows: 3.1.1. Compartment constraint modeling method cannot be used between a Role and a SWA. 3.1.2. Number of relationships constraint
Due to one-to-one, one-to-many, many-to-many relationships in the Ecore, number of relationships are controlled between the one Agent Type. 3.1.3. Relationship source and destination constraint
The direction of the relationship de fi nes the source and destination of that relationship. This constraint is de 3.1.4. Inheritance relationship constraint in an instance model will include all of the attributes and relationships of its super-class. The Agent model, all of the relationships are inherited from the Plan element.
 Since the Interaction viewpoint has basic communication and messaging relationships, it does not have a compartment structure.
However, compartment constraint is used in all the other viewpoints which have the composition relationships between the meta-elements as the compartment's structure requires. 3.2. Graphical tool facilities
While creating the model, in addition to the constraints coming from the metamodel, SEA_ML's modeling tool has some editorial constraints which help the tool user during his or her design phase. These constraints are listed below: 3.2.1. Double clicking on key elements  X  transition between viewpoints fl 3.2.2. Keeping previous entities and properties in all viewpoints other hand, system metamodel should be considered as a whole model. Therefore, any de 3.2.3. Integrity of relationship-element constraint
SEA_ML viewpoints except the Organization viewpoint as it does not have any superclass relationship in its metamodel. 4. Model-to-model transformations: operational semantics for SEA_ML on the SEA_ML model instances at runtime, in order to obtain their counterparts in real MAS infrastructures. Model-to-code transformations follow these model-to-model transformations and
In this study, transformations between SEA_ML and the JADEX BDI agent framework ( Pokahr et al., 2005 , 2007 ) are de whilst the metamodels of JADEX ( Kardas et al., 2009b ), OWL and OWL-S are platform speci transformations between this PIMM and PSMMs pave the way for the MDD of the semantic web enabled MASs based on the OMG's well-known Model Driven Architecture (MDA) ( OMG, 2003 ).
 of executable agent plans take place. The declaration of static agent properties is given in systems.
 body. Furthermore, each agent has an ADF fi le, an XML-formatted de many systems, scalability to Web requirements, compatibility with Web standards for accessibility and internationalization and enumerated classes. We have adopted OMG's ODM ( OMG, 2009 ) as the metamodel of OWL and used it during the transformations as another target PSMM.
 essential types of knowledge about a service can be stored. Service Pro
Service are named as presents , described_by , and supports . The classes ServicePro ranges of these properties. Each instance of Service presents a ServicePro
After determining the entity mappings between SEA_ML and the ab ove discussed target PSMMs, it is necessary to provide model transformation rules which are applied at runtime on SEA_ML instances to generate platform speci ( Jouault et al., 2008 ) is one of the well-known model transformation languages which are speci syntax. An ATL transformation program is composed of rules that de initialize the elements of the target models. In addition, ATL can de onto models ( ATLAS Group, 2006 ). ATL also allows code factorization through the de These features of ATL caused us to prefer it as the impleme ntation language for the transformations from SEA_ML.
ATL is composed of four fundamental elements. The fi rst one is the header section which de transformations.

ATL is used for metamodels which have been developed based on the Eclipse Ecore meta-metamodel. Thus, SEA_ML's syntax has been de fi
BDI and OWL) and hence output models of the related MAS can be achieved after automatic execution of the de
In other words, we fed the M2M transformation based on ATL by employing the SEA_ML syntax (Ecore metamodel and the instance models conforming to the SEA_ML metamodel which are in the XMI format generated by our GMF-based supported, since all the models obey EMF/Ecore rules. Second, our target metamodels already own the de and application of transformations make use of these semantics for SEA_ML models, which constitutes the implementation of MASs modeled according to SEA_ML.

In order to provide some fl avor of the transformations, entity mappings for some of the SEA_ML viewpoints and de
JADEX metamodel can be found in Table 5 . Some meta-elements are used in two or more viewpoints but listed only in the related in Table 5 since it is considered in the Ontology viewpoint.

Another group of transformation rules can be exempli fi ed for the Agent transformation. The entity mappings between these metamodels are shown in Table 6 .  X 
SWSInteraction.ecore  X  fi le is the input for the transformation rules, which is denoted by the ecore  X  fi le is the output for the transformation which is denoted by the includes the rule entitled  X  SemanticWebAgent2Agent  X  .
 source metamodel properties are indicated with the  X  from
These helper rules are also used in Listing 2 (Lines 2 and 7). The transformed into their JADEX Agent counterparts in lines 5 and 6 respectively.
 the main rules supplies the usage of the same helper rules in different transformations.
Three types of helper rules were used in this study. The fi
Agent, it sets  X  AGENT_NAME_IS_EMPTY  X  as the name of the output changes it to a lower case, in case it is not.
 element is compared with the Plan and Capabilities relationshi p. If they match, it is decided that the element is a Goal. The elements.

The usage of all types of helper rules is exempli fi ed in Listing 2. In line 4, we can see that the obtained after executing the swagent ' s  X  setName  X  helper rule. The
SemanticWebAgent instance. The helper rule  X  part1PatternforSWA helper, that all the Semantic Web Agents are determined in the input model. The
The part1PatternforSWA helper rule determines whether there is an instance of the SemanticWebAgent in the input model which is the conditions, the helper rule returns  X  true  X  to the main rule; then, the main rule ful
The  X  fi nderPlan  X  ,  X  agreementPlan  X  , and  X  executorPlan are chosen and the patterns determined by using these helpers. For instance,
Agent, Process and Grounding instances and then the main rule transforms these elements to the target model. The is given in Listing 4 as an example.
 as a query result of the helper rule. Similar helpers are used to select the appropriate elements for SWS in pattern matching.
Listing 5 controls a SWS's relationships with its WebService, Interface, Process, and Grounding members. Lines from 2 to 5 are constraints for controlling a SWS's relationships with the related elements. If the input model element satis the target model are determined (see Table 6 ). Listing 6 shows the help to fi nd the related SWS, Input, Output, Precondition, and Effect elements.

Lastly, to give an example of ATL transformations in the Agent Internal viewpoint, the
Listing 7 control its relationships with the Role and Plan elements. If the input model element satis their similarity of the transformation rules.
 model of the MAS to be implemented. To do this, Ecore encoded model 5. Model-to-text transformations for code generation language speci fi cally designed for the transformation of models into text parsed, checked, and directly executed from the Eclipse environment.
 of these rules. Hence, we fi rst prepare the MOFScript rules and apply these rules on platform speci examples of the M2T transformation rules provided in this study.

When considering the JADEX structure, each agent should have an ADF which is an XML formatted plans in Java language. An ADF describes the structure of an agent. In other words, ADF de generation of both the ADFs and Java plan classes of each modeled agent.

A part of the MOFScript codes for creating ADF fi les is given in Listing 8 . The name of the M2T
JADEX Ecore path is given by the  X  in  X  keyword in parentheses in the in line 6. For example, if an agent, Agent1, has a name attribute associated with it, a between 7 and 9 represent a declaration of those namespaces which will exist in the ADF attributes of the Agents are declared in an ADF fi le using the codes between lines 10 and 12. Consequently, we obtain ADF
XML fi les, for each agent. The beliefs, plans, goals, and capabilities of the agents are represented in these
The code block given in Listing 9 represents goal de fi nitions in a generated ADF of goals inside the  X  o goals 4  X  tags. Related goal translation methods are invoked for each type of goal.
The code of translateAchieveGoal() method is given in Listing 10 as an example. All the attributes of
Corresponding methods for parameterSet and deliberation are invoked for each keyword parameter. JADEX Plan similar rules. As can be seen in Listing 11 , the generatePlanFile() method is triggered (Line 3), for each names are created by including the  X  .java  X  extension. Prede the rule has a similar working principle to that given previously in Listing 8 .

In addition to the creation of JADEX agents, another group of rules is de of ontology fi les. A Web Services Description Language (WSDL) service. As discussed in Section 4 , each OWL-S semantic web service is represented with a service pro fi le, service process, and service grounding o f this semantic web service are described in owl  X  ,and  X  grounding.owl  X  respectively. Finally, we also generate the corresponding WSDL services that have WSDL interfaces. As is shown in Listing 12 ,ontology keyword, an OWL-S Service fi le, an OWL-S Pro fi le fi le, an OWL-S Process lines 4  X  8. Through the MOFScript codes given in Listing 13 ,a  X  process  X  ,and  X  grounding  X  fi les of the SWS in question.

Similar to OWL-S production, OWL Transformations are implemented to generate ontology based on M2T transformations for these viewpoints extend ADFs and plan 6. MAS development methodology based on SEA_ML developers can visually design and implement their agent systems for various agent deployment platforms. The proposed MAS methodology based on SEA_ML includes three main steps (see Fig. 10 ) following each other: 1. System modeling, 2. Automatic transformation of the models, and fi nally 3. Code generation for exact MAS implementation. providing more accurate models. The result of this step is the developed platform independent (SEA_ML) model of the MAS.
The next step in the MAS development methodology based on SEA_ML is the automatic model transformation. The models created in the previous step should be transformed from platform independent level into the platform-speci
OWL-S models. The source models for these transformations conform to SEA_ML's metamodel as discussed in Section 2 and they are generic enough to be transformable automatically into different platform-speci collaboratively with the SEA_ML's MAS development tool, as discussed at the end of Section 4 .
JADEX fi les (including XML encoded ADF fi les and agent plans as Java
Grounding documents). Based on the initial models of the developer, these required.
 developer may intervene in this development process if he/she wishes to elaborate or customize the achieved artifacts. provide some fl avor of the use of this MDD methodology based on SEA_ML. 6.1. Case study: development of an agent-based stock exchange system the trading in this system. Some of these are investors, brokers, companies, stocks, trade on. Automating the interactions of these systems could make the trading more ef environment and these facts dynamically change during the lifecycle of a software agent. be able to have access to the trade information service. He/she should also be able to consult with a broker and human users.

Let us assume that some web services exist for fi nding, negotiating, and exchanging stocks on the trading market. The trading fl oor performs transactions in which bids and demands are matched according to speci architecture of such an agent-based stock trading system is depicted in Fig. 11 . 6.1.1. System modeling
Conforming to the SEA_ML-based MDD methodology, we start by creating system models according to different viewpoints. In this extensive discussion on the agent-based realization of ISE's trading procedures.

For this case study, we focused on three main viewpoints, namely, MAS, Agent internal, and Agent stock exchange system. The diagrams representing the models for these viewpoints are depicted in Figs. 12
According to the scenario mentioned above, we modeled the interactions and the trading process of the system using SEA_ML. We from the Agent  X  SWS interaction viewpoint.
 the semantic web agents of this case study worked within a semantic web organization named StockSystem. This main organization some resources in other environments. Therefore, they have interactions with the required environments in order to gain access Broker1 is an expert. Similarly, InvestorC refers to Broker2 to ask for his/her expertise ( Fig. 12 ). behaviors, plans, goals, and beliefs of the agent. It also contains all the plan types which would be used in the Agent viewpoint for discovering, negotiating with, and executing the candidate services.
InvestorA agent had a Capability called Stock including its Goals ( buying. The agent could also play Selling and Buying roles. The Selling role could realize its task over the InvestorFinding plan. Similarly, in the Buying role, the agent could adopt the  X  Business and Trading  X  and is initiated within an Active state.
 plan instances. Investor and Broker agents could be modeled with appropriate plan instances in order to with the TradeManager SSMatchmaker agent which has registered the services by applying the StockRecorder plan. As InvestorA e.g. the rate of exchange for a currency or the fl uctuation rate for a speci 6.1.2. Automatic transformation of the models completed by the developer at the end.
 next step. For this purpose, the output JADEX model can be modi attributes), and is then given within the model-to-text transformation to generate the code.
JADEX metamodel. Therefore, an automatic applicat ion of the ATL rules creates elements; for example while two types of ATL rules are executed for the Agent  X  Semantic Web Service part of the system (OWL-S metamodel), which helps to generate OWL-S documents. semantic web services are de fi ned in Lines 4 and 19 respectively. Process, Interface and Grounding are de 11, and 17; and for InfoService SWS in Lines 20, 26, and 32.

Listing 15. Part of the generated OWL-S instance model for the Agent 6.1.3. Code generation for MAS implementation intermediate models. The previously discussed model-to-code transformations ( Section 5 ) would be used in order to do this.
Artifacts gained as a result of the work on the Agent Internal viewpoint and the Agent in order to exemplify the generated code by the application of written MOFScript rules. The (XML) and Plan (Java) fi les. The second one not only generates JADEX
When the developer requests code generation for the platform-speci automatically executed on these models and an ADF fi le for each agent, e.g. InvestorA, and a plan the agent are generated. When considering our case study, part of the generated ADF capability, beliefs, and goals are de fi ned in Lines 6, 8 agent for looking up proper TradingService and InfoService SWSs.
When applying the transformation rules for Agent  X  SWS Interaction viewpoint, nine ADF
S fi les, four for each SWS (Service, Service Process, Service Pro transformation template fu nctions. The ADF and plan fi les generated from the Agent generated from the Agent Internal viewpoint for InverstorA agent.

An excerpt from an OWL-S Service fi le is given as an example of the generated SWS references to the Service Pro fi le, the Service Model, and the Service Grounding 39, 41 and 43 of Listing 17 cover these references for the Pro 7. Related work
Since the model-driven development of MASs is one of the major research topics in Agent-oriented Software Engineering (AOSE), researchers have proposed various agent metamodels and modeling languages which can guide the agent programmers during the are discussed in the fi rst subsection, while the remaining MAS DSL and DSML approaches are discussed in the second. 7.1. Agent and MAS metamodels and modeling languages
AALAADIN ( Ferber and Gutknecht, 1998 ) appeared as the fi have preferred to de fi ne agent metamodels which are speci 2002 ) MAS development methodologies and introduced a uni it should also be noted that they were not suitable for general MAS modeling since the proposed models were speci methodologies and mostly provided mappings to very speci fi implementation at all ( Pavon et al., 2006 ).
 relationships between agents, agent roles, and agent groups in a MAS. The speci
Uni fi ed Modeling Language (UML) 2.0 superstructure. However, with de
MAS development methodology. Moreover, ( Bauer and Odell, 2005 ) introduced the speci fact, they discussed which aspects of a MAS could be considered as the Computation Independent Model (CIM) and the Platform ( Kardas et al., 2009a ).
 and validation of these concepts was provided by their use at various MAS development methodologies. widely-accepted software modeling language, important MAS modeling studies are mostly based on the UML or provide agent-based notation. Graph transformation was used both on the level of modeling for capturing agent speci requirement speci fi cation and analysis.

Agent UML (AUML) ( Bauer et al., 2001 ) is perhaps the more well-known modeling language in the agent community. AUML presents semantics are represented with a metamodel and agent protocols are de overall protocol with UML package and template structures. The second layer de sequence, collaboration, interaction, and the activity diagrams and statecharts of UML. Finally, the third layer de research community, experiences have shown that its UML extensions also bring some de with other developers. Finally, AUML semantics is semi-formal and again based on the UML.
The Agent Modeling Language (AML) ( Cervenka et al., 2005 ) is another general modeling language for MASs. Based on the UML
However, utilizing all the different symbols of AML's notation is too complicated and dif textual notation and it lacks semi-formal semantics. 7.2. DSLs and DSMLs for MASs are described by metamodels which can be seen as representations of the main concepts and relationships identi related DSMLs and does not give the concrete syntax or semantics of the DSMLs. In fact, the study only de for the model-driven development of MASs.

Originating from a well-formalized syntax and semantics, Ciobanu and Juravle de mobile agents domain which completely differed from the speci which was structured into several aspects each focusing on a speci to provide a concrete syntax, the appropriate graphical notations for the concepts and relations were de
The semantics of the language were given in Hahn and Fischer (2009) . This study was noteworthy because it seemed to be the of Semantic Web enabled agents with other environment members like semantic web services. Our study contributes to the aforementioned efforts by also specializing in the Semantic Web support of MASs.
 also be modeled in SEA_ML.
 (MOF) ( OMG, 2002 ), the concrete syntax and its tool was provided with GMF ( The Eclipse Foundation, 2006 ), and
However, the developed modeling language was not generic since it was based on only the metamodel of one of the speci which proposes a technique for the de fi nition of agent oriented engineering process models and can be used to de et al. (2012) nor Fuentes-Fernandez et al. (2010) covered software agents in the Semantic Web.
By considering our previous studies, in Kardas et al. (2010) , we have shown how that domain-speci the complete infrastructure of SEA_ML including its syntax and semantics de used during the development of real MASs. 7.3. A comparative analysis of SEA_ML MAS development studies.

Since the evaluation presented in Kardas (2013) mainly concentrates on the MDD of MAS and does not consider the DSL/DSML grading ( ,  X  ,  X  X  ) for each criterion is given in parenthesis next to the related grade: preferred. For this criterion, a study is graded as  X  (not available), methodology and/or does not provide a complete metamodel) or various MAS platforms). we grade a related work as  X  (not available),  X  (at least textual or a graphical concrete syntax is de graphical concrete syntaxes are provided). viewpoints. Agent-internal (AIV), MAS (MASV), Organization (OV) and Interaction (IV) viewpoints, on which the agent research based on the viewpoint(s).
Kardas (2013) . For this criterion, a study is graded as  X  but it is too abstract and not implemented) or  X  X  (a complete model-to-model transformation phase in which entity mappings between models and the implementation of the written model transformation rules are all included). M2M and M2C transformability criteria, we check whether the approach/the study in question provides some kind of semantics for
MAS. For this criterion, a study is graded as  X  (generation of software codes from MAS models is missing), de fi ned but not implemented or transformations are incomplete and code generation needs too much intervention) or support for an automatic and a complete code generation from models for at least one MAS software development framework and generated template codes are executable).
MAS developers. For this criterion, a study is graded as  X  and/or extra mechanism is needed for the support of model transformation) or modeling, application of automatic transformation between models and generating MAS software codes from MAS models). evaluation since those studies solely cover metamodel derivation for agent systems and concrete syntax de MAS DSL/DSML proposals.
 other hand, SEA_ML and DSML4MAS ( Hahn, 2008 ) differentiate from the remaining studies by introducing general metamodels with in Section 7.2 of this paper. Finally, as far as we know, SEA_ML is the grade for concrete syntax de fi nition in Table 7 . 8. Conclusion
This paper presented a DSML called SEA_ML for MAS. 1 The speci issues.
 independent modeling to automatic code generation for MASs working on the Semantic Web. been greatly improved (from the example presented in Section 6 approximately 800 lines of code written in different ef fi cient as that written by a domain expert. However, DSMLs are not a panacea for all software engineering problems. DSMLs' main cannot be regarded anymore as a little language (see Sections 2 approach is assigning all of the properties of the super-class to the subclass manually. metamodel is not easy and one technology will be stronger than the others. The current SWS notion, related entities, and M2M due to its popularity and wide usage. However, since SEA_ML metamodel is platform independent, it is straightforward to de
M2M (and then M2T) transformations for the semantic web services modeled according to SEA_ML into other SWS technologies such as WSMO.

Our next work will consider the enrichment of SEA_ML's platform-speci transformations from SEA_ML's syntax to those platforms' models and, for the JADEX platform.
 Acknowledgments
This study was funded as a bilateral project by the Scienti 109E125 and the Slovenian Research Agency (ARRS) under Grant BI-TR/10-12-004. The authors also wish to thank the anonymous the paper signi fi cantly by taking these anonymous reviewers' critical comments into account. References
