 changes in the Internet age, much research has been done on how to store XML data in relational database management system(RDBMS) and how to query/process the XML data in RDBMS. The existing works have mainly focused on how to store and how to query XML data efficiently in native XML DBMS(database management system), object-relational DBMS(ORDBMS), or pure RDBMS. In particular, previ-ous studies[1][2][3] are about the technique which defines an element in tree-structured XML document to one node, and index the node. In case of [1][2][3], they new XML document insert or a new element insert. 
In most case, by the way, the XML data is a kind of tree data. However, the XML research community has given little attention to the traditional RDBMS-based encod-RDBMS-based encoding schemes, called Nested Interval[6], for storage and retrieval of XML data. Especially, our indexing technique can efficiently insert new XML data into the RDBMS that has been already stored XML document, which is impossible or very inefficient in the existing approaches, because the encoding and indexing should be rebuilt from the scratch when any update occurs in XML data. 
In this paper, we apply a relational nested interval encoding scheme for XML stor-has good performance for storing and querying XML data in RDBMS. This scheme is valid only in tree-structured data, not applicable to the general graph-structured data. 
This is the very limitation of our scheme. However, we believe that most XML data is currently represented as tree, thus our approach has wide applications. implementation of the nested interval encoding scheme. Finally, section 5 concludes with some future studies. case, an XML data is tree-structured, so, we introduce related studies how to store and RDBMS-based XML encoding scheme, called XPath Accelerator. For the lack of per[10]. -Adjacency List Model [5] : This model is the method to store a current node key and a parent node key to store tree-structured data. -Materialized Path Model [5] : In this model, each node stores the whole path to the root. Each node has a key value and the whole path to the root. -Nested Set Model [5] : In this model, each node indexed (lft, rgt) segment and these equals (root node's rgt)/2, and the difference between the (lft, rgt) values of leaf nodes whose (lft, rgt) numbers are between the (lft, rgt) values of their parent node. pre/post plane. 
These indexing models have good performance in common, but they must re-index partial document or whole document when a new XML document or element inserted. In this section, we suggest how to apply Nested Interval Model[6] to store XML data into RDBMS. Nested intervals generalize nested sets. Thus, from Nested Interval encoding, we can easily calculate Materialized Path. Consequently, we can exploit the advantage of each model. 3.1 Basic Structure represent a node by a rational expression in Nested Interval. We must represent infin-ity number for (lft, rgt) value, so this model uses rational number set. 3.2 The Mapping Fig.1 shows mapping segments (lft, rgt) of nested interval on two-dimensional plane. figure specific. Now, we decide the point of root nod (1,0) in Fig.1. This means that all nodes except root node locate between 0 and 1. And child node '1' of the root node map into (1,1/2), '1.1' is (1,3/4), and '1.2' is (3/4, 5/8). The rules are as follow. -RULE 1 : First child node (cx1, cy1) of a node (x,y) ; mid-point between (x,y) and (x,x) =&gt; (x+x/2, x+y/2) -RULE 2 : Next sibling node (fx1, fy1) of a node (x,y) ; mid-point between (x,y) and (py1, py1) of parent node (px1, py1) of (x,y) =&gt; (x+py1/2, y+py1/2) We can map all nodes into the two dimension plane with Rule (1), (2). As Nested Set model use (lft, rgt), a node (x,y) is (rgt, lft) in this model. So, we take the same advan-tages of nested set. Because all node have unique value (x,y) in nested interval model, we can consider only current node to insert, update, delete and we do not need to re-index any other node. And, Nested Interval can convert into Materialized Path easily. Moreover, because the sum of lft, rgt has a unique value, we can store numerator and denominator of the sum into RDBMS. Now, we describe how to implement Nested Interval indexing model in a commercial queries such as Xpath, and insert new XML data and new elements into existing XML document. All experiments were run on an 2.0GHz Pentium IV processor with 1GB of physical memory running Windows XP Professional. We used Oracle 10g for our experiments. Our XML data used [9] (The Plays of Shakespeare in XML). 4.1 XML Document Parsing We parsed XML document using JAVA SAX Parser[8] to Materialized Path. To store XML document, node information stores in NIXML table and contents of each node store in XDATA table like [3]. 4.2 Mapping Functions We implement some functions that maps Materialized Path into Nested Interval with an XML document to store RDBMS. Each function was coded using Java Class, and details of description are found in [10]. -Storing function group : x_numer, x_denom, y_numer, y_denom -Relation function group : parent_numer, distance, child_numer, ... -Path function group : path, path_numer, path_denom, sibling_number 4.3 Table Scheme and Data Insertion We create two tables for storing XML document in RDBMS and Fig.2 shows table schemes and insert query. 4.4 Inserting XML Document It takes the fixed time because our indexing technique has the advantage that it does not need to re-index when we insert additional nodes into RDBMS. Table.1 shows a result could obtain the result that the inserting time per each node is increase linearly. 4.5 Converting Xpath Queries into SQL Now we describe how XPath queries translate into SQL. Nested Interval index model can easily convert to Materialized Path. So, we can use advantages of each model. In other Xpath queries are presented in the technical report version of the paper [10].  X //TITLE/parent::ACT X  (XPath) =&gt; SELECT n1.* FROM NIXML n1, NIXML n2 -SQL(Using Materialized Path) : WHERE n1.node='ACT' and n2.node='TITLE' A ND n2.depth = n1.depth +1 AND n2 .path like n1.path || '.%' -SQL(Using Nested Interval) : WHERE n1.node='ACT' and n2.node='TITLE' AND distance(n2.numer, n2.denom, n1.numer, n1.denom) = 1 technique encode nodes with Binary Rational Number. But, binary encoding grows numerator and denominator value as text type. So, we can not calculate (numera-tor/denominator), if numerator and denominator number is very big. Unfortunately, as all commercial RDBMS are not support big integer(over 64bit), we should study alternative. We describe an alternative of this problem. RDBMS into XML storage to avoid re-indexing as updates occur in XML document. The Nested Interval model generalizes nested set so it provides the same advantages that we do not need to re-index partial or whole document as additional nodes inserted in RDBMS and we can find easily position values of each node by calling some func-RDBMS. In conclusion, Nested Interval model, which is proposed to store tree-structure data, can be used for XML storage as we have shown in section 4. 
However, our model encodes each node with Binary Rational Numbers and thus JAVA). Another alternative is Nested Intervals with Farey Fractions [7], but it can not convert to Materialized Path. To overcome the Binary Rational Number problem, how to store big integer into RDBMS is the next step in our research direction. 
