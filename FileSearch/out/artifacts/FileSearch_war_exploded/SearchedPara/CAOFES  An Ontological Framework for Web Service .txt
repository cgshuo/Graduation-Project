 Semantic web search involves re trieval of user-specific web artifacts by utilizing their semantic descriptions. A very specific web artifact that has evolved in recent times is web services . Web services can be semantically de scribed in languages like OWL-S. However, such languages are limited with respect to their expressivity of context. They also lack a formal ontological framework where efficient web service retrieval can be conducted. In this paper we m odel a service request scenario within the web as an event-driven system. Services as well as user requests are modeled as events. We propose an ontological framework called Context-Aware Ontology Framework for Events and Services (CAOFES) where such event-driven web service retrieval can be efficiently executed by a novel reasoning technique. H.3.5 [ Information Storage and Retrieval ]: Online Information Services  X  Web-based services Theory, Design, Performance Ontology, Semantic Retrieval, Web Service Composition Recent research efforts aimed at modeling a new form of Web service artifacts that are loosely bound to each other so as to define a logical network of de pendencies. The purpose of such artifacts is to achieve a desired user-oriented goal by collaborating with each other through automated remote invocations in specific sequences (known as workflows ). The platform where web services can be discovered, selected and composed into complex services is termed Service Oriented Architecture (SOA). Service composition requires that the participating web services are retrieved efficiently using the semantics of their descriptions. Th is can be done with conceptual specification called ontology where concepts can be defined in well-formed statements explicating their semantics. This led to the standardization of OWL-S [1]. The SOA is designed primarily as a pull-up system where web services are discovered based on some indexing strategy using service profiles and then selected based on their superiority over others in terms of effectiveness and mutual compatibility. The discovery and subsequent selecti on are triggered by user queries. Hence, efficient web service re trieval depends upon user query formalization and web service desc ription indexing. User requests and web services have some well-defined relations with each other. These relations along with the services and the user requests should be semantically formalized. Such semantic formalization helps an intelligent reasoning system to efficiently discover the required services given the occurrence of a particular user request event. This is the core essential for any sort of service composition process in the Web. However, extracting the required services for a given user query within a semantic framework is not a trivial task. In this paper we have elucidated the major problems in designing such a framework and then have proposed an ontology framework called Context-Aware Ontology Framework for Events and Services (CAOFES) that efficiently tackles these issues so as to provide a platform for context-aware user query processing. We ev aluated the CAOFES framework with respect to the runtime performance of user event processing over the CAOFES terminology. The rest of the paper is organized as follows: we briefly discuss previous works on ontological formalization of SOA-based systems in Section 2, we introduce the event-driven model in Section 3 and the CAOFES framewo rk in Section 4, Section 5 explains reasoning technique over CAOFES for user query processing, Section 6 shows e xperimental evaluation of the CAOFES framework, and conclusive remarks and indications for future work are drawn in Section 7 . Web service retrieval techniques based on ontology reasoning is a fairly new research area. A comparatively recent work on the topic can be found in [2]. The work comprises of developing a context ontology that is generic to all types of web services. The authors have argued that context is a set of controllable entities that are defined independent of the web services and whose state values are dependent on the behavi or of web services and users. However, the definition of context is not well formed from a syntactic and semantic perspectiv e. They also have notion of events, states and transitions, but have defined StateChangeEvent separate from the other types of events (viz. SignalEvent, Call/ReturnEvent etc.). This creates problems since any type of atomic event can be associated with some sort of state change. Defining entities in terms of state machines further aggravates the problem as that would mean that all time-variant entities (including services and user queries) should have corresponding elaborate state machines for the reasoner to retrieve web services. A similar work on web service retrieval was proposed in [3]. The authors have designed a MAS (multi-agent system) based retrieval architecture where software agents are capable of interpreting user queries and match them to web service descriptions that are semantica lly defined in ontology. However, agent based reasoning comes with a large network overhead cost when the number of agent type increases and the number of services within a web service network increases. A significant contribution to SOA-system driven ontology design was SOUPA [4]. However, there are some significant problems with the SOUPA design. Firstly, the concept definitions are not complete and precise. Secondly, importing concepts creates redundancy and possible cyclic definitions. Thirdly, some of the ontologies (e.g., Event and Action) have a number of semantic equivalencies and this may creat e definitional inconsistencies. Fourthly, the relations between th e ontologies are not defined in SOUPA and this restricts reasoning over SOUPA only to individual ontologies. Finally, there is no reasoning technique for web service retrieval solely based on the concept definitions. In our event-driven model [5], all user queries and services are modeled as events . We treat an event as an activity executed by some agent (i.e. the users and the devices in a web system) in order to bring about some changes in the states of the world. A state change for an activity has to satisfy two conditions so that the activity can qualify as an event: (a) it has to be notable by an agent, and (b) it has to invoke a defined interpretation to an agent. An activity has significance to a web system only when it can be detected and identified by the system. An activity can be associated two types of states  X  initial state and final state. The initial state is the system state at the time point when the activity starts while the final state is the system state at the time point when the activity ends. The activity by itself may be interpreted by a system in several differe nt ways or may not even be interpreted at all under specific situations. Interpretation of an event follows from the perception of the change in states that is triggered by the event. A state of an event is the set of time variant vectors that describe the system within which the web services work. We term the states as activity context . Activity Context is a vector space having five distinct context element vectors: (i) the background context ( B specifies state information of entities around the place of execution of an activity, (ii) the object context ( O the entity getting affected by the execution of an activity, (iii) the activity (i.e. the agent profile and capabilities) and also the passive agent who receives the activity (i.e. the agent profile), (iv) relative location with respect to a specific address where an activity can occur, (v) the temporal context ( T year, month, morning, afternoon, evening and night when an activity can occur. However, there are state values for an event that do not change but carries specific interpretation for an agent. In the context of web service this is evident for se rvices that are context-sensitive. For an example, an online transaction service if invoked from a place in Europe asks for payment in Euro but if invoked from the US asks for payment in USD. The user request is treated as an event where the activity is transacting . The activity is notable by the service as there is a change in the initial state of the submit button from inactive to active. The change carries the interpretation to the service that there has been a transaction. However, there may be no change in the context element vector that specifies the location of the us er. Even then the value of this vector influences the behavior of the service in specific manners. For an example, a purchasing service asks payment in USD instead of Euro for transaction in USA. As the agents that interpret user events are distinct from the agents that execute the user ev ents we can therefore partition a web service system into two domains: system field and environment field . Agents within the environment field do not only act as executors of user requests but also as interpreters of the services in the system field. From the perspective of the environment field all services within the system field are therefore activities, some of which carry specific interpretation for the environment field agents. Thes e activities therefore qualify as events to those agents. As servi ces and user activities are defined as events they have their specific context vectors. We term them service context vector and user context vector respectively. Thus, context-sensitive web services can be described in terms of their functionalities and their contexts. We can model any service in a The service functional vector (shortly functional vector) comprises of four functional vector elements: (i) input that specifies the input parameters of a service, (ii) output that specifies the output parameters of a service, (iii) pre-condition that specifies the logical constraints that are needed to be satisfied for a service to be invoked, and (iv) result that specifies the all logical implications that are satisfiable by all possible service outputs. It is to be noted that a service event is the scalar equivalent of the service vector. In the CAOFES framework, for the Web, the agents that interpret user activities with the user contex t vector are the various devices that host web services and in the same way web services are interpreted as events by users and other services. The services are discovered on the run based on such interpretation and produce a result event that has a specific interpretation to the user agent. We term an event that provokes such reaction as an initial event (i.e., a user event) and the result that is produced as an effect as target event . The service(s) that gets triggered by the initial event is called the source service while the service(s) that results in the target event is called the end service . The organization of services is basically a service composition process that we term as event-handling and it will be further described in Section 5. In CAOFES, we established we ll-defined relational connection between the core ontologies. None of the core concepts are cyclic in CAOFES. As CAOFES requires newer concept additions to be consistent with these definiti ons hence, it guarantees acyclic terminology all throughout. In [5 ] we discussed the essential formalism required for understanding a service event and a user event with respect to the agents within a web domain. However, these formalisms require a semantic foundation in order to conduct efficient user query processi ng. In order to provide such a platform we developed a framework called Context-Aware Ontology Framework for Events and Services ( CAOFES ). CAOFES is a collection of five core ontologies: (i) Context Element Ontology (ii) Activity Context ontology , (iii) Activity Constraint ontology , (iv) Event ontology , and (v) Field ontology (Fig. 1). Apart from these define d ontologies we use the primal ontology OWL-S for describing the service functional vector Other upper level ontologies such as OpenCyc [6] can be imported as the framework grows and equivalent concepts are needed to be incorporated in the core ontologies. We now formally describe each of the four ontologies in terms of Description Logics notations. The Context Element Ontology (named as OntoContextElement ) is a DL terminology that houses the semantic definitions of the in [5]. The root concept Context Element ( CE ) is defined as a primitive concept. It can be further classified into the five corresponding vector element concepts B , O , A , S , T . Each of these concepts can be further classified. It is to be noted that the concepts are generally borrowe d or derived from upper level ontologies such as OpenCyc, SUMO. OntoContextElement is the building block of the other core ontologies defined within CAOFES as all the other core ontologies can be related to each other through this ontology (Fig. 1). The Activity Context Ontology (named as OntoActivityContext ) is a DL terminology that houses the se mantic definitions of concepts follows: a9 hasElement A B S O S A S S S T bc de where B , O , A , S , T corresponds to the vector elements. The existential quantifier in the above definition leaves it open for the ontology designer to introduce other filler concepts such as QoS parameter concepts like network latency, throughout, bit error rate etc. for more specific application domains. CV is the root concept of OntoActivityContex t. The instances of CV are the states . The context element vector A is responsible for executing events (both services and user query events). We define a necessary condition for the concept A as follows: 
A a 8 e x ecute s A E where E is the event concept defined in the Event Ontology in Section 4.4. The context vector concept CV can be further classified into the concept notability vector (NV) and the concept event context vector (ECV). We define NV and ECV as follows: CCN is the causal constraint and SCN is the state constraint defined in the Activity Constraint ontology (see Section 4.3). This The NV and the ECV concepts cover the CV concept. The ECV can be further classified into user event context vector (UECV) and service event context vector (SECV). The UECV is the OntoActivityConstraint ) is a DL terminology that comprises of the semantic definitions of the di fferent kind of constraints that govern the behavior of agents executing events. We define constraint ( CN ), as follows: The above definition reflects the fact that the domain of interpretation of the constraints fo r any event is the same as the context vector elements. In other words, constraints can be specified in terms of concepts derived from one or more of these five vector elements. We assume that constraints are always formalized in the CNF (Conjunc tive Normal Form). The CN concept can be further classified into three kinds: (i) causal constraint (CCN), (ii) state cons traint (SCN), and (iii) stimulus constraint (ZCN). The CCN concept specifies the causal condition required for an event to be an effect of other event(s). We define CCN as follows: The SCN concept specifies the initial state condition required to be satisfied for an event to occur. We define SCN as follows: The ZCN concept specifies the pos t-conditional stimuli given by a causal event in order to trigger other event(s) as its effect. We define ZCN as follows: From the above definition we can see that ZCN is a model concept of the concept CCN. Hence, any constraint instance that satisfies the definition connects tw o events with a causal relation  X  the one that is an interpretati on of the ZCN as the cause and the one that is an interpretation of CCN as the effect. The Event Ontology (named as OntoEvent ) is a DL terminology that comprises of the different kind of events including user events and services that may be identified within a particular system (or field). The root concept event ( E ) is defined as follows: `a where F is the concept field defined in The concept E can be further classified into two concepts: (i) user event (UE) and (ii) service event (S). We define them as follows: environment field defined in Field ontology (see Section 4.4). UE is semantic equivalent of  X  u a . is the system field defined in Field ontology (see Section 4.5). S is the semantic equivalent of  X  s a . P is the semantic equivalent of the service functional vector P jjjjjjjjjjjj k . We define the concept P as follows: 
P  X  8 hasElem ents A In S Ou S Pr S Re bc where In , Ou , Pr , Re are the service profile concepts defined in OWL-S. OntoEvent connects itself to the agen ts that interpret it. Hence, it helps the reasoner to understand th e relation between events (both user query and services) for de ducing possible dependency. The moment an event instance is recognized as UE the CAOFES automatically defines it by connecting the event to the notability vector concept ( NV ) defined in OntoActivityContext. This definition connects the event to all the context vector elements that are needed for defining the notability and also to the agent(s) (and hence, the service) that interprets it. Hence, a causal definition is established between an UE and S if and only iff the antecedent of the following rule is valid: Rule 1: The predicates defined in the above rule correspond to the relations defined in the above mentioned ontologies. The Field Ontology (named as OntoField ) is a DL terminology that defines and classifies the world in which events occur. The root concept field ( F ) is defined as follows: The concept F can be further classified into two sub concepts: (i) system field ( SF ) and (ii) environment field ( EF ). We define the each of them as follows: 
SF  X  b A F bc T 8 hasExecuters A D `a where D is the service hosting device agent s.t. D  X  b A A
EF  X  b A F bc T 8 hasExecuters A U S D bc de where U is the user agent s.t. U  X  b A A Ontofield connects OntoEvent with the agents executing specific events defined. It further helps to reason about the type of event (a user event or a service event) by verifying the type of executer. The problem of user query based se mantic web service retrieval is not trivial. This is primarily because ontology reasoning is computationally expensive. Even simple subsumption reasoning over DL propositions can be intractable [7]. CAOFES framework is a pragmatic approach where these problems are eliminated. In the encoding technique proposed in [8] ontology hierarchies have been treated as DAGs. We propose an independent sharing encoding, called Prime Code Exchange Scheme (PCES), of each of the five core ontologies that can support efficient service retrievals described in Section 5.2. The PCES scheme is to encode the relationship between two concepts across the core ontologies by exchanging of their prime codes. For example, consider two concepts C 11 and C 21 It is to be noted that only a unique type of relation is defined between each pair of the core ontologies in CAOFES. It is because of this reason that exchange of codes within a pair is a unique operation. This means that there cannot be more than one such exchange within the same pair. Exchange of codes results in a cumulative concatenation of the imported code with the existing code. This cumulated code is stored a separate element in a field called color . For an example, if two concepts C and C 31 in Ontology 3 are related then code ( C (color( C 31 )) and code( C 31 ) = memberOf (color( C concept C 32 in Ontology 3 is related to C 23 in Ontology 2 then code( C 32 ) = memberOf(color( C 23 )) and color( C {code( C 31 )||code( C 32 )}, where  X  X | X  symbolizes concatenation. Such a concatenation always results in a unique value as the constituent prime codes are unique. The color field is uniquely defined for two core ontologies over which the exchange takes place. This means that if a given concept C 23 in Ontology 2 is related to two concepts C 11 in Ontology 1 and C 31 in Ontology 3, then C have two different elements in its color field (i.e., {code( C code( C 31 ))}. The color field elements of a particular concept are indexed according to the prime code of the corresponding least specific concept with which th e concept is related. Thus, color(C 23 ) will be stored as two separately indexed elements of the field as shown in Fig 2. The three types have been designed for the query processing: Query Type 1 : Given a user request UE i, find the source services (services that are triggered by UE i, ). For an example, in the case of tour booking service there may be several services involved such as customer authorization service , payment validation service , hotel reservation service , car reservation service , trekking reservation service etc. For a particular user request book tour X, the source service is customer authorization service . All the service instances that authorize customers are to be retrieved. Type 1 reasoning is the simplest of all the three types of reasoning discussed in this paper. This is because Type 1 reasoning involves the user query events to be mapped are always existing, the reasoner finds out the service concept that is connected to the user event concept through the relation triggers . Query Type 2 : Given a target event E j, find the end services (services that trigger E j, ). In the above example the customer receipt service is the end service that results in the target event tour X booked and all such service instances are to be retrieved. Type 2 reasoning involves processing of queries of the form: (Q type2 , &lt;NV Ej, &gt;) where NV Ej is the notability of the target event E . The notability is expressed in terms of the five contextual elements defined in OntoContex tElement (Section 4.2). Once we identify the notability vector concept then we look into the corresponding color field (i.e. indexed by the prime code of the S concept from the OntoEvent ontology (Section 4.4)). The color field provides the prime code of the service concept that is connected to the notability vector concept via the relation notabilityOf . It is to be noted that a particular notability vector concept cannot be connected to more than one service concept via the same relation notabilityOf . All the instances defined within the resultant service concept are essentially the answer to the query. Query Type 3 : Given a user request UE i and a target event E find the services S i that are required for handling UE example for the user request book tour X and the target event tour X booked there are several intermediary services ( payment validation service , hotel reservation service , car reservation service , trekking reservation service ) that when composed in certain order lead from the source service customer authorization service to the end service customer receipt service . Type 3 reasoning involves processing of queries of the form: (Q reasoning in the initial level. This results in a set of source service instances and a set of end service instances. The objective now is to test Rule 1 (Section 4.4) for all services that can form a path from each of the source service to the end service. We have to check whether the source service has any triggers relation with any other service concept. The first clause is tested as has been explained in Type 2 reasoning prev iously. However, in this case we start from the notability elements of the source service. Once the notability vector concept is id entified the reasoner then checks the service concept that interpre ts the notability. This again is done by finding the value in the corresponding color field of the notability vector concept. It is to be noted that a particular notability vector concept can be connected to only one service concept. This is because a notab ility vector concept connected to a service concept means that the service concept reacts in a certain manner after interpreting the notability vector concept. Thus, for a particular notability concept signifying a particular interpretation there cannot be two reactions. The service concept so identified may be the responsive service to the source service. However, to confirm this, the reasoner needs to check whether these two servi ce concepts have dependencies. It looks up corresponding color field (i.e. indexed by the prime code of the CCN concept from OntoActivityConstraint (Section 4.3)) of the resultant service concept. The color field gives us the prime code of the causal constraint concept that is connected to the resultant service concept. We then check the color field of the source service concept that has been indexed by the prime code of the ZCN concept from OntoActivityConstraint. This field gives the prime code of the stimulus concept that is connected to the source service concept. Once this has been found we check whether the ZCN concept satisfies the CCN concept. If satisfiability is confirmed then Rule 1 is valid and we select the resultant service concept. We re peat the process by taking this resultant service concept as the source and finding the next resultant service. We go on until we find the end service concept. The intermediate resultant service concepts are basically the set of services that form the service composition path. Each of the concepts houses services that are functionally similar. Ontology 1 Ontology 2 Ontology 3 The composition path is the soluti on to Type 3 queries. It should be noted that there may be services that are collectively the cause of a single responsive service and services that are collectively responsive to a single causal servi ce. This implies that Type 3 reasoning can be branched-out tracing where a single source service concept may be connected to more than one notability vector (NV) concept. Each of these NV concepts may be connected to different responsive service concepts. Again, several NV concepts that are notability of different causal services may be connected to the same responsive service concept. Overall, in order to process these three types of queries the reasoner needs to establish causal dependencies between UE s and S s and between S s themselves. A causal relation (i.e. triggers ) is defined according to Rule 1 the moment an E instance is verified to be UE . Hence, processing Type 1 queries becomes relatively easy compared to processing of Type 2 queries in CAOFES. For the Type 2 query processing, it takes time to find the most specific service that is satisfied by the given target event. Processing of Type 3 queries require further reasoning over CAOFES. This is because it involves Type 1 and Type 2 reasoning and then finding all possible paths of services from the source to the end service such that an edge between two services represents a causal relation (i.e . triggers). Establishing causal relations requires verifica tion of Rule 1 (in which UE is replaced by S ) for each of the edges connecting two services over all possible paths from the source service to the end service. As evaluation we observed the r untime performance of Type 1, Type 2 and Type 3 reasoning. Th e experimental platform was a machine with CPU cycle of 1.4 GHz and RAM of 2 GB. The development platform was NetBean s IDE 6.0.1 with Java as the coding language. We first genera ted a CAOFES TBox. We then encoded the CAOFES TBox according the encoding technique described previously. The objectiv e was to observe the runtime performance of each of the reasoning processes using the PCES scheme (Section 5.1) involved in answering the three query types. For each of the query types we fired several query instances within a range of 100  X  1000. These queries were linearly queued up in order to be fed into the CAOFES reasoner system. We recorded the scalability of the r easoner in handling these queries. In Fig. 3, Type 1 reasoning show ed the least execution time with an upper bound of approximately 3 msec. Type 2 reasoning showed an execution time upper bound of approximately 7.5 msec. Type 3 reasoning showed th e highest runtime with an upper bound of approximately 27 msec. The overall performance of the reasoning system seems very efficient. In this paper we have proposed the COAFES framework for efficient web service retrieval. We have shown how the three types of retrieval queries can be efficiently processed using a prime encoding exchange scheme . As mentioned web service retrieval is an implicit phenomenon within the process of service composition. Thus, we believe th at CAOFES framework is very efficient in the event-driven service composition of SOA systems. As a future work we would like to compare our evaluation results with queries written in conven tional semantic query languages such as SPARQL [9] over the CAOFES framework. In addition, there will be other required reasoning problems that need to be tackled within the COAFES framework. One such reasoning is selecting the best composition pa th which includes a heuristic reasoning to achieve the best targ et event when an initial event occurs. We leave this work as a future endeavor. This work has been partially supported by National Science Foundation (IIS #0742666). [1] http://www.w3.org/TR/2004/REC-owl-features-20040210/ [2] Z. Jin, L. Liu.  X  Web Service Retrieval: An Approach Based [3] Y. Xu, J. Shen and Z. Chen,  X  Ontology-based Information [4] H. Chen, F. Perich, T. Finin, A. Joshi,  X  SOUPA: standard [5] S. Dasgupta, S. Bhat, Y. Lee, An Abstraction Framework for [6] http://sw.opencyc.org/ [7] F. Baader, D. Calvanese, D. McGuiness, D. Nardi, P. Patel-[8] D. Preuveneers and Y. Berbers.  X  Prime numbers considered [9] http://www.w3.org/TR/rdf-sparql-query/
