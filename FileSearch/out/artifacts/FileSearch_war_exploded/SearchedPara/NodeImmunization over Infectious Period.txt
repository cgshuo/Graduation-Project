 Locating nodes to immunize in computer/social networks to con-trol the spread of virus or rumors has become an important prob-lem. In real world contagions, nodes may get infected by external sources when the propagation is underway. While most studies for-malize the problem in a setting where contagion starts at one time point, we model a more realistic situation where there are likely to be many breakouts of contagions over a time window. We call this the node immunization over infectious period (NIIP) problem. We show that the NIIP problem is NP-hard and remains so even in directed acyclic graphs. We propose a NIIP algorithm to select k nodes to immunize over a time period. Simulation is performed to estimate a good distribution of k over the time period. For each time point, the NIIP algorithm will make decisions which nodes to immunize given the estimated value of k for that time point. Ex-periments show that the proposed NIIP algorithm outperform the state-of-the-art algorithms in terms of both effectiveness and effi-ciency.
With the advent of the Internet, everyone is connected. This en-ables the data generated by any user to be easily accessed by other users all over the world. Despite the convenience and ease in shar-ing information, this has also led to the fast propagation of virus in computer networks as well as rumors in the information net-works. For example, when the Malaysia Airlines Flight 370 was reported missing on the morning of March 8th 2014, millions of messages flooded the social network. A message saying "Flight MH370 has resurfaced and landed safely in Nanming, China." re-ceived millions of shares before it was proven to be a rumor. This is not only a waste of resources in information dissemination, but also causes confusions as well as panics in a very short time. In order to reduce the impact brought about by such epidemics, re-searchers study the problem of node immunization: Given a graph, which nodes should we immunize so that the maximum number of nodes will remain healthy under attacks? In computer networks, a computer is healthy if it is not infected with some malware and in social networks, a user is said to be healthy if he/she does not share/re-tweet any rumor message. In the former case, immunizing a node may mean the shutting down of certain host servers, while in the latter case, this could mean the suspension of a user X  X  account.
Existing works have mostly focused on immunizing nodes before the virus/rumor starts spreading [8, 18, 19]. Recently, the realiza-tion is that it is more practical and meaningful to identify nodes to immunize while the attack is underway. Zhang et al. [20] in-vestigated the problem of node immunization with the awareness of infected nodes. They present a polynomial-time heuristic algo-rithm called D AVA that constructs a dominator tree . They aggregate the infected nodes into one node as the root and examine the paths from the root to each node. A node u is a child of node v if every path from the root must traverse v to reach u . Thus, with the domi-nator tree, we can say that any descendant of node u in the tree will be healthy if u is immunized. Given this observation, they itera-tively select the node that maximizes the expected number of saved descendant nodes. Once selected, this node and its descendants are removed and a new dominator tree is constructed and the process is repeated to select the next node for immunization.

However, we recognize that when an attack happens in the real world, there is a time period where multiple independent sources may actively infect different nodes [15]. This infectious period is often observed in the early stage of a contagion [3]. For example, mendacious messages about MH370 X  X  safe landing in Nanming were posted by many users independently, citing different websites, in the first six hours of its attack. This will create a problem when the resources available for immunization are limited.

We will illustrate this issue with an example shown in Figure 1(a) where u 1 is the initial infected node (marked in red). Suppose the infectious period is 2 time points and u 8 becomes infected at the second time point. We also assume we only have enough resources to immunize 2 nodes. Looking at time point 1, we would choose u and u 3 and save the nodes colored in green (Figure 1(b)). However, when u 8 becomes infected at time point 2, we have no resource to immunize additional nodes, as a result, the saved nodes are once again infected, leaving us with only 2 healthy nodes (Figure 1(c)). On the other hand, if we immunize only u 3 at time point 1 and then immunize u 7 at time point 2, we would have 4 healthy nodes at the end as shown in Figure 1(d). This shows that a good immunization strategy should consider the entire infectious period on the whole when making decision as to which nodes to immunize.

In this work, we formalize the problem of node immunization over an infectious period. We show that our problem is NP-hard and present the NIIP algorithm. Our assumption is that the re-sources available for immunization are limited, that is, we only have resources to immunize k nodes. Hence, we propose a simula-tion-based approach to estimate how k should be distributed over the infectious period. At the same time, we design a scoring func-tion to model a node X  X  immunization ability in the network. Based on the estimated value of k at time point t , denoted as k k nodes with the highest scores for immunization at time point t . After immunizing these nodes, we consider the new infected nodes and update the scores of all the affected nodes. The process repeats until we have selected k nodes to immunize. We conduct extensive experiments on several real world datasets covering computer net-works, information networks and social networks to demonstrate the efficiency and effectiveness of the proposed NIIP algorithm. Our experimental results show that NIIP clearly outperforms the state-of-the-art D AVA algorithm.
 The contributions of this work can be summarized as follows:
In this section, we define the node immunization over infectious period (NIIP) problem and provide an analysis of the problem.
We consider a directed, weighted graph G = ( V; E ) as the input graph. For each edge ( u; v ) 2 E , there is a probability p senting the probability that u passes infection to v . Apart from get-ting infected via network connections, healthy nodes have a proba-bility of getting infected from external sources during the infectious period, and newly infected nodes can, in turn, infect their neigh-bors and propagate the contagion. To model this, we introduce two parameters and , where denotes the probability that a healthy node gets infected by some external sources, and denote the num-ber of time points where a healthy node can be infected by some external sources and 1 t . Our goal is to find a set of nodes to immunize such that the expected number of healthy nodes at the end of the propagation is maximized.

D EFINITION 1. NIIP problem. Let G = ( V; E ) be an input network where V is the set of nodes and E is the set of edges. Each edge ( u; v ) 2 E has an infection probability p uv . Let I be a set of infected nodes at time point t where 1 t , and be the probability that a healthy node is infected by an external source. We define ( A 1 ; A 2 ; ; A ) to be the number of nodes that remain healthy if the nodes in A t are immunized at time point t . Our goal is to find sets of nodes, A 1 ; A 2 ; ; A , such that  X 
Note that the Data-Aware Vaccination (DAV) problem defined in [20] is a special case of the NIIP problem with = 1 and = 0 . Table 1 summarizes the notations used in this paper.

Next, we show that the NIIP problem is NP-hard, and even when we restrict the problem to directed acylic graphs (DAG), the prob-lem remains NP-hard.
 T HEOREM 1. The NIIP problem in Definition 1 is NP-hard. P ROOF . (Sketch.) Zhang et al. [20] has shown that the Data-Aware Vaccination (DAV) problem is NP-hard. Since the DAV problem is a special case of NIIP problem with = 1 , we see that if there is a polynomial time solution to NIIP problem, we can set = 1 and solve the DAV problem in polynomial time. In other words, the NIIP problem is NP-hard.

T HEOREM 2. The NIIP problem restricted to a directed acyclic graph is NP-hard.

P ROOF . We show that the base case of NIIP problem on a di-rected acyclic graph with p uv = 1 for any ( u; v ) 2 E , = 1 and = 0 is NP-hard. If the base case is NP-hard, then the general NIIP problem on directed acyclic graph must be NP-hard. To prove that the base case NIIP problem is NP-hard, we first show that the decision version of the problem can be reduced from its function version in polynomial time and then we prove the decision version of the problem is NP-hard.
The decision version is stated as follows: Is there a subset of nodes A in a DAG where j A j = k such that ( A ) in Definition 1 is greater than a given value? Clearly, given a directed acyclic graph with n nodes and the infected nodes are I 1 , there are at most j
V j j I 1 j possible values for ( A ) . If we can solve the decision version in polynomial time, then the solution to our problem is the set of nodes that gives the largest ( A ) value.

Next, we show that the decision problem on a DAG is NP-hard by reducing it from the k-densest subgraph problem, namely, de-termining a k -node subgraph with at least p edges in a given graph [2]. Given an instance G = ( V; E ) ; k; p of the k -densest subgraph problem, let n = j V j and m = j E j . We can construct a directed acyclic graph G  X  = ( V  X  ; E  X  ) of (1 + n + m ) nodes and 2 m edges as follows. We first create a source node s in G  X  . For each node u in G , we create a corresponding node u  X  in G  X  and connect s to u each edge e ( u; v ) in G , let u  X  and v  X  be the corresponding nodes of u and v respectively. We create a node e  X  in G  X  and connect u v to e  X  . Let Y 1 = f u  X  1 ; ; u  X  n g and Y 2 = f e  X  1 ; ; e V Figure 2 shows an example of the construction from graph G to G . It is clear that the construction can be done in polynomial time.
Next, we prove that the k -densest subgraph instance is satisfiable if and only if there exists a subset A Y 1 where j A j = k such that ( A ) ( k + p ) .

For the only if direction, suppose the k -densest subgraph in-stance is satisfiable, that is we have a subgraph with k nodes and at least p edges among them in G . Let A Y 1 be the set of nodes in G  X  that corresponds to these k nodes. When we remove the nodes in A from G  X  , there are at least p nodes in Y 2 in G  X  that become isolated from s . These p isolated nodes correspond to the p edges in the k -densest subgraph solution. Thus, by immunizing the k nodes in A , we have made p nodes healthy. Hence ( A ) = ( k + p ) .
For the if direction, suppose the NIIP problem is satisfiable, i.e., 9
A V  X  such that ( A ) ( k + p ) . Assume j A \ Y 1 j = l and j
A \ Y 2 j = ( k l ) . Nodes in Y 1 can possibly immunize nodes in Y while immunizing nodes in Y 2 can only immunize themselves. This means the nodes in A \ Y 1 immunize ( k + p ) ( k l ) = ( p + l ) nodes in Y 2 in order for A to immunize ( k + p ) nodes in total. These p + l nodes in Y 2 correspond to the edges in G whose both end points are in A \ Y 1 . Thus we have found a subgraph in G with l k nodes and at least p edges among them. In other words, the k -densest subgraph instance I is satisfiable.
Given that the NIIP problem is NP-hard, we use a combination of simulation-based and greedy approach to solve the problem. Figure 3 shows an overview of the main steps in our proposed approach. Given a network graph, we first extract a maximum DAG from the graph. We then perform a Monte Carlo simulation to estimate the distribution of k over each time point t in given the probability of a healthy node being infected. Next, for each time point t in , we compute a score for each node that reflects the node X  X  immunization ability. Suppose the estimated distribution of k at time point t is k t , this implies that at time point t , we need to select k nodes to be immunized. Hence, the top k t nodes with the highest scores are selected and the scores of the affected nodes are updated. We repeat this process for each t in .
 The details of each step are given in the following subsections. We first discuss how to select the best k t nodes at a given time point t . Then we describe how to perform simulation to estimate the distribution of k over the time points. Based on this estimated distribution of k , we design a scalable NIIP algorithm to select sets of nodes to immunize at each time point t .
Different nodes have different immunization abilities depending on the network structure and the infected nodes. The D AVA rithm models this with a dominator tree. Figure 4 shows the dom-inator tree constructed for Figure 4(a) given u 1 is infected. Based on the dominator tree, if we can only immunize 2 nodes, the D algorithm will choose u 3 and u 4 instead of the preferred choice u and u 3 . This is because the dominator tree does not capture the joint effect when two or more nodes are immunized. If only u immunized, none of the nodes can be saved. However, immunizing both u 2 and u 3 will result in the saving of 5 nodes. To model this joint effect, we introduce the concept of immunization ability of a node. u
Consider the example in Figure 5(a), where each edge ( u; v ) is labeled with the probability of node u infecting v , denoted as p We see that u 9 has two parents u 6 and u 7 . If we immunize u u can still be infected by u 7 or via some external source. To mea-sure the protection gain to u 9 by immunizing u 6 , we first compute the probability that u 9 does not get its infection from either u u . This is given by 0 : 2 . The probability that u 9 is not infected by u 7 is 1 0 : 6 = 0 : 4 . Hence, the gain by immunizing u 6 is 0 : 4 0 : 2 = 0 : 2 . We term this the immunization ability of u 6 over u 9 .

Let parent ( u ) denote the set of parents of a node u and child ( u ) denote the set of children of u . We model the immunization ability of u over the rest of the nodes as a vector r u . The v th denoted as m uv , represents the immunization ability of u over v . m uv is given as: m
Intuitively, this makes sense because when node v has many par-ents, even though u is immunized, all the other parents of v could still pass the infection to v . Hence, in this case, the m should be small. On the other hand, if node v has only two parents, when u is immunized, the probability of v getting infected is much lower. In other words, m uv value should be large. Note that when v has only one parent u , m uv = 1 (1 p uv ) = p uv . Also, for any node u , m uu = 1 . Note that when we compute m uv , we do not need to know whether there is a path from u to v . If there is no path from u to v , m uv will be 0 since v cannot pass its immunization ability along its ancestors to u via the computation.

For each node u , we compute the immunization ability of node u over the rest of the nodes in a vector, i.e. r u , as follows: where e u is a unit vector with its component corresponding to u being one and elsewhere being zeros.

Figure 5(b) illustrates the computation of r u vector for each node. Assume u 1 and u 2 are the infected nodes. The susecptible nodes are [ u 3 ; ; u 8 ; u 9 ] . Traversing this in the reverse order, we start with u 9 . Since u 9 has no children, r u 9 has a  X 1 X  on the 9 th column and zeros elsewhere. Similarly for r u 8 with a  X 1 X  on the 8 th column. Next, we come to u 7 . The immunization ability of u over u 9 is m u 7 u 9 = (1 0 : 5) (1 0 : 5) (1 0 : 6) = 0 : 3 , thus we have r u 7 = 0 : 3 r u 9 + e u 7 , as shown in Figure 5(b). Similarly, we compute m u 6 u 9 = (1 0 : 6) (1 0 : 5) (1 0 : 6) = 0 : 2 . Note that m u 7 u 9 &gt; m u 6 u 9 makes sense since p u 7 This implies that the gain obtained by immunizing u 7 is greater than immunizing u 6 .

With this, we can now compute the score for each node u :
Algorithm 1: S-NIIP algorithm
Given a graph G and the set of infected nodes I t , our goal is to select the top k t nodes with the greatest scores. We first obtain the set of susceptible nodes S by performing depth first search start-ing with each node in I t . Then we apply the A CYCLIC algorithm [9] to find the maximum directed acyclic graph (DAG) in S . In this process, some edges may be removed. The edges that are re-moved would be the outgoing edges of the nodes that point to some earlier nodes in the DAG. These earlier nodes would have already been infected and hence the removal of such edges hardly impacts the analysis. With the DAG, we fix a topological order where nodes are ordered such that each edge in the graph originates from an earlier node to a latter node in . We traverse each node and compute its score in the reverse order of . This guarantees we will compute the score of a child node before computing the score of its parent. The node with the highest score is marked as immunized . The scores of its parent nodes need to be updated as they have one less child whom they can potentially infect, and hence, their im-munizing ability is reduced. In addition, the descendants of u will be affected. For a node v 2 child ( u ) , if u is v  X  X  only parent, we mark v as immunized since the only infection path to v is from u which has been immunized. For those nodes w 2 child ( u ) with more than one parents, their parents X  scores need to be updated too.
The details of S-NIIP algorithm is given in Algorithm 1. Given the set of infected nodes I t , we first obtain the set of susceptible nodes S and find the maximum DAG (Lines 2-4). Next, we com-pute the vectors as well as the scores of the nodes in S in a reverse topological order (Lines 5-11). We select the node with the highest score and call the function Immunize ( u ) to mark u as "immu-nized" and place the the parents of u into the U pdateList (Lines 12-16). For each node in the U pdateList , we call P rocessU pdate to recompute the score for the node and propagate the effect to the parent nodes if they are susceptible (Lines 25-29). The process is repeated till k t nodes have been immunized.

Consider the example in Figure 5(a). The infected nodes are u 1 and u 2 , i.e. I 1 = f u 1 ; u 2 g . The set of susceptible nodes well as the scores for the nodes in S and select the node with the highest score, i.e. u 6 for immunization (See Figure 5(b)). After immunization, u 6  X  X  parents u 3 and u 4 lose one child and we put u 3 and u 4 into U pdateList . Its child u 8 is  X  X mmunized X  as well since u 8 has only one parent u 6 . Its child u 9 has not been  X  X m-munized" because it still has u 7 as a parent. Since u 7 becomes the only parent of u 9 , it is also placed in U pdateList for updates. Now U pdateList = f u 3 ; u 4 ; u 7 g . We first update r notice u 7  X  X  parent u 5 2 S is not in U pdateList , hence we insert u 5 into U pdateList . We then update r u 4 and remove u 4 from U pdateList . Since u 4  X  X  parents u 1 and u 2 are not in S , we do not put u 1 or u 2 in U pdateList . Similarly for u 3 , we update r remove u 3 from U pdateList . This process causes r u 3 , r and r u 7 to be updated as marked in red in Figure 6.
When an infection happens over a time period, putting all the available resources at the start of the infection is not a good strat-egy as shown in Section 1. We note that the number of nodes we should choose to immunize at each time point is influenced by the initial set of infected nodes I 1 and the rate of infection from exter-nal sources . Given a large I 1 set, we would want to select more nodes to be immunized earlier on so as to prevent the spread of in-fection from I 1 . On the other hand, when we have a large value, we would want to reserve more quota to later time points.
We perform a Monte Carlo simulation to decide how to distribute the limited resources k over the time point t in . We generate lists f I 1 ; I 2 ; ; I g of randomly infected nodes where I [ {new infected nodes by I t 1 and by external sources with prob-ability }. Then we apply the S-NIIP algorithm to get the top k nodes for each list of infected nodes. We process these lists in in-creasing time order, i.e. from I 1 to I . When all the lists have been processed, we examine each node in the top k results correspond-ing to time point . If the node has appeared in the top k results of an earlier time point, we tag the node with the earlier time point label. The number of the nodes that are tagged with time points T ; T 2 ; ; T forms an instance of the distribution of k over . We repeat the process 1000 times and take the average to obtain an estimated distribution of k over .
 Figure 7 shows the estimation process with k = 4 and = 3 . When t = 1 , we retrieve the top 4 nodes based on the infected node list I 1 and tag them with T 1 . At the next time point, we produce a new top-4 list regarding to I 2 . Here node u 2 is selected for im-munization and we mark u 2 with T 2 . Note that if the same node appears in multiple time points, we mark it with the earliest time point. Similarly in time point t = 3 , we mark u 4 with T wards, we select the last set of top-k nodes and count the number of markings for each time point. In this example, 2 nodes are selected in time point 1 while one node is selected in time point 2 and 3 re-spetively. This creates a sample of [2 ; 1 ; 1] . We repeat the process 1000 times and choose the average number of nodes appearing in each time point as an estimated distribution of k over . (a) t = 1 With the estimated distribution of k over , we extend the S-NIIP algorithm to allow for the selection of k nodes to immunize over a time period. A naive extension is to call the S-NIIP algo-rithm repeatedly for each time point in with a different k sponding to the estimated k at time point t . However, this is not scalable as the number of nodes whose scores need to be updated increases significantly when the number of infected nodes grows.
A careful study reveals that the immunization ability is great-est when it is from a parent to its immediate child. To reduce the number of updates needed, we model only the direct immunization ability between a parent node and its children nodes. We divide the children of node u , child ( u ) , into two sets, C 1 and C 2 such that the nodes in C 1 have only u as their sole parent, while the nodes in C 2 have multiple parents besides u . The direct immunization ability of node u , denoted as r  X  u , is computed as follows: where e u is a unit vector with its component corresponding to u being one and elsewhere being zeros.

Let us illustrate the computation of r  X  u with the same example network in Figure 5(a). Vectors for u 6 , u 7 , u 8 and u same because they have no grandchildren in the network. When we compute r  X  u 3 , since u 3 is one of the parents of u m u 3 u 6 e u 6 to r u 4 . However, u 3 no longer has immunization abil-ity over u 8 or u 9 as they are not the direct children of u direct parent u 6 has multiple parents besides u 3 . Hence we com-pute r u 3 = m u 3 u 6 r u 6 + e u 3 . The final direct immunization vectors are shown in Figure 8(a).

Algorithm 2: NIIP algorithm
Algorithm 2 details how we incorporate the direct immunization vector computation to select the top k nodes over time points. We first estimate the distribution of k in Line 1. We then apply A
CYCLIC algorithm to extract a maximum DAG in G and find a topological sorting in Lines 2 and 3. We find the suscepti-ble nodes in Lines 5 and 6 with depth-first search algorithms and compute their direct immunization vectors in the reverse order of (Lines 7 and 8). The ComputeV ector () function is given in Lines 25-35. When we reach each node, we update its parent set as well as its parents X  children set (Lines 26-33). We then compute the vector following Equation 4 and the score following Equation 3. At each time point, Lines 10-17 take in the newly infected nodes and set their scores to zero. Line 14 puts their parents in U pdateList as they loses a direct child as well as their corresponding immu-nization ability. Line 16 computes the score for nodes that newly become susceptible. Function P rocessU pdate  X  () processes the nodes whose vectors need updates (Lines 36-41). Since we merely consider direct immunization, we propagate the change only when a node has a single parent as indicated in Line 39. This enables the P rocessU pdate  X  () function to end much faster compared to P rocessU pdate () in S-NIIP algorithm. Lines 18-22 select k nodes at time point t and we repeat the process for times.
Consider the example in Figure 8(a). Initially u 1 and u 2 infected i.e. I 1 = f u 1 ; u 2 g . The set of susceptible nodes are nodes in S and select the node with the highest score, i.e. u immunization. Its parents u 3 and u 4 lose one child and we put u and u 4 into U pdateList . Since u 7 gains more immunization abil-ity from u 9 because of the immunization of u 6 , we insert u U pdateList for updates. Now U pdateList = f u 3 ; u 4 ; u that all nodes in U pdateList do not need to propagate their updates to the parents because they have multiple parents. Hence only three vectors are changed as marked in red in Figure 8(b). Note that r is not updated in this case while it is updated in Figure 6. This is because u 7 is not the only child of u 5 and does not propagate the update. The updated vectors are illustrated in Figure 8(b).
Assume in the next time point, we realize u 7 is also infected as illustrated in Figure 8(c). We update S as the set of nodes that are susceptible as S = f u 3 ; u 4 ; u 5 ; u 9 g . For nodes in parent ( u i.e. u 4 and u 5 , they lose the immunization ability over u we put u 4 and u 5 into U pdateList to re-compute their vectors with Equation 4. The updated scores are shown in red in Figure 8(c).
Complexity analysis. In S-NIIP, we first perform a DFS traver-sal of the nodes in O ( j V j + j E j ) time and find a DAG with the largest number of edges maintained in O ( j E j log ( j V a node is immunized, we trace back to all the ancesters of the af-fected nodes and update their corresponding vectors. In the worst case, we update each vector of every node and hence its time com-plexity is O ( k t ( j V j + j E j )) if we select k t nodes. In NIIP algo-rithm, the initialization takes the same time complexity as S-NIIP, i.e. O ( j V j + j E j ) for DFS traversal and O ( j E j log ( extraction. When a node is immunized, we update the vector of its parents and propagate the change if the parents only have one par-ent. This process costs O ( j V j ) in the worst case. Similarly when new nodes get infected, the propagation of updates is dealt with in O ( j V j ) . In practice, a node with only one parent is likely to be a leaf node and will not be chosen for immunization as it only immu-nizes itself. Hence on average, the propagation of updates in NIIP can finish rather quickly as shown in the experiments in Section 4.
In this section, we perform comparative experimental evaluation of the various methods for node immunization problem using real world datasets covering both computer networks and information networks.We implemented the algorithms in Python 2.7. The ex-periments are carried out on a 2 Xeon E5440 2.83 GHz CPU with 16 GB RAM.
Datasets. We conduct experiments on the following real world datasets. Table 2 summarizes the datasets used.

All networks follow a power law distribution of degrees. The nodes in Twitter tend to have higher degrees due to the ease of following a user in Twitter with more than 80% of them having 20 edges or more. The nodes in Pig , Economy , and Oregon have smaller degrees with more than 60% of the nodes having degree 1 . http://snap.stanford.edu/data/memetracker9.html http://topology.eecs.umich.edu/data.html http://an.kaist.ac.kr/traces/www2010.html In the MH370 dataset, the edges are formed by retweeting behavior and hence the nodes X  degrees are small (80 % of the nodes have degree less than or equal to 2). The CDFs of the two large datasets Twitter and MH370 are given in Figure 9. In our experiments, we randomly select 100 users in Pig , Oregon and Economy and 1000 users in Twitter and MH370 to form the initial infected nodes I
Parameters. is the number of steps that we are allowed to assign our immunization nodes. is a small probability that de-cides the fraction of healthy nodes getting infected by independent sources. We set = 10 and = 0 : 05 in all our experiments. In our experiment, we set a uniform propagation probability 0 : 6 [21]. On each dataset, we conduct our experiment 1000 times and take the average.

Evaluation Metric. We measure the effectiveness of the various methods by defining a metric called Save Ratio (SR) which gives the ratio between the reduction in infected nodes when k nodes are immunized over the number of infected nodes with no immunized nodes. We denote the set of infected nodes when nodes in A are immunized as Immunized ( A ) .
 Note that the value of SR directly correspond to our objective func-tion ( A ) , i.e. higher SR ( A ) represents a higher ( A ) value. However, the value of SR will fall in [0 ; 1] where 1 indicates a full immunization of all healthy nodes while ( A ) value is not bounded.

Comparison Methods. We compare the performance of the fol-lowing methods:
In this section, we show the effectiveness of the proposed meth-ods on node immunization tasks.

Results when = 1 and = 0 . In this set of experiments, we set the time period to one ( = 1 ) and assume there is no exter-nal source of infection ( = 0 ). This setting reduces our problem to the DAV problem proposed in [20]. Figure 10 shows the per-formances of the various algorithms. In all datasets, S-NIIP gives the best performance while NIIP is a close runner-up. The narrow gap between these two algorithms demonstrates that it is sufficient to model the immunization ability based only on the direct parent-child relationships. We also observe that both NIIP and S-NIIP outperform DAVA. This shows clearly that it is advantageous to take into account the joint immunization effect of multiple nodes. In general, algorithms which take into account the infected nodes (namely, S-NIIP, NIIP, DAVA) perform better than those which pre-emptively choose nodes for immunization confirming that it is good to perform immunization while an attack is underway.

In the Pig and the Oregon graphs, S-NIIP and NIIP outperform the state-of-the-art methods by more than 20% when k is large. We note that for these two datasets, they have a small number of nodes with high out-degrees. These nodes are good candidates for immu-nization. As a result, when k is small, all the algorithms pick this small set of nodes to immunize and their performances are similar. However, as k increases, S-NIIP and NIIP rapidly outperform the other methods.

In the three larger datasets, S-NIIP and NIIP manage to outper-form all the other algorithms even when k is small. We observe that in these datasets, the networks are composed of multiple clusters and the positions of the infected nodes are critical to the selection of immunization nodes. Pre-emptive methods like N ET S HIELD B
ETWEENNESS and P AGE R ANK could not effectively utilize such information and hence perform poorly. As for the D AVA algorithm, it constructs a dominator tree from the infected nodes. If a node has multiple parents, the D AVA algorithm will link this node directly to the ancestors of its parents and therefore ignore the immunization ability of its parents. As a result, the performance of Dava suffers. We observe that S-NIIP outperforms D AVA by 45% in Twitter and 27% in the MH370 dataset.

Results when = 10 , = 0 : 05 . In this set of experiments, we perform node immunization over 10 time points. For pre-emptive methods P AGE R ANK , B ETWEENNESS and N ET S HIELD , we sim-ply run them with the given network structure as they do not con-sider the set of infected nodes as input. For the D AVA algorithm, we give the final set of infected nodes I as input. This allows the D
AVA algorithm to have the complete picture of infection nodes before making its selection of k nodes. Figure 11 gives the results. We see that the overall SR value is less compared to the graph in Figure 10. This is because introducing an infectious period implies we have a much larger set of infected nodes. Hence even if we increase the number of nodes for immunization, the overall perfor-mance decreases. As expected, pre-emptive methods give the worst performance; while the NIIP algorithm is the clear winner and out-performs all the other methods significantly ( +30% ) in all datasets. This shows that the immunization strategy adopted by NIIP is the most effective in immunizing the nodes that lead to the largest num-ber of healthy nodes in the network.

Effect of distributions of k . In this set of experiments, we ex-amine how the distributions of k affect our results. We compare three strategies for assigning k : Results are shown in two datasets, Economy and MH370 . Fig-ure 12 demonstrates that while the estimated distribution of k has the best performance, uniform decision also achieves good results in Economy dataset. However in MH370 , the NIIP-U NIFORM is clearly not as good as NIIP-E STIMATED . In both datasets, choos-ing the k nodes after time points hugely impact the performance, indicating it is an effective method to prevent propagation of infec-tion by immunizing nodes as soon as we observe infections in the network.
In this section, we report the runtime of the algorithms on the larger datasets. Table 3 shows the running time for S-NIIP, NIIP, D
AVA and N ET S HIELD on the three larger datasets in the case of = 1 ; = 0 . We see that NIIP can produce outputs within the shortest time. In the smaller graph Economy , D AVA performs faster than S-NIIP but as the graphs grow larger, D AVA runs slower. This is because D AVA needs to re-generate the dominator tree when each node is selected which requires a near-linear time algorithm. For S-NIIP, it requires near-linear pre-processing time while the worst case for updating the scores is in linear time.
There is vast amount of literature on node immunization prob-lem to prevent the spread of virus/rumors. Most of the existing strate gies select nodes to immunize before the start of an epidemic [4, 7, 8, 14]. Abbassi and Heidari [1] consider nodes with high degrees and betweenness values tend to be good candidate for im-munization. Tong et al. [17, 18] and Wang et al. [6, 19] analyze the topology of an arbitrary graph and found the larger the first eigen-value of the graph is, the easier for the virus to propogate. Hence, they identify the nodes and edges whose removal would minimize the largest eigenvalue of the graph. They show that their methods are more effective than centrality-based methods. Cohen et al. [8] propose a heuristic acquaintance immunization strategy, which is further studied in [4]. They select the random acquaintances of random nodes, in which case high degree nodes will be more likely to be selected. Experiments show that their strategy can greatly reduce the immunization threshold from 80% to 40% . All these works propose pre-emptive strategies for immunization without the awareness of infected nodes.

The work in [20] points out that taking into account the infected nodes to make decision about whom to immunize is more practical and meaningful. They formalize the problem of Data-Aware Vac-cination problem given the initial set of infected nodes and propose the DAVA algorithm to select k nodes to immunize. The DAVA algorithm integrates the infected nodes into one source node and generates a dominator tree of the graph starting from the source node. It then exams the children of the source node and see which child has the largest number of expected nodes to be infected un-der the Susceptible-Infected-Recovered model [11]. The algorithm greedily chooses one node at a time but it ignores the joint immu-nization ability of multiple nodes.

Tong et al. further extend their work in [21] by considering the probability of infected nodes not being detected and propose a sam-ple based algorithm to handle uncertain data. They utilize the D algorithm to find the nodes for immunization. Note that our method can be directly utilized in place of D AVA under such an uncertain setting. A related work that also aim to limit the spread of misin-formation in social networks given the contagion source is in [5]. Instead of choosing nodes for immunization, they assume the nodes they choose can propagate the truth such that any node which has received the truth will no longer believe in the rumor. Their strategy is to choose the nodes that can reach the largest number of people. Although these works consider the initial infected sources of either rumor or virus, they do not consider the possibility of nodes getting infected independently during a certain period. Our work is the first to address the node immunization problem over an infectious period.
In this paper, we have modeled a realistic situation in real world contagions where healthy nodes have a certain chance of getting infected from sources outside the network and proposed the prob-lem of node immunization over infectious period. We have shown that this problem is NP-hard in both arbitrary graphs and directed acyclic graphs. The S-NIIP algorithm has been developed to take into consideration the joint immunization effect of multiple nodes. We have also presented the NIIP algorithm that strategically im-munizes k nodes over a time period. Extensive experiments have been conducted and demonstrated conclusively that our algorithms outperform state-of-the-art algorithms significantly. Future work includes applications to real-time control of rumor propagation in Twitter or extending our model to consider users X  credibility and trustworthiness. [1] Z. Abbassi and H. Heidari. Toward optimal vaccination [2] Y. Asahiro, R. Hassin, and K. Iwama. Complexity of finding [3] R. Bandari, S. Asur, and B. A. Huberman. The pulse of news [4] L. Briesemeister, P. Lincoln, and P. Porras. Epidemic profiles [5] C. Budak, D. Agrawal, and A. El Abbadi. Limiting the [6] D. Chakrabarti, Y. Wang, C. Wang, J. Leskovec, and [7] P.-A. Chen, M. David, and D. Kempe. Better vaccination [8] R. Cohen, S. Havlin, and D. ben Avraham. Efficient [9] D. Erd X s, V. Ishakian, A. Lapets, E. Terzi, and A. Bestavros. [10] M. Haghir Chehreghani. An efficient algorithm for [11] H. W. Hethcote. The mathematics of infectious diseases. [12] H. Kwak, C. Lee, H. Park, and S. Moon. What is twitter, a [13] J. Leskovec, L. Backstrom, and J. Kleinberg. Meme-tracking [14] N. Madar, T. Kalisky, R. Cohen, D. ben Avraham, and [15] S. A. Myers, C. Zhu, and J. Leskovec. Information diffusion [16] L. Page, S. Brin, R. Motwani, and T. Winograd. The [17] H. Tong, B. A. Prakash, T. Eliassi-Rad, M. Faloutsos, and [18] H. Tong, B. A. Prakash, C. Tsourakakis, T. Eliassi-Rad, [19] Y. Wang, D. Chakrabarti, C. Wang, and C. Faloutsos. [20] Y. Zhang and B. A. Prakash. Dava: Distributing vaccines [21] Y. Zhang and B. A. Prakash. Scalable vaccine distribution in
