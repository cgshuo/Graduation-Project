 This paper proposes and solves a novel type of spatial queries named Subject-oriented Top-k hot Region (STR) queries. Given a sub-ject S defined by a feature set R and features importance denoted by weights, an STR query retrieves k non-overlapping regions that have the highest scores computed by the number of feature objects and their weights. As an example, the culture subject is defined by exhibition halls, libraries and museums. On the subject, an STR query finds cultural centers intensively distributed feature objects. In this paper, we propose two efficie nt algorithms, single-partition (SP) algorithm and dual-partition (DP) algorithm, to process STR queries. Extensive experiments evaluate the proposed solutions un-der a wide range of parameter settings.
 H.2.8 [ DATABASE MANAGEMENT ]: Database applications X  Spatial databases and GIS Algorithms, Performance hot region, top-k, spatial query Spatial query processing has widely been applied to Geographic Information System(GIS), location-based services, the facility lo-cation, etc. Typical spatial queries involve: (1) fundamental queries including the spatial point queries, spatial join, range queries etc. [4]; (2) some complex queries such as nearest neighbor and reverse nearest neighbor queries [8]; (3) advanced queries based on spa-tial attributes, including site rankings and density queries used to locate facilities, spatia l decision support appli cations [3, 9, 11]. In this paper, we study a new type of spatial queries, named Subject-oriented Top-k hot Region (STR) queries defined by def-inition 1. A query region is a square with l q  X  l q and the length of a square can be a user-specified parameter. We assume l where l is the line length of grid cells.

Definition 1. (Top-k Hot Region Query) : Given a query region q , subject S . Top-k hot region query retrieves k non-overlapping regions that have the highest subject region scores computed by the number of feature objects and their weights.

Consider an example, we hope to find some cultural centers in a city. Domain experts have provided us the knowledge for defin-ing a culture center. The knowledge describes what spatial objects are considered as features of a cultural center and their importance evaluation contributing to the culture center. Assuming features on this subject include exhibition halls, libraries and museums, and their weights are 0.5, 0.3 and 0.2 represented by different sym-bols as shown in figure 1. For a square region r , we compute the score according to the numbers of feature objects and their weights. Figure 1 indicates top-3 hot regions are A, B and C with highest scores 1.4, 1.3 and 1.0 respectively. an STR query retrieves overlapping regions with the highest scores at an arbitrary location.
A typical application of STR query is to evaluate the develop-ment of regions on any subject. Also, it can help us to locate ser-vices and facilities considering multiple features. STR queries are important in geographic information systems, location-based ser-vices, and spatial decision support systems.

Despite the usefulness of STR query, to our knowledge, it has not been studied in the past. The challenge of the problem is to rank regions at any location by multiple feature datasets. The in-tuitive way is to move a square-shaped window in the space, and to accumulate the scores of all locations by feature objects falling in this window. If there are N feature objects in the space, the ba-sic way will examine N 2 locations, which will spend excessive I/O and CPU cost. As discussed in related work, existing methods can not be applied to solve the problem directly.

As a ranking problem, a progressive processing is an efficient strategy, which first initializes k candidates, updates candidates and prunes the searching regions gradually. The processing efficiency is dominated by two factors including the quality of k candidates and the size of the searching region. Therefore, the targets of this paper are to get k candidates with as high scores as possible and to reduce the searching region.

We propose two efficient algorith ms, single-partition (SP) algo-rithm and dual-partition (DP) algorithm, to process STR queries. Based on a single partitioning, th e paper introduces a filtering-refinement algorithm. The algorithm sorts extensive regions by their scores. To get high  X  k , SP algorithm first visits regions with high scores, which improves the processing efficiency. Further-more, we explore an optimized algorithm (DP) based on the dual-partition to the space. DP algorithm executes a fine partition on candidate regions intensively distributed feature objects, and shrink candidate regions further by cutting borders not containing results. DP algorithm improves by reducing the searching region and pro-viding a tight pruning bound.

The paper also reports on extensive experimental studies of the proposed algorithms. The results denote that DP algorithm offers an improvement of a factor of in terms of I/O, compared with SP algorithm.
The object ranking is a popular retrieval task in various appli-cations. [9] processes the problem of ranking top-k sites (ser-vice facilities, e.g., supermarkets) based on their influence on fea-ture points(served objects, e.g., residential buildings). The influ-ence of a site p is defined by the sum of weights of feature points considering p as their nearest site. The optimal location queries in [3] retrieves the optimal location in a space based on an ob-jective function. Top-k spatial preference query is a kind of site ranking queries [10].Site ranking queries evaluate the quality of a single point location, not a region, according to surrounding fea-ture objects. However, STR queries evaluate a region by sweeping a square window in the space.

Density queries [7] find regions with a high concentration of objects. The density query is used for monitoring moving objects and identifying regions with traffic jams. STR query is a ranking problem, however, density queries find regions whose density are not lower than a threshold.

Clustering algorithms [1] group objects into clusters by some criteria. Clustering does not focus on the ranking of groups and clusters have non-fixed size and shape. However, STR queries rank regions with a fixed size and shape. As the extension of clustering problems, hot spots detection finds point-event patterns [2]. In hot spots detection, the event frequency or attribute values, e.g., tem-perature or pressure can be evaluated for clustering hot spots. How-ever, hot region queries evaluate a region by feature object numbers and their weights defined by a subject.
We use the grid index to keep the statistics information of fea-ture objects. The information can provide the pruning mechanism. Given a query region q , we can define an extensive region grid index that contains q . If the score of an extensive region less than the score  X  k of k  X  th current candidate, then generate any result.

The whole space is divided into non-overlapping cells. Cell denotes the cell on the i row and j column position. For each cell c , we only maintain numbers of feature objects falling in c by object numbers and weights of related features. We can con-struct bounds by these scores to prune regions that can not generate results. Each feature dataset is indexed by a single R-tree.
For one cell c i,j , we define an extensive region C i,j as definition 2. Extensive region C i,j of cell c i,j is the union of cells that con-tains cell c i,j . C i,j is obtained by extending the breadth of one cell on both width and length, whose size is ( l q + l )  X  ( l
Definition 2. (Extensive Region) : The extensive region C cell c i,j corresponding to q is the union of cells c u,v i  X  u  X  ( i + l q /l ) and j  X  v  X  ( j + l q /l ) .

Here, we introduce a sweep procedure named as Sweep( C , q which returns a region r with the highest score  X  r in C ,and larger than  X  k . If a candidate can not be found in C , a null region is returned. This is a fundamental process for any algorithm proposed later. The algorithm first sorts objects by coordinate x . Then, we move query window from left to right and from bottom to top. At any location, when an object passes the sweep lines (the left and bottom lines of a query window), we count the number of objects and their types, and compute the score. If the score  X  q is larger than the current maximal score  X  max ,then q is assigned to sweeping all location, the algorithm returns r .
We will propose a filtering-refinement algorithm by using a sin-gle granularity grid. The filtering phase finds top-k candidates in extensive regions. The output of this phase is a list of grid cells of the same sizes as the query region size. The refinement phase find top-k results.

The algorithm examines every extensive region of cells in the order from left to right and from bottom to top to find top-k non-overlapping regions as candidates. For each extensive region cell c , the algorithm computes the score  X  C of C .If  X  C than  X  k , it is possible to get a candidate in C . Then, SP executes a sweep procedure to find a region r with the highest score in If the score of r is larger than the k  X  th candidate and does not overlap with candidates, the algorithm inserts r into result list and delete the k  X  th candidate. If r overlaps with r i and larger than  X  i , then update r i with r .Otherwise, r is discarded.
At the refinement phase, the algorithm finds the results accord-ing to the candidates generated at the filtering stage. As discussed above, to output one region in an extensive region will generate overlapping results. In order to find non-overlapping results, we need search a global highest score region k times. After finding a result, the algorithm removes the region of the result, and searches the remaining space to find the next result.
In this section, we will introduc e a method, Dual-Partiton algo-rithm(DP), to improve the processing of STR queries. Algorithm 1 illustrates the details of DP. First, DP sorts 4-cell extensive regions by score descending, and then groups extensive regions with high scores into clusters. For each cluster, the algorithm iteratively calls function SweepCluster . After obtaining k candidates and  X  perform the second clustering, and calls function SweepCluster for searching the other regions.

Before each stage, DP groups connected extensive regions into clusters, and searches in each cluster. DP executes the clustering procedure twice. The first clustering forms some groups that can generate k candidates. When the area of MBRs is larger than times of the query region, this clustering ends. Next, in these clus-ters, we finds k candidates. Then, we cluster the other extensive regions whose scores are larger than  X  k .
Algorithm 1 : Dual-partition Algorithm(DP) input : query region q , grid index, feature objects. output : k results sorting 4-cell extensive regions by score descending L C ; initial clustering for k candiates; for each cluster G do clustering extensive regions whose scores are larger than for each cluster G do
Similar to density-based clustering method [6], an extensive re-gion cluster combines all connected extensive regions whose scores exceed a threshold  X  . An extensive region cluster G is represented by the minimum bounding rectangle of all extensive regions in Figure 2 shows 3 clusters G 1 , G 2 and G 3 are created, where is a single 4-cell extensive region, G 2 is formed from 4 extensive rectangle boundary similar to MBR in R-tree. In G 1 and G non-overlapping at most candidate can be output respectively, and G 3 can generate 4 candidate at most. Therefore, in this example, three clusters can create 6 candidates. For each cluster G , we partition its MBR by a fine granularity. For instance, a cell is divided into 4  X  4 cells, cluster ure 2(a) is partitioned further into 16  X  16 cells as shown in fig-ure 2(b). Based on fine partitioning, we can define smaller exten-sive regions than 4-cell regions. Figure 2(b) shows a new extensive region C 1 , 5 corresponding to cell c 1 , 5 . In this example, a sweeping region C 1 , 5 with 25 / 16 times of the query window is far smaller than C 1 , 5 that 4 times of the query window in algorithm 2. Al-though the method needs to process small extensive regions due to finer partitioning, it also benefits a lots from dealing less objects in small extensive regions.
 Algorithm 2 processes a cluster G , and outputs all results in First, a shrink procedure is called described in algorithm 3, which gets a small cluster G . The algorithm sweeps G , if finding a region r , then updates the candidate list L c and  X  k by ter may generate more than one result. After one result is output, SweepCluster processes other regions larger than the query win-dow described in algorithm 2.

Algorithm 3 introduces a shrink function, which is called in al-gorithm 2. An input cluster G is reduced to a small one G ting boundary region not containing results from four directions. A
Algorithm 2 : SweepCluster( G , q ,  X  k ) input :cluster G , q ,  X  k . output : k non-overlap candidates L c
G =Shrink( G , q ,  X  k ); r  X  Sweep( G , q ,  X  k ); if  X  r &gt; X  k then border b with width of one fine cell can be cut when scores of all extensive regions containing the border cells are less than
Algorithm 3 : Shrink( G , q ,  X  k ) input :cluster G , q ,  X  k . output : a shrinked cluster G partition G by a fine granularity l f ; find C max with the highest score; r  X  Sweep( C max , q ,  X  k ); if  X  r &gt; X  k then for each border b of G from four directions do return G ;
Compare with SP algorithm, DP algorithm can obtain the prun-ing threshold  X  k and provides tighter pruning bounds. First, DP visits clusters grouped by extensive regions with high scores so that  X  k can be obtained quickly. Then, large  X  k benefits the pruning processing. On the other hand, sweeping small extensive regions decreases I/O cost, and provides tighter pruning bounds. In SP al-gorithm, the pruning condition is the score of a 4-cell extensive region is larger than  X  k . However, in DP algorithm, the finer par-titions provide the tighter bounds. W hen a cell is divided into 16 parts, the pruning condition is to compare the score in a region of 25/16 times of one cell with  X  k . If dividing a cell into 16 parts, 81/64 times of one cell, far less than 4 times, is considered.
We will evaluate the efficiency and effectiveness of the proposed algorithms, including:SP and DP for top-k hot region queries. All algorithms were implemented in C++, and the experiments were conducted on a Intel(R) Core(TM)2 Duo CPU P8700 2.53 Ghz PC with 3.0GB memory, Window XP Pro. We first describe the exper-imental settings, and then, introduce the experimental results and findings.
We have used both real and synthetic datasets in the experiments and normalize the coordinates of each dimension to [0 , 1] dataset is POI data of California [5], which includes 64 features and 64000 objects expressed by long itude and latitude. We choose some features including school, church, park, building and hospital.
We investigate the performance of our proposed algorithms un-der various settings parameters. The I/O cost and the query cost(CPU) are employed as the major performance metrics. We measure the I/O cost by the number of accessed nodes(containing intermediate nodes and leaf nodes) and the CPU cost by the average response time of an STR query. The parameters used are listed in table 1. In order to evaluate the impact of each parameter, we vary one param-eter and fix the others at their default values in each experiment.
Each feature dataset is indexed by R*-tree with 4k page size. The grid index is kept in memory, in which summarized information is stored. When executing a sweeping processing, the algorithm visits objects indexed on R*-tree.
In order to testify the effectiveness of the algorithms, we list the result of an STR query, where k is 5, l q =0 . 01 , three features (school, church and park) are included. On POI data of Califor-nia, we also study the impact of the number of features m number of results k by fixing query region size l q on the efficiency of the algorithm. We vary m between 2 and 5 corresponding to 4 subjects.

Figure 3(a),(b) compare the cost of the algorithms by varying the number of features m . The costs for two methods increases with m , because more feature objects are involved for computing the scores. On I/O cost, DP slightly outperforms SP, because SP need to search a larger area shown in figure 3(a). Figure 3 (b) shows DP spends less CPU time than SP when m increases, because SP induces more computations.

Figure 3(c),(d) compares the performance of SP and DP versus the number of results k . Similar to the experimental results on the single dataset, with the increase of k , the more candidates are kept, which enlarges the searching space of algorithms. So two algo-rithms spend more I/O and CPU cost when k increases. However, DP is better than SP.
We introduced and solved a new form spatial queries named top-k hot region(STR) queries, which can be applied to regional evalua-tion and subject findings based on feature objects in spatial datasets. Our contribution is to solve the problem of ranking regions at any location by multiple feature dat asets. We proposed an algorithm SP based on a single partition on the space that prunes the regions not containing results by 4-cell extensive regions. An improved algo-rithm SP was proposed to reduce searching regions further by a fine partition on regions concentrated lots of feature objects. Our exper-imental results showed that DP outperforms SP since DP applies a dual-partition to shrink searching regions.
The authors would like to thank all the anonymous reviewers for their helpful comments. The work reported is partially supported by the National Natural Science Foundation of China (61033007, 61070024), the Fundamental Research Funds for the Central Uni-versities(N090104001) and National Key Technology R &amp; gram of China(2008BAJ08B08). [1] J. D., E. C.F., and C. C. On supervised density estimation [2] W. Ding, T. F.Stepinski, R. Parmar, D. Jiang, and C. F. Eick. [3] Y. Gao, B. Zheng, G. Chen, and Q. Li.
 [4] G. R. Hjaltason and H. Samet. Distance browsing in spatial [5] F. Li, D. Cheng, M. Hadjieleftheriou, G. Kollios, and S.-H. [6] J.S.X.X.M.Ester,H.P.Kriegel.Adensity-basedalgorithm [7] J. Ni and C. Ravishankar. Pointwise-dense region queries in [8] W.Wu, F.Yang, C.Y.Chan, and K.L.Tan. Finch: Evaluating [9] T. Xia, D. Zhang, E. Kanoulas, and Y. Du. On computing [10] M. L. Yiu, X. Dai, N. Mamoulis, and M. Vaitis. Top-k spatial [11] D. Zhang, Y. Du, and L. Hu. On monitoring the top-k unsafe
