 Answering queries using views is a well-established technique in databases. In this context, two outstanding problems can be for-mulated. The first one consists in deciding whether a query can be answered exclusively using one or multiple materialized views. Given the many alternative ways to compute the query from the materialized views, the second problem consists in finding the best way to compute the query from the materialized views. In the realm of XML, there is a restricted number of contributions in the direc-tion of these problems due to the many limitations associated with the use of materialized views in traditional XML query evaluation models.

In this paper, we adopt a recent evaluation model, called inverted lists model, and holistic algorithms which together have been estab-lished as the prominent technique for evaluating queries on large persistent XML data, and we address the previous two problems. This new context revises these problems since it requires new con-ditions for view usability and new techniques for computing queries from materialized views. We suggest an original approach for ma-terializing views which stores for every view node only the list of XML nodes necessary for computing the answer of the view. We specify necessary and sufficient conditions for answering a tree-pattern query using one or multiple materialized views in terms of homomorphisms from the views to the query. In order to efficiently answer queries using materialized views, we design a stack-based algorithm which compactly encodes in polynomial time and space all the homomorphisms from a view to a query. We further propose space and time optimizations by using bitmaps to encode view ma-terializations and by employing bitwise operations to minimize the evaluation cost of the queries. Finally, we conducted an extensive experimentation which demonstrates that our approach yields im-pressive query hit rates in the view pool, achieves significant time and space savings and shows smooth scalability.
 Categories and Subject Descriptors: H.2.4 [Database Manage-ment]: Systems  X  query processing, textual databases General Terms: Algorithms, Performance Keywords: XPath query evaluation, XML, materialized views
XML is by now the standard for exchanging, exporting and in-tegrating data on the web. As increasing amounts of information are stored, exchanged, and exported using XML, it is becoming increasingly important to efficiently query XML data sources. An-swering queries using views is a well-established technique in data integration, query caching and warehousing, where queries expressed over data sources are answered using materialized views defined over these data sources [14]. It is also (along with indexing) one of the best known techniques used for optimizing the evaluation of queries [7, 12]. The problem behind this technique can be for-mulated as follows: given a query and a set of materialized views along with their definitions, decide whether the query can be an-swered using the materialized views. If the answer is positive, usu-ally there are alternative ways to compute the query from the ma-terialized views inducing different evaluation costs. Consequently, another related problem consists in finding the best way to compute the query from the materialized views. These problems have been studied extensively in the realm of relational databases. However, there is a restricted number of contributions in that direction in the context of XML. The reason is the many limitations associated with the use of materialized views when a traditional way for evaluating queries on XML documents is adopted.
 Limitations of Previous Approaches. The core of XPath consists of tree-pattern queries with one output node (TPQs). The answer of a TPQ is the set of subtrees rooted at the matches of the query output node against the XML document tree. The presence of an output node on queries and views, and the absence of complete structural information outside the subtrees in the view materializa-tions, greatly reduces the chances of a query to have a hit of one or more views in the pool of materialized views that together can be used to answer the query. For this reason, some approaches sug-gest the materialization of additional information about the view answers, e.g. ancestor path information [2]. However, keeping this information only partially addesses the issue while increasing the size of data that needs to be stored. Storing, in addition, data values and references to XML data [2] assumes a centralized enviroment and is not appropriate when the queries need to be answered us-ing only the materialized views (that is, when the base XML data is not accessible). Further, the size of the answer subtrees can be very large. When multiple views are materialized (and inevitably ovelapping portions of the XML document are repeatedly and re-dundantly stored), view materialization becomes unfeasible due to space limitations. Even if space limitations are met, usually the view materializations are unindexed fragments of the XML doc-ument making the computation of a query more expensive com-pared to computing it against the original XML document. For this reason, in the performance studies of both [19] and [28] an upper bound has been set on the size of the XML fragment per view that can be materialized. This restriction limits both (a) the chances to answer the query using only the materialized views, and (b) the chances to find an efficient evaluation plan for the query using the materialized views. These obstacles defy the reason for materializ-ing views in the first place.

E XAMPLE 1.1. Consider the XML tree of Figure 1(a) which re-cords bibliographic information (ignore for the moment the triplets associated with the tree nodes). Let X  X  assume that the view V //article//inf o/author , which retrieves article authors, and the view V 2 : //citations//author , which retrieves citing authors, are materialized in the client cache. Views V 1 and V 2 are shown as TPQs in Figures 1(b) and 1(c) respectively, where an asterisk denotes an output node. Suppose the user issues the query Q //article [ inf o/author =  X  Mary  X  ] /citations//author against the client cache. The query asks for the authors who cite articles authored by Mary and is shown as a TPQ in Figure 1(d). One can see that query Q cannot be answered using V 1 and/or V 2 . The rea-son is that no structural information is available outside the view answer subtrees in the view materializations. Query Q cannot be answered using V 1 and/or V 2 even if ancestor path information is stored along with the subtrees in the view materializations because the absence of node identifiers does not allow a structural join on the materializations of the two views. Query Q can be answered using V 1 if node article is the output node of V 1 . However, in this case, the materialization of V 1 is the whole base XML tree, and V redundantly materializes part of it. Such a large materialization is likely prohibitive in the client cache, and if it is not, in the ab-sence of an index on the materialization of V 1 , it would probably be preferable to evaluate Q against the base XML data stored in the server instead of using the views materialized in the client cache. The Inverted Lists Evaluation Model. A recent approach for evaluating queries on large persistent XML data assumes that the data is preprocessed and the position of every node in the XML tree is encoded [4, 16]. Further , the nodes are pa rtitioned by node label, and an index of inverted lists is built on this partition. In order to evaluate a query, the nodes of the relevant inverted lists are read in the pre-order of their appearance in the XML tree. We refer to this evaluation model as inverted lists model. All the rele-vant query evaluation algorithms in this model are based on stacks that allow encoding an exponential number of pattern matches in a polynomial space. Comparison studies on XML query evalua-tion techniques [21, 13] show that holistic algorithms [4, 9, 16, 33, 8, 31] in the inverted lists model are superior to other algorithms and evaluation models (streaming/navigational approaches [23] or sequential/string matching approaches [25]). In this paper, we as-sume that the inverted lists model and holistic evaluation algorithms are adopted. Note that in the inverted lists model, the answer of a TPQ is not a subtree of the XML tree but a set of tuples. The fields of the tuples correspond to the query nodes. Each tuple contains the (positional representation of) XML tree nodes that match the query nodes in an embedding of the query to the XML tree. Problem Addressed. Driven by the prominence of the inverted lists evaluation model, we address the problem of answering TPQs using exclusively one or more materialized views in the context of this model. We also address the problem of the optimal evaluation of a TPQ using exclusively materialized views in the same context.
In this new context, query answerability by materialized views is not restricted by the presence of output nodes in queries and views since all query and view nodes can be seen as output nodes. As a consequence, queries have more chances to have a hit involving one or more materialized views in the view pool.

This new framework revises the  X  X nswering queries using ma-terialized views X  problem since previous conditions for query an-swerability are not valid anymore. Further, traditional approaches [2, 19, 32, 1, 28] evaluate queries by generating compensation TPQs over materialized views and look at the optimization of this evaluation as a problem of finding the lowest cost compensation TPQ. Unfortunately, these techniques are not applicable in the new context and novel stack-based techniques need to be devised for computing queries over view materializations.
 Our Approach. We suggest a novel approach for materializing views where instead of materializing the view answer, we material-ize sublists of the inverted lists for the labels of the view nodes. A query can be computed very efficiently using materialized views by running holistic stack-based algorithms over the inverted sublists of the view nodes.

Going back to Example 1.1, the triplets by the nodes of the XML tree of Figure 1(a) denote the positional representations of these nodes. As we show later, in the context of our approach, not only the TPQ Q of Figure 1(d) can be answered using the materializa-tions of views V 1 and V 2 of Figures 1(b) and 1(c), but also this com-putation can be performed very efficiently. Moreover, view materi-alization takes minimal space and any redundancy is avoided. Contribution. The main contributions of our paper are the follow-ing.  X 
We introduce a new setting for answ ering queries using views in the framework of the inverted lists query evaluation model. We suggest a novel approach for view materialization where instead of storing the answer of a view, we store for every view node only the list of XML nodes necessary for computing the answer of the view. This way, an exponential number of solutions can be stored in polynomial space.  X 
We consider tree-pattern queries and views and we specify nec-essary and sufficient conditions for answering a query using ex-clusively one or multiple materialized views in terms of homo-morphisms from the views to the query.  X 
In order to check the answerability of a query using views, we design an efficient stack-based algorithm for finding all view nodes that are mapped to the same query node through a ho-momorphism. Our algorithm runs in polynomial time and space by avoiding to enumerate a possibly exponential number of ho-momorphisms.  X 
We show how a query can be computed using views in the frame-work of our novel concept of materialized view by running state of the art holistic stack-based algorithms over the materialializa-tions of the views that cover the query.  X 
We show that an additional advantage of our novel concept of view materializations is that they can be stored as bitmaps and therefore consume minimal space by avoiding redundantly ma-terializing overlapping fragments of the XML data. Further, we show that query evaluation can be optimized by finding a maxi-mal number of covering views in the view pool and by applying bitwise operations to their materializations.  X 
We conduct an extensive experimentation which shows that our approach is space efficient and obtains largely higher hit rates in the view cache compared to traditional approaches, it achieves significant performance gains compared to evaluating queries without using views, and scales very smoothly in terms of space and computational overhead when the number of materialized views in the view pool increases.
Because of the increasing importance of XML, a number of pa-pers have recently addressed the important problems of XML query rewriting using views and of XML view selection [5, 2, 34, 27, 19, 32, 22, 1, 6, 29, 28]. A common assumption made by most of these works is that a view materialization is a set of subtrees rooted at the images of the view output nodes, or references to the base XML tree. In order to obtain the answer of the original query, downward navigation in the subtrees is needed.

Two types of XML query rewriting problems, namely, equiva-lent rewritings and contained rewritings have been considered. An equivalent rewriting produces all t he answers to the original query using the given view materialization(s), whereas a contained rewrit-ing may produce a subset of the answer to the query. The majority of the recent research efforts have been directed on rewriting XPath queries using materialized XPath views. Among them most works focus on the equivalent rewriting [2, 19, 32, 27, 1]. Balmin et al. [2] presented a framework for answering XPath queries using material-ized XPath views. A view materialization may contain XML frag-ments, node references, full paths, and typed data values. A query rewriting is determined through a homomorphism from a view to the query and the view usability (or query answerability) depends on the availability of one or more of the four types of material-izations. Mandhani and Suciu [19] presented results on equivalent TPQ rewritings when the TPQs are assumed to be minimized. Xu et al. [32] studied the equivalent rewriting existence problem for three subclasses of TPQs. Tang and Zhou [27] considered rewrit-ings for TPQs with multiple output nodes. However, the rewritings are restricted to those obtained through a homomorphism from the view to the query which maps the query output nodes to the view output nodes ( output preserving homomorphism). The problem of maximally contained TPQ rewritings was studied in [17] both in the absence and presence of a schema. All contributions in [2, 19, 32, 27, 17, 1] are restricted to query rewritings using a single material-ized view. A common constraining requirement for view usability is the existence of a homomorphism that satisfies two conditions: (a) it maps the view output node to an ancestor-or-self node of the query output node, and (b) it is an isomorphism on query nodes that are not descendants of the image of the view output node.
The problem of equivalently answering XPath queries using mul-tiple views has been studied in [1, 6, 29, 28]. Arion et al. [1] con-sidered the problem in the presence of structural summaries and integrity constraints. As in [27], a query can have multiple out-put nodes, and a rewriting is obtai ned by finding out put preserving homomorphisms from views to the query. Answers of views are tuples whose attributes include node ids of the original XML tree, XML subtrees, and/or nested tuple collections. The answer to a query is computed by combining the answers to the views through a number of algebraic operations. The materialization scheme of storing node ids together with XML subtress is also adopted by [6, 29]. Both papers assumed that output preserving homomorphisms exist among views and they presented rewriting algorithms which use intersection of view answers on node ids.

Tang et al. [28] addressed the multiple view rewriting problem based on the assumptions that structural ids in the form of extended Dewey codes [18] are stored with view materializations. This way, the common ancestors of nodes in different view fragments can be derived for checking view usability. Also, structural joins on the view fragments can be performed based on Dewey codes to produce query answers. The paper also studied a view selection problem defined as finding a minimal view set that can answer a given query. In [34, 22] the equivalent rewriting problem has been addresses but for queries and views which are XQuery expressions.
Our approach is orthogonal to all the previous traditional ap-proaches.Note that structural encodings of XML data nodes are also employed in [1, 28]. However, unlike our approach, [1, 28] store node encodings toghether with view materializations (XML tree fragments) and use them mainly for combining answers of multiple views to produce query answers.

Philips et al. [24] consider materializing intermediate query re-sults as sets of tuples in order to allow additional evaluation plans for structural joins. However, their context of view usability is very restricted and they do not address query answerability from mate-rialized views issues.
In this section, we briefly present the data model, the class of queries and views we consider, and the inverted lists evaluation model we adopt. We also introduce our novel concept of view ma-terialization.
 Data Model. An XML database is commonly modeled by a tree structure. Tree nodes represent and are labeled by elements, at-tributes, or values. Tree edges represent element-subelement, element-attribute, and element-value relationships. For simplicity, we do not distinguish here between element, attribute, and value nodes, and we denote by L the set of node labels in the XML tree.
 For XML trees, we adopt the region encoding widely used for XML query processing [4, 16]. This encoding associates every node with a triplet ( begin , end , level ). This triplet is called posi-tional representation of the node. The begin and end values of a node are integers which can be determined through a depth-first traversal of the XML tree, by sequentially assigning numbers to the first and the last visit of the node. The level value represents the level of the node in the XML tree. The utility of the region en-coding is that it allows efficiently checking structural relationships between two nodes in the XML tree. For instance, given two nodes n 1 and n 2 , n 1 is an ancestor of n 2 iff n 1 .begin &lt; n n .end &lt; n 1 .end .
 Query and View Language. For simplicity of presentation and in order to highlight the novel features of our approach, we consider that queries and views are tree-pattern queries (TPQs). We com-ment later on how our approach can be applied to broader classes of queries e.g. queries with reverse axes and wildcards.Contrary to all previous approaches on answering queries using views [2, 19, 1, 17], we do not impose any restriction on the output nodes. Queries and views can have any number of output nodes and this does not affect the usability of the views for the evaluation of the queries. For this reason, in our definition below we do not explicitly refer to output nodes, and all the nodes of queries and views are consid-ered to be output nodes. Our approach applies without modification to the case where arbitrary sets of nodes in queries and views are considered to be output nodes.

A tree-pattern query (TPQ) specifies a pattern in the form of a tree. Every node in a TPQ Q has a label from L .Therearetwo types of edges in Q . A single (resp. double) edge between two nodes in Q denotes a child (resp. descendant) structural relation-ship between the two nodes.

The answer of a TPQ on an XML tree is a set of tuples. Each tuple consists of XML tree nodes that preserve the child and de-scendant relationships of the query.

More formally: an embedding of a TPQ Q into an XML tree T is a mapping M from the nodes of Q to nodes of T such that: (a) a node in Q labeled by a is mapped by M to a node of T labeled by a ; (b) if there is a single (resp. double) edge between two nodes X and Y in Q , M ( Y ) is a child (resp. descendant) of M (
We call image of Q under an embedding M a tuple that contains one field per node in Q , and the value of the field is the image of the node under M . Such a tuple is also called solution of Q on T . The answer of Q on T is the set of solutions of Q under all possible embeddings of Q to T .

A view is a named query. The class of views we consider is not restricted. Any kind of query can be a view.
 Outline of the Inverted Lists Evaluation Model. In the inverted lists evaluation model, the data is preprocessed and the position of every node in the XML tree is encoded. For every label in the XML tree, an inverted list of the nodes with this label is produced. Given an XML tree T ,weuse L to denote its set of inverted lists and L to denote the inverted list in L for label a .List L a contains the positional representation of the nodes labeled by a in T ordered by their begin field.

Let Q be a query. With every query node X in Q labeled by a , we associate the inverted list L a in L . To access the nodes in L for X , we maintain a cursor C X .Cursor C X sequentially accesses the nodes in L a starting with the first node.
 With every query node X in Q , we also associate a stack S At the beginning of the evaluation of a query, all stacks are empty. When the nodes in the inverted lists are accessed by the cursors, they are possibly stored in stacks. At any point in time, stack entries represent partial solutions of the query that can be extended to the solutions as the algorithm goes on.

In the following we ignore the XML tree T and we assume that the input for the evaluation of queries and views is the set of in-verted lists L . When a query Q is evaluated on L , if the cursor of a node X in Q iterates over the inverted list L Y we say that node X is computed on L using the list L Y .
 View Materialization. We now define our novel concept of view materialization.

D EFINITION 3.1. Let V be a view, and L be a set of inverted lists. The materialization V ( L ) of V on L is a set of sublists of the inverted lists in L  X  X ne for each view node in V. If X is a node in V labeled by a , L X denotes its inverted list in V ( L ) and it contains only those nodes of L a  X  L that are images of X inasolutionof V on L . Sublist L X is called the materialization of X in V
In this sense, the inverted lists in the materialization V tain only those nodes of the inverted lists in L that contribute to a solution of V on L.

Our approach for view materialization departs from all the pre-vious approaches which consider materializing copies of XML tree fragments, typed values, ancestor paths, or references to the input XML tree [2, 19, 17, 1, 28]. Note that our approach is space ef-ficient since the sublists can encode in linear space a number of solutions for the view which is exponential on the number of view nodes.
Let Q be a query and X be a node in Q labeled by a . Recall that in order to evaluate Q on L , the cursor C X of X iterates over the inverted list L a in L . If there is a sublist, say L X ,of L Q can be computed on L by having C X iterate over L X instead of L a , we say that node X can be computed using L X on L .Let V be a view whose materialization on L is V ( L ) . The idea of our approach for answering Q using V on L is to identify nodes in Q that can be computed using the materializations of nodes in V for every L and use their materializations in V ( L ) for computing the answer of Q on L instead of using the corresponding inverted lists in L .
We start by defining what answering a query using a view means in our context of view materialization.

D EFINITION 4.1. Let V ( L ) be the materialization of a view V on a set of inverted lists L. A query Q can be answered using V if for a node X in Q there is a node Y in V with the same label as X, such that for every L , X can be computed using L Y  X  V In this case, we say that view node Y covers query node X, or that Y is a covering node of X.

Let X  X  assume that Q can be answered using V. If every node in Q is covered by a node in V, we say that Q can be answered completely using V. Otherwise, we say that Q can be answered partially using V.

When the answer of a query is computed using a view, a node of the query that is covered by a view node uses only the materi-alization of this view node. Since the materialization of the view node is a sublist of the inverted list for the node label, it is usually smaller than the inverted list. This reduces the cost for computing the answer of the query.
 Deciding Whether a Query Can be Answered Using One View. In order to specify conditions for view usability, we need the con-cept of homomorphism between views and queries. A homomor-phism from a view V to a query Q is a mapping that maps all the nodes of V to nodes with the same label in Q and preserves child and descendant relationships (preserving a descendant relationship means that it is mapped to a path of nodes).

Figure 2 shows a query Q and a view V and four homomor-phisms h 1 , h 2 , h 3 and h 4 from V to Q . Figure 2: Four homomorphisms from view V to query Q The following theorem relates node coverage to homomorphisms.
T HEOREM 4.1. Let Q be a query and V be a view. A node X in Q is covered by a node Y in V iff there is a homomorphism from V to Q that maps Y to X.

Necessary and sufficient conditions for view usability based on homomorphisms are provided by the next collorary of Theorem 4.1.

C OROLLARY 4.1. Let Q be a query and V be a view. Query Q can be answered using V iff there is a homomorphism from V to Q.

For instance, in the example of Figure 2, query Q can be an-swered using view V since there is at least one homomorphism from V to Q. Both nodes labeled by d in Q are covered by node d in V.

Notice that our definition of homomorphism is less restrictive than previous ones since we do not have to consider (and impose conditions on) output nodes [19, 32, 17]. This increases the chances for a homomorphism from a view to a query to exist. Based on Theoreom 4.1, it also increases the chances of the view to be useful in answering the query. This constitutes an important advantage of our approach compared to previous ones since it allows the ex-ploitation of views when other approaches fail.

In order to guarantee that a query can be answered completely using a view, we need to make sure that every node of the query has a covering node in the view. The next corollary of Theorem 4.1 expresses this requirement in terms of homomorphisms from the view to the query.

C OROLLARY 4.2. Let Q be a query and V be a view. Query Q can be answered completely using V iff there are homomorphisms from V to Q such that every node of Q is the image of a node in V under some homomorphism.
 Based on Corollary 4.2, one can easily see that in the example of Figure 2, query Q can be answered completely using view V. Computing the Answer of a Query Using One View. In the tra-ditional approach for answering a query using a view [2, 19, 32, 1, 28], the query is rewritten using the view. That is, in order to com-pute the answer of the query, a compensation query is determined which is applied to the materialized view and computes the answer of the query. This compensation query does so by navigating in the view materialization which is a set of subtrees of the original XML tree.

In contrast, in our approach, we use the view materialization and compute the query answer by running stack-based evaluation algo-rithms over the materializations of the covering view nodes.
Therefore, in order to perform the computation of the answer what is needed is an association of the query nodes with covering
Figure 3: Query Q and views V 1 and V 2 and homomorphisms view nodes. The set of covering view nodes of a given query node is determined by the homomorphism of Theorem 4.1 as follows: Let h 1 ,...,h k be the homomorphisms from a view V to a query Q and Y 1 i ,...,Y m k i be the nodes in V whose image under h X. Then, the set m ( X ) of covering nodes for X in V is If  X  X  X  Q , m ( X ) =  X  ,Q can be answered using V. If  X  X  X  m (
X ) =  X  ,Q can be answered completely using V. The material-ization in V ( L ) of any node in m ( X ) can be used for computing X. However, we might also use the materializations of multiple (or all the) nodes in m ( X ) :let L X 1 and L X 2 be the materializations of two nodes X 1 and X 2 in m ( X ) . The intersection L X 1 is the sublist of L X 1 and L X 2 which comprises the nodes that ap-pear in both L X 1 and L X 2 . In order to compute the answer of Q using V any subset of m ( X ) can be used: during the computation of the answer, X will be computed using the intersection of the materializations of the view nodes in this subset.

Note that a view V can have a number of homomorphisms to a query which is exponential in the number of view nodes. However, the number of covering nodes in m ( X ) is bounded by the number of nodes in V.
The presence of multiple views in the view pool increases the chances of a query to be answered using their materializations. We extend below our definition for answering a query using a view to multiple views. We first define the union of the materializations of two view nodes. Let X 1 and X 2 be two view nodes with the same label a, and L X 1 and L X 2 be their materializations. The union L exactly the nodes of both L X 1 and L X 2 .

D EFINITION 4.2. Let V 1 ( L ) ,...,V n ( L ) be the materializations of views V 1 ,...,V n on a set of inverted lists L. A query Q can be answered using V 1 ,...,V n if for a node X in Q , there are nodes Y ,...,Y k in V 1 ,...,V n , such that, for every L, X can be com-puted using L Y 1  X  ...  X  L Y k .

Let X  X  assume that Q can be answered using V 1 ,...,V n .Ifforev-ery node X in Q , there are nodes Y 1 ,...,Y k in V 1 ,...,V that, for every L, X can be computed using L Y 1  X  ... for every L, we say that Q can be answered completely using V ,...,V n . Otherwise, we say that Q can be answered partially using V 1 ,...,V n .
 Deciding Whether a Query Can be Answered Using Multiple Views. For the class of queries we consider here, checking whether a query can be answered using multiple views can be expressed in terms of checking whether a query can be answered using a single view.

T HEOREM 4.2. Let Q be a query and { V 1 ,...,V n } be a set of views. Query Q can be answered using V 1 ,...,V n iff for some V ,i  X  [1 ,n ] ,Q can be answered using V i . Figure 3 shows a query Q and two views V 1 and V 2 . Each of these views has a homomorphism to Q which is also shown in the fig-ure. Based on Corollary 4.1, Q can be answered using V 1 Therefore, based on Theorem 4.2, Q can be answered using V
For the case of answering completely a query using views we can state the following theorem.

T HEOREM 4.3. Let Q be a query and { V 1 ,...,V n } be a set of views. Query Q can be answered completely using V 1 ,...,V can be answered using V 1 ,...,V n and for every node in Q, there is a covering node in some (not necessarily the same) V i ,i
Based on Theorem 4.3, one can see that query Q of Figure 3 can be answered completely uisng the views V 1 and V 2 of the same figure.
 Computing the Answer of a Query Using Multiple Views. In order to perform the computation of the answer of the query using a set of materialized views we associate query nodes with the set of corresponding covering nodes in the views. The set of covering nodes of a given query node in multiple views is defined in terms of the set of covering nodes of the query in a single view: let X be a node in query Q ,and m 1 ( X ) ,...,m n ( X ) be the sets of covering nodes of X in V 1 ,...,V n , respectively. Then, the set m covering nodes of X in V 1 ,...,V n is
As with the case of a single view, if  X  X  X  Q , m ( X ) =  X  can be answered using V 1 ,...,V n . If  X  X  X  Q , m ( X ) =  X  can be completely answered using V 1 ,...,V n . The materialization of any node in m ( X ) can be used for computing X .However,we might also use the materializations of some (or all the) nodes in m (
X ) : during the computation of the answer, X will be computed using the intersection of the materializations of these view nodes in m ( X ) .
 In this paper, we focus on answering completely queries using views.
As discussed in Section 4, given a query Q and a view V ,the covering nodes for a node of Q in V are defined in terms of the homomorphisms from V to Q . However, the number of these ho-momorphisms can be exponential on the size of V . In this section, we present a stack-based algorithm which computes in polynomial time and space the covering nodes of the nodes in Q without ex-plicitly enumerating all the homomorphisms from V to Q . Match Sets. In the algorithm we use a data structure, called match set , which is similar to those employed in [15, 20, 3] for encoding query pattern matches.

Let q be a node in query Q and v be a node in view V. We say that v matches q if v has the same label as q .Let T v and T the subtrees rooted at v and q , respectively. Let also v node of v in V and q j be a node in the subtree T q . We say that the pair ( v, q ) is consistent with ( v i ,q j ) ,if v and v respectively, and if v/v i  X  V, then q/q j  X  Q.

The match set MS ( V, Q ) is a directed acyclic graph (dag) that compactly stores the set of homomorphisms from V to Q .The nodes of this dag correspond to node pairs ( v, q ) such that v matches q. Each node ( v, q ) is associated with an array ptrsArr indexed by the children of v in V. Given a child v i of v in V, ptrsArr [ v is a set of pointers. Each of the pointers points to a node where q j is a node in T q and ( v, q ) is consistent with is an edge in the dag from node ( v, q ) to node ( v i ,q Figure 4: (a) The match set dag for the view and the query of Figure 2, (b) The snapshots of stacks after the query leaf node d has been visited during the execution of Algorithm computeCovering a pointer from ptrsArr of ( v, q ) to ( v i ,q j ) . We call match set of a node ( v, q ) , denoted MS ( v, q ) , the node ( v, q ) array ptrsArr of ( v, q ) . Note that node ( v i ,q j ) can be a child of multiple nodes ( v, q 1 ) ,..., ( v, q n ) ,where q 1 ,...,q nodes of q j in Q .Let r V and r Q denote virtual roots of V and Q , respectively. Then, the match set dag MS ( V, Q ) is rooted at the node ( r V ,r Q ) . As we show later, the size of the dag is polynomial in the size of V and Q .

Figure 4(a) shows the dag of the match set for the view V and query Q of Figure 2. In order to uniquely identify a node of the view or the query, every node of V and Q in Figure 2 is associated with a node id.

Given a match set dag MS ( V, Q ) , we can compute the set of homomorphisms from V to Q . Clearly, the time required for enu-merating all the homomorphisms is exponential on the size of the view in the worst case. However, we do not need to enumerate all the homomorphisms in order to compute covering nodes of the query nodes. Instead, as we show below, we can compute covering nodes from the match set dag.
 Computing Match Sets. The match set MS ( v, q ) can be com-puted inductively by computing the match set of each child of v in V. If v is a leaf node of V, then MS ( v, q ) consists of only node ( v, q ) . Otherwise, suppose that we have computed all the match sets for each child v i of v . Then, ptrsArr[ v i ]of MS ( lated by adding pointers to each child node ( v i ,q j ) such that is consistent with ( v i ,q j ) . If every ptrsArr[ v i ter the population, we call the newly computed MS ( v, q ) match set.

Based on the above idea, we provide below an algorithm that efficiently computes match sets and covering nodes.
 The Algorithm. Algorithm computeCovering , shown in Listing 1, takes a query Q and a view V as inputs and computes the cov-ering nodes in V for each query node of Q . It is a stack-based al-gorithm which associates each view node of V with a stack. It pro-ceeds in two steps. In the first step, it calls Procedure constructMS (shown in Listing 2) to compute the match set dag MS ( V, Q 2). In the second step, the dag is traversed top-down to determine the covering view nodes (lines 3-5).

Procedure constructMS traverses the tree pattern Q in pre-order, constructing the match sets as it visits nodes and traverses edges. When constructMS visits a query node for the first time, it creates a match set for each matching view node. The created match set are pushed onto stacks. When constructMS returns to a query node after traversing the entire subtree of this node, it deter-mines whether the match sets created for the query node are valid and inserts into the arrays ptrsArr of their parent nodes point-ers that point to the corresponding nodes. When constructMS Listing 1 Algorithm computeCovering 1 create a stack for each node of V and initialize the covering node set 2 constructMS(root(Q)) 3 let visited be a boolean matrix where the rows are indexed by the finishes the traversal of Q , MS ( r V ,r Q ) encodes all the homomor-phisms from V to Q . We describe the process below in more detail.
Initially, a match set MS ( r V ,r Q ) is pushed onto stack S stack of the virtual view root. For each query node q visited for the first time, constructMS iterates in postorder over each view node v matching the query node (line 1). Let ( u, p ) be the node of the match set corresponding to the top entry of stack S u . Procedure constructMS checks whether ( u, p ) is consistent with ( v, q this is the case, a match set MS ( v, q ) is created and then pushed onto stack S v (lines 2-7). Next, constructMS recursively calls itself on each child node of q (lines 8-9). After the traversal of the subtree of q , for each v matching q considered in preorder, it pops out the top entry MS ( v, q ) from stack S v (lines 10-11). If MS -( v, q ) is valid, for each entry in stack S u ,where u is the parent of v , a pointer that points to ( v, q ) is created and added to the entry X  X  ptrsArr[ v i ] (lines 12-15).

Figure 4(b) shows a snapshot of the view stacks during the ex-ecution of Algorithm computeCovering . After the query leaf node d (node id 4) has been visited, the corresponding match set is popped out from the stack S d of view node d . Since it is valid, it is attached to the only match set in stack S a of view node a . Complexity. Let v be a node in V .Wedefinethe prefix query of v , denoted prefix ( V,v ) , as the path from the root of V to v . Given a query Q ,wedefinethe recursion depth of node v in Q as the maximum number of nodes in a path of Q that are images of v under all the possible embeddings to prefix ( V,v ) in that path of Q. We define the recursion depth D of V in Q as the maximum recursion depth of the view nodes of V in Q.

The number of query nodes matched by a view node is bounded by the number | Q | of the nodes of Q . The total number of match sets constructed during execution is bounded by | V | X | number of incoming pointers to each constructed match set is bounded by D. Therefore, the space complexity of Algorithm compute -Covering is bounded by O ( | V | X | Q | X  D ) .

The time complexity of Algorithm computeCovering is deter-mined by the time for processing stack entries (that is, match sets). The number of entries in each stack at any given time is bounded by D. Let v be a view node that matches a query node q under consid-eration. Procedure constructMS spends O ( fanout ( v )+ D checking whether MS ( v, q ) is valid and on visiting entries in the parent stack of v ,where fanout ( X ) denotes the out-degree of v in V. Since the number of view nodes that match node q is O ( total time spent on processing stack entries for each node in Q is O ( | V | + | V | X  D ) , which is dominated by O ( | V | X  D the time complexity of Algorithm computeCovering is bounded by O ( | V | X | Q | X  D ) . Computation Time Issues. As discussed in Section 4, if a query Q can be answered completely using some views, and m Listing 2 Procedure constructMS( q ) 2 let u be the parent of v in V 8 for (every child q of q in Q ) do 9 constructMS( q ) 11 pop out the top entry e from stack S v 12 if ( e is a valid match set) then 13 let u be the parent of v in V 14 for (every stack entry e  X  S u ) do 15 add to ptrsArr [ v ] a pointer that points to the node of e the set of all the covering nodes of a node X in Q with respect to these views, then X can be computed using the intersection of the materializations of the nodes in m ( X ) . If additional views that have a homomorphism to Q are discovered in the view pool, the set m ( X ) of covering nodes for X with respect to all the views will potentially get new view nodes and the intersection of their materializations will potentially decrease in size making, of course, the computation of X cheaper. However, there is a cost associated with discovering additional views that have a homomorphism to Q . Therefore, if a set of views that answers a query Q has been discovered in the view pool, a question that arises is whether it is worth spending additional time to find other views that have a homomorphism to Q in an effort to reduce the overall computation cost of Q using the view materializations. Our experimental results in Section 7, show that the answer to this question is positive: the implementation of our algorithm of Section 5 takes minimal time to compute all the covering nodes of a query even with a large view pool. This is largely compensated by the benefit in computation time we obtain by finding additional views with homomorphisms to Q .
 Using Bitmaps. Consider two view nodes X 1 and X 2 both labeled by the same label a . The materializations L X 1 and L X 2 X 2 are sublists of the inverted list L a . L X 1 and L X 2 lap. Instead of storing directly L X 1 and L X 2 , one can store the union L X 1  X  L X 2 of L X 1 and L X 2 along with two bitmaps B B X i ,i =1 , 2 , has a  X 1 X  bit at position x iff L X 1 comprises the XML tree node at position x of L X 1  X  L X 2 . This idea can be ap-plied to multiple view node materia lizations resulting in important space savings. Note that because the view node materializations L
X 1 ,...,L X k of the view nodes X 1 ,...,X k having the same la-bel are sorted on the begin value of the positional representation of their XML tree nodes, the intersection L X 1  X  ...  X  L be computed by merge-joining L X 1 ,...,L X k . Using bitmaps, the intersection of L X 1 ,...,L X k can be computed by bitwise AND-ing B X 1 ,...,B X k which produces a bitmap of the intersection L
X 1  X  ...  X  L X k on L X 1  X  ...  X  L X k . That is, the order is pre-served. Besides the important space savings, the use of bitmaps also offers time saving for two reasons: (a) fetching into memory bitmaps of view nodes and the inverted list nodes corresponding to their bitwise AND has less I/O cost than fetching the material-izations of these nodes, and (b) bitwise AND-ing bitmaps has less CPU cost than merge-joining the corresponding view node materi-alizations. Cache Size (MB)
We implemented our approach and ran experiments to study its time and space performance and scalability. We also ran experi-ments to compare our approach with traditional approaches. As traditional approaches assume a different evaluation model and an-swer sets, this comparison makes sense when it concerns the view cache hit rate.
Our implementation was coded in Java. All the experiments reported here were performed on an Intel Core 2 CPU 2.13 GHz processor with 2GB memory running JVM 1.6.0 in Windows XP Professional. The Java virtual machine memory size was set to 512MB. Both XML inverted lists and TPQ view definitions as well as the view materializations were stored in a commercial DBMS. Each displayed time value in the plots is averaged over 5 runs with a cold DBMS buffer cache.

We ran experiments both on an XML benchmark data set gen-erated using XMark [26] and on a synthetic dataset using IBM X  X  XML Generator [11]. We used a 56.2MB XML benchmark data set generated using XMark [26]. This XML document does not include recursive elements. It contains 74 distinct element labels. The total number of parsed element nodes (excluding attributes and text values) is 832911 and the size of their positional representa-tions (i.e., the inverted lists) is 15.1MB. We also ran experiments on a highly recursive synthetic dataset, whose results are similar to those reported here and are omitted in the interest of space. We used the XPath generator YFilter [10] to produce queries. YFilter generates XPath queries according to specified parame-ters, such as the maximum query depth, the probability of descen-dant edges ( // ), and the probability of branches. In order to create more general workloads, we modified YFilter in the following two ways: (a) we removed the limitation on supporting only one level of nesting of path expressions, so that it can generate complex XPath queries with arbitrary nesting, and (b) we relaxed the restric-tion on the axis of a predicate path expression which allows only child axes ( / ).
We first compare the view cache hit rate of our approach with that of previous approaches. The hit rate expresses the percentage of randomly generated queries that can be answered using one or multiple views materialized in the view cache. In order to com-pare with previous approaches where queries have output nodes we use the criterion for query answerability using a set of views of [28] which requires that: (a) the output node of a view in the view set is mapped to an ancestor-or-self node of the query output node through a homomorphism (in which case we say that this query node is covered by the view), and (b) each query node which is not covered by this view is covered by some other view in the set.
We generated a workload with 8000 views. We used the follow-ing setting for the workload: maximum view depth = 4, probability of descendant edges = 0.8, and probability of branches = 1. We also generated 100 random queries with the following setting: maxi-mum query depth = 9, probability of descendant edges = 0.8, and probability of branches = 1. In the experiments, we scaled the num-ber of views in the view pool from 1000 to 8000. To better illus-trate the capacities of the differ ent approaches under comparison, we also measured and compared the hit rate of these approaches when only one view can be used for answering the given query.
Figure 5(a) shows the hit rate of different approaches increasing the number of views in the view pool. We refer to our approach as MVIL (Materialized Views as Inverted Lists) and to the approach in [28] as MVST (Materialized Views as Subtrees). Our approach largely outperforms MVST both when one or multiple materialized views are used to answer the query. For the case of multiple views it outperforms MVST by at least 40% and achieves a hit rate of 97 % for 7000 or more views in the view pool.
We also measured the space efficiency of our approach. We used the workload on the XMark dataset described above. Recall that the materialization of a view is stored as bitmaps, one per each view node. In addition, a set of invert ed lists is stored, one inverted list per each distinct node label in the views of the view pool. Each such inverted list is the union of the materializations of all the view nodes with the same label in the view pool. We refer to this materi-alization scheme as bitmap materialization scheme . As a compari-son, we also stored directly the materializations of the nodes of all the views and measured the total space used. We refer to the later scheme as inverted lists materialization scheme .

Figure 5(b) reports on the view cache size under the two mate-rialization schemes as the number of materialized views increases from 1000 to 8000. The scale of the Y-axis is logarithmic. The total size of the view cache under the bitmap scheme rises from 26 . 45 MB to 128 . 3 MB as the number of views in the view pool in-creases from 1000 to 8000. In comparison, the size of the cache under the inverted lists scheme increases faster than the bitmap scheme from 305 . 8 MB to 2563 . 63 MB. Further, the inverted lists scheme consumes much more space, up to 20 times more than the bitmap scheme for most of the test cases.

Notice that the size of the bitmap materializations can be further reduced using state of the art bitmap compression techniques [30] without compromising the efficiency of bitwise logical operations. Such an implementation is beyond the scope of this paper.
We next show the speedup obtained in query evaluation time with our approach. We assume that the views are materialized in the client side while the base XML data is stored remotely in the server side. Queries are evaluated at the server side without using materialized views, while they are evaluated at the client side using exclusively the view materializations. In both cases the inverted lists evaluation model is adopted and the state of the art holis-tic algorithm TwigStack [4] is employed. The communications costs are ignored. If these costs are taken into account the savings achieved by our approach are even larger. For the comparison, we used the workload of the 8000 materialized views described above. Among the 8000 views, 6605 have non-empty answers. We also used four test queries on the XMark dataset, which are shown in Figure 8. These queries are randomly generated and they can all be answered using exclusively the materialized views. Figure 6(a) reports on the query processing time per query for two different configurations: NoViews refers to evaluating queries on the server XML database without using materialized views. WithViews refers to answering queries using exclusively materialized views stored in the client view cache. Overhead denotes the computational over-head for using materialized views. It consists of the time needed for finding the covering view nodes of the query nodes and the time needed for loading in memory and bitwise ANDing the bitmaps of the node materializations.

As we can see from Figure 6(a), WithViews achieves significant speedup compared to NoViews : from 77 % for Q 3 up to a factor of 2.3 for Q 4 (our experiments on a highly recursive dataset show a speedup by a factor of 13 for some queries). For each query, the fraction of Overhead in the total processing time using WithViews is very small, ranging from 0 . 34% for Q 3 to 1 . 73% for Q
Figure 6(b) shows the evaluation statistics of the four queries of Figure 8 over the XMark dataset. We observe that the query evaluation performance is largely determined by the number of in-verted list nodes read from disk during execution, since each disk access triggers I/O whose cost dominates the computation costs of the query. As we can see in Figure 6(b), a query can be computed using substancially smaller inverted lists with our approach (col-umn #SUB) than with the NoView approach (column #INV). For instance, the number of nodes accessed using materialized views is reduced by 78 % for query Q 4 of Figure 8. This reduction in size, reduces the I/O cost, but it also reduces the CPU cost resulting in a substancial speedup.
Finally, we measured the scalability of our approach as the num-ber of the materialized views in the view pool increases. The scal-ability is examined in terms of the computation overhead which, as explained in Section 7.4, consists of two parts: (a) the time spent on finding all the query covering nodes in the view pool X  X his oper-ation is done by the algorithm described in Section 5, and (b) the time spent on loading selected bitmaps from disk to memory and on bitwise ANDing bitmaps.
Figure 7 reports on both components of the computation over-head, as well as the number of homomorphisms from the view to the query when the number of materialized views increases from 1000 to 8000 for two queries Q 2 and Q 4 . Notice that the bitmap processing component is 0 for query Q 2 when the view pool con-tains 1000 views, since Q 2 has no hit on the view cache in this case. As expected, the number of homomorphisms for each query grows as the number of views increases. Both components of the over-head grow very smoothly. For instance, for query Q 4 , the covering node computation component and the bitmap processing compo-nent for 1000 views are 6ms and 103ms, respectively. They grow to 32ms and 128ms for 8000 views (a ratio of 5.3 and 1.2 respec-tively). Note that using a bitmap compression technique [30] can further reduce the size of bitmaps and thereby the I/O cost for load-ing them in memory.
We have addressed the problem of answering XML queries using exclusively materialized views. We claim that previous approaches to this problem are limited by the way query answers (and view ma-terializations thereof) are defined. To overcome these limitations, we have revised the problem by placing it the setting of the inverted lists model which is currently the prominent model for evaluating queries on large persistent XML data. In this context, we have sug-gested an original approach for materializing views which stores the inverted lists of only those XML tree nodes that occur in the answer to the view. To the best of our knowledge this is the first time the problem is addressed in this context and such a material-ization scheme is adopted. We provided necessary and sufficient conditions for tree-pattern query answerability in terms of view to query homomorphisms. We designed a time and space efficient algorithm for deciding query answerability and we showed how queries can be computed over view materializations using stack-based holistic algorithms. We further developed optimization tech-niques that minimize the storage space and avoid redundancy by materializing views as bitmaps, and that optimize the evaluation of the queries over the views by applying bitwise operations on view materializations. Our experimental results showed that our approach has largely higher hit rates than previous approaches, sig-nificantly speeds up the evaluation of queries without using views, and scales very smoothly in terms of storage space and computa-tional overhead.

Our approach can be directly applied to larger classes of XML queries. Even though the existence of homomorphisms might not be anymore a necessary condition for query answerability using views, it does constitute a sufficie nt condition. Therefore, homo-morphisms can be used to compute covering view nodes for the nodes of these queries as in the case of tree-pattren queries de-scribed in the paper. We are currently working on exploiting our approach for optimizing queries using materialized views in cen-tralized environments. In this framework, the focus is on answering partially a query using views and on view selection for materializa-tion. We are also working on techniques for the efficient updating of the view materializations when the XML data is modified.
