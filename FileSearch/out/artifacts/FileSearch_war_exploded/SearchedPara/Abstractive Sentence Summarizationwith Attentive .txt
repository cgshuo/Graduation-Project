 Generating a condensed version of a passage while preserving its meaning is known as text summariza-tion. Tackling this task is an important step to-wards natural language understanding. Summariza-tion systems can be broadly classified into two cat-egories. Extractive models generate summaries by cropping important segments from the original text and putting them together to form a coherent sum-mary. Abstractive models generate summaries from scratch without being constrained to reuse phrases from the original text.

In this paper we propose a novel recurrent neu-ral network for the problem of abstractive sentence summarization . Inspired by the recently proposed architectures for machine translation (Bahdanau et al., 2014), our model consists of a conditional recur-rent neural network, which acts as a decoder to gen-erate the summary of an input sentence, much like a standard recurrent language model. In addition, at every time step the decoder also takes a condition-ing input which is the output of an encoder module. Depending on the current state of the RNN, the en-coder computes scores over the words in the input sentence. These scores can be interpreted as a soft alignment over the input text, informing the decoder which part of the input sentence it should focus on to generate the next word. Both the decoder and en-coder are jointly trained on a data set consisting of sentence-summary pairs. Our model can be seen as an extension of the recently proposed model for the same problem by Rush et al. (2015). While they use a feed-forward neural language model for genera-tion, we use a recurrent neural network. Further-more, our encoder is more sophisticated, in that it explicitly encodes the position information of the in-put words. Lastly, our encoder uses a convolutional network to encode input words. These extensions result in improved performance.

The main contribution of this paper is a novel convolutional attention-based conditional recurrent neural network model for the problem of abstractive sentence summarization. Empirically we show that our model beats the state-of-the-art systems of Rush et al. (2015) on multiple data sets. Particularly no-table is the fact that even with a simple generation module, which does not use any extractive feature tuning, our model manages to significantly outper-form their ABS+ system on the Gigaword data set and is comparable on the DUC-2004 task. While there is a large body of work for generat-ing extractive summaries of sentences (Jing, 2000; Knight and Marcu, 2002; McDonald, 2006; Clarke and Lapata, 2008; Filippova and Altun, 2013; Fil-ippova et al., 2015), there has been much less re-search on abstractive summarization. A count-based noisy-channel machine translation model was pro-posed for the problem in Banko et al. (2000). The task of abstractive sentence summarization was later formalized around the DUC-2003 and DUC-2004 competitions (Over et al., 2007), where the T OP -IARY system (Zajic et al., 2004) was the state-of-the-art. More recently Cohn and Lapata (2008) and later Woodsend et al. (2010) proposed systems which made heavy use of the syntactic features of the sentence-summary pairs. Later, along the lines of Banko et al. (2000), M OSES was used directly as a method for text simplification by Wubben et al. (2012). Other works which have recently been pro-posed for the problem of sentence summarization in-clude (Galanis and Androutsopoulos, 2010; Napoles et al., 2011; Cohn and Lapata, 2013). Very recently Rush et al. (2015) proposed a neural attention model for this problem using a new data set for training and showing state-of-the-art performance on the DUC tasks. Our model can be seen as an extension of their model. Let x denote the input sentence consisting of a sequence of M words x = [ x 1 ,...,x M ] , where each word x i is part of vocabulary V , of size |V| = V . Our task is to generate a target sequence y = [ y 1 ,...,y N ] , of N words, where N &lt; M , such that the meaning of x is preserved: y = argmax y P ( y | x ) , where y is a random variable de-noting a sequence of N words.

Typically the conditional probability is mod-eled by a parametric function with parameters  X  : P ( y | x ) = P ( y | x ;  X  ) . Training involves finding the  X  which maximizes the conditional probability of sentence-summary pairs in the training corpus. If the model is trained to generate the next word of the summary, given the previous words, then the above conditional can be factorized into a product of indi-vidual conditional probabilities: In this work we model this conditional probabil-ity using an RNN Encoder-Decoder architecture, in-spired by Cho et al. (2014) and subsequently ex-tended in Bahdanau et al. (2014). We call our model RAS (Recurrent Attentive Summarizer). 3.1 Recurrent Decoder The above conditional is modeled using an RNN:
P ( y t |{ y 1 ,...,y t  X  1 } , x ;  X  ) = P t = g  X  where h t is the hidden state of the RNN: Here c t is the output of the encoder module (detailed in  X  3.2). It can be seen as a context vector which is computed as a function of the current state h t  X  1 and the input sequence x .

Our Elman RNN takes the following form (El-man, 1990): where  X  is the sigmoid function and  X  is the soft-max, defined as:  X  ( o t ) = e o t / ( i = 1 ,..., 5 ) are matrices of learnable parameters The LSTM decoder is defined as (Hochreiter and Schmidhuber, 1997): Operator refers to component-wise multiplica-tion, and W i ( i = 1 ,..., 14 ) are matrices of learn-W 3.2 Attentive Encoder We now give the details of the encoder which com-putes the context vector c t for every time step t of the decoder above. With a slight overload of nota-tion, for an input sentence x we denote by x i the d dimensional learnable embedding of the i -th word ( x i  X  R d ). In addition the position i of the word x i is also associated with a learnable embedding l i of size d ( l i  X  R d ). Then the full embedding for i -th word in x is given by a i = x i + l i . Let us which is used to convolve over the full embeddings of consecutive words. Let there be d such matrices ( k  X  X  1 ,...,d } ). The output of convolution is given by: where b k j is the j -th column of the matrix B k . Thus the d dimensional aggregate embedding vector z i is defined as z i = [ z i 1 ,...,z id ] . Note that each word x i in the input sequence is associated with one ag-gregate embedding vector z i . The vectors z i can be seen as a representation of the word which captures the position in which it occurs in the sentence and also the context in which it appears in the sentence. In our experiments the width q of the convolution matrix B k was set to 5 . To account for words at the boundaries of x we first pad the sequence on both sides with dummy words before computing the ag-gregate vectors z i  X  X .

Given these aggregate vectors of words, we com-pute the context vector c t (the encoder output) as: where the weights  X  j,t  X  1 are computed as 3.3 Training and Generation Given a training corpus S = { ( x i , y i ) } S i =1 of S sentence-summary pairs, the above model can be trained end-to-end using stochastic gradient descent by minimizing the negative conditional log likeli-hood of the training data with respect to  X  : L =  X  where the parameters  X  constitute the parameters of the decoder and the encoder.

Once the parametric model is trained we generate a summary for a new sentence x through a word-based beam search such that P ( y | x ) is maximized, argmax P ( y t |{ y 1 ,...,y t  X  1 } , x ) . The search is pa-rameterized by the number of paths k that are pur-sued at each time step. 4.1 Datasets and Evaluation Our models are trained on the annotated version of the Gigaword corpus (Graff et al., 2003; Napoles et al., 2012) and we use only the annotations for tokenization and sentence separation while discard-ing other annotations such as tags and parses. We pair the first sentence of each article with its head-line to form sentence-summary pairs. The data is pre-processed in the same way as Rush et al. (2015) and we use the same splits for training, val-idation, and testing. For Gigaword we report re-sults on the same randomly held-out test set of 2000 We also evaluate our models on the DUC-2004 evaluation data set comprising 500 pairs (Over et al., 2007). Our evaluation is based on three vari-ants of ROUGE (Lin, 2004), namely, ROUGE-1 (unigrams), ROUGE-2 (bigrams), and ROUGE-L (longest-common substring). 4.2 Architectural Choices We implemented our models in the Torch library (http://torch.ch/) 2 . To optimize our loss (Equa-tion 5) we used stochastic gradient descent with mini-batches of size 32 . During training we mea-sure the perplexity of the summaries in the valida-tion set and adjust our hyper-parameters, such as the learning rate, based on this number. For the decoder we experimented with both the Elman RNN and the Long-Short Term Memory (LSTM) architecture (as discussed in  X  3.1). We chose hyper-parameters based on a grid search and picked the one which gave the best perplexity on the validation set. In particular we searched over the number of hidden units H of the recurrent layer, the learning rate  X  , the learning rate annealing schedule  X  (the factor by which to decrease  X  if the valida-tion perplexity increases), and the gradient clipping threshold  X  . Our final Elman architecture (RAS-Elman) uses a single layer with H = 512 ,  X  = 0 . 5 ,  X  = 2 , and  X  = 10 . The LSTM model (RAS-LSTM) also has a single layer with H = 512 ,  X  = 0 . 1 ,  X  = 2 , and  X  = 10 . On the Gigaword corpus we evaluate our models in terms of perplexity on a held-out set. We then pick the model with best perplexity on the held-out set and use it to compute the F1-score of ROUGE-1, ROUGE-2, and ROUGE-L on the test sets, all of which we report. For the DUC corpus however, inline with the standard, we report the recall-only ROUGE. As baseline we use the state-of-the-art attention-based system (ABS) of Rush et al. (2015) which relies on a feed-forward network decoder. Additionally, we compare to an enhanced version of their system (ABS+), which relies on a range of separate extractive summarization features that are added as log-linear features in a secondary learning step with minimum error rate training (Och, 2003). Table 1 shows that both our RAS-Elman and RAS-LSTM models achieve lower perplexity than ABS as well as other models reported in Rush et al. (2015). The RAS-LSTM performs slightly worse than RAS-Elman, most likely due to over-fitting. We attribute this to the relatively simple nature of this task which can be framed as English-to-English translation with few long-term dependencies. The ROUGE results (Table 2) show that our models com-fortably outperform both ABS and ABS+ by a wide margin on all metrics. This is even the case when we rely only on very fast greedy search ( k = 1 ), while as ABS uses a much wider beam of size k = 50 ; the stronger ABS+ system also uses additional extrac-tive features which our model does not. These fea-tures cause ABS+ to copy 92% of words from the input into the summary, whereas our model copies only 74% of the words leading to more abstractive summaries. On DUC-2004 we report recall ROUGE as is customary on this dataset. The results (Ta-ble 3) show that our models are better than ABS+. However the improvements are smaller than for Gi-gaword which is likely due to two reasons: First, tokenization of DUC-2004 differs slightly from our training corpus. Second, headlines in Gigaword are much shorter than in DUC-2004.

For the sake of completeness we also compare our models to the recently proposed standard Neu-ral Machine Translation (NMT) systems. In par-ticular, we compare to a smaller re-implementation of the attentive stacked LSTM encoder-decoder of Luong et al. (2015). Our implementation uses two-layer LSTMs for the encoder-decoder with 500 hidden units in each layer. Tables 2 and 3 report ROUGE scores on the two data sets. From the tables we observe that the proposed RAS-Elman model is able to match the performance of the NMT model of Luong at al. (2015). This is noteworthy be-cause RAS-Elman is significantly simpler than the NMT model at multiple levels. First, the encoder used by RAS-Elman is extremely light-weight (at-tention over the convolutional representation of the input words), compared to Luong X  X  (a 2 hidden layer LSTM). Second, the decoder used by RAS-Elman is a single layer standard (Elman) RNN as opposed to a multi-layer LSTM. In an independent work, Nalla-pati et. al (2016) also trained a collection of standard NMT models and report numbers in the same ball-park as RAS-Elman on both datasets.

In order to better understand which component of the proposed architecture is responsible for the improvements, we trained the recurrent model with Rush et. al., (2015) X  X  ABS encoder on a subset of the Gigaword dataset. The ABS encoder, which does not have the position features, achieves a final vali-dation perplexity of 38 compared to 29 for the pro-posed encoder, which uses position features as well as context information. This clearly shows the bene-fits of using the position feature in the proposed en-coder.

Finally in Figure 1 we highlight anecdotal exam-ples of summaries produced by the RAS-Elman sys-tem on the Gigaword dataset. The first two examples highlight typical improvements in the RAS model over ABS+. Generally the model produces more flu-ent summaries and is better able to capture the main actors of the input. For instance in Sentence 1, RAS-Elman correctly distinguishes the actions of  X  X epe X  from  X  X erreira X , and in Sentence 2 it identifies the correct role of the  X  X hink tank X . The final two ex-amples highlight typical mistakes of the models. In Sentence 3 both models take literally the figurative use of the idiom  X  X  silence that spoke volumes, X  and produce fluent but nonsensical summaries. In Sen-tence 4 the RAS model mistakes the content of a relative clause for the main verb, leading to a sum-mary with the opposite meaning of the input. These difficult cases are somewhat rare in the Gigaword, but they highlight future challenges for obtaining human-level sentence summary. We extend the state-of-the-art model for abstrac-tive sentence summarization (Rush et al., 2015) to a recurrent neural network architecture. Our model is a simplified version of the encoder-decoder framework for machine translation (Bahdanau et al., 2014). The model is trained on the Gigaword corpus to generate headlines based on the first line of each news article. We comfortably outperform the previ-ous state-of-the-art on both Gigaword data and the DUC-2004 challenge even though our model does not rely on additional extractive features.
