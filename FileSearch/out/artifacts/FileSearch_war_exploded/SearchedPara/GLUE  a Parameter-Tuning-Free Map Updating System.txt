 Map data are widely used in mobile services, but most maps might not be complete. Updating a map automatically is an important problem because road networks are frequently changed with the development of the city. This paper stud-ies the problem of recovering missing road segments via GPS trajectories, especially low sampled data. Our approach takes the GPS measurement error into consideration and proposes an effective self-adaptive algorithm. Our work is similar as many existing works in this field as they all rely on many parameters. However, we propose theoretical models behind all the important parameters to enable self-adaptive parameter setting. To the best of our knowledge, this is the first work that addresses the parameter setting issue suc-cessfully so our approach is free of parameter-tuning. In ad-dition, we also propose a quantitative evaluation method for map updating problem. The result shows our algorithm has a much better performance than the existing approaches. H.2.8 [ Database Management ]: Database Applications X  Spatial databases and GIS Map Updating; Map Inference; Trajectory Mining
Research and markets predict that Global Digital Map market will grow at a compound annual growth rate of 9.37% over the period 2013-2018. Most, if not all, mobile users en-joy the great convenience of having digital maps available in mobile devices (e.g., smart phones). Meanwhile, we are also aware of the potential danger caused by inaccurate map data, as illustrated by a few example news reported by me-dia. A 67-year-old Belgian woman traveling to Brussels, 38 miles from her home, trustingly followed incorrect GPS di-rections on a detour of more than 800 miles, arriving two days later in Zagreb, Croatia. A woman followed her GPS c past a  X  X o Not Enter X  sign and down the wrong way on a divided highway near Scranton, Pennsylvania, causing a head-on collision. To name but a few.

On the other hand, the road network keeps changing, al-though the frequency might not be very high. For example, all the governments invest in transport infrastructure ev-ery year and part of the budget is for upgrading the road network. Beijing X  X  xinhuanet.com reported that 11,000 kilo-meters (7,000 miles) of new freeways were built in China in 2012, which is about 1.5 times as long as the freeway mileage in California, US. More than 30,000 miles of roads were built in Brazilian Amazon in 3 years, from 2004 to 2007.
Given the fact that digital map becomes more and more important and the map data do change from time to time, how to accurately gather real-time map data is critical. A large number of map providers update their maps by inves-tigating the real roads manually. This approach is expensive and it is hard to update the map timely. Some map providers employ some automatic approaches, clustered as map infer-ence technology , to generate maps based on satellite images. However, the high cost of equipments and the fact that it can only find out the major roads make it hard to be put into practice widely. Instead of generating the whole map automatically as map inference technology aims to achieve, we propose a solution based on map updating in this paper. To be more specific, we assume a base map that captures a majority of roads in a real road network is available and we use massive GPS trajectories to automatically fine-tune the map by adding missing roads.

We want to highlight that our approach is doable as a large collections of GPS trajectories are becoming widely available, thanks for the fast deployment of GPS devices in mobile platforms. According to the  X  X ransportation Statis-tics Annual Report-2007 X  released by Department of Trans-portation (DOT), there were estimated 254.4 million regis-tered passenger vehicles in the United States; according to National Household Travel Survey 2009, each vehicle trav-els 38.4 miles daily. If we assume 1% of the vehicles are equipped with GPS devices, the GPS trajectories reported by the vehicles in the United States travel 2.93 billion miles in total within a month, which is about 1 . 82  X  10 4 times of the total length of its National Highway System. In other words, it is practical to update the map automati-cally by leveraging massive GPS trajectories. Meanwhile, digital maps are also widely available if we can bear the in-accuracy of map data to certain degree. Map updating fully utilizes all the available map resources to cut down the total cost. However, we also want to highlight that map updating problem is very challenging, as explained below.

First, most trajectory data are collected in a low sampling rate, for sake of power consumption and storage. According to [19], only 34% trajectories of more than 10,000 Beijing taxis have a sampling rate higher than 1 point per minute. Existing works have poor performance in low sampling rate situations because they are mainly based on trajectory clus-tering which highly depends on the sampling rate of trajec-tory data [2, 5, 9, 15, 18]. The sparse-sampled data has lost lots of information which make it difficult to obtain the road information directly. We need to think of ways to dig useful information out from those low-sampled trajectories to recover the roads.

Second, there are many noisy GPS points, those with large measurement error, in the collection. Measurement er-ror occurs by many reasons, such as weather and buildings nearby. The noise points lead to wrong roads generated and influence the performance of our approach. Although there are several existing outlier detection methods to detect the noises [6, 17], they either need a fixed threshold working as a filter, e.g. global proximity-based approaches, or is not suitable for road-like distribution, such as clustering-based approaches and mixture model-based approach. However, in the case of map updating, the density of points in different roads may have a great difference and the distribution of the points is complex which challenges those methods. Note that although a relative density outlier detection method utiliz-ing the Local Outlier Factor (LOF) technique can handle the different density problem, parameter selection is diffi-cult, which is not suitable for application with data having different properties [17].
 Figure 1: GLUE: G PS Trajectories (L ow-Sampling rate) Based Map U pdating E ngine
By considering the challenges mentioned above, we pro-pose a G PS Trajectories (L ow-sampling rate) based Map U pdate E ngine (GLUE) that can support auto map updates based on massive low-sampled GPS trajectories, with its main components shown in Fig. 1. It takes the trajecto-ries set that captures the movement of moving objects on a real road network as input, and maps all the trajecto-ries to a given map 1 . Map matching technique classifies the trajectory set into two parts, those matched and those un-matched. Our map updating is based on all the un-matched trajectories as they imply those roads they should be matched to are missing. Ideally, map updating can locate the missing roads and then make corresponding changes to the map.

As a summary, the major contributions of this paper are five-fold. First, we propose an effective direction cluster-ing based approach on GLUE that is based on low sam-pling rate trajectory data. No existing work achieves good
We employ existing map matching algorithms to perform this step, and related work on map matching will be re-viewed in Section 2. performance using low sampling rate data, although most trajectory data are sparsely-sampled. To the best of our knowledge, GLUE is the first attempt to utilize low-sampled GPS trajectory data for auto map updating. Second, we take GPS measurement error into consideration and pro-pose an effective denoising algorithm. It is a self-adaptive and heuristic-based algorithm that can deal with regions of different point density. Third, we propose analytical models to select proper values for parameters in GLUE. The effec-tiveness of our parameter auto-tuning algorithms is demon-strated by the comprehensive experiments. Fourth, we de-sign a quantitative evaluation method to evaluate the perfor-mance of map updating algorithms. Last but not least, we use massive real data to conduct the experiment and com-plement the Singapore map of OpenStreetMap. Trajectories of more than 15,000 Singapore taxis are used in our experi-ment. Result shows that our approach outperforms the ex-isting work on low sampling rate trajectory data (sampling interval longer than 30 seconds).
In this section, we review existing work related to GLUE, including map updating, map inference, and map matching. Map updating and map inference both are based on GPS trajectories while the former is to update an existing map and the latter is to generate the whole map from scratch. Mapmatchingistomapagiventrajectorysetintoroads of an existing map and it is employed to pre-process GPS trajectories before map updating in GLUE.

As introduced in Section 1, map updating approach is to update a given map (e.g., inserting new roads) based on mas-sive GPS trajectories. CrowdAtlas, proposed in [18], is the only piece of existing work. It directly clusters unmatched trajectories according to the Hausdorff distance. During the clustering process, the size of each cluster increases as more and more unmatched trajectories are clustered. Once the size of one cluster reaches a predefined threshold, a new road will be generated from the trajectories within that cluster. Note the generation of one new road triggers a new iteration. In a new iteration, unmatched trajectories are re-matched and re-clustered as some of them might be mapped to the newly added road. Figure 2: Incorrect road generation with low sam-pling rate trajectories
This algorithm performs well in high sampling rate data (e.g., 1 point per five seconds). However, in reality, sampling rate of most trajectory data is much lower. In many cases, the shape of a trajectory cannot capture the real moving path well and hence it may result in generating wrong roads. An example is plotted in Fig. 2 where two GPS trajectories are shown on a road network that is missing. Obviously, these two trajectories, together with other potential similar trajectories, lead to the generation of a new straight road that is wrong. In addition, we have to highlight that low sampling rate trajectories make clustering based on Haus-dorff distance difficult, since it only considers the longest distance between two trajectories and might not be able to find some roads.

Map inference is a technology to generate the whole map automatically, which attracts wide attention both in indus-try and research. It mainly relies on satellite images and/or trajectory data. In other words, map inference has to em-ploy image processing technology to generate map from im-ages [11] and it has to use data mining technology to pro-cess the trajectory data [2, 3, 5, 9, 15]. For performance evaluation, it employs recall and precision as the metrics to quantify the effectiveness of a map inference algorithm [8, 20]. Recall refers to the ratio of the roads successfully gen-erated by the algorithm to all the available roads in the map region; precision stands for the ratio of correctly generated roads to all roads generated by the algorithm. Map inference technology provides a solution to map updating problem by regenerating the whole map. As studied in [8], approach TC1 [9] performs the best among all the existing map infer-ence approaches and it is selected as the representative map inference approach in our experimental study.

Map matching approach is used in our framework in the pre-processing step. Existing map matching technologies can be clustered into three groups, one based on the ge-ometry of each road [14, 20], one based on the topology of the road network [12, 13], and the other based on probabil-ity [10, 16, 19, 21]. As the algorithm proposed in [19] has a good performance and is also adopted in the only existing map updating approach CrowdAtlas, we select it to perform mapmatchinginGLUE.
Without loss of generality, we assume a trajectory consists of a series of two-dimensional points ( x i ,y i ) with correspond-ing time stamps t i , denoted as T =(( x 1 ,y 1 ,t 1 ) , ( x ... ,( x n ,y n ,t n )). A road network (digital map) is modelled as a directional graph G ( V,E ) where V refers to the set of vertexes and E refers to the set of edges (i.e., roads). A road r  X  E has two endpoints represented as r.s  X  r.e . In this paper, GLUE is based on an incomplete road network G .It takes all the unmatched sparse-sampled GPS trajectories as input and tries to recover and then complement the missing road segments to G . To be more specific, it consists of six steps, as shown in Fig. 3. In the following, we first present the main objective and detailed process of each step, and then propose analytical models to select proper values for key parameters used in GLUE.
 Partitioning. The first step, partitioning, is a preprocess-ing step. We observe that GPS points far from each other in most cases belong to different roads. Potentially, we can separate and parallel the processing of multiple roads in or-der to improve the performance, and grid-based clustering offers a way to separate those far away points [17].
The main idea of grid clustering is to create a set of grid cells, to locate each GPS point to the corresponding grid cell, and then to merge adjacent grid cells together as well as to eliminate empty cells. The output of this step is a set of disjoint partitions, with each partition P i formed by a set of connected non-empty grid cells. Due to space limitation, we use an example to illustrate the main idea. As depicted in Fig. 4, all the non-empty grid cells form two partitions, P i on the left and P j on the right.
 Figure 4: Example grids P i and P j formed by parti-tioning step Denoising. The second step denoising is mainly to filter out points that do not contribute to the formation of any road, e.g., points reported by GPS errors. It is a common observation that GPS points with large GPS errors are very likely to be far away from other points. Thus we use a kNN-based approach to detect the noise. Specifically, we denote the distance between a point p to its k th nearest neighbor as p.d k . The larger p.d k is, the more likely that p is a noise. In our work, we introduce a threshold  X  and all the points p with p.d k &gt; X  are filtered out. Note that given the GPS points located in grid cells, we can invoke a range query to find the number of GPS points located within the circle centered at p with  X  as radius to decide whether p.d k &gt; X  . This approach looks simple but is not trivial in practice since  X  should not be fixed and its setting has to consider density of GPS points. It is obvious that how to find a proper  X  is critical. We develop a heuristic-based approach to automatically select proper  X  values for regions with different GPS points distributions, as presented in Section 3.2.
 Direction Calculation. After the denoising step, we have a set of partitions with each containing GPS points that can contribute to the formation of certain missing road seg-ments. If we can cluster points that are on the same road together, we can adopt methods of fitting points to a poly-line [7] to form a road segment. In this way, as long as there are abundant GPS points scattered on the road segment, the centerline of the road can be extracted which is relevant to the sampling rate.

In order to find points on the same road, we need informa-tion other than the position. One important information we want to consider is the heading direction of vehicles. Unfor-tunately, we cannot decide the heading direction of a vehicle based on the direction formed by the two consequent points with low sampling rate trajectory data as the example shown in Fig. 2.

Given a GPS point p , intuitively, the direction of p shall align nicely with the road segment. In other words, nearby GPS points that capture the trajectories passing by the same road segment shall have same or very close direction. Mo-tivated by this observation, we count the number of GPS points that fall within different small rectangles formed by p along various directions. The one containing the maximum number of GPS points can help determine the direction of p , denoted as p. X  . Note that a direction is a relative angle to the baseline (e.g. a horizontal line) and p. X   X  [0 , X  ), for-mally defined in Definition 1. The intuition is that, given a fixed shaped rectangle formed by p , when the rectangle is located along the correct direction of p , it shall cover the maximum number of GPS points. We assume the average cost of range query is proportional to r l  X  r w ,i.e,thesizeof rectangle used in this step. We traverse angles in [0 , X  )with astepof  X  step (1 / 24  X  in our experiment). Thus, the com-putational cost of the direction calculation for each point is O ( r w  X  r l  X   X   X  the determination of direction and the computational cost, they are not selected randomly. We have developed a scheme to select the optimal values of r l and r w , as to be presented in Section 3.2.
 Figure 5: Example of direction calculation step
Definition 1. Point Direction :Givenapoint p , two pa-rameters r l and r w and a direction  X  , count ( p,  X , r l function that counts the number of GPS points fallen within a r l  X  r w rectangle formed by p and  X  , as illustrated in Fig. 5. The direction of p , denoted as p. X  , is the direction  X  such that count ( p,  X , r l ,r w ) is maximized, i.e., Clustering. After calculating all points X  directions, we clus-ter them and prepare for the polyline fitting step. The aim of this step is to group points on thesameroad together. Apoint p has three fields ( p.x, p.y, p. X  ), referring to spatial coordinates and direction. Traditional clustering methods, such as k-means, DBSCAN and SNN [6, 17], are not directly applicable in our case, for reasons including i) the shape of cluster is linear which makes k-means unworkable and ii) clusters are attached to each other which makes density-based clustering methods falsely cluster several clusters to-gether. Instead, we propose a greedy based linkage cluster-ing algorithm as a solution.

Our algorithm is based on an intuition that points on the same part of the road always have a relatively similar direc-tion, and they are close to each other. In order to evaluate the proximity from a point p to a cluster that is represented by a set of points C , we use the distance from p to its nearest neighbor within C as the distance from p to C ,asformally defined in Definition 2.

Algorithm 1 lists the pseudo code of our clustering al-gorithm. It takes the set of GPS points, and two thresh-olds th dis and th dir as inputs, and outputs a set of cluster C i generated. It first randomly picks a point p  X  P that has not yet been clustered to form a new cluster C i ,and then inserts all the points p  X  P with d ( p ,C i )  X  th dis | p . X   X  C i . X  | X  th dir into the newly formed cluster C i we use the average direction of all the points currently clus-teredincluster C i as the direction of C i , denoted as C The above process repeats until all the points in P have been clustered. Note that clusters with very few points will be ignored in the following steps.

Fig. 6 depicts an example. Assume all the points shown in Fig. 6 form the input point set P , and we randomly pick a point to form a new cluster C i , as shown in Fig. 6(a). There-after, we gradually add points to C i , as shown in Fig. 6(b) and Fig. 6(c), until none of existing points can be added. Similarly, we form another cluster C j for the rest of the points, as shown in Fig. 6(d).

Definition 2. Distance to Cluster :Givenapoint p and a cluster represented by a point set C ,let p  X  C be the point that is nearest to p in C , i.e.,  X  p  X  C , d ( p, p )  X  d ( p, p ). Thedistancefrom p to cluster C , denoted as d ( p, C ), is d ( p i ,p j ) returns the Euclidean distance between p i Algorithm 1 Clustering 1: i =0; 2: while P is not empty do 3: randomly select a point p from P ; 4: new cluster C i = { p } , i ++; 8: return C i s; Polyline Fitting. After we cluster the points, we fit points within one cluster into a polyline poly i via algorithm pro-posed in [7] and then compute its direction, denoted as poly i . X  , following Definition 3. If | poly i . X   X  C i . X  and | poly i . X   X  C i . X  | &lt; X   X  th dir , poly i will be ignored as C may not be a cluster on a missing road or poly i is wrongly generated. Due to space limitation, we skip the detail of this step.

Definition 3. Polyline Direction : A polyline poly i can be presented as a sequence of points ( p 1 ,p 2 , ..., p m direction is defined as the length-weighted average of the segment direction, i.e., poly i . X  = v direction of this vector.
 Road Merging. After generating the polylines, we can at-tach the road segments to the map in this step, based on following three criteria as defined in Definition 4, 5, and 6. To be more specific, trajectory-reachable ensures the con-fidence provided by the trajectory data; point-reachable is weaker but more robust than trajectory-reachable criterion under the low-sampling condition, as it is very rare for low-sampling rate trajectories to have two adjacent points lo-cated on two adjacent roads. Note that there is no need to satisfy both trajectory-reachable and point-reachable crite-ria. The decision on which one should be adopted is based on the property of the data. Furthermore, the reasonable criterion prevents generating the redundant topological re-lationship of the roads. Although there are some parameters introduced in the criteria, setting these parameters is empir-ical, based on the property of the data. That is to say, the better the quality of data, the stricter the criteria. Besides, since the merging process does not affect the generation of the roads which is the main object of GLUE, we do not take these parameters into consideration.
The merging process is incremental. Everytime, we tend to select a generated road near to an intersection of G c attach it to G c , after which G c is updated. The process continues until all the roads are attached to G c .Weskipthe determination of road direction as it is straightforward with the help of trajectory-reachable and our space is limited.
Definition 4. Trajectory-Reachable : Given two road segments r 1 , r 2 and a trajectory set T , if there are  X  trajec-tories satisfying that each trajectory has two adjacent points p call r 1 and r 2 are trajectory-reachable . d ( p, r ) denotes the vertical distance from point p to road segment r .
Definition 5. Point-Reachable : Given two road segments r , r 2 , and a trajectory points set P , we construct the graph as following.  X  p i ,p j  X  P ,if d ( p i ,p j ) &lt; X  , p connected via an edge. If r 1 .e and r 2 .s belong to the same connected component, r 1 and r 2 are point-reachable .
Definition 6. Reasonable : Given two road segments r 1 , r r to r 2 is reasonable , where d G c ( p i ,p j ) denotes the distance between vertexes p i ,p j on the road network G c . Note that d c ( r 1 .e, r 2 .s )=
Our GLUE framework relies on some parameters to pro-cess the GPS points. Because of space limitation, we in the following explain how to decide five most important parame-ters, including i) parameter  X  used in our first filtering step; ii) parameters r w and r l used in direction calculation step; and iii) parameters th dis and th dir used in clustering step. Selection of  X  . In our filtering step, if the majority of the error points can be successfully filtered out, it can signifi-cantly improve the performance of following steps. How to determine the value of  X  ? In our work, we utilize a common property of all the correct GPS points to derive the value of  X  . Given a road segment s , we represent it using a center line with width 2 L d . Here, L d denotes the average width of the roads (10.79m in our experiments). If S ( T ) represents a set of trajectories T that can be successfully mapped to s , the vertical distance  X  from a GPS point p  X  T to s follows the Gaussian distribution [4], i.e., p (  X  )= e  X  Without loss of generality, we assume  X  =0andGPSpoints mapped to different road segments share a common  X  value. Consequently, we can use all the GPS trajectories that are successfully mapped to existing road network (i.e., those tra-jectories not considered by our work) to derive  X  value (e.g., 15.4307 in our experiments).

For better description, we define the coordinate axes as showninFig.7.Wedenote N ( p,  X  ) as the number of GPS points that have their distances to a given point p bounded by  X  , as shown in Eq. 1 .

Note,  X  here is the density. As presented in denosing step, we re-express the denoising criteria in a perspective of k . Given  X  fixed, all the GPS points p with N ( p,  X  ) &lt;k shall be filtered as the distance to their k th nearest neighbor p.d is definitely larger than  X  . Since noisy points are all far away from the centerline of the road, filtering the noise is equiv-alent to filtering out the points whose vertical distance to r is larger than  X  M ,say1 . 5 L d in our experiment. Note that Eq. 1 is monotonous with d ( p, s ), i.e., | p.x | .Thus,weaim to find a proper  X  to satisfy the critical stated, that is to say, N ( p,  X  )= k where d ( p, s )=  X  M . By solving this function (using square to approximate the circle integral domain can achieve a simple analytic solution which can greatly save time for the solving process), we can get  X  .
 The only problem remained is how to get the density  X  . We notice that the distribution of points in different areas could be very different. Thus,  X  should be changed with the change of points X  distribution rather than set to a fixed value. Consequently, we propose a way to estimate  X  of the region near p . With the help of grids generated in the first step, we first find all the non-empty grids g near p ,e.g.less than 100m. The area covered by these girds are denoted as area ( g ). We use area ( g ) / 2 L d (2 is for the sake of bi-direction roads) to approximate the length of road segments near p . Thereafter, the density  X  corresponding to the region isthenumberofpointsin g . Selection of r w , r l , th dis and th dir . Recall that our direction calculation of point p relies on two parameters r and r l which are inputs for the function count ( p,  X , r and our clustering algorithm relies on two threshold th dis and th dir . We explain the settings of those four parameters together as their values are correlated. We need r w and r to derive the direction of p , so that we can assign p to the cluster C it belongs to. In the clustering process, only a point p with | p. X   X  C. X  | X  th dir might be clustered into C . For simplicity, we use C. X  as the baseline of direction, i.e., C. X  = 0, such that p. X   X  th dir  X  X  p. X   X  C. X  | X  th dir .
Intuitively, the density of points close to s is higher than that of points far away from s . In other words, for a point p located on the boundary ( p 2 in Fig. 7) of a road segment s (i.e., points that have the largest distance to s consid-ered in our filtering step), p b . X  is larger, compared with other points closer to s ( p 1 in Fig. 7). Consequently, the setting of r w and r l is to serve the boundary points p b to make sure | p b . X  | X  th dir . As the calculation of p depends on function count ( p,  X , r w ,r l ), we try to estimate count ( p b , X ,r w ,r l )basedonEq.2.
Note, here  X  is the density, introduced when we explain how to determine the value of  X  ,and p ( x ) is a Gaussian prob-ability distribution function. The larger the count ( p b value, the smaller the direction. Therefore, we take the derivative with respect to  X  and set it to zero to get p b p . X  =  X  0 where  X   X  X  count ( p b , X ,r w ,r l )  X  =  X  0 = 0 . In our ex-periments, we fix r w to L d to ensure most area of the rectan-gle can cover the points. Then, we plot  X   X  X  count ( p b , X ,r as a function of (  X ,r l ). As marked contour shown in Fig. 8, there are a set of (  X ,r l ) pairs where  X   X  X  count ( p b which infers that for a point p b ,themaximumdirectionof a boundary point is  X  ( i ) given r ( i ) l .Consequently,werely on experimental results of our clustering algorithm to select a good threshold th dir for the direction (e.g., 25 o in our ex-periments) and this experiment will be conducted only once. All the (  X ,r l )pairswith  X &lt;th dir are feasible. Recall that the computational cost of direction calculation is propor-tional to r l and this step is the most time-consuming part in GLUE, which means we prefer a smaller r l . From Fig. 8, we can infer that when  X  =25  X  , r l achieves its minimum as highlighted in the figure. Last but not least, to ensure p can be added into the cluster, we set th dis to L d as well.
In this section, we first introduce a robust quantitative evaluation method for map updating approaches since the existing work relies on manual approaches to evaluating the generated roads [18]. Thereafter, we study the impact of different parameters on the performance of GLUE and then compare our approach with other state-of-the-art approaches based on newly developed evaluation approach. Finally, we demonstrate how GLUE can update the roads in real appli-cations.
As mentioned before, existing work relies mainly on man-ual efforts to evaluate the quality of generated road seg-ments. Although it is easy to implement, it has lots of limitations, e.g., the lack of scalability and the relatively high error rate of manual evaluation. Consequently, we want to propose a method of evaluating map updating algorithm quantitatively. In order to achieve this objective, we need a method to judge whether a road is correctly generated or not which requires a ground-truth map. In an ideal case, a ground-truth map is a map that contains all the roads in the real world, which might not be available in many cases. In the following, we explain how to construct a ground-truth map based on existing map.

First, we match all the trajectory data to a given map us-ing map matching algorithm proposed in [19]. A map with relatively good quality (e.g., covering many parts of the road network) is highly recommended as it serves as our ground-truth map. For all the trajectories that cannot be matched to the given map, they are excluded from our evaluation in this step. The reason is that some of them are sampled from the real missing roads that are not present in the ground-truth map and the roads generated from those data will be reported as false. In other words, we exclude those trajec-tories that cannot be matched to the original map because we do not have the ground-truth to verify whether the roads generated from those trajectories are correct. Thereafter, we randomly delete some road segments from the ground-truth map, and try to recover those removed road segments using our approach.

Definition 7. Correctly Recovered Segment :Given asegment s m which is part of a missing road (e.g., s 1 and s 3 in Fig. 9), let road r g (e.g., Generated road in Fig. 9) be the one that is nearest to s m , among all the generated roads. We then project both endpoints of s m to r g and get the projected segment s g (e.g., s 2 and s 4 in Fig. 9). If both of the projection distance do not exceed a distance threshold  X  , and the angle between s m and s g is less than an angle threshold  X  0 , we consider the missing segment s m is correctly recovered . In our experiment, we set  X  as the average width of all roads in map (i.e., 10 m) and  X  0 as the angle threshold used in our clustering step (25  X  ).
 Figure 9: Example of a correctly recovered segment
We partition the removed road into small segments with equal length (20m in our experiments). We then introduce the concept of correctly recovered segment , formally pre-sented in Definition 7. For example in Fig. 9, s 1 is correctly recovered and s 3 is not since  X  3 and  X  4 exceed the thresh-old  X  0 . All correctly generated segments are collected and we rely on the total length of correctly generated segments to evaluate the performance of different map-updating al-gorithms via recall and precision , as defined in Eq. 3 and Eq. 4 respectively. Here, recall rate measures how complete the updated map is and the precision rate indicates how ac-curately the algorithm generates roads. R m refers to the set of missing roads that we purposely delete from our ground-truth map and R g is the set of generated roads. I [ condition ] is an indicator function which returns 1 if the condition is true and 0 otherwise. We use r to indicate a road and s refers to a segment of a road, and the function len ( r )isto return the length of r .
In addition to the recall and precision, we also introduce the metric of F-score . It tries to integrate both recall and precision, as defined in Eq. 5. In our study, we download the Singapore map from Open-StreetMap 2 and choose three representative regions. Re-gions with low trajectory density are ignored as we prefer high trajectory density. Each of the selected regions cov-ers roughly 20% of Singapore. We delete randomly road segments from the map, in total 106.33 km. Fig. 10 shows a small region of our experiment as an example. Roads within the circles (i.e., those in red) are the ones randomly deleted. The experiments are based on real trajectory data from one of the largest taxi companies in Singapore. Each taxi has GPS installed, and it reports its location regularly. In our studies, we use the trajectories reported from 1 Jan-uary 2011 to 15 January 2011, in total 225,000 trajectories generated by about 15,000 taxis and the average sampling rate is about 30s. Please refer to [1] for a detailed description of the dataset.

Figure 10: A sample region with deleted roads
Table 1 lists the most important parameters introduced in GLUE. We have explained how to decide the values of  X  , r w ,r l ,th dis and th dir . Here, we conduct experiments to study the impacts of different parameters on GLUE and to demonstrate the effectiveness of our parameter inference approach.
 Parameter  X  . First, we perform the denoising step in a re-gion with different point densities to demonstrate the effec-tiveness of our heuristic-based auto-tuning method. Fig. 11 visualizes the result of the denoising process under different  X  . Fig. 11(a) plots all the points in the area. When  X  is set to a small value, GLUE performs well around the high density areas, as shown in Fig. 11(d). However, points on the low density areas are filtered out. On the other hand, when  X  is set to a big value, the denoising process is not so strict that the non-noise points on the low density ar-eas are preserved but noises in the high density areas are hardly filtered out, as shown in Fig. 11(c). Result of our auto parameter tuning approach is shown in Fig. 11(b). As observed, it works very well in both dense areas and sparse http://www.openstreetmap.org/ areas since it can automatically adjust  X  by estimating the density.
 Parameter r w and r l . Next, we conduct the experiments to study the impacts of parameters r w and r l .Asdiscussed in Section 3.2, we set r w to 10m and then see how r l effects the performance of GLUE, with the efficiency in terms of timetakenandaccuracyofGLUEshowninFig.12. As r increases its value, the cost of direction calculation in-creases accordingly although the performance (i.e., recall, precision, and F-score) also improves. When r l exceeds 30m, the performance has an obvious enhancement. This is in ac-cordance with our conclusion in Section 3.2, i.e., when r exceeds 35.96m, the difference between the direction of the points located on the edge of the road ( p b . X  ) and the direc-tion of the cluster ( C. X  ) will not be larger than th dir means all the points on the road will be clustered in the same cluster. A larger r l triggers a scanning of more points which directly increases the computation cost and this step is the most time-consuming step as shown in Fig. 12(a), and hence in practice r l should be as small as possible. This ex-periments also demonstrate the effectiveness of our analytic method of calculating the minimum of r l . Parameter th dir . We next conduct the experiment to study the impact of direction threshold th dir introduced in the clustering step. Fig. 13(a) shows the result. When th increases, it is easier for a cluster to retrieve the points near it. Thus, by absorbing those points which have different di-rections, many wrong clusters might be formed. Recall that when we fit a polyline for a cluster, we also check the average direction of the points within the cluster and the direction of the polyline to eliminate those wrongly generated clus-ters. As a result, with the increase of th dir , more wrongly generated clusters are eliminated which explains the high precision value (85%+) but dropped recall value. Note that when th dir is too small (e.g., 5  X  ), clustering becomes harder which directly affects the recall. Based on F-score, we con-clude that the ideal value of th dir is between 10  X  and 40 which explains why we set th dir to 25  X  ((10  X  +40  X  ) / 2) in Section 3.2.
 Parameter th dis . Finally, we investigate the impact of th dis . According to Fig. 13(b), the performance of GLUE drops when th dis exceeds 20m. This is because points on the different road may be clustered together, similar as the rea-son we list above for th dir . Note that the precision reduces, which is different from the results on th dir . The reason is that varying th dis will not trigger the elimination of those clusters with wrong directions thus the precision drops. In addition, the smaller number of eliminated roads explains why the recall in th dis declines in a slower pace than that in th dir . On the other hand, when th dis is smaller than 10m, the performance also drops. It is resulted by the failure of clustering, which means points on one road may be clustered into several tiny parts and some of them may be eliminated. According to F-score, th dir should be set between 10m and 20m (i.e., the average width of the roads), which justifies our selection of th dir to be the average width of the roads is reasonable.
In this section, we compare the performance of GLUE with two competitors, including a map updating algorithm CrowdAtlas [18] and a map inference algorithm TC1 [9]. As presented in Section 2, CrowdAtlas and TC1 represent the state-of-the-art techniques to the best of our knowledge. They are the latest proposed methods in map updating and map inference problems and have best performances.
First, we report the recall rate of three algorithms un-der different sampling rate trajectory data in Fig. 14(a). It is observed that the recall rate of all algorithms drops as the sampling interval increases, and our algorithm GLUE performs consistently much better than the other two. Al-gorithm GLUE is able to achieve a much higher recall rate, and it is also much more resilient to the sampling rate. On average, GLUE can achieve a recall rate that is about 1.7 times and 6 times better than that of CrowdAtlas and TC1 , respectively.

Second, we investigate the precision of different algorithms, with the results again under different sampling rates plot-ted in Fig. 14(c). All methods have relatively high preci-sion (e.g., 85%), when the sampling rate is at 30 seconds perpoint. Withtheincreasesofsamplingintervals,preci-sion of both TC1 and GLUE increases a little bit but that of CrowdAtlas drops. CrowdAtlas and TC1 actually share very similar ideas on clustering trajectories and generating roads, but TC1 has a much higher precision than CrowdAtlas . The reason is that TC1 implements a pruning step. In the pruning step, trajectories are divided into small segments and those in turning corners are pruned away. With the
Figure 14: The results of comparison experiments increases of sampling intervals, more segments are pruned away and only those on straight roads remain, which im-proves the accuracy of clustering step. However, because of thesamereason, TC1 has a very low recall rate as this prun-ing step brushes off too many trajectories and it only can generate long straight roads. On the other hand, CrowdAtlas utilizes all the trajectories as input and clusters them to generate roads. Without implementing any filtering step to filter out error GPS points, CrowdAtlas always generates many roads with many of them not correct. This explains why CrowdAtlas has a high recall rate but a low precision.
Third, we examine the F-score of all three algorithms, with their performance under different sampling intervals shown in Fig. 14(e). Recall that F-score is synthesised by recall and precision using Eq. 5. We observe that as the sampling interval increases, less GPS points are available for road generation and F-score of all three algorithms drops. We also want to highlight that GLUE performs significantly better than the other two in all cases. To be more specific, GLUE achieves a F-score that is about 1.6 times higher than that of CrowdAtlas and 4 times higher than that of TC1 in average.

Last but not least, we also report the average performance of three approaches in Fig. 14(b), 14(d) and 14(f), by using the GPS data collected in different durations ranging from 1 day to 15 days. It is observed that the recall rate of all the algorithms increases as the duration extends. GLUE has the highest recall rate consistently, almost 1.5 times better than that of CrowdAtlas and 2 times better than that of TC1 . As for precision, all three algorithms have high precision although GLUE in most cases performs the best. We also notice that TC1 has the highest precision when we consider only one-day X  X  data. As explained before, TC1 prunes away lots of GPS points and it only generates long and straight road segment. This explains why it has a very high precision but a low recall rate.
In map updating, we need to decide whether we should accept all the roads generated by GLUE. Here, we propose a function to evaluate the confidence of a generated road. Intuitively, a longer road which has more existing trajecto-ries located on it tends to have a higher chance to be real. Thus, we take the length l and the density  X  into consid-eration.  X  is the density of the GPS points introduced in Section 3.2. Moreover, a road with a smoother shape should have a higher confidence than a tortuous road. Thus, we also take the angle in the shape of the road into account. Besides, under the observation that the distribution of the points located on a correctly generated road should follow Gaussian, we consider bias of the distribution as well. Ac-cordingly, the confidence evaluation function for a generated road  X  r is defined below.
 C ( X  r )=
The first factor N  X   X  0 , X  2 / N 0 0 , X  2 evaluates the distribution of the points, where  X   X  is the average distance from points near  X  r to  X  r and N 0 0 , X  2 is a normalization coefficient. Before we introduce the next tree factors, we first introduce the logistic function L (  X  ). A logistic function is commonly used as a threshold function with smoothing: where k and x 0 are the parameters controlling L .Indetail, k controls the steepness of the curve and x 0 is the x -value of the midpoint of the curve which also can be regarded as the threshold. Once x is larger than x 0 , L ( x ) will become much closer to 1 and when x is smaller than x 0 , L ( x ) will suddenly drop down to 0. Fig. 15(a) shows how k and x 0 effect the shape of L . The second and the third factors evaluate the density and length of  X  r correspondingly.  X  0 and l 0 are the threshold set by the user according to different situations. The last factor  X  L  X  k 3 ,  X  2 evaluates the shape of the generated road.  X  iterates the angles formed by adjacent segments in a polyline ( X  r ). A road with some acute angles will be penalized through the logistic function with threshold setting to  X / 2. Note that k 1 ,k 2 ,k 3 , X  0 and l 0 are set by user according to different needs. A higher k will exert a severer penalization to those roads failing to meet the threshold, which enlarges the importance of the corresponding feature. In our experiment, we set k 1 =2 ,k 2 =0 . 02 ,k 3 =6 , X  0 and l 0 = 100 under the 15 days X  dataset. (a) example of logistic function Figure 15: Example and result for confidence test
Fig. 15(b) shows the performance using different confi-dence thresholds th c to reject some generated roads. Note, when threshold set to 0, all roads will be accepted. With the increase of th c , the precision increases and the recall drops, which is consistent with our expectation. As more roads are filtered by th c , recall drops. On the other hand, roads with low precision are eliminated. Consequently, wrong gener-ated roads are rejected and precision arises. We can con-clude that roads with confidence over 0.8 can achieve over 90% precision; from the fact that recall drops from 0.73 to 0.52, we can infer that most roads generated by GLUE have a relatively high confidence. Note that th c could be tuned based on how important the precision is, as compared with the recall.
The experiments conducted above are all based on the randomly deleted roads. Here, we focus on finding out the missing roads in a real application. Fig. 16(a) visualizes the generated roads on top of the satellite map downloaded from OpenStreetMap (OSM)in 2012, based on the Singa-pore Taxi trajectories collected in 2011. Points in the same color belong to the same cluster except that those in gray are the noise detected by our denosing algorithm. This further shows the ability of our denoising algorithm to handle points with different density automatically. Our approach success-fully generates almost all the missing roads which existed in 2011 and correctly recovers the topological relations of the roads. Fig. 16(c) and Fig. 16(e) show the map of the same region downloaded from OpenStreetMap and Google Map recently. We can see although some roads existed 4 years ago (i.e., those inside the marked rectangles), they have not yet been updated as they are still missing in maps.
Fig. 16(b) shows the generated road from the trajecto-ries collected by the Geolife project. Detail of this dataset can be found in [22]. We endeavor to repeat all the quan-titative experiments presented above using this dataset but unfortunately it is very hard, mainly because the volume of this dataset is very small (1/250 of Singapore X  X  dataset, per unit area) and it only covers a very small portion of Bei-jing X  X  road network. As a result, we can hardly find enough points located on most randomly deleted roads to support the updating. Therefore, we only conduct one experiment to generate missing roads. The dataset is generated in 2009 but we do not have 2009 Beijing map. Hence, we plot our results on top of the map downloaded from OpenStreetMap in 2014, as shown in Fig. 16(b). Again, we compare our results with the maps available online. Consistent with ob-servations made based on Singapore taxi datasets, we notice some of the roads in Beijing successfully generated by GLUE still do not exist in maps available in OpenStreetMap and Google Map today, shown in Fig. 16(d) and 16(f) respec-tively. Roads in red in Fig. 16(b) are the roads with low confidence, showing that our confidence evaluation method is able to eliminate some wrong roads. Even though the data quality is quite low, GLUE can still detect the roads correctly. This area shows some small roads in a hospital with roads in this estate having not been updated, which means the map updating approach is necessary.
In this paper, we investigate the problem of map updat-ing using low sampling rate trajectory data. The main chal-lenges of map updating include low sampling rates and lots of noises.

We propose an effective approach to address all the chal-lenges by direction clustering and de-nosing. In order to Figure 16: Results of updating the roads of two re-gions in real cases evaluate the performance of a map updating approach, we also design a robust quantitative evaluation method and compare our approach with another two state-of-the-art meth-ods using the newly proposed evaluation method. With roughly 15-days X  real GPS trajectories from around 15,000 taxis in Singapore, the evaluation result demonstrates that our approach significantly outperforms the existing ones. Besides, we also conduct experiments to demonstrate GLUE does not require manual efforts to decide the values of key parameters. The property of parameter-tuning-free is very desirable in many applications.

In this paper, we only focus on the real roads that are missing in the current map. However, we also observe that some roads in map are actually unavailable in reality, e.g., some closed road segments. In the near future, we plan to find those unavailable roads based on GPS trajectory data. Our ultimate goal is to develop an on-line map updating system that can automatically recover all the missing roads and meanwhile remove all the outdated road segments using low sampled GPS trajectories. [1] R. K. Balan, K. X. Nguyen, and L. Jiang. Real-time [2] L. Cao and J. Krumm. From gps traces to a routable [3] J. Davics, A. R. Beresford, and A. Hopper. Scalable, [4] F. V. Diggelen. System design &amp; test-gnss [5] S. Edelkamp and S. Schr  X  odl. Route planning and map [6] J. Han and M. Kamber. Data mining: concepts and [7] B. K  X  egl, A. Krzyzak, T. Linder, and K. Zeger. [8] X.Liu,J.Biagioni,J.Eriksson,Y.Wang,G.Forman, [9] X.Liu,Y.Zhu,Y.Wang,G.Forman,L.M.Ni, [10] Y. Lou, C. Zhang, Y. Zheng, X. Xie, W. Wang, and [11] M. Mokhtarzade and M. Zoej. Road detection from [12] P. Newson and J. Krumm. Hidden markov map [13] W. Y. Ochieng, M. Quddus, and R. B. Noland.
 [14] B. P. Phuyal. Method and use of aggregated dead [15] S. Schroedl, K. Wagstaff, S. Rogers, P. Langley, and [16] R. Song, W. Lu, W. Sun, Y. Huang, and C. Chen. [17] P.-N.Tan,M.Steinbach,V.Kumar,etal.
 [18] Y.Wang,X.Liu,H.Wei,G.Forman,C.Chen,and [19] H. Wei, Y. Wang, G. Forman, Y. Zhu, and H. Guan. [20] C. E. White, D. Bernstein, and A. L. Kornhauser. [21] J. Yuan, Y. Zheng, C. Zhang, X. Xie, and G.-Z. Sun. [22] Y. Zheng, Q. Li, Y. Chen, X. Xie, and W. Ma.
