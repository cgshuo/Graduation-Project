 Web services are modularized applications on the Internet which allow applications to communicate with each other [1]. The automation of Web services interoperation can bring considerable advantages to effective B2B collaboration. However, the state-of-the-art techniques for Web service composition still require a lot of manual efforts. To support service composition, some composition systems were developed such as SELF-SERV [2]. SELF-SERV is a framework through which web services can be 
In the previous project, we have developed a composition system termed SASO to choose arbitrary services when there are several services for one specific goal. 
The paper presents a method for best selection, which can perform the appropriate rived from Dijkstra X  X  shortest path algorithm because Dijkstra X  X  algorithm is not suit-a selection policy such as minimum cost, the algorithm can find the most appropriate performance but can achieve best selection. experiments on the algorithm. Section 5 concludes this paper. O2...On, it can be expressed by the following rule: An example is illustrated in figure 1, used in the following sections in this paper. 
This example deploys some production rules in the following: In this example, edge from c to e and another from d to e are joined by symbol which means that vertex e is generated from c and d, instead of from any one. is not suitable for composition. paper, these paths are named group-paths and we call this multi-service problem. can generate {e}, the composition system doesn X  X  know this because Dijkstra X  X  algo-and {f} are different vertexes and the system won X  X  know that {f, g} can generate {e}. 
To deal with these problems, we developed an algorithm for best selection derived from Dijkstra X  X  algorithm. Next section will illustrate the algorithm in detail. Let us have a glance at the shortcoming of Dijkstra X  X  algorithm and consider how to needs to be fed into by services A and B where services A and B are named predeces-of vertexes is computed by Dijkstra X  X  algorithm, some actions need to be performed. The services which need to be fed into by more than one service are recorded besides of predecessor services. Then the shortest path of these services can be computed by it and its predecessors. Moreover, we regard elements in a vertex as a whole such as {f, g} and {f}. If {f} generates {e}, {f, g} will generate {e} obviously. However, {f, g} and {f} are different vertexes and the system won X  X  know the fact that {f, g} can tion. 
Consider the shortest path in other point of view. We define the shortest-group-path shortest group-path from s to v ) , ( v s  X  . In general, if vertex v has predecessor m, n and u where m and n produce v collabo  X  can be denoted by the equation 4. group of vertexes which are predecessors of vertex v and produce v collaboratively. E  X  R and source vertex s. Then for all edges has no more weight than any other group path from s to v. Specifically, path p has no source s to vertex u and then takes edges (u, v).  X  group-paths are held for the following query. When user query arrived, the algorithm traverses all shortest group-path and selects the one which meets the need of user. the shortest group-path between vertexes), etc. Then the process to compute the short-not computed in this process. Meanwhile, it cannot deal with the multi-input problem. So post processes are employed to deal wi th these two problems. All these processes are presented respectively in this paper. 
Algorithm 1: Compute All Shortest Group-path input: production list pl. output: shortest group-paths of all pairs of vertexes. begin 1. Let AI, AO, AI X , AO X  be the input, output, input whose number &gt;1 and output whose number&gt;1 of all pro-duction in pl respectively. 2. Initialize(pl). 3. for each entry s in AI 4. Compute shortest path of source s. 5. update the group-path to process multi-input prob-lem . 6. additional process to deal with multi-service prob-lem . End the array of production used for the following process. It also performs some process on multi-input problem. keep the shortest path. 
Algorithm 2: Compute shortest path of source s input: source s. output: the array holding the shortest group-path. begin 1. S={s}, D[s]=0, P[s]=0, Q=AO-S 2. for each entry i in Q 3. D[i]=C[s][i]; P[i]=PU[s][i] 4. while Q  X   X  5. D[k]=min{D[i]:i  X  Q} 6. if(D[k]=  X  ) break; 7. S=S  X  {k} ; Q=AO-S 8. for each entry i in AI X  9. if({k}  X  i) G[i].insert(s, k) 10. for each entry i in Q 11. if(D[i]&gt;D[k]+C[k][i]) 12. D[i]=D[k]+C[k][i]; P[i]=PU[k][i] 13.Distance[s]=D; Path[s]=P end 
After the shortest path of each vertex is produced in algorithm 2, we need to update service problem is taken into account. If more than one vertex in different production produced by {e}. This process is finished in line 6 of algorithm 1. for best selection in composition. We developed a prototype of the algorithm in Java. All experiments were conducted on 1GHz Intel Pentium 4 Processor with 512MB of efficiency by comparing two algorithms from user input aspect. which is omitted in this paper due to space constraints. As shown in figure 3, execu-when more rules are involved in the composition process while the time of composi-number of rules exceeds 400, composition al gorithm without selec tion policy is satis-possible group-path in some order. So time consumed is not varied finally. 
Response time of the algorithm is most important for user. The response time of the user query instead of best selection because the shortest group-path generated in algo-policy when the number of rules is below 420. Once the certain extent exceeds, our algorithm consumes just a little more time which is acceptable but achieves the most appropriate composition plan. The contributions of our work are presenting a method for computing shortest group-path in domain of service composition and developing an algorithm to implement this process. Experiments show that the algorithm achieves the most appropriate composi-tion plan although it sometimes spends a little more time. 
