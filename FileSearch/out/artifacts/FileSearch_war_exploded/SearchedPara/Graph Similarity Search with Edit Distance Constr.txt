  X  Due to many real applications of graph databases, it has become increasingly important to retrieve graphs g (in graph database D ) that approximately match with query graph q , rather than exact subgraph matches. In this paper, we study the problem of graph similarity search, which retrieves graphs that are similar to a giv-en query graph under the constraint of the minimum edit distance. Specifically, we derive a lower bound, branch-based bound, which can greatly reduce the search space of the graph similarity search. We also propose a tree index structure, namely b-tree, to facilitate effective pruning and efficient query processing. Extensive experi-ments confirm that our proposed approach outperforms the existing approaches by orders of magnitude, in terms of both pruning power and query response time.
 H.2.8 [ Information Systems ]: DATABASE MANAGEMENT X  Database applications Graph Edit Distance; Lower Bound; Graph Database
Recently, graph data models have attracted increasing research interests, because many data types in various applications can be modeled as graphs, such as chemical compounds [2], social net-works [16], road networks [1], and Semantic Web [20]. The grow-ing popularity of graph data requires efficient graph data manage-ment techniques. Among these, (sub)graph queries (i.e., given a query graph q , finding all graphs g in a graph database D , such  X  corresponding author: Lei Zou, zoulei@pku.edu.cn that q is (sub)graph isomorphic to g ) have been extensively stud-ied [5,18].

However, the real-life graphs may have many noises, such as protein-protein-interaction networks [10]. In this case, the exac-t (sub)graph isomorphism may lead to empty results to the query. Therefore, we need to design an robust solution to find graphs that are of interest to users even in the presence of noises and errors in the graph database. An interesting topic is to study graph sim-ilarity search, which retrieves all graphs g (in graph database D ) that approximately match with q under some similarity measure constraint. A number of graph similarity measures have been pro-posed [4,8,13,17]. Among them, two classical measures (i.e., max-imum common subgraphs (MCS) [4] and minimum edit distances (MED) [17]) are proposed based on the classical graph theory. Note that the two measures are inter-related [3]. In this paper, we focus on the minimum edit distance (MED). As a widely used structural similarity measure, MED is defined as the minimum operation cost (addition, deletion, and substitution) of transforming one graph q to another graph g (formally defined in Definition 2). Compared with other similarity measures, MED is flexible because it can be used in many applications, such as graph classification and graph cluster-ing [11], objects recognizing in computer vision [7], and molecule comparison in chemistry [9].

In this paper, we study the problem of graph similarity search ( defined later in Section 2) based on the minimum graph edit dis-tance constraint. Since computing the minimum graph edit distance is a NP-hard problem [17], all existing solutions adopt the filter-and-refine framework to speed up query processing. So far, lots of pruning rules have been proposed. Basically, they can be divided into two categories: the global filter and the n-gram based filter. The lower bounds of graph edit distance between a query graph q and a data graph g are computed. Then, the data graphs whose low-er bounds are larger than  X  (  X  is a user specified threshold) can be filtered out safely. 1. global filter. There are two existing global filters. The first one is to utilize the vertex/edge number difference as the lower bound [17]. The second global filter considers the difference of vertex labels and edge labels to further improve the pruning power [19]. Since these methods do not employ the graph structure, the lower bounds are not tight enough for effective pruning. 2. n-gram based filter . The basic idea of these methods is to se-lect some small structures as the n-grams . We can derive the lower bound based on the common n-grams of the two graphs. Wang et al. [15] propose k-Adjacent Tree ( k-AT ) algorithm, which defines a n -gram as a tree consisting of a vertex v and the paths starting at v with length no longer than n . Apparently, a single edit op-eration may affect many k-AT trees, especially when k is larger than 2. The star structure used in [17] is exactly the same as k-AT when k =1 . Specifically, the star-based lower bound in [17] is the mapping distance between g 1 and g 2 according to the bi-partite graph,  X  ( g 1 ) and  X  ( g 2 ) are the maximum degree in g g , respectively. If g 1 or g 2 has a high-degree vertex, the lower bound will be very small. Similar to k-AT , Zhao et al. [19] compute the lower bound by employing the path-based n -grams. However, these path-based n -grams still share many overlapping structures, if there are some high-degree vertices. Therefore, in such a case, the lower bound of the path-based n -grams is not tight.
Generally speaking, the main problem of existing n -gram based pruning methods is that the lower bounds may be not tight enough, since existing n -grams have many overlaps and a single edit opera-tion may affect many n -grams. Considering this limitation, we pro-pose a novel method for edit-distance based graph similarity search problem in this paper. We also propose an index structure to enable effective pruning by the lower bound.

Our lower bound still follows the n -gram approach. However, we use a different n -gram, namely branch , which is defined as a structure consisting of one vertex and the edges incident to the ver-tex 1 ( branch is formally defined in Section 3). The superiority of branch lies in that a single edit operation can affect two branches at most. Therefore, the branch-based lower bound is much tighter than existing n -gram methods.

In order to avoid exhaustively checking all data graphs in D one by one, we build an index structure over graphs in D , namely b-tree , where all leaves are data graphs and all non-leaf nodes are the information union of their child nodes. This index benefits the search processing greatly.

To summary, in this paper, we make the following contributions.
In this section, we first formally define our problem in this sec-tion, and then briefly review the existing solutions.
For the ease of presentation, we consider simple graphs in this paper. A simple graph is an undirected graph attributed that does not contain self-loops or multi-edges, denoted by g . It can be rep-resented by a 6-tuple g =( V,E,L V ,L E ,  X  V ,  X  E ) , where V is a set of vertices, E  X  V  X  V is a set of edges,  X  V and  X  E label sets of V and E , respectively. L V and L E are label functions that assign labels to vertices and edges, respectively.
Definition 1. (Subgraph Isomorphism, Graph Isomorphism). A subgraph isomorphism from g 1 to g 2 is an injection function f
A branch edge does not include the other endpoint except for the branch center.
 V ( g 1 )  X  V ( g 2 ) that satisfies 1)  X  v  X  V ( g 1 ) , f ( L
V ( v ) = L V ( f ( v )) , and 2)  X  e ( v 1 ,v 2 )  X  E ( g  X 
E ( g 2 )  X  L E ( e ( v 1 ,v 2 )) = L E ( e ( f ( v 1 ) ,f
Let g 1 g 2 denote that a graph g 1 is subgraph isomorphic to another graph g 2 .If g 1 g 2  X  g 2 g 1 , g 1 and g 2 are graph isomorphic to each other, denoted as g 1 = g 2 .

There are six primitive edit operations on a graph g [17]: insert an isolated vertex with label, delete an isolated vertex, substitute a vertex label, insert an edge between two vertices, delete an edge, and substitute an edge label. Given two graphs g 1 and g 2 exists a sequence of primitive edit operations to transform g such as, g 1 = g 0 1  X  g 1 1  X  ...  X  g k 1 = g 2 . We may have different operation sequences to transform g 1 to g 2 . The minimum graph edit distance (dissimilarity) between two graphs is measured by the shortest operation sequence length, as defined as follows.
Definition 2. (Minimum Graph Edit Distance). Given two graph-s g 1 and g 2 , their minimum graph edit distance is defined as the minimum number of primitive operations needed to transform g to g 1 , s.t., g 1 = g 2 , denoted by ged ( g 1 ,g 2 ) .
Given the definition of minimum graph edit distance (or called graph edit distance if there is no ambiguity in the context), we for-malize the problem of this paper as follows.
 Problem Statement ( Graph Similarity Search ) Given a query graph q , a set of data graphs g i in D s.t. ged ( q,g i )  X   X  . Figure 1: Example of a query graph q and two data graphs g
Example 1 below is a graph similarity search running example that is used throughout the paper.

E XAMPLE 1. Figure 1 shows a query graph q and two data graphs g 1 and g 2 . ged ( q,g 1 )=6 , ged ( q,g 2 )=7 . If the edit distance threshold is  X  =3 , neither g 1 nor g 2 is the answer, since edit distances of both graphs are larger than 3.

Since most existing graph similarity search algorithms follow the filter-and-verification framework, it is critical to efficiently estimate the lower bound as tight as possible.
Number Count Filter [17]. The graph edit distance ged ( q,g of two graphs g and q will not be smaller than dist N ( q,g || V ( g ) | X  X  V ( q ) || + || E ( g ) | X  X  E ( q ) || .

Label Multiset Filter [19]. This lower bound is computed as dist M ( q,g ) =  X ( M V ( q ) ,M V ( g )) +  X ( M E ( q ) ,M  X ( X,Y )= max ( | X | , | Y | )  X  X  X  X  Y | , M V ( g ) and M the multisets of vertex and edge labels, respectively.
C-star. The star structure defined in [17] is a tree of a single level rooted at a vertex. A bipartite graph can be constructed with two star sets S ( q ) and S ( g ) of q and g , where each star in S and S ( g ) is a vertex, and star pair ( s i ,s j ) is an edge ( s s  X  S ( g ) ) weighted with edit distance between s i and s that the minimum weight matching in the bipartite graph is  X  The star-based lower bound of edit distance between graphs q and g can be computed according to Equation 1, where  X  ( q ) and  X  are the maximum degree in q and g respectively.
E XAMPLE 2. Consider the graphs q , g 1 , and g 2 in Figure 1, where  X  =3 ,  X  ( q,g 1 )=14 ,  X  ( q,g 2 )=16 . We have dist 14 / 6 , and dist S ( q,g 2 )=16 / 6 . Since dist S ( q,g 1 dist S ( q,g 2 ) &lt; X  hold, neither g 1 nor g 2 is pruned by this filter.
Although star-based filter captures some structure information, c-stars may have lots of overlapping structures, which results in a huge penalty by max { 4 , [ max {  X  ( q ) , X  ( g ) } +1] } graph q or g has some large-degree vertices, the lower bound will be very small caused by the large denominator. This problem motivate us to find an effective filter (i.e., less overlapping structures). That is the branch filter proposed in Section 3.

Tree-based n -grams ( k-AT [15]). It defines a n -gram as a tree consisting of a vertex v and the paths starting from v with length no larger than n . Its main principle is based on the observation that if ged ( q,g )  X   X  , graphs q and g must share at least dist T ( q,g )=max( | V ( q ) | X   X   X  D t , | V ( g ) | X   X  common n -grams, where D t is the maximum number of tree-based n -grams that can be affected by an edit operation.

E XAMPLE 3. Consider q , g 1 , and g 2 in Figure 1, where  X  = n = 1 . dist T ( q,g 1 )=1 , dist T ( q,g 2 ) = 1 . Actually, q has 1 and 0 common tree-based 1 -gram with g 1 and g 2 , respectively. Hence, g can be pruned, whereas g 1 will pass the filter. If  X   X  2 g nor g 2 can not be pruned.

Path-based n -grams [19]. It defines a n -gram as a path of length n .If ged ( q,g )  X   X  , graphs q and g must share at least dist P ( q,g )=max( | MG ( q ) | X   X   X  D p , | MG ( g ) | X  common n -grams, where MG ( q ) and MG ( g ) denote the multiset-sof n -grams in graphs q and g , and D p is the maximum number of path-based n -grams that can be affected by one edit operation. Clearly, if there is a high-degree vertex, there are many paths con-taining the vertex. It also means that D p is very large, which incurs to low pruning power.

E XAMPLE 4. Consider q , g 1 and g 2 in Figure 1,  X  =1 , and n =1 . dist P ( q,g 1 ) =2, dist P ( q,g 2 ) = 2. Actually, q has 4 and 2 common path-based 1 -grams with g 1 and g 2 , respectively. Hence, both g 1 and g 2 can pass this filter. If  X   X  2 , both dist dist P ( q,g 2 ) will be smaller than 0. Thus, neither g 1 pruned.

In order to improve the pruning power, we propose a novel filter, namely the branch -based filter( Section 3).
As discussed in the previous section, the pruning abilities of global filters and existing n-gram filters are limited. In order to ad-dress these problems, we propose to use the  X  X ranch X  as the n-gram. It has two benefits. First, branch filters can provide the tighter lower bound than existing ones. Second, by using the branch structures, it is easy to devise an effective index to speed up the query process-ing. Specifically, we present the branch filter in this section.
Definition 3. (Branch Structure) A branch structure b is a ver-tex v and the multiset of edge labels incident to v , represented by b ( v )=( l v ,ES ) , where l v = L V ( v ) is the label of the root vertex, and ES = { L E ( e ) | edge e is adjacent to v } is the multiset of edge labels adjacent to v .
Figure 2 shows the branches of graphs q and g 1 in Figure 1. D-ifferent from stars in [17], a branch only considers edges adjacent to the root vertex. Thus, one edit operation affects two branches at most regardless of the degrees of the vertices. Therefore, the prun-ing power of branch-based filter is much more stable than other existing n-gram filters, since the pruning ability of existing lower bounds depends on the maximum vertex degree in graphs. Ac-cording to the definition of branches, we define the distance of two branches as follows.

Definition 4. (Branch Distance) Given two vertices v 1 and v their branches are denoted as b 1 =( l 1 ,ES 1 ) and b 2 =( The branch distance between b 1 and b 2 is defined as follows: where
Given two graphs q and g , we can enumerate all branch struc-tures of q and g to obtain two sets, B ( q ) and B ( g ) , respective-ly. Thus, we can construct a bipartite graph like that in Figure 2, where vertices represent branches and edges represent transforma-tions between any two branches (from B ( q ) and B ( g ) respective-ly) weighted with the their pairwise branch edit distance (defined in Definitin 4).

Definition 5. Given two multisets of branches B ( q ) and B with the same cardinality (we can add some branches if | B |
B ( g ) | ), and assume P : B ( q )  X  B ( g ) is a bijection. The mapping distance between B ( q ) and B ( g ) is
Clearly, the bijection P in Equation 4 is the minimum weighted match in the bipartite graph. Based on the distance between B and B ( g ) (i.e.,  X  ( q,g ) ), we can obtain a lower bound of the edit distance between q and g , as shown in the following theorem.
Theorem 1. Given two graphs q and g , their graph edit dis-tance and the mapping distance between B ( q ) and B ( g ) inequality: ged ( q,g )  X  dist B ( q,g )=  X  ( q,g ) , where B B ( g ) are the branch structure multisets of q and g respectively, the branch structure-based lower bound is denoted as dist B (
P ROOF . Let P =( p 1 ,p 2 , ..., p k ) be an alignment transform-ing q to g . Accordingly, there is sequence of graph q = q q 1  X  ...  X  q k = g , where q i  X  q i +1 indicates transforming q to q i +1 by operation p i . Assume that there are k 1 edge inser-tion/deletion/relabeling operations, k 2 vertex insertion/deletion/re-labeling operations in P , then k 1 + k 2 = ged ( q,g ) . 1) Edge Insertion/Deletion/Relabeling: If an edge is inserted or deleted or relabeled over the graph q i , only two branches are af-fected. Thus we can know that  X  ( q i ,q i +1 )  X  2 / 2=1 of inserting or deleting or relabeling an edge over q i . 2) Vertex Insertion/Deletion/Relabeling: As discussed in [17], a vertex can be deleted only on the condition that it is an isolated vertex, and we can only insert an isolated vertex. If a vertex is inserted or deleted over q i ,  X  ( q i ,q i +1 )=1 . When the label of a vertex v is relabeled, only the branch rooted at v is affected. Hence,  X  ( q i ,q i +1 ) is 1. Above all, we have the following inequality:
E XAMPLE 5. Consider graphs q , g 1 , and g 2 in Figure 1. Ac-cording to Theorem 1, dist B ( q,g 1 ) = 4 and dist B ( q,g of which are larger than 3 . Hence, g 1 and g 2 can be pruned out safely when  X   X  3
As described in Example 5, graphs g 1 and g 2 can be pruned safe-ly employing the branch-based filter. On the contrary, neither g nor g 2 can be filtered out by exiting lower bounds.
In this section, we first introduce the b-tree index, and then give the query processing followed by the construction of b-tree .
Given a query q and a database D , we need to exhaustively check the lower bound of ged ( q,g ) (i.e., branch filter dist B graphs g (  X  D ) one by one. Obviously, this is a long and tedious process, especially when | D | is very large. In order to avoid the sequential scan, we propose an index b-tree (because it stores the b ranches of each graph g  X  D ) as follows. Generally, b-tree is a height-balanced tree, analogue to B + -tree and R -tree.
Definition 6. A b-tree is a height-balanced tree, where (1) Each leaf node stores B ( g ) , the branch set of g , corresponding (2) Each intermediate node N is union of all its child nodes, i.e., .

Figure 3 shows an example of b-tree index structure. The con-struction of b-tree is similar to B-tree and R-tree . We will discuss b-tree construction in Section 4.3. Assuming that the b-tree has been built, we focus on how to utilize b-tree to perform the query.
The general framework is as follows. Given a query graph q , we traverse the b-tree starting from the root. Considering an inter-mediate node N i (in b-tree ), we define the directed branch-based distance (denoted as dist DB ( q,N i ) ) between q and N i rem 1. If this distance is larger than  X  , all the descendants of N can be pruned safely. The following definition and theorem show the details of the above pruning strategy.

Definition 7. The directed branch-based distance from a query graph q to an intermediate node N i , denoted as dist DB ( the minimum edit distance of transforming B ( q ) into B ( that B ( q )  X  B ( N i ) .

To compute dist DB ( q,N i ) , we only need to add | B ( q branches (dummy branches without any vertex and edges) into B and then construct a bipartite graph according to B ( q ) Finally, compute the minimum weighted match in the bipartite graph using Hungarian algorithm [6].

Theorem 2. If the directed distance dist DB ( q,N i )  X  ( all the children nodes of N i can be pruned.

P ROOF . Since N i is the union of its children nodes, the common branches between q and N i must be more than that between q and N , where N j is one child node of N i .
In this subsection, we propose the query algorithms for graph similarity search. Note that, we only focus on the filtering process, i.e., finding candidates. Any graph edit distance algorithm (such as [19]) can be used in the verification process.

Given a query graph q , we traverse the index b-tree starting from the root. For an intermediate node N i , we compute the directed distance dist DB ( q,N i ) .If dist DB ( q,N i )  X  (  X  +1) safely prune the subtree rooted at node N i . Otherwise, the subtree will be accessed. Furthermore, if the current node is a leaf node g , we need to compute the branch lower bound dist B ( q,g ) between q and g .
Since b-tree is analogue to R-tree , we can build b-tree by in-serting the graphs sequentially. An insertion operation begins at the root and iteratively chooses a child node until it reaches a leaf node. The given graph is inserted at this leaf node. The main chal-lenge of insertion is the criterion for choosing a child node. We define the similarity between a graph g and a node N i as the di-rected branch-based distance between B ( q ) and B ( N i ) Definition 7). We omit more details about the b-tree construction, since it is similar to R-tree .
In this section, we evaluate the performance of our proposed method (denoted as simB ), and compare with c-star [17], k-AT [15] and path-gram [19] over both real and synthetic datasets.
We use real and synthetic datasets in our experiment, described as follows.

Real Dataset . AIDS is an antivirus screen compound dataset from the Developmental Theroapeutics Program in NCI/NIH 2
Synthetic Dataset . The synthetic graph model is used in our experiments, namely, E rdos R enyi (denoted as ER). In ER model, N vertices are connected by M randomly chosen edges.

The statistics of the datasets are listed in Table 1, where d is the vertex degree. We randomly select 100 graphs from each dataset as its query graphs, and average the query response time.

In this paper, all experiments are conducted on a P4 3.0GHz ma-chine with 4G RAM running Linux. All programs were implement-ed in C++. The length of grams in k-AT and path-gram are set to be 1 and 3, which are the suggested parameter values in [19]. In this section, we evaluate the offline performance of our method. Due to the space limitation, we only report the index size and index construction time in AIDS dataset, as shown in Figure 4.
Since the depth of tree in is 1 for k-AT , it is just the star structures defined in c-star. Because the size of branch is smaller than the size of star, and we assign each branch an unique id to reduce the index space, the space cost of simB is competitive in index size. How-ever, simB needs to build the b-tree index as presented in Section 4. Hence, it is not the most time efficient among these apporaches. Since c-star only needs to enumerate all the star structures in the query graph and data graphs, it is superior to all the other methods in terms of the index construction time.
In order to evaluate the pruning ability of these approaches, we propose a metric, namely candidate ratio (denoted as canRatio ), which is defined in Equation 5. http://dtp.nci.nih.govdocsaidsaids_data.html where | D | is the number of graphs in the database.

In this subsection, we fix the datasets and vary the threshold  X  from 1 to 10. Figure 5 presents the canRatio s of different methods in AIDS and ER(100k), where the y-axis represents the candidate ratio generated by these methods.

According to the definition of canRatio , it is clear that the s-maller the canRatio is, the higher the prune ability of filters is. As shown in Figures 5(a) and 5(b), the candidate ratios generated by all these methods increase with the increasing of  X  . It is because that larger threshold will produce more candidates. Note that, the candidate ratio of our proposed method simB is the lowest, i.e., it has the strongest prune power. Thus, it confirms that our method is more effective compared with c-star [17], k-AT [15] and path-gram [19].
In this subsection, we evaluate the query efficiency of these ap-proaches. Since c-star needs to construct the bipartite graph be-tween two sets of star structures and it does not employ any index structure, it is the most inefficient compared other methods. On the contrary, the branch distance is easy to compute. Moreover, we carefully devise the b-tree index which benefits the query process-ing. Hence, the query response time of our method simB is much less than the other three filters by orders of magnitude as shown in Figure 6.
Figure 6: Running Time vs.  X  in Graph Similarity Search
We also study the scalability of simB together with other method-s as shown in Figure 7. We fix the threshold  X  to be 3, and vary the the size of datasets. We randomly select some subsets from AID-S(full) and ER(100K). As shown in Figure 7, the time consumed by all these approaches are almost linear of the size of datasets, be-cause the prune ability is stable in datasets of different size. What is more, our method simB is faster than the other three filters by orders of magnitude.
Figure 7: Running Time vs. | D | in Graph Similarity Search
In many real world applications, various noisy and incomplete data drive the research of approximate (sub)graph search. Hence, performing an exact graph matching probably returns none match or incorrect ones. It is crucial to find the approximate matches. SAGA [12] proposes a distance model for computing graph simi-larity, which permits node gaps, node mismatches, and graph struc-tural differences. G-Ray [14] defines the similarity based on model of random walk with restart. TALE [13] introduces the neighbor-hood index (NH-Index), the size of which is linear in the number of nodes in the database. Ness [8] proposes a graph similarity measure based on neighborhood information, under this measure subgraph similarity search is NP hard.

All above approaches define some  X  X euristic X  distances to model the similarity between two graphs. They do not discuss the rela-tionships between the heuristic functions and some classical graph similarity distances. In this paper, we focus on graph edit distance. It is based on well-found graph theory. Recently, graph edit dis-tance similarity (sub)graph search has attracted extensive attention-s [15,17,19]. Since computing graph edit distance is also a NP-hard problem, all existing methods also adopt the filter-and-verification framework. Lots of lower bounds are proposed to perform the prun-ing. We have reviewed these approaches in Section 2.2. The key problem is that the pruning power of existing solutions depends on the maximum vertex degree in graphs. Extensive experiments show that our proposed lower bounds are much better than existing ones.
Considering the limitations of existing approaches, we present a novel method for edit-distance based similarity graph similari-ty search problem. An effective lower bound based on the branch structures is first proposed. To facilitate the query processing, we carefully devise a tree index, namely b-tree . Extensive experiments over both real and synthetic datasets confirm that our proposed method outperforms the existing approaches significantly.
This work was supported by NSFC under Grant No.61003009, 61272344, 61370055. Dongyan Zhao X  X  work was also supported by National High Technology Research and Development Program of China under Grant No. 2012AA011101. Lei Zou X  X  work was partially supported by State Key Laboratory of Software Engineer-ing(SKLSE), Wuhan University, China and CCF-Tencent Open Re-search Fund. [1] J. E. Beasley and N. Christofides. Theory and methodology: [2] D. Bonchev and D. H. Rouvray. Chemical Graph Theory: [3] H. Bunke. On a relation between graph edit distance and [4] H. Bunke and K. Shearer. A graph distance metric based on [5] H. He and A. K. Singh. Closure-tree: An index structure for [6] H.W.Kuhn. The hungarian method for the assignment [7] D. Justice and A. O. Hero. A binary linear programming [8] A. Khan, N. Li, X. Yan, Z. Guan, S. Chakraborty, and S. Tao. [9] R. M. Marin, N. F. Aguirre, and E. E. Daza. Graph [10] N. Przulj. Geometric local structure in biological networks. [11] A. Robles-Kelly and E. R. Hancock. Graph edit distance [12] Y. Tian, R. C. McEachin, C. Santos, D. J. States, and J. M. [13] Y. Tian and J. M. Patel. Tale: A tool for approximate large [14] H. Tong, C. Faloutsos, B. Gallagher, and T. Eliassi-Rad. Fast [15] G. Wang, B. Wang, X. Yang, and G. Yu. Efficiently indexing [16] D. J. Watts, P. S. Dodds, and M. E. J. Newman. Identity and [17] Z. Zeng, A. K. H. Tung, J. Wang, J. Feng, and L. Zhou. [18] P. Zhao and J. Han. On graph query optimization in large [19] X. Zhao, C. Xiao, X. Lin, and W. Wang. Efficient graph [20] L. Zou, J. Mo, L. Chen, M. T.  X zsu, and D. Zhao. gstore:
