 Sensitive, high-value, information X  X uch as b anking, enterprise, and intelligence data X  are now commonly being distributed through increasingly complex, interactive web systems. Unfortunately, current web syste ms are not designed to host high-assurance content. At best, the server-side authentication provided by SSL is of limited use, and as it often built on dubious trust relationships [14] and oft-invalid certificates [39]. More fundamentally, web systems provide no content authentication other than identifying the server from which it was obtained. In this current model, there is no way for a user to determine if the content was corrupted by a compromised web server.

Document integrity systems [16,40,22,21,28] augment content with proofs of the correctness of both the document and the system from whence it was received. Such services allow the consumer of the content to validate not only that the document is authentic, but the content was received fro m an un-compromised system. This pre-vents otherwise legitimate but compromised systems from providing mis-information, and preemptively prevents that system from silently manipulating and/or exposing user operation and data. For example, a compromised banking site would be immediately detected by the user when attempting to validate the document integrity of the login screen [34]. The user will simply stop interacting with that site, and therefore no addi-tional damage can be done.

In the Spork project [28], the authors explored the creation of document integrity systems for high-throughput web systems, using the Trusted Platform Module. In order to achieve high throughput, a trade-off for increased latency was made. Such a trade-off poses a challenge for interactive AJAX applications, which require low latency re-sponses to maintain the interactive nature of the web application. What is needed is a document integrity system that supports low-latency responses, to support systems that require low latency, while still sustaining an acceptable throughput.

This paper explores methods and systems designs for providing document integrity in AJAX-style interactive web systems. Chiefly, our Sporf system exploits pre-computation to offset runtime costs of providing document integrity. We bench-mark a range of off-line/on-line signature algorithms and develop new content proof constructions built on them. We detail the design of the Apache-based Sporf server system. A detailed empirical analysis of AJAX applications under realistic workloads is performed. This analysis shows a software-only system results in latencies of ap-proximately 200 milliseconds , with a throughput of 1,500 requests per second. Further modeling shows that a hardware solution, using nominally priced hardware, results in latencies of just over 81 milliseconds, close to that of an unmodified server. In [31], Nielsen states that web application response times lower than 1 second are optimal. Our software-only prototype system can support response times that are approximately 200 milliseconds, as shown in our evaluation. We begin in the next section by provid-ing an overview of document integrity systems and the cryptographic constructions we explore to support low-latency responses. In this section we outline several areas of related work. We begin with a description of off-line/on-line signatures. Next we examine mechanisms to provide proofs of system integrity. Finally, we detail mechanisms that provide integrity for web applications. 2.1 Off-line/On-line Signatures In many operations involving digital signatures, e.g. electronic wallets and high throughput web systems, the signing operation must be very fast. Typical signature schemes, such as RSA [36] and Rabin [33] are too slow for these types of operations. In [15], the authors propose off-line/on-line signature schemes where the heavyweight computations are performed prior to the content being generated, and then a faster sign-ing operation is carried out once the content is presented for signing. This is done by using both ordinary public key signature schemes and one-time signature schemes, in a two-phase signing operation. In the off-line phase, a one-time key is generated and signed by the ordinary key. This one-time key is then used to sign a single message, or piece of content, in the on-line phase. This on-line signing phase is significantly faster than the ordinary signatures being generate d in the first phase. The full construction for off-line/on-line signature schemes can be found in our technical report [29]. 2.2 System Integrity Solutions Clients communicating with web servers over untrusted HTTP connections are given no guarantees about the security of the server or the network communications. Content accessed over SSL, either directly or via a proxy [24], is afforded some protection from network based attacks. However, SSL does nothing to protect the server, or the content hosted on the server. The client cannot be sure that the server, or the content, is not compromised in some way. The SSL certificate simply vouches for the identity of the server, or more specifically of the private key used by the web server. What is needed is a means of providing a  X  X roof X  of the server X  X  integrity.

Several proposals exist for software-based a ttestation, requiring no hardware changes at all. Such solutions are often targeted at mobile devices, but some have also looked at general purpose systems. Early proposals for software-only solutions include those proposed by Spinellis [43] and Kennel and Jamieson [23]. These projects have looked at ways that software can measure itself, in order to provide proof to a remote party that the code executed has not been tampered with. Other projects, such as SWATT [41] and Pioneer [42] look at performing computations over the code being executed that are difficult to compromise, such as executing code that is highly optimized, or walking memory locations in a pseudo-random order. Other works have looked at ways to in-crease the robustness of such projects [17], or modifying the kernel or shell to measure code before it is executed [27,19]. Measurement , in this context, refers to computing a hash of the executable code right before execution. Popular hash functions include MD5 and SHA1.

Software-only solutions have the advantage of not requiring specialized hardware that could be prohibitively expensive. However, such solutions have shown inherent weaknesses, as attacks have been developed on such solutions [49,7]. As such, hard-ware based solutions are increasing in popularity. Another reason for this increase in popularity is the decrease in the cost of some of the proposed hardware-based solu-tions.

Hardware based solutions have been proposed as a means of providing tamper-proof storage and execution environments. Projects such as AEGIS [44] and the IBM 4758 [13] provide a secure execution environment. These environments are designed to execute security-sensitive code. One limitation of using hardware in this manner is the cost of deploying the hardware and software 1 . Copilot [32] is another coprocessor based system that monitors the integrity of the kernel. The Trusted Computing Group [46] has developed a set of specifications, including the Trusted Platform Module, TPM, speci-fication [47]. The TPM, unlike other hardware, is designed to be low-cost. Due to the relatively low cost, many commodity systems are now coming equipped with TPMs. Several projects have examined the use of the TPM as a means of measuring the in-tegrity state of the system.

Several proposals have looked at using the TPM to provide system integrity re-ports [25,38,20]. The Linux Integrity Measurement Architecture [38], Linux-IMA or IMA, and its extension, the Policy Reduced Integrity Measurement Architecture [20], PRIMA, measure code before it is loaded an d create a hash chain of all executed code. IMA measures every single executable and library, while PRIMA uses a policy to de-termine what code should be measured, reducing the overall size of the measurement list. The measurements are stored in the TP M X  X  PCRs, as described above, and a list of all measurements is stored in kernel memory. When an attestation is requested by a remote verifier, the TPM quote is provided, along with the current measurement list. The verifier can examine the m easurement list to determine if the expected software is running on the system and that no un-expected software has run that could potentially compromise the system. One such example of un-expected software would be the Ran-dom JavaScript Toolkit [12]. This particular piece of malware is a rootkit that modifies Linux-based Apache webservers. The rootkit contains a small webserver that proxies Apache X  X  responses, by injecting malicious JavaScript before sending the response to the client. 2.3 Web Application Integrity Several proposals exist looking at providing content integrity for web applications. Some systems look to provide guarantees to the client that the content is correct. SINE [16] and DSSA [40] are two systems that aim to provide such guarantees. SINE provides content integrity to the client, while still allowing the client to retrieve con-tent from caches, instead of requesting content from the server every time. DSSA is a server-side solution that monitors the content hosted by the server. The monitor has a set of known-good pages, and any deviations will cause DSSA to either serve a backup of the content to the client, or simply inform the client that the content is currently un-available. These solutions still require that the user blindly trust the server, providing no basis for establishing trust that the server is not compromised in any way. Another approach is web tripwires [35] that aims to detect  X  X n-flight X  pages changes, by com-paring the received content to a known good co py. The tripwire concept assumes that the server is not compromised, agai n potentially misleading the client.

Other works have looked at utilizing trusted hardware to provide integrity guarantees for the system as well as the content being hosted. Two such systems include the We-bALPS project [21,22] and [50]. WebALPS uses the IBM 4758, a secure co-processor developed by IBM to protect the integrity of client-server interactions when the server accesses sensitive client information. In [5 0], the authors propose a trusted reference monitor, TRM, that protects the integrity and authenticity of peer-to-peer, P2P, sys-tems. The TRM depends on all of the systems in the P2P network to have a TPM, and the clients are required to run secure kernels, such as Microsoft X  X  NGSCB [11]. Such proposals have seen relatively little adoption due to the expensive hardware require-ments, or requiring the clients to abandon their current operating systems in favor of new systems.
 There has been a large effort to provide secu re environments for web applications. Such efforts include [10] and [9]. Both are proposals for new web application program-ming paradigms. Such solutions work well only if the developer is writing their appli-cation from scratch, but does not apply well to existing code bases. Hicks, et. al. [18] looked at ways of building web applications that enforce and end-to-end information flow policy. Other efforts have looked at protecting the integrity of content by speci-fying the canonical form of the content, such as Document Structure Integrity [30], or Blueprint [45], or by relying on type systems provided by programming languages, as in [37]. Another approach is to verify computations done on multiple system, as is done in Ripley [48]. While these solutions protect against popular attacks, such as cross-site scripting (XSS), they all assume that the server hosting and generating content is trustworthy with no means of establishing this trust. In this section we detail the design of a proof construction that uses off-line/on-line sig-nature schemes [15,8] to sign dynamic content, the mechanism used by Sporf. The ad-vantage to this construction is that it removes the TPM from the critical path of binding dynamic content to the system integrity state. We begin with a discussion of document integrity systems and the guarantees they provide. 3.1 Document Integrity Systems Document integrity systems provide several guarantees about the content they are host-ing and the integrity of the system itself. Such systems provide proofs of the origin of the content, as well as proofs of the current system integrity. The following are guaran-tees provided by document integrity systems: a) that a document, d , came from a given server, s b) that the server has a known integrity state c) that the server was in a known integrity state at the time the document was generated Below, we show how such a system can be constructed, from a set of primitives. We leave the details of specific systems for later discussion. We begin by examining the second guarantee, namely the known integrity state. In a system, s , supporting system integrity proofs , a verifier connecting to the system will first validate the integrity of the system. This is done using a challenge-response protocol, where the verifier provides a challenge, or nonce, n , and the remote system generates a system integrity statement , denoted: Here n is a nonce, or challenge, that ensures the freshness of the generated proof. This proof satisfies guarantees b and c . Next, we show how we can build the document in-tegrity proof for a given document.

That document is represented by d , and the server generates a proof for the specific document by computing a cryptographic hash of the document, written h ( d ) .Inorder to bind a document to the system integrity statement, we replace the nonce with the document proof : This binds the document to the proof, proving to the verifier that the server stored, or generated, document d when the integrity state was reported. To verify, a client validates the IS (  X  ) and the hash of the received document, h ( d ) . This construction satisfies a and b , but the client can no longer be sure that the proof is relatively fresh. Specifically, a compromised server can replay such proofs, even after the system has been fully compromised, and the client would be unable to detect an malicious behavior.
To overcome this limitation, the server relies on a trusted time server to provide verifiable timestamps , that can be bound to the system integrity statement, in addition to the document proof. Here, | denotes concatenation. The timestamp is written: Where IS ( h ( t i )) is a system integrity proof from the time server, bound to some time, t . After obtaining a timestamp from the time server, ts ,theserver, s , generates the following proof which satisfies the three guarantees outlined above: The hash of the document binds the document to the system integrity proof, the times-tamp allows the verifier to determine how fresh the integrity proof is, and the system integrity proof allows the client to validate the integrity of the system. Next, we show how to build a document integrity system that uses commodity trusted hardware and software. 3.2 Example System: Spork In the Spork project [28], the Trusted Platform Module, TPM [47,46], is used as a means of generating the integrity statements. The TPM provides a limited amount of tamper-evident storage for measurements and crypt ographic keys. The measurements are stored in the Platform Configuration Registers, PCRs, and provide a very limited interface for adding values to the set of measurements. The keys stored in the TPM serve a number of different functions, one of which is to sign TPM Quote s. These quotes are the basis for the integrity statements described a bove. The TPM accepts a nonce and a list of PCRs to report. The TPM reads the selected PCRs and signs the nonce and read values. The quote is written as: Here, H s is the key used by the TPM to sign the quote, pcr s represents the set of reported PCR values and n is the nonce. H s represents the identity of the system, much like an SSL certificate does for secure web transactions. The TPM itself is a passive device, and as such requires support from the system to gather measurements.
Integrity measurement systems gather measurements of the current system integrity state. These measurements can later be reported to a verifier to ensure that the system is high integrity. One such system is the Linux Integrity Measurement Architecture [38], which measures executables before they are l oaded. A list of these measurements are stored in kernel memory, as well as being reported to the TPM. By including the list of measurements with a TPM quote, a verifier can know what software has been loaded by the system, allowing the verifier to determine if they trust the system, or not. The measurement list is noted as ML s ,where s indicates which system the list is from. Relying on the TPM leads to very high latencies if each request is signed by the TPM. On average, the TPM takes 900 milliseconds to generate a single quote. In order to amortize this quote generation cost, a Merkle hash tree [26] is used to generate proofs for multiple pieces of content. A client retr ieving a proof will get the TPM quote and measurement lists, and a succinct proof from the Merkle hash tree. This allows the Spork system to sign multiple pieces of c ontent with a single TPM quote, and utilize this same quote to service multiple requests. The root of the hash tree, CPS r , replaces the single document as the document proof, written: By using the hash tree, the cost of generating a TPM quote is amortized over many doc-uments. This amortization works well for static content, where the TPM can generate a single quote for all content that the web server could potentially serve. However, even using the hash tree, Spork introduces a high amount of latency to dynamic requests, as each client must wait for the TPM to sign a hash tree that includes the requested dy-namic content. This additional latency cripples AJAX applications, which require low latency responses to maintain the appearance of desktop-like functionality. Next, we examine the design of a system that reduces the latency for dynamic content. Next, we describe the Sporf system, where we examine several potential designs for supporting low-latency, high-throughput inte grity-assured web documents, detailing the limitations of each approach. We show how to construct the document proof, before showing the full details of the document integrity system using off-line/on-line signa-tures to sign dynamic content. 4.1 Binding Using Off-line/On-line Signatures First, we will introduce some notation that is used throughout the rest of the paper. Keys are denoted as SK and VK for signing and verification, respectively. Keys for one-time signature schemes are super-scripted with ot ,i.e. SK ot and VK ot .  X  and  X  represent signatures.

We begin with the system integrity proof, showing how to bind a single document to the system integrity state: where  X  is the signature of the one-time key generated with the many-times key, and  X  is the signature of the document using the one-time key, SK ot . This construction shows that the server, s , with known integrity state (guarantee b from Section 3.1), possessed the one-time key-pair used to sign a document , d (guarantee a ). What is missing is that the document came from the server at the time when the integrity state was reported (guarantee c ).Next, we show how to bind multiple verification keys to a single TPM quote and include a recent timestamp from a trusted time server. We rely on cryptographic proof systems, namely a Merkle hash tree, to bind multiple keys to the TPM quote while being able to generate s uccinct proofs for each key. The leaves of the hash tree are the individual verification keys used to sign documents, and the root of the tree is used as the challenge for the TPM. When a client obtains a document, it obtains a succinct proof for the verification key in addition to the signatures. Figure 1 shows the full construction, using a cryptographic proof system instead of a single key. The succinct proof is constructed by providing the values of sibling nodes on the path to the root for a given key. Providing this information allows a client to reconstruct the root value from the key it obtains, and compare the computed root to the provided root to ensure that the key is the correct key. This is similar to the method Spork uses to bind multiple documents to a single integrity proof. 4.2 Latency Improvement The construction in Figure 1 allows the web server to bind a dynamically generated document to the TPM quote, by using the one-time key to sign the dynamic content. This differs from the Spork project which directly binds the content to the proof. In the Spork project, the TPM is on the critical path for serving dynamic content, leading to high latency for each request. With Sporf, the TPM is no longer on the critical path, al-lowing the system to process requests at much higher speeds, leading to lower latencies for each request.

The construction in Figure 1 provides a statement of the system integrity at the time the keys are generated , which occurs before the content has been generated. Figure 2 shows the request timeline for a single client requesting content. At time t quote 1 ,the TPM has generated a quote that can be used to service client requests. When the client requests content, the server generates a signature for the content, using a key included in the quote. This proof, shown in Figure 1, is generated at time t bind , and sent to the client. The proof in Figure 1, is called a Sporf-integrity proof . This distinguishes the proof from a Spork-integrity proof , where the client gets the proof at time t quote 2 ,after the server includes the requested content in a TPM quote.

In order to understand the differences between a Spork-integrity proof and a Sporf-integrity proof, we reconsider each of the guarantees outlined in Section 3.1, in terms of the time at which each guarantee is satisfied. The first guarantee ( a ) that the document d came from the server. This document comes from the server at time t bind . The second guarantee ( b ) is that the server, s has a verifiable integrity state. This guarantee is satis-fied at time t quote i , when the TPM generates a quote. The third guarantee is satisfied at time t quote 2 , when the client can determine the integrity of the system at time t bind .
This is different than the Spork system, where the binding and reporting occur at the same time, i.e. t bind = t quote 2 , adding additional latency. For Sporf, the proof is delivered at time t bind , eliminating the latency for obtaining content. While delivering the proof at t bind enables clients to obtain content with lower latency, this delivery also presents a window of uncertainty , where the server X  X  integrity cannot be determined by the client. 4.3 Window of Uncertaint y and Countermeasures We define the time between t quote 1 and t bind , in Figure 2 as a window of uncertainty ,as the client cannot be certain of the current state of the system up through time t bind ,when the content is generated and signed by the serv er. In order to validate the integrity of the server during this time, the generated content is included in the next TPM quote (Quote 2 in Figure 2, i.e. a Spork-integrity proof. The proof obtained is the proof described in Section 3.2, obtained by the client at t quote 2 in Figure 2. In this section, we describe mechanisms to mitigate the impact of waiting for the Spork-integrity proof.
To mitigate the impact of waiting for the Spork-integrity proof (at time t quote 2 ), the client can begin using the data after time t bind , i.e. after the Sporf-integrity proof is obtained, and issue a request for the Spork-integrity proof, to arrive after t quote 2 . While waiting for the Spork-integrity proof, any content not validated is highlighted in the client X  X  browser to indicate that it is still not fully validated. Any requests resulting from this content are delayed until the Spork-integrity proof arrives. Next, we describe example applications and how this technique operates.
 Example Applications. Below, we consider two popular applications, and how the developers would integrate Sporf into the application. We first consider the popular Gmail [3] application and also a framework for building AJAX-based instant messaging clients [1]. We show how the typical functi ons of each application would operate within the Sporf system.

For the first application, consider the web -based email application, Gmail. For this discussion, we will consider what happens when a user receives a message and replies. browser validates the initial requests. The browser will periodically issue AJAX requests to update the inbox and unread message counts for other labels 2 . When a new message arrives, the browser requests the Sporf-integrity proof as part of the AJAX request. After the initial validation, the view of the inbox is updated. The browser then requests the Spork-integrity proof from the server. Until the Spork-integrity proof is received, the message is highlighted to indi cate that the content is not fully validated. The client reads the message while waiting for the Spork-integrity proof and begins writing a reply. If the client finishes the reply and clicks the send button before the Spork-integrity proof is validated, the reply is queued until the Spork-integrity proof is validated, and the client is returned to the inbox. If the proof is valid, the reply is sent in the background, otherwise, the client is notified of the failure and the reply is discarded.
AJAX IM [1] is a framework for building instant messaging clients into web appli-cations. The back-end is a set of PHP scripts, while the front-end is a JavaScript script. Clients send messages to the server, which are then delivered to the other client in real-time. In this case, when the client receives a message from the server, the browser will request the Sporf-integrity proof and highlights the message as only partially vali-dated. The browser requests the Spork-integrity proof after delivering the message. The client can immediately see the message after the Sporf-integrity proof is validated, and can begin writing a response. When the client clicks the send button, the browser first checks that the Spork-integrity proof has been received. If the proof is not received, the message is queued. Once the Spork-integrity proof is validated, the message is sent.
In each of the above examples, the browser is responsible for validating proofs and queueing requests. In future work, we plan to explore the functionality of a Sporf-integrity proof validating browser, and also deploying AJAX applications on Sporf sys-tems. This section details the implementation of our Sporf system that supports signing dy-namic content using off-line/on-line signature schemes. We begin by describing the various systems, and the functions they perform. In addition to the web server, there is a time server that is generating periodic TPM quotes that use a hash of the current hardware clock value as a nonce, previously described in Section 3.2. The web server includes additional daemons to handle generating TPM quotes, generating off-line/on-line signatures, signing dynamic content, and generating document integrity proofs.
The Sporf daemon is responsible for generating proofs and servicing requests from clients for such proofs. In order to support the off-line/on-line schemes presented in the previous section, the daemon is split into several distinct processes. One process, la-beled Key Generator , generates off-line/on-line key s, and send these to the main Sporf daemon ( 3 in Figure 3). The Sporf daemon handles signing dynamic content gener-ated by Apache ( 2 in Figure 3), and storing the signatures of previously generated dy-namic content. In addition, the main Sporf daemon carries out several other threads of operation.
The main Sporf daemon uses a number of different threads to aid in the content integrity proof generation process. One thr ead receives off-line/on-line keys from the process generating keys ( 3 in Figure 3), adding each key t o the cryptographic proof system that will be generated in the next TPM quote window. Another thread interfaces with the TPM ( 4 in Figure 3), to generate the TPM quotes that form the core of the con-tent integrity proofs. This thread also fetches the time attestation from the time server, to be included in the TPM quote generated by the web server ( 5 in Figure 3). Another thread is responsible for servicing requests for proofs from the web server. This thread compiles all of the proof pieces, such as the c ontent signature, time attestation, TPM quote, and measurement lists, and sends the generated proof back to the server, which returns the proof to the client.

In our current implementation, the main Sporf daemon is started, and spawns the other processes. The number of spawned key generators is configurable, to take advan-tage of a varying number of processing cores on the web server. This allows the system to be tuned based on expected workloads and available hardware. In this section, we evaluate the throughput and latency of the Sporf system presented in the preceding sections. We begin our eval uation with a comparison to an unmodified Apache web server. These results lead to several optimizations, which are explored to determine the throughput and latency tradeoff s. In addition to the macro-benchmarks, we perform a series of micro-benchmarks to highlight bottlenecks present in the Sporf system.
 All tests were performed on Dell PowerEdge M605 blades with 8-core 2.3GHz Dual Quad-core AMD Opteron processors, 16GB RAM, and 2x73GB SAS Drives (RAID 0). Six blades running Ubuntu 10.04.1 LTS Linux kernel version 2.6.32 were connected over a Gigabit Ethernet switch on a quiescen t network. One blade ran the Apache web server, one blade ran the time server, and f our were used for simulated clients. All experiments use the Apache 2.2.14 server with mod python 3.3.1 modules for dy-namic content generation. The Spork daemon is written in Python 2.6.5 and uses a custom TPM integration library written in C. All load tests were performed using the Apache JMeter [6] benchmarking tool, version 2.4. 6.1 Microbenchmarks In the first experiment, we evaluate the throughput of the off-line/on-line signature schemes on our experimental test bed. The i mplementation of the signature schemes was provided by the authors of [8], and were compiled for the machines in our test environment. Table 1 shows throughput measurements for the off-line/on-line selected schemes from [8]. In this table, we consider only parameter combinations that give the highest throughput for on-line signing. A full table is presented in the Appendix of our technical report [2]. In looking at Table 1, we see that the on-line signing phase for some schemes is able to achieve very high throughputs, specifically, GHR-DL and CS-DL achieving over 50 , 000 signing operations per second. This indicates that such a scheme would be ideal for signing dynamic content. For our evaluation, we will con-sider the schemes that achieve the highest throughputs for on-line signing. This includes the following signature schemes from Table 1: GHR-DL, GHR-DL2, CS-DL, and CS-DL2. These schemes provide the highest on-line signing throughput for a single process, and will introduce the least latency when signing dynamic content.

It should be noted that the schemes labeled GHR-DL and CS-DL provide high throughput in the on-line signing phase. Intuitively, this is due to these signing oper-ations only requiring one integer multiplication operation, unlike other schemes which require more complex operations to complete. Full details are presented in the Appendix of our technical report [2].
 6.2 Baseline Macrobenchmarks In order to understand the impact of Sporf on serving web documents, we first present a set of macrobenchmarks that examine the throughput and latency characteristics of our Apache web server. In addition to looki ng at maximum throughput , we examine the latency under several different client populations, ranging from a single client to 512 clients. All tests for maximum throughput will use 512 clients, as adding more clients did not exhibit an increase in throughput, and had an adverse impact on the latency ex-perienced by each client. According to [5], the average size of a page updated via AJAX was approximately 2.5KB, versus 10KB for a f ull-page refresh. For our experiments, we will use a response size of 2.5KB for each AJAX update.

First, we consider the throughput and latency for an unmodified web server. In our tests, the unmodified Apache web server was able to sustain over 6,100 requests per second, with an average latency of 81 milliseconds per request, as measured by the client. Next, we consider the Sporf-enabled web server. Table 2 shows the throughput and latency average measurements for 512 c oncurrent clients. The average is taken for a two minute sample, once the system has reach ed a steady state, i.e. we are ignoring start-up times as these are not indicative of a server X  X  response under load.
In this experiment, we consider the throughput and latency of the Sporf system. For this test, each client requests an update, followed by the proof for that update. Again, we consider the latency experienced by each client as well as sustained throughput.
Table 2 shows the results using the four schemes selected in the previous section. The columns labeled content and proof meas ure the throughput and latency of each type of request. When looking at the table, it should be noted that the overall throughput for each of the signature schemes is much lower than the throughput shown in Table 1. This is due to the off-line signing phase. There is a single process generating keys and signing them with the off-line key, i.e. running the off-line phase of the signature algorithm. With a single process doing this, the maximum number of keys generated by the system in a single second maxes out at just over 500 keys per second, thus limiting the throughput of the system, and adding additi onal latency. In later sections, we will consider methods for alleviating this bottleneck.

In addition to measuring the latency unde r maximum load, we also measured the la-tency under varying client loads. This reveals how the server responds to various loads, and what potential bottlenecks exist. We begin with a single client, showing the min-imum possible latency, and then consider a maximum of 500 clients. For each client population, clients make serial requests for a period of one minute. All measurements are the average latency during that one minut e period, as experienced at the client. Fig-ure 4(a) shows the results for the unmodified web server. We see that the minimum latency experienced is approximately 1.66 msecs, while the average under load is 81.34 msecs. In addition to average latency, the figure shows the median, minimum and max-imum latencies for each client population. Figure 4(b) shows the average latency under varying client population sizes for a Sporf-enabled web server. Under heavy client loads, we see the latency increase. The lowest increase in latency is with the GHR-D L scheme, showing an increase from 81.34 msecs to 474.6 msecs. This is due to the clients waiting for fresh keys to be generated, as the number of requests being made pe r second exceeds the number of keys that can be generated in a single second by Sporf. Ho wever, this additional 393 milliseconds is lower than the Spork system, which exhibits an average latency increase of over 1000 milliseconds for dynamic content. In the worst case, i.e. CS-DL and CS-DL2, we see an increase in latency to approximately 1,100 milliseconds.

In looking at Table 2, we see that the latency for content requests is below one second on average, with the additional latency coming from the signing of content. Nielsen states that responses under a second allow t he client to perceive little delay [31]. In the next section, we examine an optimization that eliminates the second round-trip to fetch the proof, further reducing the overall l atency to just the lat ency experienced for fetching content. 6.3 Pre-fetching Proofs A naive solution, outlined above, has each client requesting a proof for each piece of content. This causes each client to make two HTTP requests for every AJAX update. As these updates are happening very frequen tly, very little is changing in the system X  X  integrity state. We can leverage this by pr oviding a proof to each client that includes verification keys for multiple off-line/on-line signature pairs, along with a single TPM quote. The proof is obtained by the client either with the first request made to the server, or when the current pool of keys is exhausted. When clients request content, the server obtains a key that the client already has an integrity proof for, signs the content and appends the signature to the content. Upon receiving the content and signature, the client has everything needed to validate the integrity proof, without making an addi-tional request to the web server. This completely eliminates the second request, and the additional latency introduced by obtaining the proof after fetching the content.
Table 3 shows the effect of proof pre-fetc hing for each client. We consider the effect of sending both 10 and 25 keys per integrity proof. In order to better understand the impact of this change and exclude the impact of the off-line signing phase, the system generated a large number of keys, which are then stored, and then signed by the TPM in batches, instead of generating keys in real-time. While this is not how the system will operate in a production deployment, it is useful to understand the potential benefits of Sporf 3 . As shown in the table, it is possible to increase throughput to approximately 1,500 requests per second, while latency f or content remains around 200 m illiseconds, as compared to approximately 80 millisec onds for serving dynami c content without the content integrity proof. This additional reduction helps to maintain the  X  X ub-one sec-ond X  goal to maintain the interactivity of the application, as described by Nielsen [31]. The bottleneck in this case is computation, as each client is waiting for a signature of their content. 6.4 Adding Hardware In supporting large client populations, the system cannot generate keys fast enough to sustain the throughputs of an unmodified web server. In this section, we consider the use of a cryptographic accelerator to suppor t the key generation process. The Silicom PXSC52 [4], which costs just under $500, can sustain a throughput of approximately 17,000 RSA operations per second. Since the off-line phase is based on an RSA signa-ture, if we leverage one of these cards to perform the off-line signing, we can eliminate the bottleneck where clients are waiting for keys to be generated.
To understand the impact adding the acceler ator would have on the system, we per-formed timing tests for the GHR-DL signature scheme. The off-line signing phase can be broken into two steps, with the time for each indicated: 1. Run commitment phase for on-line key (0. 292 milliseconds) 2. Sign commitment using many -times key (1.672 milliseconds) As shown above, the many-times signature operation dominates the off-line signing phase. By moving this signature to the crypt ographic accelerator, t he off-line signing phase time would drop from 1.964 millisec onds per key to 0.293 m illiseconds per key, based on the signature taking 0.001 milliseconds to complete on the accelerator. With this timing, it is possible to generate 3,424 keys per second on a single processor. By adding a second process running the first stage of the off-line signature, we can generate 6,849 keys per second, more than our server X  X  sustained throughput for an un-modified server. This leads to a system where, for a client obtaining an AJAX update, the only latency experienced would be in obtaining a signature for the update, based on the optimizations outlined above. This only adds an additional latency of 0.02 milliseconds per signature, taking the total latency a client can expect down to approximately 81.36 milliseconds, with the server able to susta in the throughputs for an unmodified server, or just over 6,000 requests per second. In this paper, we presented Sporf, a system for generating content integrity proofs for dynamic content. The system provides content integrity proofs for low-latency, high throughput systems, such as AJAX-enabled web applications. We show an in-depth empirical analysis to understand the performance limitations of the prototype Sporf system, and highlight the advantages of leveraging pre-computation. In addition, we explore potential optimizations that allow the system to scale to higher loads without exhausting system resources such as bandwidth. Our results show that a software-only prototype can provide document integrity proofs for dynamic content with approxi-mately 200 milliseconds of latency, with th roughputs of 1,500 requests per second. Our analysis shows that a hardware-supported system can provide lower latency, approxi-mately 81 milliseconds, achie ving throughputs near that of an unmodified web server. Acknowledgements. The authors would like to thank Dario Catalano, Mario Di Rai-mondo, Dario Fiore, and Rosario Gennaro fo r providing access to their implementation of off-line/on-line signature schemes from their paper titled  X  X ff-Line/On-Line Signa-tures: Theoretical aspects and Experimental Results X  [8]. We would also like to thank the members of the SIIS lab for their comments and discussions as this paper evolved, especially Will Enck, who provided the name Sporf.
 Vijay Varadharajan is the Microsoft Chair Professor in Innovation in Computing in Australia at Macquarie University. He is also the Director of Information and Net-worked System Security Research (INSS) Group at Macquarie University. Before this he was Chair of Computing and Head of School of Computing and IT at University of Western Sydney. Previously, Vijay headed Security Research worldwide for Hewlett-Packard Labs based at European Headquarters at HP Labs Bristol, UK. 
Vijay has published over 300 papers in International Journals and Conferences, has co-authored and edited 9 books and holds 3 patents. He has given 20 keynote speech-es at international conferences, chaired numerous conferences and has been a program committee member for over 200 conferences a ll over the world. Vijay has been on the Editorial Board of several journals including the IEEE Transactions in Dependable and Secure Computing, the ACM Transactions on Information Systems Security, Springer International Journal of Information Security and IEEE Security and Priva-cy. His research work has been supported by industry such as Microsoft, Hewlett-Packard, British Telecom and Fujitsu, as well as government agencies such Australian Research Council (ARC), UK Research Council (EPSRC), Australian Defense (DSD), Dept of Prime Minister and Cabinet Australia and European Union. Vijay is on the Trustworthy Computing Advisory Board (Microsoft, USA), the SAP (Germany) Security Advisory Board, Australian Government X  X  Peak Security Advisory Group for the Minister of Broadband, Communications and Digital Econo-my, Australia. He is a member of the Australian Research Council College of Experts in Engineering, Mathematics and Informatics. He has been the Technical Board Di-rector at Australian Computer Society. Vijay is a Fellow of the British Computer Society (FBCS), Fellow of the IEE, UK (FIEE), Fellow of the Institute of Mathemat-ics, UK (FIMA), Fellow of the Australian Institute of Engineers (FIEAust) and Fel-
