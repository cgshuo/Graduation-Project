 instantaneous occurrences, cannot be treated as  X  X ime points X . For example, in the medical field, some relationships can be mined from clinical records of patients to study the correlations between the symptoms and the diseases, or the influences between the diseases and other diseases . Traditional sequential mining approaches is hampered by the fact that they can only handle instantaneous events efficiently, not event intervals. Most studies on sequential pattern mining are mainly focused on time point-based event data. Few research efforts have elaborated on mining patterns from time interval -based event data. However, in many real applications, event us ually persists for an interval of time. Since the relationships among event time intervals are intrinsically complex, mining time interval-based patterns in large database is really a challenging problem. In this paper, a novel approach, named as incision strategy and a new representation, called coincidence representation are proposed to simplify the processing of complex relations among event intervals. Then, an efficient algorithm, CTMiner ( C oincidence T emporal Miner ) is developed to discover frequent tim e-interval based patterns. The algorithm also employs two pruning techniques to reduce the search space effectively. Furthermore, experimental results show that CTMiner is not only efficient and scalable but also outperforms state-of-the-art algorithms. Mining time interval-based patterns (referring as temporal patterns ) from such data is undoubtedly more complex and arduous, and requires a different approach from mining time point-based data. So far, little attention has been paid to the issue of mining time interval-based seque ntial pattern. This is partly due to the complex relations am ong event intervals. Since the feature of time interval is quite different from time point, the pairwise relationships between an y two time interval-based events are intrinsically complex. The complex relation is really a crucial problem when we endeavor to design a temporal pattern mining algorithm with efficiency and effectiveness, since it may lead to generate more numbers of candida te sequences and workload for counting the support of candidate sequence. H.2.8 [ Data Management ]: Database Applications -Data Mining To the best of our knowledge, a ll related researches in this domain are based on Allen X  X  temporal logics [2], in which there are 13 temporal relations between any two event intervals, as shown in Fig. 1. These relations hips can describe any relative position of two intervals based on the arrangements of the start and the finish end time points. However, all the Allen X  X  logics are binary relation and may suffer se veral problems when describing relationships among more than three events. An appropriate representation is very crucial for facing this circumstance. Various representations have been proposed but most of them have restriction on either ambiguity or scalability. Algorithms data mining, interval-based mini ng, sequential pattern, temporal pattern Recently, sequential pattern mining is an important research theme with broad applications, such as DNA tandem repeats, user Web click streams, customer buying behaviors and study of medical process, to name a few. Most studies mainly focus on exploring an approach to di scover frequent time-point based patterns in large sets of data [1, 5, 6, 10, 11, 14]. Some recent works have investigated the mining of interval-based events. Kam et al. [4] designed an algorithm that uses the hierarchical representation to di scover frequent temporal patterns. However, the hierarchical repr esentation is ambiguous and many spurious patterns are found. Hoppner [3] defined the supporting level of a pattern as the total time in which the pattern can be observed within a sliding window. However, the algorithm needs to scan the database repeatedly, which would significantly lower its efficiency. Papapetrou et al. [8] proposed the Hybrid-DFS algorithm to mine frequent arrangements of temporal intervals. Authors transform an event sequence into a vertical representation using id-lists. The id-lis t of an event is merged with the id-list of other events to generate temporal patterns. This approach does not scale well when the temporal pattern length increases. Mochen [7] proposed a repres entation, TSKR which uses coincident concept to facilitate the processing of discovering temporal pattern. The pattern repr esented with TSKR is not easily understandable; it may reveal the relationship between pairwise event intervals in a pattern ambiguously. Winarko et al. [12] proposed an algorithm named ARMADA which is based on an efficient sequential pattern mining algorithm, MEMISP [5], to mine frequent temporal patterns. This approach only needs two database scans and does not re quire candidate generation or database projection, but memory usage is a bottleneck when database is very large. Wu et al. [13] devised an algorithm called TPrefixSpan for mining temporal pattern from inte rval-based events. TPrefixSpan uses a nonambiguous representati on, temporal sequence, to discover frequent temporal patte rns. Although this algorithm only needs two scans of the database, it does not employ any pruning strategy to reduce the search space. Patel et al. [9] utilized additional counting information to achieve a lossless hierarchical representation, named Augmented Representation. An algorithm called IEMiner was designed to discover frequent temporal patterns from interval-based events. Although IEMiner uses some optimization strategies to reduce the search space and remove non-promising candidate sequences, it still has to scan database multiple times. In this paper, a fundamentally different technique from previous work is proposed to discover tem poral patterns. There are three contributions from our work. The first contribution is that we propose an incision strategy , to simplify the processing of complex relations when mining te mporal patterns. The incision strategy segments all intervals to disjoint slices based on the global information in a pattern. Comparing with the complex relations between intervals, the relations among event slices are simple, i.e., only  X  before , X   X  after  X  and  X  equal . X  The second contribution is that we develop a new representation, coincidence representation , to express a pattern or sequence nonambiguously, based on the incision strategy. We group all event slices occurring simultaneously together to form a coincidence and concatenate all coincidences together to represent a pattern. As mentioned above, va rious existing representations may lead to different kinds of problem. An appropriate representation can facilitate processing and improve performance of algorithm. The third contribution is that we design a new algorithm, CTMiner, which can effectively avoid the effort on candidate generation and testing for mining te mporal patterns. We transform every interval sequence in databa se to coincidence format. Then, we borrow the idea from PrefixSpan [10] (Prefix-projected Sequential pattern mining), an efficient pattern growth-based algorithm in finding time pointed-based sequential patterns, to mine frequent temporal patterns. CTMiner recursively projects the temporal database into a set of smaller projected databases, and grows temporal patterns in each projected database by appending locally frequent slices. Furthermore, CTMiner employs the proposed optimization strategi es to reduce the search space and avoids non-promising projec tion. The performance in both synthetic datasets and real datasets shows that CTMiner outperforms previous algorithms. Ou r experimental results also show that the proposed appro ach consumes a much smaller memory space. The rest of the paper is organized as follows. Section 2 provides the detailed definitions. Section 3 and 4 introduce the incision strategy and the coincidence representation, respectively. Section 5 describes the CTMiner algorithm. Section 6 gives the experiments and performance study, a nd we conclude in Section 7. Definition 1 (Event interval and event sequence) Let E = { e e ,..., e k } be the set of event symbols. Without loss of generality, we define a set of uniformly spaced time points based on the natural numbering N . We say the triplet ( e i , s i an event interval or temporal interval, where e i  X  E , s s  X  f i . The two time points s i , f i are called event times, where s is the starting time and f i is the finishing time. We can also represent s i and f i as e i . t s and e i . t event intervals over E is denoted by I . An event sequence is a series of event interval triplets  X  ( e 1 , s 1 , f 1 ), ( e f )  X  , where s i  X  s i+1 , and s i  X  f i . Definition 2 (Temporal database) Considering a database D = { r sequence-id and an event interval (i.e. an event symbol, a starting time, and a finishing time, where starting time  X  finishing time). D is called a temporal database. are grouped together and ordered by nondecreasing start time, the database can be transformed into a collection of event sequences. As a result, the database D can be viewed as a collection of event sequences. For example, in Fig. 2, the temporal database consists of 17 event intervals, and 4 event sequences. Definition 3 (Time set and time sequence) Given an event sequence q =  X  ( e 1 , s 1 , f 1 ), ( e 2 , s 2 , f ={ s 1 , f 1 , s 2 , f 2 , ..., s i , f i ,..., s elements in T and eliminate redundant element, we can derive a sequence Ts =  X  t 1 , t 2 , t 3 , ..., t k  X  where t a time sequence corresponding to sequence q .  X  ( e j , s j , f j ) in q i ,  X  j where 1  X  j  X  n ,  X  ( a , b , q i ) = {  X  1  X   X  event sequence q , and two consecutive event times t its corresponding time sequence Ts =  X  t 1 , t 2 coincidence c i is define as  X  ( t i , t i+ 1 coincidence sequence Cs is denoted by  X  c 1 , c 2 , ..., c coincidence database D c is a set of tuples  X  sid , Cs  X  where sid is a sequence-id and Cs is a co Definition 4 (Event slice) A s tart event slice of event e interval ( e i , t , f i ) where t = max{ t  X  | t  X   X  Ts , s interval ( e i , t , t  X ) where t , t  X   X  Ts , t X   X  s 1  X  i  X  n , is defined as an interval ( e i , t , t  X ) where t = s and intact event slice of event e i are denoted as e i e , respectivel For example, in Fig. 2, sequence 2 has four event intervals, ( B , 1, time set = {1, 5, 8, 14, 10, 13, 10, 13} and time sequence =  X  1, 5, slice D  X  = ( D , 8, 10), intermediate slice D * have one start slice and one finish slice but can have many intermediate slices. Definition 5 (Coincidence, coincidence sequence and Coincidence database) Let set L = {  X  ,  X  ,  X  ,  X  }, a set of event sequences Q = { q q ,...}, q i =  X  ( e 1 , s 1 , f 1 ), ..., ( e j , s s defined as follow: By our observation, the complex relation between each event interval is the major bottleneck for mining temporal patterns. We propose an incision strategy to address this critical issue. There are six possible layouts between two consecutive event times, as shown in Fig. 3. Wit hout loss of generality, we use  X  and  X   X   X  to represent two different event intervals. By traversing all end time points in a sequence, the incision strategy can segment all event intervals to even t slices based on five kinds of outputs as Fig. 3(a) to 3(e). However, we cannot distinguish between two adjacent intervals and two disjoint intervals. A meet token  X  @  X  is used to address this drawback. As in Fig. 3(f), instead of segmenting any event interval, we only output the meet token  X  @  X  to assist the distinction of two adjacent event intervals. Now we give the detailed algorith m and discuss how to segment event intervals into disjoint even t slices efficiently. The algorithm is shown in Fig. 4. Incision st rategy first puts all the end time points of every event interval in sequence into a data structure endtime_list and sorts in non-decreasing order based on their times and types, i.e., start or finish (Lines 2-3, algorithm 1). If the times of two end time points are the same but the types are 
Fig. 3: Possible segmentations between two consecutive end different, the order is based on the ty pe, i.e., finish type is smaller than start type. Then it merges the event symbol of end time points together if both time and type of end time points are identical (Line 4, algorithm). We can segment all event intervals to event slices by traversing all endtime records in endtime_list (Lines 5-12, algorithm 1). Noti ce that if the start slice e form an intact slice e since the interval e do not be incised (Line 14, algorithm 1). For example, considering an event sequence with 5 intervals shown in Fig. 5(a), we first put all 10 end time points into endtime_list and sort them in nondecreasing order based on their times and types. Then we merge the event symbol of end time points together if both time and type of end time points are the same. As in Fig. 5(b), since the B . t s is identical to the C . t merge them together. But we can not combine B . t E . t s , since the type of end time points are not the same. We traverse all the sorted end time points in endtime_list one-by-one to generate the event slices. Reducing memory usage and saving computation time are two important issues for algorithm design. Since we have utilized meet token to effectively distinguish two adjacent intervals, intermediate slices need not be incised. Given an example as Fig. 5(a), the event interval C can be segmented into five event slices, intermediate slices. By trimming the intermediate slices, we can still express the relationship betw een any two intervals correctly, as shown in Fig. 5(c). This tactic reduces the memory usage and the computation cost effectively and efficiently, thereby improves the performance of our incision strategy. By the merge operation of incision strategy, the event slices occur simultaneously in the same time period can be grouped together to form a coincidence easily. Given an event sequence, we can transform it to an equivalent coincidence sequence by incision strategy. Collecting all coincidence sequences can form a coincidence database which is e quivalent to original temporal database. All the Allen X  X  relationships are binary relation and may suffer several problems when describing relationships among more than three events. An appropriate repr esentation is very crucial for facing this circumstance. In this paper, a new format, coincidence representation is proposed to a ddress the ambiguous and scalable problem. We group simultaneously occurring slices together to form the coincidences. Concatena tion with all coincidences can describe an event sequence effectively and simplify the processing of complex pairwise relationships between all intervals efficiently. This is also the primary motivation of coincidence representation. The coincidence representation of Allen X  X  13 relations between two event intervals is categorized as shown in Fig. 6. The new format is adopted to represent both event sequence and temporal pattern since it have several advantages, as follows:  X  Good scalability : In the best case, all k intervals in a pattern  X  Nonambiguity: A representation is ambiguous if 1) the same ( B , 2, 5) ( C , 2, 8) ( D , 3, 5) ( E , 5, 7)  X  Simple is good: Obviously, the complex relations between  X  Compact space usage: Since the utilization of meet token,  X  Fig. 6: The coincidence representation of Allen X  X  13 relations Definition 6 (Projected database) Let Cs be a coincidence sequence in a database D . The Cs -projected database, denoted as D to prefix Cs . Definition 7 (Subsequence, support count and temporal pattern) Considering two coincidence sequence s 1 =  X  a and s 2 =  X  b 1 b 2 ... b m  X  , s 1 is called a subsequence of s s  X  s 2 , if there exist integers 1  X  i 1  X  i 2  X  ...  X  i a 1  X  b i 1 , a 1  X  b i 1 , ..., a n  X  b in , and s 2 supersequence of s 1 . Given a coincidence database D  X  sid , Cs  X  is said to contain a coincidence sequence s subsequence of Cs . The support of a coincidence sequence s coincidence database D c is the number of tuples in the database ( s 1  X  Cs ) } |. Given a positive integer min _ sup as the support threshold, a coincidence sequence s 1 is called a temporal pattern if support ( s 1 )  X  min _ sup . Fig. 7 illustrates the main framework which includes the necessary processing steps for disc over frequent temporal patterns. Given a temporal database, the event intervals associated with the same sequence ID can be grouped into an event sequence. CTMiner first scans the temporal database to discover all frequent intervals and remove infrequent intervals (Line 2, algorithm 2). corresponding coincidence sequences. Then we collect all coincidence sequences to build projected database D slice a (Lines 6-8, algorithm 2). As mentioned above, an event interval a may be incised to three possible event slices, intact slice a , start slice a + identical to the number of occurrence of interval a in database. Thus, we call CPrefixSpan recursively to discover all frequent coincidence patterns prefixed with the intact slice (Lines 9, algorithm 2). The support count of the start slice a accumulated concurrently with constructing projected coincidence database D |a . If the start slice a + is frequent, we also construct the projected coincidence database D | a + and call CPrefixSpan recursively to discover all frequent coincidence patterns prefixed with the start slice (Lines 10-12, algorithm 2). Finally, we output all frequent temporal patterns (Line 13, algorithm 2).
 In Fig. 8, CPrefixSpan, is si milar to PrefixSpan, however it performs two search space pruning strategy using the concepts of slice-and-coincidence. CPrefixSpan scans projected coincidence database once to collect all local frequent 1-patterns (Lines 1-3, algorithm 3). For each frequent 1-pattern, we can append it to original prefix to generate new pattern with the length increased by 1. This way, the prefixes are extended (Lines 4-9, algorithm 3). Finally, constructing the projected database with the frequently extended prefixes and recursively running until the prefixes cannot be extended will discover all frequent temporal patterns (Lines 10-14, algorithm 3). With the property of event slice and coincidence, we propose two pruning strategies, pre-pruning and post-pruning to reduce the searching space efficiently and effectively. First, the event start slices and finish slices definitely occur in pairs in a coincidence sequence. We only require projecting the frequent finish slices which have the corresponding pre-pruning strategy which can prune off non-qualified patterns before constructing projected database. Second, when we construct a proj ected database, some postfixes projected postfix is called significant, if all finish slices in postfix have corresponding start slices in  X  p  X  . When constructing the collected and all insignificant postfixes are eliminated since they can be ignored in the discovery of frequent temporal patterns. The pruning strategy directly since  X  D  X  is insignificant. We do not have to consider the  X  E  X  -projected database. The last column in Fig. 9 lists all generated frequent temporal patterns. second pruning method is called post-pruning strategy which eliminate insignificant sequence when constructing projected database (Line 11, algorithm 3) Different from PrefixSpan al gorithm, CPrefixSpan can not guarantee that the new temporal patterns formed from appending previously discovered patterns with locally frequent slices are always frequent. We require an a dditional computation to insure that the support count of the coin cidence sequences in a projected database is no less than min_sup (Lines 12-13, algorithm 3). Since | D |a | (number of sequences in D |a ) can be produced by using a simple counter when we project the database, the computation cost is near pre-pruning and post-pruning strategies can improve the performance in both computa tion time and memory usage efficiently. Notice that when scanning projected coincidence database to slice b + occurring in coincidence sequences need to be accumulated. Since the only difference between intact slice and start slice is whether the event interval have incised or not, both of them in the coi But when counting the support of start slice b or finish slice b , only the occurrence of b + or b  X  in a database have to be accumulated. We take the database in Fig. 2 with min_sup = 2 as an example. There are 17 event records which can be regarded as 4 event sequences in the temporal databa se. After scanning database, we intervals are also called frequent 1-temporal patterns. The event sequences with corresponding co incidence representation are shown as in first column in Fi g. 9. We take the interval A and E as examples to further discuss in de tails. With considering interval A , we have to process the patterns prefixed with intact slice  X  A  X  and constructing projected database with regard to intact slice  X  A  X  , we also require considering the occurrence of start slice  X  A  X   X  in sequences. The projected coincidence database with respect to  X  A  X  has 3 concurrently. Since the support count of  X  A  X   X  is 2  X  min_sup , we have to construct corresponding projected coincidence database. The projected coincidence database with respect to  X  A  X   X  has 2 )( E )( D  X  )  X  . Continuing the recursive process with the D , we can discover all frequent coincidence patterns prefixed with  X  A  X  and  X  A  X   X  respectively. In addition, when projecting intact slice  X  E  X  , the generated postfixes w ill be elimina To evaluate the performance of CTMiner, three temporal pattern mining algorithms, TPrefixSpan [13] , IEMiner [9], and H-DFS [8] were also implemented for comparison. All algorithms were implemented in C++ language and tested on a Pentium D 3.0 GHz with 2 GB of main memory running Windows XP system. The performance study has been conduc ted on both synthetic and real world datasets. The synthetic data sets in the experiments are generated using synthetic ge neration program proposed by Agrawal et al. [1]. Since the original data generation program was designed to generate time point-bas ed data, the generator for the temporal pattern mining algor ithms requires modifications accordingly. We adopt the modification proposed by Wu et al. [13]. All the duration times of even t intervals are classified into three categories: long, medium a nd short. The long, medium and short interval events are with an average length of 12, 8 and 4 respectively. For each event interval, we first randomly decide its category and then determine its length by drawing a value from a normal distribution. The temporal data generator takes eight parameters same as previous re search, as shown in Fig. 10. | T | = 2.5, | S | = 4, N S = 5,000 and N parameters are configured for comparing the temporal pattern mining algorithms. The first experiment of the four algorithms is on the data set D 10k X  C 10 X  I 1.25 X  N 1k. Fig. 11 and Fig. 12 show the running time of the four algorithms and the distribution of generated frequent patterns, re spectively. The minimum support thresholds vary from 1 % to 4 %. Obviously, when the minimum support value decreases, the pr ocessing time required for all algorithms increases. However, the runtime for IEMiner, H-DFS and TPrefixSpan increase drastically compared to CTMiner. The second experiment is performed on data set D 100k X  C 20 X  I 2.5 X  N 10k, which is much larger th an first experiment. Fig. 13 and Fig. 14 show the running time and the distribution of generated frequent patterns at different support thresholds. However, we vary the minimum support thresholds from 0.5 % to 1 % to generate larger number of frequent patterns from large data set. The data set contains a large number of frequent temporal patterns when minimum support is reduced to 0.5 %. We can see that CTMiner is significantly faster than the other algorithms. The lower the minimal support, the faster CTMiner compared with other algorithms. We also study the scalability of the CTMiner algorithm. Fig. 15 shows the results of scalability tests of the CTMiner algorithm, with the database size growing from 100K to 500K sequences, and with different minimum suppor t threshold settings. Here, we use the data set C 10 X  T 2.5 X  I 1.25 X  N 10k with varying different database size. As can be seen, CTMiner is linearly scalable with different minimum support threshol d and with different database size. Then, we compare the memory usage among the four algorithms using synthetic data set D 10k  X  C 10  X  I 1.25  X  N 1k. Fig. 16 shows the results, from which we can observe that CTMiner is not only more efficient, but also more stable in memory usage than other three algorithms. Based on our analysis, CTMiner only needs memory space to hold the sequence data sets plus a set of header tables and pseudoprojection tables to construct projected databases. Although TPrefixSpa n is also designed based on 
Fig. 12: The distribution of generated patterns on data PrefixSpan, it still consumes memory space to hold the generated candidate sequences since the comp lex relation between intervals. Both IEMiner and H-DFS need memory space to hold candidate sequences in each level. When the minimal support threshold drops, the set of candidate sequences grows up quickly, which results in memory consumption upsurging. In summary, our performance study shows that CTMiner has the best overall performance among the four algorithms tested. Our scalability study also shows that CTMiner scales well even with large database and low threshol d. The memory usage analysis shows the efficient memory consum ption of CTMiner and part of the reason why other algorithms become slow since the candidate sequences may consume a huge amount of memory. In addition to using synthetic data sets, we have also performed an experiment on real world data set to compare the performance. The database used in experime nt consists a collection of 1,098,142 library records (lending and returning) for three years from the National Chiao Tung University Library. The experimented database includes 206,844 books and 28,339 readers. An event interval is constructed by a book ID and corresponding lending and returning tim e. The size of database is the number of sequences in databa se (same as number of readers, 28,339). The maximal and the average length of sequence are 262 and 38 respectively. Fig. 17 indicates the running time of four temporal pattern mining algor ithms with varying minimum support thresholds from 0.1 % to 0.05 %. The distribution of generated patterns is shown in Fig. 18. As the minimum support drops down to 0.05 %, there are 14,549 frequent patterns and the running time of CTMiner takes 4,771 seconds, which is about 2 times faster than TPrefixSpan, a bout 4 times faster than IEMiner and H-DFS has never terminated. Mining temporal patterns from time interval-based data is a difficult problem since the processing of complex relations among intervals may require generating and examining large amount of intermediate subsequences. In this paper, a novel technique, incision strategy and a new representation, coincidence representation are proposed to remedy this critical issue. We simplify the processing of complex relations among event intervals effectively. The proposed coincidence representation is nonambiguous and has several advantages over existing representations. Based on coincidence representation, we develop an efficient algorithm, CTMiner to discover frequent temporal patterns without candidate generation. Th e algorithm further employs two pruning techniques to reduce the search space effectively. The experimental studies indicate that CTMiner is efficient and scalable. Both running time and memory usage of CTMiner outperform state-of-the-art algorithms. To the best of our knowledge, all previous extensions of mining sequential pattern only focus on time point-based data. No attention has been paid to the re lated extension studies of mining temporal patterns from time interval-based data. By our observation, the major reason is the complex relation among intervals. In this paper, we utilize proposed coincidence representation to overcome this problem and facilitate the processing. Hence, based on coincidence representation, there are many interesting extensions that may be studied further, such as mining closed and maximal tem poral patterns, incremental temporal patterns mining, and the research of method toward data stream. This work was supported in part by the National Science Council of Taiwan. Suh-Yin Lee was supported by Project No. NSC99-2221-E-009-128-MY2 and Wen-Chih Peng was supported by Project No. NSC 97-2221-E-009-053-MY3 . 
Fig. 16: The memory usage of four algorithms on data [1] R. Agrawal and R. Srikant. Mining Sequential Patterns. [2] J. Allen. Maintaining Knowledge about Temporal Intervals. [3] F. Hoppner. Finding informative rules in interval sequences. [4] P. Kam and W. Fu. Discove ring Temporal Patterns for [5] M. Lin and S. Lee. Fast Disc overy of Sequential Patterns by [6] F. Masseglia, F. Cathala and P. Poncelet. The PSP Approach [7] F. Morchen and A. Ultsch. Efficient Mining of [8] P. Papapetrou, G. Kollios, S. Sclaroff, and D. Gunopulos. [9] D. Patel, W. Hsu and M. L ee. Mining Relationships Among [10] J. Pei, J. Han, B. Mortazavi-Asl, H. Pito, Q. Chen, U. Dayal, [11] R. Srikant and R. Agrawal. Mining Sequential patterns: [12] E. Winarko and J.F Roddick. ARMADA-An algorithm for [13] S. Wu and Y. Chen. Mini ng Nonambiguous Temporal [14] M. Zaki. SPADE: An Efficient Adlgorithm for Mining 
