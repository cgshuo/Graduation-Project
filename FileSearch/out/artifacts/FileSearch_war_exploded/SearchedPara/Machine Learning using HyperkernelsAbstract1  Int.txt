 Cheng Soon Ong Cheng.Ong@anu.edu.au Alexander J. Smola Alex.Smola@anu.edu.au Kernel Methods have been highly successful in solving various problems in machine learning. The algorithms work by mapping the inputs into a feature space, and finding a suitable hypothesis in this new space. In the case of the Support Vector Machine, this solution is the hyperplane which maximizes the margin in the feature space. The feature mapping in question is de-fined by a kernel function, which allows us to compute dot products in feature space using only the objects in the input space.
 Recently, there have been many developments regard-ing learning the kernel function itself (Bousquet &amp; Her-rmann, 2003; Crammer et al., 2003; Cristianini et al., 2002; Lanckriet et al., 2002; Momma &amp; Bennett, 2002; Ong et al., 2003). In this paper, we extend the hy-perkernel framework introduced in Ong et al. (2003), which we review in Section 2. In particular, the con-tributions of this paper are:  X  a general class of hyperkernels allowing automatic relevance determination (Section 3),  X  explicit mathematical programming formulations of the optimization problems (Section 4),  X  implementation details of various SVMs and Align-ment (Section 5)  X  and further experiments on binary classification and novelty detection (Section 6).
 At the heart of the strategy is the idea that we learn the kernel by performing the kernel trick on the space of kernels, hence the notion of a hyper kernel. As motivation for the need for such a formulation, con-sider Figure 1, which shows the separating hyperplane and the margin for the same dataset. Figure 1(a) shows the training data and the classification function for a support vector machine using a Gaussian RBF kernel. The data has been sampled from two Gaussian distributions with standard deviation 1 in one dimen-sion and 1000 in the other. This difference in scale creates problems for the Gaussian RBF kernel, since it is unable to find a kernel width suitable for both dimensions. Hence, the classification function is dom-inated by the dimension with large variance. The tra-ditional way to handle such data is to normalize each dimension independently.
 Instead of normalizing the input data, we make the kernel adaptive to allow independent scales for each dimension. This allows the kernel to handle unnor-malized data. However, the resulting kernel would be difficult to tune by cross validation as there are nu-merous free variables (one for each dimension). We  X  X earn X  this kernel by defining a quantity analogous to the risk functional, called the quality functional, which measures the  X  X adness X  of the kernel function. The classification function for the above mentioned data is shown in Figure 1(b). Observe that it captures the scale of each dimension independently.
 We review the definitions from (Ong et al., 2003). Given a set of input data, X , and their associated labels 1 , Y , and a class of kernels K , we would like to select the best kernel k  X  K for the problem. Definition 1 (Empirical Quality Functional) Given a kernel k , and data X, Y , we define Q emp ( k, X, Y ) to be an empirical quality func-tional if it depends on k only via k ( x i , x j ) where x , x j  X  X for 1 6 i, j 6 m . Q emp tells us how well matched k is to a specific dataset X, Y . Examples of such functionals include the Kernel Target Alignment, the regularized risk and the negative log-posterior. However, if provided with a sufficiently rich class of kernels K it is in general possible to find a kernel that attains the minimum of any such Q emp regardless of the data (see (Ong et al., 2003) for examples). Therefore, we would like to some-how control the complexity of the kernel function. We achieve this by using the kernel trick again on the space of kernels.
 Definition 2 (Hyper RKHS) Let X be a nonempty set and denote by X := X  X  X the compounded index set. The Hilbert space H of functions k : X  X  R , endowed with a dot product  X  X  ,  X  X  (and the norm k k k = p  X  k, k  X  ) is called a Hyper Reproducing Kernel Hilbert Space if there exists a hyperkernel k : X  X  X  X  R with the following properties: 1. k has the reproducing property 2. k spans H , i.e. H = span { k ( x ,  X  ) | x  X  X } where X 3. For any fixed x  X  X the hyperkernel k is a kernel What distinguishes H from a normal RKHS is the par-ticular form of its index set ( X = X 2 ) and the ad-ditional condition on k to be a kernel in its second argument for any fixed first argument. This condi-tion somewhat limits the choice of possible kernels, on the other hand, it allows for simple optimization algo-rithms which consider kernels k  X  H , which are in the convex cone of k . Analogous to the regularized risk functional, R reg ( f, X, Y ) = 1 m P m i =1 l ( x i , y i k f k 2 , we regularize Q emp ( k, X, Y ).
 Definition 3 (Regularized Quality Functional) where  X  Q &gt; 0 is a regularization constant and k k k 2 denotes the RKHS norm in H .
 Minimization of Q reg is less prone to overfitting than minimizing Q emp , since the regularizer  X  Q 2 k k k 2 H effec-tively controls the complexity of the class of kernels under consideration (this can be derived from (Bous-quet &amp; Herrmann, 2003)). The minimizer of (2) satis-fies the representer theorem: Theorem 4 (Representer Theorem) Denote by X a set, and by Q an arbitrary quality functional. Then each minimizer k  X  H of the regularized quality func-tional (2), admits a representation of the form This shows that even though we are optimizing over a whole Hilbert space of kernels, we still are able to find the optimal solution by choosing among a finite number, which is the span of the kernel on the data. Note that the minimizer (3) is not necessarily positive semidefinite. In practice, this is not what we want, since we require a positive semidefinite kernel. There-fore we need to impose additional constraints. We re-quire that all expansion coefficients  X  i,j &gt; 0. While this may prevent us from obtaining the minimizer of the objective function, it yields a much more amenable optimization problem in practice. In the subsequent derivations of optimization problems, we choose this restriction as it provides a tractable problem. Similar to the analogy between Gaussian Processes (GP) and SVMs (Opper &amp; Winther, 2000), there is a Bayesian interpretation for Hyperkernels which is analogous to the idea of hyperpriors. Our approach can be interpreted as drawing the covariance matrix of the GP from another GP. The criteria imposed by Definition 2 guide us directly in the choice of functions suitable as hyperkernels. The first observation is that we can optimize over the space of kernel functions, hence we can take large linear com-binations of parameterized families of kernels as the basic ingredients. This leads to the so-called harmonic hyperkernels (Ong et al., 2003): Example 1 (Harmonic Hyperkernel) Denote by k a kernel with k : X  X  X  X  [0 , 1] , and set c i := (1  X   X  h )  X  i h for some 0 &lt;  X  h &lt; 1 . Then we have obtain for k (( x, x 0 ) , ( x 00 , x 000 )) However, if we want the kernel to adapt automatically to different widths for each dimension, we need to per-form the summation that led to (4) for each dimension in its arguments separately (similar to automatic rel-evance determination (MacKay, 1994)).
 Example 2 (Hyperkernel for ARD) Let k ( x, x 0 ) = exp(  X  d  X  ( x, x 0 )) , where d  X  ( x, x ( x  X  x 0 ) &gt;  X ( x  X  x 0 ) , and  X  a diagonal covariance matrix. Take sums over each diagonal entry  X  j =  X  jj separately to obtain = This is a valid hyperkernel since k ( x ) factorizes into its coordinates. A similar definition also allows us to use a distance metric d ( x, x 0 ) which is a generalized radial distance as defined by (Haussler, 1999). We derive Semidefinite Programming (SDP) formu-lations of the optimization problems arising from the minimization of the regularized risk functional. Semidefinite programming (Vandenberghe &amp; Boyd, 1996) is the optimization of a linear objective func-tion subject to constraints which are linear matrix in-equalities and affine equalities. The following proposi-tion allows us to derive a SDP from a class of general quadratic programs. It is an extension of the deriva-tion in (Lanckriet et al., 2002) and its proof can be found in Appendix A.
 Proposition 5 (Quadratic Minimax) Let m, n, M  X  N , H : R n  X  R m  X  m , c : R n  X  R m , be linear maps. Let A  X  R M  X  m and a  X  R M . Also, let d : R n  X  R and G (  X  ) be a function and the further constraints on  X  . Then the optimization problem can be rewritten as min subject to  X  &gt; 0 , G (  X  ) 0 Specifically, when we have the regularized quality func-tional, d (  X  ) is quadratic, and hence we obtain an opti-mization problem which has a mix of linear, quadratic and semidefinite constraints.
 Corollary 6 can be rewritten as minimize subject to  X  &gt; 0 The proof of the above is obtained immediately from Proposition 5 and introducing an auxiliary variable t 0 which upper bounds the quadratic term of  X  . When Q emp is the regularized risk, we obtain: Comparing the objective function in (8) with (10), we observe that H (  X  ) and c (  X  ) are linear in  X  . Let  X  0 As we vary  X  the constraints are still satisfied, but the objective function scales with  X  . Since  X  is the coef-ficient in the hyperkernel expansion, this implies that we have a set of possible kernels which are just scalar multiples of each other. To avoid this, we add an ad-ditional constraint on  X  which is 1 &gt;  X  = 1. This breaks the scaling freedom of the kernel matrix. As a side-effect, the numerical stability of the SDP problems im-proves considerably.
 We give some examples of common SVMs which are derived from (10). The derivation is basically by ap-plication of Corollary 6. We derive the corresponding SDP for the case when Q emp is a C -SVM (Example 3). Derivations of the other examples follow the same rea-soning, and are omitted. In this subsection, we define the following notation. For p, q, r  X  R n , n  X  N let r = p  X  q be defined as element by element multiplication, r = p i  X  q i . The pseudo-inverse (or Moore-Penrose in-verse) of a matrix K is denoted K  X  . Define the hyper-kernel Gram matrix K by K ijpq = k (( x i , x j ) , ( x p the kernel matrix K = reshape( K  X  ) (reshaping a m 2 by 1 vector, K  X  , to a m by m matrix), Y = diag ( y ) (a matrix with y on the diagonal and zero everywhere else), G (  X  ) = Y KY (the dependence on  X  is made explicit), I the identity matrix and 1 a vector of ones. The number of training examples is assumed to be m . Where appropriate,  X  and  X  are Lagrange multipliers, while  X  and  X  are vectors of Lagrange multipliers from the derivation of the Wolfe dual for the SDP,  X  are the hyperkernel coefficients, t 1 and t 2 are the auxiliary variables.
 Example 3 (Linear SVM ( C -style)) A commonly used support vector classifier, the C -SVM (Bennett &amp; Mangasarian, 1992; Cortes &amp; Vapnik, 1995) uses an ` 1 soft margin, l ( x i , y i , f ( x i )) = max(0 , 1  X  y which allows errors on the training set. The parameter C is given by the user. Setting the quality functional Q where z =  X y + 1 +  X   X   X  .
 The value of  X  which optimizes the corresponding La-grange function is G (  X  )  X  z , and the classification func-tion, f = sign ( K (  X   X  y )  X  b offset ) , is given by f = sign ( KG (  X  )  X  ( y  X  z )  X   X  ) .
 Proof [Derivation of SDP for C -SVM] We begin our derivation from the regularized quality functional (10). Dividing throughout by  X  and setting the cost function to the ` 1 soft margin loss, that is l ( x i , y i , f ( x max(0 , 1  X  y i f ( x i )) we get the following equation. min subject to y i f ( x i ) &gt; 1  X   X  i Recall the form of the C -SVM, and its dual, subject to P m i =1  X  i y i = 0 By considering the optimization problem dependent on f in (12), we can use the derivation of the dual problem of the standard C -SVM. Observe that C =  X   X  1 , and we can rewrite k k k 2 H =  X  &gt; K  X  due to the representer theorem. Substituting the dual C -SVM problem into (12), we get the following matrix equation, This is of the quadratic form of Corollary 6 where x =  X  ,  X  =  X  , H (  X  ) = G (  X  ), c (  X  ) =  X  1 ,  X  = C X  the constraints are A = y  X  y I  X  I &gt; and a = 0 0 0 C m 1 &gt; . Applying Corollary 6, we obtain the SDP in Example 3. To make the different constraints explicit, we replace the matrix constraint Ax + a &gt; 0 and its associated Lagrange multiplier  X  with three linear constraints. We use  X  as the Lagrange multiplier for the equality constraint  X  &gt; y = 0,  X  for  X  &gt; 0, and  X  for  X  6 C Example 4 (Linear SVM (  X  -style)) An alterna-tive parameterization of the ` 1 soft margin was in-troduced by (Sch  X olkopf et al., 2000), where the user defined parameter  X   X  [0 , 1] controls the fraction of margin errors and support vectors. Using  X  -SVM as Q emp , that is, for a given  X  , Q emp ( k, X, Y ) = ing SDP is given by where z =  X y +  X  1 +  X   X   X  .
 The value of  X  which optimizes the corresponding La-grange function is G (  X  )  X  z , and the classification func-tion, f = sign ( K (  X   X  y )  X  b offset ) , is given by f = sign ( KG (  X  )  X  ( y  X  z )  X   X  ) .
 Example 5 (Quadratic SVM) Instead of using an ` 1 loss class, (Mangasarian &amp; Musicant, 2001) uses an ` 2 loss class, l ( x i , y i , f ( x i )) = and regularized the weight vector as well as the bias term, that is the empirical quality functional is set b i = 1 , . . . , m . This is also known as the Lagrangian SVM. The resulting dual SVM problem has fewer con-straints, as is evidenced by the smaller number of La-grange multipliers needed in the SDP below. where H (  X  ) = Y ( K + 1 m  X  m +  X m I ) Y , and z =  X  1 +  X   X   X  .
 The value of  X  which optimizes the corresponding La-grange function is H (  X  )  X  (  X  + 1 ) , and the classifica-f = sign ( KH (  X  )  X  ((  X  + 1 )  X  y ) + y &gt; ( H (  X  ) Example 6 (Single class SVM) For unsupervised learning, the single class SVM computes a func-tion which captures regions in input space where the probability density is in some sense large (Sch  X olkopf et al., 2001). The quality functional Q emp ( k, X, Y ) = The corresponding SDP for this problem, also known as novelty detection, is shown below. where z =  X  1 +  X   X   X  , and  X   X  [0 , 1] a user selected parameter controlling the proportion of the data to be classified as novel.
 The score to be used for novelty detection is given by f = K X   X  b offset , which reduces to f =  X   X   X  , by substituting  X  = K  X  (  X  1 +  X   X   X  ) , b offset =  X  1 and K = reshape ( K  X  ) .
 Example 7 (  X  -Regression) We derive the SDP for  X  regression (Sch  X olkopf et al., 2000), which auto-matically selects the  X  insensitive tube for regres-sion. As in the  X  -SVM case in Example 4, the user defined parameter  X  controls the fraction of errors and support vectors. Using the  X  -insensitive loss,  X  -parameterized quality functional, Q emp ( k, X, Y ) = y i 6  X   X   X  i , y i  X  f ( x i ) 6  X   X   X   X  i ,  X  i = 1 , . . . , m and  X  &gt; 0 . The corresponding SDP is where z = F (  X  ) = The Lagrange function is minimized for  X  = F (  X  )  X  z , and substituting into f = K X   X  b offset , we obtain the regression function f =  X  K K F (  X  )  X  z  X   X  . Example 8 (Kernel Target Alignment) For the Alignment approach (Cristianini et al., 2002), Q emp = y
Ky , we directly minimize the regularized quality functional, obtaining the following optimization prob-lem, Note that for the case of Alignment, Q emp does not provide a direct formulation for the hypothesis func-tion, but instead, it determines a kernel matrix K . This kernel matrix, K , can be utilized in a traditional SVM to obtain a classification function. We used data from the UCI repository for our experi-ments. Where the data was numerical, we did not per-form any preprocessing of the data. Boolean attributes were converted to { -1,1 } , and categorical attributes were arbitrarily assigned an order, and numbered { 1, 2,. . . } . The hyperkernel used was as in Example 2. This scaling freedom means that we did not have to normalize data to some arbitrary distribution. Similar to Ong et al. (2003), we used a low rank decomposi-tion (Fine &amp; Scheinberg, 2000; Zhang, 2001) for the hyperkernel matrix. 6.1. Classification Experiments A set of synthetic data sampled from two Gaussians was created, a sample of which is illustrated in Fig-ure 1. The rest of the datasets were UCI datasets for binary classification tasks. The datasets were split into 10 random permutations of 60% training data and 40% test data. We deliberately did not attempt to tune pa-rameters and instead made the following choices uni-formly for all datasets:  X  The kernel width  X  was set to 50 times the 90% quantile of the value of | x i  X  x j | over all the training data, which ensures sufficient coverage.  X   X  was adjusted so that 1 the Vapnik-style parameterization of SVMs). This has commonly been reported to yield good results.  X   X  was set to 0.3. While this is clearly suboptimal for many datasets, we decided to choose it beforehand to avoid having to change any parameter. We could use previous reports on generalization performance to set  X  to this value for better performance.  X   X  h for the Gaussian Harmonic Hyperkernel was cho-sen to be 0 . 6 throughout, giving adequate coverage over various kernel widths in (4) (small  X  h focus al-most exclusively on wide kernels,  X  h close to 1 will treat all widths equally).  X  The hyperkernel regularization was set to  X  Q = 1. We observe (Table 1) that our method achieves state of the art results for all the datasets, except the  X  X eart X  dataset. We also achieve results much better than pre-viously reported for the  X  X redit X  dataset. Comparing the results for C -SVM and Tuned SVM, we observe that our method is always equally good, or better than a C -SVM tuned using 10-fold cross validation. 6.2. Novelty Detection Experiments To demonstrate that we can solve problems other than binary classification using the same framework, we performed novelty detection. We apply the singleclass support vector machine (Example 6) to detect outliers in the USPS data. A subset of 300 randomly selected USPS images for the digit  X 5 X  were used for the ex-periments. The parameter  X  was set to 0.1 for these experiments, hence selecting up to 10% of the data as outliers. The rest of the parameters were the same as in the previous section. Since there is no quantitative method for measuring the performance of novelty de-tection, we cannot directly compare our results with the traditional single class SVM. We can only subjec-tively conclude, by visually inspecting a sample of the digits, that our approach works for novelty detection of USPS digits. Figure 2 shows a sample of the digits. We can see that the algorithm identifies  X  X ovel X  digits, such as in the top row of Figure 2. The bottom row shows a sample of digits which have been deemed to be  X  X ommon X .
 We have shown that it is possible to define a convex op-timization problem which learns the best kernel given the data. The resulting problem, which has a Bayesian interpretation, is expressed as a SDP. Since we can op-timize over the whole class of kernel functions, we can define more general kernels which may have many free parameters, without overfitting. The experimental re-sults on classification and novelty detection demon-strate that it is possible to achieve the state of the art, and in certain cases (such as the credit data) improve the accuracy significantly.
 This approach makes support vector based estimation approaches more automated. Parameter adjustment is less critical compared to the case when the kernel is fixed. Future work will focus on deriving improved statistical guarantees for estimates derived via hyper-kernels which match the good empirical performance. Acknowledgements This work was supported by a grant of the Australian Research Council. The au-thors would like to thank Laurent El Ghaoui, Michael Jordan, John Lloyd, Robert Williamson and Daniela Pucci de Farias for their helpful comments and sugges-tions. The authors also thank Alexandros Karatzoglou for his help with SVLAB.
 Albert, A. (1969). Conditions for positive and nonneg-ative definiteness in terms of pseudoinverses. SIAM Journal on Applied Mathematics , 17 , 434 X 440. Bennett, K. P., &amp; Mangasarian, O. L. (1992). Robust linear programming discrimination of two linearly inseparable sets. Optimization Methods and Soft-ware , 1 , 23 X 34.
 Bousquet, O., &amp; Herrmann, D. (2003). On the com-plexity of learning the kernel matrix. Advances in Neural Information Processing Systems 15 .
 Cortes, C., &amp; Vapnik, V. (1995). Support vector net-works. Machine Learning , 20 , 273 X 297.
 Crammer, K., Keshet, J., &amp; Singer, Y. (2003). Kernel design using boosting. Advances in Neural Informa-tion Processing Systems 15 .
 Cristianini, N., Shawe-Taylor, J., Elisseeff, A., &amp; Kan-dola, J. (2002). On kernel-target alignment. Ad-vances in Neural Information Processing Systems 14 (pp. 367 X 373). Cambridge, MA: MIT Press.
 Fine, S., &amp; Scheinberg, K. (2000). Efficient SVM train-ing using low-rank kernel representation (Technical Report). IBM Watson Research Center, New York. Freund, Y., &amp; Schapire, R. E. (1996). Experiments with a new boosting algorithm. Proceedings of the
International Conference on Machine Learing (pp. 148 X 146). Morgan Kaufmann Publishers.
 Haussler, D. (1999). Convolutional kernels on dis-crete structures (Technical Report UCSC-CRL-99-10). Computer Science Department, UC Santa Cruz. Lanckriet, G., Cristianini, N., Bartlett, P., Ghaoui,
L. E., &amp; Jordan, M. (2002). Learning the kernel matrix with semidefinite programming. Proceedings of the International Conference on Machine Learn-ing (pp. 323 X 330). Morgan Kaufmann.
 MacKay, D. J. C. (1994). Bayesian non-linear mod-elling for the energy prediction competition. Amer-ican Society of Heating, Refrigerating and Air-Conditioning Engineers Transcations , 4 , 448 X 472. Mangasarian, O. L., &amp; Musicant, D. R. (2001).
Lagrangian support vector machines. Jour-nal of Machine Learning Research , 1 , 161 X 177. http://www.jmlr.org.
 Meyer, D., Leisch, F., &amp; Hornik, K. (2003). The sup-port vector machine under test. Neurocomputing . Forthcoming.
 Momma, M., &amp; Bennett, K. P. (2002). A pattern search method for model selection of support vector regression. Proceedings of the Second SIAM Inter-national Conference on Data Mining .
 Ong, C. S., Smola, A. J., &amp; Williamson, R. C. (2003).
Hyperkernels. Advances in Neural Information Pro-cessing Systems 15 .
 Opper, M., &amp; Winther, O. (2000). Gaussian processes and SVM: Mean field and leave-one-out. Advances in Large Margin Classifiers (pp. 311 X 326). Cam-bridge, MA: MIT Press.
 R  X atsch, G., Onoda, T., &amp; M  X uller, K. R. (2001). Soft margins for adaboost. Machine Learning , 42 , 287 X  320.
 Sch  X olkopf, B., Platt, J., Shawe-Taylor, J., Smola, A. J., &amp; Williamson, R. C. (2001). Estimating the support of a high-dimensional distribution. Neural Compu-tation , 13 , 1443 X 1471.
 Sch  X olkopf, B., Smola, A., Williamson, R. C., &amp;
Bartlett, P. L. (2000). New support vector algo-rithms. Neural Computation , 12 , 1207 X 1245.
 Vandenberghe, L., &amp; Boyd, S. (1996). Semidefinite programming. SIAM Review. , 38 , 49 X 95.
 Zhang, T. (2001). Some sparse approximation bounds for regression problems. Proc. 18th International Conf. on Machine Learning (pp. 624 X 631). Morgan Kaufmann, San Francisco, CA.
 We prove the proposition that the solution of the quadratic minimax problem (6) is obtained by mini-mizing the SDP (7).
 Proof Rewrite the terms of the objective function in (6) dependent on x in terms of their Wolfe dual. The corresponding Lagrange function is
L ( x,  X ,  X  ) =  X  where  X   X  R M is a vector of Lagrange multipliers with  X  &gt; 0. By differentiating L ( x,  X ,  X  ) with respect to x and setting the result to zero, one obtains that (19) is maximized with respect to x for x = H (  X  )  X  ( A &gt; c (  X  )) and subsequently we obtain the dual D (  X ,  X  ) = constraints in (6), such as Bx + b = 0, we get corre-spondingly free dual variables. The dual optimization problem is given by inserting (20) into (6) Introducing an auxiliary variable, t , which serves as an upper bound on the quadratic objective term gives an objective function linear in t and  X  . Then (21) can be written as minimize subject to t ( A &gt;  X   X  c (  X  )) &gt; H (  X  )  X  ( A &gt; From the properties of the Moore-Penrose inverse, we H (  X  ) 0, by the Schur complement lemma (Albert, 1969), the quadratic constraint in (22) is equivalent to
