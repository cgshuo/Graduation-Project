 Montserrat Esta  X  nol 1( It is essential to evaluate the correctness of these models as early as possible, The correctness of an artifact-centric BPM can be assessed from two differ-The main contribution of our work is to propose an approach to verify and all BAUML components into a set of logic formulas. The result of this trans-lation ensures that the only changes allowed are those specified in the model, and that those changes are taking place according the order established by the model. Having obtained this logic representation, these models can be validated by any existing reasoning method able to deal with negation of derived predi-cates. We also show the feasibility of our approach by using an implementation of an existing method that is able to carry out verification and validation tests. artifact-centric BPMs in practice with reliable results since previous proposals always dealt with this problem at a theoretical level or bounded the number of objects considered. It is also the first one to handle together reasoning on class diagrams, state transition diagrams, activity diagrams and operation contracts. this problem at a theoretical level. In [ 14 ] we did not consider the notion of business artifact, nor state transition diagrams and activity diagrams during reasoning. In [ 4 ] we identified sufficient conditions over BAUML models which guarantee decidability of verification, and which can be applied to this work. We base our work on the BALSA framework [ 12 ], which establishes four differ-ent dimensions that should be present in any artifact-centric business process model. They are the following. Business Artifacts represent the information required by the business, whose evolution we wish to track. Lifecycles are used to represent the evolution of an artifact during its life, from the moment it is cre-ated until it is destroyed. Associations establish the execution flow for services. Services (also known as tasks) are atomic units of work in the business pro-cess. As such, they make changes to artifacts by creating, updating and deleting them. Apart from artifacts, businesses keep data which may change but whose potential states are not relevant from the business X  X  point of view. We will refer to it as objects .
 the BALSA dimensions using UML and OCL: UML class diagrams for business artifacts; UML state transition diagrams for lifecycles; UML activity diagrams for associations, and OCL operation contracts for services.
 tem. Figure 1 shows its UML class diagram. Bicycle is the only business artifact since we wish to track in the system the bicycle X  X  evolution. A Bicycle may be in state Available , InUse or Unusable (we shortened the names for convenience; they should be called AvailableBicycle , etc.). The rest of the classes correspond to objects and specify the data required to rent a bicycle.
 Figure 2 shows the lifecycle of the artifact Bicycle . When a Bicycle is regis-Figure 3 shows the activity diagram for transition Register New Bicycle .To The operation contracts for the tasks in Figure 3 are shown below. For the BAUML provides a high-level of abstraction that allows specifying artifact-This section formally presents the BALSA UML models that we use and the logic formalization in which they are translated in order to check their correctness. The BAUML Model. A BAUML model B is a tuple M , S , P , T , describing the four dimensions of the BALSA framework: Class Diagram: M is a UML class diagram, in which some classes represent (business) artifacts. We denote the set of artifacts in M as artifacts ( M ) and, when convenient, we use artifacts ( B ) interchangeably. Each artifact is the top class of a hierarchy whose leaves are subclasses with a dynamic behavior (their instances change from one subclass to another). Each subclass represents a specific state in which an artifact instance can be at a certain moment in time. These subclasses must fulfill the covering and disjointness constraints (i.e. the artifact must exactly have one of the subclasses type at a certain point in time.) We denote the classes in M as classes ( M ), and the associations in M as associations ( M ). When convenient, we may refer to them as classes ( B )and associations ( B ). A class diagram will also have a set of graphical and textual (defined in OCL) integrity constraints, which we denote as O .
 State Transition Diagrams: S is a set of UML state transition diagrams, one per artifact in artifacts ( M ). More formally, for each artifact A  X  artifacts ( M ), S contains a state transition diagram S A = V, V 0 ,E,T , where V is a set of states, V 0  X  V is the set of initial states, E is a set of events, and T  X  V  X  OCL M  X  E  X  C  X  V is a set of transitions between pairs of states, where OCL M is an OCL condition over M and C is a tag on the result of the execution of the event in E . The states V of S A exactly mirror the subclasses of A . ([ facts manipulated by ExternalEvent . The transition will take place if OCL M is true when the external event is received. The execution of the event results in tag C (as we shall see, its possible values are success and fail ).
 must appear at least in a transition of the state transition diagram of each artifact a i . The execution of external events and the tags C resulting from this execution are driven by activity diagrams.
 Activity Diagrams: P is a set of UML activity diagrams, such that for every state transition diagram S = V, V 0 ,E,T  X  X  , and for every event  X   X  extEvents ( S ) there exists exactly one activity diagram P  X   X  X  .
 node, n f  X  N is the set of final nodes and F  X  N  X  G  X  C  X  N is a set of transitions between pairs of nodes where C is a tag ( success or fail ) denoting the correct or incorrect execution of the transition, and G a guard condition. nodes (denoted as ini ( P  X  )), final nodes ( final ( P  X  )), gateways ( gateways ( P  X  ) We only allow guard conditions over a transition f = n s ,g,c,n t  X  F if n s We make the following assumptions: decision nodes have one incoming flow During the execution of an activity diagram the constraints may be violated, Given an artifact A  X  X  , we denote by tasks ( A ) the set of tasks appearing S . Moreover, we assume that every task in tasks ( A ) that does not belong
T A normal clause has the form: A  X  L 1  X  ...  X  L m with m  X  0, where A is an
L i , are assumed to be universally quantified over the whole formula. A is p ( a ), where p ( a ) is a ground atom, or a deductive rule , p ( T )  X  L m  X  1, where p is the derived predicate defined by rule.
 A condition is a formula of the (denial) form:  X  L 1  X  ...  X  L m with m  X  1. every variable occurring in their head or in negative or built-in literals must also occur in an ordinary positive literal of the same body. An instance of a schema S is a tuple ( E, S ) where E is a set of facts about base predicates. DR ( E ) denotes the whole set of ground facts about base and derived predicates that are inferred from an instance ( E, S ), and corresponds to the fixpoint model of DR  X  E . Given a BAUML model, our goal is to ensure that it is correct (verification) and that it satisfies the user requirements (validation). To do so, we need to transform the model into the logic described in section 3 . After this, we will obtain a set of derivation rules and conditions (a schema) representing the BAUML model. A desirable property of the model will be then tested by checking the satisfiability of a derived predicate.
 and operation contracts were considered. Note that in this case no restrictions were imposed on the execution of the tasks nor on the checking of the constraints. 4.1 Translation Algorithms Our translation process is divided into four steps, shown in Algorithm 1 .To begin with, we focus on the generic steps: obtaining derivation rules for classes and associations, translating the integrity constraints, generating the derivation rules from the tasks, and adding the required conditions to ensure that tasks execute properly, in the context given by state transition and activity diagrams. associations. To determine if a class or association is read-only or read-write, it is only necessary to examine the postcondition of all the tasks as described in [ 14 ]. The predicate corresponding to each read-write class and association will have a time component t indicating that the element exists at time t , whereas read-only elements will not include the time t and will be treated as base predicates. and deleted in the model. The general form of these rules is: where p corresponds to the attributes in the class (including its OID [unique object identifier]) or the participants in the association, p j represents the iden-tifier of the class (its OID) or association (OID of the classes that participate and identify it) C , and thus p j  X  p ,and t and t 1 represent the time. We will see how addC ( ... )and deletedC ( ... ) are obtained later on.
 it has been created previously, at t 1 ( t 1  X  t ), and it has not been deleted in the meantime. For instance, Bicycle is encoded as:
Bicycle ( b, t )  X  addBicycle ( b, t Step 2 of the algorithm translates the constraints O into a set of formulas in For instance, the covering constraint in the hierarchy of Bicycle indicates Step 3 is the most complex and it is decomposed into various algorithms. It Finally, step 4 generates the remaining necessary constraints to ensure the Algorithm 2. translateTask( task ) a sequence of tasks that execute in the activity diagram, it ensures that all of them execute and creates the derivation rules to generate predicate validState at the end of the execution of the activity diagram.
 aimed at translating the atomic tasks. As they make changes to the instances of the class diagram, this translation will result in the derivation rules that generate predicates addEl and delEl , where el is a class or an association. In [ 14 ], these rules are generated by analyzing the postcondition of each task and determining if the task creates or deletes some instance. If the task has a precondition, then its translation (following [ 15 ]) is also added to the body of the derivation rule to ensure that it is true at time t  X  1, where t represents the time the task executes. task execution. In BAUML tasks execute following the restrictions and the order established by the state transition and activity diagrams. In particular, task k can only execute if pre task k is true and the previous task task k  X  1 has executed at t  X  1.
 Algorithm 3 to obtain the part of the rule that refers to the successful execution of the previous tasks. At the end, Algorithm 2 generates a rule of the form: where p a corresponds to the OID of the business artifact, which we use to ensure the proper evolution of the system, and z corresponds to the remaining param-eters or terms of task . The derived predicate of this rule, task ( ... ), will be used as an indicator that task has executed properly by the next task.
 depends on the previous node(s) of a certain node. Its complexity lies in the fact that we consider not only linear activity diagrams, but that we also allow decision and merge nodes. We assume that control nodes do not add execution time to our diagrams and that they are traversed immediately. So, given a node n that belongs to an activity diagram P  X  and time t , the algorithm: 1. Obtains the previous nodes of n , stores them in prevSet and initializes result to the empty set. 2. For each n p  X  prevSet , it checks its type. (a) If n p is a task, it then adds the n p ( ... ) predicate to the existing result , (b) If n p is a decision node, the algorithm needs to obtain the predicates cor-(c) If n p is a merge node, it invokes itself with parameters n p and t ,andit (d) If, on the other hand, n p is an initial node, it adds the source state of the 3. The algorithm returns variable result , containing a set of rule fragments. addAvailableIsIn ( b, a, t )  X  assignT oAnchP oint ( a, b, t )  X  AnchorP oint ( a ) assignT oAnchP oint ( b, t )  X  assignT oAnchP oint ( a, b, t )  X  AnchorP oint ( a ) dition which must be true at t  X  1, and its translation appears in the derivation rule of addAvailableIsIn . In addition to this, the body of the rule includes the predicate createN ewBicycle , that guarantees that the previous operation ( Create New Bicycle ) has executed successfully.
 Algorithm 4. generateConstraintsTaskExecution( B ) the tasks execution in one direction, ensuring that task task k can only execute if begins execution, it finishes. Algorithm 4 generates the necessary constraints to do so. For each task, it obtains its next node and, if the next node n n is a task, corresponds to the derived predicate generated by Algorithm 2 to ensure that task n n has executed properly. For instance, for the tasks Create New Bicycle and Assign to Anchor Point we have the following condition and derivation rule:  X  createN ewBicycle ( b, t )  X  X  assignT oAnchorP oint ( b, t + 1).
 possibility that there will be more than one task that can be executed. For this reason, the algorithm generates this rule:  X  task ( p a , z, t )  X  X  nextT ask ( p a ,t +1) , meaning that if task has executed at t one of its next tasks must have executed at t +1. nextT ask is a derived predicate resulting from the execution of any of the next tasks. These derivation rules are created in Algorithm 5 and have the following form: nextT ask ( p a ,t )  X  task n ( p a ,t ) . The algorithm iterates over the nodes until the next task(s) are found. Guard conditions are not considered because they have already been translated by the other algorithms. Finally, if a task is followed by a final node, we need to generate rule: validState as it is the last task in the activity diagram: validState ( t )  X  There is a special case, however. If there is a decision node n and one of the The liveliness test of a class or an association will ensure that an instance where el is the name of the class or association: livelinessT estEl ()  X  el ( p, t )  X  validState ( t ) . Remember that validState is a derived predicate generated by the last task that executes in a transition. For instance, to test the liveliness of Bicycle , we would define the following derivation rule: livelinessT estBicycle ()  X  Bicycle ( b, t )  X  validstate ( t ).
 that is, if the necessary requirements for its execution are met. The test will have the following form, for task task i : applicabilityT ask ()  X  pre task ( y, t )  X  ticularly useful for those activity diagrams with decision nodes to ensure that all paths can be taken. The test will have the following form: executabilityT ask ()  X  task ( p a ,t ). Notice that it is equivalent to checking if the predicate task can be generated, as task represents precisely the successful execution of task .For instance, to check the executability of task Confirm Return , we would run the following test: execConf irmReturn ()  X  conf irmReturn ( b, t ) .
 Validation Tests. On the other hand, validation tests ensure that the model is aligned to the user requirements. In the general case, validation tests require the intervention from the user and thus cannot be generated automatically from the model. An interesting validation test in our example would be to check if a blacklisted user can rent a bicycle: blacklistU serRent ()  X  Blacklisted ( u )  X  BicycleRental ( b, u, i, t )  X  validState ( t ) . The validState predicate is needed to ensure that the BicycleRental is not deleted before the end of a transition. We have studied the feasibility of our approach by using an existing tool, SVTe, that is able to perform the tests described previously. This tool uses the CQC E method [ 16 ] which is aimed at building a consistent state of a database schema that satisfies a given goal, represented as a set of one or more literals. The method starts with an empty solution, and given the goal, the database schema, the constraints and the derivation rules, tries to obtain a set of base facts that satisfy the goal without violating any of the constraints. The CQC E method is a semidecision procedure for finite satisfiability. This means that it does not ter-minate in the presence of solutions with infinite elements. However, termination is assured if the model satisfies the conditions identified in [ 4 ]. Variable Instantiation Patterns (VIPs), which generate only the relevant facts that need to be added to the schema to satisfy the goal. If no instance that sat-isfies the database schema and the constraints is found, then the VIPs guarantee that the goal cannot be achieved with the given schema and constraints. the bicycle liveliness test (top), the executability test for task Confirm Return (middle) and the validation test (bottom). Notice that all the tests execute Several approaches to reasoning on artifact-centric BPM use data-centric Similarly, [ 6 ] represents artifacts using a set of variables, which are updated All these works represent artifact-centric business process models in lan-friendly representation of artifact-centric business processes. [ 17 ] studies the decidability of verification over GSM models by translating them into a DCDSs. However, the presented results are theoretical, as there is no tool that can actu-ally perform the reasoning. [ 11 ] presents a system to model and execute artifact systems. However, to our knowledge, the system is limited to simulating the behavior of the model given certain data and this is different to our work in this paper. [ 10 ] performs model checking over GSM models from a multi-agent perspective; however the bound placed on the number of objects may sometimes lead to unreliable results when this bound is exceeded.
 sidering the meaning of the tasks. These are annotated with preconditions and effects defined in logic, and use an ontology to define the underlying data. Time is not considered explicitly, which only allows for analysis of the current state of the system, whereas in our case we can analyze the system X  X  evolution. deal with only one diagram. For instance, [ 15 ] focuses on the class diagram, [ 5 ] handles state-machine diagrams, and [ 7 ] focuses on activity diagrams. As far as approaches examining various UML diagrams, [ 13 ] offers a systematic literature review but only four of the analyzed papers perform reasoning on more than one of the diagrams in our approach: they can handle class and state machine diagrams. [ 14 ] handles both the class diagram and the operation contracts, but it does not consider state transition nor activity diagrams. We have presented a way of validating and verifying artifact-centric business process models defined using the BAUML framework. This framework provides us with a set of models which can be defined and are understandable by the mod-elers. Checking the correctness of these models as early as possible is important to avoid the propagation of errors to the execution stage of the process. These errors can result from mistakes in the models themselves (e.g. contradictions) or errors in the sense that the models do not fulfill the business requirements. logic and encode the desirable properties as derived predicates. We can then use an existing tool to check if the properties are fulfilled. To the best of our knowledge, there is no other proposal that is able to check the correctness of artifact-centric BPMs with reliable results.
 and even not terminate for some tests, due to the temporal cost of the search for a solution and its potential infinity. Improving the efficiency of the tool and the translation of parallelism is left as further work.
