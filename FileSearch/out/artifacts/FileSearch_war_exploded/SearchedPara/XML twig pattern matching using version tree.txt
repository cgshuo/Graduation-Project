 1. Introduction
XML is emerging as a de facto standard for information exchange over the Internet and is a popular choice for data representation. Enormous interest exists in query processing over XML data that conforms to a tree-structured data model which represents a very useful subset of XPath and XQuery. In most XML query lan-guages (e.g., [2,3] ), the structures of XML documents are expressed by twig patterns and the values of XML base is a major concern of XML query processing, both in relational implementations of XML databases and in native XML databases.

Queries with path expressions have been a major focus on research of indexing and querying XML docu-ments. In the past few years, two main areas of research in processing queries to retrieve XML data have emerged, namely, approaches based on structural index and numbering schemes . The approach based on the structural index facilitates traversing through the hierarchy of XML documents by referencing structural tural indexes can reduce the search space for processing linear path and twig queries to some extent.
The second approach is based on a numbering scheme that encodes each element by its positional informa-tion within the hierarchy of the XML document that it belongs to. In the past few years, many algorithms [1,4,12,16] proposed in the literature are based on various labeling schemes. To answer a twig query, these algorithms only access the elements whose tags appear in the nodes of the query twig without traversing the original XML documents.

In this paper, we propose a new twig pattern matching algorithm TwigVersion, which comprises both struc-tural index and numbering schemes techniques. The key to the efficiency of TwigVersion is due to the fact that most XML documents have many repetitive twigs in structure, e.g., DBLP. We utilize the version-labeling ture called Version Tree . XML query using Version Tree can avoid redundancy of structure matching to a great extent.

Using Version Tree, all structure matching is performed on Version Tree merely, that is, access of any nodes from original XML data tree is unnecessary for structure matching in TwigVersion. However, for a ments on secondary storage (or from cache) is unavoidable unless indexes on values have been provided. For-tunately, selection predicates on values can always reduce the input size of the structure join operation to a the original XML data tree but on the Version Tree, which greatly improves the performance of TwigVersion since the size of Version Tree is usually much smaller than that of the original XML data tree.
The contribution of this paper can be summarized as follows:  X  We propose a novel twig pattern matching algorithm TwigVersion based on the version-labeling schema. Our algorithm guarantees that the input of the algorithm is optimal among all related holistic algorithms.
This improvement can be mainly attributed to the Version Tree technique we employed in our algorithm.  X  When the size of XML documents is huge, we show that the performance of TwigVersion is stable and far beyond previous twig pattern matching algorithms.  X  The experimental results on a range of real and synthetic data validate our analysis and show the superi-ority of TwigVersion over previous twig pattern matching algorithms. The experiments also show TwigVer-sion can answer most queries in an acceptable response time.

The rest of the paper is organized as follows. Related work is introduced in Section 2 . Section 3 provides a preliminary knowledge on XML query processing. The concepts about Version Tree are described in Section 4 . Section 5 briefly introduces the method of constructing Version Tree. Then, the algorithm TwigVersion is 2. Related work With the rapidly increasing popularity of XML for data representation, interest in data processing over
XML has grown, and therefore a series of structural index methods [5,6,10,11,22,23] were proposed. Most of the structural indexes are based on the idea of considering the XML document as a tree and partitioning the nodes into equivalent classes based on an equivalence relationship. Goldman et al. [5] proposed strong
DataGuide as summary structure of graph-structured data. The strong DataGuide of an XML document is a tree built by merging all the child nodes with the same tag. Nodes in the XML document that have the same label path are partitioned into one equivalence class. And, a strong DataGuide holds all the parent X  X hild edges in an XML tree. Therefore, parent X  X hild and ancestor X  X escendant XPath axes can be evaluated using strong DataGuides directly. Milo et al. [6] proposed 1-index to compute simulation and bi-simulation sets of graph to partition data nodes, which is factually equivalent to strong DataGuide on tree model. Kaushik et al.
A( k )-index, which partitions nodes by their incoming label path, the parameter k is the length limit of the incoming label path. Later, Kaushik et al [11] proposed a covering index family for XML branch queries, including F + B-index and F&amp;B-index etc. Using the forward and backward bisimilation, the index family can distinguish nodes not only by their incoming label path but also their outgoing label paths.
All these indexing methods can reduce the search space of query processing to some extent, however, to our knowledge, few efficient twig matching algorithms [17] have been proposed based on these structural indexes.
On the other hand, twig pattern queries over XML documents have been extensively studied recently. Most existing techniques rely on the region encoding method to capture the structural relationship between docu-ment elements, such as the techniques presented by Zhang et al. [20] , Al-Khalifa et al. [1,13 X 15] etc. Bruno pactly represent partial results, where no large intermediate results are created. More recently, Twig was proposed by Chen et al. The difference between Twig 2 ordered tree, where each tree node is a stack. In this way, Twig without redundant relationships checking.

Some methods based on other numbering schemes also exist, such as [9,18] . These methods decompose a twig pattern into several parent X  X hild path queries and then merge the results. Lu et al. [16] propose another holistic twig join algorithm TJFast, which encodes all data nodes of XML tree with extended Dewey ID.
Using automata to perform the transformation between Dewey ID and label path, TJFast can considerably reduce the size of index. And, the I/O cost of TJFast is also reduced by reading only elements whose tags appear in leaf nodes of query twig.
 Besides numbering schema, some methods are based on sub-sequence matching, such as ViST proposed by
Wang et al. [8] . More recently, Rao et al. [7] proposed PRIX, which transforms XML documents and twig tree. And, sequences with common prefixes have correspondingly common paths in the virtual trie tree, which captures the repetitive structure of XML documents to some extent. By performing subsequence matching and based methods transform a twig query to a single path query (subsequence matching). Thus the performance of these methods is inevitably affected by the length of sequences.

Two common problems exist in these methods: (1) with the increase of XML document size, the input size of the algorithms grows dramatically, thereby twig pattern matching and disk access become more time con-suming; (2) there are many repetitive structures in XML documents, which cause a mass of redundant com-putation of structure matching in these algorithms. Therefore, TwigVersion proposed in this paper focuses on minimizing the scale of input set of query processing and avoiding redundant structural matching. As a result, TwigVersion can answer XML queries efficiently by carrying out all structural matching on concise Version
Trees of XML documents. 3. Preliminaries
In this section, we discuss the XML data model and briefly review XML twig pattern matching and the state-of-the-art labeling and indexing methods. 3.1. Data model and twig pattern
XML data is commonly modeled as a tree structure, where nodes in the tree represent elements, attributes, text in documents, and edges represent element X  X ubelement, element X  X ttribute, and element X  X ext pairs in doc-uments. Queries using XML query languages make use of twig patterns to match relevant portions of data in an XML data source. The twig pattern node may be an element tag, an attribute of an element, or a text value; and the twig pattern edges of the query are either parent X  X hild or ancestor X  X escendant edges. At each node in cussing what is permitted in this predicate, we consider only element nodes in the XML data tree.
Given a query twig pattern Q and an XML database D , a match of Q in D is identified by a mapping from base elements (the images under the mapping), and (ii) the structural (parent X  X hild and ancestor X  X escendant) relationships between query nodes are satisfied by corresponding database elements.

In this paper, we find all matches of Q in D implicitly, only the nodes in Version Tree whose tags appear in the leaf nodes. 3.2. Dewey ID labeling scheme Tatarinov et al. [19] proposed the Dewey ID labeling scheme to represent the position of an element in an
XML document. In Dewey ID, each element is represented by a vector: (i) the root is labeled by an empty string; (ii) for a non-root element u , label ( u )= label ( s ). x , where u is the x th child of s .
The Dewey ID has the following unique property: the ancestors of an element can be derived from its label and so on. This property enables the pattern matching of the XML path to be directly reduced to string matching if the path of u is known. For example, if we know that a node d has Dewey ID  X  X 1.2.3.4 X  X  and to deduce that the node d and the node f have a common grandparent b whose Dewey ID is  X  X 1.2 X  X . In the current version-labeling schema we have developed, the Dewey ID is suitable for structure matching.
In our algorithm, we use Dewey ID to expedite the twig pattern matching on Version Tree since it has the same structure as our version numbers, which makes bottom X  X p structure matching easily. 3.3. Index trees
In the recent past, many index methods on semi-structure data have been proposed, such as Dataguides, 1-index, A( k )-index, F&amp;B-index.

Dataguides, 1-index and A( k )-index partition nodes according to their root-to-node label path entirely or partially. A common problem with these methods is that the index on nodes is mostly single-path oriented. On the other hand, F&amp;B-index collects structure information forward and backward based on bi-similarity defined in [11] , which makes the information on the F&amp;B-index tree nodes very rich. However, the size of the F&amp;B-index tree is usually too big.
 Fig. 2 shows a sample XML data tree, its strong dataguide (1-index), its A(1)-index, its F + B-index and its because all those nodes cannot be distinguished by their incoming paths, which are  X  X  X /D X  X . However, B4 and  X  X  X [E] X  X , can distinguish them forwardly.

Comparing all these index methods, we can draw the conclusion that Dataguides has the most concise structure and F&amp;B-index has the most complicated structure. Among the four indexing methods, the F&amp;B-the A( k )-index and F + B-index, information carried by the index nodes is limited compared to the nodes of be distinguished using F + B-index.

In fact, Dataguides (1-index), A( k )-index and F&amp;B-index are indeed members of the covering index scheme structure (version information not counted), and our Version Tree (defined in Section 4.2 ) is an annotated strong DataGuide of an XML data tree. Based on the advantages of Dataguide and F&amp;B-index, the higher performance of TwigVersion can be achieved by performing structure matching on the most concise strong
Dataguide with the most complete structure information from the F&amp;B-index tree. 4. Version labeling
It is true that most XML documents have many repetitive structures in their tree model. If these repetitive structures can be identified, a large amount of unnecessary repetitive structure matching can be avoided. In this section, we aim to establish a version-labeling scheme for TwigVersion algorithm. 4.1. Version-Labeled Tree
As we mentioned in Section 3.3 , Our Version-Labeled Tree is the same as the F&amp;B-index tree in structure (without version information). In this paper, we term twigs in the original data tree whose root nodes are bi-similar [11] to each other as repetition twigs .

For example, as depicted in Fig. 3 , for the four twigs root at h book i nodes, twig (b) and twig (c) are T are matching twigs of the query.

Before defining the concept Version-Labeled Tree , we first introduce the definition of minimum repetition twig .
 twig of F if and only if: (1) All child twigs of Root(T) are minimum repetition twigs. (2) For all C T 2 Children(Root(T)) , a child C 2 Children(Root(T)) and C 5 C
Definition 4.2. A Version-Labeled Tree VLT of an XML data tree D is the minimum repetition twig (tree) of the equivalence class [ D ], and each node of VLT is assigned a unique version number according to the following version-labeling scheme: (a) The version number of the root node of VLT i s  X  X 0 X  X .
Although the structures of the Version-Labeled Tree and the F&amp;B-index tree are the same, the information carried by them is different. For example, given two nodes from Version-Labeled Tree, we can point out the traverse. 4.2. Version Tree proposed a more concise data structure Version Tree to carry the structure information of the original XML data tree.
 Definition 4.3. A Version Tree VT of an XML source S is a tree where every label path (from root to node) of all elements in S that have the same label path p are stored in one and the same node of VT that has the same label path p .
  X  X  X ooks/book/author X  X ,  X  X  X ooks/book/author/fname X  X ,  X  X  X ooks/book/author/mname X  X ,  X  X  X ooks/book/author/ lname X  X ,  X  X  X ooks/book/title X  X  and  X  X  X ooks/book/year X  X . Correspondingly, there are eight nodes in its Version
Tree showed in Fig. 5 . We note that there are some numbers under each node, such as [0.1,0.2,0.3]. We term these numbers versions information (a set that contains versions) of nodes. For each node in Version Tree, number series divided by commas are different version numbers, and these numbers differentiate the elements in XML document that are not repetitive (the elements have the same label path).

The properties of Version-Labeled Tree can be summarized as follows: (a) For an arbitrary twig, the version number of the root node of the twig is a prefix of all the nodes in the (b) For an arbitrary node, we can infer versions of all ancestors of the node.
 (c) Each node in Version Tree can be distinguished by its label path. There is a straightforward one-to-one
A key to this labeling scheme is that we can identify whether a query twig has matching twigs in the XML document by bottom X  X p Version Deduction and Version Set Intersection on the query pattern. If matching twigs are present in the original XML tree, the intersection result will not be empty, and the query result is obtained from the XML database easily through filtrating versions. On the other hand, if the result of inter-section is empty, we can draw the conclusion that the result of the query is also empty.

For example, in a query  X  X //book[year]/author X  X  in the XML data tree in Fig. 3 , we can find a matching twig in the corresponding Version Tree shown in Fig. 5 . According to the property of Version Tree, we know that is regarded as the answer to the query. 5. Version Tree construction In this section, we present the construction method of Version Tree. We also briefly discuss how Version
Tree can be stored on secondary storage. 5.1. Creating Version Tree The construction of Version Tree can be divided into two equivalence class partition phases: 5.2. Building Version-Labeled Tree
We traverse the XML data tree to discover all repetition twigs and assign a series of version numbers to each same version number, and this procedure is recursively applied to their descendents. Finally, all repetition twigs in their equivalence class of repetition are represented by just one twig (the minimum repetition twig) in the constructed Version-Labeled Tree. 5.2.1. Constructing Version Tree
We compress the Version-Labeled Tree to Version Tree. In this phase, nodes of the Version Labeled tree nodes in each equivalence class, versions on these nodes are merged into one and the same node of the Version
Tree. 5.3. Storing Version Tree on disk In our method, each node in the XML data tree has a unique version, thus the number of versions in the Version Tree is, in the worst case, the same as the number of nodes in the data tree. And each node of Version original data tree. Some statistical data on the size of the Version Trees of different XML documents is shown in Table 2 (Section 7 ).

Although the Version Tree of an XML document is usually far smaller than the original data tree, it is expensive and unnecessary to store the whole Version Tree in the memory for large scale XML document.
Compared to existing index methods on XML data, Version Tree has a unique property that we can deduce nodes whose tags appear in the leaf nodes of the query twig. Thus, we can cluster nodes of Version Tree by their tags naturally, and then read and cache them to the memory from disk while querying. Furthermore, for a huge XML data source, B+ Tree or a similar data structure can be considered for our Version Tree. 6. Twig pattern matching
To answer a query on an XML document, TwigVersion performs structure matching on the Version Tree of the document. TwigVersion filters out version information that satisfies the query from the Version Tree, and retrieves the answer via version information from the database. 6.1. TwigVersion algorithm
During the process of twig pattern matching, all Version Tree nodes have been clustered by their tags, and each node has a unique Dewey ID and its label path string. In our bottom X  X p algorithm TwigVersion, the version
There are three fields in the version information structure of Version Tree node: dewey , Dewey ID of the node; path , label path string of the node; versions , a set containing version numbers of the node. When the results can be easily filtered out from target element cluster.

Algorithm. TwigVersion ( twig )// twig is the root node of the query twig 01 if twig.children not empty{ 02 foreach child in twig.children 03 operands.add (TwigVersion ( child )); 04 infoSet VersionIntersection ( operands ); 05 else{ // twig is a leaf node in the query twig 06 read all nodes that satify node.tag equal to twig.tag from Version Tree; 07 add all info ( node.dewey , node.path , node.versions )to infoSet ; 08 foreach info in infoSet 09 result. add (InfoProcessing ( twig , info )); 10 return result ;
In fact, for an arbitrary query, TwigVersion finds out all matching twigs of the query twig in Version Tree
TwigVersion on each child, and all information from these children is intersected to generate information of directly. In lines 08 X 10, all info structures on twig are processed further by InfoProcessing.
Function VersionIntersection ( operands ) c.dewey = a.dewey = b.dewey AND c.path = a.path = b.path AND VerMatch ( c.dewey , c.versions )=
VerMatch ( a.dewey , a.versions ) \ VerMatch ( b.dewey , b.versions )}; / * VerMatch ( dewey , versionSet ) return such prefixes of all versions in versionSet that each prefix has as many  X  X   X   X  X  as dewey , e.g. VerMatch (0.1.1,{0.1.2.3.4,0.1.1.1}) = {0.1.2,0.1.1}
Note that in VersionIntersection, only versions on the nodes that are on the stem (from the root node to the target node) of the query twig should be reserved to guarantee that version numbers returned by TwigVersion are version numbers of the target elements.

Function InfoProcessing ( twig , info ) 01 if twig is the target node of the query 02 info.versions VerMatch(info.dewey, info.versions); 03 if twig.parent is null 04 return info ; 05 find all prefixs of twig.path that match the path string of twig.parent ; 06 foreach path in prefixs{ 07 calculate the corresponding dewey according to path ; 08 result.add ( newinfo ( dewey , path , info.versions )); 09 return result;
In the InfoProcessing function, TwigVersion deduces info of twig  X  X  parent from info of twig .If twig is the target node of the query (which can be affirmed by parsing phase of the query), the versions in info are be returned directly. In lines 05 X 09, TwigVersion finds out all possible virtual parent nodes of twig by path matching, and then deduces their info .
 For example: Consider queries Q 1, Q 2 and version information of all nodes in the Version Tree (refer to Fig. 5 )in Fig. 6 . Nodes contained in rounded rectangles are target nodes of queries.

For Q 1, the deduced info of the parent of fname and lname are [0.1.1: books/book/author: {0.1.1.1,
For Q 2, TwigVersion deduces the info of book from the info of mname , and gets the info [0.1: book: {0.1.X.X}]. After intersecting with the info deduced from year [0.1: book: {0.3.3}], TwigVersion produces h year i elements in XML document satisfying Q 2. 6.2. Queries with selection predicates on values
For queries with selection predicates on values, it is obvious that Version Tree does not have content infor-mation of XML data nodes. Thus, related data nodes need to be scanned, which is unavoidable for methods that don X  X  have indexes on the content of data nodes.

To extend TwigVersion for handling queries with selection predicates on values, there are two available methods can be applied to TwigVersion: (1) TwigVersion performs structure matching to get all matching twigs of XML query and then checks the predicates; (2) Encoding each XML data node an unique position index with same structure of version number, and then TwigVersion can deduce both the unique position index and the version number of each target node synchronously, i.e. performs predicates checking at the same time that structure matching.

In this paper, we chose the second method to extend TwigVersion algorithm. We extended the data structure info with an additional field idmark , which can be omitted in the case of pure structure matching (without selection predicates on values). And, we chose Dewey ID as the unique position index of data node.

With the new info structure, we can filter out those unqualified content-oriented twigs by transferring this idmark field bottom X  X p along with the versions field. For an arbitrary query with content constraints, Twig-
Version first scans the data node clusters corresponding to the leaf nodes of the query twig that are content ters can be cached to improve performance). Subsequently, for each data node DN , TwigVersion generates info with corresponding Version Tree nodes VN according to the following additional rules, where DN is an original data node satisfying content predicates and VN is a Version Tree node: (1) The label path of DN is the same as the label path of VN (i.e. VN is the target set of DN ). (2) The unique identifier (Dewey ID) of DN is assigned to the idmark field of info . (3) The versions field of info only reserves version numbers from DN .

For other leaf nodes without content predicates, info of these nodes needs no change except an empty idmark field.

Based on the new info structure, the version intersection algorithm requires a slight modification. Three cases on new intersection algorithm between two operands can be identified: (1) Both info structures involved in intersection have an empty idmark field. In this case, the intersection (2) Both info structures involved in intersection have non-empty idmark field. In this case, besides the ori-(3) One info has an empty idmark field and the other has a non-empty idmark field. In this case, we execute
As the auxiliary idmark field is transferred and matched along with bottom X  X p info collection, we can elim-inate nodes with unqualified idmark or version at the same time. Thus, the info we get at the root node of the query twig by TwigVersion includes not only versions info of target nodes but also idmarks of root nodes of matching twigs which is different from using the original algorithm. From these we can obtain both version and idmark information of target nodes easily.

For example, Fig. 7 depicts a sample data tree about books. The numbers in the  X  X  X  ] X  X  below each node are in the format [idmark:version] . For a query  X  X /book[author =  X  X ane Austen X  X /title X  X , TwigVersion first scans author data cluster (if they are not in cache, read them from disk) to find out all author elements that have a content value  X  X ane Austen X . In this step, we get two author elements: author [0.2.1:0.1.1] and author
Processing phase, the idmark and version info of the virtual book node deduced from author are [0.2:0.1] title [0.3.2:0.2.2]  X  X  X ride and Prejudice X  X  are returned.
 Since the idmark data is only added to the data nodes, both structure and size of Version Tree of arbitrary
XML documents will not change (i.e. Version Tree nodes have no idmark field). Access of elements relevant to values of queries can always reduce the input size of structure join operations to a great extent, which will reduce the cost of structure matching.
 6.3. Analysis of TwigVersion In this section, we first show the correctness of TwigVersion and then analyze its complexity.
The correctness of a single path query is straightforward. We know that for a branch node B with single path branches only, the deduced info returned from these branches by TwigVesion is correct. That means the input of VersionIntersection on node B is complete . And we know that info leached in VersionIntersection cannot compose a complete matching twig at node B with info in other operands. So the deletion is safe . Thus,
TwigVersion can return a correct answer for branch nodes that only have single path branches. Similarly, it is easy to draw a further conclusion that for any query twig with branch nodes, TwigVersion can return all cor-rect answers.

Theorem 6.1. Given an XML data source D, the Version Tree V of D and a twig query Q, the worst case space from nodes of V whose tags appear in the leaf nodes of Q to the root node of the Version Tree. Proof ( sketch ). TwigVersion has two main processing modules, one is InfoProcessing, and the other is VersionIntersection.

Path matching is the core function of InfoProcessing, and each matching step corresponds to a unique edge function VersionIntersection, because all info structures need to be processed no more than once, versions in these info structures will not be processed more than once, too. The fact is that no matter how many branches a branch node has, the number of versions in the info set returned by VersionIntersection is not greater than the minimum of the numbers of versions in each operand info set of intersection. In the worst case, for a branch node, at most d * t versions for intersection exist. Thus, the worst space complexity of TwigVersion is O( d * t ). And it is not difficult to draw the conclusion that the worst time complexity of TwigVersion is O( d * t + h * j E j ). h On the one hand, the advantage of TwigVersion depends on the rate of t/L , which we term Compression
Ratio on Version (CRV), where L is the number of nodes in the original XML tree whose tags appear in the leaf nodes of Q . On the other hand, the advantage of TwigVersion depends on the rate of j Version
Tree j / j XML data tree j which is called Compression Ratio on Structure (CRS). The statistical data of CRV and CRS on different XML documents are listed in experimental section (Section 7 ).
 Furthermore, the time complexity of TwigVersion can be expressed in an equivalent form: and path matching. In the equivalent form O( j Q j * j D j * ( m time of TwigVersion on an XML document mainly depends on j Q j , j D j , CRV and CRS.

Finally, the input optimality of TwigVersion will be presented here. The input of TwigVersion is mainly from Version Trees of XML documents, and all inner nodes need not be read except target nodes. For an arbi-tree. And as we know, without indexes on values no algorithms can omit the access and validation cost of leaf nodes with selection predicates on values as well as target nodes. Thus, we can say that the input of TwigVer-sion is optimal in all existing holistic twig pattern algorithms. 7. Experimental results
In this section we will present experimental results. We first show some statistical data of original XML documents and their Version Trees. Secondly, we present some performance data of TwigVersion. Subse-quently, we compare TwigVersion with TJFast on CPU time (i.e. I/O cost is not counted) because these two algorithms are executed mainly in main memory. The implementation of TJFast was obtained from usually regarded as a disk-based algorithm, both I/O and CPU cost have been included in our experiment. In succession, we compare TwigVersion with PRIX [7] on the scale of index structure because the Virtual Trie in
PRIX is similar to the Version Tree in TwigVersion to some extent. Subsequently, we compare the perfor-formance data on queries with selection predicates between TwigVersion and three other algorithms. 7.1. Experiment setup
All the experiments have been performed on a system with Celeron 2.1 GHz processor and 512 M main memory running on windows 2000. We used real-world datasets (TreeBank and DBLP [21] ) and synthetic dataset (XMark) for our experiments. We chose these three datasets because they have different characteris-tics. DBLP is a shallow and wide document with many repetitive structures, TreeBank has a very deeply recur-sive and complex structure, and the structural complexity of XMark is between the structural complexity of TreeBank and DBLP.
 Table 1 illustrates some statistical data from XMark (56.2 M), DBLP, TreeBank and their Version Trees.
Note that CRV = # of versions/ # of elements, and CRS = # of Version Tree nodes/ # of elements. 7.2. Performance analysis
As we know, DBLP has many repetitive structures, the CRV of DBLP is 0.081% and CRS is 0.0038%. In other words the Version Tree of DBLP is so tiny that the query on the Version Tree of DBLP will be tremen-dously faster than tree travel queries on DBLP. The reason for not providing experiment data of query per-formance on DBLP is that most execution time of TwigVersion on DBLP is less than 1 ms.

In all our experiments, the I/O cost of target nodes (query answer) is not considered, because it is applica-tion dependent. 7.2.1. Performance of TwigVersion
In this section, we show the performance curve of TwigVersion and verify the conclusion we made in Sec-tion 5.3 . In order to verify the performance of TwigVersion with the increase of XML documents size, we exe-cute the same query on XMark at different sizes (2 M X 113 M). Table 2 shows the statistical data of the XMark samplings.
 son that we chose it is because the query has both ancestor X  X escendant and parent X  X hild relations, and has ginal XMark, the node h to i and the node h from i have moderate occurrences in the original XMark. So we can line chart of the execution time of TwigVersion on XMark documents of different sizes.

It can be observed in Fig. 8 that approximate linear relation exists between execution time and size of XML document. From the data in Table 2 , we find out that the maximal depth of Version Tree in all XMark sam-plings on which we experimented is equal. Table 2 also shows that with the increase in size of documents, the bers on the Y -axis are the total number of versions on the relevant Version Tree nodes. We can see that the two line charts are wonderfully similar to each other.
 7.2.2. TwigVersion vs. TJFast
Since both TwigVersion and TJFast are executed mainly in main memory, we omit the I/O cost of the two algorithms, i.e., the comparison between these two is based on CPU time.

TreeBank as illustrated in Table 1 has poor CRV (93.41%) and CRS (13.896%). Thus TwigVersion cannot benefit much from the Version Tree of TreeBank. Queries on TreeBank for our experiment are listed in Table 3 .

Fig. 10 shows the comparison of execution time between TwigVersion and TJFast on TreeBank. I/O cost of the two algorithms is not included. As depicted in Table 1 , the number of versions for TreeBank is similar to the number of elements, but our method is nonetheless faster than TJFast. This advantage is due to the CRS of the Version Tree of TreeBank. As the Version Tree of TreeBank is far smaller than its original data tree in matching in InfoProcessing in total execution time of TwigVersion is much less than that of TJFast.
A comparison between TwigVersion and TJFast algorithm on XMark is shown in Fig. 11 . The experiment uses the same samplings and the same query as in the previous experiment. As depicted in Fig. 11 , we can conclude that TwigVersion is more efficient than TJFast algorithm. The reason that TwigVersion outperforms
TJFast is dependent on two aspects: (1) the Version Tree of the XML document is usually far smaller than the original XML data tree in structure, which means path matching for elements with the same label path in the original XML data tree is executed only once in TwigVersion; (2) the number of versions in the Version Tree is far smaller than the number of elements, which decreases structure join operations to a great extent. There-fore, many redundant structural matching operations are avoided in TwigVersion when compared to TJFast. 7.2.3. TwigVersion vs. F&amp;B-index
We will compare TwigVersion with F&amp;B-index on TreeBank and XMark in this section. All the queries and sampling documents are the same as those used in the previous experiments.

Usually, F&amp;B-index is too big for efficient query processing. For an XML document, the number of nodes in an F&amp;B-index tree of the document is the same as the number of versions in the Version Tree of the doc-ument, which makes both I/O cost and structure matching for query processing very time consuming. Due to expensive; while the performance of TwigVersion is considerably good.
 As depicted in Fig. 13 , the execution time of F&amp;B-index increases sharply with the increase in size of
XMark. On the contrary, TwigVersion shows a gentle upward trend. Even for a 113 M XMark, such a com-plex query  X  X  //item[//description/text]/mailbox/mail[from]/to X  X  needs only 659 ms on cold cache (121 ms for warm cache), while for F&amp;B-index the same query needs 954 ms even on warm cache (12746 ms for cold cache). Compared to F&amp;B-index, TwigVersion can answer most queries on XML documents within a response time that is acceptable to users. 7.2.4. TwigVersion VS. PRIX PRIX transforms XML documents into Pru  X  fer sequences. Subsequently, all the sequences produced by PRIX are mapped to a virtual trie tree. In a sense, the virtual trie of PRIX is similar to our Version Tree. Therefore, the comparison between TwigVersion and PRIX is based on the scale of index structure. in PRIX, not only on the shallow wide DBLP and the deeply recursive TreeBank, but also on the synthetic XMark.

For DBLP, 328858 sequences are present, i.e., 328858 root twigs in our method (the parent of the root node of the root twig is the document root). Since DBLP has many repetitive root twigs, PRIX captures most of them, and PRIX can compress these 328858 sequences into the Virtual Trie as efficiently as the Version tual Trie in structure.

In XMark, with the increase in document size the benefit of PRIX drops sharply as the number of nodes in the Virtual Trie in PRIX of the three different XMark documents are almost half the number of elements in the original documents. On the contrary, the Version Tree presents better performance along with the increase of document size.

A minor difference between twigs such as sequence variations between sibling nodes will change repetition twigs to completely different Pru  X  fer sequences, which limits the compression ability of PRIX. Furthermore, from the definition of Pru  X  fer Sequence we know that leaf nodes of both query twig and data tree cannot be processed directly in PRIX. The method utilized by PRIX is to add dummy children nodes to these leaf nodes (Extended Pru  X  fer Sequence), which causes the Virtual Trie to become much bigger.
In fact, PRIX transforms a twig query on an XML data tree to a single path query on its Virtual Trie. Thus, documents with few root twigs such as XMark (six sequences with an average length 27772 for 113 M
XMark), sequences used by PRIX are too long to be processed efficiently. 7.2.5. TwigVersion vs. Twig 2 Stack
As an innovation of TwigStack, Twig 2 Stack utilizes a hierarchical stack encoding scheme to represent the twig results compactly. Like TwigVersion, Twig 2 Stack is also a bottom X  X p twig matching algorithm. We com-pared the performance of TwigVersion and Twig 2 Stack in terms of both cold cache and warm cache.
Like TwigStack, Twig 2 Stack is also based on region encoding and linked stack techniques (linked tree stack and I/O cost of Twig 2 Stack are much larger than those of TwigVersion. On the other hand, benefit from its hierarchical stack encoding scheme, Twig 2 Stack can avoid repetitive effort on checking ancestor X  X escendant relation, however, it is not helpful for reducing redundant path matching. For example, given a query  X  X // inproceeding[author]/title X  X , there are 212,273  X  X //inproceeding/author X  X  paths in DBLP (127 M). TwigVersion algorithm matches the path  X  X //inproceeding/author X  X  only once, whereas Twig path for 212,273 times. As depicted in Fig. 14 , the cost of structure matching using Twig with the increase of XMark size whether the I/O cost is included or not.

All these experiments reveal that TwigVersion can process most XML query very efficiently no matter I/O input set of structure matching of TwigVersion is merely from Version Tree, and only the Version Tree node clusters whose tags appear in the leaf nodes of the query twig need to be scanned; (2) the Version Tree of an
XML document is usually far smaller than the original data tree or index structures of other methods. As we can see in the experiments, the execution time on a 120 MB of Xmark is less than 1 s (all I/O cost is not counted). 7.2.6. Performance on queries with selection predicates on values
To validate the performance of TwigVersion on queries with selection predicates, we compared TwigVer-sion with other three algorithms. On a 10 M XMark document, we have the following experimental result.
The query we used in the experiment is  X  X //item[description//text]/mailbox[mail[from=Libero Rive mail-to:Rive@hitachi.com]/to ] X  X . Due to the sub-sequence matching characteristic of PRIX, the processing of con-tent predicates on it can only be handled in the post-processing phase, which makes it difficult to compare
PRIX to the other four methods. Thus, we did not provide experiment data on PRIX about queries with selec-tion predicates on values.

As depicted in the Fig. 15 , the performance of TwigVersion outperforms the other three algorithms both on warm cache or cold cache. In addition, we can conclude from the experiment that TwigVersion is very effective for highly selective queries whether these queries are structure oriented or value oriented. 8. Conclusions XML twig pattern matching is a core issue for XML query processing. In this paper, we proposed the Twig-
Version algorithm as an efficient method to address this problem using a novel version-labeling scheme. For a query, TwigVersion reads nodes in Version Tree whose tags appear in the leaf nodes of the query twig and uses a bottom X  X p Version Deduction and Version Set Intersection method to generate version filter for the final answer. All structure matching is executed on Version Tree, which reduces the input cost of the algorithm and the structure matching process to a great extent. The benefit acquired from TwigVersion mainly depends on the CRV and CRS of the Version Tree. Experimental results prove that our method is much more efficient than existing twig pattern matching algorithms and can answer most of queries in a user acceptable response time.
 Acknowledgement We would like to thank the anonymous reviewers of DKE for their constructive and valuable comments.
Furthermore, we would like to thank Jiaheng Lu for his patience in providing us several versions of the imple-mentation of TJFast; and we specially thank Wei Jin and YuHong Li for their great help with editing the paper.

References
