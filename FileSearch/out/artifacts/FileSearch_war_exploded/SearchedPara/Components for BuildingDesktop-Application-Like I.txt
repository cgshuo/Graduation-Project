 Hypertext-style interface in Internet applications has been around since the in-ception of the World Wide Web (Web). What makes hypertext a reality is a standard Web language called Hypertext Markup Language (HTML). HTML brought the so-called non-linear navigation paradigm from science fiction sto-ries and research laboratories into our daily lives.
 ative Web developers, enabling them to create websites of all sorts. Over the years, HTML has withstood many challenges and evolved with new features as the web technology advances at an astonishing pace. Today, HTML is still the predominant technology for website designs. These websites provide mostly browseable-only contents with form interaction using Common Gateway Inter-face (CGI).
 database system as the backend data storage and retrieval system in conjunc-tion with a client Web browser, and a Web server. The majority of these types of Internet applications are most used by the e-commerce and entertainment sec-tors. However, most of these more sophisticated interactive applications still pro-vide only simple interactions such as product navigation, shopping cart storage, and form processing. More complex interaction is achieved by using Javascripts embedded in HTML or plug-ins.
 are gaining momentum, the click-and-link interface provided by HTML-based technology is too limited for building highly interactive applications that might someday utilize these emerging technologies. The original intent of HTML was for building hyperlink-style applications with simple interactions and not for highly interactive applications. This paper discusses the techniques used for cre-ating highly-interactive graphical user interface (GUI) components for building desktop-application-like Web applications.
 grate well together. Using these components we have built a highly interactive image retrieval Web application as a proof of concept. Our image application is easy to use because it has desktop-application-like GUI features such as folder navigation, icon representation of images, image zoom-in capability, and drag-and-drop functionalities.
 ground information and related work. Section 3 describes the component archi-tecture and application design. Section 4 discusses the usability of our compo-nents and Section 5 concludes the paper. Displaying and manipulating high-resolution images across the Internet (via a web browser) becomes a daunting challenge due to the massive amounts of data that need to be transferred and the limitation of hypertext-style interface. Hence, providing a desktop-application-like interface for image manipulation and dis-playing is the primary challenge for web-based application designers. tems capable of presenting an on-demand imagery delivery (zoom and pan) ser-vice over the Internet such as ER Mapper[1], Express Server[2], FlashPix[3], GIS Viewer[4], GridPix[5], TilePic[6], Zoomifyer[7], and ZoomView[8]. All these im-age formats and systems use variants of tiled-based, multi-resolution-tier method and pre-processed static images. However, all these systems provide view-only functionality and no highly-interactive, desktop-GUI-like environment. On-demand large image delivery with user specified region of interest[9], progressive on-demand with optimal tiling and compression[10], client-caching[10, 11], and server prefetching[11] have also been studied.
 highly-interactive components for building a Web-based image application using Flash component technology. These components can address the shortcomings of previous works. Second, our components can achieve a desktop-application-like interface in the web browser. Third, our components can be extended to provide additional real-time interaction with images stored on the server. Lastly, our component can be used by web developers (non-programmers) easily.
 which require the support of server-side components that we also have devel-oped. Client component objectives are: desktop-application-like GUI, drag-and-drop capabilities, virtual desktop, on-demand image zoom-in, client side im-age caching, usable by non-programmers and deployable on multiple platforms. Server component objectives are: remote folder/icon management, on-demand image cropping, on-demand image resize and compression, server image caching, and deployable on multiple platforms. We introduced four client-side GUI components that are commonly found in windows-based operating systems X  GUI environment: Folder , Icon , ImagePane , and ProcessingStatus components. web-application with a desktop-like environment called Web Desktop Environ-ment (WDE). The system architecture, user interface, and server-cache manage-ment will be discussed in this section. 3.1 System Architecture Our client components require the support of server-side components as shown in Figure 1. The client requests image, files and directories on demand; the server performs image processing, directory and file lookup requests sent from the client; the network is used to transfer the images and date between the server and client.
 Actionscript 2.0. The components are packaged into a Macromedia Extension Package (MXP file) for distribution. Figure 2 illustrates what the web developers will see under their Flash environment after the MXP file is installed. icon, as shown in Figure 2, into a Flash project and change some parameter settings with no programming involved. Once the Flash project is compiled and published, it becomes a Macromedia Flash File (SWF file) that can be linked from an HTML file. See Figure 3 and Figure 9 for screenshots of deployed com-ponents in action.
 1.4.2 SDK, Tomcat 5.0.16, Open AMF 1.0CR5, JMagick and ImageMagick 5.5.6. It is also deployable on OS X and Windows. Open AMF is a free open-source al-ternative to Macromedias Java Flash Remoting Gateway that implements Flash remoting protocol Actionscript Message Format (AMF). The communication between the Flash Player and the OpenAMF is request-driven which is similar to Simple Object Access Protocol (SOAP). ImageMagick is a robust collection of tools and libraries for image manipulation in various formats. The Image Bean is responsible for making ImageMagick library calls through Java API provided by JMagick. 3.2 The User Interface Windows-based GUI design was chosen for our prototype image application due to its universality and ease of use. Figure 3 is a screenshot of our Web Desktop Environment (WDE) taken directly from Mozilla Firefox browser. WDE was created using Folder, Icon, ImagePane and ProcessingStatus components that we have developed. WDE behaves like a window manager that is similar to GUI in Windows, Mac, and Linux operating systems. It handles graphical display elements (such as folder and icons), folder open and close actions, drag-and-drop of icon actions, and execution of applications.
 the remote server. The mapping between client folders to server directories and client icons to server files are handled by the Resource Mapper module. Double click on a folder triggers dynamic retrieval of folder content from the remote server as illustrated in the two opened windows in Figure 3. Drag-and-drop of an icon between folders triggers file organization updates on the server. Drag-and-drop of an icon onto a program icon causes the application represented by the program icon to be executed.
 ImageViewer icon, the action will trigger ImageViewer (based on ImagePane component) to be dynamically downloaded from the server and executed with SlideScan.jpg (a 6.85 MB JPEG file, resolution: 3344x3344 pixels) as its input. Figure 9 shows six screenshots that illustrate zoom-in interactions between the user client component (ImageViewer), and server component. The ImageViewer frame size in the browser was set to 500x500 (pixels).
 can.jpg icon onto the ImageViewer. First, the ImagePane component is dynam-ically downloaded from the application server (web server) to the web browser and executed by the Flash Player. The processing status will appear first while the following series of ImagePane component initialization steps are being per-formed: ImagePane. The left hand side of the image is the actual tissue slide scan image (about 50KB). The right hand side is a thumbnail panel for quick navigation. interest (ROI), the user has to left-mouse-click-and-drag to create a white rect-angular mask as shown in Figure 9(c). As soon as the left-mouse-button is re-leased, a request is sent to the server with following parameters: image name, ImagePane frame size, coordinates of the ROI. A processing status will appear and thumbnail panel updates as shown in Figure 9(d).
 of the ROI parameters from the client: trieved from the web server by the Process Responder. Figure 9(f) illustrates the screenshot after another zoom-in action is requested. 3.3 Server-Side Cache Management Image processing algorithms such as image cropping and resizing are time con-suming processes for large images (see Performance Evaluation section). How-ever, it is reasonable to assume that a particular ROI will be requested by the same or different users for more than once. Therefore, we developed an approx-imate caching algorithm that utilizes cached images to speed-up retrieval time based on the locality of ROI requests.
 pseudocode illustrates its major steps. This caching algorithm uses a hash-based indexing structure to ensure constant search time. It is important to mention that the minimum overlapping threshold was pre-specified at 80%. Using this caching algorithm, time consuming ROI imaging processing steps are eliminated after the initial retrieval. Server side cache is managed by using least recently used (LRU) image queue when the size of overall storage used for caching gets too large. In order to know how well our server components can perform, we conducted responsiveness and stress tests. We evaluated the server performance under four image sizes as listed in Table 1 and shown in Figure 5. The hardware used for the experiments is a Pentium 4 2.4GHz with 512MB RAM running Linux 2.4 Kernel and with 1GB of swap space. Unfortunately, we were unable to compare our system with others due to the fact that previous works only provide viewing only functionality on pre-processed static images, while ours is more about real-time interactivity on dynamic processing of images.
 on the server processing time. The image pane size is set to 500x500 pixels. ROI being used to conduct the experiment is a nNxN (pixel) square at a random location (x, y) within the target image. The details of how our server component processes the request are described in the previous section. The experiment is essentially a simulation of client requests on 10 different NxN ROI sizes from 100x100 to 1000x1000 at 100 increments. The average server processing time for 20 requests on each of the 10 ROI sizes is shown in Figure 6.
 within the target image. The random ROI size (width and height) is constrained within seven different ranges. The seven ranges are classified by the maximum ROIs width and height in respect to the target image X  X  width and height. Ranges are 1/32 (3.13%), 1/16 (6.25%), 1/8 (12.5%), 1/4 (25%), 1/3 (33.33%), 1/2 (50%), and 1/1 (100%) of the target images width and height. One hundred requests for each of the seven ranges are performed. The average processing time for each range on four images is shown in Figure 7.
 the server processing time. In this experiment a fixed size ROI (400x400) at a random location (x, y) within the target image was used. Figure 8 shows the effect of up to fourteen concurrent requests on the average processing time for all four images. One of our primary objectives is to minimize the resources needed and reduce the response time of our components. Intelligent image data delivery ensures that only the ROI portion of an image that fits within the defined display area is delivered. In this case, ROI is extracted from the original image using Im-ageMagick crop library routine, followed by a resize routine to ensure that ROI fits within ImagePane frame size (500x500), then a 75% JPEG compression level further reduced the image size. This typically reduces the ROI image to less then 50KB without any detectable image detail loss on the screen and yet it is small in size for delivery over the Internet.
 delivered twice. Desired image can be quickly retrieved and displayed in the Im-agePane by left-mouse-click on the thumbnail images in the thumbnail panel. Thumbnail panel automatically rearrange the thumbnails as zoom in/out oper-ations are being performed. Server-side image caching ensures that the same or approximate ROI will never be processed twice.
 the processing time when the width and height of ROI are both less then 33% of the target image X  X  width and height (see Figure 7). Since ROI tends to be small comparing to the original image, therefore the longer processing time associated with larger ROI sizes will not be an issue.
 linear relationship between increases in the number of concurrent requests and increase in the average processing time. This trend holds for as long as the workload fits within the main memory. In the absence of network connectivity issue, a sharp increase in the average processing time indicates the utilization of virtual memory. At which point concurrent processing is then suspended due to the unpredictability of thrashing on the average processing time. The results indicate that 5-10 concurrent users on small/medium size images and only 1-2 concurrent users on large image is possible based on our server hardware setup. sound elements produces smaller, more self-contained files than Java applets, thus faster downloading and loading is achieved. As of September 2004, flash player has a market penetration of 98.2% (512.8 million users) [12]. Based on the performance statistic of this image delivery system, our goal of providing reusable imaging components for building an on-demand, real-time, highly-interactive, desktop-application-like, and web-based image application has been achieved. Leveraging the enormous install base of Flash Player in web browsers, our client component is developed as a Flash component. Hence, it can be independently deployed and distributed to the web application developers. Since the supporting server component is written in Java, it can also be deployed in many platforms.
 and in favor of an interface that has the look and feel of a desktop application. In summary, what set our image component apart from those mentioned in previous works are: (1) real-time on-demand interaction and (2) a desktop-application-like interface. Performance is inversely proportional to server-request load, hence issues related to server-side performance improvement are of our future interests. tend the client platform to include wireless mobile devices, (3) more features such as image filtering and transformation implemented, (4) user session and work-flow management, and (5) research other methods to improve the performance of the server components.

