 In a data stream environment, a multi -way join continuous query is employed to monitor a considerable number of source data streams from various remote sites in real -time . One key role of a continuous query is detecting only the invocation of a particular event corresponding to the specifications of the query . The evaluation of such a detection -only query does not require to produce either an intermediate tuple or a final result tuple , which not only shortens the processing time of a query but also reduces the usage of memory space . However, there has been no special effort to deal with a query of th is type . This paper proposes a new evaluation framework which efficiently processes a multi -way detection -only query without generating any intermediate result tuple explicitly. H.2.4 . [ DATABASE MANAGEMENT ]: Syste ms  X  Query processing Algorithms, Management, Experimentation Data stream, Continuous query, multi -way join processing, Detection -only query Many recent research es for emerging applications such as web click monitor ing, sensor data processing and network traffic analysi s often need to deal with a data stream which is a massive unbounded sequence of data elements continuously generated at a rapid rate. In these applications, a continuous query represents a specific ev ent and it is generally used to monitor the ongoing change of recent information over infinite data streams . A multi -way join query is employed to monitor a considerable number of source data streams from various remote sites in real -time. Most previous re searches [1,2,3,4,5,7,9 ] focus on devising an efficient multi -way join processing mechanism because a join operator is a blocking operator and it is more expensive than a unary operator like a selection or projection operator. Basically, they use a tree -st ructured execution plan employed in a conventional database management system . Since t he selectivit y of a join operation over infinite data streams is mostly unpredictable, they required to employ an adaptive query re -optimization scheme to reorder the eva luation order of the join operations in a query dynamically [6,7,8 ]. This causes a serious run -time burden because finding the optimal execution plan of a query is NP -complete [6 ]. A continuous query can be classified into two different types according to its intended usage. One is a general -purpose continuous query which produces its results as an output data stream. The result tuples of this type are required explicitly to perform a subsequent task. The other is a detection -only continuous query which on ly monitors the invocation of a particular event corresponding to the specifications of the query. For a query of the second type, neither an intermediate tuple nor a final result tuple needs to be produced, which not only shortens the processing time of a query but also reduces the required usage of memory space. However, there has been no special effort to deal with this type of a query.
 This paper proposes a new query evaluation scheme for a detection -only continuous query. In order to present its basic ideas, this paper focuses on how a multi -way path join query is evaluated without generating any intermediate result tuple explicitly as well as reoptimizing its execution plan. First, a matrix -based synopsis is constructed for each source stream of an n -way path join query in which at least one and at most two join predicates are specified on every source stream. Depending on the number of join attributes specified in a source stream, either one or two dimensional matrix -based synopsis is constructed. In a ddition, a hash function is defined for each join attribute domain. The number of entries in a synopsis is determined in compile time by the number of buckets in the hash function (s) of the join attribute(s) in its corresponding source stream . Every incomi ng tuple of a source stream is hashed into an entry of its corresponding matrix -based synops is with respect to its join attribute value(s). Each entry of a matrix -based synopsis for a source stream keeps track of the number of tuples whose join attribute values are currently hashed into the entry. The proposed scheme employs a query equation , a sequence of multiplication operations on matrix -based synopses constructed for the source streams of a query. Based on the order of a query equation , a chunk of new ly incoming tuples of each source stream are batch -processed together against those tuples in the windows of the other source streams. For a new batch of each stream, the final result of the equation contains the maximum possible number of the final result s for the batch. Therefore, t he proposed scheme makes it possible to efficiently detect the invocation of the event that satisfies the specifications of a detection -only query . In addition, the proposed scheme eliminates the need of run -time query re -optim ization. This is because the optimal order of matrix multiplication operations in a query equation is determined in compile time . Therefore, a considerable amount of run -time overhead can be avoided. However, the result of a query equation may contain some false positive errors . To guarantee the accuracy of a detection -only query, the accurate final result tuples of the query can be explicitly generated when the result of the proposed scheme fails to satisfy a required accuracy level. Given an n -way path join query with n source streams { S a 1 x m matrix -based synopsis M S which only has a single join attribute A. In order to assign a tuple of the source stream S i to an entry of the synopsis M function h(k) with m buckets is employed for the attribute A . In other words, a tuple x of S i is assigned to the h(x. A) M [ h(x. A) ] where x.A denotes the value of the attribute A in x . Likewise, for a source stream S j with two join attributes  X  A  X  A  X , an m 1 x m 2 matrix -based synopsis M j is constructed. In order to assign a tuple of the source stream S j to an entry of its synopsis, two distinct hash functions h 1 (k) and h 2 (k) with m 1 employed for the join attributes A 1 and A 2 respectively. A tuple y of S is assigned to the entry M j [ h 1 ( y. A 1 ), h 2 ( y. A A is called as a row attribute of the synopsis while A 2 is called as a column attribute. When two or more attributes of a source stream are used to express a join predicate, a multiple -key hashing function is employed. Given a hash function h for a join predicate R.a=S.b on two streams Apparently, a pair of two buddy tu ples does not always satisfy the join predicate since two or more distinct attribute values can have the same hash value. However in order to satisfy the join predicate, a pair of two tuples should be buddy tuples. Therefore, a concatenated tuple of succes sive buddy tuples for a path join query can be a candidate for a final result tuple of the query. Such a tuple is called as a connecting sequence formally defined in Definition 1. Definition 1. Connecting sequences
Given a sequence of source streams &lt; S 1 ,S 2 ,...,S path join query Q whose ( n -1) join predicates are S S sequence is a list of k source tuples cs =&lt; c a tuple of a source stream up to the k th stream ( k X n ). Every tuple in cs is a buddy tuple to adjacent tuple(s). An n -partial connecting sequence is called as a complete connecting sequence .  X  For example, consider a four -way path join query Q whose predicates are Stdt.name=Sbj.name, Sbj.sid=Dep t.sid and Dept.dept=Prof.dept over source streams Student Stdt , Subject Sbj , Department Dept and Professor Prof . Suppose that the domains of the join attributes s name, sid and dname are { Adam, Bill, Sera, John }, { C01, C02, ...C06 } and { Math, EE, CS } respectiv ely. Let the number of buckets for the hash functions of the domains of these attributes be 4, 2 and 3 respectively. Let the current windows of the source streams are shown in Figure 2 -(a) where r (1  X  i  X 4) denote the pointers to the tuples in the window of the source streams. The window synopsis W of a source stream is a matrix -based synopsis for those tuples that are currently in the window of the stream. For the source streams Stdt, Sbj, Dept and Pro f , 1 X 4, 4 X 2, 2  X 3 and 1  X 3 wind ow synopses are constructed as shown in Figure 2 -(c) when the three hash functions of the attribute domains are illustrated in Figure 2 -(b). The proposed scheme employs two different types of a multiplication operation , matrix multiplication (  X  ) and element -wise array multiplication (  X  ) as follows: 1) Matrix multiplication  X   X  X  : Given a 1 X m 1 vector synopsis X and an m 1  X m 2 matrix synopsis Y , a 1 X m 2 result vector Z is produced by a matrix multiplication Z = X X Y as follows: 2) Element -wise array multiplication  X  : Given two 1 X m vector synopses X and Y , a 1 X m result vector Z is produced by an element -wise array multiplication Z = X  X  Y as follows: To estimate the total n umber of the final result tuples of a query, a query equation defined in Definition 2 is formulated.
 Definition 2 . Query equation Given an n -way path join query Q whose ( n-1 ) join predicates are S .a 1 = S 2 .a 1 , S 2 .a 2 = S 3 .a 2 ... and S n-1 equation E ( Q ) is a sequence of multiplication operations (*) on all the window synopses of the query Q by the same order as in the join path of the query as follows : The k th multiplication operation (*) in E( Q ) becomes an element -wise array multiplication operation (  X ) if W k+1 is a 1 X m vector synopsis . Otherwise, it becomes a matrix multiplication operation (  X  ). A sliding -window join operation [2 ] is a typical way of evaluating a join operation over infinite data streams. It is composed of three tasks: inserting , probing and invalidating . In t he proposed scheme , a number of consecutive tuples of a source stream form a batch which is a unit of a task . The minimum size of a batch is a single tuple but the size of a batch can be adjusted depending on the current workload. The information about the newly incoming tuples of the new batch of each source stream is maintained separately . For this purpose, an a dditional matrix -based synopsis for the batch, namely batch synopsis ( B ) is constructed for each source stream. Given a n n -way join query Q , t o evaluate its query equation E ( Q ) for the new batch  X  X  i of a source stream S i (1 X  i  X  n ), the window synops is W the stream S i is replaced by its batch synops is B query equation is called as a batched query equation E( Q| X  X  multiplication operations up to the k th synopsis of E( Q| X  X  a partial result vector V k . Each entry of V k maintain s the number of k -partial connecting sequences hashed into the entry. As a result, t he last result vector V n maintains the total number of complete connecting sequences for the current batch of the query. Therefore, it indicates the maximum possible number of final result tuples . For a new batch  X  X  i , t he following three tasks are performed in sequence for the evaluation of a batched query equation E(Q| X  X  (1) ( Inserting ) Reset all the entries of B i . Hash the tuples of the new batch  X  X  i one by one and increment the hashed entries of B res pectively. Insert the tuples of  X  X  i into the window of the source stream S i ; (2) ( Matrix multiplying ) Evaluate the batched query , (3) ( Invalidating ) Hash the out -of -window tuples in the window of the source stream S i one by one and decrement the hashed ent ry of W Finally, delete the out -of -window tuples. For example, when a new batch  X  X bj in Figure 2 is processed , the ba tched query equation E ( Q| X  sbj ) = W Stdt  X B Sbj  X W query Q is processed as shown in Figure 2. The first matrix multiplication W Stdt  X B Sbj generates a result vector V result vector indicates there are 3 partial connecting sequences up to the stream sbj . T he subsequent matrix multiplication V produces V Dept =[3, 2, 0]. Finally, V Dept  X W Prof T produces V which indicates there are 2 final connecting sequences. In Figure 3, the precise steps of the proposed scheme are pr esented.
 When the final result vector obtained by the batched query equation E(Q|  X  X  x ) of a query is zero, the query is not satisfied by the new batch  X  X  x . On the other hand, even though the final result vector is non -zero, it cannot guarantee that the query is really satisfied for  X  X  because the result of the query equation may contai n some false positive errors. There are two different causes for the false positive errors. The first one is due to the collisions of a hash function. To measure the effects of this type, the packing density  X  of a window or batch synopsis K is defined as follows: where |K| denote s the number of tuples hashed into K and  X  denotes the number of entries in K . As in a hash index, the packing density of a window or batch synopsis influences on the error rate of this type. Therefor e, given a predefined threshold  X  , in order to guarantee the accuracy of the proposed scheme for a detection -only query , the accurate final result tuples of the query should be explicitly generated as in a general -purpose continuous query if the average pa cking density of the synops es of a batched query equation becomes higher than  X .
 The other type of an error is due to batch processing. Since a batch is a unit of invalidating, the window of a source stream may include some out -of -window tuples. These tup les are not deleted because the oldest batch for invalidating has not been fully populated yet. Consequently, the entries of a window synopsis may contain some false positive counts. There is a trade -off between the error rate of this type and the processi ng time of the proposed scheme, i.e. as the size of a batch gets larger, the error rate is increased while the processing time is shortened.
 If a query is not a path join query, it can be divided into a number of sub -queries each of which is a path join query. For each sub -query, its sub -query equation is constructed and every sub -query equation is evaluated individually as described above. Among the final result vectors of these sub -query equations, if at least one result vec tor is zero, the original query is not satisfied. To illustrate the characteristics of the proposed scheme, the performance of an n -way path join detection -only query is experimented on two synthetic datasets and one real data set [1 0] obtained by EPFL  X  X  SensorScope team . In the synthetic datasets, every data stream has three integer attributes whose values are uniformly distributed in a range [ 1, ...D max ] where D attribute domain . In the experiments, a matrix -based synopsis is additionally implemented by a bitmap . A 1  X m synopsis is implemented by a bit vector of m bits. Likewise, an m X n synopsis is implemented by n bit vectors of m bits. The i th bit of the j indicates whether there exists at least one tuple assigned to the (i,j) entry of the synopsis. This is because there is no need to maintain the actual number of tuples for each entry of a matrix -based synopsis. Only a flag bit is enough for each entry to indicate whether the entry has at least on e connecting tuple for the current batch or not. Th e implementation can significantly speed up the evaluation of a batched query equation because a bitwise AND operation is much faster than a matrix multiplication operation. All the algorithms are implemen ted in C and all the experiments are executed on a Pentium 4 CPU 2.66GHz system with 4GB RAM. The system runs Linux with a 2.6 kernel and gcc 3.3.2. Figure 4 and Figure 5 illustrate the effects of the number of source streams on synthetic data sets and a real data set respectively . As the number of source streams per query is increased, the proposed scheme StaMe performs better than two other algorithms A-Greedy [7] and optDP [ 8 ] do in terms of both processing time and memory usag e. This is because it only evaluates a query equation without generating any result tuple explicitly. As mentioned in Section 3, the StaMe scheme should generate its result tuples explicitly when its accuracy is not guaranteed. Figure 6 illustrates the ov erall processing time of the proposed scheme when  X  = 0.6 and D max = 1000. In this experiment, the input rate of each source stream is varied from 1 to 30 tuples/sec. As the number of buckets for a join attribute domain is increased, the packing density decreased. However, the processing time of the proposed scheme is increased . Since A-Greedy is irrelevant to this factor, its performance remains the same. Figure 7 illustrates the effects of a packing density threshold  X  . The error rate of the proposed scheme is increased as this threshold gets larger . This is because generating query result tuples explicitly is less frequently invoked . This paper proposes a new framework for the evaluation of a detection -only query. Based on a query equation of matrix -based synopses, the proposed scheme can avoid generating query result tuples explicitly as well as re -optimizing the execution plan of a query dynamically. Therefore , it can reduce the run -time overhead of contin uous query evaluation greatly.
  X  X his work was supported by core research program (No. 2011 -0016648) and NRL Program (No.2010 -0008007) of the Korea Science and Engineering Foundation(KOSEF) grant funded by the Korea government(MEST) . X  [1] Y. Yang, D . Papadias  X  X ust -In_Time Processing of Continuous [2] J. Kang, J. F. Naughton, and S. Viglas,  X  X valuating window [3] S.Madden, J.M.Hellerstein and et al,  X  X ontinuously adaptiv e [4] The STREAM groups,  X  X TREAM: The Stanford Stream Data [5] D.J.Abadi and e t al .  X  X urora: A New Model and Architecture [6] H.K.Park, W.S.Lee, Adaptive Continuous Query Re -[7] S. Babu, R. Motwa ni, K. M unagala, Adaptive Ordering of [8] J. Gomes, H. Choi, Adaptive optimization of join trees for [9] M.Stern, K.Bohm , E.Buchmann,  X  X rocessing Continuous Join [10] G. Baraenetxea, F. Ingelrest, and et al , Sensorscope: Out -of -
