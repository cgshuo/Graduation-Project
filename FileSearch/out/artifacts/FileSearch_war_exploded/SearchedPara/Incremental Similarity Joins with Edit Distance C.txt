 With the dynamic increase of string data and the need to integrate data from multiple data sources, a challenging is -sue is to perform similarity joins on dynamically-augmente d string sets. Existing methods only exploit domain-oriente d filters to speed up join processing on static datasets, which are inefficient for incremental data-generation scenarios. In this paper, an efficient approach called ISJ-ED (abbr for I cremental S imilarity J oins with E dit D istance constraints) is proposed to tackle similarity join problem on ever-growi ng string sets. We first design a distance-based filtering tech-nique which exploits an incrementally-built index to impro ve the filtering capability. Then, for the existent filters, we study the impact of their executing orders on total filtering cost and suggest dynamically-optimized filtering orders. A ll these optimization strategies work jointly with the existi ng domain-oriented filters in ISJ-ED, that is, they are com-plementary to those filter-based methods with edit-distanc e thresholds. Experimental results demonstrate that on dy-namically augmented string sets, our method is more effi-cient than those only leverage domain-oriented filters with a fixed filtering order.
 Categories and Subject Descriptors: H.3.3 [Informa-tion Systems]: Information search and retrieval General Terms: Algorithms, Measurement, Experimenta-tion Keywords: Similarity join, string, metric space, filter
String data is ubiquitous in text, customers X  transaction sequences, biological database, etc. [4, 7, 2, 5]. Similar-ity join between two sets of strings returns pairs of strings from each set such that similarity values between the pairs are above a given threshold. Similarity join for string data have attracted significant interest, with applications in d ata cleaning, near duplicate detection, plagiarism identifica tion and bioinformatics.
 Edit distance is a widely used similarity measure for string s and bears a merit of reflecting the ordering of element in the string. The edit distance between two strings is the mini-mum number of single-character edit operations (insertion , deletion, and substitution) that are needed to transform on e string to another. In this paper, we focus on similarity join s with edit distance constraint. However, similarity joins w ith edit distance measure pose serious algorithmic challenges . As the computation of edit distance for two string of length n is quadratic complexity O ( n 2 )[4], hence the naive algo-rithm which directly computes edit distance for every pair o f strings, known as Nested-Loop approach, takes a prohibitiv e O ( N 2 n 2 ) time cost, where N is the number of strings.
In order to tackle the inefficiency of Nested-Loop algo-rithm, current state-of-the-art methods are proposed whic h are mainly based on filter-and-verify schema and are almost running on a static dataset [3, 8, 9, 1]. However, the follow-ing deficiencies restrict their applicability and degrade t hose algorithms X  efficiencies: a) Inability to efficiently work for incremental data-generation scenarios. As the real-world is highly dynamic, the string data sources like customers X  in-formation databases are gradually augmented. If these al-gorithms execute from scratch due to newly-produced data, the filtering capability of their filters would be insufficient for efficiently performing join processing. b) No use of met-ric space properties. Since edit distance is a metric, some good properties, like triangle inequality, can be exploite d to help filtering besides using those filters based on strings  X  characteristics. c) Fixed filtering order. For given filters , we observe that the total filtering cost is sensitive to their execution orders, which means fixed filtering order will slow down the filtering process, especially for large string sets .
Due to the above flaws of the existing methods, we propose a new algorithm called ISJ-ED, which uses metric proper-ties of edit distance and optimized filtering orders to furth er speed up join processing on dynamically-augmented string sets.

The rest of the paper is organized as follows: Section 2 introduces preliminaries and backgrounds. Section 3 and Section 4 present distance-based filtering method and op-timized filtering orders. Experimental results and analyse s are given in Section 5 and Section 6 concludes the paper.
Let Ed ( x, y ) denote the edit distance between two strings x and y . Given two static sets of strings R and S , a similarity join with edit distance threshold  X  returns pairs of strings from each set, such that their edit distance is no larger than  X  , i.e., R  X  X  X  S = {h r, s i| Ed ( r, s )  X   X , r  X  R, s  X  S } . Without loss of generality, we only focus on self-join case in this pa per, i.e., R  X  X  X  R = {h r i , r j i| ( Ed ( r i , r j )  X   X  )  X  ( r R, r j  X  R } .

Some existing filter-based algorithms for string similarit y joins, such as [9, 8, 3], differ mainly in their filters which ar e designed from different perspective of strings X  features an d result in distinct filtering capability. So, these methods c an be reduced to a general paradigm, termed All-Pair-Ed, illus -trated in Algorithm 1. All-Pair-Ed works in a range-query manner with multiple filters. Clearly, it also conforms to th e filter-and-verify schema. During the filtering phase, function Candidate gen generates candidate set for x  X  X  range-query to avoide all possible pair comparisons. Then, p string-feature-based filters try to filter out unpromising strings as many as possible (Lines 4-7). At last, direct edit-distance veri fica-tion is performed to remove false positive strings from the candidate set (Lines 8-9).
 Algorithm 1 : All-Pair-Ed( R,  X  )
S  X   X  ; for each x  X  R do
Return S ;
According to the definition of string similarity join on static datasets, its incremental version can be naturally de-fined as:
If the result for A  X  X  X  A has been obtained on a given string collection A , then similarity join on dynamically-augmented dataset returns the result for ( A  X  B )  X  X  X  ( A  X  B ) after an additional set B is added, and the set A is updated as ( A  X  B ) recursively in the next incremental-join task.

The problem can be transformed into an equivalent form: i.e., ( A  X  B )  X  X  X  ( A  X  B ) = ( A  X  X  X  A )  X  ( B  X  X  X  A )  X  ( B  X  X  X  B ). As the result of ( A  X  X  X  A ) is available, we only focus on the solutions to ( B  X  X  X  A ) and ( B  X  X  X  B ), named BA-Join and BB-Join, respectively.

If BA-Join is still conducted only by means of All-Pair-Ed algorithm, it will be subject to severe performance bottle-neck. Since after ( A  X  B )  X  X  X  ( A  X  B ) is performed, the set A is expanded into ( A  X  B ) in the next incremental-join task. Hence, the set A is becoming larger and larger in size with the later newly-produced datasets, which poses seriou s challenge for efficiently performing BA-Join. So, we should improve the performance of BA-Join as much as possible.
Let R ( s,  X  ) (  X  S ) denote the range-query result for s with query range  X  , and K be a minimal integer such that R ( s, K X  ) can cover S . First, we introduce an important definition in the paper :
Definition 1. For any integer k  X  1 and set S , the k -level of R ( s, K X  ) is defined as the string set T  X  S , such that for each t  X  T , ( k  X  1)  X  &lt; Ed ( t, s )  X  k X  , where the string s is called pivot string .

We incrementally construct a distance-based index w.r.t pivot string s , DisIndex-s . DisIndex-s includes different k -level of R ( s, K X  ) to cover the set A that is the union of all string sets seen so far, and all edit distance to s are also recorded.
 Assume that DisIndex-s for the set A has been built. BA-Join is also conducted based on range-query schema. For each string s  X   X  B , we identify three favorable cases which can speed up the range-query of s  X  with parameter  X  . The first case occurs when the edit distance between s  X  and pivot string s is greater than ( k 1 + 1)  X  . In this situation, we can safely filter out all strings in R ( s, k 1  X  ) based on the property of triangle inequality. In another case, if the edit distanc e Ed ( s, s  X  ) is no greater than ( k 2  X  1)  X  , then all strings in A  X  R ( s, k 2  X  ) can also be pruned away in a similar way.
For the candidate strings formed by the above two cases, their edit distances to pivot string s have been recorded previously, which makes | Ed ( s, s  X  X  )  X  Ed ( s, s  X  ) | , the lower bound on edit distance Ed ( s  X  , s  X  X  ) , easily available. So in the third case, for any string s  X  X  in candidate set, if the is taken as an unpromising string to be paired. These three cases can be formally stated below:
Theorem 1. Given s  X   X  B and different k -level of R ( s, K X  ) ( 1  X  k  X  K ) for the set A : 3. For any string s  X  X  in the candidate set formed by (1)
It is very convenient for DisIndex-s to update after each string s  X   X  B is processed, i.e., the only thing we need to do is to insert s  X  into k -level of DisIndex-s , where k =  X  By applying Theorem 1, we present the first version of ISJ-ED in Algorithm 2, termed ISJ-ED1.

From Algorithm 2, we know that no additional effort is needed for performing BB-Join, i.e., Algorithm 2 has cor-rectly given the results for BB-Join, as the following propo -sition states: Proposition 1. Algorithm 2 also correctly solves the BB-Join problem.
Most filter-based algorithms for string similarity joins an d similarity search don X  X  take the execution orders of their fi l-ters into consideration, such as [3, 9, 8, 6]. However, filter ing orders have an important impact on the overall efficiency of these algorithms, especially for continuously augmente d string sets. First, Lemma 1 indicates that whether a given Algorithm 2 : ISJ-ED1( B , DisIndex-s ,  X  )
S  X   X  ; for each x  X  B do
Return S ; string pair can be finally filter out by a series of filters is independent of their filtering orders, hence we can change filtering orders dynamically to improve the algorithm X  X  per -formance.

Lemma 1. For any filtering order F O of p independent filters in Algorithm 2, the correct final results can always be guaranteed after ISJ-ED1 runs with F O .

In general, telling whether a pair can survive each filter will incur some necessary filtering cost . We refer to the prob-ability that a random string pair ( x, y ) is filtered out by filter F as the filtering power of F . Intuitively, if all filtering costs for different filters are equal, then performing the filter wit h larger filtering power as early as possible will reduce the to tal filtering cost of all filters. We formally state this optimize d filtering order below:
Theorem 2. Given r filters F 1 , F 2 , , F r for string sim-ilarity join. Let the filtering cost of each filter for a ran-dom string pair ( x, y ) be C equally, and their filtering pow-ers fulfil the condition: F P 1  X  F P 2  X   X  F P r , where F P i (1  X  i  X  r ) stands for the filtering power of filter F Then the optimal filtering order with least total filtering co st is: F 1  X  F 2  X   X  F r , where  X  F i  X  F i +1  X  denotes that filter F i is executed prior to F i +1 .

As the actual distance distribution of the dataset is not known beforehand and the filtering mechanisms for differ-ent filters are distinct, acquiring the filtering power of eac h filter is a tough task. So, we suggest a dynamic-estimation heuristic to execute the filers with larger estimated filteri ng power seen so far as early as possible, which can be applied to all filters uniformly.

Let n t denote the total number of processed strings seen so far by F , among which n f strings have been filtered out. We approximate the filtering power of F as n f / n t . First, we choose a random filtering order and set zero for the ini-tial filtering power of each filter. Then, during the process o f range-query for string s , after each pair ( s, s  X  ) is processed, value n f and n t are accumulated for each filter and the esti-mated filtering power seen so far can be computed. Finally, we rank the filters in the descending order of their estimated filtering power. When the next string s  X  X  arrives, the pair ( s, s  X  X  ) is processed in the newly-sorted filtering order. We use this dynamic-estimation technique in Algorithm 3, and refer to this improved version as ISJ-ED, as shown in Algo-rithm 3. An function Exefiltering , is invoked to conduct filtering with the current filtering order and output a new filtering order as well as a variable indicating whether the processing pair can be pruned away.
 Algorithm 3 : ISJ-ED( B , DisIndex-s ,  X  )
Change Line 8-11 in Algorithm 2 to: ( F O, F lag )  X  ExeF iltering ( y, F O ); if ( F lag == false  X  ( Ed ( x, y )  X   X  ) then
The following algorithms are implemented in the experi-ment: ED-Join is a similarity join algorithm based on multiple domain-oriented filters and works on static string datasets . ISJ-ED1, ISJ-ED are used to study the effect of the distance-based filtering technique and the dynamically-optimized fil -tering orders proposed in this paper.
 All experiments were carried out on a PC with 2.3GHz CPU and 2GB RAM and implemented in Java. We used two datasets in the experiment: Real dataset . dataset UNIREF is the UniRef90 protein sequence data from the UniProt project 1 . We extract 500k sequences with an average length 286; each sequence is an array of amino acids coded as uppercase letters. dataset UNIREF is also used in Ed-Join algorithm.
 Synthetic dataset . We randomly generate a string set called SynStr on an alphabet of { a, b, , z } . SynStr has 900k strings and the average length of all strings is about 100.

In order to simulate an incremental data-generation en-vironment, we divided the datasets into different parts and ran the algorithms on one part of them every time. We use the notation  X  UN 1 | N 2 || N k  X  to denote different parts with size of N 1 , N 2 , N k in UNIREF dataset (also called an input-sequence). For example, input-sequence  X  X 500k | 200k | 200k X  means that after an algorithm runs on the first 500k strings in UNIREF, it continues to execute on the next 200k strings and finally on the last 200k strings. Simi-larly,  X  SN 1 | N 2 || N k  X  stand for k different parts in SynStr dataset.
Two important measures reflecting the performance of the distance-based filtering techniques are used: a) size of can di-date pairs before the final edit distance verification (denot ed as SCAND ); b) the running time. Note that the running time includes the time for incrementally constructing the index DisIndex-s . http://www.uniprot.org/ (a) Size of candidate pairs Figure 1: Performance comparisons (with parame-ter  X  =25) (a) Size of candidate pairs Figure 2: Performance comparisons (with parame-ter  X  =10) Figure 1 and 2 shows SCAND and the running time for ISJ-ED1 and Ed-Join on dataset U100k | 100k | 100K | 100k with parameter  X  =25 and S300k | 200k | 200k | 200k with parameter  X  =10, respectively. In all settings, ISJ-ED1 is the most efficient algorithm, and outperform the Ed-Join algorithm by a large margin. The general trend is that the speed-up increases with the augmentation of the dataset. The main reason for the trend is due to the insufficient filtering capa-bility in Ed-Join algorithm on ever-growing dataset.
None of ISJ-ED1 and Ed-Join deals with the issue of filter-ing orders, and ISJ-ED1 has been shown to consistently out-perform Ed-Join. Therefore, we only compare ISJ-ED with ISJ-ED1 to test the effectiveness of dynamically-optimized filtering orders.

From Figure 3(a) and 3(b), we know that on different input-sequences, dynamically optimized filtering orders p ro-posed in ISJ-ED are always superior to the fixed order pre-sented in ISJ-ED1 due to the unnecessary filtering cost taken by the fixed-order filters in ISJ-ED1.

In addition, as Figure 3(a) and 3(b) show, as more parts of the input-sequence are added, the saving for filtering cos t in ISJ-ED is more marked, which is also observed on other input-sequences. The reason for this trend can be explained as follows: the efficiency of the dynamically-optimized filte r-ing orders is dependent on how close they approach to the optimal filtering order in Theorem 2, namely, the more accu-rate the estimation for them is, the more notable the saving for filtering cost in ISJ-ED is. Since the filtering power of filter F is estimated as n f / n t , it can be considered as the application of law of large numbers . Hence, the size of sam-ple n t increase with constant augmentation of the dataset, which in turn make the estimated filtering power more and more accurate. As a result, the derived filtering orders usin g these estimated filtering powers are close to the optimal one more and more. Figure 3: Effect of dynamically-optimized filtering order
In this paper, we study the problem of similarity joins on ever-growing string sets. Combined with the existing domain-oriented filters, distance-based filtering techniq ue and dynamically-optimized filtering orders are developed in ou r proposed algorithm, ISJ-ED, to tackle the problem of ineffi-ciency on dynamically-augmented dataset. Experiments on real as well as synthetic datasets demonstrate the superior performance of ISJ-ED to the existing methods based on domain-oriented and fixed-order filters. [1] S. Chaudhuri, V. Ganti, and R. Kaushik. A primitive [2] G. Dong and J. Pei. Sequence Data Mining (Advances [3] L. Gravano, P. G. Ipirotis, H. V. Jagadish, N. Koudas, [4] D. Gusfield. Algorithms on strings, trees, and [5] M. Hadjieleftheriou and C. Li. Efficient approximate [6] C. Li, J. Lu, and Y. Lu. Efficient merging and filtering [7] S. Sarawagi. Sequence Data Mining (Advanced Methods [8] C. Xiao, W. Wang, and X. Lin. Ed-join: An efficient [9] C. Xiao, W. Wang, X. Lin, and J. X. Yu. Efficient
