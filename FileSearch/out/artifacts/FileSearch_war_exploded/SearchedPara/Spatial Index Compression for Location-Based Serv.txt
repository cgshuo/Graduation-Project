 mobile devices and wireless communication technologies have enabled location-based services (LBSs) that deliver location information to mobile users. Typical spatial data management of LBS system is depicted in Figure 1 [1]; examples of such has an index stored in a spatial database to process queries, such as R-tree. 
A spatial database system needs a server with considerable memory, and extended processing power, to manage spatial objects. In order to process spatial queries more Most of the spatial data indexing schemes assume a region ranging from the smallest value to the biggest value. The objects in each relevant region try to search the spatial data effectively by indexing using a minimum-bounding rectangle (MBR). However, a disk-based spatial database system is limited in terms of its index size. Particularly, more blocks must be read and the throughput consequently decreases. If the key size is small, a block can contain more keys and consequently fewer blocks are read. 
For spatial indexes, especially for R-tree managing two-dimensional data, MBR keys for each dimension account for approximately 80% [3] of the index. Therefore, search performance improves accordingly. As the entries in a node increase, the Nevertheless, few studies have attempted to improve performance by reducing the size of the index. 
In this paper, we propose a novel spatial indexing scheme and structure, which propose a semi-approximation R-tree (SAR-tree) that indexes spatial data and introduces a to the best of our knowledge, to take into account the semi-approximation MBR compression that decreases QMBR by 50% in two-dimensional data. 
This paper describes three definitions: th e relative coordinates of a MBR, semi-approximated MBR using quantization, and the false-overlap region (FOR). We two-dimensional space mathematically and using real location data. The results of the compression methods. In the remainder of this paper, Section 2 summarizes MBR compression schemes. Section 3 describes the SA scheme proposed here and includes some definitions. The better than existing MBR compression schemes. Finally, Section 6 concludes the paper with a brief discussion of future work. Spatial objects can be expressed by using coordinates to represent the objects, which are expressed as MBRs consisting of the bottom-left and top-right coordinates (Fig. 2) [4]. Since these keys take up most of the index structure, reducing the size of entries by compression enables more entries to be stored in a node. A number of studies have examined how to reduce the size of indexes using a MBR compression scheme. Examples include relative representation of a MBR (RMBR), hybrid representation of a MBR (HMBR) [3] using relative coordinates in a MBR, quantized representation of a MBR (QMBR) [5], and virtual bounding the number of MBR keys. The first two schemes, namely RMBR and HMBR, calculate the offset of a relevant MBR from a specific coordinate of the search region. By contrast, QMBR and VBR utilize quantization, which divides the search region using a grid shape based on a fixed value. 
RMBR compresses keys by calculating the relative offset for the MBR stored in stored in 4 bytes so that a MBR occupies 16 bytes of storage, as R0 in Figure 2. By using a relative offset to store the MBR key of each entry contained in a node, 8 bytes coordinates of the MBR with reference to the entire search space (Fig. 4). 
Dividing the search space by a constant integer and compressing keys by using the space in n -number quantization can save more space than RMBR or HMBR, and this replace keys with the number of quantization units by enlarging the MBR in the Figure 5 shows the result in which the x-and y-axes are quantized by 16  X  11 on each axis. If a quantization level is smaller than 256, each coordinate is stored in 1 byte. 
The concept of VBR, proposed in A-tree [6], reduces the number of units required to store key values by quantizing the search region, as with QMBR. In other words, it Unfortunately, these QMBR variants make the MBR larger and thereby enlarge the searching for objects. As a result, overlap with other MBRs occurs and the number of node accesses increases, degrading the overall search performance. compression, RMBR and HMBR need 8 and 6 bytes of storage space, respectively. In the case of QMBR, overlapping due to enlargement of the MBR occurs, affecting search performance. RMBR and HMBR enable keys to be stored in fewer bytes by calculating the relative offsets of the keys from the starting coordinates of the search further reduced to 6 bytes in HMBR. Nevertheless, HMBR has the disadvantage that the keys to be stored are 4 bytes larger than those for QMBR. Table 1 is a summary of the compression schemes. points represent a 2-D rectangle. In the semi-approximation MBR scheme, each node has objects) in QMBR. This also minimizes the storage space required for keys and improves search performance. We present three definitions of semi-approximation. Definition 1. Representation of the relative coordinates of a MBR Let M be the MBR of an entire search space; then the lower-left and upper-right corners of points (  X  ,  X  ), and the relative coordinate for the starting point  X  is as follows: Definition 2. Semi-approximation of a MBR in quantization is defined as follows, where Q e is the endpoint of a quantized MBR: a result, the R1 keys require only 5 bytes of storage.
 Definition 3. False-overlap region (FOR) defined as FOR, which causes MBRs to overlap, it is defined as follows: 
The SA scheme appears only in the areas of the expanded space (Fig. 6, false-overlap region). The region is half that in the QMBR scheme. The coordinate space also decreases to a minimum of 5 bytes. Although high levels of quantization increase the number of bits, over other methods. A SAR-tree is a height-balanced tree based on R-tree. The differences between SAR-structure and algorithms of SAR-tree. The SAR-tree comprises the MBRs (MBR M ) based on the minimum approximation of the objects that represent the entire region of node entries as well as a pair of (ptr, SA(MBR)) entries with information on sub-node pointers and the expanded MBR. As shown in Figure 7, a node has up to a maximum m number of entries, and a flag that distinguishes whether the node is a leaf or internal node. 
The root node calculates the SA(MBR) of the entire space, and does not possess information on the node MBR. The real MBR of an entry is calculated from the SA(MBR), the parent MBR, and the sub-MBR. That is, the child SA(MBR)s in a node can be calculated from the parent MBR in the same node and the child MBRs. Accurate information on each entry is used to prune the nodes. differences between the two trees. The major differences concern insertion and searching. To insert an object, SAR-tree searches down from the root node to the leaf node, calculates the object SA(MBR), and compares it to the entry for insertion. Algorithm 1. Object insertion 
Input: Node n, Object o, QuantizationLevel q 1: Insert(n, o, q){ 2: if first time 3: Invoke SemiApp_makeMBR(entire_space, o, 4: q_level); 5: if(n==root) Compare o.MBR to MBR of entire space; 6: n=root.ptr; 7: if(n==leaf node) 8: Insert o into the node and check overflow; 9: Return to upper; 10: Else Compare SA(o.MBR) with all entries; 11: n=Entry.ptr; 12: Insert(n, o, q); 13: } 
Another difference is that SAR-tree co mpares the quantized endpoint of query region Q with the SA key of each entry. Quantization is processed using the function SemiApp_makeMBR (Algorithm 2). An advantage of so doing is that the two (MBR) is not restored to the original coordinate. Algorithm 2. Semi approximation of MBRs 
Input: entireSpace M, object O, quantization q_level 1: SemiApp_makeMBR(M, O, q_level){ 2: SA s =abs(M s  X  X  s ); 3: /* In detail, SA.lx=abs(M.lx-O.lx); */ 4: /* SA.ly=abs(M.ly-O.ly); */ 5: If(O e ==M s ) SA e =1; 6: Else SA e =Ceiling(q_level*(O e  X  X  s )/(M e  X  X  s )); 7: Return SA(O.MBR) to upper; /* SA(O.MBR)=SA s +SA e */ 8: } Search performance can be improved by increasing node size or compressing MBR evaluate the performance of SAR-tree using a real data set. 5.1 Analysis of the Number of Node Accesses A mathematical analysis of the number of node accesses in R-tree is outlined in [5]. All nodes are assumed to have MBRs of equal height. Let h denote the hight and M h denote the number of nodes at the hight h . Then, M h is equal to the result of Equation node is 1/M h . The probability that a node of height h will overlap a given query region is is represented as follows, where N is the total number of data and f is the average fan-out of the leaf nodes: 
The total number of node accesses from the root to the leaf nodes in R-tree consists of the summation of the nodes at each height, as represented by Equation (5). 
When the quantized level q is applied, each node has a quantized cell of q d . Since access to the nodes in QMBR is first conducted at nodes of height h, followed by the Equation (6). The QMBR scheme accesses more nodes than the MBR scheme because the MBRs are bigger than the real MBRs owing to quantization. 
Equation (6) denotes the expanded sides of a MBR, and is modified into Equation 8(b). of 4 bytes, and that the MBR size of each entry is 16 bytes. The keys in 2-D space are set at 8, 6, 4, and 5, for RMBR, HMBR, QMBR, and SA, respectively. In real quantization, the false-overlap region is a slightly smaller space than in the results of the formula. 5.2 Environment for the Experiment To measure the practical impacts of our method, we compared SAR-tree with the MBR, RMBR, HMBR, and QMBR schemes. The MBR scheme was performed using R-tree, which is a 2-D index. Existing compression scheme algorithms and SAR-tree were implemented by modifying R-tree. We used a Pentium-IV 2.6-GHz CPU with 1 GB of memory, running on Windows XP Professional. 
This experiment used the SEQUOIA dataset, which contains the locations of 62,556 Californian Giant Sequoia groves [8], and was performed using Visual C++. To eliminate the influence of background processes in Windows, we applied the CSIM simulator [9]. Table 2 outlines the parameters in this experiment. 5.3 Experimental Results 
Measurement of performance in terms of processing queries was conducted for a range query, and the proportion of the query region in the entire search space was set size, and accumulated the results. As shown in Figure 8(a), the number of node accesses was lower for compressed MBRs than for non-compressed MBRs in all decrease in MBR keys. Consequently, the number of node accesses also decreases. 
The quantization levels of both QMBR and SA were set at 16. Since QMBR stores RMBR and HMBR performed better than QMBR due to the false-overlap region in QMBR. The increased size of nodes allows more node entries. As shown in bytes for keys; thus, SA has a lower number of node accesses. size grows, the search time is quickly minimized. The performance using the QMBR scheme is worse than for the other compression methods due to the increased search region. Performance is better using the RMBR and HMBR schemes owing to the although the size of QMBR keys is reduced to 4 bytes, the false-overlap region owing to enlargement by quantization causes backtracking. Thus, the search time increases. Figure 10 shows the accumulated number of node accesses in QMBR and SA with adjustment of the size of quantization. Using the QMBR scheme, the number reduces slowly, but using SA it decreases radically at q=16, when the key is stored in 5 bytes, scheme. We introduced a new scheme, SA, which applies the MBR compression scheme when spatial index structures, indexes using MBR compression have rarely been implemented. Existing compression schemes reduce the storage space required for keys in comparison with the original MBRs. Nevertheless, our scheme reduces storage further and improves search performance by halving the enlargement region of QMBR. MBRs by using SA. The performance was evaluated and compared with existing compression schemes by implementing an algorithm in both the SA schemes and SAR-tree. In the experiment, the number of node accesses in SAR-tree, measured by HMBR, although the difference was small. The evaluation in terms of quantized levels compared our method with QMBR using quantization. The methods differed processing time for queries was equivalent to the number of node accesses, and QMBR also differed markedly from other schemes. 
The results showed that SAR-tree performed better than both the two-dimensional index R-tree and existing compression schemes, although the difference was small. In the algorithm proposed here. The scheme proposed in this paper can be used to plan to study performance improvement in those areas. 
