 Sven Groppe  X  Jinghua Groppe  X  Stefan B X ttcher  X  Thomas Wycisk  X  Le Gruenwald Abstract We have to deal with different data formats whenever data formats evolve or data must be integrated from heterogeneous systems. These data when implemented in XML for data exchange cannot be shared freely among applications without data transformation. A common approach to solve this problem is to convert the entire XML data from their XSLT stylesheets. However, in many cases, not all XML data are required to be transformed an approach that optimizes the execution time of an XSLT stylesheet for answering a given XPath query by modifying the XSLT stylesheet in such a way that it would (a) capture only the parts in the XML data that are relevant to the query and (b) process only those XSLT approach, analyze its complexity and present experimental results. The experimental results show that our approach performs the best in terms of execution time, especially when many cost-intensive XSLT instructions can be excluded in the XSLT stylesheet.
 Keywords XML  X  XSLT  X  Query reformulation  X  Optimization  X  Transformation  X  Views 1 Introduction XML has increasingly become a popular tool for representing information to be exchanged applications usually define their own XML formats to store their data. A problem arises in that XML data with different formats cannot be shared and exchanged freely without some types of data transformation. A satellite technology of XML, called Extensible Stylesheet Language for Transformation (XSLT) [ 44 ], has been developed to implement the task of addressing XML nodes of an XML document. XPath can also serve as an independent query language for retrieving specified data from XML documents.

When an application wants to access a subset of XML data with a format different than its own format, the common approach that it can follow is to transform the entire XML document from the source format into the target format. Figure 1 describes the data access and transformation process. The XSLT processor transforms the source XML document D according to the given XSLT stylesheet S into the target XML document S(D) . The needed data for the application, Q(S(D)) , is obtained by applying a query Q to the transformed XML document S(D) .

The common approach performs well when all the data or most of the data from the source document is needed. When the size of the queried data is small compared to the entire transformed document, the common approach performs worse compared to approaches that transform only the required parts of the XML data instead of all the XML data [ 24 ].
An optimized approach, the query transformation approach , which optimizes the exe-cution time of answering queries on XML data that is transformed on-demand according to a given XSLT stylesheet whenever a query is set up, has been presented in [ 24 ]. Instead of transforming the entire source XML document, the query transformation approach only transforms parts of the source document that are necessary to answer a given query by trans-stylesheet. Figure 2 depicts the architecture of the optimized approach. A given query Q is transformed by the query transformation approach into a query R formulated in the source format according to the given XSLT stylesheet S . The transformed query R is used to retrieve the sufficient data R(D) from the source document D . The retrieved data R(D) is then trans-formed into the target format to get S(R(D)) by applying the XSLT stylesheet S .Atlast, Q is applied to S(R(D)) in order to obtain the needed data Q(S(R(D))) .

The query transformation approach improves the performance of the data access and transformation by projecting first the input data to a sufficient part and then transforming only the sufficient part. However, this approach does not avoid the execution of unnecessary XSLT instructions in the XSLT stylesheet S . To fill in this gap, in this paper, we present the XSLT optimization for XPath queries approach (XSLT optimization) (see Fig. 3 ). Rather than transforming a given query from the target format into the source format according to an XSLT stylesheet, our new XSLT optimization approach reconstructs the given XSLT stylesheet S so that the new XSLT stylesheet S X  contains the rules for transforming the XML document to only the part of the XML document that is relevant to answer a given query Q . First, we compute a new XSLT stylesheet S X  by optimizing the given XSLT stylesheet S according to the given query Q . Then the XSLT processor applies the new XSLT stylesheet S X  to the source XML document D in order to transform D to only the part of the target data the needed data Q(S X (D)) . We show that whenever the XSLT stylesheet S contains many of cost-intensive XSLT instructions that are not relevant to answer a given XPath query Q , the XSLT optimization approach has considerable advantages compared to both the query transformation approach and the common approach in terms of execution time. Furthermore, we avoid the additional step of retrieving the resultant XML fragment R(D) , i.e., we do not have to implement the retrieval of R(D) . Besides the XSLT stylesheet optimizer, we use only standard XSLT processors and XPath evaluators that are well-tested products, which are freely available or commercial products.

Note that the proposed optimizations (see Figs. 3 , 2 , respectively) are independent of whether S ( D ) (or S(R(D)) , respectively) is materialized or Q ( S ( D )) (or Q(S(R(D))) , that the proposed optimizations can be also applied in multiple queries scenarios dealing with many XPath queries Q1 ,..., Qm by determining S X  (or R , respectively) for the query Q = Q respectively).

The rest of the paper is organized as follows. Section 2 introduces the basic concepts including the XPath language, the XSLT language and an XSLT processor model that is later output nodes in the given XSLT stylesheet S that are relevant to answer the given query. Section 4 describes how to construct the optimized XSLT stylesheet S X  basedontheresult of the search so that S X  computes only the part of the target data that is relevant to answer the given query. Furthermore, Sects. 3 and 4 also include a complexity analysis of time and space required by the presented algorithms. Section 5 presents the results of the experiments conducted to compare the execution times of the XSLT optimization approach,the common approach and the query transformation approach. Section 6 discusses the related work. The introduces a formal XSLT output data model for a precise and formal definition of the search described in Sect. 3 . Furthermore, the Appendix covers a proof of correctness of the XSLT optimization approach based on a formal XSLT processor model. 2 Basic concepts The main underlying technologies involved in our work are the XPath language and the XSLT language. Sections 2.1 and 2.2 present the essentials of XPath and XSLT, respectively, and Sect. 2.3 illustrates the common approach and the ideas of our approach with examples. 2.1 XPath Basics The XML Path language (XPath) [ 45 ] is a W3C-developed language for specifying node sets in XML documents. XPath can either be used as an independent query language or is embedded in other XML languages like XSLT and XQuery.

The semantic of each XPath expression is defined in terms of the semantic of its sub-of an axis a and a nodetest n with or without predicates q 1 ,..., q i , e.g., child::paper and child::section[child::text()="Introduction"] . XPath defines 13 node or the document node of the XML document. For example, the child axis contains all the child XML nodes of the current input XML node, the descendant axis contains all XML nodes of the transitive closure of the child XML nodes, and the attribute axis contains all the attribute nodes of the current input XML node. A node test filters nodes from the node set identified by the axis by the node name or by the node type. XPath spec-ifies seven node types. For example, the node test paper selects the nodes with the name step select a set of XML nodes relevant to a context node, which is further filtered by the predicates. Predicates further select nodes from the set of nodes filtered by the node test. A predicate is a Boolean expression which tests every node in the context node set. If the [child::text()="Introduction"] checks whether the content of a text node of the context node is  X  Introduction  X . Location steps are separated by the token  X  /  X , and indicating that the navigation in the XML nodes starts at the document node; otherwise, it is which is the current input node of the XML document. Figure 4 contains an example of an XPath expression Q .

The XPath language also defines several abbreviations, e.g., /child::a is abbreviated to /a , attribute::a to @a and // represents /descendant-or-self::node()/ , which can be easily transformed into an equivalent long form. We use the more general long form in this paper in order to consider all cases of XPath.

The XPath expression in Fig. 4 contains four location steps and selects the pages attribute of section elements, which have a text node with value  X  Introduction  X , the parent of which is a tableOfContents element, which is a child node of the root element node paper . 2.2 XSLT basics The Extensible Stylesheet Language for Transformation (XSLT), a part of the Extensible Stylesheet Language (XSL) [ 44 ], is another language developed by W3C. It is used to specify rules for transforming XML documents from one format to another format. XSLT stylesheets themselves are XML documents and define their own elements typically with the namespace in (S1) . XSLT embeds XPath to select nodes for the transformation of an XML document and a subset of XPath for the test of whether a pattern matches the context node.
An XSLT stylesheet consists of a set of transformation rules, called templates , each of which starts with &lt;xsl:template&gt; . Figure 5 contains an example input XML document The XSLT stylesheet of Fig. 6 contains an XSLT stylesheet with two template rules which start in node (S2) and in node (S10) . The elements which are contained in templates are called XSLT instructions . An XSLT instruction describes how to transform the input XML document. For example, in Fig. 6 , (S3) outputs a new element called paper , (S4) outputs an attribute called title , (S5) copies the value of the node of the input XML document identified by the XPath expression self::node/attribute::label .The XSLT language supports also XSLT instructions for invoking template rules, e.g., (S9) . Hereby, the XSLT processor iterates through the nodes specified in the select attribute of (S9) and invokes the templates with the context node assigned with the current node of the (S2) ) is fulfilled for the context node. When more than one template rule matches a given node, the import precedence of imported templates together with the priority of the templates their semantics and the principles of template invocation.

The initial template rule to be invoked is the one that matches the document node  X  /  X  X f the input document. If no such a template explicitly exists in the given XSLT stylesheet, the built-in template rule in Fig. 8 (see also [ 44 ]) is used as the initial template rule. 2.3 Examples of the common approach and of our approach In this section, to illustrate how each of the two approaches works, we use the same input XML document shown in Fig. 5 . 2.3.1 Common approach The common approach does not perform any query-specific optimization on a given XSLT stylesheet or the input XML document. Instead, the common approach consists of the fol-lowing two steps. First, the input XML document in Fig. 5 is transformed according to the XSLT stylesheet in Fig. 6 into the XML document in Fig. 7 .

Second, the XML document in Fig. 7 is used by another application, which executes a query on this output XML document. For example, when the query Q in Fig. 4 is applied to the output XML document, the second step computes the result, which is 1. 2.3.2 The XSLT optimization approach In comparison, our approach applies the XPath query Q in Fig. 4 to the XSLT stylesheet in Fig. 6 , and generates the optimized XSLT stylesheet in Fig. 9 .

When we apply the optimized XSLT stylesheet to the input XML document in Fig. 5 , only the parts of the XML document that are relevant to answer the query Q in Fig. 4 are transformed into the output XML document in Fig. 10 .

We retrieve the same result 1 when we apply the query Q in Fig. 4 to the XML documents in Figs. 10 and 7 . 3 Computing relevant output nodes from an XSLT stylesheet In order to transform an XSLT stylesheet according to an XPath query, our approach of the XSLT stylesheet optimization first searches the paths in the XSLT stylesheet that output elements, attributes and attribute values in the correct order for answering the given XPath query. In Sect. 3.1 , we present our search approach which is based on the standard XPath evaluator typically constructed to search in an XML document instead of an XSLT stylesheet. 3.1 Modifying a standard XPath evaluator In the common approach, an XPath query Q is answered from the output XML document computed by an XSLT processor from the output nodes of an XSLT stylesheet S . Definition 1 The Output nodes of an XSLT stylesheet S are those XSLT nodes of S ,which  X  generate an element E by the XSLT node &lt;xsl:element name=E&gt; ,or  X  generate an attribute A by the XSLT node &lt;xsl:attribute name=A&gt; ,or  X  generate text nodes containing the value " content " by the XSLT instructions  X  copy the content of XML nodes I of the input XML document by the XSLT node  X  copy whole element nodes of the input XML document by the XSLT nodes &lt;xsl:copy&gt;  X  generate a number by the XSLT node &lt;xsl:number&gt; .
 For example, the paper element (R1) in Fig. 7 is generated by the node (S3) in Fig. 6 . The tableOfContents element (R3) is generated by node (S8) . All the section elements (R4) , (R5) , (R6) and (R7) are generated by node (S11) . These output nodes (S3) , (S8) and (S11) of the XSLT stylesheet S are reached after a sequence of nodes &lt;(S1) , (B1) , (B2) , (S2) , (S3) , (S8) , (S9) , (S10) , (S11) &gt; generates an output which is, for example, relevant to answer the XPath query /child::paper/child:: tableOfContent/child::section .
 We define the following terms for the search on output nodes of the XSLT stylesheet. Definition 2 Given an XPath expression XP and an input XML document D , we say that an XML node K of D is successfully visited by an XPath evaluator if the following holds: there exist two token sequences, XP1 and XP2 of XP , so that the concatenation of these token sequences, XP1 and XP2 , is equal to XP , i.e., XP = XP1 o XP2 . Furthermore, the XPath evaluator must retrieve a node set that contains K if the XPath evaluator parses and executes XP1 on D . We set the current context node of the XPath evaluator to K , and then further parsing and processing of XP2 must return a non-empty result. In this situation, we also say that K is relevant to answer the query XP . Example 1 Let XP1 = /child::paper/child::tableOfContent/child:: section and XP2 = [child::text() =  X  X ntroduction X  X /attribute:: pages . The XPath evaluator retrieves the XML nodes (R4) , (R5) , (R6) and (R7) in Fig. 7 for the evaluation of XP1 on the XML document S(D) in Fig. 6 ; however, the XPath Therefore, (R4) is successfully visited by an XPath evaluator for XP = XP1 o XP2 = /child::paper/child::tableOfContents/child::section [child:: text()= X  X ntroduction X  X /attribute::pages .
 Definition 3 Let D be an input XML document. Let XN be an XSLT node of a given XSLT stylesheet S so that an execution of XN generates an output in the form of an XML node O while the XSLT processor transforms D to S(D) . XN is relevant to answer the query Q ,if O is relevant to answer the query Q on S(D) .
 Example 2 (R4) in Fig. 7 is successfully visited while evaluating the XPath query in Fig. 4 (see Example 1 ). As (R4) is generated by the XSLT node (S11) in Fig. 6 , (S11) is relevant to answer the query Q .
 Proposition 1 Any XPath expression I containing path expressions can be divided into a relative part rp(I) and an absolute part ap(I) ( both of which may be empty ) in such a way that rp(I) contains only relative path expressions, ap(I) contains only absolute path expressions, and the union of ap(I) and rp(I) , denoted as ap(I)|rp(I) ,is of ap(I)|rp(I) for all XML documents and for all context nodes in the current XML document.
 rp ( I ) = I { 1 ,..., n } are all relative XPath expressions of I  X  X  1 ,..., n } are all absolute XPath expressions of I is equivalent to I , ap(I) contains only absolute XPath expressions and rp(I) contains only relative XPath expressions.
 Example 3 The relative part of I = (/child::resource[attribute::type=  X  X aper X  X  | child::contains/child::resource[attribute::type=  X  X ection X  X )/attribute::writer , which is equivalent with /child:: resource [attribute::type= X  X aper X  X /attribute::writer |child:: contains/child::resource[attribute::type= X  X ection X  X /attribute ::writer ,is rp(I) = child::contains/child::resource[attribute:: type= X  X ection X  X /attribute::writer , and the absolute part is ap(I) = /child:: resource[attribute::type= X  X aper X  X /attribute::writer .
 The successor XSLT nodes of an XSLT node N1 are those XSLT nodes N2 , which are XSLT nodes executed in context of N1 , i.e., which are recursively executed from an XSLT processor while executing N1 .
 Proposition 2 An XSLT node N2 is the successor XSLT node of an XSLT node N1 if  X  N2 is a child node of N1 in the XSLT stylesheet, or  X  N1 is an XSLT node with an attribute xsl:use-attribute-sets=N and N2 is an  X  N1 is an XSLT node &lt;xsl:call-template name=N&gt; and N2 is an XSLT node  X  N1 is &lt;xsl:apply-templates select=I/&gt; and N2 is &lt;xsl:template Proof of Proposition 2 We can conclude Proposition 2 from the semantics of the XSLT instructions described in [ 44 ].

If we determine the successor XSLT nodes independently of the current input XML doc-ument, we can determine a superset of the successor XSLT nodes N2= &lt;xsl:template match=M&gt; of an XSLT node N1=&lt;xsl:apply-templates select=I/&gt; by using atester T that checks whether N2 could be called from N1 . In the following, we show the existence of an incomplete tester T by using an incomplete intersection tester for XPath XML node K of N1 , I(K) ,and M are not disjointed, i.e., I ( K )  X  M ={} and the templates with a higher priority than N2 do not consume all XML nodes of I ( K )  X  M , which can be tested by ( I ( K )  X  M )  X  I ( K )  X  M  X  ( M 1  X  X  X  X  X  M k ) ={} .
 only support subsets of XPath excluding the  X - X  operator. There exist fast (but incomplete) returns  X  X isjointed X  then we are sure that the XPath expressions are disjointed; otherwise, the tester returns  X  X aybe not disjointed X  .
 Without a complex static program analysis we consider all possible current XML nodes K , which are described by the XPath expression
XP G := / descendant  X  or  X  self :: node () (/self::node()|/attribute::node()|/namespace::node()) , for I(K) by applying rp(I) on the resultant XML nodes of XP G . Note that the absolute XPath expressions ap(I) are independent from current XML nodes. Thus, we determine a superset of I(K) independent of the current XML node K by
MI := ap ( I ) | XP G / rp ( I ) and we use
MM := ap ( M ) | XP G / rp ( M ) instead of M .Thetester T can be implemented by returning  X  not called  X  if the result of the logical intersection tester with the input MI and MM is  X  X isjointed X , and otherwise  X  maybe the used XPath expressions).
 example XSLT stylesheet in Fig. 6 .

Our approach modifies a typical XPath evaluator in order to search for all relevant output nodes of an XSLT stylesheet, which can generate the output that is relevant to answer the given query Q in the correctly nested order. Since a typical XPath evaluator is constructed to compute an XPath query on an input XML document rather than on an XSLT stylesheet, our approach must alter the typical XPath evaluator to search among the output nodes of an XSLT stylesheet in the following way:  X  Similar to the search by a standard XPath evaluator, our approach starts the search at the  X  The search can pass non-output nodes as they do not generate output data,  X  The search continues from an XSLT node N1 to an XSLT node N2 if N2 is a successor  X  The evaluation of filter expressions in Q is processed as follows:  X  If a variable $v is referred to in a local input path expression by $v/XP ,where XP is  X  In comparison to the evaluation on XML documents, it may occur that during the search in We describe the search on output nodes of an XSLT stylesheet according to an XPath query in more detail in the Appendix in Sect. 8.2 . 3.2 Logging the search Our modified XPath evaluator must log different paths in the XSLT stylesheet when searching for the relevant output nodes of the XSLT stylesheet according to a given XPath query. We use the log information for the further computation of the transformed XSLT stylesheet S X  the relevant output nodes and explain how the modified XPath evaluator uses these types of paths in order to log the search.
 ( XP X  , SN , sp ) or the stylesheet path records ( h , sp 1 ,..., sp n ) ,where  X  XP X  is an XPath expression,  X  SN is a sequence of pair nodes in an XSLT stylesheet and the direction ( X  f  X  for forward  X  sp , sp  X  h is a keyword.
 XP X  is the part of a given XPath query, which still has to be evaluated; SN is a sequence XSLT stylesheet when processing XP . f represents either a stylesheet path list computed from a predicate q that tests the last node of SN , or the predicate expression q itself from which no stylesheet paths can be computed like true() or false() , but also including self::node()=C . h represents operators like or , and and not .

We call an attached stylesheet path, a subsequence of XSLT nodes in forward direction, which corresponds to a subsequence of XSLT nodes with backward direction, or a loop in the sequence SN a branched path .

We log the search in the following way:  X  We call the stylesheet path, which contains all the visited XSLT nodes of the path from  X  We call the stylesheet paths, which begin with the start node &lt;xsl:stylesheet&gt; and  X  Each operator like or , and and not in Q leads to one corresponding entry in the current  X  The modified XPath evaluator needs to return from the current XSLT node N1 to an In most cases, we then store the stylesheet paths starting at the XSLT node N2 and ending at the XSLT node N1 in the attached stylesheet paths, which are attached to the XSLT node N2 of the current stylesheet path. Although in the case that the result of a considered path is empty, a Boolean expression could be evaluated to true. For example, XML nodes of the path b/c need not be available in order to for count(b/c)=d to be evaluated to true if d can be 0 . Then, we mark the attached stylesheet path starting at the XSLT node N2 and ending at the XSLT node N1 to be not considered when computing the ipe in Sect. 4.2 .  X  Furthermore, if a variable is referenced in a local input path expression, we store the  X  We can transform the currently processed filter of Q into a filter in the XML format of  X  For each loop detected for a current XSLT node N , we generate a stylesheet path loop , The altered XPath evaluator is based on an XSLT Output Data Model , which we describe in the binary and , or and union operators. However, our approach can be extended to full XPath so that in case of doubt, we can consider a larger fragment in the XSLT stylesheet to generate more output than needed. The XSLT optimization approach is still correct, as in the last step the original XPath query is applied on the result of the XSLT stylesheet. This applies also to positional predicates of XPath expressions. We discuss the supported subset of XPath, which is larger than the supported subset of the altered XPath evaluator described in Sect. 8.1 , of our implemented prototype in Sect. 5.1 in more detail.

Figure 11 marks six parts, XP1 ,..., XP6 , of the example XPath query in Fig. 4 . Figure 12 which entries, E1 ,..., E5 , contain which sequence of XSLT nodes of the XSLT stylesheet in Fig. 6 . 3.3 Complexity analysis of the output path search |S| be the number of nodes in the XSLT stylesheet S . For each stylesheet path of the result O ( lowing reasons: the axis of a current location step in the worst case is a preceding or a following axis. Each stylesheet path contains at most a  X  |S| nodes, each of which a loop. At most all other XSLT nodes are the successor XSLT nodes of an XSLT node. Thus, we can detect O( |S|!/(|S|-i)! ) different stylesheet paths of length i and at most = 1 ( | S |! /( | S | X  i ) ! ) =| S |!  X  tains at most O( a*|S| ) XSLT nodes, for Q .
 Therefore, the worst case complexity of the search in terms of run time and space is O( a  X  | S |  X  ( a  X  | S |  X  | S |! ) a ). 3.3.1 Complexity analysis for the typical case and space for the typical case . For this purpose, we consider some properties of the 39 XSLT stylesheets of the XSLTMark benchmark [ 13 ] and some properties of the XPath queries of the XPathMark benchmark [ 18 ]. We expect that the properties of real XSLT stylesheets and real XPath queries do not differ much from the determined properties of the benchmark XSLT stylesheets and benchmark XPath queries, as the purpose of these benchmark XSLT stylesheets and benchmark XPath queries is to reflect the XSLT stylesheets and XPath queries in real-world scenarios. Here, the determined properties of the benchmark XSLT stylesheets and benchmark XPath queries represent the typical case and we conclude the complexity analysis for the typical case based on these properties. Ta b l e 2 contains some properties of the XSLT stylesheets of the XSLTMark benchmark. less than the number of XML nodes in typical input XML documents. Furthermore, the average number of successor XSLT nodes is 0.42, i.e., less than half of the XSLT nodes have a successor XSLT node. The average maximum number of successor XSLT nodes in an XSLT stylesheet is approximately 6, which is a hint that XSLT stylesheets are not flat XML documents, but are deep XML documents. The average maximum number of XSLT nodes generating elements with the same name is approximately 3, which demonstrates that XSLT stylesheets do not often generate similar output at different places in the XSLT stylesheet. Furthermore, most XSLT stylesheets (64%) generate elements with certain names only at one place in the XSLT stylesheets. The other XSLT stylesheets often generate layout information table rows and &lt;td&gt; elements for table columns.

Ta b l e 3 contains some properties of the XPath queries of the XPathMark benchmark. The average number of location steps is approximately 5, from which 80% are location steps a descendant , descendant-or-self , ancestor , ancestor-or-self , preceding or following axis, the evaluation of which consumes much time in the search algorithm. 85% of the location steps are location steps with a name test as node test and only 13% of the location steps contain the unspecific node tests node() or wildcard ( * ). We have measured the selectivities of XPathMark queries applied to an XPathMark input XML document with a file size of 10 MB. The selectivities of the XPathMark queries vary from low (many queries) to high (few queries). The average selectivity of the queries is 12.27% of the input XML document.
 Thus, we assume that the typical case for real scenarios is characterized as follows: each XSLT node in the XSLT stylesheet S has only a small number of successor XSLT nodes and S does not generate any redundant output. Furthermore, we assume that the query Q specifies a small node set so that we only detect a small number, which is less than a constant k ,of detected stylesheet paths for each location step. Therefore, the complexity of the search in terms of run time and space is O( k*a*|S| ) in the typical case. 4 Optimizing XSLT stylesheets given XPath query Q into an optimized XSLT stylesheet S X  so that Q(S X (D)) , instead of Q(S(D)) , can be executed for answering Q on the transformed XML document of an arbitrary input XML document D .

The detected stylesheet paths (and their branched paths) describe the part of the XSLT stylesheet which generates a relevant output for the given input XPath query Q .Thefirst Only if a whole detected stylesheet path is executed, output that is relevant to answer execution of S X  as soon as possible whenever a whole detected stylesheet path cannot be executed completely. In Sect. 4.2 , we describe how to construct filter expressions that are fulfilled for a current context node of an XSLT node N on a detected stylesheet path if the expressions constructed according to Sect. 4.2 into the local input path expressions, which constructed according to Sect. 4.2 when detected stylesheet paths with common XSLT nodes We then conduct a complexity analysis of the presented optimization methods in Sect. 4.7 . 4.1 Reducing the XSLT stylesheet to the XSLT nodes of the detected stylesheet paths We have to guarantee that evaluating the given input XPath query Q using the optimized XSLT stylesheet S X  yields the same result as evaluating the given input XPath query Q using the original XSLT stylesheet S for every input XML document D . This includes the case in which the execution of an XSLT instruction, &lt;xsl:apply-templates select=I&gt; , optimized XSLT stylesheets. In general, if we delete a complete template T1 starting with the XSLT node &lt;xsl:template match=M/&gt; , which is not in the detected stylesheet paths (and their branched paths), another template T2 in S X  could be called for a node N in situation in that evaluating the given input XPath query Q using S X  would yield more results than evaluating Q using S . Therefore, we must not delete any template head consisting of the XSLT instruction, &lt;xsl:template match=M/&gt; . However, we can delete anything match=M/&gt; ), which are not in the detected stylesheet paths (and their branched paths).
The first optimizing step can be summarized as follows: eliminate all XSLT instructions in the XSLT stylesheet S except XSLT instructions in the detected stylesheet paths (and their branched paths), and except all template heads, &lt;xsl:template match=M/&gt; . Example 5 Given the XPath query, /child::paper/child::tableOfContents/ child::section[child::text()= X  X ntroduction X  X /attribute:: pages , we reduce the XSLT stylesheet in Fig. 6 to the following: 4.2 Filter expressions that are fulfilled if a whole detected stylesheet path is executed Definition 5 For a current input node K of an XSLT node N on a detected stylesheet path, the current input node is relevant to answer the given query if the rest of a whole detected stylesheet path starting from N with the current input node K can be executed. that are relevant to answer the given query (see Definition 5 ).
 Definition 6 ( input nodes ): The input nodes of an XSLT stylesheet S with local input path expression I are  X  &lt;xsl:apply-templates select=I/&gt; ,  X  &lt;xsl:copy&gt; ,where I=self::node() ,  X  &lt;xsl:copy-of select=I X &gt; ,where I=I X /descendant-or-self::node()  X  &lt;xsl:element name="{I}"&gt; , where we deal with this XSLT node as it is on an  X  &lt;xsl:attribute name="{I}"&gt; , where we deal with this XSLT node as it is on  X  &lt;xsl:processing-instruction name="{I}"&gt; , where we deal with this  X  &lt;xsl:value-of select=I/&gt; and  X  &lt;xsl:for-each select=I&gt; .
 Furthermore, the following XSLT nodes, which we call test nodes , can restrict the current input XML nodes of the input XML document by a Boolean test expression T .
 sion T are  X  &lt;xsl:if test=T&gt; ,  X  &lt;xsl:when test=T&gt; and  X  &lt;xsl:otherwise&gt; where T is implicitly  X  not(T1) and ... and not(Ti)  X  X f sions of input nodes and test expressions of test nodes along the XSLT nodes of a detected we use a variable input path expression ( ipe ) defined as follows:
The ipe contains the whole input path expression of the detected stylesheet path from a current XSLT node to the end of the detected stylesheet path. The following holds for the node set described by ipe in context of the current input node of N .Let W be the node set containing all current input nodes while the XSLT processor processes the last XSLT node of the detected stylesheet path. The node set described by ipe in the context of the current input node of N contains all XML nodes of W .

We now design different computing steps (see column 2 of Table 4 )for ipe in order to fulfill the above-mentioned requirement by collecting all input path expressions along the detected stylesheet path and combining them in the correct way depending on the type of the current node and the paths attached to the current node (see column 1 of Table 4 ). The correctness of these computing steps can be verified by comparing them with the semantic of the XSLT language [ 44 ].

In order to compute ipe for each node along the detected stylesheet path and its branched stylesheet through the sequence of XSLT nodes p[k].SN.N after the initialization of ipe . Then depending on the current entry, we do the following:  X  construct new path expressions of the ipe , which we call ipe  X  recursively construct and combine the ipes of the attached stylesheet paths and loops of an Figure 14 presents the construction of ipe , where we use the detected stylesheet path in Fig. 12 , starting at the XSLT node (S11) , where we initialize ipe with self::node() in order to align the example with examples presented below. Furthermore, Fig. 14 illustrates the construction of ipe starting at the XSLT node (S9) , where we initialize ipe with an empty expression, and the construction of ipe starting at the XSLT node (S17) ,wherewe initialize ipe with an empty expression using the detected stylesheet path in Fig. 12 .Note that the XPath language does not support the arbitrary repetition of an XPath expression A , which we denote A n , but we can retrieve a fragment containing a superset of the XML nodes required by replacing A n with /descendant-or-self::node() if A contains only child, descendant and descendant-or-self axes, and with the following XPath expression for an arbitrary A .
Figure 15 contains the computeFilter algorithm, which computes the filter expression the rest of the contained XSLT nodes of a whole detected stylesheet path starting from N can be executed. The algorithm, computeFilter , expects an XSLT node N and the detected stylesheet paths P as input and returns the computed filter expression as output. First, the subpaths of the detected stylesheet paths (or one of its branched paths) starting from N to the end of the considered detected stylesheet path (or one of its branched paths) is computed in line (6). Note that if N is on a loop within a sequence of XSLT nodes, then the resultant subpath contains the subpath of the loop from N to the loop head. We further concatenate the resultant subpath with the subpath starting from the loop head to the end of the stylesheet we recursively proceed as before. We compute the ipe of each of these subpaths in line (7) and line (8). Hereby, for the first XSLT node in a subpath, we do not apply the formula for computing ipe in the case of an input node, as we add a filter (see below) in context of the local input path expression of the first XSLT node. Considering the construction of ipe , at least one XML node of ipe must be available in order to execute the complete path. Therefore, we compute in line (9) the required filter expression to be the disjunction of all the ipe s computed before. Finally, we return the computed filter expression in line (10). 4.3 Optimizing the local input path expressions in the optimized XSLT stylesheet Considering the algorithm to retrieve the detected stylesheet paths and their branched paths, we recognize that the XSLT processor generates an output relevant for answering the query Q only if a detected stylesheet path and its branched paths are completely executed (where loops can be executed an arbitrary number of times). In other words, if the execution of a detected stylesheet path or a branched path is aborted before the detected stylesheet path or the branched path is executed completely, the output of the aborted detected stylesheet path is not relevant for answering Q (see the search algorithm in Sect. 3 ).

Whenever a new node set is selected by an input node of the XSLT stylesheet, a detected in the input XML document D , which are needed to further execute the considered detected stylesheet path or the considered branched path, respectively, are missing. Furthermore, the
Therefore, our second optimization idea is as follows: We add a filter F , which we compute according to the way we describe in Sect. 4.2 , to each local input path expression of those XSLT instructions, which select a new node set of the input XML document D .If F is not fulfilled, the considered detected stylesheet path or the branched path cannot be excecuted completely. This means the current input node is not relevant to answer the given query. In Finally, we replace the local input path expression I in the considered input node N with I[F] .
 Example 6 Given the XPath query, /child::paper/child::tableOfContents/ child:: section[child::text()= X  X ntroduction X  X /attribute:: pages , we optimize the local input path expressions of the XSLT stylesheet in Example 5 to the following: 4.4 Inserting tests at split XSLT nodes In general, detected stylesheet paths and/or branched paths overlap at certain XSLT nodes in the optimized XSLT stylesheet that we retrieve by applying the approach described in branched paths overlap until a last common node C and continue with different XSLT nodes, SP1 ,..., SPn , which we call split XSLT nodes in the following.
 node following C when the path starting with an XSLT split node SPi cannot be executed completely. In order to abort the execution of such paths as soon as possible, we insert an &lt;xsl:if test=F&gt; statement as a child of C and a parent of SPi , where the path starting with an initialized ipe being set to self::node() .

If SPi is an input node, which is already optimized according to Sect. 4.2 ,thetest F would in the input node). Therefore, we do not insert the statement, &lt;xsl:if test=F&gt; ,inthis case. Example 7 Given the XPath query, /child::paper/child::tableOfContents/ child:: section[child::text()= X  X ntroduction X  X /attribute:: XSLT nodes as shown below: 4.5 Optimization algorithm in pseudo code Figure 16 contains the entire algorithm, optimizeXSLTStylesheet , for optimizing an XSLT stylesheet according to an XPath query Q. optimizeXSLTStylesheet expects an XSLT stylesheet S andanXPathquery Q as input and returns the optimized XSLT presented in Sect. 8.2 , i.e., we evaluate the given XPath query Q on the output nodes of the given XSLT stylesheet S and return the logged paths in S . Then the XSLT stylesheet S is XSLT stylesheet S X  in line (17). 4.6 Further optimization There is further optimization to eliminate a location step in the query and the corresponding output nodes in the XSLT stylesheet that are not relevant to answer the query. Example 8 Instead of using the XPath query, /child::paper/child::tableOf Contents/ child::section[child::text()= X  X ntroduction X  X / attribute::pages and the XSLT stylesheet in Example 7 , we can use the XPath query, /child::section[child::text()=  X  X ntroduction X  X /attribute:: pages and the following XSLT stylesheet, where the generation of the elements paper and tableOfContent is eliminated.
In this example, we can further optimize the XSLT stylesheet by eliminating both, the ele-ment generation of section and its content, from the XSLT stylesheet S and the section expressions of the original XPath query Q are not fulfilled.

We do not present these optimization rules here but refer interested readers to [ 21 ], which state some of these optimization rules for XQuery. Grinev and Pleshachkov [ 21 ] describes a tion approach for XQuery . In comparison with [ 21 ], we describe an optimization approach for XSLT in this paper, such that the results from [ 21 ] cannot be transferred. Furthermore, [ 21 ] only supports child and descendant axes for these kind of optimizations, while our contribution supports all XPath axes. 4.7 Complexity analysis Let |S| be the number of XSLT nodes in S and let a be the number of location steps in Q . The runtime complexity of the optimization presented in Sect. 4.1 consists of the runtime of and the runtime of inserting filters into the input nodes of S and inserting conditional XSLT worst case and O( k  X  a  X  | S | ) in the typical case. 5 Performance analysis approach (common approach, query transformation approach or XSLT optimization the execution times of the different approaches when using the most widely used application programming interfaces for accessing XML data, DOM [ 43 ]andSAX[ 31 ] (see Sects. 5.2 , describes the experimental environment, which we have used for the first two experiments. We present the third experiment (see Sect. 5.4 ) in order to show that our XSLT optimization approach speeds up the processing of XSLT stylesheets even if we use another computer con-figuration and various different XSLT stylesheets. We discuss and analyze the experimental results in Sect. 5.5 . 5.1 Experimental environment Our test system for the first and second experiments is an Intel Pentium 4 processor 1.7 GHz with 1 GB RAM, Windows XP as operating system and Java VM Version 1.4.2. We use Ve r s i o n 8 . 0 [ 27 ] as XSLT processors.

The prototype of our XSLT optimization approach supports a larger subset of XPath than we have described in the altered XPath evaluator in Sect. 8.2 . The supported subset of XPath includes all XPath axes, all built-in functions, and , or and union operators and arbitrary comparsions ( &lt; , &lt;= , &gt; , &gt;= and =). 5.2 The first experiment set using synthetic data Figure 17 contains the XSLT stylesheet which we have used in this experiment set.
We have generated the XML documents of different sizes according to the DTD in Fig. 18 (from 0 MB up to 25 MB), where the size of an XML document (or of a query result) is the number of bytes used for the textual representation of the XML document (or of the query results). The b attribute of the a tag contains a numeric value equally distributed in the interval of [0; 99].

For this experiment set, we use the query Q=/child::s/child::c[attribute:: d&lt;X]/attribute::d , which is applied to the transformation of the original document. the original document. Given the query above, our XSLT optimization approach optimizes the XSLT stylesheet of Fig. 17 to the XSLT stylesheet of Fig. 19 . We use this optimized XSLT stylesheet in the following experiments. We run each experiment with both the XSLT processors, Xalan and Saxon. The average of ten experiments is presented.

The following experimental results compare our XSLT optimization approach with the common approach of transforming the entire XML document, and with the query transfor-mation approach, and present the effects of query selectivity and size of XML data on the execution times of the three approaches. The two most widely used application programming interfaces to access XML data are DOM and SAX. Section 5.2.1 presents the experimental results when using a DOM tree as input and output; Sect. 5.2.2 presents the results when using SAX events as input and output.
 5.2.1 Using a DOM tree as input and output First the XML document is parsed by a DOM parser and its DOM tree is generated. The second step is transforming XML data and the process of transformation depends on the individual approach:  X  Common approach: The entire DOM tree is the input of the XSLT processor which  X  Query transformation: The query Q is reformulated to R according to the XSLT style- X  XSLT optimization: First, the XSLT stylesheet of Fig. 17 is optimized to the XSLT At last, we apply Q to the transformed XML data.

We have already compared the execution times of the query transformation and XSLT optimization approaches with the common approach before. We compare the execution time of the query transformation approach with that of the XSLT optimization approach in Fig. 22 when using Xalan and in Fig. 25 when using Saxon. Our XSLT optimization approach is faster at any selectivity for file sizes bigger than 2 MB when using Xalan and for any file our XSLT optimization approach becomes faster compared with the query transformation approach. In the experiments, our XSLT optimization approach is two times faster for 60% selectivity at a file size of 5 MB when using Saxon, and is up to four times faster for 90% selectivity at a file size of 7 MB. For Xalan, our XSLT optimization approach is up to three times faster. 5.2.2 Using SAX events as input and output Depending on the approach used, we proceed in the following way in order to answer a given XPath query Q on the data, which is the result of a transformation according to an XSLT stylesheet S with input XML document D :  X  Common approach : the entire input stream of the XML document is the input of the  X  Query transformation :first Q is reformulated to R according to the XSLT stylesheet We apply the SAX Loader (an extended approach of [ 32 ]) according to Q to the transformed XML data. There does not exist an out-of-memory error in any of these experiments at file sizes up to 25 MB.
 We have shown several comparisons of the query transformation and XSLT optimization. Figure 28 presents the areas in which our XSLT optimization approach is faster than the query transformation approach in terms of the selectivity of the queries and the file size of the input XML document when using Xalan and Fig. 31 when using Saxon. Our XSLT XSLT optimization approach is faster for more than 60% selectivity at a file size of 5 MB and When using Saxon, our XSLT optimization approach is faster for more than 32% selectivity Fig. 31 ).

Our XSLT optimization approach has significant advantages over the query transforma-tion approach when using DOM, as the query transformation approach copies all relevant information of the input data when using DOM, and the copying process is time-consuming. XSLT optimization approach, because additional filter expressions are directly incorporated into the optimized XSLT stylesheet. Therefore, our XSLT optimization approach has con-siderable advantages over query transformation when using DOM. When using SAX, query transformation uses the SAX Loader to filter the irrelevant information, and the filtering is very efficiently implemented. Thus, the XSLT optimization approach does not perform significantly faster than the query transformation when using SAX. 5.3 The second experiment set using the DBLP data set In this set of experiments, we have used the first 7.7 MB of the DBLP data [ 40 ]oftheversion of the 7 February 2005, which contains a bibliography of publications. We have used the XSLT stylesheet of Fig. 32 for the experiments.

We have varied the selectivity of the queries by using two queries Q1 and Q2 with para-query Q2 additionally returns the whole entries. In more detail, we have used the query Q1=/child::result/child::entry[child::Year &lt; X]/child::Year for a selectivity up to 11.8% and we have used the query Q2=/child::result/child:: entry[child::Year &lt; X]/child::* for a selectivity of more than 11.8 %. The experiments measure the execution time which each approach costs to perform the queries with different selectivity on the DBLP data.

The document node of the used DBLP data set has 33,929 child nodes, each of which has 10 child nodes on average. Each of these 10 child nodes has a half child node on average. There are altogether only 88 nodes at the fifth level and only one element node at the 6th level in the used DBLP data set. These kinds of documents, where each node has many child nodes on average, are called flat XML documents . In comparison to flat XML documents, each node in deep XML documents has few children on average.

Figure 33 present the results for the common approach, the query transformation approach and the XSLT optimization approach when using the Xalan XSLT processor with DOM, and Fig. 34 when using SAX. Figure 35 presents the results when using the Saxon XSLT processor with DOM, and Fig. 36 presents the results when using the Saxon XSLT processor with SAX.
The SAX Loader used in the query transformation approach can efficiently filter irrelevant XML fragments even in flat XML documents within one single scan. However, the XSLT optimization approach often adds complex filter expressions into the optimized XSLT stylesheet. The evaluations of these complex filter expressions often have to navigate children as flat input XML documents. Therefore, the query transformation approach per-forms better than the XSLT optimization approach when using SAX (see Figs. 34 , 36 )for the DBLP data, which is a flat XML document. The XSLT optimization approach performs better than the query transformation approach when using DOM (see Figs. 33 , 35 ), as the XSLT optimization approach avoids copying relevant XML nodes, which is time consuming. We provide a further analysis of the experimental results in Sect. 5.5 .
 5.4 The third experiment set using different XSLT stylesheets We present the third experiment in order to show that the XSLT optimization approach speeds up the processing of XSLT stylesheets even if we use (a) another computer configuration and (b) various different XSLT stylesheets.
 Our test system for the third experiment is an Intel Pentium 4 M processor 2 GHz with 1 GB RAM, Windows XP as operating system, Java VM build Version 1.5.0 and its included XSLT processor. We have chosen the XSLT stylesheets and data sets of the XSLTMark benchmark [ 13 ]. The designers of the XSLTMark benchmark choose these XSLT stylesheets in order to cover as many aspects of the XSLT language as possible.

Ta b l e 5 contains the execution times of the XSLT optimization approach versus the execu-tion times of the common approach and the query transformation approach using the XSLT stylesheets of the XSLTMark benchmark, SAX, the given input XML documents and XPath queries. The experimental results show that the XSLT optimization approach is either compa-Both approaches are ususally faster than the common approach. A further analysis of the experimental results is presented in Sect. 5.5 . 5.5 Discussion of experimental results After analyzing all experimental results, we can characterize which types of XSLT stylesheets and which types of queries can be better optimized with which approach, XSLT optimization or query transformation.  X  XSLT stylesheets with an extensive usage of built-in templates : Built-in templates  X  XSLT stylesheets where the name of generated elements do not depend on the input  X  Complex queries and complex input path expressions : The XSLT optimization  X  Flat versus deep input XML documents : The XSLT optimization approach often adds  X  DOM versus SAX in the input source : The query transformation approach is signif-6 Related work Query reformulation is known from relational databases. In comparison to our approach, applying the reformulated query transforms the retrieved data into the target format in one step as follows [ 12 ]: Given two schemas F orig and F transf and a correspondence S between them, find a query R formulated in terms of schema F orig that is equivalent to a given query Q formulated in terms of schema F transf modulo the correspondence S .
In our approach, we perform the transformation of XML data in a separate step in order to use standard XSL processors and standard XPath evaluators wherever possible. As in the approach of query reformulation in relational databases, our approach does not use a direct connection to a database for transforming the query.

Unlike the XML data model, the classical relational model and the deductive data model have no hierarchy, treat element order as insignificant, and do not support identity. These properties of the XML data model have to be considered in query reformulation for XML. Therefore, query reformulation approaches for other data models cannot be applied in pure XML environments, where only XML is used. In comparison to the approaches where XML data and XML queries are first mapped to relational databases and relational queries can avoid performance bottleneck which occurs whenever complex mappings are processed, by using an XML query reformulation approach that uses only XML data and XML lan-guages.

For the transformation of XML queries into queries based upon other data formats, at least two major research directions can be distinguished. First, the mapping of XML queries second, the transformation of XML queries or XML documents into other XML queries or XML documents based on another XML data format (e.g., [ 1 ]). We follow the second queries.

In related contributions to schema integration, two approaches to data and query transla-a unique representation, we follow [ 8 ] and map the queries to those domains where the data resides.
 Thecontributionin[ 11 ] contains query reformulation according to path-to-path mappings. We go beyond this, as we use XSLT as a more powerful mapping language. The work reported in [ 33 ] describes how XSL processing can be incorporated into database engines, but focuses on efficient XSL processing. The complexity of XPath query evaluation on XML documents is examined in [ 19 ]. In comparison, we use an evaluation based on output nodes of XSLT to filter an XML document according to a given query and analyze the performance, but the an approach to compress XML data, where queries can be evaluated on the compressed XML data.
 an XSLT variant of the optimization approaches presented here.
 The study in [ 9 ] describes how the language XQuery can be extended to support views. It describes the language extensions but does not describe how to optimize them. Many applications use XSLT in order to render XML data into HTML web pages. Mukherjea [ 34 ] describes a special search engine for web pages, which significantly reduces the number of pages, which need to be downloaded. It would be interesting to extend the approach of [ 34 ] for usage of XSLT views in order to propagate queries to the original data of web pages rather than their rendered versions.

The approach proposed in [ 32 ] projects XML documents to a sufficient XML fragment which computes a set of projection paths formulated in XPath from an arbitrary XQuery expression. In comparison to this approach we describe, among other things, a path analy-predicates.
 Theworkin[ 29 ] describes how to transform XQuery expressions into XSLT stylesheets. This approach can be used in order to extend our proposed approach to support XQuery as query language and as view language.

Based on the approaches presented in [ 30 , 35 ], our approach for XSLT optimization could be extended for XML document similarity computation and clustering of XML data through XML views expressed by XSLT stylesheets.
 approach where we do not optimize the XSLT stylesheet itself. In [ 24 ], we have introduced the XSLT processor model, which is summarized in this paper, for the query trans-formation approach. Furthermore, our work in [ 24 ] also contains a simple modified XPath by support of additional axes. We have adapted the general XPath evaluator to the require-the query transformation approach in order to support XSLT queries , which can be also used to extend our new XSLT optimization approach for the support of XSLT queries.

In contrast to all these approaches, in this paper, we focus on the optimization of XSLT stylesheets according to XPath queries by modifying the XSLT stylesheet (instead of pro-jecting the input data to a sufficient part). Furthermore, we describe a sketch of an XSLT optimization algorithm, which supports whole XPath and whole XSLT, and we present a proof of its correctness. In experiments, we compare the execution times of the XSLT opti-mization approach with the common approach which transforms first the entire XML data, and we compare with the query transformation approach which does not modify the XSLT stylesheet, but projects the input data to a sufficient part. 7 Summary and conclusions Whenever XML data D given in an XML format F orig can be transformed by an XSLT stylesheet S into an XML format F transf , and a query expressed in terms of format F transf has to be applied, to execute the query efficiently, we need to avoid replicas, reduce the processing costs for document transformation by an XSLT processor, and reduce data ship-ping costs in distributed scenarios. For those purposes, we have introduced the XSLT opti-mization for XPath queries approach (XSLT optimization) and have compared it with the query transformation approach and the common approach.

In the common approach, we first transform the entire data D according to an XSLT stylesheet S into S(D) and query S(D) afterwards according to a given query Q .Thefinal result of the common approach is Q(S(D)) .
 In the query transformation approach [ 24 ], we transform a given query Q by using a given XSLT stylesheet S into a query R. R can be applied to the input XML document D in order to retrieve a smaller XML fragment R(D) , which contains all the relevant data. R(D) can be transformed by the XSLT stylesheet into S(R(D)) , from which the query Q selects the relevant data.
In the proposed XSLT optimization approach, we optimize a given XSLT view according to a given query Q . This optimized XSLT view can be applied to the input XML document D , the result of which contains all the relevant data to answer Q .

We have shown by experimental results that both approaches, the XSLT optimization approach and the query transformation approach, out-perform the common approach in many cases, particularly in the case for queries on large XML documents. We have shown that our approach is scalable and becomes more efficient for larger XML documents. The analysis about the advantages of both approaches, the query transformation approach or the XSLT optimization approach, for which types of input XML documents and for which types of XSLT stylesheets is complex. We have discussed the analysis in Sect. 5.5 .

Whenever XML data is transformed according to an XSLT stylesheet, all three approaches (i.e., the common approach, the XSLT optimization approach and the query transformation approach) can be used to enable on-demand transformations. Especially, the query trans-formation approach and the XSLT optimization approach can be incorporated into XML the relational data) in an efficient and scalable manner. The XSLT optimization approach approach, but additionally, the XSLT optimization approach does not execute unnecessary XSLT instructions to answer a given query. Thus, the XSLT optimization approach outper-forms the query transformation approach in most cases of the real world.

It is promising to investigate whether a combination of the query transformation approach and the XSLT optimization approach has considerable advantages in some application sce-narios. One might think about a distributed scenario, where the source data are stored on a different computer than the one on which a transformation unit is processed. We can then determine the needed fragment of the input data by using the query transformation approach. Thus, we can already project the input data to the fragment, which is sufficiently needed by this fragment of the input data over the network to the computer executing the transformation unit instead of all input data, which is more time consuming. The transformation unit after-ward uses the XSLT optimization approach to optimize the execution of the XSLT stylesheet, as the XSLT optimization executes only the sufficient XSLT instructions to answer a given query on its output instead of all XSLT instructions (when using the query transformation approach), which is more time consuming. 8 Appendix The Appendix consists of 4 subsections. Section 8.2 describes the search on output nodes ness, which we present in Sect. 8.4 , of our XSLT optimization approach. 8.1 XSLT output data model Based-on the data models for the XSL language given by [ 44 ], we develop a model for the output data of XSLT stylesheets. We use this XSLT output data model in order to define the search on output nodes of a given XSLT stylesheet with full technical details in Sect. 8.2 . Definition 8 If the XSLT node N2 is a successor XSLT node of N1 , we call N1 the predecessor XSLT node of N2 .

An XSLT stylesheet is a set of nodes of type Node . There are four main specific Node types in an XML document, which are generated by output nodes of the XSLT stylesheet: root (type of the document node), iElem (type of element nodes), iAttr (type of attribute nodes) and iText (type of text nodes). Accordingly, we define four functions of Node  X  Boolean to test the type of a node: isRoot , isiElem , isiAttr ,and isiText ,which return true if the generated XML node of the given XSLT node is a root node, is of type iElem , iAttr or iText respectively, otherwise these functions return false. We use sequences to express the detected stylesheet paths and paths in the XSLT stylesheet. = &lt; x ing non-repetition) of nodes of a sequence z . We denote x [ k ]= x k for the k -th entry of the sequence x . We use the type sequence( Node  X  { X  f  X , X  b  X  X ) for the data structure to represent paths in the XSLT stylesheet. We refer to the first field of an entry x[k] repre-senting the node in the XSLT stylesheet with x[k] . N and to the second field representing the direction in the XSLT stylesheet with x[k] . d ,where X  f  X  represents the forward direc-sequence(Node  X {  X  f , b } )  X  Set ( sequence ( Node  X  { X  f  X , X  b  X  X )) and the helper functions root ( empty  X  Node ), last ( sequence ( Node  X  { X  f  X , X  b  X  X )  X  Node  X  { X  f  X , X  b  X  X ), succe ( Node  X  Set ( Node )), S ( Node  X  sequence ( Node  X  { X  f  X , X  b  X  X )) and sp ( sequence ( Node )  X  sequence ( Node )). root(x) returns the root node of the XSLT stylesheet in which x occurs; iChild ( iAttr respectively) relates the last node of the sequence to its child nodes (attribute nodes, respectively). For computing iChild(x) and iAttr(x) an auxiliary function S(x) is defined, which relates the last node of the sequence x to its self node and all its successor nodes one node before an output node marking also loops. iDesc returns a sequence from the last XSLT node of the sequence x to all its descen-dant nodes marking also loops. The function sp(x) eliminates XSLT nodes with backward direction in the sequence x and their corresponding XSLT nodes with forward direction. The function sp(x) is used for the computation of the sequence to the parent node by iParent (and its helper function iP ) and of the sequence to the ancestor nodes by iAncestor , which detects and marks also loops. The relation function iSibling(x) relates to the sibling output nodes. iPS(x) ( iFS(x) , respectively) relates to the sibling output nodes of the output. The document order is computed from an XSLT stylesheet in the following way: the document order of elements is the order in which they are defined except they are in the scope of iterations like &lt; xsl:for-each &gt; or &lt; xsl:apply-templates &gt; ,where any element of this set of elements can occur before any other elements of this element set.
Let NodeTest be the type of the node test of XPath. An auxiliary function attr(x, name) retrieves the value of the attribute name of the node x . The function NT: Node  X  NodeTest  X  Boolean , which tests an XSLT node against a node test of XPath, is defined as:  X  NT(x, * ) = isiElem(x)  X  isiAttr(x)  X  NT(x, label) = (isiElem(x)  X  (attr(x, name)=label))  X  NT(x, text()) = isiText(x)  X  (isiAttr(x)  X  (attr(x, name)= label))  X  NT(x, node()) = true 8.2 Altered XPath evaluator Note that our approach works for full XPath [45]. However, due to simplicity of presentation, we present the approach for only a subset of XPath, which we define in the following rules formulated in Extended Backus Naur Form (EBNF), to describe the search on output nodes by our altered XPath evaluator: e ::=e X  X  X  X |/e| e/e |e[q]|axis::nodetest. q ::= e|e=C|e=e|q and q|q or q|not(q)|(q)|true()| false() . axis::=child|attr|desc|self|following|preceding|parent| ances|DoS|AoS|FS|PS. nodetest::=label| * |node()|text(). eral, i.e., a string or a number, where we write DoS for descendant-or-self , AoS for ancestor-or-self , FS for following-sibling and PS for preceding-sibling .Furthermore,weuse attr as short name for attribute , desc for descendant and ances for ancestor .

However, our approach can be extended to full XPath so that in case of doubt, we can consider a larger fragment in the XSLT stylesheet to generate more output than needed. The XSLT optimization approach is still correct, as in the last step, the original XPath query is applied on the result of the XSLT stylesheet. This applies also to positional predicates of XPath expressions.

Our proposed search on output nodes evaluates an XPath query on an XSLT stylesheet, and computes a set of stylesheet paths to the possible output nodes specified by the XPath query.
 In the following paragraphs, we describe the search on output nodes of the considered XSLT stylesheet, and define the following notations. Let z be a pointer in a stylesheet path path record to which the pointer z points.
Figure 38 defines the semantics L of the search on XSLT stylesheets, where we initial-ize the search by evaluateXPathOnXSLT(Q,S):=L(Q,  X  ) ,where Q is the given XPath query and S the given XSLT stylesheet. The function L takes an XPath expression and a stylesheet path as argument and yields a set of new stylesheet paths, and is defined recursively on the structure of XPath expressions. For evaluating each location step of an XPath expression, our search first computes the axis and the node test of the location step by iteratively taking the last XSLT node of the sequence p[|p|].SN from each stylesheet path p in the path set as the context node. The path set is computed from the part XP X  of the XPath expression, which has been evaluated, i.e., XP=XP X /XP X  and XP = XP f / XP r , where XP f is the current location step and XP r is the subexpression of XP , which still has p-p X =p X  in the case of p=p X  o p X  , otherwise p-p X =p .
 q i itself when q i does not contain location steps. The node last(p[i].SN).N is the context node of these predicates. q i is evaluated to false if q i is computed to the empty set with the exception of not ( q i ) , which is computed to true. For example, L(e [ q 1 and q ],p) is computed to empty set if q 1 or q 2 are false. Example 9 The single computation steps of applying the XPath query given in Fig. 11 to the XSLT stylesheet of Fig. 6 when using the formulas of Fig. 38 are given in Table 6 .Thefinal result is presented in Fig. 12 . 8.3 XSLT processor model In this section, we outline the execution of an XSLT stylesheet by an XSLT processor and define the state of the XSLT processor. This work is useful for the following aspects:  X  to understand how an XSLT processor transforms XML documents,  X  to define a formal XSLT processor model,  X  to develop an XSLT stylesheet optimizing algorithm, and  X  to prove the correctness of the XSLT optimizing algorithm (see Sect. 8.4 ) based on the 8.3.1 Algorithms for XSLT stylesheet execution To simplify the XSLT processor model, we reduce many cases of XSLT instructions by first transforming XSLT instructions into their long form, i.e., XML nodes, which represent the in long form for generating the output (e.g., &lt;xsl:element name= X  X lem X &gt; ). Let us consider the case that an XSLT instruction I contains an attribute A , which is set to the value of one or more XPath expressions, i.e., in the case of an XPath expression A= X  X XP} X  , where XP is an XPath expression. In order to keep the XSLT processor model simple, we assume that the XSLT processor evaluates XP as it would be a child node &lt;xsl:value-of select= X  X P X &gt; of I . Furthermore, other attributes of I containing an XPath expression are also executed as they would be a child node of I . Figure 39 presents the pseudocode algorithms of an XSLT processor, which executes XSLT stylesheets.

The first algorithm processXSLTStylesheet (see Fig. 39 ) initializes the XSLT processor by selecting the first input XML node of the input XML document iXML and the first XSLT node N of the XSLT stylesheet (line 6). N contains the initial template, which may The XSLT processor processes this template by calling the algorithm processXSLTNode (line 8).

The second algorithm processXSLTNode (see Fig. 39 , line 9 X 22) executes a given single XSLT node N . Further parameters of the algorithm processXSLTNode include the current XML node K in the input XML document iXML and the last generated XML node o in the output XML document for adding new output to the output XML document relative to o . The algorithm processXSLTNode contains a loop iterating through the input node set of N (see line 18 X 22). The input node set of the XSLT node N is the result of evaluating the XPath expression stored in a select attribute with context node K (see line 16) or is a set containing only the current input XML node K (see line 17) in the case that a new input node set is not declared by a select attribute of N .

The method executeOneXSLTNode (line 20) with three parameters, the current XSLT describe the implementation of the method executeOneXSLTNode here. Note that the execution of an XSLT node ( &lt;xsl:apply-templates&gt; , &lt;xsl:apply-imports&gt; or &lt;xsl:call-template&gt; ) can cause the execution of a whole template. If the current XSLT node N generates an output XML node oz , the method executeOneXSLTNode also attaches oz as a child node of the last node o in the output XML document. The method executeOneXSLTNode then returns the XML node oz in the output XML document (see Fig. 39 , line 21), which serves as the last XML node in the output XML document in line 22. Here, the XSLT processor processes all child nodes DN of the current XSLT node N recursively by calling the method processXSLTNode with the parameter X  X  child node DN , current input XML node K , input XML document iXML and output XML node oz . 8.3.2 State of an XSLT processor Considering the execution algorithm of an XSLT processor (see Fig. 39 ), we can define the state of the XSLT processor as follows.
 Definition 9 The state X of an XSLT processor that transforms an input XML document D according to an XSLT stylesheet S is a tuple ( N , X P , K , I ) ,where  X  N is the currently executed XSLT node of S ;  X  X  X  K is the current input XML node;  X  I is the input XML node set of the current XSLT node N with those XML nodes marked, Definition 10 Given an input XML document D and an XSLT stylesheet S ,the execution according to S . Example 10 Figure 40 contains the execution sequence &lt;X1 ,..., X45&gt; of the XSLT proces-sor while the XSLT processor executes the XSLT stylesheet S in Fig. 6 on the XML document D in Fig. 5 .InFig. 40 , we use the node identifiers specified in Figs. 6 and 5 . Example 11 Figure 41 contains the execution sequence &lt;X1 X , X2 X , X3 X , X4 X , X5 X , X10 X , X11 X , X12 X , X12a X , X13 X , X14 X , X15 X , X18 X  , X19 X &gt; of the states of the XSLT processor while executing the optimized XSLT stylesheet S X  in Fig. 9 on A state Xi X  (except X12a X  ) corresponds to the state Xi in Fig. 40 . Note that the result of applying the query Q in Fig. 4 to the output of the execution sequence in Fig. 41 is the same in Fig. 40 . 8.4 Proof of correctness In this section, we prove the correctness of the XSLT optimization algorithm. More precisely, we prove that using our approach for XSLT optimization, which transforms a given XSLT stylesheet S into an optimized XSLT stylesheet S X  according to an XPath query Q ,weretrieve thesameresultfor Q(S X (D)) and for Q(S(D)) for all XML documents D .

We prove the correctness by comparing the execution sequences of the XSLT processor with and without using our XSLT optimization approach. We check whether all relevant output is still generated when using our XSLT optimization approach and no other output nodes are generated when using our XSLT optimization approach. Our proof of correctness demonstrates in general how the correctnesses of such kind of optimization approaches can be proven by this example.
 paths computed by the search for output nodes described in Sect. 3 .
 Definition 11 Given a state x of an XSLT processor. We define Pred trans ( x ) to be the set P ( x ) be {x} and let P  X  Definition 12 Let Z be an execution sequence according to Definition 10 .Thenwedefine the result of the function, excludeTestNodes(Z) , to be an execution sequence Z X  of states, which contains all states of Z in the same order, except the states, the XSLT node of Z X  , are replaced with the predecessor state of the excluded state. This means that we set x to be ( N , predecessor ( X P ), K , I ) until the predecessor state is in Z X  . Definition 13 Givenanexecutionsequence Z of states for a given XML document. Let Z X  be the result of excludeTestNodes(Z) .Wedenote x P Z ,if  X  p  X  P so that the following two conditions hold: (1) The state x  X  Z of an XSLT processor and its predecessor states contain those executed XSLT nodes that are the visited XSLT nodes of the detected stylesheet path p or its branched paths in the same order as in p , (2)  X  x  X  Z : X  x  X  Pred trans ( x ) : x  X  Pred trans ( x ) and x X  and its predecessor states contain those executed XSLT nodes that are the visited XSLT nodes of the whole detected stylesheet path p in the same order.

We denote x P Z for the case that x is relevant for generating output that is relevant to answer Q . We demand the requirement 2) because x can be on a branched path of p and is only consider situations where a whole detected stylesheet path is executed. Definition 14 Given an execution sequence Z of states for a given XML document and given x1 , x2  X  Z ,then x1  X  from the predecessor relation (see Definition 9 ) between states of Z .
 Definition 15 Givenanexecutionsequence Z of states, then Z X  is a subsequence of Z iff  X  x  X  Z : x  X  Z and  X  x1 , x2  X  Z : x1  X  Z  X  x2 &lt; = &gt; x1  X  Z x2 .
 Definition 16 Givenanexecutionsequence Z of states and a state x1  X  Z ,wedefinethe distance of x1 , which we denote by dist(x1) , to the first state in Z by counting the number of predecessor states until the first state.
 Example 12 In Fig. 40 , the first state is X1 and the distance of X37 , i.e., dist(X37) ,is6.
In the proof of correctness of the XSLT optimization algorithm, we use Lemmas 1  X  5 defined below. In these lemmas, we assume that an XSLT stylesheet S andanXPathquery optimization algorithm with the input S and Q .
 and let x2 = ( N , X P2 , K , I 2 ) . Then we denote x1=* x2 iff the following two conditions are true: 1) I 1  X  I 2 and 2) x1 and x2 are the first states of the execution sequences or X We u s e x1=*x2 in order to express corresponding states in different execution sequences. Definition 18 Let Z1 be an execution sequence and let Z2 be an execution sequence. We denote Z1  X  Z2 iff  X  x1  X  Z1 : X  x2  X  Z2 : x1 =  X  x2 .

We u s e Z1  X  Z2 for the case that Z1 contains only states which have corresponding states in Z2 . Note that we do not consider the order of states in Z1 and Z2 for Z1  X  Z2 .
Let ZS be the execution sequence of states of the XSLT processor while transforming the input XML document D according to the XSLT stylesheet S into S(D) .Let ZS be the execution sequence of states of the XSLT processor while transforming the input XML document D according to the optimized XSLT stylesheet S into S (D) . Furthermore, let ZSeTN be the result of excludeTestNodes(ZS ) .
 Lemma 1 ZSeTN  X  ZS .
 Proof of Lemma 1 Ignoring the inserted test nodes (see Sect. 4.4 ), S contains only XSLT maybe a more restricted input XML node set) are also in ZS (but maybe not all states in ZS are also in ZSeTN ).
The basic idea of the lemmas, Lemmas 2  X  5 , is to prove the following condition E for the subsequences in ZS and for the corresponding subsequences in ZSeTN .
 Definition 19 Let subZS be a subsequence of ZS and let subZSeTN be a subsequence of ZSeTN .The condition E(subZS,subZSeTN ) is true for subZS and subZSeTN iff  X  x  X  x P
Finally,weprove E(ZS,ZSeTN X ) in Lemma 5 , which is used in Proposition 3 for the proof of correctness of the XSLT optimization algorithm.
 Lemma 2 Let x Last  X  ZS be a state where x Last P ZS . Then  X  x Last  X  ZSeTN : x Last =  X  x Proof of Lemma 2 The combination steps of ipe of a single XSLT node on a detected stylesheet path (or its branched paths) are designed so that the evaluation of the whole ipe as Boolean expression returns true if the current input node is relevant to answer Q .The constructed ipe s are used to restrict the input node sets (see Sect. 4.3 ) and are used for the insertion of test nodes (see Sect. 4.4 ). All XSLT nodes on detected stylesheet paths are also available in S .Thus,if x Last P ZS ,then  X  x Last  X  ZSeTN : x Last =  X  x Last and x Last PZSeTN .
 Lemma 3 Let x Last  X  ZS be a state where x Last P ZS .Let x Last  X  ZSeTN : x Last = x way:
Let LS line20 be a subsequence of ZS where LS line20 = &lt; x | x  X  ZS  X  predecessor ( x ) = x
We also analogously define the subsequences of ZSeTN X  and the states generated in the function call of line (22):
Let LSeTN line21 be a subsequence of ZSeTN X  where LSeTN line21 = &lt; x | x  X  ZSeTN  X  predecessor ( x ) = x Last  X  x is generated by line (20) of state x Last &gt; .
Let LS line22 be a subsequence of ZS where LS line22 = &lt; x | x  X  ZS  X  predecessor ( x ) = x
Let LSeTN line23 be a subsequence of ZSeTN X  where LSeTN line23 = &lt; x | x  X  ZSeTN  X  predecessor ( x ) = x Last  X  x is generated by line (22) of state x Last &gt; . Then E ( LS line20 , LSeTN line21 ) and E ( LS line22 , LSeTN line23 ) hold. Proof of Lemma 3 We conclude E ( LS line20 , LSeTN line21 ) and E ( LS line22 , LSeTN line23 ) by considering the algorithm, processXSLTNode (see Fig. 39 ). Note that the combination steps of ipe of a single XSLT node on a detected stylesheet path (or its W be the XML node set which is retrieved for S by the internal XPath evaluator in line (16) of Fig. 39 for the states in LS line20  X  LS line22 .Let W S  X  W be the XML node set which is retrieved for S X  by the internal XPath evaluator in line (16) of Fig. 39 for an arbitrary state in LSeTN line21  X  LSeTN line23 . For all states x1  X  LS line20  X  LS line22 ,where x1 P ZS , the current context node K of x1 is also in W S . K  X  W S because we restrict the of a whole detected stylesheet path. Therefore,  X  x1  X  ZSeTN : x1 =  X  x1 . Furthermore,  X  x  X  Pred trans ( x1 ) : X  x2 P ZS : ( x  X  Pred trans ( x2 )  X  X  X  x2  X  ZSeTN : x2 =  X  x2 ) as we designed the XSLT optimization algorithm so that the following two conditions to answer Q . Therefore, x2 P ZSeTN . Considering also Lemma 1 , we prove Lemma 3 . Lemma 4 Let SZS old be a subsequence of ZS ,let SZSeTN old be a subsequence of ZSeTN X  where E ( SZS old , SZSeTN old ) holds. Let x Last  X  SZS old be a state where x Last P ZS . As E ( SZS old , SZSeTN old ) holds,  X  x Last  X  ZSeTN old : x Last =  X  x Last and x Last P
ZSeTN  X  . Furthermore, we require the following to hold: x
We d e fi n e SZS new to be a subsequence of ZS ,where SZS new = &lt; x | x  X  SZS old  X  ( x  X 
ZS  X  predecessor ( x ) = x Last )&gt; ,and SZSeTN new to be a subsequence of ZSeTN X  , where SZSeTN new = &lt; x | x  X  SZSeTN old  X  ( x  X  ZSeTN  X  predecessor ( x ) = x Then condition E ( SZS new , SZSeTN new ) holds Proof of Lemma 4 SZS new can be divided into four subsequences, SZSnew 1 , LS line20 , LS line22 and SZSnew 2 of SZS new so that SZS new  X 
SZSnew 2 ,where  X  denotes the concatenation of sequences: (2) After x Last , the states of LS line20 occur in SZS new . (3) After the states of LS line20 , the states of LS line22 occur in SZS new . (4) Let x Last + 1 be the state after x Last in SZS old . The fourth subsequence SZSnew 2 Considering the definitions of the execution sequences and the algorithm processXSLTNode in Fig. 39 , first all states of SZSnew 1 occur in SZS new , then all states are no other states in SZS new . We can define subsequences of SZSeTN new depending on x that first all states of SZSeTN new 1 occur in SZSeTN new , then all states of LSeTN line21 , all states of LSeTN line23 and finally all states of SZSeTN new 2 occur in SZSeTN new . There are no other states in SZSeTN new .
 Considering the presumption of Lemma 4 and considering Lemma 3 , the condition E(x,y) holds for each single subsequence x in SZS new and its corresponding subse-quence y in SZSeTN new , i.e., E ( SZSnew 1 , SZSeTN new 1 ), E ( LS line20 , LSeTN line21 ), E (
LS line22 , LSeTN line23 ) and E ( SZSnew 2 , SZSeTN new 2 ) hold. We now have to prove x2 in SZS new ,where x1 P ZS and x2 P ZS .Then  X  x1 =  X  x2  X  SZSeTN new , x1 =  X  x1 , x2 =  X  x2 , x1 P ZSeTN and x2 P ZSeTN because this is a requirement of the LSeTN line23 ) and E ( SZSnew 2 , SZSeTN new 2 ) hold.

We consider two different cases for x1 and x2, x1 X  and x2 X  . (a) If x1,x2 are both elements of the same subsequence, SZSnew 1 , LS line20 , LS line22 (b) x1, x2 are elements of different subsequences, SZSnew 1 , LS line20 , LS line22 and Therefore, condition E ( SZS new , SZSeTN new ) holds Lemma 5 Condition E(ZSeTN X ,ZS) holds.
 Proof of Lemma 5 If there is no detected stylesheet path, then Lemma 5 is true. Otherwise, there is at least one detected stylesheet path. Let ZS(n) and ZSeTN X (n) be the subsequence respectively. In other words: Let ZS(n) be a subsequence of ZS where ZS ( n ) = &lt; x | x  X  ZS , dist ( x )&lt; = n &gt; .
Let ZSeTN X (n) be a subsequence of ZSeTN X  where ZSeTN ( n ) = &lt; x | x  X  ZSeTN , dist ( x )&lt; = n &gt; .
 Then we prove E(ZS(n),ZSeTN X (n)) (see Definition 19 ) by induction on variable n .
As ZS and ZSeTN X  are limited in the number of states, we prove Lemma 5 by the following induction proof:
Base clause ( n = 0 ) : The first state x Start in ZS and also in ZSeTN X  is always ( N = &lt; xsl : stylesheet &gt;, X ZS ( 0 ) = ZSeTN ( 0 ) = &lt; x X stylesheet paths always start with the XSLT node &lt; xsl : stylesheet &gt; . Furthermore, x In order to prove the recursion clause , we assume that E(ZS(n),ZSeTN X (n)) holds. through the set Z Last ={ x Last  X  ZS | x Last P ZS  X  dist ( x Last ) = n } .Let x Last be the currently considered state of Z Last .Then  X  x Last  X  ZSeTN : x Last = X  x Last and x Last P ZSeTN (see Lemma 2 ). Let SZS new (n) be a subsequence of ZS ,where SZS new (n) = &lt; x  X  ZS | x  X  SZS old (n)  X  predecessor(x)=x Last &gt; .
 Let SZSeTN X  new (n) be a subsequence of ZSeTN X  ,where
SZSeTN new ( n ) = &lt; x  X  ZSeTN | x  X  SZSeTN old ( n )  X  predecessor ( x ) = x
We prove E ( SZS new ( n ), SZSeTN new ( n )) by using Lemma 4 . After proving the condition E ( SZS new ( n ), SZSeTN new ( n )) ,weset SZS old ( n ) to states of Z Last are considered and E(ZS(n+1),ZSeTN X (n+1)) is proved.
 Thus, condition E(ZS,ZSeTN X ) holds.
 Proposition 3 Let S be an XSLT stylesheet and let Q be an XPath query. Then the XSLT optimization algorithm transforms S into an optimized XSLT stylesheet S X  so that for every input XML document D the following holds: Q(S(D)) returns the same result as Q(S X (D)) . Proof of Proposition 3 We compute the detected stylesheet paths of Q in S . Then we can in ZSeTN X  , but is relevant to answer the query Q. ZS X  is identical to ZSeTN X  ignoring output. Thus, there is also no other output generated in ZS X  . Therefore, Q(S(D)) returns thesameresultas Q(S X (D)) for every XML document D .
 References Author biographies
