 Classification is the task of learning from one data set and making predictions in another data set. The learning data is called training data which consists of entities with their labels. The other data set is called testing data which consists of entities without labels, and the classifying task is to make prediction of their labels based on what we learn from the training data. Many classifiers have been proposed in the literature. Here, we focus on pattern-based classifiers.
Frequent patterns are patterns that appear frequently in the dataset. Fre-quent patterns whose supports in the training data set change significantly from one class to the other are used to construct the classifiers. These patterns are called emerging patterns (EP) [9,10,16] and these patterns are applied to test-ing instances to predict their class memberships. As a classifier may generate many rules for the same class, aggregating their discrimination power gives bet-ter prediction results [4,8,10,20]. Using EPs has the advantage that they not only predict the class labels but also provide explanation for the decision.
Jumping emerging patterns (JEP) are a special type of EPs that have non-zero occurrence in one class and zero occurrence i n all other classes [10,11]. PCL [9,10] is a classifier based on aggregating the prediction power of frequent JEPs. Given a test instance t , PCL selects the top-K JEPs with the highest supports that are contained in t from each class and then computes the score for each class using these selected patterns. PCL assigns the class label with the highest score to the testing instance. The choice of a good value for K is tricky and its optimal value varies on different datasets, as shown in Fig. 1. Remarkably, the problem of choosing the best value of K has not been investigated previously.
Here, to avoid overfitting K to the data, we sample many subsets of the train-ing data to get the value of K that appears the best on average. By this method, we maximize the likelihood that the chosen K will produce the best results in the whole dataset. Our main contributions are summarized as follows: (i) We revisit the PCL algorithm [9,10] and propose a method to find the most appropriate parameters to improve the performance of PCL. (ii) We introduce a method to speed up the proposed algorithm as well as cross-validation methodology for frequent-pattern-based classification algorithms in general. Emerging patterns are a special type of fr equent patterns. They occur frequently in one class but rarely in other classes. Emerging pattern-based classification ben-efits enormously from the advancement of frequent pattern mining algorithms and better understanding of the patterns space. Many methods have been pro-posed to select a good set of patterns for co nstructing classifiers [15]. Most of these algorithms first gener ate frequent patterns satisfying a certain minimum support constraint, and then select patterns based on some criteria and make predictions based on the selected patte rns. These algorithms mainly differ in how patterns are selected and how class labels are determined.

The first class of methods pick the best pattern to classify testing instances, like CBA [14] and MMAC [18]. CBA first derives classification rules from fre-quent patterns, and then ranks the rules in descending order of their confidence. A very small set of rules is then selected to maximize the class ification accuracy on the training data. The class label of a new instance is decided by the first rule that matches the instance. MMAC extends CBA to multiple classes and labels. Only a small set of patterns are selected for classification. So it is possible that anewtestinginstancedoesnotco ntain any EP that is selected.

The second class of methods treats frequent patterns as additional features and then use classical algorithms to classify the data [2,3]. Cheng et al. [2,3] build a connection between pattern frequency and discriminative measures such as information gain score, and develop a strategy to set minimum support in frequent pattern mining for generating useful patterns for classification. Based on this strategy, coupled with a propose d feature selection a lgorithm, selected EPs are used as additional features to build high quality classifiers. The results show that using EPs as additional features can improve the accuracy of C4.5 and SVM. The main drawback of this approach is that the intuitiveness of the pattern-based classifiers may be lost.

The last class of methods selects the top-K patterns and aggregates the pre-dictive power of the selected pattern s. They include CAEP [4], iCAEP [20], PCL [9,10], CEP [1], CPAR [17], CMAR [8] and HARMONY [19]. CAEP uses EPs with high growth rate to do classification. iCAEP aggregates the prediction power of EPs based on information theory. PCL uses only JEPs. JEPs occur in one and only one class, which may be too restrictive in some cases. CEP relaxes this constraint by putting an upper bound on the number of occurrences of the EPs in other classes. CPAR uses the expect ed accuracy to select classification rules. It compares the average expected accuracy of the best K rules of each class and chooses the class with the highest ex pected accuracy as th e predicted class. CMAR uses a weighted measure to select rules, and the score of a class is also calculated using this weighted measure. HARMONY directly mines the final set of classification rules by using an instance-centric rule generation approach.
The aggregation-based algorithms generally show better performance than other algorithms. However, the value of K is critical to their performance in many cases. Here, we use PCL as an example to study how to select proper values for parameter K to maximize the accuracy of the aggregation-based algorithms. Let I = { i 1 ,i 2 , .., i n } be a set of distinct literals called items. An itemset or apatternisasubsetof I . A transaction is a non-empty set of items. Let C = { C 1 ,C 2 , .., C k } be a set of distinct labels called class labels. A transac-tional database consists of a set of transactions associated with their labels. A classification task involves two phases: training and testing. In training, the class labels are revealed and in testing, class labels are hidden. The classifier builds a model based on the training set and uses this model to predict the class labels of transactions in the testing set. The accuracy of a classifier A is the proportion of test-instances which a re correctly classified by A .

A pattern P covers a transaction t if P  X  t . The support of P is the number of transactions that are covered by P .Weuse sup ( P, D ) to indicate the support of P in the dataset D .Weuse P | D to indicate the set of transactions in D that contain P . Given a 2-class dataset, jumping emerging patterns (JEP) are patterns whose frequency in one class is non-zero and in other class is zero. An EP i is called a JEP from class A to class B if its support in class A is zero. A pattern P is a generator if and only if for every P  X  P , sup ( P ,D ) &gt;sup ( P, D ). A JEP generator is both a generator and a JEP. 4.1 PCL We present here an overview o f PCL [9,10]. The dataset D is divided into positive and negative class es. Given a test-instance t , two sets of JEPs that JEPs that cover t are sorted in descending order of their supports. Suppose the set of JEPs (based on the training set) from negative to positive classes are EP + 1 ,EP + 2 , .., EP + n in descending order of their supports. Similarly, EP  X  1 ,EP  X  2 , .., EP  X  n is the set of JEPs from positive to negative. It is hypoth-esized that if t belongs to one class, it should contain more JEPs of this class than the other class. So Li and Wong [9] formulated the scores of t with respect to the two classes as below.
 4.2 PSM Maintenance of EPs was first introduced in [11], though a complete solution for insertion and deletion was not discu ssed. Here, we describe a more efficient method called PSM for complete maintenance introduced recently in [5]. PSM is a maintenance algorithm for frequent pattern space. It is based on the GE-tree, an effective data structure described in [6,7] for enumerating genera-tors. Frequent generators a re stored in the GE-tree an d the tree is incrementally adjusted when new transactions are added or existing transactions are removed. Each node in the tree represents a generator. To find EPs, we modify the GE-tree so that each node stores both positive and negative supports of the correspond-ing generator. In addition to frequent generators, GE-tree maintains a negative border which comprises infrequent generators whose immediate subsets are all frequent [5,6]. The negative border helps generate new frequent generators and equivalence classes efficiently when transactions are added or removed.
Computating frequent generators is expensive. The benefit of PSM is that a new set of frequent generators does not need to be computed from scratch when the data is modified. As a small change in dataset seldom causes a big change in the set of frequent patterns, PSM is e ffective for pattern space maintenance. 4.3 rPCL and ePCL A good choice of K has a big impact on prediction results in PCL. We propose a method to tackle this problem as follows. According to the Central Limit The-orem, the distribution of accuracy will behave like normal distribution. Indeed, Fig. 2 suggests the convergence of average classification accuracy in training data to the real value of accuracy in the whole dataset. So we simulate the actual pro-cess of classification in training set and choose the value of K that maximizes the mean accuracy. The simulation is ru n repeatedly to determine which value of K appears as the best on average. By the Central Limit Theorem, the average accuracy of each K approaches the true a ccuracy of that value of K, given suf-ficient number of simulation runs. Thus, the value of K that has the best mean accuracy in the simulation runs will also perform well in the whole set of data.
We describe two algorithms rPCL and ePCL. Algorithm rPCL is a direct but naive solution for the method above. We use it as a benchmark to understand where inefficiencies might be and to ass ess the improvement of a more efficient method using maintenance. ePCL is th e fast version where PSM is used. It produces the same results as rPCL but runs many times faster.
In rPCL (Fig. 3) we use a technique called repeated random sub-sampling validation as a framework to assess the best parameter for PCL. It involves several rounds, in each round the training set is randomly divided into new complementary testing and training set . For each K, we perform this procedure to determine the expected accuracy of the classifier wrt this K. The chosen K is the one which returns the best average a ccuracy over these runs. 10-fold cross validation is popular for accessing cla ssifier performance. So, we subsample 10% of training set as testing subsample and 90% as training subsample.
 In rPCL, makeDecision simply d ecides if the classifier with Score K [ t, +] and Score K [ t,  X  ] correctly predicts the class of t , wrt to the current K. At step 9, we can compute Score K [ t, +] from Score ( K  X  1)[ t, +] in constant time. To achieve this, we use a vector to store Score K [ t, +] and Score K [ t,  X  ] for all t  X  Dt .To determine a good value of K, a significantly large number of iterations maxtime is performed and all values of K in the range 1..maxK are considered.
Constructing a set of frequent EPs from the training set (step 4) is compu-tationally very expensive. It involves frequent pattern mining. And this step is repeated many times with different Dt and Dn. Because the testing-training sep-arations are largely similar among all the runs, we should not need to construct the set of EPs from scratch in such a naive fashion. PSM [5,6] is used to achieve this purpose. PSM allows us to adjust the set of frequent patterns when the training fold is changed. We only need to construct the frequent patterns space at the beginning and repeatedly use PSM to maintain the set of rules when the sub-sampling folds are changed. That is, we only need to mine frequent patterns once at the beginning. With this innovation, we present an improved algorithm called ePCL (Fig. 4) which stands for enhanced PCL.

The set of frequent generators are incrementally maintained. Line 5 and 17 show the execution of PSM: PSM.delete is invoked when a fold is removed from the training set and PSM.add is invoked to add this fold into original set. That eliminates building a new set of frequent patterns when we run the simulation with a new testing-training separation. Fig. 5 is the workflow of rPCL and ePCL. 4.4 Complexity Analysis We compare the theoretical improve ment of ePCL from rPCL. In rPCL, the outer loop repeats maxtime, which is the number of runs needed to find the best K. In each loop, we need to run PCL classifier which involves a frequent pattern mining step ( FPM ) and evaluation for all K from 1 to maxK. The total time is maxtime  X  ( FPM + PCL ( maxK )). PCL ( maxK ) is the time to compute scores for K =1 ..maxK . This step evolves visiting entire frequent pat-tern set to get the top K patterns and co mpute scores accordingly for each test instance. In ePCL, we only need to build fr equent patterns once and incremen-tally adjust the pattern space. The total time is FPM + maxtime  X  ( | D | / 10  X  maintenance + PCL ( maxK )), where maintenance is the running time for main-taining one transaction, | D | is the size of the dataset. According to [5], PSM is much more efficient than mining-from-scratch algorithms. At 10% of the data size, the speed-up is at least 3 times fast er for incremental and 5 times faster for decremental maintenance than mining from scratch. 5.1 Experiment Setup Experiments are conducted using 18 data sets of various sizes from UCI reposi-tory. Continuous attributes are discretized by the entropy method. Table 1 gives details of these data sets. We evaluate the performance on two-class datasets. For multi-class datasets, we select one class as positive and the remaining as negative. The process is done for all classes. PCL ca n be extended to handle multiple-class datasets; however, the method of choosing parameter is still applicable. 10-fold cross validation is used to assess the e fficiency and average accuracies are re-ported. The datasets are separated in such a way that the proportion of each class is consistent in both testing and training.

For the original PCL, we use the frequent pattern mining algorithm provided by [13]. The experiments are done in Windows machine with 2.6 GHz processor and 1G memory. We assess the accuracy improvement of rPCL over PCL and running time comparison of ePCL and rPCL. Time is measured in seconds.
When we compute the score of an instance in two classes, it is possible that the scores are both zero. Such a test-instance is not covered by any pattern and therefore unclassifiable by both PCL and ePCL. The average percentage of unclassified data is 11% and there is no dataset with more than 20%. We do not include these cases in our accuracy comput ation. The purpose is to evaluate the improvement of rPCL over the original PCL only.
 5.2 Parameters Setting All the patterns used in PCL and its improved versions are JEP generators [10]. The exception is an early paper [8]; it uses the  X  X oundary X  JEPs, which are defined in [9] as those JEPs where none of their proper subsets are JEPs. Here, we use JEP generators as discriminative patterns because:  X  It is known that the JEP space is partitioned into disjoint equivalence  X  The minimum description length princip le is a well-accepted general solution  X  JEP generators are efficient to comput e. We can make use of many efficient For rPCL and ePCL, we set maxtime to 50 and we run K in a range from 1 to 50. We limit the range to 50 because small-frequency patterns have minimal prediction power over the top ones. Patterns ranked higher than 50 generally have low support. As shown in Fig. 1, the predictions stabilize after K = 50, so no need to consider K&gt; 50. For original PCL, we use K = 10 as suggested in [9]. Minimum support is set to make sure enough EPs are found. 5.3 Efficiency PCL with generators and boundary EPs. For PCL, we have choices over which type of frequent patterns are used to make predictions. We have done experiments to justify our choice of JEP generators, as suggested in [9], rather than boundary JEPs. We want to test the robustness of PCL in the case of noise with these two types of patterns. When a part of the original dataset is missing, the noisy dataset reduces the accuracy of the classifier. Fig. 6 shows accuracy of PCL with generators (gen PCL) and boundary JEPs (boundary PCL) for different levels of missing rate (We assume items in the dataset are missing with certain rate): 0%, 10%, 20%, 30%, 40% and 50%. The accuracies are average over 18 datasets. Gen PCL is less noise-sensitive than boundary PCL. PCL and ePCL. We compare the accuracy of the original PCL and ePCL.
 Since rPCL and ePCL give the same res ults, we do not show the accuracy of rPCL here. Table 2 shows accuracy of ePCL and the original PCL in 18 datasets. Overall, the improvement is 3.19%. In some datasets like Promoters, Wine and Hepatitis, we get improvement of 26%, 11% and 15% respectively.

Recall in PCL, to classify one test ins tance, one score is computed for each class. Some instances recei ved zero score in one class and non-zero score in the other class; thus the association rules vote unanimously to one class. We call these the easy cases and the rest are difficult cases. The value of K has a much greater impact on the difficult cases. Table 3 sh ows the accuracy of original PCL and ePCL in difficult cases. Although we do not show statistics for easy cases here, the accuracy is close to 100% for most easy cases. We do not show datasets with too few difficult cases since there are not enough samples to evaluate accurately. Performance. We compare the running time of rPCL, ePCL and original PCL. The performance of ePCL compared to rP CL is good, demonstrating the supe-riority of using pattern maintenance. Table 4 shows that ePCL is an order of magnitude faster in many cases. In one c ase (vehicle.dat), rPCL could not com-plete after more than one day, but ePCL completed within 4 hours. Nevertheless, ePCL takes more time than PCL due to the repeating part; fortunately, this is compensated by the much better accuracy of ePCL.
 Cross-validation is a technique to assess the performance of classification algo-rithms. Typically the testing set is much smaller than the training set and a classifier is built from the training set which is largely similar between runs. Our framework of maintenance can be applied to efficiently perform cross-validation for pattern-based classification. Recall PSM allows us to maintain the set of frequent generators while adding or deleting a relatively small portion of the dataset. We only need to maintain a single frequent pattern set and incremen-tally adjust using PSM. In addition, for more efficient computation, PSM can be extended to handle multiple additions/deletions at the same time by organizing transactions in a prefix tree.

We showed the importance of finding the top K patterns for PCL. We intro-duced a method to perform the task efficiently, making use of the PSM main-tenance algorithm [5]. The maintenance framework can be applied to general cross-validation tasks which involve frequent update of the pattern space. Our experiments showed improvement in accuracy. However, we compromised on complexity. We hope to get a better implementation for ePCL, thus minimiz-ing the running time to close to original PCL and implement the mentioned extensions.

