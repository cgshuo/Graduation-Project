 Sensing technologies such as Radio Frequency IDentification(RFID) have been widely used in modern monitoring applications, such as logistics and supply chain management, asset tracking and activity monitoring. Their successful deploy-ments require primitive events to be correlated and transformed into meaningful complex events that reach a semantic lev el appropriate for end applications.
The technique of complex event processi ng(CEP) has been extensively studied in the context of active databases [1] and message-based systems [2] in the past. However, these methods are not suitable to process modern monitoring systems due to huge-volume/velocity and complicated event attribute constraints.
Existing CEP approaches [3][4][5] mainly focus on sequence patterns. They assume the events are ordered by their timestamps and exploit NFA to achieve high-performance processing. Even though sequence represents an important class of complex event pattern, boolean pattern is more general and has many applications: Example 1. In an emergency alarming application, an event detection is usually based on a fusion of multiple sensed values of different sensors. For instance, the occurrence of fire should satisfy the conditions such as temperature &gt; 100 o C and smoke &gt; 100 mg/L . Such composite events are represented by boolean ex-pressions.
 Example 2. In a RFID-monitored retail store, the manager is interested in the customers that visit three places(A, B and C) within one hour in whatever se-quence. This scenario can be describ ed by the following complex event: ( a and b and c ) satisfying ( a.location = A )and( b.location = B )and( c.location = C ) and ( a.customerID = b.customerID = c.customerID ) within one hour. The at-tribute location represents an event X  X  occurrence place and customerID identi-fies an event X  X  corresponding customer.
 Example 3. In stock trading, an abnormal fluctuation on the prices of a stock can be detected by complex event pattern s. For instance, consider the scenario that stock A X  X  price rises by more than 10 percent within 10 minutes and falls more than 5 percent within the next 10 minutes. It can be described by the a .time +10 minutes )and( a 2 .time &lt; a 3 .time  X  a 2 .time +20 minutes )and ( a 2 .price tion, a i represents a trading event on stock A , the attribute time is its trading time and price is its trading price.
 In this paper, we study the issues of processing complex events modeled as boolean expressions. Our solution is based on pseudo-NFA. Compared with the traditional NFA which tracks the state transfer of complex events, pseudo-NFA tracks the state transfer of primitive events. As a pseudo-NFA may have multiple valid state transfer routes, we further study the optimization problem of how to identify the state transfer route which minimizes the overall evaluation cost.
The contributions of this paper are summarized as follows: 1. We propose an efficient evaluation approach based on pseudo-NFA for the general boolean model. 2. On the problem of pseudo-NFA optimization, we present a dynamic pro-gramming algorithm to compute the optimal evaluation roadmap for tree-structured pattern. 3.Our extensive experiments on synthetic and simulated sensing data demon-strate that the proposed techniques perform considerably better than existing alternatives.
 The rest of this paper is organized as follo ws. Related work is discussed in Section 2. We introduce the boolean complex event model in Section 3. The general pseudo-NFA evaluation approach and its optimization is described in Section 4 and Section 5 respectively. The experim ental study is presented in Section 6. Finally, we conclude this paper with Section 7.
 Complex event processing has been previously studied in active databases and message-based systems [1]. However, the presence of attribute value comparison constraints and sliding windows in the complex event specifications for modern monitoring applications makes these traditional processing frameworks no longer applicable.Data structures, such as tree[1], finite automata[6], cannot flexibly ac-commodate the necessary extensions to trad itional complex event specifications.
Early work on complex event processing for modern monitoring applications include Berkeley X  X  HiFi project [7] and Si emens RFID middleware [8]. In the HiFi system, complex event processing was used to support efficient aggregation of data generated by distributed intercepto rs. Complex event processing in Siemens middleware used the graph computation model to transform raw RFID readings into semantic data. Unfortunately, neither HiFi nor Siemens RFID middleware provides the necessary techniques to opti mize huge-volume event processing.
In [3], Eugene et al. proposed a declarative specification language SASE for complex events and presented a corresp onding evaluation framework based on NFA. Their work addressed the optimization issues of huge-volume event pro-cessing. The Cayuga project at Cornell [9] also defined its own complex event language and provided a variant of NFA for event evaluation. Note that the effec-tiveness of the SASE and Cayuga techniques depends on the sequential structure of event pattern. They do not support boo lean event pattern. More recently, [10] proposed a CEP system called ZStream which is supposed to support efficient complex event processing. Its tree-based query plans mainly target sequence patterns and can not be directly applied on boolean model either. where type denotes event type, id is event identifier, and attr i (1  X  i  X  k ) denotes the value of the i th attribute of an event. For instance, for an RFID event, event type is the reader location. Tag identifier and reading timestamp as well as other information are all its event attributes. Some of the denotations used by this paper are summarized in Table 1.
 Definition 1. A boolean complex event pattern is defined in the following re-cursive way: (1) Any singular event type is a valid pattern. operators ( and , or and not )andeach E i represents a valid pattern. Besides pattern, complex event specification may involve attribute value com-parisons between events and have a time window within which all events are supposed to occur. Formally, a boolean complex event is specified by the follow-ing syntax: In a boolean complex pattern, an attribute value comparison has the format ison operators ( &lt; , &gt; ,=,  X  ,  X  ,and =). We suppose that the comparison condi-tions can only be specified on the same attribute, and multiple comparisons are connected by boolean operators . A time window can be specified on a pat-tern connecting the events by the and operator. Semantically, the specification type ( e i )= E i (1  X  i  X  k )and max { e i .timestamp } -min { e i .timestamp } X  w .
On complex event specification, boolean is a more powerful expression model than sequence. A sequence complex event specification { SEQ ( E 1 ,E 2 ,  X  X  X  ,E k ) WITHIN w } can be transformed into an equivalent boolean one: PATTERN and ( E 1 ,E 2 ,  X  X  X  ,E k ) WHERE E 1 .timestamp &lt; E 2 .timestamp &lt;  X  X  X  &lt;E k .timestamp
WITHIN w
The basic boolean transformation rule: implies that any boolean expression can be transformed into the format of tors. It is observed that each E i within the or boolean operator can be evaluated independently. We model an and boolean expression consisting of singular event types by a graph , in which each node represents an event type and an edge be-tween two nodes corresponds to an attribute value comparison constraint. An example of boolean complex event specification and its corresponding tree model is shown in Figure 1. In this section, we present the evaluation approach for the case where the at-tribute value comparisons between even ts of a boolean pattern involve only one attribute. Our solution is based on pseudo-NFA. We first define pseudo-NFA, and then present the evaluation approach for tree boolean pattern. 4.1 Pseudo-NFA Pseudo-NFA is defined on tree boolean pattern. It characterizes a primitive event X  X  state evolvement process from its initial state to its final state. A primi-tive event X  X  state corresponds to its matching status on a complex event pattern. Given a tree pattern P , the possible states of an A event a i include any con-nected sub-tree of P rooted at the node A .Anevent a i is in the state of P if and only if there is at least one complex event instance which includes a i and matches P . For instance, on the tree pattern P =( A -B -C ), an A event can be in the state of ( A ),( A , B )or( A , B , C ).

Figure 2(a) show the pseudo-NFA cons truction process of a specific event type. An example is also presented in Figure 2(b). Since a primitive event can be a component event in several complex event instances, it may be in different states simultaneously. For instance, in Figure 2(b), a B event b i canbeinboth states of ( BCD )and( BCE ). The event b i may be correlated with two C events, c and c k , whose states are ( CD )and( CE ) respectively. 4.2 Evaluation Approach for Tree Boolean Pattern For tree boolean pattern evaluation, we suppose attribute value comparison is represented as ( E i .attr k op E j .attr k ), where op is one of the five comparison each edge on tree pattern T . Additional symbol denotations used by this section are summarized in Table 2 Basic Pseudo-NFA Approach. We store the same type of events in a B+-tree ordered by their attribute values. Each entry in the B+-tree has a data structure recording its corresponding event X  X  state information. Suppose a event node A is directly connected with n nodes, E 1 ,E 2 ,  X  X  X  ,E n , on a tree pattern P . A newly arriving event a i is processed by the following steps: Step1. Insert a i into the B+-tree of A and determine a i  X  X  state.
 Step2. Update the events states directly or indirectly correlated with a i .
Step3. If a i is in its final state, generate and output the corresponding com-plex event instances including a i .
 Step1 can be accomplished by performing s earch operations on the relevant B+-trees. We describe how to perform state transfer on the event a i .Weuse P j to denote the resulting subtree rooted at E j (for 1  X  j  X  n ) after cutting all the edges of A on the tree pattern P and use S ( j ) to denote the set of distinct states a the states of a i are computed as: where  X  P j S ( j ) projects each state in S ( j ) on the subtree P j .
Step2 propagates the event a i  X  X  new states to other events directly or in-directly correlated with a i . It repeatedly performs state transfer on the events directly correlated with an event whose states have transferred. Consider an E j event e jk directly correlated with a i .

In Step3 , the result is output in a recursive way: (1)for each edge ( A -E j )(for 1  X  j  X  n )on P , the algorithm identifies all the E (2)for each e jk event, compute its complex event instances matching P j ; (3)the event a i is correlated with the complex event instances computed in the previous step to generate the final complex event instances matching P . A pseudo-NFA of an event type A on a tree pattern P specifies all possible state transfer routes taken by an A event to reach its final state ( P )asshown in Figure2(b). In this section, we propose an approach to optimize the event state transfer roadmap of a pseudo-NFA. It partitions P into multiple (probably nested) subtrees, each of which corresponds to an evaluation block. For instance, in the first case of Figure 3, P 1 represents the block ( A -B )and P 2 represents the block ( P 1 -C ). In the second case, the node C is grouped with node D to constitute a new block P 3 . In both cases, there is only one state transfer route for the B events.

For simplicity of presentation, we use P =(( A -B )-C ), where ( A -B )isablock, as an example to illustrate the evaluation approach for tree pattern with defined blocks. Whenever a new C event c i arrives, the algorithm first correlates c i with the B events in the state of ( A, B ). The algorithm then determines the states of c and output the results if necessary.
 Whenever a B event b i arrives, the algorithm first searches its corresponding A events. There are two possibilities: (1) No A event is correlated with b i . In this case, the algorithm does not need to search C events according to pseudo-NFA. (2)Atleastone A event is correlated with b i . In this case, the algorithm should continue to search the C events correlated with b i .Ifno C event is correlated ( A, B, C ) and output the matching results.
 Whenever an A event a i arrives, the algorithm first searches its corresponding B events. If there is no B event correlated with a i , the algorithm exits to process next event. Otherwise, it processes these B events sequentially and updates a i  X  X  states accordingly: (1) If the current B event b j is in the state of ( B ), the algorithm continues to search the C events correlated with b j and updates b j  X  X  state accordingly. it does not need to search the C events correlated with b j .
 We now compare the evaluation efficiency of P 1 =( A -B -C )withthatof P 2 =(( A -B )-C ). We use num ( P i ) to denote the total number of complex event instances matching P i ,by | P i | in this section. According to the pseudo-NFA evaluation approach described in Sectio n4.2, Step 1 of evaluating P 1 invokes totally ( | A | + 2 | |
C | ) searches, where Set ( AB ) denotes the set of complex event instances match-ing the pattern ( AB )and  X  is the project operator. Since |  X  B Set ( AB ) | X | B | , evaluating P 2 invokes no more searches than P 1 . Note that state transfer only needs to be performed at the B events because the event nodes A and C are leaves on P 1 and P 2 .On P 1 , the pseudo-NFA of B events has two state evolve-ment routes: (( B )  X  ( AB )  X  ( ABC )) and (( B )  X  ( BC )  X  ( ABC )). Its total number of executed state transfers is ( ns b ( AB )+ ns b ( BC )+ ns b ( ABC )), in which ns b ( P ) represents the number of the B events that are in the state of P after the whole evaluation process. On P 2 , the pseudo-NFA for B events has only one state evolvement route: (( B )  X  ( AB )  X  ( ABC )). Its total number of performed on P 2 is therefore less than or equal to that performed on P 1 . 5.1 A Dynamic Programming Evaluation Approach Suppose a tree pattern P consists of two blocks ( P 1 -P 2 ), where node A and B are the boundary nodes in the blocks P 1 and P 2 respectively, we have the following lemma: Lemma 1. On a tree pattern P ,if P =( P 1 -P 2 ), in which P 1 and P 2 are two separate blocks, is the optimal evaluation roadmap for P , the block structure within P 1 should also be the optimal evaluation map for P 1 . This is similarly true for P 2 .
 Lemma 1 assures the optimality of a sub-structure solution within a global opti-mal solution. The optimal evaluation roadmap for P therefore can be computed by a dynamic programming approach. The optimal evaluation roadmap for a subtree of a boolean pattern of size j is computed as follows:
P j is partitioned into two subtrees whose sizes are less than j . For each such partitioning, compute the expected cost of its corresponding evaluation roadmap as described above. The one with the minimal cost is selected to be P j  X  X  optimal evaluation roadmap. Note that there are in total ( j  X  1) possible partitions, each of which corresponds to deleting an edge on P j . 6.1 Experimental Setup We have tested the performance of the proposed pseudo-NFA approaches on two datasets: synthetic sensing data and simulated RFID data.
 Synthetic Sensing Data. Each synthetic primitive event has an attribute in-dicating its event type, an attribute recording its timestamp and two sensing attributes, ( attr 1 , attr 2 ), which are used to specify the attribute value com-parison constraints on tree patterns. Suppose there are four interesting event randomly within a preset interval.
 Simulated RFID Data. We simulate customer X  X  moving route in an RFID enabled retail store. Four locations are denoted by ( A , B , C , D ). A customer X  X  moving route is simulated by a walk on the complete graph consisting of four nodes. The elapsed time of moving between two locations are randomly set to be within an interval [ t 1 ,t 2 ]. Supposing the four locations constitute a square in graph, we set the elapsed time intervals of moving between two locations as follows: (AB)=(AC)=(BD)=(CD)=[9, 11], (AD)=(BC)=[13, 15]. The corre-sponding complex event pattern is specified as follows: We measure evaluation efficiency by two metrics: CPU time, number of event searches which accurately quantify algorithm efficiency. We conduct the following comparative experiments to verify the e ffectiveness of the proposed pseudo-NFA approaches: 1. Pseudo-NFA vs Stream Join[11]; 2. Pseudo-NFA Optimization, Basic Manner vs Block manner; All the experiments are performed on a computer with Pentium(R) 4 CPU 2.8 GHz running on Windows XP and implemented in Visual C++. 6.2 Pseudo-NFA vs. Stream Join We have implemented Stream Join algorithm in [11] and compared it with our method. On the synthetic event streams, we evaluate the chain tree pattern P =( A -B -C -D ) in which the attribute value comparison constraints are specified on the attribute attr 1 with (( A = B ) and ( B&lt;C ) and ( C = D )). Because of high volume and velocity of modern monitoring applications, we study these two evaluation approaches X  scalability by measuring their performance variation with event stream size. The evaluation efficiency comparisons on the synthetic event streams and RFID event stream are presented in Figure 4 (a)-(d). In term of both search and event searches, the pseudo-NFA approach performs considerably better than stream join because search and traversing cost of stream join depend on the sizes of its intermediate evaluation results. The performance of pseudo-NFA is instead independent of such intermediate evaluation results. 6.3 Pseudo-NFA Optimization Techniques In this subsection, we investigate the effectiveness of the roadmap optimiza-tion techniques in speeding up pseudo-NFA evaluation. The tested tree pattern on the synthetic event streams is P 1 =( A -B -C -D ) with constraints (( A = B ) and ( B&lt;C )and( C = D )) specified on the attribute attr 1 .On P 1 ,wetest four evaluation roadmaps : P 11 =( ABCD ), P 12 =(( AB ) CD ), P 13 =((( AB ) C ) D ) and P 14 =(( AB )( CD )) respectively. To test pseudo-NFA optimization X  X  sensi-tivity to edge selectivity on tree patterns, we use two types of synthetic event streams with sel ( A  X  B )=0 . 05 and sel ( A  X  B )=0 . 2, in which sel ( A  X  B )=  X  means that only (  X   X  100) percentage of the B events have their corresponding A events. The tested tree pattern on the RFID event stream is P 2 =( A -B -C -D ). We tested three evaluation roadmaps : P 21 =( ABCD ), P 22 =(( AB ) CD )and P 23 =(( AB )( CD ))respectively.

The evaluation efficiency comparisons on the synthetic event streams are pre-sented in Figure 5 (a)-(d). It is obser ved that on all three cost metrics, the evaluation roadmaps P 13 and P 14 perform better than P 12 , which in turn per-forms better than P 11 .

The block evaluation manner of P 14 therefore saves more search and traversing cost than P 13 . It is also observed that the perfor mance discrepancies in the case of sel ( A  X  B )=0 . 05 are more striking than in the case of sel ( A  X  B )=0 . 2. In the case of sel ( A  X  B )=0 . 05, the percentage of the B events satisfying ( A = B ) is lower.

The evaluation results of P 2 on the simulated RFID event stream are presented in Figure 5 (e)-(f). Similarly, both P 22 and P 23 perform better than P 21 on the three cost metrics. The attribute comparison constraints of P 2 are more rigorous than those of P 1 . The number of complex event instances matching P 2 is therefore less than that of complex event instances matching P 1 . Measured by percentage, the saved cost of search and event access on P 2 as a result of the block evaluation appears to be larger. In this paper, we have proposed a cost model and the pseudo-NFA evaluation approaches for boolean complex events . We also present effective algorithms to optimize the pseudo-NFA evaluation roadmap. Our extensive experiments have demonstrated the efficiency and effectiveness of the proposed pseudo-NFA approaches.

Several interesting problems remain to be investigated in future work. Firstly, the presented solutions to graph model and multi-dimensional attribute com-parison evaluation are only preliminary. The CEP evaluation in these cases has potential to be further optimized. Secondly, aggregation operators have been shown to be important to expressivity of sequential complex event specification. How to incorporate them into boolean model and process them efficiently is also a challenging problem.
 Acknowledgments. This work was mainly completed when the first author was studying in northwestern polytechnical university, thanks professor Chen Qun and Li Zhanhuai X  X  supervision. This work is sponsored partially by Na-tional Natural Science Foundati on of China (No. 61033007,No. 61003142 and No. 61262058) and Project(KYTZ201313) supported by the Scientific Research Foundation of CUIT.

