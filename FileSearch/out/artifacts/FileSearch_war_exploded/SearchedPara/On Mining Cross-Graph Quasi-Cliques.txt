 Joint mining of multiple data sets can often discover intere sting, novel, and reliable patterns which cannot be obtained solel y from any single source. For example, in cross-market customer se gmen-tation, a group of customers who behave similarly in multipl e mar-kets should be considered as a more coherent and more reliabl e cluster than clusters found in a single market. As another ex am-ple, in bioinformatics, by joint mining of gene expression d ata and protein interaction data, we can find clusters of genes which show coherent expression patterns and also produce interacting proteins. Such clusters may be potential pathways.

In this paper, we investigate a novel data mining problem, min-ing cross-graph quasi-cliques , which is generalized from several interesting applications such as cross-market customer se gmenta-tion and joint mining of gene expression data and protein int erac-tion data. We build a general model for mining cross-graph qu asi-cliques, show why the complete set of cross-graph quasi-cli ques cannot be found by previous data mining methods, and study th e complexity of the problem. While the problem is difficult, we de-velop an efficient algorithm, Crochet , which exploits several inter-esting and effective techniques and heuristics to efficacio usly mine cross-graph quasi-cliques. A systematic performance stud y is re-ported on both synthetic and real data sets. We demonstrate s ome interesting and meaningful cross-graph quasi-cliques in b ioinfor-matics. The experimental results also show that algorithm Crochet is efficient and scalable.
 Categories and Subject Descriptors: H.2.8 [Database Applica-tions]: Data Mining General Terms: Algorithms, Performance.
 Keywords: Graph mining, mining multiple data sets, quasi-cliques, bioinformatics.  X  This research is supported in part by NSERC Grant 312194-05, NSF Grants IIS-0308001 and DBI-0234895, and NIH grant 1 P20 GM067650-01A1. All opinions, findings, conclusions and rec om-mendations in this paper are those of the authors and do not ne ces-sarily reflect the views of the funding agencies.
 Copyright 2005 ACM 1-59593-135-X/05/0008 ... $ 5.00.
In many applications, data is often collected, organized an d stored in multiple sources. Many hidden patterns crossing multipl e pieces of data cannot be found by mining only one single data set. The re-fore, the advanced data analysis in practice calls for joint mining of multiple data sets , which can often discover interesting, novel, and reliable patterns that cannot be obtained solely from an y single source.
 CUSTOME R SE GME NTAT ION ). In marketing and customer relation management, customer segmentation is an important task, wh ich partitions customers into groups according to their market behav-ior such as their purchase records and their responses to mar keting campaigns. Customer segmentation in a single market has bee n ex-tensively studied. However, it is interesting and informat ive to ex-plore cross-market customer segmentation , which identifies groups of customers who have similar behavior in multiple markets. Cus-tomer groups found in cross-market customer segmentation c an be more coherent and more reliable.
 Consider the market behavior of six customers, Ann, Bunny, Cathy, Deborah, Ellen and Frank, in two markets, the financia l product market and the consumer product market. In a specific market, the similarity among customers in market behavior c an be modeled as a similarity graph. Each customer is a vertex in th e graph, and two customers are connected by an edge if their beh av-ior in the market is similar enough. Figure 1 shows the simila rity graphs in the two markets. Figure 1: The similarity graph of six customers in two market s.
A close look at both similarity graphs may find that the sub-graphs induced by the group of customers S = { Ann, Bunny, Cathy, Deborah, Ellen } in both similarity graphs are interesting: they are quasi-cliques (i.e., the subgraphs are almost cliq ues). In each similarity graph, each customer in S is similar to at least out of the 4 customers in the group. This observation may strongly suggest that S is a coherent and reliable customer group.
Example 1 motivates a novel problem of mining multiple graph s as follows. Consider multiple graphs about a set of objects w hich are the vertices of the graphs. We are interested in finding gr oups of objects such that the induced subgraph of each group of obj ects in each graph is almost a clique (thus called quasi-clique)  X  that is, in every graph, each object in a group is connected to at le ast a portion  X  (0 &lt;  X   X  1) of the other objects in the same group, where  X  is a user-specified parameter. We call the problem mining cross-graph quasi-cliques .

Mining cross-graph quasi-cliques and its variations appea r in many applications. We present below another interesting ex ample in bioinformatics  X  joint mining gene expression data and pr otein interaction data.
 From the gene expression data, we can find co-expressed genes , which are groups of genes that demonstrate coherent pattern s on samples or against stimuli. On the other hand, from the prote in interaction data, we can find groups of proteins which freque ntly interact with each other.

Genes and proteins are related  X  a protein is a product of a gen e (however, one gene can produce more than one protein). If we c an conduct a joint mining of both gene expression data and prote in interaction data, then we may find the clusters of genes that a re co-expressed and also their proteins interact.

Such cross-data set clusters found from the joint mining are in-teresting and meaningful in bioinformatics. First, both th e gene expression data and the protein data are often very noisy. Cl us-ters in a single source are often unreliable. The clusters co nfirmed by both data sets will strongly indicate the correlation/co nnection among the genes in a cluster, and thus are more reliable. Seco nd, al-though highly related, gene expression data and protein int eraction data still carry different biological meaning. The coincid ence of co-expressed genes and interacting proteins is biological ly signifi-cant. As indicated in [25], many pathways exhibit two proper ties: their genes exhibit a similar gene expression profile, and th e protein products of the genes often interact.

Technically, the gene expression data and the protein inter ac-tion data can be modeled using a gene coherence graph a protein interaction graph G p , respectively. In the gene coherence graph G g , vertices are genes, and two genes are connected if their expression patterns are similar according to a user-specifi ed simi-larity measure (e.g., Euclidean distance, Pearson X  X  corre lation coef-ficient, KL-distance [19], or pattern-based similarity mea sures [7, 29]). In the protein interaction graph G p , the vertices are proteins, and two proteins are connected if they interact with each oth er. We use a surjective (i.e., onto) mapping m ( p ) = g from proteins to genes to model the relationship between genes and proteins.
A group of proteins is interesting if each protein in the grou p interacts with most of the rest of the proteins in the same gro up, and in the set of genes producing the group of proteins, each g ene is similar to most of the rest of the genes in the same group. Th ey are cross-graph quasi-cliques .

As shown, mining multiple graphs may discover interesting p at-terns that cannot be found by conventional data mining appro aches. Finding cliques in a graph is a problem that has been investig ated for a long time. Computing quasi-cliques in one graph was als o the topic of some recent studies, such as [1, 21]. One may won-der,  X  Can the complete set of cross-graph quasi-cliques be mined easily by extending the existing algorithms for finding cliq ues or quasi-cliques in an  X  X ntegrated X  graph?  X  FROM AN INT E GRAT E D GRAPH ?). A natural thinking may be as follows. We can integrate the multiple graphs into one based on Figure 2: An integrated graph based on a weighted sum sim-ilarity function. The thick edges are of weight 2 and the thin edges are of weight 1 . a similarity function between data objects. The integrated similar function combines the similarity between data objects in di fferent data sets in some weighted manner. Then, we can find quasi-cli ques in the integrated graph.

Consider the two graphs in Example 1 again. Figure 2 shows an integrated graph based on a weighted sum similarity funct ion. Any two objects are connected by an edge in the integrated gra ph if there is an edge between those two objects in either G Figure 1. The weight of an edge is 2 if the edge appears in both and G c , otherwise, the weight is 1 .

From the integrated graph, we cannot observe the group S = {
Ann, Bunny, Cathy, Deborah, Ellen } as a cluster. If we only con-sider all edges with weight 2 , each of Ann, Bunny, Deborah and Ellen only connects to 2 of the other customers in S . If we con-sider all edges with weight 1 or above, then the 6 customers form a clique. Therefore, the integrated graph method does not wor k!
Although there are extensive studies on cliques and some rec ent studies on quasi-cliques, to the best of our knowledge, our s tudy is the first one to address the following two issues at the same ti me.
Mining the complete set of quasi-cliques from multiple grap hs is challenging. A na  X  X ve method may have to examine a huge num -ber of possible combinations of vertices and edges over the g raphs, which is computationally expensive or even prohibitive on l arge graphs (e.g., graphs with thousands of vertices and tens of t hou-sands of edges).

Bearing the above challenges, in this paper, we tackle the pr ob-lem of mining cross-graph quasi-cliques and make the follow ing contributions.
The remainder of the paper is organized as follows. In Sectio n 2, we present the general model of mining cross-graph quasi-cl iques, and also show the complexity of the problem. The algorithms a re developed in Section 3. A systematic performance study is re ported in Section 4. We discuss related work in Section 5. Section 6 c on-cludes the paper.
In this section, we propose a general model for cross-graph q uasi-clique mining and show the complexity of the problem.
In this paper, we consider simple graphs only, i.e., the graphs without self-loops or multi-edges. For graph G , V ( G ) denote the sets of vertices and edges of G , respectively.
For vertices u, v  X  V ( G ) , let d ( u, v ) be the number of edges in the shortest path between u and v . Trivially, d ( u, u ) = 0 is called connected if d ( u, v ) &lt;  X  for any u, v  X  V ( G )
For a vertex u  X  V ( G ) , N ( u ) is the set of neighbors of N ( u ) = { v | ( u, v )  X  E ( G ) } . Moreover, we define { v | d ( u, v )  X  k } for ( k  X  1) . Clearly, N ( | V ( G ) | X  1) set of vertices that are connected to u . We also denote the set by N  X  ( u ) . In a connected graph, N  X  ( u ) = V ( G ) .

In graph G , let U  X  V ( G ) be a subset of vertices. The sub-graph induced on U , denoted by G ( U ) , is the subgraph of vertex-set is U and whose edge-set consists of all edges in have both endpoints in U , i.e., G ( U ) = ( U, E U ) , where { ( u, v ) | ( u, v )  X  E ( G )  X  u, v  X  U } .

A complete graph is a graph such that every pair of vertices is joined by an edge. In a graph G , a subset of vertices S  X  V ( G ) is a clique if the subgraph induced on S , i.e., G ( S ) , is a complete graph, and no proper superset of S has this property. Please note that, there can be more than one clique in a graph, and the cliq ues may not be exclusive. That is, two cliques may share some comm on vertices.
 CL IQUE ). A connected graph G is a  X  -complete graph (0 &lt;  X   X  1) if every vertex in the graph has a degree at least  X  ( | V ( G ) | X  1)
In a graph G , a subset of vertices S  X  V ( G ) is a  X  -quasi-clique (0 &lt;  X   X  1) if G ( S ) is a  X  -quasi-complete graph, and no proper superset of S has this property.

Clearly, a 1 -quasi-complete graph is a complete graph, and a quasi-clique is a clique.

The degree of a vertex must be an integer. A  X  -quasi-complete graph G must be connected. That is, necessarily,  X  ( | V ( G ) | X  1)  X  1 . Hence, we have  X   X  1 | V ( G ) | X  1 . Moreover, we have the following result.
 GRAPHS ). In a graph G , let S  X  V ( G ) . If G ( S ) is a complete graph, then, for any subset S  X   X  S , G ( S ) is also a complete graph.
In general, the anti-monotonicity does not hold for quasi-c omplete graphs. That is, for a  X  -quasi-complete graph G (0 &lt;  X  &lt; 1) G ( S ) may not be a  X  -quasi-complete graph for an S  X  V ( G ) in Figure 3. It is a 0 . 8 -quasi-complete graph, since every vertex has a degree of 4 = (6  X  1)  X  0 . 8 .

Interestingly, a subgraph induced on any subset of 5 vertices is not a 0 . 8 -quasi-complete graph. As an example, the subgraph in-duced on { a, b, c, d, e } is also shown in Figure 3. Vertices and e in the induced subgraph have a degree of 3 &lt; (5  X  1)  X  0 . 8 = 3 . 2 .

In  X  -quasi-complete graphs, parameter  X  controls the compact-ness of the graph. That is, with a larger  X  , each vertex joins to more other vertices and thus the graph is more compact. One measure of the compactness of a graph is the diameter. The di-ameter of G , denoted by diam ( G ) , is defined as ship between the diameter of a  X  -quasi-complete graph and G be a  X  -quasi-complete graph such that n = | V ( G ) | &gt; 1 The upper bounds are realizable.
 Proof sketch. When 1  X   X  &gt; n  X  2 greater than ( n  X  2) , and hence must be ( n  X  1) . Thus, complete graph and diam ( G ) = 1 .
 N ( u )  X  N ( v ) | X  n . Thus, diam ( G ) = 2 .
 vertices u, v  X  V ( G ) such that the shortest path between has length l = diam ( G ) . V ( G ) can be partitioned into if and only if d ( u, w ) = ( i  X  1) .

Clearly,  X  1  X  i  X  ( l +1) S i = V ( G ) , otherwise, diam ( G ) &gt; l critical fact is that, for any vertex w  X  S i (1  X  i  X  ( i + 1)) N ( w )  X  S i  X  1  X  S i  X  S i +1 . That means | S i  X  1  X  S | S i  X  1 | + | S i | + | S i +1 | X  deg ( w )+1  X   X  ( n  X  1)+1 have | S 1 | = 1 , | S 2 | =  X  ( n  X  1) , and | S l | + | S (otherwise, there exists at least one vertex v such that  X  ( n  X  1) ). The inequations in the theorem can be proved using the above inequations. Limited by space, we omit the details her e.
When  X  = 1 the graph can be a path, and thus diam ( G ) = ( n  X  1) . Recall that a quasi-complete graph must be connected.  X   X  1
The bounds can be shown realizable. For example, Figure 4
The theorem is important, which discloses the effect of  X  ure 5 shows the trend of diameter on  X  , where the number of ver-tices is set to 100 . We can observe the following. First, when reasonably large, i.e., 0 . 5 or up, the  X  -quasi-complete graph is com-pact, i.e., the diameter is very small, no more than 2 . Second, when  X  is small, the upper bound of the diameter of the quasi-comple te when  X  is small, the quasi-complete graph can be a series of small clusters. When  X  = 1 graph can be a path of n vertices. Based on the above analysis, a user may be often interested in quasi-complete graphs with a rea-sonably large  X  value, such as  X   X  0 . 5 or larger. In such cases, the diameter is bounded by a small integer.
Intuitively, a cross-graph quasi-clique is a maximal set of ver-tices whose induced graphs in all the graphs are quasi-compl ete subgraphs.
 a set of vertices and G 1 , . . . , G n be n graphs such that (1  X  i  X  n ) . For parameters  X  1 , . . . ,  X  n (0 &lt;  X  S  X  U of vertices is called a cross-graph quasi-clique ( CGQC for short) if G i ( S ) is a  X  i -quasi-complete graph for all and there is no proper superset of S has the property.

Clearly, in Definition 2.2, when n = 1 , a cross-graph quasi-clique on a single graph is simply a quasi-clique in the graph . There-fore, the concept of cross-graph quasi-clique is a generali zation of quasi-clique crossing multiple graphs. However, when n &gt; 1 cross-graph quasi-clique may not be a quasi-clique in any gr aph due to the maximality requirement.

E XAMPL E 5 (M AXIMAL IT Y ). Consider graphs G 1 and G in Figure 6. Suppose  X  1 =  X  2 = 0 . 5 . Then, S = { a, b, d } cross-graph quasi-clique. However, S is not a 0 . 5 -quasi-clique in either G 1 or G 2 . In G 1 , S is a proper subset of { a, b, d, e } a 0 . 5 -quasi-clique. In G 2 , S is also a proper subset of which is a 0 . 5 -quasi-clique.

A cross-graph quasi-clique can be insignificant in data anal ysis if it contains a very small number of vertices. For example, a single Figure 6: A cross-graph quasi-clique may not be quasi-cliqu es in any individual graphs due to the maximality requirement. vertex itself is a (trivial) quasi-complete graph for any such a triviality, a user may specify a minimum number of vert ices in the cross-graph quasi-cliques. Only cross-graph quasi-cliques large enough should be returned.
 Problem Definition (Mining Cross-Graph Quasi-Cliques). For a given set of graphs G 1 , . . . , G n on a set of vertices V ( G 1 ) = = V ( G n ) = U ), parameters  X  1 , . . . ,  X  1) , and a minimum size threshold min s , the problem of mining cross-graph quasi-cliques is to find the complete set of cross-graph quasi-cliques that each has at least min s vertices.

In some cases, such as joint mining of gene expression data an d protein interaction data (Example 2), the sets of vertices i n differ-ent graphs are different, and there exist mappings between s ets of vertices in different graphs. Our basic model of mining cros s-graph quasi-cliques can be extended to handle such cases.
 PING ). Let G 1 , . . . , G n be n graphs and f 2 , . . . , such that f i (2  X  i  X  n ) is from V ( G 1 ) to V ( G i rameters  X  1 , . . . ,  X  n (0 &lt;  X  i  X  1) , a subset vertices in G 1 is called a cross-graph quasi-clique with mapping ( CGQC(M) for short) if (1) G 1 ( S ) is a  X  1 -quasi-complete graph; (2) for S i = { f i ( v ) | v  X  S } , G i ( S i ) is a  X  i and (3) there is no proper superset of S has properties (1) and (2). Problem Definition (Mining Cross-Graph Quasi-Cliques with Mapping). For a given set of graphs G 1 , . . . , G n and functions . . . , f n such that f i : V ( G 1 )  X  V ( G i ) (2  X  i  X  n )  X  , . . . ,  X  n (0 &lt;  X  i  X  1) , and a minimum size threshold the problem of mining cross-graph quasi-cliques with mapping is to find the complete set of CGQC(M) X  X  that each has at least vertices.

T HE ORE M 2 (C OMPL E XIT Y ). The problem of counting the number of cross-graph quasi-cliques is in #P-Complete.
 Proof sketch. We prove by restriction. That is, we show that the problem of counting the number of cross-graph quasi-clique s con-tains a #P-Complete problem as a special case. In fact, the pr ob-lem of counting the number of cliques from one graph is in #P-Complete [14], and is a special case of the problem of countin g the number of cross-graph quasi-cliques where n = 1 and  X  = 1
Thus, the problem of mining (i.e., enumerating) the complet e set of cross-graph quasi-cliques is NP-hard in the worst case. Input: graphs G 1 , . . . , G n ;  X  1 , . . . ,  X  n ; mapping Output: the complete set of cross-graph quasi-cliques; Method: 1: in G 1 , compute the complete set of  X  1 -quasi-complete 2: for each  X  1 -quasi-complete subgraph H , in the 3: let cross-graph-quasi-clique = true ; 4: if H has a proper superset as a cross-graph 5: for i = 2 to n 6: if G i ( V ( H )) is not a  X  i -quasi-complete graph 7: if ( cross-graph-quasi-clique == true ) then
In this section, we develop algorithms for mining cross-gra ph quasi-cliques. The algorithms target at the applications w here there are a small number of large graphs. We assume that the graphs c an be held into main memory.
 We present two algorithms. The first algorithm is rudimentar y. The second algorithm, Crochet , exploits several smart and effective techniques to achieve efficient mining.
As illustrated in Examples 4 and 5, a cross-graph quasi-cliq ue may not be a quasi-clique in any graph, and an induced subgrap h on a subset of a quasi-clique may not even be a quasi-complete gr aph. Hence, we cannot find the quasi-cliques in each graph and take the intersection. Instead, we have to take a joint mining approach .
By definition, a cross-graph quasi-clique must be a quasi-co mplete graph in every graph by the mapping. Thus, a rudimentary algo -rithm works in two steps: mining G 1 and jointly mining , as shown in Figure 7.

In the first step, we mine the complete set of  X  1 -quasi-complete graphs in G 1 which have at least min s vertices. In other words, in graph G 1 , we find the subsets of vertices S such that the subgraph induced on S is a  X  1 -quasi-complete graph.

In the step of joint mining, for each subset of vertices S the first step, we check whether G i ( S ) is still a  X  i graph for all (2  X  i  X  n ) . Only maximal subsets passing the tests are output as the cross-graph quasi-cliques.

Please note that the rudimentary algorithm never searches t he complete set of quasi-complete subgraphs in all the graphs. Instead, quasi-clique must form a quasi-complete subgraph in G 1 and must be a maximal subset having the properties in Definition 2.2.
The rudimentary algorithm may not be efficient in mining larg e graphs due to two reasons. First, it still has to compute the com-plete set of quasi-complete subgraphs in G 1 , since it conducts the joint mining as the second step . If G 1 is large and dense (i.e., it has many edges), then there can be many such quasi-complete s ub-graphs. Computing all of them can be expensive. Can we compute as less quasi-complete subgraphs in G 1 as possible? {a,b,c,d} {a,b,c}
Second, the rudimentary algorithm mines the whole graphs. If that, some vertices and edges in the graphs, such as the verti ces with low degrees, cannot be a part of a cross-graph quasi-cli que or the induced subgraphs. Such parts should be pruned as earl y as possible so that the graphs can be reduced. Mining smaller gr aphs can definitely improve the efficiency. In order to reduce the g raphs, we have to consider multiple graphs at the very beginning. Can we reduce the graphs aggressively to speed up the mining?
In summary, the major drawback of the rudimentary algorithm is that it conducts the joint mining late . We need to exploit  X  X ggres-sive X  joint mining of multiple graphs.
To make our presentation clear and easy to follow, we first exa m-ine a basic case of cross-graph quasi-clique mining  X  mining from two graphs G 1 and G 2 such that V ( G 1 ) = V ( G 2 ) = U discuss how to extend the basic case to mine multiple graphs a nd handle mapping functions other than bijections.
In order to efficiently mine the complete set of cross-graph q uasi-cliques, we have to address two issues as follows. First, the correct-ness and completeness. That is, how can we find a systematic way to find all the cross-graph quasi-cliques without duplicates ? Sec-ond, the efficiency. That is, how can we find rules to prune futile search subspaces (i.e., the subspaces where there is no cros s-graph quasi-clique at all) and heuristics to speed up the mining?
To address the issue of correctness and completeness, we com -pute the complete set of cross-graph quasi-cliques by enume rat-ing the subsets of vertices systematically and pruning the u nfruitful subsets.

Given a set S of n elements and a total order  X  on S , the com-plete set of various subsets of S (i.e., 2 S ) can be enumerated sys-tematically using a set enumeration tree [24]. For example, the set enumeration tree for set { a, b, c, d } with respect to order c  X  d is shown in Figure 8.

In a set enumeration tree of vertices, each node is a subset of vertices. Some nodes are cross-graph quasi-cliques. Algor ithm Crochet conducts a depth-first search on the set enumeration tree of vertices to find the cross-graph quasi-cliques, which can identify the complete set of answers.

To address the concern on efficiency, at each step of the depth -first search, Crochet employs the following techniques. Reducing Vertices
Some vertices in the graphs can be removed if their degrees ar e too small or they are not connected to enough other vertices t o form a quasi-complete graph.
 L E MMA 3.1 (R E DUCING VE RT ICE S ). For vertex u in graph G i ( i = 1 or 2) , if deg ( u ) &lt;  X  i ( min s  X  1) or | N k ( u ) | &lt; ( min s  X  1) , where k is the upper bound of diam ( G ) in Theorem 1, then u and the edges having u as an endpoint can be removed from both G 1 and G 2 and all cross-graph quasi-cliques in G 1 are retained.
 Proof. If deg ( u ) &lt;  X  i ( min s  X  1) , u fails the requirement on the minimum degree in a quasi-complete graph in G i . If | N k ( u ) | &lt; ( min s  X  1) , u cannot be a vertex in any subgraph which has a diameter k and also has at least min s vertices. Hence, in either of the two cases, u cannot be a vertex in any quasi-complete subgraph in
G i . That means u cannot be a vertex in any cross-graph quasi-clique. Thus, u as well as the edges having u as an endpoint can be removed from G 1 and G 2 , and the mining results will not be affected.

Lemma 3.1 can be applied iteratively to reduce the graphs, un til no vertex or edge can be removed. The checking of degrees is simple. However, dynamically maintaining N k ( u ) for every vertex u can be costly if k is large. Fortunately, as shown in Theorem 1, the upper bound of the diameter of a  X  -quasi-complete graph is pretty small if  X  is not too small. Moreover, as discussed before, a user is often interested in only the cross-graph quasi-cli ques with respect to reasonably large  X  values, e.g.,  X   X  0 . 5 or larger. In our experiments, when  X   X  0 . 5 , Lemma 3.1 often improves the efficiency by a factor of at least 20% .
 Reducing Edges
Between G 1 and G 2 , if there is a  X  i = 1 ( i = 1 or 2) can remove some edges in the other graph according to the edge s in
L E MMA 3.2 (R E DUCING E DGE S ). When  X  i = 1 , an edge ( u, v )  X  E ( G 3  X  i ) can be removed if ( u, v ) 6 X  E ( G cross-graph quasi-cliques from G 1 and G 2 are retained. Proof. Suppose  X  1 = 1 . If ( u, v ) 6 X  E ( G 1 ) , u and be in a complete subgraph in G 1 , and thus cannot be in a cross-graph quasi-clique. Removing ( u, v ) from E ( G 2 ) will not affect any cross-graph quasi-cliques.

We can apply Lemma 3.2 to reduce the graphs by scanning the edges of the two graphs once, if their edges are sorted consis tently. Combining Graphs In the case  X  1 =  X  2 = 1 , we can combine the two graphs G 2 into one graph G as follows. The vertices in G is the same set of vertices in G 1 and G 2 , i.e., V ( G ) = V ( G 1 ) = V ( G is an edge in G if and only if ( u, v ) is an edge in both i.e., E ( G ) = E ( G 1 )  X  E ( G 2 ) . Then, the problem of mining cross-graph quasi-cliques from the two graphs can be reduced to min ing cliques in the combined graph.
 let
G be a combined graph such that V ( G ) = V ( G 1 ) = V ( G and E ( G ) = E ( G 1 )  X  E ( G 2 ) . A set of vertices S quasi-clique in G 1 and G 2 if and only if S is a clique in Proof. Intuitively, when  X  1 =  X  2 = 1 , S is a cross-graph quasi-clique means that the induced subgraph on S in G 1 and G 2 complete sub-graphs. In other words, every edge in the induc ed subgraph on S in one graph (e.g., G 1 ) must also appear in the other graph (e.g., G 2 ).
As discussed in Section 3.2.1, Crochet conducts a depth-first search on a set enumeration tree of vertices. If a graph has ma ny vertices, the set enumeration tree can be huge. Therefore, o ne crit-ical part of Crochet is to prune the futile subtrees as early as possi-ble.

Basically, three issues have to be addressed. We answer the above three questions one by one.
 Generating Children
Let us consider a node X  X  V ( G 1 ) in the set enumeration tree such that X 6 =  X  . The following lemma indicates the set of vertices which can be used to generate the children of X that may lead to some cross-graph quasi-cliques.

L E MMA 3.4 (C ANDIDAT E VE RT ICE S ). Let X 6 =  X  be a sub-set of vertices. If C  X  X is a cross-graph quasi-clique, then for every vertex u  X  ( C  X  X ) , where k i is the upper bound of diameter of complete complete graph in G i given by Theorem 1.
 Proof sketch. Following Theorem 1, for any u  X  ( C  X  X ) and X , d ( u, v ) in G i is bounded by the upper bound of the diameter. Thus, we have the lemma.

For a node X in the set enumeration tree, Lemma 3.4 gives the initial set of candidate vertices . Moreover, as required by the set enumeration tree, only the vertices behind the last vertex i n the order of vertices should be taken.
 Pruning Futile Children and Subtrees
The initial set of candidate vertices can be reduced further . The central idea is as follows. Let Y be the initial set of candidate ver-tices given by Lemma 3.4. If there is no cross-graph quasi-cl ique in G ( X  X  Y ) and G 2 ( X  X  Y ) , then X cannot be in any cross-graph quasi-cliques. In other words, the vertices in Y should not be used to generate children of X since they are futile.
L E MMA 3.5 (P ROJE CT ION ). Let X  X  V ( G 1 ) be a node in the set enumeration tree and Y be the initial set of candidate ver-tices given by Lemma 3.4. For any C such that X  X  C  X  ( X  X  Y ) C is a cross-graph quasi-clique in G 1 and G 2 if and only if cross-graph quasi-clique in G 1 ( X  X  Y ) and G 2 ( X  X  Y ) Proof sketch. The necessity is straightforward. To show the suffi-ciency, suppose C is a cross-graph quasi-clique in G 1 ( X  X  Y ) G ( X  X  Y ) , but not in G 1 and G 2 . Thus, there must be a according to the construction of X and Y , X  X  C  X   X  ( X  X  Y ) G ( X  X  Y ) , which leads to a contradiction.
 G i ( X  X  Y ) is called the projection of G i on X . Based on Lemma 3.5, we can recursively apply the vertex reduction (Lemma 3.1) to prune the projections. We denote the set of ver -tices in the projections after the pruning by P ( X ) . Clearly, in the set enumeration tree, only the children of X in the form of u  X  ( P ( X )  X  X ) should be considered.
 Moreover, in some situations, the whole subtree rooted at not contain any cross-graph quasi-cliques. The following l emma lists four cases.

L E MMA 3.6 (P RUNING RUL E S ). Let X be a node in the set enumeration tree. The subtree rooted at X does not contain any cross-graph quasi-clique if (1) | P ( X ) | &lt; min s ; (2) (3) P ( X )  X  C where C is a cross-graph quasi-clique already found; or (4) X is not a clique in G i if  X  i = 1 .
 Proof sketch. The first pruning rule follows the requirement on the minimum number of vertices in cross-graph quasi-cliques. T hat is, if the sets of vertices in the subtree are too small, there is n o hope to find a significant cross-graph quasi-clique and thus the su btree can be pruned.

The second rule follows the construction of the set enumerat ion tree. That is, some vertex in X can be pruned by edge reduction and vertex reduction. Then, there is no hope to get a cross-gr aph quasi-clique from the subtrees which are superset of X .
The third rule follows the requirement of maximality for cro ss-graph quasi-cliques. In other words, the cross-graph quasi -cliques containing X as a subset should be found in different branches of the set enumeration tree instead of the subtree rooted at
The last rule follows Proposition 1. Since  X  i = 1 and X is not a clique in G i , X cannot be in any cross-graph quasi-clique.
If one of the four conditions specified in Lemma 3.6 happens, the subtree rooted at X should be pruned.
 Ordering Children and Identifying Cross-Graph Quasi-Cliq ues
Intuitively, a vertex with a high degree is likely a member of a cross-graph quasi-clique. Heuristically, we can use  X  ( v ) = to measure how well a vertex satisfies the  X  -quasi-complete graph requirement, where ldeg ( v ) is the degree of v in the induced graph on the current node X in the set enumeration tree. The vertices can be sorted in the  X  ( v ) descending order. However, a vertex may have different  X  value in different graphs. An observation is that how well a vertex is connected to the others crossing the grap hs is bounded by the minimum  X  ( v ) value in the graphs. Therefore, we have the following heuristic.
 of a node in the set enumeration tree can be explored in the descending order, where  X  min ( v ) = min G
The experimental results in Section 4 show that the heuristi c accomplishes good performance in practice. However, since it is Input: graphs G 1 , G 2 ;  X  1 ,  X  2 ; minimum size Output: the complete set of cross-graph quasi-cliques; Method: 1: apply edge reduction (Lemma 3.2), vertex 2: if graphs can be combined then compute the complete set 3: let G 1 and G 2 denote the reduced graphs; 4: for each vertex v  X  V ( G 1 ) in  X  min ( v ) descending 5: let X = { x } 6: call recursive-mine ( X, G 1 , G 2 ) ; Function recursive-mine ( X, G 1 , G 2 ) 7: compute P ( X ) according to Lemma 3.4; 8: let G i = G i ( P ( X )) ; // Lemma 3.5 9: apply vertex reduction (lemma 3.1); 10: let G 1 and G 2 denote the reduced graphs; 11: if at least one condition in Lemma 3.6 holds 12: let unsubsumed = 1 ; 13: for each vertex v  X  P ( X )  X  X , in  X  min ( v ) descending 14: call recursive-mine ( X  X  X  v } , G 1 , G 2 ) ; 15: if the returned value is 1 then unsubsumed = 0 ; 16: if unsubsumed is 0 then return (1) ; 17: if G i ( X ) is a  X  i -quasi-complete graph then a heuristic, there is no theoretical guarantee that the rule always achieves the optimal efficiency.
 After searching the subtree rooted at X , we can determine that is a cross-graph quasi-clique if G 1 ( X ) and G 2 ( X ) are both quasi-complete graphs and there is no cross-graph quasi-clique in the sub-tree of X .

L E MMA 3.7 (D E T E RMINAT ION OF CGQC). Let X be a node in the set enumeration tree. X is a cross-graph quasi-clique if and only if G 1 ( X ) and G 2 ( X ) are both quasi-complete graphs and there exists no cross-graph quasi-clique C such that X  X  C  X  P ( X ) .

Algorithm Crochet is summarized in Figure 9.
The basic Crochet algorithm can be straightforwardly extended to handle more than two graphs. If there are more than one grap h with  X  = 1 , we can combine them into one graph according to Lemma 3.3. The benefit of combining all the graphs having into one is twofold. First, it reduces the number of graphs. S ec-ond, it can be shown that, for the combined graph G , | E ( G ) |  X  min 1  X  i  X  l {| E ( G i ) |} . In words, the combined graph reduces the edges and thus may have a better chance to use the edge-reduct ion (Lemma 3.2) to further reduce edges in other graphs.
Now, let us consider the problem of mining cross-graph quasi -cliques with mapping, where the mapping from V ( G 1 ) to ( i &gt; 1) may not be bijective. Crochet can handle the non-bijective functions with minor extensions.

Consider mining cross-graph quasi-cliques from graphs G 1 G 2 such that V ( G 1 ) 6 = V ( G 2 ) . Let f 2 : V ( G 1 )  X  V ( G mapping. For any vertex v  X  V ( G 2 ) , the pre-images of is denoted as f  X  1
Clearly, a vertex v cannot be in any cross-graph quasi-clique if f ( v ) does not appear in G 2 . Moreover, any vertex in G evant to any cross-graph quasi-clique if there exists no ver tex G 1 such that f 2 ( u ) = v . Those vertices can be removed and the mining results will not be affected.
 PRE -IMAGE ). A vertex u  X  V ( G 1 ) and the edges in G 1 u as an endpoint can be removed if f 2 ( u ) 6 X  V ( G 2 v  X  V ( G 2 ) and the edges in G 2 having v as an endpoint can be removed from G 2 if f  X  1 and edges will not affect the mining of cross-graph quasi-cl iques.
For non-bijective mapping, all the above discussion about Cro-chet still holds by replacing u  X  V ( G i ) by f i ( u ) , except for edge reduction (Lemma 3.2) and combining graphs (Lemma 3.3).

For edge reduction (Lemma 3.2), there are two cases. First, s up-pose  X  1 = 1 . For any edge ( u, v )  X  E ( G i ) ( i &gt; 1) exists no edge ( u  X  , v  X  )  X  E ( G 1 ) such that u  X  v  X  f  X  1 i ( v ) , then ( u, v ) can be safely removed from cross-graph quasi-cliques are retained, since such an edge cannot contribute to the construction of any cross-graph quasi-cl ique.
Second, suppose  X  i if ( f i 0 ( u ) , f i 0 ( v )) 6 X  E ( G i 0 ) , then ( u, v ) graph G 1 and all cross-graph quasi-cliques are retained. More-over, for any edge ( u, v )  X  E ( G i ) ( i &gt; 1 , i 6 = i ists no edge ( u  X  , v  X  )  X  E ( G i v  X  f i 0 ( f  X  1 i ( v )) , then ( u, v ) can be removed from graph the cross-graph quasi-cliques are retained. The rationale is similar. Limited by space, we omit the formal proof here.

For combining graphs (Lemma 3.3), in order to handle non-bijective mapping, we revise the definition of combined grap h as follows. Suppose graphs G i j  X  l ) . Then, we construct the combined graph G = ( V, E ) that V = V ( G 1 ) and E = { ( u, v ) | ( u, v  X  V ( G 1 ))  X  (  X  j : 1  X  revision, Lemma 3.3 holds.
We conducted an extensive performance study using both real data sets and synthetic data sets. The algorithms were imple mented in Java and the experiments were run on a Sun Ultra 10 work station with a 440MHz CPU and 256 MB main memory. We used a real data set consisting of the gene expression data CDC28 and the protein-protein interaction data DIP.

The CDC28 data set [8] records the mRNA transcript levels of the budding yeast S. cerevisiae during the cell cycle. It contains the expression values of 6 , 096 ORFs (genes) during a 17-point time-series, and is publicly available at http://cellcycle-www .stanford.edu.
The protein-protein interaction data DIP, which is publicl y avail-able at http://dip.doe-mbi.ucla.edu, is a database of inte racting pro-teins. We downloaded the version on June 6th, 2004, of the S. cere-visiae subset (yeast20040606.lst). This data set contains pairs of interacting proteins identified in the yeast S. cerevisiae .
We found 4 , 668 matched gene-protein pairs between CDC28 and DIP. For CDC28 data set, we used the Pearson X  X  correlatio n co-efficient as the measure of coherence and set the coherence th resh-old  X  = 0 . 5 . As the result, the gene graph G E contains edges whose both endpoints (genes) appear in the matched gen e-protein pairs. After removing the self-interacting protei n pairs, the protein graph G P contains 15 , 115 edges whose both endpoints (proteins) appear in the matched gene-protein pairs.

In our experiments, we found the complete set of quasi-cliqu es across the gene graph G E and the protein graph G P . Unless par-ticularly specified, we set  X  E = 1 for G E ,  X  P = 0 . 5 min s = 5 .
We wrote a data generator for synthetic data sets, which gene r-ates synthetic data sets as follows.

Given the number of graphs k and a set of vertices V , the data generator first creates k graphs G 1 , . . . , G k such that for each graph G , V ( G i ) = V and E ( G i ) =  X  . Then, given the expected num-ber of cross-graph quasi-cliques N q and the parameters  X  the data generator randomly generates N q cross-graph quasi-cliques and embeds them into graphs G 1 , . . . , G k . The size of the cross-graph quasi-cliques is uniformly distributed between qMax that are specified by user. Finally, given the density value for graph G i , the data generator keeps adding randomly generated edges into the graph G i until the overall density of G i Here, the density of a graph G is defined as density ( G ) =
In the experiments reported in this section, the default val ues for the parameters were as follows: k = 2 ,  X  1 = 1 for G 1 , for G 2 , min s = 5 , qMin = 5 and qMax = 20 .

The experimental results on real data sets and synthetic dat a sets are consistent. Limited by space, we use the results from the real data set to illustrate the effectiveness of the mining and th e effect of the pruning techniques, and use both the real data set and t he synthetic data sets to examine the efficiency and the scalabi lity. We mined cross-graph quasi-cliques from the genomic data se t. Figure 10 shows an example cross-graph quasi-clique Q (  X  and  X  P = 0 . 4 ), where the diameter is only 3 . The induced graph of G
E (the gene expression graph) on Q is a perfect clique, so we only show the induced graph of G P (the protein interaction graph) on here. The cross-graph quasi-clique contains 11 vertices. W e use the ORF (Open Reading Frame) names to represent the correspondi ng genes and proteins.

The cross-graph quasi-clique is interesting in biology sin ce these 11 genes are highly coherent and the corresponding 11 proteins are intensively interacting.

To compare the efficiency of the rudimentary algorithm (Sec-tion 3.1) and Crochet , we got subsets of genes and proteins in the genomic data set by sampling. We used the induced graphs on th e samples to test both algorithms. The number of vertices in th e sub-Figure 10: A cross-graph quasi-clique of 11 proteins. min sets ranges from 4 , 000 to 6 , 018 (the whole data set). The runtime is shown in Figure 11(a). Please note that axis Y is in logarith-mic scale. Clearly, Crochet is dramatically more efficient than the rudimentary method. This strongly indicates that the techn iques in Crochet are effective.

To understand the huge difference between the efficiency of t he two algorithms, recall that the rudimentary algorithm comp utes the complete set of quasi-complete subgraphs in G E . In Figure 11(b), we plot the number of quasi-complete subgraphs in G number of cross-graph quasi-cliques, respectively. Clear ly, the num-ber of cross-graph quasi-cliques is much smaller. That part ly ex-plains the saving in Crochet . Since Crochet is dramatically faster and more scalable than the rudimentary algorithm, hereafte r, we focus on analyzing the performance of Crochet .

Figures 12 (a) and (b) show the number of cross-graph quasi-cliques and the runtime of Crochet with respect to parameter the minimum number of vertices in a cross-graph quasi-cliqu e. As can be seen, when min s is large, the number of cross-graph quasi-cliques is small and the runtime is short. As min s decreases, the number of cross-graph quasi-cliques may increase substant ially and the runtime also increases accordingly. The two curves foll ow the same trend.

We also tested the effect of  X  P and  X  E , as shown in Figures 12(c)-(f). We fixed  X  E = 1 in Figures 12(c) and (d). The two curves follow the same trend. When  X  P  X  0 . 5 , the cross-graph quasi-cliques are compact and the number of cross-graph quasi-cli ques is Rule (1), Lemma 3.6 16 . 765 16 . 392 1 . 023 Rule (2), Lemma 3.6 130 . 460 16 . 392 7 . 959 Rule (3), Lemma 3.6 10 . 838 16 . 392 0 . 661 Rule (4), Lemma 3.6 338 . 916 16 . 392 20 . 676 Figure 13: The effect of various techniques in Crochet ( 1 . 0 ,  X  P = 0 . 5 , min s = 5 ). small. When  X  P &lt; 0 . 5 , the number of cross-graph quasi-cliques increases substantially and so does the runtime.

In Figures 12(e) and (f), we fixed  X  P = 0 . 5 and varied 0 . 5 to 1 . Interestingly, the number of cross-graph quasi-cliques does not decrease monotonically when  X  E increases. The reason is that when  X  E increases, some large cross-graph quasi-cliques may split into several smaller ones. The runtime of Crochet decreases consistently as  X  E increases.

To examine the effect of the techniques in Crochet on improv-ing the efficiency, we tested the speedup of the specific techn iques. That is, for a specific technique, we recorded the ratio of the run-time of Crochet without the technique against using the technique.
The results are shown in Figure 13. From the figure, we can see that rules (2) and (4) in Lemma 3.6 are most effective in pruni ng. Interestingly, rule (3) in Lemma 3.6, checking whether a pot ential quasi-complete subgraph is a subset of a cross-graph quasi-clique, is expensive and costs more than it can save. However, to avoi d du-plicates in output, this step cannot be removed from the algo rithm.
Using synthetic data sets, we tested the scalability of Crochet on five aspects, namely (1)the number of cross-graph quasi-cli ques in the data set; (2) the number of vertices in the graphs; (3) the den-sity of the graphs; (4) the maximal size of the cross-graph qu asi-cliques; and (5) the number of graphs. Among the five factors, we observed that the number of cross-graph quasi-cliques is th e deter-minant one. The reason is that the more cross-graph quasi-cl iques in the graphs, the fewer nodes we can prune from the set enumer -ate tree, and the longer the runtime. However, the other fact ors may also influence the runtime. For example, the more edges in the graphs, more cross-graph quasi-cliques may exist.

We created synthetic graphs with 1,000 vertices and embedde d 1,000-10,000 cross-graph quasi-cliques in the graphs. Fig ure 14(a) illustrates the runtime with respect to the number of cross-graph quasi-cliques. With the graph reduction, graph projection and other pruning rules, we can see that Crochet is approximately linearly scalable with respect to the number of cross-graph quasi-cl iques.
We also tested the runtime of Crochet with respect to the num-ber of vertices (Figure 14(b)). We fixed the density of both gr aphs at 2% and embedded 100 expected cross-graph quasi-cliques in the graphs. As the number of vertices increases, the number o f cross-graph quasi-cliques as well as their sizes increase s ubstan-tially. That leads to the rapid increase of the runtime.
We explored the scalability of Crochet with respect to the density of the graphs. The general trend is that the runtime of Crochet in-creases as the density increases. Moreover, the increase of density in the graph with higher  X  value brings more significant effect to the increase of Crochet runtime. This is because, likely, the number of cross-graph quasi-cliques is bounded by the graphs with hig her values. When the  X  values are set to be the same, then the increase of density in the graph with the lowest density brings the mos t sig-nificant effect on the runtime. Please note that, in our synth etic data sets, the noisy edges are randomly distributed to satisfy th e density requirement. In real applications, the distribution of edg es may not be even. Limited by space, we omit the details here.

Figure 15 shows the runtime of Crochet and the number of cross-graph quasi-cliques with respect to the maximal size of cros s-graph quasi-cliques, respectively. As can be seen, the larger the embed-ded cross-graph quasi-cliques, the more skewed the edges ar e dis-tributed. Thus, the number of cross-graph quasi-cliques an d the runtime increase substantially.

Last, Figure 16 shows the scalability of Crochet with respect to the number of graphs. We fixed the number of vertices to and generated multiple graphs with density 10% . Since the more graphs, the less likely and the smaller cross-graph quasi-c liques are formed, and also the sharper the cross graph pruning (edge re duc-tion and vertex reduction) is, the runtime of Crochet drops dramat-ically when the number of graphs increases.

From the above experiments, we can see that Crochet is efficient and scalable in mining large graphs. On the other hand, scala ble mining of dense graphs and graphs with large cross-graph qua si-cliques is still challenging.
To the best of our knowledge, [1] and [21] are the two previous studies most related to this paper. In [1], Abello et al. defin ed a clique in a graph G as a subset of vertices S  X  V ( G ) such that the induced graph on S is connected and | E ( G ( S )) |  X   X   X  | They also proposed a greedy randomized adaptive search algo -rithm, GRASP , to find a  X  -clique with the maximum size. In [21], Matsuda et al. introduced a definition of quasi-clique simil ar to ours in this paper. However, instead of finding the complete set of quasi-cliques in the graph, they proposed an approximation algori thm to cover all the vertices in the graph G with a minimum number of p -quasi-complete subgraphs. However, both [1] and [21] neither find the complete set of quasi-cliques, nor address mining mu ltiple graphs .
To a more general extent, graph mining has become an importan t topic in data mining. For example, mining frequent substruc tures and subgraph patterns from many graphs (i.e., a graph databa se) has been studied intensively [4, 27, 16, 17, 20, 32, 31, 28]. Y an et al. [33] used frequent graph patterns to index graphs. Fre quent graph pattern mining in those previous studies focuses on fin d-ing the common embedded subgraphs that appear in many graphs , which is very different from the problem of mining cross-gra ph quasi-cliques investigated in this study. For a cross-grap h quasi-clique, the induced graphs on the clique can be very differen t from graph to graph. Therefore, those frequent graph pattern min ing al-gorithms cannot be extended to mine cross-graph quasi-cliq ues.
In addition to frequent graph pattern mining, Palmer et al. [ 23] developed a fast and scalable tool ANF to answer various complex analytical queries from massive graphs that may not be able t o fit into main memory. Faloutsos et al. [13] investigated the pro blem of fast discovery of connection subgraphs which nicely capt ure the relationship between pairs of nodes in large social network s graphs. In [18], Jeh and Widom proposed the problem of mining the spac e of graph properties.

Besides graph mining, graph-based algorithms are applied t o cluster large data sets. A data set can be modeled as a graph, and the problem of clustering can be converted to some tradit ional graph problems, such as finding (quasi-)cliques or minimum c ut in the graph. For example, the spectral clustering approach [9 ] can be viewed as finding the relaxed optimal normalized cuts in a wei ghted graph. A spectral clustering algorithm that uses the k eigenvectors of the adjacency matrix simultaneously was presented in [22 ].
As another frontier of data mining research, mining from mul -tiple sources has received more and more attention. The pape rs in [11] provided good examples for techniques and applicati ons of mining multiple relational tables.

On the application side, recent technical advances have ena bled collections of many different types of biological data at a g enome-wide scale, such as DNA and protein sequences, gene expressi on measurements, and protein-protein interactions. Various cluster-ing approaches, including the graph-based algorithms, hav e been developed to explore interesting patterns in those data set s. For example, Hartuv et al. [15] proposed an algorithm, HCS , to find groups of genes that have similar expression patterns. HCS re-cursively splits the weighted gene graph G into a set of highly connected components along the minimum cut. Each highly con -nected component is considered as a gene cluster. Motivated by HCS , Shamir et al. developed the algorithm CLICK [26]. In [5], Ben-dor et al. presented a heuristic algorithm CAST to iteratively identify the maximal cliques once at a time. Xu et al. [30] gen -erated a Minimum Spanning Tree (MST) from the weighted gene graph G . By removing ( K  X  1) edges from the generated MST, the data set is partitioned into K clusters. Moreover, Enright et al. [12] developed TRIBE-MCL based on MCL [10], a graph-based algo-rithm using flow simulation, to efficiently detect protein fa milies from large protein sequence databases. Bu et al. [6] used the spec-tral clustering method [22] to analyze the topological stru cture in the protein interaction graphs. Moreover, Bader et al. [2] p roposed a heuristic approach, MCODE , based on the concept of scale-free networks [3] to find molecular complexes in large protein int erac-tion graphs.

Recently, joint mining of multiple biological data sets has re-ceived intense interest. As a pioneer work, Segal et al. [25] pro-posed a unified probabilistic model to learn the pathways fro m gene expression data and protein interaction data. However , their method requires the users to input the number of pathways tha t is often unknown in advance.
In this paper, we proposed a novel and interesting problem, m in-ing cross-graph quasi-cliques from multiple graphs, and sh owed some promising application examples. The complexity analy sis showed that the problem is difficult. We developed an efficien t algorithm, Crochet , which exploits several effective techniques to mine the complete set of cross-graph quasi-cliques. An exte nsive performance study using both real data sets and synthetic da ta sets illustrated that the mining results are interesting and alg orithm Cro-chet is efficient and scalable.
