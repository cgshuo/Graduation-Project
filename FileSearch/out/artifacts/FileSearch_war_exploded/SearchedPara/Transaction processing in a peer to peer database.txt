 1. Introduction may semantically relate to data in another peer. Therefore, each peer speci in the literatures. For creating a global database, each local source de schema(s) [5] . In this architecture, the lowest layer ( fi federated schema integrates multiple export schemas and its information is, in turn, peers is not possible due to the pair-wise mappings between peers and the dynamic behavior of peers. one of the distinguishing characteristics of peer-to-peer systems and it is one of the main bene methodology. 1.1. State of the art internally consistent instance that this particular source accepts from other sources. and local transactions are those that execute at a single site/peer. Similar to FDBSs and MDBSs, the dif processing transactions in a P2PDBN due to these two characteristics of the P2PDBNs: heterogeneity and autonomy.
Heterogeneity: Since each peer database is created independently, each local database management system may follow schedule under the assumption that local schedules at each LDBS are serializable. A schedule S transactions operations resulting from their execution. A serialization graph for a schedule S corresponding to the transactions that are committed in S transaction T i and T j are in direct con fl ict in schedule S and o j ( x )in T j , T i  X  T j , such that o i ( x ) followed by o partial ordered set of all operations belonging to local and global transactions such that, for any local site s set of global and local transactions executing at site s k global transactions' serializability is enforced by a GTM.
 execution consistency criteria as ensuring serializability.
 application of these protocols is not feasible or applicable due to the following reasons: (i) The local database management systems in a P2PDBN or in an MDBS are pre-existing and have been developed global serializability ina P2PDBN which is presented in Section 6.2 . 1.2. Problem description
In a P2PDBN, we assume that LDBSs in peers are considered as black boxes that cannot be modi example below.

Example 1. Consider a peer database network consisting of three peers: P executed at P 1 , concurrently.
 Assume that the LDBS of P 1 produced the following schedule:
Suppose that peers P 2 and P 3 are connected with P 1 . Hence, after execution of T
Assume that when P 2 executes the transactions it also executes the following local transaction L Assume that the LDBS of P 2 generates the following schedule.

We fi nd that the resulting serialization orders ( SOs )of T
Notice that each local schedule in each peer is serializable, but the serialization order or con schedule S 3 at P 3 is different with respect to the schedule S con fl icts between transactions. It turns out to be more dif that may occur during the execution of transactions. For example, a peer may go of failure to pass the validation test by the local transaction manager. We consider an of follows.

Example 2. Consider a peer database network consisting of three peers: P transaction T 1 as follows that is originated at peer P 1
Assume that after executing T 1 , peer P 1 forwards the transaction to its acquaintances P transaction they execute the transaction independently. Assume that when P originated. Consider the following schedule generated by the local concurrency controller of P
The transaction T 1 is executed at P 3 in the usual way. Note that transaction T situation an inconsistent read of data at acquaintances.

In order to ensure serializability at acquaintances, we introduce a correctness criteria called acquaintance-level also observe that an inconsistent serialization order due to an indirect con approaches. 1.3. Contributions
The contributions of this paper are as follows:  X  peer in a P2PDBN.  X  proposes two approaches for ensuring the correctness criteria without violating the autonomy of LDBSs in peers.  X  execution and presents a solution for maintaining the consistent execution. conclude in Section 11 by pointing to future works. 2. System model
We consider a peer to peer database network, where peers are acquainted through data-level mappings [8 mappings allow us to relate the data values of two peers. In our model, a P2PDBN is a set P ={ P autonomous pre-existing local database systems (LDBSs). Each peer P relational database with a fi nite universe of attributes U domain of A j and is denoted as dom ( A j ). If X ={ A 1 , A  X  peer is said to expose these attributes.

Accordingly, in our model, each peer P i has a set of mapping tables [9] which is denoted as M tuple ( x , y ) in a mapping table m [ X , Y ] indicates that the value x tables M ij ={ m 1 ,  X  , m k }  X  M i in P i stores the data mappings between data items of P
P . The construction of mapping tables M ij forms an acquaintance ( i , j ) between P
M sources all containing information about videos or music fi peers that belong to different worlds. 2.1. Preliminaries database be a ( fi nite) set D ={ a , b , c , ... } of data objects. A transaction T data objects D . Formally, T i =( O T invoked by a transaction T i . The operations of a transaction T operations. Further, T i has termination operations commit (denoted by c The concurrent execution of transactions results in a schedule. A schedule S is a pair ( transactions and  X  S is a partial order over the operations of transactions in preserves the order of steps within each transaction, (that is,
The most commonly used correctness criteria for an acceptable schedule is con
S consists of transactions T i and T j , then a transaction T operations o i in T i and o j in T j , T i  X  T j , such that o
By  X  4 , we denote the transitive closure (indirect con fl ict) of the transactions a serialization order. A set of transactions transactions in  X  have the same serialization orders. When there is no con to be serialization order of the transactions. 3. General execution scenario of transactions
In the P2PDBN represented by our model, when a user in a peer P the local database schema and data vocabulary. When a transaction T appropriate actions are performed in DB i . Whenever, a data is accessed by T need to be accessed subject to the data mappings in M ij for the data accessed by T the transaction. A mapping table m [ X , Y ] is relevant to T forwards translated transactions to the acquaintees which are relevant to T the execution of a local transaction T i at a peer has no effect on its acquaintee P mapping tables). We call this acquaintee irrelevant for the transaction T
P local transaction L 1 as well as a global transaction T 1 after being translated as T 1 2 .
 3.1. Transaction classi fi cations
Based on the execution scenarios, transactions are classi transactions.

Local transaction ( L i ): A transaction L i which is submitted in a peer P
Remote transaction ( T i j ): From the point of view of a peer P
Global transaction ( G i ): A global transaction G i ={ T
Note: For ease of presentation we denote remote transactions T global transaction G i is represented by T i . Intuitively, execution of any component transaction T of G . 3.2. Properties of a global transaction transaction.

We now describe the structure of a global transaction G i component transactions of G i . When P i generates a set of remote transactions from T
G can be viewed as a two-level transaction. In this case, T transactions, and there is an edge from transaction T i j depend on transaction T i j if peers P j and P k are acquainted, and transaction T cycles. For each edge of the induced graph, we de fi ne the relationship as parent (child) of T i k ( T i j ) and denoted as T j i P T k i ( T k 3.3. Transaction translation
When a transaction is forwarded to an acquaintee for execution, translation is restricted as speci fi ed in the de fi nitions below.
De fi nition 1 (Order restriction). Consider two transactions T follows the order restriction of T i if O T operations.

De fi nition 2 (Schedule order restriction). Consider a schedule S of P i that follows the order restriction of S i if for any two operations o totality of its operations have been translated.

De fi nition 3 (Partial translation). A transaction T j is a partial translation of a transaction T restriction of T i .

De fi nition 4 (Complete translation). A transaction T j is a complete translation of a transaction T order restriction of T i .
Example 3. Suppose a global transaction G 1 is initiated by T
Suppose the following data mappings are in place:
Based on these mappings, P 1 generates the following remote transactions from T
When P 3 receives T 1 3 , it also generates the following remote transaction for P and P 4 .

From the above translation, we can say that T 1 2 and T 1
T . All of the translations also follow the order restrictions.
 presented in Ref. [6] . 3.4. Data constraint property classify the consistency of data items in a peer database network into two types:
Local consistency: the consistency of the local data items. The constraints are de
Therefore, the introduction of the peer-to-peer constraints partitions the data items D shared data ( SD i ), such that LD i  X  SD i =  X  and D i = LD mapping table, then data items a i and a j are shared data items in D the mapping tables coexist with in a local database.
 peer. This is logical since global transactions are used only to access shared data. 4. Consistent execution view of concurrent transactions agree on the execution of global transactions in a speci fi long lived, the use of serializability as a correctness criteria would restrict data availability [32] . without violating the autonomy of local databases. The main problem occurs due to indirect con solutions have been proposed, for example, in Refs. [4,7,20 plays an important role to ensure the global serializability of global transactions in the system.
However, in a P2PDBN there is no GTM, and transactions are executed if the following two conditions are satis fi ed: 1. All the operations of a transaction must be executed in the same order in peers P acquaintances ( j , k ) between P j and P k (1  X  k  X  m ), if T if there are schedules S j =(  X  S transaction in  X  S each acquaintee of a peer. Note that the second condition cannot be ful transactions over an acquaintance.

Example 4 (Direct con fl ict). Consider a P2PDBN shown in Fig. 4 . Assume that peer P { a , b 2 , c 2 }, and P 3 has data items { a 3 , c 3 }. Suppose that the transactions T schedule S 1 as follows:
Suppose the following data mappings exist in the acquaintances.
Based on the data accessed by T 1 and T 2 , P 1 translates T we keep the same notation of T 1 and T 2 , and their translation. The translation of T
Assume that peer P 2 executed the following local transaction L
Consider that after receiving the translated transactions T
Therefore, the resulting serialization orders of T 1 and T
Notice that each local schedule in each peer is serializable, but the execution view of T other, the execution view of the transactions should be the same in each peer. transactions in the acquaintees of a peer P i even though the transactions have no con
Consider Fig. 5 , where transactions T 1 and T 2 executed concurrently at P schedule S 1 :
Based on the data mappings, P 1 generates the following transactions for P them.

Assume that the following local transactions executed at the same time when P Consider that P 2 and P 3 generate the following schedules.

Notice that when T 1 and T 2 executed at P 1 , there was no con at P 3 , they evolve into indirect con fl ict due to the presence of the local transaction L
P and P 3 , we observe the following serialization orders.

Notice that the serialization orders of T 1 and T 2 at P 2 maintained.
 acquaintees, the peer has no control of the execution of transactions at the acquaintees. 5. Maintaining acquaintance-level consistent execution of transactions protocols (e.g. two-phase commit), which tend to introduce blocking and are thus not easily scalable. Speci acquaintance that is included in the propagation path of the transactions. same in all the acquaintees of a peer if the transactions have direct con indirect con fl ict between the transactions when it occurs in acquaintees. An indirect con transactions in a database, therefore, different execution views of transactions due to the indirect con write  X  read and read  X  write . A write  X  read con fl ict between T is followed by a write operation of T 1 . A read  X  write con of L . Therefore, if L has a write  X  read con fl ict with T another transaction T 2 . This is because T 1 and T 2 had no con with T 1 , then L does not create a write  X  read con fl ict with another transaction T execution of transactions in a peer and its acquaintees.

De fi nition 5 (Acquaintance-level schedule). An acquaintance-level schedule peer P i for a set of transactions  X  is the union of the schedule S acquaintee of P i .

De fi nition 6 (Acquaintance-level consistent schedule). An acquaintance-level schedule consistent with respect to a schedule S i in P i for a set of transactions acquaintance ( i , j ), (1  X  j  X  m )if (1) all the local schedules in S i are serializable, and (2) for any two transactions T 1 and T 2 in S i , if there exists a serialization order ( SO ) T
De fi nition 7 (Acquaintance-level serializable). An acquaintance-level consistent schedule serializable w.r.t S i between peers P i and all acquaintees P
De fi nition 8 (Global schedule). A global schedule S = S i  X  X  n
P , consists of the acquaintance-level schedule S i w.r.t S in a P2PDBN where  X  executes.
 acquaintance in the propagation paths of the global transactions.
 Theorem 1. A global schedule S consisting of a set of global transactions ( P  X  ...  X  P z ) with respect to a schedule S i at P i if for each acquaintance in ( P
Proof 1. (By induction over the length of the path from P
Let l be the length of the propagation path of  X  from P i Case l =0.  X  executed only at P i , and there is no further propagation of serializable. Hence, the global schedule S , which consists of only the schedule S
Case l =1.  X  executed at P i , and an acquaintee P j of P according to De fi nition 7 , the serialization orders of
Case (0  X  k  X  l ). For the induction step, we assume that consistency holds along the path between P acquaintance, where P k is a peer before P z . Now we need to show that serializability holds between P
S is consistent over the path ( P i  X   X   X  P k ) and P k , and P consistency holds over the path ( P i  X   X   X  P z ).

De fi nition 9 (Global consistency). A global schedule S over a set of global transactions (1) all local schedules in S are serializable, and (2) for each acquaintance ( j , k ) over all the propagation paths ( P Theorem 2. A global schedule S consisting of a set of global transactions schedule S i at P i if for all propagation paths ( P i  X   X   X  serializable, and each path between P i and P z is acyclic.
 Proof 2. According to Theorem 1 , S is consistent in a path of ( P  X   X   X  P z ). Moreover, each path is acyclic. Therefore, S
Example 6. Consider Fig. 6 where two global transactions T transactions are initiated at P 1 . In the scenario, the global schedule schedules are locally serializable. The initial schedule S
S with respect to S 1 at P 1 is { S 1 , S 2 , S 3 }. We see that serialization order T 1  X  T 2 , but S 3 is not acquaintance-level serializable because SO
S is not globally consistent. 6. Ensuring acquaintance-level consistent execution of transactions The acquaintance-level serializability ensures the same execution views of a set of transactions transactions  X  is executed at a peer P i , the transactions are executed immediately at P without waiting for the execution of  X  in its acquaintees. After execution, P execution and forward steps continue until no propagation of 6.1. Merging transactions local concurrency control protocol. Therefore, the peer generates a local serializable schedule forming a speci returnSchedule () function returns only the operations of operations that is generated by the sender in its schedule.
 considering both the direct and indirect con fl icts.

Example 7 (Direct con fl ict). Consider the situation of Example 4 . The local schedule generated at P scenario.

According to the method, P 1 creates a new transaction T 12 operations of T 12 follows the order as mentioned in the schedule S
Consider that P 2 and P 3 received the transaction T 12 and executed it. Note that it is not possible for peer P scheduleasdescribed in Example 4 since transactions T 1 and T
T cannot come before the operation w 1 ( c 3 )of T 1 . The only possible schedules P
Note that the transaction T 12 contains the operations of T
P and P 3 , therefore the operations T 12 are executed in the same order as it is executed at P
T
Example 8 (Indirect con fl ict). Consider Example 5 , there is no con the following schedule is generated at P 1 .

According to the method, P 1 creates the following transactions for its acquaintees P
Consider the same execution view of the operations as mentioned in Example 5 . Therefore, P following schedules. Fig. 8 shows the schedules generated by each peer.
We notice from Fig. 8 that the schedules S 2 and S 3 are not allowed by the local concurrency control of P schedules have cycles. In P 2 , either L 2 or T 12 will be blocked or aborted. If the local schedules in P then the schedule would be permitted by the local concurrency control at P Similarly, if the local schedules at P 3 were then the schedule would be permitted by the local concurrency control at P that from the above executions, both P 2 and P 3 schedule the transactions T acquaintance-level serializability is maintained with respect to S 6.2. OTM based propagation determined by the sender.

In the following, we describe the protocol using an example considering that there is no con when they executed at a peer.

According to the method, P 1 creates the following transactions adding w(t) operation to T the acquaintees P 2 and P 3 .

Peer P 1 uses the getSeriliazeOrder () function to fi nd the serialization orders of T executed before T 2 in S 1 . Therefore, P 1 sends T 1 before T
Consider that the following schedules are generated by P 2 by each peer.

We notice from Fig. 9 that the schedule S 3 is not allowed by the local concurrency control of P schedule. That is, either L 3 or T 2 will be blocked or aborted. On the other hand, if the local schedules in P then schedule would be permitted by the local concurrency control at P transactions T 1 and T 2 are same in all the acquainted peers of P the ticket method.

According to the method, P 1 now creates the following transactions by adding w(t) operation to T them to the acquaintees P 2 and P 3 .

Now P 1 uses the getSeriliazeOrder () function to fi nd the serialization orders of T serialized before T 2 in S 1 . Therefore, P 1 sends T 1 before T the generated schedules are as follows. Fig. 10 shows the schedules generated by each peer.
Notice from Fig. 10 that the schedule S 3 is not allowed by the local concurrency control of P schedule. On the other hand, if the local schedule in P 3 then the schedule would be permitted by the local concurrency control at P transactions T 1 and T 2 at P 3 is same as in P 1 , therefore ensuring acquaintance-level serializability.
An edge ( T i , T j ) of GSG means that the ticket operation of a global subtransaction T subtransaction T j at least at one site. The set of edges re and maintained by delaying the propagation of the transactions. 7. Ensuring acquaintance-level consistent execution of transactions considering failures of transactions However, the approaches assume that the failures of transactions do not occur during their execution.
There are several failure-prone situations that may occur in a P2PDBN. For examples, a peer may go of explicitly mention why a transaction aborts. We consider an of same set of transactions when a transaction fails in a peer. We consider the situations of direct and indirect con transactions at the time transactions execute in peers.

P2PDBN with three peers shown in Fig. 11 . We see from the and P 3 has data items { a 3 , b 3 }. Suppose that transactions T produced the schedule S 1 :
Suppose that the following data mappings exist between the acquaintances.
Based on the data accessed by T 1 and T 2 , P 1 translates T and P 3 are as follows:
For ease of presentation, we keep the same notations of T transactions, P 2 and P 3 generate the following schedules.

The resulting serialization orders of transactions T 1 and T
Notice that each local schedule in each peer is serializable, but the execution view of T different with respect to the schedule S 1 in P 1 . The execution view is different since T after the execution of T 2 .
 transactions in acquaintees of a peer P i even though transactions have no con transactions T 1 and T 2 executed at P 1 , and the local transaction manager at P
According to the data mappings, P 1 generates the following transactions for P to them. Note that T 2 has been translated partially for P
Assume that peer P 3 has a local transaction L 3 when P 3 Consider that P 2 and P 3 generate the following schedules.

Notice that when T 1 and T 2 executed at P 1 , there was no con executed at P 3 , they are involved in indirect con fl ict due to the presence of a local transaction L in P 2 and P 3 , we observe the following serialization order.

Note that the serialization orders of T 1 and T 2 in P 2 and P executionviewoftransactionsin P 3 .Sinceinpeers P 1 and P participating sites have direct or indirect controls over the individual operation of global transactions.
However, in a peer to peer database network a transaction is not decomposed into subtransactions to be executed in no control over the execution of transactions.
 of transactions. Again, we consider both the direct and indirect con occurs due to abort of a transaction on behalf of the LDBS [30] . This issue is discussed in Section 8 .
Example 13 (Direct con fl ict). Consider the situation of Example 11 . The local schedule generated in P
According to the approach 1, P 1 creates a transaction T 12 operations in T 12 follows the order as mentioned in the schedule S Consider the same execution of operations at P 2 and P 3 as in Example 11 .
Note that at peer P 3 , after the operation w 12 the transaction T until w 12 successfully executes. After another try T 12 is executed. Hence, the order of operations of T it is in P 1 . Therefore, acquaintance-level consistent execution is maintained at P
Example 14 (Indirect con fl ict). Consider Example 12 , there is no con the following schedule is generated in P 1 .

According to the method, P 1 creates the following transactions for its acquaintees P the scenario.

Assume that the following schedules result at P 2 and P 3 illustrated in Example 12 .

Notice that the schedule S 3 is not allowed by the local concurrency control in P ( T 12  X  L 3  X  T 12 ). If the local schedule in P 3 is then the schedule would be permitted by the local concurrency controller in P maintained with respect to S 1 .

So far we have presented how the merging transactions approach ensures acquaintance-level consistent execution of consistent execution, a peer has to wait to forward the second transaction until the successful execution of the
This is the limitation of the second approach. 7.1. Discussion the complete execution in the local peer.

That is the Ticket approach only works if transactions are sent in FIFO order according to their commit order. 8. Execution model of transactions remote transactions received from remote peers. In the following, we de transaction.  X  needs to be executed in other peers.  X  called a participant.  X  respect to its coordinator, and is called a coordinator with respect to its participants. functionality of the RTA and server modules.
 transaction into each acquainted peer. A peer log in P i for one of its acquainted peers P forwards to P j . For example, when a peer P i propagates a transaction T writes a log b T i , send N in the peer log of P j . If the Server receives an acknowledgement from P received N in the corresponding peer log of P j . If Server does not receive an acknowledgement during the speci unable to receive T i . In this case, P i assumes that P j network and noti fi es P i then Server of P i sends T i again. If T
Server of P i receives a response for T i it writes an entry remote transaction in an atomic transaction for a speci fi receives a noti fi cation of the active status from an acquainted peer after the status of the aborted transaction, which is active or to-be-committed before the occurrence of the failure. After the corresponding server of the remote transaction.
 advantages of this approach: coordinator and re-executes the transaction and starts forwarding the transaction. observes the execution over its immediate participants. transaction commits acquaintance to acquaintance.
 importantly, peers should not become blocked. 9. Evaluation and receiving transaction messages.
 are generated using the tool. Table 1 provides a summary of the con objectives and the experimental results.
 result shows that the execution time of transactions increases rapidly with the increased size of networks. system considering the involvement of the local transactions in peers. We veri execution time is 46.812 s. This shows that there is no signi network size changes as it is obvious from Fig. 18 .
 shown in Fig. 19 . 10. Related work guaranteed eventually in the system. Therefore, it provides an object's availability by sacri and the individual peer does not have to wait for the other peers to con operations.
 serialization graph. The serialization graph of the peer re approach changed the transaction semantics of conventional DBMS, since in the approach transactions resolve con of details does not permit of comparison with our approach.
 executes updates in their tentative order, then rolls back and replays them in the fi nal timestamp is assigned to the update. Hence, the con fl icts independently. Also, in our system, updates are propagated along the mappings between peers. provider) and another peer acts as a target (data receiver). The target schema is de fl ight reservation network are created for sharing data of fl desirable [9] because of peer independence.
 sites must be connected to the merging site during reconciliation and then wait until reconciliation is However, it lacks precise semantics of transactions and does not describe the execution semantics of transactions. them whenever possible.
 but not replicated.
 in replicated environment has not been addressed.

Authors in Refs. [55  X  57] speci fi ed update exchange policies on-the-exchange supports through fi ring of triggers that satis fi constraint. 11. Concluding remarks
In this paper, we introduce a transaction execution model for a peer to peer database network where sources are immediate acquaintances by ensuring acquaintance-level serializability. Mainly, we contribute the following:  X 
We analyze the execution of transactions in a peer to peer database network.  X  execution of transactions initiated from a single peer.  X  executed concurrently in the system, and to analyze the correctness criteria for such executions. cycle and can generate new data at each cycle round until a guarantee completeness. Solving this issue, too, is our future goal.
References
