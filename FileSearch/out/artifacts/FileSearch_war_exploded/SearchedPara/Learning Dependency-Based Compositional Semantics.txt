 What is the total population of the ten largest cap-itals in the US? Answering these types of complex questions compositionally involves first mapping the questions into logical forms (semantic parsing). Su-pervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expen-sive. On the other hand, existing unsupervised se-mantic parsers (Poon and Domingos, 2009) do not handle deeper linguistic phenomena such as quan-tification, negation, and superlatives.

As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the end-to-end problem of mapping questions to answers. However, we still model the logical form (now as a latent variable) to capture the complexities of lan-guage. Figure 1 shows our probabilistic model: We want to induce latent logical forms z (and pa-rameters  X  ) given only question-answer pairs ( x ,y ) , which is much cheaper to obtain than ( x ,z ) pairs.
The core problem that arises in this setting is pro-gram induction: finding a logical form z (over an exponentially large space of possibilities) that pro-duces the target answer y . Unlike standard semantic parsing, our end goal is only to generate the correct y , so we are free to choose the representation for z . Which one should we use?
The dominant paradigm in compositional se-mantics is Montague semantics, which constructs lambda calculus forms in a bottom-up manner. CCG is one instantiation (Steedman, 2000), which is used by many semantic parsers, e.g., Zettlemoyer and Collins (2005). However, the logical forms there can become quite complex, and in the context of program induction, this would lead to an unwieldy search space. At the same time, representations such as FunQL (Kate et al., 2005), which was used in Clarke et al. (2010), are simpler but lack the full ex-pressive power of lambda calculus.

The main technical contribution of this work is a new semantic representation, dependency-based compositional semantics (DCS), which is both sim-ple and expressive (Section 2). The logical forms in this framework are trees, which is desirable for two reasons: (i) they parallel syntactic dependency trees, which facilitates parsing and learning; and (ii) eval-uating them to obtain the answer is computationally efficient.

We trained our model using an EM-like algorithm (Section 3) on two benchmarks, G EO and J OBS (Section 4). Our system outperforms all existing systems despite using no annotated logical forms. We first present a basic version (Section 2.1) of dependency-based compositional semantics (DCS), which captures the core idea of using trees to rep-resent formal semantics. We then introduce the full version (Section 2.2), which handles linguistic phe-nomena such as quantification, where syntactic and semantic scope diverge.

We start with some definitions, using US geogra-phy as an example domain. Let V be the set of all values , which includes primitives (e.g., 3 , CA  X  V ) as well as sets and tuples formed from other values of predicates (e.g., state , count  X  P ), which are just symbols.
 A world w is mapping from each predicate p  X  P to a set of tuples; for example, w ( state ) = { (
CA ) , ( OR ) ,... } . Conceptually, a world is a rela-tional database where each predicate is a relation (possibly infinite). Define a special predicate  X  with w (  X  ) = V . We represent functions by a set of input-output pairs, e.g., w ( count ) = { ( S,n ) : n = | S |} . As another example, w ( average ) = { ( S,  X  x ) : is treated as a set-valued function S ( x ) = { y : ( x,y )  X  S } with domain S 1 = { x : ( x,y )  X  S } .
The logical forms in DCS are called DCS trees , where nodes are labeled with predicates, and edges are labeled with relations. Formally: Definition 1 (DCS trees) Let Z be the set of DCS trees, where each z  X  Z consists of (i) a predicate z.p  X  X  and (ii) a sequence of edges z.e 1 ,...,z.e m , each edge e consisting of a relation e.r  X  R (see Table 1) and a child tree e.c  X  X  .
 We write a DCS tree z as  X  p ; r 1 : c 1 ; ... ; r m : c m Figure 2(a) shows an example of a DCS tree. Al-though a DCS tree is a logical form, note that it looks like a syntactic dependency tree with predicates in place of words. It is this transparency between syn-tax and semantics provided by DCS which leads to a simple and streamlined compositional semantics suitable for program induction. 2.1 Basic Version The basic version of DCS restricts R to join and ag-gregate relations (see Table 1). Let us start by con-sidering a DCS tree z with only join relations. Such a z defines a constraint satisfaction problem (CSP) with nodes as variables. The CSP has two types of constraints: (i) x  X  w ( p ) for each node x labeled with predicate p  X  P ; and (ii) x j = y j 0 (the j -th component of x must equal the j 0 -th component of y ) for each edge ( x,y ) labeled with j j 0  X  X  .
A solution to the CSP is an assignment of nodes to values that satisfies all the constraints. We say a value v is consistent for a node x if there exists a solution that assigns v to x . The denotation evaluated on w ) is the set of consistent values of the root node (see Figure 2 for an example).
 Computation We can compute the denotation J z gramming on trees (Dechter, 2003). The recurrence is as follows: At each node, we compute the set of tuples v consis-tent with the predicate at that node ( v  X  w ( p ) ), and for each child i , the j i -th component of v must equal the j 0 i -th component of some t in the child X  X  deno-tation ( t  X  number of nodes times the size of the denotations. 1 Now the dual importance of trees in DCS is clear: We have seen that trees parallel syntactic depen-dency structure, which will facilitate parsing. In addition, trees enable efficient computation, thereby establishing a new connection between dependency syntax and efficient semantic evaluation.
 Aggregate relation DCS trees that only use join relations can represent arbitrarily complex compo-sitional structures, but they cannot capture higher-order phenomena in language. For example, con-sider the phrase number of major cities , and suppose that number corresponds to the count predicate. It is impossible to represent the semantics of this phrase with just a CSP, so we introduce a new ag-gregate relation , notated  X  . Consider a tree  X   X  : c  X  , whose root is connected to a child c via  X  . If the de-notation of c is a set of values s , the parent X  X  denota-tion is then a singleton set containing s . Formally:
Figure 3(a) shows the DCS tree for our running example. The denotation of the middle node is { s } , where s is all major cities. Having instantiated s as a value, everything above this node is an ordinary CSP: s constrains the count node, which in turns constrains the root node to | s | .

A DCS tree that contains only join and aggre-gate relations can be viewed as a collection of tree-structured CSPs connected via aggregate relations. The tree structure still enables us to compute deno-tations efficiently based on (1) and (2). 2.2 Full Version The basic version of DCS described thus far han-dles a core subset of language. But consider Fig-ure 4: (a) is headed by borders , but states needs to be extracted; in (b), the quantifier no is syntacti-cally dominated by the head verb borders but needs to take wider scope. We now present the full ver-sion of DCS which handles this type of divergence between syntactic and semantic scope.

The key idea that allows us to give semantically-scoped denotations to syntactically-scoped trees is as follows: We mark a node low in the tree with a mark relation (one of E , Q , or C ). Then higher up in the tree, we invoke it with an execute relation X i to create the desired semantic scope. 2
This mark-execute construct acts non-locally, so to maintain compositionality, we must augment the denotation d = about the marked nodes in z that can be accessed by an execute relation later on. In the basic ver-sion, d was simply the consistent assignments to the root. Now d contains the consistent joint assign-ments to the active nodes (which include the root and all marked nodes), as well as information stored about each marked node. Think of d as consisting of n columns , one for each active node according to a pre-order traversal of z . Column 1 always corre-sponds to the root node. Formally, a denotation is defined as follows (see Figure 5 for an example): Definition 2 (Denotations) Let D be the set of de-notations, where each d  X  X  consists of  X  a set of arrays d.A , where each array a =  X  a list of n stores d.  X  = ( d. X  1 ,...,d. X  n ) , We write d as  X  X  A ; ( r 1 ,b 1 ,c 1 ); ... ; ( r n ,b n ,c use d { r i = x } to mean d with d.r i = d. X  i .r = x (similar definitions apply for d {  X  i = x } , d { b i = x } , and d { c i = x } ).

The denotation of a DCS tree can now be defined recursively:
The base case is defined in (3): if z is a sin-gle node with predicate p , then the denotation of z has one column with the tuples w ( p ) and an empty store. The other six cases handle different edge re-lations. These definitions depend on several opera-tions ( ./ j , j 0 ,  X  , X i , M ) which we will define shortly, but let us first get some intuition.

Let z be a DCS tree. If the last child c of z  X  X  root is a join ( j j 0 ), aggregate (  X  ), or execute ( X lation ((4) X (6)), then we simply recurse on z with c removed and join it with some transformation (iden-tity,  X  , or X i ) of c  X  X  denotation. If the last (or first) child is connected via a mark relation E , C (or Q ), then we strip off that child and put the appropriate information in the store by invoking M .
 We now define the operations ./ j , j 0 ,  X  , X i , M . Some helpful notation: For a sequence v = ( v 1 ,...,v n ) and indices i = ( i 1 ,...,i k ) , let v i = ( v i 1 ,...,v i k ) be the projection of v onto i ; we write v denotations, let  X  X  A ;  X   X  X  [ i ] =  X  X  X  a i : a  X  A } ;  X  Let d [  X   X  ] = d [  X  i ] , where i are the columns with empty stores. For example, for d in Figure 5, d [1] keeps column 1, d [  X   X  ] keeps column 2, and d [2 ,  X  2] swaps the two columns.
 Join The join of two denotations d and d 0 with re-spect to components j and j 0 (  X  means all compo-nents) is formed by concatenating all arrays a of d with all compatible arrays a 0 of d 0 , where compat-ibility means a 1 j = a 0 1 j 0 . The stores are also con-catenated (  X  +  X  0 ). Non-initial columns with empty stores are projected away by applying  X  [1 ,  X   X  ] . The full definition of join is as follows:  X  X  A ;  X   X  X  ./ j , j 0  X  X  A 0 ;  X  0  X  X  =  X  X  A 00 ;  X  +  X  0 A 00 = { a + a 0 : a  X  A, a 0  X  A 0 ,a 1 j = a 0 1 j 0 } . (10) Aggregate The aggregate operation takes a deno-tation and forms a set out of the tuples in the first column for each setting of the rest of the columns:  X  (  X  X  A ;  X   X  X  ) =  X  X  A 0  X  A 00 ;  X   X  X  (11) 2.2.1 Mark and Execute
Now we turn to the mark ( M ) and execute ( X i ) operations, which handles the divergence between syntactic and semantic scope. In some sense, this is the technical core of DCS. Marking is simple: When a node (e.g., size in Figure 5) is marked (e.g., with relation C ), we simply put the relation r , current de-notation d and child c  X  X  denotation into the store of column 1: M ( d,r,c ) = d { r 1 = r,b 1 = d,c 1 =
The execute operation X i ( d ) processes columns i in reverse order. It suffices to define X i ( d ) for a single column i . There are three cases: Extraction ( d.r i = E ) In the basic version, the denotation of a tree was always the set of con-sistent values of the root node. Extraction al-lows us to return the set of consistent values of a marked non-root node. Formally, extraction sim-ply moves the i -th column to the front: X i ( d ) = d [ i,  X  ( i,  X  )] {  X  1 =  X  } . For example, in Figure 4(a), before execution, the denotation of the DCS tree is  X  X  X  [( CA , OR ) , ( OR )] ,... } ;  X  ; ( E , after applying X 1 , we have  X  X  X  [( OR )] ,... } ;  X   X  X  . Generalized Quantification ( d.r i = Q ) Gener-alized quantifiers are predicates on two sets, a re-strictor A and a nuclear scope B . For example, w ( no ) = { ( A,B ) : A  X  B =  X  X  and w ( most ) = { ( A,B ) : | A  X  B | &gt; 1
In a DCS tree, the quantifier appears as the child of a Q relation, and the restrictor is the par-ent (see Figure 4(b) for an example). This in-formation is retrieved from the store when the quantifier in column i is executed. In particu-lar, the restrictor is A =  X  ( d.b i ) and the nu-clear scope is B =  X  ( d [ i,  X  ( i,  X  )]) . We then apply d.c i to these two sets (technically, denota-tions) and project away the first column: X i ( d ) = (( d.c i ./ 1 , 1 A ) ./ 2 , 1 B ) [  X  1] .

For the example in Figure 4(b), the de-notation of the DCS tree before execution is  X  X  X  X  ;  X  ; ( Q , set ( A ) is the set of all states, and the nuclear scope ( B ) is the empty set. Since ( A,B ) exists in no , the final denotation, which projects away the actual pair, is  X  X  X  [ ] } X  X  (our representation of true).

Figure 4(c) shows an example with two interact-ing quantifiers. The quantifier scope ambiguity is resolved by the choice of execute relation; X 12 gives the narrow reading and X 21 gives the wide reading. Figure 4(d) shows how extraction and quantification work together.
 Comparatives and Superlatives ( d.r i = C ) To compare entities, we use a set S of ( x,y ) pairs, where x is an entity and y is a number. For su-perlatives, the argmax predicate denotes pairs of sets and the set X  X  largest element(s): w ( argmax ) = { ( S,x  X  ) : x  X   X  argmax x  X  S paratives, w ( more ) contains triples ( S,x,y ) , where x is  X  X ore than X  y as measured by S ; formally: w ( more ) = { ( S,x,y ) : max S ( x ) &gt; max S ( y ) } .
In a superlative/comparative construction, the root x of the DCS tree is the entity to be compared, the child c of a C relation is the comparative or su-perlative, and its parent p contains the information used for comparison (see Figure 4(e) for an exam-ple). If d is the denotation of the root, its i -th column contains this information. There are two cases: (i) if the i -th column of d contains pairs (e.g., size in Figure 5), then let d 0 = reads out the second components of these pairs; (ii) otherwise (e.g., state in Figure 4(e)), let d 0 = J  X   X   X  counts the number of things (e.g., states) that occur with each value of the root x . Given d 0 , we construct a denotation S by concatenating ( + i ) the second and first columns of d 0 ( S =  X  (+ 2 , 1 ( d 0 {  X  2 =  X  } )) ) and apply the superlative/comparative: X i ( d ) = (
J  X   X   X 
Figure 4(f) shows that comparatives are handled using the exact same machinery as superlatives. Fig-ure 4(g) shows that we can naturally account for superlative ambiguity based on where the scope-determining execute relation is placed. We now turn to the task of mapping natural language utterances to DCS trees. Our first question is: given an utterance x , what trees z  X  X  are permissible? To define the search space, we first assume a fixed set of lexical triggers L . Each trigger is a pair ( x ,p ) , where x is a sequence of words (usually one) and p is a predicate (e.g., x = California and p = CA ). We use L ( x ) to denote the set of predicates p trig-gered by x ( ( x ,p )  X  L ). Let L ( ) be the set of trace predicates , which can be introduced without an overt lexical trigger.
 Given an utterance x = ( x 1 ,...,x n ) , we define Z
L ( x )  X  Z , the set of permissible DCS trees for x . The basic approach is reminiscent of projective labeled dependency parsing: For each span i..j , we build a set of trees C i,j and set Z L ( x ) = C 0 ,n . Each set C i,j is constructed recursively by combining the trees of its subspans C i,k and C k 0 ,j for each pair of split points k,k 0 (words between k and k 0 are ig-nored). These combinations are then augmented via a function A and filtered via a function F , to be spec-ified later. Formally, C i,j is defined recursively as follows: In (13), L ( x i +1 ..j ) is the set of predicates triggered by the phrase under span i..j (the base case), and T ( a,b ) = ~ T d ( a,b )  X  ways of combining trees a and b where b is a de-scendant of a ( ~ T d ) or vice-versa ( defined recursively as follows: ~ T 0 ( a,b ) =  X  , and ~
T d ( a,b ) = [ The latter ( ~ T ( a,b ) allows us to insert up to d trace predi-cates between the roots of a and b . This is use-ful for modeling relations in noun compounds (e.g., California cities ), and it also allows us to underspec-ify L . In particular, our L will not include verbs or prepositions; rather, we rely on the predicates corre-sponding to those words to be triggered by traces.
The augmentation function A takes a set of trees and optionally attaches E and X i relations to the root (e.g., A (  X  city  X  ) = { X  city  X  ,  X  city ; E :  X   X  X  ). The filtering function F rules out improperly-typed trees such as  X  city ; 0 0 :  X  state  X  X  . To further reduce the search space, F imposes a few additional con-straints, e.g., limiting the number of marked nodes to 2 and only allowing trace predicates between ar-ity 1 predicates.
 Model We now present our discriminative se-mantic parsing model, which places a log-linear distribution over z  X  Z L ( x ) given an utter-where  X  and  X  ( x ,z ) are parameter and feature vec-tors, respectively. As a running example, con-sider x = city that is in California and z =  X  city ; 1 1 :  X  loc ; 2 1 :  X  CA  X  X  X  , where city triggers and California triggers CA .

To define the features, we technically need to augment each tree z  X  Z L ( x ) with alignment information X  X amely, for each predicate in z , the span in x (if any) that triggered it. This extra infor-mation is already generated from the recursive defi-nition in (13).

The feature vector  X  ( x ,z ) is defined by sums of five simple indicator feature templates: ( F 1 ) a word triggers a predicate (e.g., [ city , city ] ); ( F 2 ) a word der a trace predicate (e.g., [ in , loc ] ); ( F 4 ) two pred-icates are linked via a relation in the left or right direction (e.g., [ city , 1 1 , loc , RIGHT ] ); and ( F predicate has a child relation (e.g., [ city , 1 1 ] ). Learning Given a training dataset D con-taining ( x ,y ) pairs, we define the regu-larized marginal log-likelihood objective Z
L ( x ))  X   X  k  X  k 2 2 , which sums over all DCS trees z that evaluate to the target answer y .
 Our model is arc-factored, so we can sum over all DCS trees in Z L ( x ) using dynamic programming. However, in order to learn, we need to sum over { z  X  Z L ( x ) : additional constraint We therefore resort to beam search. Specifically, we truncate each C i,j to a maximum of K candidates sorted by decreasing score based on parameters  X  . Let  X  Z L, X  ( x ) be this approximation of Z L ( x ) .
Our learning algorithm alternates between (i) us-ing the current parameters  X  to generate the K -best set  X  Z L, X  ( x ) for each training example x , and (ii) optimizing the parameters to put probability mass on the correct trees in these sets; sets contain-ing no correct answers are skipped. Formally, let  X  O (  X , X  0 ) be the objective function O (  X  ) with Z L ( x ) replaced with  X  Z L, X  0 ( x ) . We optimize  X  O (  X , X  setting  X  (0) = ~ 0 and iteratively solving  X  ( t +1) = argmax  X   X  O (  X , X  ( t ) ) using L-BFGS until t = T . In all experiments, we set  X  = 0 . 01 , T = 5 , and K = 100 . After training, given a new utterance x , our system outputs the most likely y , summing out the latent We tested our system on two standard datasets, G EO and J OBS . In each dataset, each sentence x is an-notated with a Prolog logical form, which we use only to evaluate and get an answer y . This evalua-tion is done with respect to a world w . Recall that a world w maps each predicate p  X  P to a set of tuples w ( p ) . There are three types of predicates in P : generic (e.g., argmax ), data (e.g., city ), and value (e.g., CA ). G EO has 48 non-value predicates and J OBS has 26. For G EO , w is the standard US geography database that comes with the dataset. For J
OBS , if we use the standard Jobs database, close to half the y  X  X  are empty, which makes it uninteresting. We therefore generated a random Jobs database in-stead as follows: we created 100 job IDs. For each data predicate p (e.g., language ), we add each pos-sible tuple (e.g., ( job37 , Java ) ) to w ( p ) indepen-dently with probability 0.8.

We used the same training-test splits as Zettle-moyer and Collins (2005) (600+280 for G EO and 500+140 for J OBS ). During development, we fur-ther held out a random 30% of the training sets for validation.

Our lexical triggers L include the following: (i) predicates for a small set of  X  20 function words (e.g., ( most , argmax ) ), (ii) ( x,x ) for each value System Accuracy Clarke et al. (2010) w/answers 73.2 Clarke et al. (2010) w/logical forms 80.4 Our system (DCS with L ) 78.9 Our system (DCS with L + ) 87.2 predicate x in w (e.g., ( Boston , Boston ) ), and (iii) predicates for each POS tag in { JJ , NN , NNS (e.g., ( JJ , size ) , ( JJ , area ) , etc.). 3 Predicates corresponding to verbs and prepositions (e.g., traverse ) are not included as overt lexical trig-gers, but rather in the trace predicates L ( ) .
We also define an augmented lexicon L + which includes a prototype word x for each predicate ap-pearing in (iii) above (e.g., ( large , size ) ), which cancels the predicates triggered by x  X  X  POS tag. For G
EO , there are 22 prototype words; for J OBS , there are 5. Specifying these triggers requires minimal domain-specific supervision.
 Results We first compare our system with Clarke et al. (2010) (henceforth, S EM R ESP ), which also learns a semantic parser from question-answer pairs. Table 2 shows that our system using lexical triggers L (henceforth, DCS ) outperforms S EM R ESP (78.9% over 73.2%). In fact, although neither DCS nor S
EM R ESP uses logical forms, DCS uses even less su-pervision than S EM R ESP . S EM R ESP requires a lex-icon of 1.42 words per non-value predicate, Word-Net features, and syntactic parse trees; DCS requires only words for the domain-independent predicates (overall, around 0.5 words per non-value predicate), POS tags, and very simple indicator features. In fact, DCS performs comparably to even the version of S EM R ESP trained using logical forms. If we add prototype triggers (use L + ), the resulting system (
DCS + ) outperforms both versions of S EM R ESP by a significant margin (87.2% over 73.2% and 80.4%).
Next, we compared our systems ( DCS and DCS + ) with the state-of-the-art semantic parsers on the full dataset for both G EO and J OBS (see Table 3). All other systems require logical forms as training data, whereas ours does not. Table 3 shows that even DCS , which does not use prototypes, is comparable to the best previous system (Kwiatkowski et al., 2010), and by adding a few prototypes, DCS + offers a decisive edge (91.1% over 88.9% on G EO ). Rather than us-ing lexical triggers, several of the other systems use IBM word alignment models to produce an initial word-predicate mapping. This option is not avail-able to us since we do not have annotated logical forms, so we must instead rely on lexical triggers to define the search space. Note that having lexical triggers is a much weaker requirement than having a CCG lexicon, and far easier to obtain than logical forms.
 Intuitions How is our system learning? Initially, the weights are zero, so the beam search is essen-tially unguided. We find that only for a small frac-tion of training examples do the K -best sets contain any trees yielding the correct answer (29% for DCS on G EO ). However, training on just these exam-ples is enough to improve the parameters, and this 29% increases to 66% and then to 95% over the next few iterations. This bootstrapping behavior occurs naturally: The  X  X asy X  examples are processed first, where easy is defined by the ability of the current model to generate the correct answer using any tree.
Our system learns lexical associations between words and predicates. For example, area (by virtue of being a noun) triggers many predicates: city , state , area , etc. Inspecting the final parameters (
DCS on G EO ), we find that the feature [ area , area ] has a much higher weight than [ area , city ] . Trace predicates can be inserted anywhere, but the fea-tures favor some insertions depending on the words present (for example, [ in , loc ] has high weight).
The errors that the system makes stem from mul-tiple sources, including errors in the POS tags (e.g., states is sometimes tagged as a verb, which triggers no predicates), confusion of Washington state with Washington D.C., learning the wrong lexical asso-ciations due to data sparsity, and having an insuffi-ciently large K . A major focus of this work is on our semantic rep-resentation, DCS, which offers a new perspective on compositional semantics. To contrast, consider CCG (Steedman, 2000), in which semantic pars-ing is driven from the lexicon. The lexicon en-codes information about how each word can used in context; for example, the lexical entry for borders is S \ NP / NP :  X y. X x. border ( x,y ) , which means borders looks right for the first argument and left for the second. These rules are often too stringent, and for complex utterances, especially in free word-order languages, either disharmonic combinators are employed (Zettlemoyer and Collins, 2007) or words are given multiple lexical entries (Kwiatkowski et al., 2010).

In DCS, we start with lexical triggers, which are more basic than CCG lexical entries. A trigger for borders specifies only that border can be used, but not how. The combination rules are encoded in the features as soft preferences. This yields a more factorized and flexible representation that is easier to search through and parametrize using features. It also allows us to easily add new lexical triggers without becoming mired in the semantic formalism.
Quantifiers and superlatives significantly compli-cate scoping in lambda calculus, and often type rais-ing needs to be employed. In DCS, the mark-execute construct provides a flexible framework for dealing with scope variation. Think of DCS as a higher-level programming language tailored to natural language, which results in programs (DCS trees) which are much simpler than the logically-equivalent lambda calculus formulae.

The idea of using CSPs to represent semantics is inspired by Discourse Representation Theory (DRT) (Kamp and Reyle, 1993; Kamp et al., 2005), where variables are discourse referents. The restriction to trees is similar to economical DRT (Bos, 2009).
The other major focus of this work is program induction X  X nferring logical forms from their deno-tations. There has been a fair amount of past work on this topic: Liang et al. (2010) induces combinatory logic programs in a non-linguistic setting. Eisen-stein et al. (2009) induces conjunctive formulae and uses them as features in another learning problem. Piantadosi et al. (2008) induces first-order formu-lae using CCG in a small domain assuming observed lexical semantics. The closest work to ours is Clarke et al. (2010), which we discussed earlier.

The integration of natural language with denota-tions computed against a world (grounding) is be-coming increasingly popular. Feedback from the world has been used to guide both syntactic parsing (Schuler, 2003) and semantic parsing (Popescu et al., 2003; Clarke et al., 2010). Past work has also fo-cused on aligning text to a world (Liang et al., 2009), using text in reinforcement learning (Branavan et al., 2009; Branavan et al., 2010), and many others. Our work pushes the grounded language agenda towards deeper representations of language X  X hink grounded compositional semantics. We built a system that interprets natural language utterances much more accurately than existing sys-tems, despite using no annotated logical forms. Our system is based on a new semantic representation, DCS, which offers a simple and expressive alter-native to lambda calculus. Free from the burden of annotating logical forms, we hope to use our techniques in developing even more accurate and broader-coverage language understanding systems. Acknowledgments We thank Luke Zettlemoyer and Tom Kwiatkowski for providing us with data and answering questions.
