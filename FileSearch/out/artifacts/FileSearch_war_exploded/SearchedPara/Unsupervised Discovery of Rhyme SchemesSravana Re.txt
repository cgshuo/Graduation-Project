 Rhyming stanzas of poetry are characterized by rhyme schemes, patterns that specify how the lines in the stanza rhyme with one another. The question we raise in this paper is: can we infer the rhyme scheme of a stanza given no information about pro-nunciations or rhyming relations among words? Background A rhyme scheme is represented as a string corresponding to the sequence of lines that comprise the stanza, in which rhyming lines are de-noted by the same letter. For example, the limerick X  X  rhyme scheme is aabba , indicating that the 1 st , 2 nd , and 5 th lines rhyme, as do the the 3 rd and 4 th . Motivation Automatic rhyme scheme annotation would benefit several research areas, including:  X  Machine Translation of Poetry There has been  X   X  X ulturomics X  The field of digital humanities  X  Historical Linguistics/Study of Dialects
An obvious approach to finding rhyme schemes is to use word pronunciations and a definition of rhyme, in which case the problem is fairly easy. However, we favor an unsupervised solution that uti-lizes no external knowledge for several reasons.  X  Pronunciation dictionaries are simply not avail- X  The definition of rhyme varies across poetic  X  Pronunciations and spelling conventions There have been a number of recent papers on the automated annotation, analysis, or translation of po-etry. Greene et al. (2010) use a finite state trans-ducer to infer the syllable-stress assignments in lines of poetry under metrical constraints. Genzel et al. (2010) incorporate constraints on meter and rhyme (where the stress and rhyming information is derived from a pronunciation dictionary) into a machine translation system. Jiang and Zhou (2008) develop a system to generate the second line of a Chinese cou-plet given the first. A few researchers have also ex-plored the problem of poetry generation under some constraints (Manurung et al., 2000; Netzer et al., 2009; Ramakrishnan et al., 2009). There has also been some work on computational approaches to characterizing rhymes (Byrd and Chodorow, 1985) and global properties of the rhyme network (Son-deregger, 2011) in English. To the best of our knowl-edge, there has been no language-independent com-putational work on finding rhyme schemes. A collection of rhyming poetry inevitably contains repetition of rhyming pairs . For example, the word trees will often rhyme with breeze across different stanzas, even those with different rhyme schemes and written by different authors. This is partly due to sparsity of rhymes  X  many words that have no rhymes at all, and many others have only a handful, forcing poets to reuse rhyming pairs.

In this section, we describe an unsupervised al-gorithm to infer rhyme schemes that harnesses this repetition, based on a model of stanza generation. 3.1 Generative Model of a Stanza 1. Pick a rhyme scheme r of length n with proba-2. For each i  X  [1 ,n ] , pick a word sequence,
The probability of a stanza x of length n is given by Eq. 1. I i,r is the indicator variable for whether line i rhymes with at least one previous line under r . 3.2 Learning We denote our data by X , a set of stanzas. Each stanza x is represented as a sequence of its line-end words, x i ,...x len ( x ) . We are also given a large set R of all possible rhyme schemes. 3
If each stanza in the data is generated indepen-dently (an assumption we relax in  X  4), the log-likelihood of the data is P x  X  X log P ( x ) . We would like to maximize this over all possible rhyme scheme assignments, under the latent variables  X  , which rep-resents pairwise rhyme strength , and  X  , the distribu-tion of rhyme schemes.  X  v,w is defined for all words v and w as a non-negative real value indicating how strongly the words v and w rhyme, and  X  r is P ( r ) .
The expectation maximization (EM) learning al-gorithm for this formulation is described below. The intuition behind the algorithm is this: after one iter-ation,  X  v,w = 0 for all v and w that never occur to-gether in a stanza. If v and w co-occur in more than one stanza,  X  v,w has a high pseudo-count, reflecting the fact that they are likely to be rhymes.

Initialize:  X  and  X  uniformly (giving  X  the same Expectation Step: Compute P ( r | x ) =
Maximization Step: Update  X  and  X  :
After Convergence: Label each stanza x with the 3.3 Data We test the algorithm on rhyming poetry in En-glish and French. The English data is an edited ver-sion of the public-domain portion of the corpus used by Sonderegger (2011), and consists of just under 12000 stanzas spanning a range of poets and dates from the 15 th to 20 th centuries. The French data is from the ARTFL project (Morrissey, 2011), and contains about 3000 stanzas. All poems in the data are manually annotated with rhyme schemes.

The set R is taken to be all the rhyme schemes from the gold standard annotations of both corpora, numbering 462 schemes in total, with an average of 6 . 5 schemes per stanza length. There are 27 . 12 can-didate rhyme schemes on an average for each En-glish stanza, and 33 . 81 for each French stanza. 3.4 Results We measure the accuracy of the discovered rhyme schemes relative to the gold standard. We also eval-uate for each word token x i , the set of words in { x i +1 ,x i +2 ,... } that are found to rhyme with x i by measuring precision and recall . This is to account for partial correctness  X  if abcb is found instead of abab , for example, we would like to credit the algo-rithm for knowing that the 2 nd and 4 th lines rhyme.
Table 1 shows the results of the algorithm for the entire corpus in each language, as well as for a few sub-corpora from different time periods. 3.5 Orthographic Similarity Bias So far, we have relied on the repetition of rhymes, and have made no assumptions about word pronun-ciations. Therefore, the algorithm X  X  performance is strongly correlated 4 with the predictability of rhyming words. For writing systems where the written form of a word approximates its pronunci-ation, we have some additional information about rhyming: for example, English words ending with similar characters are most probably rhymes. We do not want to assume too much in the interest of language-independence  X  following from our earlier point in  X  1 about the nebulous definition of rhyme  X  but it is safe to say that rhyming words involve some orthographic similarity (though this does not hold for writing systems like Chinese). We therefore initialize  X  at the start of EM with a simple similarity measure: (Eq. 5). The addition of = 0 . 001 ensures that words with no letters in common, like new and you , are not eliminated as rhymes.
This simple modification produces results that outperform the na  X   X ve baselines for most of the data by a considerable margin, as detailed in Table 2. 3.6 Using Pronunciation, Rhyming Definition How does our algorithm compare to a standard sys-tem where rhyme schemes are determined by pre-defined rules of rhyming and dictionary pronunci-ations? We use the accepted definition of rhyme in English: two words rhyme if their final stressed vowels and all following phonemes are identical. For every pair of English words v,w , we let  X  v,w = 1 + if the CELEX (Baayen et al., 1995) pronun-ciations of v and w rhyme, and  X  v,w = 0 + if not (with = 0 . 001 ). If either v or w is not present in CELEX, we set  X  v,w to a random value in [0 , 1] . We then find the best rhyme scheme for each stanza, using Eq. 2 with uniformly initialized  X  .

Figure 1 shows that the accuracy of this system is generally much lower than that of our model for the sub-corpora from before 1750. Performance is comparable for the 1750-1850 data, after which we get better accuracies using the rhyming definition than with our model. This is clearly a reflection of language change; older poetry differs more signifi-cantly in pronunciation and lexical usage from con-temporary dictionaries, and therefore, benefits more from a model that assumes no pronunciation knowl-edge. (While we may get better results on older data using dictionaries that are historically accurate, these are not easily available, and require a great deal of effort and linguistic knowledge to create.) Initializing  X  as specified above and then running EM produces some improvement compared to or-thographic similarity (Table 2). So far, we have treated stanzas as being indepen-dent of each other. In reality, stanzas in a poem are usually generated using the same or similar rhyme schemes. Furthermore, some rhyme schemes span multiple stanzas  X  for example, the Italian form terza rima has the scheme aba bcb cdc... (the 1 st and 3 rd lines rhyme with the 2 nd line of the previous stanza). 4.1 Generative Model We model stanza generation within a poem as a Markov process, where each stanza is conditioned on the previous one. To generate a poem y consist-ing of m stanzas, for each k  X  [1 ,m ] , generate a stanza x k of length n k as described below: 1. If k = 1 , pick a rhyme scheme r k of length n k 2. If k &gt; 1 , pick a scheme r k of length n k with 4.2 Learning This model for a poem can be formalized as an au-toregressive HMM , an hidden Markov model where each observation is conditioned on the previous ob-servation as well as the latent state. An observation at a time step k is the stanza x k , and the latent state at that time step is the rhyme scheme r k . This model is parametrized by  X  and  X  , where  X  r,q = P ( r | q ) for all schemes r and q .  X  is initialized with orthographic similarity. The learning algorithm follows from EM for HMMs and our earlier algorithm.

Expectation Step: Estimate P ( r | x ) for each
Maximization Step: Update  X  and  X  analogously 4.3 Results As Table 2 shows, there is considerable improve-ment over models that assume independent stanzas. The most gains are found in French, which contains many instances of  X  X inked X  stanzas like the terza rima , as well as English data containing long poems made of several stanzas with the same scheme. Some possible extensions of our work include au-tomatically generating the set of possible rhyme schemes R , and incorporating partial supervision into our algorithm as well as better ways of using and adapting pronunciation information when avail-able. We would also like to test our method on a range of languages and texts.

To return to the motivations, one could use the discovered annotations for machine translation of poetry, or to computationally reconstruct pro-nunciations, which is useful for historical linguis-tics as well as other applications involving out-of-vocabulary words.
 We would like to thank Morgan Sonderegger for providing most of the annotated English data in the rhyming corpus and for helpful discussion, and the anonymous reviewers for their suggestions.
