 This paper presents an algorithm for solving the following class of online resource allocation prob-lems. We are given as input a finite set V of activities . A pair ( v, X  )  X  V  X  R &gt; 0 is called an action , and represents spending time  X  performing activity v . A schedule is a sequence of actions. We use S to denote the set of all schedules. A job is a function f : S  X  [0 , 1] , where for any schedule S  X  S , f ( S ) represents the proportion of some task that is accomplished by performing the sequence of actions S . We require that a job f have the following properties (here  X  is the concatenation operator): We will evaluate schedules in terms of two objectives. The first objective, which we call benefit-` ( S ) = 6 . The second objective is to minimize the cost of a schedule, which we define as where S  X  t  X  is the schedule that results from truncating schedule S at time t . For example if S = that f ( S ) is the probability that some desired event occurs as a result of performing the actions in the expected time we must wait before the desired event occurs if we execute actions according to the schedule S . The following example illustrates these definitions.
 Example 1. Let each activity v represent a randomized algorithm for solving some decision prob-lem, and let the action ( v, X  ) represent running the algorithm (with a fresh random seed) for time  X  . Fix some particular instance of the decision problem, and for any schedule S , let f ( S ) be the probability that one (or more) of the runs in the sequence S yields a solution to that instance. So f ( S  X  T  X  ) is (by definition) the probability that performing the runs in schedule S yields a solution to the problem instance in time  X  T , while c ( f,S ) is the expected time that elapses before a so-lution is obtained. It is clear that f ( S ) is monotone, because adding runs to the sequence S can only increase the probability that one of the runs is successful. The fact that f is submodular can be seen as follows. For any schedule S and action a , f a ( S ) equals the probability that action a together with the monotonicity of f , implies that for any schedules S 1 ,S 2 and any action a , we have f ( S 1  X  S 2 ) = (1  X  f ( S 1  X  S 2 ))  X  f (  X  a  X  )  X  (1  X  f ( S 1 ))  X  f (  X  a  X  ) = f a ( S 1 ) . we must finish each job (via some schedule) before moving on to the next job. When selecting a but we have no knowledge of f ( i ) itself or of any subsequent jobs. In this setting we aim to minimize regret , which measures the difference between the average cost (or average benefit) of the schedules produced by our online algorithm and that of the best single schedule (in hindsight) for the given sequence of jobs. 1.1 Problems that fit into this framework A number of previously-studied problems can be cast as the task of computing a schedule S that expression can be interpreted as follows: the job f consists of n subtasks, and p i ( v, X  ) is the prob-ability that investing time  X  in activity v completes the i th subtask. Thus, f ( S ) is the expected fraction of subtasks that are finished after performing the sequence of actions S . Assuming p i ( v, X  ) is a non-decreasing function of  X  for all i and v , it can be shown that any function f of this form is monotone and submodular. P IPELINED S ET C OVER [11, 15] can be defined as the special case in otherwise. M IN -S UM S ET C OVER [7] is the special case in which, additionally,  X  v = 1 or  X  v =  X  for all v  X  V . The problem of constructing efficient sequences of trials [5] corresponds to the case in which we are given a matrix q , and p i ( v, X  ) = q v,i if  X   X  1 and p i ( v, X  ) = 0 otherwise. monotone submodular set function subject to a knapsack constraint [14, 20] (which in turn gener-alizes B UDGETED M AXIMUM C OVERAGE [12], which generalizes M AX k -C OVERAGE [16]). The only difference between the two problems is that, in the latter problem, f ( S ) may only depend on the set of actions in the sequence S , and not on the order in which the actions appear. 1.2 Applications We now discuss three applications, the first of which is the focus of our experiments in  X  5. 1. Online algorithm portfolio design. An algorithm portfolio [9] is a schedule for interleaving the execution of multiple (randomized) algorithms and periodically restarting them with a fresh random seed. Previous work has shown that combining multiple heuristics for NP-hard problems into a port-folio can dramatically reduce average-case running time [8, 9, 19]. In particular, algorithms based on chronological backtracking often exhibit heavy-tailed run length distributions, and periodically restarting them with a fresh random seed can reduce the mean running time by orders of magnitude [8]. As illustrated in Example 1, our algorithms can be used to learn an effective algorithm portfolio online, in the course of solving a sequence of problem instances. 2. Database query processing. In database query processing, one must extract all the records in a database that satisfy every predicate in a list of one or more predicates (the conjunction of predicates comprises the query). To process the query, each record is evaluated against the predicates one at a time until the record either fails to satisfy some predicate (in which case it does not match the query) or all predicates have been examined. The order in which the predicates are examined affects the time required to process the query. Munagala et al. [15] introduced and studied a problem called P IPELINED S ET C OVER (discussed in  X  1.1), which entails finding an evaluation order for the predicates that minimizes the average time required to process a record. Our work addresses the online version of this problem, which arises naturally in practice. 3. Sensor placement. Sensor placement is the task of assigning locations to a set of sensors so as to maximize the value of the information obtained (e.g., to maximize the number of intrusions that are detected by the sensors). Many sensor placement problems can be optimally solved by maximizing a monotone submodular set function subject to a knapsack constraint [13], a special case of our benefit-maximization problem (see  X  1.1). Our online algorithms could be used to select sensor placements when the same set of sensors is repeatedly deployed in an unknown or adversarial environment. 1.3 Summary of results results [6, 7], we find that, for any &gt; 0 , ( i ) achieving an approximation ratio of 4  X  for the cost-minimization problem is NP-hard and ( ii ) achieving an approximation ratio of 1  X  1 e + for the benefit-maximization problem is NP-hard. We then present a greedy approximation algorithm that simultaneously achieves the optimal approximation ratios (of 4 and 1  X  1 e ) for these two problems, building on and generalizing previous work on special cases of these two problems [7, 20]. In the online setting we provide an online algorithm whose worst-case performance guarantees ap-proach those of the offline greedy approximation algorithm asymptotically (as the number of jobs approaches infinity). We then show how to modify our online algorithm for use in several different  X  X andit X  feedback settings. Finally, we prove information-theoretic lower bounds on regret. We conclude with an experimental evaluation. As discussed in  X  1.1, the offline cost-minimization problem considered here generalizes M IN -S UM S
ET C OVER [7], P IPELINED S ET C OVER [11, 15], and the problem of constructing efficient se-quences of trials [5]. Several of these problems have been considered in the online setting. Mu-nagala et al. [15] gave an online algorithm for P IPELINED S ET C OVER that is asymptotically O (log |V| ) -competitive. Babu et al. [3] and Kaplan et al. [11] gave online algorithms for P IPE -LINED S ET C OVER that are asymptotically 4-competitive, but only in the special case where the jobs are drawn independently at random from a fixed probability distribution (whereas our online algorithm is asymptotically 4-competitive on an arbitrary sequence of jobs).
 Our offline benefit-maximization problem generalizes the problem of maximizing a monotone sub-modular set function subject to a knapsack constraint. Previous work gave offline greedy approx-imation algorithms for this problem [14, 20], which generalized earlier algorithms for B UDGETED M
AXIMUM C OVERAGE [12] and M AX k -C OVERAGE [16]. To our knowledge, none of these prob-lems have previously been studied in an online setting. Note that our problem is quite different from online set covering problems (e.g., [1]) that require one to construct a single collection of sets that covers each element in a sequence of elements that arrive online.
 In this paper we convert a specific greedy approximation algorithm into an online algorithm. Re-cently, Kakade et al. [10] gave a generic procedure for converting an  X  -approximation algorithm optimization problems, but not to the non-linear problems we consider here.
 Independently of us, Radlinkski et al. [17] developed a no-regret algorithm for the online version of M
AX k -C OVERAGE , and applied it to online ranking. As it turns out, their algorithm is a special case of the algorithm OG unit that we present in  X  4.1. In the offline setting, we are given as input a job f : S  X  [0 , 1] . Our goal is to compute a schedule S that achieves one of two objectives, either minimizing the cost c ( f,S ) or maximizing f ( S ) subject to the constraint ` ( S )  X  T . 2 As already mentioned, this offline problem generalizes M IN -S UM S ET C
OVER under the former objective and generalizes M AX k -C OVERAGE under the latter objective, which implies the following computational complexity result [6, 7].
 Theorem 1. For any &gt; 0 , achieving a 4  X  (resp. 1  X  1 e + ) approximation ratio for the cost-minimization (resp. benefit-maximization) problem is NP-hard.
 bounds on the performance of G in terms of the j values. Note that we can ensure j = 0  X  j by schedule so as to maximize the resulting increase in f per unit time). A key property is stated in the following lemma, which follows from the submodularity assumption (for the proof, see [18]). Using Lemma 1, together with a geometric proof technique developed in [7], we now show that the greedy algorithm achieves the optimal approximation ratio for the cost-minimization problem. Theorem 2. Let S  X  = arg min S  X  X  c ( f,S ) . If j = 0  X  j , then c ( f,G )  X  4  X  c ( f,S  X  ) . More R Proof. We consider the special case j = 0  X  j ; for the full proof see [18]. Let R j = 1  X  f ( G j ) ; left hand side equals c ( f,S  X  ) , and, using the fact that s j = R j  X  R j +1  X  to The greedy algorithm also achieves the optimal approximation ratio for the benefit-maximization problem, as can be shown using arguments similar to the ones in [14, 20]; see [18] for details. Theorem 3. Let L be a positive integer, and let T = P L j =1  X  j . Then f G  X  T  X  &gt; f We measure performance using two different notions of regret. For the cost-minimization objective, Here for any schedule S and job f , we define c T ( S,f ) = R T t =0 1  X  f S  X  t  X  dt to be the value of c ( S,f ) when the integral is truncated at time T . Some form of truncation is necessary because c S ( i ) ,f ( i ) could be infinite, and without bounding it we could not prove any finite bound on regret (our regret bounds will be stated as a function of T ). For the benefit-maximization objective, we that for each i , E ` S ( i ) = T , where the expectation is over the online algorithm X  X  random bits. That is, we allow the online algorithm to treat T as a budget in expectation, rather than a hard budget. consider the oblivious adversary model , in which the sequence of jobs is fixed in advance and does not change in response to the decisions made by our online algorithm. We confine our attention to schedules that consist of actions that come from some finite set A , and assume that the actions in A have integer durations (i.e. A X  X   X  Z &gt; 0 ). 4.1 Unit-cost actions In the special case in which each action takes unit time (i.e., A  X  V  X { 1 } ), our online algorithm OG unit is very simple. OG unit runs T action-selection algorithms, E 1 , E 2 ,..., E T , where T is the number of time steps for which our schedule is defined. The intent is that each action-selection algorithm is a no-regret algorithm such as randomized weighted majority (WMR) [4], which selects actions so as to maximize payoffs associated with the actions. Just before job f ( i ) arrives, each action-selection algorithm E t selects an action a i t . The schedule used by OG unit on job f ( i ) is S Theorem 4. Algorithm OG unit has E [ R benefit ] = O q T n ln |A| and E [ R cost ] = O T q T n ln |A| in the worst case, when WMR [4] is the subroutine action-selection algorithm. Proof. We will view OG unit as producing an approximate version of the offline greedy schedule for  X  a , and extend the domain of each f ( i ) to include the meta-actions by defining f ( i ) ( S  X  X   X  a t  X  ) = f Thus OG unit behaves exactly like the greedy schedule G for the function f , with t = r t . Thus, Theorem 3 implies that R benefit  X  P T t =1 r t  X  R . Similarly, Theorem 2 implies that R cost  X  TR . To complete the analysis, it remains to bound E [ R ] . WMR has worst-case expected regret O 1 n p G max ln |A| , where G max is the maximum sum of payoffs payoff for any single ac-tion. 3 Because each payoff is at most 1 and there are n rounds, G max  X  n , so a trivial bound is E [ R ] = O T q 1 n ln |A| . In fact, the worst case is when G max =  X  n T for all T action-selection algorithms, leading to an improved bound of E [ R ] = O q T n ln |A| (for details see [18]), which completes the proof. 4.2 From unit-cost actions to arbitrary actions In this section we generalize the online greedy algorithm presented in the previous section to accom-modate actions with arbitrary durations. Like OG unit , our generalized algorithm OG makes use of a series of action-selection algorithms E 1 , E 2 ,..., E L (for L to be determined). On each round i , OG constructs a schedule S ( i ) as follows: for t = 1 , 2 ,...,L , it uses E t to choose an action a t = ( v, X  )  X  A , and appends this action to S that results from the first t steps of this process (so S ( i ) t contains between 0 and t actions). The time that would have resulted from appending a to the schedule-under-construction).
 As in the previous section, we view each action-selection algorithm E t as selecting a single meta-f monotone and submodular.
 (whereas in fact,  X  a t takes unit time per job in expectation). We show later that this assumption does not invalidate any of our arguments.
 are using the assumption that  X  a t takes unit time. Let r t be the regret experienced by E t . Although r 6 = t in general, the two quantities are equal in expectation (proof omitted).
 Lemma 2. E [ t ] = E [ r t ] .
 We now prove a bound on E [ R benefit ] . Because each f ( i ) is monotone and submodular, f is mono-tone and submodular as well, so the greedy schedule X  X  approximation guarantees apply to f . In particular, by Theorem 3, we have R benefit  X  P T t =1 t . Thus by Lemma 2, E [ R benefit ]  X  E [ R ] , time. First, note that the value of the objective function f (  X  S ) is independent of how long each meta-action  X  a t takes. Thus, the only potential danger is that in making this assumption we have overlooked a constraint violation of the form E ` S ( i ) 6 = T . But by construction, E ` S ( i ) = L for each i , regardless of what actions are chosen by each action-selection algorithm. Thus if we set L = T there is no constraint violation. Combining the bound on E [ R ] stated in the proof of Theorem 4 with the fact that E [ R benefit ]  X  E [ R ] yields the following theorem.
 Theorem 5. Algorithm OG , run with input L = T , has E [ R benefit ]  X  E [ R ] . If WMR [4] is used as the subroutine action-selection algorithm, then E [ R ] = O q T n ln |A| .
 The argument bounding E [ R cost ] is similar, although somewhat more involved (for details, see [18]). One additional complication is that ` S ( i ) is now a random variable, whereas in the definition of R cost the cost of a schedule is always calculated up to time T . This can be addressed by making the probability that ` S ( i ) &lt; T sufficiently small, which can be done by setting L T and applying concentration of measure inequalities. However, E [ R ] grows as a function of L , so we do not want to make L too large. The (approximately) best bound is obtained by setting L = T ln n . Theorem 6. Algorithm OG , run with input L = T ln n , has E [ R cost ] = O ( T ln n  X  E [ R ] + T  X  n ) . In particular, E [ R cost ] = O (ln n ) 3 2 T q T n ln |A| if WMR [4] is used as the subroutine action-selection algorithm. 4.3 Dealing with limited feedback Thus far we have assumed that, after specifying a schedule S ( i ) , the online algorithm receives com-plete access to the job f ( i ) . We now consider three more limited feedback settings that may arise in practice. In the priced feedback model , to receive access to f ( i ) we must pay a price C , which each t &gt; 0 . In the opaque feedback model , we only observe f ( i ) S ( i ) .
 The priced and partially transparent feedback models arise naturally in the case where action ( v, X  ) represents running a deterministic algorithm v for  X  time units, and f ( S ) = 1 if some action in S yields a solution to some particular problem instance, and f ( S ) = 0 otherwise. If we execute a schedule S and halt as soon as some action yields a solution, we obtain exactly the information that is revealed in the partially transparent model. Alternatively, running each algorithm v until it returns a solution would completely reveal the function f ( i ) , but incurs a computational cost, as reflected in the priced feedback model.
 Algorithm OG can be adapted to work in each of these three feedback settings; see [18] for the specific bounds. In all cases, the high-level idea is to replace the unknown quantities used by OG with (unbiased) estimates of those quantities. This technique has been used in a number of online algorithms (e.g., see [2]). 4.4 Lower bounds on regret We now state lower bounds on regret; for the proofs see the full paper [18]. Our proofs have the same high-level structure as that of the lower bound given in [4], in that we define a distribution over jobs that allows any online algorithm X  X  expected performance to be easily bounded, and then prove a bound on the expected performance of the best schedule in hindsight. The upper bounds in Theorem 4 match the lower bounds in Theorem 7 up to logarithmic factors, although the latter apply to standard regret as opposed to R benefit and R cost (which include factors of 1  X  1 e and 4). Theorem 7. Let X = q T n ln |V| T . Then any online algorithm has worst-case expected regret  X  ( X ) (resp.  X  ( TX ) ) for the online benefit-maximization (resp. cost-minimization) problem. The annual SAT solver competition ( www.satcompetition.org ) is designed to encourage the development of efficient Boolean satisfiability solvers, which are used as subroutines in state-of-the-art model checkers, theorem provers, and planners. The competition consists of running each submitted solver on a number of benchmark instances, with a per-instance time limit. Solvers are ranked according to the instances they solve within each of three instance categories: industrial , random , and hand-crafted .
 We evaluated the online algorithm OG by using it to combine solvers from the 2007 SAT solver competition. To do so, we used data available on the competition web site to construct a matrix X , where X i,j is the time that the j th solver required on the i th benchmark instance. We used this data to determine whether or not a given schedule would solve an instance within the time limit T (schedule S solves instance i if and only if, for some j , S  X  T  X  contains an action ( h j , X  ) with  X   X  X i,j ). As illustrated in Example 1, the task of maximizing the number of instances solved within the time limit, in an online setting in which a sequence of instances must be solved one at a time, is an instance of our online problem (under the benefit-maximization objective).
 Within each instance category, we compared OG to the offline greedy schedule, to the individual solver that solved the most instances within the time limit, and to a schedule that ran each solver in parallel at equal strength. For these experiments, we ran OG in the full-information feedback model, after finding that the number of benchmark instances was too small for OG to be effective in the limited feedback models. Table 1 summarizes the results. In each category, the offline greedy schedule and the online greedy algorithm outperform all solvers entered in the competition as well as the na  X   X ve parallel schedule. [1] Noga Alon, Baruch Awerbuch, and Yossi Azar. The online set cover problem. In Proceedings [2] Peter Auer, Nicol ` o Cesa-Bianchi, Yoav Freund, and Robert E. Schapire. The nonstochastic [3] Shivnath Babu, Rajeev Motwani, Kamesh Munagala, Itaru Nishizawa, and Jennifer Widom. [4] Nicol ` o Cesa-Bianchi, Yoav Freund, David Haussler, David Helmbold, Robert Schapire, and [5] Edith Cohen, Amos Fiat, and Haim Kaplan. Efficient sequences of trials. In Proceedings of [6] Uriel Feige. A threshold of ln n for approximating set cover. Journal of the ACM , 45(4):634 X  [7] Uriel Feige, L  X  aszl  X  o Lov  X  asz, and Prasad Tetali. Approximating min sum set cover. Algorith-[8] Carla P. Gomes and Bart Selman. Algorithm portfolios. Artificial Intelligence , 126:43 X 62, [9] Bernardo A. Huberman, Rajan M. Lukose, and Tad Hogg. An economics approach to hard [10] Sham Kakade, Adam Kalai, and Katrina Ligett. Playing games with approximation algorithms. [11] Haim Kaplan, Eyal Kushilevitz, and Yishay Mansour. Learning with attribute costs. In Pro-[12] Samir Khuller, Anna Moss, and Joseph (Seffi) Naor. The budgeted maximum coverage prob-[13] Andreas Krause and Carlos Guestrin. Near-optimal nonmyopic value of information in graph-[14] Andreas Krause and Carlos Guestrin. A note on the budgeted maximization of submodular [15] Kamesh Munagala, Shivnath Babu, Rajeev Motwani, Jennifer Widom, and Eiter Thomas. The [16] G. L. Nemhauser, L. A. Wolsey, and M. L. Fisher. An analysis of approximations for maxi-[17] Filip Radlinski, Robert Kleinberg, and Thorsten Joachims. Learning diverse rankings with [18] Matthew Streeter and Daniel Golovin. An online algorithm for maximizing submodular func-[19] Matthew Streeter, Daniel Golovin, and Stephen F. Smith. Combining multiple heuristics on-[20] Maxim Sviridenko. A note on maximizing a submodular set function subject to a knapsack
