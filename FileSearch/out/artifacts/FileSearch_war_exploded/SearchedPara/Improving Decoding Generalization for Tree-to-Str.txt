 Among linguistically syntax-based statistical ma-chine translation (SMT) approaches, the tree-to-string model (Huang et al. 2006; Liu et al. 2006) is the simplest and fastest, in which parse trees on source side are used for grammar extraction and decoding. Formally, given a source (e.g., Chinese) typical tree-to-string SMT is to find a target (e.g., English) string e* by the following equation as translation of the given source string c and its T 1-best A typical tree-to-string decoder aims to search for the best derivation among all consistent derivations that convert source tree into a target-language string. We call this set of consistent derivations the tree-to-string search space. Each derivation in the search space respects the source parse tree. 
Parsing errors on source parse trees would cause negative effects on tree-to -string translation due to decoding on incorrect source parse trees. To ad-dress the parse error issue in tree-to-string transla-tion, a natural solution is to use n -best parse trees instead of 1-best parse tree as input for decoding, which can be expressed by of c produced by a state-of-the-art syntactic parser. A simple alternative (Xiao et al. 2010) to generate &lt; T n-best &gt; is to utilize multiple parsers, which can improve the diversity among source parse trees in &lt; T n-best &gt; . In this solution, the most representative work is the forest-based translation method (Mi et al. 2008; Mi and Huang 2008; Zhang et al. 2009) in which a packed forest (forest for short) structure is used to effectively represent &lt; T n-best &gt; for decod-ing. Forest-based approaches can increase the tree-to-string search space for decoding, but face a non-trivial problem of high decoding time complexity in practice. 
In this paper, we propose a new solution by re-constructing new similar source parse trees for de-coding, referred to as similarity-based decoding generation (SDG), which is expressed as where &lt;T sim &gt; denotes a set of similar parse trees of T 1-best that are dynamically reconstructed at the de-coding time. Roughly speaking, &lt; T n-best &gt; is a sub-set of { T 1-best , &lt;T sim &gt; }. Along this line of thinking, Equation (2) can be considered as a special case of Equation (3). In our SDG solution, given a source parse tree T 1-best , the key is how to generate its &lt;T sim decoding time. In practice, it is almost intractable to directly reconstructing &lt;T sim &gt; in advance as in-put for decoding due to too high computation com-plexity. To address this crucial challenge, this paper presents a simple and effective technique based on similarity-based matching constraints to construct new similar source parse trees for decod-ing at the decoding time. Our SDG approach can explicitly increase the tree-to-string search space for decoding without changing any grammar ex-traction and pruning settings, and has little impact on decoding speed in practice. We choose the tree-to-string paradigm in our study because this is the simplest and fastest among syn-tax-based models, and has been shown to be one of the state-of-the-art syntax-based models. Typically, by using the GHKM algorithm (Galley et al. 2004), translation rules are learned from word-aligned bilingual texts whose source side has been parsed by using a syntactic parser. Each rule consists of a syntax tree in the source language having some words (terminals) or variables (nonterminals) at leaves, and sequence words or variables in the tar-get language. With the help of these learned trans-lation rules, the goal of tree-to-string decoding is to search for the best derivation that converts the source tree into a target-language string. A deriva-tion is a sequence of translation steps (i.e., the use of translation rules). 
Figure 1 shows an example derivation d that performs translation over a Chinese source parse tree, and how this process works. In the first step, we can apply rule r 1 at the root node that matches a subtree {IP [1] (NP [2] VP [3] )}. The corresponding target side { x 1 x 2 } means to preserve the top-level word-order in the translation, and results in two unfinished subtrees with root labels NP [2] and VP [3] , respectively. The rule r 2 finishes the translation on the subtree of NP [2] , in which the Chinese word  X   X  X   X  is translated into an English string  X  the Chinese side  X . The rule r 3 is applied to perform translation on the subtree of VP [3] , and results in an unfinished subtree of NP [4] . Similarly, rules r 4 r are sequentially used to finish the translation on the remaining. This process is a depth-first search over the whole source tree, and visits every node only once. 3.1 Similarity-based Matching Constraints In typical tree-to-string decoding, an ordered se-quence of rules can be reassembled to form a deri-vation d whose source side matches the given source parse tree T . The source side of each rule in d should match one of subtrees of T , referred to as matching constraint . Before discussing how to ap-ply our similarity-based matching constraints to reconstruct new similar source parse trees for de-coding at the decoding time, we first define the similarity between two tree-to-string rules. Definition 1 Given two tree-to-string rules t and u, we say that t and u are similar such that their source sides t s and u s have the same root label and frontier nodes, written as u t  X  , otherwise not.
Here we use an example figure to explain our similarity-based matching constraint scheme (simi-larity-based scheme for short). rule t* instead of rule t , where t* t  X  .

Given a source-language parse tree T , in typical tree-to-string matching constraint scheme shown in Figure 3(a), rule t used by the derivation d should match a substree ABC of T . In our similarity-based scheme, the similar rule t* ( t  X  ) is used to form a new derivation d* that performs translation over the same source sentence { w 1 ... w n }. In such a case, this new derivation d* can yield a new similar parse tree T* of T . 
Since an incorrect source parse tree might filter out good derivations during tree-to-string decoding, our similarity-based scheme is much more likely to recover the correct tree for decoding at the decod-ing time, and does not rule out good (potentially correct) translation choices. In our method, many new source-language trees T * that are similar to but different from the original source tree T can be re-constructed at the decoding time. In theory our similarity-based scheme can increase the search space of the tree-to-string decoder, but we did not change any rule extraction and pruning settings. 
In practice, our similarity-based scheme can ef-fectively keep the advantage of fast decoding for tree-to-string translation because its implementa-tion is very simple. Let X  X  revisit the example deri-vation d in Figure 1, i.e., d = r 1  X  r 2  X  r 3  X  r 4  X  r such a case, the decoder can effectively produce a new derivation d* by simply replacing rule r 3 with its similar rule  X  3 ( d* = r 1  X  r 2  X   X  3  X  r 4  X  r 5 . 
With beam search, typical tree-to-string decod-ing with an integrated language model can run in time 2 O(ncb 2 ) in practice (Huang 2007). For our decoding time complexity computation, only the parameter c value can be affected by our similar-ity-based scheme. In other words, our similarity-based scheme would result in a larger c value at decoding time as many similar translation rules might be matched at each node. In practice, there are two feasible optimization techniques to allevi-ate this problem. The first technique is to limit the maximum number of similar translation rules matched at each node. The second one is to prede-fine a similarity threshold to filter out less similar translation rules in advance. 
In the implementation, we add a new feature into the model: similarity-based matching counting feature . This feature counts the number of similar rules used to form the derivation. The weight  X  sim of this feature is tuned via minimal error rate train-ing (MERT) (Och 2003) with other feature weights. 3.2 Pseudo-rule Generation In the implementation of tree-to-string decoding, the first step is to load all translation rules matched at each node of the source tree T . It is possible that some nonterminal nodes do not have any matched rules when decoding some new sentences. If the root node of the source tree has no any matched rules, it would cause decoding failure. To tackle this problem, motivated by  X  glue  X  rules (Chiang 2005), for some node S without any matched rules, we introduce a special pseudo-rule which reassem-bles all child nodes with local reordering to form new translation rules for S to complete decoding. 
Figure 4 (a) depicts an example unseen substree where no any rules is matched at its root node S . Its simplest pseudo-rule is to simply combine a sequence of S  X  X  child nodes. To give the model more options to build partial translations, we util-ize a local reordering technique in which any two adjacent frontier (child) nodes are reordered during decoding. Figure 4(b) shows four pseudo-rules in total generated from this example unseen substree. 
In the implementation, we add a new feature to the model: pseudo-rule counting feature . This fea-ture counts the number of pseudo-rules used to form the derivation. The weight  X  pseudo of this fea-ture is tuned via MERT with other feature weights. 4.1 Setup Our bilingual training data consists of 140K Chi-nese-English sentence pairs in the FBIS data set. For rule extraction, the minimal GHKM rules (Gal-ley et al. 2004) were extracted from the bitext, and the composed rules were generated by combining two or three minimal GHKM rules. A 5-gram lan-guage model was trained on the target-side of the bilingual data and the Xinhua portion of English Gigaword corpus. The beam size for beam search was set to 20. The base feature set used for all sys-tems is similar to that used in (Marcu et al. 2006), including 14 base features in total such as 5-gram language model, bidirectional lexical and phrase-based translation probabilities. All features were linearly combined and their weights are optimized by using MERT. The development data set used for weight training in our approaches comes from NIST MT03 evaluation set. To speed up MERT, sentences with more than 20 words were removed from the development set (Dev set). The test sets are the NIST MT04 and MT05 evaluation sets. The translation quality was evaluated in terms of case-insensitive NIST version BLEU metric. Statistical significance test was conducted by using the boot-strap re-sampling method (Koehn 2004). 4.2 Results Table 1 depicts the BLEU scores of various meth-ods on the Dev set and four test sets. Compared to typical tree-to-string decoding (the baseline), our method can achieve significant improvements on all datasets. It is noteworthy that the improvement achieved by our approach on full test sets is bigger than that on small test sets. For example, our method results in an improvement of 2.52 BLEU points over the baseline on the MT05 full test set, but only 0.55 points on the MT05 small test set. As mentioned before, tree-to-string approaches are more vulnerable to parsing errors. In practice, the Berkeley parser (Petrov et al. 2006) we used yields unsatisfactory parsing performance on some long sentences in the full test sets. In such a case, it would result in negative effects on the performance of the baseline method on the full test sets. Ex-perimental results show that our SDG approach can effectively alleviate this problem, and signifi-cantly improve tree-to-string translation. Another issue we are interested in is the decod-ing speed of our method in practice. To investigate this issue, we evaluate the average decoding speed of our SDG method and the baseline on the Dev set and all test sets. 
Table 2 shows that our approach only has little impact on decoding speed in practice, compared to the typical tree-to-string decoding (baseline). No-tice that in these comparisons our method did not adopt any optimization techniques mentioned in Section 3.1, e.g., to limit the maximum number of similar rules matched at each node. It is obviously that the use of such an optimization technique can effectively increase the decoding speed of our method, but might hurt the performance in practice. 
Besides, to speed up decoding long sentences, it seems a feasible solution to first divide a long sen-tence into multiple short sub-sentences for decod-ing, e.g., based on comma. In other words, we can segment a complex source-language parse tree into multiple smaller subtrees for decoding, and com-bine the translations of these small subtrees to form the final translation. This practical solution can speed up the decoding on long sentences in real-world MT applications, but might hurt the transla-tion performance. 
For convenience, here we call the rule  X  3 in Fig-ure 2(b) similar-rules . It is worth investigating how many similar-rules and pseudo-rules are used to form the best derivations in our similarity-based scheme. To do it, we count the number of similar-rules and pseudo-rules used to form the best deri-vations when decoding on the MT05 full set. Ex-perimental results show that on average 13.97% of rules used to form the best derivations are similar-rules, and one pseudo-rule per sentence is used. Roughly speaking, average five similar-rules per sentence are utilized for decoding generalization. String-to-tree SMT approaches also utilize the similarity-based matching constraint on target side to generate target translation. This paper applies it on source side to reconstruct new similar source parse trees for decoding at the decoding time, which aims to increase the tree-to-string search space for decoding, and improve decoding gener-alization for tree-to-string translation. 
The most related work is the forest-based trans-lation method (Mi et al. 2008; Mi and Huang 2008; Zhang et al. 2009) in which rule extraction and decoding are implemented over k -best parse trees (e.g., in the form of packed forest) instead of one best tree as translation input. Liu and Liu (2010) proposed a joint parsing and translation model by casting tree-based translation as parsing (Eisner 2003), in which the decoder does not respect the source tree. These methods can increase the tree-to-string search space. However, the decoding time complexity of their methods is high, i.e., more than ten or several dozen times slower than typical tree-to-string decoding (Liu and Liu 2010). 
Some previous efforts utilized the techniques of soft syntactic constraints to increase the search space in hierarchical phrase-based models (Marton and Resnik 2008; Chiang et al. 2009; Huang et al . 2010), string-to-tree models (Venugopal et al. 2009) or tree-to-tree (Chiang 2010) systems. These methods focus on softening matching constraints on the root label of each rule regardless of its in-ternal tree structure, and often generate many new syntactic categories 3 . It makes them more difficult to satisfy syntactic constraints for the tree-to-string decoding. This paper addresses the parse error issue for tree-to-string translation, and proposes a similarity-based decoding generation solution by reconstruct-ing new similar source parse trees for decoding at the decoding time. It is noteworthy that our SDG approach is very easy to implement. In principle, forest-based and tree sequence-based approaches improve rule coverage by changing the rule extrac-tion settings, and use exact tree-to-string matching constraints for decoding. Since our SDG approach is independent of any rule extraction and pruning techniques, it is also applicable to forest-based ap-proaches or other tree-based translation models, e.g., in the case of casting tree-to-tree translation as tree parsing (Eisner 2003). We would like to thank Feiliang Ren, Muhua Zhu and Hao Zhang for discussions and the anonymous reviewers for comments. This research was sup-ported in part by the National Science Foundation of China (60873091; 61073140), the Specialized Research Fund for the Doctoral Program of Higher Education (20100042110031) and the Fundamental Research Funds for the Central Universities in China. 
