 Relation extraction is a subtask of information ex-traction that finds various predefined semantic re-lations, such as location, affiliation, rival, etc., between pairs of entities in text. For example, the sentence  X  X eorge Bush is the president of the United States. X  conveys the semantic relation  X  X resident X  between the entities  X  X eorge Bush X  (PER) and  X  X he United States X  (GPE: a Geo-Political 
Prior feature-based methods for this task (Kambhatla 2004; Zhou et al., 2005) employed a large amount of diverse linguistic features, varying from lexical knowledge, entity mention informa-tion to syntactic parse trees, dependency trees and semantic features. Since a parse tree contains rich syntactic structure information, in principle, the features extracted from a parse tree should contrib-ute much more to performance improvement for relation extraction. However it is reported (Zhou et al., 2005; Kambhatla, 2004) that hierarchical struc-tured syntactic features contributes less to per-formance improvement. This may be mainly due to the fact that the syntactic structure information in a parse tree is hard to explicitly describe by a vector of linear features. As an alternative, kernel meth-ods (Collins and Duffy, 2001) provide an elegant solution to implicitly explore tree structure features by directly computing the similarity between two trees. But to our surprise, the sole two-reported dependency tree kernels for relation extraction on the ACE corpus (Bunescu and Mooney, 2005; Cu-lotta and Sorensen, 2004) showed much lower per-formance than the feature-based methods. One may ask: are the syntactic tree features very useful for relation extraction? Can tree kernel methods effectively capture the syntactic tree features and other various features that have been proven useful in the feature-based methods? 
In this paper, we demonstrate the effectiveness of the syntactic tree features for relation extraction and study how to capture such features via a con-volution tree kernel. We also study how to select the optimal feature space (e.g. the set of sub-trees to represent relation instances) to optimize the sys-tem performance. The experimental results show that the convolution tree kernel plus entity features achieves slightly better performance than the pre-vious best-reported feature-based methods. It also shows that our method significantly outperforms the two dependency tree kernels (Bunescu and Mooney, 2005; Culotta and Sorensen, 2004) on the 5 ACE relation types. The rest of the paper is organized as follows. In Section 2, we review the previous work. Section 3 discusses our tree kernel based learning algorithm. Section 4 shows the experimental results and com-pares our work with the related work. We conclude our work in Section 5. The task of relation extraction was introduced as a part of the Template Element task in MUC6 and formulated as the Template Relation task in MUC7 (MUC, 1987-1998). 
Miller et al. (2000) address the task of relation extraction from the statistical parsing viewpoint. They integrate various tasks such as POS tagging, NE tagging, template extraction and relation ex-traction into a generative model. Their results es-sentially depend on the entire full parse tree. Kambhatla (2004) employs Maximum Entropy models to combine diverse lexical, syntactic and semantic features derived from the text for relation extraction. Zhou et al. (2005) explore various fea-tures in relation extraction using SVM. They con-duct exhaustive experiments to investigate the incorporation and the individual contribution of diverse features. They report that chunking infor-mation contributes to most of the performance im-provement from the syntactic aspect. The features used in Kambhatla (2004) and Zhou et al. (2005) have to be selected and carefully calibrated manually. Kambhatla (2004) use the path of non-terminals connecting two mentions in a parse tree as the parse tree features. Besides, Zhou et al. (2005) introduce additional chunking features to enhance the parse tree features. How-ever, the hierarchical structured information in the parse trees is not well preserved in their parse tree-related features. 
As an alternative to the feature-based methods, kernel methods (Haussler, 1999) have been pro-posed to implicitly explore features in a high di-mensional space by employing a kernel function to calculate the similarity between two objects di-rectly. In particular, the kernel methods could be very effective at reducing the burden of feature engineering for structured objects in NLP research (Culotta and Sorensen, 2004). This is because a kernel can measure the similarity between two dis-crete structured objects directly using the original representation of the objects instead of explicitly enumerating their features. 
Zelenko et al. (2003) develop a tree kernel for relation extraction. Their tree kernel is recursively defined in a top-down manner, matching nodes from roots to leaf nodes. For each pair of matching nodes, a subsequence kernel on their child nodes is invoked, which matches either contiguous or sparse subsequences of node. Culotta and Sorensen (2004) generalize this kernel to estimate similarity between dependency trees. One may note that their tree kernel requires the matchable nodes must be at the same depth counting from the root node. This is a strong constraint on the matching of syntax so it is not surprising that the model has good preci-sion but very low recall on the ACE corpus (Zhao and Grishman, 2005). In addition, according to the top-down node matching mechanism of the kernel, once a node is not matchable with any node in the same layer in another tree, all the sub-trees below this node are discarded even if some of them are matchable to their counterparts in another tree. 
Bunescu and Mooney (2005) propose a shortest path dependency kernel for relation extraction. They argue that the information to model a rela-tionship between entities is typically captured by the shortest path between the two entities in the dependency graph. Their kernel is very straight-forward. It just sums up the number of common word classes at each position in the two paths. We notice that one issue of this kernel is that they limit the two paths must have th e same length, otherwise the kernel similarity score is zero. Therefore, al-though this kernel shows non-trivial performance improvement than that of Culotta and Sorensen (2004), the constraint makes the two dependency kernels share the similar behavior: good precision but much lower recall on the ACE corpus. 
Zhao and Grishman (2005) define a feature-based composite kernel to integrate diverse fea-tures. Their kernel displays very good performance on the 2004 version of ACE corpus. Since this is a feature-based kernel, all the features used in the kernel have to be explicitly enumerated. Similar with the feature-based method, they also represent the tree feature as a link path between two entities. Therefore, we wonder whether their performance improvement is mainly due to the explicitly incor-poration of diverse linguistic features instead of the kernel method itself. 
The above discussion suggest s that the syntactic features in a parse tree may not be fully utilized in the previous work, whether feature-based or ker-nel-based. We believe that the syntactic tree fea-tures could play a more important role than that reported in the previous work. Since convolution kernels aim to capture structural information in terms of sub-structures, which providing a viable alternative to flat features, in this paper, we pro-pose to use a convolution tree kernel to explore syntactic features for relation extraction. To our knowledge, convolution kernels have not been ex-plored for relation extraction 1 . In this section, we discuss the convolution tree kernel associated with different relation feature spaces. In Subsection 3.1, we define seven differ-ent relation feature spaces over parse trees. In Sub-section 3.2, we introduce a convolution tree kernel for relation extraction. Finally we compare our method with the previous work in Subsection 3.3. 3.1 Relation Feature Spaces In order to study which relation feature spaces (i.e., which portion of parse trees) are optimal for rela-tion extraction, we define seven different relation feature spaces as follows (as shown in Figure 1): (1) Minimum Complete Tree (MCT): 
It is the complete sub-tree rooted by the node of the nearest common ancestor of the two entities under consideration. (2) Path-enclosed Tree (PT): 
It is the smallest common sub-tree including the two entities. In other words, the sub-tree is en-closed by the shortest path linking the two entities in the parse tree (this path is also typically used as the path tree features in the feature-based meth-ods). (3) Chunking Tree (CT): It is the base phrase list extracted from the PT . We prune out all the internal structures of the PT and only keep the root node and the base phrase list for generating the chunking tree. (4) Context-Sensitive Path Tree (CPT): 
It is the PT extending with the 1 st left sibling of node of entity 2. If the sibling is unavailable, then we move to the parent of current node and repeat the same process until the sibling is available or the root is reached. (5) Context-Sensitive Chunking Tree (CCT): 
It is the CT extending with the 1 st left sibling of node of entity 2. If the sibling is unavailable, the same process as generating the CPT is applied. Then we do a further pruning process to guarantee that the context structures of the CCT is still a list of base phrases. (6) Flattened PT (FPT): 
We define two criteria to flatten the PT in order to generate the Flattened Parse tree : if the in and out arcs of a non-terminal node (except POS node) are both single, the node is to be removed; if a node has the same phrase type with its father node, the node is also to be removed. (7) Flattened CPT (FCPT): 
We use the above two criteria to flatten the CPT tree to generate the Flattened CPT . 
Figure 1 in the next page illustrates the different sub-tree structures for a relation instance in sen-tence  X  Akyetsu testified he was powerless to stop the merger of an estimated 2000 ethnic Tutsi's in the district of Tawba.  X . The relation instance is an example excerpted from the ACE corpus, where an ACE-defined relation  X  X T.LOCATED X  exists be-tween the entities  X  Tutsi's  X  (PER) and  X  district  X  (GPE). 
We use Charniak X  X  parser (Charniak, 2001) to parse the example sentence. Due to space limita-tion, we do not show the whole parse tree of the entire sentence here. Tree T 1 in Figure 1 is the MCT of the relation instance example, where the sub-structure circled by a dashed line is the PT . difference between the MCT and the PT lies in that the MCT does not allow the partial production rules. For instance, the most-left two-layer sub-tree [NP [DT ... E1-O-PER]] in T 1 is broken apart in T . By comparing the performance of T 1 and T 2, we can test whether the sub-structures with partial production rules as in T 2 will decrease perform-ance. T 3 is the CT . By comparing the performance of T 2 and T 3 , we want to study whether the chunk-ing information or the parse tree is more effective for relation extraction. T 4 is the CPT , where the two structures circled by dashed lines are the so-called context structures. T 5 is the CCT , where the additional context structures are also circled by dashed lines. We want to study if the limited con-text information in the CPT and the CCT can help boost performance. Moreover, we illustrate the other two flattened trees in T 6 and T 7 . The two cir-cled nodes in T 2 are removed in the flattened trees. We want to study if the eliminated small structures are noisy features for relation extraction. 3.2 The Convolution Tree Kernel Given the relation instances defined in the previous section, we use the same convolution tree kernel as the parse tree kernel (Collins and Duffy, 2001) and the semantic kernel (M oschitti, 2004). Generally, we can represent a parse tree T by a vector of inte-ger counts of each sub-tree type (regardless of its ancestors): trees of type i , ..., # of sub-trees of type n ) This results in a very high dimensionality since the number of different sub-trees is exponential in its size. Thus it is computational infeasible to directly use the feature vector () T  X  . To solve the compu-tational issue, we introduce the tree kernel function which is able to calculate the dot product between the above high dimensional vectors efficiently. The kernel function is defined as follows: ( , ) ( ), ( ) ( )[ ], ( )[ ] K TT T T T i T i where N 1 and N 2 are the sets of all nodes in trees T and T 2 , respectively, and I i (n) is the indicator func-root at node n and zero otherwise. Collins and Duffy (2002) show that convolution kernels over tree structures, and which can be computed in ing recursive definitions (Let (1) if or their children are different then (2) else if their children ar e leaves (POS tags), then (3) else 1 where ( 01  X  &lt;&lt; ) is the decay factor in order to make the kernel value less variable with respect to the tree sizes. 3.3 Comparison with Previous Work It would be interesting to review the differences between our method and the feature-based meth-ods. The basic difference between them lies in the relation instance representation and the similarity calculation mechanism. A relation instance in our method is represented as a parse tree while it is represented as a vector of features in the feature-based methods. Our method estimates the similar-ity between two relation instances by only count-ing the number of sub-structures that are in common while the feature methods calculate the dot-product between the feature vectors directly. The main difference between them is the different feature spaces. By the kernel method, we implicitly represent a parse tree by a vector of integer counts of each sub-structure type. That is to say, we con-sider the entire sub-structure types and their occur-ring frequencies. In this way, on the one hand, the parse tree-related features in the flat feature set are embedded in the feature space of our method:  X  Base Phrase Chunking  X  and  X  Parse Tree  X  fea-tures explicitly appear as substructures of a parse tree. A few of entity-related features in the flat fea-ture set are also captured by our feature space:  X  en-tity type  X  and  X  mention level  X  explicitly appear as phrase types in a parse tree. On the other hand, the other features in the flat feature set , such as  X  word features  X ,  X  bigram word features  X ,  X  overlap  X  and  X  dependency tree  X  are not contained in our feature space. From the syntactic viewpoint, the tree repre-sentation in our feature space is more robust than  X  Parse Tree Path  X  feature in the flat feature set since the path feature is very sensitive to the small changes of parse trees (Moschitti, 2004) and it also does not maintain the hierarchical information of a parse tree. Due to the extensive exploration of syn-tactic features by kernel, our method is expected to show better performance than the previous feature-based methods. 
It is also worth comparing our method with the previous relation kernels. Since our method only counts the occurrence of each sub-tree without considering its ancestors, our method is not limited by the constraints in Culotta and Sorensen (2004) and that in Bunescu and Mooney (2005) as dis-cussed in Section 2. Compared with Zhao and Grishman X  X  kernel, our method directly uses the original representation of a parse tree while they flatten a parse tree into a link and a path . Given the above improvements, our method is expected to outperform the previous relation kernels. The aim of our experiment is to verify the effec-tiveness of using richer syntactic structures and the convolution tree kernel for relation extraction. 4.1 Experimental Setting Corpus : we use the official ACE corpus for 2003 evaluation from LDC as our test corpus. The ACE corpus is gathered from various newspaper, news-wire and broadcasts. The same as previous work (Zhou et al., 2005), our experiments are carried out on explicit relations due to the poor inter-annotator agreement in annotation of implicit relations and their limited numbers. The training set consists of 674 annotated text documents and 9683 relation instances. The test set consists of 97 documents and 1386 relation instances. The 2003 evaluation defined 5 types of entities: Persons, Organizations, Locations, Facilities and GPE. Each mention of an entity is associated with a mention type: proper name, nominal or pronoun. They further defined 5 major relation types and 24 subtypes: AT (Base-In, Located...), NEAR (Relative-Location), PART (Part-of, Subsidiary ...), ROLE (Member, Owner ...) and SOCIAL (Associate, Parent...). As previ-ous work, we explicitly model the argument order of the two mentions involved. We thus model rela-tion extraction as a multi-class classification prob-lem with 10 classes on the major types (2 for each relation major type and a  X  X ONE X  class for non-relation (except 1 symmetric type)) and 43 classes on the subtypes (2 for each relation subtype and a  X  X ONE X  class for non-relation (except 6 symmet-ric subtypes)). In this paper, we only measure the performance of relation extraction models on  X  X rue X  mentions with  X  X rue X  chaining of corefer-ence (i.e. as annotated by LDC annotators). Classifier : we select SVM as the classifier used in this paper since SVM can naturally work with ker-nel methods and it also represents the state-of-the-art machine learning algorithm. We adopt the one vs. others strategy and select the one with largest margin as the final answer. The training parameters are chosen using cross-validation (C=2.4 (SVM);  X  =0.4(tree kernel)). In our implementation, we use the binary SVMLight developed by Joachims (1998) and Tree Kernel Toolkits developed by Moschitti (2004). Kernel Normalization : since the size of a parse tree is not constant, we normalize ing it by Evaluation Method : we parse the sentence using Charniak parser and iterate over all pair of men-tions occurring in the same sentence to generate potential instances. We find the negative samples are 10 times more than the positive samples. Thus data imbalance and sparseness are potential prob-lems. Recall ( R ), Precision ( P ) and F-measure ( F ) are adopted as the performance measure. 4.2 Experimental Results In order to study the impact of the sole syntactic structure information embedded in parse trees on relation extraction, we remove the entity informa-tion from parse trees by re placing the entity-related phrase type ( X  X 1-O-PER X , etc., in Figure 1) with  X  X P X . Then we carry out a couple of preliminary experiments on the test set using parse trees re-gardless of entity information. Feature Spaces P R F Minimum Complete Tree 77.45 38.39 51.34 Path-enclosed Tree (PT) 72.77 53.80 61.87 Context-Sensitive PT( CPT ) 77.87 42.80 55.23 
Table 1. Performance of seven relation feature spaces over the 5 ACE major types using parse tree information only Table 1 reports the performance of our defined seven relation feature spaces over the 5 ACE major types using parse tree information regardless of any entity information. This preliminary experi-ments show that:  X 
Overall the tree kernel over different relation feature spaces is effective for relation extraction since we use the parse tree information only. We will report the detailed performance comparison results between our method and previous work later in this section.  X  Using the PT s achieves the best performance. 
This means the portion of a parse tree enclosed by the shortest path between entities can model relations better than other sub-trees.  X  Using the MCT s get the worst performance. 
This is because the MCT s introduce too much left and right context information, which may be noisy features, as shown in Figure 1. It suggests that only allowing complete (not partial) produc-tion rules in the MCT s does harm performance.  X 
The performance of using CT s drops by 5 in F-measure compared with that of using the PT s. 
This suggests that the middle and high-level structures beyond chunking is also very useful for relation extraction.  X 
The context-sensitive trees show lower perform-ance than the corresponding original PT s and 
CT s. In some cases (e.g. in sentence  X  X he merge of company A and company B.... X ,  X  X erge X  is the context word), the context information is helpful. However the effective scope of context is hard to determine.  X 
The two flattened trees perform worse than the original trees, but better than the corresponding context-sensitive trees. This suggests that the removed structures by the flattened trees con-tribute non-trivial performance improvement. 
In the above experiments, the path-enclosed tree displays the best performance among the seven feature spaces when using the parse tree structural information only. In the following incremental ex-periments, we incorporate more features into the path-enclosed parse trees and it shows significant performance improvement. Path-enclosed Tree ( PT ) P R F 
Parse tree structure in-formation only +Entity information 76.14 62.85 68.86 +Semantic features 76.32 62.99 69.02 
Table 2. Performance of Path-enclosed Trees with different setups over the 5 ACE major types 
Table 2 reports the performance over the 5 ACE major types using Path-enclosed trees enhanced with more features in nodes. The 1 st row is the baseline performance using structural information only. We then integrate entity information, includ-ing Entity type and Mention level features, into the corresponding nodes as shown in Figure 1. The 2 nd row in Table 2 reports the performance of this setup. Besides the entity information, we further incorporate the semantic features used in Zhou et al. (2005) into the corresponding leaf nodes. The 3 row in Table 2 reports the performance of this setup. Please note that in the 2 nd and 3 rd setups, we still use the same tree kernel function with slight modification on the rule (2) in calculating  X  (see subsection 3.2) to make it consider more features associated with each individual node: 2, we can see that the basic feature of entity infor-mation is quite useful, which largely boosts per-formance by 7 in F-measure. The final performance of our tree kernel method for relation extraction is 76.32/62.99/69.02 in preci-sion/recall/F-measure over the 5 ACE major types. 
Ours: convolution kernel over parse trees 
Kambhatla (2004): feature-based ME 
Zhou et al. (2005): feature-based SVM 
Culotta and Sorensen (2004): dependency kernel 
Bunescu and Mooney (2005): shortest path de-pendency kernel 
Table 3. Performance comparison, the numbers in parentheses report the performance over the 24 
ACE subtypes while the numbers outside paren-theses is for the 5 ACE major types 
Table 3 compares the performance of different methods on the ACE corpus 3 . It shows that our method achieves the best-reported performance on both the 24 ACE subtypes and the 5 ACE major types. It also shows that our tree kernel method significantly outperform the previous two depend-ency kernel algorithms by 16 in F-measure on the 5 ACE relation types 4 . This may be due to two rea-sons: one reason is that the dependency tree lacks the hierarchical syntactic information, and another reason is due to the two constraints of the two de-pendency kernels as discussed in Section 2 and Subsection 3.3. The performance improvement by our method suggests that the convolution tree ker-nel can explore the syntactic features (e.g. parse tree structures and entity information) very effec-tively and the syntactic features are also particu-larly effective for the task of relation extraction. In addition, we observe from Table 1 that the feature space selection (the effective portion of a parse tree) is also critical to relation extraction. 
Finally, Table 4 reports the error distribution in the case of the 3 rd experiment in Table 2. It shows that 85.9% (587/684) of the errors result from rela-tion detection and only 14.1% (97/684) of the er-rors result from relation characterization. This is mainly due to the imbalance of the posi-tive/negative instances and the sparseness of some relation types on the ACE corpus. In this paper, we explore the syntactic features us-ing convolution tree kernels for relation extraction. We conclude that: 1) th e relations between entities can be well represented by parse trees with care-fully calibrating effective portions of parse trees; 2) the syntactic features embedded in a parse tree are particularly effective for relation extraction; 3) the convolution tree kernel can effectively capture the syntactic features for relation extraction. 
The most immediate extension of our work is to improve the accuracy of relation detection. We may adopt a two-step method (Culotta and Soren-sen, 2004) to separately model the relation detec-tion and characterization issues. We may integrate more features (such as head words or WordNet semantics) into nodes of parse trees. We can also benefit from the learning algorithm to study how to solve the data imbalance and sparseness issues from the learning algorithm viewpoint. In the fu-ture, we would like to test our algorithm on the other version of the ACE corpus and to develop fast algorithm (Vishwanathan and Smola, 2002) to speed up the training and testing process of convo-lution kernels. Acknowledgements: We would like to thank Dr. Alessandro Moschitti for his great help in using his Tree Kernel Toolkits and fine-tuning the system. We also would like to thank the three anonymous reviewers for their invaluable suggestions. 
