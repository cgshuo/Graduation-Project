 We introduce EntityEngine, a system for answering entity-relationship queries over text. Such queries combine SQL-like structures with IR-style keyword constraints and ther e-fore, can be expressive and flexible in querying about enti-ties and their relationships. EntityEngine consists of var ious offline and online components, including a position-based ranking model for accurate ranking of query answers and a novel entity-centric index for efficient query evaluation. Categories and Subject Descriptors: H.3.3 Information Storage and Retrieval: Information Search and Retrieval General Terms: Algorithms, Design, Experimentation Keywords: entity search, entity ranking, structured entity query, Wikipedia The Web is now an information repository full of entities . In discovering fascinating entities, Web users are in need o f structured querying facilities that explicitly deal with t he entities, their properties, and relationships.
 Example 1 (Motivating Example): Consider a business analyst interested in this task: Find the list of companies and their founders , where the companies are in Silicon Val-ley and the founders are Stanford graduates.

Two major mismatches make keyword search unsuitable for resolving such tasks. First, our tasks focus on typed en-tities such as PERSON and COMPANY and, in database terminology, their  X  X oin X  relationships. Second, our task s of-ten require synthesizing information scattered across diff er-ent places. For instance, one page may tell the analyst that Jerry Yang is a founder of Yahoo! , but whether Yahoo! is a Silicon Valley company and whether Jerry Yang is a Stan-ford graduate may only be found in other pages. Therefore, with only keyword search, the user has to manually assemble information from many result pages of multiple searches.
In this paper, we demonstrate EntityEngine ( http://idir.uta. edu/erq ), a system for answering entity-relationship query (ERQ), for solving tasks like the above one. An SQL-like declarative query mechanism, ERQ produces entities direct ly instead of documents. Below is the query for Example 1. Query 1 (Entity-Relationship Query for Example 1):
We take a DB-IR integration approach in proposing entity-relationship queries. On the one hand, ERQs have explicit structured components: typed entity variables (e.g., x , bound to entities of type PERSON), selection predicates (e.g., p 1 and relation predicates (e.g., p 3 for the requirement that x founded y ). In general, an ERQ may have an arbitrary number of variables and predicates. On the other hand, the predicates are specified by keyword-based constraints. The query semantics dictates that entities satisfy a predicate by a simple and intuitive requirement: the entities co-occur wi th the keywords in some contexts. A context can be a sen-tence, a window of text, etc. For simplicity, we use sentence as context in this demo. For example, predicate p 1 requires every x in the query answer to co-occur with  X  X tanford X  and capture entity properties and relationships through shall ow though such syntax clue is by no means rigorous or error-proof (e.g., false evidence such as  X  X  X  X  partner is a Stanfor d graduate X ), it becomes robust when we take into account the repetitive nature of the Web: true facts are more likely to be stated on many different pages.

Our approach is different from previous work in two im-portant aspects. (1) We support complex queries with mul-tiple selection and relation predicates. Studies on entity search [2, 3, 6] focus on single-predicate queries. The INEX and TREC entity tracks do not consider entity relation-ships, i.e., relation predicates. (2) The DB-based approac h of structured querying of the Web [1] explicitly extracts in -formation into databases (or similarly into RDF [5]), which will then be queried. This approach is constrained by the ca-pability of the information extraction (IE) and natural lan -guage processing (NLP) techniques. Particularly, it requi res explicit identification of the  X  X ames X  of entity relationsh ips. For example, if a  X  X ound X  relation between Jerry Yang and Yahoo! was not detected during extraction phase, the infor-mation is lost and could not be queried. By contrast, ERQ, as an alternative to the DB-based approach, relies on users in forming keyword constraints. It is particularly attract ive for tasks where entity properties and relationships cannot be satisfactorily extracted given the capacity of IE techniqu es.
Entity Catalog and Corpus: The 2008-07-24 snapshot of Wikipedia (about 2.5 million English articles) is used as allowing a context to match  X  X lumni X  if not  X  X raduate X . ity in choosing proper keywords, as in IR queries. the entity catalog, i.e., each article describes one entity and its title is the entity name. The same snapshot is also the corpus. In an article, the hyperlinks to other Wikipedia articles are occurrences of the linked entities. About 0.75 million entities are assigned into ten predefined types base d on simple hand-crafted rules. Nearly 100 million occurrenc es of these entities are collected from the corpus. We are also pages to enable ERQs on Web corpus.

EntityEngine is implemented upon Apache Lucene. It has several offline and online components, as shown in Figure 1.
Offline Components: For each article, the Preprocessor removes section titles, tables, etc., retaining only the ma in text, which is segmented into sentences. It then removes punctuation marks and stems all words. The Classifier as-signs entities into predefined types based on simple rules. The Indexer takes preprocessed corpus and typed entities as input and constructs a novel Entity-Centric Index (ECI) [4] that records the occurrences of entities in articles. Unlik e conventional document-centric inverted index in IR system s, ECI orders postings in each inverted list by entity ID instea d of document ID. This design enables more efficient evalua-tion of ERQs than the document-centric index.

Online Components: The Retriever leverages ECI to retrieve entities satisfying query predicates. By the sema n-tics of ERQ, a query can yield many false positive answers due to abundant accidental co-occurrences of entities and keywords. Therefore, in addition to ranking the answers according to co-occurrence frequency, it is also critical t o tell true co-occurrence evidence apart from false evidence . The Ranker is thus based on a Bounded Cumulative Model (BCM) that integrates three position-based features X  prox -imity, ordering pattern, and mutual exclusion. BCM ranks co-occurrence contexts by their likelihood of being true ev -idence. Comprehensive experiments on both INEX bench-mark queries and our hand-crafted queries verified its supe-riority over state-of-the-art techniques adapted for ERQ [ 4]. Finally, the Query Interface is an Ajax-based Web client that assists users in composing queries and displays ranked answers with supporting evidence.
During the demo session, users can either form arbitrary queries or choose from 45 prepared queries, at our demo site http://idir.uta.edu/erq. Below we use Query 1 to illustrat e.
Query Formulation (Figure 2): (1) The user specifies entity variable x by selecting type PERSON from the first combo box. Variable x has one se-lection predicate, p 1 , specified by entering keywords  X  X tan-ford X  and  X  X raduate X  in the input field. The user similarly specifies variable y and predicate p 2 . (2) The user can add more selection predicates to x (and y ) by clicking the  X  X dd X  button beside its predicate and a blank input field appears below it. The user can also remove additional predicates by clicking the  X  X  X  mark beside them. (3) To further explore the interface, the user temporarily defines a third variable CITY z . The user observes four lines in the bottom part of the interface, corresponding to differ-ent combinations of the variables X  xy, xz, yz , and xyz . Re-lation predicates on the combinations can be specified in the corresponding input fields. The user now removes variable z by de-selecting its type CITY. Then all the combinations containing z disappear. (4) The user enters  X  X ound X  in the input field next to com-bination xy , specifying the relation predicate p 3 . The user clicks the  X  X O X  button and the constructed query is sent to EntityEngine for evaluation.

Result Interpretation (Figure 3): 25 answers are re-turned for Query 1. (Figure 3 shows only one of them.) A snippet is provided under each answer, e.g., the black box in Figure 3. The snippet shows one context (sentence) for each predicate, serving as evidence of the answer satisfying the predicate. In the sentences, entities and query keywords ar e highlighted with different colors. The user can browse more evidence sentences for each predicate (if any) by clicking t he  X  X ee all X  link at the end of each sentence.
