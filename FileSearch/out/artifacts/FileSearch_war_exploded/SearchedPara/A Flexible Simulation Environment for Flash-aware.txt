 salizhi@mail.ustc.edu.cn In this paper, we present a flexible simulation environment for the performance evaluation of flash-aware algorithms, which is called Flash-DBSim. The main purpose of Flash-DBSim is to provide a configurable virtual flash disk for upper systems, such as file system and DBMS, so that the algorithms in those systems can be easily evaluated on different type s of flash disks. Moreover, it also offers a prototyping environment for those algorithms inside flash disk, e.g. the algorithms for garbage collection or wear-leveling. After an overview of the general features of Flash-DBSim, we discuss the architectur e of Flash-DBSim. And finally, a case study of Flash-DBSim X  X  de monstration is presented. D.m [S oftware ]: Miscellaneous General Terms : Design, Experiment ation, Performance. Flash disk; Performance evaluati on; Simulation environment. Recently, NAND flash (either SLC-or MLC-based) in the form traditional magnetic disks [1]. For compatibility reasons, current SSDs export a block-level interface, which is supported by the firmware inside SSDs, called Flash Translation Layer ( FTL ) [2]. The FTL module enables software to run on SSDs without any further modifications on the interfaces to storage devices. However, traditional software has mostly been designed and optimized for magnetic disks. Hence, many algorithms in traditional software are needed to be reevaluated in order to fully utilize the special properties of flash disks. and techniques on flash disks, e. g. two new buffering algorithms for flash-based databases can be found in [3] and [4]. Those algorithms are either towards the upper-layered software on SSDs or the modules inside SSDs. In order to evaluate the performance of these algorithms, researchers have to design and implement their own simulation environments or tools [5, 6]. However, most of them were designed for sp ecific experiments and other researchers are hard to reuse them. Moreover, due to the different implemental ways of the simulati on tools, it is difficult to conduct comparisons among different al gorithms. Furthermore, although some works directly used SSDs to measure performance, it is difficult to evaluate the algorithms designed to be integrated inside SSDs, such as the cache algorithms inside SSDs, garbage collection algorithms, and wear-leveling policies. disks, called Flash-DBSim. We aim at providing a unified simulation tool for both the algor ithms running on flash disks and those inside flash disks. Compared to the previous evaluation methods for flash-aware algorithms, Flash-DBSim has the following unique features: either enterprise flash disks or those still in laboratory, e.g., hybrid flash disks using both SLC, MLC, and NOR flash chips. which users only need few codes to integrate the Flash-DBSim into their experiments. This is useful to reduce the redundant work in the current evaluation ways of flash-aware algorithms. such like the FTL/NFTL algorithms. Users can use them directly without any other work. provide statistics results for algorithms running on it. While traditional SSD-based evaluation method can not reflect the status inside SSDs, e.g., the erase behaviors, our tool can capture those properties. Flash-DBSim contains the follo wing components (as shown in Fig.1): (1) VFD Module ( Virtual Flash Device ): This module provides the abstraction of a virtual flash memory with some specific properties such as I/O latencies and erasure limitation. Its main function is to simulate a real NAND-or NOR-based flash disk. (2) MTD Module ( Memory Technology Device ): This module manipulates the VFD module through some internal interfaces. It hides the differences between NAND and NOR flash memory, so upper modules can access all virtual flash memories by using the same interfaces defined in MTD module. (3) FTL Module : This module simulates the FTL/NFTL algorithm, and controls the address translation, space allocation, garbage collection processes. It accesses the underlying virtual flash disk by calling the interfaces provided by the MTD module. (4) Library : The library of Flash-DBSim contains the implementations of some general features of flash memory, such as classes for different NAND or NOR memory, typical FTL algorithms, and so on. These impl ementations can be used in other research works. (5) Public Access Interfaces : This module offers transparent page-level interfaces for upper-layered algorithms. It hides all the details in Flash-DBSim and is i ndependent with the upgrades of the underlying modules. C++ and follow the object-oriented programming standard, which enables users to implement their own algorithms easily. It also makes Flash-DBSim very flexible and configurable, so that it can be used in most flash-based res earch experiments by customizing different VFD, MTD, and FTL modules. Flash-DBSim is designed to serve different types of flash-based experiments. When we need to evaluate a flash-aware algorithm, we can use Flash-DBSim in the following steps: (1) Parameters Configuration Typical parameters include the block numbers, page size, I/O latencies, and so on. The following is an example. (2) Initialization DBSim by using the Initialize interface. For example, suppose we have defined the parame ters in the first step, we can issue the following statement to initialize the environment. (3) Using Page-level Interfaces These interfaces are the only way for users to interact with Flash-DBSim. These interfaces access the underlying modules (FTL, MTD, and VFD) through the predefined interfaces of each module. In case that we want to design and evaluate new SSD-inside algorithms, we need to define new classes such as  X  FTL0001Info  X  and replace the original class in Flash-DBSim. Our demonstration will use Flash-DBSim to evaluation the performance of some flash database buffering algorithms, including LRU, CFLRU [3], and LRU-WSR [4]. We will show how to quickly create a project based on Visual C++ or other programming tools to evaluate the performance of each algorithm on Flash-DBSim. In the demonstrati on, we will first generate four types of traces, namely random, read-intensive, write-intensive, and Zipf-distributed traces, and change the size of buffer as well as the window size of the CF-L RU and compute the hit ratio, write count and estimated runtime of each algorithm. Fig.2 shows the structure of the demonstra tion. The source codes of Flash-DBSim as well as a DLL version are available at http://kdelab.ustc.edu.cn/flash -dbsim/download_en.html. The DLL version offers simpler use in case that you want to evaluate some upper-leveled algorithms. However, the downloadable version does not include the MT D module, which means you can only simulate one flash disk at each running. following. We will present an overview of Flash-DBSim and then we will briefly discuss the process of using Flash-DBSim in the performance testing of the given buffer algorithms. Next, we will present the console-based interface and explain the results of executions. Flash-DBSim is impl emented in C++ language and a Visual C++ environment is requi red for the demonstration. The demonstration of Flash-DBSim is expected to bring some new and practical ideas to researchers in the area of flash-based databases. Foundation of China under the grant no. 60776801 and 60833005. [1] J. Gray. Tape is dead, Disk is tape, Flash is disk, RAM [2] Intel Corporation. Understanding the flash translation layer [3] S. Y. Park, D. W. Jung, J. U. Kang, et al., CFLRU: a [4] H. Y. Jung, H. Shim, S. Y. Park, et al., LRU-WSR: [5] N. Agrawal, V. Prabhakaran, T. Wobber, et al., Design [6] P. Wei, L. Yue, Z. Liu, et al., Flash Memory Management 
