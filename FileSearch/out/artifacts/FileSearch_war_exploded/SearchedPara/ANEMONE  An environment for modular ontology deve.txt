 1. Introduction [8]. The modular structure of ontologies can be exploited in several ways. The bene computational cost and memory requirements.
 the resulting ontology.
 meaningfully and accurately in order to produce useful results as de fl property (properties that are required for a class), a concretizing property (properties that de quantity), and a part-of chain (an ordered list of properties that together de section concludes the paper and describes future work. 2. Related work and background knowledge including C-OWL [14], E-Connections [15], D-DL [16], and P-DL [17]. fi module network. Prot X g X  4.0 and NeOn support the development of ontology modules. They also de these modules. However, neither Prot X g X  4.0 nor NeOn de fi guarantees the construction of an interoperable module network.
 existing ontology building methodologies are composed of top-layer guidelines, guidelines at the lower layers, because they directly in fl methodology elaborates on existing methodologies by de fi 3. ANEMONE modular ontology development methodology ontology. Fig. 1 shows the de fi ned modules and their relations.
The global ontology is organized into modules, which are de as follows: modules in the system.
 are used either by direct reference or specialization in the related domain ontology modules.
Domain ontology module: A domain ontology module de fi nes related domain-speci ontology modules share common concepts, these concepts are de corresponding higher-order domain ontology module, and its subconcepts are de ( Specializing the higher-order domain concept ). On the other hand, if a concept is de modules ( Referring the higher-order domain concept ).

Local ontology module: A local ontology module stores two kinds of knowledge. The domain concepts . A domain ontology module stores the domain-speci subconcept, which is the specialized or renamed version of the domain ontology concept, is de module. individuals to the unique URIs of ontology instances.

The process of creating the ontology module network starts with the de local ontology developers use domain ontology modules to de entire life-cycle of the ontology module network.

The next two subsections propose two guidelines, which describe these steps in detail. The methodology compatible operations on ontology modules. 3.1. Pattern-based domain ontology development guide de fi nitions of some concepts that are used in the sequel. In this work, we de concepts in the ontology module, S be the all axioms in the ontology module, and expanded and con fi rmed using Algorithm 1.

Algorithm 1 . Computing the expanded version of  X  ex . for i =0 to  X  ex . count do end for if  X  ex =  X  then else end if 3.1.1. Identify the list of terms
Framework of Information System Concepts) report [28] states that organizational structures, work procedures, communication lines, computers, databases, and so on. of terms. 3.1.2. Update the base ontology module if necessary In this phase, the ontology developer examines if the addition of a new domain ontology module ( m network will entail updating the base ontology module. If the m module. Let  X  ex be the set of unapproved concepts in the base ontology module, then Algorithm 1.If  X  ex is not con fi rmed (i.e., the expanded version of ontology developer must import the base ontology module as it is. m . Finally, the base ontology module is added to the import lists of the m developer speci fi es some concepts in the base ontology module as irrelevant, namely, unapproved. 3.1.3. De fi ne classes by reusing existing concepts modules. Assume we have concept c 1 in the domain ontology module m ontology module m D ways:  X 
Specializing the higher-order domain concept: If two common concepts c is de fi ned in the corresponding higher-order domain ontology module m are related in this way. The domain ontology developer de the ComputerHardware ontology as subclasses of the Battery class.  X 
Referencing the higher-order domain concept: If two common concepts c corresponding higher-order domain ontology module m H and substitutes for c modules.
 Rule-1. Each concept de fi ned in a higher-order domain ontology module m ontology modules importing m H )of m H .

A domain ontology module m D  X 
If c 1 is de fi ned in a domain module m D import lists of both m D  X 
If c 1 is de fi ned in a higher-order domain module m H of m D  X 
If c 1 is de fi ned in a higher-order domain module m H concepts (  X  ex ) is expanded and con fi rmed using Algorithm 1.If concepts in m H new higher-order domain ontology module ( m H module are associated with each other, the higher the cohesion of the module. 3.1.4. Construct class hierarchies The class and property hierarchies are constructed according to Rule-2. Rule-2. If C sub / p sub is a class/property in a domain module m subPropertyOf of C / p , then C / p has to been de fi ned in m notions that differentiates it from each of its primitive parents (the Aristotelian from asserting multiple classi fi cations manually.
 normalization result of the tangled hierarchy (shown in Fig. 3 (a)). With some a pure tree structure and the greater the complexity of an ontology. TIP is de subClassOf  X  edges and | N  X  | is the number of nodes in an ontology's inheritance hierarchy:
Let n be the number of alternate hierarchies, and d x be the depth of the x normalization technique can reduce the number of  X  rdfs:subClassOf
On the other hand, if there are no multiple inheritances in the class hierarchy, the (  X  =0). The  X  max and  X  are de fi ned as follows: 3.1.5. De fi ne properties of classes de fi ning multiple domain/range restrictions on a property. Let a property p have a domain C
C and the instance Y must be of type C r . A common pitfall is the de domains of Grape and Wine . This would entail that LindemansBin65Chardonnay , which is de color value White , is also an instance of Grape class.
 the union (  X  ) of the domain/range classes of the property. Next, he speci 3.1.6. Apply ontology design patterns
The patterns presented herein are language extensions to OWL, and they are classi certain logical constructs.
 OWL language in the OWL code slot .
 shared extensions ( Appendix A ) , (b) de fi ne abstract properties ( Appendix B ) , (c) de (d) de fi ne concretizing properties of classes ( Appendix D ) , (e) de relations ( Appendix F ) . 3.1.7. De fi ne class individuals
In general, a domain ontology module represents the schema knowledge of a speci ranges of owl:ObjectProperties. For example, individuals of the Color class, which is de shared by a group of local ontology modules. Thus, these individuals are de 3.1.8. Update domain ontology module domain ontology module, the local ontology developer de fi
Domain ontology developers trace their child ontology modules and move the newly de domain ontology modules, if necessary.

A domain ontology developer can also update the domain ontology module following the module modi  X  module m, can be instantiated in module m by owners and non-owners of m .  X 
No restriction is de fi ned for incremental module modi fi  X   X   X 
Generalization of a concept de fi nition is allowed. But specialization of the concept de 3.2. Local ontology development guide 3.2.1. Identify domain ontology modules to import which imports all of the related domain ontology modules. Next, he de 3.2.2. Specialize domain ontology concepts if necessary concept is de fi ned by specializing a domain module concept. 3.2.3. De fi ne individuals of concepts to more than one class, then the intersection class ( c  X  c 3.2.4. Update local ontology module keep the local module up-to-date. 3.3. Operations on ontology modules this table, m L is a local ontology module, m D is a domain ontology module, m module imported by the ontology module in question, m child question, # stands for  X  number of  X  , x  X  m means that resource x is de subject i and object v . 4. Functionalities of the ANEMONE tool environment
We support the module-based methodology with an ontology development tool. list these features and we also state which feature supports which step of the methodology the erroneous operation or by reporting the error and preventing the operation. (Appendices A to F).

If class C is de fi ned as an instance of  X  ClassWithSharedExtension
Appendix G by moving instances of C from module m 2 , which is a child of module m in Appendix G by de fi ning an instance of the  X  AbstractProperty step in Appendix G by specifying a property as an essential property of class also supports A19 step in Appendix G by specifying a property as a concretizing property of class de fi ned asa concretizingproperty of class C , the tooldeactivatesto de allows de fi ning individuals of  X  Unit  X  class ( Appendix E ). The values of the
A6.1 step in Appendix G . The tool uses parallel composition such as normalization, substring tests, and edit-distance.

In order to verify the effectiveness of the auto-suggestion technique, the letter pairs were swapped, as well as  X  fat-fi ngering  X   X  result. According to [34], the precision ( P ) and recall ( R ) are calculated as follows, where R retrieved, T r is the number of relevant records in the dataset, and A calculated as 0.923076.
 automatically creates a new higher-order domain ontology module m moves the excluded concepts to m H with other classes in the source ontology.
 formats are supported. The ontology developer maps whole column to a class/property and speci operations correspond to ontology development steps from A21 to A23.1 in Appendix G . 5. Evaluation of the ANEMONE Ontology Development Methodology the seven semiotic categories of modeling methodologies ( c de fi ned for each criterion in the sequel. Finally, a total coverage weight ( [12] de fi nes coverage weights  X  1, 1, or 2 for each classi c is calculated using the following function: 5.1. Weltanschauung (c 1 ) recommended. However, the constructivistic worldview is not a crucial requirement, and thus iw ( c criterion. 5.2. Coverage in process (c 2 ) tests the method's ability to address the following issues: ( i ontology ,( i 2 3 ) use and operations of ontologies ,( i development, operations, and maintenance of ontologies . The cw ( c covered; therefore, iw ( c 2 ) is equal to 5.
 process  X  and addresses i 2 1 , i 2 2 , i 2 3 , and i 2 5 methodology addresses is between ]2,5], then cw ( c 2 ) is equal to 2. 5.3. Coverage in product (c 3 )  X  Coverage in product  X  tests the method's ability to operate on ( i development of a single ontology in a stand-alone application is suf iw ( c 3 ) is equal to 1 (Eq. (4)).
 to develop a single ontology. Therefore, the ANEMONE methodology satis  X  methodology for c 3 is equal to 1. 5.4. Reuse of product and process (c 4 ) reuse is important and must be integrated into the process, iw ( c ( i ( i ( i ( i ( i ( i methodology can answer six questions; therefore, it has a coverage weight of 2. 5.5. Stakeholder participation (c 5 ) responsible for developing the method ,( i 5 2 ) those with cover the participants' development; thus, iw ( c 5 ) is equal to 3.
The ANEMONE methodology states that module builders, module users, and equal to two [12]. Therefore, the cw of the ANEMONE methodology is calculated as 2. 5.6. Representation of product and process (c 6 )
Representation languages for both product and process can be ( i formality in the product. This criterion has a high utility; therefore, iw ( c the cw of the ANEMONE methodology for c 6 is equal to 1. 5.7. Maturity (c 7 )  X  fully described ;( i 7 2 ) if the method lends itself to adaptation, navigation, and development ;( i practical applications ;( i 7 4 ) if it is used by many organizations ; and ( i it is recommended for an ontology building method to be widely adopted, iw ( c
The steps in our development process are fully described ( i (Section 6 ). The number of issues about maturity that our methodology satis the coverage weight of the ANEMONE methodology for c 7 is calculated as 1. and meets most of the evaluation criteria. [12] evaluates three method guidelines:
Guide  X  [37],  X  Creating Semantic Web (OWL) Ontologies with Prot X g X  because they do not provide detailed instructions and general guidelines for ontology creation. 6. Case study: an ontology based e-commerce application fi ontology modules, 14 domain ontology modules, and 86 local ontology modules ( Fig. 4 ). This can be used to develop a family of related ontologies ( i ( c in Section 5.5) in the ontology development activity. While domain ontology developers and modules using the schema knowledge in the domain ontology modules. the individual de fi nitions represented in a structured tabular format. following ways. 6.1. Size is required to be greater than zero to ensure existence of at least one acceptable module. to values in [0,1] in the following way: 6.2. Redundancy redundancy) should be limited. 6.3. Connectedness connected; therefore, a low connectedness value indicates a good partitioning. 6.4. Effort
Finally, [42] proposes a combined indicator for partitioning quality as follows: re fl methodology implements compositional ( i 4 5 issue in Section 5.4 ) and blackbox ( i represents the attribute richness , and I represents the inheritance richness . result is a temporary situation that we think will disappear as the number of individuals increases.
The leaf (local) ontology modules are extended with modi fi concepts/terms that are common to all domain ontology modules are placed in the base ontology module. developers moved 5% of local ontology triples, which were the de individuals to the domain ontology modules that contain the de 12% in our case. The domain ontology developers used the ANEMONE tool environment to domain ontology modules (  X  Auto-suggestion of common concepts parent modules (  X  Axiom transport support  X  in Section 4 ).
 ontology developers traced their child ontology modules and moved these concept de editor.
 improvement ratio of around 11  X  20%, 3 indicates an improvement ratio of around 21 7. Conclusion and future work methodology.

Another future direction is to integrate the ANEMONE methodology into the NeOn toolkit to provide a in [49,50] . We also intend to extend the framework described in [12]. Although the classi suf fi methodology.

Finally, as de Hoog says [51] ,  X  it is extremely dif fi scenarios.
 Acknowledgments
This work is based on the PhD dissertation of Tu  X  ba  X zacar (2009). The author is grateful to Prof. O the project collaborators from NETSIS Co. for applying the proposed methodology and tool. Appendix A. Classes with shared extensions
General issue: A module is assigned to a group of experts and can only be modi some cases, other modules need to create and publish individual data in the parent module. preserving the privacy of the rest of the module.

Approach: To solve this problem, we propose the notion of usually the range of the properties that are de fi ned as an owl:ObjectProperty . When we de owners of m , and it represents the individuals of classes with shared extensions , which are de
OWL code: We extend OWL with ClassWithSharedExtension class as follows; b rdfs:Class rdf:ID="ClassWithSharedExtension" N b /rdfs:Class N
An individual of a ClassWithSharedExtension would be the Color class in the base ontology module; b rdf:Description rdf:ID="Color" N b /rdf:Description N Appendix B. Abstract properties subproperties, each of which can be instantiated: width , length and height .
Approach: Use abstract properties. A property that is de fi ontology module. non-abstract subproperties.

OWL code: We de fi ne the abstract property class as follows; b rdfs:Class rdf:ID="AbstractProperty" N b /rdfs:Class N
An example of an abstract property would be; b rdf:Description rdf:ID="dimension" N b /rdf:Description N Appendix C. Essential properties of classes application. The values of these properties must be completed unless the property is de module developer is responsible for completing these values in his local ontology. product  X  attributes that maximally discriminate the product values of these properties is essential for the application.
 accidental property of an object is one that it happens to have but could lack [53]. In our speci de fi ned as the most prominent properties of an object for a speci property in one application, may not be de fi ned as an essential property in another application. restriction does not imply that p is an essential property of
For example, in a clinical information system, you may de Person individual with a missing SSN value.

The value of an essential property is compulsory to complete unless the essential property is de fi individuals in his local ontology. axiom 3 can be translated into the following LP rule ( lp-rule5 ): b rdf:Property rdf:ID="essentialPropertyOf" N b /rdf:Property N
The property brand can be de fi ned an essential property of Product class in a speci b rdf:Property rdf:ID="brand" N b /rdf:Property N Appendix D. Concretizing properties of classes individual, to which a group of real-world individuals, each with a different color, are mapped. count increases to m n .
 values v i , there is at least one real-world individual with a and fi lls the values of these columns for each concrete individual in the database ( d to the abstract individual i in the ontology ( Fig. 7 ).
 b rdf:Property rdf:ID="concretizedBy" N b /rdf:Property N to concretizing properties are handled in the database. b rdfs:Class rdf:ID="MobilePhone" N b /rdfs:Class N Appendix E. Units of measurement without a reference that makes sense of the given value.
 predetermined length .
 value of the domain ontology developer).

OWL code: We de fi ne the Unit class and unit property as follows; b rdfs:Class rdf:ID="Unit"/ N b rdf:Property rdf:ID="unit" N b /rdf:Property N
The unit of the length property speci fi ed as centimeter ; b onteco:Unit rdf:ID="centimeter"/ N b rdf:Property rdf:ID="length" N b /rdf:Property N Appendix F. Part  X  whole relations nesting in concept representation.
 crankcase and carburetor.
 ordered list of properties is as follows: hasEngine , hasCarburetor .
If property p 2 is a successor of p 1 in a part-of chain list then for any x , y and z : p (Fig. 8 ). We translate axiom 4 into the following LP rules ( lp-rule6 and lp-rule7 ):
OWL code: We de fi ne mereologicalSuccessorOf property as follows; b owl:ObjectProperty rdf:ID="mereologicalSuccessorOf" N b /owl:ObjectProperty N
We de fi ne a part-of chain, whose members are hasEngine and hasCarburetor as follows; b owl:ObjectProperty rdf:about="#hasCarburetor" N b /owl:ObjectProperty N Appendix G. The steps of the ANEMONE ontology development methodology.
References
