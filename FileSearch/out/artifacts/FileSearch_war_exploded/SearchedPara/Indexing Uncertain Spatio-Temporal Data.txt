 The advances in sensing and telecommunication technologies allow the collection and management of vast amounts of spatio-temporal data combining location and time information. Due to physical and resource limitations of data collection devices (e.g., RFID readers, GPS receivers and other sensors) data are typically collected only at discrete points of time. In-between these discrete time instances, the positions of tracked moving objects are uncertain. In this work, we propose novel approximation techniques in order to probabilis-tically bound the uncertain movement of objects; these techniques allow for efficient and effective filtering during query evaluation using an hierarchical index structure. To the best of our knowl-edge, this is the first approach that supports query evaluation on very large uncertain spatio-temporal databases, adhering to possi-ble worlds semantics. We experimentally show that it accelerates the existing, scan-based approach by orders of magnitude. H.3.3 [ INFORMATION STORAGE AND RETRIEVAL ]: Infor-mation Search and Retrieval Uncertain Spatio-Temporal Data, Uncertain Trajectory, Indexing
Efficient management of large collections of spatio-temporal data pertaining to mobile entities whose locations change over time is paramount in a large variety of application domains: military ap-plications, structural and environmental monitoring, disaster/rescue management and remediation, Geographic Information Systems (GIS), Location-Based Services (LBS). The technological enabling fac-tors for such applications are advances in sensing and communica-tion/networking, along with the miniaturizations of the computing devices and development of embedded systems. In almost every application domain, the location data at different (discrete) time-instants is obtained via some positioning devices, like GPS-enabled mobile devices, RFID or road-side sensors. In addition, to reduce the communication cost, improve the bandwidth utilization, and cope with storage constraints, often the recorded object trajectories undergo simplification, eliminating some recorded values. Hav-ing object trajectories sampled only at discrete time-instants and/or simplified, renders the movement in-between samples uncertain and query evaluation challenging.

Consider an object o , moving in a one-dimensional space, as il-lustrated in Figure 1. Having complete information about this tra-jectory enables answering a query asking whether the object inter-sects a spatio-temporal window Q . However, this task becomes difficult if only a few positions (at times { t s ,t i ,t ample) of the exact trajectory are recorded. A simple interpolation approach, which connects temporally consecutive observations by line segments and assumes a movement with constant direction and speed between these points, is unacceptable for applications where probabilistic analysis of the uncertain movement is required. When taking uncertainty under consideration, the main challenge is that the space of possible ( location, time ) positions between two ob-servations can grow very large. More importantly, the number of possible trajectories between two observed locations explodes.
A common method to approximate possible locations between two observations is the beads (or necklace) model ([11, 22]). This model is based on some constraints about the motion of an ob-ject. In particular, assuming a maximum speed in each direction of each dimension, the possible locations that an object can visit be-tween two exact observations is bounded. Recent work [8] follows the pragmatic assumption that the uncertain movement of an object between consecutive observations can be described by a Markov-Chain model, which captures the time dependencies between con-secutive locations. [8] shows how the space of possible worlds (i.e., trajectories between consecutive observations) can be effi-ciently analyzed by multiplying Markov-Chain transition matrices and that probabilistic query evaluation can be facilitated by inte-grating pruning mechanisms into the Markov Chain matrices. All these are sufficient for the case where there are few queried objects, following similar movements; however, if there is a large number of objects in the database, with different movements, evaluating a probabilistic spatio-temporal query directly against each object in-dividually (i.e., a scan-based approach) would be very expensive.
In this paper, we propose an indexing framework to efficiently cope with large spatio-temporal data bases. Our work also assumes that the movement of each object follows a Markov-Chain model (described in Section 2). The objective of our index (described in Section 4) is to minimize the number of objects for which exact probabilistic evaluation has to be performed. To achieve this goal, in Section 3, we propose a number of uncertain spatio-temporal (UST) object approximations , which are stored in the index and a set of corresponding pruning methods, which use the approxima-tions to efficiently eliminate objects that may not qualify a given probabilistic query. Section 5 presents an extensive experimental evaluation, which demonstrates the effectiveness of our indexing approach. Related work is discussed in Section 6. Finally, Section 7 concludes the paper.
This section formally defines the type of spatio-temporal data that we index, the stochastic model that we use for uncertain trajec-tories derived from the data, and the query types that we handle. Data: We consider a discrete time and space domain, i.e., the com-mon assumption of many existing works (e.g. [18, 1, 10, 8]), where S = { s 1 , ...s |S| } X  R D is a finite set of possible locations, which we call states ,ina D -dimensional space and T = N + 0 is the time domain. Given this spatio-temporal domain, the (certain) move-ment of an object o corresponds to a trajectory represented as func-tion o : T X  X  of time defining the location o ( t )  X  X  of o at a certain point of time t  X  X  . We consider incomplete (and/or im-precise) spatio-temporal data, where the motion of an object is not recorded by a crisp trajectory. Instead, we are only given a set o.T obs of ( location, time ) observations for each object o .Atany time t/  X  o.T obs , the position of o is uncertain, i.e., a random vari-able. In many applications, a stochastic model can be built and used to infer knowledge about this uncertainty.
 Uncertain Data Model: We refer to the spatio-temporal approxi-mation of a trajectory of an object o in a time interval spanned by two consecutive observations of o at t i and t j as a bead or dia-mond ( o, t i ,t j ) . The diamond can be computed by considering the maximum and minimum (singed) velocities of the object in each dimension [25]. The whole approximation of the trajectory based on a set T obs of observations (i.e., a chain of beads) is re-ferred to as a necklace . For example, the movement of the object in Figure 1 is bounded by a chain of diamonds.

Existing studies on modeling uncertain trajectories ([23, 25, 24, 26, 15]) naively consider all possible trajectories bounded by a necklace equi-probable. However, given two consecutive obser-vations o ( t i ) and o ( t j ) of object o , there are time dependencies between consecutive locations between o ( t i ) and o ( t der some locations in the corresponding diamond (e.g., those near visited by o than others (e.g., those near the boundary of the dia-mond). Therefore, these models possibly yield incorrect inferences resulting in incorrect answers to probabilistic queries. To over-come this problem, in our proposal each uncertain spatio-temporal (UST) object o  X  X  is associated with an uncertain object trajec-tory , which is represented by a stochastic process. The stochastic process assigns to each t  X  T exactly one random variable; random variables at consecutive time moments can be mutually dependent. This dependency is vital in most applications, where the locations of an object at two close points of time are highly correlated. Thus, the uncertain trajectory o ( t ) of object o comprises a set of (crisp) trajectories, each assigned with a probability indicating its likeli-hood to be the true trajectory of o . Thereby, each trajectory with a non-zero probability is called a possible world of o . Assuming that objects are mutually independent, our semantics comply with the classic possible worlds model [6]. If t  X  o.T obs (i.e., the exact location of o at time t has been observed), then o ( t ) corresponds to a (trivial) random variable having one possible location (i.e., state) with probability 1 .

The main challenge in answering a probabilistic spatio-temporal query is to correctly consider the possible worlds semantics in the model. In other words, the query results should comply with the possible worlds model. Naively, this can be done by evaluating the query predicate on each possible world, and summing up the prob-abilities of possible worlds satisfying the query predicate. In gen-eral, the number of possible worlds to be considered is O exhaustively examining all of them requires exponential time, even for finite time and space domains. Clearly, any naive approach that enumerates all possible worlds, is not feasible.

In this work, we model the uncertain movement of an object within a diamond, using a first-order Markov-chain model. This approach models the movement between successive points in time, based on background knowledge (e.g., physical laws) and has proven capable of effectively capturing the behavior of real objects in prac-tice. For instance, [1] and [10] show how Markov-models can ef-fectively capture the movement of vehicles on road networks for prediction purpose. In [18], it is shown that Markov-models can also be used to model the indoor movement of people, as tracked in RFID applications.
 D EFINITION 1. A stochastic process o ( t ) ,t  X  X  , is called a Markov-Chain if and only if
P ( o ( t +1)= s j | o ( t )= s i ,o ( t  X  1) = s t  X  1 , ..., o where the conditional probability is the (single-step) transition probability of object o from state s to state s j at time t . The matrix o.M ( t ):=( o.P i,j ) transition matrix . Let o.P ( t )=( p 1 ,...,p |S ) be the distribution vector of an object o at time t , where p i corresponds to the proba-bility that o is located at state s i at time t . The distribution vector o.P ( t +1) can be inferred from o.P ( t ) as follows: Queries: Within the scope of this paper, we focus on selection queries specified by the following parameters: (i) a spatial window S  X  X  , (ii) a contiguous time window T  X  X  , and (iii) a prob-ability threshold  X  . In the remainder, we use Q = S  X T to denote the search space of a query. The most intuitive definition of a probabilistic spatio-temporal query is given below: D EFINITION 2. [Probabilistic Spatio-Temporal  X  Exists Query] Given a query window S in space and a query window T in time, a probabilistic  X  spatio-temporal exists query (PST  X  trieves all objects o  X  X  such that P (  X  t  X  X  : o ( t )  X  X  )  X  i.e., the trajectory of o intersects the query window Q with prob-ability at least  X  .
 For example, consider the trajectory of Figure 1 and assume that we only know for certain its observed locations at { t s ,t a PST  X   X  Q query defined by rectangle Q would return the de-picted trajectory, only if the probability that the trajectory inter-sects S at any time within T exceeds  X  . Another query type is the Probabilistic Spatio-Temporal  X  ForAll Query ([8]), denoted as (PST  X   X  Q), which requires an object to remain in the spatial win-dow S for the whole time window T . Due to space constraints, we will not discuss this query in this work, but note that our tech-niques proposed for PST  X   X  Q queries can easily be adapted.
By modeling the movement within a diamond using a Markov-chain model, the true probability that an object o satisfies a PST  X  query, can be computed in PTIME [8], exploiting that the matrix M is generally sparse (only a few states are directly connected to a single state). Still, query evaluation remains too expensive over a large spatio-temporal database, where we have to compute the qualification probabilities of all objects. In view of this, we define a set of approximations of uncertain object trajectories enabling spatio-temporal and probabilistic filtering in Section 3. We then show in Secion 4 how we can organize these approximations in an index in order to perform efficient query evaluation.
In this section, we introduce (conservative) spatio-temporal as well as probabilistic (conservative) spatio-temporal (UST-) object approximations, which serve as building blocks for our proposed index, to be presented in Section 4.
To bound the possible locations of an object o between two sub-time pairs ( s, t )  X  S  X  T,t i  X  t  X  t j such that o has a non-zero probability of being at state s at time t . This is done by consider-ing all possible paths between state o ( t i ) at time t i at time t j . An example of a small set of such paths is depicted in Figure 2(a). Here, we can see a set of five possible trajecto-ries of an object o , i.e., all possible ( state, time ) pairs of o in the time interval [ t i ,t j ] . In practice, the number of possible paths becomes very large. Nonetheless, we can efficiently compute the set of possible ( state, time ) pairs using the Markov-chain model: The set of state-time pairs S i reachable from o ( t i ) can be com-puted by performing t j  X  t i transitions using the Markov chain o.M ( t ) of o , starting from state o ( t i ) and memorizing all reachable ( state, time ) pairs. Similarly, we can compute S j as all state-time pairs ( s, t )  X  X  X T ,t i  X  t  X  t j such that o can reach state o at time t j by starting from state s at time t . S j can be computed in a similar fashion, starting from state o ( t j ) and using the transposed Markov chain o.M ( t ) T . The intersection S i,j = S i  X  state-time pairs which are consistent with both observations. Let us note that in practice, it is more efficient to compute S i parallel fashion, to reduce the explored space. When the computa-tion of S i and S j meet at some time t i  X  t  X  t j , we can prune any states which are not reachable by both s ( t i ) at time t time t j . However, the number | S i,j | of possible state-time pairs in S i,j can grow very large, so it is impractical for our index structure (proposed in Section 4) to store all S i,j for each o  X  DB in our index structure. Thus, we propose to conservatively approximate S i,j . The issue is to determine an appropriate approximation of S i,j which tightly covers S i,j , while keeping the representation as simple as possible. The basic idea is to build the approximation by means of both object observations o ( t i ) and o ( t j ) sponding velocity of propagation in each dimension. To do so, we first compute for the set of state-time pairs S i to derive the maxi-mum and minimum possible velocity in the time interval [ t (a) Approximating trajectories where s [ d ] ( o ( t i )[ d ] ) denotes the projection of state s ( o the d -th dimension. By definition, we can guarantee that for any t  X  t  X  t j it holds that
Furthermore, we bound the velocity of propagation at which o can have reached state o ( s j ) at time t j from each location in the state-space S j : Again, we can bound the position of o in dimension 1  X  d  X  at time t i  X  t  X  t j as follows:
In summary, using the positions o ( t i ) at time t i and o t , and using velocities v d ,v d ,v d ,v d , we can bound the random variable of the position o ( t ) of o at time t i  X  t  X  t o ( t )[ d ]  X  I d ( t ):=[ max ( o ( t i )[ d ]+( t  X  t i )  X  v
Deriving these intervals for each dimension, yields an axis-parallel rectangle, approximating all possible positions of o at time t . In the following, we will call this time dependent spatial approximation of o ( t ) in the time interval [ t i ,t j ] between two observations o o ( t j ) a spatio-temporal diamond , denoted as ( o, t i ,t j ) ometric property of this approximation is that computing the inter-section with the query window at each time t is very fast. Another advantage is that existing spatial access methods (e.g., R-trees) can be easily used to efficiently organize these approximations. To store the approximation, we only need to store the 4  X  D real val-ues v d ,v d ,v d ,v d , 1  X  d  X  D . A diamond is reminiscent to a time-parameterized rectangle, used to model the worst-case MBR for a set of moving objects in [19]; however, the way of deriving velocities is different in our case. As an example, Figure 2(a) shows for one dimension d  X  D , positions o ( t i ) at time t i time t j . The diamond formed by the velocity bounds v d ,v and v d conservatively approximates the possible ( location, time pairs. Note that it is possible to use a minimal bounding rect-angle ( o, t i ,t j ) instead of the diamond ( o, t i ,t j tively approximate the ( location, time ) space S i,j . In cases, how-ever, where the movement of an object in one dimension is biased
I in one direction, a rectangle may yield a very bad approximation (see Figure 2(b) for an example). Our index employs both ap-proximations ( o, t i ,t j ) and ( o, t i ,t j ) for spatio-temporal prun-ing; ( o, t i ,t j ) is used for high-level indexing and filtering, while ( o, t i ,t j ) is used as a second-level filter.
Based on the spatio-temporal approximation of an uncertain ob-ject as described in the previous section, it is possible to perform filtering during query processing.

If none of the diamonds assigned to an object o  X  X  intersects the query window, then o is safely pruned. In turn, if a diamond of o is inside the query window S in space, i.e. fully covered by S , at any point of time t  X  X  , then o is a true hit and, thus, o can be immediately reported as result of the query. In order to em-ploy the above spatio-temporal pruning conditions, for a diamond ( o, t i ,t j ) of an object o we need to determine the points of time when it intersect the query window S in space, as well as the points of time when ( o, t i ,t j ) is fully covered by S purpose, it is helpful to focus on the spatial domain S and interpret a diamond as well as the query as a time-parameterized (moving) rectangle. By doing so, we can adapt the techniques proposed in [19]: In general, a rectangle R 1 intersects (covers) another rectan-gle R 2 , if and only if R 1 intersects (covers) R 2 in each dimension. Thus, for each spatial dimension d ( d  X  X  1 ,...D } ), we compute the points of time when the extents of the rectangles intersect in that dimension and the points of time when the extents of the diamond rectangle are fully covered by the query rectangle S .

For a single dimension d , with Equation 1 the query window given by Q d intersects the diamond given by o ( t i )[ d v , v d , v d and v d within the points of time Similarly, Q d fully covers the diamond within the points of time An example is illustrated in Figure 3(a). To compute both sets I int,d and I cov,d , we intersect the margins of the diamond with the query window resulting in a set of time intervals, which subse-quently have to be intersected accordingly in order to derive I and I cov,d . Now, let us consider the overall intersection time in-terval I int = D d =1 I int,d (e.g., see Figure 3(b)) and the overall points of covering time I cov = D d =1 I cov,d .

If, for an object o  X  X  , there is no diamond yielding a non-empty set I int , o can be safely pruned. If any diamond of o yields a non-empty set I cov , o can be reported as result.

In summary, the spatio-temporal filter can be used to identify uncertain object trajectories having a probability of 100% or 0% intersecting (remaining in) the query region Q . Still, the proba-bility threshold  X  of the query is not considered by this filter. In addition, the object approximation may cover a lot of dead space if there exist outlier state-time pairs which determine one or more of the velocities, despite having a very low probability. In the fol-lowing, we show how to exclude such unlikely outliers in order to shrink the approximation, while maintaining probabilistic guaran-tees that employ the probability threshold  X  .
We now propose a tighter approximation, based on the intuition that the set of possible paths within a diamond is generally not uni-formly distributed: paths that are close to the direct connection be-tween the observed locations often are more likely than extreme paths along the edges of the diamond. Therefore, given a query with threshold  X  , we can take advantage of a tighter approximation, which bounds all paths with cumulative probabilities  X  to perform more effective pruning.

Based on this idea, we exploit the Markov-chain model in order to compute new diamonds, which are spatio-temporal subregions, called subdiamonds, of the (full) diamond ( o, t i ,t j ) in Figure 4(a). For each such subdiamond, we will then show how to compute the cumulative probability of all possible trajectories of o passing only through this subdiamond. Let us focus on restricting the diamond at one direction of one dimension; we choose one di-mension d  X  D , and one direction dir  X  X  X  ,  X  X  . Direction corresponds to the two diamond sides v d and v d ( v d and v obtain the subdiamond, we scale the corresponding sides by a factor  X   X  [0 , 1] relative to the average velocity v avg We obtain the adjusted velocity values for direction  X  as follows: and The adjusted velocity values for direction  X  can be computed anal-ogously. Thus, for a given diamond ( o, t i ,t j ) , dimension d direction dir  X  X  X  ,  X  X  and scalar  X   X  [0 , 1] , we obtain a smaller diamond ( o, t i ,t j ,d,dir, X  ) , derived from ( o, t i ,t direction dir in dimension d by a factor of  X  . Figure 4(b) illus-trates some subdiamonds for one dimension, the  X  direction and for various values of  X  .

To use such subdiamonds for probabilistic pruning, we first need to compute the probability P ( inside ( o, ( o, t i ,t j ,d,dir, X  object o will remain within ( o, t i ,t j ,d,dir, X  ) for the whole time interval [ t i ,t j ] , in a correct and efficient way. The main challenge for correctness, is to cope with temporal dependencies, i.e. the fact that the random variables o ( t i ) and o ( t i +  X t ) are highly corre-lated. Thus, we cannot simply treat all random variables o mutually independent and aggregate their individual distributions. To illustrate this issue, consider Figure 4(a), where one subdia-mond is depicted. Assume that each of the five possible trajec-tories has a probability of 0 . 2 . We can see that three trajectories are completely contained in the subdiamond, so that the probability P ( inside ( o, ( o, t i ,t j ,d,dir, X  ))) that o fully remains in the sub-diamond ( o, t i ,t j ,d,dir, X  ) is 60% . However, multiplying for all time instants t  X  [ t i ,t j ] the individual probabilities that o is lo-cated in ( o, t i ,t j ,d,dir, X  ) at time t produces an arbitrarily small and incorrect result, as time dependencies are ignored. Further-more, due to the generally exponential number of possible trajecto-ries, P ( inside ( o, ( o, t i ,t j ,d,dir, X  ))) is too expensive to com-pute by iterating over all possible trajectories. Instead, we compute this probability efficiently and correctly, as follows.

To compute the probability of possible trajectories between o at t i and o ( t j ) at t j that are completely contained in ( ) , an intuitive approach is to start at o ( t i ) at time t i transitions using the Markov-chain o.M ( t ) . After each transition, we identify states that are outside ( o, t i ,t j ,d,dir, X  ble trajectory which reaches such a state is flagged. Upon reaching t , we only need to consider possible trajectories in state o since all other worlds have become impossible due to the observa-tion of o at t j . The fraction of un-flagged worlds at state o time t j yields the probability that o does not completely remain in ( o, t i ,t j ,d,dir, X  ) .
 To formalize the above approach, we first rewrite the probability P ( subdiamond , 1 given the observations o ( t i ) , o ( t j o.T obs , using the definition of conditional probability:
P ( inside ( o, ) | o ( t i ) ,o ( t j )) = P reaches the state o ( t j ) observed by observation o ( t starting at o ( t i ) at time t i remains inside . P ( o ( the probability that state o ( t j ) at time t j is reached, given that o starts at o ( t i ) at time t i , regardless whether o remains in .
In the previous section, we described, how to compute the prob-ability of a probabilistic diamond ( o, t i ,t j ,d,dir, X  mond ( o, t i ,t j ) , dimension d , direction dir , and scaling factor  X  . In this section we will show how to find, for a given query window Q and a given query predicate the subdiamond with the highest pruning power. Let us focus on PST  X   X  queries first. That is, our aim is to find a value for d , dir and  X  , such that the resulting subdi-amond ( o, t i ,t j ,d,dir, X  ) does not intersect Q , and at the same time it has a high probability P ( inside ( o, )) . This probability can be used to prune o as we will show later. Formally, we want to efficiently determine constrained to Q  X  ( o, t i ,t j ,d,dir, X  )=  X  .

For a single dimension d , and the north direction, a possible situ-ation is depicted in Figure 4(d). Here, the projection d ( the full diamond ( o, t i ,t j ) to the d -th dimension and the projec-tions Q 1 [ d ] and Q 2 [ d ] of two query windows Q 1 and
Since the context is clear, we simply use to denote ( o, t i ,t j ,d,dir, X  ) . picted. The aim is to find the largest values  X  opt of  X  , such that the corresponding probabilistic diamond ( o, t i ,t j ,d,  X  , X  we call optimal subdiamond, does not intersect Q 1 ( Q 2 ). To solve this problem, we distinguish between the following cases. Case 1: the direct line between observations ( o ( t i ) ,t in dimension d intersects Q [ d ] . In this case, there cannot exist any  X   X  [0 , 1] such that Q  X  ( o, t i ,t j ,d,dir, X  )=  X  . Therefore, our problem has no solution in dimension d , and d is ignored. Case 2: the direct line between ( o ( t i ) ,t i ) and ( o not intersect Q [ d ] , and we assume without loss of generality that Q [ d ] is located above this line. 2 In addition, in this case, the time value of the north corner c of d ( o, t i ,t j ) is located in the interval T (e.g., see Q 2 in Figure 4(d)). 3 In this case, the edge v opt of the optimal subdiamond by ( o ( t i ) ,t i ) and ( s, t ) where s corresponds to the lower bound of S [ d ] and t equals to the time component of c .
 Case 3: Q is above the direct line between ( o ( t i ) ,t (as in Case 2), but the time value of the north corner c of is not located in the time interval T (e.g. Q 1 of Figure 4(d)). In this case, the optimal subdiamond must touch a corner of Q [ due to convexity of both Q [ d ] and any diamond. If Q [ d cated to the left of c (the right direction is handled symmetrically), then the edge v opt of the optimal subdiamond is given by the line between ( o ( t i ) ,t i ) and the lower right corner of Q [ Figure 4(d)).

The optimal value  X   X  opt for cases 2 and 3 equals the quotient v  X  v avg , i.e., the fraction of the maximum velocity of the opti-mal subdiamond and the maximum velocity of the full diamond, both normalized by the average velocity v avg = s ( t j )[ After identifying the value for  X   X  opt , for a dimension d and a di-rection dir , we can compute the probability of the corresponding subdiamond ( o, t i ,t j ,d,dir, X   X  opt ) . Since we can guarantee, that any path in this subdiamond does not intersect the query window, we can obtain a lower bound P
LB ( never ( o, t i ,t j , Q ))= P ( inside ( o, ( o, t i of the event that o never intersects the query window in the time interval [ t i ,t j ] . This directly yields an upper bound of the probability that the reverse event that o intersects the query
If Q [ d ] is below the line, we consider direction dir =  X  metrically.
Corner c is given by the intersection of lines ( o ( t i ) ( o ( t j ) ,t j )+ v . window at least once in [ t i ,t j ] . This bound can be used for proba-bilistic pruning for PST  X   X  queries, as we will see in Section 3.6.
The main goal of our index structure, proposed in Section 4, is to avoid expensive probability computations for subdiamonds. Since the query window is not known in advance, 2 D computations (i.e., one for each dimension and direction) have to performed in order to identify the optimal subdiamond for a given query and candidate object o . To avoid these computations at run-time, we propose to precompute, for each diamond ( o, t i ,t j ) in D , probabilistic sub-diamonds for each dimension and direction and for a set  X  values. This yields a catalogue of probability values, i.e. a proba-bility for each ( o, t i ,t j ,d,dir, X  ) ,d  X  D,dir  X  X  X  ,
Given a query window, the optimal value  X  opt computed in Sec-tion 3.4 may not be in  X  . Thus, we need to conservatively approxi-mate the probability of probabilistic diamonds ( o, t i ,t for which  X /  X   X  . We propose to use a conservative linear approxi-mation of P ( inside ( o, ( o, t i ,t j ,d,dir, X  ))) which increases mono-tonically with  X  , using the precomputed probability values. For example, Figure 4(c), shows the (  X , probability ) -space, for six puted pairs (  X , P ( inside ( o, ( o, t i ,t j ,d,dir, X  )))) Our goal is to find a function f (  X  ) that minimizes the error with respect to P ( inside ( o, ( o, t i ,t j ,d,dir, X  )) , while ensuring that  X   X   X  [0 , 1] : f (  X  )  X  P ( inside ( o, ( o, t i ,t j ,d,dir, X  latter constraint is required to maintain the conservativeness prop-erty of the approximation, which will be required for pruning. We model this as a linear programming problem: find a linear function l (  X  )= a  X   X  + b that minimizes the aggregate error with respect to the sample points, under the constraint that the approximation line does not exceed any of the sample values (e.g., the line in Figure 4(c)). That is, we compute: We use the simplex algorithm to solve fast this optimization prob-lem. In summary, a probabilistic spatio-temporal object o is ap-proximated by a set of | o.T obs | X  1 diamonds, one for each sub-sequent time points t i ,t j  X  o.T obs . Each diamond approximation contains its spatio-temporal diamond ( o, t i ,t j ) , consisting of four real values v ,v ,v ,v , and a set of 2  X  D linear approxima-tion functions f d,dir (  X  ) , one for each dimension d  X  direction dir  X  X  X  ,  X } . Next, we will show how to use these ob-ject approximations for efficient query processing over uncertain spatio-temporal data.
For each dimension d  X  D and direction dir  X  X  X  ,  X } ,wenow have a linear function to approximate all (  X , P ( o, t i However, using this line directly, may violate the conservativeness property, since the true function may have any monotonic increas-ing form, and thus, for a value  X  Q located in between two values  X  and  X  2 (  X  1 , X  2  X   X  , X  1 &lt; X  Q &lt; X  2 ) the probability is bounded by P (  X  1 )  X  P (  X  Q )  X  P (  X  2 ) . To avoid this problem, we can exploit that the catalogue  X  is the same for all diamonds, dimensions and directions. Thus, we chose the function f (  X  )= l (  X  ) , where  X  denotes the largest element of  X  such that  X   X   X  . In our run-ning example, the function f (  X  ) is depicted in Figure 4(e). In this example, assume that we have computed an optimal value  X  opt the previous steps. The corresponding conservative approximation f (  X  opt ) is shown.

Now, we show how these probability bounds can be used to bound the probability that an object (i.e. its corresponding chain of diamonds) satisfies the query predicate. This is done by prob-ing each uncertain trajectory approximation (each necklace) on the query region Q . Obviously, we only have to take into account di-amonds intersecting the query time range T . In turn, when prob-ing an uncertain trajectory approximation ( o, t i ,t j ) range Q , we only have to take the time range [ t i ,t j ] i.e., if the time range T of the query spans beyond [ t i truncate T accordingly. Consequently, in the case where more than one diamonds of an object intersect T , we can split the time dimension and separately probe the object diamonds on the corresponding query parts. The resulting probabilities obtained for individual diamonds can be treated as independent.

L EMMA 1. Let ( o, t i ,t j ) , ( o, t j ,t k ) be two successive di-amonds of object o and 1 := ( o, t i ,t j ,d 1 ,dir 1 , X  1 ( o, t j ,t k ,d 2 ,dir 2 , X  2 ) be probabilistic subdiamonds, associated with respective probabilities P ( 1 ) and P ( 2 ) that o intersects these subdiamonds. Then, the probability P ( 1  X  2 ) that o in-tersects both subdiamonds, is given by
P ROOF . We first rewrite P ( inside ( o, 1 )  X  inside ( o, ing conditional probabilities.
 Furthermore, we exploit the knowledge that object o is at the ob-served location o ( t j ) at time t j
P ( inside ( o, 1 ))  X  P ( inside ( o, 2 ) | inside ( o, 1 Based on the Markov model assumption, we know that, given the position at t j , the behavior of o in the time interval [ pendent of any position at times t&lt;t j . Thus, we obtain: Finally, the lemma is proved based on the fact that the position o ( t j ) has been observed, and thus, is not a random variable.
Lemma 1 shows that the random events of two successive proba-bilistic diamonds of the same object are conditionally independent, given the observation in between them. This observation allows us to compute the probability P  X  ( o ) that the whole chain of diamonds of o intersects a query window Q . Let { t i ,t j } X  seq o.T set of pairs of subsequent observations in o.T obs . Then, That is, o satisfies a PST  X   X  query, if and only if at least one dia-mond of o intersects Q at least once. Rewriting yields Exploiting Lemma 1 yields Using our probability bounds derived in Section 3.4, we obtain which can be used to prune o ,if
If Equation 4 cannot be applied for pruning, we propose to it-eratively refine single diamonds of o . Thus, the exact probabil-ity P ( sometimes ( o, t i ,t j , Q )) is computed using the technique proposed in [8]. This exact probability of a single diamond can then be used to re-apply the pruning criterion of Equation 4 , by using the true probability as lower bound. When all diamonds of o have been refined, Equation 4 yields the exact probability P  X  (
In the previous section, we showed that we can precompute a set of approximations for each object, which can be progressively used to prune an object during query evaluation. In this section, we in-troduce the UST-tree, which is an R-tree-based hierarchical index structure, designed to organize the object approximations and effi-ciently prune objects that may not possibly qualify the query; for the remaining objects the query is directly verified based on their Markov models, as described in [8] ( refinement step ). Section 4.1 describes the structure of the UST-tree and Section 4.2 presents a generic query processing algorithm for answering PST X   X  queries.
The UST-tree index is a hierarchical disk-based index. The basic structure is illustrated in Figure 5. An entry on the leaf level corre-sponds to an approximation of an object o represented by a quadru-ple ( ( o, t i ,t j ) , ( o, t i ,t j ) , { f d,dir : d  X  containing (i) the MBR approximation ( o, t i ,t j ) (cf. Section 3.1), (ii) the diamond approximation ( o, t i ,t j ) (cf. Section 3.1), (iii) a set { f d,dir : d  X  D,dir  X  X  X  ,  X }} of 2  X  D linear ap-proximation functions for the precomputed probabilistic diamonds of o (cf. Section 3.5), and (iv) a pointer oid to the exact uncertain spatio-temporal object description (raw object data). Intermediate node entries of the UST-tree have exactly the same structure as in an R-tree; i.e., each entry contains a pointer referencing its child node and the MBR of all MBR approximations stored in pointed subtree. Note that the necklace of each object is decomposed into diamonds, which are stored independently in the leaf nodes of the tree. Since the directory structure of the UST-tree is identical to that of the R-tree, the UST-tree uses the same methods as the R [2] to handle updates.
Given a spatio-temporal query window Q , the UST-tree is hier-archically traversed starting from the root, recursively visiting en-tries whose MBRs intersect Q ; i.e., the subtree of an intermediate entry e is pruned if e.mbr  X  X  =  X  . For each leaf node entry e , we progressively use the spatio-temporal and probabilistic diamond approximations stored in e to filter the corresponding object.
In the spatio-temporal filter step, we first use ( o, t i MBR Filter) using simple rectangle intersection tests. If this fil-ter fails, we proceed using ( o, t i ,t j ) (ST-Diamond filter) by per-forming intersection tests against Q as described in Section 3.2. Note that sometimes multiple leaf entries associated with an ob-ject are required to prune an object or confirm whether it is a true leaf level: directory levels: hit . Therefore, candidates are stored in a list until all their diamond approximations have been evaluated.

Finally, for the remaining candidates we exploit the probabilis-tic filter (Probabilistic Diamond Filter) as described in Section 3.6. Thereby, we use the linear approximation functions { f d,dir D,dir  X  X  X  ,  X }} stored in the leaf-node entry in order to derive an upper bound of the qualification probability P (  X  t  X  ( T  X  [ t ,t j ]) : o ( t )  X  X  ) or P (  X  t  X  ( T  X  [ t i ,t j ]) : (depending on the query predicate). For each object o which is not pruned (or reported as true hit), we accumulate in a list L upper bounds of its qualification probabilities from the leaf entries that index the diamonds of o . After collecting all candidate objects, the qualification probabilities stored in the list L ( o ) didate o are aggregated in order to derive the upper bound of the overall qualification probability P (  X  t  X  X  : o ( t )  X  X  ) as described in Section 3.6. If this probability falls below  X  we can skip o , otherwise we have to refine o by accessing the exact object data referenced by oid .
In order to evaluate the proposed techniques we used data de-rived from a real application and several synthetic data sets. Real Data. As a basis for the real world data served the trajectory data set containing one-week trajectories of 10,357 taxis in Beijing from [27]. This heterogeneous dataset contains trajectories having different samples rates, ranging from one sample every fives sec-onds to one sample every 10 minutes. The average time between localization updates (observations) is 177 seconds. The average distance between two observations is 623 m. We applied the tech-niques from [4] to obtain both a set of possible states (mostly corre-sponding crossroads) and a transition matrix reflecting the possible movements of the taxis. We only included data of taxis where the time between two GPS signals (observations) is no more than two minutes to train the Markov chain. The resulting data set consists of 3008 states and 11699 possible transitions between theses states. Synthetic Data. In order to demonstrate the behavior of the pro-posed techniques depending on the underlying data we also gener-ated a set of synthetic data sets with different characteristics. For the possible states, we generated n points uniformly distributed in the [0 , 1] 2 space. Each point was then connected to the points which have an Euclidean distance smaller than . Those connections cor-respond to the possible movements of an object in the space and we randomly assigned probabilities to each connection such that the sum of all outgoing edges sums up to 1. These values are the entries for the corresponding transition matrix. As a default for this dataset we generated 1000 objects each with 100 observations (= 99.000 probabilistic diamonds) and the parameters were set to n = 10000 , =0 . 02 and the catalogue size |  X  | =10 .
 Observations. Additionally to the positions of the states and the transition matrix, we further need observations from each object in order to build a database. The observations were constructed by a directed random walk through the underlying graph (states = vertices and non-zero transitions = edges). At some time steps we memorize the current position of the object and take these time-state-tuples as an observation of the object. The time steps between two successive observations was randomly chosen from the interval [10,15] if not stated otherwise. For the observations of the real dataset we used the GPS data of taxis, where the time between two signals is between 2 and 20 minutes.
 All experiments were run on a Quad Intel Xeon server running Windows Server 2008 with 16 GB RAM and 3.0 GHz. The UST-tree was implemented in Java. For all operations involving matrix operations (e.g., the refinement step of queries) we used MATLAB for efficient processing. All query performance evaluation results are averaged over 1000 queries. The spatial extent of the query windows in each dimension was set to 0 . 1 and the duration of the queries was set to 10 time steps by default. Unless otherwise stated, we experimented with PST  X   X  queries, with  X  =0 . 5 . The page size of the tree was set to 4 KB. Our experiments assess the construction cost of the UST-tree structure and its performance on query eval-uation. For experiments regarding the effectivity of the Markov-chain model, and an evaluation of its capability to capture the real world in various applications, we refer to previous work, e.g., [1, 4, 10, 18], where Markov Chains were proved successful in modeling spatio-temporal data. The first experiment investigates the cost of index construction. In particular, we evaluate the cost for generating the spatio-temporal and probabilistic diamond approximations used to build the entries of the leaf level; this is the bottleneck of constructing and updating the tree, since restructuring operations always take at most 1ms. On the other hand, constructing the probabilistic diamonds is typically 2-3 orders of magnitude costlier, as illustrated in Figure 6(a). Still, this cost is reasonable, since the construction of a probabilistic dia-mond is comparable to the construction of 2  X  D  X |  X  | subdiamonds, which in turn corresponds to one refinement step (considering the subdiamond as a query window). Construction times pay off, when the query load on the database is reasonable. Figure 6(a) illustrates the construction time as a function of the speed of the objects (up-per x-axis values) and the number of time steps between succes-sive observations (lower x-axis values). From a theoretical point of view, both parameters linearly increase the number of reach-able states, i.e., the density of the sparse vectors representing the uncertain position of an object at one point of time. The results reflect the theoretical considerations showing a quadratic runtime behavior with respect to both parameters. In a streaming scenario with several updates/insertions per second and large probabilistic diamonds (due to high speed of objects or large intervals between observations), the construction of probabilistic diamonds can be performed in parallel and is therefore still feasible. Figure 6(b) shows the construction cost as a function of parameter |  X  | determines the number of subdiamonds). Theoretically this param-eter should have a linear impact on the construction time. However our implementation exploits the monotonicity of the uncertain tra-jectories regarding probabilistic subdiamonds; a trajectory which is not included in the probability of a subdiamond, is also excluded from larger subdiamonds in the same dimension and direction. This explains the sublinear runtime w.r.t. |  X  | .
In the first set of query performance experiments, we compare the cost of using UST-tree with two competitors on synthetic data (see Figure 7). Scan+ is a scan based query processing implemen-tation, i.e., without employing any index [8]. For each pair of two successive observations of an object, refinement is performed im-mediately, i.e., there is no filter cost. We enhanced the implemen-tation of Scan+ by prepending a simple temporal filter, which only considers observation pairs which temporally overlap the query window. The R*-Tree competitor approximates all possible loca-tions (i.e. state-time pairs) between two successive observations of an object using only ( o, t i ,t j ) . These MBRs are then indexed us-ing a conventional R*-Tree [2]. In Figure 7(a), we show the average CPU cost per query (I/O cost is not the bottleneck in this problem), for the three competitors. The cost are split into filter and refine-ment costs. Although the R*-Tree has lower filter cost, the overall query performance of the UST-tree is around 3 times better than that of the R*-Tree (note the logarithmic scale). This is attributed to the effectiveness of the different filter steps used by the UST-tree; the overhead of the UST-tree filter is negligible compared to the savings in refinement cost.

Figure 7(b) shows the cost and the effectiveness of the individ-ual filter steps of the filter-refinement pipeline used by the UST-tree. The bars show the overall runtime (query time) of each fil-ter and the numbers on top of the bars show the effectiveness of the filter in terms of remaining (observation pair) candidates af-ter the corresponding filter has been applied. We clearly see that the spatio-temporal filters reduce the number of candidates and, thus, the number of required refinements, drastically. We can also observe that the probabilistic filter can reduce the number of re-finements by 30% after applying the sequence of spatio-temporal filters. Comparing the cost of the probabilistic filter (which is com-parable to that of the spatio-temporal filter) to the cost of candidate refinement, we can observe that the cost required to perform the probabilistic filter can be neglected. This experiment shows that each of the filters incorporated in the UST-tree indeed pays off in terms of CPU cost.

Although I/O cost is not the bottleneck under our setting, the I/O costs of R*-Tree and the UST-tree are illustrated in Figure 7(c) for completeness. Filter cost here means all costs which occur during the traversal of the corresponding index structure, i.e., access to in-termediate and leaf nodes. Refinement cost includes the number of page accesses to refine the observation pairs that pass the filter step, assuming one I/O per such pair. Note, that the cost of a refinement can be much higher than one page access (e.g. if the Markov Chain, which can become very large does not fit in one disk page) under different settings. The UST-tree has higher filtering cost, since the representation of the probabilistic diamonds requires more space and the tree is larger than the R*-Tree, which only stores MBR approximations but incurs much higher I/O cost for refinements.
The above experiments unveil that the most costly operation is the refinement of spatio-temporal diamonds; thus, we now take a closer look at the effectiveness of the three different methods on pruning spatio-temporal diamonds. The next experiments measure the number of spatio-temporal diamonds which have to be refined at the refinement step; these results can be directly translated to runtime differences of the different approaches. (a) |  X  | for different values of  X  (e) varying maximum speed Size of the Catalogue |  X  | . An important tuning parameter for the index is the size of the catalogue which is used for building the probabilistic diamond approximations. In Figure 8(a), it can be observed that the filter effectiveness converges at around (default value for the experiments). Depending on the query param-eter  X  , a too small catalogue yields up to twice as much candidates which have to be refined. Note that the number of refinement can-didates does not decrease monotonically in |  X  | . In general a larger catalogue results in a linear function with a larger approximation error. However, the step-function for the conservative approxima-tion becomes smoother which results in a smaller approximation error. Because of these two contrary effects a larger catalogue does not always result in higher filter effectiveness.
 Query Parameters. The characteristics of the query have differ-ent implications on the index performance. Increasing the spatial extent of the query obviously yields more candidates since more diamonds in the database are affected (cf. Figure 8(b)). The spatio-temporal filter utilizing the diamond approximations becomes more effective in comparison to the ST-MBR-Filter. The percentage of the diamonds which can be pruned using the probabilistic filter re-mains rather constant (at around 30%) in comparison to the spatio-temporal filter. Another query parameter is the temporal extent of the query. Increasing the length of the query time window creases the number of refinement candidates. The results are very similar to the results when increasing the spatial extent of the query; we do not include the comparison plot due to space limitations.
Changing the value of  X  obviously only affects the probabilistic filter (cf. Figure 8(c)). The higher  X  is set, the more candidates can be pruned by the probabilistic filter. From a value of around 20%, the candidates which have to be refined decrease linearly with  X  . Influencing Variables of ST Diamonds. The size of the spatio-temporal diamonds is generally affected by two parameters. One is the time interval between successive observations, since a larger interval increases the space that can be reached by the moving ob-ject between the two observations. For this experiment, the number of time steps between successive observations in the data set was chosen randomly from the intervals on the x-axis in Figure 8(d). The second parameter is the speed of the object and has a similar effect. The speed corresponds to the parameter , which reflects the maximum distance of points which can be reached by an object within one time step (cf. Figure 8(e)). Since larger spatio-temporal diamonds usually result in more objects which intersect the query window, the number of candidates to be refined increase when in-creasing these two parameters. Interestingly, the effectiveness of the ST-Diamond Filter decreases over the ST-MBR-Filter, whereas the pruning effectiveness of the Probabilistic Filter increases. This shows, that the probabilistic filter copes better with more uncer-tainty in the data than the other two filters.
 Database Size. We evaluated the scalability of the UST-tree by in-creasing the amount of observations (cf. Figure 8(f)). The number of results increases linearly with the database size. The experiment also shows that the number of refined candidates increase linearly. Real Data. The experiments on the real world data, show similar behavior as those on the synthetic data. Due to space limitations, we only show excerpts from the evaluation. Figure 9(a) illustrates the results for PST  X   X  queries when varying the value of  X  .Itis notable that the ST-Diamond Filter seems to even perform better (compared to the ST-MBR-Filter) on the real dataset. The reason for this is that the real dataset has much more inherent irregular-ity (regarding the locations and the movement of obejcts). This favors the ST-Diamond filter over the MBR approximation (since diamonds are more skewed as in Figure 2(b)). The probabilistic filter is apparently not affected. When varying the query extent (cf Figure 9(b)) the results resemble the results on the synthetic dataset.
The problem of managing, mining and querying spatio-temporal data has received continuous attention over the past decades (for a comprehensive coverage, see [9]). Specifically for efficient query processing a vast amount of indexing structures for different pur-poses and data characteristics has been developed (an overview and a classification can be found in [14] and [16]). From this body of work, our approach is mostly related to spatio-temporal data index-ing for predictive querying, for example indexes like [19, 12] and approaches like [20]. Still, these papers neither consider probabilis-tic query evaluation nor model the data with stochastic processes.
However, in scenarios where data is inherently uncertain, such as in sensor databases, answering traditional queries using expected values is inadequate, since the results could be incorrect [3]. One of the first works that deal with uncertainty in trajectories is [17]. This work reviews the sources of error which yield to uncertain trajectories and proposes a filter refinement approach for simple query types. The prevalent approach is to bound the possible posi-tions of an object at each point of time by simple a spatial structure resulting in a spatio-temporal approximation. Examples include static ellipses [25, 24, 23], dynamic MBRs (Minimum Bounding Rectangles) [15] and dynamic ellipses [22, 13] yielding skewed cylinders, diamonds and beads, respectively. To answer queries most of the existing works restrict the possible queries. Often no specific assumption is made about the probability density function (pdf) of the object positions over time ([17, 25, 24, 23, 22, 28, 7]). Thus quantifiers such as  X  X lways X ,  X  X ometimes X ,  X  X efinitely X  and  X  X ossibly X  are used to indicate whether an object intersects a given spatio-temporal query window. These types of queries can be answered by only considering the spatio-temporal approxima-tions. As a consequence, these approaches do not compute proba-bilities for objects to qualify the queries. A possibility for returning probabilistic results is to restrict the temporal window of the query, such that queries refer to exactly one point in time (cf. [5, 28]). All the aforementioned approaches avoid modeling and consider-ing the time dependencies between successive object locations (see Section 2). These dependencies were first considered in [8], where a Markov Chain model is used, and [18], where certain event detec-tion is the main focus (this work does not handle window queries).
Our work is also inspired by methods for indexing uncertain spa-tial data. The U-Tree [20, 21] and its extension [29] bound each spatial uncertain object with an MBR and additionally associate it with a set of  X  X robabilistically constrained regions X  (PCR). These PCRs can be used for probabilistic pruning during query process-ing. For efficiency reasons the set of PCRs are conservatively ap-proximated by a linear function over the parameters of the PCRs.
In this work, we proposed the UST-tree which is an index struc-ture for uncertain spatio-temporal data. The UST-tree adopts and incorporates state-of-the art techniques from several fields of re-search in order to cope with the complexity of the data. We showed how the most common query types (spatio-temporal  X  -and  X  queries) can be efficiently processed using probabilistic bounds which are computed during index construction. To the best of our knowl-edge, this is the first approach that supports query evaluation on very large uncertain spatio-temporal databases, adhering to possi-ble worlds semantics. Outside the scope of this work is the con-sideration of an object X  X  location before its first and after its last observation. In both cases, the resulting diamond approximation would be unbounded. An approach to solve this problem is to de-fine a maximum time horizon for which diamond approximations are computed. Beyond this horizon, we can use the stationary dis-tribution of the model M to infer the location of an object.
