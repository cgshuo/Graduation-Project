 Location-based services have attracted significant attentions from both industry and academia, thanks to modern smart-phones and mobile Internet. To provide users with gratifi-cations, location-aware publish/subscribe has been recently proposed, which delivers spatio-textual messages of publish-ers to subscribers whose registered spatio-textual subscrip-tions are relevant to the messages. Since there could be large numbers of subscriptions, it is necessary to devise an efficient location-aware publish/subscribe system to enable instant message filtering. To this end, in this paper we propose two novel indexing structures, MBRTrie and PT-Quadtree . Using the indexes, we devise two filtering algorithms to sup-port fast message filtering. We analyze the complexities of the two filtering algorithms and develop a cost-based model to judiciously select the best filtering algorithm for different scenarios. The experimental results show that our method achieves high performance and significantly outperforms the baseline approaches. Location-based services (LBS) such as Foursquare 1 and Yelp 2 have been extensively deployed in many systems and widely accepted by the Internet users. LBS includes two important models: user-initiated model and server-initiated model. The former, aka location-aware keyword search, re-turns the relevant answers for each user-initiated spatio-textual query (which includes the query location and query keywords) [7, 5]. For example, considering a user who wants to find a hotel nearby, she issues a spatio-textual query with her current location and keywords  X  hotel two-beds room  X  to an LBS system, which returns relevant answers by consid-ering the spatial proximity and textual relevancy. The lat-ter, aka location-aware publish/subscribe, delivers the spatio-textual messages of publishers to relevant subscribers.
In this paper, we focus on location-aware publish/subscribe. http://foursquare.com http://www.yelp.com/ c  X  The subscribers register spatio-textual subscriptions. When a publisher posts a spatio-textual message, the system in-stantly delivers the message to the subscribers whose regis-tered subscriptions are relevant to the message. To evaluate the relevancy between spatio-textual messages and subscrip-tions, we need to combine spatial proximity and textual rel-evancy (see Section 2 for more details).

There are many real-world applications that require the location-aware publish/subscribe services. For example, con-sider a Groupon system. The subscribers (e.g., Groupon customers) register their spatio-textual subscriptions (e.g.,  X  The Avengers  X  at Melbourne University ) to the system. For each message posted by the publisher (e.g., a Groupon message about movie  X  The Avengers: Age of Ultron  X , at Melbourne Downtown ), the system delivers the message to relevant subscribers. Location-aware publish/subscribe has many other real applications, e.g., location-aware news de-livery, location-aware advertisements, and location-aware mar-ket analysis [14, 3].

A publish/subscribe system requires to support large num-bers of subscriptions and a big challenge is to enable instant message filtering [14, 3, 24]. Although Li et al. [14] pro-poses an R t -tree based method, which adds some selected tokens from spatio-textual subscriptions into R-tree nodes and uses the R t -tree to filter messages, it cannot meet the high-performance requirement, because it has low pruning power on the textual part, especially for upper-level R t nodes that contain too many selected tokens.

To address this challenge, we propose two novel spatio-textual index structures, MBRTrie and PT-Quadtree . MBR-Trie constructs a trie structure based on the textual descrip-tion and integrates spatial information into trie nodes while PT-Quadtree utilizes a quadtree to index spatial informa-tion and adds the textual descriptions into the quadtree nodes. Using the indexes, we devise two efficient filtering algorithms. MBRTrie and PT-Quadtree have their own su-periorities: MBRTrie is efficient for the messages with a small number of tokens while PT-Quadtree is efficient for messages with small spatial regions. To achieve high performance for various settings, we analyze the complexities of the two algo-rithms and develop a cost-based model to judiciously select the best filtering algorithm for various scenarios.
To summarize, we make the following contributions. (1) We propose two spatio-textual index structures, MBR-Trie and PT-Quadtree . Based on the two index structures, we propose two efficient filtering algorithm. (2) We analyze the complexities of the two filtering algo-rithms and develop a cost-based model that selects the best algorithm to filter a message. (3) Based on the cost model, we develop a new filtering algorithm and develop several pruning techniques. (4) We have implemented our method. The experimental results on real datasets show our method achieves high per-formance and significantly outperforms existing approaches.
The rest of this paper is organized as follows. In Section 2, we formulate the problem and review related works. We present an MBRTrie index and develop a filter-verification framework in Section 3 while PT-Quadtree index structure is proposed in Section 4. Then we devise a cost-based algo-rithm in Section 5. The experimental results are shown in Section 6. And finally we conclude in Section 7.
We first formalize the location-aware publish/subscribe problem and then review related works.
In a location-aware publish/subscribe system, publishers post spatio-textual messages and subscribers register sub-scriptions to capture their interests. A subscription s in-cludes a textual description s.T and spatial information s.R , denoted by s =  X  T,R  X  . The spatial information is used to capture a subscriber X  X  most interested region. In this pa-per we use the well-known minimum bounding rectangle (MBR) to denote a region s.R . We use the bottom-left corner and top-right corner to describe an MBR, denoted by s.R =  X  ( x bl ,y bl ) , ( x tr ,y tr )  X  . Especially if x y bl = y tr , the region is reduced to a point. The textual de-scription is used to capture a subscriber X  X  content interests, denoted by a set of tokens s.T =  X  t 1 ,t 2 ,  X  X  X  ,t | s.T |
A message m is denoted by m =  X  T,R  X  in which m.T and m.R have the same meaning as those of subscriptions. If the spatial information of a message is a point, we call it point message ; otherwise it is called a range message .

Given a subscription s and a message m , s could be an answer of m if s and m have spatial overlap and all the tokens in s are contained in m 3 , i.e. they satisfy (1) Spatial constraint : m.R  X  s.R 6 =  X  and; (2) Textual constraint : m.T  X  s.T .

Based on the notations, we formalize the location-aware publish/subscribe problem.
 Definition 1 (Location-aware Publish/Subscribe).
 Given a set of subscriptions S = { s 1 ,s 2 ,  X  X  X  ,s |S| message m , a location-aware publish/subscribe system deliv-ers m to s i  X  X  if m.R  X  s i .R 6 =  X  and m.T  X  s i .T . For example, consider the twelve subscriptions in Figure 1. For a point message m p = ( { b,c,d,e,f } , (26 , 14)), subscrip-tion s 4 = ( { b,c,d } ,  X  (20 , 10) , (28 , 18)  X  ) is an answer of m s = ( { b,c,d } ,  X  (20 , 32) , (35 , 35)  X  ) is not an answer as it does is also not an answer as it has a token  X  a  X  which does not appear in m p . We deliver subscriptions s 4 ,s 7 ,s 10 to message m we deliver the subscriptions s 2 ,s 10 ,s 11 to m r .
Our method can efficiently support other metrics, and due to space constraints, we omit the details. Location-Aware Publish/Subscribe. Li et al. [14] pro-posed the R t -tree to support location-aware publish/subscribe, which extended the R-Tree by selecting some representative tokens from subscriptions and adding them into R-tree nodes to enable textual pruning. However, for upper-level nodes, there are many tokens and thus it has low pruning power on textual part. We have compared with this approach and our method significantly outperformed it (see Section 6).
Hu et al. [11] studied the parameterized location-aware publish/subscribe, which requires subscribers to specify pa-rameters to enable personalize filtering. Chen et al. [3] studied the problem of matching boolean range continuous queries to streaming objects. Guo et al. [9] studied on fil-tering dynamic streams for continuous moving boolean sub-scriptions. Obviously they are different from our problem. Wang et al. [19] proposed a cost-based method to support spatial keyword queries using a tree structure. Different from our works, they utilized keyword partition and space partition in one tree structure when constructing index for queries based on expected matching cost. And they com-puted the cost based on the number of queries associated to each partition and the probability that whether the partition is explored during object matching, instead of the complex-ity of filter and verification steps.
 Location-Aware Keyword Search: There are several studies on location-aware keyword search [7, 25, 13, 2, 16, 12]. Felipe et al. [7] proposed IR 2 -Tree which combines an R-tree with text signatures to find top-k answers. Cong et al. [2] presented a location-aware textual search model based on integrating R-tree and inverted files. Lu et al. [16] studied on supporting reverse spatial textual search. All these works designed algorithms to find answers based on the given lo-cation and keywords. For the region-based keyword search problem, Jin et al. [12] proposed a hybrid model to return objects that contain related keywords within a given region. Zhou et al. [25] and Hariharan et al. [10] proposed different strategies for combining R  X  -tree and inverted lists.
In addition, location-aware keyword search has been ap-plied into different scenarios. For example, Yao et al. [23] presented a model to answer similarity string queries in spa-tial databases. Chen et al. [4] studied on query processing in geographic search engines based on spatial keyword search. Roy and Chakrabarti [17] designed a location-aware type ahead search. Wu et al. [20] studied on processing continu-ously moving spatial keywords queries.
Different from location-aware keyword search, location-aware publish/subscribe services adopt a push model which delivers message to relevant subscribers.
 Traditional Publish/Subscribe Services: Foltz and Du-mais [8, 21, 22] studied on selecting textual information un-der space model from IR perspective. Fabret et al. [6] de-signed a  X  X rocessor cache conscious X  algorithm for matching subscriptions. Liu et al. [15] utilized synopses to construct an index to support the publish/subscribe problem.
In this section, we first propose an index MBRTrie in Sec-tion 3.1, and devise a filtering framework in Section 3.2. Then we develop efficient filtering algorithms in Section 3.3.
Before index construction, we first fix a global order for tokens in subscriptions, e.g., the alphabetical order. Then for each subscription, we sort its tokens based on this order. Given a sorted token set T =  X  t 1 ,t 2 ,  X  X  X  ,t | T |  X  ,  X  t set  X  t 1 ,t 2 ,  X  X  X  ,t x  X  is smaller than token set  X  t t based on their token-set order, and associate each subscrip-tion with a subscription ID.

We construct an MBRTrie for subscriptions as follows. For each subscription, we utilize its token set to build a unique path from the root to a leaf in which each trie node is as-sociated with a token. The root and leaf have an empty token . For simplicity, a trie node is interchangeably used with its corresponding token in this paper. Based on this structure, the subscriptions with a common prefix of token sets share the same ancestors. And children of a node are sorted by the corresponding token. Each leaf has an inverted list of subscriptions X  IDs which contains the corresponding token set. As subscriptions are sorted by the token-set or-der, we associate each node n with a subscription ID range [ n ,n u ], where n l and n u respectively denote the minimum and maximal IDs of subscriptions under this node (which are subscriptions on the inverted lists of its leaf descendants).
For each node n , we also associate it with a node MBR , which is the minimum bounding rectangle of MBRs of sub-scriptions under node n , denoted by n mbr . And if the MBR of a message m has no overlap with n mbr , the subtrie rooted at node n can be pruned since all the subscriptions under it have no spatial overlap with m .

For example, Figure 2 gives an MBRTrie of subscriptions in Figure 1 with alphabetical order. The MBR of node 1 is  X  (10 , 0) , (30 , 40)  X  , which is the minimum bounding rectangle of MBRs of subscriptions under node 1, i.e., s 1 and s 2 . Node 8 has a subscription range [ s 3 ,s 9 ]. That means subscriptions s to s 9 are under this node. In other words, subscriptions with token  X  b  X  (node 8) as the first token must be in [ s Space Complexity: Suppose the average token number of subscriptions is S avg , which is usually very small, e.g., 3. The number of nodes in the MBRTrie is at most S avg  X |S| . As many token sets share prefix, the real number is smaller than it. Thus with the total length of inverted lists |S| , the space complexity of MBRTrie is O ( S avg  X |S| ).
 Updates: For a new subscription, we only need to insert it into MBRTrie and update the MBRs and subscription ranges of the nodes on the path from the root to the new inserted leaf. As subscription IDs are sorted in order, we can re-
Figure 2: MBRTrie index by an alphabetical order serve some IDs for accommodating future insertions. For deletions, we can use a special mark to denote the deletions.
To achieve high performance, we want to only visit a small number of relevant trie nodes. Thus in this subsection, we will discuss how to filter MBRTrie nodes.

When traversing MBRTrie , we only need to visit the nodes having leaf descendants which contain subscriptions as re-sults of message. However an MBRTrie node may have a lot of leaf descendants and checking whether it satisfies this condition is expensive. Therefore we propose a filter-and-verification framework. The first step identifies a set of can-didate nodes (there is an answer under the node) and the second step verifies the subscriptions on the inverted lists of leaf descendants of these candidate nodes.
 Step 1 -Filter: For a trie node n , we prune node n , if (1) MBR Filter: n mbr  X  m.R =  X  , which means any sub-scriptions under node n have no spatial overlap with m ; or (2) Token Filter: n 6 X  m.T (The token of n is not in m.T ). As all subscriptions under node n containing this token which does not appear in m , it invalidates the textual constraint. Step 2 -Verification: For each leaf node surviving in the filter step, the subscriptions on its inverted list are candidate answers of message m . All of them must already satisfy the textual constraint since all the tokens in their ancestors ap-pear in the message (otherwise this node should be pruned). However the subscriptions may not satisfy the spatial con-straint because the node MBR contains some regions that have no overlap with the subscriptions in its leaf descen-dants. Therefore we need a verification step to do spatial checking for the subscriptions.

In the verification step, we examine all subscriptions on the inverted lists of leaf candidate nodes. And time com-plexity is O ( P l |I l | ), where l denotes a leaf candidate node and I l is the inverted list of l . In the filter step, we traverse MBRTrie to find candidate nodes. Given a node, the MBR filter checks whether its node MBR has spatial overlap with the message with complexity O (1). For token filter, we find all the trie nodes which appear in the message. Next we introduce several algorithms to efficiently find such nodes.
Given a message m , we first sort the tokens in message m based on a global order (e.g., alphabetical order) and remove the duplicates. Let T =  X  t 1 ,t 2 ,  X  X  X  ,t N  X  denote the sorted token set of m . Next we propose three algorithms to implement the token filter. ProbeTokenSet -Use trie nodes to probe token sets: The first method traverses MBRTrie in pre-order. For each node n , we check whether it satisfies two filters. If not, we prune node n ; otherwise we access its children. Iteratively, we can find all leaf candidate nodes.

As tokens in T are sorted, we can do a binary search to check whether a node n appears in T . The time complexity for checking is O (log N ), where N is the number of tokens in T . In the worst case, we need to enumerate all trie nodes, thus the worst-case complexity is O ( M  X  log N ), where M is the number of nodes in MBRTrie . Next we analyze the average-case complexity.

Suppose there are totally D distinct tokens which are in-dependent. That is given a node, any token has the same probability to appear as a child of it, which is pose there are L i nodes in the i -th level (the level of the dren in the first level is 1. As there are L 1 nodes in the first level, the time complexity for the first-level nodes is O ( L 1  X  log N ). Each node in this level has N D probability to appear in T , which means the probability to access nodes in the second level is N D . As there are L 2 nodes in the second level, the average-case complexity for the second-level nodes is O ( L 2  X  N D  X  log N ). Similarly the average-case time com-plexity for the i -th level nodes is O ( L i  X  ( N D ) i  X  1 Thus the average-case time complexity for all nodes is where H t is the height of MBRTrie .

In practice, N D , and for i  X  3, L i  X  ( N D ) i  X  1  X  log N is close to 0. The average-case time complexity can reduce to ProbeTrie -Use the tokens to probe trie nodes: The second method visits tokens in T in order. For each token t  X  T , it checks whether the root has a child with token t and has spatial overlap with m . If there is no such node, it breaks and visits the next token t i +1 ; otherwise, it locates the node with token t i , and as tokens in T are sorted in order, next we repeat this step for each token after t i in T . Iteratively, it can find all leaf candidate nodes.

To check whether a trie node has a child with token t i , we can do a binary search among all the children of this node. Suppose the average fanout of a node is F . The complexity to do the checking is O (log F ). In the worst case for each combination of tokens in T , we need to do a binary search on the trie, thus the worst-case complexity is
Next we give the average-case complexity. The fanout of the root is L 1 . Thus the average-case time complexity for the first-level nodes is O ( N  X  log L 1 ). Considering the i -th level nodes, their parents are in ( i  X  1)-th level and have ( N probability in T . The average fan-out of ( i  X  1)-th level the i -th level nodes is O logF i  X  1  X  L i  X  1  X  ( N D ) average-case complexity is 0. Thus the average-case time complexity can reduce to Algorithm 1 : MBRTrie ( S ,m ) Input : S : The subscription set; m : A message
Output : R : Answers of m begin end Function MBRTrie-Filter ( n , T n , m , CN ) Input : n : A trie node; T n : Token set; m : A message begin end Function SelectPair ( n , T n , m ) Input : n : A trie node; T n : Token set; m : A message
Output : P : Candidate node set begin end Function MBRTrie-Verify ( m , CN ) Input : m : A message; CN : Leaf candidate node set
Output : R : Answers of m begin end A Cost-based Method: Notice that upper-level nodes usually have many children, thus it is efficient to use tokens to do a binary search on the trie structure. On the contrary, it is more efficient to use trie nodes to probe tokens in mes-sage on the lower-level trie nodes which have few children. Based on this observation, we propose a cost-based method.
Consider a candidate node n . There exists one and only one token in T that matches n (as tokens in T are distinct). Suppose it is t i . Let T n = { t i +1  X  X  X  t N } . We call  X  n,T candidate pair if n satisfies the spatial constraint. If  X  n,T is a candidate pair, we try to find candidate pairs from n  X  X  children. As tokens in T are sorted, n  X  X  children can only match tokens in T n . Based on this observation, we propose an extension-based method to find candidate pairs. Let P denotes the candidate-pair set for n  X  X  children, | n | denotes the number of n  X  X  children. We compute P as follows. (1) If | T n | X  log | n | &lt; | n | X  log | T n | , we use each token t to probe n  X  X  children. If a child c matches t j and c m.R 6 =  X  ,  X  c,T c =  X  t j +1 ,  X  X  X  ,t N  X  X  is a candidate pair and added into P . (2) Otherwise, we use each child of n to probe token set T For a child c , if c matches a token t j  X  T n and c mbr  X  m.R 6 =  X  ,  X  c,T c =  X  t j +1 ,  X  X  X  ,t N  X  X  is a candidate pair and added to P .
Next we repeat the above steps for pairs in P . Iteratively we can find all candidate pairs. And based on the candidate pairs, we can find the leaf candidate nodes.

Figure 3 illustrates the MBRTrie algorithm. It first fixes a global token order and constructs an MBRTrie (line 2-3). Then it calls function MBRTrie-Filter to find candidate nodes (line 7). Finally it verifies the candidates and gets the answers by calling function MBRTrie-Verify (line 8).
MBRTrie-Filter first checks whether the node in a can-didate pair is a leaf node. If yes, we select it into leaf candi-date node set (line 2). Next MBRTrie-Filter adaptively selects a better method to find candidate pairs by calling function SelectPair (line 3). If MBRTrie-Filter finds a candidate pair, it recursively finds candidate pairs based on the current pair (line 5).
 Time Complexity: As we select a better method to find trie nodes, the average-case complexity of the filter step is Cost F T = O
Suppose there are cand T candidate nodes and the inverted step, the time complexity is
An algorithm should satisfy (1) completeness: any sub-scription satisfying the spatial constraint and the textual constraint must be found by the algorithm; and (2) correct-ness: any subscription found by the algorithm must satisfy the spatial constraint and the textual constraint. The MBR-Trie satisfies the two properties as formalized in Theorem 1.
Theorem 1. The MBRTrie algorithm satisfies complete-ness and correctness. 4
For example, consider message m p = ( { b,c,d,e,f } , (26 , 14)) and the MBRTrie in Figure 2. As there are 5 tokens in the message and the root has 4 children, we use trie nodes to probe the token set and find three candidate nodes 1, 8, 23. Node 26 is pruned as its MBR does not contain the message point. For node 1, we find an answer s 1 in its child node 2. For node 8, we select its children 9, 16 and prune nodes 14 and 19. Iteratively we can find all answers for the mes-sage m p . Here we prune sixteen nodes and only visit fifteen nodes in MBRTrie , and the visisted nodes are nodes 0  X  4, 8  X  11, 16  X  18, and 23  X  25.
The node MBRs of the upper-level nodes in the MBRTrie cover large numbers of subscription MBRs and may involve many unnecessary regions. Thus they may have low spatial pruning power. To address this issue, we propose a quadtree-based index structure in Section 4.1, and then introduce efficient filtering algorithms in Section 4.2. To facilitate spatial pruning, we construct a qudatree for MBRs of subscriptions. Firstly we generate a minimal region to cover all subscription MBRs and select the center of the region as root node, and then divide the region into four subregions. Recursively, we divide each subregion into four small regions. For each region, we terminate its division and take it as a leaf node if (1) the number of subscription MBRs that have overlap with the region is smaller than a threshold  X  num ; or (2) the area of the region is smaller than a threshold  X  area . For each leaf node, we maintain an inverted list of sorted IDs of subscriptions whose MBRs have overlap with the region.

If many MBRs have overlaps, they may appear in many inverted lists of leaf nodes. To address this issue, we can use the MX-CIF quadtree implementation [18], which asso-ciates each MBR with the quadtree node corresponding to the smallest region that contains the MBR. In other words, the subscription IDs can be associated with both leaf and non-leaf nodes, and each subscription ID appears in one and only one inverted list. Moreover, given an extra space buffer, we can select some regions and push down the subscription IDs in these regions to their leaf descendant regions.
To support textual pruning in the quadtree, we integrate textual description into nodes. A straightforward method associates a node with all the distinct tokens of subscriptions that have overlap with it. Based on this method, given a message m , we traverse the quadtree from root. For each node, if it has overlap with m.R and there exists a token associated with the node appearing in m.T , we access the node. Otherwise we prune the node, as it does not satisfy the spatial or textual constraint.

For example, consider the quadtree in Figure 4. Sub-scriptions s 3 ,s 5 ,s 9 are in node 1. The token set associated with node 1 should be the union of their token sets, i.e., { b,c,d,f,h } . For range message m r = ( { a,c,d,e } ;  X  (10 , 10) , (40 , 40)  X  ) in Figure 1, as node 1 has spatial overlap with m and contains a token  X  c  X  that appears in the token set, we need to access the node.

In the straightforward method, the number of tokens as-sociated with a node is very large and the pruning power is low. For instance, in the last example we should prune node 1, because although node 1 shares token  X  c  X  with mes-sage m r , all subscriptions under this node contain another token  X  b  X  which does not appear in the message. This is not achieved when we access node 1. To address this issue, we propose a pivotal-token quadtree to reduce the number of tokens associated with nodes. Next we discuss how to select and associate pivotal tokens with each node.

For a leaf node, we generate its pivotal-token set by select-ing a single token from each subscription on its inverted list to represent it. For an internal node, its pivotal-token set is the union of its children X  X  pivotal-token sets. Obviously if the s pivotal-token set has no common token with the message, we can prune the node, as stated in Lemma 1.

Lemma 1. Given a quadtree node n and a message m , if n  X  X  pivotal-token set has no common token with m.T , we can prune the node.

To save the space and improve the performance, we want to minimize the pivotal-token set. However like the mini-mum hitting set problem, this is an NP-hard problem [1]. Thus we propose a greedy algorithm. First we select the largest df token into the pivotal-token set and remove the subscriptions contain it. Then the largest df token in the rest of subscriptions is put into pivotal-token set. Iteratively we can generate the pivotal-token set for leaf nodes until no subscription left. For each internal node, its pivotal-token set is generated by computing the union of its children X  X  sets.
We can further remove tokens for internal nodes as fol-lows. Given a node n , if all its children contain a token t , we will keep t in n , and remove it from all four children. In this way, when checking whether t is contained in the message, we just do it for parent and not repeat for its de-scendants. Utilizing this idea, we keep two pivotal-token sets for a quadtree node: a cover set and a non-cover set. In the cover set, we keep the token appearing in all four chil-dren. For the no common tokens are kept in non-cover set, and they are not removed from children. We call such a quadtree Pivotal-Token Quadtree ( PT-Quadtree ).

For example, the subscriptions in Figure 1 can be con-structed as a PT-Quadtree shown in Figure 4. Consider leaf nodes 2, 3, 4, 5 with subscriptions s 3 ,s 3 ,s 9 ,s 5 . As the four nodes contain token  X  b  X , we select token  X  b  X  as their pivotal tokens . Obviously token  X  b  X  should be kept in their parent X  X  cover set, i.e., node 1. For nodes 17, 18, 19, 20, we respec-tively select pivotal tokens d,b,b,b . As their pivotal-token token is not the same, the cover set of their parent (node 16) is  X  and the non-cover set is { b,d } .
 Space Complexity: Suppose the height of PT-Quadtree is H q and there are N q nodes in the quadtree. If we use the MX-CIF Quadtree [18], each subscription is stored only at the node corresponding to the smallest region that contains the subscription MBR, and the sum of lengths of all inverted lists is |S| . To achieve high performance, we want to keep inverted lists only for leaf nodes, and the inverted-list size is  X   X |S| , where  X  is a parameter and depends on datasets. There are at most |S| pivotal tokens in leaf nodes, and each token is at most stored H q times. Thus the maximal size of pivotal-token sets is O ( |S| X  H q ). In practice, as many subscriptions share tokens, the size is much smaller. Thus the overall space complexity is O ( N q +  X   X |S| + |S| X  H Updates: For a new subscription, we insert into PT-Quadtree and select a pivotal token to insert into the non-cover set of nodes on the path from root to the leaf (if the non-cover Algorithm 2 : PT-Quadtree ( S ,m ) Input : S : The subscription set; m : A message
Output : R : Answers of m begin end Function PT-Quadtree-Filter ( n , m , CN ) Input : n : An PT-Quadtree node; m : A message begin end Function PT-Quadtree-Verify ( m , CN ) Input : m : A message; CN : leaf candidate node set
Output : R : Answers of m begin end set does not contain the token). For deletions, we can use a special mark to denote the deletions.
For the PT-Quadtree , we introduce a filter-and-verification framework. In the filter step, we generate a set of leaf candi-date nodes. Then we verify the subscriptions on the inverted lists of leaf candidate nodes in the verification step. Step 1 -Filter: We traverse PT-Quadtree in a depth-first order. For each PT-Quadtree node n , let n.CSet and n.NSet respectively denote n  X  X  cover set and non-cover set. (1) If n  X  m.R =  X  , we prune node n based on spatial con-straint; (2) If n.CSet  X  m.T =  X  and n.NSet  X  m.T =  X  , we prune the node as it invalidates textual constraint; (3) If n  X  m.R 6 =  X  , n.CSet  X  m.T =  X  , and n.NSet  X  m.T 6 =  X  , n is a candidate. We repeat the filter steps for its children. (4) Otherwise n  X  m.R 6 =  X  and n.CSet  X  m.T 6 =  X  , sub-scriptions on the inverted lists of n  X  X  leaf descendants share a common token with m . Thus we only check whether the descendants of n satisfy the spatial constraint. If yes, these leaf nodes are candidate nodes; otherwise we prune them. Step 2 -Verification: Given a leaf candidate node, as subscriptions on its inverted list may not satisfy both con-straints, we need a verification step to examine the subscrip-tions to get the final answers.
Next we devise an PT-Quadtree based algorithm as shown in Figure 5. First we construct a PT-Quadtree (line 2). Then for the message m , we call function PT-Quadtree-Filter to find candidate nodes from the root (line 4). Consider a candidate node n . PT-Quadtree-Filter first checks whether node n has an overlap with m.R . If not, we prune it (line 2); otherwise, we check whether it satisfies the tex-tual constraint as follows. First if n.CSet  X  m.T 6 =  X  , we need to access all of n  X  X  descendants (line 3, 4); otherwise, we check whether n.NSet  X  m.T 6 =  X  (line 6). If yes we need to visit n  X  X  children (line 8); otherwise, we prune the node. Iteratively we can get all leaf candidate nodes. Theorem 2 formalizes the correctness of our algorithm.

Theorem 2. The PT-Quadtree algorithm satisfies com-pleteness and correctness.

For example, consider PT-Quadtree in Figure 4. For range message m r in Figure 1. As the non-cover set of root con-tains token  X  d  X  which appears in m r .T , we need to visit its children. Node 1 is pruned as its pivotal-token set has no overlap with the token set of m r . We can also prune nodes 14, 19, and 20 as they have no spatial overlap with m r . Thus the leaf candidate nodes are 7, 10, 12, 17. Next we verify the subscriptions s 2 , s 11 , and s 10 on their inverted lists. Time Complexity: We can check whether m.T  X  n.CSet 6 =  X  ( m.T  X  n.NSet 6 =  X  ) using the cost model in Section 3.3. The time complexity is O min(log N  X | n.CSet | , log | n.CSet | X  N ) , where N is the number of tokens in m.T . Suppose there are cand Q leaf candidate nodes and the height of PT-Quadtree is H q . The complexity of the filter step is Cost F Q = O H q  X  cand Q  X  min(log N  X  Avg RT , log Avg RT where Avg RT is the average size of pivotal-token sets.
Note that each subscription of candidate nodes may not have overlap with the message. To find the final answers that satisfy both two constraint, we can use each token in s.T to do a binary search on m.T and the complexity is O ( | s.T | X  log N ). Suppose there are cand Q candidate leaf nodes, the inverted lists of them are I 1 ,  X  X  X  , I cand Q average token size of the subscriptions is S avg . The time complexity of the verification step is
In this section, we first compare MBRTrie and PT-Quadtree algorithms in Section 5.1. Then we propose a pruning tech-nique in Section 5.2 and give a cost-based model in Sec-tion 5.3. Finally, we propose an algorithm in Section 5.4.
In the verification step, MBRTrie only verifies the spa-tial constraint (Section 3.3) and PT-Quadtree needs to verify both spatial constraint and textual constraint (Section 4.2), thus MBRTrie has lower complexity than PT-Quadtree in ver-ification. Next we consider the filter step of two methods.
Let Cost F T and Cost V T respectively denote the cost of the filter step and the verification step of MBRTrie which can be computed by Equations 1 and 2, and the cost of filter and verifications steps of PT-Quadtree are denoted by Cost F Q Cost V Q , respectively. They can be computed by Equations 3 and 4. We consider the following two cases.
 Case 1: Cost F Q &gt; Cost F T . This happens when the message X  X  MBR is large, for example. Cost F Q will be very large. More-over MBRTrie is very efficient to verify the candidates in the verification step, thus we employ the MBRTrie algorithm. Case 2: Cost F Q  X  Cost F T . In this case, we employ the PT-Quadtree algorithm in the filter step since PT-Quadtree is more efficient than MBRTrie in the filter step. For example, for a point message, as PT-Quadtree only accesses a single quadtree node in each level, Cost F Q is very small. And in the verification step Cost V Q is expensive, we have two strategies to verify candidates. The first verifies results as discussed in PT-Quadtree algorithm directly. The second utilizes MBR-Trie algorithm to do further pruning by their inverted lists after generating leaf candidate nodes by PT-Quadtree . The detail of this method is described in the next subsection.
In the MBRTrie , subscriptions are sorted in the token-set order. Therefore subscriptions under node n must be in a range [ n l ,n u ] which means all the ID of subscriptions in the inverted list of n  X  X  leaf nodes are between n l and n u . Based on these ranges we can integrate MBRTrie and PT-Quadtree to filter a message. First we consider a point message.
For a leaf candidate node found by PT-Quadtree for the point message, there are two strategies to find answers from scriptions in I . The second is to utilize MBRTrie and I to do further filtering as follows.

When we traverse MBRTrie , for a trie node n with sub-scription range [ n l ,n u ], we check whether I contains a sub-subscription, as any subscription under it will not satisfy the spatial constraint. We call this technique list pruning which can prune many unnecessary subscriptions.

We utilize a binary search to check whether I has over-lap with [ n l ,n u ]. If I has no subscription within [ n we prune node n . Otherwise, suppose the smallest ID not smaller than n l is n min and n max is the largest ID that no larger than n u . We generate a sublist I n of I by selecting the subscriptions in [ n min ,n max ]. Thus subscriptions under node n that satisfy the spatial constraint must be in I Next we use I n to do pruning for n  X  X  children. Interactively we can find a set of leaf nodes L . For each leaf node l  X  X  , suppose its new list is I l . Each subscriptions in I satisfy the textual constraint and the sum of number of sub-scriptions in the inverted list of leaf nodes in L is smaller than that of I ( P l  X  X  |I l |  X  |I| ). Therefore we only verify subscriptions in I l for spatial constraint and this complexity on new lists is smaller than that on the original list I .
For example, consider PT-Quadtree in Figure 4. For point message m p in Figure 1, we can generate the inverted list I = { s 1 ,s 4 ,s 7 ,s 9 } . Then we traverse MBRTrie in Figure 2. For the children of the root, we prune node 26 as I has no subscription in range ([ s 11 ,s 12 ]) of node 26. For node 8 with range [ s 3 ,s 9 ], it generate a sublist I n = { s 4 ,s 7 easily extend our method to support range messages. Selecting an algorithm in the filter step: As discussing in Section 5.1. We select the filter algorithm based on the cost of Cost F Q and Cost F T as shown in Equation 1 and 3, re-spectively. Cost F T can be easily computed based on the MBR-Trie structure and the message m . For Cost F Q , we only need to estimate cand Q and other parameters can be gotten from the PT-Quadtree structure. For a point message cand Q = 1. Next we discuss how to estimate cand Q for a range message. We can use the k -th level PT-Quadtree nodes to estimate the number of candidates. For each PT-Quadtree node n i in the k -th level, suppose it has | leaves ( n i ) | leaf descendants. Obviously, the larger the spatial overlap || n i  X  m.R || is, the more leaf nodes have overlap with m under node n i , where || n i  X  m.R || is the overlap area between node n i and m.R . Thus we use the following equation to estimate the number,
If Cost F Q &gt; Cost F T , we use MBRTrie algorithm in both the filter and verification steps; otherwise, in the filter step we select PT-Quadtree algorithm. Next we discuss how to select an algorithm for the verification step in this situation. Selecting an algorithm in the verification step: Given a trie node n in the i -th level and a list I n , suppose n matches the j -th token t j in message token set T . As dis-cussed in Section 3.3, we estimate the complexity to find n  X  X  descendants with tokens in T n = { t j +1 ,  X  X  X  ,t N } as below. C
F = O min L i +1  X  log | T n | + L i +2  X  For n  X  X  leaf descendants, we verify subscriptions on their lists with the complexity O ( I n ). As we need to use the range of n to probe I n with complexity O (log |I n | ), the total complexity of the list-pruning technique is The time complexity to directly verify the list is where S avg is the average token number of subscriptions.
Initially we consider the root node and the inverted list gotten by PT-Quadtree . If C L &gt; C V , we directly verify the list; otherwise we traverse MBRTrie using list-pruning technique. Iteratively, we always select a better verification model for each accessed node.
 For multiple inverted lists, C L = O ( C F + P I X   X  I ) and C V = O ( P I X   X  the set of inverted lists generated by PT-Quadtree .
In this section, we devise an efficient location-based filter-ing algorithm, LFilter , asillustrated in Figure 6.
In LFilter , we first construct an PT-Quadtree (line 2) and an MBRTrie (line 3). If Cost F Q &gt; Cost F T , LFilter MBRTrie algorithm (line 5); otherwise it calls function PT-Quadtree-Filter to generate the candidate nodes based on PT-Quadtree (line 7). Then based on the inverted-list set  X  , LFilter calls function HybridPrune to filter the mes-sage using a cost model (line 9).

For each trie node n , if n is a leaf node, we check whether subscriptions on its inverted list satisfy spatial constraint (line 3). Next we select a better verification strategy for the subscriptions on the inverted lists on it satisfy both two con-straints (line 6); otherwise we use list pruning technique on Algorithm 3 : LFilter ( S ,m ) Input : S : The subscription set; m : A message
Output : R : Answers of m begin end Function HybridPrune ( n , T n ,  X  I , R ) Input : n : A trie node; m : A message begin end n  X  X  children (line 9), update the inverted lists using its chil-dren X  ranges (line 11), and recursively check whether access its children (line 12). Iteratively we can find the answers and Theorem 3 guarantees the correctness and completeness.
Theorem 3. The LFilter algorithm satisfies complex-ness and correctness.
We compared with state-of-the-art location-aware pub-lish/subscribe method R t ++ -Tree [14] and location-aware keyword search method IRTree [5] 5 .
 We used two datasets. The first one was a real dataset Twitter . We collected 60 million tweets and selected 10 mil-lion tweets with region information as subscriptions and used others as messages. Each subscription contained an MBR and had 1-5 frequent tokens selected from tweets. The av-erage token number of subscriptions was 3. The second dataset was a synthetic dataset by combing Point of Inter-ests (POIs) in USA and publications in DBLP. The USA dataset contained 17 million POIs and DBLP had 1.5 mil-lion publications. We generated MBRs from the POIs by selecting a POI as the center and extending a random width
We extended it to support our problem by checking whether IR-tree nodes can be pruned with our filters. (a) Short Point Messages (c) Short Range Messages (a) Short Point Messages (c) Short Range Messages and height. Each subscription was generated by selecting an MBR and 1-6 tokens from DBLP. Each message was gener-ated by selecting an MBR and a publication.

To evaluate different algorithms, we generated four groups of messages for both datasets by considering the number of tokens and a point location or an region. For the length of messages, the short and long messages contained 6-20 and 100-1000 tokens, respectively. And each group contained 10, 000 messages. We computed the average elapsed time. Table 1 showed datasets and index sizes, where subscription length represents the number of tokens in a subscription. Due to space constraints, the results on USA dataset were only shown in Section 6.3 to compare with existing methods.
All the algorithms were implemented in C++. All the experiments were run on a machine running Ubuntu with a 3.0GHz CPU and 8 GB memory.

We evaluated the MBRTrie algorithm by varying differ-ent probe strategies: ProbeTokenSet , ProbeTrie , and Cost-BasedProbe , as discussed in Section 3.3. Figure 7 shows the results. We can see that CostBasedProbe achieved the best performance as it adaptively selected a better probing strategy. For upper-level nodes which had large numbers of children, CostBasedProbe used messages to probe trie struc-tures; when the nodes in the lower-level had small number, it used the trie nodes to probe messages. For instance, in Figure 7(d), for messages with 1000 tokens, ProbeTrie took 98 milliseconds, ProbeTokenSet took 72 milliseconds, and CostBasedProbe only took 56 milliseconds.
We compared our three algorithms, MBRTrie , PT-Quadtree , and LFilter by varying the message lengths. The results are shown in Figure 8. LFilter significantly outperformed other two algorithms as it used a cost-based model to se-lect a better strategy to deal with any types of messages. PT-Quadtree was better than MBRTrie for point messages, since it only accessed one node in each level (see Figure 8(a) and 8(b)). However, for range messages, MBRTrie achieved higher performance than PT-Quadtree , as PT-Quadtree was very expensive in the verification step (see Figures 8(c) and 8(d)). For example, in Figure 8(d), for messages with 1000 tokens, LFilter took 16 milliseconds and MBRTrie and PT-Quadtree took more than 50 milliseconds. We compared our LFilter with existing methods, R t ++ -Tree [14] and IRTree [5]. Figures 9 and 10 showed the results on Twitter and USA respectively.

We can see that LFilter outperformed R t ++ -Tree , which in turn was better than IRTree . The reason is that the two existing methods had low pruning power on the textual part. For each R-tree node, if the node contained a token in the message, their method had to visit its children. Thus it ac-cessed huge number of unnecessary nodes. So IRTree and R t ++ -Tree were not efficient for the location-aware filtering problem. Our algorithm always achieved the highest per-formance for any types of messages utilizing its cost-based model to select a better filtering strategy for both filtering and verification. For example, in Figure 9(b), IRTree took more than 15 milliseconds, R t ++ -Tree decreased to 10 mil-liseconds, and LFilter only took 2-4 milliseconds.
Figure 11 showed the results of the scalability of our method by varying the numbers of subscriptions. We can see that our method scaled very well, and with increasing the num-bers of subscriptions, the elapsed time increased almost lin-early. For example, for messages with 600 tokens, the per-formance was 6 milliseconds for 2 million subscriptions and the elapsed time for 10 million subscriptions was only 16 milliseconds. This is because even if the number of sub-scriptions increased, our index structures can pruned a large number of unnecessary subscriptions.
In this paper we have studied the location-aware pub-lish/subscribe problem. We propose two new index struc-(a) Short Point Messages (c) Short Range Messages (a) Short Point Messages (c) Short Range Messages (a) Short Point Messages (c) Short Range Messages tures MBRTrie and PT-Quadtree to address this problem. MBRTrie is efficient for the messages with a small number of tokens and PT-Quadtree achieves high performance for messages with small regions. We also develop a cost-based model LFilter to select the best filtering strategy to achieve high performance for any types of messages. Experimental results show that our method achieves high performance and significantly outperforms existing approaches.

