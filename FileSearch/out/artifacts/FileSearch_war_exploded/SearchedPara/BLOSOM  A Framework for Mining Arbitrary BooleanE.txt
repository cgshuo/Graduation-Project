 We introduce a novel framework, called BLOSOM , for min-ing (frequent) boolean expressions over binary-valued datasets. We organize the space of boolean expressions into four cate-gories: pure conjunctions, pure disjunctions, conjunction of disjunctions, and disjunction of conjunctions. We focus on mining the simplest expressions (the minimal generators ) for each class. We also propose a closure operator for each class that yields closed boolean expressions. BLOSOM efficiently mines frequent boolean expressions by utilizing a number of methodical pruning techniques. Experiments showcase the behavior of BLOSOM , and an application study on a real dataset is also given.
 Categories and Subject Descriptors: H.2.8 [Database Management]: Database Applications -Data Mining General Terms: Algorithms.
 Keywords: Minimal Generator, Closed Itemsets, Boolean Expression, Data Mining
One of the basic goals of data mining is to discover novel patterns that are potentially useful. For example, item-set mining [1] discovers patterns that are pure conjunctions of items. However, this covers a very restricted subset of the wider class of boolean patterns, which may consist of conjunctions, disjunctions, and negations of items. Min-ing such boolean patterns can lead to significant nuggets of knowledge, with many potential applications in market bas-ket analysis, web usage mining, social network analysis, and bioinformatics.

Boolean expression mining can provide tremendous value, but there are two main challenges to contend with. The first deals with the problem of high computational complexity. With n items (or variables), there are 2 2 n possible distinct-valued boolean expressions, far too many to enumerate. To render the search tractable we focus on only the frequent boolean expressions. Also instead of mining all frequent boolean expressions, we focus on mining a lossless subset that retains complete frequency information, namely closed boolean expression. The second challenge relates to com-prehension of the patterns, i.e., they may be complex and difficult to understand. Here we focus on mining the sim-Copyright 2006 ACM 1-59593-339-5/06/0008 ... $ 5.00. plest or minimal expressions (which are in fact the minimal generators of the closed expressions) that still from a lossless representation of all possible boolean expressions. In this paper, we present a novel framework, called BLO-SOM (an anagram of the bold letters in BOOL ean expres-sion M ining over attribute S ets), the first such approach to simultaneously mine closed boolean expressions over at-tribute sets and their minimal generators. Our main con-tributions are as follows: We organize boolean expressions into four categories: (i) pure conjunctions ( and -clauses), (ii) pure disjunctions ( or -clauses), (iii) conjunctive normal form (conjunction of disjunctions), and (iv) disjunctive nor-mal form (disjunction of conjunctions). For each class of expressions, we propose a closure operator, and we give a characterization of the minimal generators . BLOSOM em-ploys a number of effective pruning techniques for search-ing over the space of boolean expressions, yielding orders of magnitude in speedup. We also highlight some of the patterns found using BLOSOM on real datasets. Lattice Theory: Let X  X  first review a few facts from lattice theory [5], which will be useful in our discussion. Let ( P, be a partially ordered set (also called a poset ). Let X, Y P and let f : P  X  P be a function on P . f is called monotone if X  X  Y  X  f ( X )  X  f ( Y ). We say that f is idempotent if f ( X )= f ( f ( X )). f is called extensive (or expansive) if X  X  f ( X ). Finally, f is called intensive (or contractive) if f ( X )  X  X .A closure operator on P is a function C : P  X  P such that C is monotone, idempotent, and extensive. X is called closed if C ( X )= X .Onthe other hand, a kernel operator on P is a function K : P  X  P , which is monotone, idempotent, and intensive. X is called open if K ( X )= X . The set of all closed and open members of P form the fixed-point of the closure ( C )andkernel( K operators, respectively. Given two posets ( P,  X  )and( Q, a monotone Galois connection between them consists of two order-preserving functions,  X  : P  X  Q and  X  : Q  X  P ,such that for all X  X  P and Y  X  Q ,wehave: X  X   X  ( Y )  X  X  X   X  ( X )  X  Y . The composite function  X   X   X  : P  X  P is a closure operator, whereas the function  X   X   X  : Q  X  Q is a kernel operator, on P and Q , respectively [5]. Given posets ( P,  X  )and( Q,  X  ), a anti-monotone Galois connection [5] between them consists of two order-reversing functions,  X  : P  X  Q and  X  : Q  X  P , such that for all X  X  P and Y  X  Q , we have: X  X   X  ( Y )  X  X  X  Y  X   X  ( X ). The composite functions  X   X   X  : P  X  P and  X   X   X  : Q  X  Q are both closure operators on P and Q , respectively [5].
 Boolean Expressions: Let I = { i 1 ,i 2 ,...,i m } be a set of binary-valued attributes or items .Let and , or ,and not denote the usual logical operators. We denote a negated item ( not i )as i . Weusethesymbol | to denote or ,and we simply omit the and operator whenever there is no am-biguity. For example, ( i 3 and i 4 ) or ( i 1 and ( not negation  X  i .A clause is either the logical and or logical of one or more literals. An and -clause is a clause that has only the  X  operator over all its literals, and an or -clause is one that has only the  X  operator over all its literals. We as-sume without loss of generality that a clause has all distinct literals (since a clause is either an and -oran or -clause, repeated literals are logically redundant). A boolean expres-sion is the logical and or or of one or more clauses.
A boolean expression is said to be in negated normal form (NNF) if all  X  operators directly precede literals (any ex-pression can be converted to NNF by pushing all nega-tions into the clauses). An NNF boolean expression is said to be in conjunctive normal form (CNF) if it is an and of or -clauses. An NNF expression is said to be in dis-junctive normal form (DNF)ifitisan or of and -clauses. ( i tion, single or -clauses and single and -clauses, are in both CNF and DNF. Furthermore, when considering negated lit-erals, we disallow a tautology like the or -clause containing i | i which is always true. Similarly, we disallow a contradic-tion like the and -clause containing i  X  i since this is always false. Note that a CNF expression is a tautology if and only if (iff) each one of its clauses contains both an item and its negation. Likewise, a DNF expression is a contradiction iff each one of its clauses contains both a variable and its nega-tion. Thus by disallowing the tautologies (contradictions) in individual clauses, we disallow them in CNF (DNF) ex-pressions, respectively.
 Dataset: Let I = { i 1 ,i 2 ,...,i m } be a set of items, let T A dataset D is then a subset of T X  2 I (note that 2 I denotes the power-set of I , i.e., the set of all subsets of I ); in other words, the dataset D is a set of tuples of the form ( t, t.X ), where t  X  X  is the tid of the transaction containing the set of items t.X  X  X  . Note that any categorical dataset can be transformed into this transactional form, by assigning a unique item for each attribute-value pair.

Given dataset D ,wedenoteby D T the transposed dataset that consists of a set of tuples of the form ( i, i.Y ), where i  X  X  and i.Y  X  X  is the set of tids of transactions containing i . Fig. 1 shows a dataset and its transpose, which we will use as a running example in this paper. It has five items I = { A, B, C, D, E } and five tids T = { 1 , 2 , 3 , 4 , 5 that in D , transaction t 1 contains the set of items { A, C, D (for convenience, we write it as ACD ), and in D T ,thesetof tids of transactions that contain item A is { 1 , 3 , 4 } for convenience we write it as 134).
 Tidset and Support: Given a transaction ( t, t.X )  X  X  , with t  X  X  and t.X  X  X  , we say that tid t satisfies an item/literal i  X  X  if i  X  t.X ,and t satisfies the literal i if i  X  t.X . For a literal l ,the truth value of l in transaction t , denoted V t ( l ) is given as follows: We say that a transaction t  X  X  satisfies a boolean expres-sion E if the truth-value of E ,denoted V t ( E ), evaluates to true when we replace every literal l in E with V t ( l ). For any boolean expression E , t ( E )= { t  X  X  : V t ( E )=1 } denotes the set of tids (also called a tidset ), that satisfy E .
The support of a boolean expression E in dataset D is the number of transactions which satisfy E , i.e., | t ( E ) expression is frequent if its support is more than or equal to a user-specified minimum support ( min sup ) value, i.e., if | t ( E ) | X  min sup . For disjunctive expressions, we also impose a maximum support threshold ( max sup ) to disallow any expression with too high a support. Setting min sup = 1and max sup =  X  allows mining all possible expressions. Boolean Expression Mining Tasks: Given a dataset D and support thresholds min sup and max sup , the task is to mine minimal and closed frequent boolean expressions, such as and -clauses, or -clauses, CNF and DNF.

Before presenting the BLOSOM framework, we first study the structure and properties of four classes of boolean ex-pressions; we consider each case separately  X  and -clauses, or -clauses, CNF and DNF. For simplicity of exposition, we restrict our examples to only positive literals, but our ap-proach is applicable to negated literals as well.
Given dataset D , and thresholds min sup and max sup, thegoalhereistomine or -clauses that occur in at least min sup and in at most max sup transactions. Let E  X  be the set of all possible or -clauses over the set of items is the set of all tids as before. For an or -clause X  X  X   X  L ( X )= { l | l is a literal in X } denote the set of its literals. Given X, Y  X  X   X  , we define the relation  X  between or -clauses as follows: X  X  Y iff L ( X )  X  X  ( Y ). Then  X  induces a partial order over E  X  . For example, A | C  X  A | B | C ,since L ( A | C )  X  X  ( A | B | C ). Let X  X  X   X  be an or -clause, and let l  X  X be some literal in X .Then t ( X )= example, t ( A | B )= t ( A )  X  t ( B ) = 134  X  23 = 1234. Closed or -Clauses: For convenience let the or -clause l | l 2 | X  X  X | l k be represented as the partial order over or -clauses, and let (2 T ,  X  )bethe partial order over the tidsets under the usual subset (  X  relationship.

Theorem 1. Given posets ( E  X  ,  X  ) and (2 T ,  X  ) .Let X E  X  and Y  X  2 T . Then the following two mappings form a monotone Galois connection over E  X  and 2 T :  X  = t : E  X   X  2 T , t ( X )= { t  X  X  | t satisfies X }  X  = i :2 T  X  X   X  , i ( Y )=
Since ( t , i ) forms a monotone Galois connection, it follows immediately that C = i  X  t : E  X   X  X   X  is a closure opera-tor and K = t  X  i :2 T  X  2 T is a kernel operator for or -clauses (see Sec. 2). For example, in our example dataset from Fig. 1, C ( A | C )= i ( t ( A | C )) = i (1234) = A Thus A | B | C | D isaclosed or -clause. On the other hand K (234) = t ( i (234)) = t ( B )=23. Thus23isanopentid-set. It is also easy to see that the corresponding tidset for aclosed or -clause is always open. For example, the closed or -clause A | D has the open tidset 134. We use the notation C ( E  X  ) to denote the set of all closed or -clauses. Minimal or -Clauses: Given any set X of subsets over a universe U ,wedenotebymin  X  ( X ) the set of all minimal members in X , w.r.t. the subset operator  X  .Let X  X  X   X  be a closed or -clause. We say that Y  X  X, Y =  X  is a gen-erator of X if C ( Y )= X . Y is called a proper generator if Y = X . By definition, a proper generator cannot be closed. Let G ( X ) be the set of all generators of X , including X . Then M ( X )=min  X  { Y  X  X  ( X ) } , the set of all the minimal elements of G ( X ) are called the minimal generators of X . The unique maximal element of G ( X )is X .
Lemma 2. Let X = C ( X ) .If Y is a generator of X then t ( Y )= t ( X ) .
 By Lemma 2, t ( Y )= t ( X )= T for all generators Y  X  G ( X ). We conclude that X is the unique maximal or -clause that describes the set of objects T . On the other hand, a minimal generator of X is the minimal or simplest or -clause that still describes the same object set T .Thesetofall minimal generators of closed or -clauses in E  X  is given as M ( E  X  )= closed or -clauses, and their corresponding tidsets, for our example database (from Fig. 1), are summarized in Table 1. Table 1: Closed (CO) and Minimal (MO) or -Clauses
It should be apparent at this point that both closed or -clauses (CO) and minimal or -clauses (MO), individually, quent) or -clauses. We are particularly interested in minimal or -clauses, since they tend to be simpler to comprehend. We would like to gain further insight into the structure of these minimal generators.

We give two separate characterizations of the minimal generators, one based on the closed clauses and the other a direct one. They are both based on the notion of hitting sets. Let X = { X 1 ,X 2 ,  X  X  X  ,X k } be a set of subsets over some universe U .Theset Z  X  U is called a hitting set (or transversal )of X iff Z  X  X i =  X  for all i  X  [1 ,k ]. Let denote the set of all hitting sets of X . Z is called a minimal hitting set if there does not exist another hitting set Z ,such that Z  X  Z .Let X be a closed or -clause, we define the lower-shadow of X as the set X = { X i } i  X  [1 ,k ] where for all i  X  [1 ,k ], X i  X  X , X i is closed, and there doesn X  X  exist any other closed or -clause Y , such that X i  X  Y  X  X .Inother words, the lower shadow of X is the set of closed or -clauses that are immediate subsets of X . We further define the dif-where X i  X  X .

Theorem 3. Let X be a closed or -clause, and let X  X  be the differential lower shadow of X .Then M ( X )=min  X  { Z E  X  | Z  X  X  ( X  X  ) } .

The theorem states that the minimal generators of a closed or -clause X are exactly the minimal hitting sets of the dif-ferential lower shadow of X . For example, consider the closed clause X = A | B | C | D | E . From Table 1 we obtain as its lower shadow the set of closed clauses X = { A | B | C A |
D | E , B | E } . Thus the differential lower shadow of X is given as X  X  = { E, B | C, A | C | D } . The minimal hitting sets of X  X  are given as min  X  {H ( X  X  ) } = { C | E, A | B | We can see from Table 1, that the minimal hitting sets are identical to the minimal generators of A | B | C | D | E .
The above characterization of minimal generators relies on knowing the closed sets and their lower shadows. There is in fact a direct structural description. We define a union tidset to be a tidset obtained by finite unions over the set of tidsets for single items, { t ( i ) | i  X  X } .Let U be the set of all distinct union tidsets. For a union tidset T  X  X  ,we define the transaction set of T ,astheset R ( T )= { t.X  X  I| t  X  T, ( t, t.X )  X  X } , i.e., the set transactions in D with tids t  X  T .

Theorem 4. Let T  X  X  be a union tidset. Then the set min  X  { Z  X  X   X  | Z  X  X  ( R ( T )) and t ( Z )= T } is identical to the minimal generators of the closed or -clause X which has the corresponding open tidset T = t ( X ) .

The above theorem states that every distinct tidset T ob-tained as a union of other tidsets produces minimal gener-ators for the closed or -clause associated with the tidset T . For example, let T =1345= t ( A )  X  t ( E ) in our example database in Fig. 1. Then R ( T )= { ACD, ABCD, ADE, E } . The hitting sets Z with t ( Z )= T and that are minimal are given as follows { A | E, D | E } .Notethat C | E is a minimal hitting set of R ( T ), but t ( C | E ) = 12345 = T ,thuswereject it. We can see from Table 1 that these minimal hitting sets form the minimal generators of the closed or -clause A | D with tidset T = 1345.
Closed and -clauses have been well studied in data min-ing as closed itemsets [4], as well as in the Formal Concept Analysis as concepts [6]. The notion of minimal generators for and -clauses has also been previously proposed in [4]. We thus focus on our novel structural insights for and -clauses. Let E  X  be the set of all and -clauses over the set of items I , Given posets ( E  X  ,  X  )and(2 T ,  X  ), and X  X  X   X  ,Y  X  2 the following two mappings form an anti-monotone Galois connection [6]: Notice the duality, in the definition of i and the Galois con-nection, for or and and clauses (see Theorem 1). Since ( t , i ) forms an anti-monotone Galois connection, it follows that C = i  X  t : E  X   X  X   X  ,and t  X  i :2 T  X  2 T both form a closure operator for and -clauses [6]. We use the nota-tion C ( E  X  )and M ( E  X  ) to denote the set of all closed and minimal generators of and -clauses, respectively.
In terms of the structure of minimal generators for and -clauses, an analog of Theorem 3, describing the minimal generators of a closed and -clause as the minimal hitting sets of its differential lower shadow is already known [9]. We focus instead on a novel characterization of the minimal generators for and -clauses. We define an intersection tidset to be a tidset obtained by finite intersections over the set of distinct intersection tidsets. As before, for an intersection tidset T  X  X  , we define the transaction set of T , denoted R ( T ), as the set of transactions with tids t  X  T . For exam-ple, T = 13 is an intersection tidset since it can be obtained as the intersection of t ( A )and t ( C ). The transaction set of T is the set of transactions with tids 1, and 3, given as R ( T )= { ACD, ABCD } .

Theorem 5. Let T  X  X  be an intersection tidset. Then the set min  X  { Z  X  X   X  | Z  X  X  ( R ( T )) and t ( Z )= T } identical to the minimal generators of the closed and -clause X which has the corresponding closed tidset T = t ( X ) . Table 2: Closed (CA) and Minimal Generators (MA) for and -clauses
This theorem gives a novel structural description of the minimal and -clauses. It states that every distinct tidset T obtained as a finite intersection of other tidsets produces minimal generators for some and -clause. For example, let T =13= t ( A )  X  t ( C ) in our example database in Fig. 1. Then R ( T )= { ACD, ABCD } . The hitting sets Z of R ( T ) with t ( Z )= T and that are minimal are given as follows {
AC, CD } .Notethat A is a minimal hitting set, but t ( A )= 134, thus we reject it. Likewise we reject hitting sets C , D , AB ,and BD . Table 2 lists the set of all closed (CA) and clauses, the minimal generators (MA), and the correspond-ing tidsets. We can see that the minimal hitting sets are identical to the minimal generators of the closed and -clause ACD with tidset T = 13.
Let E dnf denote the set of all boolean expression in DNF, i.e., each X  X  X  dnf is an or of and -clauses. For convenience we denote a DNF-expression X as X = is an and -clause. By definition E  X   X  X  dnf .Also E  X   X  X  dnf since an or -clause is a DNF-expression over single literal ( and ) clauses. We assume we have already computed the corresponding tidsets.
 Note that any DNF-expression X = (in terms of the database) to the DNF expression X = W C ( X i ), since any tidset that satisfies X i must satisfy as well. Similarly X is also equivalent to the DNF ex-pression X = say that X = and -clause X i there does not exist another X j ( i = j ) such that X i  X  X j . Note that any DNF-expression can easily be made a min-DNF-expression by simply deleting the offending clauses. For example in the DNF-expression ( AD ) | ( ADE ), we have AD  X  ADE ; thus the expression is logically equivalent to its min-DNF form ( AD ). For any DNF-expression X , we use the notation min dnf ( X )tode-note its min-DNF form. Given X, Y  X  X  dnf ,with X = and Y = noted X  X  Y , if there exists a 1-1 mapping f that maps each X i  X  X to f ( X i )= Y j  X  Y , such that X i  X  Y j .
Tidset Closed (maximal 123 ( ACD ) | ( BC ) C 134 ( ACD ) | ( ADE ) A, D 234 ( ADE ) | ( BC ) B | ( AE ), B | ( DE ) 345 ( ABCD ) | E ( AB ) | E ,( BD ) | E 1234 ( ACD ) | ( ADE ) | ( BC ) A | B, A | C, B | D, C | D 1345 ( ACD ) | E A | E, D | E 2345 ( BC ) | E B | E 12345 ( ACD ) | ( BC ) | E A | B | E, B | D | E, C | E Table 3: Additional/changed Closed (CD) and Min-imal Generators (MD) for DNF Closed DNF: We now define a closure operator for DNF expressions. First, we consider DNF expressions consisting only of closed and -clauses. Then if we treat each X i  X  C (
E  X  )asa composite item , we can define two monotone mappings that form a monotone Galois connection as fol-lows: Let X = C (
E  X  ), and let Y  X  2 T . Define t ( X )= { t  X  X  | t satisfies X and i ( Y )= plies that C = i  X  t is a closure operator. For example, consider each closed and -clause in Table 2 as an  X  X tem X . Consider X = ACD | E . C ( X )= i ( t ( ACD | E )) = i (1345) = ABCD | ADE | ACD | E | AD , which is a closed DNF expres-sion. However it is logically redundant. What we want is the maximal min-DNF expression equivalent to C ( X ), which is ACD | BC | E .
 Minimal DNF: Let T  X  2 T be a union tidset obtained as the finite union of tidsets of closed and -clauses. As before the transaction set of T ,denoted R ( T ), as the set of trans-actions in D with tid t  X  T . Analogous to Theorem 4 for or clauses, we can characterize the minimal DNF expressions as the set min  X  { Z  X  X  dnf | Z  X  X  ( R ( T )) and t ( Z )= T which is the set of all minimal hitting sets of R ( T )hav-ing the tidset T . For example, consider the union tidset T = 34 (which is the union of t ( ABCD )and t ( ADE ). The minimal DNF hitting sets that hit only the tidset 34 are AB | AE, AB | DE, BD | AE, BD | DE . In fact minimal hitting sets can be obtained directly from minimal and -clauses.
Theorem 6. Let T be a union tidset, and let X be the closed DNF-expression with t ( X )= T .Then M ( X )= min  X  { Z =
For example, for T = 34, we see in Table 2 that { AB , BD are the minimal generators with tidset 3, and { AE, DE } have tidset 4. Taking the minimal or expressions obtained from these two sets, we get all the minimal generators having tidset T =34,namely AB | AE, AB | DE, BD | AE, BD | DE . Table 3 shows the closed and minimal DNF expressions, in addition to those shown in Tables 1 and 2. Some entries are repeated since the closed expressions in DNF have changed. Also the new union tidsets are marked in bold.
Let E cnf denote the set of all boolean expressions in CNF, i.e., each X  X  X  cnf is an and of or -clauses. By definition E  X   X  X  cnf and E  X   X  X  cnf . For convenience we denote a CNF-expression X as X = clause. We say that X is a min-CNF-expression if for each or -clause X i there does not exist another X j ( i = j )such that X i  X  X j . For a CNF expression X , we use the notation min cnf ( X ) to denote its min-CNF form. Let E cnf denote the set of all min-CNF-expressions. Given X, Y  X  X  cnf ,with X = than Y ,denoted X  X  Y , if there exists a 1-1 mapping f that maps each X i  X  X to f ( X i )= Y j  X  Y , such that X i  X  Analogously to DNF expressions, we can define the closed and minimal CNF expressions directly from the set of all corresponding tidsets.

Let X  X  treat each X i  X  C ( E  X  )asa composite item ,we can define two anti-monotone mappings that form an anti-monotone Galois connection as follows: Let X = a CNF expression, such that X i  X  C ( E  X  ), and let Y 2 . Define t ( X )= { t  X  X  | t satisfies X } ,and i ( Y )= V { X i | X i  X  C ( E  X  )  X  Y  X  t ( X ) } . This implies that C = i  X  t is a closure operator. For example, consider each closed or -clause in Table 1 as an  X  X tem X . Consider ( B | C )( A | D )( A | B | C | D )( A | D | E )( A | B | C | However it is logically redundant. What we want is the maximal min-CNF expression equivalent to C ( X ), which is ( A | D | E )( B | C ).

Theorem 7. Let T  X  2 T be an intersection tidset ob-tained as the finite intersection of tidsets of closed or Let X be the closed CNF-expression with t ( X )= T .Then M ( X )=min  X  { Z =
For example, let T =13. Wecanobtain13asthein-tersection of several minimal or -clauses X  tidsets, e.g., the minimal or -clauses C and { A | E, D | E } . However the min-imal among all of these are C and { A, D } , giving the two minimal CNF expressions: AC and CD . Table 4 shows the closed CNF expressions and their minimal generators in ad-dition to those already shown in Tables 1 and 2, or those that have changed.
Tidset Closed (maximal 234 ( A | B | C | D )( B | E ) ( A | B )( B | E ), ( A | 345 ( A | D | E )( B | E ) ( A | E )( B | E ), ( D | E )( B Table 4: Additional/changed Closed (CC) and Min-imal Generators (MC) for CNF
The BLOSOM framework supports the mining of arbi-trary boolean expressions, including closed/minimal clauses ( or / and ) and normal forms (CNF/DNF). BLOSOM as-sumes that the input dataset is D , and it then transforms it to work with the transposed dataset D T . Starting with the single items (literals) and their tidsets, BLOSOM per-forms a depth-first search (DFS) extending an existing ex-pression by one more  X  X tem X . BLOSOM employs a num-ber of effective pruning techniques for searching over the space of boolean expressions, yielding orders of magnitude in speedup. These include: dynamic sibling reordering, parent-child pruning, sibling merging, threshold pruning, and fast subsumption checking. Further BLOSOM utilizes a novel extraset data structure for fast frequency computations, and to identify the corresponding transaction set for a given ar-bitrary boolean expression. Due to space limitations, we are not able to give a detailed account of these pruning methods; a very brief account follows.
BLOSOM-MO mines all the minimal or -generators, and is broadly based on Charm [15]. However, Charm mines only the closed and -clauses, whereas BLOSOM-MO mines the minimal or -clauses. BLOSOM-MO takes as input the set of parameter values min sup , max sup , max item and a dataset D (we implicitly convert it to D T ). The max item constraint is used to limit the maximum size of any boolean expression, if desired. BLOSOM-MO conceptually utilizes a DFS tree to search over the or -clauses. Each or -clause is stored as a set of items (the or is implicitly assumed). Thus each node of the search tree is a pair of ( I  X  T ), where I is an item set denoting an or -clause and T isatidset. BLOSOM-MO systematically searches over this DFS tree, enumerating all the frequent minimal and closed or -clauses. The main difference in mining closed or -clauses is that in-stead of finding the minimal elements, we have to find the maximal elements corresponding to the given tidsets. Thus in
BLOSOM-CO the logic of subsumption checking, as well relationship pruning, has to be reversed.
To mine the minimal and closed and -clauses, we build upon BLOSOM-MO and BLOSOM-CO , respectively. Note that by DeMorgan X  X  law, to mine the minimal and -clauses, we can mine the minimal or -clauses over the complemented tidsets. For example in our example dataset in Fig. 1, with T = 12345, we have t ( AB )= t ( A )  X  t ( B ) = 134  X  23 = 3. We can obtain the same results if we mine for A | B in the comple-mented database. For example t ( A ) | t ( B )= t ( A )  X  25  X  145 = 1245 = 3.

Following the structural characterization of minimal DNF expressions in Sec. 4.1, BLOSOM-MD follows a two-phase approach. It first extracts all the minimal and -clauses and then find the minimal DNF expressions using those. First we use BLOSOM-MA to get all MA generators ( M MA )onthe original dataset. Second, we generate tidsets for each entry in
M MA and assign each MA class a new item label. These then form a new dataset. Third, we call BLOSOM-MO to get all MO generators on the new dataset. Next, we com-bine the results from BLOSOM-MA and BLOSOM-MO to form MD candidates by replacing each item label in M MD with the MA generators it represents. Finally, we delete the subsumed generators in M MD to produce min-DNF forms. Finally, for mining the minimal DNF and CNF expressions, we can adopt BLOSOM-MO by using the closed expression methods BLOSOM-CO and BLOSOM-CA instead of the minimal generator methods.
All experiments were done on a Ubuntu virtual machine (over WindowsXP &amp; VMware) with 448MB memory, and a 1.4GHz Pentium-M processor. We used both synthetic and real datasets to evaluate BLOSOM .
We study the effect of various optimizations proposed in on the performance of BLOSOM-MO ,asshowninFig.2.
 The x -axis shows the number of items |I| in the synthetic datasets. The number of transactions were generated as |T | =2 |I| . Given the dataset density parameter  X  =0 . 5, given as  X   X |T| . Each curve in the figure shows the running time after applying the optimizations specified in succes-sion. Thus the final curve for no-transaction-set includes all previous optimizations ( original stands for the unopti-mized version). We can see that the cumulative effect of the optimizations is substantial; BLOSOM-MO can process a dataset around 10 times ((38  X  76) / (12  X  24) = 10) larger than the base algorithm can in the same running time. Thus all the optimizations together deliver a speedup of over an order of magnitude compared to the base version. We compared BLOSOM-MA with CHARM-L [14], which can also mine the minimal generators for and -clauses (i.e., itemsets). We used the chess dataset, from the UCI machine learning repository, which has 3196 rows and 75 items. From Fig. 3 we can see that BLOSOM-MA canbeabouttentimes faster than CHARM-L, and the gap is increasing with decreasing support. This is mainly because CHARM-L first finds all closed expressions and then uses their differential lower shadows to compute the minimal and -clauses. In contrast, BLOSOM-MA di-rectly mines the minimal generators, and uses effective op-timizations to speed up the search.
An application of BLOSOM is in finding complex gene regulatory networks, which can be represented in a simpli-fied form, as boolean networks [2]. Consider the network involving 16 genes, taken from [2], shown in Fig. 4.
Here  X  and denote gene activation and deac-tivation , respv. For ex-ample, genes B , E , H , J ,and M are expressed if their parents are not expressed. On the other hand G , L ,and D ex-press if all of their par-ents express. For exam-ple, D depends on C , F , X 1 and X 2 .Notethat F expresses if A does, but not L . Finally A , C , I , K , N , X 1 and X 2 do not depend on anyone, and can thus be considered as input variables for the boolean net-work. We generated the truth table corresponding to the 7 input genes but BLOSOM was provided the values for all genes, without explicit instruction about which are in-puts and which are outputs. This yields a dataset with 128 rows and 16 items (genes). We then ran BLOSOM to discover the boolean expression corresponding to this gene network; we used min sup = 100%, since we want to find expressions that are true for the entire set of assign-ments. BLOSOM output 65 expressions in 0.36s, which hold true for the entire dataset. After simplification these can be reduced to the equivalent expression, as shown in Fig. 5. We verified that indeed this expression is true for struct the boolean gene network shown in Fig. 4. For ex-ample, the first component of the expression in the first row D | ( A BCEF G HJK L MX 1 X 2 ) can be converted into the implication D  X  ( A BCEF G HJK L MX 1 X 2 ), which means that D depends on the variables on the right hand side (RHS). If, at this point, we supply any partial knowledge about the input variables or of the maximum fan-out of the network, we could project the RHS only on those variables to obtain ( ACKX 1 X 2 ), which happens to be precisely the relationship given in Fig. 4. The second row tells us that L depends on the activation of C and inactivation of K , i.e., K , if we restrict ourselves to the input variables. Also C and K give the values for the remaining variables in the second row. Note that other dependencies in the boolean network are also included in the mined expression. For example, we find that B and A always have opposite values, and so do B and E ,and K and M . G and B always have the same values, and so on. Thus this example shows the power of BLOSOM in mining gene regulatory networks.
Mining frequent itemsets (i.e., pure conjunctions) has been extensively studied within the context of itemset mining [1]. The closure operator for itemsets ( and -clauses) was pro-posed in [6], and the notion of minimal generators for item-sets was introduced in [4]. Many algorithms for mining closed itemsets (see [7]), and a few to mine minimal genera-tors [4, 14] have also been proposed in the past. The task of mining closed and minimal monotone DNF expressions was proposed in [12]. It gives a direct definition of the closed and minimal DNF expressions (i.e., a closed expression is one that doesn X  X  have a superset with the same support and a minimal expression is one that doesn X  X  have a subset with the same support). The authors further give a level-wise Apriori-style algorithm. In contrast, the novel contribution of our work is the structural characterization of the differ-ent classes of boolean expressions via the use of closure op-erators and minimal generators, as well as the framework for mining arbitrary expressions. Within the association rule context, there has been previous work on mining nega-tive rules [11, 13, 3], as well as disjunctive rules [8]. Unlike these methods we are interested in characterizing such rules within the general framework of boolean expression mining. Also of relevance is the task of mining redescriptions. The CARTwheels algorithm [10] mines redescriptions only be-tween length-limited boolean expressions in disjunctive nor-mal form and CHARM-L [14] is restricted to redescriptions between conjunctions.
In this paper we present the first algorithm, BLOSOM, to simultaneously mine minimal generators of boolean ex-pressions and their closures. Our four-category division of the space of boolean expressions yields a compositional ap-proach to the mining of arbitrary expressions. The pruning operators employed here have resulted in orders of magni-tude speedup, producing highly efficient implementations.
There are still many interesting issues to consider. The first one involves the effective handling of negative literals without being overwhelmed by dataset density. The sec-ond issue is to push tautological considerations deeper into the mining algorithm by designing new pruning operators. Finally, given a general propositional reasoning framework, we are interested in mining the simplest boolean expressions necessary for inference in that framework.

