 This paper considers top-k retrieval using Conditional Preference Network (CP-Net). As a model for expressing user preferences on multiple mutually correlated attributes, CP-Net is of great interest for decision support systems. However, little work has addressed how to conduct efficient data retrieval using CP-Nets. This paper presents an approach to efficiently retrieve the most preferred data items based on a user X  X  CP-Net. The proposed approach consists of a top-k algorithm and an indexing scheme. We conducted exten-sive experiments to compare our approach against a baseline top-k method  X  sequential scan. The results show that our approach out-perform sequential scan in several circumstances.
 H.2.4 [ Database Management ]: Systems X  Query Processing Top-k , CP-Net, Preference, Database
Preferences are widely used in our daily lives, either for mak-ing decision or for selecting merchandise. Conditional Preference Network (CP-Net) is a widely used one, as it has achieved a good tradeoff between expressiveness and simplicity [1, 2]. Given a set of attributes, a CP-Net can not only express a user X  X  preference on each individual attribute, but also specify the correlations over dif-ferent attributes.

The integration of user preference in database systems has been investigated extensively in recent years. Previous research was mainly focused on how to express user preferences in database queries [3] and how to efficiently retrieve data based on user pref-erences [4]. The most well studied methods for data retrieval are known as top-k [5] and skyline [6]. However, the majority of the top-k and skyline approaches do not consider the correlations among attributes, and cannot be applied to CP-Net. The contextual pref-erence models [7] come closer to the CP-Net approach. However, their data retrieval algorithms still use quantitative methods, which cannot accurately capture the semantics of the qualitative prefer-ences expressed by CP-Net.

In this paper, we consider how to efficiently retrieve the k most preferred data objects based on a user X  X  CP-Net. Our approach to top-k retrieval consists of a progressive algorithm and an indexing scheme. The algorithm conducts an exploration in a similar fash-ion as the depth first search, which can quickly identify the objects within the top-k . Moreover, as the algorithm can progressively out-put the top objects as they are identified, its initial response time is minimized. To facilitate the algorithm, we design an indexing scheme called hierarchical bitmap, which can be used to efficiently determine if a set of attribute instantiations exist in a data set. We conducted extensive experiments on both synthetic and real data to evaluate its performance. We compared our approaches against the baseline sequential scan approach. Our results show that our top-k approach outperforms sequential scan significantly in many circumstances.

The rest of this paper is organized as follows. In Section 2, we review the CP-Net model and its primary properties. In Section 3, we present the proposed progressive algorithm for top-k retrieval. Section 4 introduces the indexing scheme. Section 5 reports a per-formance study. We conclude the paper in Section 6.
Conditional Preference Network (CP-Net) was first introduced by Boutilier et al. in [1]. It was designed to represent users X  prefer-ences on qualitative attributes, also known as categorical attributes. The model of CP-Net can be defined as follows.
 Definition 1 (CP-Net): Let V = { X 1 , ..., X n } be a set of at-tributes. A CP-Net over V is a directed graph G over X 1 whose nodes are annotated with conditional preference tables , de-noted by CP T ( X i ) for each X i  X  V . Each conditional preference table CP T ( X i ) associates a total order of X i  X  X  values with each instantiation of X i  X  X  parents. 2 We illustrate the semantics of CP-Net using the example in Fig. 1. Suppose Alice plans to visit Sydney. She faces a number of choices when booking a hotel. Alice X  X  preferences are given by the CP-Net in Fig. 1 (a). She has an unconditional preference on time. Indi-cated by the corresponding CPT, she prefers to spend a weekend rather than a weekday in Sydney. Alice X  X  preference on location, however, depends on when she visits Sydney. If it is a weekend, she would like to stay in the CBD. If it is a weekday, she prefers to stay in a suburb. Moreover, Alice X  X  preference on the type of hotel depends on the area where she is staying. If the hotel is in the CBD, she prefers a budget hotel. If it is in a suburb, she prefers a luxury hotel with quality service. As we can see, the user X  X  preference on some attributes depends on the values on some other attributes. CP-Net, in essence, offers the expressiveness to describe such con-ditional preferences.

With a CP-Net, we can compare any two options and determine which one is better. We call such comparison dominance testing . Definition 2 (Dominance): Let N be a CP-Net over a set of at-tributes V . Given two instances e 1 and e 2 , if for every attribute X i  X  V , (1) e 1 and e 2 assign the same values to X i  X  X  parents, and (2) based on the corresponding entry in CP T ( X i ) , e 1 equal or better value to X i than that assigned e 2 , then we say that e dominates e 2 . We denote it by N e 1 e 2 . Moreover, the domi-nance relationship is transitive, i.e. N e 1 e 2  X  N e 2 e implies N e 1 e 3 . 2
For example, based on Alice X  X  CP-net in Fig. 1 (a), we can de-duce that the instantiation {(time=weekend)  X  (location=CBD)  X  (type=luxury)} dominates {(time=weekend)  X  (location=suburb)  X  (type =luxury)}. By materializing the dominance relationships among all the possible instances, we obtain the detailed preference graph of Alice, which is shown in Fig. 1 (b).
The properties of CP-Net were extensively investigated in the literature [2, 8, 9]. We present some of the important properties in this section.
 Property 1 (Dominance Testing is Complex): Given a CP-Net N and two instances e 1 and e 2 , the dominance testing aims to deter-mine if one of the instances dominate the other. The testing must reach one of the following three conclusions  X  (1) N e 1 e (2) N e 2 e 1 or (3) N 2 e 1 e 2  X  N 2 e 2 e 1 (also known as indifference ).
 Conclusion: Dominance testing for CP-Net is intractable in gen-eral. 2 Dominance testing is a complex problem w.r.t. the size of the CP-Net. Boutilier et al. [2] has proven that the dominance testing for binary-valued, acyclic CP-Nets is NP-complete.
 Property 2 (Ordering Testing is Easy): Given a CP-Net N and two instances e 1 and e 2 , the ordering testing aims to reach one of the following conclusions  X  (1) N 2 e 1 e 2 or (2) N 2 e 2 e 1 (3) both.
 Conclusion: Ordering testing can be solved in linear time.
Ordering testing is a weaker version of dominance testing. Al-though it cannot determine if one instance dominates the other, it can at least tell that one instance is not worse than the other. Given a set of instances, if we sort them based on the ordering relationship, we guarantee that the instances with higher ranks are not worse than those with lower ranks. As shown subsequently, ordering-relationship is sufficient for top-k retrieval.
Conventional Top-k retrieval aims to identify the k most pre-ferred objects for a user. Following its spirit, we use the dominance relationship to define top-k retrieval with CP-Net.
 Definition 3 (Top-k for CP-Net): Given a CP-Net N and a set of instances E , the top-k instances of E on N is a set of k instances E 0 = { e 1 , ..., e k } X  E , such that no instance in E  X  E any instance in E 0 . 2
As the dominance testing for CP-Net is an intractable problem, it is usually impractical to conduct top-k retrieval by materializ-ing the dominance relationships. Fortunately, the ordering testing (Property 2) is sufficient for us to retrieve a valid top-k set. Lemma 1 : Given a CP-Net N and a set of instances E , we sort E based on the outcomes of the ordering testing, i.e., if N then e 2 is ranked before e 1 . Then, the first k instances of the sorted list is a top-k set of E on N .
 Proof : Let us hypothesize that E 0 is the first k instances of the sorted list and E 0 is not a top-k set of E . Then, there must be an instance e 0  X  E  X  E 0 that dominates an instance e i  X  E N e 0 e i . However, as e i is in front of e 0 based on the ordering testing, we can deduce that N 2 e 0 e i . There is an contradiction. Therefore, E 0 is a top-k set. 2
According to Lemma 1, a straight forward algorithm for con-ducting top-k retrieval is to scan through the existing objects in the database and output the k objects that are ranked at the top in the ordering testing. However, a scan of the entire data set is costly. In this paper, we introduce an algorithm that can retrieve the top k results without a complete scan of the data. It retrieves the top-k instances by exploring the data space through a depth-first search. The detail are given in Algorithm 1.

In a nutshell, the algorithm sorts the attributes based on the de-pendency order in the CP-Net. It then considers the attributes one after another. For each attribute X i , it retrieves the list of its instan-tiations v i m v i m  X  1 ... v i 1 from the CPT, and evaluates the instantiations one by one according to the preference order. Once Algorithm 1: Depth First Top-k Retrieval for CP-Net
Input : let N be a CP-net over attributes V , and E be a set of begin it finds an instantiation that can be satisfied by the data set, the al-gorithm extends this instantiation by traversing forward to the next attribute in the sorted attribute list. After all the instantiations of an attribute are evaluated, the algorithm traverses back to the previous attribute to continues its evaluation on that attribute. Whenever it finds a complete instantiation of all the attributes that can be satis-fied by the data set, the algorithm outputs the corresponding data instance as a member of the top-k results. This depth-first traversal continues until k instances are identified.
 Lemma 2 : Let N be a CP-Net over the attributes V . Let V subset of V , i.e., V 0  X  V , such that there is no a  X  V parents belong to V  X  V 0 . Let N 0 be a subgraph of N which contains all the attributes in V 0 but not a single attribute in V  X  V Then, (1) N 0 is a valid CP-Net on V 0 ; (2) Let e 1 and e 2 be two instantiations on V , and e 0 1 mappings on V 0 respectively. If e 0 1 6 = e 0 2 and N 0 N 2 e 1 e 2 . 2
Lemma 2 shows that if the ordering test has determined that an instance e 1 does not dominate another instance e 2 on a subset of attributes, then e 1 cannot dominate e 2 on all the attributes. With Lemma 2, the soundness of Algorithm 1 can be proven easily. Theorem 1 : Given a CP-net N over the attributes V and a set of instances E , the first k instances outputted by Algorithm 1 is a top-k set of E conforming to Definition 3. 2
In the algorithm, we always need to test if an instantiation of a set of attributes can be satisfied by the data. We call this step computation unit, it is easy to prove that the maximum possible computational cost of Algorithm 1 to retrieve a single result is in O ( D  X  C ) . D represents the number of attributes (dimensionality) and C represents the cardinality of each attribute.
To enable efficient satisfiability test, we utilize the mechanism of bitmap. In a nutshell, we construct a number of abstract levels upon the original bitmap to save unnecessary data access, and ob-tain a hierarchical bitmap. The structure of the hierarchical bitmap is illustrated in Figure 2.

The right hand of Figure 2 shows a conventional bitmap. Each row in the bitmap corresponds to an object in the database. Each column in the bitmap corresponds to a possible value of an at-tribute. For an object, if it is assigned with an attribute value, the corresponding bit in the bitmap is set to 1. Otherwise, the bit is set to 0. To perform satisfiability test using the conventional bitmap, we need to extract the columns corresponding to the instantiated at-tributes and perform a bitwise and . This procedure needs to access a significant proportion of the bitmap.

A hierarchical bitmap contains several abstract levels over the original bitmap. As illustrated on the left of Figure 2, an abstract level is actually a condensed bitmap, by merging the columns of each attribute into a smaller number of columns. To conduct the merge, we perform an bitwise OR on the columns being merged. (While Figure 2 shows only one level of abstraction, multiple ab-stract levels can be used in practice, where each level is an ab-straction of another.) To test the satisfiability of an instantiation I using the hierarchical bitmap, our system starts with a scan of the most abstract level. Only when there is a row R that satisfies I , it descends to the more concrete levels to evaluate the rows that cor-responds to R . This process continues until the system descends to the original bitmap and identify a row that satisfies I or finishes scanning the entire hierarchical bitmap.

For instance, to test the satisfiability of ( A = a 6 )  X  ( C = c we first transform this instantiation into the bit strings correspond-ing to the bitmaps. As illustrated in Figure 2, Q and Q bit strings corresponding the the original and the abstract bitmaps. Our algorithm starts with a scan of the abstract bitmap, comparing Q 0 against each row. Once a match is identified, it turns to scan the corresponding proportion of the original bitmap and compare the rows with Q . If this proportion contains a row that matches Q , we conclude that ( A = a 6 )  X  ( C = c 1 ) is satisfiable and stops the process. Otherwise, the algorithm moves back to the abstract bitmap and continues the scan. If the scan finishes without identi-fying any match, we conclude that ( A = a 6 )  X  ( C = c 1 satisfiable. As shown in Figure 2, we can finish the satisfiability test of ( A = a 6 )  X  ( C = c 1 ) by evaluating 6 rows, 3 in the abstract bitmap and 3 in the original bitmap.

Intuitively, satisfiability test using the hierarchical bitmap can be efficient, regardless of whether the tested instantiation is common or rare. If the instantiation is common, the scan is likely to stop at the early stage. If the instantiation is rare, most of its preceding rows in the original bitmap can be skipped through the evaluation on the abstract bitmap.

To retrieve the top-k results, Algorithm 1 needs to conduct a number of satisfiability tests. As the algorithm performs the tests in the depth-first order, the data instantiations being evaluated in two consecutive tests usually share a significant number of attribute val-ues. Therefore, we can let each satisfiability test reuse the bitmap access of the previous tests, to further improve the efficiency of top-k retrieval. In Algorithm 1, whenever an instantiation passes the satisfiability test, it will be extended with an additional attribute, and pushed back to the stack (i.e. ST ). At this moment X  we can mark the positions of the bitmap the previous test has reached, and store the marks together with the new instantiations in the stack. When testing the new instantiations, we can start scanning the bitmap from the marked positions.
To evaluate the effectiveness of the proposed top-k algorithm, we conducted an extensive set of experiments. This section reports the most representative results.
In the experiments, we evaluated three top-k retrieval approaches  X  sequential scan, our depth first algorithm using the conventional bitmap and our depth first algorithm using our hierarchical bitmap. We denote these approaches by Scan , Bitmap and H-Bitmap in the rest of this section. We used both synthetic data and real data in the experiments. Using synthetic data, we can easily change the characteristics of a data set and observe the performance of the top-k approaches in different circumstances.

For the experiments on both synthetic and real data, we gener-ated random CP-Nets as user preferences. Each generated CP-Net was a random partial order graph, in which the parents of each node varied from 0 to 3. The CPTs were also generated randomly, such that each entry in a CPT is a random order of attribute values.
All the experiments are carried out on an Intel Core2 PC with a 2.40GHz processor and 3.24 GB of main memory running the Win-dows XP operating system. All the algorithms are implemented in Java.
We assumed that both the data sets and the indexes reside on disk. We conducted three sets of experiments. In each set of ex-periments, we varied a single parameter of the synthetic data set, to see how it affects the performance of the considered top-k ap-proaches. We mainly measured the response time of each top-k retrieval, where k was set to 1, 10 and 100. For each experiment, we conducted it for 100 times using different CP-Nets and reported the average time. Before the execution of each query, we flushed the memory to ensure that all data are indeed retrieved from the disk.
Fig. 3 shows the performance of the three top-k approaches with the number of data instances varying from 500,000 to 2,000,000.
As sequential scan needs to go through the complete data set be-fore outputting the top-k , its response time increases linearly with the size of the data set. Its performance remains the same no mat-ter what k is. The response time of Bitmap increases with the data set size, but the speed of increase slows down gradually. On one hand, as the lengths of the bit arrays increase with the data set size, Bitmap needs to load more data from the disk. On the other hand, when the number of data instances grows, the density of the data increases, which in turn improves the success rate of satisfiability tests.

In contrast to sequential scan and Bitmap, The response time of H-Bitmap does not increase with the growth of data. H-Bitmap allows the system to avoid a significant amount of data access, such that the performance of satisfiability test is not remarkably affected by the data size. At the same time, when the density of the data increases, the success rate of satisfiability test increases too, which speeds up the depth-first algorithm.
 As we can see, the initial response time of both Bitmap and H-Bitmap is much shorter than that of sequential scan. H-Bitmap also clearly outperforms Bitmap in initial response time, because it incurs less access to the bitmap.
In the second set of experiments, we varied the number of at-tributes from 6 to 14. Fig. 4 gives the performance of the three top-k approaches.

When the dimensionality increases, the size of the data set in-creases too. Therefore, the response time of sequential scan grows linearly with the dimensionality. The increase of dimensionality has negative impact on the performance of our depth-first algo-rithm, for both Bitmap and H-Bitmap. On one hand, increasing the dimensionality will increase the sparsity of the data, which forces the algorithm to perform more satisfiability tests. On the other hand, the increase of dimensionality directly increases the depth of the search space for the depth first algorithm. As a result, the re-sponse time of both Bitmap and H-Bitmap grows much faster than sequential scan. Nevertheless, Bitmap and H-Bitmap still outper-form sequential scan significantly in initial response time, even for high dimensionality.
In the third set of experiments, we varied the cardinality of each attribute from 5 to 20. The effects are shown in Fig. 5.

The change of cardinality has little effect on sequential scan, as the size of the data set increases only slightly with the cardinal-ity (effects of encoding). Its effects on the depth-first algorithm is similar to that of dimensionality. That is to say, the increase of cardinality would decrease the density of the data space, and thus increase the cost of the depth first algorithm. However, the negative impact of cardinality on Bitmap and H-Bitmap is not as severe as that of dimensionality, because the sparsity of data grows slower with the cardinality than it grows with the dimensionality.
To test our algorithm on real world data, we used the US-Census-1990-raw data set obtained from the Census Bureau website. The original data set contains 2,458,285 items described by 68 cate-gorical attributes, from which we selected 12 attributes that can possibly be used to describe user preferences. The maximum car-dinality of the 12 attributes is 18. . Two sets of experiments were conducted  X  one with data residing on disk, the other with data in memory. The results are shown in Fig. 6. As we can see, the results on real data are consistent with the results on synthetic data. Both Bitmap and H-Bitmap achieve significant improvement on initial response time. This advantage dismisses gradually as k increases. This is specially true for the main memory scenario.
Based on the experimental results on synthetic and real data, we draw the following conclusions. First, the proposed depth first al-gorithm can remarkably improve the initial response time of top-k retrieval for CP-Net. Second, the hierarchy bitmap can achieve good performance in satisfiability test, so as to further improve the efficiency of top-k retrieval. Third, the improvement made by our approach is constrained by three factors, including the dimension-ality of the data set, the cardinality of the data set and the number of results to be returned (i.e. k ). Due to these constraints, sequential scan can be a superior choice over our depth-first algorithm in some application scenarios. These scenarios include: (1) the data is ex-tremely sparse; (2) the application needs to retrieve a large number of results ( k is very big). In this paper, we studied the top-k retrieval issue for Conditional Preference Network (CP-Net). We defined the problem of top-k re-trieval for CP-Net. We proposed a depth first algorithm to generate top-k results without scanning the database. To support the algo-rithm, we designed a indexing scheme  X  Hierarchical Bitmap. We conducted extensive experimental study on both synthetic and real world data to demonstrate the effectiveness of our approach.
This work is supported by the NSFC project entitled  X  X ystem of Systems Software Mechanisms and Methods based on Service Composition", the Chinese 973 Program Project No. 2012CB316205 and the JSNSF Project No. BK2010417. [1] C. Boutilier, R. I. Brafman, H. H. Hoos, and D. Poole, [2] C. Boutilier, R. I. Brafman, C. Domshlak, H. H. Hoos, and [3] W. Kie X ling,  X  X oundations of preferences in database [4] R. Fagin, A. Lotem, and M. Naor,  X  X ptimal aggregation [5] S. Chaudhuri and L. Gravano,  X  X valuating top-k selection [6] S. B X rzs X nyi, D. Kossmann, and K. Stocker,  X  X he skyline [7] R. Agrawal, R. Rantzau, and E. Terzi,  X  X ontext-sensitive [8] J. Goldsmith, J. Lang, M. Truszczynski, and N. Wilson,  X  X he [9] C. Domshlak, F. Rossi, K. B. Venable, and T. Walsh,
