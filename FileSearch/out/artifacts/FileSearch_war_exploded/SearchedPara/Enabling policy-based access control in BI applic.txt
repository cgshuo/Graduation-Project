 1. Introduction company X  X  data warehouse from unauthorized access is an important component of this mechanism, and information needs to be protected based on the authorization level of the users.

Consider, for example, the BI application of an insurance company which has multiple claim processing units, and it is desirable to ensure appropriate access controls, such as the following: insurance, etc.
 Within a business unit, agents can only look at the cases they are assigned at the certain stages. Within a business unit, managers may want to look at all pending cases.
 Within or across business units, executives can look at all resolved and pending cases.
In such an environment, the company may need to use multiple authorization policies for the same data warehouse, trol features of the underlying database systems. 1.1. Problem statement cations typically use materialized views for faster response times and hence improved performance. Although there exist performance, but not both. Effectively, materialized views cannot be utilized if users must selectively access the data warehouse.

Essentially, the problem of making materialized view management authorization-aware is to process the OnLine Analyt-through both direct table accesses as well as materialized views. To the best of our knowledge, there is no prior work addressing the issues of authorization and access control in materialized view management. 1.2. Contributions and organization
In this paper, we provide a middleware-enabled policy-based framework that addresses this concern. Our approach in-by the database community and is also well-supported in leading database products.

The premise of our approach is to seamlessly incorporate the LBAC security semantics within the materialized view man-agement mechanism of a database system. Toward this end, our proposed authorization middleware works by closely inter-acting with (yet not requiring changes to) the materialized view management mechanism of the database and uses a novel uses a data labeling scheme based on a novel encoding that facilitates efficient maintenance of the security policy.
The empirical evaluation results of our approach on the TPC-H workload show that our approach (i) provides much more improved performance than a naive approach of using dedicated or shared materialized views for different authorization tables, and (iii) can act as a modular add-on to an existing database system.
 of related research covering those problems, and we consider it outside the scope of this paper. grate the security policy with materialized view management. Section 7 provides the evaluation results for implementing the proposed approach using IBM DB2 and TPC-H workload. Section 8 provides a compendium of work related. Section 9 concludes the paper and provides directions for future work. 2. Solution overview
In this section, we provide an overview of our approach for enabling policy-based access control in BI applications. To in IBM DB2 are referred to as Materialized Query Tables (MQTs), and the recommendation of MQTs for a given workload is provided by a module called Materialized Query Table Advisor (MQTA) which is a component of DB2 Design Advisor. shall refer to the same concept. 2.1. System architecture is stored in the security tag structure . More complex tagging scenarios are discussed in later sections. field T1.ST could be ST1, ST2, or ST3 depending on the security policy. No security tag is required for T2 and T3. lined number and as follows:
Such an application could run on a Web and Application Server (WAS), such as IBM WebSphere. 2. When the application issues a query on behave of the user, the query alone with $UID_app are passed to the database access layer of the application (e.g. JDBC). Let us assume the query Q1 (shown below) is issued. 3. The query is intercepted by an Access Control Enablement (ACE) module (could be implemented in JDBC). The module looks up the $ST for the UID_app on the mapping maintained by the ACE module. Note that the mapping between $UID_app and $ST is maintained outside of the application and database design logic, thus a UID_app can be assigned to a different ST without modification of application logic or database table tags. 4. The query is rewritten in the way that a predicate T1.ST where  X  X  X T2 X  is the security tag indicating the access control category of the user submitting the query. 5. The query is then sent to database with $UID_db. A typical implementation of access control enabled application may have a few hundreds of application users identified by $UID_app, 5 X 10 access control categories identified by ST, and a few database IDs, such as user and DBA, identified by $UID_db. 6. The rewritten query is sent to database for processing. Database optimizer and MQT matching module do not need to be authorization-aware. The database does not need to be aware of the semantics of table column used for access control.
Note that the base tables are tagged with ST in the pre-processing step while the MQTs are tagged with ST in the MQT recommendation phase (see step 9). tional computation based on the query result and returns the application result to the user. 8. The database log (query workload tagged with ST) is extracted from the database by MQT Advisor. The workload is used as input for MQTA for pattern analysis and MQT recommendation. 9. MQTs recommended by MQTA are MQTs with ST tags since the query workload in the database log is tagged with ST. Note that MQTs with ST tags can be refreshed using existing MQT refresh schemes available since ST is a part of database scheme (e.g. a pseudo column associated with a table for ST). 2.2. Approaches to MQT design We consider the following approaches to MQT with security tags to enable access control for the BI applications:
Dedicated MQT for each security tag : MQTs for Q1 for ST1, ST2, and ST3, MQT_ST1, MQT_ST2, and MQT_ST3, can be defined as follows respectively:
These three MQTs are recommended and used specifically for the users assigned with access control category identified MQTs maintain overlapped data logically but they are created dedicatedly physically.
 accessed by the users with access control category ST1. Thus we can create an MQT that can be shared by the users of both access control category ST1 and ST2. An example MQT for Q1 that is shared by ST1, ST2, and ST3 can be defined as follows: while the design approach of dedicated MQT has a higher query performance since it pre-computes the result for each category.
 based approach to designing MQTs with security tags and thus enable access control for BI applications. The approach looks at the tradeoff between space and processing overhead of MQTs as well as the frequency of MQT hits in the MQT recommendation phase. For example, in Fig. 2 , we may select to build a shared MQT for ST1 and ST3 and a dedicated MQT for ST2 if such a combination is more cost efficient. The design details of the cost-based approach is provided in Section 5 .
 3. Authorization model quently occurring) write accesses in BI applications for future work. 3.1. LBAC read-only semantics specific for BI applications.
 We define the labeling structure as follows: indicated subject or object.
 Definition 2 ( Simple security property ). Subject s can read object o if k ( s ) P k ( o ). Enforcing this rule ensures that no information can flow downward in the structure.
 parable to label  X  X  X entral_North X .
 of geographical regions. 3.2. Applying LBAC
In the following, we describe the strategy for applying an LBAC policy to a database. 3.2.1. Policy configuration cation layer as follows: cation layer.
 tag will be applied to the relevant tuples by maintaining an additional column in the table. ging can be performed on any subset of the database tables with requirement for access control, and can be done even on database systems with no existing mechanism for access control on base tables. 3.2.2. Database connection In current database systems, the LBAC model will typically be applied in addition to the classical Discretionary Access Control (DAC) model. DAC provides for the baseline GRANT, REVOKE mechanism which is part of the SQL standard. Since
LBAC in our scheme is primarily intended to support application level users, whereas DAC works only for database users, we must provide some form of mapping between the LBAC and DAC users.

In most 3-tier business applications today, this mapping is straightforward. Essentially, it is a many-to-one mapping, therefore be readily adopted by commercial organizations without changes to existing infrastructure. 4. Security tagging
A key component of our approach that we describe here is a labeling scheme based on a novel tag encoding used for also maintain it. The proposed labeling scheme is a major advantage of our approach over LBAC mechanisms previously proposed for database systems, since no earlier approach has considered policy maintenance issues related to an LBAC policy. 4.1. Example policy dreds of regions, corresponding to the operations of a given company.

Fig. 3 describes the TPC-H schema showing the various tables and their relationships. From the TPC-H schema, we note limited using fine-grained access control, as motivated earlier in the paper.
 these authorization semantics to construct the LBAC policy in our example.

The example LBAC security policy we use for the data warehouse having the TPC-H schema is based on the labeling struc-control. The following rules are included in the example policy: Regional agents are allowed READ/WRITE access only to customer orders for their region. The General Manager for Central region can read customer orders for the Central-South and Central-North regions.
Executives are allowed to read all customer orders. 4.2. Tag encoding easy to maintain when security policy changes.
The tag encoding scheme is similar to the numbering scheme [5] used to index XML nodes for deriving the ancester X  first traversal. The tags associated with each node in Fig. 4 have been precomputed in this manner. range [ p L , p L + s L ), where p L is the preorder number of L and s ulation as required to enforce the semantics of access control hierarchy.

When the tree structure changes which corresponds to the security policy changes in reality, the preorder number and ing is as follows: 1. The size of each leaf node is n . 2. The size of a non-leaf node is the sum of the total size of its children plus 2 n . 3. The preorder number of the first child is obtained by increasing the preorder number of the parent by n . 4. The preorder number of the next sibling is the sum of the preorder number and the size of the previous node. more space can be reserved for these parts.

Note that the first number associated with each node is not the preorder number of the node any more. We call it tag number from now on. The tag number is still used to keep the nodes in order. The second number of each node still has of the parent but less than the sum of the tag number and the size of the parent.
 update operations will be discussed in Section 6.3 .
 Delete a leaf node . Remove the node. Nothing else need to be changed. For example, if the node tag numbers and sizes of all the other nodes remain.
 do not need to be changed. Note that there will be holes between consecutive nodes. For example, range of [101,201), while the next sibling CENTRAL _ NORTH ranges of parents and children still holds.
 node will be half of the available space. s =( t i t p )/2 and t = t node NEW _ ENGLAND is to be inserted as the only child of If a new node CENTRAL _ MIDDLE is to be inserted as the second child of as (351,50) and the size of the pervious sibling CENTRAL _ existing nodes do not need to be changed.

Insert a non-leaf node . Insert a new node between a parent X  X hild pair p and c new node depends on whether c i was the first child of p .If i =1, c c i , i.e., t =( t p + t 1 )/2. In the case c i was not the first child of p , assume the previous sibling of c new node will be at the half way between the tag of the last descendant d of c node can simply be the ending point of c i , i.e., s = t i and WEST _ COAST , the tag and size will be (501,200).
 Update a node . Only the name of the node is changed. Neither tag number, nor size is changed.
When the reserved space between two nodes is used up, an insertion of a tag between the nodes cannot be done without to the right. The way that causes less overhead of retagging data is chosen.

To minimize the overhead, the middle ware need to know the data distribution for each security label (tag). This infor-mation can be represented as the number of rows that has a particular tag number. It can be obtained by running an SQL with the tags is shown in Table 1 . 4.3. Tagging the users
The users accessing the data warehouse are tagged with LBAC security labels according to the labeling structure and  X  X  X orporate X  but can access those at the level of  X  X  X entral South X .
 cient retrieval later on.

We note that this mapping requires human involvement, and is a process that involves careful consideration. However, which is the preorder number used in the encoding defined in Fig. 5 . 4.4. Tagging the objects the tag is associated with the tuple(s) by maintaining an additional column in the table(s) to be protected.
The process of tagging the objects can be done in two different ways, depending on whether the table already exists or not: tag.
 tuples in the table will then be inserted with an associated security tag.
 as follows: ALTER TABLE [tablename] ADD SECLABEL INTEGER NOT NULL DEFAULT 1; Note that 1 is a special tag used in our example only for administrative purposes. This is needed when using the ALTER TABLE statement because SECLABEL is a mandatory field.
 the script correspond to the values defined in the columns of the same names in Table 2 ): UPDATE ORDERS O SET O.O _ SECLABEL = [encoded tag]
WHERE EXISTS UPDATE LINEITEM L SET L.L _ SECLABEL = [encoded tag]
WHERE EXISTS are now labeled with the encoded security tag representing the region of the customer. 5. Enabling access control in MQT design
We have so far described the authorization model and the security labeling scheme. In this section, we first review how awareness using our middleware-based approach. 5.1. Materialized view management
Most database systems used for data warehousing applications have modules responsible for materialized view manage-ment, providing support for recommending and maintaining materialized views. In the following, we will use a reference commercial database system IBM DB2 to describe its support for materialized views. Using our proposed authorization only as a reference system, and our approach is agnostic to a particular database system.
To recall, the materialized views in IBM DB2 are referred to as Materialized Query Tables (MQTs), and the recommenda-ponent of DB2 Design Advisor. MQTA takes a workload (read and write queries to the database system) and simulated insignificant queries, which are inexpensive or infrequent. It then performs multi-query optimization to derive common parts in the workload and generates candidate MQTs. The MQTA then: 1. Calculates benefits of these candidate MQTs (in terms of resource time reduction based on simulated catalog); 2. Calculates overhead (in terms of resource time) for refreshing MQTs by incorporating database updates; 3. Estimates the size of MQTs; ces size; and 5. Recommends the MQTs whose utility values are higher than a given threshold.
 rialized view management in current commercial database systems. It therefore makes sense for our purposes to leverage existing functionality for materialized view management and make it authorization-aware, as opposed to design a com-pletely new mechanism that will meet with resistance in adoption. Consequently, a noteworthy aspect of the proposed DB2 as a reference system for our proof of concept.

The goal of making materialized views authorization-aware is to allow the query for each user to be answered according rialized views and the trade-offs between them in this section.
 all the users is known in advance. Assume there are n security tags, each materialized view recommended by MQTA corre-materialized view for security tag ST2 is defined by adding a predicate of the form definition of the regular materialized view.
 labels incurs more space cost.
 extra cost needs to be spent to filter out the unauthorized tuples.

There are trade-offs between these two approach. We will compare them empirically later in Section 7 . How can we find rialized views to recommend a mixed set of authorization-aware materialized views. 5.2. Proposed cost-based approach
The cost-based approach considers the cost and benefit of each dedicated and shared materialized views as well as the vided by the submodule Authorization-Aware (AA) MQTA inside the middle ware.
 access control category. Algorithm 1 shows the details of AAMQTA which we explain as follows. tags as described in Section 5.2 . 2. As shown in Line 5, The new workload AW is then fed into the regular MQTA to recommend a set of candidate materi-alized views CM 1. The regular MQTA performs a cost-based analysis among the candidates as mentioned in Section 5.1 . The resulting set CM 1 will then be returned by the middle ware with or without post-processing depending on whether CM 1 contains both shared and dedicated materialized views. CM 1 may contain only shared materialized views.
Most of the commercial MQTAs, when generating the candidates, try to generalize the candidates by removing the local predicates and add the column originally in the predicates to the group by column. This is exactly what we do in the shared strategy. Therefore shared materialized views can be generated by MQTA. The candidates with local predicates (dedicated materialized views in our case) may or may not be kept as candidate in the cost-based analysis, therefore may or may not be recommended in CM 1. candidate set CM 2. mation for shared candidates are already in hand of AAMQTA from the output of MQTA. ing the net benefit by the size of the materialized view. 6. The candidates are ranked by the ROIs and the one with the highest ROI is recommended and removed from the list as long as it can fit in the available disk space as shown in the while loop started at Line 18. 7. The dependencies between materialized views are maintained. A dedicated materialized view is dependent on the cor-responding shared materialized view and vice versa. For each shared candidate c , there are n corresponding dedicated views are present in the database, query should be routed to the dedicated one since the query is optimized this way.
That means when a dedicated candidate c i is selected to the recommendation set, the benefit of the shared candidate c to the queries should be removed from the benefit of c . In other words, we want to maintain the additional benefit of each candidate materialized view. On the other hand, if a shared candidate c is selected to the recommendation set,
All the unselected dedicated candidates have no additional benefit.
Algorithm 1. Authorization-aware MQTA alized view for this security level is definitely the best choice.

This cost-based approach is guaranteed to consider both dedicated and shared candidates. The overall performance including the benefit and the maintenance cost, and the disk space constraints are incorporated in the cost model. More importantly, the underlying MQTA can be utilized by the middle ware without any changes. 5.3. Illustrative example
We will now present an example to illustrate the different approaches to support the authorization-ware materialized view. This example is base on the TPC-H database and query workload. We will start with a materialized view recommended by regular MQTA. Then the dedicated and shared materialized views are shown. At last, we will describe how the authori-zation-aware MQTA performs the preprocessing and post processing.

Using the TPC-H workload as input, the MQTA recommend a set of Materialized views to improve the performance. One example MQT is defined as follows.

CREATE SUMMARY TABLE MQT1 AS ( SELECT SUM (Q1.L _ EXTENDEDPRICE w FROM LINEITEM AS Q1 GROUP BY Q1.L _ QUANTITY, LINEITEM is tagged with security tags. The column is named as alized view MQT1 should be the same as Table 4 . With access control, users with security label have different views on MQT1 . Table 5 is the view of users in mended by the regular MQTA are useless.

A query issued by users with security label CENTRAL in the BI application is modified by the middle ware by adding one predicate L _ SECLABEL &gt;= 201 AND L _ SECLABEL &lt; 201 should be included in the predicate.

Since the query is modified by adding security predicate, the authorization-aware materialized views need to carry the of which is associated with one security category. The materialized view for security category by adding one predicate on L _ SECLABEL column.
 CREATE SUMMARY TABLE MQT _ DEDICATED AS ( SELECT SUM (Q1.L _ EXTENDEDPRICE w COUNT ( w )AS  X  X  C4  X  FROM LINEITEM AS Q1 WHERE Q1.L _ SECLABEL &gt; = 201 GROUP BY Q1.L _ QUANTITY, alized view for all the security categories is written as follows: CREATE SUMMARY TABLE MQT AS ( SELECT SUM (Q1.L _ EXTENDEDPRICE w FROM LINEITEM AS Q1 GROUP BY Q1.L _ SECLABEL,
The cost-based approach provides the functionality of an authorization-aware MQTA (AAMQTA) by calling traditional commercial MQTA. The AAMQTA takes as the input a traditional query workload along with the issuing frequency of each query by each security category. 2 An example workload is as follows:  X  # set frequency EAST _ COAST = 2  X  # set frequency CENTRAL = 10 SELECT SUM (L _ EXTENDEDPRICE w L _ DISCOUNT) AS REVENUE FROM DGAO.LINEITEM WHERE L _ SHIPDATE &gt; = DATE (  X  1994-01-01  X  )
The AAMQTA then modifies the queries in the workload and adds the frequency to each resulting query. The resulting workload is as follows:  X  # set frequency 2 SELECT SUM (L _ EXTENDEDPRICE w L _ DISCOUNT) AS REVENUE FROM LINEITEM WHERE L _ SHIPDATE &gt; = DATE (  X  1994-01-01  X  )  X  # set frequency 10 SELECT SUM (L _ EXTENDEDPRICE w L _ DISCOUNT) AS REVENUE FROM LINEITEM WHERE L _ SHIPDATE &gt; = DATE (  X  1994-01-01  X  )
The new workload is input into the underlying regular MQTA to get the recommendation of dedicated and shared mate-ular MQTA. 6. Policy maintenance implementing the policy change is different in each case. We will now discuss how these policy changes are handled in our scheme. 6.1. Relabeling the users the application level, and no changes need to be made inside the database layer.
 For example, assume the mapping shown in Table 2 changes as follows: A new user Kevin replaces John in the role of Executive.
 User Kelly in WEST_COAST region replaces James in the role of agent in EAST_COAST, and vice versa.
This policy change can be implemented by updating the mapping in the application. If this mapping is realized in a data table in an RDBMS maintained by the application, then a SQL script can be used to update the mapping (which is the approach we have used in our prototype). As an example, if this table is called MAPPING, then the following SQL script can be used: UPDATE MAPPING M SET USER _ ID =  X  Kevin  X  WHERE USER _ ID =  X  John  X  UPDATE MAPPING M SET USER _ ID =  X  Kelly  X  WHERE USER _ ID =  X  James  X  UPDATE MAPPING M SET USER _ ID =  X  James  X  WHERE USER _ ID =  X  Kelly  X  6.2. Relabeling the objects inside the database, relabeling them requires changes to the database layer.
 a merger, etc.): Customers in region  X  X  X ENTRAL_SOUTH X  ( encoded tag = 203) are temporarily assigned to region  X  X  X EN-TRAL_NORTH X  ( encoded tag = 103).

In our case, this policy change can be implemented by updating the values for the O_SECLABEL field in the ORDERS table and L_SECLABEL field in the LINEITEM table. The following SQL script can be used to implement the change: UPDATE ORDERS O SET O _ SECLABEL = 301 WHERE O _ SECLABEL = 401; UPDATE LINEITEM L SET L _ SECLABEL = 301
WHERE L _ SECLABEL = 401; 6.3. Changes to the labeling structure from time to time. Here are some of the reasons why this may happen: The company adds a new region of operation.
 The company removes an existing region of operation.
 The company divides its operations for an existing region into two regions.
 The company merges its operations for two existing regions into one region.
 existing nodes unchanged in basic update operation. This way we minimize the overhead of retagging data when security minimized. For example, if WEST _ COAST and CENTRAL are merged to a new node delete of WEST _ COAST and an update of CENTRAL to WEST . All the data with the tag of 601 ( minimized. The examples will reference the numbers in Table 1 .

Merge ( n 1 , n 2 , n ). Merge two sibling nodes n 1 and n of n 1 and n 2 become the child nodes of n .  X  Case 2: n 1 and n 2 are next to each other. Assume the tag of n
Split ( n , n 1 , n 2 , C 1 , C 2 ). Split a node n into two nodes n will become the child set of n 1 and C 2 will become the child set of n know how many rows with the tag of n will have the tag of n between n 1 and n 2 .  X  Case 1: C 1 and C 2 are ordered (the biggest tag in C 1
So far we have defined the five basic update operations and two extended update operations. For both of them, we have UPDATE MQT1 SET ST = 101 WHERE ST = 201; INSERT INTO TEMP _ TABLE SELECT SUM(C0) AS  X  X  C0  X  , C1, C2, C3, SUM (C4) AS  X  X  C4  X  , ST FROM MQT1 GROUP BY ST, C0, C1, C2; DELETE FROM MQT1 WHERE ST = 201; INSERT INTO MQT1
SELECT w FROM TEMP _ TABLE; 7. Evaluation
To evaluate the proposed approach for authorization-aware materialized view management using our authorization mid-dleware, we conducted several experiments using the data warehouse set up for our example policy. All experiments were conducted on a regular build for DB2 UDB Version 9 (aka Viper) and the MQTA is the IBM DB2 Design Advisor. We evaluated all three strategies for recommending authorization-aware materialized views discussed in Section 5 , namely dedicated, shared, and cost-based, and did their performance comparison. 7.1. Database setup
Based on our discussion on the data labeling scheme in Section 4.4 , the data warehouse was created as follows. We created a TPC-H databases of size 2 GB each stored on backend Windows processor and 2 GB of memory. We tagged the rows of the ORDERS and LINEITEM tables in the database with appropriate tags from the example policy using the process described in Section 4.4 , based on the region information populated in
The example policy has six different regions (ST x j 1 6 x LBAC labeling structure, as previously discussed.
 is incurred only once for each policy. 7.2. Workload
We chose a workload based on a subset of the standard set of 22 TPC-H queries. The subset comprises of 12 queries, and tion from DB2 Design Advisor, and were then compiled on the database to see which queries actually get routed to mate-rialized views. The 12 queries were the ones that were routed to materialized views, and hence were considered for inclusion in the workload for evaluation of our approach. 7.3. Experiments 7.3.1. Parameters of interest
The experiments were designed to capture several parameters contributing to the overall performance of an OLAP query workload in data warehouses, namely:
Query frequency : The materialized view recommendation in data warehouses depends on the query frequency. The query categories in the data warehouse as follows. We defined three kinds of access patterns:  X  Uniform : each query may be issued by a user belonging to any of the six access control categories with a uniform  X  Sparse : each query is issued only by users belonging only to three certain access control categories with a random
These access patterns represent a variety of real world data warehouse access scenarios, and we try to evaluate our approach against these scenarios.
 capture this parameter, we performed the experiments for a series of fixed disk space sizes, and obtain the performance achieved by using the different strategies.
 among these categories (as determined by the dominance relationship amongst them), and is therefore used to capture this parameter.
 where our different strategies stand in comparison. 7.3.2. Execution and results
For each proposed strategy, we first obtained the materialized view recommendation from the DB2 Design Advisor, and sured the query performance in all cases.
 maximum number of materialized views recommended by MQTA, and the number of queries that could benefit from these issue a query with non-zero frequency.
 following:
The cost-based strategy is better in terms of achieving the maximum performance for the same disk space size among all strategies, since these materialized views are recommended using ROI calculations.
 egy. This is because dedicated MQTs take less space, and more can be added for a given disk space size benefitting more queries than in the shared approach.
This is because shared MQTs take more space, but with a larger disk space size many shared MQTs can be used, resulting in a better overall performance since one shared MQT can be used by many queries.
 over another, however, varies across access patterns.
 numbers indicate how bad will be the performance of existing data warehouses if the authorization-awareness principles discussed in this paper are applied without adopting the proposed authorization middleware. use of additional space and adding more materialized views because they are still not useful. The shared approach makes gradual use of additional space in the experiment because shared MQTs require more space and require a large disk space increment for many of them to be packed as needed to benefit a large number of queries in the workload. The dedicated approach could only make good use of additional disk space until the point (8192 MB) where enough shared MQTs could of available space, and achieves its maximum performance with much less space consumption than the other strategies. sizes. Once again, it is clear that the cost-based approach works the best for each kind of access pattern. 8. Related work posed for incremental view maintenance [10,11] , view recommendation [12,6,13] , and dynamic view management [14 X 17] , none of this work addresses the issue of access control for views.
 Authorization mechanisms in database can be classified as classical and emerging. Among the classical ones are the cess control matrix [20] approaches. Many of these mechanisms have found acceptance in commercial mainstream dat-abases. All relational databases implement the GRANT REVOKE as the basic authorization model. LBAC is actually an instantiation of the Mandatory Access Control (MAC) model. LBAC features can be found in both Oracle [21] and IBM DB2 [22] . A system for enforcing multi-purpose MAC in IBM DB2 is also described in [23] . The classical models target only direct-table accesses, and do not provide support for authorization-aware materialized view management. our proposed work. They have formulated the problem of data warehouse security as problem of management of appropriate on information as opposed to physical permissions on actual tables. The authors have, however, not addressed any of the challenges we have outlined in this paper.

Several emerging authorization mechanisms for database recently became popular. Many researchers have designed mechanisms for logical view management or query modification as the basis for authorization in database systems rialized view, the protection offered by schemes such as Hippocratic Database or VPD will be conveniently bypassed. The our approach with the Hippocratic Database.
 terms of outcome, but is different from them in terms of purpose and approach. The purpose in approaches such as those on user privileges. The design issues when dealing with authorization semantics are not covered by earlier approaches. 9. Conclusions
In this paper, we provide a middleware-enabled policy-based framework that addresses this concern. Our approach in-level of the user. It works by closely interacting with (yet not requiring changes to) the materialized view management mechanism of the database and uses a novel cost-based strategy to recommend  X  X  X uthorization-aware X  materialized views. ing scheme and algorithm proposed in this paper.

References
