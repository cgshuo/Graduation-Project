 } @is.s.u-tokyo.ac.jp Tree-to-string translation rules are generic and ap-plicable to numerous linguistically syntax-based Statistical Machine Translation (SMT) systems, such as string-to-tree translation (Galley et al., 2004; Galley et al., 2006; Chiang et al., 2009), tree-to-string translation (Liu et al., 2006; Huang et al., 2006), and forest-to-string translation (Mi et al., 2008; Mi and Huang, 2008). The algorithms proposed by Galley et al. (2004; 2006) are fre-quently used for extracting minimal and composed rules from aligned 1-best tree-string pairs. Deal-ing with the parse error problem and rule sparse-ness problem, Mi and Huang (2008) replaced the 1-best parse tree with a packed forest which com-pactly encodes exponentially many parses for tree-to-string rule extraction.

However, current tree-to-string rules only make use of Probabilistic Context-Free Grammar tree fragments, in which part-of-speech (POS) or Table 1: Bidirectional translation probabilities of rules, denoted in the brackets, change when voice is attached to  X  killed  X . phrasal tags are used as the tree node labels. As will be testified by our experiments, we argue that the simple POS/phrasal tags are too coarse to re-flect the accurate translation probabilities of the translation rules.

For example, as shown in Table 1, sup-pose a simple tree fragment  X  X BN( killed ) X  ap-pears 6 times with  X  koroshita  X , which is a Japanese translation of an active form of  X  killed  X , and 4 times with  X  korosareta  X , which is a Japanese translation of a passive form of  X  killed  X . Then, without larger tree fragments, we will more frequently translate  X  X BN( killed ) X  into  X  ko-roshita  X  (with a probability of 0.6). But,  X  X BN( killed ) X  is indeed separable into two fine-grained tree fragments of  X  X BN( killed :active) X  and  X  X BN( killed :passive) X  1 . Consequently,  X  X BN( killed :active) X  appears 5 times with  X  ko-roshita  X  and 1 time with  X  korosareta  X ; and  X  X BN( killed :passive) X  appears 1 time with  X  ko-roshita  X  and 3 times with  X  korosareta  X . Now, by attaching the voice information to  X  killed  X , we are gaining a rule set that is more appropriate to reflect the real translation situations.

This motivates our proposal of using deep syn-tactic information to obtain a fine-grained trans-lation rule set. We name the information such as the voice of a verb in a tree fragment as deep syn-tactic information. We use a head-driven phrase structure grammar (HPSG) parser to obtain the deep syntactic information of an English sentence, which includes a fine-grained description of the syntactic property and a semantic representation of the sentence. We extract fine-grained trans-lation rules from aligned HPSG tree/forest-string pairs. We localize an HPSG tree/forest to make it segmentable at any nodes to fit the extraction algorithms described in (Galley et al., 2006; Mi and Huang, 2008). We also propose a linear-time algorithm for extracting composed rules guided by predicate-argument structures. The effective-ness of the rules are testified in our tree-to-string and string-to-tree systems, taking bidirectional Japanese-English translations as our test cases.
This paper is organized as follows. In Section 2, we briefly review the tree-to-string and string-to-tree translation frameworks, tree-to-string rule ex-traction algorithms, and rich syntactic information previously used for SMT. The HPSG grammar and our proposal of fine-grained rule extraction algo-rithms are described in Section 3. Section 4 gives the experiments for applying fine-grained transla-tion rules to large-scale Japanese-English transla-tion tasks. Finally, we conclude in Section 5. 2.1 Tree-to-string and string-to-tree Tree-to-string translation (Liu et al., 2006; Huang et al., 2006) first uses a parser to parse a source sentence into a 1-best tree and then searches for the best derivation that segments and converts the tree into a target string. In contrast, string-to-tree translation (Galley et al., 2004; Galley et al., 2006; Chiang et al., 2009) is like bilingual parsing. That is, giving a (bilingual) translation grammar and a source sentence, we are trying to construct a parse forest in the target language. Consequently, the translation results can be collected from the leaves of the parse forest.

Figure 1 illustrates the training and decoding processes of bidirectional Japanese-English trans-lations. The English sentence is  X  John killed Mary  X  and the Japanese sentence is  X  jyon ha mari wo koroshita  X , in which the function words  X  ha  X  and  X  wo  X  are not aligned with any English word. 2.2 Tree/forest-based rule extraction Galley et al. (2004) proposed the GHKM algo-rithm for extracting (minimal) tree-to-string trans-lation rules from a tuple of  X  F, E t , A  X  , where F = Figure 1: Illustration of the training and decod-ing processes for tree-to-string and string-to-tree translations. f 1 is a sentence of a foreign language other than English, E t is a 1-best parse tree of an English sen-tence E = e I 1 , and A = { ( j, i ) } is an alignment between the words in F and E .

The basic idea of GHKM algorithm is to de-compose E t into a series of tree fragments, each of which will form a rule with its corresponding translation in the foreign language. A is used as a constraint to guide the segmentation procedure, so that the root node of every tree fragment of E t ex-actly corresponds to a contiguous span on the for-eign language side. Based on this consideration, a frontier set ( fs ) is defined to be a set of nodes n in E t that satisfies the following constraint: fs = { n | span ( n )  X  comp span ( n ) =  X  } . (1) Here, span ( n ) is defined by the indices of the first and last word in F that are reachable from a node n , and comp span ( n ) is defined to be the comple-ment set of span ( n ) , i.e., the union of the spans of all nodes n  X  in E t that are neither descendants nor ancestors of n . span ( n ) and comp span ( n ) of each n can be computed by first a bottom-up exploration and then a top-down traversal of E t .
By restricting each fragment so that it only takes  X  Mary  X  as a modifier ( t 3 , t 4 ) or an argument ( t 1 are attached to the forest as well. the nodes in fs as the root and leaf nodes, a well-formed fragmentation of E t is generated. With fs computed, rules are extracted through a depth-first traversal of E t : we cut E t at all nodes in fs to form tree fragments and extract a rule for each fragment. These extracted rules are called minimal rules (Galley et al., 2004). For example, the 1-best tree (with gray nodes) in Figure 2 is cut into 7 pieces, each of which corresponds to the tree frag-ment in a rule (bottom-left corner of the figure).
In order to include richer context information and account for multiple interpretations of un-aligned words of foreign language, minimal rules which share adjacent tree fragments are connected together to form composed rules (Galley et al., 2006). For each aligned tree-string pair, Gal-ley et al. (2006) constructed a derivation-forest, in which composed rules were generated, un-aligned words of foreign language were consis-tently attached, and the translation probabilities of rules were estimated by using Expectation-Maximization (EM) (Dempster et al., 1977) train-ing. For example, by combining the minimal rules of 1, 4, and 5, we obtain a composed rule, as shown in the bottom-right corner of Figure 2.
Considering the parse error problem in the 1-best or k -best parse trees, Mi and Huang (2008) extracted tree-to-string translation rules from aligned packed forest-string pairs. A for-est compactly encodes exponentially many trees rather than the 1-best tree used by Galley et al. (2004; 2006). Two problems were managed to be tackled during extracting rules from an aligned forest-string pair: where to cut and how to cut. Equation 1 was used again to compute a frontier node set to determine where to cut the packed forest into a number of tree-fragments. The dif-ference with tree-based rule extraction is that the nodes in a packed forest (which is a hypergraph) now are hypernodes, which can take a set of in-coming hyperedges. Then, by limiting each frag-ment to be a tree and whose root/leaf hypernodes all appearing in the frontier set, the packed forest can be segmented properly into a set of tree frag-ments, each of which can be used to generate a tree-to-string translation rule. 2.3 Rich syntactic information for SMT Before describing our approaches of applying deep syntactic information yielded by an HPSG parser for fine-grained rule extraction, we would like to briefly review what kinds of deep syntactic information have been employed for SMT.
 Two kinds of supertags, from Lexicalized Tree-Adjoining Grammar and Combinatory Categorial Grammar (CCG), have been used as lexical syn-tactic descriptions (Hassan et al., 2007) for phrase-based SMT (Koehn et al., 2007). By introduc-ing supertags into the target language side, i.e., the target language model and the target side of the phrase table, significant improvement was achieved for Arabic-to-English translation. Birch et al. (2007) also reported a significant improve-ment for Dutch-English translation by applying CCG supertags at a word level to a factorized SMT system (Koehn et al., 2007).

In this paper, we also make use of supertags on the English language side. In an HPSG parse tree, these lexical syntactic descriptions are included in the LEXENTRY feature (re-fer to Table 2) of a lexical node (Matsuzaki et al., 2007). For example, the LEXEN-TRY feature of  X  t 1 :killed  X  takes the value of [NP.nom&lt;V.bse&gt;NP.acc]_lxm-past _verb_rule in Figure 2. In which, [NP.nom&lt;V.bse&gt;NP.acc] is an HPSG style supertag, which tells us that the base form of  X  killed  X  needs a nominative NP in the left hand side and an accessorial NP in the right hand side. The major differences are that, we use a larger feature set (Table 2) including the supertags for fine-grained tree-to-string rule extraction, rather than string-to-string translation (Hassan et al., 2007; Birch et al., 2007).
 The Logon project 2 (Oepen et al., 2007) for Norwegian-English translation integrates in-depth grammatical analysis of Norwegian (using lexi-cal functional grammar, similar to (Riezler and Maxwell, 2006)) with semantic representations in the minimal recursion semantics framework, and fully grammar-based generation for English using HPSG. A hybrid (of rule-based and data-driven) architecture with a semantic transfer backbone is taken as the vantage point of this project. In contrast, the fine-grained tree-to-string translation rule extraction approaches in this paper are to-tally data-driven, and easily applicable to numer-ous language pairs by taking English as the source or target language. We now introduce the deep syntactic informa-tion generated by an HPSG parser and then de-scribe our approaches for fine-grained tree-to-string rule extraction. Especially, we localize an HPSG tree/forest to fit the extraction algorithms described in (Galley et al., 2006; Mi and Huang, 2008). Also, we propose a linear-time com-posed rule extraction algorithm by making use of predicate-argument structures. 3.1 Deep syntactic information by HPSG Head-driven phrase structure grammar (HPSG) is a lexicalist grammar framework. In HPSG, lin-guistic entities such as words and phrases are rep-resented by a data structure called a sign . A sign gives a factored representation of the syntactic fea-tures of a word/phrase, as well as a representation of their semantic content. Phrases and words rep-resented by signs are composed into larger phrases by applications of schemata . The semantic rep-resentation of the new phrase is calculated at the same time. As such, an HPSG parse tree/forest can be considered as a tree/forest of signs (c.f. the HPSG forest in Figure 2).

An HPSG parse tree/forest has two attractive properties as a representation of an English sen-tence in syntax-based SMT. First, we can carefully control the condition of the application of a trans-lation rule by exploiting the fine-grained syntactic Table 2: Syntactic/semantic features extracted from HPSG signs that are included in the output of Enju. Features in phrasal nodes (top) and lexi-cal nodes (bottom) are listed separately. description in the English parse tree/forest, as well as those in the translation rules. Second, we can identify sub-trees in a parse tree/forest that cor-respond to basic units of the semantics, namely sub-trees covering a predicate and its arguments, by using the semantic representation given in the signs. We expect that extraction of translation rules based on such semantically-connected sub-trees will give a compact and effective set of trans-lation rules.

A sign in the HPSG tree/forest is represented by a typed feature structure (TFS) (Carpenter, 1992). A TFS is a directed-acyclic graph (DAG) wherein the edges are labeled with feature names and the nodes (feature values) are typed. In the original HPSG formalism, the types are defined in a hierar-chy and the DAG can have arbitrary shape (e.g., it can be of any depth). We however use a simplified form of TFS, for simplicity of the algorithms. In the simplified form, a TFS is converted to a (flat) set of pairs of feature names and their values. Ta-ble 2 lists the features used in this paper, which are a subset of those in the original output from an HPSG parser, Enju 3 . The HPSG forest shown in Figure 2 is in this simplified format. An impor-tant detail is that we allow a feature value to be a pointer to another (simplified) TFS. Such pointer-valued features are necessary for denoting the se-mantics, as explained shortly.

In the Enju English HPSG grammar (Miyao et Figure 3: Predicate argument structures for the sentences of  X  John killed Mary  X  and  X  She ignored the fact that I wanted to dispute  X . al., 2003) used in this paper, the semantic content of a sentence/phrase is represented by a predicate-argument structure (PAS). Figure 3 shows the PAS of the example sentence in Figure 2,  X  John killed Mary  X , and a more complex PAS for another sen-tence,  X  She ignored the fact that I wanted to dis-pute  X , which is adopted from (Miyao et al., 2003). In an HPSG tree/forest, each leaf node generally introduces a predicate, which is represented by the pair of LEXENTRY (lexical entry) feature and PRED (predicate type) feature. The arguments of a predicate are designated by the pointers from the ARG  X  x  X  features in a leaf node to non-terminal nodes. 3.2 Localize HPSG forest Our fine-grained translation rule extraction algo-rithm is sketched in Algorithm 1. Considering that a parse tree is a trivial packed forest, we only use the term forest to expand our discussion, hereafter. Recall that there are pointer-valued features in the TFSs (Table 2) which prevent arbitrary segmenta-tion of a packed forest. Hence, we have to localize an HPSG forest.

For example, there are ARG pointers from t 1 to c 1 and c 5 in the HPSG forest of Figure 2. How-ever, the three nodes are not included in one (min-imal) translation rule. This problem is caused by not considering the predicate argument depen-dency among t 1 , c 1 , and c 5 while performing the GHKM algorithm. We can combine several min-imal rules (Galley et al., 2006) together to ad-dress this dependency. Yet we have a faster way to tackle PASs, as will be described in the next subsection.

Even if we omit ARG , there are still two kinds of pointer-valued features in TFSs, HEAD and SEM HEAD . Localizing these pointer-valued fea-tures is straightforward, since during parsing, the HEAD and SEM HEAD of a node are automati-cally transferred to its mother node. That is, the syntactic and semantic head of a node only take Algorithm 1 Fine-grained rule extraction the identifier of the daughter node as the values. For example, HEAD and SEM HEAD of node c 0 take the identical value to be c 3 in Figure 2.
To extract tree-to-string rules from the tree structures of an HPSG forest, our solution is to pre-process an HPSG forest in the following way:  X  for a phrasal hypernode, replace its HEAD  X  for a lexical node, ARG  X  x  X  and PRED fea-A pure syntactic-based HPSG forest without any pointer-valued features can be yielded through this pre-processing for the consequent execution of the extraction algorithms (Galley et al., 2006; Mi and Huang, 2008). 3.3 Predicate-argument structures In order to extract translation rules from PASs, we want to localize a predicate word and its ar-guments into one tree fragment. For example, in Figure 2, we can use a tree fragment which takes c 0 as its root node and c 1 , t 1 , and c 5 on its yield (= leaf nodes of a tree fragment) to cover  X  killed  X  and its subject and direct object arguments. We define this kind of tree fragment to be a minimum cov-ering tree . For example, the minimum covering tree of { t 1 , c 1 , c 5 } is shown in the bottom-right corner of Figure 2. The definition supplies us a linear-time algorithm to directly find the tree frag-ment that covers a PAS during both rule extracting and rule matching when decoding an HPSG tree. Algorithm 2 PASR extraction See (Wu, 2010) for more examples of minimum covering trees.

Taking a minimum covering tree as the tree fragment, we can easily build a tree-to-string translation rule that reflects the semantic depen-dency of a PAS. The algorithm of PAS-based rule (PASR) extraction is sketched in Algorithm 2. Suppose we are given a tuple of  X  F, E t , A  X  . E t is pre-processed by replacing HEAD and SEM HEAD to be L , R , or S , and computing the span and comp span of each node.

We extract PAS-based rules through one-time traversal of the leaf nodes in E t (line 2). For each leaf node n , we extract a minimum covering tree T c if n contains at least one argument. That is, at least one ARG  X  x  X  takes the value of some node identifier, where x ranges 1 over 4 (line 3). Then, we require the root and yield nodes of T c being in the frontier set of E t (line 5). Based on T c , we can easily build a tree-to-string translation rule by fur-ther completing the right-hand-side string by sort-ing the spans of T c  X  X  leaf nodes, lexicalizing the terminal node X  X  span(s), and assigning a variable to each non-terminal node X  X  span. Maximum like-lihood estimation is used to calculate the transla-tion probabilities of each rule.

An example of PAS-based rule is shown in the bottom-right corner of Figure 2. In the rule, the subject and direct-object of  X  killed  X  are general-ized into two variables, x 0 and x 1 . 4.1 Translation models We use a tree-to-string model and a string-to-tree model for bidirectional Japanese-English transla-tions. Both models use a phrase translation table (PTT), an HPSG tree-based rule set (TRS), and a PAS-based rule set (PRS). Since the three rule sets are independently extracted and estimated, we use Minimum Error Rate Training (MERT) (Och, 2003) to tune the weights of the features from the three rule sets on the development set.

Given a 1-best (localized) HPSG tree E t , the tree-to-string decoder searches for the optimal derivation d  X  that transforms E t into a Japanese string among the set of all possible derivations D : d  X  = arg max Here, the first item is the language model (LM) probability where  X  ( d ) is the target string of derivation d ; the second item is the translation length penalty; and the third item is the transla-tion score, which is decomposed into a product of feature values of rules: s ( d | E t ) = This equation reflects that the translation rules in one d come from three sets. Inspired by (Liu et al., 2009b), it is appealing to combine these rule sets together in one decoder because PTT provides excellent rule coverages while TRS and PRS offer linguistically motivated phrase selections and non-local reorderings. Each f ( r ) is in turn a product of five features: f ( r ) = p ( s | t )  X  3  X  p ( t | s )  X  4  X  l ( s | t ) Here, s/t represent the source/target part of a rule in PTT, TRS, or PRS; p (  X | X  ) and l (  X | X  ) are transla-tion probabilities and lexical weights of rules from PTT, TRS, and PRS. The derivation length penalty is controlled by  X  7 .

In our string-to-tree model, for efficient decod-ing with integrated n -gram LM, we follow (Zhang et al., 2006) and inversely binarize all translation rules into Chomsky Normal Forms that contain at most two variables and can be incrementally scored by LM. In order to make use of the bina-rized rules in the CKY decoding, we add two kinds of glues rules: Here X m ranges over the nonterminals appearing in a binarized rule set. These glue rules can be seen as an extension from X to { X m } of the two glue rules described in (Chiang, 2007).

The string-to-tree decoder searches for the op-timal derivation d  X  that parses a Japanese string F into a packed forest of the set of all possible derivations D : d  X  = arg max This formula differs from Equation 2 by replacing E t with F in s ( d number of glue rules used in d . Further definitions of s ( d | F ) and f ( r ) are identical with those used in Equation 2. 4.2 Decoding algorithms In our translation models, we have made use of three kinds of translation rule sets which are trained separately. We perform derivation-level combination as described in (Liu et al., 2009b) for mixing different types of translation rules within one derivation.

For tree-to-string translation, we use a bottom-up beam search algorithm (Liu et al., 2006) for decoding an HPSG tree E t . We keep at most 10 best derivations with distinct  X  ( d ) s at each node.
Recall the definition of minimum covering tree, which supports a faster way to retrieve available rules from PRS without generating all the sub-trees. That is, when node n fortunately to be the root of some minimum covering tree(s), we use the tree(s) to seek available PAS-based rules in PRS. We keep a hash-table with the key to be the node identifier of n and the value to be a priority queue of available PAS-based rules. The hash-table is easy to be filled by one-time traversal of the termi-nal nodes in E t . At each terminal node, we seek its minimum covering tree, retrieve PRS, and up-date the hash-table. For example, suppose we are decoding an HPSG tree (with gray nodes) shown in Figure 2. At t 1 , we can extract its minimum covering tree with the root node to be c 0 , then take this tree fragment as the key to retrieve PRS, and consequently put c 0 and the available rules in the hash-table. When decoding at c 0 , we can directly access the hash-table looking for available PAS-based rules.

In contrast, we use a CKY-style algorithm with beam-pruning and cube-pruning (Chiang, 2007) to decode Japanese sentences. For each Japanese sentence F , the output of the chart-parsing algo-rithm is expressed as a hypergraph representing a set of derivations. Given such a hypergraph, we use the Algorithm 3 described in (Huang and Chi-ang, 2005) to extract its k -best ( k = 500 in our experiments) derivations. Since different deriva-tions may lead to the same target language string, we further adopt Algorithm 3 X  X  modification, i.e., keep a hash-table to maintain the unique target sentences (Huang et al., 2006), to efficiently gen-erate the unique k -best translations. 4.3 Setups The JST Japanese-English paper abstract corpus 4 , which consists of one million parallel sentences, was used for training and testing. This corpus was constructed from a Japanese-English paper abstract corpus by using the method of Utiyama and Isahara (2007). Table 3 shows the statistics of this corpus. Making use of Enju 2.3.1, we suc-cessfully parsed 987,401 English sentences in the training set, with a parse rate of 99.3%. We mod-ified this parser to output a packed forest for each English sentence.

We executed GIZA++ (Och and Ney, 2003) and grow-diag-final-and balancing strategy (Koehn et al., 2007) on the training set to obtain a phrase-aligned parallel corpus, from which bidirectional phrase translation tables were estimated. SRI Lan-guage Modeling Toolkit (Stolcke, 2002) was em-ployed to train 5-gram English and Japanese LMs on the training set. We evaluated the translation quality using the case-insensitive BLEU-4 metric (Papineni et al., 2002). The MERT toolkit we used is Z-mert 5 (Zaidan, 2009).

The baseline system for comparison is Joshua (Li et al., 2009), a freely available decoder for hi-erarchical phrase-based SMT (Chiang, 2005). We respectively extracted 4.5M and 5.3M translation rules from the training set for the 4K English and Japanese sentences in the development and test sets. We used the default configuration of Joshua, expect setting the maximum number of items/rules and the k of k -best outputs to be the identical Table 4: Statistics of several kinds of tree-to-string rules. Here, the number is in million level and the time is in hour. 200 for English-to-Japanese translation and 500 for Japanese-to-English translation.

We used four dual core Xeon machines (4  X  3.0GHz  X  2CPU, 4  X  64GB memory) to run all the experiments. 4.4 Results Table 4 illustrates the statistics of several transla-tion rule sets, which are classified by:  X  using TFSs or simple POS/phrasal tags (an- X  composed rules (PRS) extracted from the  X  composed rules ( C  X  forest-based rules ( F ), where the packed
Table 5 reports the BLEU-4 scores achieved by decoding the test set making use of Joshua and our systems (t2s = tree-to-string and s2t = string-to-tree) under numerous rule sets. We analyze this table in terms of several aspects to prove the effec-tiveness of deep syntactic information for SMT.
Let X  X  first look at the performance of TFSs. We take C S 3 and F S as approximations of CFG-based translation rules. Comparing the BLEU-4 scores of PTT+ C S 3 and PTT+ C 3 , we gained 0.56 (t2s) and 0.57 (s2t) BLEU-4 points which are signifi-cant improvements ( p &lt; 0 . 05 ). Furthermore, we gained 0.50 (t2s) and 0.62 (s2t) BLEU-4 points from PTT+ F S to PTT+ F , which are also signif-icant improvements ( p &lt; 0 . 05 ). The rich fea-tures included in TFSs contribute to these im-provements. Table 5: BLEU-4 scores (%) achieved by Joshua and our systems under numerous rule configura-tions. The decoding time (seconds per sentence) of tree-to-string translation is listed as well.
Also, BLEU-4 scores were inspiringly in-creased 3.72 (t2s) and 2.12 (s2t) points by append-ing PRS to PTT, comparing PTT with PTT+PRS. Furthermore, in Table 5, the decoding time (sec-onds per sentence) of tree-to-string translation by using PTT+PRS is more than 86 times faster than using the other tree-to-string rule sets. This sug-gests that the direct generation of minimum cover-ing trees for rule matching is extremely faster than generating all subtrees of a tree node. Note that PTT performed extremely bad compared with all other systems or tree-based rule sets. The major reason is that we did not perform any reordering or distorting during decoding with PTT.
 However, in both t2s and s2t systems, the BLEU-4 score benefits of PRS were covered by the composed rules: both PTT+ C S 3 and PTT+ C 3 performed significant better ( p &lt; 0 . 01 ) than PTT+PRS, and there are no significant differences when appending PRS to PTT+ C 3 . The reason is obvious: PRS is only a small subset of the com-posed rules, and the probabilities of rules in PRS were estimated by maximum likelihood, which is fast but biased compared with EM based estima-tion (Galley et al., 2006).

Finally, by using PTT+ F , our systems achieved the best BLEU-4 scores of 24.75% (t2s) and 22.67% (s2t), both are significantly better ( p &lt; 0 . 01 ) than that achieved by Joshua. We have proposed approaches of using deep syn-tactic information for extracting fine-grained tree-to-string translation rules from aligned HPSG forest-string pairs. The main contributions are the applications of GHKM-related algorithms (Galley et al., 2006; Mi and Huang, 2008) to HPSG forests and a linear-time algorithm for extracting com-posed rules from predicate-argument structures. We applied our fine-grained translation rules to a tree-to-string system and an Hiero-style string-to-tree system. Extensive experiments on large-scale bidirectional Japanese-English translations testi-fied the significant improvements on BLEU score.
We argue the fine-grained translation rules are generic and applicable to many syntax-based SMT frameworks such as the forest-to-string model (Mi et al., 2008). Furthermore, it will be interesting to extract fine-grained tree-to-tree translation rules by integrating deep syntactic information in the source and/or target language side(s). These tree-to-tree rules are applicable for forest-to-tree trans-lation models (Liu et al., 2009a).
 This work was partially supported by Grant-in-Aid for Specially Promoted Research (MEXT, Japan) and Japanese/Chinese Machine Translation Project in Special Coordination Funds for Pro-moting Science and Technology (MEXT, Japan), and Microsoft Research Asia Machine Translation Theme. The first author thanks Naoaki Okazaki and Yusuke Miyao for their help and the anony-mous reviewers for improving the earlier version.
