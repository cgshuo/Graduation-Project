 It is well known that the size of the Internet is increasing everyday. This can be measured in terms of the number of web pages added, the number of people connected, single phenomenon  X  traffic on the Internet is getting heavier and heavier. Two of the major problems that the web users are suffering from are the network congestion and server overloading. One of the solutions to alleviate this problem is to store some frequently referenced web objects in proxy servers so the need to retrieve the same object from its host web site is reduced [3]. The Internet traffic is expected to reduce and the response to user request is expected to improve. Proxy severs help lower the demand on bandwidth and improve request turn around time by storing up the frequently referenced web objects in their local caches. However, the cache still has a physical capacity limit and objects in the cache need to be stored in the cache. A single proxy can serve [17, 14]. An efficiency lower bound (i.e. the proxy system is ought to be at least as efficient as using direct cont act with the remote servers) should also be enforced. With the increasing demand for information from the Internet, multiple proxy servers in one site are common. As suggested in [20, 21], a group of caches cooperating with each other in terms of serving each others X  requests and making storage decisions result in a powerful paradigm to improve cache effectiveness. Cooperative proxies provide an effective way to use such information. These cooperative proxies usually share the knowledge about their cached data and allow fast document fetching through request forwarding. Cooperating caches have three separate functions: discovery, dissemination, and delivery of cache objects [8]. Discovery refers to how a proxy locates cached objects. Dissemination is the process of selecting and storing objects in the caches. Delivery defines how objects make their ways from the web server or a remote proxy cache to the requesting proxy [9, 25]. In this paper, we use an anycast-based architecture and develop and anycast-based cooperative web proxy caching algorithm. In our scheme, we mainly pay attention to the following issues: 1. Load balancing: Since requests tend to target at a small part of the entire collection 2. Self-configuration of cache groups: In order for the infrastructure of web caches 3. Response time: As an important performance for the user, response time is network, which provides a base to apply the anycast. To apply the anycast routing, the simplest method could be to have all web servers and cache servers joined into a single anycast group. The nearest cache or origin server with the page will be the first one to hear the request and respond. However, one fatal flaw of this method is that it does not scale. In this paper, we design a scalable infrastructure to make the anycast apply possible and easy. Another challenge in building the anycast-based proxy caching system is that, generally speaking, we do not know beforehand which pages would be interesting to users, or where the interested parties may be located, or when they may fetch the pages. Following the basic principles in the Internet architecture design, we propose to build a cooperative caching system. For the clients, the documents requested trends to be located in the nearest proxy in the anycast group. Sometime the placement may be change, but the system can adaptive these changes quickly. In our scheme, the object placement and replacement problems [18] are formulated as an optimization problem and the solution is obtained by using our replace algorithm based on the anycast mechanism. The rest of the paper is organized as follows. Section 2 provides a brief review of existing cooperative proxy systems and the concept of anycast. Section 3 presents our based design, the related formulation and ACPA algorithm. Section 4 evaluates the performance of our scheme and algorithm. Finally, section 5 concludes the paper and discusses the future directions. As we know, proxy severs help to lower the demand on bandwidth and improve request turnaround time by storing up the frequently referenced web objects in their local caches [11]. There are a lot of researcher s agree that the browser and local proxy caching improve performance [10, 16], but there is considerable debate about the fundamental structure and mechanisms for cooperative proxies [23]. Existing cooperative proxy systems can be organized in hierarchical and distributed manners. The hierarchical approach is based on the Internet Caching Protocol (ICP) [6] with a fixed hierarchy. A page not in the local cache of a proxy server is first requested from neighboring proxies on the save hierarchy level. Root proxy in the hierarchy will be queried if request objects are not resolved locally and they continue to climb the hierarchy until the request objects are found. This often leads to a bottleneck situation at the main root server. Most operational proxy cache hierarchies use a three-level caches predominately use software descended from the Harvest project[2], one popular variant being the freely available Squid proxy cache. In the United States, the National Laboratory for Applied Network Research operates a global cache hierarchy composed of eight parent caches that service tens of proxies each. Organization of caches in these systems is static and usually configured manually. The distributed approach is usually based on a hashing algorithm like the Cache Array Routing Protocol (CARP)[26], which divides the URLs space among an array of loosely coupled caches and lets each cache store only the documents whose URLs are hashed to it. Each requested page is mapped to exactly one proxy in the proxy array in a hashing system and will either be resolved by the local cache or requested from the origin server. Hashing-based allocations can be widely regarded as the id eal way to find cached web pages, due to the fact that their location is predefined. Their major drawbacks are inflexibility and poor adaptability. The third approach organizes proxies into multicast groups. The Adaptive Web Caching (AWC) design of Zhang et al. [15] uses IP multicast to automatically configure cache groups. Proxies are self-organizing and form a tight mesh of overlapping multicast group and adapt as necessary to changing conditions. Queries are sent to a multicast address, so clients need not be manually reconfigured every time a member joins or leaves the group. Proxies are partitioned into groups and objects are returned from the origin Web Server through a path of overlapping groups. Consequently, AWC delivery may require multiple remote network transfers, just as in a cache hierarchy. This paper does not explicitly model a multicast group organization, although the concept of using multicast groups to dynamically maintain the proxy cooperation group could be applied to either a hierarchy or a mesh organization [4, 24]. service whereby receivers that share the same characteristics are assigned the same anycast address [5, 19]. A sender interest ed in contacting a receiver with those characteristics sends its packet to the anycast address and the routers conspire to deliver the packet to the receiver nearest the sender , where nearest is defined according to the routing system measure of distance. Anycast was first introduced in the RFC 1546 [19] auto-configuration. Now it has been defined as a standard service under IPv6 [22]. Using anycast communication services may considerably simplify some applications. For example, it is much easier for a client to find a best server when there are a multiple available services for one kind of service in the network. In the Figure 1, P1 , P2 and P3 network delivers it to the nearest receiver P2 , if sender2 and sender3 send packet to the anycast address, the network delivers it to receiver P1 . But the relations between senders and receivers are not fixed, which will be dynamic according to the network environments. It provides us an adaptive in frastructure to put objects into the nearest proxy and get the high efficiency and load balancing. We model the network as a graph G=(V,E) , where V is the set of nodes (routers) in the networks, each associated with a cache, and E is the set of networks links. The anycast maintained by content server. Each web object is served by exactly one server. Usually, the client and the server of a request are not located at the same site and there are a lot more clients than servers. For each object O , a nonnegative cost C(u ,v, O) is associated with each link (u, v) . It represents the cost of sending a request for object O and the associated response over link (u, v) . If a request travels through multiple network links before obtaining the target object, the access cost of the request is simply the sum of the general sense. It can be interpreted as different performance measures such as network latency, bandwidth requirement, and processing cost at the cache, or a combination of these measures. It is known that most web objects are relatively static, i.e. the access frequency is much higher than the update frequency. We shall assume the objects stored in the caches are up-to-date [7]. After the request reaches object proxy, the target object is sent along the same path back to the client. Routing paths form all nodes to a given server are represented by a tree topology. For simplicity, symmetric routing is assumed in our analytical model. However, since this assumption may not be valid in some situation, we have also modified the proposed coordinated caching scheme to handle routing asymmetry and studied its performance by simulation experiments. To reduce the cost of future accesses to object O , a copy of O can dynamically placed in investigated include: 1) Which nodes should O be placed (object placement problem). 2) Which objects should be removed from a cache if there if not enough free space 3.1 Placement Problem The object placement problem is trivial if cache size are infinite, in which case, objects can be stored in every cache to minimize total access cost. However, due to limited cache space, one or more objects may need to be removed from the cache when a new object is placement problem for anycast-based proxy cacheing is further complicated by cacheing dependencies, i.e., a placement decision at one node in the network affects the performance gain of cacheing an object nodes. The optimal locations to cache an object scheme. We start by computing the cost saving and the cost loss of cacheing an object at individual nodes. We introduce two cost functions: the link and processing cost functions. The link cost function is denoted by requested. The processing cost function is denoted by ) ( ' v c p . The total cost function is then defined as the sum of these two costs: Where The cost ) , ( ' v u c is the cost from u to v X  , which belongs to the cost between two nodes in the cooperative proxies (the anycast group), and Thus, we obtain (6) from (1),(2),(3),(4) and (5). requested from the source node v next time, the total cost is: 
Where problem is solved according to the following policies: proxy u . 3.2 Replacement Problem anycast group. In this way, cost of refunded is minimized in the next time. In Fig.1, we can see that the requested document move from the proxy which have the document to the nearest proxy. As the cache is getting full, we need to decide what to be replaced in the proxy, cache if it is full, which belongs to the object replacement problem bound. From our experiments, if we do not deal with replicates, the cooperative proxies will be low efficient, for the replicates will fill in the cooperative proxies. 
We adopt the cost saving table to replace it. In each cooperative proxy, a cost saving table is used to record the frequently re quested object X  X  average cost. For each proxy, it is a nearest proxy to some document requested. For a document O , its average cost in the node ' v can be defined as: Now there are two different cost between the nearest proxy u and v X  if we migrate the object O from v X  to u . Here we define them as: Cost saving for object O in node u , costsaving(size(O)) : Cost loss for object O in node v X  : We estimate ) ( t p i , i  X  anycastgroup , by the delay time of the probe messages that a proxy sends to others. 
Table 1 shows steps of the anycast-based cooperative proxy algorithm (ACPA): selects the nearest proxy in the anycast gr oup according to cost for each document. In the ACPA, by the  X  X earest X  characteristics, client can get the documents with minimum cost. In Table 1, the first part presents a function for initializing the network topology and the anycast group. From this we can see that each proxy has two major tasks, one is update the objects, and other is to communicate with other anycast member or the original server. The second part shows those actions of proxy in anycast group. The third and fourth parts provide the replacement and the placement functions. This section provides a quantitative description of the potential improvement when ACPA is used. And the simulation results show that our scheme can reduce hop counts, decrease the average delay time. 4.1 Simulation Environment In Figure 2, we can get the network topology used in the experiments. The network topology is randomly generated using the Georgia Tech ITM topology generator [12], which generates topologies that resemble typical networks. Following is the topology used for our experiment. Here to simple the experiment, we just simulate a metropolitan area network (MAN) with ten routers. From the Figure 2, we can get that the network consists of ten nodes same anycast address and are in the same local area. 4.2 Simulation Results In our simulations, assignment in each routers follows a Zipf-like distribution, that is, a parametric distribution where the probability of selecting the i th item is proportional to response time of ACPA and CARP when Zipf parameter x=0.2 . The average response time of ACPA is 1.073s/req, and CARP is 1.115s/req. From the figure, we can get that the time of CARP in high value is longer than that of ACPA. At the same time, we can see that ACPA can quickly come down from the high value. figure, we can get that ACPA performs well than CARP in the hop counts. These results also show that CARP represents a average hop counts for using a hash function based upon the  X  X rray membership list X  and URL to prov ide the exact cache location of an object. But ACPA is an adaptive algorithm where the client gets the object from the nearest proxy. In table 2 and 3, we count t-test result of twenty experiments with average delay time and hop counts. From the t-test, we can also get that ACPA performs better than CARP. In this paper, we propose a new scheme which employs anycast-based cooperative proxies. It puts response time, hop counts and load balancing as primary concerns. In our formulation, we integrate the anycast conception with the cooperative proxies group. Each object can get from the nearest anycast member. In our paper, we solve the placement and replacement problems as an optimization problem and the solution is obtained by using our ACPA algorithm. From the analytical and simulation results, we can get that anycast-based proxy cooperation could reduce the average response time and the hop counts efficiently. In our simulation, we just provide the experiments on response time and hop counts. In the future research, we will consider to design some experiments for the adaption, load balancing and stability. 
