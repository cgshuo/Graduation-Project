 REGULAR PAPER Yannis Tzitzikas Abstract A faceted taxonomy is a set of taxonomies each describing the applica-tion domain from a different (preferably orthogonal) point of view. CTCA is an algebra that allows specifying the set of meaningful compound terms (meaningful conjunctions of terms) over a faceted taxonomy in a flexible and efficient man-ner. However, taxonomy updates may turn a CTCA expression e not well-formed and may turn the compound terms specified by e to no longer reflect the domain knowledge originally expressed in e . This paper shows how we can revise e after a taxonomy update and reach an expression e that is both well-formed and whose semantics (compound terms defined) is as close as possible to the semantics of the original expression e before the update. Various cases are analyzed and the revis-ing algorithms are given. The proposed technique can enhance the robustness and usability of systems that are based on CTCA and allows optimizing several other tasks where CTCA can be used (including mining and compressing).
 Keywords Faceted taxonomies  X  Updates  X  Knowledge revision 1 Introduction Suppose that we want to build a catalog of traditional recipes from all over the world and for this purpose we decide to define facets like Ingredients , LocationO-fOrigin and CookingStyle as shown in Fig. 1 . Notice that several combinations of terms are invalid , even in this very small domain. For example, the compound that contains truffle. For the same reason the compound term { Roquefort (from Ingredients ), Greece (from Location ) } is invalid as well as the compound term {
Fe t a (from Ingredients ), France (from Location ) } . Moreover, the compound term {
Wo k (from CookingStyle ), Europe (from Location ) } is invalid because wok is of compound terms to the set of valid (meaningful) compound terms and invalid (meaningless) compound terms is shown in Table 7 found at Appendix A. specifying the set of meaningful compound terms over a faceted taxonomy in a flexible and efficient manner. By using CTCA the designer provides only a small set of valid or invalid compound terms and from these sets other valid and invalid compound terms are inferred. Having partitioned the set of compound terms to of indexing objects according to the faceted taxonomy, and the task of browsing a collection of objects that are indexed according to a faceted taxonomy (for more see [ 27]).
 and let T = T 1  X  ...  X  T k . Each expression e of CTCA specifies a set S F e of valid (i.e. meaningful) compound terms (conjunctions of terms) over T .Soan the powerset of T . For example, the partition shown in Table 7, can be specified using the following very short CTCA expression: with the following P and N parameters: specifically by the expression Ingredients  X  P LocationOfOrigin . For reasons of space, single terms have been omitted. This expression partitions the set of com-pound terms over the first two facets of Fig. 1.
 may turn the expression e obsolete (i.e. not well-formed), or it may make the de-rived compound terminology S F e to no longer reflect the desire of the designer, i.e. it may no longer reflect the domain knowledge that was expressed in e .Forex-ample, if a term t  X  T is deleted, and t appears in a compound term in a parameter formed. In addition, the deletion of t may make several compound terms (that do update automatically e to an expression e that is (a) well-formed (w.r.t. F ), and sion after taxonomy update. Figure 2 describes graphically the interrelationships between F , F , e , e , S F e and S F e .
 pound term specification, i.e. it can enhance the robustness and usability of sys-tems that are based on CTCA, like FASTAXON [ 11]. In addition, as a CTCA expression can be also used for exchanging compactly the compound terms that are extensionally valid according to a materialized faceted taxonomy (using the mining algorithms presented in [ 8]), this automation could be exploited in order to avoid reapplying these (computationally expensive) mining algorithms after an update of the faceted taxonomy. Moreover, as showed in [ 28], CTCA can be used for compressing a Symbolic Data Table [ 5]. In this context, this automation could also be exploited in order to avoid recompressing a Symbolic Data Table after a small change of its contents. However, a detailed elaboration of these issues goes beyond the scope of this work.
 the Compound Term Composition Algebra (CTCA), and Sect. 3 describes the tax-onomy update operations that we consider. Subsequently, Sect. 4 defines formally solution to this problem for each type of update operations. Section 6 discusses ther research. 2 The compound term composition algebra Faceted classification was suggested quite long ago by Ranganathan in the 1920s [24 ]. The adoption of faceted taxonomies is beneficial for Libraries [ 21], Soft-ware Repositories [ 3, 4], Web Catalogs or Web Sites [ 22], and other application domains, like biology. 1 Current interest in faceted taxonomies is also indicated eXchangeable Faceted Metadata Language), a markup language for applying the faceted classification paradigm on the Web. Other work on faceted classification includes [ 9, 20, 29] and the more recent [ 23, 25].
 of four basic algebraic operators (plus-product, minus-product, plus-self-product, and minus-self-product) which can be used for specifying the set of compound terms over a given faceted taxonomy that are valid (i.e. meaningful )intheap-plication domain. From a  X  X ogical X  point of view, we could say that CTCA is an algebra for specifying the  X  X atisfiable X  conjunctions of terms. The initial moti-vation for CTCA was to provide a well-founded method that is both flexible and economical (in terms of required input) and computationally efficient. One system based on CTCA has already been built [ 11], while other applications of CTCA are described in [ 8, 28]. The semantics of CTCA differ from that of Description Log-ics (DL)[ 6] mainly because each operation of CTCA makes either a positive or a negative closed world assumption at its range, as it is shown in detail in [ 10]. Specifically, for a DL-based representation of an expression e ,wehavetoconvert either all plus-product operations to minus-products, or all minus-product opera-and secondly, in many cases the resulting DL representation of e has much more sentences (concept axioms or concept assertions) than the parameters of the ex-pression e (for more see Sect. 4 of [ 10]).
 onomies and faceted taxonomies that are used in this paper.
 omy, defines a class of equivalent terms (e.g. we can write t  X  t iff t  X  t and t  X  t ). However, and without loss of generality, we can hereafter consider that that  X  denotes the subsumption relation over the classes of equivalence that are induced by the initial subsumption relation. So, we can safely assume that  X  has the form of a directed acyclic graph (or a tree). Note that under this perspective,  X  is also antisymmetric, so it is actually a partial order (and not just a preorder). 2.1 CTCA: syntax and semantics Let F ={ ( T 1 ,  X  1 ),...,( T k ,  X  k ) } be a faceted taxonomy and let T = T 1  X  ...  X  T Syntactically, an expression e over F is defined according to the following gram-mar ( i = 1 ,..., k ): The initial operands, thus the building blocks of the algebra, are the basic com-pound terminologies , which are the facet terminologies with the only difference The basic compound terminology of a tree-structured taxonomy ( T i ,  X  i ) is de-fined as lows: The motivation for this difference is that every individual term of a taxonomy is by default assumed that it is valid (meaningful), i.e. there are real-world objects (at least one) to which this term applies. It follows, that in the taxonomy C of { c 4 } . This is captured by the above formula as { c 2 , c 3 } X  Br ( { c 4 } ) . a parameter that is denoted by P (resp. N ) which is a set of compound terms over T .Ina P parameter the designer puts valid compound terms, while in a N parameter the designer puts invalid compound terms. The exact definition of each operation of CTCA (also including two auxiliary operations, called product and self-product ) is summarized in Table 3.
 and every parameter set P or N of e is always subset of the corresponding set of genuine compound terms . Intuitively, a genuine compound term combines nonempty compound terms from more than one compound terminologies. Specif-(or N ( e 1 ,..., e k ) ) is denoted by G e 1 ,..., e k and it is defined as For example, the compound term { Truffle , Greece } is a genuine compound term in the context of an operation e 1 = Ingredients N LocationOfOrigin , but not genuine in the context of the operation e 1  X  P CookingStyle because it does not contain any term from CookingStyle .
 ation, is denoted by G T i and is defined as: G T i = In that sense, minus-products are antitonic [ 14]. 2 However, as we have shown in [10 ], well-formed expressions have a monotonic behavior with respect to number of facets, meaning that the valid compound terms of a subexpression cannot be invalidated by an expression that contains it. pression e and a compound term s , and checks whether s  X  S e . This algorithm has union of all P parameters and N denotes the union of all N parameters appearing in e . The pair ( S e , ) is called the compound taxonomy of e .
 and C . Some examples of compound terminologies that are defined by expressions of CTCA are given in Table 4 (the empty compound term  X  is not shown, and { c 2 , c 3 } ).
 we will denote by nm ( T i ) . Some extra notations that we shall use in the sequel follow: 3 Taxonomy updates Here, we discuss the taxonomy update operations that we consider. Each update subsumption relationships, namely:  X  subsumption relationship deletion, denoted by delete ( t  X  t ) ,and  X  subsumption relationship addition, denoted by add ( t  X  t ) .
 Before an operation delete ( t  X  t ) we assume that the relationship t  X  t belongs to the transitive reduction (Hasse Diagram) of  X  . Now before an operation instance, Fig. 4 shows an example of a deletion and an addition of a subsumption relationship. We also assume that both t and t belong to the same facet.  X  term renaming, denoted by rename ( t , t ) ,  X  term deletion, denoted by delete ( t ) ,and  X  term addition, denoted by add ( t ) .
 Concerning the deletion of terms we consider that whenever a term t is deleted, all subsumption relationships in which t participates are deleted too. For example, { a after the deletion of a 3 the taxonomy will be as shown in Fig. 5b. If however the  X  is stored, then whenever a term t is deleted, the immediate parent(s) of t should set of all terms which immediately subsume t ,and Nr ( 1 ) ( t ) denotes the set of t can be expressed in terms of the primitive update operations, we study them sepa-to study what the designer wishes (concerning expression revision) after each of these operations. In particular, we consider the following two:  X  term addition as leaf node, denoted by addLeaf ( t , Pa r ) ,where Pa r  X  T  X  term addition as intermediate node, denoted by Par ) = addIntermediate ( t ,  X  , Par ) .Now addIntermediate ( t add ( t  X  p ) for every p  X  Pa r ,and add ( c  X  t ) for every c  X  Chi . their preconditions can be expressed as shown in Table 5.
 describe the effects of each update operation on the broader and narrower terms of each term.  X  add ( a )  X  delete ( a )  X  delete ( b  X  a )  X  add ( b  X  a )  X  addLeaf ( a , Par )  X  addIntermediate ( a , Chi , Pa r ) 4 Problem statement Let F be a faceted taxonomy and let e be an expression of CTCA that defines the desired compound terminology S F e . Now assume an update operation u F on F and let F be the resulting faceted taxonomy. Clearly, this update may turn the expression e obsolete, specifically:  X  e may no longer be well-formed (and thus S F e may be undefinable), or Roughly, and in the ideal case, we would like to find an expression e such as: (  X  ) e is well-formed, and (  X  Although condition (  X  ) can be satisfied quite easily, condition (  X  = )maybeim-possible to satisfy in some cases, e.g. in the obvious case when F is derived by deleting terms from F . We can thus relax condition (  X  = ) and consider that our As stated in [ 12], the most important principle related to the way a change is im-plemented in knowledge bases is the Principle of Minimal Change [ 15], which Prior Knowledge [ 2], or the Principle of Conservation [ 13]. This principle states that the new knowledge base should be as close as possible to the original (a thor-ough discussion can be found at [ 12]). Of course, closeness or distance has to be defined formally. In our case, we define the distance between two compound ter-minologies S , S as the cardinality of their symmetric difference (in the classical set-theoretic sense), i.e. we can write: discussed in Sect. 6.
 defined by expressions of CTCA. We can now express condition (  X  ) formally as follows: (  X  ) S F e = arg S min { dist ( S , S F e ) | S  X  S F } The notation arg S denotes the S that gives the minimum distance. In other words, the righthand side of the above equation returns the S  X  S F that has the minimum distance from S F e .
 S e than being a superset, or the reverse. Consequently, we may state two, different than (  X  ), conditions: (  X  ) S F e  X  S F e and S F e is the biggest possible in S F .
 (  X  ) S F e  X  S F e and S F e is the smallest possible in S F .
 expressions in S F (as this would be computationally inadmissible), but we rather 5 CTCA expression revision In the following, we will assume that the basic compound terminologies are de-son is that an operation delete ( b  X  a ) may turn a DAG-structured taxonomy into a tree-structured taxonomy, while an operation add ( b  X  a ) may turn a tree-structured taxonomy into a DAG-structured taxonomy or into a cyclic taxonomy. So these operations may change the basic compound terminologies. By adopting basic compound terminologies for tree-structured taxonomies we can overcome concerns the combinations of elements from the basic compound terminologies (specifically, of those compound terms that contain at most one term from each facet).
 aterm t , we shall use the notation s # t to denote the compound term s  X  X  t } .Now given a compound term s and two terms t and t , we shall use the notation s # t # t to denote the compound term s if t  X  s , otherwise the compound term derived from s by replacing t by t ,i.e. For example, { a , b , c } # { b , c , d } # { e , f , g }={ a , e , f , g } . applied on F . 5.1 Term renaming, rename ( t , t ) S F , is the one obtained by replacing t by t , i.e.: S clearly S sol  X  S F ).
 the term t by the term t in all compound terms of the parameters P and N of e (in case they contain the term t ). Thus, from each parameter set P (or N )of e ,we can derive the corresponding parameter P (or N )of e , as follows: 5.2 Term deletion, delete ( a ) S corresponding P or N parameter of the sought expression e , should satisfy the following equations: Note that if a compound term s does not contain a then means that we do not have to care about the parameters of e that do not contain longer well-formed. We should therefore modify all parameters of e that contain a . Consider a compound term s that contains a and s appears in a P parameter. In this case we should replace s by all s that are obtained by replacing a by an { s # a | s  X  Nr F ( s ) } .
 condition ( X ) . Figure 6 shows two examples of such an updating. In the first one, e is a plus-product operation, while in the second, e is a minus-product operation. 5.3 Term addition, add ( a ) newly inserted term a should be valid or not. According to the minimum distance S product operation. In this case, we do not have to update the parameter P of this operation because all compound terms that contain a do not belong to Br F ( P ) (because a is not connected to any other element of T i ). For the same reason, we do not need to update any other P parameter of e . have to modify the parameter N . The reason is that since a is not connected to any other term of T i , all compound terms that contain a cannot belong to Nr F ( N ) ; hence, they are considered as valid (according to the semantics of N ). Below, we explain how we can modify N so as to turn these compound terms invalid. Let tops denote the maximal elements (w.r.t. ) of the compound terminologies that are operands of the minus-product operation, excluding the facet T i . For example, to N all compound terms {{ a , u }| u  X  tops } , thus we can define N as follows: We have to update analogously the N parameter of every minus-product operation. (1  X  i  X  k ) such that f ( a )  X  f ( e each u i  X  maximal ( S e i ) .
 5.4 Subsumption relationship deletion, delete ( b  X  a ) This deletion does not necessarily make e obsolete. However, this deletion can terms a and b , and thus change the set of genuine compound terms of a subsuming operation, turning the expression e not well-formed.
 every P or N of e we want to find a P or N such that Br F ( P ) = Br F ( P ) and Nr F ( N ) = Nr F ( N ) . Recall from Sect. 3 that after the operation delete ( b  X  a ) it holds: either a term broader than a , or a term narrower than b . For these parameters we should add extra parameters so that to recoup the  X  X issing compound terms X , i.e. those missed due to the reduction of Nr ( t ) and Br ( t ) .
 than b ,weaddto P a compound term s which is derived from s by replacing t by the set P is defined as follows: Analogously, for each s  X  N which contains a term t that is broader than a ,we add to N a compound term s which is derived from s by replacing t by b .One can easily see than in this way we have Nr F ( N ) = Nr F ( N ) . Specifically, the set N is defined as follows: T i remains the same. Consequently, we do not have to make any other update on the expression. We have achieved S F e = S F e . Figure 7 shows two examples of such an updating: one for a plus-product and one for a minus-product operation. 5.5 Subsumption link addition, add ( b  X  a ) change the genuine compound terms of a subsuming operation, and thus turn the entire e not well-formed. Our main objective is to revise the expression to a well-formed one. Secondly, we would like to find an e such as S F e = S F e .Asweshall Two such cases are shown in Fig. 8. Below, we shall identify when this happens. taxonomy F ,andthat F denotes the faceted taxonomy after the update operation Add ( b  X  a ).
 Proposition 1 We can find an expression e such that S F e = S F e if and only if: (a) for every P parameter of e, it holds: (b) for every N parameter of e, it holds: Proof Let F and F be two faceted taxonomies with the same basic compound terminologies.This means that F and F have the same terms (the same number of facets each one having the same terms), but not necessarily the same subsumption relations. Now let e be a well-formed expression over F .If e is a well-formed expression over F that has the same parse tree with e and for every P of e it holds S pound term x it holds This is impossible if there is a nonempty compound term x (i.e. x = X  ) such that always holds { b } X  x { a } X  x .
 such that always holds { b } X  x { a } X  x .
 ditions ( 3)and( 4) hold only for x = X  then we have no problem, i.e. we can find an expression e such that S F e = S F e . The reason is that if x = X  then only the (general) basic compound terminologies have changed. If we consider basic compound terminologies for trees (as we have done) then both F and F have the same basic compound terminologies.
 { a } X  x  X  Nr F ( N ) then { b } X  x  X  Nr F ( N ) . In this case, we can set e = e and get S F e = S F e .
 satisfy the condition (  X  = ). Moreover, and as we shall see below, there are cases For instance, consider the case shown in Fig. 9 and the following expression: pound term { a 2 , b , c } and only S F e contains the compound term { a 1 , b } ). (i) How can we check efficiently whether the conditions (a) and (b) of Propo-(ii) If the conditions of Proposition 1 do not hold, is S F e well-formed or not? (iii) If the conditions of Proposition 1 do not hold, how we should revise e to Proposition 2 If p  X  Nr F ( b ) = X  for all p  X  P of every P of e, and if n  X  Br F ( a ) = X  for all n  X  N of every N of e, then conditions (a) and (b) of Prop. 1 hold, and thus, S F e = S F e . Proof Recall from Sect. 3 that  X   X   X  Br F ( p ) = Br F ( p ) .  X  Nr F ( n ) = Nr F ( n ) .
 that S F e = S F e . If on the other hand, they do not hold, then we cannot decide whether the conditions (a) and (b) of Proposition 1 hold or not. The following proposition gives us sufficient and necessary conditions.
 Proposition 3 We can find an expression e such that S F e = S F e if and only if (i) for each p  X  P of every parameter P of e it holds: (ii) for each n  X  N of every parameter N of e it holds: If (i) and (ii) hold then S F e = S F e .
 and (b) of Proposition 1 hold due to Proposition 2.
 { b } X  x  X  Br F ( P ) , it also holds { a } X  x  X  Br F ( P ) ,forevery x = X  .Wecan say t x , such that t x  X  b . Let us now investigate what x can be. From the above we can infer that x  X  Br F ( p  X  Nr F ( b )) .Inotherwords, x belongs to set of compound terms defined as follows: from each broader of p we delete the terms p  X  Nr F ( b ) = X  because p is a genuine compound term (as it is a parameter). and only if  X  p  X  P such that p F x  X  X  a } for every x  X  Br F ( p  X  Nr F ( b )) . This is true if and only if  X  p  X  P such that p F ( p  X  Nr F ( b ))  X  X  a } .Sowe proved (i). Question (ii) well-formed is to check whether every individual element of the P / N parameters of e belongs to the associated set of genuine compound terms. Notice that this involves running | P  X  N | times the algorithm IsValid ( e , s ) [27]. Question (iii) ual element of the P / N parameters of e . What should we do in case we encounter an element of a parameter that does not belong to the genuine compound terms of the associated operation? Should we delete it or modify it and how? N parameter of an expression e it holds:  X  Br F ( P )  X  Br F ( P ) , hence S F e  X  S F e (the compound terminology grows )  X  Nr F ( N )  X  Nr F ( N ) , hence S F e  X  S F e (the compound terminology shrinks ) As only in minus-products the compound terminology becomes smaller (in plus-products it becomes bigger), we may encounter a problematic compound minus-product operation. This means that if e has only plus-products then S F e is certainly well-formed.
  X  exprs ( e ) : the subexpressions of e . Each non-leaf node of the parse tree of e belong to the corresponding set of genuine compound terms (w.r.t. F ), then this is due to a contained minus-product operation. This means that only expressions in exprs  X  ( e ) can have parameter elements that are not genuine.
 ement s of e that is not genuine. Now for each e i  X  exprs  X  ( e ) we can define s =  X  problem. This can be achieved in two different ways: (a) revise s i to an s i such that s i  X  S F e (b) revise e i to an e i such that s i  X  S F e Nr F ( n i ) . Specifically, the previous propositions imply that  X  s i certainly has a term t  X  b ,and  X  n i certainly has a term t  X  a .
 Br F i.e. (b)).
 | case.
 Policy (a) to Nr F ( b ) should be replaced by terms that belong to x  X  X Br F ( x )  X  X (note that x  X  X Br F ( x )  X  X  X  T  X  x  X  X Nr F ( x ) ). Now according to the mini-mum distance criterion, the most preferable terms are those in the set Y as defined step (5) replaces the original  X  X roblematic X  parameter element s by one or more compound terms, specifically by those derived after substituting the s i part of s (recall that s i  X  s ) by the revised version(s) of s i .
 Policy (b) our previous discussion). All these terms have to be replaced. Furthermore, the the end of this algorithm we are sure that s i  X  Nr F ( N ) . 4 result in revised parameters. Policy (a) favors revising the parameters of opera-the parse tree. From the perspective of the minimum distance criterion, it can be shown that the  X  X istance X  of the resulting compound terminology is the closest possible but this is true only for the operation whose parameters we decided to update. Concerning the compound terminology of the entire expression we cannot say for sure which policy prevails, as this depends on the size of all S e i .Sothe choice is left to the designer, or the system may adopt by default one policy. consider the case shown in Fig. 10 . The addition of the subsumption link b 2  X  b 1 makes the expression e not well-formed as the compound term longer belongs to the set of genuine compound terms of the plus-product operation ( the reader.
 different methods for reaching a well-formed expression that also satisfies a min-imum distance criterion locally. 5.6 Leaf addition, addLeaf ( a , Pa r ) operation add ( a  X  p ) for each p  X  Pa r . Although we could satisfy ( X  = ) ,here it is more reasonable to assume that the designer would prefer a to  X  X ollow its parents X , i.e. the terms in Pa r .
 parent X  means that if a valid compound term s contains tp ,then s # tp # a should be valid too. For example, if we add the term Crete under the term Greece (in the clear what S F e should be. Concerning expression revision and plus-products, note that a compound term s that contains tp can be valid only due to a parameter p that contains a term t  X  Nr F ( tp ) . This implies that for each such parameter element (that contains a term t  X  Nr F ( tp ) ), we should add a new parameter where t is replaced by a . Consequently, reaching to the sought e requires revising each parameter P as follows: revise the N parameters of e .
 two terms tp 1and tp 2. Let s 1and s 2 be two compound terms that contain the same terms except that s 1 contains tp 1and s 2 contains tp 2. Consider now the the (unrealistic) term RoquefortFeta under the terms Roquefort and Fe t a . Should { be valid, then all compound terms that are broader than s 1# tp 1# a would be valid (so s 2 would no longer be invalid). The revision algorithm follows easily from the above. 5.7 Intermediate term addition, addIntermediate ( a , Chi , Pa r ) . operation add ( a  X  p ) for each p  X  Pa r and an operation add ( c  X  a ) for each c  X  Chi .
 not the same, and there is a conflict (as described in addLeaf ), a should follow the invalid compound terms.
 and is valid, then s # c # a should be valid too (according to the minimum distance should be invalid, according to the minimum distance criterion, but in practice the decision is up to the designer. For example, consider the case a new term X is placed between Ingredients and Truffle .Whether { Greece , X } should be valid or not depends on the meaning of X and the domain knowledge of the designer. 5.8 Epilogue The results reported so far apply also for the case where e contains self-product operations. One slight difference is that in case of an operation Add ( a ) applied we should add to N apair { a , t } for each maximal element t of T i . reach to a compound terminology closer to S F e ) by an expression e with structure (parse tree) different than e . The answer is negative. At first note that previous is always an expression e such that S e = A . Moreover, we have shown that this is operands and parentheses). This means that the set of compound terminologies that can be specified by an expression with a given parse tree equals the set of compound terminologies that can be specified by an expression of any parse tree. without wondering whether the revised expression should have a different parse tree. 6 Similar problems and related work closed world assumptions) differentiate it from other logic-based languages and the corresponding literature on updates and revisions.
 stance, we could consider F as a database and CTCA as a query language, meaning revision in databases. The latter problem is formulated as follows: given a (e.g. relational) database db and one view definition (named query) q , how we should revise q (to a q ) after an update operation on db (that resulted in db ), so that problem of updating databases through views, i.e. how to update the database after (e.g. see [ 16, 26]), nor the problem of (incremental) updating the contents of a In our case, we want to revise the definition of the view, i.e. the focus is given on the transition db  X  q . Recent related work in the context of information integration include [ 1, 17].
 CTCA expression revision corresponds to a special case of belief revision. Un-other sentences (here, term conjunctions) can be inferred. Let us denote the later by Cons ( F , e ) (where Cons comes from Consequence) and write Cons ( F , e ) = { s | ( F , e ) | s }= S F e , where  X  |  X  is based on the semantics of CTCA. Con-sider now an update operation u on F and let F = u  X  F . From this perspective, our objective is to revise e to an expression e such that ( F , e ) is well-formed count that all KB revision approaches also adopt a minimum change criterion, i.e. conform to the new information but retain as much as possible the old knowledge. Notice that we do not focus on the update F = u  X  F , although one can easily see that the definition of the primitive taxonomy update operations tacitly adopt a minimum change criterion too. 5 In our case, we consider F as unquestionable and try to update/revise e according to our objectives.
 sitional logic). A quick answer is that our objective is to capture both cases. A change operation could be a revision operation, i.e. it may assume a static world. For example, consider the case where the term Belgium is added to the taxonomy of the facet LocationOfOrigin of Fig. 1, not because this country emerged now but because it was not recorded at the initial version of this taxonomy. Moroever, a change operation could also be an update, i.e. it may assume a dynamic world. For example, if the original taxonomy contained the term Yugoslavia , then the de-signer would have to delete this term and create new terms for the new emerged countries (world change). However if we consider that each term of this taxonomy denotes a physical space on earth then the  X  X orld X  did not change, but only the names that are used to refer to the world have been changed. A couple of questions now arise: (a) should we revise a CTCA expression in the same way in both cases (i.e. in revision and update), and (b) should the distance criterion as defined in Sect. 4 is appropriate for both cases? Again pragmatic reasons were the gnomon of our choices. The formulation (or maintenance) of e is more costly (and diffi-cult for the designer) than the construction of taxonomies, that X  X  why we want to S e , should be equal to the set of compound terms that involve a 1 are elements of S F e . The same holds in an operation delete ( b  X  a ) :thesetof the way the distance function was defined, i.e. the reason why it was defined inde-pendently of the nature (static or dynamic) of the world. Probably, the distinction between update and revision (in the sense defined in [ 15]) would be more evident in the following scenario (which is out of the scope of this work). Suppose the or suppose the designer wants a compound term s to be removed from S F e (now s  X  S F sentences), then we could probably differentiate between revision and update. when new contradictory information is obtained. Of course, the notion of contra-diction can be defined in several different ways. If we would like to identify the most contradictory case, then this would be the operation Add ( a  X  b ) , because this operation sometimes obliges us to update the parameters of operands out of the scope of the taxonomy operation (even to obtain well-formedness). much, firstly because CTCA cannot be directly expressed, and secondly because this would rather complicate the problem and the notations. 7 Concluding remarks This paper showed how we can revise a CTCA expression e after a taxonomy update and reach an expression e that is both well-formed and whose semantics (specified compound terms) is as close as possible to the original expression e before the update. Various cases were analyzed and the revising algorithms were given.
 by extending the P / N parameters (so as to recover the missing compound terms from the semantics of the original expression). On the other hand, the addition of subsumption relationships cannot be handled always. The reason is that since the tion (which is derived by  X  ), after the addition of a subsumption relationship we may no longer be able to separate (from the semantics) compound terms that were previously separable (i.e. compound terms which were not -related before the addition of the subsumption link). We saw that after such taxonomy updates, the resulting compound terminology may neither be subset nor superset of the original compound terminology. This happens because the effects of adding a subsumption relationship is different in  X  P and N . Specifically, the compound terminologies defined by  X  P operations become larger, while those defined by N operations become smaller. Now the combination of  X  P and N operations leads to com-pound terminologies which are neither larger nor smaller than the original one. In such cases, we saw how we can revise e to an e that is well-formed with respect to F . Two policies were identified. For each of them we gave a revision algo-context). The above results are summarized in Table 6.
 CTCA in real-world applications where updates are very frequent. Without such a service, designers are obliged to reformulate their expressions after taxonomy updates.
 applying a sequence of updates U on F . Instead of deriving one revised e after set of updates U , because we could eliminate the  X  X alancing X  update operations contained in U . This would allow managing efficiently  X  X ong (taxonomy update) transactions X  which are quite common in design applications.
 A An example of CTCA References Author Biography
