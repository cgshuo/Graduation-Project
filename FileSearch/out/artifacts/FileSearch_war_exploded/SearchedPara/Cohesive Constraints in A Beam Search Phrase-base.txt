 Phrase-based machine translation is driven by a phrasal translation model, which relates phrases (contiguous seg-ments of words) in the source to phrases in the tar-get. This translation model can be derived from a word-aligned bitext. Translation candidates are scored accord-ing to a linear model combining several informative fea-ture functions. Crucially, this model incorporates trans-lation model scores and n -gram language model scores. The component features are weighted to minimize a translation error criterion on a development set (Och, 2003). Decoding the source sentence takes the form of a beam search through the translation space, with inter-mediate states corresponding to partial translations. The decoding process advances by extending a state with the translation of a source phrase, until each source word has been translated exactly once. Re-ordering occurs when the source phrase to be translated does not immediately follow the previously translated phrase. This is penalized with a discriminatively-trained distortion penalty. In or-der to calculate the current translation score, each state can be represented by a triple:  X  A coverage vector HC indicates which source words  X  A span  X  f indicates the last source phrase translated  X  A target word sequence stores context needed by the As cohesion concerns only movement in the source, we can completely ignore the language model context, mak-ing state effectively an (  X  f, HC ) tuple.

To enforce cohesion during the state expansion pro-cess, cohesive phrasal decoding has been proposed in (Cherry, 2008; Yamamoto et al., 2008). The cohesion-enhanced decoder enforces the following constraint: once the decoder begins translating any part of a source sub-tree, it must cover all the words under that subtree before it can translate anything outside of it. This notion can be applied to any projective tree structure, but we use de-pendency trees, which have been shown to demonstrate greater cross-lingual cohesion than other structures (Fox, 2002). We use a tree data structure to store the depen-dency tree. Each node in the tree contains surface word form, word position, parent position, dependency type and POS tag. We use T to stand for our dependency tree, and T ( n ) to stand for the subtree rooted at node n . Each subtree T ( n ) covers a span of contiguous source words; for subspan  X  f covered by T ( n ) , we say  X  f  X  T ( n
Cohesion is checked as we extend a state (  X  f h , HC h ) (  X  f h +1 , HC h +1 ) . Algorithm 1 presents the cohesion check described by Cherry (2008). Line 2 selects focal points, based on the last translated phrase. Line 4 climbs from each focal point to find the largest subtree that needs to be completed before the translation process can move elsewhere in the tree. Line 5 checks each such subtree for completion. Since there are a constant number of fo-cal points (always 2) and the tree climb and completion checks are both linear in the size of the source, the entire check can be shown to take linear time.

The selection of only two focal points is motivated by a  X  violation free  X  assumption. If one assumes that the Algorithm 1 Interruption Check (Coh1) (Cherry, 2008)
Input: Source tree T , previous phrase  X  f h , current phrase  X  f h +1 , coverage vector HC 1: Interruption  X  False 2: F  X  the left and right-most tokens of  X  f h 3: for each of f  X  F do 4: Climb the dependency tree from f until you reach 5: if n exists and T ( n ) is not covered in HC h +1 6: Interruption  X  True 7: end if 8: end for 9: Return Interruption translation represented by (  X  f h , HC h ) contains no cohe-sion violations, then checking only the end-points of  X  f is sufficient to maintain cohesion. However, once a soft cohesion constraint has been implemented, this assump-tion no longer holds. 2.1 Exhaustive Interruption Check (Coh2) Because of the  X  X iolation free X  assumption, Algorithm 1 implements the design decision to only suffer a violation penalty once, when cohesion is initially broken. How-ever, this is not necessarily the best approach, as the de-coder does not receive any further incentive to return to the partially translated subtree and complete it.
For example, Figure 1 illustrates a translation candi-date of the English sentence  X  X he presidential election of the united states begins tomorrow X  into French. We consider  X  f 4 =  X  X egins X ,  X  f 5 =  X  X omorrow X . The decoder already translated  X  X he presidential election X  making the coverage vector HC 5 =  X 1 1 1 0 0 0 0 1 1 X . Algorithm 1 tells the decoder that no violation has been made by trans-lating  X  X omorrow X  while the decoder should be informed that there exists an outstanding violation. Algorithm 1 found the violation when the decoder previously jumped from  X  X residential X  to  X  X egins X , and will not find another violation when it jumps from  X  X egins X  to  X  X omorrow X .
Algorithm 2 is a modification of Algorithm 1, chang-ing only line 2. The resulting system checks all previ-Algorithm 2 Exhaustive Interruption Check (Coh2)
Input: Source tree T , previous phrase f h , current phrase f h +1 , coverage vector HC 1: Interruption  X  False 2: F  X  X  f | HC h ( f ) = 1 } 3: for each of f  X  F do 4: Climb the dependency tree from f until you reach 5: if n exists and T ( n ) is not covered in HC h +1 6: Interruption  X  True 7: end if 8: end for 9: Return Interruption Algorithm 3 Interruption Count (Coh3)
Input: Source tree T , previous phrase  X  f h , current phrase  X  f h +1 , coverage vector HC 1: ICount  X  0 2: F  X  the left and right-most tokens of  X  f h 3: for each of f  X  F do 4: Climb the dependency tree from f until you reach 5: if n exists then 6: for each of e  X  T ( n ) and HC h +1 ( e ) = 0 do 7: ICount = ICount + 1 8: end for 9: end if 10: end for 11: Return ICount ously covered tokens, instead of only the left and right-most tokens of  X  f h +1 , and therefore makes no violation-free assumption. For the example above, Algorithm 2 will inform the decoder that translating  X  X omorrow X  also the time complexity of Coh2 is worse than Coh1. How-ever, we can speed up the interruption check algorithm by hashing cohesion checks, so we only need to run Al-gorithm 2 once per (  X  f h +1 , HC h +1 ) . 2.2 Interruption Count (Coh3) and Exhaustive
Algorithm 1 and 2 described above interpret an inter-ruption as a binary event. As it is possible to leave several words untranslated with a single jump, some interrup-tions may be worse than others. To implement this obser-vation, an interruption count is used to assign a penalty to cohesion violations, based on the number of words left uncovered in the interrupted subtree. We initialize the in-terruption count with zero. At any search state when the cohesion violation is detected the count is incremented by Algorithm 4 Exhaustive Interruption Count (Coh4)
Input: Source tree T , previous phrase f h , current phrase f h +1 , coverage vector HC 1: ICount  X  0 2: F  X  X  f | HC h ( f ) = 1 } 3: for each of f  X  F do 4: Climb the dependency tree from f until you reach 5: if n exists then 6: for each of e  X  T ( n ) and HC h +1 ( e ) = 0 do 7: ICount = ICount + 1 8: end for 9: end if 10: end for 11: Return ICount one. The modification of Algorithm 1 and 2 lead to Inter-ruption Count (Coh3) and Exhaustive Interruption Count (Coh4) algorithms, respectively. The changes only hap-pen in lines 1, 5 and 6. We use an additional bit vector to make sure that if a node has been reached once during an interruption check, it should not be counted again. For the example in Section 2.1, Algorithm 4 will return 4 for ICount ( X  X f X ;  X  X he X ;  X  X nited X ;  X  X tates X ). 2.3 Rich Interruption Constraints (Coh5)
The cohesion constraints in Sections 2.1 and 2.2 do not leverage node information in the dependency tree struc-tures. We propose the rich interruption constraints (Coh5) algorithm to combine four constraints which are Interrup-tion, Interruption Count, Verb Count and Noun Count. scribed above. Verb and Noun count constraints are en-forcing the following rule: a cohesion violation will be penalized more in terms of the number of verb and noun words that have not been covered. For example, we want to translate the English sentence  X  X he presidential elec-tion of the united states begins tomorrow X  to French with the dependency structure as in Figure 1. We consider  X  f =  X  X he united states X ,  X  f h +1 =  X  X egins X . The coverage bit vector HC h +1 is  X 0 0 0 0 1 1 1 1 0 X . Algorithm 5 will re-turn true for Interruption , 4 for ICount ( X  X he X ;  X  X res-idential X ;  X  X lection X ;  X  X f X ), 0 for V erbCount and 1 for NounCount ( X  X lection X ). We built baseline systems using GIZA++ (Och and Ney, 2003), Moses X  phrase extraction with grow-diag-final-end heuristic (Koehn et al., 2007), a standard phrase-based decoder (Vogel, 2003), the SRI LM toolkit (Stol-cke, 2002), the suffix-array language model (Zhang and Vogel, 2005), a distance-based word reordering model Algorithm 5 Rich Interruption Constraints (Coh5)
Input: Source tree T , previous phrase  X  f h , current phrase  X  f h +1 , coverage vector HC 1: Interruption  X  False 2: ICount, V erbCount, NounCount  X  0 3: F  X  the left and right-most tokens of  X  f h 4: for each of f  X  F do 5: Climb the dependency tree from f until you reach 6: if n exists then 7: for each of e  X  T ( n ) and HC h +1 ( e ) = 0 do 8: Interruption  X  True 9: ICount = ICount + 1 10: if POS of e is  X  X B X  then 11: V erbCount  X  V erbCount + 1 12: else if POS of e is  X  X N X  then 13: NounCount  X  NounCount + 1 14: end if 15: end for 16: end if 17: end for 18: Return Interruption , ICount , V erbCount , with a window of 3, and the maximum number of target phrases restricted to 10. Results are reported using low-ercase BLEU (Papineni et al., 2002). All model weights were trained on development sets via minimum-error rate training (MERT) (Och, 2003) with 200 unique n-best lists and optimizing toward BLEU. We used the MALT parser (Nivre et al., 2006) to obtain source English dependency trees and the Stanford parser for Arabic (Marneffe et al., 2006). In order to decide whether the translation output of one MT engine is significantly better than another one, we used the bootstrap method (Zhang et al., 2004) with 1000 samples ( p &lt; 0 . 05 ). We perform experiments on English  X  Iraqi and English  X  Spanish. Detailed corpus statistics are shown in Table 1. Table 2 shows results in lowercase BLEU and bold type is used to indicate high-significant better than the baseline.
 Our English-Iraqi data come from the DARPA TransTac program. We used TransTac T2T July 2007 (july07) as the development set and TransTac T2T June 2008 (june08) as the held-out evaluation set. Each test set has 4 reference translation. We applied the suffix-array LM up to 6-gram with Good-Turing smoothing. Our co-hesion constraints produced improvements ranging be-tween 0.5 and 1.2 BLEU point on the held-out evaluation set.

We used the Europarl and News-Commentary parallel corpora for English  X  Spanish as provided in the ACL-WMT 2008 shared task evaluation. The baseline sys-tem used the parallel corpus restricting sentence length to 100 words for word alignment and a 4-gram SRI LM with modified Kneyser-Ney smoothing. We used nc-devtest2007(ncd07) as the development set and nc-test2007(nct07) as the held-out evaluation set. Each test set has 1 translation reference. We obtained improve-ments ranging between 0.7 and 1.2 BLEU. All cohesion constraints perform statistically significant better than the baseline on the held-out evaluation set. In this paper, we explored cohesive phrasal decoding, fo-cusing on variants of cohesive constraints. We proposed four novel cohesive constraints namely exhaustive inter-ruption check (Coh2), interruption count (Coh3), exhaus-tive interruption count (Coh4) and rich interruption con-straints (Coh5). Our experimental results show that with cohesive constraints the system generates better transla-tions in comparison with strong baselines. To ensure the robustness and effectiveness of the proposed approaches, we conducted experiments on 2 different language pairs, namely English  X  Iraqi and English  X  Spanish. These ex-periments also covered a wide range of training corpus sizes, ranging from 600K sentence pairs up to 1.3 mil-lion sentence pairs. All five proposed approaches give positive results. The improvements on English  X  Spanish are statistically significant at the 95% level. We observe a consistent pattern indicating that the improvements are stable in both language pairs.

