 Event structures in open domain texts are frequently highly complex and nested: a  X  X rime X  event can cause an  X  X nvestigation X  event, which can lead to an  X  X rrest X  event (Chambers and Jurafsky, 2009). The same observation holds in specific domains. For ex-ample, the BioNLP X 09 shared task (Kim et al., 2009) focuses on the extraction of nested biomolecular events, where, e.g., a REGULATION event causes a TRANSCRIPTION event (see Figure 1a for a detailed example). Despite this observation, many state-of-the-art supervised event extraction models still extract events and event arguments independently, ignoring their underlying structure (Bj  X  orne et al., 2009; Miwa et al., 2010b).

In this paper, we propose a new approach for su-pervised event extraction where we take the tree of relations and their arguments and use it directly as the representation in a dependency parser (rather than conventional syntactic relations). Our approach is conceptually simple: we first convert the origi-nal representation of events and their arguments to dependency trees by creating dependency arcs be-tween event anchors (phrases that anchor events in the supporting text) and their corresponding argu-ments. 1 Note that after conversion, only event an-chors and entities remain. Figure 1 shows a sentence and its converted form from the biomedical do-events, anchored by the phrase  X  X cts as a costim-ulatory signal, X  and two TRANSCRIPTION events, both anchored on  X  X ene transcription. X  All events take either protein entity mentions ( PROT ) or other events as arguments. The latter is what allows for nested event structures. Existing dependency pars-ing models can be adapted to produce these seman-tic structures instead of syntactic dependencies. We built a global reranking parser model using multiple decoders from MSTParser (McDonald et al., 2005; McDonald et al., 2005b). The main contributions of this paper are the following: 1. We demonstrate that parsing is an attractive ap-instances of event anchors and italicized text denotes entities ( tree (Section 3.1). 2. We propose a wide range of features for event 3. We evaluate on the biomolecular event corpus The pioneering work of Miller et al. (1997) was the first, to our knowledge, to propose parsing as a framework for information extraction. They ex-tended the syntactic annotations of the Penn Tree-bank corpus (Marcus et al., 1993) with entity and relation mentions specific to the MUC-7 evalua-tion (Chinchor et al., 1997)  X  e.g., EMPLOYEE OF relations that hold between person and organization named entities  X  and then trained a generative pars-ing model over this combined syntactic and seman-tic representation. In the same spirit, Finkel and Manning (2009) merged the syntactic annotations and the named entity annotations of the OntoNotes corpus (Hovy et al., 2006) and trained a discrimina-tive parsing model for the joint problem of syntac-tic parsing and named entity recognition. However, both these works require a unified annotation of syn-tactic and semantic elements, which is not always feasible, and focused only on named entities and bi-nary relations. On the other hand, our approach fo-cuses on event structures that are nested and have an arbitrary number of arguments. We do not need a unified syntactic and semantic representation (but we can and do extract features from the underlying syntactic structure of the text).

Finkel and Manning (2009b) also proposed a parsing model for the extraction of nested named en-tity mentions, which, like this work, parses just the corresponding semantic annotations. In this work, we focus on more complex structures (events instead of named entities) and we explore more global fea-tures through our reranking layer.

In the biomedical domain, two recent papers pro-posed joint models for event extraction based on Markov logic networks (MLN) (Riedel et al., 2009; Poon and Vanderwende, 2010). Both works propose elegant frameworks where event anchors and argu-ments are jointly predicted for all events in the same sentence. One disadvantage of MLN models is the requirement that a human expert develop domain-specific predicates and formulas, which can be a cumbersome process because it requires thorough domain understanding. On the other hand, our ap-proach maintains the joint modeling advantage, but our model is built over simple, domain-independent features. We also propose and analyze a richer fea-ture space that captures more information on the global event structure in a sentence. Furthermore, since our approach is agnostic to the parsing model used, it could easily be tuned for various scenarios, e.g., models with lower inference overhead such as shift-reduce parsers.
 Our work is conceptually close to the recent CoNLL shared tasks on semantic role labeling, where the predicate frames were converted to se-Figure 2: Overview of the approach. Rounded rect-angles indicate domain-independent components; regular rectangles mark domain-specific modules; blocks in dashed lines surround components not nec-essary for the domain presented in this paper. mantic dependencies between predicates and their arguments (Surdeanu et al., 2008; Hajic et al., 2009). In this representation the dependency structure is a directed acyclic graph (DAG), i.e., the same node can be an argument to multiple predicates, and there are no explicit dependencies between predicates. Due to this representation, all joint models proposed for semantic role labeling handle semantic frames independently. Figure 2 summarizes our architecture. Our approach converts the original event representation to depen-dency trees containing both event anchors and entity mentions, and trains a battery of parsers to recognize these structures. The trees are built using event an-chors predicted by a separate classifier. In this work, we do not discuss entity recognition because in the BioNLP X 09 domain used for evaluation entities (
PROTEIN s) are given (but including entity recog-nition is an obvious extension of our model). Our parsers are several instances of MSTParser 2 (Mc-Donald et al., 2005; McDonald et al., 2005b) con-figured with different decoders. However, our ap-proach is agnostic to the actual parsing models used and could easily be adapted to other dependency parsers. The output from the reranking parser is converted back to the original event representation and passed to a reranker component (Collins, 2000; Charniak and Johnson, 2005), tailored to optimize the task-specific evaluation metric.

Note that although we use the biomedical event domain from the BioNLP X 09 shared task to illustrate our work, the core of our approach is almost do-main independent. Our only constraints are that each event mention be activated by a phrase that serves as an event anchor, and that the event-argument struc-tures be mapped to a dependency tree. The conver-sion between event and dependency structures and the reranker metric are the only domain dependent components in our approach. 3.1 Converting between Event Structures and As in previous work, we extract event structures at sentence granularity, i.e., we ignore events which span sentences (Bj  X  orne et al., 2009; Riedel et al., 2009; Poon and Vanderwende, 2010). These form approximately 5% of the events in the BioNLP X 09 corpus. For each sentence, we convert the BioNLP X 09 event representation to a graph (repre-senting a labeled dependency tree) as follows. The nodes in the graph are protein entity mentions, event anchors, and a virtual ROOT node. Thus, the only words in this dependency tree are those which par-ticipate in events. We create edges in the graph in the following way. For each event anchor, we cre-ate one link to each of its arguments labeled with the slot name of the argument (for example, connecting gene transcription to IL-2 with the label THEME in Figure 1b). We link the ROOT node to each entity that does not participate in an event using the ROOT -LABEL dependency label. Finally, we link the ROOT node to each top-level event anchor, (those which do not serve as arguments to other events) again using the ROOT -LABEL label. We follow the convention that the source of each dependency arc is the head while the target is the modifier.

The output of this process is a directed graph, since a phrase can easily play a role in two or more events. Furthermore, the graph may contain self-referential edges (self-loops) due to related events sharing the same anchor (example below). To guar-antee that the output of this process is a tree, we must post-process the above graph with the follow-ing three heuristics: Step 1 : We remove self-referential edges. An exam-ple of these can be seen in the text  X  X he domain in-teracted preferentially with underphosphorylated TRAF2 , X  there are two events anchored by the same underphosphorylated phrase, a NEGATIVE REGU -latter serves as a THEME argument for the former. Due to the shared anchor, our conversion compo-nent creates an self-referential THEME dependency. By removing these edges, 1.5% of the events in the training arguments are left without arguments, so we remove them as well.
 Step 2 : We break structures where one argument par-ticipates in multiple events, by keeping only the de-pendency to the event that appears first in text. For example, in the fragment  X  X y enhancing its inactiva-tion through binding to soluble TNF-alpha receptor type II , X  the protein TNF-alpha receptor type II is an argument in both a BINDING event ( binding ) and As a consequence of this step, 4.7% of the events in training are removed.
 Step 3 : We unify events with the same types an-chored on the same anchor phrase. For example, for the fragment  X  X urface expression of intercellu-lar adhesion molecule-1 , P-selectin , and E-selectin , X  the BioNLP X 09 annotation contains three distinct GENE EXPRESSION events anchored on the same phrase ( expression ), each having one of the proteins as
THEME s. In such cases, we migrate all arguments to one of the events, and remove the empty events. 21.5% of the events in training are removed in this step (but no dependencies are lost).

Note that we do not guarantee that the resulting tree is projective. In fact, our trees are more likely to be non-projective than syntactic dependency trees of English sentences, because in our representation many nodes can be linked directly to the ROOT node. Our analysis indicates that 2.9% of the dependencies generated in the training corpus are non-projective and 7.9% of the sentences contain at least one non-projective dependency (for comparison, these num-bers for the English Penn Treebank are 0.3% and 6.7%, respectively).

After parsing, we implement the inverse process, i.e., we convert the generated dependency trees to the BioNLP X 09 representation. In addition to the obvious conversions, this process implements the heuristics proposed by Bj  X  orne et al. (2009), which reverse step 3 above, e.g., we duplicate GENE EX -PRESSION events with multiple THEME arguments. The heuristics are executed sequentially in the given order: 1. Since all non-BINDING events can have at 2. Similarly, since REGULATION events accepts 3. Lastly, we implement the heuristic of Bj  X  orne et 3.2 Recognition of Event Anchors For anchor detection, we used a multiclass classifier that labels each token independently. 3 Since over 92% of the anchor phrases in our evaluation domain contain a single word, we simplify the task by re-ducing all multi-word anchor phrases in the training corpus to their syntactic head word (e.g.,  X  X cts X  for the anchor  X  acts as a costimulatory signal  X ).
We implemented this model using a logistic re-gression classifier with L2 regularization over the following features:  X  Token-level: The form, lemma, and whether  X  Surface context: The above token features ex- X  Syntactic context: We model all syntactic de- X  Bag-of-word and entity count: Extracted 3.3 Parsing Event Structures Given the entities and event anchors from the pre-vious stages in the pipeline, the parser generates la-beled dependency links between them. Many de-pendency parsers are available and we chose MST-Parser for its ability to produce non-projective and n -best parses directly. MSTParser frames parsing as a graph algorithm. To parse a sentence, MST-Parser finds the tree covering all the words (nodes) in the sentence (graph) with the largest sum of edge weights, i.e., the maximum weighted spanning tree. Each labeled, directed edge in the graph represents a possible dependency between its two endpoints and has an associated score (weight). Scores for edges come from the dot product between the edge X  X  corre-sponding feature vector and learned feature weights. As a result, all features for MSTParser must be edge-factored , i.e., functions of both endpoints and the la-bel connecting them. McDonald et al. (2006) ex-tends the basic model to include second-order de-pendencies (i.e., two adjacent sibling nodes and their parent). Both first and second-order modes include projective and non-projective decoders.

Our features for MSTParser use both the event structures themselves as well as the surrounding English sentences which include them. By map-ping event anchors and entities back to the original text, we can incorporate information from the orig-inal English sentence as well its syntactic tree and corresponding Stanford dependencies. Both forms of context are valuable and complementary. MST-Parser comes with a large number of features which, in our setup, operate on the event structure level (since this is the  X  X entence X  from the parser X  X  point of view). The majority of additional features that we introduced take advantage of the original text as context (primarily its associated Stanford dependen-cies). Our system includes the following first-order features:  X  Path: Syntactic paths in the original sentence  X  Original sentence words: Words from the full  X  Graph: Parents, children, and siblings of  X  Consistency: Soft constraints on edges be- X  Ontology: Generalized types of the end-Both Consistency and Ontology feature classes in-clude domain-specific information but can be used on other domains under different constraints and type hierarchies. When using second-order de-pendencies, we use additional Path and Ontol-ogy features. We include the syntactic paths be-tween sibling nodes (adjacent arguments of the same event anchor). These Path features are as above but differentiated as paths between sibling nodes. The second-order Ontology features use the type hierarchy information on both sibling nodes and their parent. For example, a POSITIVE REGULA -TION anchor attached to a PROTEIN and a BINDING event would produce an Ontology feature with the child 2 : SIMPLE EVENT ] (among several other possi-ble combinations).

To prune the number of features used, we employ a simple entropy-based measure. Our intuition is that good features should typically appear with only one edge label. 7 Given all edges enumerated during training and their gold labels, we obtain a distribu-tion over edge labels ( d f ) for each feature f . Given this distribution and the frequency of a feature, we can score the feature with the following: The  X  parameter adjusts the relative weight of the two components. The log frequency component fa-vors more frequent features while the entropy com-ponent favors features with low entropy in their edge label distribution. Features are pruned by accepting all features with a score above a certain threshold. 3.4 Reranking Event Structures When decoding, the parser finds the highest scoring tree which incorporates global properties of the sen-tence. However, its features are edge-factored and thus unable to take into account larger contexts. To incorporate arbitrary global features, we employ a two-step reranking parser. For the first step, we ex-tend our parser to output its n -best parses instead of just its top scoring parse. In the second step, a discriminative reranker rescores each parse and re-orders the n -best list. Rerankers have been success-fully used in syntactic parsing (Collins, 2000; Char-niak and Johnson, 2005; Huang, 2008) and semantic role labeling (Toutanova et al., 2008).

Rerankers provide additional advantages in our case due to the mismatch between the dependency structures that the parser operates on and their cor-responding event structures. We convert the out-put from the parser to event structures (Section 3.1) before including them in the reranker. This al-lows the reranker to capture features over the ac-tual event structures rather than their original de-pendency trees which may contain extraneous por-tions. 8 Furthermore, this lets the reranker optimize the actual BioNLP F1 score. The parser, on the other hand, attempts to optimize the Labeled Attachment Score (LAS) between the dependency trees and con-verted gold dependency trees. LAS is approximate for two reasons. First, it is much more local than the BioNLP metric. 9 Second, the converted gold de-pendency trees lose information that doesn X  X  transfer to trees (specifically, that event structures are really multi-DAGs and not trees).
 We adapt the maximum entropy reranker from Charniak and Johnson (2005) by creating a cus-tomized feature extractor for event structures  X  in all other ways, the reranker model is unchanged. We use the following types of features in the reranker:  X  Source: Score and rank of the parse from the  X  Event path: Path from each node in the event  X  Event frames: Event anchors with all their ar- X  Consistency: Similar to the parser Consis-
To improve performance and robustness, features are pruned as in Charniak and Johnson (2005): se-lected features must distinguish a parse with the highest F1 score in a n -best list, from a parse with a suboptimal F1 score at least five times.

Rerankers can also be used to perform model combination (Toutanova et al., 2008; Zhang et al., 2009; Johnson and Ural, 2010). While we use a sin-gle parsing model, it has multiple decoders. 10 When combining multiple decoders, we concatenate their n -best lists and extract the unique parses. Our experiments use the BioNLP X 09 shared task corpus (Kim et al., 2009) which includes 800 biomedical abstracts (7,449 sentences, 8,597 events) for training and 150 abstracts (1,450 sentences, 1,809 events) for development. The test set includes 260 abstracts, 2,447 sentences, and 3,182 events. Throughout our experiments, we report BioNLP F1 scores with approximate span and recursive event matching (as described in the shared task definition). For preprocessing, we parsed all documents us-ing the self-trained biomedical McClosky-Charniak-Johnson reranking parser (McClosky, 2010). We bias the anchor detector to favor recall, allowing the parser and reranker to determine which event an-chors will ultimately be used. When performing n -best parsing, n = 50 . For parser feature pruning,  X  = 0 . 001 .

Table 1a shows the performance of each of the de-coders when using gold event anchors. In both cases where n -best decoding is available, the reranker im-proves performance over the 1-best parsers. We also present the results from a reranker trained from mul-tiple decoders which is our highest scoring model. 11 In Table 1b, we present the output for the predicted anchor scenario. In the case of the 2P decoder, the reranker does not improve performance, though the drop is minimal. This is because the reranker chose an unfortunate regularization constant during crossvalidation, most likely due to the small size of the training data. In later experiments where more data is available, the reranker consistently improves accuracy (McClosky et al., 2011). As before, the reranker trained from multiple decoders outperforms unreranked models and reranked single decoders. All in all, our best model in Table 1a scores 1 F1 point higher than the best system at the BioNLP X 09 shared task, and the best model in Table 1b performs similarly to the best shared task system (Bj  X  orne et al., 2009), which also scores 53.5% on development.
We show the effects of each system component in Table 2. Note how our upper limit is 87.1% due to our conversion process, which enforces the tree constraint, drops events spanning sentences, and performs approximate reconstruction of BINDING events. Given that state-of-the-art systems on this task currently perform in the 50-60% range, we are not troubled by this number as it still allows for plenty of potential. 12 Bj  X  orne et al. (2009) list 94.7% as the upper limit for their system. Considering this relatively large difference, we find the results in the previous table very encouraging. As in other BioNLP X 09 systems, our performance drops when switching from gold to predicted anchor informa-tion. Our decrease is similar to the one seen in Bj  X  orne et al. (2009).

To show the potential of reranking, we provide or-acle reranker scores in Table 3. An oracle reranker picks the highest scoring parse from the available parses. We limit the n -best lists to the top k parses where k  X  { 1 , 2 , 10 , All } . For single decoders,  X  X ll X  uses the entire 50-best list. For multiple de-coders, the n -best lists are concatenated together. The oracle score with multiple decoders and gold anchors is only 0.4% lower than our upper limit (see Table 2). This indicates that parses which could have achieved that limit were nearly always present. Im-proving the features in the reranker as well as the original parsers will help us move closer to the limit. With predicated anchors, the oracle score is about 13% lower but still shows significant potential.
Our final results on the test set, broken down by class, are shown in Table 4. As with other systems, complex events (e.g., REGULATION ) prove harder than simple events. To get a complex event cor-rect, one must correctly detect and parse all events in Table 2: Effect of each major component to the over-all performance in the development corpus. Compo-nents shown: AD  X  event anchor detection; Parse  X  best individual parsing model; RR  X  reranking multiple parsers; Conv  X  conversion between the event and dependency representations.  X  X  X  indicates that gold data was used;  X  X  X  indicates that the actual component was used. Table 3: Oracle reranker BioNLP F1 scores for our n -best decoders and their combinations before reranking on the development corpus. the event subtree allowing small errors to have large effects. Top systems on this task obtain F1 scores of 52.0% at the shared task evaluation (Bj  X  orne et al., 2009) and 56.3% post evaluation (Miwa et al., 2010a). However, both systems are tailored to the biomedical domain (the latter uses multiple syntac-tic parsers), whereas our system has a design that is virtually domain independent. We believe that the potential of our approach is higher than what the current experiments show. For example, the reranker can be used to combine not only several parsers but also multiple anchor rec-ognizers. This passes the anchor selection decision to the reranker, which uses global information not available to the current anchor recognizer or parser. Furthermore, our approach can be adapted to parse event structures in entire documents (instead of in-Table 4: Results in the test set broken by event class; scores generated with the main official metric of ap-proximate span and recursive event matching. dividual sentences) by using a representation with a unique ROOT node for all event structures in a doc-ument. This representation has the advantage that it maintains cross-sentence events (which account for 5% of BioNLP X 09 events), and it allows for document-level features that model discourse struc-ture. We plan to explore these ideas in future work.
One current limitation of the proposed model is that it constrains event structures to map to trees. In the BioNLP X 09 corpus this leads to the removal of almost 5% of the events, which generate DAGs in-stead of trees. Local event extraction models (Bj  X  orne et al., 2009) do not have this limitation, because their local decisions are blind to (and hence not limited by) the global event structure. However, our approach is agnostic to the actual parsing mod-els used, so we can easily incorporate models that can parse DAGs (Sagae and Tsujii, 2008). Addi-tionally, we are free to incorporate any new tech-niques from dependency parsing. Parsing using dual-decomposition (Rush et al., 2010) seems espe-cially promising in this area. In this paper we proposed a simple approach for the joint extraction of event structures: we converted the representation of events and their arguments to dependency trees with arcs between event anchors and event arguments, and used a reranking parser to parse these structures. Despite the fact that our ap-proach has very little domain-specific engineering, we obtain competitive results. Most importantly, we showed that the joint modeling of event structures is beneficial: our reranker outperforms parsing models without reranking in five out of the six configura-tions investigated.
 The authors would like to thank Mark Johnson for helpful discussions on the reranker component and the BioNLP shared task organizers, Sampo Pyysalo and Jin-Dong Kim, for answering questions. We gratefully acknowledge the support of the Defense Advanced Research Projects Agency (DARPA) Ma-chine Reading Program under Air Force Research Laboratory (AFRL) prime contract no. FA8750-09-C-0181. Any opinions, findings, and conclusion or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the view of DARPA, AFRL, or the US government.
