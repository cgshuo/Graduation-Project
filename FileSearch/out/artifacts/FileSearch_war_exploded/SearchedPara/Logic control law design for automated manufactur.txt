 1. Introduction
Manufacturers are facing nowadays a market with frequent fluctuations in product demand. To be competitive in such a context the flexibility and reactivity of manufacturing systems have to be properly involved in order to guara nty the productivity and quality of the production system. To reach this objective, not only the reactivity of the higher levels of the control system (Enterprise Resource
Planning and Manufacturing Execution System) but also the real time control level (PLC control level) has to be improved. This paper is located at this control level. PLC control level of an automated manufacturing system is very crucial to ensure the execution of desired manufacturing behaviors b y coordinating various machines and operating a large number of processes. Each time a new product is requested or each time a corrective maintenance is operated, a new logic control law has to be designed in order to match the current manufacturing abilities. Then the model reconfiguration problematic should be solved to make change the models along with manufactur-ing configuration changes ( Li et al., 2009 ). Today, from an industrial point of view, practitioners in industry pursuit more intuitionally standardized modeling tools, e.g., IDEF family (IEEE-SA Standard
Board, 1998), GEMMA  X  study guide of the starting and stopping modes (of an automated process), and one or several languages of the
IEC-611313-3 norm ( IEC-61131-3, 1993 ), to design new logic control code when required. The developer uses the implicit model of the physical system that is his ow n knowledge about the system.
Generally speaking this knowledge synthesizes the resources abilities and their possible effects on the product flow as well as the physical constraints of the system to prevent disruptive events such as collisions between resources or degradation of products. The con-straints assure the integrity of people and goods. Depending on the objectives defined by the scheduling level, the developer designs a logic control law that satisfies the physical constraints and the objectives.

By the end, the following drawbacks of this handmade method can be mentioned:
The optimality of the resulting logic control law with regard to a given criteria cannot be ensured. It directly depends on the expertise level of the developer.

Theoretical tools classically adopted by academia, such as automata ( Linz, 2000 ), Petri nets (PNs) ( Murata, 1989 ), statecharts ( Harel, 1987 ), and finite state machines ( Endsley et al., 2006 ) to check behavioral properties have usually not been used due to difficulties for industry to accept such tools.
The languages traditionally used to code the logic control law (Sequential Function Chart (SFC) or Ladder Diagram languages
IEC-61131-3, 1993 ) do not lend themselves to analytic verifica-tion during the design step. However, the behavioral properties like liveness, boundedness (or safety), and reversibility, are very important to operating and control of production systems.
The global design time of a logic control law is the sum of the three-part time: the design, the verification/validation steps and the tuning phase. Even if today, the time of the last two parts can be reduced with the 3D virtual environment, the global design time is very long. So, the reduction of the lead time of logic control law, and so production time, is not guaranteed.

When a PLC program developer leaves the company, all the knowledge on the physical system which is not formalized and which is known only by the PLC program developer is lost if a knowledge management is not prop erly spread into the company.
With this time constraint, a logic control law is only designed off-line during the design or re-design of the manufacturing system. Then, on-line, a reaction to an event that requires a new logic control law cannot be answered ( Herroelen and Leus, 2005 ).

To settle these challenging problems of logic control code changes and so to contribute at least, not only to the reduction of the production lead time at the real time control level, but also to give means to test behavioral properties of the resulting logic control code, a generic logic control law design approach for industry is proposed. One of the originalities of the proposed approach is to fill the gap between academia and industry, starting from a guided and intuitionally modeling tool (issued from automatic planning field of research), dedicated industrial practitioners, and a sub-optimal resulting control code based on formal tool, e.g., PNs, allowing behavioral properties processing.
The paper is organized as follows. The main approaches for logic control laws design are depicted in Section 2 . The proposed methodology is submitted in Section 3 . The proposed control model is described as well as the operation concept on which it relies on. The formal definition and derived properties of opera-tion are given. The design algorithm is displayed in Section 4 .
Section 5 is devoted to an illustrative case study. Finally, conclu-sions are given and further research is commented on. 2. Logic control law design in CIM level 1 2.1. Design need
Elementary functions (move a product from one point to another, stop a product, etc.) of an automated system are performed by functional chains. A functional chain includes all the components required to achieve this function: an actuator with its effector and elements associated to interface with the control system (pre-actuators and sensors).

From the functional chain level to the highest control level, the control system of a production system is generally divided into five levels as proposed by the CIM ( CIM, 1989 ; ISA-S95, 2000 ;
Trentesaux, 2009 ). Control equipment machines such program-mable logic controllers (PLC) correspond to the CIM level 1.
To design the logic control laws for the PLC, the level 1 is divided into two sub-levels to separate the constraints: functional chain and coordination.

At functional chain level, a logic control law is designed to provide services to the coordination, such as extend cylinder, retract cylinder, start conveyor, change the conveyor speed, etc.
A logic control law at a functional chain level has then to include all the technological constraints required to offer the service.
These technological constraints depend on the type of actuator (single or double effect cylinder, synchronous motor, etc.), the type of pre-actuators (bistable or monostable solenoid valve, starter motor, etc.) and information provided by the sensors.
At coordination level, the execu tion of logic control law changes the state of the products throu gh the services offered by the functional chains. At this level, the controlled system is composed of functional chains and product s. The addressed constraints are interactions between functional ch ains and products. The optimiza-tion of time cycle, that is the main criterion, is generally obtained by simultaneously performing several services.

At the coordination level, our approach aims to design off-line a logic control law in one IEC 61131-3 language (Structure Functional Chart, Ladder Diagram, etc.) to modify the state of functional chains and products from an initial state to a final state by optimizing the time cycle. The design approach is based on a controlled system model, an objective function and a design algorithm. The controlled system model must represent the evolutions of the functional chains with their effects on the products. The objective to achieve is the time cycle, the initial state and the final state of both the product and the functional chains. From these data, the design of a logic control law in coordination level boils down to determine the set of operations to be performed with their precedence constraints.

In the literature, various models of the controlled system exist according to the initial data of the problem and the desired result. In order to establish the foundations of the controlled system model needed to design a control law in coordination level, the next section presents the existing design approaches. 2.2. Design approaches in the literature
We have identified as design approach every method that provides a law to control partially or entirely a controlled system. They are used in different CIM levels or in other application fields than manufacturing. Finally, from this analysis of available methods, the design principle proposed in this paper is defined to answer some drawbacks highlighted by the analysis. 2.2.1. Scheduling
From the set of operations to be performed with their constraints, the scheduling problem consists of finding the chron-ological order of operations which is the best feasible calendar with respect to a given performance criteria ( Chretienne et al., 1997 ). In the manufacturing field, the scheduling is used in the CIM level 3. An operation represents the use of a resource (operator or machine) to produce a service. The set of operations to be performed is determined from manufacturing bill of materials (mBOM) of each product and the quantities of products to manufacture. This knowledge of all operations to be performed is the main difference with the design problem of logic control law in coordination level. 2.2.2. Supervisor synthesis
The supervisor synthesis is based on the Ramadge and Won-ham theory ( Ramadge and Wonham, 1987 ). From a state model of controlled system and the set of prohibited states, the output called supervisor is the set of prohibited events according to the state of the controlled system. The supervisor observes the state of the controlled system and limits its evolutions by prohibiting some events ( Charbonnier et al., 1999 ). From the Ramadge and Wonham theory, other approaches ( Lee and Lee, 2002 ; Qiu et al., 2003 ) exist that are used in the CIM level 2. This observer role of the supervisor which prohibits some events is the main difference with the design problem of the logic control law whose execution imposes evolution on the controlled system. 2.2.3. Automated control code synthesis
This approach proposed by Holloway et al. (2000) is based on the condition systems that are closely related to interpreted Petri nets. A component model representing a functional chain is described with this formalism as well as the associated task blocks. For each output condition of the component model and from any marking of the component model, a task block defines all the control laws to reach the marking for which the output condition is true. In a condition system, the output conditions result from marked places. The effects on the product flow are not modeled in the component model which represents the state space of a component. Then, a sequence of product states is initially given to have the expected effects on the product flow.
This approach designs a control code which defines for an actuator the evolution of the PLC outputs to reach successively the different component states. According to the authors, the approach is limited to functional chain level with technological constraints. The need to provide a sequence of states of the product is the main difference with the design problem of the logic control law. 2.2.4. Automated planning
Automated planning is a control law design method devoted to path and motion planning for mobile systems like trucks or robots that can be easily extended to assembling operations ( Valente and
Carpanzano, 2011 ). Automated planning consists of defining an organized collection of actions whose global effect on mobile systems or handling parts satisfies a given objective ( Ghallab et al., 2004 ). The controlled system model consists of the set of all available actions, a description of the state of the controlled system, and some objectives defined by the final state of the mobile system or parts. The planning algorithm consists of finding the subset and string of available actions to reach the final state satisfying the constraints all along the planning. The automated planning is a sequence of actions that can depend on the current execution context. No parallelism mechanism is involved in the automated planning. Then the model and the algorithms used in automated planning cannot be directly used to design control laws in manufacturing systems in which several parts have to be processed in the same time. But the controlled system model based on the available actions is very interesting because it takes into account constraints on the controlled system state using the pre-constraint notion. Moreover, the action model includes the impacts of the action X  X  execution on the controlled system.
Furthermore, with the action concept, the state space of the controlled system is not explicitly built. The result as a sequence without parallelism is the main difference with the design problem of the logic control law. 2.2.5. Analysis
The previous submitted formal approaches do not give a satisfactory solution ( Zaytoon, 2002 ) to design a logic control law for CIM level 1. Depending on the initial data and results of the problem defined in Section 2.1 , Table 1 summarizes the partial adequacy of the four approaches to design a logic control law in coordination level.

In view of these elements, especially the outputs, the best approach with regard to the need expressed in Section 2.1 is the automated planning. Indeed, this approach allows one to deter-mine all the operations to be performed to achieve a final state of the controlled system. However, optimization of a criterion is not considered by this approach that generates a control law without parallelism. The design approach that is introduced in this paper is based on the automatic planning. 3. Proposed controlled system model
In the previous section, all requirements for the automated control law design are defined. The first requirement is the definition of a controlled system model adapted to the design of logic control laws. Then the set of information contained in this model must be specified. It connects directly with both the control law features, and the constraints satisfied by the con-trolled system evolutions imposed by a control law. 3.1. Constraint levels satisfied by a control law
The basic function of a manufacturing system (defined by the norm NF X50 X 100) can be expressed as increasing the value of the product flow. This basic function is achieved by performing effects on the product flow. The set of these effects modifies a product from its input state to its output state. An effect on the product flow is the result of the conversion by a functional chain of a request emitted by the control system. A functional chain is generally made up of pre-actuator(s), an actuator, and an effector, as in Fig. 1 . In the proposed approach, an effector is always considered to be confused with an actuator. Depending on the desired effects on the product flow and with the notion of functional chains, the PLC program developer uses several points of view to synthesize a control law.

In the manufacturing systems, a control law is generally imple-mented in a Programmable Logic Controller (PLC). In this case, the requests are emitted by the PLC outputs depending on a control law run by the PLC. Then, a control law implemented in a PLC has a PLC output point of view. But a control law is never directly designed manually with this point of view. To design such a control law, the setofconstraints(oftheobjectivesandthecontrolledsystem)is taken into account progressively . Indeed, a PLC program developer begins by defining a control law from a product flow point of view.
This control law defines the evolutions of the product flow state to modify it from its input state to its output state. The functional-chain constraints are progressively taken into account by designing a control law from an actuator point of view, then from a pre-actuator(s) point of view, and finally from a PLC output point of view. The components of a functional chain are generally standard.
And in this case, they are chosen in a library. Therefore when starting with a control law with an actuator p oint of view, designing a control law with a pre-actuator point of view and finally with a PLC output point of view, the new constraints taken into account are not specific to the manufacturing system. These new constraints depend only on the functional-chain technology like single or double cylinder action for the actuator, and one valve with three positions or two valves with two positions for the pre-ac tuator. Finally, all the specific constraints of the manufacturing system are taken in a control law from an actuator point of view into account. Thus, the most difficult work of a PLC program developer is to design a control law from an actuator point of view. It is the aim of the proposed approach.
The control law design is mainly based on the controlled system model. To model the controlled system, the correct point of view must be determined. The controlled system model must have a product flow point of view to be compatible with the objectives. But with only this point of view, the actuator evolu-tions without effect on the product flow cannot be found. Finally, to design a control law from the actuator point of view, the controlled system model must have a double point of view: actuators and product flow. And the model must give the links between both points of view. If an operation models the actuator evolutions and possible associated product flow evolutions, then the links defining the causal relations between two types of evolutions will be modeled.

This double point of view to model the controlled system is also required to know the executable operations for a state of the actuators and the product flow.

To achieve its basic function, the manufacturing system must control the product flow evolutions. But its control system does not drive directly the product flow evolutions; it drives the resource evolutions. Thus, we propose to represent the controlled system model by the set of the product flow evolutions, the resource evolutions and the links between the product flow and resource evolutions. With these links and from product flow evolutions respecting the objectives, the required resources will be deduced. Then a logic control law will be automatically designed. To define the link between the evolutions of resources and the product flow, the product flow and resource evolutions are modeled in the same operation. The operation structuring is based on the model proposed in automated planning field ( Sandewall and Ronnquist, 1986 ; Ghallab et al., 2004 ) and used by Klein (1999) , Castillo et al. (2000) , and Aylett (2001) in the manufacturing and batch-process field. 3.2. Formal definition of an operation
Before formalizing the operation behavior, the required nota-tions are defined. 3.2.1. The automaton notations
The controlled system is made up of all the resources and the product flow. The state of a resour ce or a product is defined by state variables ( s v ). A state q of the controlled system is defined by the value of each sv . The set of states of the Controlled System Model is denoted Q CSM . We assume the following partition: Q CSM  X  Q where Q A and Q F are the sets of Authorized and Forbidden states, respectively. From the control law design point of view in the SMC context ( Combacau et al., 2000 ), the controlled system evolves in accordance with the occurrence of e vents:  X  X  X tart operation i X  X ,  X  X  X nd operation i X  X  and  X  X  X xpected ex ternal events X  X . The state evolu-tion of the resources and the product flow may be seen as a four-alphabet of events defined above; d : Q CSM S -Q CSM is a partial transition function; and q 0 is the initial state. When the designer begins the modeling of the controlled system, no operation exists. Then, Q A and Q F are empty, and there are no event and no d . 3.2.2. The operation notations First, the notation of the different sub-behaviors is submitted. Then, the notation of an operation behavior is presented. Finally the definition of the sub-behavior structure is given. An operation i will be denoted O i . The set of the operations is O  X f O i g i A  X  0 , M . An operation is made up of two kinds of sub-behaviors (see Fig. 2 ):
One basic sub-behavior bb i which defines the effect on the resource with the associated constraints.

The extra sub-behaviors. An extra sub-behavior, denoted eb defines an effect on the product flow with the associated constraints. The eb i , j number is not limited, so j A  X  0 , N . The set of the extra behaviors of O i is
EB
When an operation is run from a state, the effects defined by bb and eb i , j are obtained simultaneously. The description of bb eb is given in the end of this part.

Depending on the controlled system state from which O i is run, all the extra sub-behaviors are not obtained. However, two extra sub-behaviors can be not compatible, e.g., they can never be obtained simultaneously for all the controlled system states. For the above reasons, it is necessary to consider the sub-sets of EB i
The number of EB i , k with p eb i , j elements is the combination of N compatible, the maximum number of EB i , k is equal to:
C
EB is defined by
EB  X f eb i , j = j A J k 4 k A  X  0 , 2 N 1 g , EB i , k EB i
To have a concise notation to refer to an operation behavior, the k index value refers to a behavior. The binary value of k index is considered and each bit represents an extra sub-behavior. If the bit equals one, then the associated extra sub-behavior is included in the operation behavior. So, from the k index, the numbers of extra sub-behaviors included are formally defined in the J k set by
J  X  xk  X  ()
When an operation is run, the basic sub-behavior is always obtained. Finally, a behavior of an O i operation is made up of the basic sub-behavior and a sub-set of EB i . It is denoted B defined by
B  X f bb i g[ EB i , k sub-behaviors are compatible, the number of B i , k is equal to the cardinality of EB i , k .
 Card  X  B i  X  X  Card  X  EB i , k  X  X 
For instance, the extra sub-behaviors of the EC1 operation  X  O  X  are: EB Then k A  X  0 , 2 2 1 and the set of J k is:
J  X f | g , J 1  X f 1 g , J 2  X f 2 g , J 3  X f 1 ; 2 g Finally, the set of the EC 1 behaviors is B
EC 1 ; 0  X f bb EC 1 g , no extra sub-behavior is simultaneously obtained with the basic sub-behavior, B obtained with the basic sub-behavior, B obtained with the basic sub-behavior, B 2 are incompatible, thus, the B EC 1 ; 3 behavior does not exist.
It is still impossible to define the operation behavior without giving details on the sub-behaviors (the basic sub-behavior  X  bb and the extra sub-behaviors  X  eb i , j  X  ). The structure of the sub-behaviors is generic (see Fig. 2 ). They are made up of
The sub-behavior effect on the controlled system. The intermedi-ate state ( IdS ) defines the effect that results from the  X  X  O the value of each one of sv on which the sub-behavior has an the  X  X  O i end X  X  event occurrence. Af ter this event occurrence, IF () gives the value of each one of sv on which the sub-behavior has an canbeonlyonthe sv of the Rr resource running the operation.  X  eb i , j  X  canbeonlyonthe sv of the product flow.

The condition on the initial state. For a state q , if the condition ( IS ) of a sub-behavior is true, then the  X  X  X tart O i  X  X  event occurrence will cause the effects defined by the sub-behavior.
The condition is specified by a propositional formula with an elementary proposition defined by the value of a state vari-able. The elementary proposition can be expressed with the sv of the resources or the product flow. And the sv used to specify the sub-behavior effects must be used in the condition specification. The conditions of the basic sub-behavior  X  bb and an extra sub-behavior  X  eb i , j  X  are denoted IS  X  bb IS  X  eb i , j  X  , respectively.

The associated constraints. For the controlled system evolution resulting from the effects of a sub-behavior, they insure the respect of the security and environmental constraints to avoid harmful consequences. The pre-constraints ( PeC ) and the constraints ( Ct ) are specified by a propositional formula with an elementary proposition defined by the value of a state variable. The sv used here must not exist in IS , and IdS of the sub-behavior. 3.3. The behavior of an operation
The operation behavior B i , k is defined when the operation is the only one to be run. For a state q A Q CSM , the effects of the operation behavior are defined by the effect of the basic sub-behavior bb i and the simultaneously obtained extra sub-behaviors f eb = j A J k g . From a state q after the  X  X  O i start X  X  event occurrence, the effect of a sub-behavior is obtained while respecting the security and environmental constraints, if the condition is true and the associated pre-constraints are satisfied. And from a state q after the  X  X  O i start X  X  event occurrence, the effect of an extra sub-behavior is not obtained if the condition is false.

Definition 1. The set Q I  X  B i , k  X  of the initial B i , k states from which the  X  X  X tart of B i , k  X  X  event occurrence is author-ized. Formally, this set is represented by Q
 X   X  q A Q CSM = IS  X  bb i  X  4 PeC  X  bb i  X  ^
Definition 2. The set Q Id  X  B i , k  X  of intermediate B i , k the states in which the controlled system can be after the  X  X  X tart of
B  X  X  event occurrence and from which the  X  X  X nd of B i , k  X  X  event occurrence is authorized. Formally, this set is represented by Q
 X   X  q A Q CSM = IdS  X  bb i  X  4 Ct  X  bb i  X  ^
Definition 3. The set Q F  X  B i , k  X  of the final B i , k states in which the controlled system can be after the  X  X  X nd of B event occurrence. Formally, this set is represented by Q ^ state q 0 . The sv values of this state are the sv values of the state q which are modified by IdS  X  bb i  X  and IdS  X  eb i , j  X  for j and after the occurrence of  X  X  X nd of B i , k  X  X  event, denoted  X  e controlled system is in a state q 00 . The sv values of this state are the sv values of the state q which are modified by FS  X  bb on the controlled system can be represented as below: q -3.4. Three types of operations
In the preliminaries, we have highlighted two sets of opera-tions: with or without effects on the product. This classification of operations is not sufficiently accurate towards the product flow state. Some state variables of the product flow result from the product specifications like geometric forms, etc. And other state variables of the product flow result from resources and their position in the manufacturing system. According to the state variables modified by an operation running, we have identified three kinds of operations, presented in Fig. 3 . 4. Design algorithm
At the coordination level of the CIM architecture ( Trentesaux, 2009 ), this section presents the proposed method to automati-cally design, for a single product, a control law able to satisfy one demand provided by the scheduling level.

The global structure of the proposed algorithm is directly driven by the operations classification presented above. For each kind of operations, we formulate processes as three optimal path searching problems are associated with ( Lacomme et al., 2003 ). At each step, an optimal path is provided including constraints depending first on the product processing, second on the product moving and third on the preparation of the functional chain.
By the end, a fourth step is added to optimize the cycle time of the sequence, studying the available parallelization between operations. As a result, we generate a control sequence in Petri net formalism that can be directly translated into one of the IEC 1131-3 languages, as Ladder Diagram ( Lee et al., 2004 ) or SFCs that are a subset of the more complex Petri net. 4.1. Step 1: product processing 4.1.1. Principle
Here, it is proposed to focus on the physical states of the product to look for a path able to transform it from an initial state to the final one corresponding to the demand (objectives).
So, only operations with behavior that have an effect on variables states related to the physical state (form, color, etc.) of products are used.

Let us define the state q 1 that represents the controlled system and its environment in the physical condition of the product belonging to the set Q 1 . Q 1  X  Q x A VE values of the state variable x .

A state q 1 A Q 1 is defined by q 1  X f X  x  X  c  X  9 x A VE 1
The states space considered in this first step describes the changes in the physical state of the product. It is a state transition system noted D 1 defined by a triple D 1  X  X  Q 1 , B 1 , d 1  X  with Q defined above, B 1 the set of behaviors transformation resulting from all operations and d 1 the transition function of Q 1 B 1
For an initial state Q 1 : 0 , describing the physical state of a product just inserted in the factory process, and an objective (demand) Ob 1 defined by one (or more) specification on the physical state of the product, the first step is to find an optimal path in D 1 from the initial state q 1 ; 0 A Q 1 to a target state q such as Ob 1 is satisfied (see Fig. 4 ).

To only build the useful part of the states space limited to product processing and to reduce the time process required to generate this space, the reachable states from the initial state Q for a given objective Ob 1 are only considered. D 1 is defined by a quintuple D 1  X  X  Q A 1 , B 1 , d 1 , q 1 ; 0 , Ob 1  X  with Q set of reachable states from Q 1 : 0 for the objective Ob 4.1.2. Building of states space To build the only reachable states space from an initial state Q 1 : 0 , the proposed algorithm uses a greedy procedure ( Lacomme et al., 2003 ) which generates new states to visit.

So, two sets of states are updated: the set of states to visit, noted Q v , the set of processed states, noted Q A 1 .
 The principle of the algorithm is then as follows:
Determining all processing behaviors from a state of the set of states to be visited. This state is then removed from this set of states and next added to the set of processed states;
Initial state q 1,0
Calculate the status achieved through the application of each such behavior;
If the reached state is a new state, it is added to the set of states to be visited.

Algorithm 1. Algorithm to build the states space reachable by transforming the product from an initial state Q 1 : 0 A Q Function Reachable States  X  q 1 ; 0  X  : System state transitions
Q Q d  X  q 1 , b 1  X  est vide While  X  Q v a f | g X  do
B
Q v  X  Q v \ f q 1 g Q
While  X  B 1  X  q 1  X  a f | g X  do q 00 1  X  d  X  q 1 , b 1  X  tel que b 1 A B 1  X  q 1  X 
If  X  q 00 1 = 2 Q A 1 et q 00 1 = 2 Q v  X  then end if done done return D 1  X  X  Q A 1 , B 1 , d 1 , q 1 ; 0  X  ; End
The algorithm ends when the set of states to be visited, Q empty. The set of reachable states is then given by the processed states. As a result, the state transition system D 1  X  X  Q is built (see Fig. 5 ).

From the initial, the optimal path to reach the objective is look for in the reachable state space. 4.1.3. Optimal path
Considering a criterion, the search process to find an optimal path to reach a goal state from an initial state is a classical graph theory problem ( Lacomme et al., 2003 ). Among the many existing solutions and considering that the weight of arcs are positive or equal to zero, the use of Dijkstra X  X  algorithm ( Dijkstra, 1959 )is submitted. It is applied to the system state transitions D graph g 1 . The vertices correspond to states of the system transi-tions and arcs to transitions between states. The initial state Q becomes the top s 1 : 0 vertices and objectives S 1 , Ob correspond to objective states Q 1 , Ob . Weighted arcs are defined from the char-acteristic of the operations (i.e. duration, see Section 2 ) required to evaluate the optimization criterion.

The optimal path of processing product, noted Ch 1 is obtained by associating the vertices g 1 and the states transition system D
At the end of this first step, only sequenced operations able to transform the physical states (form, color, etc.) of the product according to the demand are submitted. Thus, the second step, presented in the next section, aims to act on the product location, to drive it from a processing operation to another one. 4.2. Step 2: move the product
Consideration of changes in the position of the product aims firstly to satisfy the scheduling level request taking arrival and departure of the product in the manufacturing system, and secondly to meet conditions and constraints on the intermediates product X  X  location with the path constructed above, Ch 1 into account.

Because of the significant similarities with step 1 proposed previously, the presentation of step 2 is voluntary reduced.
In the first step, only one single sequence is proposed, from the initial physical state of the product to the final one. In step 2, we have to build as many sequences as arcs between two vertices (processing operation) of Ch 1 (see Fig. 6 ).

The integration of these sequences to Ch 1 results in the generation of a new path denoted CH 12 .

The constructive principle of such sequences shows a funda-mental difference in the definition of the initial state Q objectives Ob 1 directly issued from the scheduling level demand. from the application with the reachable states space noted D (see Fig. 6 ).

Beyond this particular knowledge on the initial state and objectives, finding a path only representing changes of the location of the product, denoted CH 2 , i differs from the above algorithm on the following four points: Here, only move operations are considered.

Only the location of the product evolves. Thus, a state q
CH 2 , i belongs to the set defined by Q 2 ,where Q 2  X  Q with V x corresponding to all the values of the variable state x .A state q 2 A Q 2 is defined by Q 2  X  Q x A VE
The path of processing and move operations, CH 12 is built gradually with each new resulting sequences ( CH 2 , i  X  .
The complexity of the reachable states space in which is searched after the product X  X  location is limited by restrictive conditions different from those used in step 1. 4.3. Step 3: preparation of functional chains
The meaning of this step is to build sequences, noted CH 3 , i representing functional chains that do not affect the product. The integration of these sequences in the path CH 12 will be called
CH
The corresponding algorithm for generating the path CH 123 quite similar to the one used to generate CH 12 ; so it is not detailed here. This algorithm uses a function Optimal Path that built a specific path, denoted CH 3 , i , limited to the changes of the functional-chain state. This path differs slightly from the sequence CH 2 , i looking for the evolution of the position of the product:
Only operations affecting the state of the functional chains are considered. Then, a state q 3 of the path CH 3 , i belongs to the set variable x . A state q 3 A Q 3 is defined by q 3  X f X  x  X  c  X  [ VE 2 [ VE 2 g , where c A V x .

Restrictive conditions specific to this third step limit the complexity of the reachable states space.

The search for the shortest path is performed in the same way as in steps 1 and 2. Obviously, the states space in which the path is searched is different. 4.4. Step 4: optimization
The found path CH 123 is not always optimal. Indeed, the cycle time of the control law corresponding to the sequence of opera-tions specified by this path can be reduced by introducing parallelism between operations.

Let us consider a full path CH 123 composed of N transitions which are each labeled with the following behaviors ( B k These behaviors transform the product, alter its position, or prepare functional chains.

Adding to the path CH 123 information on parallel implementa-tion leads to a path, called optimal control law, from a cycle time point of view. It is denoted CH Op .

Both lists (// forward and di v )ofa B k behavior are completed as follows: list // forward . If the behaviors B k and B k 1 can be executed in
A full path CH 123 has been designed for a product, then it is not possible to reverse the order of two operations whose effects would be different from the specified one by the full path CH 5. Case study
The presentation of the case study is based on the principle of the control law design presented in Section 4.1.1 . After the description of the controlled system used for the case study, this section presents the model of the controlled system, the initial state and the objective. The control law provided by the design algorithm is then given. 5.1. Controlled system description
The controlled system used for the case study is based on the loading system (see Fig. 8 ) of an automated system. This system is dedicated to the assembly of camshafts, denoted products. A rotating storage with four places is used to receive up to six different kinds of products. The products are identified by a weight identification system. Once a product has been identified, a central conveyor drives it to a sorting device. A robot takes the different products to assemble them. A worker is in charge of filling the rotating storage and emptying the assembly station.
The points A, B, C and D are fixed. So, if there is a product in A and if the rotating storage begins to turn clockwise, the product will be between A and B, then in B, then between B and C, and so on.
The next section presents the model of the loading system. 5.2. Controlled system model The loading system model is made up of ten operations: E xtend C ylinder 1 from its retracted position (EC1) (see Fig. 9 ), R etract C ylinder 1 from its extended position (RC1), E xtend C ylinder 2 from its retracted position (EC2), R etract C ylinder 2 from its extended position (RC2),
R otate the rotating Storage Clockwise from an indexed posi-tion to the next (RSC),
R otate the rotating Storage CounterClockwise from an indexed position to the next (RSCC), I dentify the P roduct on the weight identification system (IP), D etect the presence of a P roduct in A (DPA), D rop a P roduct in C by the operator (DPC), E vacuate a P roduct from F by conveyor (EPF) (see Fig. 10 ).
The EC1 operation (Extend Cylinder 1 from its retracted position) includes a basic sub-behavior and two extra sub-behaviors. The basic sub-behavior describes on the one hand the evolution of the resource (actuator 1) on which the operation is based and on the other hand constraints to be satisfied to ensure the integrity of the system. If the condition on cylinder 1 is not satisfied, the operation cannot be executed. If the constraints are not satisfied, the operation execution is possible but the loading system or the products risk to be damaged. The con-straints guarantee to avoid collisions between cylinder 1 and other elements (cylinder 2 or products). When cylinder 1 is extended, the two extra sub-behaviors describe the possible
Basic sub-Behavior 1 Extra sub-Behavior 2 Extra sub-Behavior
Basic sub-Beha vior 1 Extra sub-Beha vior effects on products according to the product state before the operation execution. The difference between condition and con-straint is the same as in the basic sub-behavior.

For the other operations, there are between zero and four extra sub-behaviors. For instance, cylinder 1 retraction cannot have any effect on a product and therefore the operation RC1 has no extra sub-behavior. In contrast, the rotating storage holds up to four products and may have an effect simultaneously on these four products. Thus, the RSC and RSCC operations have four sub-behaviors each.

The DPC and EPF operations have no basic sub-behavior. For the DPC operation, the operator drops the product in C on the rotating storage when he wants. The operator can drop or remove the products in C. He does not inform the control system about his actions. And the product presence (or absence) in the rotating storage is known only when the product arrives in A. So in C, the presence of a product is uncertain. The operator is outside of the controlled system, the control system cannot run the DPC opera-tion. In addition, the state of the operator is not necessary to write constraints or conditions for other operations, it is unnecessary to model the state and its evolution in the basic sub-behavior. For this operation performed by a resource outside of the controlled system, only information on its occurrence and its effect on the product is modeled in the extra sub-behavior.

Similarly for the EPF operation, the conveyor that acts on the product is outside of the controlled system. The state of the conveyor is not needed for writing requirements and constraints for other operations, the operation EPF has no basic-sub-behavior, see Fig. 10 .

With this controlled system model, the controlled system state space is not explicitly represented. The problem of the state space explosion is avoided. In addition to the controlled system model, the design algorithm also needs to know the initial state of the controlled system and the objective that are detailed in the next section. 5.3. Initial state and objectives
The values of all variables of the controlled system are defined in the initial state. SVP A S variables define the entry state of products into the loading system. For this system, the entry state is characterized by the single variable  X  X  X ype X  X . All the values of the variable  X  X  X ype X  X  are: unknown, 1-type to 6-type. For SVP variables, the initial state is characterized by Type  X  unknown.
For SVP = 2 S variables, the values are: no product in the controlled system. For SVR variables, the values are: C1 and C2 in the retracted position, the rotating storage in the indexed position with a null speed.

For the objective, the value of all variables is not necessarily defined. For the proposed example, the objective is to reach a state without product through a state with a product identified in F. This objective is defined only by the values of some variables. The optimized criterion is the cycle time.

The results of the algorithm that uses operations to design a control law according to the initial state and the objective are presented later in the next section. 5.4. Design algorithm
This section presents the main results of the four steps of the algorithm described in Section 4.1.1 . 5.4.1. Step 1: sequence with processing operations
The only processing operation provided by the loading system is the product identification (IP). Indeed, for the control system, this operation changes the features of the product. The features are known according to the value of variable Type . In the initial state, the features of the product are unknown. After the product identification, product features have changed state for the control system because they are known.

Step 1 result is a sequence with a single operation whose execution modifies the values of SVP A S variables in the initial state to the values defined by the objective. This sequence is very simple, the first step is no more detailed before presenting the second step. 5.4.2. Step 2: adding moving operations
Step 2 adds moving operations to the sequence generated in step 1 in order to satisfy the conditions and constraints on the product position of the processing operations. For the loading system, this step generates two sequences of moving operations. To allow the execution of the processing IP operation, the first sequence is designed to put a product on the weight identification system. After the IP operation, the second sequence is designed to put the controlled system in its initial state without product to generate a cyclic control law.

To design the first sequence, the problem is characterized by the initial state defined in Section 5.3 but limited to all the variables SVP. The objective of the first sequence is to satisfy the conditions and constraints of IP operation on variables SVP = 2 S (one product on the identification system). As indicated in the presentation of the algorithm in Section 4 , the reachable state space is generated with the loading system model from the initial state before looking for the shortest path between the initial state and a state satisfying the objective. The shortest path is repre-sented by a bold line in Fig. 12 whose state 1 is the initial state.
To limit the size of the reachable state space, the number of products in the system is limited to one for this step 2. For the loading system, the number of products increases with the DPE operation when the operator drops a product in C. Apart from the states that respect the objective, this limitation is characterized by states reached with the DPE operation from which there is no transition for leave (see Fig. 12 ).

Of course, there is a risk of combinatorial explosion. For instance, the number of states and transitions with one product in the system is lower than 100 and for three products the number of states exceed 3000 and the number of transition is closed to 8000.

From the graph, a sequence of moving operations is obtained with the operations belonging to the shortest path in Fig. 12 . This sequence is added before the processing IP operation determined in step 1. The same principle is applied to design a sequence of moving operations added after the IP operation. After the assem-bly of these sequences, the result of Step 2 is a sequence of processing and moving operations shown in Fig. 11 in which preparation operations are added in step 3. 5.4.3. Step 3: adding preparation operations
The objective is to satisfy the conditions and constraints on resources for processing and moving operations. The principle of step 3 is to add preparation operations in the sequence generated in step 2. For the loading system, the constraint on the state of actuator 1 which must be returned to run the EC2 operation (Extend Cylinder 2) is not satisfied after the IP operation. To satisfy this constraint, a sequence of preparation operations is designed with the same principle as in steps 1 and 2. The preparation RC1 operation (Retract Cylinder 1) is added from the state q 9 after IP operation (see Fig. 11 ).
 Finally, step 3 leads to add the RC1 operation and the RC2 operation (Retract Cylinder 2). The sequence designed after step 3 can reach the objective but it is not optimal in terms of cycle time. Operations that can be performed simultaneously have to be identified. 5.4.4. Step 4: parallelism
Step 4 of the algorithm aims at finding authorized parallelism between operations in the sequence generated in step 3. From the principle of step 4 shown in Fig. 7 , the RC1 operation can be performed simultaneously with the IP operation. However, the
RC1 and EC1 operations cannot be performed simultaneously because they require the same resource, cylinder 1. The paralle-lism between RC1 and IP corresponds first to perform the RC1 and
IP operations after the EC1 operation and second to perform RC2 only after the end of the IP and RC1 operations. This information of AND divergence after EC1 operation and of AND convergence before EC2 operation is contained in both lists // forward and div which will translate the control law into a Petri net or a language for PLC as SFC language.

Unlike these languages, the translation into a precedence graph of Fig. 13 does not allow execution of the control law by a digital system (PLC, industrial computer) but it only allows to illustrate simply the result of step 4. The precedence graph formalism is poorer in information than the state model with lists // forward and div . Indeed, the precedence graph does not contain information on the state of the controlled system after the execution of each operation. But, this information is required by the subsequent steps of the algorithm in the case of a multi-product problem. This problem is reflected by the presence at a time t of several products. The algorithm for solving this problem that contains additional steps is not presented in this article.
To complete the presentation of case studies, the result of the translation into a Petri net of the design control law is proposed in the case of multi-product problem. 5.4.5. Logic control law
From the viewpoint of the control system, the loading system is a system in which several products can be present simulta-neously and for which there is one different objective for two product families. Indeed, after the rotation of the rotating storage, the DPC operation (Drop a Product in C by the operator) is always executed for the design algorithm by lack of information provided by the operator. The presence of a product dropped in C is therefore uncertain. The real presence of a product is detected in A with the detection operation. Because of this uncertainty about the presence of products on the rotation storage, the loading system is characterized by the treatment of two product families: the present products and lacking products. In addition, the system can act on several products simultaneously which may include on the rotating storage in A, B, C and D. Although the steps of the design algorithm are not presented in this article, Fig. 14 shows the result of the design algorithm for these two additional problems and translation of the result into a Petri net. A software environment to design control laws has been developed in Java under Eclipse. 5.4.6. Result with automated planning approach With a classic automated planning approach ( Valente and Carpanzano, 2011 ), a single kind of operation is defined in contrast to the proposed approach, which defines three kinds. With no difference between pre-conditions and pre-constraints in automated planning, coupling between functional-chain and product evolutions is lacking or permanent. The sequence of operations obtained with an automated planning approach is limited to non-optimal sequence of processing operations or a sequence of moving operations in case of lacking of process operation. For the proposed system, the controlled system will be able to go through step 21 in Fig. 12 before to achieve the state goal 19. Finally, the result does not contain all the operations, the sequence of operations does not minimize the cycle time and parallelism do not exist between the operations. Finally, the system would treat the products one by one while it is possible to have more than six products simultaneously in the manufacturing cell. 6. Conclusion
In this paper, a methodology to help automation engineers to design off-line a logic control law from the controlled system abilities is proposed. The modeling concept is based on the extension of the one proposed in automatic planning field of research: operation model. There are double interests of this controlled system modeling. First, there is no problem of combi-natory explosion which is generally the limit of automaton representation usually used at this level. Next, the model struc-turing and the required information (effects of a service, condi-tions, and constraints) facilitate the modeling task. Such a modeling approach presents also the advantage to capitalize a technical knowledge of the controlled system abilities resolving in part the departure of automation engineers from the company.
Moreover, considering separately each of the operation of the controlled systems allows to simply update the model in case of changes due to physical reconfigurations or loss of controlled system capacities in failures context.

Based on the proposed decomposition, the resulting logic control law is not optimal. In return, the proposed algorithm is based on a compromise between the complexity of the build states space and the solution X  X  performance. Finally, it is impor-tant to notice that the resulting solution support on a formalism of representation favorable with its translation into languages of standard IEC 61131-3, thus, opening interesting application for PLC programming.

Future works will focus first on the way to develop a graphical interface to help designer to capitalize the required knowledge using a functional chain point of view. Secondly, the problem with several different types of products will be studied. The principle would be very similar to the steps defined to face parallelism for several identical products. By the end, this logic control law design approach will be extended to an uncertain execution context characterized by resource failures in order to provide some reactivity abilities to the manufacturing system. In this context, an automatic update process of the model of the controlled system must be studied. Indeed a failure has two consequences, first the evolution of the AMS can be in an unexpected state and second, a possible modification to the
AMS capabilities. Then before to try to design a new adequate control law, the model must take these modifications into account.
 References
