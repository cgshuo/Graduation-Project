 In this paper, I present a novel approach for implementing a stream-based Recommender System (RecSys). I propose to add RecSys operators to an application-independent Data Stream Management System (DSMS) to allow writing con-tinuous queries over data streams that calculate personalized sets of recommendations. That empowers RecSys providers to create a custom RecSys by writing queries in a declara-tive query language. This approach ensures a flexible and extendable usage of RecSys functions in different settings and benefits from matured features of DSMSs.
 H.4 [ Information Systems Applications ]: Miscellaneous; H.3.3 [ Information Storage and Retrieval ]: Information Search and Retrieval X  information filtering, relevance feed-back recommender system; collaborative filtering; data stream management system; stream processing
In real-world Recommender Systems (RecSys), ratings are produced continuously and in a temporal order by a large number of users. Recent research on RecSys has emerged model-based collaborative filtering algorithms for stream-ing data (so-called online or incremental collaborative fil-tering; e. g., [11]). These algorithms allow to add new rat-ings to existing models. Thus, the model can be updated more often and is able to express the recent interests of the users. Combined with methods of time-aware RecSys [6], these approaches allow the calculation of recommendations influenced by the current interests of the users instead solely based on general preferences.

There are some libraries that provide implementations of learning algorithms for RecSys models. However, it takes more than learning algorithms to operate a stream-based and time-aware RecSys. Such a system needs to manage and provide input and output data stream connections, parse and transform streaming data, organize the (transient) stor-age of the data, optimize and distribute the data processing, should allow a configuration of the RecSys, etc.

In this paper, I propose to add RecSys functions to a application-independent Data Stream Management System (DSMS). A DSMS is designed to continuously process data streams by the use of query plans. A query plan consists of operators that implement base functions (e. g., a stream-based variant of the relational algebra) as well as special tasks (e. g., data mining operators). Using a DSMS for a stream-based RecSys has the following advantages:  X  The RecSys operators can be used by DSMS users in ar-bitrary queries written in a declarative query language.
They can build a customized RecSys without the need of writing code.  X  A lot of operations needed for a RecSys can be covered by existing operators. This includes the access to data sources and sinks, the calculation and aggregation of val-ues like the model error for the RecSys evaluation, the selection of the top-K recommendations, etc.  X  A RecSys can be enhanced by adding additional opera-tors to the query. This can be useful to combine different data sources, to pre-and post-process data (e. g., normal-ization of input data), to include and process additional data (e. g., context data or linked open data), to combine different model learners for ensemble learning, etc.  X  The RecSys developer can benefit from many DSMS fea-tures like query plan optimization, query sharing, paral-lelization and distribution of queries, scheduling, etc. This leads us to the following research questions:  X  How can a collaborative and model-based RecSys be im-plemented by a DSMS? How can a RecSys be split into DSMS operators to achieve a flexible composition of a
RecSys by a declarative query language?  X  How can a RecSys benefit from DSMS features? What are the limitations of this approach?  X  Is it possible to efficiently implement different state-of-the-art RecSys methods to a DSMS? How can different implementations be compared? The remainder of this paper is structured as follows: First, I introduce the background of my work (Sec. 2). Then, in Sec. 3, I present the current state of my approach. This includes a sample query plan for a RecSys, the introduction of new operators, and a basic implementation that shows the feasibility. In Sec. 4, I give an overview of related work. Finally, I discuss plans for feature work (Sec. 5). Let U = { u 1 , . . . , u n } and I = { i 1 , . . . , i m all users and items, respectively. Furthermore, let T be a discrete time domain with a total order, e. g., the set of all non-negative integers T = { 0 , 1 , 2 , 3 , . . . } interpretable as UNIX timestamp. Every user u has interacted with a set of items I u  X  I . Each interaction results in a rating score r that quantifies the interest of the user to the item he/she interacted with at a certain time t  X  T . The rating might be explicitly given by the user or implicitly derived from the interaction. This leads to a set of tuples of known or observed ratings R := { ( u, i, r, t ) | ( u, i, r, t )  X  U  X  I  X  that we call the rating data . The challenge of a time-aware RecSys is to predict a rating  X  r of an item i for a certain user u at a point in time t . In order to give recommendations for a user u , the RecSys predicts ratings for each item of a set of recommendation candidates for user u and recommends these with a minimum predicted ratings score and/or the K items with the highest ratings (top-K set). The set of recommendation candidates for user u includes usually all items not rated by u .
 A data stream in our DSMS is a potentially infinite sequence of elements, each annotated with an half-open validity time interval [ t s , t e ). The elements of every stream are ordered by t , so that t s is monotonically, but not necessarily strictly, increasing. An operation that uses different elements of one or more data streams should process only these elements together that have overlapping validity intervals (elements that are valid at the same time). Due to the required order of stream elements, an operation can drop a stream element e when each involved stream has delivered an element with a t s greater than or equal to t e of e . In this case, no data stream will deliver another element whose validity interval overlaps with e . By default, each element becomes valid at the time t of creation (e. g., when a user rates an item) and will be valid forever, which results in an interval [ t,  X  ). DSMSs are developed to continuously process data streams. Similar to Database Management Systems (DBMSs), a user writes queries by the use of a declarative query language. The system parses the query and transforms it into a logical query plan of operators that determines the logical sequence of operations. This plan can be optimized (e. g., by changing the operator order) and is translated into a physical query execution plan, which consists of operators with an appro-priate implementation. While traditional DBMSs focus on giving a precise answer by a one-time query on a fully known persistent data set, DSMSs typically use continuous queries to process streams of transient data in order to continu-ously give (often approximated) answers [4]. In contrast to a DBMS, a DSMS has no random access to the data. It ac-cesses the elements sequentially in order of the occurrence in the stream. An element cannot be requested again unless it is explicitly held in memory ( one-pass paradigm ). Because a stream is potentially infinite, the number of stored elements needs to be limited to prevent a memory overflow [4]. In this section, I introduce an approach for building a Rec-Sys based on a DSMS. The RecSys has two input streams: one that provides the rating data as user-item-rating triples and one that provides requests for recommendations. An output stream delivers sets of recommendations for each re-quest. Additionally, I define a data stream of model errors as an output of a continuous evaluation.

The stream elements are processed by operators of a query plan. To simplify writing customized RecSys queries, I in-troduce a set of logical RecSys operators that abstract from the actual physical implementation. During the query plan transformation, these operators were replaced by basis op-erators or translated to RecSys-specific physical operators. Where possible, existing basis operators were reused. The transformation of the logical query plan to physical opera-tors can be customized by transformation rules (e. g., choos-ing the best implementation depending on the input data) or controlled by query parameters given by the DSMS user. A minimal RecSys query uses the data of the ratings input stream to train a RecSys model and outputs recommenda-tion sets for each request for recommendations by the use of the trained model. Additionally, it can be extended by operators that evaluate the recommendation quality. Fig-ure 1a shows a logical query plan of a RecSys that can be used as a reference for custom queries. On the left we see the incoming and on the right the outgoing data streams as described above. The logical operators and the intermediate data flow (solid lines with arrows) are depicted in between. The RecSys operators are distinguished between learning, recommending, and evaluating operators.

The rating data stream is split by EXTRACT TEST DATA into two data streams: a stream with test data and a stream with learning data. The physical implementation of this operator is responsible for the evaluation methodology (e. g., hold out or interleaved test-then-train (ITTT); cf. [9]).
The learning data is used by TRAIN RECSYS MODEL to train a model. With every new learning tuple, this operator updates the model and outputs a copy for the subsequent operators. This operator must set the validity intervals of the outgoing models according to the following rules: (1) At every point in time, there is exactly one valid model. That means, the previous model needs to become invalid when a new model becomes valid. (2) All learning tuples that are used to train the model need to be valid in the complete va-lidity interval of the model and there must exist no learning tuple that was not used for model training that is valid in the validity interval of the model. That means, the operator must output an updated model every time a learning tuple becomes valid or invalid. A preceding WINDOW operator allows to limit the validity of the learning data by modi-fying t e . This can be useful to learn a model that focuses only on the newest ratings and to remove outdated ratings (to handle concept drifts). Additionally, it limits the ratings held in memory.
 For each request for recommendations of a user, RECOMM CANDIDATES determines a set of recommendation candi-dates. These are usually all items that have not been rated by the user. A PREDICT RATING operator uses the models to predict the rating score for each recommendation candi-date resp. for each test tuple. It ensures a temporal and de-terministic matching of models and recommendation candi-dates resp. test tuples. The RECOMMEND operator chooses the items that should be recommended (recommendation candidates with a minimal predicted rating and/or the top-K items).

The TEST PREDICTION operator implements an evalua-tion metric, e. g., RMSE. It compares the predicted and the true rating resp. the predicted and the true ranking position and aggregates an overall or moving average.
 Figure 1b shows an example of a physical query plan as a result of the transformation from the logical plan. The left column implements the evaluation, the middle column the model training, and the right column the calculation of rec-ommendations. Physical operators that belong to one logi-cal operator of Figure 1a are surrounded by a dashed rect-angle. Existing base operators are drawn with a solid line, new RecSys-specific operators ( ITTT , BRISMF , RECOMM CAND , PREDICT RATING ) with a dashed line.

The ACCESS operators at bottom of Figure 1b bind the input data streams and set the default validity intervals [ t,  X  ). The SEND operators at top provides the output data streams. The TIME WINDOW operator next to the ACCESS operator of the requests for recommendations stream sets the validity intervals to [ t, t + 1). These requests are valid for the single point in time t .

After splitting the rating data stream into a test and learn-ing stream by the ITTT operator (which implements the ITTT evaluation methodology as described below), the va-lidity of the learning data is limited by a TIME WINDOW operator, so that each tuple is valid for a certain time span (e. g., for 6 months). The BRISMF operator is an implemen-tation of the logical TRAIN RECSYS MODEL operator and implements the BRISMF algorithm [11]).

The models were joined with requests for recommenda-tions by a CROSS PRODUCT operator. This operator joins elements with overlapping time intervals. Because we ex-pect at every point in time exactly one valid model from BRISMF , each request for recommendations is joined deter-ministically with exactly one model. The RECOMM CAND operator outputs a stream element ( u, i ) as recommendation candidate for every item the requesting user has not rated yet. Each candidate is joined with a model, again with a CROSS PRODUCT operator. The PREDICT RATING oper-ator uses the model to predict a rating  X  r for the user-item pair of the candidate element and outputs it as predicted recommendation candidate ( u, i,  X  r ). A SELECT operator re-moves all candidates with a predicted rating less than R min (e. g., R min = 3 . 5) and a TOP K operator creates a list of the top K items related to the predicted rating (e. g., K = 8). The models for RECOMM CAND and for PREDICT RAT-ING do not necessarily have to be the same. If the RecSys model does not allow to determine the unrated items of a user (e. g., user and item feature matrices as the result of ma-trix factorization), the model for RECOMM CAND can be a model that solely maps users to their unrated items. There-fore, we cannot pass the model through RECOMM CAND and need to join the candidates with the other models.
In this sample query, I use the ITTT evaluation method-ology. At first, each rating tuple is used for testing and after that to train the model (cf. [9]). Because the scheduler of a DSMS controls which operator processes data and which one suspends, we cannot assure that a rating tuple is processed at first by the PREDICT RATING operator of the evaluation and after that by the BRISMF operator. However, with the help of the validity intervals, we can control which model is joined with the test tuple. The ITTT operator outputs for every rating tuple e two copies: a tuple e T as test tuple and a tuple e L as learning tuple. While e L keeps the validity interval [ t 1  X  1 , t 1 ). That means e T becomes invalid before e
L becomes valid. Due to the rules for the validity inter-vals of the models described in the last section, the validity interval of each model that used e L for training starts not before t 1 . Furthermore, the model that becomes invalid at t (and is valid at t 1  X  1) did not use e L for training. That means, that the model whose validity interval [ t 0 , t 1 t &lt; t 1 overlaps with the interval [ t 1  X  1 , t 1 ) of e the latest model that has not used e L for training. Test tuples get a predicted rating by the PREDICT RAT-ING operator. In general, this operator adds the predicted rating  X  r to the input tuple and removes the model, which was joined to the recommendation candidate resp. the test tuple. This means, for the recommendation task, PREDICT RATING outputs ( u, i,  X  r ) tuples and for the evaluation task ( u, i, r,  X  r ) tuples. Subsequently, the query calculates a mov-ing root mean square error (RMSE) for the evaluation task. A MAP operator calculates for each test tuple the square error se = ( r  X   X  r ) 2 . A TIME WINDOW operator defines the validity interval of the square error for the AGGREGATION operator: e. g., a time window that sets the validity of the square errors to 24 hours instructs the AGGREGATE oper-ator to calculate for each new error value the mean value of all values of the past 24 hours. Subsequently, the MAP operator calculates the square root of the aggregated mean and hence outputs the RMSE for the past 24 hours.
 I implemented this approach by extending the open-source DSMS Odysseus 1 [2]. Odysseus is designed to be modu-lar and extendable. It supports an editor for the SQL-like stream-based query language CQL [3], the functional query language PQL [2], and a graphical query editor, as well as a dashboard to visualize the data and a GUI to con-trol the DSMS. Additionally, developers can add new (do-main specific) languages, new operators, new data source and sink connectors, and new dashboard parts by the use of the Odysseus framework.

I evaluated the feasibility of this approach by comparing the overall RMSE after each tested tuple for the Movie-Lens dataset with the results of the stream mining frame-work Massive Online Analysis (MOA) [5]. To make the re-sults comparable, I added the MOA implementation of the BRISMF algorithm [11], removed the WINDOW operator that precedes BRISMF , and calculated the overall RMSE af-ter each tested tuple with ITTT. The error values are exactly the same as those of MOA, which shows that the matching of learning data, models, and test data as well as the imple-mentation of the evaluation operate correctly.
While a lot of research in the field of RecSys focuses on developing new online algorithms (e. g., [11]), our approach has the objective to incorporate these algorithms to a DSMS to benefit from its abilities for processing streaming data. Closely related is StreamRec [7]. It uses the stream process-ing system Microsoft StreamInsight to calculate item simi-larities with basic stream operators. In contrast to our ap-proach, they do not present a generic usage of a DSMS as a RecSys. They show an implementation for item similarity.
There are some publications about stream-based systems that implement RecSys functions. For example, Ali et al. [1] propose an implementation of a distributed CF algorithm with Apache Storm . MOA [5] implements algorithms for stream-based RecSys. In contrast to our approach, they do not use an application-independent DSMS that processes stream elements with operators of a query plan with the advantages described above.
Our preliminary research on incorporating RecSys func-tions in a DSMS shows the feasibility as well as some chal-http://odysseus.informatik.uni-oldenburg.de/ lenges and prospects of this approach. It has the potential to benefit from well studied features of DSMSs. The future work focuses on the following aspects:  X  Studying the implementation of other methods for recom-mending (e. g., other learning algorithms) and evaluation (e. g., ranking-based) with DSMS operators. This includes considering additional data sources, e. g., context data.  X  Studying optimizations of the operator-based processing.  X  Proving the suitability and flexibility of this approach in different settings.  X  Evaluating and comparing of recommendation quality, la-tency, throughput, and memory usage in a real-world set-ting, e. g., in a Living Lab like Newsreel. 2 Our approach allows to remove older ratings by the WIN-DOW operator. Other RecSys approaches use for example a gradient decay of learning tuples, a temporal bias [10], or a reservoir that holds samples of the learning data [8]. An important aspect of future work is to develop special imple-mentations of the WINDOW operator to achieve these be-haviours and to allow to compose these with different model learners. [1] M. Ali, C. C. Johnson, and A. K. Tang. Parallel [2] H.-J. Appelrath, D. Geesen, M. Grawunder, [3] A. Arasu, S. Babu, and J. Widom. The CQL [4] B. Babcock, S. Babu, M. Datar, R. Motwani, and [5] A. Bifet, G. Holmes, R. Kirkby, and B. Pfahringer. [6] P. G. Campos, F. D  X  X ez, and I. Cantador. Time-aware [7] B. Chandramouli, J. J. Levandoski, A. Eldawy, and [8] E. Diaz-Aviles, L. Drumond, L. Schmidt-Thieme, and [9] J. Gama, I. Zliobaite, A. Biefet, M. Pechenizkiy, and [10] Y. Koren. Collaborative filtering with temporal [11] G. Tak  X acs, I. Pil  X aszy, B. N  X emeth, and D. Tikk. http://www.clef-neewsreel.org/
