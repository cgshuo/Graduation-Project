 This paper revisits the analysis of annotation propagation from source databases to views defined in terms of conjunc-tive ( SPJ ) queries. Given a source database D ,an SPJ query Q ,theview Q ( D ) and a tuple  X  V in the view, the view (resp. source ) side-effect problem is to find a minimal set  X  D of tuples such that the deletion of  X  D from D re-sults in the deletion of  X  V from Q ( D ) while minimizing the side effects on the view (resp. the source). A third problem, referred to as the annotation placement problem, is to find a single base tuple  X  D such that annotation in a field of  X  D propagates to  X  V while minimizing the propagation to other fields in the view Q ( D ). These are important for data provenance and the management of view updates. However important, these problems are unfortunately NP -hard for most subclasses of SPJ views [5].

To make the annotation propagation analysis feasible in practice, we propose a key preserving condition on SPJ views, which requires that the projection fields of an SPJ view Q retain a key of each base relation involved in Q . While this condition is less restrictive than other propos-als [11, 14], it often simplifies the annotation propagation analysis. Indeed, for key-preserving SPJ views the annota-tion placement problem coincides with the view side-effect problem, and the view and source side-effect problems be-come tractable. In addition we generalize the setting of [5] by allowing  X  V to be a group of tuples to be deleted, and investigate the insertion of tuples to the view. We show that group updates make the analysis harder: these prob-lems become NP -hard for several subclasses of SPJ views. We also show that for SPJ views the source and view side-effect problems are NP -hard for single-tuple insertion, but are tractable for some subclasses of SPJ for group insertions, in the presence or in the absence of the key preservation con-dition.
 Categories and Subject Descriptors: F.2 [ Analysis of Copyright 2006 ACM 1-59593-433-2/06/0011 ... $ 5.00. Algorithms and Problem Complexity ]: Miscellaneous; H.2.4 [ Database Management ]: Systems  X  Relational Databases General Terms: Theory, Algorithms Keywords: Annotations, Provenance, View updates.
It is common to find real-world data dirty [17]. To cope with this, corrections or annotations of errors are often added to the data by experts. This information is essen-tial to the quality (accuracy and timeliness) of the data, and should be carried over along with the regular data when the data is migrated, transformed or integrated. With this comes the need for studying annotation propagation, i.e., how annotations propagate through migration, trans-formation or integration processes. The analysis of anno-tation propagation has proved important in data prove-nance [5, 6] (aka. lineage [10, 9]) for tracing the origin of a piece of data, data cleaning [17] for improving data qual-ity, and in security [19] for enforcing access control, among other things.

In many applications data migration, transformation or integration can be expressed as views defined in terms of conjunctive queries, i.e., SPJ queries defined in terms of the selection, projection, join and renaming operators of the relational algebra. The analysis of annotation propagation can thus be formalized as follows: We consider annotations to be pieces of information associated with a location (tu-ple) in a relation. More formally, a triple ( R, t, A ) indicates that the annotation A is associated with tuple t in rela-tion R . Given a source database D and an SPJ query Q , annotations are propagated to the view V = Q ( D )inthe straightforward way (see [5] for more details). The asso-ciated problems addressed in this paper are the following: Given a tuple  X  V in the view,  X  the view side-effect problem is to find a set  X  D of tuples in D such that Q ( D )  X  Q ( D  X   X  D )isa minimal set containing  X  V and in addition, among all such source updates,  X  D is minimal ; intuitively, this means that the deletion of  X  D from the source leads to the removal of  X  V from the view with minimal view side effect; in other words,  X  D indicates how the tuple  X  V gets into the view, and the problem is to identify a minimal set  X  D of locations (tuples) in the source such that annotations in those places propagate to a minimal number of tuples in the view including  X  V ; (a) Table (c) View Q 1 =  X  the source side-effect problem is to find a minimal set  X  D of tuples in D such that Q ( D )  X  Q ( D  X   X  D )contains X  V ; intuitively, it is to simply find a minimal set of locations (tuples) in the source such that the desired annotation in the view can be obtained by annotating in those places in the source, regardless of side effects on the view; as opposed to the previous problem, the source side-effect problem does not require Q ( D )  X  Q ( D  X   X  D ) to be minimal, while it tends to incur minimal changes to the original source data;  X  the annotation placement problem is to find, given a field (location) in the tuple  X  V ,a single tuple  X  D in D such that annotation in a field of  X  D propagates to a minimal number of tuples (locations) in the view including  X  V ;in other words, when some error or other annotation is known for the tuple in  X  V , the problem is to find the corresponding tuple (location) in the source D to concretely annotate such that the annotation propagates to the view.
 Example 1.1: To illustrate these decision problems, consider a database D consisting of two relations, PC( PCName,Conf ) and Conf( Conf, Topic , # Paper ) (with keys underlined), and an SPJ query (view definition) Q =  X  PCName,Topic ( PC Conf ). An instance of each relation and the view Q 1 ( D ) are shown in Fig. 1(a)-(c) (ignore Fig. 1(d) for now). Suppose that John is not a database researcher and thus the tuple (John, DB) in the view Q 1 ( D ) is an error, i.e.,  X  V = { (John, DB) } .Wewant to find locations (tuple fields) in the base relations of D to annotate the error information such that the annotations propagate to the fields in the view tuple  X  V via Q in other words, we want to find tuples in D to remove such that their removal leads to the deletion of the error  X  V . The three decision problems described above impose different conditions on how to do this. (1) View-side effect problem: There are multiple ways to remove tuples in D in order to delete  X  V from the view. Note that D tuples related to  X  V , i.e., those tuples with matching values in  X  V ,are (John, CIKM), (John, SIGMOD), (CIKM, DB, 30) and (SIGMOD, DB, 30) . While removing certain combinations of these tuples leads to the removal of  X  V , we want to find a combination  X  D such that the removal of  X  D incurs minimal side effect on the view, i.e., it deletes  X  V and a least number of other tuples from the view, and furthermore,  X  D contains the least number of tuples. In other words, we want to find and annotate  X  D such that all the fields of the view tuple  X  V will be annotated by propagation of the annotations in  X  D via Q 1 .Onesolution is to remove { (John, CIKM), (John SIGMOD) } from the PC table, and the other is by removing (John, CIKM) from PC and (SIGMOD, DB, 30) from Conf. Note that none of the solutions is side-effect free: the first solution, for example, also results in the deletion of (John, IR) from the view. (2) Source side-effect problem: The difference from (1) is that we do not care about the view side-effect when we search for a minimal set  X  D of tuples in D to delete. Thus in this case, removing { (SIGMOD, DB, 30), (CIKM, DB, 30) from Conf is also a solution although it incurs more severe view side effects than the solutions given above. (3) Annotation placement problem: Suppose that the infor-mation  X  X ohn is not a database researcher X  is to be anno-tated on  X  V . We want to find a single tuple  X  D in the database D to annotate such that the annotation propa-gates to  X  V and a least number of other tuples in the view Q ( D ). Here, annotating  X  D = (John, SIGMOD) is the de-sired solution with zero side effect.
 Prior work. Although there has been a host of work on data provenance [4, 5, 6, 9, 10, 19], the complexity bounds for the decision problems associated with annotation prop-agation analysis are only studied in [5, 19], in which it is shown that the analysis is in general beyond reach in prac-tice. Indeed, the view and source side-effect problems are NP-hard for views expressed in SPJ andinfactinitssub-class PJ [5], and the annotation placement problem is NP -hard for PJ and SPJ views [19]. Although these problems are also of interest to the management of view updates, their complexity is not addressed in that line of work and the only complexity results known in the study of view updates con-cern finding minimal complements of views [8, 15], a problem quite different from the analysis of annotation propagation. Contributions. To this end we identify a practical con-dition under which th e analysis of annotation propagation becomes feasible. The condition, referred to as the key-preservation condition, requires that an SPJ view Q retains a key of every base relation involved in the definition of Q . In other words, the primary keys of all the base relations in-volved in Q are included as distinct attributes in the projec-tion fields of Q . Thisislessrestrictivethanotherproposals for restricting view definitions [11, 14], and many views for data transformation or integration found in practice can be naturally modified to be key preserving, by extending the projection-attribute list to include the primary keys.
We focus on fundamental issues in connection with key-preserving SPJ views: we give a full treatment of the deci-sion problems associated with annotation propagation, and establish a variety of complexity results for these problems.
Our first contribution consists of complexity bounds for the analysis of annotation propagation for key-preserving SPJ views. These results tell us that the key preservation condition simplifies the annotation propagation problems studied in [5, 19]. We show that under the key preservation condition, the view side-effect problem and the annotation placement problem coincide, and moreover, the view and source side-effect problems (and thus the annotation place-ment problem) all become tractable for SPJ views.

Our second contribution is an investigation of the impact of group updates on the analysis of annotation propagation. Here we allow the given view update  X  V to include multiple tuples to be deleted from the view, rather than a single tuple as stated above. In this setting the propagation analysis is to identify propagation of multiple annotations in the view. We show that group updates complicate the analysis: all the three problems become NP -hard for views defined in terms of join, i.e., these problems are intractable for SJ , PJ SPJ views while they remain tractable for SP views. To our knowledge these are among the first complexity results for group view updates.

Our third contribution consists of complexity results for the view and source side-effect problems when the given  X  V is a set of tuples to be inserted instead of deleted. The mo-tivation for studying this is that one often wants to know, when new tuples along with annotations are inserted into the view, how the annotations should be propagated back to the source (aka. feedback loop [17]). We study these problems both in the presence and in the absence of the key preserva-tion condition. We show that for PJ (and thus SPJ )views, the view and source side-effect problems are already NP -hard for single-tuple insertion, and these problems are in PTIME for SP and SJ views for group insertions, in the presence and in the absence of the key preservation condi-tion. To our knowledge no previous work has established complexity results for these problems for view insertions.
Our main conclusions are: (a) key preservation simplifies the propagation analysis of annotations and view updates, to an extent; (b) group updates make our lives harder than a single-tuple update; and (c) view insertion does not behave as well as its deletion counterpart for key preserving views.
Taken together, these provide a dichotomy in the com-plexity of the analysis of annotation propagation for all sub-classes of SPJ views, and for single-tuple and group view insertions and deletions . These complexity results are im-portant not only for the propagation analysis of annotations; they are also useful for the study of classical view update problems, for which, to our knowledge, few complexity re-sults have been established by previous work.

It should be mentioned that the key preservation condi-tion was first studied in [7] for xml view updates. However, the decision problems investigated in [7] are different from thedecisionproblemsconsideredinthispaper.
 Organization. The remainder of the paper is organized as follows. Section 2 presents the key-preservation condition. Section 3 revisits the annotation propagation analysis of [5, 19] under the key preservation condition, and establishes complexity results for group deletions. Section 4 investigates these problems for view insertions. Related work is discussed in Section 5, followed by a conclusion in Section 6. All proofs of the complexity results are included in the paper.
In this section we define the notion of key preservation and show that under this condition, the view side-effect problem and the annotation placement problem coincide.
 SPJ queries. Let R =( R 1 , ..., R n ) be a relational schema. An SPJ query on databases of R is an expression defined in terms of the selection (  X  ), projection (  X  ), join ( ) and renaming (  X  ) operators in the relational algebra, and with relation names R 1 ,...,R n in R as well as con-stants. It is known that the class of satisfiable SPJ queries is equivalent to conjunctive queries as well as SPC queries defined in terms of the selection, projection and cross prod-uct (  X  ) operators (see, e.g., [1]). Thus in the sequel we shall use SPJ and SPC interchangeably.

We also study various subclasses of SPJ , denoted by list-ing the operators supported: SP , SJ ,and PJ (the renam-ing operator is included in all subclasses by default without listing it explicitly). For instance, PJ is the class of queries defined with the projection, join and renaming operators. For example, the view given in Fig. 1(c) is a PJ view. Key preservation. Consider Q ( R 1 ,...,R k ), an SPJ query that takes the base relations R 1 ,...,R k (repeats permitted) of
R as input. From these base relation schemas and the definition of Q , it is straightforward to derive the schema of the output relation of Q , denoted by schm ( Q ).

We say that Q is key-preserving if all primary key at-tributes (with possible renaming) of each occurrence of the base relations involved in Q are included in the projection fields of Q .
 Example 2.1: The query Q 1 (Fig. 1(c)) given in Exam-ple 1.1 can be extended such that it is key-preserving as sponding view for Q 2 ( D ) is given in Fig. 1(d).
Observe that queries without projection are always key-preserving.

We remark that key-preservation is far less restrictive than other conditions on view definitions proposed in earlier work [11, 14]. Indeed, these earlier proposals ask for joins to be defined on foreign keys, join attributes to be preserved in schm ( Q ), join to form a single tree, and/or for selection conditions not to include attribute comparison, etc. The equivalence of the view side-effect problem and the annotation placement problem. For a key-preserving SPJ query Q ( R 1 ,...,R k ), the two problems co-incide. To see this, consider a source database D and the view V = Q ( D ). For any tuple t  X  V ,andforeachoc-currence of each base relation R i , t retains a key of the R relation. Hence one can identify a unique tuple t i from each occurrence of the R i relation, such that t in the view is constructed from these t i  X  X  via Q . Thus as will be seen in Section 3, for the view side-effect problem, to delete t from V it suffices to remove a single t i from some R i relation. In other words, to remove a tuple  X  V from V it is always possible to find a single tuple to remove from the source. Equivalently, for the annotation placement problem, to an-notate a single field in t , one can always identify a single t such that annotation at a field in t i propagates to the field in t . This allows us to consider only the view side-effect and source side-effect problem in the sequel.
 Example 2.2: The deletion analysis of Example 1.1 is sim-plified for the key-preserving view of Example 2.1. Consider the deletion  X  V = { (John, CIKM, DB) } from Q 2 ( D ). (1) View-side effect problem: Due to the key preservation prop-erty of Q 2 , it is obvious that the deletion can be performed by deleting either (John, CIKM) from PC or (CIKM, DB, 30) from Conf. Here { (John, CIKM) } is the minimal dele-tion with the minimal view side-effect. Note that the key preservation property also helps check the view side-effect by finding the occurrences of key values of deleted relation tuples in the view. (2) Source side-effect problem: Similar to (1), we can easily determine that the solution is either (John, CIKM) } or { (CIKM, database, 30) } . (3) Annotation placement problem: Under key preservation, the problem is the same as (1), and the solution is { (John, CIKM) } . Difference between insertions and deletions. To insert a tuple t into V , one can identify the key k i of the tuple t that needs to be inserted into each occurrence of each R i relation involved. As will be seen in Section 4, based on k one can either identify a tuple t i already in the R i relation with k i as its key, or otherwise, construct a tuple t i carrying k as its key and insert it into the R i relation. Observe that while view-tuple deletion can always be carried out when side effect is allowed, in contrast, it is not always doable to insert a tuple into view in the presence of keys even if side effect is allowed, as illustrated below.
 Example 2.3: Consider another key preserving view Q 3 = PC Conf in the setting of Example 1.1, and the insertion of the tuple (Kate, SIGMOD, DB, 35) into the view Q 3 ( D ). At first glance, it seems that this insertion can be carried out by inserting (Kate, SIGMOD) into table PC and (SIGMOD, DB, 35) into table Conf. However, in fact the insertion is not possible: the insertion (SIGMOD, DB, 35) has to be rejected since taken together with (SIGMOD, DB, 30) it violates the key in the relation Conf. 1
In this section we investigate the view and source side-effect problems for key-preserving SPJ views, in Sections 3.1 and 3.2, respectively, for single-tuple and group deletions. 3.1 The View Side-Effect Problem
Given a view deletion  X  V , the view side effect problem is to find a minimal set of source tuples to delete so that other view tuples (not in  X  V ) deleted are minimized. The table below gives the complexity of the problem for various subclasses of SPJ queries for single-tuple or group deletions.
Query class Complexity of view side-effect problem SPJ ( PJ , SJ ) PTIME NP -hard
It is known [5] that without key preservation the view side-effect problem for single deletion on a PJ view is NP hard. In contrast, the problem becomes tractable for key preserving SPJ views. This shows that the key preservation condition simplifies the analysis of annotation propagation. Theorem 3.1: The view side-effect problem is in PTIME for single-tuple deletion for SPJ (and thus PJ and SJ )views under key preservation.
 Proof: It suffices to give a proof for SPJ views. Let R = {
R 1 ,..., R n } be a relational schema, Q a key-preserving SPJ query, D an instance of the schema R ,and X  V consist of thesingletuple t to be deleted from the view Q ( D ).
Due to the key-preservation, we can associate with t (nec-essarily unique) tuples s i in the base relations R i appearing in Q , such that s i and t have the same key for this relation. In order to delete t from Q ( D ) is suffices to delete a single
Figure 2: Illustration of the proof of Theorem 3.2. such s i from its base relation R i . Any such deletion obvi-ously results in a  X  D of minimal size since  X  D consists of a single tuple only, as illustrated in Example 2.2.
For  X  D to be a solution for the view side-effect problem, we need to find tuple s i that leads to the minimal number of side-effects. Let S i be the set of tuples in Q ( D ) carrying the key of s i (in R i ). Note that computing S requires only a linear scan over the view Q ( D ). Clearly, the size of S i determines the number of side-effects obtained when choosing  X  D = { s i } .Let s be the tuple s i such that its corresponding S i is of minimal size. Then  X  D = { s a solution. It is clear that s can be found in PTIME .
The problem, however, becomes NP -hard if we consider group deletions. This tells us that group updates may com-plicate the analysis of annotation propagation. It should be remarked that the complexity of group view deletions is not considered in [5, 19].
 Theorem 3.2: The view side-effect problem is NP -hard for group deletions for SPJ , PJ and SJ views under key preservation.
 Proof: It suffices to show that the problem is NP -hard for views defined in terms of join only, by reduction from the minimal set cover problem. An instance of the minimal set cover problem consists of a collection C of subsets of a finite set S ; it is to find a subset C  X  C such that every element in S belongs to at least one member of C and moreover, | C | is minimal. This problem is NP -complete (cf. [12]).
Given S and C , we define an instance of the view side-effect problem. Let S = { x i | i  X  [1 ,n ] } and C = { c [1 ,k ] } . We construct two base tables R and R S ,ajoinview and a group view deletion, as follows.
 Source database. We define two base relations R and R S .  X  R ( A ), where A is the key and is to hold a number in [1 ,k ]. Initially, R ( A )contains k = | C | tuples { (1) , (2) ,..., ( k ) that represent the index of k subsets.  X 
R S ( j, A 1 ,...,A k ), where all the columns are the key. We encode each element in S with tuples in R S as follows. For each x i in S ,let T i be the collection of all the subsets in C that contain x i . We assume w.l.o.g. that T i =  X  (other-wise there is no solution for the minimal set cover problem). Enumerate the elements of T i as ( c i 1 ,...,c i n i ). We gener-ate a list of size k from T i , L i = &lt;i 1 ,...,i n i ,...,i replacing c i j with its index i j and appending ( k  X  X  T at the end of the list (to make the size of the list to be k ).
If | S | &gt;k , then we generate | S | tuples by adding one number in [1 , | S | ] at the beginning of each list L i .Otherwise, we generate k + 1 tuples by adding one number in [1 , | S the beginning of each list L i and generate k +1  X  X  S | tuples by adding numbers [ | S | +1 ,k +1] to L n .Thustable R S initially contains =max {| S | ,k +1 } tuples.
Let the database instance D be the collection of all tuples defined above. The construction is illustrated in Fig. 2 for S = { a, b, c, d } and C = { c 1 = { a, b } ,c 2 = { a, d { b, c } ,c 4 = { b, c, d }} .
 View. We define a view in terms of query Q = R S  X  1 ( R ) Initially, Q ( D ) consists of view tuples, which are the same as those in the relation R S .

Obviously, the view defined as above is key-preserving.  X 
View deletion. The group deletion  X  V is to remove all tuples in the view Q ( D ).

The view side-effect problem is to find a smallest set of the tuples from R and R S so that  X  V is deleted without side-effect. For example, suppose that we want to delete all tuples in the view V shown in Fig. 2. For each view tuple t , we indicate with colors which tuples (or c i  X  X ) in R should be deleted in order to remove t from V . When all tuples are to be removed from V , i.e.,  X  V = V , then clearly deleting 1and4from R achieves this goal (each tuple in V contains either 1 or 4). Hence,  X  R = { 1 , 4 } and C = { c 1 ,c 4 minimal cover of S .

More formally, we next verify that the construction above is indeed a reduction from the minimum set cover problem. First suppose that C is a minimal cover of S . We define  X  D such that it consists of deletion of tuples { ( i 1 ) ,..., ( i from R ,where i j is the index of subset c j  X  C .Inorderto delete a tuple t in  X  V , we delete either t [ R S ](itscomponent in R S ) or one of its components in R .Since C is a cover of S , at least one of components of t in R is in  X  D .Hence,it is clear that Q ( D  X   X  D )= Q ( D )  X   X  V =  X  .Furthermore,  X  D is minimal since (1) although deleting all the tuples from table R S suffices to delete  X  V , it is not a minimal solution since | C | X  k (and by construction, &gt;k ), and (2) C is a minimal cover of S . Conversely, suppose that  X  D is a solution to the view side-effect problem. Then as discussed above  X  D will be only composed of tuples in R . Let C be the subset of C such that an element c j of C is in C if and only if  X  D involves deletion of the tuple ( j ) from relation R .Toseethat C is a cover of S ,notethat Q ( D  X   X  D )= Q ( D )  X   X  V =  X  , and thus for each x i  X  some set c i j is in C .Moreover, C is minimal since  X  D is minimal.

Fortunately, the problem remains tractable for SP views and group deletions.
 Theorem 3.3: The view side-effect problem is in PTIME for group deletions for SP views under key preservation. Proof: Let  X  V be a group deletion. It is easy to see that we can apply a simple modification of the algorithm given in the proof of Theorem 3.1 for each tuple in  X  V independently. Indeed, for each tuple t  X   X  V we have to delete a single distinct tuple s t in the base relation appearing in the SP query Q .Let X  D consist of the base relation tuples s t for t  X   X  V . Clearly,  X  D is of minimal size. Due to the key-preservation of Q , the deletion of  X  D from D will only delete the tuples in  X  V from the view Q ( D ). Hence,  X  D is indeed a solution for the view side-effect problem. 3.2 The Source Side-Effect Problem
Given a view deletion  X  V , the source side-effect problem is to find a minimal set of source tuples to be deleted so that the view tuples in  X  V are deleted. Although the source side-effect problem relaxes the requirement of minimizing view side-effects in the view side-effect problem, unfortunately the problem does not become easier, and the complexity remains the same as its view side-effect counterpart. The table below gives the complexity of determining the mini-mum source deletions for various subclasses of SPJ queries for single-tuple or group deletions.

Query class Complexity of source side effect problem SPJ ( SJ , PJ ) PTIME NP -hard
It has been shown in [5] that the source side-effect prob-lem is already NP -hard for single deletion for PJ view. The problem for single deletion becomes polynomial-time solv-able when the key preservation condition is imposed. This again verifies our observation that the key-preservation con-dition makes our lives easier.
 Theorem 3.4: The source side-effect problem is in PTIME for single-tuple deletion for PJ , SJ and SPJ views under key preservation.
 Proof: It suffices to give a proof for SPJ views. We remark that the PTIME algorithm presented in the proof of The-orem 3.1 already gives a solution for the source side-effect problem. Indeed, it is observed there that the computed up-date  X  D is of minimal size. We can therefore use the same algorithm for the source side-effect problem, except that we do not have to perform the steps for selecting the update which minimizes the number of view side-effects.

In fact the proof of Theorem 3.3 also works for the source side-effect problem. Hence, we have the following: Theorem 3.5: The source side-effect problem is in PTIME for group deletions for SP views under key preservation.
However, the problem for group deletions remains NP -hard, as its view side-effect counterpart. Again this problem has not been considered by previous work.
 Theorem 3.6: The source side-effect problem is NP -hard for group deletions for PJ , SJ and SPJ views under key preservation.
 Proof: The proof of Theorem 3.2 is applicable here.
We next investigate the view and source side-effect prob-lems for insertions, i.e., when the view update  X  V consists of tuples to be inserted into the view. We study these two problems in Section 4.1 and 4.2 respectively, in the presence and in the absence of the key preservation condition, and for both single-tuple or group insertions. 4.1 The View Side-Effect Problem
We first study the view side-effect problem in the absence of key-preserving condition: given a source database D ,a query Q ,theview V = Q ( D )andaset X  V of tuples, it is to find a minimal set  X  D of tuples such that Q ( D )  X  Q ( D  X  D )contains X  V and is minimal, i.e., the insertion of  X  D Figure 3: Illustration of the NP -hardness proof of Theorem 4.1. into the source D gets  X  V into the view while incurring minimal side effect on the view. This problem turns out to be nontrivial: it is already intractable when Q is a PJ (and thus SPJ ) view, even if  X  V consists of a single tuple. Theorem 4.1: The view side-effect problem is NP -hard for PJ views and single-tuple insertion, when the PJ views are not necessarily key preserving.
 Proof: We prove the NP -hardness by reduction from the non-tautology problem. An instance of the latter problem is  X  = C 1  X  X  X  X  X  C n ,whereallthevariablesin  X  are x 1 ,...,x C j is of the form l j 1  X  l j 2  X  l j 3 ,and l i j is either x s  X  [1 ,k ]. The problem is to determine whether there is a truth assignment such that  X  is false, i.e.,  X  is not valid. This problem is known to be NP -complete (cf. [12]).
Given  X  , we define a source database D ,a PJ view Q ,and a single tuple  X  V to be inserted into the view V = Q ( D ), such that  X  is not valid iff there exists a minimal  X  D that is side-effect free , i.e., Q ( X  D  X  D )= V  X   X  V . Source D . The database consists of four base relations, R , R  X  , R E ,and R T defined as follows.  X 
R ( A, B ), where intuitively, A is to hold a number in [1 ,k ] encoding a variable, and B is a truth value ( T or F ). That is, R ( A, B ) is to encode a truth assignment for  X  . Initially R ( A, B ) consists of a single tuple (0 ,T ).  X 
R  X  ( C, j, j 1 ,X 1 ,j 2 ,X 2 ,j 3 ,X 3 )inwhichforeach C l such that l j i is s if l j i = x s or l j i =  X  x s , X i and X i is F if l j i =  X  x s . Each of these tuples codes a clause in  X  . A special tuple ( T, 0 , 0 ,T, 0 ,T, 0 ,T )isalsoin R  X 
R E ( e 1 ,e 2 ,...,e k ), in which e i is to code i in [1 ,k ]. Ini-tially, R E consists of a single special tuple (0 ,..., 0).  X  R T ( C, D, E ) consisting of the four tuples ( T,T,T ), ( T, F,F ), ( F, T, F ), and ( F, F, T ). That is, the E -attribute is T if the other attributes are equal, and is F otherwise. View. We define a PJ query Q = V 0 V 1 V 2 as follows:  X 
V 0 =  X  E (  X  f 1 ( R )  X  f 2 ( R ) R T ), where  X  f 1 to C and  X  f 2 renames B to D . where  X  f i renames A to j i and B to X i for i =1 , 2 , 3. Intu-itively, C holds if and only if one of the C j  X  X  is true.  X  renames A to e i for i  X  [1 ,k ].
 Initially V = Q ( D ) has a single tuple ( T, 0 ,..., 0). View insert. We define  X  V to consist of a single tuple ( T, 0 , 0 , 0 , 0 , 1 ,...,k )into V .

The construction above is illustrated in Fig. 3. In this figure, we have depicted the base relations R , R  X  , R E R
T as well as the intermediate view relations V 0 , V 1 and V The final view V 0 V 1 V 2 is shown at the bottom right. The tuple inserted in the view, as well as the tuples to be inserted in the base relations R and R E are indicated by the bold rectangles. As we will show formally below, the key observation is that a zero side-effect update exists as long as V 1 only contains the initial tuple (0 , 0 , 0 , 0). This in its turn is equivalent to saying that  X  is a non-tautology.
We next verify that there is a minimal, side-effect free  X  D iff  X  is not a tautology. First, if  X  is not a tautology, then there is a truth assignment  X  such that  X  is false, and thus C j is false w.r.t.  X  for all j  X  [1 ,n ]. We define  X  D based on  X  as follows: for i  X  [1 ,k ], we insert ( i, T )into R ( A, B ) iff  X  ( x i )= T ,andinsert( i, F )iff  X  ( x i )= F .Wealsoinsert (1 ,...,k )into R E . Then obviously Q ( X  D  X  D )= V  X   X  V . To see that  X  D is minimal, note that for any side-effect free  X  D , X  D must contain k tuples of the form ( i, X i )tobe inserted into R for i  X  [1 ,k ], where X i is either T or F ,as well as a tuple (1 ,...,k )tobeinsertedinto R E .Thusthe  X  D given above is already minimal.

Conversely, suppose that there is a minimal, side-effect free  X  D . Then again  X  D must insert (1 ,...,k )into R E in addition  X  D contains a unique tuple of the form ( i, X ) to be inserted into the base relation R for each i  X  [1 ,k ], where X is either T or F .Toseewhy( i, X ) is unique, note that if for some i both ( i, T )and( i, F )arein X  D ,then a tuple of the form ( F, 0 , 0 , 0 , 0 , 1 ,...,k ) would also be in Q ( D  X   X  D ) by the definition of Q (and in particular V R
T ), a contradiction. Hence the instance of R is a valid truth assignment for  X  .Since X  D is side-effect free, V 1 remain (0 , 0 , 0 , 0) after  X  D is inserted, i.e., C j will remain false for each j  X  [1 ,n ]. Thus  X  is not a tautology. Worse, key preservation does not make our lives easier: Theorem 4.2: The view side-effect problem is NP -hard for key preserving PJ views and single-tuple insertion. Proof: The proof is similar to that of Theorem 4.1, by re-duction from the non-tautology problem.
 Source D . The database consists of three base relations, R , R  X  and R E .Here R ( A, B )and R E ( e 1 ,e 2 ,...,e the same as defined in the proof of Theorem 4.1, with A and e 1 ,...,e k as the key of R and R E , respectively. The relation R  X  is defined to be R  X  ( j, j 1 ,X 1 ,j 2 ,X 2 which j is the key, and j, j 1 ,X 1 ,j 2 ,X 2 ,j 3 ,X 3 are the same as given in the proof of Theorem 4.1.
 View. We define a PJ query Q = V 1  X  V 2 ,where V 1 and V are the same as given in the proof of Theorem 4.1. Initially Figure 4: Illustration of the PTIME algorithm in the proof of Theorem 4.3.
 V = Q ( D ) has a single tuple (0 ,..., 0) (k+4 0 X  X ). It is easy to verify that Q is key preserving.
 View insert. We define  X  V to consist of a single tuple (0 , 0 , 0 , 0 , 1 ,...,k )tobeinsertedinto V .
 We next verify that there is a minimal, side-effect free  X  D iff  X  is not a tautology. When  X  is not a tautology, a minimal, side-effect free  X  D can be constructed as described in the proof of Theorem 4.1. Conversely, suppose that there is a minimal, side-effect free  X  D .Then X  D must insert (1 ,...,k )into R E ,andinsertsa unique tuple of the form ( i, X )into R for each i  X  [1 ,k ], where X is either T or F . Note that if for some i both ( i, T )and( i, F )arein X  D , then these tuples violate the constraint that A is a key of R . Thus the instance of R is a truth assignment for  X  .The rest of the argument is the same as that of Theorem 4.1. The good news is that the problem becomes tractable for SP and SJ views and for group insertions , in the presence and in the absence of key preservation.
 Theorem 4.3: The view side-effect problem is in PTIME for (a) SP views and (b) SJ views, for group insertions, no matter whether the views are key-preserving or not. Proof: The proof is constructive. For each of the cases we provide a PTIME algorithm which either halts (indicating that no solution exists) or outputs a solution for the view side-effect problem. Note that some insertions on the view may not be doable, as demonstrated in Example 2.3. Key-preserving SP views. Let D be a source database, Q a key-preserving SP query, and  X  V be a group update consisting of insertions only. We may assume that Q is of the form  X  B 1 ,...,B n (  X  C (  X  f ( R ))) where R is one of the relations in the schema R .Ifwedenoteby A 1 ,...,A k the primary key attributes of R , w.l.o.g., then by the key-preservation of Q it is the case that { A 1 ,...,A k } X  X  B 1 ,...,B n } .
For each tuple t  X   X  V , we define its tuple template  X  t = in the remaining attributes in t , and finally, z consists of distinct variables for each remaining attribute in schm ( R ).
The PTIME algorithm for the view side-effect problem performs the following steps. We illustrate some of them in Fig. 4 for the base relation R (with A as its key), SP view Q =  X  AB (  X  C = X  c ( R )) and updates  X  V 1 , X  V 2 and  X  V
First, we check whether  X  V contains different tuples with the same key attributes. If so, then clearly no solution for the problem exists, and the algorithm halts. See e.g., for  X  V 2 in Fig. 4 (the gray color indicates the conflict: it is not possible to insert two distinct tuples with the same key e ).
Otherwise, the algorithm continues by testing for each tuple t  X   X  V , whether there already exists a tuple s in R with the same key attributes, i.e., s [ A 1 ,...,A k ]= a .If this happens, then  X  t should be equal to s .Ifoneofthe b attributes of t differs from those in s , then no solution exists and the algorithms halts. This happens e.g., for  X  V 1 Fig. 4 (the gray color indicates the conflict).

Moreover, in order to get t inserted into the view, a neces-sary condition is that  X  C ( s ) holds. If not, then no solution for the group update can be found and, again, the algorithm halts. Otherwise, we can safely remove all t from  X  V whose key already appears in R .

Finally, for each remaining tuple t in  X  V we need to in-stantiate the variables in its template  X  t . More specifically, we need to instantiate these variable such that the resulting tuple (this will be a tuple to be added to R ) satisfies the se-lection condition C in Q .Because Q does not contain joins, wecantreateachtuplein X  V independently.

We recall that C is a conjunction of equalities of the form x = y ,where x, y are either attributes or constants. By plugging in C the constants available in  X  t , i.e., those in a and b , we obtain a new conjunction C (with possibly less variables). By constructing a dependency graph G between the constants and variables in C and computing its transi-tive closure G , one can then easily check whether a desired instantiation of the variables exists. Indeed, if there exists an edge ( a, b )  X  G with a, b two different constants, then no instantiation exists. We say that C is conflicting. Con-sequently, in this case no solution of the view side-effect problem exists and the algorithm halts. Otherwise, one as-signs to all the variables in the same connected component in G the same constant value (i.e., the value of the unique constant in this component, or an arbitrary one if the con-nected component consists of variables only). Variables not appearing in C can be instantiated arbitrarily. The resulting tuple is then added to  X  D .

The algorithm successfully computes a solution for the view side-effect problem if for each tuple in  X  V (modulo the ones whose key already appeared in R ) a tuple is added to  X  D . In all other cases, no solution exists. For example, in Fig. 4 a solution for  X  V 3 exists. First, the tuple in  X  V is expanded to a template (introducing the variable z ), then this variable is instantiated using the condition C = X  c of the selection predicate of Q .

We remark that in case a solution exists,  X  D computed by the above algorithm is of minimal size. Indeed, for each new key in  X  V , a single tuple with this key is added to  X  D .Since Q is key-preserving, this is the minimal number of tuples required for any solution. Moreover, it is easy to see that this solution is side-effect free, and hence is also minimal on the view side.
 The algorithm runs clearly in polynomial time.
 Arbitrary SP views. Let us now drop the key-preserving condition on the view Q . We use the same approach as in the key-preserving case, except that we do not have to check for conflicting keys. However, even in the absence of key-preservation, the update to the view cannot always be performed successfully. As we will see below, a necessary condition is that the tuples to be inserted in the view can be extended to tuples in the base relation satisfying the se-lection condition C .

Indeed, for each tuple t in  X  V to be inserted in the SP view Q , we create a tuple template  X  t =( t, z )where z consists of variables for the attributes in schm ( R ) \{ B 1 ,...,B
We then proceed by checking for each template  X  t whether there exists already tuples s in R such that (i)  X  t and s agree on schm ( Q ); and (ii)  X  C ( s ) holds. If there exists such a tuple s ,then  X  t is set to s , and we can safely remove t from  X  V to be inserted (it will automatically belong to the view). Otherwise, if  X  C ( s ) does not hold or no such s exists, then we need to instantiate the variables z in  X  t in such a way that for the resulting tuple t ,  X  C ( t ) holds. The tuples t willmakeuptheupdate X  D to the database.

Testing whether such an instantiation exists can be done similarly as in the key-preserving case above. If this can be done successfully for each template, then  X  D will be a solution for the view side-effect problem. In fact, this solution does not introduce any side effects. Also,  X  D is minimal, because only the necessary tuples are inserted in D (we use existing tuples where possible). The algorithm runs clearly in polynomial time.
 Key-preserving SJ views. We may assume that Q =  X  (  X  f 1 ( R 1 )  X  X  X   X  f k ( R k )).

The PTIME algorithm consists of the following steps. Be-cause Q does not contain projections, we can derive from each tuple t in  X  V and for each relation R i ( i  X  [1 ,k ]) in Q a tuple  X  t i =( a i , b i ) over the attributes of R i check for each t  X   X  V whether (  X  f 1 (  X  t 1 )  X  X  X   X  f satisfies the selection condition C . If not, then no solution exists and the algorithm halts. Otherwise, it continues.
Similar to the cases above, we check for each  X  t i whether there exists already an s i in R i having the same key a i this is the case,  X  t i should be equal to s i .Ifthereexistsa for which this does not hold, then no solution exists and the algorithm stops. Otherwise, the algorithm continues.
Denote by  X  R i the set of tuple  X  t i for which no tuple in R exists with the same key. We check whether  X  R i contains two different tuples having the same key. If such tuples exists, no solution can be found and the algorithm halts. Otherwise, we define  X  D to be {  X  R 1 ,...,  X  R k } .
We remark that  X  D is the minimal solution. Indeed, in each instance R i , the same number of tuples as the number of new keys for R i present in  X  V are inserted. This is the minimum requirement for any solution, so we cannot do it with less updates to D . Because we have no choice (due to the lack of projections) about which tuples to insert, the number of side-effects created is necessarily minimal. The algorithm clearly runs in polynomial time.
 Arbitrary SJ views. Let us now drop the condition of key-preservation. Again, because Q does not have a pro-jection, we can associate with each tuple t in  X  V and each relation R i in Q , a unique tuple  X  t i over the attributes of R i . We simply check if  X  t i already appears in the in-stance R i . If not, then we add  X  t i to  X  R i . Assuming that  X  we define  X  D = {  X  R 1 ,...,  X  R k } . For the same reasons as in the key-preserving case, this is a solution of the view side-effect problem.
 These results are summarized in Table below.
 Figure 5: Illustration of the PTIME algorithm in the proof of Theorem 4.4.

Query class Complexity of view side-effect problem 4.2 The Source Side-Effect Problem
Finally we study the source side-effect problem for in-sertions: given a source database D ,aquery Q ,theview V = Q ( D )andaset X  V of tuples, it is to find a minimal set  X  D of tuples such that Q ( D )  X  Q ( D  X   X  D )contains  X  V , i.e., we want to find a minimal set of tuples to insert into the source such that the insertion will get  X  V into the view, regardless of side effects on the view. We study this problem for both key-preserving and general view queries Q in
SPJ and its subclasses. The main results of this section are summarized in the Table below.

Query class Complexity of source side-effect problem We first present the tractable results.
 Theorem 4.4: The source side-effect problem is in PTIME for (a) SP views and (b) SJ views, for group insertions, no matter whether the views are key-preserving or not. It is also in PTIME for (c) key-preserving SPJ views.
 Proof: The proofs of cases (a) and (b) are similar to those of (a) and (b) for the view side-effect problem (see Theo-rem 4.3). To show (c), it requires a bit more effort (recall that the view side-effect problem for this case is intractable, by Theorem 4.2).
 Arbitrary SP and SJ views. The update  X  D returned by the PTIME algorithm for the view side-effect problem is a solution of the source side-effect problem. Indeed, only the necessary tuples are inserted by those algorithms given for Theorem 4.3. As a result,  X  D is of minimal size. Key-preserving SPJ views. Consider a key-preserving As before, for each tuple t in  X  V and each relation R i in Q , we associate a template  X  t i =( a i , b i , z i ).
The PTIME algorithm first checks for incompatible tem-plates: (i) there should be no two different templates with the same key; or (ii) templates  X  t i with the same key as an existing tuple s i in R i , but which differ in another attribute. Asbefore,weusetheseexistingtuples s i (if they exist) to instantiate the variables in  X  t i .

Fig. 5 illustrates the algorithm for the base relations R R , R 3 ,withkeys A , C and D , respectively, the key-preserving SPJ view Q =  X  ACD (  X  A = E ( R 1 R 2 R 3 and view update  X  V . We also depict the templates for each tuple in  X  V .

If no conflicts are found, we define  X  R i to be the set of templates  X  t i (note that some of then will have no variables anymore, which means that they are already in R i ). It remains to instantiate the variables in the templates. For this, we proceed as follows: for each tuple t in  X  V we compute a conjunctive formula  X  t representing the selec-tion and join condition to hold on  X  t 1  X   X  t 2  X  X  X  X  X   X  t that it will generate t in the view. The formula  X  t con-sists of a conjuncts of equations of the form x = y where x and y are either variables or constants in  X  t i , i  X  [1 ,k ]. We group together all conjunctions  X  t into a big conjunction  X = Theorem 4.2) whether there exists an instantiation of the variables which makes  X  true.

Since we are not concerned about the size of the side ef-fects, we do not have to take into account constraints re-garding existing constants in the database (this is in con-trast with the NP -hardness proof in Theorem 4.1). Hence, if an instantiation exists, we can complete the templates into tuples which populate the update set  X  R i . Finally, we define  X  D = {  X  R 1 ,...,  X  R k } . For example, in Fig. 5 we show  X  and a possible instantiation of the variables. The updated view is shown on the bottom right. In this case no side-effects were created (while in general, side effect cannot be avoided).
 We remark that  X  D is a solution and is also minimal. Indeed, at most a single tuple for each new key in tuples in  X  V is added, a necessary requirement for any solution.
We next show that in the absence of the key preserva-tion condition, the source side-effect problem becomes in-tractable for PJ (and thus SPJ ) views and single-tuple in-sertion. Contrast this with Theorem 4.4 (b) and (c). Taken together, these tell us that the key preservation condition may also simplify the analysis of annotation propagation when view insertions are concerned.
 Theorem 4.5: The source side-effect problem is NP -hard for PJ views and single-tuple insertion, when the PJ views are not necessarily key preserving.
 Proof: We prove the intractability by reduction from the minimal set cover problem (see the proof of Theorem 3.2 for the statement of this problem). It is known that this problem is NP -complete [12].

Given S and C , we define an instance of the source side-effect problem. Let S = { x i | i  X  [1 ,n ] } and C = { c [1 ,k ] } . We construct a source database D ,a PJ view Q ,the view V = Q ( D ), and a single tuple  X  V to be inserted into V . We show that we can find a minimal cover C of S iff there exists a minimal set  X  D of tuples such that Q ( D  X   X  D ) contains  X  V . Figure 6: Illustration of the NP -hardness proof of Theorem 4.5.
 Source database. We define k +2 relations R i S , i  X  [1 ,k +1] and a relation R C .  X  R i S ( I S ,I C ), for i  X  [1 ,k +1], where I S and I over [1 ,n ]and[1 ,k ], respectively. Initially, ( i, j )isin D iff x  X  c j , i.e., ( i, j ) indicates whether or not the element x of S is in the subset c j in the collection C . As will be seen shortly, we keep k +1 copies of the R i S ( I S ,I C )relationto prevent insertions into any of these relations.  X  R C ( I C ) is to hold the elements of C to be picked for covering S .Inotherwords, R C ( I C ) is to represent a cover C (after it is picked) such that ( j )isin D iff c j  X  C ,for j  X  [1 ,k ]. Initially R C in D is empty, i.e., no element of C is picked yet.
 View. We define a PJ view Q =  X  f 1 ( Q ) . . .  X  f n where Q is  X  I S ( R 1 S R 2 S  X  X  X  R k +1 S R C ), and  X  names I S to a distinct name I i S in order to conduct cross product (rather than natural join). A tuple in the view is a n -vector ( a 1 ,...,a n ), where a i  X  [1 ,n ]. Initially, V = Q ( D ) is empty. Note that Q is not key preserving.
 View insertion. The tuple  X  V is (1 ,...,n ). It is to force acover C to be picked, i.e., every element x i in S is to be covered by some subset c j in C .

The reduction is illustrated in Fig. 6 for S = { a, b, c, d and C = { c 1 = { a, b } ,c 2 = { a, d } ,c 3 = { b, c } ,c The tuple inserted into the view and the tuples to be inserted into R C are indicated by the bold rectangles. Tuples in R determine which sets in C is considered to be in a (minimal) cover of S . The colors represent the two elements in C , c = { a, b } and c 4 = { b, c, d } , selected by the insertion of (1) and (4) in R C . It can be seen that the intermediate relation Q contains all elements in S , which implies that { c 1 ,c form a cover of S . The insertion of these two elements in R
C is forced by the insertion of (1 , 2 , 3 , 4) in the view. As explained below, k +1 copies of R S are needed to prevent an insertion in those base relations (as updates to one relation will cause an update in all k +1).

More formally, we next show that this is indeed a reduc-tion. First, assume that C is a minimal cover of S .Then we construct source tuples  X  D such that ( j )isinsertedinto R
C ( I C )iff c j  X  C . Obviously,  X  D  X  Q ( D  X   X  D )since C is a cover, and moreover,  X  D is minimal since C is minimal. Note that, however,  X  D is not side-effect free: Q ( D  X   X  D ) contains all permutations of (1 ,...,n ). But side effects are not the concern of the source side-effect problem. Conversely, suppose that there is a minimal  X  D such that  X  D  X  Q ( D  X   X  D ). Note that  X  D consists of insertions to R C ( I C ) only. Indeed, if one wants to insert tuples into R
S ( I S ,I C ), for some i  X  [1 ,k + 1], in order to add a tuple to the view, the same insertions always have to be performed to all k +1 source relations R i S ( I S ,I C ). Obviously, the minimal solution always consists of maximal k updates.
 Given the minimal update  X  D to R C ( I C ), we define a set C such that c j is in C iff ( j )isin R C ( I C )in X  D .Since (1 ,...,n )isin Q ( D  X   X  D ), from the definition of Q it follows that  X  D consists of ( j ) X  X  such that for any i  X  [1 ,k ], there is ( i, j )  X  R S ( I S ,I C ). Thus C is a cover of S . In addition, C is a minimal cover since  X  D is minimal. That is, C is a minimal cover of S .
To our knowledge, the only known complexity results for the analysis of annotation propagation were given in [5, 19]. We have remarked in Section 1 on the connection between our work and [5, 19]. In particular, key preservation, group updates and propagation of view insertions were not consid-ered in [5, 19]. On relational view updates, surprisingly few complexity bounds are known; in fact the only tractability and intractability results we are aware of were established in [2, 8, 15], for finding a minimal view complement for re-lational views, a problem very different from ours.
There has also been work on the modelling and managing of provenance information [10, 20, 4, 3]. Except for [10], no complexity results were given. In [10], a key-preserving condition was also considered. It was shown there that the condition simplifies the computation of lineage. However, views of [10] are defined in terms of generic mapping func-tions, which are quite different from SPJ views studied in this paper. As a consequence their complexity results do not apply to the decision problems considered in this paper and vice versa.

An algorithm was provided in [9] for translating view dele-tions to base relations with zero side-effects, based on data lineage. This algorithm performs an exhaustive search over all candidate solutions, leading to an exponential time com-plexity. In contrast, with our key-preservation condition, the computation of data lineage can be simplified and the view side-effect free deletion problem is PTIME resolvable.
There has been a host of work on relational view updates ( e.g., [8, 11, 14, 15, 3]). Algorithms were provided in [11] for translating restricted view updates to base-table updates without side effects in the presence of certain functional de-pendencies. An algorithm was developed in [14] to translate (with side effects) a class of SPJ view updates to base rela-tions, with the following restrictions: base tables may only be joined on keys and must satisfy foreign keys; a join view corresponds to a single tree w here each node refers to a re-lation; join attributes must be preserved; and comparisons between two attributes are not allowed in selection condi-tions. As remarked in Section 2 , our key preservation condi-tion is less restrictive than those in [11, 14]. More recently in [3], a bi-directional query language was proposed, which imposes conditions on the operators in the language such that arbitrary changes to views can be carried out. The conditions are more restrictiv e than the key preservation condition studied in this paper.

Commercial database systems [13, 16, 18] allow updates on very restricted views, while allowing users to specify up-dates manually with the instead of triggers. For example, for views to be deletable ibm db2 [13] restricts the from clause to reference only one base table.
We have re-investigated the propagation analysis of an-notations under the key preservation condition. We have shown that for key-preserving SPJ views, the view and source side-effect problems are in PTIME as opposed to NP -hard in the absence of the condition [5, 19]. We have also investigated the impact of group updates on the com-plexity of the propagation analysis, and shown that group updates complicate the analysis: for group deletions the view and source side-effect problems become NP -hard for key-preserving SPJ views. In addition, we have established the first complexity results for the analysis of view insertions for SPJ views, both in the presence and in the absence of the key preservation condition. These provide a complete picture of the complexity of the propagation analysis of an-notations. These results are not only important for data provenance but are also useful for view-update processing.
We are currently studying approximation (heuristic) al-gorithms for conducting the pro pagation analysis of anno-tations when the associated problems are intractable. We also plan to identify other practical conditions on view def-initions such that the analysis can be performed efficiently. Acknowledgment. Wenfei Fan is supported in part by EPSRC
