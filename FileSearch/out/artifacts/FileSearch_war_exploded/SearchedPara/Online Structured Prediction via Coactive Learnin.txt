 Pannaga Shivaswamy pannaga@cs.cornell.edu Thorsten Joachims tj@cs.cornell.edu In a wide range of systems in use today, the interac-tion between human and system takes the following form. The user issues a command (e.g. query) and re-ceives a  X  possibly structured  X  result in response (e.g. ranking). The user then interacts with the results (e.g. clicks), thereby providing implicit feedback about the user X  X  utility function. Here are three examples of such systems and their typical interaction patterns: Web-search: In response to a query, a search engine Movie Recommendation: An online service recom-Machine Translation: An online machine transla-In all the above examples, the user provides some feedback about the results of the system. However, the feedback is only an incremental improvement, not necessarily the optimal result. For example, from the clicks on the web-search results we can infer that the user would have preferred the ranking [ B, D, A, C, ... ] over the one we presented. However, this is unlikely to be the best possible ranking. Similarly in the recom-mendation example, movie B was preferred over movie A , but there may have been even better movies that the user did not find while browsing. In summary, the algorithm typically receives a slightly improved result from the user as feedback, but not necessarily the op-timal prediction nor any cardinal utilities. We conjec-ture that many other applications fall into this schema, ranging from news filtering to personal robotics. Our key contributions in this paper are threefold. First, we formalize Coactive Learning as a model of interaction between a learning system and its user, define a suitable notion of regret, and validate the key modeling assumption  X  namely whether observ-able user behavior can provide valid feedback in our model  X  in a web-search user study. Second, we derive learning algorithms for the Coactive Learning Model, including the cases of linear utility models and convex cost functions, and show O (1 / either case with a matching lower bound. The learn-ing algorithms perform structured output prediction (see ( Bakir et al. , 2007 )) and thus can be applied in a wide variety of problems. Several extensions of the model and the algorithm are discussed as well. Third, we provide extensive empirical evaluations of our algo-rithms on a movie recommendation and a web-search task, showing that the algorithms are highly efficient and effective in practical settings.
 The Coactive Learning Model bridges the gap between two forms of feedback that have been well studied in online learning. On one side there is the multi-armed bandit model ( Auer et al. , 2002b ; a ), where an algorithm chooses an action and observes the util-ity of (only) that action. On the other side, utili-ties of all possible actions are revealed in the case of learning with expert advice ( Cesa-Bianchi &amp; Lugosi , 2006 ). Online convex optimization ( Zinkevich , 2003 ) and online convex optimization in the bandit setting ( Flaxman et al. , 2005 ) are continuous relaxations of the expert and the bandit problems respectively. Our model, where information about two arms is revealed at each iteration sits between the expert and the ban-dit setting. Most closely related to Coactive Learn-ing is the dueling bandits setting ( Yue et al. , 2009 ; Yue &amp; Joachims , 2009 ). The key difference is that both arms are chosen by the algorithm in the duel-ing bandits setting, whereas one of the arms is chosen by the user in the Coactive Learning setting. While feedback in Coactive Learning takes the form of a preference, it is different from ordinal regression and ranking. Ordinal regression ( Crammer &amp; Singer , 2001 ) assumes training examples ( x, y ), where y is a rank. In the Coactive Learning model, absolute ranks are never revealed. Closely related is learning with pairs of examples ( Herbrich et al. , 2000 ; Freund et al. , 2003 ; Chu &amp; Ghahramani , 2005 ) where absolute ranks are not needed; however, existing approaches require an iid assumption and typically perform batch learn-ing. There is also a large body of work on ranking (see ( Liu , 2009 )). These approaches are different from Coactive Learning; they require training data ( x, y ) where y is the optimal ranking for query x . We now introduce coactive learning as a model of in-teraction (in rounds) between a learning system (e.g. search engine) and a human (e.g. search user) where both the human and learning algorithm have the same goal (of obtaining good results). At each round t , the learning algorithm observes a context x t  X  X (e.g. a search query) and presents a structured object y t  X  X  (e.g. a ranked list of URLs). The utility of y t  X  Y to the user for context x t  X  X is described by a utility function U ( x t , y t ), which is unknown to the learning algorithm. As feedback the user returns an improved object  X y t  X  X  (e.g. reordered list of URLs), i.e., when such an object  X y t exists. In fact, we will also allow violations of ( 1 ) when we formally model user feedback in Section 3.1 . The process by which the user generates the feedback  X y t can be understood as an approximate utility-maximizing search, but over a user-defined subset  X  Y t of all possible Y . This mod-els an approximately and boundedly rational user that may employ various tools (e.g., query reformulations, browsing) to perform this search. Importantly, how-ever, the feedback  X y t is typically not the optimal label In this way, Coactive Learning covers settings where the user cannot manually optimize the argmax over the full Y (e.g. produce the best possible ranking in web-search), or has difficulty expressing a bandit-style car-dinal rating for y t in a consistent manner. This puts our preference feedback  X y t in stark contrast to super-vised learning approaches which require ( x t , y  X  t ). But even more importantly, our model implies that reliable preference feedback ( 1 ) can be derived from observable user behavior (i.e., clicks), as we will demonstrate in Section 3.2 for web-search. We conjecture that simi-lar feedback strategies also exist for other applications, where users can be assumed to act approximately and boundedly rational according to U .
 Despite the weak preference feedback, the aim of a coactive learning algorithm is to still present objects with utility close to that of the optimal y  X  t . Whenever, the algorithm presents an object y t under context x t , we say that it suffers a regret U ( x t , y  X  t )  X  U ( x time step t . Formally, we consider the average regret suffered by an algorithm over T steps as follows: The goal of the learning algorithm is to minimize REG T , thereby providing the human with predictions y t of high utility. Note, however, that a cardinal value of U is never observed by the learning algorithm, but U is only revealed ordinally through preferences ( 1 ). 3.1. Quantifying Preference Feedback Quality To provide any theoretical guarantees about the regret of a learning algorithm in the coactive setting, we need to quantify the quality of the user feedback. Note that this quantification is a tool for theoretical analysis, not a prerequisite or parameter to the algorithm. We quantify feedback quality by how much improvement  X y provides in utility space. In the simplest case, we say that user feedback is strictly  X  -informative when the following inequality is satisfied: U ( x t ,  X y t )  X  U ( x t , y t )  X   X  ( U ( x t , y  X  t In the above inequality,  X   X  (0 , 1] is an unknown pa-rameter. Feedback is such that utility of  X y t is higher than that of y t by a fraction  X  of the maximum pos-the above feedback model are allowed by introducing slack variables  X  t  X  0: 1 U ( x t ,  X y t )  X  U ( x t , y t )  X   X  ( U ( x t , y  X  t We refer to the above feedback model as  X  -informative feedback. Note also that it is possible to express feed-back of any quality using ( 5 ) with an appropriate value of  X  t . Our regret bounds will contain  X  t , quantifying to what extent the strict  X  -informative modeling as-sumption is violated.
 Finally, we will also consider an even weaker feedback model where a positive utility gain is only achieved in expectation over user actions:
E t [ U ( x t ,  X y t )  X  U ( x t , y t )]  X   X  ( U ( x t , y We refer to the above feedback as expected  X  -informative feedback. In the above equation, the ex-pectation is over the user X  X  choice of  X y t given y t under context x t (i.e., under a distribution P x t [  X y t | y is dependent on x t ). 3.2. User Study: Preferences from Clicks We now validate that reliable preferences as specified in Equation ( 1 ) can indeed be inferred from implicit user behavior. In particular, we focus on preference feedback from clicks in web-search and draw upon data from a user study ( Joachims et al. , 2007 ). In this study, subjects (undergraduate students, n = 16) were asked to answer 10 questions  X  5 informational, 5 navi-gational  X  using the Google search engine. All queries, result lists, and clicks were recorded. For each subject, queries were grouped into query chains by question 2 . On average, each query chain contained 2 . 2 queries and 1 . 8 clicks in the result lists.
 We use the following strategy to infer a ranking  X y from the user X  X  clicks: prepend to the ranking y from the first query of the chain all results that the user clicked throughout the whole query chain. To assess whether U ( x ,  X y ) is indeed larger than U ( x , y ) as assumed in our learning model, we measure utility in terms of a standard measure of retrieval quality from Information Retrieval. We use DCG @10( x , y ) = P 10 i =1 r ( x , y where r ( x , y [ i ]) is the relevance score of the i-th doc-ument in ranking y (see e.g. ( Manning et al. , 2008 )). To get ground-truth relevance assessments r ( x , d ), five human assessors were asked to manually rank the set of results encountered during each query chain. We then linearly normalize the resulting ranks to a rela-tive relevance score r ( x , d )  X  [0 .. 5] for each document. We can now evaluate whether the feedback ranking  X y is indeed better than the ranking y that was originally presented, i.e. DCG @10( x ,  X y ) &gt; DCG @10( x , y ). Figure 1 plots the Cumulative Distribution functions (CDFs) of DCG @10( x ,  X y )  X  DCG @10( x , y ) for three experimental conditions, as well as the average over all conditions. All CDFs are shifted far to the right of 0, showing that preference feedback from our strategy is highly accurate and informative. Focusing first on the average over all conditions, the utility difference is strictly positive on  X  60% of all queries, and strictly negative on only  X  10%. This imbalance is significant (binomial sign test, p &lt; 0 . 0001). Among the remain-ing  X  30% of cases where the DCG@10 difference is zero, 88% are due to  X y = y (i.e. click only on top 1 or no click). Note that a learning algorithm can easily detect those cases and may explicitly eliminate them as feedback. Overall, this shows that implicit feedback can indeed produce accurate preferences.
 What remains to be shown is whether the reliability of the feedback is affected by the quality of the cur-rent prediction, i.e., U ( x t , y t ). In the user study, some users actually received results for which retrieval qual-ity was degraded on purpose. In particular, about one third of the subjects received Google X  X  top 10 results in reverse order (condition  X  X eversed X ) and another third received rankings with the top two positions swapped (condition  X  X wapped X ). As Figure 1 shows, we find that users provide accurate preferences across this sub-Algorithm 1 Preference Perceptron.

Initialize w 1  X  0 for t = 1 to T do end for stantial range of retrieval quality. Intuitively, a worse retrieval system may make it harder to find good re-sults, but it also makes an easier baseline to improve upon. This intuition is formally captured in our def-inition of  X  -informative feedback. The optimal value of the  X  vs.  X  trade-off, however, will likely depend on many application-specific factors, like user motiva-tion, corpus properties, and query difficulty. In the following, we therefore present algorithms that do not require knowledge of  X  , theoretical bounds that hold for any value of  X  , and experiments that explore a large range of  X  . In this section, we present algorithms for minimizing regret in the coactive learning model. In the rest of this paper, we use a linear model for the utility function, where w  X   X  R N is an unknown parameter vector and  X  : X  X  Y  X  R N is a joint feature map such that k  X  ( x , y ) k  X  both x and y can be structured objects.
 We start by presenting and analyzing the most ba-sic algorithm for the coactive learning model, which we call the Preference Perceptron (Algorithm 1 ). The Preference Perceptron maintains a weight vector w t which is initialized to 0 . At each time step t , the algo-rithm observes the context x t and presents an object y that maximizes w  X  t  X  ( x t , y ). The algorithm then ob-serves user feedback  X y t and the weight vector w t is updated in the direction  X  ( x t ,  X y t )  X   X  ( x t , y t Theorem 1 The average regret of the preference per-ceptron algorithm can be upper bounded, for any  X   X  (0 , 1] and for any w  X  as follows: Proof First, consider k w T +1 k 2 , we have, w + (  X  ( x T ,  X y T )  X   X  ( x T , y T ))  X  (  X  ( x T ,  X y  X  w  X  T w T + 4 R 2  X  4 R 2 T.
 On line one, we simply used our update rule from algorithm 1 . On line two, we used the fact that w
T (  X  ( x T ,  X y T )  X   X  ( x T , y T ))  X  0 from the choice of y
T in Algorithm 1 and that k  X  ( x , y ) k  X  R . Further, from the update rule in algorithm 1 , we have, (Cauchy-Schwarz inequality), which implies From the  X  -informative modeling of the user feedback in ( 5 ), we have  X 
X from which the claimed result follows.
 The first term in the regret bound denotes the qual-ity of feedback in terms of violation of the strict  X  -informative feedback. In particular, if the user feed-back is strictly  X  -informative, then all slack variables in ( 8 ) vanish and REG T = O (1 / Though user feedback is modeled via  X  -informative feedback, the algorithm itself does not require the knowledge of  X  ;  X  plays a role only in the analysis. Although the preference perceptron appears similar to the standard perceptron for multi-class classification problems, there are key differences. First, the stan-dard perceptron algorithm requires the true label y  X  as feedback, whereas much weaker feedback  X y suffices for our algorithm. Second, the standard analysis of the perceptron bounds the number of mistakes made by the algorithm based on margin and the radius of the examples. In contrast, our analysis bounds a different regret that captures a graded notion of utility. An appealing aspect of our learning model is that sev-eral interesting extensions are possible. We discuss some of them in the rest of this section.
 4.1. Lower Bound We now show that the upper bound in Theorem 1 cannot be improved in general.
 Lemma 2 For any coactive learning algorithm A with linear utility, there exist x t , objects Y and w  X  such that REG T of A in T steps is  X (1 / Proof Consider a problem where Y = { X  1 , +1 } , X = { x  X  R T : k x k = 1 } . Define the joint feature map as  X  ( x , y ) = yx . Consider T contexts e 1 , . . . , e that e j has only the j th component equal to one and all the others equal to zero. Let y 1 , . . . y T be the se-quence of outputs of A on contexts e 1 , . . . , e T . Con-struct w  X  = [  X  y 1 / have for this construction k w  X  k = 1. Let the user feedback on the t th step be  X  y t . With these choices, the user feedback is always  X  -informative with  X  = 1 since y  X  t =  X  y t . Yet, the regret of the algorithm is 4.2. Batch Update In some applications, due to high volumes of feedback, it might not be possible to do an update after every round. For such scenarios, it is natural to consider a variant of Algorithm 1 that makes an update every k iterations; the algorithm simply uses w t obtained from the previous update until the next update. It is easy to show the following regret bound for batch updates: 4.3. Expected  X  -Informative Feedback So far, we have characterized user behavior in terms of deterministic feedback actions. However, if a bound on the expected regret suffices, the weaker model of Expected  X  -Informative Feedback from Equation ( 6 ) is applicable.
 Corollary 3 Under expected  X  -informative feedback model, the expected regret (over user behavior distri-bution) of the preference perceptron algorithm can be upper bounded as follows: The above corollary can be proved by following the argument of Theorem 1 , but taking expectations Algorithm 2 Convex Preference Perceptron.

Initialize w 1  X  0 for t = 1 to T do end for E [2 w  X  T (  X  ( x T ,  X y T )  X   X  ( x T , y T ))] + E T [(  X  ( x 4 R 2 . In the above, E denotes expectation over all user feedback  X y t given y t under the context x t . It follows Applying Jensen X  X  inequality on the concave func-tion k w  X  k q E [ w  X  T w T ] . The corollary follows from the def-inition of expected  X  -informative feedback. 4.4. Convex Loss Minimization We now generalize our results to minimize convex losses defined on the linear utility differences. We as-sume that at every time step t , there is an (unknown) convex loss function c t : R  X  R which determines the c t are assumed to be non-increasing. Further, sub-derivatives of the c t  X  X  are assumed to be bounded (i.e., (  X  )  X  [  X  G, 0] for all t and for all  X   X  R ). The vector w  X  which determines the utility of y t under context x t is assumed from a closed and bounded convex set B whose diameter is denoted as |B| .
 Algorithm 2 minimizes the average convex loss. There are two differences between this algorithm and Algo-rithm 1 . Firstly, there is a rate  X  t associated with the update at time t . Moreover, after every update, the re-sulting vector  X w t +1 is projected back to the set B . We have the following result for Algorithm 2 , a proof of which is provided in an extended version of this paper ( Shivaswamy &amp; Joachims , 2012 ).
 Theorem 4 For the convex preference perceptron, we have, for any  X   X  (0 , 1] and any w  X   X  X  , In the bound ( 11 ), c t (0) is the minimum possible greater than zero by definition of y  X  t . Thus the the-orem upper bounds the average convex loss via the minimum achievable loss and the quality of feedback. Like the previous result (Theorem 1 ), under strict  X  -informative feedback, the average loss approaches the best achievable loss at O (1 / stant factors. We empirically evaluated the Preference Perceptron algorithm on two datasets. The two experiments dif-fered in the nature of prediction and feedback. While the algorithm operated on structured objects (rank-ings) in one experiment, atomic items (movies) were presented and received as feedback in the other. 5.1. Structured Feedback: Learning to Rank We evaluated our Preference Perceptron algo-rithm on the Yahoo! learning to rank dataset ( Chapelle &amp; Chang , 2011 ). This dataset consists of query-url feature vectors (denoted as x q i for query q and URL i ), each with a relevance rating r q i that ranges from zero (irrelevant) to four (perfectly relevant). To pose ranking as a structured prediction problem, we defined our joint feature map as follows: In the above equation, y denotes a ranking such that y i is the index of the URL which is placed at position i in the ranking. Thus, the above measure considers the top five URLs for a query q and computes a score based on a graded relevance. Note that the above util-ity function defined via the feature-map is analogous to DCG@5 (see e.g. ( Manning et al. , 2008 )) after replac-ing the relevance label with a linear prediction based on the features.
 For query q t at time step t , the Preference Percep-tron algorithm presents the ranking y q t that maximizes w t  X  ( q t , y ). Note that this merely amounts to sort-done very efficiently. The utility regret in Eqn. ( 3 ), based on the definition of utility in ( 12 ), is given by the optimal ranking with respect to w  X  , which is the best least squares fit to the relevance labels from the features using the entire dataset. Query ordering was randomly permuted twenty times and we report aver-age and standard error of the results. 5.1.1. Strong Vs Weak Feedback The goal of the first experiment was to see how the regret of the algorithm changes with feedback quality. To get feedback at different quality levels  X  , we used the following mechanism. Given the predicted ranking y , the user would go down the list until she found five URLs such that, when placed at the top of the list, the resulting  X y t satisfied the strictly  X  -informative feedback condition w.r.t. the optimal w  X  . Figure 2 shows the results for this experiment for two different  X  values. As expected, the regret with  X  = 1 . 0 is lower compared to the regret with respect  X  = 0 . 1. Note, however, that the difference between the two curves is much smaller than a factor of ten. This is because strictly  X  -informative feedback is also strictly  X  -informative feedback for any  X   X   X  . So, there could be several instances where user feedback was much stronger than what was required. As ex-pected from the theoretical bounds, since the user feedback is based on a linear model with no noise, util-ity regret approaches zero. 5.1.2. Noisy Feedback In the previous experiment, user feedback was based on actual utility values computed from the optimal w  X  . We next make use of the actual relevance labels provided in the dataset for user feedback. Now, given a ranking for a query, the user would go down the list inspecting the top 10 URLs (or all the URLs if the list is shorter) as before. Five URLs with the highest relevance labels ( r q i ) are placed at the top five locations in the user feedback. Note that this produces noisy feedback since no linear model can perfectly fit the relevance labels on this dataset.
 As a baseline, we repeatedly trained a conventional Ranking SVM 3 . At each iteration, the previous SVM model was used to present a ranking to the user. The user returned a ranking based on the relevance la-bels as above. The pairs of examples ( q t , y q t svm ) and ( q ,  X y q t svm ) were used as training pairs for the ranking SVMs. Note that training a ranking SVM after each iteration would be prohibitive, since it involves solv-ing a quadratic program and cross-validating the reg-ularization parameter C . Thus, we retrained the SVM whenever 10% more examples were added to the train-ing set. The first training was after the first iteration with just one pair of examples (starting with a random y 1 ), and the C value was fixed at 100 until there were 50 pairs of examples, when reliable cross-validation be-came possible. After there were more than 50 pairs in the training set, the C value was obtained via five-fold cross-validation. Once the C value was determined, the SVM was trained on all the training examples available at that time. The same SVM model was then used to present rankings until the next retraining. Results of this experiment are presented in Figure 3 . Since the feedback is now based on noisy relevance la-bels, the utility regret converges to a non-zero value as predicted by our theoretical results. Over most of the range, the Preference Perceptron performs sig-nificantly 4 better than the SVM. Moreover, the per-ceptron experiment took around 30 minutes to run, whereas the SVM experiment took about 20 hours on the same machine. We conjecture that the regret val-ues for both the algorithms can be improved with bet-ter features or kernels, but these extensions are orthog-onal to the main focus of this paper. 5.2. Item Feedback: Movie Recommendation In contrast to the structured prediction problem in the previous section, we now evaluate the Preference Perceptron on a task with atomic predictions, namely movie recommendation. In each iteration a movie is presented to the user, and the feedback consists of a movie as well. We use the MovieLens dataset, which consists of a million ratings over 3090 movies rated by 6040 users. The movie ratings ranged from one to five. We randomly divided users into two equally sized sets. The first set was used to obtain a feature vector m j for each movie j using the  X  X VD embedding X  method for collaborative filtering (see ( Bell &amp; Koren , 2007 ), Eqn. (15)). The dimensionality of the feature vectors and the regularization parameters were chosen to optimize cross-validation accuracy on the first dataset in terms of squared error. For the second set of users, we then considered the problem of recommending movies based on the movie features m j . This experiment setup sim-ulates the task of recommending movies to a new user based on movie features from old users.
 For each user i in the second set, we found the best least squares approximation w T i  X  m j to the user X  X  util-ity functions on the available ratings. This enables us to impute utility values for movies that were not ex-plicitly rated by this user. Furthermore, it allows us to measure regret for each user as 1 T P T t =1 w  X  i  X  ( m t  X  which is the average difference in utility between the recommended movie m t and the best available movie m t  X  . We denote the best available movie at time t by m t  X  , since in this experiment, once a user gave a particular movie as feedback, both the recommended movie and the feedback movie were removed from the set of candidates for subsequent recommendations. 5.2.1. Strong Vs Weak Feedback Analogous to the web-search experiments, we first ex-plore how the performance of the Preference Percep-tron changes with feedback quality  X  . In particular, we recommended a movie with maximum utility accord-ing to the current w t of the algorithm, and the user returns as feedback a movie with the smallest utility that still satisfied strictly  X  -informative feedback ac-cording to w i  X  . For every user in the second set, the algorithm iteratively recommended 1500 movies in this way. Regret was calculated after each iteration and separately for each user, and all regrets were averaged over all the users in the second set. Figure 4 shows the results for this experiment. Since the feedback in this case is strictly  X  -informative, the average regret in all the cases decreases towards zero as expected. Note that even for a moderate value of  X  , regret is already substantially reduced after 10 X  X  of iterations. With higher  X  values, the regret converges to zero at a much faster rate than with lower  X  values. 5.2.2. Noisy Feedback We now consider noisy feedback, where the user feed-back does not necessarily match the linear utility model used by the algorithm. In particular, feedback is now given based on the actual ratings when available, or the score u  X  i  X  m j rounded to the nearest allowed rat-ing value. In every iteration, the user returned a movie with one rating higher than the one presented to her. If the algorithm already presented a movie with the highest rating, it was assumed that the user gave the same movie as feedback. As a baseline, we again ran a ranking SVM. Like in the web-search experiment, it was retrained whenever 10% more training data was added. The results for this experiment are shown in Figure 5 . The regret of the Preference Perceptron is again significantly lower than that of the SVM, and at a small fraction of the computational cost. We proposed a new model of online learning where preference feedback is observed but cardinal feedback is never observed. We proposed a suitable notion of regret and showed that it can be minimized under our feedback model. Further, we provided several ex-tensions of the model and algorithms. Furthermore, experiments demonstrated its effectiveness for web-search ranking and a movie recommendation task. A future direction is to consider  X  -strongly convex func-tions, and we conjecture it is possible to derive algo-rithms with O (log( T ) /T ) regret in this case. Acknowledgements We thank Peter Frazier, Bobby Kleinberg, Karthik Raman and Yisong Yue for helpful discussions. This work was funded in part under NSF awards IIS-0905467 and IIS-1142251.
