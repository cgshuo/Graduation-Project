 Indoor spaces accommodate large populations of individuals. The continuous range monitoring of such objects can be used as a foun-dation for a wide variety of applications, e.g., space planning, way finding, and security. Indoor space differs from outdoor space in that symbolic locations, e.g., rooms, rather than Euclidean posi-tions or spatial network locations are important. In addition, posi-tioning based on presence sensing devices, rather than, e.g., GPS, is assumed. Such devices report the objects in their activation ranges. We propose an incremental, query-aware continuous range query processing technique for objects moving in this setting. A set of critical devices is determined for each query, and only the obser-vations from those devices are used to continuously maintain the query result. Due to the limitations of the positioning devices, queries contain certain and uncertain results. A maximum-speed constraint on object movement is used to refine the latter results. A comprehensive experimental study with both synthetic and real data suggests that our proposal is efficient and scalable. H.2.8 [ DATABASE MANAGEMENT ]: Database Applications Algorithms, Design, Experimentation, Management Indoor Moving Objects, Symbolic Indoor Space, Continuous Range Monitoring
People spend large parts of their lives in indoor spaces such as office buildings, shopping centers, conference facilities, airports, and other transport infrastructures. Meanwhile, such spaces are be-coming increasingly large and complex. For example, the London Underground has 268 stations and a network of 408 kilometers [1]. Each hour, 146,000 passengers enter its tube system: during the three morning peak hours alone, 51,100 people enter the busiest tube station, Waterloo; and the total number of daily passengers exceeds 4 million.

With the deployment of indoor positioning based on technolo-gies such as RFID [19] and Bluetooth [8], it is possible to contin-uously monitor indoor moving objects in order to support various applications. For example, such monitoring is very useful for space use analysis and security purposes. However, existing techniques for continuous range monitoring in outdoor spaces [10, 15, 16] are not easily applicable in indoor spaces, for two main reasons.
First, an indoor space is typically modeled differently from an outdoor space, where either an Euclidean space or a spatial net-work is typically assumed. Indoor space is characterized by entities such as doors, rooms, and hallways that enable and constrain move-ment. This renders movement more constrained than movement in Euclidean spaces. Consequently, geometric movement represen-tations, e.g., the linear model that is widely adopted for outdoor movement, are not suitable for indoor movement. Further, indoor movement is less constrained than movement in a spatial network, where objects are constrained to a polyline. As a result, symbolic models, rather than geometric models, of indoor space are often used [3].

Second, proximity-based indoor positioning technologies differ fundamentally from those typically assumed in outdoor settings. Unlike GPS and cellular positioning technologies that are capa-ble of continuously reporting the position and velocity of an object with varying accuracies, proximity-based indoor positioning tech-nologies are unable to report velocities or accurate locations [9]. In particular, an indoor object is detected only when it enters the acti-vation range of a position sensing device, e.g., an RFID reader or a Bluetooth hotspot.

To the best of our knowledge, this paper represents the first work on the continuous monitoring of moving objects in symbolic indoor space. The paper X  X  contribution is fourfold. First, it proposes an infrastructure for indoor range monitoring, which includes a state classification of the moving objects and a hashing-based object in-dexing scheme that exploits the states.

Second, a query-aware scheme is proposed for the incremental maintenance of range queries. For each query, critical devices are determined so that only the new observations from those devices are needed in order to maintain the query X  X  result. The partitioning of critical devices into five classes enables efficient update.
Third, we provide query results with certain results and uncer-tain results. Probabilities for the uncertain results are derived from assumed maximum object speeds.

Fourth, the paper reports results of a comprehensive performance study of the paper X  X  proposals using both synthetic and real data.
The remainder of the paper is organized as follows. Section 2 covers preliminaries and Section 3 elaborates on the management of indoor moving objects. Section 4 presents the proposals for the processing of range monitoring queries. Section 5 covers the em-pirical studies. Finally, Section 6 briefly reviews the related work and Section 7 concludes and discusses research directions.
A simplified plan of the first floor of the CS Department at Aal-borg University is shown in Figure 1. The floor is divided into three clusters, each having its own (numbered) hallway and rooms. The clusters are connected by a common hallway, labeled 40. Other floors can be reached via a staircase, labeled 50. The outside is la-beled 0. For simplicity, we regard hallways and staircases as rooms. For example, we use  X  X oom 10 X  for  X  X allway 10. X  13 12
Figure 1: Floor Plan and Positioning Device Deployment
We assume the use of presence, or proximity-based, sensing tech-nologies such as RFID, Bluetooth, and Infrared. We do not con-sider signal strength [2] as the activation ranges of RFID readers in our setting are relatively small (tens of centimeters to 3 me-ters [19]).

These technologies employ proximity analysis [9], which deter-mines when an object is within the activation range of a device. Each device detects and reports the observed objects at a relatively high sampling rate. A reading ( deviceID , objectID , t ) states that object objectID is detected by device deviceID at time t .
A positioning device deployment is shown in Figure 1, where the numbered red circles indicate the devices and their activation ranges. For positioning devices with overlapping ranges, we treat the intersection as the activation range of a new, virtual position-ing device. For example, the intersection of device 1 and device is assigned to a device device 1 0 1 . An object seen by device but not device 1 0 , is then in the non-intersecting part of the range of device 1 . Unlike overlapping devices, so-called paired devices, covered in Section 2.2, are used to detect movement direction, e.g., entry/exit of a room.

For each moving object, only its first and last appearances in the range of a device are of interest. We thus introduce a pre-processing module in-between the sensing devices and the continuous query processing module that continuously (according to the sampling unit T s ) receives readings from all positioning devices, and outputs records in the format ( deviceID , objectID , t, flag ) . Here, flag = ENTER indicates that the object is entering the device X  X  activation range; flag = LEAVE indicates the object is leaving the range. The deviceID can be that of a virtual device. Unless explicitly stated otherwise, this applies to all deviceID s in the rest of the paper. Due to space limitations, we omit the details of the pre-processing module. We differentiate between two types of positioning devices.
Partitioning devices partition the indoor space into cells in the sense that an object cannot move from one cell to another without being observed. An example is a device deployed by the single door of a room. There are two options for partitioning devices. First, undirected partitioning devices ( UP ) cannot detect move-ment directions between two cells. For example, device not tell whether an observed object enters or leaves cell c that device 1 , device 1 0 , and device 1 0 1 are also undirected. Sec-ond, directed partitioning devices ( DP ) consist of entry/exit pairs of devices, which enables the movement direction of an object to be inferred by the reading sequence. An example is device device 11 0 in Figure 1.

Next, presence devices ( PR ) simply sense the presence of objects in their ranges. These are exemplified by device 10 in Figure 1.
A Devices mapping maintains the information on the positioning devices: where  X  devices is the domain of device identifiers, ActRange in-dicates the activation range of a device (a geometry describing the range); and TYPE indicates the type of a device: UP , DP , or PR . To facilitate object tracking and querying, a deployment graph G = ( C, E,  X  devices , ` E ) is created based on the topological rela-tionship between the floor plan and the positioning device deploy-ment. The set of vertices C consists of the cells formed by the partitioning devices. The set of edges E consists of sets { c set of positioning devices: a non-loop edge { c i , c j } is mapped to the device(s) that partitions cells c i and c j , and a loop edge { c is mapped to the presence device(s) in cell c i .

An in-depth study on deployment graphs, including relevant data structures and algorithms is available elsewhere work [7]. The de-ployment graph of Figure 1 is shown in Figure 2, where the label D i indicates the positioning device device i .
Each cell created by a reader deployment corresponds to one or more rooms. For example, cell c 10 is mapped to rooms 10 and 14 because an object can go between these rooms without being ob-ship, where  X  rooms is the domain of room identifiers.
It is important to observe that rooms make up a partitioning of a floor plan that is independent of a particular deployment of posi-tioning devices. In contrast, a cell partitioning is caused by a de-ployment of positioning devices. The extent of a cell is the union of the extents of the rooms that make up the cell, excluding the ranges of any intersecting devices. In the example, cell c 10 is the union of rooms 10 and 14 excluding the activation ranges of device Thus an indoor space is partitioned into activation ranges and cells.
A deployment of positioning devices induces an active subspace that is the union of the activation ranges of all the positioning de-vices and an inactive subspace that is the part of space that is not covered by any positioning device. An object is said to be in the active (inactive) state when it is in the active (inactive) subspace.
Using the Devices mapping from Section 2.2, we are able to directly determine the whereabouts of active objects. For inactive objects, additional processing and information are needed to infer their possible locations.

We refine the inactive state so that an object is in the determinis-tic state if it is certain that the object is in one specific cell; it is in the nondeterministic state if it can be in several cells.
More specifically, if a moving object leaves (the activation range of) a presence device d , it must be still in the cell G.` is again seen 1 . Therefore, its state changes from active to determin-istic. In our running example, if an object leaves device enter c 10 . If an object leaves a directed partitioning device pair, the cell the object is entering can be determined from the reading sequence. Therefore, its state also changes from active to determin-istic. Thus, if an object is seen at device 11 0 and then device must enter c 11 .

In contrast, if an object leaves an undirected partitioning device, the object can be in either of the cells in G.`  X  1 E ( d ) . Therefore, its state changes from active to nondeterministic. For example, if a moving object leaves device 12 , it can be in either c 10
If an object enters the range of a positioning device, its state changes from inactive (deterministic or nondeterministic) to active.
An object cannot switch directly between deterministic and non-deterministic. For an object to enter/leave a cell, it must be detected by a partitioning device, which makes its state become active be-fore it can switch.

Based on the resulting state diagram, in Figure 3, we proceed to present specific object indexing structures.

The partitioning devices render the indoor space discrete. This and the specifics of the positioning devices render indexes for free-moving outdoor objects unsuitable for indoor objects.
 We propose an indexing scheme that utilizes several hash tables. Let O indoor be the set of all the moving objects in the indoor space of interest. A Device Hash Table (DHT) is created that maps each positioning device, identified by deviceID , to the set of active ob-jects in its range: DHT [ deviceID ] = O A ; deviceID  X   X  devices , O A  X  O indoor
Next, a Cell Deterministic Hash Table (CDHT) maps each cell, identified by cellID , to the set of deterministic objects in it: Similarly, a Cell Nondeterministic Hash Table (CNHT) maps a cell to the set of nondeterministic objects in it:
Finally, an Object Hash Table (OHT) captures the states of all objects:
OHT [ objectID ] = ( STATE , t, IDSet ); objectID  X  O indoor Here STATE denotes the object X  X  current state; t is the start time of the state; IDSet is a set of cell identifiers or a set of device iden-tifiers, indicating where the object can currently be. If the object X  X  state is active, IDSet is a singleton set consisting of a device identi-fier. If the state is deterministic, IDSet is a singleton set consisting of a cell identifier. If the state is nondeterministic, IDSet is a set of cell identifiers.

The four hash tables need updating whenever there is a new out-put from the pre-processing module. The update algorithm, de-scribed in Algorithm 1, handles a record received from the pre-processing module according to its flag value.
 Algorithm 1 updateHashTables (Pre-processing output O , De-ploymentGraph G ) 1: IDSet sSet  X  X  X  ; 2: if O . flag = ENTER then 5: for the single element c in sSet do 6: Delete O . objectID from DHT [ c ]; 8: for the single element c in sSet do 9: Delete O . objectID from CDHT [ c ]; 10: else 11: for each element c in sSet do 12: Delete O . objectID from CNHT [ c ]; 15: else 20: for each element c in sSet do 21: Add O . objectID to CNHT [ c ]; 22: else 24: for the single element c in sSet do 25: Add O . objectID to CDHT [ c ];
For an ENTER record, if the object X  X  previous state is active, it is deleted from the corresponding device X  X  DHT (lines 4 X 6). If its previous state is deterministic, it is deleted from the corresponding cell X  X  CDHT (lines 7 X 9). Otherwise, its previous state is nonde-terministic, and the object is deleted from all corresponding cells X  CNHT s (lines 10 X 12). After the deletion, the object is added into the DHT of the current device, and its state is updated accordingly (lines 13 X 14).

For a LEAVE record, the object is deleted from the correspond-ing device X  X  DHT (lines 15 X 16). The possible cells are determined by the function G.`  X  1 E (lines 17). If the object leaves a UP device, its state becomes nondeterministic, and the object is added into all the corresponding cells X  CNHT s (lines 18 X 21). If the object leaves a DP or PR device, its state becomes deterministic, and the object is added into the corresponding cell X  X  CDHT (lines 22 X 25).
The implementation uses bitmaps for storing the sets of object identifiers in DHT , CDHT , and CNHT . In particular, each value in these hash tables maintains a bitmap, each bit of which corre-sponds to a specific object. A bit is set only if the object is currently in the object set of the value. Bitmaps require little space, render-ing main-memory storage of these hash tables possible. Combined with suitable masks, bitwise AND and OR operations render up-dates (the insertions and deletions in Algorithm 1) very efficient.
A Continuous Range Monitoring Query ( CRMQ ) takes an in-door spatial range R as parameter. It is activated when it is regis-tered in the system, say t s . At each point in time, it then reports all objects that are currently within R . This continues until the query is unregistered from the system, say t e . The query result is main-tained from time t s to time t e as follows.  X  t  X  [ t s , t e ] : o  X  CRMQ [ R ]( M )  X  o  X  X  X  pos M ( o, t )  X  R , where M indicates all the objects moving in the indoor space; pos M is a function which can determine the location of the object o at timestamp t . Multiple monitoring queries may be expected to coexist in the system. They can be registered (unregistered) at different times.

The result of a CRMQ needs updating whenever an object enters or leaves its range. A naive approach is to reevaluate each query when a new observation is produced by the pre-processing module. However, this yields an unnecessarily high workload, especially when the number of concurrent queries is high. Another solution entails periodical reevaluation, which searches the index structures and computes an up-to-date result periodically, according to user configurations. These two approaches are query blind, as they do not take advantage of the ranges of the registered queries when they process the queries.

We propose a query-aware and incremental approach. The idea is that not every pre-processing observation causes changes to the result of every CRMQ . For each query, we identify the critical de-vices from which new observations may change the query X  X  result. Accordingly, only ENTER and LEAVE observations from such devices are needed to correctly update the results of the relevant monitoring queries.

Our approach is shown in Figure 4. When a new query is reg-istered in the system, the hash indexes are searched for all moving objects currently in the query range. The set of critical devices and the result of the query are stored in main memory. As time elapses, new observations will be emitted by the critical devices, and the query result will be updated accordingly in the query processing module, which is detailed in Section 4.3.

The range of a CRMQ can be represented either symbolically or geometrically. It is straightforward to use the device and cell identifiers in the symbolic representation. Through the hash tables DHT , CDHT and CNHT , the query result can be obtained di-rectly. This arrangement is tightly integrated with the positioning device deployment, which may not be available to query issuers.
In the geometrical representation, the query range is represented as a geometrical shape, e.g., a polygon or a circle. To enable such queries, the floor plan, positioning device activation ranges, and cells are indexed by spatial indexes, such as a 2-dimensional R-tree, which enables easy retrieval of the corresponding symbolic identifiers. We thus assume that a geometrical query range is not fully contained in any single activation range.
In our setting, the position of an object is typically constrained to be in one or several cells, as discussed in Section 3.1. Conse-quently, the result of a CRMQ is divided into a certain and an uncertain part. The certain result contains all objects that are defi-nitely in the query range CRMQ .R , and the uncertain result con-tains those objects that may be in the query range.

Specifically, if the query range CRMQ .R covers (intersects) the whole activation range of a device, all active objects in the device X  X  DHT are in the certain (uncertain) result the of CRMQ . For exam-ple, the range of a CRMQ query 1 is shown as a dashed rectangle in Figure 5. The active objects in device 13 ( device 16 certain (uncertain) result.

We say that region x covers region y if y is fully contained in x . We say that x intersects with y if they overlap but do not cover each other. Let u return the intersection of two argument regions. If x u y 6 =  X  and neither x u y 6 = x nor x u y 6 = y ), we say that x intersects with y ; if x u y 6 =  X  and x u y = y , we say that x covers y .
Furthermore, if the query range covers an entire cell, the deter-ministic (nondeterministic) objects in the cell X  X  CDHT ( CNHT ) are in the certain (uncertain) result. Refer again to the query Figure 5. The deterministic (nondeterministic) objects in c
Figure 5: Query Examples The query range covers both c 12 and c 13 . If an object leaves device 16 , it becomes a nondeterministic object for both c c . However, it is still definitely within the query range and thus in the certain result. For a nondeterministic object, if all its possible cells (can be obtained from OHT ) are covered by the query range, it is included in the certain result of the query.

We proceed to elaborate on the query processing, covering the computation of the initial certain and uncertain results and their incremental maintenance. A probabilistic accuracy analysis on the uncertain result is given in Section 4.4.
When a new query arrives, the query registration module com-putes the initial query result (both certain and uncertain), identifies the critical devices, and registers the query into the system with the corresponding information. The query update module is responsi-ble for incrementally maintaining query results as new observations are emitted by the pre-processing module. See Figure 4.

In Section 4.3.1, we identify for each query critical devices that enable incremental query result update. In Section 4.3.2 we deter-mine the initial result for a new coming query. In Section 4.3.3, we propose the incremental query result update method. In Sec-tion 4.3.4, we discuss how to improve query result when the maxi-mum object speed is available.
For a CRMQ query, a critical device is one from which a new observation can potentially change the query result (either certain or uncertain). In order to continuously update the query result, it is crucial to know all such devices. This is achieved by means of the deployment graph covered in Section 2.2. Clearly, the devices whose activation ranges intersect with or are covered by the query range CRMQ . R are critical.

A query range may also intersect with or cover a set of cells C = { c | c u R 6 =  X  X  . In order to guarantee the accuracy of the query result, we introduce another extended set of cells C ex = { c |{ c, c G.E, c 0  X  C ic } , which contains the neighbor cells of C ample, for query 2 in Figure 5, C ic = { c 12 , c 13 }; and C Taking the deployment graph into account, all edges whose vertices contain one of the cells in set C ic or C ex indicate the positioning devices whose future observations can potentially change the query result. Critical devices cannot come from any further-away graph edges because for any object to enter or leave the query range, it must first be detected by devices whose corresponding graph edges are closer to the query range.

Let R be the range of a CRMQ , d be a positioning device, and d be the activation range of the device d . In other words, we have d = Devices ( d ). ActRange . To improve the query processing, we categorize all critical devices into five classes.

The classes have the following pertinent properties. The activa-tion range of a CLASS1 device is fully covered by the query range R and all its corresponding cells are fully covered by the query range R . For query 2 in Figure 5, device 16 is a CLASS1 device.
The activation range of a CLASS2 device is fully covered by the query range R , and at least one of its corresponding cells is not fully covered by the query range R . For example, device CLASS2 devices of query 1 .

The activation range of a CLASS3 device intersects with the query range R . For example, device 16 is a CLASS3 devices of query
The activation range of a CLASS4 device is disjoint with the query range R and at least one of its corresponding cells is in C For example, device 1 is a CLASS4 device of query 1 .

Finally, the activation range of a CLASS5 critical device is dis-joint with the query range R and at least one of its corresponding cells is in C ex , but none of them are in C ic . For example, device is a CLASS5 critical device of query 2 .

As discussed, only new observations from the critical devices can affect the result of a given query. The classification will be helpful for the query result update (to be detailed in Section 4.3.3). It is then beneficial if the relationships between a query and its critical devices are recorded appropriately in the system. Therefore, a Device Query Hash Table (DQHT) is defined: where deviceID indicates a device, queryID indicates a query that has the device as a critical device, and CLASS indicates the class of the critical device in the particular query.

During continuous query updating, as soon as a new observation from a device is output by the pre-processing module, all queries relevant to the device are determined through DQHT . This can avoid unnecessary result updates on queries for which the device is not critical.
In order to process multiple concurrent CRMQ efficiently, an incremental query result update method is applied. In other words, each update is based on the previous query result. A query index Query Hash Table(QHT) is created in main memory. It maps a query identifier to the query X  X  results:
QHT [ queryID ] = ( CR , UR ); CR  X  O indoor , UR  X  O indoor where CR is the certain result and UR is the uncertain result.
The registration procedure for a new query, detailed in Algo-rithm 2, identifies the critical devices, obtains the initial query re-sults, and registers the relevant information to facilitate future result updates. First, a new identifier is generated for the query (line 5). The covered devices/cell sets and intersected devices/cell sets are determined through the predefined spatial index (lines 6 X 9). The covered devices are then added to the critical devices set, and the class is determined according to the relevant definitions (lines 10 X  14). The intersected devices are added into the critical devices set with CLASS3 (lines 15 X 16). After that, CLASS4 critical devices are determined (lines 17 X 20). For each edge in the deployment graph G , if one of its two vertices is in the covered or intersected cell set and the edge X  X  corresponding device is not in critical de-vices set, the device is a CLASS4 critical device. At the same time, the extended cell set C ex is determined (line 21). For each edge in G , if one of its two vertices is in the extent cell set C and the edge X  X  corresponding device is not in critical devices set, the device is a CLASS5 critical device (lines 22 X 25).

For each device in the covered device set, all the corresponding active objects from DHT are added to the certain result (lines 26 X  27). For each device in the intersected device set, all the corre-sponding active objects from DHT are added to the uncertain re-sult (lines 28 X 29). For each cell in the covered cell set C corresponding deterministic objects from CDHT are added to the certain result (lines 30 X 31). If the covered cell set has more than one cells, each nondeterministic object in these cells is checked. If all its possible cells OHT [ o ] . IDSet are in C c , the object is added to the certain result. Otherwise, the object is added to the uncertain result (lines 32 X 37). If C c has only one cell, all the correspond-ing nondeterministic objects from CNHT are added to the uncer-tain result (lines 38 X 39). For each cell in the intersected cell set, both deterministic objects from CDHT and nondeterministic ob-jects from CNHT are added to the uncertain result (lines 40 X 41). Then, the initial result sets are added to QHT (line 42). Finally, the DQHT is updated for each critical device (line 43-44). Algorithm 2 register (Range R , DeploymentGraph G ) 4: CriticalDeviceList(deviceID, CLASS) cd  X  X  X  ; 5: Generate a new identifier queryID for the query; 12: Add ( d , CLASS1 ) to cd ; 14: Add ( d , CLASS2 ) to cd ; 16: Add ( d , CLASS3 ) to cd ; 17: for each edge e in G do 22: for each edge e in G do 33: for each nondeterministic object o in C c do 36: else 38: else 43: for each item a in cd do
When the pre-processing module outputs a new observation ( deviceID , objectID , t, flag ) , the result of each query having deviceID as a critical device needs updating. The query update cases are summarized in Table 1, where CR ( UR ) is the certain (uncertain) result and the query result after each update is described. For simplicity, we use o to denote the moving object identified by objectID .

Upon receipt of a new observation O , the query update module only updates the results of those queries that O. deviceID maps to in DQHT . For each such query, action is taken according to Table 1.

If O is an ENTER observation, the observed object is enter-ing the activation range of the corresponding critical device. For a CLASS1 or CLASS2 critical device, whose range is covered by the query range, the object is definitely in the query range, so the object is added to the certain result of the query. If the object is originally in the uncertain result set, it is deleted. For a CLASS3 critical device, whose range intersects with the query range, the ob-ject is possibly in the query range. Therefore, the object is added to the uncertain result of the query. If the object is already in the certain result set, it is deleted. For a CLASS4 or CLASS5 critical device, whose range is disjoint from the query range, the object is definitely not in the query range. Therefore, the object is deleted from the certain or uncertain result of the query as necessary.
If O is a LEAVE observation, the observed object is leaving the activation range of the corresponding critical device. After leaving a CLASS1 critical device X  X  range, all the possible cells in which the object can be are fully covered by the query range, so the object is still definitely in the query range. Therefore, the object should remain in the certain result, which means that the query result needs not be updated. After leaving a CLASS2 critical device X  X  range, the object may enter the adjacent cell that is not fully covered by the query range. Thus the object may not be in the query range. Therefore the object is added to the uncertain result and removed from the certain result if necessary.

After leaving a CLASS3 critical device X  X  range, cells in which the object may be intersect with the query range. The object should be still in the uncertain result set. Therefore, the query result needs no update. After leaving a CLASS4 critical device X  X  range, cells in which the object may be intersect with the query range. The object is therefore added to the uncertain result set. After leaving a CLASS5 critical device X  X  range, the object must be still out of the query range. Therefore, the query result needs no update.
If the maximum speed of a moving object is known, the query result update can be deferred, which improves query accuracy.
Consider query 1 in Figure 5. According to Table 1, after an object o leaves a CLASS2 critical device device 13 , o should be moved from the certain to the uncertain result. Let object o  X  X  maxi-mum speed be V max , and let the time span from its latest LEAVE observation on device 13 to current time be  X  t . The longest possi-ble distance o can move from the boundary of the device 13 tion range is R 1 = V max  X   X  t . In other words, the possible region of o is constrained by a circle with the deployed location of device as the center, and the radius of device 13 plus R 1 as the radius. If this maximum speed constraint circle is still in the query range, the moving object is still definitely in the query range and the certain result. Consequently, we can maintain the certain result without updating for an extra period of time  X  T .

Assuming that function minDist ( deviceID , R ) returns the min-imum indoor walking distance from the boundary of a device X  X  ac-tivation range to that of a given query range R , the aforementioned  X  T is determined as minDist ( deviceID , R ) / V max . After time period  X  T , the moving object may leave the range, and we can-not guarantee that it remains in the certain result. Notice that the minimum indoor walking distance is different from the shortest Eu-clidean distance, as we shall see later.

According to Table 1, if a moving object o leaves a CLASS4 critical device, e.g., device 1 for query 1 in Figure 5, o is added to the uncertain result of the query. As a matter of fact, only af-ter some time  X  T = minDist ( device 1 , R ) / V max , can the object o possibly enter the query range. As shown in Figure 5, the func-tion minDist ( device 1 , range ) returns the minimum indoor walk-ing distance, which is R 3 + R 4 rather than the Euclidean distance R . Because the Euclidean distance line segment R 2 is intersected by room 14, it is impossible for an object to walk along R sequently, the uncertain query result can be maintained without up-dating for a longer time.

However, deferred query result updates based on the maximum speed constraint are only applied to LEAVE observations that are from CLASS2 and CLASS4 critical devices. Let t be the time when the latest LEAVE observation of o on deviceID is produced and let  X  T = minDist ( deviceID , R ) /V max .

If deviceID is a CLASS2 critical device, object o is kept in the certain result from time t until time t +  X  T when o will be moved to the uncertain result. We call such an update a C2U deferred update. If deviceID is a CLASS4 critical device, object o will not be added to the uncertain result until time t +  X  T . We call such an update an N2U deferred update.

In order to execute deferred updates efficiently, each query main-tains a deferred update table (DUT) which is a hash table defined as follows: where T indicates the time when the deferred update should be executed, objectID indicates the object involved, and TYPE indi-cates the type of the deferred update.

The elements in DUT are sorted non-decreasingly on the future update time T . Each time when the query is to be updated, the query processing module needs only to check the first record of DUT to determine whether there is any deferred update to execute. If the object in DUT enters the activation range of any critical device before the deferred update time, the corresponding record should be deleted from DUT .

To incorporate deferred query result updates, the query update module needs slight changes as follows. For an ENTER obser-vation, if the object is in DUT , the corresponding record should be removed from DUT . For a LEAVE observation, if the critical device is a CLASS2 device, a C2U update record is created and inserted into DUT with the corresponding future update time. If the device is a CLASS4 device, a N2U update record is created and inserted into DUT .
Given a range monitoring query and a moving object o in its uncertain result, we intend to infer the probability that o is in the query range R . We assume that the possible locations of an object o in a given indoor space conform a uniform distribution within all reachable regions constrained by o  X  X  maximum speed. The binary relationship o  X  R denotes that the object o is in the range R .
Recall from Section 4.3.2 that all the objects in the activation range of a CLASS3 device d form the uncertain result of the rel-evant query. We first infer the probabilities for such objects based on the areas of the regions in which objects can be. Formally, the probability that an active object o is in the range R is defined as:
In Figure 5, device 16 is a CLASS3 device for query 1 , and the probability for an active object in device 16 to be in the query range
As described in Section 4.3.3, after leaving a CLASS2 , CLASS3 , or CLASS4 critical device, an inactive object is added to or kept in the uncertain result of the query. For such inactive objects, which are currently in cells, the probabilities can be defined based on the maximum speed constraint.

We use the binary relationship o  X  d to indicate that the inactive object o has most recently left critical device d . Let the set CD234 contain all the CLASS2 , CLASS3 , and CLASS4 critical devices for a given query. The probability that an inactive object o is in query range R is defined as:
For each object o in the uncertain set, the positioning device d which o has just left can be exactly determined through the query update module. The probability prob ( o  X  d ) equals 1 for this par-ticular device d and equals 0 for all other devices in CD234 . Let H be the assumption that indicates this fact. We then need to consider the probability prob ( o  X  R, H ) , which indicates the probability that object o is in the query range R given assumption H .

After leaving the positioning device d , the object should enter one of the cells in the set C d = G.`  X  1 E ( d ) . Therefore, the probability can be defined as follows: prob ( o  X  R, H ) =
If the device d is a DP or PR device, the object must enter exactly one specific cell. The probability of the object being in this cell is 1. If d is a UP device, the object may enter an arbitrary cell in the cell set C d . Assume that the function Bound ( deviceID , cellID ) returns the length of the boundary of the device X  X  activation range that falls in the cell. The probability that an object enters a cell c i  X  C d is defined as:
Let the maximum speed of object o be V max and assume that o left critical device d at time t . Function Circle ( time , deviceID , objectID ) returns the maximum speed constraint circle with re-spect to the parameters given. Binary relationship  X  indicates an indoor accessible intersection , which returns the accessible inter-section of two indoor regions. For simplicity, we use Circle for Circle ( t, d, o ) . We then have: Refer to the example in Figure 6. Assume that the assumption H indicates that object o most recently left device 12 at time t . The object o is constrained in its reachable region, i.e., the maximum speed constraint circle, which is shown as the dashed circle R the left in Figure 6. Let the maximum speed be V max and let the time span from the current time to t be  X  T . Then R 1 =  X  T  X  V Although the circle with radius R 1 intersects with room 14, the circle does not intersect with the door of room 14. This means that the object cannot enter room 14 within time span  X  T .

Next, let the minimum indoor walking distance from the door to the boundary of device 12 be l = minDist ( device 12  X  T &lt; l / V max , the object cannot enter room 14. Here, c denotes the accessible intersection between the maximum speed constraint circle R 1 and the part of cell c 10 within room 10. Con-tinuing, c 10  X  Circle u R is the intersection between the accessible region c 10  X  Circle and query range R , shown as the shaded region to the left in Figure 6.

As time passes, if  X  T  X  l / V max , the moving object can possibly enter room 14. The reachable region in room 14 is the maximum speed constraint circle with R 2 = V max  X  ( X  T  X  l / V max and the location of the door as center.

The region of c 10  X  Circle is composed of two parts. The first part is the intersection of the room 10 part of cell c 10 imum speed constraint circle R 3 =  X  T  X  V max . The second part is the intersection between the room 14 part of cell c 10 and the circle with radius R 2 . Similarly, c 10  X  Circle u R is the intersection re-gion between c 10  X  Circle and query range R , shown as the shaded region to the right in Figure 6.

Next, we define the relationship  X  . Given a cell c , we can ob-tain all its rooms through the Cells mapping defined in Section 2.2. For a cell with more than one room (indicated by | Cells ( c ) | &gt; 1 ), we partition it into a direct part and an indirect part . The direct part is the region reachable without any constraint, e.g., room 10 in cell c 10 in Figure 6. The indirect part is the region only reachable through some constraint, e.g., room 14 in cell c 10 is only reachable through the door.

Given a cell c and a device d , function DP ( c, d ) returns the di-rect part of c for d , and IP ( c, d ) returns the indirect part. Note that the same room in the same cell can be a direct or an indirect part depending on the device assumed. Consider cell c 30 in Figure 1: for device 30 , room 30 is the direct part and room 34 is the indirect part. The arrangement for device 34 is the opposite.

After leaving a device at time t , the reachable region for object c in a cell c is defined as follows:
The reachable region involves two parts. The first part is the inter-section between the direct part of the cell and the maximum speed constraint circle with time parameter t (that can be obtained from the assumption H ).

The second part is the intersection between the indirect part of the cell and the maximum speed constraint circle with time param-eter t 0 , the time when the object satisfies the constraint to enter the indirect part. In the running example, t 0 is the time when object o reaches the door of room 14. This t 0 is determined by the minimum walking distance l and the maximum speed, i.e., t 0 = l / V
Note that the minimum walking distances from different devices to the same indirect part are different. For example, in Figure 6, the distances from devices device 10 and device 12 to the door of room 14 are different. As a final remark, the minimum walking distance from a device to a given indirect part is determined by the floor plan and the positioning device deployment. Such distances can be calculated by the query registration module and recorded in the system for future use. We use both synthetic and real data in the experimental study. We generate moving objects using a 3-floor building plan with 30 rooms and 3 staircases on each floor. All rooms and staircases are connected by doors to a hallway in a star-like manner. An RFID reader is deployed by the door of each room. In addition, readers are deployed along the hallways and in the staircases. A total of 143 RFID readers are deployed. According to the definition of par-titioning and presence devices in Section 2.2, the readers deployed by doors are undirected partitioning devices; and those deployed along the hallways and in the staircases are presence devices.
Three rules are used to generate movements: 1) an object in a room can move to the hallway or move inside the room; 2) an object in a staircase can move to the hallway or move in the staircase; 3) an object in the hallway can move in the hallway, move to one of the staircases, or move to one of the rooms. At each step, an object randomly chooses a room as the destination. If the destination room chosen is on the same floor as the object, it will move according to the minimum indoor walking distance. Otherwise, it will use the nearest staircase. After the object gets into the destination room, it will move inside the room for a random time duration and then start a new movement. All objects move with the constant speed of 4 km/hour. We vary the number of indoor moving objects and the radius of the activation ranges of the positioning devices according to Table 2, with default values shown in bold.

We use a real data set collected from Copenhagen Airport. More than 1,000,000 tracking records from 25 Bluetooth hotspots are col-lected each day. We extract the tracking data on the most active day from April 2008 to October 2008. The total number of mov-ing objects, i.e., those passengers with Bluetooth enabled devices in Copenhagen Airport, is 9,638. More than 1.1M tracking obser-vations are recorded in around 110K sampling units.
 In the experimental study, we compare three methods: (1) Naive Method (NM): When a new observation is produced by the pre-processing module, every query is reevaluated. We use this naive method as a baseline. (2) Periodical Method (PM): The query pro-cessing module searches the index and updates the query results periodically. The query result is obtained from the corresponding hash tables in the same way as in query registration (Algorithm 2). In the experiments, we set the period of PM to the sampling pe-riod of the positioning devices. The number of positioning devices is large, and they are usually not synchronized, which means that the pre-processing module can produce more than one observation within a sampling period. As a result, the reevaluation frequency of NM is higher than that of PM. (3) Critical Devices Method (CDM): The method we propose in the paper. A computer with Windows XP professional, a 2.66GHz Core2 Duo CPU, and 3.25GB main memory is used to run all experiments.
Since the QHT and DQHT are stored in the main memory, we give a brief analysis on their worst-case memory consumption with respect to the synthetic data.

Each key (query identifier) in QHT has two bitmaps, for certain result and uncertain result respectively. We use an int value for each query identifier, which occupies 4 bytes. A 6,250 byte bitmap is enough for representing the 50K moving objects, which is the largest number of objects in the experiment 2 . As a result, each entry in QHT is 12,504 bytes. For 5K queries, the total size of QHT is 5K  X  12,504= 62.52M bytes.

The size of DQHT is related to the query range. A bigger query range results in more corresponding critical devices. In the worst case, the range can be the entire indoor space, which makes all positioning devices critical. We use an int value for each device identifier and a 1 byte byte value to indicate the class of each critical device. If the 5K queries have the whole indoor space as their query ranges, the largest size of each entry in DQHT is (4+5K  X  (4+1))= 25,004 bytes. For all the 143 devices, the size of DQHT is 143  X  25,004  X  3.5M bytes, a modest main memory consumption.
During continuous query updating, different methods use differ-ent numbers of observations to update the query results. We quan-tify a workload by the average number of observations used within each sampling period to update the query results. We use synthetic data in this experiment. Our CDM method is able to reduce the workload significantly, as seen in Figure 7. For both NM and PM, all the observations from the pre-processing are used to reevaluate queries because they are query blind. For CDM, only the observa-tions from critical devices are considered for a query.
In Figure 7(a), we fix the number of queries at 1K and vary the number of objects from 1K to 50K. The workloads of NM and PM increase markedly with increasing numbers of objects, while CDM performs much more steadily.

To observe the effect of the activation range, we vary the radius from 100cm to 250cm. The results are reported in Figure 7(b). As the number of observations after pre-processing is affected only little by the varying radius, the workload is also stable. Note that CDM outperforms NM and PM significantly.
We proceed to compare PM and CDM in terms of the efficiency of the continuous query result update. We consider the average CPU time spent on query result update per sampling unit. We omit NM because it incurs considerably more time by reevaluating each query whenever a new observation arrives. In a real setting, the indoor positioning devices can produce large numbers of raw read-ings and pre-processing observations, rendering NM infeasible.
Using the synthetic data, we fix the number of queries at 1K and vary the number of moving objects and the activation range. The results are reported in Figure 8. It is seen that CDM is considerably more efficient than PM. In PM, all queries are reevaluated every sampling period. The query processing module fetches its results from corresponding hash tables for all queries. The time used re-mains constant for varying object counts and activation ranges, ap-proaching 1.5 seconds per sampling period. This indicates that only if the sampling period of positioning devices exceeds 1.5 seconds can the system guarantee that all queries are always reevaluated on time. In a real setting, however, the sampling unit is usually smaller than 1.5 second [19].
In CDM, query results are updated incrementally only when a new observation comes from a critical device. As a result, contin-uous query result update consumes much less time than does PM. This indicates that CDM is a practical and efficient solution in a real setting.

The cost of one-time query registration in CDM is almost the same as that of a result update in PM. The cost of un-registering a query is similar to that of a result update in CDM, as it only deletes relevant items from the memory-resident DQHT and QHT .

To investigate the effect of the deferred query result updates that exploit the maximum speed constraint (MSC), we compare the time difference between CDM with MSC and CDM without MSC.

Since the maximum speed constraint only applies to observations from CLASS2 and CLASS4 critical devices, we generate a set of queries that concern only CLASS2 and CLASS4 critical devices. The number of such queries is varied from 500 to 5K. The default values are used for the object number and activation range.
For each query, the minimum indoor walking distance from the query range to each critical device is calculated and recorded during query registration. As these distances are constant, we do not need to calculate them repeatedly during continuous query result update.
The relevant results are reported in Figure 9. The computation cost increases as the number of queries grows for both methods. Although the processing cost of CDM with MSC is higher than that of the CDM without MSC, the total processing time is still quite low, i.e., less than 0.2 seconds per sampling period, and it is still much better than PM (around 1.5 seconds per sampling period; see Figure 8). Figure 9: Deferred Query Re-sult Update
Next, we investigate the efficiency of the probabilistic analysis proposed in Section 4.4. We generate a set of queries, each with a room as its range. The Monte Carlo method is employed to com-pute the relevant areas used in the definitions in Section 4.4. We set the basic unit to 5cm  X  5cm, 10cm  X  10cm, and 20cm  X  20cm, respectively, and the area is measured as the number of units. A smaller unit produces more accurate results while also yielding a higher computational cost, as shown in Figure 10. The probability is reevaluated for every sampling unit. As time passes, the radius of the maximum speed constraint circle increases and thus results in higher computational cost. For the 20cm  X  20cm unit setting, which is an acceptable accuracy level for indoor space, the pro-cessing time is the lowest, and it remains largely constant.
Finally, we investigate the scalability of PM and CDM by vary-ing the query number from 500 to 5K. We use the real data set in this experiment. We consider both the workload and query up-date efficiency. The average numbers of used observations for each query per sampling unit are reported in Figure 11(a). Both CDM and PM exhibit near constant performance, with CDM using much fewer observations.
The results on average CPU time for updating the query results per sampling period are reported in Figure 11(b). As the number of queries increases, PM degrades markedly; in contrast, CDM per-forms is almost unaffected, with only a slightly visible CPU cost increase. The results indicate that CDM is scalable in terms of the number of concurrent queries.
Various techniques have been proposed for continuous range mon-itoring queries in the context of outdoor free-moving objects. The basic method to process continuous queries involves periodic reeval-uation [6, 15, 16]. The degree of accuracy is largely determined by the reevaluation frequency, which is hard to optimize.

To facilitate query processing, indexes [17, 18] have been pro-posed for the current locations of moving objects that are modeled as linear functions of time. Alternatives [4, 11, 13] support frequent location updates of moving objects. By differentiating positive and negative updates on the query result, incremental processing re-duces the workload in reevaluation [15]. These proposals are not suited for indoor moving objects because they assume that the ob-jects move in Euclidean spaces.

Querying imprecise outdoor location data has been studied re-cently. Cheng et al. [5] propose a framework to process the prob-abilistic range query and nearest neighbor query over moving ob-jects. Ishikawa et al. [12] consider queries with imprecise query locations against exact locations. Yiu et al. [14] study probabilis-tic queries on existentially uncertain data. The techniques in these works, however, are not directly applicable to our indoor setting.
This paper addresses incremental and query-aware processing of continuous range monitoring queries against objects moving in symbolic indoor spaces. Based on an indoor positioning device de-ployment, states of the indoor moving objects are identified, which in turn are utilized to design effective indexing structures for the in-door moving objects. Given a continuous range monitoring query, its critical devices are identified to obtain the initial query result and significantly constrain the search space for future query result up-dates. Due to the limitations of indoor positioning devices, query results are partitioned into certain and uncertain parts. By taking advantage of the categorization of critical devices, query results are updated in an incremental manner. Exploiting a maximum speed constraint for objects, the paper also offers a probabilistic analysis of the uncertain query results. An experimental study is conducted on both synthetic and real data. The results suggest that our pro-posal is efficient and scalable.

Several interesting research directions exist. First, it is possi-ble to share query processing cost among concurrent queries so as to reduce the overall system overhead. Critical devices common to multiple queries can be identified and exploited for that pur-pose. Second, it is of interest to consider other types of monitoring queries, e.g., range and k NN queries that are attached to moving objects. Third, it is interesting to conduct probabilistic analysis on other kinds of object distributions, e.g., Gaussian distribution. Acknowledgments This research was partially supported by the Indoor Spatial Awareness project of the Korean Land Spatialization Group and BK21 program. C. S. Jensen X  X  work was done when he was a Visiting Scientist at Google Inc.
