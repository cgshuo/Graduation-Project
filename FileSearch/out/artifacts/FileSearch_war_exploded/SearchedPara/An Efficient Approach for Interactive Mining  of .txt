 community due to its wide applicability in many areas. Frequent itemset mining plays an essential role in many important data mining tasks such as associations [1], corre-problem is formulated as follows: given a large database of transactions, find all fre-categories. One utilizes the traditional horizontal transactional database format, and the other utilizes the vertical transactional database format. Apriori [6] and FPgrowth [9] are most important algorithms belonging to the first category and Eclat [10] is one of the most important algorithms belonging to the second category. As mentioned in [11], mining algorithms using the vertical format have shown to be very effective and usu-ally outperform horizontal approaches. 
However, most of the previous work has focused on mining frequent itemsets under very little work has been done on the mining problem where minsup may change. As stated in [12], users are often unsure about their requirements on the minimum support resulting from different threshold settings. Therefore, they may have to re-execute the mining procedure many times with varied thresholds in order to get satisfied results in thresholds are wasted. As a result, it is both desirable and imperative to develop effec-tive approaches for interactive mining, which is the problem of mining frequent item-[12] for interactive mining has been developed. It is based on the Apriori algorithm and needs n passes over the database where n is the size of the maximal frequent itemset. One year later, Remining [13] based on FPgrowth was proposed. Although it avoids the problem of scanning database n times, it must re-examine all existing frequent itemsets strategy of FPgrowth. 
In this paper, we present an algorithm to find the new frequent itemsets with minimal re-computation when the minsup is changed. Our algorithm overcomes the shortcom-ings of Posteriori and Remining by maintaining a vertical itemset tree. The important characteristics of our algorithm are the following: 2. We use a novel data structure called vertical itemset tree (or VI-tree for short) 3. Our algorithm just needs one scan of the database in initial mining procedure. problem description. Section 3 introduces the vertical itemset tree and its construction method. Section 4 develops a VI-tree based interactive mining algorithm of frequent and points out some future research issues. 2.1 Mining of Frequent Itemsets contains A if and only if A  X  T . The support of A is the number of transactions con-predefined minsup  X  . 
Given a transaction database DB and a minsup  X  , the problem of finding the com-plete set of frequent itemsets is called the frequent itemsets mining problem. 2.2 Interactive Mining of Frequent Itemsets Let FI be the set of frequent itemsets in the database DB , and  X  be the minimum sup-port. After users have found some frequent itemsets, they may be unsatisfied with the support thresholds, such as from  X  to  X  X  . We call mining frequent itemsets under dif-ferent minsups is interactive mining of frequent itemsets. The essence of the problem of interactive mining is to find the set FI  X  of frequent itemsets under a new minsup  X  X  . 
When the minsup is changed, two cases may happen: 1.  X &lt;  X  X  : some frequent itemsets in FI will become infrequent under  X  X  . Therefore, 
For the first case, the finding of frequent itemsets is simple and intuitive. Just select can be found in [12]. In the paper, we concentrate on the second case. 3.1 Preliminaries Because the vertical itemset tree is based on vertical transactional database format, we first introduce vertical data layout as preliminaries in this session.
 id tidset of A , is defined as follows: The right of Table 1 illustrates the vertical format of SDB . 3.2 Vertical Itemset Tree To design a data structure for efficient interactive mining, let X  X  first examine the ways rithms have been proposed [10, 11, 14, 15] that use vertical data layout. In this paper, we discuss Eclat. listed in some order, such as support ascending order or lexicographic order. Define an a prefix-based equivalence relation [10]. The equivalence relation partitions the set I into disjoint subsets called equivalence classes. Eclat is based on a recursive decom-using intersections of tidsets of frequent items. 
In Figure 1, we assume that the minsup is 4 and the items list as the children of root according to their support descending order. For each frequent node (itemsets) A , from ( a are the equivalence class with a as common prefix. Although ac is a frequent children itemsets. It is obvious that all frequent itemsets (minsup is 4) are in the tree showed by Figure 1. For more information about Eclat, please refer to [10]. 
Let us examine what we will get if minsup change from 4 to 3. Figure 2 shows the result of vertical mining when the absolute minsup is 3. We can find facts as follows. 2. All new nodes of Figure2 originate from nodes that are infrequent under 4. without re-structuring it. The vertical itemset tree can be constructed as follows. 
First, we change the tree generated by vertical mining with attaching each node with its tidset. 
Second, to facilitate finding infrequent itemsets in the tree, a table is built in which node-link. For judging whether an infrequent node is frequent or not under new minsup quickly, the support of each infrequent node is also contained in the table. The tree with the associated node-links is shown in Figure 1. If a node in the table is frequent under a generated as the children of d . As a result, we can expand the tree in Figure 1 into the tree in Figure 2. Of course, the table also should be modified for further mining when the minsup is changed again.
 These examples lead to the following design and construction of a vertical itemset tree. 
Definition 1 (VI-tree): Given a transaction database DB and a minsup  X  . A vertical itemset tree (or VI-tree for short) is a tree structure defined below. 1. It consists of one root labeled as  X  X ull X , which lies in level 0. 2. Sort I (the set of all items) in support descending order as OI . Without lost of 3. Given an existing node A , if A is frequent, A will be used to generate its chil-4. Each node has two fields: itemset-name and tidset, where itemset-name reg-According to the definition of a VI-tree, we have some properties as follows. the form of a i 1 a i 2 ... a ik a x , where x &lt; i j for all j (1  X  j  X  k ). Rational. Refer to 2 and 3 in the definition of a VI-tree. a a i 2 ... a ik a x , B must be a child of A . a a . Therefore, we have C = A . Property 3: all frequent itemsets are in the VI-tree. Rational. According to the definition, the procedure of the VI-tree actually enumerates all frequent itemsets by breadth -first or deep-first manner. 
Based on this definition, we have the following VI-tree construction algorithm, found as byproduct in our algorithm. Algorithm VIC (VI-tree construction) Input: A transaction database DB and an initial minsup  X  . Output: Its vertical itemset tree ( VIT ) and the set of all frequent itemsets ( FP ).
Method: 1. Create the root of a VI-tree, VIT , and label it as rt . 2. Scan the transaction database DB once. Collect the set 3. For each item a in L , do 4. Call TBD-growth( rt ,  X  ). 
Procedure TBD-growth(F_node,  X  ) become small without re-structuring a new VI-tree under new minsup. In this section, we will study the equivalence of the expanding VI-tree and the new VI-tree. Based on itemsets.  X  X  VI-tree constructing on DB with  X  X  . Definition 2 gives the procedure for expanding T when the minsup is changed from  X  to  X  X  . the NB_table and is used to generate all of its descendants if its support is no less than  X  X  . The process of generating A  X  X  descendants is showed as follows: 2. after generate all children of A , all no-child descendants of A will be generated 
It should be noted that the processing order of nodes in the NB_table is in the de-Property 2. Now, we show that T 1 also have Property 3. the set of the children of X be X VT .children. We have following Lemma. Lemma 1: T 1 and T  X  have the relations as follows: 1) A (  X  I ), if A  X  T 1 .Nds, then A  X  T  X  .Nds, and vice versa. of an itemsets X be X .sup. We first proof 1), and then proof 2). The Proofing of 1): Let A = a ik ... a i 2 a i 1 , where i x &lt; i y if x &lt; y .  X  A  X  T A  X  ( T of  X  X   X  X  . According to the construction of T  X  , a a  X  A  X  T  X  .Nds. According to the construction of T  X  , we know a a ( a a should be in T 1 . That is, A  X  T 1 .Nds. The Proofing of 2):  X  A  X  T T  X  .Nds. As a result, According to Property 2, we have A 1  X  A T  X  .children.  X  A  X  T  X  .Nds, A  X  A T 1 .children. trees. Corollary 1: T 1 contains all frequent itemsets under  X  X  . nodes. 
Because itemsets that are frequent with minsup  X  are also frequent with minsup  X  X  , we should only find new frequent itemsets 2 in order to get all frequent itemsets when expending T into T 1 according to definition 2. The following Algorithm gives the de-tails. Algorithm VIBIM (VI-tree Based Interactive Mining) Input: VIT and FP under old minsup  X  , and new minsup  X   X  &lt;  X  ; Output: modified FP and modified VIT under  X   X  . Methods: In this section, we present a performance comparison of our approach (VIC+VIBIM) proach runs VIC for the first time mining of frequent itemsets, and then run VIBIM for the later mining procedure under small minsups. It should be pointed out again that we just consider the case where the new minsup is smaller than the old minsup. For the case, where the new minsup is greater than the old minsup, The procedure of mining frequent itemsets is trivial because we can just select those old frequent itemsets with support no less than new minsup in order to get all new frequent itemsets. 
All the experiments are performed on a 1.4-GHz Pentium notebook PC machine with 512 megabytes main memory, running on Microsoft Windows XP. All programs solute number of runtime with those in [10] because different programs may differ on the absolute runtime for the same algorithms. Instead, we implement Eclat in [10] in generated using the procedure described in [6]. We report experimental results on two itemset size, and D denotes the number of transactions. Let us consider the case  X   X  &lt;  X  , the runtime of Eclat and VIC+VIBIM for DB 1 and DB 2 are plotted in Figure 3 and Figure 4 respectively. We start the mining with relative turn. By multiplying relative threshold by D (the number of transactions), It is easy to VIC+VIBIM is much faster than Eclat except for the first time mining. Because VIC, which is used at the first time mining in our approach, is equal to Eclat in terms of the process of mining except that VIC constructs a VI-tree in the first time mining. Figure 3 shows that VIC+VIBIM is 4 to over 1000 times fast than Eclat, and over 200 times in average. Figure 4 shows that VIC+VIBIM is 10 to over 1000 times fast than Eclat, and over 400 in average. All these figures show that our approach outperforms algorithms proposed in [12, 13], where the speedup radio is between 2 and 6. We studied an efficient approach for interactive mining of frequent patterns. Our ap-proach has characteristics as below. First, by generating and maintaining a TV-tree, the developed technique can fast find all new frequent itemsets under new minsup without re-examining old frequent itemsets. Second, no scanning of databases are needed ex-mining than others existing algorithms. 
Recently, there have been some interesting studies at mining maximal frequent itemsets [16, 17] and closed frequent itemsets [18, 19]. The extension of our technique research. In addition, we also take efforts towards space-preserving interactive mining. Acknowledgement. This research is supported by the National Natural Science reviewers for their comments. 
