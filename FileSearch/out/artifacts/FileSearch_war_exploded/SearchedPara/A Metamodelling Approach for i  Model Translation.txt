 The i* (pronounced i-star ) framework [1] is currently one of the most widespread goal-and agent-oriented modelling and reasoning frameworks. It has been applied for modelling organizations, business processes and system requirements, among others. 
Throughout the years, different research groups have proposed variations to the name it  X  X he i* language X ). There are basically two reasons behind this fact:  X  Some groups have used the i* framework with very different purposes thus differ-The adaptability of i* to these different needs is part of its own nature, therefore these variations are not to be considered pernicious, on the contrary, flexibility may be considered one of the framework X  X  key success features. However, there are some obvious implications that are not so desirable: The work presented here addresses these problems and specifically tries to answer the following research questions:  X  What types of i* variations are proposed and how can they be characterized?  X  Which is an appropriate semantic framework for analysing i* interoperability? The rest of the paper is structured as follows. Section 2 provides the background about i* variations. Section 3 presents the metamodel framework for translation re-marking why the concepts of supermetamodel and semantic-preservation can be used for dealing with interoperability among i* variants. Section 4 proposes the super-metamodel for i* variants, and Section 5 presents a translation algorithm to maximize semantic-preservation illustrated with an example of model interchange between two i* tools. Finally, Section 6 states the conclusions and future work. 
Basic knowledge of i * is assumed, see [1] and the i * wiki [4] for details. posed and used in KAOS [5] and in the NFR Framework [6]. This original work on i* has been the most cited in the community. Recently, an updated version has been included as part of the i* wiki [4], with minor differences with respect to the seminal one (e.g., richer types of contribution links). From this major trunk, we may consider two main variations. On one hand, the Goal-oriented Requirement Language (GRL) which is part of the User Requirements Notation (URN) [7]. On the other hand, Tropos [8], an agent-oriented software with respect to the seminal Yu X  X  i* are not that relevant to consider them as different notations, but due to its adoption by the community we consider them as major varia-tions. Thus, we may say that i* has three main dialects: the seminal i* currently repre-sented by the wiki definition, GRL, and the language adopted by Tropos. 
On top of these three main dialects, we may find many proposals for particular purposes. Some of them are bound to a particular domain, e.g., security as in Secure-Tropos [9], or norm compliance as in N X mos [10]. Others propose very particular some others propose more fundamental variations affecting the way of modelling, as the concepts of service, variation point or aspect. 
Table 1 presents a comparative analysis of the proposals issued by the community journals for the period 2006-2010: CAiSE, REJ, DKE, IS Journal, RE, ER, RiGiM, been carrying out a systematic review but to get a representative sample of the com-munity proposals in this period as a way to know what the major trends concerning language variability are. In total, we have found 146 papers about i* in these sources (without including papers talking about goal-modelling, since we are interested in language-specific issues). From them, we have discarded 83 which are not really relevant to our goals (i.e., papers not directly related with the constructs offered by the language). For the remaining 63, the table shows how many of them propose addition, removal or modification of concepts classified into six different types. It must be taken into account that a single paper may propose more than one construct variation and that similar changes are proposed or assumed in different papers. Also it is neces-that case we assume that the other part remains unchanged. 
An analysis of this table follows:  X  On actor links. Most of the variants include is_part_of and is_a but some get rid  X  On intentional elements. Although all virtually all variants keep the four standard  X  On intentional element links. Most of the variants keep the general idea of the  X  On dependencies. About modifications, we may find the addition of attributes  X  On diagrams. The distinction among SD and SR diagrams is not always kept, The result of this study shows the complexity of the model transformation problem. In fact, one may easily anticipate that it will be impossible to get an automatic transfor-mation technique for any pair of existing proposals. It becomes necessary to investi-gate the limits of model transformation in i* and provide a general customizable framework. Metamodels have been the traditional tool in Software Engineering to express valid models of a certain modelling language [11]. The language used to specify a meta-model is called metalanguage. Note that metamodels represent only what can be ex-pressed in valid models but not what these expressions mean, i.e., a metamodel speci-fies the syntax of a modelling language but not its semantics. correspond to their own metamodels which are expressed using different metalan-guages (e.g., UML, EBNF, Telos). The problem of transforming a source model into a target model can be viewed as a particular case of applying general rules to transform the differences between the corresponding metamodels. 3.1 Wachsmuth X  X  Proposal on Metamodel Adaptation In 2007, Guido Wachsmuth presented a proposal [12] to deal with the problem of metamodel evolution and its implications for adapting its instance models according models can be automatically derived from well-defined metamodel evolution steps. Wachsmuth defines different semantic-preserving categories and matches them with specific refactoring operations on metamodels. The way of handling semantic-preserving features respond to the concept of semantics already introduced, i.e., se-mantic preservation is not characterized by meaning but by structural changes on corresponding metamodels. 
Here, we are proposing the adoption of this framework in the context of the prob-lem of translating models among metamodels which have a common set of concepts (see Fig. 1, right). In other words, we change the perspective:  X  from: given a model m A created as instance of a metamodel M A , translate it into 3.2 Wachsmuth X  X  Proposal: Relationships and Semantic Preservation To characterize refactoring operations Wachsmuth proposes some basic concepts:  X  M M represents all the metamodels conforming to a specific metamodel formalism M, denoted by M M := {  X   X  M}. Although it is not really relevant, we may assume 
MOF 2.0 formalism in this paper.  X  typical concepts would be actor , intentional element , etc.  X 
I(  X  ) represents the set of all metamodel instances conforming to a metamodel  X  , model of some i* variation (e.g., i*-wiki metamodel, GRL metamodel, Tropos metamodel) and then for each  X  , I(  X  ) are i* models built as instances of  X  .  X  metamodel  X  . Using these concepts, 5 types of generic relationships between metamodels are defined (see 1 st and 2 nd columns of Fig. 2.) which yield to 5 degrees of semantic pres-ervation. The transformation from one metamodel to another implies a relationship R between the source and target metamodels, thus, the type of semantic preservation of types of instance preservation (see 4 th column of Fig. 2). 3.3 Wachsmuth X  X  Proposal: A Framework for i* Interoperability As we have already said, most of the i* variants have their own metamodel which conforms a different modelling formalism. However, this diversity of formalisms seems to be just a representational problem. We have assessed this opinion in earlier works by proposing an i* reference metamodel and proposing a set of refactoring operations to allow obtaining the different variants [13]. 
But this preliminary result that we obtained, although valuable as a first step, exhib-its an important drawback that the set of common concepts was intentionally kept to a minimum (i.e., we wanted to represent the universally agreed concepts). Whilst provid-ing a good ontological basis, this decision was damaging the model interoperability goal that we are targeting here. Wachsmuth allows stating the reason why: model translation was suffering from eliminating or decreasing semantic preser-vation. In this work, we search for the fundamental property of instance preservation: given an i* model that is instance of a metamodel M A that represents a source variation then, when applying the mapping from M A to M B (the metamodel that represents the target varia-tion) the model can also be considered an instance of M B . 
Let X  X  assume that a model, named the i* supermetamodel, exists, therefore any ex-isting metamodel of i* variation is a submetamodel of the i* supermetamodel. Then, if we could model refactoring operations from the i* supermetamodel to the particular variants, then we would have a feasible tran slation from each variant to another. This hypothetical scenario would exhibit three advantages: (i) supporting at some extent interoperability between models belonging to different metamodels; (ii) given k i* variants, providing a framework that offers translation from one variant to each other characterized with a clear sp ecification of preservation (strict, modulo varia-tion, increasing or decreasing). In Figure 3 we illustrate this hypothetical assumption. 
Although it may appear hard to sustain that such an i* supermetamodel exists (due to the continuous proposals that modify it), in the next section we will discuss supermetamodel approach will be presented. From its definition, we can colloquially understand a supermetamodel as a metamodel which contains the superset of language constructs existing on other metamodels. In the case of the i* framework, this means that if M is a supermetamodel for i* then the different values of softgoals contributions (some+, helps, makes, +, ++, -, --) should be modelled in M. Besides, the same for intentional element types, actor types, etc. 
Therefore, in the attempt of formulating a supermetamodel for the existing variants the same metamodel a set of different language constructs coming from different i* variants?, (ii) how to make this supermetamodel stable enough in order to suffer answer both questions, the key concept is abstraction to allow putting different structure which requires high effort to be refactorized. In the first case, an additional problem appears, because using a high abstraction level means adjusting basic syntax formations by means of textual (e.g., OCL) constraints, and textual constraints are not considered in the Wachsmuth X  X  framework, therefore semantic preservation could not be qualified. Therefore, we are looking for a metamodel which allows representing different i* variant structures and possible extensions whilst, at the same time, keep-ing the core i* language constructions. 
These two situations appear in the two most related works we may found in the lit-erature. Amyot et al. have proposed a metamodel for GRL [14] that contains concepts such as metadata, links and groupings that enable the language to be extended and tailored, also using OCL constraints. So it ma y be classified as too abstract. In addi-tion, it presents some peculiarities that forces its customization either in quite classical intentional elements X  are not allowed; dependencies without dependums are allowed) or in non-classical contexts (e.g., types of boundaries are impossible to be set). On the other hand, the reference metamodel presented by Cares et al. [13] proposes the use of refactoring operations to map into other variants. However, there are specializations for representing specific i* elements, therefore, adding a new language element would mean adding new classes to the metamodel. Thus, the reference model has a great value, but the problem comes when we want to use it in the context of model transla-tion since it would imply alterations to classes. 
The i* supermetamodel proposal is based on the reference model but incorporates the concept of metadata appearing in the GRL metamodel. From the i* reference model we obtain a more abstract metamodel using i* related concepts and their exten-sions are handled with metainformation. We formalize this idea into UML stereo-types. The result is the metamodel that appears in Fig. 4. Actor and IElement are the central classes. Then ActorLink and IElementLink are recursive binary associations on them. Boundary is a binary association among IElement and Actor (note that an IEle-ment may appear outside any boundary, e.g., dependums). Finally the concept of dependency is implemented with two associations: dependencies are divided into DependencySegment which is an easy way to allow different properties at each end, or even with just one end defined. Each DependencySegment connects an Actor (considered depender or dependee depending on the value of the participatorType particular IElement that would be an internal element inside the corresponding Actor . We remark that this high-level model is providing stability since abstract concepts are shared in the different variants, and accordin g to the historical track of the language, we may assume that future variants will still adhere to them. kind of enumeration class that may grow (i.e., may be assigned more values). We have included as class attributes only the most consolidated ones (i.e., name of Actor and IElement ; value of IElementLink as optional for those links without values; having an additional list of attribute-value pairs. To take full profit of this definitions, 
The i* supermetamodel as presented is capable to represent as instances those i* illustrate this expressive power we show, in Figure 5, an object diagram correspond-We may observe different usual elements (types of actors , goals , softgoals , etc.) then some particular elements, more precisely costs in contribution links (both a label and a quantitative value). We have tested the i* supermetamodel with additional represen-tations including service-oriented i* [16], i* with norms [10] and the different secure-oriented i* variants [9]. model cannot be considered an i* variant by itself. Although it is a metamodel, it just community, e.g., a belief decomposed into resources . Therefore, the i* supermeta-model has to be considered just a reference framework for supporting model interop-erability. Nevertheless, it must be mentioned that the i* supermetamodel does impose long to more than one actor. Other additional conditions are not shown graphically inside the boundary of the Actor linked by the segment: 
It must be mentioned that the current i* supermetamodel proposed here does not cover the complete range of constructs that appear in the state of the art, that remain for the next version. The elements remarkably left are: links to external elements (i.e., from other conceptual models, e.g., UML classes), boundaries other than actors and some types of intentional links (e.g., GRL X  X  correlations). Now we face the ultimate goal of our work: given a model m1 built as an instance of a metamodel M1 that represents a particular i* variant, how to proceed in order to ob-translation, we need an algorithm and a computational representation of the i* supermetamodel. 
Let X  X  start by the second point, which is simpler. As computational representation of the metamodel we use the iStarML interchange format [17]. It was designed with the reference model in mind but it may easily match the i* supermetamodel as well. XML was chosen as interchange language, therefore we may use a broad set of technologies in order to parse and process iStarML files. The particular XML ele-ments of iStarML correspond to supermetamodel concepts as we show in Table 2. 
For the translation algorithm, it is important to start reminding from Section 3 that, since we are using the i* supermetamodel, then the departing model m1 is considered an instance of the i* supermetamodel. Therefore the translation from the metamodel M1 to M2 should be considered in f act as a translation from the i* supermetamodel to metamodel, then the refactoring operations required for translation can be only to attributes. In our iStarML implementation, this means to omit some attribute of an Both types of translations (if any) can imply different semantic-preserving situations. 
In order to minimize information loss, an algorithm is proposed (Figure 6). It is presented as a UML activity diagram labelled with information about the semantic-preservation consequences co nsidering Wachsmuth X  X  framework. The activities are:  X  rectly considered as part of m2 . In other words, the concepts which are shared by both metamodels M1 and M2 are kept. In case that the full model m1 is a valid in-stance of M2 , we finish and classify the translation as strictly semantic preserving. 
Example: a generic actor is al ways kept as a generic actor.  X  been treated in the previous activity. The part of m1 A for which we may establish a bijective mapping between its elements and corresponding elements, which are instance of M2 , is translated using this bijective mapping. In other words, the concepts that can be expressed in both metamodels M1 and M2 but with different treated, then the translation is semantic preserving modulo variation . Example: a task can be translated into plan and a plan into a task .  X  been treated in the previo us activity. The part of m1 B for which we may establish an injective mapping from its elements to others which are instance of M2 , is trans-lated using this mapping. In case that after this activity the full m1 has been treated, then the translation is decreasing modulo variation (the variation introduced by the mapping). Example: a make contribution from GRL can be translated into ++ contribution in seminal i* , but not any ++ is a make contribution.  X 
Forget non translating formations . Finally, those constructs in m1 which have not been translated in the previous activities, are just removed. Example: a belief from GRL when translating into Aspectual i* . In order to illustrate the process, we have designed a proof-of-concept for translating models built with the OME tool [18] into the jUCMNav tool [19]. The metamodels involved are determined in this case by the implementation of the tool. Basically menting GRL X  X  metamodel, although a closer look reveals some minor differences algorithm we have used XSLT, a declara tive language for transforming XML files [20]. The algorithm is implemented as a Java applet and currently available at http://www.essi.upc.edu/~gessi/iStarML/. Besides, jUCMNav has been modified in order to import and export iStarML files [21]. We prove the approach doing XSLT transformation from OME representations ( i* ), as special case of supermetamodel, to jUCMNav representations (GRL). In Table 3 we show four submodels to illustrate the four different outputs of the translation algorithm. We explain below each row:  X 
Row 1: dependency from an intentional element into another. Strictly semantic preserving: all the model is translated without changes. Output 1 in Figure 6.  X 
Row 2: task decomposition with dependency to an intentional element. Semantic preservation modulo variation: the task decomposition in OME is translated into an 
AND-decomposition in jUCMMNav. Note th at it would be possible to recreate the original model. Therefore, this is a bijective mapping. Output 2 in Figure 6.  X 
Row 3: dependency from an intentional element into an actor. Please note that jUCMNav does not admit dependencies with actors as dependers or dependees comes 1 in jUCMNav). Decreasing modulo variation: it is possible to translate the dependency by creating an intentional element in the target actor and attaching de-pendency on it, but the original model can not be recreated, since it is not known if the added intentional element is really new or not. In particular, note that this jUCMNav model is identical to the previous one, clearly showing the lack of bijec-tion with respect to this particular point. Output 3 in Figure 6.  X 
Row 4: agent as instance of actor. Although the agent is converted into actor (decreasing modulo variation), the instance link is lost. Eliminating semantic pres-ervation: the element can not be kept and is removed. Informational loss. Output 4 in Figure 6. We remark that we are not proposing specific semantic equivalences from one variant to another, we are just showing a proof-of-concept of our approach by describing a general procedure to maximize semantic pr eservation reducing the complexity of different semantic-pragmatic communities and the equivalences or mappings among metamodels (in fact, from the i* supermetamodel to variants X  metamodels) should be a matter of a meaning-making process inside that specific community. Just to mention the departing metamodel but not in the target metamodel. Choosing one or another depends on the target community. under a metamodel perspective. We organized the research into 4 questions which we think have been satisfactorily explored:  X  We have surveyed 146 proposals presented by the community in the last 5 years,  X  We have proposed a framework for the interoperability problem based on an ap- X  Given the framework above, we have classified the surveyed i* variation types in  X  We have defined a process for translating a model compliant to one metamodel to not just syntactic but also semantic interoperability in the i* framework. Our approach may help creating a repository of i* models (using the i* supermetamodel as universal reference model), may favour the application of techniques that work over different metamodels, and may possibilitate the interchange of models between tools. 
Our future work spreads along four different axes. First, improving the translation modulo variations. Second, to offer a portfolio of tool interconnections in similar way to the one between OME to jUCMNav explained here (in fact, we have a more com-plete case of interconnection among the jUCMNav and H i ME [22] tools, described in [21]). Third, consider not just syntax and semantics but also ontological issues in the translation process. Forth, digging into more details of Wachsmuth X  X  framework for proposing translation heuristics depending on the refactoring distance between the source and target metamodels, allowing thus having some default translation rules instead of a pure case-by-case analysis (although as remarked at the end of Section 5, translation will ultimately depend on the community ontological perception of i* ). 
