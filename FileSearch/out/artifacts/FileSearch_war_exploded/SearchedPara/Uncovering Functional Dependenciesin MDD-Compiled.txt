 A functional dependency is a logical relationship amongst the at-tributes that define a table of data. Specifically, a functional de-pendency holds when the values of a subset of the attributes in a dataset determine the values of one or more other attributes. Un-covering such dependencies is utilized in many domains, such as database design. We demonstrate that it can also be utilized in a recommendation context when datasets represent product cata-logues. State-of-the-art approaches to discovering functional de-pendencies require a tabular representation of the data. However, product catalogues can sometimes be defined implicitly, for exam-ple, as a set of solutions to a combinatorial problem. Such com-binatorial catalogues can have a very large number of products, thus making standard approaches to uncovering functional depen-dencies inapplicable. In this paper we present the first approach to computing functional dependencies over compiled knowledge rep-resentations which can often be small even for huge catalogues. In particular, we develop efficient algorithms that operate over deci-sion diagrams , which allow us to handle catalogues that are out of reach for current approaches. We apply our algorithms to tabular and combinatorial benchmarks and detect a number of properties that could be considered as anomalies in product catalogues. H.3.3 [ Information Systems ]: Information Search and Retrieval Algorithms, Verification
Uncovering functional dependencies is an important problem in many artificial intelligence (AI) domains. Many AI datasets are represented in tabular form, defined in terms of a set of attributes. A dataset might be represented as a database or as a spreadsheet. Determining that one or more attributes is functionally determined by values of other attributes can be of critical importance, e.g. in analyzing the effect of chemical compounds on cancerogenity or studying the shopping habits of the customers.

We suggest that uncovering functional dependencies can also be useful in the context of recommender systems. In particular, vari-ous forms of anomalies can be introduced if care is not taken when the catalogue is updated, or if the raw catalogue data is  X  X leaned X  either by vendors before deploying it in an online e-commerce ap-plication, or by researchers before subjecting it to various forms of experimental evaluation. We show how one class of such anomalies can be detected using functional dependencies. For instance, ignor-ing seemingly  X  X edundant X  attributes can lead to catalogues where identical product specifications have different prices. Detecting this anomalous case reduces to verifying that the price attribute is func-tionally determined by the remaining attributes.

However, some product catalogues cannot be represented in a tabular form, but can be defined implicitly, as solutions to combi-natorial problems. We refer to such cases as combinatorial cat-alogues . For example, in the holiday travel domain a solution is any itinerary that fits transportation schedules and accommodation availability. In the pr oduct configuration domain a solution is any product that is possible to manufacture in a factory. There could be a huge number of such solutions, making it infeasible to repre-sent the catalogue in a table. Techniques depending on a tabular representation of all solutions would, therefore, be inapplicable.
In this paper we, therefore, present an approach to uncovering functional dependencies when a catalogue is compiled into a multi-valued decision diagram (MDD). MDDs are a multi-valued exten-sion of binary decision diagrams [1] which have been proved to be useful for compactly representing solution sets in many combinato-rial domains, such as planning, di agnosis, probabilistic reasoning, and product configuration. While the size of an MDD is, in the worst-case, linear in the number of solutions, they can often be ex-ponentially smaller. The algorithms we develop in this paper have quadratic time complexity in the size of the MDD, thus offering potentially dramatic improvements in the complexity of reasoning over large solution spaces. Therefore, we have an approach that outperforms the state-of-the-art whenever a catalogue with a large number of solutions can be represented using a small MDD. In the experimental section we show that such catalogues frequently oc-cur in the product configuration domain. To the best of our knowl-edge, this is the first approach to functional dependency detection and exploitation over compiled knowledge representations.
The remainder of this paper is organised as follows. Section 2 presents the necessary technical background required throughout the paper. We develop MDD-based algorithms for uncovering var-ious forms of functional dependencies in Section 3. We report on a number of experiments in Section 4 and conclude in Section 5. Solution Sets. We consider contexts where we are given a set of variables (product attributes) X = { x 1 ,...,x n } and an associated set of finite domains D 1 ,...,D n such that each variable x value from the corresponding set of possible values D i .Wearealso given a set of solutions (available products) Sol  X  D 1  X  which can be defined either explicitly as a set of items in a prod-uct catalogue, or implicitly as the s et of solutions to a constraint satisfaction problem X, D, C = def { c 1 ,...,c m } , in which each c  X  C restricts the set of possible choices one can make over a sub-set of the variables in X . Consider the following example which demonstrates each representation form for a T-shirt catalogue.
E XAMPLE 1(T-S HIRT C ATALOGUE ). Consider a catalogue white, red, or blue), the size (small, medium, or large) and the print ( X  X en In Black X  -MIB or  X  X ave The Whales X  -STW). There are two constraints that define the set of valid combinations: the MIB print is only available on black t-shirts, and the STW print does not fit on small t-shirts. The implicit representation X, D, C of the T-shirt example consists of variables X = { x ues from the following domains, respectively: D 1 = { 0 , ( and D 3 = { 0 , 1 } ( MIB , STW ) . The two constraints are de-fined as follows: x 3 =0  X  x 1 =0( MIB  X  black ) , and x 2 =0  X  x 3 =1( small  X  not STW ) .  X 
An equivalent representation of the solution space of the T-shirt example, satisfying the constraints defined above, can be given ex-plicitly defined catalogue can always be interpreted as a constraint satisfaction problem having only one (tabular) constraint. color size print black small MIB black medium MIB black medium STW black large MIB black large STW white medium STW white large STW red medium STW red large STW blue medium STW blue large STW (a) Explicit Representation. Figure 1: Solution set representations for the T-shirt example. Multivalued Decision Diagrams. Multivalued decision diagrams (MDDs) are compressed representations of solution sets Sol D 1  X  ...  X  D n . MDDs are directed acyclic graphs that, for a sorted list of attributes, use prefix and suffix sharing to compactly represent the solution set. Each solution is encoded as a path, and every edge on the path encodes an attribute-value pair. MDDs are a generalization of binary decision diagrams (BDDs) [1] which are used as compressed representations of Boolean functions in many areas, such as verification, model c hecking, and VLSI design [4].
Formally, an MDD M is a rooted directed acyclic graph ( V, E where V is a set of vertices containing the special terminal vertex 1 and a root r  X  V .Furthermore, var : V  X  X  1 ,...,n +1 } labeling of all nodes with a variable index such that var its end node u and an associated value a . An MDD representing the T-shirt solution set is presented in Figure 1(b).

MDDs are deterministic: no node may have more than one out-going edge with the same label. We work only with ordered MDDs. A total ordering &lt; of the variables is assumed such that for all regarded as being arranged in n layers of vertices, each layer being labeled with the same variable index. We denote as V i the set of all nodes labeled with x i , V i = { u  X  V | var ( u )= i } .Wedenoteas E i the set of all edges originating in V i ,i.e. E i = { e E | var ( u )= i } . For example, in Figure 1(b), V 3 = { u E 3 = { ( u 4 , 1 , 0) , ( u 5 , 1 , 0) , ( u 5 , 1 , 1) , (
An MDD encodes a CSP solution set Sol  X  D 1  X  ...  X  D n , defined over variables { x 1 ,...,x n } . To check whether an assign-ment a =( a 1 ,...,a n )  X  D 1  X  ...  X  D n is in Sol we traverse M from the root, and at every node u labeled with variable x follow an edge labeled with a i . If there is no such edge then a is not a solution a  X  Sol . Otherwise, if such a traversal eventually ends in terminal 1 then a  X  Sol . We will denote as p : u any path in the MDD from u 1 to u 2 . Also, edges between u and u will sometimes be denoted as e : u  X  u .Avalue a of an assignment associated with path p will be denoted as v ( p Every path corresponds to a unique assignment. Hence, the set of all solutions represented by the MDD is Sol = { v ( p ) | 1 } . In fact, every node u  X  V i can be associated with a subset of solutions, Sol ( u )= { v ( p ) | p : u 1 } X  D i  X  ...  X  D example, Sol ( u 3 )= { (1 , 1) , (2 , 1) } .
 Functional Dependencies. Given solution set Sol defined over variables X = { x 1 ,...,x n } , and given solution a  X  Sol , a ( a 1 ,...,a n ) , we define the projection of solution a onto variable x corresponding to the variables in Y . For a given set of solutions S  X  Sol , we define the projection onto a subset of variables Y as a collection of all projected tuples, S [ Y ]= def { a [ Y
For a solution set Sol , defined over variables X = { x 1 we say that a variable x i is functionally determined by a subset of variables Y  X  X , denoted as Y  X  x i , if for any two solutions a , a 2  X  Sol , whenever a 1 and a 2 agree on variables Y ( a a [
Y ] ), they also agree on variable x i ( a 1 [ x i ]= a 2
Y
A number of approaches are known for uncovering functional dependencies. A core operation that is executed repeatedly is test-ing for atomic functional dependencies of the form Y  X  x i of-the art approaches for testing atomic dependencies first cluster data into equivalence classes with respect to the value of x then make multiple linear iterations through th e dataset. This in-curs linear complexity in the number of solutions [2].
We present our main contribution: efficient algorithms for de-tecting functional dependencies when a product (solution) set is represented compactly as a multi-valued decision diagram.
Directional dependencies { x 1 ,...,x i  X  1 } X  x i state that a vari-able x i is determined by the subset of all variables preceding it in the variable ordering of the MDD. This is a particularly easy case to detect as shown in the following proposition.

P ROPOSITION 1. { x 1 ,...,x i  X  1 } X  x i if and only if for all u  X  V i , u has only one outgoing edge, i.e. | Out ( u ) | =1
P ROOF .Let p : r u be a path from root to u , e 1 : u  X  u and e 2 : u  X  u 2 be two outgoing edges and p 1 : u 1 1 and p 2 : u 2 1 be paths from u 1 and u 2 to terminal 1 respectively. ent assignments to x i variable, v ( e 1 ) = v ( e 2 ) .
Proposition 1 provides us with a simple test for checking whether { x 1 ,...,x i  X  1 } X  x i . It suffices that all nodes in V i one outgoing edge. This can be easily checked by verifying that the number of nodes and outgoing edges is the same, | V i | = | set of all variables implied by preceding variables in the order are given by Imp  X  = { x i || V i | = | E i |} .
Variables determined by subsets of preceding variables in the order, Imp  X  , do not account for all implied variables. If variable x is implied by any subset Y  X  X \{ x i } then it will be also implied by X \{ x i } . Therefore, the set of all implied variables Imp is the set of all x i such that X \{ x i } X  x i . To detect such variables in an MDD, we will use the following proposition.
P ROPOSITION 2. X \{ x i }  X  x i if and only if there is a node u  X  V i with two outgoing edges e 1 : u  X  u 1 , e 2 : u  X  u that v ( e 1 ) = v ( e 2 ) and Sol ( u 1 )  X  Sol ( u 2 ) =  X 
P ROOF .If X \{ x i }  X  x i then there are two solutions a ( a 1 ,...,a n ) , a =( a 1 ,...,a n ) differing only in the i -th coordi-nate, a i = a i .Let p a and p a be the paths encoding these solu-tions. These paths must be of the form: p a =( p, e 1 ,p 1 ( p, e 2 ,p 2 ) ,where p is a unique path encoding ( a 1 ,...,a p ends in a node u  X  V i .Since a i = a i , v ( e 1 ) = v v ( p 1 )= v ( p 2 )=( a i +1 ,...,a n ) ,then Sol ( u 1 )  X  Sol
Alternatively, if there is a u  X  V i with two outgoing edges e such that v ( e 1 ) = v ( e 2 ) and Sol ( u 1 )  X  Sol ( u are paths p 1 : u 1 1 , p 2 : u 2 1 such that v ( p 1 )= v It suffices to choose any path from the root to u , p : r u to construct paths p a =( p, e 1 ,p 1 ) and p a ( p, e 2 ,p 2 solutions differing only at the i -th coordinate. Hence, X x holds.

Assume that for each pair of nodes in the same layer ( u 1 have precomputed Boolean indicators D [ u 1 ,u 2 ] as follows: Whenever we encounter a pair of nodes ( u 1 ,u 2 ) such that D 1 , we are guaranteed that there are at least two paths p 1 and p 2 : u 2 1 encoding the same solution v ( p 1 )= v ( Given such labels, we can compute all functionally determined variables using Algorithm 1. In each layer we check for all pairs of edges with the same parent ( e 1 ( u, u 1 ,a 1 ) , e 2 ( u, u D [ u 1 ,u 2 ]=1 . As soon as such edges are found we have proven that x i is not implied and we may proceed to the next layer. The in each layer u  X  V i , we compare in the worst-case all pairs of its child edges, and there are at most | D i | X  ( | D i | X  1) pairs. The space complexity is O ( n i =1 | V i | 2 ) sincewehaveto store Boolean indicators D [ u 1 ,u 2 ] for each pair ( u Algorithm 1 : Compute functionally determined variables. Data :MDD M ( V, E )
Imp = X ; foreach i =1 ,...,n do return Imp ;
Compatibility pairs D [ u 1 ,u 2 ] can be computed in quadratic time and space using Algorithm 2. We first initialize D [ u 1 ,u all pairs of nodes, except for the terminal 1 , setting D We then, in a bottom-up manner, traverse the MDD. It is crucial to observe that D [ u 1 ,u 2 ]=1 if and only if there are two out-going edges e 1 : u 1  X  u 1 ,e 2 : u 2  X  u 2 such that v ( v ( e 2 )  X  D [ u 1 ,u 2 ]=1 . The algorithm runs in O ( n i =1 time since in each layer, E i , each pair of edges is compared at most once. The algorithm takes  X ( i | V i | 2 ) space, since we introduce a compatibility indicator for each pair of nodes in the layer. Algorithm 2 : Compute Boolean indicators.
 Data :MDD M ( V, E )
D [  X  ,  X  ]=0 , D [ 1 , 1 ]=1 ; foreach i = n,..., 1 do return D ;
We have so far discussed only exact dependencies, i.e. we detect only whether variable x i is determined or not. However, a subset of variables Y might have a significant implicative influence on a variable x even though it does not imply it exactly. Therefore, we are interested in computing the degree , d ( Y, x )  X  [0 , a dependency Y  X  x holds. There are a number of ways to define it, for example in [2] the authors use the minimal percentage of solutions that must be removed in order for the dependency to hold. In this paper we define d ( Y, x ) as | Sol [ Y ] | / | Sol
When Y  X  x ,then | Sol [ Y ] | = | Sol [ Y  X  X  x } ] | ,and d 1 . On the other hand, when x is completely undetermined by Y , then every assignment to Y variables a  X  Sol [ Y ] can be combined with all values in domain for x , D x . Hence, larger values indicate larger degrees of dependency, and when d ( Y, x )=1 , Y  X  exactly. Note that such a statistic can be easily computed using a BDD-based representation of solution set Sol . A BDD-package BuDDy 1 supports both projection and counting operations. Count-ing the number of solutions in a BDD is an efficient operation, lin-http://sourceforge.net/projects/buddy ear in the number of nodes. While computing a BDD representa-tion of a projected solution space can in theory increase the size of the BDD, in practice projecting out variables is almost always an efficient operation that decreases the number of nodes significantly.
To evaluate our approach we applied our algorithms to a set of standard tabular and combinatorial benchmarks.
 Tabular Benchmarks. We have applied our techniques to four well-known product catalogues that are frequently used in recom-mender system research. These are related to digital cameras, lap-top computers, property lettings and travel [3]. We analyzed the data under the same adjustments that are usually used for experi-mental evaluation. Firstly, all unique identifiers or textual descrip-tions were removed. Secondly, all declared domain values that did not appear in at least one product, but appeared in the specification, were also removed. If some values appeared in datasets but were not declared, we added them to the model specification. Table 1: Basic properties of the tabular product catalogues.
A summary of the properties of the instances are reported in Ta-ble 1. For each instance, Cameras, Laptops, Travel, Lettings we show the number of rows in the initial tabular representation, the number of solutions extracted from the MDD representation, the number of variables, and the minimum/maximum/average domain size. We discovered that three out of four datasets contain duplicate entries , since the number of solutions is smaller than the number of rows. This suggests the presence of anomalies in the data.
After compiling catalogues int o MDDs we performed a depen-dency analysis X \{ x i } X  x i for each instance and each attribute. For each instance and each attribute we computed a degree of de-not functionally dependent in any of the catalogues, with values 0.9666, 0.8555, 0.809 and 0.563 for Cameras, Laptops, Travel and Lettings datasets, respectively. This indicates that in each catalogue there are identical configurations that have different prices! This is particularly evident in the Lettings catalogue, where the degree of dependence is 0 . 563 . This means that each configuration of the remaining attributes, on average, has two different prices. We dis-covered that such a large degree of dependency was caused by the omittance of the Street attribute in our preprocessing phase. How-ever, for the Cameras and Laptops datasets, preprocessing removed only the attributes we anticipated: a row identifier and a textual de-scription. The lack of functional determinism implies that there are products containing identical features but differing only in a textual description. For example, in the Laptops catalogue, two "Intel Pentium MMX" laptops are o ffered with identical features, but with different prices, costing 1409 and 1508 respectively. A user navigating the catalogue has no means of understanding what causes such a difference in price. Even after reintroducing the tex-tual description, i.e. operating over the unprocessed catalogue, the explanation the user can obtain is not satisfactory:  X  X he first laptop costs less because its name is AMS Travel Pro 2500CS while the second laptops X  X  name is AMS Travel Pro 2500CT ". This indicates that an essential feature of the product necessary for understanding the pricing structure is missing in the catalogue and is only hinted at in a textual description through a change in a single character. Combinatorial Benchmarks. To demonstrate the applicability of our approach to combinatorial catalogues, we generated MDDs for a number of real-world configuration instances from CLib 2 present their relevant properties in Table 2. The columns indicate instance name, number of variables, number of solutions, size of compiled representation on disk, number of MDD nodes | V | number of MDD edges | E | . We can see that even small MDDs can represent huge solution sets thus highlighting the computational ad-vantage of our methodology. In particular, catalogue Big-PC is considerably out of reach for approaches operating over explicit tabular representations.
 Table 2: MDD properties for some combinatorial catalogues.
We used Algorithm 1 and Algorithm 2 from Section 3 to com-pute the sets of implied variables. Catalogues Bike2 , PC2 , PC and Big-PC have 15, 35, 39 and 114 implied variables, respectively. For the first three instances the execution time was less than a second. For the largest instance, Big-PC , it took 34 seconds. All experi-ments were executed on a Fedora 9 operating system, using dual Quad core Intel Xeon processor running at 2.66 GHz.
We presented an approach to computing functional dependen-cies over an MDD representation of a product catalogue. Unlike state-of-the-art approaches, we do not require that we operate over a tabular representation of data, and hence can handle huge cata-logues that have small MDD representations. Using functional de-pendencies as an analytical tool we discovered that a set of publicly available product catalogues exhibits specific characteristics some of which can be regarded as anom alies in the catalogue definition or in the preprocessing step of the catalogues.
 Tarik Hadzic is supported by a Post-doctoral Research Fellowship from the Irish Research Council for Science, Engineering and Tech-nology. Barry O X  X ullivan is supported by Science Foundation Ire-land (Grant Number 05/IN/I886). [1] R. E. Bryant. Graph-based algorithms for boolean function [2] Y. Huhtala, J. K X rkk X inen, P. Porkka, and H. Toivonen. Tane: [3] R. Nicholson, D. Bridge, and N. Wilson. Decision diagrams: [4] I. Wegener. Branching Programs and Binary Decision http://www.itu.dk/research/cla/externals/clib
