 Determining which words are being linked by a co-ordinating conjunction is a classic hard problem. Consider the pair: + ellipsis rocket \ w  X  ellipsis asbestos \ w + ellipsis is about both rocket attacks and mortar at-tacks , unlike  X  ellipsis which is not about asbestos chloride . We use h to refer to the head of the phrase, and w
Natural Language Processing applications need to recognize NP ellipsis in order to make sense of new sentences. For example, if an Internet search en-gine is given the phrase rocket attacks as a query, it should rank documents containing rocket and mor-tar attacks highly, even though rocket and attacks are not contiguous in the document. Furthermore, NPs with ellipsis often require a distinct type of re-ordering when translated into a foreign language. Since coordination is both complex and produc-tive, parsers and machine translation (MT) systems cannot simply memorize the analysis of coordinate phrases from training text. We propose an approach to recognizing ellipsis that could benefit both MT and other NLP technology that relies on shallow or deep syntactic analysis.

While the general case of coordination is quite complicated, we focus on the special case of com-plex NPs. Errors in NP coordination typically ac-count for the majority of parser coordination errors (Hogan, 2007). The information needed to resolve coordinate NP ambiguity cannot be derived from hand-annotated data, and we follow previous work in looking for new information sources to apply to this problem (Resnik, 1999; Nakov and Hearst, 2005; Rus et al., 2007; Pitler et al., 2010).
We first resolve coordinate NP ambiguity in a word-aligned parallel corpus. In bitexts, both mono-lingual and bilingual information can indicate NP structure. We create separate classifiers using mono-lingual and bilingual feature views. We train the two classifiers using co-training, iteratively improv-ing the accuracy of one classifier by learning from the predictions of the other. Starting from only two initial labeled examples, we are able to train a highly accurate classifier using only monolingual features. The monolingual classifier can then be used both within and beyond the aligned bitext. In particular, it achieves close to 96% accuracy on both bitext data and on out-of-domain examples in the Treebank. Our system operates over a part-of-speech tagged in-put corpus. We attempt to resolve the ambiguity in all tag sequences matching the expression:
Each example ends with a noun, h . Preceding h are a pair of possibly-conjoined words, w either nouns ( rocket and mortar ), adjectives, or a mix of the two. We allow determiners or possessive pronouns before w common. Depending on the domain, we find it in roughly one of every 10 to 20 sentences. We merge identical matches in our corpus into a single exam-ple for labeling. Roughly 38% of w both adjectives, 26% are nouns, and 36% are mixed.
The task is to determine whether w conjoined or not. When they are not conjoined, there are two cases: 1) w as a whole (e.g. asbestos and polyvinyl chloride ), or 2) The conjunction links something higher up in the parse tree, as in,  X  X armers are getting older \ w and younger \ w farming. X  Here, and links two separate clauses.
Our task is both narrower and broader than pre-vious work. It is broader than previous approaches that have focused only on conjoined nouns (Resnik, 1999; Nakov and Hearst, 2005). Although pairs of adjectives are usually conjoined (and mixed tags are usually not), this is not always true, as in older/younger above. For comparison, we also state accuracy on the noun-only examples (  X  8).

Our task is more narrow than the task tackled by full-sentence parsers, but most parsers do not bracket NP-internal structure at all, since such struc-ture is absent from the primary training corpus for statistical parsers, the Penn Treebank (Marcus et al., 1993). We confirm that standard broad-coverage parsers perform poorly on our task (  X  7).

Vadas and Curran (2007a) manually annotated NP structure in the Penn Treebank, and a few custom NP parsers have recently been developed using this data (Vadas and Curran, 2007b; Pitler et al., 2010). Our task is more narrow than the task handled by these parsers since we do not handle other, less-frequent and sometimes more complex constructions (e.g. robot arms and legs ). However, such constructions are clearly amenable to our algorithm. In addition, these parsers have only evaluated coordination res-olution within base NPs , simplifying the task and rendering the aforementioned older/younger prob-lem moot. Finally, these custom parsers have only used simple count features; for example, they have not used the paraphrases we describe below. We adopt a discriminative approach to resolving co-ordinate NP ambiguity. For each unique coordinate NP in our corpus, we encode relevant information in a feature vector,  X  x . A classifier scores these vec-tors with a set of learned weights,  X  w . We assume N labeled examples { ( y 1 ,  X  x 1 ) , ..., ( y N ,  X  x N able to train the classifier. We use  X  y = 1  X  as the class label for NPs with ellipsis and  X  y = 0  X  for NPs without. Since our particular task requires a bi-nary decision, any standard learning algorithm can be used to learn the feature weights on the train-ing data. We use (regularized) logistic regression (a.k.a. maximum entropy) since it has been shown to perform well on a range of NLP tasks, and also because its probabilistic interpretation is useful for co-training (  X  4). In binary logistic regression, the probability of a positive class takes the form of the logistic function: Ellipsis is predicted if Pr ( y = 1) &gt; 0 . 5 (equiva-lently,  X  w  X  x &gt; 0 ), otherwise we predict no ellipsis.
Supervised classifiers easily incorporate a range of interdependent information into a learned deci-sion function. The cost for this flexibility is typically the need for labeled training data. The more features we use, the more labeled data we need, since for linear classifiers, the number of examples needed to reach optimum performance is at most linear in the number of features (Vapnik, 1998). In  X  4, we pro-pose a way to circumvent the need for labeled data.
We now describe the particular monolingual and bilingual information we use for this problem. We refer to Table 1 for canonical examples of the two classes and also to provide intuition for the features. 3.1 Monolingual Features Count features These real-valued features encode the frequency, in a large auxiliary corpus, of rel-evant word sequences. Co-occurrence frequencies have long been used to resolve linguistic ambigui-ties (Dagan and Itai, 1990; Hindle and Rooth, 1993; Lauer, 1995). With the massive volumes of raw text now available, we can look for very specific and indicative word sequences. Consider the phrase dairy and meat production (Table 1). A high count in raw text for the paraphrase  X  production of dairy and meat  X  implies ellipsis in the original example. In the third column of Table 1, we suggest a pat-tern that generalizes the particular piece of evidence. It is these patterns and other English paraphrases that we encode in our count features (Table 2). We also use (but do not list) count features for the four paraphrases proposed in Nakov and Hearst (2005,  X  3.2.3). Such specific paraphrases are more com-mon than one might think. In our experiments, at least 20% of examples have non-zero counts for a 5-gram pattern, while over 70% of examples have counts for a 4-gram pattern.

Our features also include counts for subsequences of the full phrase. High counts for  X  dairy produc-tion  X  alone or just  X  dairy and meat  X  also indicate el-lipsis. On the other hand, like Pitler et al. (2010), we have a feature for the count of  X  dairy and produc-tion . X  Frequent conjoining of w that there is no ellipsis, that w and heads of two separate and conjoined NPs.
Many of our patterns are novel in that they include commas or determiners. The presence of these of-ten indicate that there are two separate NPs. E.g. seeing asbestos , and polyvinyl chloride or the as-bestos and the polyvinyl chloride suggests no ellip-sis. We also propose patterns that include left-and-right context around the NP. These aim to capture salient information about the NP X  X  distribution as an entire unit. Finally, patterns involving prepositions look for explicit paraphrasing of the nominal rela-tions; the presence of  X  h PREP w pus would suggest ellipsis in the original NP.
In total, we have 48 separate count features, re-quiring counts for 315 distinct N-grams for each ex-ample. We use log-counts as the feature value, and use a separate binary feature to indicate if a partic-ular count is zero. We efficiently acquire the counts using custom tools for managing web-scale N-gram data (  X  5). Previous approaches have used search engine page counts as substitutes for co-occurrence information (Nakov and Hearst, 2005; Rus et al., 2007). These approaches clearly cannot scale to use the wide range of information used in our system. Binary features Table 2 gives the binary features and feature templates. These are templates in the sense that every unique word or tag fills the tem-plate and corresponds to a unique feature. We can thus learn if particular words or tags are associated with ellipsis. We also include binary features to flag the presence of any optional determiners before w or w words that precede and follow the tag sequence in the source corpus. These context features are analo-gous to the L / R -CTXT features that were counted in the auxiliary corpus. Our classifier learns, for exam-ple, that instances preceded by the words its and in are likely to have ellipsis: these words tend to pre-cede single NPs as opposed to conjoined NP pairs. Example Table 3 provides part of the actual in-stantiated monolingual feature vector for dairy and meat production . Note the count features have log-arithmic values, while only the non-zero binary fea-tures are included.

A later stage of processing extracts a list of feature labels from the training data. This list is then used to map feature labels to integers, yielding the stan-dard (sparse) format used by most machine learning 3.2 Bilingual Features The above features represent the best of the infor-mation available to a coordinate NP classifier when operating on an arbitrary text. In some domains, however, we have additional information to inform our decisions. We consider the case where we seek to predict coordinate structure in parallel text: i.e., English text with a corresponding translation in one or more target languages. A variety of mature NLP tools exists in this domain, allowing us to robustly align the parallel text first at the sentence and then at the word level. Given a word-aligned parallel cor-pus, we can see how the different types of coordinate NPs are translated in the target languages.

In Romance languages, examples with ellipsis, such as dairy and meat production (Table 1), tend to correspond to translations with the head in the first position, e.g.  X  X roducci  X on l  X actea y c  X arnica X  in Span-ish (examples taken from Europarl (Koehn, 2005)). When there is no ellipsis, the head-first syntax leads to the  X  w cloreto de polivinilo in Portuguese. Another clue for ellipsis is the presence of a dangling hyphen, as in the Finnish maidon -ja lihantuotantoon . We find such hyphens especially common in Germanic lan-guages like Dutch. In addition to language-specific clues, a translation may resolve an ambiguity by paraphrasing the example in the same way it may be paraphrased in English. E.g., we see hard and soft drugs translated into Spanish as drogas blandas y drogas duras with the head, drogas , repeated (akin to soft drugs and hard drugs in English).

One could imagine manually defining the rela-tionship between English NP coordination and the patterns in each language, but this would need to be repeated for each language pair, and would likely miss many useful patterns. In contrast, by represent-ing the translation patterns as features in a classifier, we can instead automatically learn the coordination-translation correspondences, in any language pair.
For each occurrence of a coordinate NP in a word-aligned bitext, we inspect the alignments and de-termine the mapping of w each of our examples represents all the occurrences of a unique coordinate NP in a corpus. We there-fore aggregate translation information over all the occurrences. Since the alignments in automatically-aligned parallel text are noisy, the more occurrences we have, the more translations we have, and the more likely we are to make a correct decision. For some common instances in Europarl, like Agricul-ture and Rural Development , we have thousands of translations in several languages.
 Table 4 provides the bilingual feature templates. The notation indicates that, for a given coordi-nate NP, we count the frequency of each transla-tion pattern in each target language, and generate real-valued features for these counts. The feature counts are indexed to the particular pattern and lan-guage. We also have one language-independent fea-ture, C h ord ( w each ordering across all languages. The span is the number of tokens collectively spanned by the trans-lations of w resents the translation using wildcards for all other foreign words, but maintains punctuation. Letting  X * X  stand for the wildcard, the detailed patterns for the translations of dairy and meat production in Ta-ble 1 would be [ h w (Finnish) and [ h * * w or more consecutive wildcards are converted to  X  ...  X . For the  X  simple pattern , X  we remove the wildcards and punctuation. Note that our aligner allows the English word to map to multiple target words. The simple pattern differs from the ordering in that it de-notes how many tokens each of w Example Table 3 also provides part of the actual instantiated bilingual feature vector for dairy and meat production . We exploit the orthogonality of the monolingual and bilingual features using semi-supervised learn-ing. These features are orthogonal in the sense that they look at different sources of information for each example. If we had enough training data, a good classifier could be trained using either monolingual or bilingual features on their own. With classifiers trained on even a little labeled data, it X  X  feasible that for a particular example, the monolingual classifier might be confident when the bilingual classifier is Algorithm 1 The bilingual co-training algorithm: subscript and u C : regularization param. for classifier training
Create L
Create L
Create a pool U
Create a pool U for i = 0 to k do and n end for uncertain, and vice versa. This suggests using a co-training approach (Yarowsky, 1995; Blum and Mitchell, 1998). We train separate classifiers on the labeled data. We use the predictions of one classi-fier to label new examples for training the orthogo-nal classifier. We iterate this training and labeling.
We outline how this procedure can be applied to bitext data in Algorithm 1 (above). We follow prior work in drawing predictions from smaller pools, U and U beled examples  X  X re more representative of the un-derlying distribution X  (Blum and Mitchell, 1998). We use a logistic regression classifier for h h . Like Blum and Mitchell (1998), we also create a combined classifier by making predictions accord-ing to argmax
The hyperparameters of the algorithm are 1) k , the number of iterations, 2) u the smaller unlabeled pools, 3) n ber of new labeled examples to include at each itera-tion, and 4) the regularization parameter of the logis-tic regression classifier. All such parameters can be tuned on a development set. Like Blum and Mitchell (1998), we ensure that we maintain roughly the true class balance in the labeled examples added at each iteration; we also estimate this balance using devel-opment data.

There are some differences between our approach and the co-training algorithm presented in Blum and Mitchell (1998, Table 1). One of our key goals is to produce an accurate classifier that uses only mono-lingual features, since only this classifier can be ap-plied to arbitrary monolingual text. We thus break the symmetry in the original algorithm and allow h to label more examples for h that h cause we don X  X  have unlimited unlabeled examples to draw from, only those found in our parallel text. Web-scale text data is used for monolingual feature counts, parallel text is used for classifier co-training, and labeled data is used for training and evaluation. Web-scale N-gram Data We extract our counts from Google V2 : a new N-gram corpus (with N-grams of length one-to-five) created from the same one-trillion-word snapshot of the web as the Google 5-gram Corpus (Brants and Franz, 2006), but with enhanced filtering and processing of the source text (Lin et al., 2010, Section 5). We get counts using the suffix array tools described in (Lin et al., 2010). We add one to all counts for smooth-ing.
 Parallel Data We use the Danish, German, Greek, Spanish, Finnish, French, Italian, Dutch, Por-tuguese, and Swedish portions of Europarl (Koehn, 2005). We also use the Czech, German, Span-ish and French news commentary data from WMT tions of joint IBM Model 1 training, followed by 3-to-5 iterations of joint HMM training, and align with the competitive-thresholding heuristic. The English portions of all bitexts are part-of-speech tagged with CRFTagger (Phan, 2006). 94K unique coordinate NPs and their translations are then extracted. Labeled Data For experiments within the paral-lel text, we manually labeled 1320 of the 94K co-ordinate NP examples. We use 605 examples to set development parameters, 607 examples as held-out test data, and 2, 10 or 100 examples for training. For experiments on the WSJ portion of the Penn Treebank, we merge the original Treebank annota-tions with the NP annotations provided by Vadas and Curran (2007a). We collect all coordinate NP se-quences matching our pattern and collapse them into a single example. We label these instances by deter-mining whether the annotations have w joined. In only one case did the same coordinate NP have different labels in different occurrences; this was clearly an error and resolved accordingly. We collected 1777 coordinate NPs in total, and divided them into 777 examples for training, 500 for devel-opment and 500 as a final held-out test set. We evaluate using accuracy : the percentage of ex-amples classified correctly in held-out test data. We compare our systems to a baseline referred to as the Tag-Triple classifier . This classifier has a single feature: the tag ( w Tag-Triple is therefore essentially a discriminative, un lexicalized parser for our coordinate NPs.
All classifiers use L2-regularized logistic regres-sion training via LIBLINEAR (Fan et al., 2008). For co-training, we fix regularization at C = 0 . 1 . For all other classifiers, we optimize the C parameter on the development data. At each iteration, i , classifier h annotates 50 new examples for training h pool of 750 examples, while h examples for h This ensures h labeled examples.
We also set k , the number of co-training itera-tions. The monolingual, bilingual, and combined classifiers reach their optimum levels of perfor-mance after different numbers of iterations (Fig-ure 1). We therefore set k separately for each, stop-ping around 16 iterations for the combined, 51 for the monolingual, and 57 for the bilingual classifier. We evaluate our systems on our held-out bitext data. The majority class is ellipsis, in 55.8% of exam-ples. For comparison, we ran two publicly-available broad-coverage parsers and analyzed whether they correctly predicted ellipsis. The parsers were the C&amp;C parser (Curran et al., 2007) and Minipar (Lin,
Table 5 shows that co-training results in much more accurate classifiers than supervised training alone, regardless of the features or amount of ini-tial training data. The Tag-Triple system is the weakest system in all cases. This shows that better monolingual features are very important, but semi-supervised training can also make a big difference. System 2 10 100 Tag-Triple classifier 67.4 79.1 82.9 Monolingual classifier 69.9 90.8 91.6 Co-trained Mono. classifier 96.4 95.9 96.0 Bilingual classifier 76.8 85.5 92.1 Co-trained Bili. classifier 93.2 93.2 93.9 Mono.+Bili. classifier 69.9 91.4 94.9 Co-trained Combo classifier 96.7 96.7 96.7
Table 6 shows the net benefit of our main contri-butions. Bilingual features clearly help on this task, but not as much as co-training. With bilingual fea-tures and co-training together, we achieve 96.7% ac-curacy. This combined system could be used to very accurately resolve coordinate ambiguity in parallel data prior to training an MT system. While we can now accurately resolve coordinate NP ambiguity in parallel text, it would be even better if this accuracy carried over to new domains, where bilingual features are not available. We test the ro-bustness of our co-trained monolingual classifier by evaluating it on our labeled WSJ data.
 The Penn Treebank and the annotations added by Vadas and Curran (2007a) comprise a very special corpus; such data is clearly not available in every domain. We can take advantage of the plentiful la-beled examples to also test how our co-trained sys-tem compares to supervised systems trained with in-System Nakov &amp; Hearst --79.2 84.8 Tag-Triple WSJ 777 76.1 82.4 Pitler et al. WSJ 777 92.3 92.8 MonoWSJ WSJ 777 92.3 94.4 Co-trained Bitext 2 93.8 95.6 domain labeled examples, and also other systems, like Nakov and Hearst (2005), which although un-supervised, are tuned on WSJ data.
 notations. We compare these systems to Tag-Triple and also to a supervised system trained on the WSJ using only our monolingual features (MonoWSJ). The (out-of-domain) bitext co-trained system is the best system on the WSJ data, both on just the ex-amples where w nificantly better than the prior state-of-the-art Pitler et al. system (McNemar X  X  test, p &lt; 0.05) and also exceeds the WSJ-trained system using monolingual features (p &lt; 0.2). This domain robustness is less sur-prising given its key features are derived from web-scale N-gram data; such features are known to gen-eralize well across domains (Bergsma et al., 2010). We tried co-training without the N-gram features, and performance was worse on the WSJ (85%) than supervised training on WSJ data alone (87%). Bilingual data has been used to resolve a range of ambiguities, from PP-attachment (Schwartz et al., 2003; Fossum and Knight, 2008), to distinguishing grammatical roles (Schwarck et al., 2010), to full dependency parsing (Huang et al., 2009). Related work has also focused on projecting syntactic an-notations from one language to another (Yarowsky and Ngai, 2001; Hwa et al., 2005), and jointly pars-ing the two sides of a bitext by leveraging the align-ments during training and testing (Smith and Smith, 2004; Burkett and Klein, 2008) or just during train-ing (Snyder et al., 2009). None of this work has fo-cused on coordination, nor has it combined bitexts with web-scale monolingual information.

Most prior work has focused on leveraging the alignments between a single pair of languages. Da-gan et al. (1991) first articulated the need for  X  X  mul-tilingual corpora based system, which exploits the differences between languages to automatically ac-quire knowledge about word senses. X  Kuhn (2004) used alignments across several Europarl bitexts to devise rules for identifying parse distituents. Ban-nard and Callison-Burch (2005) used multiple bi-texts as part of a system for extracting paraphrases.
Our co-training algorithm is well suited to using multiple bitexts because it automatically learns the value of alignment information in each language. In addition, our approach copes with noisy alignments both by aggregating information across languages (and repeated occurrences within a language), and by only selecting the most confident examples at each iteration. Burkett et al. (2010) also pro-posed exploiting monolingual-view and bilingual-view predictors. In their work, the bilingual view encodes the per-instance agreement between mono-lingual predictors in two languages, while our bilin-gual view encodes the alignment and target text to-gether, across multiple instances and languages.
The other side of the coin is the use of syntax to perform better translation (Wu, 1997). This is a rich field of research with its own annual workshop (Syn-tax and Structure in Translation).

Our monolingual model is most similar to pre-vious work using counts from web-scale text, both for resolving coordination ambiguity (Nakov and Hearst, 2005; Rus et al., 2007; Pitler et al., 2010), and for syntax and semantics in general (Lapata and Keller, 2005; Bergsma et al., 2010). We do not currently use semantic similarity (either tax-onomic (Resnik, 1999) or distributional (Hogan, 2007)) which has previously been found useful for coordination. Our model can easily include such in-formation as additional features. Adding new fea-tures without adding new training data is often prob-lematic, but is promising in our framework, since the bitexts provide so much indirect supervision. Resolving coordination ambiguity is hard. Parsers are reporting impressive numbers these days, but coordination remains an area with room for im-provement. We focused on a specific subcase, com-plex NPs, and introduced a new evaluation set. We achieved a huge performance improvement from
Size matters. Most parsers are trained on a mere million words of the Penn Treebank. In this work, we show how to take advantage of billions of words of bitexts and trillions of words of unlabeled mono-lingual text. Larger corpora make it possible to use associations among lexical items (compare dairy production vs. asbestos chloride ) and precise para-phrases ( production of dairy and meat ). Bitexts are helpful when the ambiguity can be resolved by some feature in another language (such as word order).
The Treebank is convenient for supervised train-ing because it has annotations. We show that even without such annotations, high-quality supervised models can be trained using co-training and features derived from huge volumes of unlabeled data.
