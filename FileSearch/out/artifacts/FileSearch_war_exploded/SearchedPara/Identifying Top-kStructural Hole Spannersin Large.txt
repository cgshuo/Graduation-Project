 Recent studies have shown that in social networks, users who bridge different communities, known as structural hole spanners, have great potentials to acquire available resources from these communities and gain access to multiple sources of information flow. Structural hole spanners are crucial in many applications such as community detections, diffusion controls, and viral marketing. In spite of their importance, not much attention has been paid to them. Particularly, how to characterize the structural hole spanner properties and how to devise efficient yet scalable algorithms to find them are fundamental issues. In this paper, we formulate the problem as the top-k structural hole spanner problem. Specifically, we first provide a generic model to measure the quality of structural hole spanners, by exploring their prop-erties, and show that the problem is NP-hard. We then devise efficient and scalable algorithms, by exploiting the bounded inverse closeness centralities of vertices and making use of articulation points of the network. We finally eval-uate the performance of the proposed algorithms through extensive experiments on real and synthetic datasets, and validate the effectiveness of the proposed model. Our ex-perimental results demonstrate that the proposed model can capture the characteristics of structural hole spanners accu-rately, and the proposed algorithms are very promising. H.2.8 [ Database Management ]: Database Applications; J.4 [ Social and Behavioral Sciences ]: Miscellaneous Social networks, Top-k structural hole spanners, Linear-time algorithms, Inverse closeness centrality, Articulation points
The last decade experienced an exponential growth of a variety of large-scale networks such as social networks, ci-tation networks, biological networks, wireless networks, etc. Thus, there are high demands for developing efficient al-gorithms to explore some unique properties of such net-works. Most social networks exhibit the so-called commu-nity structure property, that is, the vertices in a network can be grouped into different sets of cohesive groups (com-munities) [10], where vertices in the same community share similar attributes. The communities play a significant role in information diffusion within the network, information within a community circulates very quickly and diffuses to other communities through community boundaries or bridges. On the other hand, there is a consensus among social scientists [7] that a person who plays a bridge role between differ-ent communities can acquire more potential resources from these communities and has more control over the informa-tion that is being transmitted. Burt [7] studied social struc-tures of many organizations and introduced the notion of structural holes as positions that can bridge diverse groups and bring benefits to the beholder. It is shown that informa-tion within a single community tends to be homogeneous. Non-redundant information is often obtained through the contacts between different communities [23]. Therefore, a person who develops relations with people from multiple communities will gain more benefits. Structural hole span-ners were studied initially by Lou et al. [19], as a few peo-ple who fill the structural holes can bridge different com-munities. For example, a community in an academic col-laboration network represents the group of people with the similar research interests, and people (structural hole span-ners) who bridge different communities are more potent to combine ideas from different research groups and create in-terdisciplinary works. Structural hole spanners have a wide range of applications. For example, in community detection, identifying central hubs that connect different groups can help isolate and identify communities [2, 29]. In Epidemic diseases and rumors spreading, quarantining structural hole spanners can stop the spread of infection and rumors into other communities [6, 12, 20]. In viral marketing, the most influential structural hole spanners can speed-up the new product marketings to different groups [15, 26, 25, 31].
Since structural hole spanners are fundamental in many applications, several models have been proposed for it [11, 17, 19, 24]. For example, Lou et al. [19] introduced a model for structural hole spanners, and proposed two algorithms based on the model, by assuming that communities are given already. However, their work relies on communities while finding communities in a large-scale network is painstaking. Moreover, the quality of the solution delivered by their algo-rithm is determined by the chosen communities. There are other studies that aim to discover the structural hole span-ners from a social network, using the topological structure of the network. Goyal et al. [11] considered a structural hole spanner as a vertex that lies on a large number of shortest paths, which is similar to betweenness centrality. Tang et al. [24] formulated structural hole spanners as the vertices which lie on a large number of shortest paths of length two only. These models however failed to capture some essential properties of structural hole spanners, which is illustrated by Fig. 1. As can be seen, vertex v 1 , rather than vertex v lies on a large number of shortest paths of length two, vertex v , instead of vertex v 1 is a better structural hole spanner as it bridges more communities. Figure 1: Illustration of structural hole spanners; each closed area represents a community, and ver-tices v 1 , v 2 represent structural hole spanners that span multiple communities.

One of the implications of structural hole spanners is that they bridge different communities and the shortest paths be-tween those communities go through them. Therefore, their removal will increase the length of shortest path between other vertices. For example, vertex v 1 in Fig. 1 plays a key role in the shortest paths between the nodes in different com-munities and its removal can significantly change the length between the other nodes, while the impact of the removal of other vertices on shortest paths is insignificant. In this paper, we propose a model based on the mean distance of the network [5] for modeling the structural hole spanners, which is the average of the lengths of all pairs of vertices in the network. We consider the structural hole spanners problem as a set of vertices whose removal will result in the maximum increase on the mean distance of the network, and we term the top-k structural holes problem as the prob-lem of finding a set of k vertices whose removal will make the increase on the mean distance maximized. To the best of our knowledge, this is the first time that a novel, top-k structural hole spanner problem is formulated and its NP-hardness is proven. Unlike most existing works that assume that either all communities are given or rely on community detection algorithms to find them first, our model relies on the network topological structure only.

The main contributions of this paper are as follows. We study the top-k structural hole spanner problem in a large-scale social network. We first formulate the problem as an optimization problem and show its NP-hardness. We then devise two efficient, yet scalable algorithms, by ex-ploiting the small-world phenomenon and using the bounded inverse of closeness centrality of vertices and using articu-lation points in the network. We finally evaluate the per-formance of the proposed algorithms by extensive experi-ments on real and synthetic datasets. Experimental results show that the structural hole spanners delivered by the pro-posed algorithms can connect more and larger communities in comparison with that by other existing methods in real datasets. Moreover, using a synthetic datasets, we show that the proposed algorithms can accurately find the struc-tural hole spanners. Furthermore, our evaluations show that the proposed algorithms outperform the other heuristics in terms of accuracy and running time.

The rest of this paper is organized as follows. Section 2 introduces basic notations, and the problem definition. Sec-tion 3 shows the NP-hardness of the problem. Section 4 proposes algorithms for the problem. Section 5 evaluates the performance of the proposed algorithms, using real and synthetic datasets. Section 6 reviews related works on struc-tural hole spanners, and Section 7 concludes the paper.
A social network can be modeled as an undirected con-nected graph G = ( V,E ), where V is the set of vertices representing individuals and E is the set of edges represent-ing the relationships between individuals. Let n = | V | and m = | E | . The degree of a vertex v is the number of its neighbors, denoted by deg( v ). Maximum degree of vertices in G is denoted by  X ( G ).

Given two vertices u,v  X  V , the vertex connectivity  X  G ( u,v ) in G between them is the minimum number of vertex-disjoint paths. Vertices u and v are referred to as k -vertex-connected if they are still connected after the removal of no more than k vertices from G . A graph G is k -vertex-connected if any pair of vertices in it is k -vertex-connected. A vertex is an ar-ticulation point of G if its removal will disconnect the graph.
As G is an unweighted graph, we assume that each edge has a weight of 1, and we term each edge e  X  E as a real edge . The distance d G uv between two vertices u and v in G is the length of the shortest path between them. We assume that d G vv = 0 for any vertex v  X  V . Given a subset V S let G [ V \ V S ] be the induced subgraph of G by the vertices in V \ V S . We abbreviate G [ V \ V S ] by G \ V S . The inverse closeness centrality of a vertex v in G is the average distance between vertex v and other vertices [5], i.e., The mean distance of a graph G thus is defined as follows. The sum of lengths of all pairs shortest paths in G is
Note that if G is disconnected, to make the mean distance of G still be valid, the distance between two vertices not in the same connected component is defined by a sufficiently large value  X  to avoid the infinite distance. This value should be larger than the sum of lengths of all pairs of shortest paths in any connected component of G , e.g.,  X  = n 3 , as the upper bound on the sum of lengths of all pairs shortest paths in a n -vertex graph is no more than  X / 3 [22].
Given a social network G = ( V,E ) and a positive integer k , the top-k structural hole spanner problem in G is to find a subset of vertices V S ( V S  X  V ) with | V S | = k , such that the removal of the vertices in V S from G will result in the maximum increase on the sum of the lengths of all pairs of shortest paths among the vertices in the induced subgraph G \ V S , i.e., the problem objective is to which is equivalent to Since communities are dense, the distance between vertices within each community is small and the member removal does not change the distance between the other members considerably. In contrast, the removal of top-k structural hole spanners in a network will result in the maximum num-ber of communities disconnected in comparison with other k -vertex removals, thereby significantly increasing the mean distance of network. Fig. 1 illustrates the impact of removal of structural hole spanners on the distances. Specifically, the proposed model captures three important characteristics of structural hole spanners. 1. Given an individual u who bridges multiple communi-2. Given an individual u who bridges large communities 3. Given an individual u who bridges many communities
In this section we show that the top-k structural hole span-ner problem is NP-hard by a reduction from an NP-hard problem -the Most Vital Node Problem (MVNP) [4], defined as follows. Given an undirected graph G = ( V  X  X  s,t } ,E ), a pair of nodes s and t , and a positive integer k , assume that there is no edge in G connecting vertices s and t and the vertex connectivity  X  G ( s,t ) between vertices s and t is no less than k + 1, the problem is to find a subset V S of V with | V
S | = k such that the length of the shortest path between s and t in subgraph G [( V \ V S )  X  X  s,t } ] of G is maximized. The rest is to show that the problem is NP-hard by a reduction from the MVNP by the following theorem.

Theorem 1. The top-k structural hole spanner problem is NP-hard.
 Sketch of the Proof. Given an instance of MVNP in an undirected graph G = ( V  X  X  s,t } ,E ) with n = | V  X  X  s,t }| , a pair of vertices s and t in G , and a positive integer k , an instance of top-k structural hole spanner problem in another undirected graph G 0 = ( V  X  S  X  T,E 0 ) can be constructed as follows. Let l = 4 n 6 . Sets of vertices S and T are ob-tained by duplicating vertices s and t , each l times, i.e., S = { s 1 ,s 2 ,...,s l } and T = { t 1 ,t 2 ,...,t l } . For any two differ-ent vertices u,v  X  V , an edge ( u,v ) is added to E 0 if an edge ( u,v )  X  E . For each vertex v  X  V , l edges ( v,s 1 ) , ( v,s and ( v,s l ) (or ( v,t 1 ) , ( v,t 2 ) ,..., and ( v,t l if edge ( v,s ) (or ( v,t )) is contained in E . The construction of G 0 is illustrated in Fig. 2. Clearly, it can be verified that  X  t  X  T and d G 0 uv = d G uv for every pair of vertices u and v . Figure 2: G 0 is constructed from G by replicating vertices s and t and their incident edges l times.

The MVNP in G = ( V  X  X  s,t } ,E ) can be reduced to the structural hole spanner problem in G 0 as follows. We first show that the optimal solution to the problem in G 0 does not contain any vertex s i or t i . We prove so by showing that for every given solution V S of the problem for G V S contains a vertex s i or t j , we can construct another set V
S such that the mean distance of G 0 \ V 0 S is strictly larger at least one path from s i to t j in G 0 \ V S , thus we replace one s i or t j in V S by a vertex that lies on the shortest path between s i and t j in G \ V S to obtain V 0 S . We then prove that every feasible solution V S of the MVNP problem is optimal if and only if it is the optimal solution for the problem in G , otherwise, we show a contradiction to the optimality by finding another set V 0 S such that d G \ V 0 S st &gt; d
Due to space limit, the detailed version of the proof is deferred to the full version of this paper.
In this section, we devise efficient algorithms for the top-k structural hole spanner problem. We first consider a greedy approach for the problem and improve the efficiency by sim-plifying the objective function. We start with a basic algo-rithm, using the inverse closeness centrality of vertices. We then develop a faster algorithm, by exploring the bounded inverse closeness centrality of vertices. We finally propose a fast, scalable algorithm by utilizing both articulation points and the bounded inverse closeness centrality of vertices.
A structural hole spanner in a social network usually spans multiple communities, thus the sum of distances between the spanner and the other vertices should not be larger than the sum of distances between an ordinary vertex and the other members in the network. The mean distance of the network after the removal of a vertex v  X  V thus is where the value of n ( n  X  1) c ( G ) is the same for every ver-tex in G . If we only consider the first term in Eq. (6) as the dominant term, it can be implied that the shorter the distance between v and others, the more likely vertex v is to maximize the mean distance in the graph -the inverse closeness centrality of a vertex. We will use this metric as a measure to find the top-k structural hole spanners in G . Specifically, the algorithm proceeds iteratively. The set of hole spanners V S is empty initially, within each iteration, a new hole spanner v  X  V \ V S is found and added to V S , if its inverse closeness centrality c ( v ) is the smallest among vertices in V \ V S . This procedure continues until the num-ber of vertices in V S becomes k . The detailed algorithm is described as follows.
 Algorithm 1 ICC 2: build a priority queue Q of top k hole spanners with the key 3: for each vertex v  X  V do 4: calculate the inverse closeness centrality c ( v ) of v ; 5: if | Q | &lt; k then 6: add v to Q ; 7: else if c ( v ) is less than the largest key in Q then 8: remove the largest key element from Q ; 9: add v to Q ;
We refer to Algorithm 1 based the I nverse C loseness C entrality of vertices as Algorithm ICC for short.

The dominant running time of Algorithm 1 is to find a sin-gle source shortest path tree for each source vertex v  X  V , which takes O ( m + n ) time, using the BFS traversal on G . Algorithm 1 thus takes O ( nm + n log k ) = O ( mn ) time, where the log k factor in the second term is the time of each priority operation in priority queue Q . Despite Algorithm 1 is efficient, its time complexity is still quite high for a large-scale network that contains millions or billion of vertices. A challenging question then is whether this time complex-ity can be further significantly improved, e.g. a linear-time complexity, while the solution quality is not inversely com-promised. In the following we answer this question affirma-tively by devising two efficient algorithms for the problem.
Most real world social networks follow two important facts: one is the sparsity. The number of neighbors of each ver-tex is constant, which does not proportionally grow with the network size [3]; another follows the small world law: the ex-pected distance between any pair of vertices is a small con-stant, not proportional to the network size [16, 30]. Thus, instead of finding the single source shortest path tree for each vertex that includes all vertices in G , it suffices to find a partial shortest path tree for the vertex that reaches up to a given level of neighbors, where the neighbors of a vertex is its level-1 neighbors , the neighbors of its neighbors is its level-2 neighbors, and so on. We term the partial shortest path tree spanning up to level-l neighbors of v as the l -bounded short-est tree T l ( v ), and the l -bounded inverse closeness centrality of v thus is defined as We here adopt the similar metric as Algorithm 1, the only difference between this algorithm and Algorithm 1 is to choose K vertices with top-K largest l -bounded inverse close-ness centrality, rather than the k vertices with top-k smallest inverse closeness centralities in Algorithm 1, assuming that K  X  k . The rationale behind is that if a vertex (as a source) can reach a larger portion of vertices in a network within a small distance l , then its average distance to other vertices is shorter. To explore the diversity among vertices and to mitigate two neighbors to be chosen as the top-k structural hole spanners at the same time, the number of candidates K for the top-k hole spanners can be larger than k , e.g., K = ck ( c  X  1). We then calculate the inverse closeness centralities of these K vertices in G , and choose the top-k smallest ones as the top-k structural hole spanners of the network. Specifically, the proposed algorithm proceeds as follows.
 Algorithm 2 BICC 1: build a priority queue H with the bounded inverse closeness 2: build a priority queue V S with the inverse closeness as the 3: for each vertex v  X  V do 4: calculate the bounded inverse closeness centrality c l 5: if | H | &lt; K then 6: add v to H ; 8: remove the smallest key element from H ; 9: add v to H ; 10: for each vertex v  X  H do 11: calculate the inverse closeness centrality c ( v ) of v ; 14: else if c ( v ) is less than the largest key in V S then 15: remove the largest key element from V S ;
It first identifies K vertices with top-K largest l -bounded inverse closeness centralities, starting at each vertex v  X  V , using the BFS traversal on G . Assume that c l ( v ) is the sum of the lengths of shortest paths from each vertex within the l -neighborhood of vertex v . Let H be the set of top-K vertices with top-K largest bounded inverse closeness centralities. It then calculates the inverse closeness centrality c ( v ) of v , for each vertex v  X  H , using the BFS technique on G . It finally identifies the k vertices from the K chosen vertices with top-k smallest inverse closeness centralities of the vertices. We refer to Algorithm 2 based the B ounded I nverse C loseness C entrality of vertices as algorithm BICC for short. The rest is to analyze its time complexity by the following theorem.
Theorem 2. Given an undirected connected graph G = ( V,E ) with constant maximum degree and positive integers k and l , there is a fast, scalable algorithm, Algorithm 2, for the bounded inverse closeness centrality in G , which takes O ( m + n ) time, where n = | V | and m = | E | .
 Proof. Assume that G is represented by adjacency lists of its vertices. Following Algorithm 2, it first constructs a partial shortest path tree T l ( v ) rooted at v for each vertex v  X  V using BFS, which takes O ( P l i =1 d i max ) = O ( d time, where d max is the maximum degree of vertices in G . It then identifies the top-K vertices with the largest bounded inverse closeness centrality, which takes O (log K ) time for each vertex insertion into the priority queue H . Therefore, it takes O ( nd l +1 max ) = O ( m + n ) time for finding the set H as both d max and l are small constants, in com-parison with the network size n . Identifying set V O ( K ( n + m ) + K log k ) time, due to the BFS search in G for each candidate vertex in H , and the addition of the candi-date vertex to set V S , where V S is maintained as a priority queue. Therefore, the time complexity of Algorithm 2 is O ( K ( n + m ) + K log K ) = O ( m + n ) as K = ck usually is constant.

Note that in real social networks the number of neighbours of an individual is a small constant which is not proportional to the network size.
So far, we have provided an algorithm based on the inverse closeness centrality and devised an efficient algorithm by ap-proximating the inverse closeness centrality of each vertex, through the introduction of l -bounded inverse closeness cen-trality concept. In the following, we take the second term of Eq. (6) into account and devise another efficient algorithm which further speeds up the running time in practice, by exploring articulation points of G .

One of the instinct properties of structural hole spanners in most real social networks is their tendency to connect mul-tiple isolated communities. Such hole spanners are referred to the articulation points in graph theory. Thus, a top-k structural hole spanner usually is an articulation point too. However, the number of articulation points in real social net-works is quite large, e.g., the number of articulation points in each network of Table 1 is at least 10% of the number of ver-tices in the network. How to identify top-k structural hole spanners from all articulation points in a large-scale network is a challenging issue. In the following, we shall devise a fast yet scalable algorithm for the top-k structural hole spanner problem, by exploring the articulation points and using the bounded inverse closeness centrality of vertices.

Lemma 1. [22] Let G be an unweighted graph G = ( V,E ) with n = | V | vertices, then the sum of lengths of all pairs shortest paths in G is no more than n 3 / 3 .

Given two vertices u and v that are not in the same con-nected component of G , we assume that there is a virtual edge in G between them with weight larger than the sum of lengths of all pairs of shortest paths in G , and we assign this virtual edge with a weight w ( u,v ) = cn 3 with c  X  1 / 3. For the sake of convenience, we set c = 1 in the rest of dis-cussion. Assume that v is an articulation point in G , we distinguish into two cases as follows.

Case one: if the removal of v results in two connected components CC 1 and CC 2 . Let CC i contain n i vertices. The weighted sum of all virtual edges resulting from the removal of v is n 1  X  ( n  X  n 1 ) cn 3 + n 2  X  ( n  X  n 2 ) cn nn 2  X  n 2 1  X  n 2 2 ). Clearly, when n 1  X  n 2 , the weighted sum is maximized. This implies that an articulation point is likely to be a top-k hole spanner if its removal results in two large connected components.

Case two: if the removal of v results in l connected com-ponents CC 1 ,CC 2 ,...,CC l with l &gt; 2. Let CC i contain n vertices (1  X  i  X  l ). Let n = P l i =1 n i . Then, the weighted sum of virtual edges between vertices in CC i and CC P mized when all components have roughly equal sizes.
Following the analysis of these two cases, it can be seen that an articulation point in G is likely to be one of top-k structural hole spanner if its inverse closeness centrality is maximized, which approximately equals the weighted sum of virtual edges resulting from its removal, since the sum of all pairs shortest paths in each connected component is much less than the weight of each virtual edge. We now propose a fast, scalable algorithm by exploring the inverse closeness centralities of articulation points. Specifically, the algorithm consists of two stages. Let A be the set of articulation points in G . If | A | &lt; k , the algorithm will proceed the second stage after the first stage. Within the first stage, there is a number of iterations. An articulation point within each iteration will be chosen as a top-k hole spanner. In the second stage, Algorithm 2 will be invoked to find the rest of top-k structural hole spanners. The detailed algorithm is described in Algorithm 3.
 Algorithm 3 AP_BICC 1: build a priority queue V S of top-K approximate inverse close-2: let A be the set of articulation points in G , which can be 3: for each vertex v  X  A do 8: remove the smallest key element from V S ; 11: U  X  V \ A ; 13: build a priority queue Q of K elements with the key of 15: extract the the element v with largest key from Q ; We refer to Algorithm 3 based on A rticulation P oints and B ounded I nverse C loseness C entrality of vertices as Algo-rithm AP_BICC for short. We now show the articulation point finding and their approximate inverse closeness cen-trality, c 0 ( v ), for each v  X  A can be efficiently calculated, using a Depth-First Search (DFS) traversal on G .

Let v be an articulation point of G , in the DFS tree con-struction starting from a vertex v , assume that u 1 ,u 2 be the children of vertex v in the DFS tree. Let V i be the set of vertices in the subtree T i rooted at u i and CC i the con-nected component of G induced by the vertices in V i with 1  X  i  X  p . Let CC 0 be the connected component contain-ing the ancestors of v in the DFS tree. Following the DFS search property, all edges in G can be partitioned into  X  X ree edges X  and  X  X on-tree edges X , respectively. And all non-tree edges are  X  X ack edges X , which means that one endpoint of the edge is a descendant while another endpoint of the edge is a proper ancestor of v in the DFS tree. Clearly, there is no edges between any two connected components CC i and CC j with i 6 = j and 1  X  i,j  X  p , by the DFS traversal property. If there is a back edge between a vertex in V i and a vertex in CC 0 , then both CC i and CC 0 are the same connected component when the removal of v from G , 1  X  i  X  p . An illustration of this case is shown in Fig 3. Figure 3: An illustration of exploring an articulation point v and its p children u 1 ,u 2 ,...,u p during a DFS traversal on G .

Assume that there are p 0 CCs among the p CCs derived from p children of v have back edges. Then, the removal of v will result in p  X  p 0 CCs. For the sake of convenience, we assume that these p  X  p 0 CCs are CC 0 1 ,CC 0 2 ,...,CC 0 each having n 0 i vertices. The approximate inverse closeness centrality of v then is The linear-time procedure of detecting each articulation point and the calculation of its approximate inverse closeness cen-trality is then detailed as follows. A vertex v is identified as an articulation point of G if a subtree rooted at one of its children does not contain any back edges. The induced subgraph by the set of vertices in this subtree is a connected component after the removal of vertex v from G . The num-ber of vertices contained in each such connected component is the number of descendants of that child in the DFS tree. To keep track of the number of descendants of each vertex when performing the DFS traversal on G and to identify those children of the vertex without any back edges, the ap-proximate inverse closeness centrality of v (as an articulation point) can be easily calculated. The detailed implementa-tion of this is given in Procedure 1 and Procedure 2.
Theorem 3. Given a graph G ( V,E ) with constant max-imum degree and an integer k &gt; 0 , Algorithm 3 takes time O ( n log k + m ) = O ( m + n ) as k is a constant. Proof. Following Algorithm 3, the detection of all articula-tion points and the calculation of their approximate inverse closeness centralities takes O ( n + m ) time by Procedure 1. Procedure 1 Articulation points and their approximate in-verse closeness centrality calculation 1: for each vertex u  X  V do 2: /* the number of children of u */ 3: u.child  X  0; 4: /* each vertex has 3 colors white/grey/black */ 5: u.color  X  white ; 7: time  X  0; 8: for each vertex u  X  V do 9: if u.color == white then 10: call Modified-DFS( G , u ) /* Procedure 2 */; Procedure 2 Modified-DFS( G,u ) 1: u.color  X  black ; 2: time  X  time + 1; 3: /* the discovered time of vertex u */ 4: u.discovered  X  time ; 5: /* the smallest discovered time of any neighbor of u  X  X  descen-6: u.lowest  X  time ; 7: /* the number of vertices in CC 0 after removing u */ 9: /* the number of descendants of u in DFS tree */ 10: u.descendant  X  0; 11: for all ( u,v )  X  E do 12: if u.color == white then 13: u.color  X  grey ; 14: v. X   X  u /* u is the parent of v */; 15: u.child  X  u.child + 1; 16: call Modified-DFS( G , v ); 17: u.descendant  X  u.descendant + v.descendant ; 18: u.lowest  X  min ( u.lowest,v.lowest ); 19: if ( v.lowest  X  u.discovered ) OR ( u is root AND 20: /* v will be disconnected without u */ 23: else if v 6 = u. X  then 24: u.lowest  X  min ( u.lowest,v.discovered ); For each vertex u , its adjacency list is traversed exactly once and the number of descendants and children are calculated in the post-traversal in DFS. The maintenance of the prior-ity queue Q takes O ( | A | log k ) = O ( n log k ) time, where A is the set of all articulation points in G . The total amount of time for calculating the number of descendants of each vertex in the DFS tree is O ( n ). Thus, the time complexity of Algorithm 3 is O ( n + m ).
In this section we evaluate the performance of the pro-posed algorithms for the structural hole spanner problem, using different datasets. We start with the experimental en-vironment settings, we then investigate the effectiveness of the proposed models of structural hole spanners, compared with other models using both real and synthetic datasets. We finally study the performance of the proposed algorithms and the impacts of parameters on the performance using the datasets in Table 1 and in the end, we discuss the results.
To evaluate the performance of the proposed algorithms, we adopt the real-world datasets, which are listed in Table 1, where GR-QC is the collaboration network from arXiv 1 , cov-ering collaborations between authors of papers submitted to General Relativity and Quantum Cosmology category. Epinions is an online social network of a general consumer review site Epinions 2 . The Twitter dataset was obtained from [19]. Email-EuAll is the anonymous email network of a large European research institution for an 18-month period [18]. The DBLP-2011 dataset is the collaboration net-work obtained from the DBLP web site 3 , and the Live-Journal dataset describes the social network of free on-line blogging community 4 .

Recall that Algorithms 1, 2, 3 are denoted by ICC , BICC and AP_BICC , respectively. To evaluate their performance on the mentioned datasets, we will use the following state-of-the-art algorithms for benchmark purposes.
Notice that all our experiments were conducted based on a Linux desktop with GenuineIntel Core i7-3370 (3.40GHz) CPU and 8GB main memory.
 Table 1: Six different real datasets, where APs stands for Articulation Points in the corresponding network and Diam stands for Diameter. http://arxiv.org/ http://epinions.com/ http://www.informatik.uni-trier.de/  X  ley/db/ http://livejournal.com/
We first evaluate the effectiveness of the proposed model using the definition proposed by Burt [7] such as: (1) the size of communities that each individual spans, (2) the number of communities and (3) the number of neighbours of that individuals. Burt [7] suggested that a good structural hole spanner is connected to many communities, but to be in-fluential, the ratio of the number of its communities to the number of its neighbors should be large. This definition im-plies a metric for evaluating the structural hole spanners in a setting where the communities are given in advance. Given a graph G = ( V,E ), suppose S is the set of structural holes found by an algorithm, then, the quality of the solution S is
We evaluate the performance of different algorithms using this metric in order to find out the degree to which our model maps the real structural hole spanners. We use the DBLP dataset which has been used for the same purpose in [19]. The communities in this network are publication venues, e.g, journal or conference; authors who published to a certain journal or conference form a community. We evaluate two algorithms by MaxD and HIS proposed by Lou et al. [19].
Fig. 4(a) shows that Algorithm AP_BICC significantly out-performs all the other algorithms in terms of the average community size by varying k . Fig. 4(a) verifies our claim in Section 2.2 that our model can identify the vertices connect-ing with larger communities. Similarly, it can be observed in Fig. 4(b) that algorithm AP_BICC outperforms the other algorithms in the benchmark at least 50%, using the metric in Eq. (9). In a nutshell, Algorithm AP_BICC can guarantee to find efficient structural hole spanners connecting to larger communities in this dataset while the other algorithms pro-duce the results with less number of communities compared to the number of their neighbors. Also, the running time of Algorithm AP_BICC is a few milliseconds, while Algorithm MaxD takes minutes and Algorithm HIS takes a few seconds. Figure 4: Effectiveness of different algorithms on dataset DBLP using different quality metrics.
We then evaluate the quality of structural hole spanners found by different algorithms. We generate a random graph of 2 11 vertices using SSCA method 5 . SSCA generates cliques of random size with average size 2 7 and random inter-clique edges. We then place a ground-truth structural hole span-ner s i for every clique i . For every edge ( u,v ), such that u is in clique i and v is in clique j , we replace it with two edges ( u,s i ) and ( s i ,v ). Fig. 5 shows the performance im-provement made by Algorithm AP_BICC in empirical results. http://www.cse.psu.edu/  X  madduri/software/GTgraph/ Fig. 5 demonstrates that the solution accuracy delivered by Algorithm AP_BICC is at least 20% of the others for k &gt; 5. The reason for such significant improvement is that algo-rithm AP_BICC finds more meaningful structural hole span-ners that play a significant role in the connectivity of com-munities (cliques) and vertices in the network. Figure 5: Running time and precision improvement by Algorithm AP_BICC using synthetic dataset.
We thirdly evaluate the performance of the proposed algo-rithms ICC , BICC , and AP_BICC , against benchmark structure-based algorithms PathCount , PageRank , and 2-Step against different datasets listed in Table 1. We avoid comparing community-based algorithms MaxD and HIS , since using any community detection method is subject to unfairness.
Fig. 6 and Fig. 7 show the performance of different algo-rithms in terms of the optimization objective in Eq. (4), i.e., C ( G \ S )  X  C ( G ) and their running times. Specifically, it can be seen from Fig. 6(a) that Algorithm AP_BICC significantly outperforms all the other algorithms by at least 100% for dataset GR-QC , while its running time is only 6% of the best of the three benchmark algorithms as shown in Fig. 7(a). It can be observed from Fig. 6(e) to Fig. 6(f) that Algorithm AP_BICC has the similar performance and running time for other datasets. That is, it outperforms all the other algo-rithms at least 50% while its running time is only around 7% and 65% of the fastest benchmark algorithm for datasets DBLP-2011 and LiveJournal , respectively. Fig. 6(b) and Fig. 6(d) show that it is superior in comparison with bench-mark algorithms such as PageRank and PathCount on both performance and running time for datasets Epinions and Email-EuAll when k is small ( k &lt; 20). With the increase of k , the performance gap between Algorithm AP_BICC and other algorithms increases, too. Furthermore, it can be seen from Fig. 7(b) and Fig. 7(d) that the running time of Algo-rithm AP_BICC is less than 7% of the fastest benchmark Algo-rithm PageRank and 0.01% of Algorithms ICC and PathCount for dataset DBLP-2011 as shown in Fig. 7(e). Moreover, Al-gorithm AP_BICC significantly outperforms Algorithm BICC , which means that the second term in Eq. (6) is dominant. Furthermore, since the number of articulation points is large, Algorithm AP_BICC never reaches to the second phase, caus-ing it to run considerably faster than Algorithm BICC .
We finally evaluate the impact of parameters on the per-formance of the proposed Algorithms AP_BICC and BICC . As the number of articulation points in each mentioned dataset is far larger than k , the second stage of Algorithm AP_BICC , the bounded inverse closeness centrality of vertices will not be invoked. Therefore, we only investigate the impact of parameters l and K on the performance of algorithm BICC .
Fig. 8 plots the performance curves of Algorithm BICC by varying the value of l , based on two representative large datasets LiveJournal and DBLP-2011 in Table 1. As the ex-perimental results indicate that algorithm BICC will deliver the similar performance for other datasets, we focus only on these two large datasets. Fig. 8(b) implies that when l is small with 2  X  l  X  6, Algorithm BICC has the best per-formance for dataset LiveJournal . It also exhibits similar behavior for dataset DBLP-2011 as shown in Fig. 8(a). How-ever, its performance degrades chromatically when l = 6, i.e., its performance decreases by at least 80% compared with its performance when l = 2. This implies that its per-formance dramatically drops with the growth of l . The rea-son behind is that algorithm BICC always chooses the top-K vertices with the largest l -bounded inverse closeness c l By continuously increasing the value of l , the value of c will be closer to the value of its inverse closeness centrality c ( v ). Since the top-K vertices with the  X  X argest X  l -bounded inverse closeness centrality (that is indeed almost the same as inverse closeness centrality for large l ) will be chosen, the algorithm performance drops. Fig. 8 suggests that the value of l in practice should be small, otherwise the quality of the solution is not promising, this further verifies the small-world phenomenon that causes l -bounded closeness central-ity to be very close to inverse closeness centrality, since the small-world phenomenon states that the largest distance in the network is expected to be a constant. Fig. 8(d) plots the running times of algorithm BICC for different k using dataset LiveJournal , from which it can be seen that it takes more time on finding a solution with the growth of l . Specifically, its running time when l = 2 is a tiny fraction of its running time when l = 10 (0.001%). Fig. 8(c) further shows that it has the similar behavior for dataset DBLP-2011 .

Fig. 9(a) shows that the performance of algorithm BICC for dataset DBLP is stable, with the increase of K . The ra-tionale behind is that social networks follow the small-world law that individuals can reach each other with a few num-ber of hops, thus the l -bounded inverse closeness centrality of vertices can approximately represent closeness centrality. Fig. 9(b) demonstrates that algorithm BICC leads to a better performance for dataset LiveJournal with the growth of K . Fig. 9(d) shows its running time, using different values of K for dataset LiveJournal , from which it can be seen that the running time of algorithm BICC linearly increases, with the growth of K . The reason is that by increasing the value of K , algorithm BICC will examine more candidate vertices.
We now turn to the discussion of the experimental re-sults. Fig. 6 shows that in co-authorship datasets GR-QC and DBLP-2011 , the performance gain of Algorithm AP_BICC over Algorithm PageRank is significant. The reason is that Algorithm AP_BICC finds the individuals who bridge differ-ent communities, while Algorithm PageRank detects the in-dividuals with high reputation. In other words, within co-authorship networks, opinion leaders have a high reputation as they collaborate with many people in their own commu-nity, however, the structural hole spanners connect different communities and their absence is more tangible. Similarly, in dataset LiveJournal , bloggers produce contents within a few subjects gain high reputation. The bloggers who publish in multiple subjects however, have a wider perspective, more sources of information and hold more significant positions. Figure 8: Impact of parameter l on performance of algorithm BICC .
 Moreover, Fig. 6 shows that the performance of Algorithm AP_BICC is similar to PageRank for dataset Email-EuAll . Dataset Email-EuAll is the email network of an organiza-tion in which high level managers gain a high reputation. The high level managers communicate with the operation managers in each separate division and act as the only com-munication link between each separate division. Thus, they are also structural hole spanners. A similar explanation can be applied to dataset Twitter , where people who have higher reputation are directly followed by a larger portion of users and their content is forwarded by their followers.
Over last few years, the size of real networks has increased enormously, developing efficient algorithms for finding influ-ential individuals in such large-scale networks with unique properties such as structural hole spanners has become a challenging task. Moreover, building accurate models that truly reflect the properties of structural hole spanners is cru-cial to identify such individuals. Nevertheless, researchers take lots of effort towards this aim.

The notion of structural hole spanners was first introduced by Burt [7] to find the key employees in organizations for in-tegrating operations across functional and business bound-aries. This concept later was further refined in [1, 8, 9]. A few studies have exploited the concept of structural holes in Figure 9: Impact of parameter K on performance of algorithm BICC . order to design strategic games for network formation [11, 17]. Goyal et al. [11] presented a network formation model that a vertex u serves as an intermediary between many vertices. However, this strategy leads to the star network and real networks do not follow a star topology. In order to tackle this problem, Kleinberg et al. [17] designed a game by building a model of the payoffs that arise from filling structural holes. This payoff is a decreasing function of the number of paths with length two between each pair of neigh-bors to avoid the star topology. One of the limitations of the model presented by Kleinberg et al. [17] is that this model needs careful tuning of parameters such as the link maintenance cost that is not easily achieved in large-scale networks. Another line of research in computer science is to find structural hole spanners in order to incorporate them in contagion, and can be divided in two categories as follows.
Structural-based Models: Goyal et al. [11] formulated a structural hole spanner as a vertex that resides on more shortest paths between different pairs of vertices. Since counting the number of shortest paths in large networks is time-consuming, Tang et al. [24] proposed to only count the number of shortest paths with length two on which a ver-tex lies. In this model, any shortest path of length greater than two will be ignored, thus the model suggests candidates that are connected to smaller rather than larger, richer and more influential communities. A fairly common case under this model is its failure of finding good quality structural hole spanners when a vertex is densely connected to two communities. For example, in Fig. 1, vertex v 1 forms more length-2 paths than that of v 2 , while v 2 is connected to more communities and is a better structural hole based on Burt X  X  theory [7]. However, this model suggests v 1 as a better struc-tural hole spanner. In order to address this problem, Ugan-der et al. [28] defined the structural diversity of an individ-ual as the number of connected components in its contact neighborhood, which is a similar notion as structural hole spanners, and studied the role of structural diversity in con-tagion of information within real social networks. Huang et al. [14] studied the top-k structural diversity search in large networks and developed efficient algorithms for massive dy-namic networks. However, only a small number of vertices in each community can be part of contact neighborhood, and they can form multiple connected components. Similarly, Tong et al. [27] defined the gateway-ness of a vertex v , pro-portional to the paths between source vertices S and target vertices T , on which v lies. In addition, each path is given a score, which is inversely proportional to its length. Yang et al. [31] studied the role of structural holes in diffusion.
Community-based Models: Lou et al. [19] proposed a model to find structural holes in a network, assuming that communities in the network are given. The objective in their model is to maximize a utility function that measures the de-gree to which vertices span communities. One instantiation is to find a set of vertices whose removal leads to the max-imum decreases on the number of inter-community edges. One major concern about this model is that communities usually are not known, thus the quality of the solution relies on the quality of communities found. Moreover in Fig. 1, the removal of v 1 decreases the number of inter-community edges by 8 and the removal v 2 decreases the inter-community edges by 6. Therefore, this model implies v 1 as the preferred structural hole spanner. However, v 2 should be a better structural hole as it bridges more communities.
In this paper we studied the top-k structural hole spanner problem in a large-scale social network. We first proposed a novel model to measure the quality of structural holes. We then formulated a novel top-k structural hole spanner problem and showed its NP-hardness. We thirdly devised two fast yet scalable linear-time algorithms for the problem by using both the bounded inverse closeness centrality of vertices and articulation points of the network. We finally evaluated the performance of the proposed algorithms and validated the effectiveness of the proposed model through ex-tensive experiments on real and synthetic datasets. Exper-imental results demonstrated that the proposed model can capture the characteristics of structural hole spanners, and the proposed algorithms outperform several other heuristics.
This work is supported by the grant of Australian Re-search Council Discovery Project No. DP120102627.
