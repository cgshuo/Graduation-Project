 1. Introduction a key point in the design of systems. Indeed, energy consumption during steady-state phases very often dominates the energy consumption of the transitory states.
 neering and requires the prediction of the behavior of complex systems. To comply with this need, different modeling languages have been developed over the past 20 years ( Sinha et al., 2001 ).
One aspect of system-control consists in determining which input settings of the controlled system will lead to a wanted behavior.
Determining these input settings requires a-causal models and modeling languages that allow to reverse models; indeed, con-straints posted on the dynamic performances of the system have to be propagated backwards in the behavior model.
 model combining an emission sub-model with a ship propulsion sub-model. It illustrates one of the major challenges for the future: the reduction of the human impact on environment. Ship transportation has produced almost 843 millions of tons of CO 2007 ( ADEME, 2009 ). Transport by boat might seems to be a clean solution because boats produce five times less CO 2 /t/km than road transport. But the increase of the flow of goods transported on water (about 7 billion tons of goods/year) generates nowadays a pollution comparable to the one produced by air transportation, and slightly lower than the one produced by road transport ( Eyring et al., 2005 ). This contribution to the green house effect can be reduced by the development of improved tools for ship control, including the management of on-board energy. Ships navigate almost 95% of their operating time at steady-state, so they are an ideal study case to evaluate whether a programming language is adapted or not for steady-state simulation. Further-more, the scale of the present problem is significant since it uses more than a hundred mixed variables, linked by linear or non-linear equations, inequations, and also tables of values.
The global model has been implemented in constraint pro-gramming. From this experience, various elements such as its modeling properties and solving process have been analyzed.
The aim of the present work is to highlight that object oriented constraint programming, an interval based approach ( Moore, 1966 ), is well adapted to simulate the steady-states of systems. To support this point of view, CP is compared with the Modelica language ( Modelica Association, 2010 ), an approach for simula-tion used by some industrials. Elements on the use and relevant-ness of these two approaches in steady-state simulation of systems are provided, showing that CP is more suitable to simulate the steady states of systems.

In the first part of the paper the major challenges of steady-state simulation for system control are exposed, thus defining the requirements in simulation. It is followed by a general overview of system simulation and a presentation of the most used simulation languages. Afterwards, CP characteristics and solving process are detailed. Then the case study is described and numerical results obtained with CP are exposed. Eventually, constraint program-ming approach is confronted to Modelica language, leading to a discussion. As a conclusion, we provide an overview of future works in this field. 2. Requirements
This section defines the main properties of the currently used models as well as the needs in simulation to design and control complex systems. 2.1. Flexibility of point of view
Controlling a system requires the identification of mainly two kinds of variables: performance drivers (PDs) and key performance indicators (KPIs) ( Porter, 1998 ). PDs are the features of a system and its environment that influence the final performances. They cannot be modified without generating pe rformance fluctuations. Perfor-mance drivers are thus causal factors. PDs can be not only environ-mental, status or action variables but also organizational capabilities. KPIs are measurable quantitative v alues that characterize the beha-vior of a system. Cost and resources consumption are among the most usual KPIs. Fig. 1 (a) shows how variables are viewed when modeling and simulating a system: we try to obtain the best KPIs according to PDs.

Other variables in models may be viewed as auxiliary variables whose purpose is defining relations between PDs and KPIs. How-ever, the choice of PDs and KPIs may depend on the user point of view ( Ammar-Khodja et al., 2008 ). Indeed, an engineer during the design phase may not consider the same PDs and KPIs as during the useofthesystem.Moreover,withthesamemodelofasystem,users may want to cover several usages. They do not want to define as many models as use cases (it is not possible in most cases).
Furthermore, the problem of system control may be viewed as a reversed problem. The user could want to know the values of the PDs X  that correspond to some expected key performance indicators (EKPIs) as shown in Fig. 1 (b). Considering a steady state of a system, we neither want to do real-time simulation nor dynamic simulation. We would rather want to provide relevant guidelines for controlling complex systems in given life situations.
Flexible a-causal models are needed, when a causality depend-ing on their context of use can be applied. Conceptual models are a descriptive and declarative representation of a system. They may not imply by themselves a causality in further simulation models. In most simulation platforms, modeling languages are programming languages, i.e. they are imperative and causal.
Modelica 1 seems to be the only initiative to provide an a-causal language at the simulation level, even if at the end all Modelica compilers produce causal executable models. 2.2. Heterogeneous models
Designing or modeling a system involves using heterogeneous models, which level of details depends on the considered situa-tion in the design process of the system. The initial description of a system will be a high level one, while subsystem description will be more detailed.

The majority of the different models used in multi-physics simulation are analytical models of mechanical behavior, dynamic behavior, kinematic behavior, etc. The complexity and size of those models can fluctuate since they use several analytic rela-tions, such as linear and/or non-linear equations, inequalities, differential equations, etc. Excepted in steady-state simulation, models are closely linked with the temporal dimension: the objective of the simulation is to determine the evolution of the state variables of the system, which are time dependant.
When designing a system, the problem is different: the objective is not only to evaluate key performance indicators but also to make design choices. While most of simulation variables are continuous, design variables are often discrete: in design (especially in routine design), some choices are made among tables of values or references catalogs, which involves splitting the choices.

Since complex systems are often based on heterogeneous com-ponents, it is necessary to be able to define models composed of variables with various dimensions linked by analytical relations. 2.3. Under and over-constrained systems
In addition to the need to reverse heterogeneous models, some-times the behavior of an under-or over-constrained system has to be simulated. If we consider a system with n PDs and p KPIs, identifying the p KPIs requires a minimum of p equations involving a maximum of n PDs. A system of equations has to be squared to be solved by classical simulation too ls.Itiscommoninpre-designthat the whole system is not yet fully defined, so the system is under-constrained. In such cases, it may be useful to use the known constraints to provide a framework of KPIs or to generate some (even all) feasible solutions to assess their KPIs. When the system is iso-constrained (clearly defined), if the models are only composed of linear equations, the problem allows a unique solution. Else, in the case of non-linear equations, it may allow one or more solutions, function of the domains of the variables and the other constraints.
There are various reasons for a sys tem to be over-constrained. When some constraints are redundant w ith other constraints, or when a constraint is a combination of others constraints (it is often not obvious), the problem might allow one or more solutions. If the system is over-constrained by inconsistent constraints, it does not admit any solution, meaning that some domains needs to be extended or some constraints needs to be relaxed. 2.4. Inequalities In system control, it is often necessary to set bounds to some PDs.
For example if the system has an internal combustion engine, it may be appropriate, during the simul ation, to limit the temperature of the cooling water, or its rotational speed. In design, both specifica-tions and technological constraint s are frequently set as inequality constraints: for example, the sliding velocity between two solids A and B must remain less than xm / s to avoid damaging contact surfaces. 3. State of the art constraint programming compared to languages and tools dedi-cated to simulation, such as Modelica, for simulating the steady-states of complex systems. Therefore, it makes sense to introduce a short definition of a complex system, before presenting the main simulation tools and languages. The resolution process of the tools used for the experiments is explored more in detail towards the end of this section. 3.1. Complex system definition of the concept of a complex system and the notion of system architecture. According to these definitions, a system is a set of interconnected parts (also called sub-systems) forming an integrated whole and working together to ensure a function F transforming an input vector x ( t ) into an output vector y ( t ) according to the state q ( t ) of the considered system y  X  t  X  X  F  X  x  X  t  X  , q  X  t  X  , t  X  first source of complexity comes from the potentially colossal number of sub-systems which engenders integration problems due to the number of interrelations among them. The complexity also results very frequently from the heterogeneousness of the components. They involve different areas of knowledge between which the link is sometimes difficult to establish.

This discipline facilitates the manipulation of objects by arguing about their structural properties. The architecture of a system is its invariant part, fixed in time, and used as support for its design and for managing its evolution. 3.2. System simulation behavior. It can be used in several fields to make predictions (e.g. meteorological predictions), to better understand the functioning of a system (e.g. space simulation), to check the safety of a system (e.g. nuclear simulation), to learn how to drive systems (e.g. flight simulators), etc. Here, focus is made on the use of simulation for checking the feasibility of a system at an early state of the design process (mainly embodiment design, Pahl and Beitz, 1996 ) and/or for supporting its control.
 tions and specialized usages. Simulations can be divided into two major groups, discrete and continuous simulations ( Schamai et al., 2009 ). Most physical phenomena such as kinematics (rigid body motion), electronics, fluids and heat flows evolve as con-tinuous functions of time and are therefore best modeled by a set of differential algebraic equations. Others disciplines, such as logistics or transportation, are composed of discrete events and therefore discrete simulation is needed ( Taylor, 2001 ). combination of continuous time physical phenomena and events occurring at discrete space and time coordinates. Therefore, hybrid models were developed in order to fulfill a more relevant accuracy ( Mosterman, 1999 ; Iung et al., 2004 ).

Another distinction can be made between the deterministic simulation and the stochastic simulation. In the deterministic simulation, input parameters are precisely specified, whereas in the stochastic simulation input parameters are uncertain and may be randomly determined or through a probability distribution.
A large part of languages and tools developed for system simulation link system simulation and time; therefore, there is a real need for time independent simulation especially for steady-state system behaviors. 3.3. System modeling languages In most engineering tasks, models are ubiquitous ( Ogren, 2000 ;
Frigg and Hartmann, 2009 ). They can take many forms to represent a real or an abstract object. We consider to be a model of a system any representation of the knowledge related to it that allows us to manage and control it. Product design is one of the engineering tasks that heavily use heterogeneous models with, for instance, product life cycle management ( Saaksvuori and Immonen, 2008 ). Several meth-odologies and languages were developed to help engineers to define models of systems ( Gero and Kannengiesser, 2002 ; Weilkiens, 2008 ).
In the context of system simulation, an executable representa-tion of the system must be defined in order to reproduce its behavior. Physical laws and phenomenological laws are mainly stated in models, and thus are based on a set of variables and a set of algebraic relations between them ( Sinha et al., 2001 ).
However, the system X  X  structure may also be detailed through object-oriented languages ( Mattsson et al., 1997 ; Broenink, 1999 ).
Therefore, the gap between high-level modeling languages and simulation becomes smaller and makes it possible to pass from one to the other automatically ( Schamai et al., 2009 ; Paredis et al. ). Modelica is a generic object-oriented language, designed by the
Modelica Association, and dedicated to the simulation of complex physical systems ( Modelica Association, 2010 ). It is independent from any simulation platform, even if some mappings exist, as
Modelica models are not directly executable by most existing simulation cores.

Modelica language specification ( Modelica Association, 2010 ) states this:
Modelica is a language for modeling of physical systems, designed to support effective library development and model exchange. It is a modern language built on a-causal modeling with mathematical equations and object-oriented constructs to facilitate reuse of modeling knowledge.

Modelica is a declarative language, especially developed for modeling and simulating hybrid complex systems (i.e. systems involving mixed discrete and continuous variables). It structures data by providing an elegant way of classifying manipulated entities that share common properties (by inheritance). All the data types are described using classes. A class de fines the common properties of the components attached to it and is structured into four main sections:
Definition of inheritance (optional, it can be simple or multi-ple), classes can be specialized.

Declaration of components (variables), including their variability (constant, parameter, discrete, etc.), their causality (input or output) and possibly flow type (used for connections). Equations (linking the state variables) and/or algorithms. Function calls.

With all these characteristics, Modelica is designed to be domain neutral. As a result, it can be used to model complex physical systems containing mechanical, electrical, electronic, hydraulic, thermal, control, electric power or process-oriented subcomponents, as shown by its standard library. 2 Modelica only makes performance evaluation, i.e. all the systems parameters must be set before the simulation, even if running simulations with unlocked parameters would allow to determine their influence on KPIs.

In most existing simulation platforms based on Modelica, the main scheme to execute/simulate a model can be depicted as in Fig. 2 . Indeed, the Modelica object-oriented code is first flattened and the major reformulation work is done during this phase. Symbolic reformulations are made and a causality is inferred to produce a flat generic model. Then, this model is translated to C/C  X  X  source codes while generating at the same time C/C  X  X  solving algorithms. Values of parameters are also extracted to a text file, thus avoiding having to compile again if the user wants to simulate the same model with other parameters values. Finally these source codes are compiled to produce an executable reading the parameter configuration file. One implementation of the generic code genera-tion scheme can be found in the OpenModelica compiler. 3
When looking at the potential of the main modeling/simulation tools and languages, compared to the needs expressed in the requirements section, obvious gaps appear. Even if Modelica may be used to simulate complex systems in steady state operations, the lack of consideration of inequalit y constraints as well as the non-management of sub-and over-constrained systems are prohibitive. Indeed, in a  X  X  X egular X  X  simulation, parameters are set, even if it could be interesting to run simulations with unlocked parameters in order to determine their influence on KPIs. In Section 6.4 , constraint programming will be compared to Modelica, which seems to be an environment of reference for steady state simulations. 4. Constraint programming approach
Previous sections mainly describe modeling concerns of a system. However, a relevant description of a system is not enough to simulate its behavior in a dynamic or a steady-state context. In this section, the constraint programming solving technology that can be used for steady-state simulation is detailed.

Constraint programming (CP) is a programming paradigm mainly based on the concept of constraint ( Rossi et al., 2006 ). The major strength of CP is the declarative and a-causal meaning of constraints. For instance, stating x  X  y  X  z is equivalent to stating y  X  z  X  x or z  X  x y or x y z  X  0 or, etc. Constraint programming combines different generic algorithms in order to solve problems formulated as constraint satisfaction problems (CSPs) defined by a triplet / X , D , C S , where
X  X f x 1 , ... , x n g is the set of variables of the considered problem.

D  X f d 1 , ... , d n g is the set of domains defining the problem search space, where d i is the domain of x i .

C  X f c 1 , ... , c k g is the set of constraints, i.e. relations between variables restricting possible combinations of values. Constraints can be defined in several manners like algebraic relations or compatibility tables.

CP appeared in the 1970s with at first consistency and propaga-tion algorithms ( Montanari, 1974 ; Mackworth, 1977 ). These algo-rithms use constraints to reduce do mains by removing inconsistent values and propagate these changes since no more improvements are made. Before the 1990s, most work was done on consistency and propagation algorithms for discrete domains with mainly graph-based algorithms ( Mohr and Henderson, 1986 ; Je  X  gou, 1993 ).
With constraint logic programming (CLP) merging constraint solving and logic programming ( Jaffar and Lassez, 1987 ), the first major CP language and solvers appeared. Based on interval analysis ( Moore, 1966 ), CLP(R)  X  an extension to CLP  X  was defined. It initiated most research work on continuous constraint algorithms ( Lhomme, 1993 ; Benhamou and Older, 1997 ; Benhamou et al., 1999 ).

In this paper, we focus mainly on continuous CSPs since we have to deal with real-world problems with physical constraints. Discrete variables can be easily modeled with intervals refined using the integrality condition. Calculus on real numbers with a computer is subjected to their representation in memory (i.e. floating-point numbers) as detailed by the IEEE-754 standard. They introduce computation errors ( Goldberg, 1991 ). Interval analysis can take into account rounding errors to avoid erroneous computations. Real numbers are represented by two englobing floating-point numbers.
All computations are made ensuring that the result on real numbers is in the computed interval by controlling the CPU rounding mode.
Thus, all arithmetic operators must be redefined. For instance, in the case of the addition operator, the computed interval is obtained using the following formula:  X  x , x  X  X  y , y  X  X b x  X  y c , d x  X  y e where x is the greatest floating point number under real x and x the smallest one over x . b x  X  y c corresponds to the results of x  X  y with rounding towards minus infinity mode and d x  X  y e uses rounding towardsplusinfinitymode.
 Based on this arithmetic, consistency algorithms like HC4 and
BC3 can be used to compute outer approximations with floating-point numbers of the feasi ble space on real numbers ( Benhamou et al., 1999 ). Moreover, some interval extensions of numerical methods can be used to improve outer approximations computed by consistency algorithms like the interval Newton contractor ( Van
Hentenryck et al., 1998 ). Propagation algorithms compute consistent hulls according to constraints, whereas search algorithms must be used to exhibit some solutions. The iterative combination of propagation and search mainly defines the Branch-and-Prune algo-rithm ( Van Hentenryck et al., 1997 ; Granvilliers, 2001 ). It also defines a generic and flexible framework computing the complete set of solutions for mixed non-linear problems. Search strategies are mainly based on search-tree exploration where several kinds of heuristics may be used to improve performances ( Chenouard et al., 2009a ). These strategies deeply affect solving performances. Choos-ing a relevant strategy instead of a default one (greater domain or round-robin) can improve the solving time by several orders of magnitudeinsomecases.Itisesp ecially true when dealing with heterogeneous models with variables having values of different orders of magnitude.
 Constraint technology is mainly accessible through APIs like IBM ILOG Solver ( Puget, 1994 ) or Realpaver ( Granvilliers and
Benhamou, 2006 ). They also provide a declarative language to define CSPs with, for instance, OPL ( Van Hentenryck, 1999 ) for
Ilog Solver. CSPs provide a generic and flexible framework to solve various kinds of problems since they are, by nature, declarative and a-causal ( Freuder, 1997 ; Mazhoud et al., 2012 ; Yvars, 2009 ). 5. Case study autonomous transportation systems such as cars, airplanes or, in our case study, ships, are constantly evolving in order to manage their energy. Our goal is to enable ship-control by set-inversion while ensuring the minimization of operating costs and the satisfac-tion of all the constraints associa ted to a ship. Those constraints can be technical, environmental, economic, statutory, human or even touristic, creating a temporal configuration of an extreme variability within a defined mission. Usually, ship-control parameters are determined by a succession of direct simulations (see Fig. 1 a): a vector of performance drivers (which is believed to be a possible solution) is tested, the envir onmental data are known and the simulation allows to determine the associated vector of key perfor-manceindicators.Ifthelatterm eets the expectations, then the command vector used for the last simulation is adopted. Otherwise, another control vector is tested.
 test X  X  evaluation scheme. It consists in reversing the analytical models of the system. Knowing the environmental data, a required performance vector is imposed in order to determine with certainty, and in a determinist way, the vector of performance drivers which would achieve the desired key performance indicators. 5.1. System description 12 m. The ship is a bulk carrier (sea-going vessel) propelled by a low-speed four-stroke engine developing a maximal power of 62 MW and a mechanical propulsion system.

The ship propulsion system that is to be modeled here is based on the most common ship propulsion system in the merchant navy (tankers, bulk carriers, etc.), that is to say a mechanical transmission between the engine and the propeller. This kind of propulsion is composed of an engine, a gearbox, a transmission shaft and a propeller, those components being integrated in a hull (see Fig. 3 ).
Depending on the desired rate of load ( PofMCR ) and rotational speed ( RPM ), the engine provides a torque directly transmitted to a gearbox ( M in ). In general, the reduction ratio of the gearbox ( n ) essentially depends on the diameter of the propeller ( D ) and rotational speed of the engine. In the current case, there is no reduction of the rotational speed ( n  X  1), the gearbox is used to provide a secondary output shaft driving various auxiliaries (not taken into account here). The propulsion power is then trans-mitted by a shaft toward the fixed blade propeller (out of the hull), which transforms the rotational movement of the shaft in a thrusting force, propelling the ship. In order to calculate the propeller thrust and torque ( T , Q ), the polynomials for the propellers of the Wageningen B type are used.

Fig. 4 can help to improve the understanding of the global system: the propulsion system previously described is a composi-tion of four sub-systems. It is associated with an emission model determining environmental performances and with an hydrody-namic model calculating the hydrodynamic resistance based on the ship speed.

A ship propulsion system can be considered to be a complex system since the collective behavior observed throughout the system is richer than the behavior of its components. Several fields of physics are involved in the vessel X  X  behavior, increasing complexity and highlighting its representativeness of complex systems within the proposed approach.

Depending of the use of function (whether it is of initial design, control or even risk-analysis), various methods were developed to simulate the behavior of a ship. Theotokatos (2007) and Medica et al. (2009) propose Matlab X  X imulink tools dedicated to the naval field. The first one is available  X  X  X or the overall ship propulsion plant, so that the initial tests of various design options can be investigated X  X . It is thus an iterative method of exploration of the design space. The second one analyzes the performances resulting from the simulation of a ship propulsion system submitted to aggravated conditions. Real time simulation is required to represent these conditions so that needed models are precise and may be used to simulate one single case at a time. The approach of Andrews (2006) , based on the 35 years personal experience of the author, takes place in a more general reflection on the design of ships: from the beginning of simulation based design until its integration in the design building block approach. He shows that system simulation tends to be integrated into a more global approach based on the architecture of the system (a well known notion of the definition of complex system) and its virtual graphic representation. But in this approach too, there is still only about direct simulations, which implies that one simulation is needed for each design option. 5.2. Propulsion model
The propulsion system can be modeled by a cascade model (see Fig. 5 ), where the outputs of one component are the inputs of another. For a direct simulation use, the propulsion model inputs are the command vector and the ambient environment, the outputs are the environmental and dynamic performances.
Each component model (see Fig. 5 ) is composed by a finite number of variables (listed and defined in Tables 6 X 11 , the domain of which can be discrete or continuous (report to Section 4 ), such that it can be modeled as a CSP. For example, the gearbox is modeled by Eqs. (7) X (10) (linear and non-linear).

In this study, the deformations of the mechanical transmission components and the losses in the mechanical connections (except inside the gearbox, see Table 14 ) are ignored. The characteristics of the propulsion system, modeled in these conditions, are detailed in Fig. 6 . 5.3. Emission model Because Belgium needed to comply with international and European agreements, the Belgian Science Policy financed the
MOPSEA project ( Vangheluwe et al., 2007 ). First, in order to have a better overview of maritime transport, an inventory of the legislation and international reporting obligations was made. Then, a new activity based model was developed in order to map historical emissions and to make a projection of the emissions for the near future.

The MOPSEA model makes possible, for most of the sea-going vessels, to quantify the main Green House Gases produced. To be more relevant, this model makes the distinction between fuel related emissions (CO 2 ,SO 2 ) and technology related emissions (HC, CO, NO x , PM). It is based on basic emission factors, which are averages of all stages of navigation and based on test cycles. To be representative of each vessel and each individual stage of navigation, tables of correction factors are implemented. These properties make the MOPSEA model particularly relevant for an application in ships X  dynamic simulation. All the equations are detailed in the project report ( Vangheluwe et al., 2007 ) and also in the appendix.
The MOPSEA emission model can be illustrated by Fig. 7 .There are three main input categories; emissions are highly impacted by the type of fuel used and by some characteristics of the engine such as its age, technology or its instant operating point. At this point, another parameter appears to be needed for emission calculation: the time parameter. Depending ontheseinputs,oneisableto estimate ship instant emission f actors but also the mass of fuel related emissions (CO 2 ,SO 2 ), and technology related emissions (HC,
CO, NO x , PM) for a defined mission. In order to calculate the emissions of a four-stroke engin e, the MOPSEA model requires 31 variables, four parameters, only 12 equations, but also six constraint tables (cf. Appendix for details: variables and parameters in Table 6 , equations in Table 12 and constraint Tables 18 X 23 ). 5.4. Hydrodynamic model
Holtrop and Mennen (1982) , is a statistical power prediction method, based on a regression analysis of random model experiments and full-scale test data. It can be used to determine the required propulsive power at the initial d esign stage of a ship. Even if the model is quite old, this case study does not need a precise calcula-tion, like a detailed FEM (finite element method) determination of the hydrodynamic resistance. Mor eover, the tools used require algebraic models, such as the Holtrop X  X ennen model, to determine the running resistance of a given ship according to its speed. The parameters used are detailed in Table 1 and some of them are illustrated in Fig. 8 .
 conditions (If y Then y ), considered in CP as a dynamically evolving system of constraints ( Gelle and Faltings, 2003 ; Sabin and Gelle, 2006 ). To highlight the importance of conditions in the
Holtrop X  X ennen model, the complexity of the model is given: it contains 46 variables, 19 parameters, 28 equations (linear and non linear), 0 inequations and 25 conditional constraints (The full model is also detailed in the Appendix). 6. Results and discussion 6.1. Modeling with CP Most of CP libraries are based on an object-oriented paradigm.
The modeling approach is composed of three steps: first, the classes have to be created and implemented. Second, objects have to be instantiated in a model. Eventually, these objects must be connected together.

In CP, the form of declaration of the variables and constraints strongly depends on the language and the environment of devel-opment. Nevertheless, the modeling process remains almost the same. Variables are declared with a defined domain or set of values, and then constraints are added. Constraints are rela-tions between variables (linear and non-linear equations), func-tion calls, inequations, constraint tables, etc. Therefore, in CP, connections between the objects of the model are made manually by adding equality constraints between the complex data mem-bers of the objects. When all the constraints are posted, the constraint-solver is able to propagate them, i.e. to reduce the domain of the variables according to the constraints. It is also able to search available solutions inside the reduced domains.
The declarative meaning of CSPs makes models implemented directly from the theoretical constr aints, without any transformation: constraints are posted exactly as equations are written in Appendix. 6.2. Solving strategies
In CP, for a quick resolution of real-scale problems, it can be needed to implement an exploration strategy, i.e. to define the order in which variables are instantiated. Some solving strategies are already implemented in constrai nt solvers. Three main splitting strategies are used for solving numerical CSPs: one depends on the size of the domains, another on the constraint network and the last is the well-known Round-Robin strategy ( Chenouard et al., 2009b ).
Therefore, these strategies are often not efficient for solving pro-blems involving large complex systems. As a consequence, strategies adapted to the specifications of the problem have to be defined. It is obvious that we should begin first and foremost with the most impacting variables because it re duces significantly the domains of many other variables in the early it erations of the solving process.
Through this approach, the strategy must be determined using a causal analysis of the models and based on the structure of the system in order to be efficient. The present point highlights the importance of having practical experience to define the strategy.
During the resolution, variables are differently treated, depending on their type of domain. Discrete do mains are reduced by an enumera-tion and test process. The reduction of continuous domains (i.e. intervals) is performed by a bisection process and test of the two half-intervals generated. Taking into account this difference is essential to define a relevant strategy. Generally, the strategy for a system modeled by a cascade model (such as this one) is relatively easier to determine than in the case of a closed loop(s) model. In the current case study, it is necessary to define two fully different strategies depending on whether the model is used in direct or reverse simulation (see Fig. 9 ). As an example, for reverse simulation, the speed of the ship is known and the command parameters have to be determined. Fig. 9 clearly shows that all variables of the propulsion chain can be determined sequentially. Once the hull model is completely instantiated, all data necessary for the instantiation of the propeller are available, and so on and so forth. 6.3. Numerical results with CP
The results are obtained for a 1 h period of functioning and presented in Table 2 . They permit to achieve a better monitoring of the evolution of the variables domains while constraints are added. Only KPIs are relevant and exposed. The first column (1) reminds the initial intervals of the variables (that can be found in appendix, Section A.1 ). Column (2) shows the evolution of the variable domains after the propagation of the internal constraints of each sub-models and the connection constraints between these sub-models. Column (3) contains the variable domains after propagation of the design constraints of the model (setting values for the parameters of the models). The fourth column (4) shows the results of the direct simulation of the system, i.e. when adding to the CSP (3) a constraint on the rate of load of the engine: PofMCR  X  70. By defining the rate of load, the objective is to observe both the polluting emissions of the ship, and its dynamic performances The fifth column (5) shows the results of the reverse simulation of the system, i.e. when adding to the CSP (3) a constraint on the forward speed of the ship: Vs  X  13. Here, the a-causal nature of CP is tested, since it is essential for ship-control, or decision support. The objective is to determine the control settings that achieve the desired speed of the ship.

Between columns (1) and (2), very few intervals have been reduced. The propagation of functional constraints (internal to the models) can be useful only if some variables have relatively small initial domains of definition. The third column is the most interesting, as propagating design constraints bounds all the domains of the variables. Some of them, like the cruise speed or the emissions of CO 2 , are interesting for the designer to observe, as they can help him to determine the operating limits of the system. At first, the comparison of columns (4) and (5) can be confusing, as a same rate of engine load may lead to different ship speeds. This is due to the fact that for marine engines, rate of load and rotational speed are decoupled variables. 6.4. Comparison with the existing approach The CP approach provides answers to the problems raised in
Section 2 . The reliability of the approach must be verified by comparison with a different simulation language. The choice naturally fell into Modelica language as justified in the conclusion of the state of the art ( Section 3 ). 6.4.1. Differences in modeling
Modelica offers more possibilities than CP on the type of objects that can be created. The object of higher level which can be instantiated is the object of type  X  X  X lass X  X . Based on the properties wished for a defined object, it is also possible to create objects of type model, type record, type block, etc. All these types of items are defined in the Modelica language specification ( Modelica Association, 2010 ). In the same way, Modelica permits to declare various component types associated with different prefixes such as flow, stream, discrete, parameter, constant, input, output, etc., depending on the role of each component. To be modeled as a Modelica model, the case study needs a little part of the available class types.
 tems of the system) are defined, objects of the  X  X  X onnector X  X  type should link them. On the condition of defining clearly which are the variables or parameters connectin g the objects, they can easily be instantiated in others models. This reusability is enhanced by the graphical interfaces of the mode ling tools based on the Modelica language (e.g. OMEdit, 4 Scilab, 5 Dymola, 6 SimulationX, to the user a useful Drag-and-Drop feature. 6.4.2. Differences in results taneous for the two simulation cases (i.e. direct and reverse simulation). Computations are made on an Apple MacBook Pro,
Processor: Intel Core 2 Duo 2.4 GHz, RAM: 4 Go 1067 MHz DDR3, running on Microsoft Windows 7 64 bytes.
 meaning that inputs are defined and KPIs are observed. Only KPIs are relevant and exposed. By defining the power of the engine (and therefore the rate of load PofMCR), the objective is to observe both the polluting emissions of the ship and its dynamic performances. The results are obtained for a rate of load of 70% are presented in Table 3 .
 different in terms of dynamic performance. Nevertheless the difference remains acceptable. These points will be further dis-cussed in the final part of this paper.
 both Modelica and CP languages is tested, because it is essential for decision support, or ship-control. The objective is to determine the control settings that achieve the desired speed of the ship.
To be coherent and able to compare the direct approach versus the reverse one, the numerical values of the same KPIs as in the previous table are presented. In this case, an advance speed is imposed. First, the control settings of the ship are determined and then, the emissions of the ship are calculated. For a speed of 13 m/s (i.e. 25.27 knots in nautical terms), we obtain the results presented in Table 4 .

Here, the difference between the results given by CP and Modelica is more pronounced; however, the difference remains acceptable. This will be further discussed in the final part of the paper.
To enhance the interest of the CP approach, a use-case for which Modelica cannot give a solution (in a unique simulation) is suggested. Instead of setting a value to the ship speed, two constraints of inequality are posted on it: Vs Z 10 m = s : Vs r 13 m = s :
Results are given in Table 5 . The Modelica compiler returns an error: it lacks one equation, as it does not accept a non-square system of equations. A solution to perform this use-case with a
Modelica-based tool should be to run some simulations for speeds between 10 m/s and 13 m/s and to pick up manually the mini-mum and maximum obtained for each variable. 6.4.3. Discussion
As introduced in the presentation of the results, a significant difference exists between the numerical values, even if accepta-ble, depending on the modeling language used, CP or Modelica.
According to the authors, this difference can be explained by the fact that low-level arithmetic libraries do not use the same methods of calculation, or even the same approximation of the variables.

The main drawback of Modelica is that its solving algorithms only permit the resolution of square systems of equations, i.e., models containing as many equations as variables. In addition, the model must include a square system of equations for each type of variable (integer, real, etc.). In the model implemented to define the case of direct simulation, if an equation on the rate of load, PofMCR (Integer), is added, the model becomes inconsistent. Indeed, the model includes one extra equation featuring integers and it lacks an equation featuring reals. An equivalent solution is, in our case, to impose the power of the engine, since these two variables are directly connected by Eq. (16) (see the equations of the models in appendix). This trick keeps the consistency of the model. Furthermore, in a Modelica model, variables and para-meters must be clearly distinguished. These parameters cannot be free but necessarily valued, which is extremely restrictive.
Among all the constraints that can be applied on complex systems, constraints of inequality are needed to set requirements on command variables, performance variables, or even functional requirements on the system itself. In Modelica, constraints of inequality cannot be included in the equation section without using the function assert() . It has to be used as follows: assert  X  condition ; message ; level  X  AssertionLevel : warning  X  ;
The condition of assertion has to be a Boolean expression. If the condition is true, message and procedure call are ignored. Else, depending on the assertion level, the warning message is returned and the current evaluation may be aborted. For example, in the model of a propeller, the value of the variable J, representing the advance number of the propeller, has to be in the interval [0, 1] assert  X  J 4  X  0andJ o  X  1 ,  X  X  Invalid advance number J  X  X  , level  X  AssertionLevel : error  X  ;
This constitutes a serious drawback in Modelica, that is to say that we are able to simulate without ensuring that all the variables remain in their domain of definition.

With Modelica language, when a variable is declared, it can be associated with a unity (SI units and non-SI units are available in the Modelica Library). During the solving process, the solver ensures the consistency of the results or informs the user of a possible error. This is one strength of Modelica, compared to CP which does not take into account the units of the variables, so that users must be cautious while connecting the models.

Given the iterative solving process, some variables must be initialized. Otherwise the non-linear solver cannot solve the system of equations because of the presence of trigonometric functions in the model of Holtrop and of polynomials of various degrees in some models.

This problem brings the question of solving polynomial equa-tions: during the resolution, which root of the polynomial should be chosen for further calculations? Modelica solvers use iterative resolution methods, so the authors believe that the choice of the root depends on the initial value of the variables. In CP, the choice is influenced by the domain of the variables, as constraint solvers use methods like box-consistency or interval Newton algorithm ( Hansen and Walster, 2004 ). All roots contained in the variable domain are kept (here, reference is made to the domain con-tracted by each step of the propagation of the constraints).
The Holtrop X  X ennen model, defined in Section 5.4 , includes conditions (If y Then y ) differently interpreted in the Modelica language and constraint programming (CP). In the Modelica language, these conditions are interpreted as a distinction of cases (i.e. a conditional structure as in imperative language). In
CP they are considered as a dynamically evolving system of constraints (i.e. the constraints present in the  X  X  X hen X  X  part of the structure are posted dynamically during the resolution as soon as the  X  X  if X  X  condition becomes true) ( Gelle and Faltings, 2003 ; Sabin and Gelle, 2006 ).

The emission model ( Vangheluwe et al., 2007 ) used in these experiments contains abacuses, the use of which is not trivial in the Modelica language. These properties make causal the imple-mentation of the model. Tables must be browsed to find the index of the box containing the value of the instantiated variable, then the values of other variables corresponding to the previously found index must be acquired. This method is not efficient at all from a computational point of view and leads to the non-reversibility of this part of the model. Indeed, it is no longer possible to impose a constraint on emissions (even if the function assert () previously described can be used) without resorting to iterative methods, the relevance of which has been discussed in
Larroude  X  et al. (2010) . In CP, some researchers are working on so-called global constraints; the global aspect can be semantic, operational or algorithmic ( Re  X  gin, 2003 ). The global constraint
Constraint Table permits the addition of constraints on any value of the constraint table. As shown in Larroude  X  et al. (2010) , it can be useful in design to add constraints on the emissions of the designed ship to be sure that emissions remain lower than the international environmental air legislation. 7. Conclusion and future work faced when dealing with steady state simulation. Existing simula-tion platforms were built to achieve 1D or 3D simulation. When considering preliminary design problems, it is often not necessary to investigate such heavy simulation and designers prefer to check the feasibility in a few relevant life situations of a system.
Moreover, we highlight the need of declarative a-causal models, providing more flexibility and the reuse of models. In this case, we are able to use classical models  X  from PDs to KPIs  X  to control a system even if mathematical equations have to be reversed, since we want to get values for the system control levers in a given context and for expected performances.
 for the steady-sate simulation of complex systems, meaning that it perfectly handles constraints related to this problem, as described in Section 2 . Indeed, since its acausality confers itself a flexible point of view, there is no need to declare if a variable is an input or an output: models can be used for direct or reverse simulation without any modification. Moreover, the CP approach is shown to be able to simulate at the same time models involving different kinds of physics such as mechanics and hydrodynamics so that it can be used to simulate complex systems composed of heterogenous components. Furthermore, in a pre-design situa-tion, it is possible to compute a domain for the performance variables of a not fully defined complex system (i.e. the system of equations to be solved is not squared since it features more unknowns than equations). In addition, with the implementation of constraints of inequality, the CSP approach can manage discrete events related to the state of continuous variables, thus permitting the control of complex systems. Eventually, thanks to the declarative aspect of the approach, it is not necessary to precondition the used models, thus providing a significant saving of time. All these points demonstrate that the CSP approach brings answers to the pre-sizing, control and simulation of the steady states of complex systems when current tools do not succeed in fulfilling all these points.
 The last part of the paper considers two solving approaches.
Modelica is closer to classical solving methods than CP, since it uses almost the same solving engine, requiring square systems of equations. It is based on a high-level object-oriented language to state models, which are reformulated into causal models in order to be simulated. A standard library can be used. It covers many scientific fields and provides SI units. On the other side, CP is an emerging solving technology in the simulation field. It has proved its relevance for combinatorial operational research problems, and this paper shows that it can also be used in the field of complex systems X  simulation, which would be useful for systems pre-design and driving. In CP, models are a-causal by nature and directly processed by a generic solving engine. One advantage of
CP is its ability to make set computations using interval arith-metic. This avoids numerical rounding errors, so that the same problem processed on several solvers should always yield the same results.

Constraint programming is the only approach able to manage effectively constraints of inequality and under-or over-con-strained systems. The reformulation process of Modelica implies at the solving step that a-causal models have to be thought in a causal way to be processed. This last point and the non-manage-ment of constraints of inequality are a clear lack. CP solving technology is generic and thus may meet slow solving time. Some strategies or heuristics can be used to exploit model specificity, but it could be difficult for CP beginners to fine tune the solver in this way. This last point is one main aspect of our future work, since we may want to provide steady-state dedicated heuristics to ease the use of CP by non-experts.
 Acknowledgments We would like to thank the F.U.I. for financial support on the EONAV project. We would like to thank all industrial partners: STX
Europe, DCNS, SIREHNA, SHERPA Engineering, ALTEP Inge  X  nierie and Bureau Ve  X  ritas for their contribution on the case study. Appendix A A.1. Nomenclature of the variables See Tables 6 X 11 .
 A.2. Equations of the models See Tables 12 X 23 .
 References
