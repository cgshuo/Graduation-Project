 ORIGINAL PAPER Martin W. C. Reynaert Abstract We present a new approach based on anagram hashing to handle globally the lexical variation in large and noisy text collections. Lexical variation addressed by spell-ing correction systems is primarily typographical variation. This is typically handled in a local fashion: given one partic-ular text string some system of retrieving near-neighbors is applied, where near-neighbors are other text strings that dif-fer from the particular string by a given number of characters. The difference in characters between the original string and one of its retrieved near-neighbors constitutes a particular character confusion. We present a global way of performing this action: for all possible particular character confusions given a particular edit distance, we sequentially identify all the pairs of text strings in the text collection that display a particular confusion. We work on large digitized corpora, which contain lexical variation due to both the OCR pro-cess and typographical or typesetting error and show that all these types of variation can be handled equally well in the framework we present. The character confusion-based proto-type of Text-Induced Corpus Clean-up ( ticcl ) is compared to its focus word-based counterpart and evaluated on 6 years X  worth of digitized Dutch Parliamentary documents. The char-acter confusion approach is shown to gain an order of magni-tude in speed on its word-based counterpart on large corpora. Insights gained about the useful contribution of global corpus variation statistics are shown to also benefit the more tradi-tional word-based approach to spelling correction. Final tests on a held-out set comprising the 1918 edition of the Dutch daily newspaper  X  X et Volk X  show that the system is not sen-sitive to domain variation.
 1 Introduction We present an approach to spelling variation identification and correction on the scale of very large corpora.

This work is situated in the context of the large digitization programmes underway at the Koninklijke Bibliotheek ( kb ), the Dutch National Library. The results of our work should be applicable to the etexts produced by a broad range of large digitization efforts comprising at least those involving lan-guages written in alphabetic scripts.

The main objective of this work can be illustrated by refer-ence to the difference one would find in the perceived correct version, i.e. the gold standard, produced for e.g. a printed book for the purposes of evaluating the electronic version obtained by means of Optical Character Recognition ( ocr ) versus the gold standard produced for evaluating a post-ocr correction system. The ocr -gold standard should faithfully represent the text as printed, i.e. would have end-of-the-line hyphenated and split words at the end of one and at the beginning of the next line. It would also mirror any typographical or typesetting errors that happen to occur. The ocr post-correction gold stan-dard would have neither: split words would have been restored and unnecessary hyphens removed, typographical or typeset-ting errors would have been duly corrected. Seen from this point of view, however perfect the ocr -process may eventu-ally become, post-correction will have real world use.
In this paper, we investigate a new approach to the iden-tification and correction of lexical variation implemented in the Text-Induced Corpus Clean-up tool ticcl . In principle, ticcl looks for any kind of lexical variation, whatever was its cause, be it historical spelling changes, typographical or typesetting errors, ocr misrecognition, transmission noise or morphological variation.

Approximate matches are strings that are similar but not identical to the string one looks for. An in-depth overview of the state of the art in approximate string matching can be found in [ 1 ]. While many algorithms for finding approx-imate matches between word strings have been developed, so far no algorithm seems to have been put forward that, per character confusion, identifies all those word pairs that differ in exactly the same particular set or bag of charac-ters, regardless of the actual character sequences. This paper proposes this approach. The approach takes a different tack from the usual local focus on one particular text string. We present a simple, efficient technique that allows for identi-fication of all the pairs of strings in a corpus that differ in the same particular set of characters. We call this a global, character confusion-based operation, in contrast to the local, word-based variant retrieval procedures employed by most spelling correction systems.

In Sect. 2 , we first discuss related work, with the focus on the two mainstream approaches to spelling correction today. We conclude the section by discussing what we see as the main drawbacks of both approaches in light of work on large-scale digitized corpora. In Sect. 3 , we outline anagram hashing and both the focus word-based and character confu-sion-based approaches to spelling checking. In Sect. 4 ,we then proceed to explain which information sources and filter-ing techniques the implementation of our correction systems was equipped with in order to be able to achieve high and well-balanced recall and precision. In Sect. 5 ,wesketchthe context in which we develop our systems, describe the cor-pora we work on and provide some statistics about the errors they contain. We evaluate extensively on a gold standard for a corpus of 327,798 pages of ocr -ed Dutch parliamentary text and on a held-out set comprising one year X  X  edition of a Dutch newspaper. We conclude in Sect. 6 . 2 Related work A very comprehensive, but now dated, survey of the field of spelling error detection and correction prior to 1992 is provided by [ 2 ]. Since then, tremendous amounts of work have been done, not only for English, but for many other lan-guages. The range and scope of the work has broadened enor-mously. An admirably concise yet very informative overview of the overall evolution in the field of lexical error correction is provided in [ 3 ]. Whereas spelling correction initially relied exclusively on a dictionary which delineated what is a real word and what is not, i.e. is a non-word, due to changes in the circumstances in which spelling correction has found appli-cation, reliance on the dictionary has lessened. Their last and most comprehensive reformulation of the spelling correction problem is the first to no longer make explicit use of a vali-dated lexicon of the language. In the work we report on here, this is also the case, as we shall show later.

Work on the post-correction of ocr -ed documents is by no means new. We note the study by [ 4 ] in which output from various ocr engines is set to vote on the most likely character sequence.

Our work is situated mainly in non-word spelling correc-tion, to which we see two mainstream approaches, although both have also been applied to context sensitive spelling cor-rection, i.e. the identification and correction of confused real words. On the one hand, there is the noisy channel-based approach going back to [ 5 ], in which the work of Cucerzan is rooted. On the other hand, there are large bodies of work based on Finite State technology, which gained considerable influence at least in part due to the work of [ 6 ] on agglutina-tive languages.

A very recent concise overview of the work in the source channel paradigm up to date is provided in [ 7 ]. The main application of this approach in recent years is in the context of the spelling checking of search queries. This is a diffi-cult task, as is evident from the rather low scores reported, i.e. 0.573 recall, 0.781 precision. We note that apart from accuracy, recall and precision are now being provided which implies that the importance of precision is gradually being recognized. The task of query spelling correction is very dif-ferent from corpus clean-up because the online medium pro-vides the training material necessary for applying the source channel paradigm. Fruitful use can be made of the recorded actions of the users who correct their own spelling errors in their own queries. There is unfortunately no equivalent for this in corpus clean-up. If the source channel approach is to be applied to corpus clean-up, costly hand-crafted training material will have to be created or error corpora will have to be fabricated. One possible solution might lie in digiti-zation programmes where manual correction is performed. This would require the alertness of the programmes X  man-agers to the need of preserving the uncorrected OCR-ed text and of providing these with the corrected versions for train-ing and testing purposes to the document analysis, recog-nition and post-correction community. Benchmark sets for almost all languages are sorely lacking and this perhaps helps explain why the source channel approach is not today commonly deployed in corpus clean-up. Early work on ocr post-correction in the noisy channel paradigm is by [ 8 ]. This escaped the notice of [ 9 ] who mistakingly claimed a first and further have had to report that the system developed by [ 10 ] outperforms theirs on their own test data. Both papers only report accuracy on error lists. The lack of re-usable benchmarks, consensus on the metrics and best practices for evaluation and the fact that many researchers de facto work on different languages make fruitful comparison of achieve-ments and progress a goal to be reached in the future.
Likely in the absence of sufficiently large corpora and lack of training materials, statistical approaches developed on the morphologically less rich English language were found wanting and researchers such as Oflazer working on the highly agglutinative Turkish language turned to Finite State techniques. These techniques also allow for model-ing subtle exceptions in a language which are less likely to be discerned by statistical approaches. This has found wide acceptance and has been successfully applied to corpus clean-up. Working in this mainstream Finite State Automata ( fsa paradigm, mainly on German corpora, the group around professor Schultz at the University of Munich work on large-scale corpus clean-up. In [ 11 ], the focus is on post-correc-tion of ocr -ed corpora, while in [ 12 ], on the cleaning of web-derived corpora. The paper describes in detail how the typical error types that are observed in collections of typo-graphical, spelling and ocr -errors are modeled. Further how and why the ranges of errors are limited in order to build error dictionaries in which these patterns are applied to validated dictionary words and the fabricated erroneous word forms incorporated in an fsa .

We shall see that the approach presented here does not require prior error modeling, so no prior assumptions about which error types may or may not be encountered are made. Neither need we fabricate and represent the possible errone-ous word forms, as is necessary in the fsa paradigm. Within the limits of a particular Levenshtein distance ( ld )[ 13 ]we set it to search in, our approach exhaustively surveys the full corpus and retrieves all the variation present in it. Perhaps most importantly, the vocabulary of the corpus under consid-eration is dynamically incorporated and use is made of the observed token frequencies to help guide the correction pro-cess. This alleviates the well-known domain and genre effects that seem to be currently primarily attracting this group X  X  attention, cf. [ 14 ]. We are not sure whether incorporating the corpus vocabulary at correction time is possible in the fsa paradigm.

The two mainstream approaches to spelling correction, the noisy channel and fsa approaches, both have drawbacks. Noisy channel approaches, although there have been attempts to reduce the effects of this dependency, need costly train-ing material. fsa approaches do not necessarily need this, but underlying the fsa s that are built need necessarily be particu-lar assumptions concerning the data to be handled, mainly to reduce the cost of the fsa itself, i.e. for reasons of scalability. These assumptions necessarily limit the capabilities of any fsa which is built, e.g. if it is assumed that the first character of a word is hardly ever substituted for another character, the system will not be able to handle this phenomenon if it nevertheless does occur.

The system we describe in this paper does not require training material, it derives the statistics about e.g. character confusions that occur from the corpus to be cleaned itself. This entails that no prior assumptions regarding the prev-alence of particular phenomena within the material to be cleaned need to be made. In fact, within the limits of the ld the system is set to work, it will exhaustively gather all the variation present and employ the statistics gathered about them to the full.

One major obstacle in this work is the huge diversity in corpora. Corpora may have been born digital or be the result of digitization efforts. They can be in any language. There is a huge diversity in text types and domains. Increasingly, diachronic spelling is revived by the digitization of older text collections. There are tremendous amounts of work to be done. We would argue that a system which does not require prior modeling or specific training data is worth investigat-ing. In the next Section, we describe such a system. 3 Anagram key spelling correction In this section, we first describe the basic algorithm underly-ing both the focus word-based and character confusion-based approaches to large-scale spelling correction. 3.1 Anagram key search 3.1.1 Introduction to anagram hashing Anagram hashing is the core spelling variation identification algorithm we first described in [ 15 ] and in more depth in [ 16 ]. Anagram hashing uses a simple hashing function to assign a large natural number to all word strings in the corpus at hand. The natural number assigned is the same for all word strings that consist of the same set of characters. For each word type in a ticcl lexicon or in a corpus to be processed by it, anagram hashing obtains a numerical value, which will serve as an index or hash key to the actual word strings. The formula represents the mathematical function devised to do this, where f is a particular numerical value assigned to each character in the alphabet and c 1 to c | w | the actual characters in the input string w .
 Key (w) = Informally: the numerical value for a word string is obtained by summing the code value, e.g. ISO Latin-1, of each charac-ter in the string raised to a power n , where n was empirically set at: 5.

By application of this formula to the list of word strings obtained from a corpus, in effect, all anagrams, loosely defined as words consisting of a particular set of charac-ters and present in the list, will be identified through their common numerical value. In the limit, associated with a par-ticular key would be the n ! permutations given n distinct characters, if these were realized within the corpus. Given the set of characters a, b, c , there could be 3x2x1=6per-mutations, but only two, i.e.  X  X bc X  and  X  X ab X , are likely to be encountered in e.g. an English dictionary. As the collisions produced by this function identify anagrams, we refer to this as an anagram hash and to the numerical values obtained as the anagram values ( av s) and anagram keys , when we discuss these in relation to the hash. Based on a word form X  X  anagram key, it thus becomes possible to systematically and sequentially query the list for any variants of a particular word string present, be they morphological, historical, typo-graphical, orthographical or due to ocr -misrecognition or other transmission noise. This querying is done on the basis of the av s which represent the alphabet which is used. ticcl in fact performs a bounded exhaustive search over the possible permutations given a particular set of characters that happen to have been realized in the particular corpus it is set to work on. This is less expensive than it may seem in that in practice within a language only a limited number of all the possible word forms given a particular set of characters are realized as valid words. 3.1.2 Alphabet Instead of matching on actual characters, we perform sim-ple mathematical operations with the av s derivable from the alphabet A used. The actual amount of av s is defined by the ld or edit distance the system is allowed to cover and the size a of A .The ld then defines the k character dif-ferences or possibly  X  X rrors X  that the system will search for. In this work, k = 2. Given the characters in A in combina-tion with k = 2, the av -alphabet contains the av s for single characters and for all possible two-character combinations derivable from this alphabet. 3.1.3 Lexicon The lexicon contains the vocabulary of the validated dictio-nary (if any) as well as the vocabulary from the corpus to be cleaned. The lexicon is a regular hash built up at run-time having the av s as keys and chained anagrams as values. 3.2 The sequential focus word-based approach In the focus word-based approach, each word string is examined in a sequential fashion, making the word string under consideration temporarily the  X  X ocus word X  ( fw ). Most approximate matching and therefore spelling correction sys-tems work in this fashion.
 The fw is not likely to contain all the characters in A . The subset of values from the av -alphabet derivable from the characters actually present in fw forms the fw -alphabet. If k = 2, the fw -alphabet has all the av s for the character unigram and all possible bigrams derivable from the Given the av for a particular fw and by systematically querying the lexicon hash on the basis of all the values in the av -alphabet and in the fw -alphabet, all possible variants that fall within k are retrieved. The actual number of hash look-ups required is defined by the number of unique values in the av -alphabet and by the number of unique values for all the character combinations in the fw up to k .

The av for the focus word and the fw -alphabet and av -alphabet are used to query the lexicon hash for variants of the focus word. These variants can all be seen as varia-tions and combinations of the usual error type taxonomy due to [ 17 ]. In the implementation, all four edit operations are handled as substitutions. For substitutions ,avaluefromthe fw -alphabet is subtracted and a value from the av -alphabet added. A single query on the av for  X  X esterday X  minus the av for an  X  X  X , plus the av for an  X  X  X  may thus retrieve the typo: *yeaterday. Insertions are substitutions where a value from the fw -alphabet is subtracted and zero added. Deletions are substitutions where zero is subtracted and a value from the av -alphabet added. To find transposition errors, nothing needs to be added or subtracted, but the chained anagrams for the particular focus word av need to be examined. If only a single word string is associated with the fwav , no trans-positions can be present. If anagrams are associated with the fwav , then a pair of these may be found to contain transposi-tions. The transposed characters need not be adjacent. To give an example: given that a corpus contains the words  X  X teenm-olen X  (E: stone mill) and  X  X olensteen X  (E: mill stone), but also the non-word:  X  X elonsteen X . The three anagrams will be chained to the same av . The first two have an ld of 5 and are ruled out as containing a transposition error. The last two have an ld of two and can thereby be identified as containing a transposition error. 3.2.1 Pseudo-code for the sequential word-based approach Set LDlimit to k Set WordLengthLimit to l Foreach FocuswordAnagramValue 3.3 The sequential character confusion-based approach Given a particular k and a particular alphabet A , we first form all the possible combinations of all the characters in A and calculate their av s. We then perform all the additions, dele-tions and substitutions on the basis of all their av s. Given that k = 2 and alphabet size a is 31, this gives 123,752 unique values. These values represent all the possible minimal con-fusions given A and k . Minimal confusions are the result of the fact that equal characters on both sides of the equation cancel each other out. Calculating the av for the character combinations  X  X b X  minus  X  X  X  or for  X  X c X  minus  X  X  X , we obtain the same minimal confusion: the av for  X  X  X .

Given this list of character confusion av s, one can now query the list of lexicon/corpus anagram keys for all the word/anagram pairs which display these particular numer-ical differences. This we do sequentially for all the character confusion av s by efficient iteration over both numerical lists. 3.3.1 Pseudo-code for the sequential character Foreach CharacterConfusionValue in CharacterConfusion
Endfor 3.4 Necessity of output filtering The word pairs identified per character confusion and retrieved from the anagram hash constitute the members of the confusion set. Be advised that a particular confusion in fact describes a minimal confusion. The actual surface forms of a member pair may be very divergent: all we know a priori about them is that they differ by the set of characters implied by the confusion X  X  anagram value and that one of the pair will show the extra (or in anagram value terms: numerically greater) character(s). The actual sequence of the characters in the pair may be very different. This is where the ld comes in: only for the pairs retrieved need we measure their ld .Ifthis measured ld exceeds the ld implied by the confusion X  X  ana-gram value, the pair has been spuriously linked and should be discarded. 4 Text-Induced corpus clean-up or TICCL The ticcl prototype presented in [ 18 ] was turned into a pro-duction version for the kb according to their specifications. The production version at first performed only fw variant lookup. The move to the cc variant look-up in the current form is new. Also, new is that in the fw mode retrieved vari-ant pairs are no longer evaluated in isolation, but as members of the cc sets they belong to, i.e. on the basis of the sizes of these sets: the statistics obtained over the whole corpus about the variation within k actually present.

Faced with the tremendous rates at which very large collections of digitized text grow and are becoming avail-able online, we have been searching for alternative, simpler solutions to the lexical variation problem. In [ 19 ], we have presented our first attempt at approaching the problem not from a word type-centered perspective, but from the charac-ter confusion perspective. We there described a solution for finding all the word pairs in a corpus that exhibit the same character confusion in a single parallel operation. The solu-tion proposed was a Boolean AND operation on very large and sparse bit vectors built from the anagram hash for a partic-ular corpus. This was later found to be unnecessarily costly, the vectors being very sparse, and the idea was shelved. We here propose a faster and in fact simpler solution. ticcl is implemented in Perl. For the character confu-sion iterations, we have had a fast C ++ module built which efficiently performs all the necessary iterations over the ana-gram keys for the corpus-derived anagram hash on the basis of numerically ordered lists. 4.1 TICCL: Step 1: normalization for search space ticcl first effects a thorough normalization of the corpus it works on. Primary aim of this normalization is to drastically reduce the search space ticcl has to work in by a reduction in the actual number of different characters present in the corpus. In this paper, we reduced this number to the size a of A , where a = 31. In our experience, the ocr process may very well produce all the characters in the full code page, even non-printing characters. This search space needs to be reduced to manageable proportions.

The alphabet A we work with here is the range of the lowercased characters  X  X  X  to  X  X  X . ticcl basically ignores numbers, internally these are all converted into  X 3 X . This frees up the other digits. We translate all punctuation marks except for the apostrophe and the hyphen into the digit  X 2 X . The word-internal punctuation marks apostrophe and hyphen retain their own identity. All characters bearing diacritics are translated into the digit  X 4 X  when lowercase and  X 5 X  when uppercase.

In Step 1 of processing, ticcl traverses the range of direc-tories it was directed to and normalizes the word forms it encounters in the files to be processed, building frequency lists and, optionally, bigram word list on the way. Full word form normalization is postponed until all the word forms have been seen. Because we do not work on preprocessed input, i.e. no prior sentence splitting or tokenization is required or assumed, we iterate over the frequency list containing the corpus vocabulary and conflate all the word forms that contain normalized punctuation with the matching higher frequency word forms that do not contain normalized punc-tuation. At this point, the punctuated form X  X  frequency is tallied to the unpunctuated word form X  X  frequency and reset to zero. The observed surface forms, i.e. the non-normalized conflated word forms X  character strings as observed in the corpus, are stored in a separate hash. These forms are thus withheld from further cluttering the search space during var-iation look-up. At the end of total processing, they are linked to the canonical form reported for the normalized, unpunctu-ated word form. In this same manner, words having diacritics or names requiring capitalization are output in their canonical form. 4.2 TICCL: Step 2: Character confusion word pair This second step is the only one in which the all-Perl fw mode and the combined Perl/C ++ cc mode implementa-tions differ.

The fw -based version in essence processes part of the corpus vocabulary word list by descending order of the word forms X  frequencies. A number of parameters may be set to restrict this process, i.e. frequency thresholds may be imposed or word length restrictions invoked. The settings for the tests we report on later were: process everything between the highest frequency observed and above frequency 1 having word length longer than 5 and shorter than 100 characters. The motivation for this limit on word length is this: for some words, there simply are no other words resembling them to the extent that these would fall within the ld of 1, 2 and even more edits. As such, words with a higher neighborhood density [ 20 ], especially short words and words derived from a stem and highly common pre-and/or affixes, are far more likely to incur more False Positives. Short words not even being indexed by search engines we therefore disregard.
The sequential cc -based version works on the lexicon hash obtained from the normalized corpus. For efficiency, this may already have been reduced in size, i.e. when building this hash one may want to opt to not include word forms shorter than a particular threshold. This we did not do in the tests described further. The C ++ routine works strictly numerically on the anagram keys of the lexicon hash and the character confu-sion av s. The module X  X  output is lists of corpus anagram key values each linked to a particular character confusion av
Wo r k i n g i n cc mode has introduced the need to rethink handling the variation retrieved by the system. The fw mode returns a set of actual variants displaying a range of charac-ter confusions per particular focus word. This set has already undergone some filtering on the basis of the actual word pairs retrieved from the lexicon hash. Words shorter than the length limit set have not been retained, pairs displaying a larger ld than k have also not been returned. Word pairs where both members do not actually occur in the corpus, i.e. that have an undefined corpus frequency, are also discarded. The cc mode returns a possibly very large set of references to word type pairs, all displaying the same character confusion, somewhere in the bags of characters that these word types represent. For a first filtering, we now need to retrieve the character confusion word pairs from the lexicon hash and apply the ld and word length filtering. We also perform a single pass over the lexicon hash and retrieve the word pairs displaying character transpositions in the way described in Subsect. 3.2 .

When this filtering has been performed, we now have sets of likely word pairs. We can now also determine the size of these sets, thereby gathering useful statistics about the actual variation present in the corpus. 4.3 TICCL: Step 3: filtering the output In Step 3 in processing the corpus, all the character confu-sions are handled sequentially in descending order of the size of their character confusion set membership. This is equiva-lent to assigning a higher probability to one particular con-fusion than to another.

We next perform additional filtering of the word pairs. For this, additional sources of information are used. 4.3.1 Additional language information sources  X  Validated lexicon: The validated lexicon consists of the  X  Validated lexicon confusables: Within k , we build a full  X  Ispell morphological rules: To identify morphologically 4.3.2 Contribution of additional language information In applying the information sources described above to the corpus vocabulary, we are able to:  X  correctly link morphologically related word forms  X  to avoid linking the semantically unrelated but typo- X  and finally to retain primarily those word pairs that are 4.3.3 Filtering loops implemented in ticcl We next examine all the remaining word pairs per character confusion av with the latter in descending order of member-ship sizes.

The character av s either correspond to the set of derived from the minimal confusions of the Ispell rules or not. If corresponding, for each word pair retrieved, we check if any of the expanded Ispell rule patterns apply. If a pat-tern applies, the pair is identified as being morphologically related word forms. If no pattern applies, the pair is linked as being error variants. This linking is done on the basis of the observed corpus frequency of both word forms, the lesser fre-quent form being linked to the higher one. The assumption in this is that the more canonical word form is likely to be more frequent than an erroneous variant, given Zipf X  X  law [ 21 ].
For those character confusion av s that do not correspond to an av derived from the minimal confusions of the Ispell rules, we first check for each word pair retrieved whether it occurs in the validated lexicon X  X  matrix of confusables. If it does not, the words are linked according to their frequencies in the same manner as above.

We perform no further filtering in the current ticcl although further refinements are due to be added. We here report the evaluation results obtained with this simple filter-ing only. 4.3.4 Ranking The word pairs finally retained are output after they have undergone sorting, i.e. a final ranking of the correction can-didates. We sort them according to the observed order of having been filtered according to the sizes of their cc mem-bership set, then according to the ld between canonical form and lexical variant, finally according to the frequency of the canonical form. We have tried different sorting sequences, but obtained the best results with this one. All results reported in the next Section were obtained by sorting according to this sequence, except those where no ranking was performed.
At time of output, we can invoke a stopping criterium: with best-first ranking only a single pair is output, with 2-best or rank 2, the two first ordered pairs, etc. 5 Evaluating TICCL 5.1 Preliminaries to the evaluation of ticcl This work was undertaken with a specific user in mind, i.e. the kb . At least to some extent, it was undertaken in accordance with the user X  X  requirements and according to his specifica-tions. The user undertakes huge digitization programmes in order to make available online large parts of his immense text collections. These programmes are not undertaken in uniform ways, although all adhere to specific international standards. As such, the user requires flexibility and independence from our tool and our solutions. We were not asked to deliver a tool that would correct the kb  X  X  digitized texts. Rather, we were asked to deliver a tool that would allow them to enrich the digitized texts with canonical forms for the word vari-ants present in these texts. The canonical forms added to the texts should allow for better recall on users X  queries through a search engine built on top of the particular text collection.
The above considerations help to define what the target of our tool is and thereby how we should evaluate it. The target should be those word forms that enhance the recall of a user X  X  query. The kb would like its users to be able to query histor-ical documents in the contemporary spelling, given that the user may well not be familiar with historical spelling and/or the fact that historical spelling varied a great deal through-out time and space. This we do not deal with nor measure in the current paper. What we do measure here is how well our two approaches manage to deal with lexical variation due to typographical/typesetting or ocr misrecognition error. 5.2 The corpora On invitation by the kb we have worked on contemporary and historical text collections. We developed on the con-temporary collection, which comprises the published Acts of Parliament (1989 X 1995) of The Netherlands, referred to as  X  X taten-Generaal Digitaal X  (henceforth: sgd ). 7 From the historical newspaper collection, the  X  X atabase Digital Daily Newspapers X  8 ( ddd ) we have chosen the 1918 edition of  X  X et Volk X  (E: The People). We list statistics on the corpora in Table 1 .

We list statistics obtained from the ocr -ed corpora we here work with: error statistics on 5,047 mainly ocr -errors from the sgd in Table 2 and 3,799 from the ddd in Table 3 .Forthe sgd , we focused on the word  X  X elasting X  (E: tax), a common topic in parliamentary debate, and strove to identify all vari-ants in all morphological and compound forms of the word. In all, we identified 1,577 variants for the various guises of the noun  X  X elasting X . For the ddd , we opted to identify all the variants for the lemma  X  X egeering X , i.e.  X  X overnment X . This lemma yielded 1,468 variants in a single newspaper in the ddd , the 1918 edition of  X  X et Volk X  alone. A multiple error cannot be described by reference to just one of the 4 cate-gories of errors, i.e. either to insertion, deletion, transposition or substitution alone. A multiple contiguous error (multi-C) would be the ocr -error  X  X egeermg X  for  X  X egeering X , i.e. the multiple error consisting of deletion of an  X  X  X  and substitu-tion of the  X  X  X  by  X  X  X  is situated in one location within the word. A multiple noncontiguous error (multi-NC) would be the ocr -error  X  X cgecring X  for  X  X egeering X . 5.2.1 Gold standards We measure the extent to which ticcl manages to achieve acceptable recall and precision on our gold standards. These gold standards, while quite large, are necessarily limited and may well not be adequate to show the systems X  full, real performance. The system might actually fail regarding phe-nomena that occur in the corpus but for which there happen to be no instances in the gold standard.

We evaluate on a subset of the paired lists of variants and focus word for which we presented error distribution statis-tics. The subsets involved all the variants for the 20 sgd words in Table 4 , 890 in all, and all the variants for the 17 focus words for  X  X et Volk X , 3,102 in all. Listed next to the focus words are the numbers of variants found. Sampling the typographical variation present within the corpora involves exhaustively gathering all the typographical variants for the focus words. There is some overlap in the common words between the sgd and  X  X et Volk X . Names, especially names of historical figures, being more tied to their era, provide less opportunity for such overlap.

We built a gold standard for the years 1989 X 1995 ( sgd8995 ). We here re-use this for evaluation on the devel-opment set and for running ablation tests with the aim of demonstrating the contribution of the various language infor-mation sources to full system performance. We eventually also test on the held-out gold standard derived from  X  X et Volk X  1918-articles ( hetvolk1918 ). For the purposes of the present work, we ignore the fact that Dutch spelling was offi-cially changed, repeatedly, since then and test the system on its ability to link word variants to their canonical form at the time. So we do not require that e.g. the 1,468 variants for the current spelling  X  X egering X  (E: government) are linked to this current canonical spelling, but measure whether they are linked to the then canonical spelling  X  X egeering X . 5.2.2 Test settings The tests were limited to unigram correction only, we here did not perform variant retrieval for word bigrams. The gold standard did not contain any instances involving spaces. k is 2. We use real world dictionaries, which do not necessarily contain all the correct word forms for all the variants pres-ent. We evaluate on the n-first or  X  X est X  ranked correction candidates returned by the systems, and we measure how well the system is able to detect errors and to suggest the appropriate correction candidate within the n candidates it maximally reports without making use of any local context. This is measured in terms of the impact on word types, but for the held-out test set, also in terms of the impact on the word tokens, i.e. in terms of how often a word type appears in the corpus and may thus influence the overall quality of the text. 5.2.3 Metrics used We evaluate in terms of recall and precision, resulting in the combined F-score [ 22 ]. These metrics are derived from the numbers of True Positives ( tp s), False Positives ( fp False Negatives ( fn s) returned by the system. True Positives are defined by what constitutes the target of our exercise. The target is the primarily non-word variants present in the corpus-derived list to be processed. False Positives are non-word variants or real words, that are erroneously reported to be variants for a particular focus word. False Negatives are those items in the list of known, annotated variants for the particular focus word that are absent from the list of variants returned for this focus word, i.e. that the system was not able to retrieve or  X  X orrect X . The formulae used are as follows: Recall = r = Since we deem recall and precision to be equally important, the harmonic mean of r and p , the simplified F measure, f is given by: F-score = f = 5.3 Evaluation of ticcl All performance scores reported here are accumulated ld 2 scores. We did not set k higher, so we do not measure higher ld scores. Scores are on n-best first ranking, in contrast to previously reported results on these corpora. Scores reported in [ 18 ] were  X  X verall X : however many correction candidates were retrieved, given that the correct one was among them, the system was there given credit for it. Good first or sec-ond best and well-balanced scores are a prerequisite for a spelling and ocr correction system to be set to work fully automatically on a corpus. 5.3.1 Comparison of fw and cc modes on sgd8995 We have now evaluated and timed both approaches. Table 5 shows performance of ticcl in scores and time in min-utes required when run in fw versus cc modes. The only difference in the implementations and running of the two approaches lies in the identification of the variants present. For steps 1, 3 and 4 of the whole process, the Perl code is shared. The C ++ cc -based code replaces that for step 3 of the fw approach.

The differences in performance scores are negligible. We have hereby shown that a sequential word-based system may also collect the global information about the various charac-ter confusions seen within a corpus and apply this knowledge in the same way as the cc approach does, i.e. by handling all the sets of character confusions in the order of decreasing size of their membership sets.

Processing times differ by an order of magnitude: average run times over the five runs here are over 22 h for the fw mode and just over 3 h for the cc mode. While ostensibly feasible, building all possible character bigrams for every word type to be examined by the fw approach is costly. It is this cost which is translated into the far longer processing times required. This provides conclusive evidence that the cc approach allows faster identification of spelling variation with less work, given a large corpus. Given a relatively small corpus e.g. a single ocr -ed book would however not call for an exhaustive look-up over all possible cc s, indicating the use of the fw approach. 5.3.2 Ablation tests on cc mode on sgd8995 Further evaluations are performed in cc mode only. We run ablation tests in which information sources are not available to the system and test the effect of ranking the correction candidates.

Table 6 shows performance of ticcl when information sources are left out in comparison with the full system.
Measurements beyond rank 3 on ranks 4, 5 and 10 show no further fluctuations in the scores when ranking is done. Not using a validated lexicon has the greatest effect on pre-cision. The validated lexicon and the lexicon confusables information actually have an adverse effect on recall, but greatly contribute to the level of precision attained by the full system. While their impact is slight, the Ispell dic-tionary and affix information do contribute about 1% to overall performance of the full system. This should be due to the effect of the morphological information being applied by analogy to unknown words. Dutch is highly compounding, and compounds are not listed in dictionar-ies when their meaning is inferable from the compounding parts.

The results of the ablation study are highly informative concerning the contribution to the excellent performance of the full system. We discuss their impact on first-best rank-ing results. Both validated lexicon and confusables list cause some loss of recall in the full system, but this cost is offset by the gain in precision, respectively, 6.2% for the validated lexicon and 5.5% for the confusables list. The morphologi-cal information derived from Ispell, in combination with its lexicon, helps both recall (0.3%) and precision (1.6%). The combination of the three information sources in the full sys-tem causes a negligible loss of recall (0.1%) which may well be due to rounding effects, for a total gain (6.3%) in preci-sion which may well be fully due to the validated lexicon. All language information resources omission tests showed no further divergence in scores beyond rank 3. What we do see is that from rank 2 onwards recall climbs to 99.0%. Divergence in scores on ranks higher than 3 we do observe when we omit the ranking. When the information sources are in place, we see that precision remains strong and sta-ble, showing 0.7% gain on rank 2. Recall, however, plum-mets to just below 50% on rank 1 to almost fully recover to 95% on rank 10. Note that with no ranking at all in place, the system in effect randomly outputs retrieved word pairs due to the random nature of Perl hashes. When the informa-tion sources are then also left out, recall drops to 50.9% to recover better to 97.8%. Precision remains below 90% on all ranks.

We have now discussed our performance results, obtained on the development set sgd8995 . We now continue with results on the held-out test set hetvolk1918 , for the full system only. 5.3.3 Evaluation of cc mode on held-out hetvolk1918 We list the results obtained per rank on hetvolk1918 Table 7 . We list the results on word types and on word tokens.
The performance scores on word types obtained on the held-out test set hetvolk1918 are fully in line with those obtained on the qualitatively very different sgd8995 .They represent very different text types and domains.

We claim to have developed an unsupervised, flexible, viable and competitive approach to large-scale spelling and OCR-error correction which requires no training data, adapts to the lexical variation actually present within a corpus and travels well across domains.

We developed on the sgd8995 gold standard and per-formed final evaluation runs on the held-out hetvolk1918 gold standard. These are qualitatively very different corpora, the first representing state-of-the-art high accuracy ocr text, the second very low-quality ocr -ed text obtained from low quality, non-ocr oriented microfilms made from low-quality paper and print. On the basis of the performance scores on the sgd and hetvolk1918 gold standards, we conclude that given the extra information available to ticcl i.e. the affix rules borrowed from Ispell, their application by analogy to the full corpus vocabulary and the availability of full knowledge concerning the possible confusables present in the validated lexicon within k , all combine to deliver a highly efficient system for the post-correction of large cor-pora, whatever the form or origin of the lexical variation within them. The scores show that ticcl handles typograph-ical and ocr misrecognition errors equally well. Given its exhaustive look-up, there is no need to model for arguably different types of error. 5.4 Discussion of ticcl 5.4.1 Variation in character confusion in different corpora We have so far worked under the assumption that just about anything can happen to the character strings when a cor-pus is digitized, depending on circumstances such as the ocr -software used, mode of scanning, quality of the input whether paper or microfilm, etc. Since our approach does not require prior error modeling, we do not risk having made incorrect or incomplete assumptions about the actual varia-tion present in a particular corpus. If we look at the top 20 character confusions observed in our test runs on sgd8995 and hetvolk1918 , shown in Table 8 , we see that at least with respect to these major character confusion classes our assumption is confirmed that the actual variation present in the text tokens may widely diverge between different text col-lections. The top two confusions in sgd8995 in fact reflect morphological variation in Dutch, these two being singu-lar/plural character confusions. The top two confusions in hetvolk1918 show the main ocr -induced confusions on the most frequent character in Dutch, i.e.  X  X  X . 5.4.2 Language independence The algorithm we have presented is not language-dependent in se. In [ 16 ], we worked on both English and Dutch and built a trilingual spelling correction system by further add-ing French to a mixed English-Dutch system. ticcl retains this feature. 5.4.3 Distributability for parallelization An attractive feature of character confusion-based spelling variant retrieval is the fact that the search for particular con-fusions can easily be distributed over as many processors or computers one has at hand. So the character confusion look-up enables easy parallelization of the full task. This should enable the method to scale to the largest corpus sizes. ticcl could easily be run-on x processors for this work by simply dividing the list of the anagram keys for the n confusions to be examined in x equal parts. This would fully ensure there is no overlap between the systems running independently and that no double work is done. All tests reported on here were run-on single Intel Xeon 3Ghz. processors. 5.4.4 Further steps We have shown that anagram hashing provides a powerful framework for tackling lexical variation in corpora. We have shown that it allows for easy integration of external infor-mation sources regarding the language. Validated word lists and lists of named entities contribute heavily to the per-formance. The full mapping of confusables within the vali-dated lexicon likewise. Morphological information, too, can easily be accommodated and contributes. The framework explored here provides a solid basis for further extension and refinement. No doubt even better best-first ranking can be achieved, by means of more refined ranking mechanisms as explored in related work. We have here limited ourselves to addressing the variation given k = 2. Moving beyond that is straightforward but requires more processing. Extending the alphabet with a space, given word bigrams in the lexicon, allows for addressing the problem of split and run-on words, as was shown in [ 16 ]. 5.4.5 Availability To conclude, a final remark about ticcl  X  X  availability: ticcl and the kb gold standards are to be made available under open source licenses. The corpora we have worked on here are freely available online at the kb . 6 Conclusions In this paper, we have presented a global approach to tackling spelling variation in corpora.

We have proposed a character confusion-based look-up algorithm for identifying all the pairs of words that happen to be confused in particular characters. We have demonstrated that we can exhaustively examine and further process the word type list of a large Dutch corpus for all the character confusions up to ld 2 in a couple of hours.

We have conducted formal evaluations on a contemporary corpus and on a historical corpus both of which have been digitized by the kb , the National Library of The Netherlands. In these tests, conducted with both a development gold stan-dard for the contemporary corpus and a held-out gold stan-dard for the historical corpus, we have compared the focus word-based working mode of ticcl with the character confu-sion-based mode. Preliminary work had given us useful new insights into how the more traditional, sequential word-based approach can also be made to gather global statistics about the variation in a corpus. This should also be applicable to any other focus word-based spelling correction approach.
Our contribution is that we have proposed an unsupervised viable alternative based on anagram hashing for spelling cor-rection purposes of large ocr -ed corpora to the mainstream source model and Finite State approaches, both of which need costly training materials. We have shown that by focus-ing not on each word string individually but rather on the character confusions that sets of word pairs have in com-mon, useful statistics are gained which enhance the ranking of correction candidates and help to provide not only great recall, but also sufficiently high precision for the process to be run automatically, in an unsupervised fashion.

We have in this paper demonstrated that the framework of anagram hashing allows for easy incorporation of useful sources of information helpful to the process of fully auto-matic, unsupervised clean-up of large ocr -ed corpora. We have shown that morphological information may be applied by analogy to unknown words, which helps in highly com-pounding languages such as Dutch.

The cc approach has been demonstrated to be fast on large corpora. The fw approach remains viable, and indicated, for smaller clean-up tasks such as a single ocr -ed book.
Faced with the huge scale of the current digitization pro-grammes, the inherent distributability of the cc approach is a valuable asset. The numerical work to be performed on just two lists of numbers can very straightforwardly be distributed over as many processors as one has at one X  X  disposal. Given the right hardware, i.e. sufficient numbers of processors at hand, the gigantic task of cleaning-up say one hundred years X  worth of sgd ocr -ed text might well soon be performed in a single day.
 References
