 Web services are gaining momentum in industry as a paradigm for building and deploying applications with a strong emphasis on interoperability between service providers. Inherent in this movement is the need to codify and monitor performance of applications or application componen ts which are administered or purchased agreements (SLAs), which can capture ex pectations and roles in a declarative fashion [1,2]. One view of such agreements is that they constitute a domain specific language. As with any language, then, the question becomes how to map the  X  X igh X  abstraction of the SLA language into a lower-level implementation. This amounts to run-time measurement, feedback, and adaptation interspersed into a web service-enable application. 
In addition to viewing SLAs as a domain specific language, it is helpful to consider them as an aspect of a web-based application in the sense of Aspect Oriented Programming (AOP)[3]. This follows from noting that SLAs typically describe some application functionality that crosscuts application implementation which means that given a complete implementation of the application including service monitoring, then the SLA implementation code will be found in multiple components of the main application, an d furthermore, the crosscutting code is heavily mixed, or tangled , in components where this crosscutting occurs. 
AOP centers on the use of source code weavers to attack this problem crosscutting an tangling in an organized fashion. Currently, the most significant AOP tool has been the AspectJ weaver [4], developed after several years of effort, which supports the addition of aspect code to general Java applications. Applying the same techniques to C and C++ code, however, has been harder. The question arises, then, as to whether it is difficult to implement weavers for any language. We built the AXpect weaver into the existing code generation framework, the Infopipe Stub Generator [5,6]. The ISG has three important parts: the intermediate collection of templates written in XSLT. 
This paper describes the architecture and implementation of the AXpect weaver in detail, as well as discusses a prototyp ical example application whereby a WSLA document is used to specify CPU usage policy between a server and client of a media stream. In section 2, we introduce the Infopipes abstraction for distributed applications. In section 3, we discuss the pre-existing code generator for our project, the ISG. In section 4, we present a close look at how we implement AOP in our system, and in section 5, we evaluate the weaver in the context of an example media application. distributed programming paradigm. This mainly stems from the fact that a distributed application may have to deal with comparatively vast time scales, less security, and much greater divergence in resource availability than when operating on a single machine, even if it is a parallel machine. Consider that memory access and procedure call times may be measured in nano-or micro-seconds, but that web applications must address millisecond latencies  X  three to six orders of magnitude longer. 
Infopipes are designed to take these differences into account, particularly for information flow applications. One reason for targeting information flow applications is that they are difficult to capture abstractly using RPC because their normal operation, sending a continuous stream of data, is innately mismatched to RPC X  X  request/response scheme. Second, such applications often involve multiple processing steps, a concept that is again not addressed by RPC X  X  encouragement of the client-server style. Finally, RPC completely obscures the communication taking place in the application, so that if latency, bandwidth, security, or some other property is needed then a developer mu st  X  X ncover X  the communication and insert new code to recover lost data about connection performance, and add any new functionality by hand which may be particularly difficult if some sort of end-to-end property is desired to be enforced. As we stated before, Infopipes expose the communication step, and make it much easier for a developer to capture connection information and implement properties around needed communication boundaries. 
The Infopipes architecture is service-oriented  X  it encapsulates granules of distributed computation which are intended to be composited together [7]  X  just like those proposed for web service applications. While the ISG does not currently explicitly support XML as a wire format as is currently required to be Web Service compliant, it in no way excludes such a possibility, and even some previous unpublished Infopipe experiments have used XML as an ad hoc wire format. The ISG, in fact, already supports two completely different wire formats  X  PBIO, which is the wire format for ECho, and x86 byte-ordered data, as might come directly from a C program. 
We have devised a prototype application to demonstrate Infopipes. The application is a video-streaming example in which the receiver of the video stream has Quality of Service requirements; it is constrained by its CPU resource and must provide feedback to the sender of the str eam to control image arrival rate. Our code generator creates the communication setup, binding, and marshalling code and then automatically incorporates the QoS code which is parameterized in an external WSLA document. In the next section, we describe the implementation of our ISG to generate the base communication code. For this example, we will denote as our base application the sender and recei ver X  X  communication code with no QoS supporting code. 
We can see that there the application requires several functions to be implemented to support its QoS needs: a control channel, for feedback information; timing tags and code to monitor the CPU usage from times gleaned; and a rate control channel which implements the actions to take based on observations from the CPU monitor. The ISG toolkit has been developed for the Infosphere project to automate the programming of Infopipes code for developers. It consists of a human-friendly descriptive language Spi (Sp ecifying I nfopipes), an intermediate descriptive language XIP (XML for Infopipes), a repository for persistence of defined Infopipes structures, and a hybrid C++/XSLT code generation engine. 
For a developer, converting a Spi specifi cation to compilable source code is a three-step process: 1. Create a Spi document to describe the information flow system. 2. Compile the Spi into XIP. 3. The XIP is then processed with the ISG. AXpect weaver), it proceeds through multip le stages to generate the communication code for the application: 1. The XIP is processed; new specifications go to the repository. 2. Previously defined specifications are retrieved and ISG constructs a full 3. Once the XIP+ document is completed, the XIP+ document is processed 4. Code weaving can now be performed (see Section 4). 5. Code is written to directories and files ready for compilation. 
The choice of XML for our intermediate format has proven to be beneficial even though XML X  X  primary role is in the data connections between organizations. Instead of only inter-organizational data interchange, however, we use it for data interchange allows us to retain and add to semantic information that might otherwise be lost from stage-to-stage within the code generator. In particular, it allows us to capture domain information injected by virtue of operating in the Infopipes domain and with the Infopipes suite of domain languages. Such information is not readily preserved by general purpose programming languages. Second, it allows us to have one common wrapper format for multiple languages. Using XML, we can treat our code as data This technique is already widely used in programming languages, but is only recently catching on in code transformation. Examples in general purpose languages include LISP macros, C++ templates, and Java generics. Each of those, in some fashion, allows the programmer to create a type of data-code hybrid. Later, as needed, certain parameters can be changed and custom code can be created for an application. Weaving is a concept from AOP in which new pieces of code are executed in a video application. The weaving integrates code to measure CPU statistics, provide maintaining CPU usage receiver-side below a given level. 
There are three key concepts that enable th e weaver. First, we attach semantic tags to the source code that we generate. Second, we use XSLT describe the weaving process in the aspect, and third, we inse rt weaving directives into the Infopipes description file. 
Any weaver must have some points in the target code that it can identify. These are the  X  X oinpoints. X  In our case, we benefit from our domain specific arena. Because of this, we know that specific activities occur within each Infopipe with known ordering. each inport and each outport, resolving bindings and names, and actually making each of these  X  X ommon tasks. X  
AOP has three types of advice: before, after, and around. A developer chooses a joinpoint using a pointcut, and then designates by keyword whether aspect code should execute before, after, or around (which subsumes instead-of) the selected XML opening tag marks  X  X efore, X  the closing tag marks  X  X fter, X  and taken together the tags make up  X  X round X  semantics. For a concrete example, consider a fragment of template for generating C code Infopipes. This template excerpt generates a startup function for the Infopipe. The startup function name is based on the name of the Infopipe. The XSL commands are XML tags which have the xsl namespace prefix (like the element xsl:value-of which retrieves the string representation of some XML element, attribute, or XSLT ending of the code block that implements the startup functionality. We have reverse-printed the joinpoint XML for clarity, and printed the C code in bold to distinguish it from the XSLT. 
Sometimes a joinpoint does not denote code but language artifacts that are needed for code to be written correctly. In following example, we see that we can denote the header file for an inport. This allows the C developer of new aspect code to insert new function definitions at the appropriate scope. 
Joinpoints remain with the code until the files are written to disk. After the this startup code: 
At this point, obviously, the code looks very much like pure C ready for compilation, and most importantly, we and the AXpect weaver know what the code about 26 joinpoints are necessary for quite a bit of flexibility with respect to actions we can perform on the generated code. These joinpoints have evolved into some broad categories as evidenced in Table 1 , below.  X  X anguage Artifacts X  help a developer structure his code properly.  X  X ata X  joinpoints relate to the structures that hold incoming/outgoing data.  X  X ipe X  joinpoints define actions that occur during the overall running of the pipe. Communication layer joinpoints are needed because it is common for these packages to need to perform some applications may need to build on this communication layer behavior or modify it. Last, we have joinpoints on the inports and outports themselves. 
The second ingredient of the AXpect weaver is an XSLT file that contains aspect statement, written using XPath and utilizing the XSLT pattern matching engine, to find the proper joinpoint and the code to be inserted. This corresponds to the role of the pointcut in an AOP system like AspectJ. The pointcut in AXpect is an XPath predicate for an XSLT match statement in a fashion similar to this: 
We can dissect the elements of the pointcut XPath statement: 
Instead of keywords like AspectJ, the AXpect developer uses placement. The actual joinpoint and its contents are copied over by XSLT X  X  xsl:copy instruction. A simple aspect for AXpect looks like this (the C code is bolded for distinction from the XSLT): It is now easy to see how aspect code, pointcuts and joinpoints, and advice mesh. executed before the rest of the shutdown code. The xsl:apply-templates is boilerplate XSLT that ensures the processor continue s to pattern match to all elements and boilerplate like the xsl:copy elements and to generate them from a higher level description.) 
As a second example, we can examine a case where around is helpful: 
In this case we are structurally bound by the standards of C coding which advocate scope. This means we weave on the joinpoint that defines the source file of the Infopipe. The declaration of the variable occurs before the main code of the Infopipe, and the definition and declaration of the main function occur after. Since main() is not generated by default we add it using an aspect and then call the Infopipe startup code which spawns a thread to handle service our incoming Infopipes connection. 
One of the interesting results of using XSLT and XML for this system is that aspects can introduce new joinpoints in the form of new XML tags. This means that code to measure how long various pieces of Infopipe code take to run the user function which can be used later in calculating CPU usage. 
The timing code is bracketed with XML th at declares it, and the CPU monitoring code can then select it with a pointcut just like any other joinpoint: apply in the XIP specification. This is a very simple process in which we add &lt;apply-aspect&gt; statements to the pipe descriptions: 
Note that we can nest the apply-aspect elements to declare dependencies of one aspect upon another. Since we invoke the XSLT processor multiple times, and neither the XSLT standard nor Xalan-C supports self-invocation, the evaluation of these statements is handled in a C++ program using Xerces-C, which is the platform the ISG is built around. The weaver proceeds recursively through the following steps on each pipe: 
This algorithm implementation only required an additional 79 lines of C++ code be added to the generator application. The bulk of the weaver complexity is contained by the XSLT weaver. We used the AXpect weaver and Infopipes to implement the sample application which we described earlier in the paper. We now discuss the implementation of application. 
The timing aspect hooks on to all join points that designate an executable block of code. This can be done in an efficient fashion by using the pattern matching to select entire sets of joinpoints around which to install timing code around. Complementing this is creating new variables to hold the timing measurements which we do by creating their names at aspect-weaving time. 
On top of this we install the CPU monitoring code. This code installs around the middle-method code. Instead of using start-to-end elapsed time which would only provide a measure of how long it took to execute a joinpoint, we measure end-to-end so that we have a measure of the total time for the application to complete one  X  X ound-trip X  back to that point. We can compare this to the system-reported CPU time to calculate the percentage of CPU used by this process. 
The control channel sends data between the two ends of the Infopipe. We used a socket independent of the normal Infopipe data socket both to avoid the overhead of functionality on top of the OS demultiplexing which would be performed, anyway. robustness of the application as there is no possibility of errant application data being interpreted as control data or of misleading data being injected as control data somehow. 
Finally, there is the SLA aspect. During weaving, it reads an external SLA observe and report. At run time, the SLA reads the CPU usage values and sends them returned value. In our example, the SLA can set a variable to control if and for how long the sender enters usleep() to adjust its rate control. 
We compiled the sample application and ran it with a  X  X trong X  sender, a dual 866MHz Pentium III machine and a  X  X eak, X  resource-constrained receiver, a Pentium II 400MHz. Running without any controls on resource usage, the video sender is able to capture roughly 36% of the receiver X  X  CPU. Using the CPU control, we are able to bring the CPU usage back to a target 20 X 5% range. 
We have observed so far that our aspect files are generally larger than they amount increase in locality of code and reusability (some of these aspects, such as timing and CPU monitoring, have been reused already in another demo). In fact, when we aspect such as the sender-side SLA code can alter four of the generated files and then lines if they are handwritten into the base set of 18 files versus the six AXpect files. (See also http://www.cc.gatech.edu/projects/infosphere/online_demos/WeaveDemo) The AOP and code generation community is actively exploring the new possibilities in combining the two including SourceWeave.NET [8], Meta-AspectJ[9], two-level weaving [10], and Xaspects [11]. 
Before that, The AOP community has worked diligently on weavers for general AspectWerkz, JBossAOP, and AspectC[4,13,14,15]. Generally, development of period of time. Other work has tackled separation of concerns for Java through language extensions, such as the explicit programming approach of ELIDE project [16]. 
DSLs have also often been implemented on top of weavers. Notable in this area is the QuO project, which uses a DSL then generates CORBA objects which are called from the execution path to run and be evaluated at the join point to implement quality the execution pathof the application ther efore imposes invocation overhead [17]. Bossa uses AOP ideas to abstract scheduling points in OS kernels, but again does not do source weaving; each joinpoint triggers an event and advice registers at events in order to run [18]. Because of the use of aspects in conjunction with DSLs, the XAspects project is studying the use of aspects to implement families of DSLs. Still, this project uses AspectJ as the source weaver and therefore focuses only on Java as the target language [11]. The Meta-AspectJ package also targets enhancing the power of code generators and using code generation plus AOP to reduce complexities for implementing security and persistence [9]. Work has been done using XML in the AOP arena; however, this work has concentrated on using XML to denote the abstract SourceWeave.NET to weave aspect code in the bytecode of the .NET the Common Language Runtime (CLR) [8]. We have shown that even adding a relatively simple QoS requirement can entail widespread changes to an application and that those changes can be spread throughout the entire application. To address this, we described the AXpect weaver. The AXpect weaver can use information from a WSLA and integrate new code into source code generated from an Infopipes XML specification. Our target application used the weaver to add new functionality to a C program which realized an image-streaming with responsiveness to CPU usage constraints on the sender end of the image stream. For future work, we are continuing to explore the space of applications for weaving, and we have already demonstrated early a pplication of the weaver to C++ programs with further plans for Java. Also, we are investigating Infopipes support for Web Service applications. The authors are grateful for the input of Charles Consel ( INRIA, University of Bordeaux, France); Ling Liu, Younggyun Koh, Wenchang Yan, and Sanjay Kumar (Georgia Institute of Technology, Atlanta, GA), and Koichi Moriyama (SONY Corp., Japan); Part of this work was done under DARPA funding. 
