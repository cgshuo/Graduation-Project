 The multiplication of data sources and the raise of data volumes due to the success of Internet, the improvement and affordability of storage medium as well as the massive data aggregation by human organizations have led computer scientists to define a wide variety of search data structures that provides efficient query capabilities that meets the ever-increasing need for speed. Numerous fields of computer science as multidimensionnal data management, automata theory and graph theory have contributed to the emergence of new methods to deliver fast access to large data sets. One of the first approach formerly introduced in [K73], [K71] and still inspiring researchers, are the trie (or digital tree) and the binary search tree, each of them providing query time in O ( q ) and O ( q  X  log n ) for a storage size of O ( n ) and O ( n  X  log n ) where the query is a sequence of q bits and the data set consists in n sequences of fixed size. In the fields of multidimensional data management and computational geometry, those two data structures were the starting point for multidimensional range search data structures. Progressively, it emerged that in order to provide fast query time, the size of the data structure must increase exponentially with the tuples dimension, leading to the so-called curse of dimensionality . Despite this, efficient search data structures were proposed for a small dimension d : as kD-trees [B75] ( O ( n 1  X  1 /d ) quadtrees [FB74]. More recently, the good probabilistic properties of skip lists were combined with quadtrees to propose an innovative data structure [EGS08] that guarantees with some probability the correctness of the query result set ; the better the query time the worse the correctness. Since tuples are closed to trees, similar issues have been raised in the fields of hiearchical data management and graph theory. In particular, an efficient method was introduced in [BKS02] to query XML documents with queries defined in the twig formalism that captures a small useful fragment of the XML query language. This method was then extended to query graphs in [GC08] with an optimal enumeration algorithm for the k best answers in [CLZYZQ15]. An other approach [RS14] for searching within a set of graphs consists in storing those graphs in a trie -like data structure to return subgraphs in nearly linear time that are isomorphic to a given graph query. Automata theory has also led to some innovative methods, as the one proposed in [FIJMP12] that uses pushdown-automata to search a rooted tree query pattern within a rooted data tree in a query time linear in the given tree pattern, although the size of the automaton might be exponential in the data tree size if the search examines all the subtrees of the data tree. The work presented in this paper is also based on automata theory, with the difference that the automata used here are word finite states automata.
 trees are formulated in a knowledge representation language defined according to a relational vocabulary  X  and equiped with a set-theoretic semantics. This data structure provides an efficient interrogation mechanism that complies with the set-theoretic semantics and returns the results of a query of size q in a time linear in q , although the size of the data structure might be exponential in n . If an integer parameter k is provided, a trade-off is possible between the query time O ( k 2  X  q ) and the size O ( k 2  X |  X  | X  2 d n/k e ) of the data structure. knowledge representation language, its concrete and abstract syntaxes ; and its set-theoretic semantics leading to a notion of subsumption. The labeled tree ho-momorphism is then defined and shown equivalent to the subsumption ; and an algorithm is given to compute all homomorphisms from a tree to another. The second section introduces the notion of tour language of a tree, shows that for each tree there is an automaton recognizing its tour language and establishes the equivalence between tour language containment and homomor-phism/subsumption. Finally, the third section makes use of the automata theory machinery to build the aforementionned data structure. 2.1 Concrete trees Given a relational vocabulary  X  , the concrete representation of a labeled rooted tree T (in short concrete tree or tree ) defined on  X  is a tuple T = ( N,r,s ) where N is the non-empty set of nodes, r  X  N is the root and s : N  X   X   X  2 N is the successor function between nodes of N . A node n  X  N is a  X  -successor of a node p  X  N iff n  X  s ( p, X  ). The successor function s is defined such that the node r is the root and s does not contain any cycle. | T | denotes the size in nodes of the tree T and identity between trees is defined by means of tree isomorphism. 2.2 Abstract syntax and semantics Abstract syntax defined on the relational vocabulary  X  iff either a is the empty string, a =  X X  X  or a = XY where  X   X   X  ,  X  is a special symbol not in  X  and X,Y are abstract trees defined on  X  .
 is either the empty string if N T is a singleton ; or else an abstract tree in the form  X  T =  X  X  u  X   X  V such that (1) u is one  X  -successor subtree of r T ; and (2) V is the concrete tree resulting from the removal of u among the  X  -successor subtrees of r T in T .
 a is the concrete tree  X  ( a ) = ( N a ,r a ,s a ) such that :  X  if a =  X x  X  Y where x and Y are (possibly empty) abstract trees then  X  ( a )  X  else if a is the empty string then N a = { r a } is a singleton and s a is undefined where D is a non-empty set, called the domain and i is an interpretation function that maps every (relational) symbol from  X  to a subset of D  X  D ; and every abstract tree a defined according to  X  to a subset of D such that (1) if a is empty i ( x ) } where Y and x are abstract trees defined on  X  .
 tive fragment of the description logic ALC [BHS08] (i.e. the fragment limited to existential restriction and intersection operators). The equivalence is proven by considering  X  as role names and by defining a bijective function f that re-cursively translates an abstract tree a =  X x  X  Y into its equivalent ALC concept definition f ( a ) = (  X   X f ( x )) u f ( Y ).
 written b w a ( a v b ), iff i ( b )  X  i ( a ) for all interpretation structures I =  X  D,i  X  of  X  . 2.3 Rooted labeled tree homomorphism A rooted labeled tree homomorphism h (in short homomorphism or hom in the proofs) from a tree A into a tree B is a function h : N A  X  N B from the nodes of A into the nodes of B that maps the roots h ( r A ) = r B of the trees and preserves the successor function such that for all  X   X   X  and n,p  X  N A if n is a  X  -successor of p in A then h ( n ) is a  X  -successor of h ( p ) in B . h ( A ) denotes the subtree in B that is the image of A by h .
 tree with m nodes, there is an algorithm that computes all homomorphisms from the tree into the graph in O ( mn ) time. Given two trees A and B , the set H = { h | A h  X  B } of all homomorphisms from A to B can be computed in two steps.
 that returns the set { x  X  X such that there is an homomorphism A h  X  B and h ( a ) = x } : every step of the loop in homs ( a,A,X,B ) is linear in the size of B up to a factor linear in the size of each recursively traversed subtree in A . Thus, when summing up all the steps, the resulting time complexity for homs ( a,A,X,B ) is O ( | A || B | ).
 keeping the D x,a i sets outside the function homs . Doing so, one can build each homomorphism h by browsing recursively the structure D x,a i in order to select an image h ( a 0 i ) for each node a 0 i of A fitting the one selected for its parent a 0 ; following a recursive traversal of A from its root to its leaves. More precisely, h  X  H is exhibited by chosing h ( a )  X  homs ( a,A,X,B ), then recursively : if h ( a 0 ) = x and a 0 i is a  X  -successor of a 0 then choose h ( a 0 i )  X  D x,a 0 is a  X  -successor of x .
 Theorem 1. Let a and b be two abstract trees, a subsumes b iff there exists an homomorphism  X  ( a ) h  X   X  ( b ) between their respective concrete representations  X  ( a ) and  X  ( b ) .
 Proof. The proof can be done by recurrence on the trees.  X  The lowest level of the recurrence is the case where a is empty. There is  X  When a and b are non empty strings of the form a =  X a 0  X  A and b = As shown in the following, each tree can be represented by an eulerian tour (equivalent to an abstract representation) and by its tour language which is the set of tree tours allowing inner repetitions. Finite state word automata are used to recognize the tour language of a tree and to materialize the equivalence between tour language containment and tree homomorphism/subsumption. 3.1 Definitions ( Q, X , X ,q 0 ,F ) where Q is the set of states,  X  the transition function  X  : Q  X   X   X  2
Q (which may not be total), q 0 the initial state and F the final states set. Let  X   X  be the function such that given a word w =  X w 0 with  X   X   X   X   X  ( x,w ) =  X  ( x, X  ) accepts a word w if  X   X  ( x,w )  X  F 6 =  X  and the language recognized by A is the set L A of all words accepted by A . The notation of  X   X  is extended to allow  X   X  to take a set X  X  Q as parameter such that  X   X  ( X,w ) = S {  X   X  ( x 0 ,w ) | x 0  X  X } . where Q is the set of states,  X  the transition function  X  : Q  X   X   X  Q (which may not be total), q 0 the initial state and F the final states set. Let  X   X  be the function such that given a word w =  X w 0 with  X   X   X   X   X  ( x,w ) =  X  ( x, X  ) when w 0 = or otherwise  X   X  ( x,w ) =  X   X  (  X  ( x, X  ) ,w 0 ). An IDFA A accepts a word w if  X   X  ( x,w )  X  F and the language recognized by A is the set L A of all words accepted by A .
 a finite string and (1) either t is empty, (2) either t =  X t 0  X  t 00 such that t 00 is a tour of T and t 0 is a tour of a subtree of T starting at one of the  X  -successors of the root r of T . The tour language L T of a tree T is the set of all tours of T . to T . An abstract representation  X  T of a tree T is an eulerian tour. 3.2 INFA infa ( A ) induced by a tree A Given a tree T = ( N,r,s ), let infa ( T ) = ( Q, X  0 , X ,q 0 ,F ) be the INFA defined on the alphabet  X  0 =  X   X  X   X  } such that Q = N , q 0 = r , F = { r } and  X  ( x, X  ) = X 0 and  X  ( x 0 ,  X  ) = { x } for all x 0  X  X 0 iff s ( x, X  ) = X 0 .
 Theorem 2. Given a tree T = ( N,r,s ) , the INFA A T = infa ( T ) recognizes the tour language L T of T .
 Proof. t  X  L T iff t  X  L A T by recurrence on t . It is true when t is empty, since the empty string belongs to both languages. Considering the recurrence hypothesis true for the automata A T 0 and A T 00 of the components t 0 and t 00 of a tour t =  X t 0  X  t 00 and their corresponding trees T 0 and T 00 : we build the tree T by joining the two trees T 0 and T 00 such that the root r of T is the one of T 00 and T 0 becomes the  X  -successor of r ; and we obtain the language L T . In the same time, we build an automaton A T by joining the both A T 0 and A T 00 automata in which the initial state q 0 is the one from A T 0 and there is a  X  -transition from q 0 preserves the languages equivalence : t  X  L T iff t  X  L A T . 3.3 Tour language and homomorphisms Lemma 1. Given a tree T , L T is equal to the set { t  X  A  X  |  X  ( t ) h  X  T } of all abstract trees t  X  A  X  such that there is an homomorphism from  X  ( t ) to T . Proof. The proof is by recurrence on t and  X  ( t ).  X  If t is empty then  X  ( t ) = (), and it is obvious since h matches the single node  X  Forward direction : if  X  ( t ) h  X  T then t is a tour of T The tree  X  ( t ) can be  X  Backward direction : if t  X  L T then  X  ( t ) h  X  T . Let t =  X x  X  y and let T be the Theorem 3. Given a tree T , L T is the set of all tours of all trees more generic than T .
 Proof. Let T 0 be any tree such that T T 0 and t 0 any tour of T 0 . Since by lemma 1 (backward way), there is an hom  X  ( t 0 ) f  X  T 0 . And since T T 0 , there is an hom T 0 g  X  T . Thus we can build the hom h = f  X  g from  X  ( t 0 ) into T . And again by lemma 1 (forward way), t 0 is a tour of T . Thus all tour t 0 of any tree T 0 more generic than T is a tour of T .
 of a tree T 0 more generic than T . Indeed, this tree T 0 is  X  ( t ). 3.4 Tour language containment and homomorphism equivalence Theorem 4. Given two trees T 1 and T 2 , T 1 h  X  T 2 iff L T 1  X  L T 2 . Proof. We prove the two direction separately :  X  Forward direction : if T 1 h  X  T 2 then L T 1  X  L T 2 . Since L T 1 is the tour language  X  Backward direction : if L T 1  X  L T 2 then T 1 h  X  T 2 . L T 1 is the set of every 3.5 Eulerian tour membership equivalent to language containment Theorem 5. Given two trees T 1 and T 2 and e an eurlerian tour of T 1 , e  X  L T 2 Proof. We prove the two direction separately :  X  Forward direction : if e  X  L T 2 then L T 1  X  L T 2 . Since e  X  L T 1 and e is eulerian  X  Backward direction : if L T 1  X  L T 2 then e  X  L T 2 . Since L T 1  X  L T 2 with 3.6 Forest and tour language union A knowledge base B is a forest (i.e. a set of trees). Given a tree T and a forest B , h is an homomorphism T h  X  B from T into B iff there exists a tree U  X  B such that h is an homomorphism T h  X  U from T to U .
 of all the trees T  X  B in the forest. Given a forest B , the INFA A B with initial state q 0 recognizing the tour language L B of the forest B contains the INFAs A
T i = infa ( T i ) with initial states q i 0 of the trees T i  X  B such that there is in A B a  X  -transition from q 0 to a state iff q i 0 transitions to this state on the  X  symbol L
B of the forest B and (2) there exists an homomorphism T Since the abstract representation of a tree A (or its eulerian tour) is accepted by the INFA infa ( B ) iff there is an homomorphism from A to B , the deter-minization of this INFA into an IDFA provides the ability to test the existence of an homomorphism in time linear in | A | . If all homomorphisms are requested, this time is increased by a logarithmic factor in | B | for each homomorphism. The search data structure is the IDFA resulting from the determinization by the powerset construction of infa ( B ). 4.1 Powerset construction The INFA infa ( B ) is determinized into an IDFA idfa ( B ) with the so-called pow-erset construction algorithm proposed in [RS59]. Let infa ( B ) = ( Q N , X , X  N ,q 0 ,F N ) be the INFA for the forest B , the IDFA idfa ( B ) = ( Q D , X , X  D ,X 0 ,F D ) equiva-lent to infa ( B ) is such that :  X  X 0 = { q 0 } and X 0  X  Q D  X  if  X   X   X  and X  X  Q D then  X  D ( X, X  ) = { y | x  X  X andy  X   X  N ( x, X  ) } and  X  for all X  X  Q D , X is an accepting state ( X  X  F D ) in idfa ( B ) iff at least one 4.2 Homomorphism test Let A = ( N,r,s ) be a tree and a =  X  A an abstract representation (or eulerian tour) of A , let A B be the IDFA idfa ( B ) resulting from the determinisation of the forest B : there exists an homomorphism from A into B iff a is accepted by A size of the word, the time complexity to check the existence of an homomorphism from A to B is O ( | A | ). 4.3 Homomorphisms reconstruction Let f A be the index function of an abstract representation a =  X  A of a tree A that maps an index 0  X  i  X | a | X  1 of a symbol a [ i ] in a with its corresponding node in A . More precisely, f A is defined such that :  X  if A is the single-node tree, since a is empty then f A is undefined for all i  X  0  X  else since a =  X  X  u  X   X  V where (1) u is the subtree whose root r u is a  X  -Since f A is not injective, one node x from A may have several antecedents indeces and f  X  1 A ( x ) is a set.
 symbol in a with the state  X   X  ( q 0 ,a [0 ,i ]) of the run reached by the word a [0 ,i ]. is the state of the run that recognizes in a the symbol at the farthest position i (from the start of the string) and that corresponds to the node x = f A ( i x ). n ( s ) from B in bijection with the set S of states reached in infa ( B ) by w . Let  X  s be the function partitionning the nodes of n ( s ) according to their parents such that for a state s in idfa ( B ) and a node x in B ,  X  s ( x ) = n ( s )  X  S x where S x is the set of successors of x .
 successor node x of p in B . The set of homomorphisms H from A into B can be reconstructed with the following procedure.
 last symbol in a leading to the accept state in A B . Every node x 0 of the domain dom (  X  s ) of  X  s where s =  X  A ( x ) is an image of x according to an homomorphism from A to B . Thus we add in H as many partial homomorphisms h as there exist nodes x 0  X  dom (  X  s ) such that h ( x ) = x 0 . These partial homomorphisms will be completed by the following loop until they become full homomorphisms from A to B .
 H 0 containing further completed copies of the homomorphisms in H ; and at the end of the step : H 0 replaces H .
 every homomorphism h  X  X  and every node x  X  A such that h ( x ) = x 0 :  X  if x is a successor of p in A then we add in H 0 a copy h 0 of h such that h 0 ( p )  X  if y is a  X  -successor of x in A then for all node y 0  X   X  s ( x 0 ) where s =  X  A ( y ) method (as BST) to search the unique parent  X  ( x ) or the children  X  ( x ) of a given node x in B , then the search in the maps is performed in O (log | B | ). Since, the idfa ( B ) accepts a =  X  A in time O ( | A | ) and at most O ( | A | ) lookups are done in  X  and  X  maps in order to build each homomorphism of H ; then supposing that there are K homomorphisms to be returned, the reconstruction time is O ( K. | A | . log | B | ). 4.4 Trade off between space and time As shown in [E10], given an integer k an -transition NFA of size n may be partially determinized up to a ratio d n/k e of its nodes into a data-structure that provides a trade-off between O ( k 2  X |  X  | X  2 d n/k e ) space to determinize the INFA and O ( w  X  k 2 ) time to read a word of size w . This data-structure is an array storing k equal sized arbitrary partitions of the INFA such that inside each partition the simulation is deterministic. The remaining non-determinism occurs when multiple partitions have to be combined to compute the next step during an INFA simulation.
 of the INFA infa ( B ) of the forest B . Each subsets Y i  X  X i , within each subset X , are indexed by integers from 0 to 2 d n/k e .
 [0 , 2 d n/k e ]. An argument ( i,j, X ,x i ) of D is composed of two values 0  X  i  X  k  X  1 and 0  X  j  X  k  X  1 identifying two subsets X i and X j of the partition, a symbol  X   X   X  and the integer 0  X  x i  X  2 d n/k e  X  1 indexing the subset Y i of X i . The that a state s belongs to Y j iff s belongs to X j and there is a state in Y i that transitions to s on input symbol  X  .
 X 0 is the partition subset containing the initial state of infa ( B ) and all bits of the sequence b are set to zero excepted the bit whose index corresponds to this initial state. Let p = 0 be the position of the symbol a [ p ] currently read in a . the set X j that can be reached by a transition on a [ p ] from a state in the set Y i identified by the sequence b as a subset of the set X i . Let Z be the set of all integer values D ( i,j,a [ p ] ,b ) for every pair i,j  X  [0 ,k  X  1] and let z be the result of the OR bitwise binary operation of all the indeces in Z . Now, z is the bit sequence indexing the unique subset Y j of the set of states X j reachable in infa ( B ) by the substring a [0 ,p ] of a . If p &lt; | a | X  1 then increment p , set the sequence b equal to z and start again this procedure.
 and the simulation is finished. If Y j contains at least one accepting states from infa ( B ) then a is accepted, otherwise it is rejected.
 Thus each step takes time O ( k 2 ), and since there are as many steps as | a | symbols in a then the total simulation time is O ( | a | X  k 2 ), which is equal to O ( | A | X  k 2 ) where A is the concrete representation of a . The knowledge representation language presented in this paper provides a con-crete and abstract syntax for the definition of labeled rooted trees such that if A (resp a ) is a concrete (abstract) tree then  X  A (  X  ( a )) is an abstract (its concrete) representation. The abstract syntax is provided with a set-theoretic semantics equivalent to the description logic intersection and existential restriction opera-tors ; and from this semantics arises a notion of subsumption. On the other hand, a notion of homomorphism is defined between concrete trees and an algorithm is proposed to compute all the homomorphisms from a source tree of size s to a target tree of size t in time O ( s  X  t ). It is then shown that given two concrete trees A and B ,  X  A subsumes  X  B iff there exists an homomorphism from A to B ; making possible the use of the homomorphism algorithm to check the existence of a subsumption.
 n , the result set of the query is defined as the subset of the stored trees subsumed by the query tree. The subsumption and homomorphism equivalence is exploited to propose a default query mechanism that computes the result set in O ( q  X  n ) time. Then the equivalence has been established between the tour language L T of a tree T and the set of all trees from which there is an homomorphism into T . Since a tour language is recognized by an non-deterministic automaton (INFA), it makes possible the use of the automata theory machinery to determinize the automaton in order to decrease the dependence of the query time to the forest size. When no trade-off is needed between the structure size and the query time, the proposed data structure is a deterministic automaton whose size is at most O (2 n ). For computing the result set, the automaton reads the abstract representation a of the query tree in O ( q ) time and if it is accepted, the set of all homomorphisms from the query tree to the forest can be reconstructed from the run in the automaton. When a trade-off depending on a parameter k is needed between the search time and the size of the structure, one can construct a table of size O ( k 2  X |  X  | X  2 d n/k e ) that partitions the INFA into k deterministic pieces ; and that reads the string a in O ( k 2  X  q ) time.

