 Recently, the problem of efficiently supporting advanced query op-erators, such as nearest neighbor or range queries, over multidimen-sional data in widely distributed environments has attracted much attention. In unstructured peer-to-peer (P2P) networks, peers store data in an autonomous manner, thus multidimensional routing in-dices (MRI) are required, in order to route user queries efficiently to only those peers that may contribute to the query result set. Fo-cusing on a hybrid unstructured P2P network, in this paper, we analyze the parameters for building MRI of high selectivity. In the case where similar data are located at different parts of the network, MRI exhibit extremely poor performance, which renders them in-effective. We present algorithms that boost the query routing per-formance by detecting similar peers and reassigning these peers to other parts of the hybrid network in a distributed and scalable way. The resulting MRI are able to eagerly discard routing paths during query processing. We demonstrate the advantages of our approach experimentally and show that our framework enhances a state-of-the-art approach for similarity search in terms of reduced network traffic and number of contacted peers.
 H.2.4 [ Database Management ]: Systems X  Query processing Algorithms, Experimentation, Performance Multidimensional routing indices, P2P query processing
Routing indices [5] have been proposed to improve the perfor-mance of search in unstructured peer-to-peer (P2P) networks. The purpose of routing indices is to direct queries to peers in an in-tentional manner, by discarding network paths. Traditional routing indices in P2P systems are mainly designed for document retrieval applications, thus maintaining aggregated one-dimensional values, representing the number of documents that can be obtained in a cer-tain direction in the network. However, many applications handle multidimensional data and require more advanced query types. Re-cently, there exists a trend towards supporting advanced query pro-cessing in P2P networks as well [7, 19, 31], using multidimensional summary information for directing queries in the network in a de-liberate way. Similar to centralized multidimensional indices, data stored on peers is described by representative (multidimensional) data descriptors, realized as minimum bounding regions (MBRs) that enclose all data points on a peer.

The main disadvantage of using multidimensional indexing tech-niques in unstructured P2P networks, is that the query processing performance quickly deteriorates when the number of participating peers increases. Therefore, in this paper, we assume a super-peer overlay that provides the necessary stability in order to provide effi-cient query processing. Nowadays, the advantages of using a super-peer architecture [32] have been recognized by most of the existing P2P file-sharing networks (eMule, KaZaA) that rely on a super-peer architecture. Beyond file-sharing, there are several important appli-cations, such as distributed image search [12] and query processing over distributed collaborative scientific databases [22, 24], which can benefit from a super-peer architecture. For example, consider scientists (peers) that collect massive datasets of astronomical ob-servations [24] or biological data [22] and upload their descriptions to dedicated servers (super-peers), in order to share it with other scientists. Unlike plain file-sharing platforms, these distributed ap-plications handle multidimensional data and require more advanced query types, such as nearest neighbor or range queries, in order to provide the desired functionality.

Multidimensional routing indices (MRI) [7, 10, 19] are com-posed of different local centralized multidimensional indices, each stored at a super-peer. The data objects stored by the MRI at a super-peer are MBRs that summarize the data available through each neighboring super-peer. The simplest form of a MRI at a super-peer is a list of one or more MBRs for each neighboring super-peer. In the example of Figure 1, the MRI of SP A is de-picted, which consists of three entries, one for each neighbor { SP B , SP C , SP D }. The MRI are constructed in a distributed man-ner. SP D is informed about SP E  X  X  content by receiving a set of MBRs (i.e., m 5 ), representing the data that can be retrieved if a query is forwarded in that direction. This information is then ag-gregated ( m 4 , 5 ) with its own MBRs (i.e., m 4 ) and forwarded to SP A . Thus, each super-peer (in this case SP A ) builds and main-tains its own MRI and utilizes it in order to efficiently route a query to its neighbors.

There exists a distinct difference between a MRI and a distributed multidimensional index, such as [11]. In the latter case, the nodes of a single index are themselves distributed on different servers, whereas MRI consist of multiple centralized indices at super-peers that describe the data available through each neighboring super-peer. Also notice the difference between approaches that rely on a structured [28] (i.e., DHT-based) or tree-based [21] P2P network, where each peer is (a priori) assigned and becomes responsible for a part of the data space. These approaches follow a space partitioning approach and rely on deliberate data placement on peers, whereas MRI adopt a data partitioning approach where each peer stores its data autonomously. Even though multidimensional indexing tech-niques based on data partitioning have been extensively studied in centralized settings [13], the advantages of using data partitioning techniques in P2P systems have been only partially explored.
Assuming that each super-peer stores its own MRI, a super-peer is able to deliberately route the query to some of the neighboring super-peers during query processing. For example, a range query is forwarded to all neighboring super-peers for which there is an MBR in the MRI that overlaps with the query. Thus, the performance of query processing depends on the selectivity of routing indices, which is the ability to discard neighboring super-peers (or routing paths) during query routing. An important parameter that affects the selectivity of the MRI is the similarity of the data maintained by neighboring super-peers. The aggregation of the MBRs during the MRI construction causes the enlargement of the MBRs. In turn, this leads to overlapping MBRs and affects the selectivity of the MRI, similar to multidimensional access methods [13] in the centralized case. In our running example in Figure 1, the aggregation of m and m 5 leads to an enlarged MBR, namely m 4 , 5 . Notice that SP stores locally only m 4 , 5 and the enclosed MBRs are depicted only for sake of clarity. In addition, since each super-peer summarizes the data stored by its peers by a set of MBRs, an important factor is the underlying distribution of data to super-peers. Although data on peers may be clustered into a few thematic areas that reflect the user X  X  interests, when peers join the network by connecting to a randomly chosen super-peer, the super-peers end-up indexing data spread all over the data space. Again in this case the selectivity of the MRI is poor.

Focusing on a super-peer network, in this paper, we propose an efficient approach for constructing MRI of high selectivity that boosts the query processing performance, since fewer super-peers need to be contacted. We present algorithms for the identification of peers with similar content and reassign them to the same super-peer, by establishing new additional overlay connections. Our ap-proach is self-organizing, in that there is no prior assignment of space partitions or data to each super-peer, but the data distribution is dynamically captured. The peer MBRs reassignment takes into account the super-peer topology, so that neighboring super-peers index peers with similar content.

The individual contributions of this paper are: In addition, we provide the definitions in Section 2, we review re-lated work in Section 8, and we conclude in Section 9.
In this paper, we assume a super-peer network [7, 32] that con-sists of N sp super-peers, each connected to a limited set of at most DEG sp other super-peers. Such networks include many simple peers and few enhanced super-peers, in terms of processing power, storage capacity or network connectivity. Each super-peer SP responsible for DEG p simple peers, which connect to SP i rectly. The initial assignment of peers to super-peers is random with respect to peers X  contents [7, 32]. Each peer P i , i  X  [1 tains its own dataset O i that consists of n i d -dimensional points. Hence, the complete dataset O is the union of all N p datasets O ( O =  X  O i , i  X  [1 ,N p ] ), which is the case of horizontal data dis-tribution, and moreover the size of the complete set of points is n
We are interested in supporting exact query processing on top of the super-peer network, which means that we would like to process a query in a distributed manner, but the answer set should be the same as if the query had been executed on the dataset O in a central-ized setting. In the rest of the paper, we describe how range queries are processed, merely as a showcase example, although other query types can be supported as well.

D EFINITION 1. Range query R ( q, r ) . Given a query object q and a radius r , a point p  X  O belongs to the result set of the range query if dist ( q, p )  X  r ,where dist () denotes the distance function.
Multidimensional routing indices are built at super-peer level, in order to route user queries more efficiently to only few super-peers that can contribute to the query result set. We now provide a more concrete description of a multidimensional routing index at super-peer SP i . The routing index MRI can be considered as a set of up to DEG sp entries MRI = { S 1 ,..., S DEG sp } , one for each neighboring super-peer. Each entry S j consists of k j MBRs and is associated with a super-peer SP j that is a neighbor of SP data point stored by a peer that is accessible through super-peer SP j is enclosed by an MBR that belongs to the S j entry. Each super-peer SP i can use any centralized technique to store and query efficiently these sets of MBRs, such as an R-Tree [16].
In the following, we quantify the similarity between MBRs by defining appropriate metrics, analogously to construction methods of multidimensional access methods. We refer to dead space as the space that is covered by the aggregated MBR, but not by the MBRs that are enclosed by it.

The similarity of a set of MBRs can be expressed by the volume of the MBR that encloses all MBRs that belong to the set.
D EFINITION 2. Enclosed Volume. Given a set of n MBRs { m 1 ,..., m n }, the enclosed volume the MBR m that encloses m 1 ,..., m n : When  X  V is large, the enclosed MBRs are dissimilar and the prob-ability of enclosed dead space is high. Small values of  X  that the enclosed MBRs are probably overlapping or lying nearby in the data space.

The most important factor that determines the quality of an indi-vidual MBR is the volume of dead space that it encloses. In order to quantify the dead space, we define a quality measure named com-pactness .

D EFINITION 3. Compactness. Given an MBR m i which en-closes a set of k MBRs m j , 1  X  j  X  k , the compactness of m defined as: A small value of compactness (much smaller than 1 ) means that there is a large volume of dead space inside m i .

The overlap of two MBRs also conveys some notion of similar-ity, therefore we define the relative overlap of two MBRs.
D EFINITION 4. Relative Overlap. Given m i and m j , their over-lap from the perspective of m i is defined as relative overlap: By definition relative overlap is not symmetric RO ( m i , m RO ( m j , m i ), when Volume ( m i ) = Volume ( m j ), and its values vary between 0 and 1 .When RO is high, close to 1 , with respect to the volume of m i ,then m i is almost covered by m j . In the case that RO is low, the volume of the intersection is much smaller than the volume of m i , even though the overlap may be significant.
In this section, we first describe the construction of MRI and then we describe how query processing is performed. Finally, we analyze the factors that affect the selectivity of MRI.
Prior to MRI construction, local indexing of peer MBRs at the responsible super-peer is performed. Each super-peer aggregates and maintains a set of MBRs that summarize the available data stored on its peers. Assume that each peer X  X  data is described by a list of k i MBRs, which enclose all data objects that exist on the peer. Each super-peer gathers the MBRs of its DEG p associated peers and stores them locally using any available centralized mul-tidimensional indexing data structure, such as an R-Tree. In addi-tion, each super-peer creates a list of aggregated MBRs 1 the collected MBRs of its peers. Then, given a peer P j connected to a super-peer SP i ,everyMBRof P j is enclosed by at least one MBR of the aggregated MBRs of SP i . In the case of an R-Tree, the aggregated MBRs could be the root MBRs.

The MRI are constructed in a distributed manner, by having each super-peer receive, aggregate and propagate the MBRs of its neigh-bors. Assuming an acyclic network topology, each super-peer in-forms its neighbors about the data that it indexes, by broadcast-ing its aggregated MBRs. A super-peer SP i that receives a set of MBRs by a neighbor SP N performs two operations. First, SP dates the set S N with SP N  X  X  MBRs, in order to accurately describe the data that can be obtained, if a query is forwarded to SP for each neighbor SP j ( j = N ), SP i aggregates its local MBRs with all sets of MBRs present in its routing index (except for the MBRs in entry S j ), and sends the aggregated MBRs to SP j this way, any neighbor super-peer SP j has an accurate view of the data that can be obtained through SP i . Following this construction protocol, all super-peers have eventually built their routing indices and have sufficient information in the form of MBRs that describe what data can be retrieved by routing the query to each of their neighbors. Figure 1 serves as a showcase of MRI construction, from the aspect of super-peer SP A .

In order to handle cycles, one simple solution is to assume a spanning tree over the super-peer network. Then, MBRs are prop-agated and aggregated using only the super-peer connections in the spanning tree. An alternative solution is that each super-peer propagates the MBRs that it has received from its neighbors, with-out aggregating them, so duplicate elimination can be performed. Then, each super-peer that receives some MBRs from a neigh-boring super-peer, can exclude already received MBRs, i.e., from super-peers that are accessible through a different neighbor.
Consider a range query R ( q, r ) initiated at a querying super-peer . At query time, any super-peer SP i is able to decide which of the neighboring super-peers may contribute to the query result set based on the MBRs in its MRI. The query is forwarded to all neigh-bors SP j , for which at least one routing entry S j overlaps with the query, while all other neighbors are pruned. This constitutes the query routing mechanism.

Furthermore, by storing its peers X  MBRs, SP i is able to deter-mine during query processing the peers that may contribute to the result set of the query. Thus, SP i contacts only peers responsible for MBRs that overlap with the query and this process is called lo-cal query processing at SP i . Then, the queried peers process the query based on their local data, and return their results to SP
The query is processed by all super-peers that receive the query in a similar way. Each recipient super-peer first performs query routing, then performs local query processing and waits to gather the results of its neighbors. Finally, the combined result set is sent back through the reverse query path to the querying super-peer.
During the construction of the routing indices, MBRs are ag-gregated at intermediate super-peers. As it is well-known from centralized multidimensional access methods, the aggregation of MBRs causes the enlargement of the MBRs and worsens the per-
Any technique proposed in centralized settings for creating MBRs that enclose multidimensional data may be used, such as packing algorithms [23, 29] or spatial clustering algorithms [17]. m m m formance of the indices during query processing. Similarly in the case of MRI, the aggregation of the MBRs affects their selectivity, since their enlargement may lead to forwarding the query to more super-peers than necessary. Obviously, the enclosed dead space in an aggregated MBR leads to its enlargement. The aggregation of the MBRs may lead to MRI of low selectivity due to high overlap and dead space.

E XAMPLE 1. Figure 2 depicts two alternative aggregations of four MBRs in two groups. The aggregation in Figure 2(a) is ob-viously inappropriate, as the aggregated MBRs have much dead space and overlap, whereas the aggregated MBRs in Figure 2(b) are non-overlapping with much less dead space. Consider now the case that these MBRs represent peer data, and as such they are dis-tributed over a super-peer network. Let us assume that m 1 belong to super-peer SP A , while m 2 and m 4 belong to super-peer SP B . Then the aggregated MBRs of these super-peers are similar to Figure 2(a), leading to a high probability that a query must be sent to both super-peers. Therefore, a third super-peer that indexes the aggregated MBRs of SP A and SP B forwards most queries to both directions.

High volumes of dead space of the aggregated MBRs increase the probability that a query is forwarded to a direction that retrieves no results, while high overlap results in more traversed paths. The combination of both is even worse, since the query is forwarded to multiple directions with low probability of finding any result.
The problems of MBR aggregation are also reflected in the se-lectivity of MRI, due to: (1) the initial peer to super-peer assign-ment, and (2) the MBR propagation and aggregation required by MRI construction. First, even if the peers X  MBRs cover a small part of the data space, when peers join the network and connect to a super-peer that is chosen at random, super-peers end up indexing MBRs spread all over the data space. In this case, the MBRs de-scribing the super-peer X  X  data cover a large part of the data space. This causes the degradation of query processing performance, since a query may  X  in worst case  X  reach all super-peers, even though some of them may not return any result. Secondly, during MBR propagation, if the MBRs of a super-peer X  X  neighbors are not simi-lar to its own MBRs, the aggregated MBRs will span over the entire data space.

To address these problems, we describe two techniques that are applied prior to MRI construction , aiming to improve the selectiv-ity of MRI. In this way, the initial random peer to super-peer assignment changes in an intentional manner. By establishing new additional overlay connections, super-peers are assigned with peers with similar con-tent in a self-organizing way, which is beneficial for the quality of the subsequently constructed MRI.
In order to identify similar peers across the entire network, we use a hierarchical overlay that aggregates in a distributed way the MBRs of all peers into N R MBRs. These MBRs describe the data available in the entire network. In the next step, the N R dynamically decomposed to N sp groups 2 , essentially one group for each super-peer. After N sp groups are created, the peers whose MBRs belong to the same group are assigned to a super-peer. We emphasize that the hierarchical overlay is only used to assign simi-lar peers to super-peers. Thereafter, MRI are constructed at super-peer level (i.e., only one level is used), as described in Section 3.1, to ensure fault-tolerance and load-balancing during query process-ing.
In order to acquire an overview of the data distribution over the entire network, a super-peer hierarchy is required. Although any hierarchical overlay can be applied, we employ the DESENT hi-erarchy [6] to ensure scalability. The hierarchy is formed in an unsupervised, bottom-up manner. The bottom level consists of the individual peers, while the next level consists of all super-peers. In
In the following instead of referring to the set of the MBRs that belong to a group, we refer to the group. Figure 3(a), the first level of the hierarchy consists of 8 peers, while the next level of 4 super-peers.
 At the same time, a hierarchy of MBRs is created, as depicted in Figure 3(c). Initially, each super-peer aggregates the MBRs of its peers by using at most N R MBRs. For the sake of simplicity, in our example we set N R =2 and Figure 3(b) shows the corresponding data space. The aggregated MBRs of SP A at level-1 are repre-sented by m 7 and m 8 . As the super-peer hierarchy is created, each super-peer assembles the MBRs of its children and creates a new aggregated set of MBRs that correspond to all the contents of the tree rooted at that super-peer. For example, SP A maintains the ag-gregated MBRs m 3 and m 4 at level-2. Eventually, at the top-level super-peer, a set of N R MBRs that span the contents of the entire network is created. In the example, SP A becomes the super-peer of the last level, collects SP D  X  X  MBRs and aggregates them with its own, and produces MBRs m 1 and m 2 that describe all data. No-tice that the information about which MBRs of the previous level form an MBR m i is maintained only at the super-peer responsible for m i , and it is not necessary to be disseminated to the rest of the network.

The aggregation process results in a hierarchy of MBRs, where the top-level consists of N R MBRs enclosing all the available data. Notice that the MBR hierarchy is distributed over different super-peers and each level of the hierarchy describes the data in the entire network at a different level of detail .
We propose an algorithm that dynamically decomposes the MBR hierarchy to form N sp groups of similar MBRs. Each group con-tains one or more MBRs of potentially different level of detail. The overall objective is to assign similar MBRs to the same group, while at the same time make the different groups as dissimilar as possible. This is accomplished by dynamically identifying the level of detail of MBRs that results in groups with high intra-group and low inter-group similarity. Intuitively, this can be thought of as a cut in the MBR hierarchy, depicted in Figure 3(c) by the grey-colored MBRs. In this example, an appropriate group assignment is: { m 3 }, { m 9 , m 12 }, { m 10 , m 11 }and{ m 6 }.
The dynamic decomposition of the N R MBRs to N sp groups is performed by the top level super-peer in the hierarchy. Notice that the lack of global knowledge of lower level MBRs makes the task of MBR assignment particularly challenging. Moreover, each time an MBR of lower level of detail is required, communication is necessary between the top level super-peer and the responsible super-peer.

Initially, the N R top-level MBRs are given as input to our algo-rithm that dynamically explores the hierarchy by expanding some MBRs, until the appropriate level of detail is obtained. By expan-sion, we mean that an MBR m r is replaced by the MBRs that are enclosed by m r in the previous level. For example, if m 1 panded in (Figure 3(c)), then it is replaced by m 3 and m exist two reasons that require the expansion of an MBR. First, a group may be empty and all MBRs have already been assigned to other groups. Then, an MBR must be expanded, in order to ensure that all groups have at least one MBR assigned. Second, and more important, our algorithm aims to determine an appropriate cut in the MBR hierarchy, which creates high quality groups. Consider for example Figure 3(b). Let us assume that m 1 and m 2 have been expanded, so that m 3 , m 4 , m 5 and m 6 have been assigned to the 4 groups. Even though there exists no empty group, the quality of the groups is not sufficient. For example, by expanding m m 5 and replacing them with more detailed MBRs, groups of higher quality can be created, as demonstrated earlier. Our algorithm uses Algorithm 1 Dynamic MBR decomposition. 5: while ( list =  X  ) do 9: else 12: end if 14: ( m r ,j )  X  getMaxV olMBR () 16: list.add ( expand ( m r )) 17: end if 22: list.add ( expand ( m r )) 23: end if 24: end for 25: end if 26: end while a heuristic quality test that ensures that when it terminates, there exist N sp groups of sufficient quality, each of them containing at least one MBR, without exploring the whole hierarchy.
 The pseudocode of our algorithm is presented in Algorithm 1. A list is used to keep the MBRs that have not been assigned to any group yet. Initially the list maintains only the N R top-level MBRs (line 4). In each iteration, if there exists an empty group, we assign to it the MBR that is unassigned and most dissimilar to all already assigned MBRs (lines 6-9). This MBR m r is determined by function getMostDissimilarMBR() , which returns the MBR with maximum enclosed volume. In the case where no empty group ex-ists, but there exist unassigned MBRs in the list , these MBRs are assigned to the most suitable group (lines 9-12) based on similar-ity with already assigned MBRs. Function getMostSimilarMBR() identifies for each MBR m r in the list, the most appropriate group based on minimizing the enclosed volume. In case the list becomes empty and there exists an empty group (line 13), then it is neces-sary to expand an MBR ( m r ) that is already assigned to a group G (lines 13-17). m r is removed from G j (line 15) and all enclosed MBRs are inserted in the list (line 16). Lines 18-23 describe our quality test for the created groups, which is invoked only when the list is empty and all groups have been assigned with MBRs. Fi-nally, the algorithm terminates, when the list is empty at a new repetition (line 5). This occurs if all groups have been assigned with MBRs of acceptable quality. In the following we describe the basic functionality in more detail.
 Expansion of MBR, if an empty group exists (lines 13-17). This is achieved by the function expand() (line 16). The MBR with the largest volume is selected from all assigned MBRs, using get-MaxVolMBR() , since this MBR is more probable to lead to overlap-ping groups and its expansion may reduce the enclosed dead space. Notice that replacing an MBR m r by its enclosed MBRs requires communication between the top level super-peer and the super-peer SP that generated m r . This communication is efficiently accom-plished using the super-peer hierarchy. The cost for such a commu-nication is bound by a number of messages equal to the height of the hierarchy ( logN p ), which are required to contact SP . Expansion of MBR, if no empty group exists (lines 18-23). In this case, our algorithm employs the quality test to determine if a cut of sufficient quality in the MBR hierarchy has been found, oth-erwise some MBRs have to be expanded further. An MBR m r is expanded, if its compactness is smaller than the relative overlap of m r with m j ,where m j any MBR that belongs to a different group. The intuition is that when this condition holds, the volume of the overlap with m j is larger than the volume of the enclosed MBRs of m r . Notice that the compactness provides a lower bound of the dead space in the MBR, while the relative overlap provides an esti-mate of the overlapping volume of two MBRs. The compactness of a bounding region is computed by function getCO() , whereas the overlap is computed using getRO() (line 20).
Given the generated N sp groups of MBRs, the remaining chal-lenge is to assign each group to a super-peers. A naive way is to pick for each group a super-peer randomly. However, this approach can result in a situation where neighboring super-peers in the super-peer topology index dissimilar MBRs of peers. This influences the aggregated MBRs of neighboring super-peers, and hence, the selec-tivity of the MRI. Therefore, the aim is to assign groups to super-peers, in such a way that neighboring super-peers index peers with similar content.

In the following, we first show that the problem of group assign-ment to super-peers can be mapped to a weighted graph matching problem [30] and then we present our algorithm for mapping the MBRs to super-peers.
The problem of group assignment to super-peers can be mod-eled in the following way. The super-peer network topology is an undirected graph Graph 1 that consists of N sp vertices. We also rep-resent the groups of MBRs and their similarity as a graph Graph also mentioned as similarity graph . The similarity graph is an undi-rected fully-connected graph with N sp vertices. Each vertex corre-sponds to a group of MBRs and the weights on edges represent the similarity between the corresponding vertices, i.e., groups. We use as a similarity measure the enclosed volume of the MBRs that be-long to the two groups. The weights are normalized in the interval [0 , 1] and smaller weight values indicate higher similarity.
The problem of assigning each group to a super-peer, is equiva-lent to matching the vertices of the network topology graph ( Graph to the vertices of the similarity graph ( Graph 2 ), in such a way that the edges of Graph 2 that correspond to an edge in Graph 1 weight as small as possible. Consider for example Figure 4, where a super-peer topology is matched to a similarity graph. By map-ping groups to super-peers as depicted in Figure 4, we ensure that similar groups are assigned to neighboring super-peers, because the sum of weights is minimized.
 More formally, we further assume that Graph 1 is also weighted, Algorithm 2 Mapping of groups to super-peers. 2: Output: Assignment 3: parent  X  X  X  , nei  X  X  X  9: list  X  list  X  X  G i } 10: while ( parents =  X  ) do 17: list  X  list  X  X  G j } 18: parent.add ( SP j ) 19: end for 20: end while where edges that correspond to the links between super-peers have a weight equal to 0 , while other edges have a weight of 1 the problem of group assignment to super-peers is mapped to the weighted graph matching problem.

P ROBLEM 1. Weighted Graph Matching: Let Graph 1 ( V 1 ,E and Graph 2 ( V 2 ,E 2 ) be weighted undirected graphs with |
V 2 | = n nodes. Also, let w 1 : E 1  X  + and w 2 : E 2  X  + be the weighting functions of graphs Graph 1 and Graph 2 respec-tively. The weighted graph matching problem is finding a corre-spondence f between V 1 = { v 1 ,v 2 , ..., v n } and V 2 which minimizes the difference:
The aim is to find a 1-1 mapping between the vertices of the two graphs, while keeping the weights of the edges as similar as possible, by minimizing the sum of their squared difference. Intu-itively, this conveys that similar groups are assigned to neighboring super-peers, since groups with small values of enclosed volume are assigned to super-peers with network-edges that exist (weight
The algorithm that solves the problem of weighted graph match-ing has a combinatorial complexity with respect to the number of vertices ( N sp ), which becomes prohibitively expensive for large networks. Therefore, we present an approximate algorithm of lin-ear complexity with respect to N sp . Our algorithm dynamically creates a spanning tree over the network topology and assigns the most appropriate group to each super-peer in breadth-first man-ner. As a root of the spanning tree, the super-peer with the maxi-mum connectivity degree is chosen. We assume that the super-peer with highest connectivity degree is more important and the reason is twofold. First, a super-peer with many connections influences the performance of the MRI more, since it propagates aggregated MBRs to more super-peers. Secondly, it is less probable to find a group that is similar to many other groups, and it gets more difficult if some groups are already assigned, as they impose constraints to new assignments. After assigning an appropriate group to the first super-peer, the next subset of super-peers is its neighbors; priority is based on super-peer connectivity degree, with well-connected super-peers being assigned with groups first. This procedure is re-peated until all groups are assigned to a different super-peer.
Group selection is based on the similarity to the group already assigned to the neighboring super-peer. If G i denotes the already assigned group to SP i , we assign to a neighboring super-peer SP the group G j that minimizes the enclosed volume  X  V ( G i a group G i , a ranking of a set of groups { G j } can be defined based on the enclosed volume with respect to G i .Wedenoteas top the k groups G j that have the minimum values  X  V ( G i ,G the following formula defines a score for each group G i based on its k most similar groups.
The pseudocode describing the algorithm is presented as Algo-rithm 2. First, the super-peer SP next with the highest connectivity degree deg ( SP next ) is selected (line 5). Since there is no group assigned to SP next , we pick the group G i that has the highest similarity with k = deg ( SP next ) unassigned groups, i.e., minimum score k ( G j ) value (line 7). Notice that we take into account only the k = deg ( SP next ) most similar groups, because each group of MBRs has high similarity to some groups and low similarity to the remaining groups. Then, SP next is added to the parent list (line 6) which stores the super-peers for which their unassigned neighbor-ing super-peers will be processed in the next iterations. Then, until the parents list is empty (line 10), the first element is examined (line 11) and a group is assigned to each neighbor (lines 14-19). The most similar groups to SP i are retrieved (line 13) and assigned to the neighbors (lines 15-16). Each neighbor is added to the parent list (line 18). Thus, the algorithm assigns groups to super-peers by visiting them in a breadth-first way, starting from SP next end, each of the N sp groups has been assigned to a super-peer.
Notice that the algorithm requires knowledge of the super-peer topology only at runtime. As super-peers are usually a couple or-ders of magnitude fewer than peers (i.e., the size of the P2P net-work), this assumption is tolerated. Moreover, notice that peer to super-peer reassignment may increase their real geographic dis-tance. This is the basic idea behind overlay networks, which cre-ate overlay links between peers based on content similarity. It is generally established that the performance of query processing im-proves by using such overlay links (as for example in CAN [28] or VBI-tree [21]), compared to the case of links reflecting geographic distance but no useful information about content location.
Data and MBR Updates. Updates, insertions and deletions of data stored at a peer may alter the set of MBRs that encloses the peer X  X  data. As long as the data distribution of the peer X  X  data does not change, the MBRs will not change by each single data update. Only if some of the peer X  X  MBRs changes, the corresponding super-peer has to be informed. Then, this super-peer has to update its locally stored peer MBRs and the set of aggregated MBRs that en-close the data of all peers. Notice that this does not necessary lead to an update of the MRI. Assuming that a peer X  X  MBR changes slightly, it is quite probable that the super-peer X  X  MBR that sum-marizes the peer data does not change, since other peers may store similar data. Only when the set of aggregated MBRs of a super-peer changes, this leads to an MBR update 3 , which influences the MRI. Thus, MBR updates occur less frequently than data updates.
The case of an MBR update at a super-peer is the most generic maintenance operation, as it can be triggered by peer data updates,
The term MBR update refers to an update of an aggregated MBR. peer joins and failures. When an MBR increases in size, this change must be immediately communicated to other super-peers, other-wise a query intersecting only with the increased region will not be routed to the updated super-peer. When an MBR decreases in size, this change can be communicated with some delay, as in the meantime the updated super-peer may be queried in vain, but the correctness of the result is still guaranteed. In a similar way, if a super-peer SP N receives an updated set of neighboring MBRs, then SP N updates its local MRI and informs its neighboring super-peers about the MBR update.

Although data and MBR updates can be efficiently handled us-ing the aforementioned protocols, it is possible that high rates of churn may result in MRI of poor quality. However, using the met-rics defined and used throughout this paper, a super-peer can indi-vidually decide when the quality of its local MBRs has degraded significantly. For example, by observing the average compactness of its local MBRs, a super-peer can decide that their quality is no longer acceptable. Therefore, when most of the super-peers iden-tify such a situation, the routing indices construction is triggered anew, in order to generate MRI of higher selectivity. Even though the construction could run periodically regardless of churn rate, the proposed approach is more appropriate, because it is on demand and it can self-adapt to the peer dynamics in the system.
Peer joins. When a new peer P J joins the system, P J provides a summary description of its data by means of a set of k MBRs. Obviously the value of k is not fixed and it varies for different peers. Initially, P J connects to a super-peer SP J at random, using the basic bootstrapping protocol. Then, SP J undertakes the task to discover the most relevant super-peers that P J should connect to. In order to achieve this goal, the MRI are exploited.

For each m i ( 1  X  i  X  k )of P J  X  X  MBRs, SP J executes the following procedure. SP J computes the minimum enlargement of volume of its aggregated MBRs caused by m i . This value serves as a measure of goodness for accommodating m i . Then, SP its MRI to compute the value of enlargement for each neighbor-ing super-peer, and forwards m i only to those neighbors that have a smaller value of enlargement based on the MRI. Any recipient super-peer SP R computes the value of enlargement and checks if m i needs to be forwarded further. Eventually, any recipient super-peer SP R sends back to SP J its locally computed value of enlarge-ment and SP J assigns m i to the SP R with smallest value. The ob-jective is to assign m i to that super-peer, which can accommodate m i with minor changes to its MBRs. Using this peer joining proto-col, P J establishes up to a maximum k intentional connections to other super-peers in the network. For each super-peer SP R assigned with P J due to one of its MBRs, it is possible that SP needs to update its MBRs, in order to enclose also the data of P
Fault-tolerance. Regarding peer failures, each super-peer SP can easily and timely detect the failure of a peer P F , by sending periodically ping messages to all peers connected to SP i was connected to SP i , we assume without loss of generality that there exists (at least) one MBR of SP i that encloses an MBR of P When the failure is detected, SP i deletes the peer X  X  MBRs from its local index, and updates its list of aggregated MBRs that contained P  X  X  MBR. Finally, SP i checks if an MBR update occurred and if necessary the neighbors are informed as already described.
Churn of super-peers is infrequent, however it can be efficiently handled capitalizing on the methods for MBR updates. When a super-peer failure occurs, peers have to reconnect to the network using the bootstrapping protocol. Whenever neighboring super-peers detect a super-peer failure, the corresponding MBRs are deleted from the MRI and their neighbors are informed. When a super-peer joins the network, it connects to DEG sp other super-peers, and peers connect to this super-peer through the peer join procedure. In this way, the super-peer builds its aggregated MBRs and exchanges MBRs with its neighbors.
We evaluate the selectivity of MRI using large-scale simulations, with a simulator prototype implemented in Java. We used the GT-ITM topology generator 4 to create well-connected random graphs of N sp ( 200 -600 ) super-peers with average connectivity DEG ( 4 -7 ). Unless mentioned explicitly, we use DEG p = 10 for the ini-tial P2P topology, thus obtaining the number of peers N p 6000 ). We conduct experiments varying the dimensionality d ( and the cardinality n ( 1 -3 M) of the dataset. We keep the number of objects per peer ( n/N p ) constant and equal to 500 .

In order to evaluate the scalability of our approach, we experi-mented with synthetic clustered data collections, partitioned evenly among the peers. For the clustered dataset generation, we randomly pick N sp d -dimensional points and each peer obtains k distinct cen-troids from them at random. Obviously, two peers may share the same centroid. Thereafter, each peers X  object is generated inside a radius r from one of the peer X  X  centroids. The radius r is selected in a way that the total volume of the data capture v % of the data space. Although we use as default value v = 10% , we study the effect of varying v values in our experiments. Peer data are represented by spherical MBRs, and they are determined using the k-means clus-tering algorithm. Notice that the choice of the clustering algorithm is orthogonal to our framework and other techniques can be em-ployed. MBR aggregation at any super-peer is also performed us-ing the k-means algorithm on the MBRs centroids. Naturally, we study the performance of MRI for varying values of k .

To study the performance of query processing on top of the MRI, we employ the SIMPEER [7] framework, which is the state-of-the-art approach for multidimensional query processing over a super-peer architecture. For comparative purposes, we compare against SIMPEER that assumes random peer to super-peer assignment. The comparison against SIMPEER helps to quantify the improvement of the MRI in terms of selectivity achieved by our approach. Fur-thermore, we evaluate the performance of routing indices constructed by our approach (MRI) to indices constructed by an OPTIMAL peer to super-peer assignment, which provides the best performance that any algorithm can achieve.
Our first objective is to evaluate the selectivity of MRI, which di-rectly depends on the quality of the groups (or equivalently MBRs) that have been assigned to the super-peers, as their dead space and overlap determine the selectivity of the MRI. Our default setup con-sists of a network of 2000 peers, 200 super-peers, 1 M data objects, and we set the k-means parameter to k = 10 . All experiments were repeated using 10 different synthetically generated datasets and the average number of the measurements is depicted in all cases.
In Figure 5(a), we study the compactness with respect to the data dimensionality, in particular by increasing the dimensionality from d = 2 to d = 6 . We compare the compactness of the groups assigned to super-peers using MRI to SIMPEER, for varying number k of MBRs. Recall that a value of compactness smaller than 1 means that definitely dead space is enclosed, while for values larger than 1 the probability of existing dead space decreases. Clearly, the groups created by SIMPEER have compactness close to zero for all tested values of k . In contrast, MRI manages to create groups of high quality, especially with increasing k . This is because higher
Available at: http://www.cc.gatech.edu/projects/gtitm/ number of MBRs enables more detailed description of data, hence MBRs are aggregated in a more efficient way. Notice that the de-crease of compactness with increasing dimensionality is expected, however its values remain high and 1 to 2 orders of magnitude bet-ter than SIMPEER in all cases.
To evaluate the routing ability of the MBRs, we select randomly 20 MBRs out of the original peer MBRs, and consider them as range queries that follow the data distribution. We measure the average number of groups that contain an overlapping MBR with the queries or, equivalently, the minimum number of super-peers that have to be contacted during query evaluation. We fix the value of k to 10 and vary the super-peer network topology, from sparse ( DEG sp = 4 )todense( DEG sp = 7 ) in Figure 5(b). We conclude that the topological characteristics only slightly affect the number of super-peers that is necessary to be contacted. This verifies the high quality and routing ability of MRI, regardless of the topology. Moreover, based on the way data is generated on each peer, we can define an OPTIMAL case where all peers that obtained a particular centroid connect to the minimum possible number of super-peers. Since the number of such peers is 100 and each super-peer indexes DEG p = 10 peers, the OPTIMAL number of super-peers is 10 observe that MRI manages to achieve performance much closer to OPTIMAL than SIMPEER.

In Figure 6(a), we depict only dimensionality 3 and 4 and we increase the network size N p by scaling the number of peers up to 6000 . The number of super-peers N sp is kept to 200 . Thus, each super-peer is assigned with DEG p = 10 to 30 peers. With respect to compactness, MRI outperforms SIMPEER for all network sizes. Moreover, the compactness increases with network size, since each super-peer is initially connected to more peers, hence more MBRs are collected and their aggregation is of higher quality. In addi-tion, we increased N sp up to 600 super-peers, and we observed that MRI always outperforms SIMPEER in terms of number of con-tacted super-peers (chart omitted due to space limitations). More importantly this gain is maintained as the number of super-peers increases, clearly demonstrating the scalability of MRI.
The effect of the percentage v of data space volume captured by the dataset is studied in Figure 6(b). We test v = 1% , v = v = 20% , where increasing values resemble the more uniform data distribution. In all cases, MRI performs gracefully compared to OPTIMAL, and MRI is more stable and less affected by increasing v values, compared to SIMPEER.
In the following, we verify that the gains in the quality of MRI are also reflected in query processing performance. We compare the performance of routing indices constructed using our algorithms (MRI) to the indices of SIMPEER. We generate random range queries of varying selectivity (number of results) that follow the distribu-tion of data. We measure the comparative performance of both ap-proaches in terms of average number of messages for searching and peer success ratio, i.e., how many of the contacted peers returned results. Figure 7 reports the experimental results. Although several different setups were tested, we only show the most important find-ings, due to lack of space. As an example we show results of range queries with selectivity ( res ) equal to 100 and 200 objects.
In Figure 7(a), the average number of messages used for query processing is shown. MRI requires fewer messages than SIMPEER to retrieve the complete result set and, most importantly, this gain increases with d . This verifies the robustness and superiority of MRI, in terms of query processing performance, irrespective of di-mensionality. We also measure the peer success ratio, shown in Figure 7(b). Despite the expected drop of success ratio with in-creased dimensionality, MRI is always better than SIMPEER and MRI achieves acceptable values even for d = 6 . This result demon-strates the efficiency of routing using MRI. In order to ensure the validity of this result for larger networks, we increase the num-ber of super-peers ( N sp ) from 200 to 600 , while the number of peers also increases to 10  X  N sp . The chart in Figure 7(c) shows that MRI maintains a stable peer success ratio when the network size increases, whereas SIMPEER presents a downward tendency. Hence, MRI is a scalable solution when the network size increases. In Figure 8, we study the effect of peer data updates on the MRI. We update all 500 data points at each peer (in total 1M data points are updated), modeled as deletions and insertions, and we measure the percentage of data updates that caused an update at peer and super-peer MBRs for varying dimensionality (Figure 8(a)), as well as the number of peer MBR updates as time elapses (Figure 8(b)). The updates follow the data distribution of the generated data. In Figure 8(a), the results show that fewer than 1% of data updates lead to peer MBR updates, while even fewer than 0.1% of data updates lead to super-peer MBR updates. Therefore, only 0.1% of the updates on the peers cause an update of the MRI. In Figure 8(b), we depict how many peer MBRs are updated per batch of 100K data point updates. The decreasing tendency shows that the effect of data updates on peers diminishes as time elapses.
Routing indices [5] have been originally proposed in the con-text of unstructured P2P systems, as a search-enabling technique that provides a direction to routing, instead of blind forwarding. Although the original context was best-effort document retrieval, several research papers adopt routing indices, including super-peer networks [26], semantic routing indices [25] and routing indices based on histograms [27]. Unfortunately, traditional routing indices are not applicable for multidimensional data that require more ad-vanced query types, such as similarity search, and when the aim is retrieval of the exact and complete result set.

Distributed data summaries as routing indices. The most rel-evant works to ours are those that assume autonomous data storage by peers and build distributed data summaries for routing. Hose et al. use a tree-based structure, named QTree [19], for summariz-ing data and query routing. Recently in [20], the maintenance of routing indices is addressed and the authors discuss requirements that need to be fulfilled by such routing structures. In contrast, our approach focuses more on improving the selectivity of the MRI by dynamic peer reallocation. The use of P2P data summaries has also been proposed in [18]. SIMPEER [7, 8] supports exact query pro-cessing over multidimensional data distributed in a super-peer net-work. Sharing similar goals to this paper, namely efficient routing of similarity search queries, SIMPEER relies on routing indices, but ignores the factors that influence their selectivity.
Scalable distributed data structures (SDDS). Distributed mul-tidimensional indices, such as distributed R-trees, have been pro-posed in the literature. SD-Rtree [11] is a distributed balanced bi-nary spatial tree that is used to store and query spatial objects. Each node has knowledge of all other nodes in the system and this con-stitutes a major difference to P2P systems, where a (super-)peer is only aware of a limited set of neighboring (super-)peers. P2P multidimensional indexing based on space partitioning. Content addressable network (CAN) [28] was the first approach for P2P multidimensional indexing. Although it is based on hashing, CAN is similar to a dynamic multidimensional grid on the data space. Space partitioning, based on distributed tree structures, has also been considered. In [14], the authors identify two primary components for multidimensional query processing, namely parti-tioning and routing. They propose an adaptation of the kd-tree for partitioning and use of skip pointers for routing. P-ring [4] is a P2P index that assigns ranges of the search space to peers. VBI-Tree [21] is a framework for multidimensional indexing in P2P networks. Peers are organized in a balanced tree structure based on the space partitions assigned to them. Our techniques differ significantly from such space partitioning approaches [4, 14, 21], because each peer stores its own data autonomously, in contrast to predefined assignment of regions of the data space to peers and de-liberate data placement on peers. Moreover, P2P multidimensional indexing approaches suffer from load balancing issues, which even-tually leads to the additional cost of restructuring the network.
Dynamic topology adaptation has been thoroughly studied in unstructured P2P systems [1, 2, 3], where the aim is for peers to create links to peers with similar content, thus improving the per-formance of routing. Nevertheless, in super-peer architectures, in-tentional peer to super-peer assignment has only recently attracted the attention of the research community. A self-organizing super-peer network architecture named SOSPNET, is presented in [15], and deals with the issue of how clients connect to a super-peer. Al-though relevant to our approach, the main difference is that SOSP-NET organizes peers according to requests for files, while our ap-proach is data-centric and focuses on data distribution. Moreover our approach can handle more complex data types than files and process complex queries. In [9], self-organization of peers based on content similarity has been shown to improve the performance of search, thereby motivating the appropriateness of building selec-tive multidimensional routing indices as described in this paper.
In this paper, we addressed the challenging problem of construct-ing multidimensional routing indices (MRI) of high selectivity. Fo-cusing on a super-peer architecture, we identified an important fac-tor that affects the performance of query routing, namely the en-largement of the MBRs that describe the data available through each neighboring super-peer. Our proposed approach improves the selectivity of the MRI by assigning peers with similar content to the same super-peer in a self-organizing manner. Moreover, neigh-boring super-peers index similar content which improves the rout-ing process even further. The experimental results show that MRI significantly improve a state-of-the-art approach for P2P similarity search, by boosting the performance of query routing.
