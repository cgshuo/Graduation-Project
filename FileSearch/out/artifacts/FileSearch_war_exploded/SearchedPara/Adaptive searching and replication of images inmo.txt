 1. Introduction
Recent advancements in the area of small mobile devices have made wireless networks very popular. These miniature devices have limited battery power, processing capacity and restricted memory. We consider wire-less ad hoc network constructed using wireless communication protocols such as Bluetooth, GPRS, EDGE, and WiFi, etc. They connect wireless devices but most of these do not support high bandwidth communica-tion. In addition, like conventional wired/wireless computer networks there can be various network topologies between mobile devices but unlike wired networks these topologies are dynamic due to the mobility of the devices. Content management [10,22] , therefore, has become much more important in Mobile P2P networks.
For example, which data to replicate and where to replicate are two important issues to address? In our appli-cation, we consider multimedia objects (images) which could be very large and due to wireless network envi-ronment and device constraints exchanging original images are not required. In many scenarios, users either do not need or have not subscribed to high quality images. This is also to address quality of service (QoS) guarantee [7,23] to subscribers who pay more or require better quality objects for their applications.
We consider a hierarchical mobile ad-hoc network for peer-to-peer networks (called M-P2P), a self-config-uring network consisting of mobile peers equipped with small mobile devices connected by wireless links. The peers are free to move randomly and can organize themselves arbitrarily; thus, the topology may change rap-idly and unpredictably. In M-P2P, devices can connect directly to each other within a small geographical loca-tion which then can even get connected to other small networks or external wired network such as to the
Internet. Hereafter, the term node and peer is used interchangeably and it refers to users carrying mobile devices.

Consider an application scenario where a group of rescue workers working in a disaster or War zone involves collecting image samples of objects such as damaged houses, uprooted trees, broken bridges, flooding areas, injured people, etc. In addition, there are groups such as News media, non-profit organizations such as
Red Cross and commercial entities like Insurance agents, whose wireless networks are integrated to provide seamless connectivity for disaster relief. Each group is responsible for tracking one or more of these objects by surveying the designated area with small wireless devices and collecting images for collaborative processing of information within and across the groups. Thus, the objective is to minimize the network traffic while exchang-ing images among groups to accomplish the mission. The project leader is responsible for monitoring the glo-bal view of the situation within their groups and also, communicates to other group leaders. The requirements of each group and user profiles including the configuration of the mobile devices in the network may vary.
Thus, the images can be re-sampled based upon the requirements and device configuration and can be trans-ferred to lower resolution to reduce the network load. In addition, the sharing of images can be optimized by combining two small resolution images into one or using image residues to build the original quality image. The project manager controls the content distribution and manages the traffic using this adaptive approach.
Any user who needs an image from any other area/agency first contacts the project manager who authorizes him for doing the same in order to protect against possible intruders and malicious nodes which might have been integrated from other agencies, which could jeopardize the data integrity. This approach targets super-peer based management of image replicas and ensures the optimum network utilization with respect to traffic routing and at the same time preserving P2P autonomy. First, each node sends the request to the super-peer, which provides an authentication certificate allowing access to data within and across groups. In addition, it can forward a list of possible peers to whom the query should be forwarded to as recommendations. Later, peers can cache and reuse this peers ids, certificates and its duration of validation and data for subsequent searches. This way all the requests can be authenticated by super-peer nodes and can track the movement of peers inside a group, such as peers entering and leaving the group.

For most of the collaborative applications discussed above, we envisage a P2P network in a hierarchical form called hierarchical mobile ad-hoc peer-to-peer networks . The grouping of peers is done by super-peers which are assumed to be rich in resources and thus, serves other peers underneath. Super-peers decide the rep-lica allocation of images by considering various parameters like resources available, network state, trust val-ues, average response time, etc. It can provide requesting peers a certificate which states the quality of service agreement and its validity time-period. The peer then sends the request to the peers in the target list along with the certificate.

The images are replicated after converting them into lower resolution based upon the constraints of the requesting device (peer) and access privileges granted to the peer. The idea of image re-sampling increases the wireless network efficiency by reducing the file size and the quality of service parameters by giving the peers what they are authorize to or depending on the current context and environmental conditions. Our algorithm also uses the strategy of image reconstruction from different parts of the same image to increase the search efficiency. We have used the Bi-Linear algorithm [20,2] to re-sample images (other algorithms such as JPEG 2000, etc., can also be used). Using Bi-Linear re-sampling technique, the target resolution is computed from the image and the remaining pixels not used in the new image are stored as a residue at the same peer. The residue is then can be used in the image reconstruction based on the other peers X  request in the network; the residue and the lower quality images can be combined to form the original quality image. The requesting peer then decides whether it is economical to download the corresponding image or download pieces of an image from multiple peers or convert an available quality image to the required quality image. Thus, there is a trade-off between the delay in the downloading the required quality image and the power consumption in converting it to the required resolution image. In other words, there is a trade-off between finding a shortest path to download residues/fragments of different resolution and forming the required quality image and the power consumption in downloading, computing and converting an available image to the required quality image locally. We have also compared the performance of Ada-Rep with base replication and uniform repli-cation algorithms. Our method outperforms these existing replica creation algorithms. As far as we know, this is the first paper which considers replicating fragments of an image data object of different resolution to improve the efficiency of replica allocation and searching algorithm in M-P2P.

The following section gives the architecture description with architecture components. Section 3 defines image search strategies used in the network. Section 4 describes the image re-sampling technique used in the protocol. Section 5 gives the Ada-Rep algorithm for image search and replication with example. Section 6 comprises of simulation results which compares different search and replication strategies. Section 7 con-cludes the paper. 2. Related work
The concept of hierarchical peer-to-peer systems was first introduced in [15] , where peers are organized into groups, and each group has its autonomous intra-group overlay network and lookup service. Groups are organized in a top-level overlay network. Later in [11,12] , a hierarchical architecture was proposed that could potentially scale P2P networks to large numbers of peer nodes and contents. They compared there P2P model with the existing non-hierarchical P2P systems. In [26] , authors gave a hierarchical mobile wireless network (HMWN) to support movable base stations. The lightweight super-peer topologies (LST) [18] for hierarchical
P2P Networks targets to explore a class of P2P Networks between structured and unstructured. LST are designed to have a low management complexity as well as overhead. A P2P file sharing architecture is dis-cussed in [9] . Caching is used to improve the searches in [3,14,25] and various other caching schemes are pro-posed in [19] for hierarchical architecture.

The idea of merging data files over transferring the complete file was first proposed in [22] . We extend this idea to a step further as stated in the application examples to improve the network efficiency in case of image data objects. We propose adaptable replication schemes, much more advanced than discussed in [19] where the replication schemes such as leave copy everywhere (LCE), prob (a randomized version of LCE), leave copy down (LCD) and move copy down (MCD) do not take the network traffic and data object demand in con-sideration while replication. In [24] , a light-weight adaptive replication (LAR) algorithm is proposed to bal-ance the load in network but is not designed to handle mobile network constraints.

A more optimal replication strategy compared in [6,21] shows that the optimal (with respect to search performance) replication is achieved when the number of copies per data item is proportional to the square root of their popularity. In [6] , it compares the square root replication with uniform and proportional rep-lication strategies where everything is replicated equally in uniform and more popular items are replicated more in proportional , which is designed to perform better. In [6] , it shows that both of these schemes have same expected search size on successful queries and proves that the square root replication minimizes the expected search size on successful queries. Another algorithm proposed in [8] replicates almost equal to the square root replication when the query rate for each item is not known. In our case, the query rate is tracked by the super-peer which decides the number of replicas required for each item. In [21] , the author examined a number of algorithms, namely, owner -replication , path -replication , and random -replication . Tak-ing it one step further, our protocol also decides the optimal replication node based upon the load on each intermediate peer and use image replicas (of small resolution) and residues to reduce the network load.
Unlike [6,21] , we propose a hybrid approach for monitoring the load balancing and query latency to increase the accuracy of replica placement in the network. In addition, we consider parameters like nodes request processing frequency, computing capacity etc. and optimize the image replication based on each peer X  X  resource reserves. 3. System model
Considering the requirements of the applications described earlier, we propose a flexible hierarchical P2P overlay architecture within the bandwidth constraint wireless communication network integrated with differ-ent small wireless devices with limited memory and battery power. We consider the random movement and frequent disconnections of mobile devices. Note that we are only considering images as data objects in the M-P2P network.

The M-P2P system model is as follows.  X  The network hierarchy is not rigid; the peers can connect and disconnect randomly. The super-peer hier-archy [18] is based on the trust values of the peers to provide better management and increased data avail-ability. Note that our focus is not on designing trust algorithm here, and therefore, we compute trust values using some of the available algorithms [1] .  X  This architecture is restricted to a mobile network where some of the nodes can be connected to the wired network. This network can be formed by a group of users that are equipped with mobile devices connected using ad-hoc network with certain peers acting as super-peers. The proposed architecture is shown in Fig. 1 . For forming peer groups, the proposal in [18,21] can be adopted. The work in [5] performs peer clustering in
M-P2P networks by modeling the clustered layout based on a heavytail distribution such as the Pareto dis-tribution . In particular, the Bounded Pareto distribution is used in order to bound the minimum and maxi-mum number of nodes in each sub-area to produce a connected network.  X  In M-P2P, the group super-peers are considered as the root of the hierarchy of a small ad hoc networked group of peers. These are the trusted peers equipped with more resources than others. We either can elect a super-peer based on the resources available or can designate some peers to act as super-peers in each region by rotation. There can be sub super-peers under them depending on the levels in the hierarchy based on an application. The function of a group super-peer is to connect its group network to the outside as well as to manage the traffic inside the group. In our architecture, we consider that group super-peers connect phys-ically or logically to other group super-peers nearby and can establish a network for communication at a higher level than other peers. The trust factor of all the nodes inside a group is stored at this peer, which facilitates the proper allocation of resources and manages the traffic inside the group.  X  M-P2P can have some wireless nodes that are directly connected to the Internet known as Internet Peers.
This is useful for ensuring some fault tolerance capability in case a super-peer fails or moves out of the group, then these peers can provide access to external resources.
  X  Looking at the uncertainty of connections in mobile networks, we assume that any node may disconnect without prior information to the super-peer. In that case the super-peer has to update the disconnected nodes information based on acknowledgements received from other peers regarding successful or unsuc-cessful transactions. This report is sent periodically to super-peers to update trust values and availability of peers.  X  A new node entering into the network will inform the super-peer of the group by sending a join message using its neighbors which can also pass to the new node the region topology, including the possible paths to the super-peer. Using this topology it can issue a query to the super-peer which can provide an authen-tication certificate . An authentication certificate is used to give provider information regarding level of access permission granted to peers. It includes information such as ids, keys, validity period, quality of ser-vice, user profiles etc. A peer cannot send any request or access any image data without the authentication certificate from its group X  X  super-peer. The request is first sent to the group super-peer who monitors initial peer queries in the network. The group super-peer then replies back with the authentication certificate so that it can access the image from (1) an authentic node only (2) can get the image according to its user and device profile (3) others in-between nodes only act as relay nodes. Later peers can issue queries themselves as long as the certificate is valid.  X  Every peer has a unique peer id in the network. Let the total number of peers in the network be n , and the set of all peers be P  X f P 1 ; P 2 ; ... ; P n g . Each peer can connect to any number of peers inside the network.
Let the peer P j be connected to m number of peers. If m = 0, the peer is disconnected from the network and if m  X  n 1 the peer is connected to all the nodes in the network. In practical situations, the average con-nectivity of nodes lies between 0 6 m 6 n 1.  X  If the total number of peers is n in the network, then the set of all peers in the network can be represented by peer then i 2 P  X  v  X  , where P  X  v  X  is the set of nodes having the requested image. A node will never request for an image which it is already having with desired quality.  X  Image searches can be done inside and across groups. The hierarchical search across groups is used when the image request is not satisfied within a group. Note that peers are moving and therefore, some peers who may be having images are currently in different groups or may be out of reach and in that case, the request propagates up in the hierarchy. The search starts after the permission is granted by the super-peer. The request is then transmitted into the same group with a TTL (time to live limit) set by the peer. After the query is executed, the requesting peer acknowledges the super-peer periodically about the successes and fail-ures of queries. It can acknowledge immediately if the request is not satisfied. If the acknowledgement is negative, then the super-peer may start the second iteration by expanding the search towards higher/other group super-peers. The acknowledgement will be negative if the TTL expires without any response. Search is carried out iteratively till an image is found or the search reaches the root of the hierarchy. When the TTL expires, the request is not forwarded further.  X  Image transfer is done in a bucket brigade manner. The message is passed from one peer to another until it reaches the destination peer. Bucket brigade is more reliable with moving peers and frequent disconnec-tions. The throughput is increased because bucket brigades spontaneously generate the optimal division of work among peers along the path. The transmission cost of this protocol is discussed in Section 5.1 .  X  We have used dynamic source routing (DSR) [4] protocol which uses source routing instead of relying on the routing table at each intermediate device. Determining the source route requires accumulating the address of each device between the source and the destination during the route discovery. The accumulated path information is cached by nodes processing the route discovery packets. The return path is used to route the packets. To accomplish source routing, the routed packets contain the address of each device the packet will traverse.
 We focus on three types of searching methods:
Flooding ( one to all ): Here an image request is sent to all the peers in the network. The super-peer only sends the authentication certificated on the request, but does not supply the list of target peers as it may not have always up-to-date information. Once the requesting peer received the certificate, it floods the network with the request along with the certificate obtained. Fig. 2 shows the Flooding scheme in work where dotted lines represent the request being propagating to all the nodes in the network. The search begins at the requesting node and it explores all the neighboring nodes. Then for each of those nearest nodes, it explores their unex-plored neighbor nodes, and so on, until it finds the requested object. The forwarding peers keep on appending their ids to the route vector to trace the final path back to the requesting peer. In the worst case scenario, the the number of nodes and j E j the number of edges in the network graph. Flooding makes sure that every path in traversed in the network and finds a path with minimum number of edges between two given peers/nodes until the object is found.

Multicast ( one to N ): In this case, the super-peer supplies the list of peers who have the desired object with the authentication certificate or the peer may have this information from the last search query. In this case, the requesting peer floods the request for only those peers who possibly have the required object and are in the region. Fig. 3 illustrates the multicast scheme where the request is sent only to the concerned nodes (nodes with images).

Restricted flooding : This protocol is used when a request is not satisfied in its group and a broader search needs to be executed. After receiving a negative acknowledgement by the requesting peer the super-peer for-wards the image request to the super-peers of other regions and super-peers then flood the query to the peers within their region. This protects the peers by not providing location transparency to the remote peers ( Fig. 4 ). The complexity of this algorithm is based on the number of different groups searched for the object. The complexity of restricted flooding is the result of flooding algorithm complexity multiplied by a factor of n , where n is the number of total groups searched for the request. Note that each query has a TTL even when it goes to other groups. 4. Image re-sampling
The image re-sampling is used to decrease the wireless network traffic and to provide the adaptable quality of service. It is required to change the resolution of an image for display on different small mobile devices according to the constraints given. In addition, a peer may not need a high quality image for his/her applica-tion (like accessing images of injured people and damaged houses by News networks) or due to the network congestion, a higher resolution image may not be given to a peer to reduce the latency. Moreover, an image can be reconstructed by combining different fragments of the same image. As mobile devices are not having high computational powers, only low cost algorithms can be used to re-sample the images. We have used the Bi-linear image re-sampling algorithm [2,20] in our simulation (see Fig. 5 ).

Let us assume that we have  X  X  N s  X  X  samples in the source and we want to pick  X  X  N
Linear algorithm for every destination pixel, the location of the ideal source pixel is found by using the N pixel location. The new image is calculated and the residue is saved separately to use it in the further recon-struction of the image.

To track the number of re-sampled images and residues, we use the following nomenclature to define the quality of an image. For simplicity, we consider that the percentage size of re-sampled image is only in the multiples of 10, i.e., 10%, 20 X 90%. So the image versions are marked as a example, a 3  X  b 7  X  100 % image. We also use the same equation for combining fragments and residues of images to construct the full image ( a 3 is considered as 30% residue and b image and similarly, in the case of the fragments, a 3 and b here are (1) to download a lower quality image or to convert a higher quality image to the quality requested (2) to download a lower quality image and residue to get a higher quality image or in fact download the desired quality image from another peer (3) to reconstruct an image from different fragments (4) to decide whether to replicate an image quality at some peer on the search path. 5. Ada-Rep algorithm
Based on the last paragraph above, we would like to calculate different costs to decide among all the options. For calculating the image reconstruction costs, we consider the size of a and b images. If the requested image size is less then 50% then the size of residue image ( b ) is more then a image. In that case we need to consider the residue images with least transmission cost and find the corresponding a image. If the requested size is more then 50% then we find the minimum cost a image and the corresponding b image. The total recon-struction cost is then compared with the complete image transfer cost. If transferring of the complete image is cheaper than transferring the two different images, the complete image is transferred or else it is reconstructed from different images. After transferring the images, the trust value of peers is updated by the requesting peer by sending the information to the group super-peer. 5.1. Costs involved
The description of various costs involved in the system is as follows. 5.1.1. Transcoding cost (C s )
This is the cost incurred to re-sample a higher resolution image to a lower resolution. It depends on the size of the image and the processing power of the re-sampling device and is calculated as: where Image size is the size of the image in bytes, and Processing power is the chunk of data the device can process in a unit of time. For example, let the unit of data be bytes then the transcoding cost C (bytes/s) gives the cost in units of time (i.e., in seconds). 5.1.2. Transmission cost (C t )
This is the cost of transmission delay due to low bandwidth, poor connectivity or excessive traffic in the network. The transmission delay depends mainly on the size of the image to be transferred, the available band-width and the request queue size at all the nodes in the path. While the image response is traversing back, all the nodes in the path calculate their transmission delay and add to the previous value in the message header.
The requesting peer then receives the summation of transmission costs at all the nodes in the routing path. The final transmission delay is formulated as where n is the total number of nodes in the path, S is size of the image to be transferred, BW is average band-width at that node, JL is the length of job queue at that node and SR is the service rate of that node. C measured per unit of time (in seconds). 5.2. Replication decision
The decision for creating the new replica in the reply path is made by the super-peer. The super-peer decides the number of replicas to be maintained in the network. The availability percentage of N nodes can be decided based upon the number of requests for that image and the average response time taken for all the requests for that image in the last few periods. The response time is inversely proportional to the number of replicas/copies in the network.

More number of copies will result in lesser response (average) time. The super-peer maintains a list of requested image objects with their request count and average response time which is updated periodically after each requesting peer informs the data about successful searches in the time period. For comparing the average response time, we consider the highest value of average response time of all image objects. If the average response time for any object exceeds the threshold value set by the super-peer (based on percent of nodes requesting), the super-peer will increase the availability by allowing more replicas to be created.
We use a modified version of the square root replication proposed in [21] , where the replication of an object i is proportional to the square root of its query probability q (the number of the replica copies), the new replica count ( K of all the queries for that object in a given time period. The proper fraction obtained from the average and low response time (refer formula below) is added to 1 to get the fractional increase in the number of replicas. If the difference in the low and average response time is more then more replicas will be created to lower the average replica count ( K 0 )as where T avg is the average response time of the image and T
Every peer periodically acknowledges the super-peer about all its queries executed successfully in that per-iod. The super-peer then updates the response time for each image transaction into the list of requested objects. The super-peer calculates the new average response time of the images periodically and compares with the response time in the previous period. If the new average response time for any image is higher than the previous one, it marks that object for increasing its replicas with the number of more copies required. The replication permission is granted to each request for that image until the desired replica count is attained.
If the request/response path is chosen for the image replication and is already has some small resolution images, a residue of that image is replicated instead of the original image size requested. The propagating request along with the count of the number of copies encountered, it also stores the summation of percentages of all the copies in that path using which the final peer calculates the average image size in that path. The res-idue image size calculation is discussed in detail in the next section.

The assumptions for placing the replicas using Ada-Rep are as follows. 1. New replica will not be placed at any node already having a copy of the image. 2. If the request/response path is already having the required percentage of copies irrespective of their reso-lution (including residues) compared to the number of nodes in that path, no new copies will be created. 3. The decision to replicate the original copy or its residue is made by the requesting peer. The related formu-las and calculations are discussed in the following section. 4. Replica placement is based on the ranking of Replication Factor values of intermediate nodes which is dis-cussed next.

Here, we do not discuss the reduction in the number of copies when peers leave the network or demand goes down. This can be done by removing replicas with low access frequencies periodically. 5.3. Replication factor
Replication factor (RF) is a parameter calculated at each peer when the image response is propagated back to the requesting peer (only if the path is not having the amount of copies as required by the super-peer for increas-ing the availability of the object in the network). The RF algorithm runs parallel to the image request/response algorithm. The replication factor helps to locate the peer(s) to replicate the image. A constant size array is used to store RFs with their peer id X  X  on the request return path. The peers with highest RFs are marked in the return-ing message to replicate the image. We assume here that the return path is same as the query request.
Algorithm: 1. The query peer sends the request to the source with the replication permission (assuming that the permis-sion is granted by the super-peer). The search when finally reaches the target, has in the message header the number of existing replicas of that image available in the cache memory of nodes in that path. Note that this information is piggy back when a query is forwarded. While propagating, it also keeps on storing, in the message header, the summation of percentages of copies of the image (CP%) in that path. The target peer which satisfied the request calculates the average size percentage (AS%) of all the copies in the path and appends to the request reply message header. 2. If there is a replication permission granted with the request (provided by the super-peer with authentication certificate) and the number of existing replicas is less then the required number of replicas, on returning back, the replication factor is calculated for each intermediate node except at the nodes already having the copies. Refer to Fig. 6 , the light colored node is the requesting peer, dark colored node is the source peer and the replication factor is calculated at each intermediate peer between them. 3. Replication Factor at each peer is based on various parameters including memory, trust, bandwidth avail-able and the processing power. Replication Factor is calculated as follows: where k is the peer calculating the replication factor, PT is the peer trust value of the node k , M is the mem-ory available at the node k , S is the size of the requested image, BWavg is the average bandwidth at the node k , RPPS is the requests processed per second by the node k , MPPS is the message passing per second at the node k . Both of these values are average values.The message header maintains a sorted array of node-id X  X  and their respective replication factors. Every peer appends its RF while forwarding a message and inserts its node-id and replaces the lowest replication factor if its RF is more then the lowest value in the table so that the size of the array does not grow. 4. The message return header is as given in Fig. 6 where ID cation factors in sorted order with the Ids, and AS% is the average of percentages of copies in the path. 5. After receiving the request back, the requesting peer chooses between the replicating requested copy or its residue on the intermediate node with the highest replication factors based on the average image size per-centages (AS%). The size of the replication image is calculated as: 6. The requesting peer then issues the final request with the replication array information to the source peer with the residue/original size of the image to be replicated. On the returning path the image/residue is rep-licated at the designated peers given in the replication array.

The RF parameters are calculated as:  X  BWavg ( average bandwidth ): where n is the number of connections a node can have at any given time, and bw is the bandwidth between the current node and the node i , it is connected to.  X  RPPS ( request processed per second ): The number of messages passing this node per second.  X  MPPS ( message processed per second ): The actual number of images passed through this node during any query execution or answering a request during a given time period. 5.4. Trust values
Note that each peer periodically provides the feedback to the super-peer about the fate of their queries posed during the last period. Based on the feedback, the super-peer assign trust values to each peer. The super-peer in each group maintains a table listing the trust values of all the peers. The trust value is calculated using the adaptation of the algorithm given in [1] .In [1] , the authors propose a distributed reputation based trust management protocol, but in our case the trust values are populated at the super-peers only so we do not need the distributed algorithm for confirming the reputation of the peers. We only adopt the algorithm for maintaining trust values using binary vectors known as trust vectors . The super-peer maintains a trust vector for all the peer nodes responding to queries under it. trust vector is of constant length (typically 16 or 32 bits) binary vectors of l bits. One bit represents a successful transaction and 0 an unsuccessful transaction. An inte-written at the most significant bit, shifting the present bits to the right ( Fig. 8 ).

A trust vector with m significant bits is read as an m -bit integer and divided by 2 scalar trust rating in the 0 X 1 interval. For example, the trust value for the above example will be calculated as The super-peer maintains a table ( Table 1 ) for storing the trust values and vectors of the peers in the group.
Periodically, based on queries (successful or unsuccessful) between the peers, the requesting peer recom-mends to the group super-peer which then update the trust values. 5.5. Ada-Rep using flooding
The key point to note in the flooding algorithm is that the super-peer is only used to evaluate the trust val-ues of the peers under it and assign replica permission to the request based upon the availability of each object.
Algorithm steps : 3. The super-peer then replies to the requesting peer with authentication certificate and the replication out-4. After receiving the reply from the super-peer, the peer P 5. The request is propagated to all the nodes in that group with following conditions: 6. After receiving the request and authenticating it with the information provided in the certificate, the 7. P s , the source peer then replies to P r , the requesting peer with: ( P 8. After receiving all the responses, P r calculates the transmission cost ( C 9. For all the responses, P r now calculates the total time to get the image as: C 10. Now the requesting peer P r calculates the transcoding cost C 11. For the image reconstruction the peer needs to calculate the appropriate a and b pair of images. Then 12. If C ab &lt;( C r and C s ) then reconstruct the image 13. After receiving the image from peer P s , the requesting peer P 5.6. Ada-Rep using multicast
Apart from the tasks performed by the super-peer in the flooding algorithm, here the super-peer also main-tains the transaction record of all the peers in its group. This algorithm provides more centralized control over content distribution in the network. Its centralized control makes sure that a peer only gets the resource that it deserves. The target peer ids for the request are supplied initially by the super-peer only.
Algorithm steps : 10. For image reconstruction the peer needs to calculate the appropriate pair of a and b pair of images. Sort 11. If C ab &lt;( C r and C s ) then reconstruct the image 12. After receiving the image from the peer P s , the requesting peer P 5.7. Application example
The basic difference between both the schemes is the initial knowledge about the target peers to the request-ing peer. The initial operation of the algorithms is different but rest of the algorithm operates almost in the same fashion. We will discuss the algorithm using Flooding to illustrate the steps of our algorithm. Note that reduction in the size of pixels and the image size used in this example has no relationship except saying that reduced pixel size will reduce the size of the image.

Flooding scheme : Refer to Fig. 6 for example of the flooding scheme algorithm. Let node 0 is the super-peer of the group and the node 6 is the requesting peer. The algorithm works as follows.  X  The node 6 ( P r ) sends the request for image I r to the group Super-peer node 0 ( Fig. 9 ).  X  The super-peer then replies to node 6 with the image quality permission of 70% with the authentication cer-tificate (so that the nodes without any common key just forward this request to the next node). The node 6 then floods the request for the image I r into the network ( Fig. 9 a) where Flooding is being shown by the dotted line. Let the original image size and resolution is 50 kB and 150  X  150 pixels, respectively.  X  The request then propagates to all the nodes and the nodes with the image are ready to respond back to the requesting peer ( Fig. 9 )[ Refer to the step 5 in the algorithm ].  X  All the nodes reply to the requesting peer with the information about the image as ( P to the step 7 of the algorithm ] so the requesting peer has all the requests as:
Transmission cost from all the nodes is also updated when the responses are received back ( Fig. 9 ).  X  For all the responses, node 6 ( P r ) now calculates the total time to get the image as C  X  Now the requesting node 6 ( P r ) calculates the transcoding cost C at peer P s with least C Total . Let the transcoding cost from 100% to 70% quality for node 6 be 3 s. So, C getting the image from node 0 (with minimum transmission cost) and transcoding at the source peer will be 7.5 s + 3 s = 10.5 s [ Refer to the step 10 of the algorithm ].  X  For the image reconstruction, node 6 needs to calculate the appropriate pair of a and b pair of images and then sort the peers with a and b in ascending order of transmission cost in lists L ( a ) and L ( b )as  X  Now as requested resolution is greater than 50% (i.e., IR sponding b in L ( b )as L ( IR s a ) with minimum total cost, e.g., node 5 has 20% of a so we search for
L (70 20), i.e., 50% of b image. Here we find the 50% of b at nodes 9 and 3 but the total transmission cost from node 9 is lower than that of node 3, so the node finally decides to reconstruct the image from a and b images from nodes 5 and 9, respectively [ Refer to the step 11 of the algorithm ].  X  Comparing all the costs [ Refer to the step 12 of the algorithm ] C structed from a and b images ( Fig. 9 ).  X  Finally the trust values of nodes 5 and 9 are updated at the group super-peer ( Fig. 9 ). 5.8. Replication factor calculations
As discussed in Section 5.3 , the replication factor ( Fig. 7 ) is calculated at each intermediate (except the nodes which already have a copy of the image) node as
Let the size of the requested image be 50 kB and only one more replica is required in the path (as decided by the super-peer), so the RF Array size in message header will be one element. Consider the example in Fig. 6 , where node r is the requesting node and n be the final responding node. The replication factor at each node is also dependent on the load on the peers between that node and node-id n . As the image is not to be replicated at node n , the next node will calculate its RF value and add it to the RF array in the message header. Suppose the average bandwidth (BWavg) at next node be 80 kbps, RPPS = 5 and MPPS = 20. So the replication factor will be calculated as
This replication factor value is updated or replaced (if array is full and the current RF value is greater then the lowest RF value in the array) in the RF Array in message header and sent to the next node. Now consider that the next node 2 only left with 200 kB of the memory and the BWavg at the next node be 50 kbps with
RPPS = 6 and MPPS = 15. The Replication Factor will now be the Replication Factor (at node 2) = 0.5 * (200 kB/50 kB) * 50 * (6/15) = 40. This time the RF is very less compared to the previous node 1, so the RF of the previous node is not replaced from the message header array and passed to the next node 3. Let the Trust Factor of the node 3 be 0.8 and the BWavg at next node be 100 kbps with RPPS = 8 and
MPPS = 20, the RF will be then equal to the replication factor (at node 3) = 0.8 50 kB) * 100 * (8/20) = 384. Now the replication factor is higher than the one in message header array so it is replaced by the new RF and sent to the next node. Thus, the RF is calculated at each node and replaced if it is the lowest value in RF Array with the current load summation on the communication link. 6. Simulation
In this section, we present the simulation results to evaluate the performance of the proposed methods and compare them with some existing protocols. We assume here that once the route is found after that message lost and transmission of image failures are neglected in all the experiments. We believe these are more net-working issues, but may have an impact on the applications. 6.1. Simulation environment
We have built an experiment environment to perform a simulation study for the two search and replication schemes discussed in Section 5 and their comparison with some other models. The nodes move according to
Random waypoint model [13] . Node movement is used to track the query failure rate during the replication scheme simulations. The simulation area is about 1000 m  X  600 m. The average distance between the boundary peers and the super-peer can be 5 X 10 hops. The radio communication range of the mobile peers is a circular region of 100 m radius. The data objects are randomly generated at nodes initially with random sizes ranging from 50 kB to 500 kB and thereafter, a random request generator function is used to generate requests. Table 2 lists the various parameters used in the simulation. Simulations were conducted using synthetically generated
Zipf-like document popularity distributions to model client requests [16] . Zipf X  X  law states that the size of the r th largest occurrence of the event is inversely proportional to its rank r : where a (alpha) is close to unity, and N is the number of distinct occurrences of an event. Under a Zipf-like distribution, the probability of requesting the i th most popular document is given by:
Zipf distribution is characterized by a , N ,and K . In this document, we will refer to N as the number of image objects in the distribution, K as the frequency or popularity of the most frequently occurring object in the distribution, and a as the relative popularity of objects in the distribution. For our experiments we gen-erated a set of 100 queries based upon Zipf distribution of 50 ( N ) image objects with the frequency of the most popular image K = 15 and relative popularity a = 0.7. Fig. 10 shows the pivot chart for Zipf image distribu-tion. The queries are generated at random nodes and the image id is picked randomly from the pool of Zipf distributed image copies.
 6.2. Simulation results Experiments are conducted to evaluate the performance of search and replication schemes separately. Searching schemes are compared based upon the average response time and traffic to get the desired objects.
Replication schemes are compared on the basis of increase in replica count, average response time, memory usage, number of hops and failure rate. Ada-Rep replication scheme is compared with the base replication scheme where copies are made only at the peers requesting the objects wherein Ada-Rep intermediate node replicas are created to optimize the average response time and traffic load. Scalability is also shown for rep-lication schemes for increasing number of queries and network sizes. 6.2.1. Flooding and multicast comparison
Flooding and multicast are two commonly used techniques for search in ad-hoc networks. We have com-pared them in our hierarchical P2P network scenario. We have compared the two schemes based upon the average response time and network traffic generated by the queries excess to the base case. 6.2.1.1. Flooding and multicast average response time. In both the algorithms, the flooding is used once to find the targets. In case of the flooding, the message is flooded to find all the nodes having the target image but in multicast the target node ids are already available and the search is carried out for only one or two nodes. The tions) in the graph (network). The difference is there due to waiting time for all the responses to come back.
Multicast has to wait only for the specified node reply whereas the Flooding waits for a constant time until all the replies are submitted back.

The average response time ( ART ) is calculated starting from the initial time when the query is submitted till the final response if received with the image from the target node. This also includes the responses from multi-ple nodes in case an image is generated by combining fragments.
 where T s is the initial query request sent to the super-peer for authentication, T 10 consecutive queries).

Fig. 11 shows the comparison between the average response time of both algorithms compared with the base case of one-to-one transfer assuming that route to the target node id as already known and no extra pro-cessing is required. The readings are taken as an average of every 10 consecutive queries ( N nodes are randomly scattered and the image request and size is randomly chosen, the graph shows variance in the response time after average of every 10 queries.
Observing the difference between the base case and Multicast algorithm, we can infer that the compara-tively small difference is due to the extra cost of sending messages to super-peer and transcoding the images to the required size. The average difference in the readings of base case and multicast is 1.1 s but the average difference between the flooding and multicast is 2.11 s. This clearly shows that multicast performance is closer to the base case and comparatively better than the performance of the flooding algorithm. 6.2.1.2. Flooding and multicast network traffic. Network traffic ( NT ) is the total number of messages trans-ferred in the network for each query. For a uniform reading, we took average of total messages for every 10 consecutive queries same as in ART . The message count is started from the first query sent to the super-peer until the final reply from the target node or multiple nodes in case of fragments. As a base case for the comparison, we use one-to-one image transfer assuming that the initial peer knows the route to the target peer.

Fig. 12 shows the results from the network traffic comparison among the flooding, multicast and one-to-one algorithms in a network with 85 nodes and approximately 280 connection links between them. The difference in traffic is evident because of the number of nodes replying back in each algorithm. In the case of Flooding, all the nodes with images reply back which may increase with increased replication, but in multicast only one or two nodes reply back at the most in any case, thus generating comparatively much lesser traffic than the flooding. In the above simulation it is clearly evident that after a run of 200 queries, the average number of messages for flooding is 140 approximately whereas for multicast it is 90. On an average a difference of approximately 50 messages comes for each query in both the algorithms. 6.2.2. Ada-Rep and base replication scheme comparison
We examine the Ada-Rep and Base Replication schemes based upon the popularity of the image. The rep-lication is done using the square root replication technique discussed in Section 5.2 which ensures that the pop-ular items are replicated more than the less popular ones. All the results are compared for individual images sorted on X -axis in descending order of number of requests (popularity) by using Zipf factor. The Zipf factor is plotted on secondary Y -axis to show the decreasing popularity of image objects.

As all the simulations are performed using random size images and nodes, the graph shows variation in values for each individual image readings. Sometimes the requests having replication permission also cannot replicate because of unavailability of appropriate node in the path. 6.2.2.1. Ada-Rep and base replication replica count. With the increasing popularity and demand of the objects, more replicas are created to economize the request turnaround time and increase the availability of the objects.
Fig. 13 shows the increase in replica copies with the increase in popularity based on Zipf factor plotted on secondary Y -axis.
As evident in Fig. 13 the difference in the count of copies is more when the image is more popular, this is shown by the difference between the initial count and the replica count in both the schemes. The difference between the Ada-Rep and base replication schemes is also more with the increase in demand and runs almost constant with the decreasing popularity.

Fig. 14 shows the increase in replica count using the Ada-Rep compared to the base replication scheme with the increase in the number of queries. After a run of 400 queries, the Ada-Rep shows a replica count increase of 33% over the base replication strategy. Ada-Rep thus increases the number of copies of different granularity in accordance to the demand and available resources in the network than the base replication. 6.2.2.2. Ada-Rep and base replication average response time. The average response time ( ART ) is computed individually for each image. The value of average response time varies for random image sizes. The average response time for each image ( i ) is computed as where T s is the initial query request sent to super-peer for authentication, T back to it for each query k , and N is the total number of queries issued for each image i .
Fig. 15 shows the result of the average response time comparison between the Ada-Rep and base replication schemes. The Zipf factor of popularity is plotted on the secondary Y -axis. The unevenness in the ART reading is due to the random image size request issued by random nodes. The graph shows that the ART for more popular items is comparatively lower then the ART of less popular ones justifying the purpose of the square root replication technique. This is the main trade-off discussed in this paper.

Fig. 16 shows the result of average response time behavior with increasing number of queries. The average reading is taken at an interval of 25 randomly generated queries with random image size in demand. As the queries and each required size is randomly generated, there is an uneven variation in the readings of the two consecutive intervals. The ART for the Ada-Rep constantly stays lower then that of the base replication scheme. The graph shows a slight decline in the ART with increasing amount of queries because of more cop-ies available in the network and the decline is more in case of the Ada-Rep as it optimizes the number of copies required.

Fig. 17 portrays the increase of ART with the increase in the number of nodes in the network. With more peers in the network, the network is more widespread and consequently, more number of hops required for reaching the target peers. With Ada-Rep, there is intermediate node replicas which minimize the ART com-pared to the base replication scheme. The average response time is decreased with the increase in nodes since the query brings the images of the appropriate sizes as desired from a single or close by multiple nodes rather than from a single node as in the case of base replication. These three experiments prove that Ada-Rep provides an efficient replication scheme for improving the
ART. In an average case, the Ada-Rep scheme helps in reducing the turnaround time and therefore, it increases the image availability. 6.2.2.3. Ada-Rep and base replication memory usage. Memory usage comparison is done based upon the qual-comparison is done among the base replication, Ada-Rep and uniform-replication schemes. In the base rep-lication no intermediate node copy is made, Ada-Rep uses the square root replication technique as used in the previous experiment and the uniform replication is like Ada-Rep but it replicates full size images instead of the requested sizes. Fig. 18 compares the various replication schemes based on the memory usage. The initial memory distribution is shown for increase in the memory usage based upon the image popularity. The image popularity is plotted by the Zipf factor on secondary Y -axis.

The results clearly signify the increase in memory usage with more popular replication of the images. The difference between the initial size and the various replication schemes is more for the popular items and remains almost constant for the less popular ones. On the average, the difference between the base replication and Ada-Rep schemes is lower than the difference between the Ada-Rep and uniform-replication schemes. In the graph, the average difference between the Ada-Rep and the Base Replication is 800 kB where as the dif-ference between the Uniform and the Ada-Rep is 1600 kB which is almost double of the previous difference.
The difference is lesser in the first case of Ada-Rep because of the lower resolution (adapted) copies made com-pared to the original size replicas made in the Uniform Replication in the second. This implies that the Ada-
Rep scheme is closer to the Base Replication which clearly signifies that Ada-Rep is significantly better than the Uniform-Replication and more adaptive than the base replication to increase data availability and repli-cate images according to demand and resource availability. 6.2.2.4. Ada-Rep and base replication hop count. Hops are counted by adding the number of hops required to bring the image from the target peer (or combining residues to construct an image) to the source peer. Hops are counted one way only. Fig. 19 shows the comparison between the hop counts by the Ada-Rep and base replication schemes in a network with 85 nodes and approximately 270 connections between them. The irreg-ularity in the graph is due to the random query and image size generation. Average hop count is taken after every 20 queries.

With the increase in the number of copies/replicas of images, there is a decline in the number of hops required to get or construct an image. The hop count goes on decreasing with time, as increasing number of queries increases the number of replicas. The decline in hop counts for Ada-Rep is faster then the base rep-lication due to extra replicated copies. 6.2.2.5. Ada-Rep and base replication failure rate. This experiment is conducted with moving the nodes using
Random waypoint model [13] . At any instance on time there are 10 X 20% of nodes moving in the simulation area. Failure rate is counted as the number of unsatisfied queries due to moving nodes for Ada-Rep and base replication. This comparison shows the increase in data availability due to replication. Fig. 20 plots the increase in query failure count with the total count of queries issued in the network. Failure count is taken after every 10 queries issued.

Ada-Rep shows a much lower failure rate with increasing amount of queries compared to the base repli-cation scheme. Initially the failure rate is the same until there is enough data available. With increasing num-ber of queries failure rate shoots higher for base replication scheme because the less replicas in the network and consequently the poor data availability rate. Ada-Rep shows a significant decrease in failure rate com-pared to base replication over longer period of run. Due to initial failure rate in base replication scheme, less number of copies and replicas are made wherein Ada-Rep creates replicas with regular copies which increase data availability at a higher rate than base replication scheme eventually leading to less query failures over a longer run.

Ada-Rep shows a much lower failure rate with increasing amount of queries compared to the base repli-cation scheme. Initially the failure rate is the same until there is enough data available. With increasing num-ber of queries failure rate shoots higher for base replication scheme because the less replicas in the network and consequently the poor data availability rate. Ada-Rep shows a significant decrease in failure rate com-pared to base replication over longer period of run. Due to initial failure rate in base replication scheme, less number of copies and replicas are made wherein Ada-Rep creates replicas with regular copies which increase data availability at a higher rate than base replication scheme eventually leading to less query failures over a longer run. 7. Conclusions and future work
In this paper, we propose a hierarchical peer-to-peer network model for replication of image fragments of different resolution. The proposed model adapt constraints such memory and load available at each node in the query path while replicating. In addition, it finds the peer which should ideally replicate the image and then determines the correct resolution with respect to the available resources to maintain the response time and throughput at the desired level. It also exploits the fact that images can be segregated or recombined to form various other resolutions required by wide-ranging small devices. Replication of images with different resolu-tion also addresses the fact that mobile devices have different configuration and requirements based on the application environment. Our experiments clearly indicate that our partial object replication works better then the uniform object replication strategy in reducing the memory usage and request turnaround time. Our model also helps in reducing the failure rate and hop count to acquire an image in comparison to base replication method. As a future work, we are exploring a prototype implementation of the model; however, the simulation environment is the fastest way and cheapest way to do experimentation [17] .

References
