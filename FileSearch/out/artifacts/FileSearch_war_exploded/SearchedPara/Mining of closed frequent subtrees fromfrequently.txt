 Graduate School of Informatics, Kyoto University, Kyoto, Japan 1. Introduction and motivations
In this paper, we examine a mining problem, called incremental tree mining. Tree mining, an exten-the web and XML data [1], graph database indexing [23,25], and marketing channel management [20], tree mining has attracted noticeable attention from researchers in the data mining community. There have been several ef fi cient algorithms proposed in the previous works, see for example, [4,11,14,17]. limitation in application fi elds where the data increase continuously as the time moves on. For exam-ple, an online shopping website where browsing behavior of each user is produced in the form of trees may be browsed by hundreds of people every minute. In such situations, it is undesirable to mine the incremented databases from scratch, and so naturally, an incremental mining algorithm which reuses the results of past minings to minimize the computation time should be adopted.

This paper develops an incremental mining algorithm for closed frequent labeled ordered trees. Closed with their exact support count given the set of all closed frequent subtrees. By imposing closure, the number of frequent subtrees is heavily reduced. As a nice side effect, the user is mainly interested in the closed subtree set only. A downside, however, is that mining closed frequent subtrees brings more challenges than mining just frequent subtrees, especially in the incremental setting.

After a careful survey of the previous work, we found that the essential technique used in many for example [5,8,13]. In case of closed subtree mining, this technique could not be applied effectively expensive due to the tree inclusion checking problem. We, instead, adopt a divide-and-conquer strategy and treat each kind of new emerging closed subtrees differently based on their own characteristics. The key point of our algorithm is that it requires no additional scan of the whole database. Besides, the memory for keeping information from previous mining iterations is still reasonable even for very low minimum support thresholds. 2. Related work
Various mining algorithms have been proposed for free trees [10], ordered trees [3,4,11,21], and un-work. In [21], a candidate ( k +1) -subtree is generated by joining two frequent k -subtrees with k  X  1 nodes in common. Asai et al. [4] use the rightmost extension technique which generates subtrees of size k +1 from frequent subtrees of size k by adding nodes only to the rightmost branch of the tree. This technique is contemporarily developed by Zaki [21] and adopted by many others, for example [3,11,24]. There are algorithms which use different techniques other than the rightmost extension technique. thors use the divide and conquer strategy which recursively projects the database to generate frequent subtrees.

All above-mentioned algorithms are for mining from labeled trees . A labeled tree is a tree in which each node is given a unique label. In some cases, the trees are unlabeled. Balc X zar et al. [6] propose an algorithm for mining closed rooted unlabeled subtrees which is useful in applications such as the from unlabeled trees.

Although there are pl enty of work in literatures for tree mining, very few work have been proposed for the problem of incremental tree mining up to now. The reason may partly be the complexity of this problem. The main challenge here is how to achieve fast response time, even real-time response in some strict scenarios, with reasonable memory space usage. Asai et al. [5] introduce an online algorithm for mining tree data streams, but their problem settin g in which data arrive continuously node-by-node may of transactions over the time. Further, only approximate answers are returned and no accuracy guarantee an incremental mining algorithm for frequent unlabeled rooted trees. After computing the set of new closed subtrees of the additional batch, the algorithm checks the subsumption of every subtree of the new detected closed subtrees against all closed subtrees mined in the previous run. In mining labeled rooted trees, the number of closed subtrees is often many times bigger than that of the unlabeled cases and the subsumption checking for labeled trees is also often much more expensive than the subsumption checking for unlabeled trees. These obstacles make the method proposed in [7] not suitable when applied to labeled trees.

The rest of the paper is organized as follows. Section 3 formally de fi nes the problem of incremental closed subtree mining. Section 4 describes the new incremental algorithm. Section 5 reports the experi-mental results. Section 6 concludes the paper. 3. Preliminaries In this section, we introduce the notations and concepts used in the remainder of the paper.
Rooted labeled trees. Let  X = { l 1 ,...,l m } be a set of labels. A rooted labeled tree T =( V,E,r,L ) labelling function L : V  X   X  assigning a label L ( v ) to each node v of T .
 node v has no child, then v is called a leaf .
 included in T , denoted by S T , if there exists an injective mapping  X  : V S  X  V T such that 1.  X  preserves the node labels:  X  v  X  V S L S ( v )= L T (  X  ( v )) . 2.  X  preserves the parent-child relation: ( v 1 ,v 2 )  X  E S iff (  X  ( v 1 ) , X  ( v 2 ))  X  E T . 3. The left-to-right ordering among the children of a node v in S is a sub-ordering of the children of
If S T holds, then we also say that S occurs in T , S is a subtree of T , T is a supertree of S , sometimes called a pattern , and unless otherwise speci fi ed, a subtree means an induced subtree.
Suppose V S has k nodes which are indexed with numbers 1 , 2 ,...,k as v 1 ,...,v k .The total occur-T of S in T .

Support of a subtree and frequent subtrees. Let D denote a database of a set of transactions, where frequent in D if supp D ( t ) is greater than or equal to a support threshold msup D .Let 0  X  1 be a non-negative number called the minimum support speci fi ed by a user, we have msup D =  X   X | D | ,where | D | is the size of D .

Like the mining of itemsets, here the monotone property also holds that, for two patterns s and t , s t implies supp D ( s ) supp D ( t ) .
 t has.

Aclosedsubtreeasde fi ned above is closed unde r addition of node, that is, any a ddition of a new subtrees, and the support of t is equal to the maximal support of those closed subtrees that contain t . When we mine closed subtrees, we implicitly discard redundancies, and thus, make the task of the anlysis easier.
 Incremental mining problem. Suppose a set of new tree transactions,  X  , is to be added to the database D . The database D is referred to as the original database , the database  X  as an increment database , and the database U = D  X   X  as the updated database where  X  denotes the concatenation of two sets. given D ,  X  , and the minimum support  X  . We denote the set of all closed frequent subtrees mined from a database D as C ( D ) .

Figure 1(a) shows the original tree database D comprised of three transactions T 1 , T 2 ,and T 3 ,the U respectively, when  X  is set to 50%. The number in brackets denotes the support of a closed subtree. This example is used as a running example in our paper. 4. The mining algorithm
In this section we discuss a divide-and-conquer method for incremental mining of closed subtrees, where the set of closed subtrees will be divided into different non-overlapping subsets, each of which can be obtained independently by using its own characteristics and stored information from the previous mining iteration. 4.1. A divide-and-conquer solution The insertion of new transactions in  X  may give rise to new closed subtrees which never appear before. Some existing closed subtrees mined from D may have support count increased by  X  . There also are old closed subtrees which remain completely unchanged by the insertion of  X  . In general, we can divide C ( U ) , the set of all closed subtrees mined from U = D  X   X  , into two subsets as follows: the insertion of  X  .
 Proposition 1. It holds that C ( U )= C ( U ) |  X   X  C ( U ) | s .
 C c/ c proposition follows.
 the computation is still expe nsive because we s till need to scan th e whole database U . Our solution access to the database.
 none of their pre fi xes appear in C ( D ) as well. These subsets are formally de fi ned as follows: where t C ( D ) means that there exists a closed subtree c  X  C ( D ) s.t. t c , t C ( D ) if otherwise, and pre i ( t ) is the subtree containing fi rst i nodes in the pre-order traversal of t . In summary, we have length 3 of ct 2  X  C ( D ) ,and C ( U ) | r  X  =  X  . 4.2. Enumerating frequent subtrees
We adopt the rightmost extension technique proposed by Asai et al. [4] and Zaki [21] to enumerate frequent substrees. 4.2.1. The rightmost extension technique
A subtree t of size k is extended to a tree of size k +1 by adding a new node only to a node on the of t and a node to be added is called a rightmost extension of t .

Figure 2 shows the basics of the rightmost extension technique. The subtree t is extended in a bottom-occurrences of the rightmost node of t need to be stored because the occurrences of all other nodes on the rightmost path can be easily computed by taking the parent of the child on the rightmost path. t , we call a supertree t of t that has one more node than t an immediate supertree of t . The additional categories, the rightmost extensions and the free extensions as shown in Fig. 3.

By systematically enumerating all frequent subtrees starting from the empty tree ,an enumeration tree is formed. The complete enumeration tree for the database U = D  X   X  is shown in Fig. 4. 4.2.2. Delta frequent rightmost extensions
If we mine C ( U ) from scratch, for each subtree t , we have to consider every possible rightmost frequent extension of t .However,tomine C ( U ) |  X  , the number of possible rightmost extensions of a msup U . Here, t is called a candidate immediate supertree of t .

The  X  -frequent rightmost extensions of are frequent nodes that occur in  X  .InFig.4,  X  -frequent enumeration tree.

Nodes in  X  (considered as 1-subtrees) that are infrequent in D but become frequent under the insertion support counts of all nodes, both frequent and infrequent, of the original database D . We update these support counts each time when the increment database  X  is received.

We explain the computation of subsets of C ( U ) |  X  in the remaining of this section. We assume constant-time access to all parts of the database. More speci fi cally speaking, given an occurrence of time. 4.3. Mining C ( U ) | r  X  all infrequent nodes in D . When the increment database  X  is received, it is scanned once to update all those occurrence lists. New frequent nodes (nodes that are infrequent in D but become frequent in U ) now have enough information to grow until all the closed subtrees rooted at that nodes are discovered. 4.3.1. Pruning
The rightmost extension technique enumerates all frequent subtrees, however, not all of frequent sub-trees are closed, and many of them can be ef fi ciently pruned under the conditions as shown in the following proposition.
 occurrences of t ,then t together with all the descendants of t in the enumeration tree can be pruned. enumeration tree. Therefore, t and all the descendants of t in the enumeration tree can not be closed because we can always add e f to t (or to the descendant of t ) to form an immediate supertree with the same support. We can early prune some rightmost extensions of a subtree t as follows. Let us look at Fig. 2 again. returns candidate supertrees of a frequent subtree t with early pruning of some rightmost extensions. This function is also used in mining C ( U ) | o  X  and C ( U ) | p  X  with some modi fi cation. 4.3.2. Closure checking
A frequent subtree t which is not pruned can still be not closed. The following proposition, which also utilizes the notion of extensions, can be used to determine whether the subtree t is closed or not. Proposition 3. For a frequent subtree t , if there exists an extension e of t such that e occurs at all transactions of t ,then t is not closed, otherwise t is closed.
 Proof. Let t be the immediate supertree obtained by adding e to t .If e occurs at all transactions of t does not exist a supertree of t that has the same support with t , and thus t is closed. by Proposition 2 (at every occurrence of t 8 , there is a root extension with label E ). 4.4. Mining C ( U ) | o  X  For a frequent subtree t such that t C ( D ) , we denote by C ( D ) | t the set of closed subtrees in C C t re-scan the original database D .

For example, we can use ct 2 , ct 3 and T 4 to grow the subtree t 3 in Fig. 4. We have supp U ( t 3 )= supp D ( ct 3 )+ supp  X  ( t 3 )=3+1=4 . Similarly, to grow t 13 , only ct 2 and T 4 are enough. 4.4.1. Pruning We can still apply the pruning t echnique of Proposition 2. If there exists a free extension e of t in C t C pruning is much faster than when we mine from D  X   X  . 4.4.2. Closure checking of t in D . We have the following proposition which is derived from Proposition 3.
 otherwise t is closed.
 compared with using the original database D . 4.5. Mining C ( U ) | p  X 
Only C ( D ) and  X  are not enough to compute C ( U ) | p  X  . Our solution is to use C ( D ) as a bridge to the original database D by keeping some additional information together with C ( D ) .Bythis,when of informations are kept:
Note that we do not store all the possible extensions themselves which can be very huge but only occurrences of nodes in closed subtrees which have potential extensions. However, an occurrence of a node may occurs in more than one closed subtrees that may lead to redundant computation. To avoid redundant, we use the following simple but ef fi cient solution.

Suppose that closed subtrees in C ( D ) are ordered by their generation times. For a node v of a closed kept in some closed subtrees generated before c . Now, suppose that we are growing a subtree t with C ( D ) | t = { c i c and there is no duplication among the groups. Here c i closed subtree c i same process to RE ( v ) .
 Suppose t is a child of a subtree t in the enumeration tree where t occurs in C ( D ) and t does not. Once the occurrences of the rightmost node of t in U are known, the occurrences of all nodes on the rightmost path of t can be easily computed. This means that we have enough information to grow t using the rightmost extension technique. 4.5.1. Pruning
We can still apply Proposition 2 to check whether t or any descendant of t can be pruned because this proposition does not require having the occurrences of all nodes of t .Thisiscalled partly pruning since we can compute free extensions for those nodes whose occurrences are known only. 4.5.2. Closure checking (at some nodes whose occurrences are known) that occurs at every transaction of t then t is not closed. test as follows.
 C of t in the enumeration tree then s is always generated before t due to the rightmost extension method. We use a hash-based technique to check the closedness of the subtree t . When a closed subtree c in C example of Fig. 4, t 20 is pruned and t 26 is detected as a closed subtree of C ( U ) | p  X  .
The fi nal algorithm, named ICTreeMiner (I ncremental C losed Tree Miner ) is summarized in Algo-increased by the insertion of  X  .Wehave DS = { t 7 } for our example. C ( D ) \ CS contains closed fre-Extend _ p (line 4 of Procedure Grow _ oDelta ) computes candidate intermediate supertrees of a subtree t using the complement information of C ( D ) | t .

We show in Fig. 6 the enumeration tree for C ( U ) |  X  by using our method. As can be seen from the the full database U .
 Algorithm 1 The ICTreeMiner Algorithm 5. Experiments In this section, we present experimental results on synthetic and real-life datasets. We compare IC-TreeMiner with CMTreeMiner, an ef fi cient static algorithm for mining closed frequent subtrees. All experiments are measured on a 2.4 GHz Intel Core 2 Duo CPU with 2 GB of RAM, running Windows XP.
 For synthetic dataset, we use the T 1 M dataset generated by the tree generation program provided by Zaki [21]. The tree generating algorithm fi rst generates a master tree based on parameters supplied by total number of nodes M =10 , 000 , the maximal depth D =10 , and the maximum fan-out F =10 . from the master tree by setting the parameter T , the total number of trees. In our experiments, we set T =1 , 000 , 000 .

For real-life dataset, we use the CSLOGS dataset 1 which contains web logs collected over a month in the CS Department at RPI. Each web log, represented as a tree, records the sequence of web pages that have been visited in a user session and integrates the website X  X  topological information. Since a same CSLOGS consists of 59 , 690 trees with total 772 , 188 nodes. There are total 13 , 361 unique web pages this dataset are 4 and 2 . 5 , respectively.

First, we evaluate the response times by varying the minimum support. For each value of the minimum support, we take the average value of 20 runtimes of ICTreeMiner. For T 1 M ,wetakeits fi rst 900 , 000 the rest of the T 1 M dataset whereas the incremental database  X  for CSLOGS has 500 transactions for each test. The performance results are shown in Fig. 7.

We can see that the proposed incremental algorithm ICTreeMiner is much more ef fi cient than the static of ICTreeMiner for T 1 M and CSLOGS . The second to last column shows the number of subtrees checked by the subsumption checking when mining C ( U ) | p  X  (line 5, Procedure Grow _ pDelta ). The last column Table 1 shows the memory usage for storing complement information of C ( D ) . Here we can see that the memory usage is not so big even for very low of minimum supports. However, the memory closed subtree is high.

Finally, we evaluate the scalability of our algorithm by varying the size of the database and fi xing the minimum support value. The values of the minimum support are 0 . 12% and 0 . 1% for T 1 M and CSLOGS , respectively. Each time the database is updated, we run CMTreeMiner from scratch. The per-size, but the incremental algorithm ICTreeMiner still slightly outperforms the algorithm CMTreeMiner that works in a static manner. 6. Conclusion
We have studied in this paper an important data mining problem called incremental tree mining. This problem setting is motivated by applications where data are presented as trees and the tree database is updated frequently by getting new tree transactions. We then propose an ef fi cient algorithm which follows the divide-and-conquer approach for this p roblem with the supposition that the change to the database is small each time the database is updated. We divide the search space for frequent closed growing and pruning techniques speci fi c to each subset which help to reduce the search space greatly. The running time of the proposed algorithm is thus reduced greatly compared with mining the whole database from scratch.

For future work, we would like to extend the proposed algorithm to handle other kinds of subtrees such as unordered and embedded subtrees. The incremental mining is closely related to online mining over a data stream which is a very important data mining problem with broad applications. Thus it is previously arrived transactions.
 Acknowledgment This work is partly supported by Kyoto University Global COE  X  X nformation Education and Research Center for Knowledge-Circulating Society X .
 References
