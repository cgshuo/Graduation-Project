 A linear classifier is a fundamental tool for many NLP applications, including logistic regression models (LR), in that its score is based on a lin-ear combination of features and their weights,. Al-though a linear classifier is very simple, it can achieve high performance on many NLP tasks, partly because many problems are described with very high-dimensional data, and high dimensional weight vectors are effective in discriminating among examples.

However, when an original problem cannot be handled linearly, combination features are often added to the feature set, where combination features are products of several original features. Examples of combination features are, word pairs in docu-ment classification, or part-of-speech pairs of head and modifier words in a dependency analysis task. However, the task of determining effective combina-tion features, namely feature engineering , requires domain-specific knowledge and hard work.

Such a non-linear phenomenon can be implic-itly captured by using the kernel trick. However, its computational cost is very high, not only during training but also at inference time. Moreover, the model is not interpretable, in that effective features are not represented explicitly. Many kernels meth-ods assume an L 2 regularizer, in that many features are equally relevant to the tasks (Ng, 2004).
There have been several studies to find efficient ways to obtain (combination) features. In the con-text of boosting, Kudo (2004) have proposed a method to extract complex features that is similar to the item set mining algorithm. In the context of L 1 regularization. Dud  X   X k (2007), Gao (2006), and Tsuda (2007) have also proposed methods by which effective features are extracted from huge sets of fea-ture candidates. However, their methods are still very computationally expensive, and we cannot di-rectly apply this kind of method to a large-scale NLP problem.

In the present paper, we propose a novel algorithm for learning of an L 1 regularized LR with combina-tion features. In our algorithm, we can exclusively extract effective combination features without enu-merating all of the candidate features. Our method relies on a grafting algorithm (Perkins and Theeiler, 2003), which incrementally adds features like boost-ing, but it can converge to the global optimum.
We use L 1 regularization because we can obtain a sparse parameter vector, for which many of the parameter values are exactly zero. In other words, learning with L 1 regularization naturally has an in-trinsic effect of feature selection, which results in an efficient and interpretable inference with almost the same performance as L 2 regularization (Gao et al., 2007).

The heart of our algorithm is a way to find a feature that has the largest gradient value of likeli-hood from among the huge set of candidates. To solve this problem, we propose an example-wise al-gorithm with filtering. This algorithm is very simple and easy to implement, but effective in practice.
We applied the proposed methods to NLP tasks, and found that our methods can achieve the same high performance as kernel methods, whereas the number of active combination features is relatively small, such as several thousands. 2.1 Logistic Regression Model In this paper, we consider a multi-class logistic re-gression model (LR). For an input x , and an output label y  X  Y , we define a feature vector  X  ( x,y )  X  R
Then in LR, the probability for a label y , given an input x , is defined as follows: where w  X  R m is a weight vector 1 correspond-ing to each input dimension, and Z ( x, w ) = P
We estimate the parameter w by a maximum like-lihood estimation (MLE) with L 1 regularization us-ing training examples { ( x 1 ,y 1 ) ,..., ( x n ,y n ) } where C &gt; 0 is the trade-off parameter between the likelihood term and the regularization term. This es-timation is a convex optimization problem. 2.2 Grafting To maximize the effect of L 1 regularization, we use the grafting algorithm (Perkins and Theeiler, 2003); namely, we begin with the empty feature set, and incrementally add effective features to the current problem. Note that although this is similar to the boosting algorithm for learning, the obtained result is always optimal. We explain the grafting algorithm here again for the sake of clarity.

The grafting algorithm is summarized in Algo-rithm 1.

In this algorithm we retain two variables; w stores the current weight vector, and H stores the set of features with a non-zero weight. Initially, we set w = 0 , and H = {} . At each iteration, the fea-ture is selected that has the largest absolute value of the gradient of the likelihood. Let v k =  X  X  ( w ) the gradient value of the likelihood of a feature k . By following the definition, the value v k can be cal-culated as follows, where  X  i,y = I ( y i = y )  X  p ( y i | x i ; w ) and I ( if a is true and 0 otherwise.

Then, we add k  X  = arg max k | v k | to H and opti-mize (2) with regard to H only. The solution w that is obtained is used in the next search. The iteration is continued until | v  X 
We briefly explain why we can find the optimal weight by this algorithm. Suppose that we optimize (2) with all features, and initialize the weights us-ing the results obtained from the grafting algorithm. Since all gradients of likelihoods satisfy | v k |  X  C , and the regularization term pushes the weight toward 0 by C , any changes of the weight vector cannot in-crease the objective value in (2). Since (2) is the convex optimization problem, the local optimum is always the global optimum, and therefore this is the global optimum for (2)
The point is that, given an efficient method to esti-mate v  X  can solve the optimization in time proportional to the active feature, regardless of the number of candidate features. We will discuss this in the next section. This section presents an algorithm to compute, for combination features, the feature v  X  largest absolute value of the gradient.

We propose an element-wise extraction method, where we make use of the sparseness of the training data.

In this paper, we assume that the values of the combination features are less than or equal to the original ones. This assumption is typical; for exam-ple, it is made in the case where we use binary values for original and combination features. Algorithm 1 Grafting
Input: training data ( x parameter C
H = {} , w = 0 loop end loop Output w and H First, we sort the examples in the order of their P by one. Let us assume that r examples have been examined so far. Let us define t = t where  X   X 
Then, simple calculus shows that the gradient value for a combination feature k , v k , for which the original features are k 1 and k 2 , is bounded be-low/above thus; t Intuitively, the upper bound of (5) is the case where the combination feature fires only for the examples with  X  i,y  X  0 , and the lower bound of (5is the case where the combination feature fires only for the ex-amples with  X  i,y  X  0 . The second inequality arises from the fact that the value of a combination feature is equal to or less than the values of its original fea-tures. Therefore, we examine (5) and check whether or not | v k | will be larger than C . If not, we can re-move the feature safely.
 Since the examples are sorted in the order of their P Therefore, many combination features are filtered out in the early steps. In experiments, the weights for the original features are optimized first, and then the weights for combination features are optimized. This significantly reduces the number of candidates for combination features.
 Algorithm 2 Algorithm to return the feature that has the largest gradient value.

Input: training data ( x ( i = 1 ,...,n , y = 1 ,..., | Y | ), and the param-eter C . Examples are sorted with respect to their
P t = 0 , H = {} // Active Combination Feature for i = 1 to n and y  X  Y do end for
Output: arg max
Algorithm 2 presents the details of the overall al-gorithm for the extraction of effective combination features. Note that many candidate features will be removed just before adding. To measure the effectiveness of the proposed method (called L 1 -Comb), we conducted experi-ments on the dependency analysis task, and the doc-ument classification task. In all experiments, the pa-rameter C was tuned using the development data set.
In the first experiment, we performed Japanese dependency analysis. We used the Kyoto Text Cor-pus (Version 3.0), Jan. 1, 3-8 as the training data, Jan. 10 as the development data, and Jan. 9 as the test data so that the result could be compared to those from previous studies (Sassano, 2004) 2 . We used the shift-reduce dependency algorithm (Sassano, 2004). The number of training events was 11 , 3332 , each of which consisted of two word positions as inputs, and y = { 0 , 1 } as an output indicating the dependency relation. For the training data, the number of orig-inal features was 78570 , and the number of combi-nation features of degrees 2 and 3 was 5787361 , and 169430335 , respectively. Note that we need not see all of them using our algorithm.
In all experiments, combination features of de-grees 2 and 3 (the products of two or three original features) were used.

We compared our methods using LR with L 1 regularization using original features ( L 1 -Original), SVM with a 3 rd-polynomial Kernel, LR with L 2 regularization using combination features with up to 3 combinations ( L ceptron with original features (Ave. Perceptron).
Table 1 shows the result of the Japanese depen-dency task. The accuracy result indicates that the accuracy was improved with automatically extracted combination features. In the column of active fea-tures, the number of active features is listed. This indicates that L 1 regularization automatically selects very few effective features. Note that, in training, L 1 -Comb used around 100 MB, while L 2 -Comb3 used more than 30 GB. The most time consuming part for L 1 -Comb was the optimization of the L 1 -LR problem.

Examples of extracted combination features in-clude POS pairs of head and modifiers, such as Head/Noun -Modifier/Noun, and combinations of distance features with the POS of head.

For the second experiment, we performed the document classification task using the Tech-TC-300 data set (Davidov et al., 2004) 3 . We used the tf-idf scores as feature values. We did not filter out any words beforehand. The Tech-TC-300 data set con-sists of 295 binary classification tasks. We divided each document set into a training and a test set. The ratio of the test set to the training set was 1 : 4 . The average number of features for tasks was 25 , 389 .
Table 2 shows the results for L 1 -LR with combi-nation features and SVM with linear kernel 4 . The results indicate that the combination features are ef-fective. We have presented a method to extract effective combination features for the L 1 regularized logis-tic regression model. We have shown that a simple filtering technique is effective for enumerating effec-tive combination features in the grafting algorithm, even for large-scale problems. Experimental results show that a L 1 regularized logistic regression model with combination features can achieve comparable or better results than those from other methods, and its result is very compact and easy to interpret. We plan to extend our method to include more complex features, and apply it to structured output learning.
