 The problem of storing, indexing and querying XML documents has been among the requirements on query flexibilities pose unique challenges to database indexing methods. 
XML documents are often modeled as a tree whose nodes are labeled with tags, are used as part of selection predicates. 
In recent years, many XML index methods are proposed. We classify them into the following three categories: One of the categories is the path index method, such as DataGuides[10] and Index Fabric[9]. Query with a path express has been one of the major focus of research for processing simple path expressions. But it can not well support twig query and query index too big to be efficient in query evaluation. 
Another kind of approaches is based on the join operation. A complex path expressions are found by directly accessing the index structure. All the other forms of among this kind of techniques. ViST[18] and PRIX[16] appeared in recent two years. They transform both the XML documents and query pattern into some kind of sequences. By performing sub-sequence matching on the set of sequences in the database to find the occurrences of the size of this structure could hardly be controlled very well. While the discontinuous results be manageable. iii) It can not well su pport unordered twig queries. In order to find unordered matches, extra queries must be taken. 
In this paper, we propose LMIX (Line Model for Indexing XML), a dynamic XML index method, which supports twig queries and queries with wildcards. According to the Line Model we design, we consider XML document as a line, and every elements of the document as the line X  X  segments. To query an XML document is to identify the corresponding segments. Using a range-based dynamic tree labeling scheme, each trie, and organize the range sets with B+-trees grouping by the node on the trie. Three operations are defined, which enable the range sets on the B+-trees corresponding to the trie to operate with each other. The final results of twig queries can be got through these operations directly. need to read the clustered blocks as a whole, which greatly decreases the disk I/O, and also allows for disk optimization. We only keep the raw path index, and use defined can be controlled at a proper level. Unlike the traditional join operation, whose worst-case time complexity is O(m*n), our operations are simple and have a worst-case time operations.) z We propose the Line Model (not Linear Model) for querying XML document. z We define three operations and the corresponding algorithms, whose worst-case z The most possible matched points are clustered in the index structure, which z Dynamic tree labeling scheme makes our index a dynamic one. An once-over z Through algorithm analysis and experiments, we demostrate that the processing introduce the dynamic tree labeling scheme and give the once-over index construction the paper and point out some future researches. querying XML document. In section 2.2 the structure of the trie and B+-tree we using procedure. 2.1 The Line Model for Querying XML XML can be viewed as a nested tree structur e. If we consider attribute nodes as sub-elements and the value of attributes as text nodes, then we have two kinds of nodes on the XML tree: elements and values. 
As shown in Fig.1(a), we consider the XML document as a line, and every according to the document order, to a well formed XML document, every element and value will get a range, which is a key pair like &lt;LeftPos, RightPos&gt;. 
To query an XML document is to identify the corresponding segments. As Fig. lines. We call this the Line Model for querying XML documents. 2.2 The Trie and B+-Tree Structure characters and values of attributes, we change them into some kind of mark, such as  X  X  X . This will greatly decrease the size of the trie. For every node on the trie, we put value and their range into B+-tree, using the value as key and range as data. 
With the techniques mentioned above, the trie structure can be kept in a relatively small size. Generally, we can put the trie structure in memory, while all the B+-trees on the disk. 2.3 Three Operations and the Algorithms In the following, we X  X l give the definitions of three operations. Definition 1: Operation CONTAINS: 
C=A CONTAINS B, if for any element &lt;l,r&gt;  X  C 1. &lt;l,r&gt;  X  A 2.  X  &lt;l X ,r X &gt;  X  B and &lt;l X ,r X &gt;  X  &lt;l,r&gt;. element of B. Definition 2: Operation CONTAINED: 
C=A CONTAINED B, if for any element &lt;l,r&gt;  X  C 1. &lt;l,r&gt;  X  B 2.  X  &lt;l X ,r X &gt;  X  A and &lt;l,r&gt;  X  &lt;l X ,r X &gt;. 
This operation means choosing all the elements of B, which at least is contained by one element of A. Definition 3: Operation UNION: 
C=A UNION B, if for any element &lt;l,r&gt;  X  C &lt;l,r&gt;  X  A or &lt;l,r&gt;  X  B. This operation means merging all the elements of A and B. following theorems can be obvious. Theorem 1: For range sets A, B on the B+-trees, If A is an ancestor of B on the trie then And for all the other &lt;l X  X ,r X  X &gt;  X  A, &lt;l,r&gt;  X  &lt;l X  X ,r X  X &gt;=  X  . 
This theorem means if A and B have ancestor-descendant relationship, then any element in B is contained by one and only one element of A. Theorem 2: For range sets A, B on the B+-trees, If A and B has no ancestor-descendant relationship then Any &lt;l,r&gt;  X  A,&lt;l X ,r X &gt;  X  B, &lt;l,r&gt;  X  &lt;l X ,r X &gt;=  X 
This theorem means if A and B have no direct ancestor-descendant relationship, any element in A doesn X  X  intersect with any element in B and vice versa. efficient. They are given as follows: Algorithm 1: CONTAINS Input: A &lt;a[i],b[i]&gt;, range set from B+-tree, ordered; Output: C &lt;e[i],f[i]&gt;, range set, ordered; k, the number of elements in C;
Function CONTAINS (a, b, m, c, d, n) j=0;k=0; return ; end function Algorithm 2: CONTAINED Input: A &lt;a[i],b[i]&gt;, range set from B+-tree, ordered; Output: C &lt;e[i],f[i]&gt;, range set, ordered; k, the number of elements in C;
Function CONTAINED (a, b, m, c, d, n) j=0; k=0; return ; end function Algorithm 3: UNION Input: A &lt;a[i],b[i]&gt;, range set from B+-tree, ordered; Output: C &lt;e[i],f[i]&gt;, range set, ordered; k, the number of elements in C;
Function UNION (a, b, m, c, d, n) j=0; k=0; return ; end function We shall briefly compare our operations with the traditional join operation.  X  Unlike join, whose worst-case time complexity is O(m*n), our operations is  X  Traditional join uses the structure information during the join, and discard the  X  Our operation can be applied to parent-child, ancestor-descendant or sibling 2.4 Query Processing In this section, we X  X l detail the procedure of query processing. In Fig.3, we show four through the three operations we defined. The path expressions for the queries in Figure 3 can be: Q1: /A/B/E , E is the output node for Q1; Q2: /A[./C/text()= X  X 4 X  X  , A is the output node for Q2; Q3: /A[./C/text()= X  X 4 X  X /B/D , D is the output node for Q3; Q4: /A/B/F | /A/C , C and F are the output nodes for Q4; means the range set corresponding to the value on the B+-tree of the path_expression . follows. Q1: S(/A/B/E), means the range set on the B+-tree corresponding to path  X /A/B/E X . 
Q2: S(/A) CONTAINS S(/A/C/text()= X  X 4 X ), means to find the elements among the range set on B+-tree  X /A X , which contain at least one element of the range set on B+-tree  X /A/C/text()= X  X 4 X   X . 
Q3: S(/A) CONTAINS S(/A/C/text()= X  X 4 X ) CONTAINED S(/A/B/D), means the ranges on B+-tree  X /A/B/D X , which are at least contained by one element of the range set of S(/A) CONTAINS S(/A/C/text()= X  X 4 X ). 
Q4: S(/A/B/F) UNION S(/A/C), means all the elements on B+-tree  X /A/B/F X  and  X /A/C X . From the above discussion, we can conclude the query procedures as follows: 1. Using the structure information in the XPath expression, transform the query expression into sets of the three operations. Generally, every branch of the query X  X  tree structure needs one operation. Use CONTAINS to connect the test branch, and 
CONTAINED to connect the ancestor-desc endant branches and UNION to connect sibling branches. expressions. We X  X l further discuss the processing of wildcards in section 4. 3. Retrieve the range sets on the corresponding B+-trees, and evaluate the operations. 
It should be noticed that some query optimization might be taken here. For example: reading all the ranges in the B+-tree and decrease disk I/O. And the order of operations provide an algorithm to automatically execute queries using these three operations. such that the containment property is satisfied. So, we can give the root node a range &lt;1,MAX_INT&gt;, and give the child nodes sub ranges of this maximal range, such that the sub ranges are disjoint and are completely contained in their parent node X  X  ranges. The containment property is recursively satisfied. allocation. We can get this information through the DTD or schema of XML, or/and through statistical analysis of existing XML documents. 
Assume we don X  X  have any information about the document to be indexed, which is demonstrates an example of dynamic range allocation. Suppose &lt;L,R&gt; is the range of allocated range. More formally, according to the above procedure, for a given node X, the index reconstruction. On the XML tree, attribute nodes and character nodes are destined to be leaf nodes. Since they won X  X  have any child nodes, we can give them a zero length range such as &lt;range, range&gt;. This will save the ranges of parent nodes. 
Using this dynamic tree labeling scheme, we can give the once-over index is the handle function for the SAX event of StartElement. The handle function for the SAX event of Characters is similar to the handle of attribute values. Algorithm 4: Once-over index construction Input: XML document to be indexed Output: the trie and B+-trees 
Function StartElement() P=P+(R-P)/k; end function insert it into the B+-tree (if insert); ii) find the range corresponding to the node, and delete it from the B+-tree (if delete). 
Unfortunately, as the number of nodes in the XML documents increasing, our labeling scheme may experience the problem which is called under-flow when the nodes in the XML document according to the statistical characters of the document. have a structural abstract, such as a DTD or schema, which is relatively smaller to the doing complex computation. wildcards as range query. But, in fact, due to the low disk I/O and low processing cost techniques. We implemented LMIX in C++ for XML indexing. The implementation uses the B+-tree API provided by the Berkeley DB Libr ary[17]. For comparison purposes, we also experiments on a Win2000 Server system with a 1.6GHz Pentium IV processor and 256MB RAM, 80G IDE disk. During the experiment, operating system X  X  cache effects are considered and eliminated carefully. For all the experiment, the buffer pool size was fixed at 200 pages. The page size of 8k was used. For our experiments, we use the datasets of public XML database DBLP[13], the XML benchmark database XMARK[19]. DBLP is widely used in benchmarking XML DBLP, XMARK is a single record with a very large and complicated tree structure. In algorithm, we also generated several datasets of different size using xmlgen[19]. 
We tried various kinds of queries on the DBLP and the XMARK datasets, and ascending complexity. The experimental results of these queries are summarized in Fig.5. 
Q1 is a simple path query, and there is no attribute values involved. For this kind of query, LMIX just retrieve the query results from the corresponding B+-tree. We without wildcards, this hindered the query performance to some extend, but due to the high efficiency of every single query , the totaling performance is still faster than the the complexity of these kinds of queries depend on the structure of XML documents. When there are wildcards ViST needs to search more points, and performance is not as good as corresponding expressions without wildcards. From the experiment results, performance is similar to ViST, and quite better than XISS. 
We carried out scalability tests of the proposed algorithms on the datasets generated with xmlgen[19]. The size is 58 MBytes, 131 MBytes, 232 MBytes, 349 size of query results often has great effects on the query performance. expensive join operations. We have shown that the processing cost and disk I/O cost of our index method is linearly propositional to the size of indexed documents and the demostrate the great performance benefits of our proposed techniques. the storage manager of the database system. In any case, searching the index proceeds system. How to improve the efficiency of this procedure has great effects on the query performances. Some clustered storage technique may be used according to the index structure and query patterns in the future. 
