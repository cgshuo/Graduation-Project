 1. Introduction
Control systems are expected to achieve different objectives at different times (e.g., production objectives, quality objectives, safety objectives). The achievement of these objectives relies on the services provided by the system components (e.g., sensors, actuators, process components). If a component fails, the system objectives can be compromised ( Staroswiecki and Gehin, 2001 ). For this reason, in order to meet the increasing demand for system safety and reliability, control systems are increasingly integrating fault detection and isolation (FDI) and fault-tolerant control (FTC) procedures ( Blanke et al., 2006 ).

FDI algorithms aim to detect and to localize the faults 1 as possible, in order to make decisions that will avoid their propaga-tion and their undesirable effects. They check the consistency of the real-time system operation observations using the available model-based or data-based knowledge. Venkatasubramanian et al. (2003a , 2003b , 2003c) have published a good review of the FDI methods, concerns the potential for the system to continue its operations with the required performances, despite component failures. FDI algo-rithms, being part of the information system of the supervised process, need information redund ancy, whereas FTC algorithms, being part of the decision and actuation system, need decision and actuation redundancy (i.e., the redundancy of the services that are provided to the users by the system components) ( Gehin and Staroswiecki, 2008 ).

Different approaches have been proposed for the design of FTC algorithms ( Blanke et al., 2001 ; Zhang and Jiang, 2008 ). In passive approaches, the controllers are fixed and designed to be robust against a class of presumed faults. In passive FTC, a system may tolerate only a limited number of faults, which are assumed to be known before designing the controller. The fault considered are time-varying processes or uncertain parameters in the system component models. Suppose, for example, that a pump is used to regulate the level in a tank and that a regulator is used to produce the pump control v ( t ) so as to obtain the pump flow Q  X  k where k v is uncertain (i.e., not well identified) or is time varying because there is a leak that depends on the pump X  X  rotational speed; thus, the delivered flow Q will not have the desired value.
In passive approaches, the controller parameters are adapted from an estimation of the value k v (adaptive control) or from a minimization of a predictive criterion (robust control). (Readers interested in passive FTC approaches can referred to Ioannou and Sun (1995) and Zhou and Doyle (1998) for a good introduction.
Readers interested in adaptive or robust control methods can refer to Liang et al., 2000 ; Ye et al., 2009 .) uses the available resources and both physical and analytical system redundancy to deal with unanticipated faults, either by selecting a pre-computed law, or by synthesizing a new one in real-time ( Niemann, 2005 ; Theilliol et al., 2008 ). After a failure, a part of the services provided by the system X  X  components may become unavailable and the overall system will work inade-quately, if, for example, a faulty sensor (resp. actuator) makes the plant partially unobservable (resp. uncontrollable). Objectives can be achieved, in spite of the faults, if at least one of two procedures  X  fault accommodation and system reconfiguration  X  can be used successfully. Fault accommodation relies on estimat-ing the variables provided by the faulty sensors; system reconfi-guration uses alternative actuators or sensors to provide services that are equivalent to the services previously provided by the failed components. System X  X  reconfiguration includes control reconfiguration: designing or the selecting a new law to control the new components implied in the new control loops ( Lunze et al., 2008 ).
 assumed to be non-failing, only system reconfiguration will be considered. More precisely, what is meant by reconfiguration in this paper is, despite faulty components, the possibility of: 1. continuing system operation without intolerable loss of 2. continuing system operation with reduced specifications, or 3. abandoning the mission while still avoiding disaster. algorithms under actuator faults ( Lunze, 2006 ; Tao et al., 2002 ;
Chen et al., 2002 ). But, in most cases, these approaches use the quantitative system behaviour model including, for example, the state and output equations in the time domain to select or redesign the input vector, the output vector, the control law and the set-point. But in the case of a complete failure of an actuator, the potential for the system to achieve its objectives has to be re-evaluated qualitatively before synthesizing of a new control law.
To express these possibilities in term of available or unavailable functions is a very precious understandable information for operators who supervise the system and who have to exactly know at each time what they can expect for this system. using a self-updating model and a model-checking technique. The idea is to provide the mechanisms to automatically calculate the real system model each time a fault occurs and then to evaluate whether or not this updated model will be able to achieve the system X  X  objectives. In computer science logic, model checking refers to a method for formally verifying that a model meets a et al., 2008 ). System specifications are expressed as temporal logic formulas, and models take the form of state transition graphs.
Efficient symbolic algorithms are used to test whether or not a given model satisfies the given specifications; if not, the algo-rithm generates a counterexample. By studying the counterex-ample, the source of the error in the model can be highlighted and the model corrected. Model checking has proven to be a success-ful technique to verify the requirements and design of a variety of real-time embedded, safety X  X ritical systems ( Havelund et al., 2001 ; Molnar and Veres, 2009 ). Its application to analysing the reconfigurability of a system is, we think, an original idea. Two parts can be distinguished: diagnosis and reconfiguration.
The diagnosis part aims to detect and identify faults. A fault is detected when the observations made on the real system are inconsistent with the prediction of the system model. A fault identification module is then run to identify the faulty component and its fault type (e.g., valve blocked in the open position or in the closed position for a valve). In the opposite case, the behaviour of the system is considered as normal (non-faulty), and the current system model remains valid. The reconfiguration part of our reconfigurable control architecture uses the result of the diag-nosis part to automatically calculate an updated model, using the real observations and the fault reports. If the faulty system, as it is described by its updated model, allows the system to achieve its specified objectives, the updated model becomes the new current system model. In the opposite case, the system reconfiguration is considered as impossible, and the system is shut down or placed to a safe state.

This paper focuses on the reconfiguration part, so the diagnosis part is not described. The diagnosis is assumed to be correctly performed by an appropriate procedure. The systems considered are continuous systems for which continuous variables are dis-cretised, and the faults are assumed to be permanent, not inter-mittent. The rest of the paper is organized as follows. Section 2 describes a system from a functional viewpoint. Section 3 presents our framework for generating a self-updating system model. Section 4 introduces the temporal logic used for describing system objectives and the model checking method used to automatically calculate reconfigurability. Section 5 presents the example used to illustrate the different notions. Section 6 provides our conclusions and some prospects for future research. 2. Functional viewpoint
Systems are built by connecting different components, which provide services to users ( Gehin and Staroswiecki, 2008 ). For example, a sensor provides a measurement service; a pump provides two services: delivering a flow and not delivering a flow; a controller provides a calculation service; and a tank provides a storage service. Lower level components (e.g., sensors, actuators, controllers and process components) are grouped to form subsystems in order to define higher level services. For example, a level sensor, a pump, a controller and a tank can form a single subsystem that provides a regulation service in which the con-troller uses the tank level provided by the measurement service to calculate the pump X  X  input control. The advantage of creating high-level components is to provide high-level services, which ends up in the overall system and its control objectives.
A service is described by the variables it consumes ( cons ), the variables it produces ( prod ), and a procedure ( proc ) that trans-forms the former into the latter. Services are derived from the component behaviour, which is governed by physical laws and (possibly) by embedded software. For example, a tank consumes input and puts out mass flows, and produces a stored mass, using is the flow in the input pipe, and q out is the flow in the output pipe. The procedure follows from the principle of conservation of mass. The regulation service of a controller consumes data provided by a measurement service and produces signals to an actuation service according to a specific algorithm.

Services describe what the user expects to obtain from a component or from a subsystem under normal operation. How-ever, there are two reasons for a given service s to fail to deliver the appropriate values of the variables it produces: Internal faults affect some resources ( res ) needed by the service.
As a result, the actual values of the produced variables ( prod ) are not those specified by the procedure ( proc ). A leak in a tank is an example of an internal fault. The procedure _ m  X  t  X  X  q in  X  t  X  q out  X  t  X  does not correctly describe the behaviour of a leaking tank since the flow associated with the leak is not taken into account.

External faults affect the inputs ( cons ) of the service. A level regulation service is subject to an external fault when the level value it consumes is false, due to the failure of the level sensor, or if its time stamp is outdated, due to a failure in the communication system.

Fault-tolerant components integrate multiple instances of the same service, listed as a set of versions. All versions of the same service produce the same outputs (so they can be interchanged), and at least one among the inputs, procedures and resources is different from one version to another. The different versions of this same service differ by their accuracy, running time and/or energy consumption, and they are ranked by the designer. When a service is requested, the version that is selected is the most preferred in that all the resources it needs are known to be non-faulty. The first version of this ordered set is named nominal version , and the other versions are degraded versions . The service becomes unavailable if there is not any version that allows it to be provided.

To take into account the unavailability of a part of the services associated to a component, the notion of operating modes is introduced. For example, three modes are associated to a valve: normal , blocked _ on , blocked _ off . In the non-faulty case, the oper-ating mode is normal . The valve _ open and valve _ close services are available. The operating mode of the valve is blocked _ on (resp. blocked _ off ) if the valve is blocked in the open (resp. closed) position, and only the service valve _ close (resp. valve _ open )is available. Due to the unavailability of a part of the system component services, the achievement of the nominal system objectives may become impossible. The designer may have to implement degraded objectives to increase the system X  X  fault tolerance capability. The system can in this case continue its operations with a reduced but tolerable performance. Never-theless, the normal system behaviour model is no longer valid. A new model has to be calculated in order to check whether or not the system can continue to meet its objectives. For this reason, in the next section, we propose a self-updating model mechanism that produces the real behavioural model of the system for each observation time. 3. The self-updating modelling
The paper focuses on faults corresponding to the complete loss of a service provided by an actuator. Because a fault of this type totally changes the system X  X  physical structure, the normal system behaviour model is no longer valid. Thus, a flexible system model mechanism is required to automatically update the system model. This mechanism has three parts: a database containing basic knowledge about the system, a procedure for identifying the current system state of the system, and an algorithm to auto-matically build the system model using the first and second parts. 3.1. Basic knowledge database
Basic knowledge is the knowledge required to infer the current system conditions and predict how the system will evolve. This information is the result of the functional analysis, especially the specification of the control objectives, which requires measure-ment, calculation and action services to give the process variables their expected values.
 More formally, let the basic knowledge be: Y the variable v j A V , C  X f c 1 , c 2 , ... , c m g , the system components, A used by a controller to modify the value of the variable v M j  X f m component c j , (i.e.: an observation atom is a possible value for a measured output or a control input).

Let D  X  S m x  X  1 M c x be the set of the diagnosis atoms (i.e.: a diagnosis atom is a possible operating mode for a component), where m is the number of components.
 A control action a is then defined by two elements: PC ( a )  X  a pre-condition that states which observation and diagnosis atoms must hold true before the running of the control action, EF ( a )  X  an effect, expressed as a variation direction for the controlled variable, that takes into account the variable X  X  initial value before applying the new control and the values of variables that influence the controlled variable. This effect determines possible values for the controlled variables as the result of the control action. 3.2. Current system state identification
The current system state is given by the subset of the observation and diagnosis atoms that hold true.
 an arbitrary number between 1 and the number of elements of the set Y v j , and y v j x v the part of the observation vector obtained from the sensor outputs.
 an arbitrary number between 1 and the number of elements of the set A v j , and a v j x v the variable v j  X  be the part of the observation vector obtained from the actuator inputs.
 an arbitrary number between 1 and the number of elements of the set M c j , and m c j x v  X  be the diagnosis vector. The components of this vector are determined by an appropriated diagnosis module which is not described in this paper but which is presented in Hu et al. (2009a , 2009b) .
 s 0  X  X  O Y  X  0  X  , O A  X  0  X  , D  X  0  X  X  components. 3.3. System modelling algorithm knowledge to determine the possible successor states from the current system state. It returns a graph G  X  S , T , s 0  X  as the updated model, where:
From the current state s 0 , the algorithm searches the control actions that can be applied to s 0 among the global control action set S n i  X  1 A i (i.e: the control actions in which s 0 verifies the pre-condition PE ). If such a control action a i is found, one or several new states are created (lines 6 X 7). All these states have:
The newly found states, if they have not already be found in a previous step, are added to the graph G  X  S , T , s 0  X  (lines 12 X 14). The search process then is iterated until no new state is found (lines 20 X 25).
 model is equal to: Q n j  X  1 9 Y v j 9 Q n j  X  1 9 A v j 9 used to express the cardinality of a set). But in reality, among all the possible combinations of variable values and control inputs only a few of them have a physical meaning. For example, a combination pump  X  on and valve  X  off is forbidden if the pump is at the input of a pipe where the valve is at the output. On the same idea a combination with a high liquid temperature and a low liquid level may be forbidden for security reasons. One of the key points of our algorithm is that it does not investigate all the potential states but that it only referees on the available control actions, that extremely limits the complexity. In every cases, the size of the generated behaviour model stays enough small to be easily processed by the classical model checking algorithms. Algorithm 1. Model Generation 1: S  X  f s 0 g , T  X  | , test _ states  X  f s 0 g , new _ list 2: while again do 3: for all s orig A test _ states do 4: for all i  X  1to n do 5: for all a i A A v i do 6: if s orig checks PC  X  a i  X  then 7: create a new state s dest such as: 11: y dest j checks EF  X  a j  X 8 j A  X  1 , n 12: if t  X  s orig , s dest , a i  X  = 2 T then 13: new _ list  X  new _ list  X f s g 14: T  X  T  X f t  X  s orig , s dest , a i  X g 15: end if 16: end if 17: end for 18: end for 19: end for 20: if new _ list a | then 21: test _ states  X  new _ list 22: new _ list  X  | 23: else 24: again  X  false 25: end if 26: end while 27: return G  X  S , T , s 0  X  4. Model verification 4.1. The model checking requirements The diagnoser identifies the current system state s 0  X  X  O O  X  0  X  , D  X  0  X  X  . According to Algorithm 1 , the successor states of the current system state can be predicted. A fault is detected when a discrepancy exists between the predicted behaviour and the behaviour really observed. The diagnoser X  X  aim is to detect the fault (i.e., a discrepancy exists), to locate the faulty component (e.g., the valve is faulty) and to identify the kind of fault (e.g., the valve is blocked in the open position). This allows the algorithm to update the component X  X  operating modes and the list of the available control actions to act on the process variables. The mechanisms on which the diagnoser is based are not described in this paper. Some ideas about building this diagnoser have been given in papers ( Hu et al., 2009a , 2009b ).

Once the updated model is obtained (by running Algorithm 1 with the new system conditions as input), the next step is to check whether or not the new model satisfies the system objectives. To this end, the model checking approach translates the updated system model into a labelled transition model, called the execution structure, on which the correctness properties, expressed as temporal logic formulas, are verified by means of specific algorithms ( Emerson, 1991 ; Clarke et al., 1999 ). The execution structure is, in our case, the updated model G  X  S , T , s 0  X  to which a finite set of logical atoms L  X  O is added.

More formally, the execution structure and a path in the execution structure can be described through the following definitions: Definition 1 ( The execution structure ). The execution structure is the state transition graph M  X  S , L , T , s 0  X  where:
L  X  O Y [ O A [ D is a finite set of logical atoms describing the possible values for the system inputs and outputs, and the possible operating mode for the system components,
S is the state set. Each state s A S is labelled with a set of atomic propositions L ( s ) which contains all atoms true in that state, which means that if p is an atomic proposition, then p is true at a state s if and only if p labels s (i.e. p is an element of L ( s )).
T is the transition set defined as for the system model G  X  S , T , s s 0 is the initial state.
 Definition 2 ( Path in an execution structure ). A path in an execu-tion structure M in an infinite state sequence p  X  s 0 , s starting at s i .

This execution structure can then check whether or not a system objective expressed as a sequence of events to observe by the mean of a temporal logic formula, can be achieved. This is the basic idea of the model checking technique. 4.2. The specification of system objectives
Many temporal logics have been defined and studied in the literature. In temporal logic, the truth values of a proposition are not always constant in time. Tempora l operators are used to express propositions such as:  X  X  X he level is always equal to 20. X  X ,  X  X  X he level valve is opened. X  X . Linear temporal logic (e.g., LTL Manna and Pnueli, 1992 ) reasons about only one possible future for the evolution of a property. Branching time logic (e.g., CTL Clarke et al., 1986 )assumes that a property might evolve differently in the future if there is an unpredictable environment. For example, such properties as  X  X  X here is a possibility that the level will decrease. X  X  can be used to express different future executions, by taking into account the fact we do not know whether or not the valve will ever open.

The systems we chose to study are partially non-deterministic since the effects of a control action are linked to the current state and system dynamic. Furthermore, these systems are not always designed to achieve the final objectives expressed as final states to be reached. Objectives may be expressed as potentially cyclic execution sequences, such as maintaining a property, achieving an objective periodically or within a number of steps after the request was made, or achieving several objectives in sequence. Branching time logic is quite appropriate for formulating such objectives and integrating the part of non-determinism since it allows the expression of multiple execution possibilities. As the system model is based on a state graph, a temporal logic that refers to  X  X  X tates X  X  rather than  X  X  X ctions X  X  (e.g., TLA Lamport, 1994 , ACTL De Nicola and Vaandrager, 1990 ) is preferable. For this reason, we chose the computation tree logic CTL n ( Emerson and Halpern, 1986 ) to formulate the system objectives.

Clarke et al. (1999) describe CTL n , and its use in model checking, model checking are reviewed below. Readers already familiar with these definitions and conc epts can skip directly to Section 5 .
Let P be the set of the atomic propositions and p A P an element of P . According to Emerson X  X  (1991) work, CTL n formulas are built from P using  X  X  X ath quantifiers X  X  and  X  X  X emporal operators X  X . Path quantifiers are used in a given state to specify that all or some of the paths starting at that state have certain properties. Two types of path quantifiers are possible:
A is a universal path quantifier, meaning that certain proper-ties hold true on all paths starting from a given state.
E is an existential path quantifier, meaning that certain proper-ties hold true on some paths s tarting from a given state. As temporal logic does not explicitly express time as quantity, five temporal operators are introduced to describe path properties:
X (next time) requires that a property hold true in the path X  X  second state.

F (eventually or in the future) is used to affirm that a property will hold true at some states on the path.

G (always or globally) specifies that a property holds true at every state on the path.

U (until) states that a property holds true if there is a state on the path in which the second property holds true and if the first property holds true at every previous state on the path.

R (release) requires that the second property holds true along the path, up to and including the first state in which the first property holds, although the first property is not required to hold true in the future.

TherearetwotypesofformulasinCTL n : state formulas ,whichare true in a specific state, and path formulas , which are true along a specific path. If f is a state formula, the notation M , s holds true at state s in the execution structure M . Similarly, if f is a path formula, the notation M , p F f means that f holds true along path p in M .Therelation F is defined inductively as follows (assuming that f 1 , f 2 are state formulas and g 1 , g 2 M , s F p 3 p A L  X  s  X  (p is true in the current state). M , s F : f 1 3 M , s j f 1 .
 M , s F f 1 3 f 2 3 M , s F f 1 or M , s F f 2 .
 M , s F f 1 4 f 2 3 M , s F f 1 and M , s F f 2 .
 M , s F E  X  g 1  X  3 there is a path p from s , such that M , p M , s F A  X  g 1  X  3 for every path p from s , M , p F g 1 M , p F f 1 3 s is the first state of p and M , s F f 1 . M , p F X  X  g 1  X  3 M , p 1 F g 1 .
 M , p F F  X  g 1  X  3 there is a k Z 0 such that M , p k F g M , p F G  X  g 1  X  3 for all i Z 0, M , p i F g 1 .
 M , p F g 1 Ug 2 3 there is a k Z 0 such that M , p k F g 0 r j o k , M , p j j g 1 .
 M , p F g 1 Rg 2 3 for all j Z 0, if for every i o jM , p i M , p j F g 2 .

Fig. 2 gives some examples of CTL n formulas. Each computa-tion tree has the state s 0 as its root ( Huth and Ryan, 2004 ). the system objectives may be split into different properties to checked. According the type of studied systems, such a classifica-tion may make appeared: reachability or liveness objectives, such as EF ( g ), which require that the system may be able to reach desired states where g holds true, and AF ( g ), which requires that the system will be for any engineer and brings him an important help to make sure nothing forgotten. He only has to check that all the constraints are correctly extract from the system requirements.
 system has, or does not have, to carry out its objectives, in faulty situations. The existence of solutions to continue the system opera-tion is based on the existence of multiple versions of the same service, which characterizes the s ystem reconfigurability property.
Since control actions are mode lled for different outcomes that cannot be predicted at the time of execution (i.e., it is impossible for the system to know a priori which of the different possible outcomes will actually take place), different reconfiguration results may be obtained. For instance, a reconfiguration might guarantee that an objective will be accomplished, or might just provide the results to be described and defined. For example, the strong objective
AF ( g ) means that the reconfiguration guarantees the accomplish-ment of the desired objectives, while the weak objective EF ( g ) expresses that reconfiguration only has a chance of success. which the objectives can be changed at the moment that the fault report is received. If nominal objectives cannot continue to be fulfilled, the solution of carrying out the degraded objectives has to be evaluated. For a desired property g , the temporal objective would be AG  X  g  X  (i.e., g always holds true) in the normal operating mode. If there is a fault that causes g to deviate from its desired value, then reconfiguration will correct this deviation and will keep g within its desired value range. But in a non-determi-nistic system, a control action sent by the reconfiguration proce-dure cannot be guaranteed to produce the desired effects (i.e., the original objective cannot be guaranteed). This situation can be described as EF  X  AG  X  g  X  X  , which means that g will eventually be accomplished in some future state from which g will be perma-nently maintained. However, this does not satisfy the require-ments of some high-security systems. Thus, EF  X  AG  X  g  X  X  must be changed into a strong solution, such as AF  X  AG  X  g  X  X  . If the execution structure satisfies the objective AF  X  AG  X  g  X  X  , then reconfiguration will be successful in spite of non-determinism. 4.3. The model checking
Let C be a objective expressed in CTL n logic. Let M  X  S , L , T , s the execution structure. The model checking task aims to deter-mine which states in S satisfy C . To accomplish this, the formula C is first decomposed into sub-formulas that make only the connectives : , 4 , ? , EX , EG and EU appear, using the following equivalences ( Clarke et al., 1999 ): AX  X  f  X  X : EX  X : f  X  .
 EF  X  f  X  X  E  X  trueUf  X  .
 AG  X  f  X  X : EF  X : f  X  .
 AF  X  f  X  X : EG  X : f  X  .
 A  X  fUg : E  X : gU  X : f 4 : g  X  4 : EG  X : g  X  .
 A  X  fRg : E  X : fU : g .
 E  X  fRg : A  X : fU : g .

The labelling operation is then p rocessed. This operation deter-This operation is repeated for each state of M ,startingwiththe smallest sub-formulas and working recursively towards C . Initially, label  X  s  X  is just L ( s ). The algorithm then processes the sub-formulas result is the set of states of the model that satisfy the formula. If this set includes the initial state s 0 ,then M satisfies C .
Some examples are given below to describe how states are labelled.

If C is: 1. ? : then no states are labelled with ? . 2. p : then label s with p if p A L  X  s  X  . 3. C 1 4 C 2 : label s with C 1 4 C 2 if s is already labelled both with 4. : C 1 : label s with : C 1 if s is not already labelled with C 5. EG  X  C 1  X  : 6. E  X  C 1 U C 2  X  already labelled with C 1 . 8. AF  X  C 1  X 
These eight sub-algorithms can be combined to deal recur-sively with the different formulas. For example, the verification of analysis of a system, this method makes it possible to determine whether or not a faulty system has the potential to continue its operation without intolerable performance losses or with reduced specifications. Let now apply the proposed methodology on a didactic example. 5. Example: the two tank system (TTS) 5.1. A description of our TTS
We chose the TTS to illustrate our method because this example (or similar ones) has been used to illustrate different approaches in fault diagnosis and fault tolerant control ( Blanke et al., 2006 ; related to a level-regulation process involving two identical con-nected tanks (see Fig. 3 ). The main objective of the TTS is to provide a continuous water flow Q O to a consumer via an outlet valve V located at the bottom of tank T 2 . To accomplish this objective, pump P fills tank T 1 up to a nominal water level of 50 cm. The flow in tank T is kept at a level of 10 cm via valve V 1 placed in tank T connecting pipe at level 30 cm. Valve V 2 , placed in tank T connecting pipe at level 0 cm, is always closed in the nominal case andisusedasabackupvalvewhen V 1 is faulty.

The nominal objective is to regulate the level in tank T 1 water level of 50 cm. In the case in which the nominal objective cannot be fulfilled, users accept a regulation to a water level just under the valve V 1 location (i.e., 30 cm). The available process measurements are the water levels l 1 for tanks T 1 , and l
T , given, respectively, by the sensors L 1 and L 2 . For the nominal case, a controller C 1 turns off the pump P 1 when l 1 is 50 cm (degraded case: 30 cm) and turns it on when l 1 reaches 45 cm (degraded case: 25 cm). Another controller C 2 turns on valve V (or V 2 )if l 2 falls to 9 cm and turns it off when level rises to 11 cm.
There were many reasons for ch oosing the TTS example for our paper, other than the one stated above. First, multi-tank systems are widely used in industrial domains as diverse as chemistry, produc-tion and power plants. Second, many physical processes include the inflow and outflow of materials and thus can be modelled by multi-tank systems. A complex system can be decomposed into many of these small basic systems for analysis. Third, this example allows us to specify nominal and degraded objectives and illustrates some interesting proprieties, such as the cycle execution and the non-determinism. In fact, the TTS regulation process requires a cyclic execution of services that makes it possible to increase the levels and then to decrease them. The flow between the two tanks varies according to the different water levels in each tank. Thus, during the regulation process, a single valve action results in different water level changes in each tank. This is a non-deterministic property that has to be formulated correctly. 5.2. The functional viewpoint
From the TTS description, the nominal control objective is  X  X  X o regulate the level in tank T 1 between 45 cm and 50 cm and to regulate the level in tank T 2 between 9 and 11 cm X  X . The degraded version of this objective is  X  X  X o regulate the level in tank T between 25 cm and 30 cm and to regulate the level in tank T between 9 cm and 11 cm X  X . Accomplishing this control objective relies on the services provided by the TTS components: the two valves V 1 and V 2 , pump P 1 , tanks T 1 and T 2 , sensors L controllers C 1 and C 2 . The sensor L i provides a measurement service: L i _ level . The valve V i provides two actuation services:
V _ open and V i _ close . The pump P 1 provides two services: P and P 1 _ close . The tank T i provides a storage service T controller C i provides a calculation service according a regulation algorithm. Several operating modes can be associated to the TTS components: f normal , non normal g for the tanks, the controllers and the pump. This functional analysis supports the definition of the system X  X  behaviour model. 5.3. The system model
The basic knowledge required by the TTS to infer the current system conditions and predict the system X  X  evolution is as follow: The list of the process variables to control is V  X f l 1 , l cannot fail. For this reason, they do not appear in the basic knowledge.
 level rises (resp. falls, keeps the same value).
 V 1 _ open :  X  J case : stuckC  X  P 1  X  J case stuckC  X  P 1  X  V 2 _ open :  X  J case : stuckC  X  P 1  X  J case stuckC  X  P 1  X  V 2 _ close :  X  PC  X  V 2 _ close  X  X  V 2 _ open 4  X  l 2  X  11  X 
EF  X  V 2 _ close  X  X  l 2 k 5.4. Generating the model
The system X  X  behaviour model can be automatically generated from the system X  X  basic knowledge and from the identification of the current system state. Suppose that the diagnoser identifies the system X  X  current state as: s 0  X f l 1 A 45 , 50  X  , l V _ open , ok  X  P 1  X  , ok  X  V 1  X g .

In this case, the system is not faulty since the diagnosis vector is D N  X f ok  X  c j  X 8 c j A C m . The corresponding system behaviour model is the normal behaviour model ( Fig. 4 ). This model can be automatically generated from s 0 by running Algorithm 1 . Algorithm 1 receives as input the state s 0 , denoted state 1 on the graph presented in Fig. 4 . Among the control actions in A [ A l 2 , only V 1 _ close has its pre-condition verified by s control action takes the place of V 1 _ open . The list of the input observation atoms of the successor states of s 0 is P 1 _ close , V The list of the output observation atoms of the successor states of s is obtained from the possible combinations of the effects of tain l 1  X  X  for P 1 _ close and  X  X  X o decrease l 2  X  X  for V graph given in Fig. 4 was found in this way. A state with l 1 A 45 , 50  X  , l 2 A 9 , 11  X  is not taken into account as such a state leads to no new control actions. Successors states from s determined in the same way. The system model does not need to be recalculated when there is no change in the diagnosis vector D . 5.5. Formulating the TTS objectives
In the normal operating mode, the objective of the TTS is to maintain the tank T 2 level between 9 cm and 11 cm and to try to maintain the tank T 1 level between 45 cm and 50 cm. This temporal objective can be expressed as AG  X  9 r l 2 r 11 EG  X  45 r l 1 r 50  X  . The nominal objective is to regulate the level in tank T 1 up to a water level of 50 cm. In the case in which the nominal objective cannot be fulfilled, users accept a revised objective that regulates the water level in tank T 1 just under the valve V 1 location (i.e., 30 cm). This degraded objective is acceptable only in faulty situations and can be expressed by the CTL n formula: AF  X  AG  X  9 r l 2 r 11  X  4 EG  X  25 r l 1 r 30
The system is assumed to be well designed and thus able to fulfil the nominal objective in non-faulty situations. This hypoth-esis can nevertheless be checked by testing the formula AG  X  9 r l 2 r 11  X  4 EG  X  45 r l 1 r 50  X  on the execution structure cor-responding to the system X  X  nominal model (see Fig. 4 ). In faulty situation, the reconfigurability analysis procedure first tests the nominal objective, expressed as AF  X  AG  X  9 r l 2 r 11  X  4 EG  X  45 r l r 50  X  X  . If the evaluation result shows that the nominal objective cannot be fulfilled, the degraded objective, expressed as AF  X  AG  X  9 r l 2 r 11  X  4 EG  X  25 r l 1 r 30  X  X  , is tested. 5.6. The model checking procedure
Suppose that the current state of the system is the state noted 1 on the Fig. 4 . From this state, the model generation algorithm predicts that the control action V 1_ close will be applied and that the system will evolve to the state 2. Consequent to the running of this new control action, the level l 2 must decrease. If this level is increasing instead of decreasing a fault is detected. The fault detection time is linked to the system dynamic. If a priori any component may become faulty at any time, a fault sign usually manifests after attempting to apply an action on the system. To continue with our example, if the predicted state noted 2 in Fig. 4 is not observed when the control action V 1_ close is run, it is probably because this action has not been correctly realised. Consequently, the fault localisation time can be reduced by testing as first fault mode, a fault mode corresponding to the last action applies on the system (i.e. V 1_ stuck _ on in our example).
The corresponding revised system model obtained when the diagnoser detects that valve V 1 is blocked in the opened position is given in Fig. 5 . State 1 is the current system state at the time the diagnoser detects the fault. This model is the execution structure for the model checking procedure. The nominal objective to be checked is expressed by the CTL n formula AF  X  AG  X  9 r l 2 r 11  X  4 EG  X  45 r l 1 r 50  X  X  . The current state (state 1) obviously does not nominal objective be fulfilled in the future ? X  X . To answer to this question, the CTL n formula is tested as proposed in Section 4.3 .
Let be f the abbreviation for 9 r l 2 r 11 and g be the abbrevia-tion for 45 r l 1 r 50. The CTL n formula AF  X  AG  X  9 r l 2 r 11  X  4 EG  X  45 r l 1 r 50  X  X  is first re-written in terms of the basic connectives : , 4 , ? , EX , EG and EU , using the equivalences given labelling operation is then processed, dealing recursively with the different sub-formulas. Let S  X  c  X  denote the set of all states labelled with the sub-formula c . The processing steps are: 1. S  X  g  X  X f 1 g . Only state 1 shown on the graph given in Fig. 5 verifies 45 r l 1 r 50. first labelled with EG ( g ), and then the label EG ( g ) is deleted from any state if none of it successors is labelled with EG ( g ).
This deletion procedure is repeated until there is no change. satisfy 9 r l 2 r 11. 4. S  X : f  X  X f 1 , 2 g 5. S  X  EF  X : f  X  X  X  S  X  E  X  trueUf  X  X  X f 1 , 2 g 6. S  X : EF  X : f  X  X  X f 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 g 7. S  X : EF  X : f  X  4 EG  X  g  X  X  X fg 8. S  X  AF  X : EF  X : f  X  4 EG  X  g  X  X  X  X fg
This result shows that the nominal objective cannot be met when the valve V 1 is blocked in the open position. The second step of the reconfiguration procedure tests the degraded objective, expressed as  X  AG  X  9 r l 2 r 11  X  4 EG  X  25 r l 1 r 30  X  X  . Re-written in terms of basic connectives, the revised objective is AF  X : EF  X : f  X  4 EG  X  g  X  X  , where f stands for 9 r l 2 r 11 and g stands for 25 r l 1 r 30. The different steps of the labelling procedure are: 1. S  X  g  X  X f 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 g . 2. S  X  EG  X  g  X  X  X fg . 3. S  X  f  X  X f 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 g . 4. S  X : f  X  X f 1 , 2 g 5. S  X  EF  X : f  X  X  X  S  X  E  X  trueUf  X  X  X f 1 , 2 g 6. S  X : EF  X : f  X  X  X f 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 g
In order to calculate S  X  AF  X  c  X  X  , the states of S  X  c  X  are, first, labelled with AF  X  c  X  , and then the label AF  X  c  X  is applied to any state that has all its successors are labelled with AF  X  c  X  until there is no change. State 2 is first found by this way and then state 1.
This result is very strong because it means that the verified objective holds true along every path from any state in the execution structure. Specifically, since this set contains the initial state 1, it can be concluded that, with this execution structure, if the reconfigurable control starts at the moment when the fault is identified and the model is recalculated, the degraded objective  X  AG  X  9 r l 2 r 11  X  4 EG  X  25 r l 1 r 30  X  X  is guaranteed to be met at some later time. 6. Conclusion lities of controlling a system when a fault occurs, we bring an important help to operators who have to exactly know, at each time, what they can obtain from the system they supervise.
Moreover, these possibilities can be expressed in term of available and unavailable functions, and this kind of information is well adapted to the human reasoning. The flexible model we propose is built on this functional analysis. It allows to take into account the dynamic aspect required to oversee the system on line, and to evaluate the availability of the services provided by the system components. It takes the form of a state transition graph. Each state groups a set of atoms whose values are true for this state.
The atoms are observation atoms (i.e., measured values, control action values) and diagnosis atoms (i.e., the normal and faulty operation modes of the components). The transitions between the states correspond to control action that can be applied to the system when it is in the origin state to drive it to a destination state. The transition graph is automatically built by an appro-priated algorithm each time the values of the diagnosis atoms change. The algorithm requires as input the values of the observation and diagnosis atoms and a description of the control actions that can be provided by the system X  X  components, expressed in the form of a pre-condition and one or more effects.
This description is obtained from the functional analysis of the system. The values of the diagnosis atoms are updated by the diagnoser which is not described in this paper. The basic ideas for building the diagnoser are the following. Comparing the states predicted by the flexible model and the states actually observed makes it possible to detect faults. Using fault models, expressed as control actions, in terms of pre-conditions and effects, make it possible to identify the faulty component and the fault mode ( Hu et al., 2009a , 2009b ).

By associating diagnosis and reconfiguration, all built on the same model, we hope to contribute to the development of a global supervisory control system. Indeed, the interest of using the same model is to improve the delay to reconfigure the system when a fault appears. Possible future research is first to imple-ment the global solution for supervising a system in real-time and second test our solution on a large system. One of the future applications is the supervision of intelligent autonomous vehicles in the InTraDe project (Intelligent Transportation for Dynamic Environments). This project is financed by European regional development funding through InterregIVB and is supposed to lead to the development of an automatic navigation system for port terminals. In this context, the ultimate objective of our work is to design a supervision system representing the management of the operating modes of a vehicle and giving the conditions for its reconfiguration when a part of its inner components is faulty or when another vehicle with it has to cooperate is not in a nominal operating mode. One of the challenges is to see how the proposed representation can be distributed on a set of subsystems (the vehicles or some parts of a same of vehicle). Global objective has for this to be decomposed into local sub-objectives and local diagnosis and reconfiguration possibilities have to be merged to reconstruct global diagnosis and reconfiguration solutions. References
