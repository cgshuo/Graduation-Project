 The widespread adoption of mashup as a new development style for quick-to-build applications has enabled its introduction also within enterprises. Enterprise mashups are usually developed by selecting and aggregating domain-specific Web APIs, provided internally to the enterprise, and general-purpose Web APIs, pro-vided by third parties. Web APIs are used to access underlying resources, func-tionalities or data, through web-based user interfaces [2]. Effective Web API search should be based not only on Web API features, such as categories, tags, protocols and data formats. Advanced methods and techniques should further enable web designers, both internal and external to the enterprise, to exploit experience of other designers in developing web applications, starting from the same repositories of Web APIs.

As a motivating example, consider Josephine, a designer who aims at building a new web application for her enterprise. The application should provide access to details about products advertised on the network through an enterprise e-commerce portal and information about customers who bought the products, such as shipping data, purchase history and contact information. Moreover, the web application could provide additional facilities to display on a map customers X  addresses to better schedule shipping activity. The Josephine X  X  problem is to de-cide if the functionalities of the new application, such as e-commerce facilities, must be implemented from scratch or if she may rely on available Web APIs. For instance, Josephine may use the well-known e-commerce facilities of the Amazon API, thus making the new application as more interoperable as possible by using a widely adopted component. Similarly, she may adopt Salesforce.com ,forcus-tomer relationship management, or Google Maps . Josephine may be supported in her task by searching for Web APIs not only according to their categories, tags or more technical features, such as the protocols and data formats. Web APIs could be suggested to Josephine on the basis of past choices made by her colleagues or other web designers while developing similar applications or using similar Web APIs.

To support Web API search according to the vision highlighted above, we propose a framework based on a novel enterprise mashup model. The model re-flects three different perspectives, namely component (Web APIs), application (enterprise mashups built with Web APIs) and experience perspective (web de-signers, who used Web APIs to develop enterprise mashups). We exploit the multi-perspective framework for Web API search and ranking, according to dif-ferent search scenarios, namely the dev elopment of a new enterprise mashup and the enlargement of functionalities or the substitution of Web APIs in an existing mashup.

The paper is organized as follows. Section 2 describes the multi-perspective mashup model. In Section 3 we describe the search scenarios and the functional architecture of the proposed framewor k. The Web API search and ranking tech-niques are described in Section 4. In Sect ion 5, we discuss about implementation issues and preliminary evaluation. Section 7 presents a comparison with the state of the art. Finally, Section 8 closes the paper. The model we propose in this paper is desi gned according to three interconnected perspectives as shown in Figure 1 and detailed in the following. Each perspective is focused on specific elements, namel y Web APIs, enterprise mashups and web designers, further described with proper features and relationships with elements of the other perspectives.
 The Component Perspective. According to this perspective, Web APIs de-scriptive features are distinguished between classification features and technical features. These features have been chos en to be compliant with the descriptions of Web APIs indexed within the ProgrammableWeb repository, that is the most populated and better updated Web API public registry 1 . Classification features are categories and semantic tags. In our model, a Web API W is assigned to a cat-egory c W among the 67 ProgrammableWeb categories, such as mapping , search or payment . Semantic tags are adopted to face polisemy (that is, the same tag refers to different concepts) and homonymy problems (i.e., the same concept is pointed out using different tags), which traditional tagging may present. Dur-ing the assignment of such tags, sense disambiguation techniques based on the WordNet lexical system are applied. In WordNet the meaning of terms is defined by means of synsets . Each synset has a human readable definition and a set of synonyms. Starting from the tag specified by the designer, WordNet is queried, all the synsets that contain that term are retrieved, thus enabling the designer to select the intended meaning. In our model, each semantic tag t W , associated with the Web API W , is a triplet, composed of: (i) the term itself extracted from WordNet; (ii) the set of all the terms in the same synset; (iii) the human read-able definition associated with the synset. The semantic tagging procedure has been extensively described in [4]. The ProgrammableWeb repository also enables to retrieve additional Web API information, namely the technical features listed in Table 1. Sample descriptions of the Amazon e-commerce and eBay APIs using classification and technical features are the following: The Application Perspective. According to this persp ective, an enterprise mashup M k is composed of a set {W M } of Web APIs and is described through aset { t M } of semantic tags, that are defined in the same way as Web API se-mantic tags. No technical features are prov ided for mashups, since these features are directly related to the component Web APIs. For instance, the following two mashups have been implemented using the Salesforce.com API together with other APIs, such as Amazon e-commerce and eBay APIs: The Experience Perspective. This perspective models the set D W of design-ers, both internal and external to t he enterprise, who used the Web API W to develop their own mashups. Each designer d i  X  X  W is modeled through: (a) the skill  X  i for developing web applications; (b) a set of triplets W j ,M k , X  jk to denote that the designer assigned a quantitative rating  X  jk to the Web API W j when used within the mashup M k . The skill is asked to the web designer during the registration to the system, acco rding to a discrete scale: 1.0 for expert ,0.8 for high confidence , 0.5 for medium confidence , 0.3 for low confidence and 0.0 for unexperienced .

The value of the quantitative rating  X  jk is selected by the designer according to the NHLBI 9-point Scoring System, whose adoption for Web API rating has been described in [4]. This scoring system has few rating options (only nine) to increase potential reliability and consistency and with sufficient range and appropriate anchors to encourage designers to use the full scale. During the rating, the designer is provided with the set of options that are mapped into the [0 , 1] range. In the following exam ple, the external designer d 1 , who is a medium-skilled enterprise mashup developer, used eBay API in the M Channel mashup and rated the Web API as exce llent, while the internal designer d 2 ,who is an expert developer, used the Amazon API in the M eCommazon mashup and rated the API as very good. The metrics based on the proposed model have been implemented in the system we called APITagger . The functional architecture of APITagger is shown in Figure 2.

The APITagger Web Interface guides the web designer through the regis-tration process, the Web API search and rating, the Web API and enterprise mashup semantic tagging. Designers X  registration is required to setup the devel-opment skill and other features according t o the experience perspective. Semantic tagging is supported by a Sense Disambiguation (SD) module that implements the sense disambiguation facilities introduced in the previous section. The mod-ule is implemented as a Web service and is invoked by other modules of the architecture.

Web API categories and technical features are obtained from a catalog inter-nal to the enterprise or from ProgrammableWeb public registry through proper methods ( api.programmable.com ), invoked within the Web API Features Ex-tractor . Ranking and filtering module implements the metrics described in this paper (see Section 4). The designer is supported throughout the formulation of the request ( Web API search ), according to different search scenarios ,which are defined in the next section. The request is issued as a query on the Web API RegistryDB and query results are ranked, filtered and presented to the de-signer, who may rate them and/or specify their joined use in her own enterprise mashups ( Web API rating and aggregation ). 3.1 Search Scenarios We classify different search scenarios w hich the web designer may be acting in according to two dimensions: the search target and the search typology .
The search target identifies the goal of the Web API search, namely the selection of a single Web API, that we denote with single selection target (for instance, when the designer starts the design of a new mashup), the comple-tion of an existing mashup by adding new Web APIs ( completion target )orthe substitution of a Web API in an existing mashup ( substitution target ).
The search typology identifies the way Web API search is performed. We distinguish between simple search , advanced search and proactive search .Inthe simple search, the web designer is looking for a Web API by specifying a category and a set of semantic tags. A variant of this search, denoted with advanced search , is the one where the designer has also in mind the mashup where the Web API to search for should be used. The mashup is specified through a set of semantic tags and, optionally, a set of Web APIs already included in the mashup where the new Web API will be inserted. In the proactive search, the designer does not specify the Web API to search for; she starts from a mashup, specified through a set of semantic tags and a set of Web APIs already included in the mashup, and she relies on the system that proactively suggests which Web APIs could be added given similar mashups developed in the past. For instance, in the running example, the system could proactively suggest to Josephine to include a chat API since this kind of functionality is often adopted within mashups which contain both Salesforce.com and Amazon e-commerce APIs.
 A generic Web API request is defined as a 4-tuple: where c r W is the requested Web API category, { t r W } is a set of semantic tags specified for the Web API to search for, { t r M } is a set of semantic tags featuring the mashup M where the Web API to search for should be used, {W r M } is the set of Web APIs already included in the mashup M .

The definition of the request W r is specialized depending on the search sce-nario as shown in Table 2. In the simple search, the requested Web API category c
W and semantic tags { t r W } are specified, while in the advanced search also { t r M } are used to describe the mashup that is being developed and where the Web API to search for should be included. When simple or advanced search are used for completion or substitution purposes, also the set {W r M } of Web APIs already included in the mashup to be completed or modified is specified in the request. Note that in the substitution target, c r W and { t r W } are automatically extracted from the category and semantic tags of the Web API selected by the designer for substitution. Proactive search is applicable only for completion purposes. In fact, in the substitution target the Web API to substitute is known (through its c
W and { t r W } ), that is, no proactivity is involved. In the single selection target, there is no mashup under development yet and the system has no information which proactive suggestion could be based on.

For example, a request W r , formulated according to the advanced search and completion target , to find an e-commerce Web API in the category Shopping , to be used in a mashup specified through the tag selling and which already includes Salesforce.com and UPS APIs, can be represented as follows: 4.1 Web API Search Web API search and ranking have been implemented through a set of metrics, which compare the elements of the request W r with the features of each API W indexed in the Web API RegistryDB, according to the three perspectives described in Section 2. Search and rank ing metrics can be properly set up de-pending on the search scenarios. For Web API search purposes, the most a Web API W fits the request W r , the most their categories, their semantic tags and the mashups which contain them are similar. The building blocks are the category similarity ,the semantic tag similarity and the mashup composition similarity metrics.
The category similarity between the category c r W of W r and the cate-gory c W of W can not be inferred using advan ced semantic-driven techniques (such as category subsumption checking), since no hierarchies are defined among the available categories in the ProgrammableWeb categorization we chose for our model. Nevertheless, we consider the two categories as more similar as the number of Web APIs that are categorized in both the categories, denoted with | c
W  X  c W | , increases with respect to the overall number of Web APIs classified similarity is defined as follows: The semantic tag similarity between two sets of semantic tags, denoted with Sim tag ()  X  [0 , 1], is computed by evaluating th e term affinity between pairs of tags, one from the first set and one from the second set, and by combining them through the Dice formula. The term affinity between two tags t 1 and t 2 be-longs to the range [0 , 1] and it is computed as extensively described in [4], based on WordNet. In WordNet, synsets are related by hyponymy/hypernymy rela-tions , used to represent the specialization/generalization relationship between two terms. Term affinity is equal to 1.0 if the two tags belong to the same synset or coincide; it decreases as long as the pa th of hyponymy/hypernymy relations between the two synsets of the tags increa ses. In particular, term affinity is equal to 0 . 8 L , where there is a path of L hyponymy/hypernymy relations between the two terms. The value 0 . 8 has been proven to be optimal in our experiments on WordNet term affinity. Pairs of tags to be considered in the Sim tag computation are selected according to a maximization function that relies on the assignment in bipartite graphs. This function ensures that each tag from the first set partic-ipates in at most one pair with one of the tags from the second set and viceversa and the pairs are selected in order to maximize the overall Sim tag .Figure3 shows a portion of WordNet vocabulary and a sample computation of Sim tag .
The mashup composition similarity between a mashup composed of a set denoted with Sim comp ( {W r M } , {W k } ), evaluates the number of common Web APIs in the two mashups. The corresponding formula is built by following the same rationale of Sim cat (), that is: where | X | denotes the number of Web APIs in the set and |{W r M } X  X W k }| denotes the number of common Web APIs in the two sets. For instance, if {W r M } = { Salesforce.com , UPS } and {W k } = { Amazon , Salesforce.com , UPS } , therefore Sim comp ( { eBay , Salesforce.com } , { ChannelAdvisor , Salesforce.com , UPS } ) = 0.4 are computed in the same way.

Category, semantic tag and mashup composition similarity metrics are used to compute: (a) the similarity between the request W r andanAPI W accord-ing to the features of the component perspective, denoted with APISim (); (b) the similarity between W r and W in the context of mashups where W has been used (application perspective), denoted with MashupSim (). The similar-ity APISim ( W r , W )  X  [0 , 1] is defined as: where c W is the category of W , { t W } is the set of semantic tags associated with W ,0  X   X  1 , X  2  X  1and  X  1 +  X  2 = 1. Inspection of the adopted ProgrammableWeb categorization showed that the category is only a coarse-grained entry point to look for Web APIs. According to this, th e weights have been configured in our experiments as  X  1 =0 . 2and  X  2 =0 . 8. An example of APISim () computation is the following: Similarly, APISim ( W r , eBay )=0 . 8. Note that, in the last case, the APISim () is high although Sim cat () = 0, due to the proper setup of  X  1 and  X  2 weights.
The similarity between the request W r andanAPI W in the context of an enterprise mashup M , denoted with MashupSim ( W r , W ,M )  X  [0 , 1], is defined as the following linear combination: where 0  X   X  3 , X  4  X  1,  X  3 +  X  4 =1 . 0, M is composed of Web APIs in {W k } and W belongs to M . To setup the weights in this case we have to take into account the search target . In fact, in the single selection search target, {W r M } is not specified (see Table 2). Therefore,  X  3 =1and  X  4 = 0. In the other cases,  X  3 and  X  4 weights are both set to 0.5 to equally consider the two kinds of similarity. For instance: Similarly, MashupSim ( W r , eBay , M Channel ) = 0.53. The overall matching mea-sure between the request W r and each API W , denoted with Sim ( W r , W )  X  [0 , 1], is computed as: where W X  M i . In particular, the second term in Equation (6) takes into account that the Web API W has been used in different mashups, by designers with different skills  X  i ,where  X  i is the declared skill of designer d i  X  X  W . The second term in Equation (6) ensures that the pas t experiences of more expert designers have a higher impact on the Sim () computation. Intuitively, the closest the  X  i and MashupSim () values to 1 (maximum value) for all the designers d i ,the closest the second term in Equation (6) to 1.0. The weight  X  5 is set according to the search typology . If a simple search is being performed, the second term in Equation (6) must be ignored, that is,  X  5 =1 . 0; similarly, if we are performing a proactive search,  X  5 = 0 to ignore the first term; otherwise,  X  5 =0 . 5toequally weight the two terms in the Sim () evaluation. For instance: Similarly, Sim ( W r , eBay )=0 . 53. The Web APIs included in the search results (which we denote with {W } X  X W} ) are those whose overall similarity is equal or greater than a threshold  X   X  [0 , 1] set by the web designer. 4.2 Web API Ranking The Web APIs {W } , included among the search results, are ranked taking into account both the technical features in t he component perspective and ranking of web designers who used the Web APIs to develop new mashups. In particular, the ranking function  X  : {W }  X  [0 , 1] is defined as a linear combination as follows: where 0  X   X ,  X  j  X  1, j =1 , ..., 6, and  X  + 6 j =1  X  j = 1 are weights that are equally weighted because we consider all the terms in Equation (7) as equally relevant. Fu-ture work will be devoted to the setup of preferences among  X  1 () and  X  j () functions.
The computation of  X  1 ( W ) follows the same rationale of the second term in Equation (6), that is, considers as more important ratings assigned by more expert designers: where Equation (8) must consider the ratings  X  jk given by all the designers d  X  X  W who used the Web API W in mashups { M pletion or a substitution target, then rating must be further weighted by the mashup similarity, that is: The computation of  X  j ( W ) is based on the technical features in the component perspective (see Table 1). As for possible metrics to be adopted within  X  j ( W ), a good survey can be found in [6]. For instance,  X  1 ( W ), that is associated with the set of protocols P W , can be based on the popularity of protocols P W (that is, the number of APIs which use them);  X  5 ( W ), that is associated with the API update time  X  W , is based on the delta of  X  W with respect to the current date. Nevertheless, among technical features, we distinguish those that may behave differently for Web APIs W that must be placed within existing mashups, for completion or substitution purposes. Specifically, we consider the protocols in P
W and the data formats in F W . In these specific cases, the best solution is that all the Web APIs within the mashup share the same protocol and data format. Therefore, let be P W and F W the union set of protocols and data formats, respectively, used by Web A PIs within an existing mashup, and W an API to be added to such mashup for completion and substitution purposes. We propose a variant of  X  j ( W ) functions, where j =1 , 2, denoted with  X  j ( W ), where  X  1 ( W )=1 . 0if P W  X  P W , 0.0 otherwise (  X  2 ( W ) is defined in the same way for F W ). For instance, eBay API provides more data formats and protocols with respect to Amazon , but if we are going to search for a Web API to be included in a mashup where the XML data format is required, then Amazon should be the preferred choice. This example shows how the search target is used to select the ranking functions. Specifically, if the target is the completion of an existing mashup or the substitution ofaWebAPIinanexistingmashup, then the variants  X  1 ( W )and  X  2 ( W ) are adopted in Equation (7). A further filtering could be performed if the Web API W has been used by a designer, external or internal to the enterprise. For instance, a web designer may prefer to consider only those search results which have been used by other designers within the enterprise (e.g., to consider Web APIs which expose functionalities for the enterprise core business). Figure 4 shows the APITagger search page for a logged web designer. Designer X  X  registration is required to setup the development skill and to list designer X  X  pri-vate information, including the list of her mashups in the My MashUp menu. The selected mashup is described in the middle of the search page, together with the details about mashup APIs. Here the designer may tag both the mashups and the Web APIs through the tag button.
By pushing the button, a popup window is displayed, where a text field is provided to enter the tag. As the designer inputs the characters of the term she wants to specify for tagging, the system provides an automatic completion mechanism based on the set of terms contained in WordNet. Starting from the tag specified by the designer, the Sense Disambiguation Web service queries WordNet and retrieves all the synsets that contain that term and shows the semantic tags list.

In the search page, the designer may also rate the Web APIs for their use in a given mashup, according to the NHLBI 9-point Scoring System: for example, in Figure 4 the designer may rate the Amazon ,the Salesforce.com or the UPS API as used within the eCommazon mashup. The other elements of the search page, such as the list of categories on the left or the search field on the top, enable the designer to perform traditional Web API search, namely category-based or keyword-based. Finally, by pushing the Advanced button, the system guides the designer through the formulation of request W r by means of a sequence of popup windows. Since there are no benchmarks to compare our implementation with similar efforts, we built our own dataset to perform a preliminary laboratory experi-ment on the framework. The experiment focuses on the application domain of the running example: we considered a subset of 922 Web APIs grouped in the Advertising , Enterprise , Office , Shopping and Shipping categories together with their technical features extracted from the ProgrammableWeb repository; we collected a subset of mashups from the same repository, among the ones built with the selected Web APIs, and the corresp onding developers (for example, the Amazon API has been used in about 416 mashups owned by 216 developers). We performed semantic tagging starting from the keywords extracted from the Web API and mashup descriptions; finally, we classified developers X  skills on the basis of the number of mashups and APIs they own. We merged this dataset with the one built in the same way in [4], obtaining a total of 1317 Web APIs and related mashups.
 We ran two kinds of experiments on an Intel laptop, with 2.53 GHz Core 2 CPU, 2GB RAM and Linux OS. Experiments have been performed ten times using different requests. In the first e xperiment, we performed a single Web API search by specifying a category and atagandissuingtherequesttofour different systems: (a) the ProgrammableWeb search facilities; (b) an implemen-tation of the system that relies on the classification and technical features in the component perspective only, inspired by ApiHut [10]; (c) the APITagger sys-tem implementation. Then we randomly selected 20 Web APIs, both included and not considered among the first 10 search results and we asked five expert users to classify the Web APIs as relevant and not relevant for the request is-sued. Finally, we compared the search results against the classification made by users, considering as relevant for th e systems those Web APIs that have been listed among the first 10 search results. The comparison is based on the well known Cohen X  X  kappa statistical measure. The results are shown in the first col-umn in Table 3: as expected, all systems perform better than ProgrammableWeb , but APITagger outperforms all the systems, due to the extensive use of other designers X  experiences both for searching and ranking.

In the second experiment, we randomly chose a mashup M and we extracted from the mashup a Web API W . We then issued a request using the features of W given a mashup M = M/ {W} and we calculated the average position of W among search results given by our system. The results are shown in the second column of Table 3.
 The approach described in [15] is the one cl osest to our, since authors consider also past experiences in building mashups to search for relevant Web APIs and for ranking the search results. As underlined in [15], approaches which rely only on a single perspective may suffer from the cold start problem ,thatis,acom-ponent that has been used in a significative number of cases gets more and more used despite the inner quality of the Web API, or may pass unnoticed because of its poor quality descriptions (as often happens when the designers themselves are in charge of assigning categories or tags). These limitations apply to works which rely only on the popularity of Web APIs according to their use in existing mashups [8,11,16], or within approaches which only consider techni-cal features, categories and tags for the classification and ranking of Web APIs, such as the one described in [10]. Nevertheless, despite its similarity with our multi-perspective framework, the appr oach described in [15] focuses on what we denoted as the component and application perspectives, without taking into ac-count other aspects such as ratings and designers X  expertise and without tuning search and ranking mechanisms according to different search scenarios. Other works [3,5,13] focus only on one of the perspectives we considered in this paper.
For what concerns the definition of models for Web API search and ranking, the ones which have been proposed in several papers focus on a subset of the features considered in our model. Techni cal features have been discussed in [6], where the authors includes them in a Web API model aimed at classifying the quality of resources accessed through th e Web APIs (in terms of accuracy, com-pleteness, timeliness and availability) and the quality of the Web API interface in terms of usability and accessibility. Component and application perspectives have been modeled in [1] and, in an enterprise context, in [12], without con-sidering the experience perspective. In [4] a framework based on a Web API lightweight model is proposed. This model is compliant with the information ex-tracted from the ProgrammableWeb repository and enriches such information by means of a collaborative semantic tagging system, where web designers can take actively part in the semantic tagging of Web APIs. In this paper, we perform several steps forward: i) we proposed a revision of the model by introducing three perspectives, focused on Web APIs, enterprise mashups built with Web APIs and web designers, who used Web APIs to develop enterprise mashups; ii) we extended the set of features to be considered for Web API search and ranking; iii) we tuned the multi-perspective framework according to different search sce-narios, namely the development of a new enterprise mashup and the enlargement of functionalities or the substitution of Web APIs in an existing mashup. Specif-ically, the aim in this paper has been to rely on a lightweight API model that is compliant with existing Web API repositories as well. The need of adopting a lightweight model also affected the adoption of simplified matching techniques used for discovery purposes: the adoption of ontology-based techniques such as the ones described in [7,9] is unfeasible i n this context, since they would require semantic annotation of Web API descriptions that is error-prone and time con-suming. The evolution of our approach towards these kinds of metrics will be investigated as future work, after an integration of the APITagger framework with advanced techniques for extractin g additional information from Web API documentation [14]. A framework that merges different Web API features, ranging from descriptive to social-based ones, is crucial for Web API sharing to enable the development of quick-to-build applications starting from ready-to-use components. In this paper we proposed a multi-perspective framework, where a perspective focused on the experience of web designers is used jointly with other Web API search techniques, relying on classification features, like categories and tags, and tech-nical features, like the Web API protocols and data formats. Future work will be devoted to enrich the model, both adding further social features (e.g., modeling the social network of web designers) and including features extracted from other Web API repositories (e.g., mashape ). Future work will also concern the refine-ment of framework metrics, such as the implementation of different strategies to setup thresholds and weights (for instance, depending on the search scenario) or extending the sense disambiguation module with additional knowledge bases and lexical systems.

