 1. Introduction of x and y will be stored in an intensional way, since the representation and visualization of the information are more that represent relations between variables which cannot be stored in a classic relational database.
The applications in which the information can be represented by constraints are very common in engineering and indus-mation of these applications has been approached by constraint databases (CDBs), since CDBs allow the storage of con-queries about constraints whilst simultaneously permitting classic data to be accessed.
Although there are important and interesting proposals in the CDB field, there are aspects that can be improved in rela-duced by Veltri [55]. Veltri proposed storing the box consistency of the variables for each constraint to improve the improve the computational complexity.
 constraints and the method of evaluation. For union and difference operations two relations are combined vertically into a new relation. For both operators it is necessary to compare the different tuples to know if there are shared solutions and its behaviour is equal to that in classic relational algebra.
 sible values that these variables represent in a extensional way.
 elimination problems. These problems are created dynamically according to the query and they are solved using different problems; and using relational and object-oriented paradigms.

Although our architecture can be used for any type of problem which involves linear or polynomial constraints, in this work model-based diagnosis is employed since it has many industrial utilities, such as with hardware and software compo-require different procedures for their evaluation, while spatiotemporal problems are defined over only four dimensions abases and analyses previous work on CDBs. Section 3 gives some definitions necessary for the explanation of model-based and query a LORCDB and the proposed architecture. Section 5 explains how a query is evaluated. Section 6 presents some and future work are presented. 2. Background
Constraint databases were initially developed in 1990 with a paper by Kanellakis et al. [37], and were extended through first search method, Datalog uses breadth-first search strategy which returns answer sets. These paradigms were used to represented as an equality constraint between an attribute of the database and a constant.
Many database applications have to deal with an enormous quantity of data which can be even infinite such as time and 2.1. Constraint databases definitions
Before starting the explanation of some of the most important prototypes developed in the constraint databases, some modified definitions from [20] are necessary.
 set P of predicate symbols. The sets of functions and predicates have an associated arity. For example the vocabulary symbols 0 and 1.

Definition 2.2 ( First-order logic over X ). Terms are defined inductively as a variable, or a value v 2 D ,or f  X  t f 2 F is of arity n , and t 1 ; ... ; t n are terms.

Definition 2.3 ( Atomic formula ). This has the form t t 0 or p  X  t predicate.

A formula can be an atomic formula , or a Boolean combination of atomic formulas. In our case, if u and w are formulas, then ( u ^ w ) and ( u _ w ) are also formulas.
 called an X -constraint.
 The previous definitions can be expressed with the following grammar:
Constraint:= Atomic _ Constraint BOOL _ OP Constraint
BOOL _ OP:=  X  _  X  j  X  ^  X 
Atomic _ Constraint:= function PREDICATE function function:= Var FUNCTION _ SYMBOL function
PREDICATE:=  X  =  X  j  X &lt; X  j
FUNCTION _ SYMBOL:=  X  +  X  j  X  - X  j  X  *  X  The constraint types permitted in our architecture are based on [36,11] , and are: constraints are of the form p  X  0, where p is a linear function of the form a belonging to the domain D , and x i is a variable.
 Such constraints are of the form p  X  0, where p is a polynomial with coefficients belonging to the domain D . constraints are of the form p &gt; 0or p 6 0, where p is a linear function of the form a belonging to the domain D .
 Definition 2.5. Constraint database modelGiven a vocabulary X :
A constraint k-tuple , with the variables x 1 ; ... ; x k an X -constraint. The variables of each u i are all contained in x
A constraint relation of arity k, over X , is a finite set r  X f w the same variables x 1 ; ... ; x k . The corresponding formula is the disjunction w relation as different tuples, where each w i forms a constraint k-tuple .
 2.2. Related work
There are several important proposals for implementing and building prototypes for CDBs. The most important proposals are analysed below:
DISCO [8] (DATALOG with Integer Set COnstraints) is a CDB system which implements Datalog with Boolean constraints on databases have been published over the years, such as in the design of large-scale databases and concurrent access. The syntax of DISCO is very similar to that of Datalog, and very different from the standard SQL. DISCO is presented as an extensible system where the Boolean algebra can be modified by replacing some operators in a non-complicated way.
MLPQ/PReSTO [49,48] presents a combination of MLPQ (Management of Linear Programming Queries) and PReSTO (Para-metric Rectangle SpatioTemporal Object). MLPQ is a system to manage and query linear constraints in a CDB. It allows
Datalog queries and the addition of operators over linear functions. PReSTO enables query systems which change over use a plain text to store the information and a query transformation process into Datalog.
DEDALE [31] is an implementation of CDBs based on linear constraint models. DEDALE proposes a language to query CDBs, straints, DEDALE uses the object-oriented paradigm, which is an appropriate way to represent complex data. The disad-algebra.The syntax of DEDALE is very different from standard SQL, and therefore, any user of the system must learn another language, which is a great disadvantage.

CCUBE [5] (constraint comprehension calculus) is the first constraint object-oriented database system. The CCUBE system was designed to be used for the implementation and optimization of high-level constraint object-oriented query lan-guages. The CCUBE data manipulation language, constraint comprehension calculus, is an integration of constraint calcu-lus for extensible constraint domains within monoid comprehension. CCUBE serves as an optimization-level language for object-oriented queries. The data model for the constraint calculus is based on Constraint SpatioTemporal (CST) objects.
CCUBE guarantees polynomial time data complexity whose implementation uses the linear programming package CPLEX developed by Bixby et al. [4]. CPLEX allows both integer programming and very large linear programming problems to be solved.
 queries are based on relational operators, and look similar to SQL; however, there are numerous syntactic and semantic CDB.
 The different characteristics are shown in Table 1 . The main disadvantages of the proposals mentioned are: independent of the nature of the problem domain. Most of these prototypes are developed to work with spatiotemporal teristics which are different from the spatiotemporal information.
 There are many query languages whose syntax are very different to SQL, whereby the user needs to learn a new language. Sometimes this syntax is focused on the application of CDBs, frequently in the spatiotemporal domain. on relational databases. Some of these proposals are based on deductive databases whose disadvantages of consistency indexation, clustering and hashing. All of them have been included in commercial relational databases managements, but not when deductive databases are used.
 approximation is inappropriate for other applications where more precision is necessary.
None of these prototypes defines constraints as a new type of data, and although some of them use the object-oriented paradigm, they do not distinguish between discrete and continuous information, and hence are unable to exploit the rela-tional algebra in any of these aspects.

These proposals are not focused on handling several variables simultaneously. Although work such as [20,39,10] analyses the projection operator over the variables of a constraint by using quantifier elimination, there are no proposals that are explained in the next section. 3. Model-based diagnosis: a new application domain for CDB
Most work on constraint databases uses spatiotemporal data as case studies, however, this paper proposes model-based type of constraints stored and queries about them, by defining problems that are more complicated than spatiotemporal examples.

Fault detection and identification of faulty components are very important from the strategic point of view of companies due to the economic demands and environment conservation required to remain in competitive markets. This paper pro-good example since it is possible to use a great number of variables while spatiotemporal problems are defined over only four dimensions (height, width, length and time). Furthermore, the use of model-based diagnosis also proves that CDBs can be used in other types of applications.

Constraint satisfaction problems have sometimes been used in discrete model-based diagnosis [52,50] . The relation be-tween the components is equal to the network of related constraints defined in [40], although in our proposal the compo-nents have been modelled as constraints and the links between the components are their shared variables. variables a , b , c , e , d , f and g .
 constraints which determines the system behaviour. This set is created by using the relation between the non-observable system variables  X  V nob  X  and the observable variables  X  V work correctly. An SPM is formed by the tuple f P ; V ob ; V
Definition 3.2. ( Context set (CS) ). Any subset of components which composes the system. There are 2 text sets, where nComps is the number of components of the system.
 observable variables is created. In the example of Fig. 3 the CARCs are:
CARC 1 f f  X  a c  X  b d g , generated with the constraints of the components f M
CARC 2 f g  X  b d  X  c e g , generated with the constraints of the components f M
CARC 3 f f g  X  a c c e g , generated with the constraints of the components f M
For example, for the OM { a =1, b =2, c =2, d =3, e =2, f =9, g = 11}, CARC least one component of f M 1 ; M 2 ; A 1 g and another of f M component M 2 is failing.

A system composed of components that can be handled by the projection operator of the relational algebra adapted to the constraints, has the following characteristics: of the variables of the constraints are obtained.
 attributes can be variables.
 instantiated.
 plained. Using our SQL extension over constraints makes it possible to obtain several constraint models depending on the which variables are observable, while the remaining variables are non-observable. 4. A new definition of CDB changed in this paper as follows.
 Definition 4.1 ( Revision of the CDB model).

A constraint k-tuple with the variables x 1 ; ... ; x k over the vocabulary X is a finite conjunction u for 1 6 i 6 N , is either a constraint such that f x j  X  Constant g , where x straint over the variables x 1 ; ... ; x k which do not correspond to a classic attribute, called Constraint Attribute . finite set of r  X f w 1 ; ... ; w M g , where each w j for 1 mula is the disjunction w 1 __ w M , such that w j  X  u 1 ^^ u each w j 2 r there is a u i such that f x  X  Constant g , where x is the same variable in all u to constraint attributes .
 butes if and only if: u ij is a u i 2 u 1 ^^ u N and w j 2 w 1 __ w M , such that w attribute  X  x  X  if: where c j is a constant, M the number of tuples and N the number of attributes (columns). attribute, since this variable follows the relational algebra defined by Codd.
 constant, and do not appear in the rest of the attributes.
 attributes:
Classic attribute  X  at i  X  : at i belongs to the n -tuples of a relation  X  1 for example Integer , String , Date , etc. This type of attribute can be represented as a constraint such as { at relational databases only permit attributes with atomic values.

Constraint attribute  X  at c i  X  :at c i belongs to the n -tuples of a relation where at c ables v 1 v k . For our proposal a constraint relation is formed by classic and constraint attributes.
Constraint-variable attribute  X  at c i v j  X  :v j is a variable which belongs to a constraint attribute at c sented by: constraint database (LORCDB). 4.1. CORQL: constraint object-relational query language
This section shows the syntax of the language to create, query and fill a LORCDB, whereas the following sections present different types of data.
 facilitate the handling of constraints by inexpert users, we propose a new language CORQL (constraint object-relational query language), developed to facilitate the relation between the user and the system for the projection operator. Since the language CORQL maintains very similar syntax to SQL. CORQL is a superset of SQL, where new syntactical constructors 4.1.1. Creating a LORCDB In order to create a LORCDB the following sentence is used: CREATE LORCDB h database _ name i tables implicitly change according to the constraints added to or removed from the LORCDB. The table Constraints stores added, and they are created and stored in an implicit way in order to locate constraints more quickly and efficiently. 4.1.2. Creating and inserting information into a table several columns of constraint type.
 For the example shown in Fig. 3 , the sentence is: CREATE TABLE Component(IdComponent Integer, base. The checking of the type is performed as for usual types.

The constraint objects are stored as syntactic trees, where the internal nodes can be comparator operators (=, &lt;, for Integer variables, {0..Integer.MAX_VALUE} for Natural variables, and {Float.MIN_VALUE..Float.MAX_VALUE} for Float
The syntax to insert a constraint (according to Definition 2.4) is: { h Constraint i , In order to store the example shown in Fig. 3 in a LORCDB, a sentence can be:
INSERT INTO Component(IdComponent, Name, Behaviour) VALUES that will be created depending on the query. 4.1.3. Querying a labelled object-relational CDB here. According to the new attributes, we propose an extension of the functionality of the projection operator when the information involved in the query is a constraint. This operator is analysed below, and we study how it is affected when working with constraint information.

The projection operator has the signature R 1  X  p  X  a 1 ; ... ; a n  X  ferent types of attributes:
It is only necessary to redefine the syntax of the projection over constraint-variable attributes  X  at c straints inferred from the original constraints with only those variables that appear in the projection. the LORCDB wants to obtain a set of variables in a symbolic way, the following syntax is used:
SELECT CONSTRAINTS( at c 1 v 1 ; ... ; at c 1 v k ; ... ; at that a conjunction of constraints over the variables x 1 ; ... ; x ing x i if and only if there is an S * such that S  X 9 x i the LORCDB wants to obtain a group of values of variables, the following syntax is used:
SELECT VALUES[n]( at c 1 v 1 ; ... ; at c 1 v k ; ... ; at sible that the number of solutions will be infinite.

AVG , the MIN and MAX . For our language CORQL, only the MIN and MAX functions are extended in order to obtain the max-imum or minimum value of a variable, whereas the rest of the aggregate functions will be studied in future work. The syntax of the MIN and MAX functions to obtain the minimum or maximum value of the variable v bute at c i is:
SELECT [MAX j MIN] VALUE  X  at c i v j  X  FROM h Table i 4.2. Computational techniques of their characteristics are explained in the following subsections. 4.2.1. Gr X bner Bases
One of the most promising schemes to solve systems of polynomial equality equations is Gr X bner Bases. Gr X bner Bases theory is the origin of many symbolic algorithms used to manipulate multiple-variable polynomials. This scheme is a gen-equations.

Using Gr X bner Bases makes it possible to transform a set of polynomial constraints into a standard form. Let the set of polynomial equality constraints be in the form P  X  0, hence Gr X bner Bases theory allows an equivalent system G  X  0to properties than the original systems.

An easy example of Gr X bner Bases is: By using the equations { a + b =c, d + e = f , c only the variables { a , b , d , e , g } are presented. Here the solution is { g ( a + b )
The Buchberger algorithm [7] was the first algorithm for computing such Gr X bner Bases. The first improvement was re-lated with strategies during Gr X bner computation (F4 [23]). Another open issue was to remove useless computations, which was precisely the goal of Faug X re [22] in order to give a theoretical and practical answer. algorithm which uses Gr X bner Bases the fewest number of times possible. 4.2.2. Cylindrical algebraic decomposition
The quantifier elimination for inequality constraints is based on cylindrical algebraic decomposition. It is a technique used in the study of topological properties of semi-algebraic sets, which decomposes the space into a number of regions,
The cylindrical algebraic decomposition returns inequality constraints whose borders involve algebraic functions. In or-der to explain these ideas, the example shown in Fig. 7 is used.

In the example of Fig. 7 , the following constraints are represented: cumference, also of radius 1, but centred at ( 1,0).
 lines are created. These divisions are formed depending on the value of x where both constraints have the same y value, which leads us to perform an analysis of these points. In this case the following new constraints are obtained:
The quantifier elimination over variable y can separate the part of the constraint where only x is involved, and yields: tion over integer or natural domains [33]. 4.2.3. Constraint satisfaction problems and constraint optimization problems
Constraint satisfaction problems (CSPs) represent a reasoning framework consisting of variables, domains and con-straints. Formally, it is defined as a triple h X , D , C i where X  X f x d  X  x 2  X  ; ... ; d  X  x n  X g is a set of domains of the values of the variables, and C  X f C straint C i is defined as a relation R on a subset of variables V  X f x may be represented as a subset of the Cartesian product d  X  x sible values of the variables in V simultaneously in order to satisfy R . Let V  X  x 1 ; x k 2 ; ... ; x k l  X  from d  X  x k 1  X  ; d  X  x k 2  X  ; ... ; d  X  x if it satisfies the constraints C .

Usually, to solve a CSP, a combination of search and consistency techniques is used [17]. The consistency techniques re-mization techniques have been proposed as ways of improving the efficiency of search algorithms. function f that has to be optimized (maximised or minimised): the COP [15,34] . 4.3. Labelled object-relational CDB architecture
Here, the term architecture is used to refer to a set of software components which work with constraints. The computa-holistic solution as a proposal.
 query-driven model, computational processing and data layer: information as in a relational database, but it is also possible to store constraints as objects.
The query-driven model layer obtains the constraints related to the query, and builds a model that will be solved by the needed to evaluate the projection depending on the type of query, as explained in Section 5. This submodule is crucial since it allows the creation of constraint problems with only those constraints necessary, thereby improving the compu-tational evaluation time. Once the related constraints are known, the submodule Build Models depending on the type of submodule numeric resolution deals with queries whose solutions are numeric values (when the projection uses the word
VALUES ), while the submodule symbolic resolution works with symbolic techniques for queries whose answers are new constraints inferred from the stored constraints (when the projection uses the word the module numeric resolution has two submodules in order to build constraint satisfaction problems (if a set of values has to be obtained) or constraint optimization problems (if only the minimum or maximum value of a variable has to be known). The module symbolic resolution has two submodules that are used depending on the type of constraints related algebraic decomposition for inequality polynomial constraints.
 include other tools.

Management has been used, although it is also possible to use any database management that permits the object-rela-tional paradigm. When a LORCDB is created or queried, the CORQL sentences are transformed into SQL sentences known by the database management system (Oracle in this case).

This architecture is modular so that those modules which evaluate the query can be modified or extended. For example, if types of constraints and the evaluation query modules can be extended.
 depending on the Query are presented. These submodules are in charge of analysing the query to reduce the computational complexity and to define an efficient plan for the evaluation of the query. 5. Search engine for related constraints arately, thereby building smaller and easier problems to solve. 5.1. Step 1  X  Selection of the solving tool and the type of model then the problem will be solved using cylindrical algebraic decomposition. 5.2. Step 2  X  Identification of clusters of related constraints resent the edges. Two constraints have an edge in common if they have a common variable. to another constraint (node) with a variable of the projection.
 graph, where the connected component has at least one variable of the projection.
 f A ; A 2 ; M 1 ; M 2 ; M 3 g .
 straint as f c  X  6 a g , because b is presented in both constraints and can therefore be substituted. This idea generates a new definition.
 Definition 5.2 ( Cluster of related constraints for symbolic projection (CRC)). G query Q (CRC( Q )) if Querys( C , Q ) are the variables of the constraints C that appear in the query Q .
 f A ; M 1 ; M 2 g ; f A 2 ; M 2 ; M 3 g and f A 1 ; A 2 ; M 1 variables, then these constraints form a CRC.
 However, another definition is necessary to describe the algorithm to obtain the clusters of related constraints: algorithm uses a list of constraints in the search ( ConstraintList ): Algorithm 1. Obtaining CRCs for Symbolic Projection List ConstraintList :  X  new List() List CRC :  X  new List()
Boolean end :  X  LoadConstraintList(ConstraintList) while ( : end) do Description of methods: List does not change, the method returns false to indicate that the search has finished. are the edges. In order to determine if a set of constraints forms one or more CRCs, the method looks for the connected components. These connected components form a CRC if all the VarNoQuery variables are in at least two constraints and it is minimal. In order to determine if the CRC is minimal, it is necessary to analyse only the VarNoQuery variables that appear in more than two constraints. If a connected component cc appear in more than two constraints, then the method analyses whether f cc means that cc i is a CRC. Otherwise, the process continues to determine whether f cc
When a CRC is determined in the ConstraintList , these constraints are deleted from ConstraintList . void deleteUnSolvedConstraints(List): This method deletes the unsolved constraint according to Definition 5.3. The algorithm to obtain the CRCs is better explained with a more complex example, as shown in Fig. 10 where the Var-SELECT CONSTRAINTS (Behaviour.a, Behaviour.b, Behaviour.c, FROM Component
For the example in Fig. 10 and the variables of the last query, the names of the components related to the constraints obtained with the LoadConstraintList method are: {A1, A2, M3, A7, A23, S1, A11, M4, A18}
In fact the algorithm works with the field idConstraint , although here the names of the components are used in order to clarify the explanation. The known constraints are those shown in Step a of Fig. 11 , obtained with the method LoadCon-ables, to the previous list. After this execution the ConstraintList has the constraints: {A1, A2, M3, A7, A9, S1, A11, M4, A18, M1, A3, A8, A23, M6, A10, M9} two CRCs: {A1, A2, M3, M1} and {A9, S1, A11, M11, M6, A10}
Hence the rest of the constraints of ConstraintList are: {A7, A3, M4, A8, A18, M9} in Step c of Fig. 11 ) becomes: {A7, A3, M4, A8}
The search continues with the variables { j , q , t }, and the new list (shown in Step d of Fig. 11 ) becomes: {A7, A3, M4, A8, M2, A6, M5} this point the process finishes, since there are no constraints left to analyse in ConstraintList . return any information.

The computational complexity of the algorithm is related to the number of constraints stored in the LORCDB and not to required.
 constraints, there is an edge between two nodes if they have the same variable. If C
C . The distance between two variables of the same constraint is 0.
 necessary to study two scenarios, which are: search for the constraints is expanded depending on both VarQuery variables and VarNoQuery variables included in pre-vious expansions. Hence, the worst case is half of the longest distance between two variables of the same CRC. For the example of Fig. 11 , the distance between the variables a 1 and a 2 is 4, and both of them are VarQuery variables, which means that it is necessary to execute the search algorithm for constraints twice.

WhenitisnotpossibletofindaCRCforthe VarQuery variablesdefinedfortheprojection.ItisnotalwayspossibletofindCRCs (suchasM5,A8,M4, ... )becausetheyareunsolvedconstraints.Anotherunfavourablecaseisthegreatestdistancebetweena
VarQuery andanother VarNoQuery whichisimpossibletosolvebecausethisvariablebelongstoan unsolvedconstraint .Forthe means that it is necessary to execute the search for constraints three times until an unsolved constraint is found. algorithm to obtain CRCs is: where a , b , c are VarQuerys and d is a variable of an unsolved constraint. 6. Building models depending on the type of query the section above. Depending on the query, one of the aforementioned techniques is used for its evaluation. 6.1. Symbolic model for equality constraint query
This type of model is created when a new set of constraints has to be obtained using those stored, and the stored con-the variables of the query, must be replaced by variables of the query.
 An example of a query solved using this symbolic technique is: SELECT CONSTRAINTS (Behaviour.m, Behaviour.j, Behaviour.g, the variables { m , j , g , d , r , s }.

For these variables and using the explained algorithm, three different CRCs are found, as shown in Fig. 12 . This figure shows an example formed by equality polynomial constraints and the new constraints inferred from the originals. The dif-constraints are presented.

Since all the constraints are labelled as polynomial equality constraints, Gr X bner Bases technique implemented in Math-ematica TM ) v : 5 is used. The prototype of the function is: GroebnerBasis[ { CRC } , { VarQuerys } , { VarNoQuerys } ] For the system presented in the figure above, an example of the model for equality constraint projection is:
GroebnerBasis[ f g d u  X  0 ; m  X  j q  X  0 ; q k r  X  0 ; k  X  u s  X  0 g whose result is: { d * g * j + d * g * m + r j * s m * s = 0}.

It is also possible to combine classic and constraint attributes using projection. For example, to know the CARCs of the systems and the Context Sets for these CARCs, the query could be: SELECT Name , CONSTRAINTS (Behaviour.m, Behaviour.j, Behaviour.g,
The result is shown in Table 2 , where three different CARCs appear in the column Behaviour , and the components related with them in the column Name . 6.2. Symbolic model for inequality constraint query for example, the system of Fig. 10 has constraints associated to the components such as: A16: i1+j1 6 q1 S2: k1-l1 6 r1 M7: q1 * r1 6 u1 A12: q1+u1 6 s2
An example of a query in fault diagnosis could be: how does the system work if the sensors are located in the variables { i1 , j1 , k1 , l1 , s2 }? The query is: SELECT CONSTRAINTS (Behaviour.i1, Behaviour.j1, v.5 is also used. The syntax is: Reduce[Exists[ { VarNoQuery } ,CRC], { VarQuery } ] For the example, the model created to solve the projection is:
Reduce[Exists[ { q1, r1, u1 } ,i1 + j1 6 q1 ^ q1 * r1 6 u1 ^ k1 -l1 6 r1 ^ q1 + u1 6 s2],
In this case, the output of the function is: j1 &lt; -i1 _ j1 = -i1 ^ (l1 P 1+k1 ^ s2 P 0 _ l1 &gt; 1 + k1) _ j1 closed property. 6.3. Numeric model for constraint satisfaction problems projection can be the search for 10 possible tuples of values for the variables SELECT VALUES[10](Behaviour.g2, Behaviour.p2, Behaviour.q2) puts, when the user knows the values of some variables but wants to know the values of others. For instance, what is the value of u if the value of the sensors are: f a  X  1 ; b  X  3 ; c  X  2 ; d  X  1 g ? The query for this example is: SELECT VALUES[1](Behaviour.u) FROM Component WHERE Behaviour.a=1 AND Behaviour.b=3 although only VarQuery variables are presented as the solution. A common issue in diagnosis is the problem of knowing whether the system works correctly for an observational model. This is discovered by carrying out the projection over a constraint attribute. An example of this type of query can be: Does the system work correctly for the OM f a  X  1 ; b  X  3 ; c  X  2 ; d  X  1 ; u  X  15 g ? This query is: SELECT VALUES[1] (Behaviour.a, Behaviour.b, Behaviour.c, WHERE Behaviour.a=1 AND Behaviour.b=3 AND Behaviour.c=2 not working correctly. 6.4. Numeric model for constraint optimization problems
When a numeric evaluation obtains several tuples and the user wants to select from among the possible options, a COP has to be created. CORQL makes it possible to obtain the maximum or minimum value of a variable, and an example of a query that creates this type of module is: SELECT MIN VALUE(Behaviour.u) FROM Component
A COP is built according to a query in a similar way to a CSP, and it is also possible to add new constraints to the COP defined in the query. An example can be: SELECT MIN VALUE(Behaviour.u) FROM Component WHERE Behaviour.a &gt;  X  3 AND Behaviour.b &gt;  X  1 7. Experimental results for the projection operator and without using CRCs for symbolic projection, and also with and without using heuristics for numeric projection. base Management System Oracle is running. All the measures are presented in milliseconds.
All solutions are presented over float domain problems, since natural or integer domains cannot always be used for sym-complex to solve than over the integer domain, and hence the worst domain case for the numeric projection is analysed in this work.

The problems used in the tests are generated randomly, whereby different parameters are changed. All the constraints have the form { v 1 operation v 2 comparator v 3 }. Each constraint of a problem has a set of variables ( problems that can be diagnosed. The relation between the constraints will be defined for those variables shared between the different constraints.

The random problems are created incrementally, by adding new constraints whose variables can be new variables or vari-ables already included in the problem. The systems created in this way are composed of one connected component according the worst case of the projection for a constraint problem. 7.1. Symbolic projection evaluation constraints.

To show how the evaluation time decreases when only CRCs are analysed, two options are compared. The first option is to or with duplications are not analysed. The compared options are:
Checking all the combinations: This involves the analysis of  X  2 either Gr X bner Bases or cylindrical decomposition is used to obtain new constraints with only VarQuery variables depend-ing on the type of related constraints.
 variables. This means that symbolic-elimination techniques can be only used with some sets of constraints. 7.1.1. Test queries for symbolic projection performance ferent depending on the technique used to evaluate the projection (Gr X bner Bases or cylindrical decomposition). In both uation times.
 proposed improvement using CRCs, and without this improvement. The evaluation time used to obtain the CRCs is also shown as a part of the whole time necessary to evaluate the whole query. In Fig. 14 , it is also possible to observe how the use of CRCs drastically reduces the evaluation time. Using more than 18 constraints, the evaluation times without improvement go sky high. In the bar diagram this is presented with the value 10 the evaluation time is exponential according to the number of variables, as was explained in Section 4.2.1.
Obviously, the evaluation time depends on the structure of the constraint relation (relation between constraints), the number of constraints, the number of variables of the projection and the type of constraints (linear or polynomial). variables changes and the type of constraints changes.

The results presented in Fig. 15 have been generated by a randomly created static structure whilst changing the number how the time drops when the number of variables of the projection grows because the distance between the variables are a relation to be found between the number of polynomial constraints and the execution time when Gr X bner Bases are used, since the algorithm complexity is exponential according to the number of variables that have to be eliminated. are presented. The comparison is defined both with the proposed improvement, and without this improvement. The part of In the bar diagram this is presented with the value 10 9 , although the processes take longer than 8 days. way to Gr X bner Bases, the evaluation time depends on the structure of the system, the number of constraints and the num-changes for a constraint relation when the number of VarQuery variables changes and the type of constraints changes.
The results presented in Fig. 17 have been generated by a randomly created static structure whilst changing the number is changed, it is possible to observe how the time increases when the number of polynomial constraints grows. 7.2. Numeric projection evaluation our architecture makes using these heuristics easier in order to solve the models, and some comparisons are presented in this work: obtained from the CDB.

By domain: This means starting with the variable with the smallest domain. The most used variable-ordering heuristic selects the variable with the minimum number of values in its current domain [32]. This is possible since the LORCDB stores the minimum and maximum value of each variable as a box consistency.
 of polynomial constraints after. 7.2.1. Test queries with numeric projection
In this section, some examples of queries which obtain instantiated values of variables are presented. A set of random examples and projections have been executed, whereby some parameters have been changed such as the number of con-straints and the number of polynomial constraints.

Some measurement times for the evaluation of each query using the different heuristics are presented in Fig. 18 . These tion time depends on the number of constraints. Fig. 18 also shows how the evaluation time for the same problem changes linear constraints are changed into polynomial constraints. This means that the behaviour of the constraints changes of constraint is changed. For the solved examples, the execution time experiences a slight decrease when the number of domain of the solution through the use of polynomial constraints.
 son, the number of variables of the projection has not been analysed for numeric resolution purposes. 7.3. Projection over the maximum or minimum value of a constraint-variable attribute a constraint optimization problem with all the constraints which belong to the CRCs. By using the proposed architecture this case two ways are compared to show how the evaluation time drops sharply when using the box consistency. The dif-ferent ways that are compared are: the solutions are analysed to find the best value from among all the solutions found. idea to solve a COP is to avoid studying all the possible solutions to obtain the maximum or minimum value of a con-this end, we propose starting the instantiation for the objective variable with a value-ordering by using the most prom-imum value of the objective variable stored in the LORCDB or with the maximum value otherwise. Hence, we transform a solution is found for r  X  15, the process has to proceed until the whole domain is analysed. 7.3.1. Test queries over maximum value maximum value of a variable. In Fig. 20 , the different measurements are presented which are produced by changing the with the objective variable and the appropriate instantiated value.
 parison with all other solutions.
In this case, other tests have also been executed which are produced by changing the number of polynomial constraints due to the type of problems created, and the reduction of the possible values in the domain of the solution through the use of polynomial constraints. 8. Conclusions and future work to evaluate each query. Furthermore, important optimization improvements are presented, such as: The indexation of variables in order to improve the computation time of the query or the use of heuristics to solve CSP.
An algorithm to obtain the CRCs, which improves the computation time in symbolic techniques. This algorithm creates constraint problems with only those constraints related to the query.
 The storing of the box consistency to reduce the options to solve the CSPs and COPs.

The labelling of the constraints to decide which tool is more appropriate for the evaluation of a query where the con-straints are involved.

The architecture is designed in layers which provides a means of interaction between the user and the system. The use of architecture also offers a way of including constraints into the query which are not stored in the CDB.
Finally, some examples and computation times are presented in order to demonstrate how the architecture helps in the evaluation of queries with the projection operator.

As future work, we suggest an extension to the selection, Cartesian product, union and difference operators in order to dard SQL, such as UPDATE, REMOVE and other aggregation functions.
 Acknowledgements This work has been partially funded by the Ministry of Science and Technology of Spain (DPI2006-15476-C02-00) and the
European Regional Development Fund (ERDF/FEDER).
References
