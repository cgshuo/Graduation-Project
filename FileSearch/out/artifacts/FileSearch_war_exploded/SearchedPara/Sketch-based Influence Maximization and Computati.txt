
The spread of contagion (information diffusion or spread of an infection) is a universal phenomenon that is extensively studied in the context of physical, biological, and social networks. Such cascades can have one or multiple sources (or seeds ) and spread from infected nodes to neighbors through the link structure. A motivating application for the study of influence is viral marketing strategies [14, 23], in which the influence of a set S of people in a social network is the number of adoptions triggered if we give S free copies of a product. The problem also has important applications beyond social graphs, such as placing sensors in water distribution networks for detecting contamination [20].
 A popular model for information diffusion is Independent Cascade (IC), in which an independent random variable is associated with each (directed) edge ( u,v ) to model the degree of influence of u on v . A single propagation instance is obtained by instantiating all edge variables. We then study the distribution of a property of interest, such as the number of infected nodes, over these random instances.

The simplest and most studied IC model is binary IC , in which the range of the edge random variables is binary. A biased coin of probability p uv is flipped for each directed edge ( u,v ) . Accordingly, the edge can be either live , meaning that once u is infected, v is also infected, or null . This model was formalized in a seminal work by Kempe et al. [19] and is based on earlier studies by Goldenberg et al. [14]. Note that each direction of an undirected edge { u,v } may have its own independent random variable, since influence is not necessarily symmetric. A particular propagation instance is specified by the set of live edges, and a node is infected by a seed set S in this instance if and only if it is reachable from a seed node. The influence of S is formally defined as the expectation, over instances, of the number of infected nodes. Instead of working directly on this probabilistic IC model, Kempe et al. [19] proposed a simulation-based approach, in which a set { G ( i ) } of propagation instances (graphs) is gener-ated in Monte Carlo fashion according to the influence model. The average influence of S on { G ( i ) } is an unbiased estimate that converges to the expectation on the probabilistic model. The ability to compute influence with respect to an arbitrary set of propagation instances has significant advantages, as it is useful for instances generated from traces or by more complex models [16, 1], which exhibit correlations between edges that cannot be captured by the simplified IC model [15]. Moreover, the average behavior of a probabilistic model on a small set of instances captures its  X  X ypical X  behavior, which is often more relevant than the expected value when the variance is very high.

A basic primitive in the study of influence are influence queries : Compute (or approximate) the influence of a query set S of seed nodes. With binary influence, this amounts to performing graph searches from the seed set in multiple instances. Unfortunately, this does not scale well when many queries are posed over graphs with millions of nodes. Even more computationally challenging is the fundamental Influence Maximization problem, which is finding the most potent seed set of a certain size or cost. The problem was formalized by Kempe et al. [19] and inspired by Richardson and Domingos [23]. Kempe et al. showed that, even when the influence function is deterministic (but the number s of seeds is a parameter), the problem encodes the classic Max Cover problem and therefore is NP-hard [19]. Moreover, an inapproximability result of Feige [13] implies that any algorithm that can guarantee a solution that is at least (1 1 /e + ) times the optimum is likely to scale poorly with the number of seeds. Chen et al. [5] showed that computing the exact influence of a single seed in the binary IC model, even when edge probabilities are p = 0 . 5 , is #P hard [5].
Using simulations, the objective studied by Kempe et al. [19] is then to find a set S of seeds with maximum aver-age influence over a fixed set of propagation instances. A natural heuristic is to use the set of most influential individ-uals, say those with high degree or centrality [19], as seeds. This approach, however, cannot account for the dependence between seeds, missing the fact that two important nodes may  X  X over X  essentially the same communities. Kempe et al. [19] proposed a greedy algorithm ( Greedy ) instead. It starts with an empty seed set and iteratively adds to S the node with maximum marginal gain in influence (relative to current seed set). Since our objective is monotone and submodular, a classical result from Nemhauser et al. [21] implies that the influence of the greedy solution with s seeds is at least 1  X  (1  X  1 /s ) s  X  63% of the best possible for any seed set of the same size. From Feige X  X  inapproximability result, this is the best approximation ratio guarantee we can (asymptotically and realistically) hope for.

Greedy has become the gold standard for influence max-imization, in terms of the quality of the results. Greedy however, does not scale to modern real-world social networks. The issue is that evaluating the marginal contribution of each node requires a directed reachability computation in each instance (of which there can be hundreds). Several per-formance improvements to Greedy have thus been proposed. Leskovec et al. [20] proposed CELF, which are  X  X azy X  eval-uations of the marginal contribution, performed only when a node is a candidate for the highest marginal contribution. Chen et al. [6] took a different approach, using the reachabil-ity sketches of Cohen [7] to speed up the reevaluation of the marginal contribution of all nodes. While effective, even with these and other accelerations [17, 22], the best current imple-mentations of Greedy do not scale to networks beyond 10 6 edges [5], which are quite small by modern standards.
To support massive graphs, several studies proposed algo-rithms specific to the IC model, which work directly with the edge probabilities instead of with simulations and thus can not be reliably applied to a set of arbitrary instances. Borg et al. [3] recently proposed an algorithm based on reverse reachability searches from sampled nodes, similar in spirit to the approach used for reachability sketching [7]. Their algorithm provides theoretical guarantees on the approxima-tion quality and has good asymptotic performance, but large  X  X onstants. X  Very recently, Tang et. al. [25] developed TIM, which engineers the (mostly theoretical) algorithm of Borgs et al. [3] to obtain a scalable implementation with guarantees. A significant drawback of this approach is that it only works for a pre-specified seed set size s , whereas Greedy produces a sequence of nodes, with each prefix having an approxima-tion guarantee with respect to the same-size optimum. In applications we are often interested not in a single point, but in a trade-off curve that allows us to find a sweet spot of influence per cost or characterize the network. TIM also scales very poorly with the seed set size s , and the evaluation only considered seed sets of up to 50 nodes.

The DegreeDiscount [6] heuristic refines the natural ap-proach of adding the next highest degree node. MIA [5] converts the binary IC sampling probabilities p e to deter-ministic edge weights and works essentially with one deter-ministic instance. IRIE, by Jung et al. [18], is a heuristic approximation of greedy addition of seed nodes, and has the best performance we are aware of for an algorithm that produces a sequence of seed nodes. In each step, the proba-bility of each node to be covered by the current seed set estimated using another algorithm (or simulations). They then use eigenvector computations to approximate marginal contributions of all nodes. Of those approaches, the IRIE heuristic scales much better and is much more accurate than other heuristics. In particular, it performs nearly as well as Greedy on many research collaboration graphs [18].
We design a novel sketch-based approach for influence com-putation which offers scalability with performance guarantees. Our main contribution is SKIM (SKetch-based Influence Maximization), a highly scalable (approximate) implementa-tion of the greedy algorithm for influence maximization. We also introduce influence oracles : after preprocessing that is almost linear, we can answer influence queries very efficiently, considering only the sketches of the query seed set.
We can apply our design on inputs specified as a fixed set of propagation instances, as in Kempe et al. [19], with influence defined as the average over them. We also handle inputs specified as an IC model, where influence is defined as the expectation. Our model is defined precisely in Section 2.
We now provide more details on our design. The exact computation of an influence query requires expensive graph searches from the query seed set S on each of ` instances. The exact greedy algorithm for Influence Maximization requires a similar computation for each marginal contribution. We address this scalability issue by working with sketches.
The core of our approach are per-node summary structures which we call combined reachability sketches . The sketch of a node compactly represents its influence  X  X overage X  across instances; we call this its combined reachability set . The combined reachability sketch of a node, precisely defined in Section 3, is the bottom-k min-hash sketch [10, 8] of the combined reachability set of the node. This generalizes the reachability sketches of Cohen [7], which are defined for a single instance. The parameter k is a small constant that determines the tradeoff between computation and accuracy. Bottom-k sketches of sets support cardinality estimation, which means that we can estimate the influence (over all instances) of a node or of a set of nodes from their combined reachability sketches. The estimate has a small relative error and good concentration [7]. Our use of combination sketches and state-of-the-art optimal estimators is key to obtaining the best balance between sketch size and accuracy.
Our SKIM algorithm for influence maximization is pre-sented in Section 4. It scales by running the greedy algorithm in  X  X ketch space, X  always taking a node with the maximum estimated (rather than exact) marginal contribution.
SKIM computes combined reachability sketches, but only until the node with the maximum estimated influence is computed. This node is then added to the seed set. We then update the sketches to be with respect to a residual problem in which the node that is selected into the seed set and its  X  X nfluence X  are no longer present. SKIM then resumes the sketch computation, starting with the residual sketches, but (again) stopping when a node with maximum estimated influence (in the current, residual, instance) is found. A new residual problem is then computed. This process is iterated until the seed set reaches the desired size. Since the residual problem becomes smaller with iterations, we can compute a very large seed set very efficiently. We also prove that the total overhead of the updates required to maintain the residual sketches is small. In particular, for a set { G ( i ) } of ` arbitrary instances, the algorithm can be run to exhaustion, producing a full permutation of the nodes in over nodes of the maximum indegree (over instances). For all s  X  1 , the first s nodes we select have with a very high probability (at least 1  X  1 /n c for a constant c ) influence that is at least 1  X  (1  X  1 /s ) s  X  times the maximum influence of a seed set of the same size s . These are worst-case bounds. We propose an adaptive approach that exploits properties of actual networks, in particular a skewed influence distribution, to achieve faster running times with the same guarantees.
Our use of the residual instances by SKIM is the key for maintaining the accuracy of the greedy selection through the execution and providing with high probability, approximation ratio guarantees that nearly match those of exact Greedy .
Section 5 presents our influence oracles, which preprocess the input to compute combined reachability sketches for all nodes. For instances { G ( i ) } with n nodes and m ( i ) edges, the sketches are built in O ( k P of a set S  X  V can then be approximated from the sketches of the nodes in S . The oracle applies the union cardinality estimator of Cohen and Kaplan [11] to estimate the union of the influence sets of the seed nodes. The query runs in time O ( | S | k log | S | ) and unbiasedly with a well-concentrated rela-tive error of = 1 /  X  k . While preprocessing depends on the number of instances, the sketch size and the approximation quality only depend on the sketch parameter k .

The asymptotic bounds we obtain are novel also from a theoretical perspective, and significantly improve the state of the art, even for influence maximization on a single (de-terministic) instance (select a seed set in a directed graph with maximum reachable set).

Section 6 presents an extensive experimental study. Be-sides demonstrating the scalability of our algorithms on real-world networks, we compare SKIM with existing ap-proaches, including exact Greedy (when size allows), the state-of-the-art IRIE heuristic, and TIM. We obtain IC mod-els from networks by using the well-studied weighted and uniform [19] probabilities. Our algorithms scale up to very large graphs with barely any compromise on quality over exact Greedy , with theoretical guarantees. On instances generated by an IC model, we achieve more than an order of magnitude speedup over the best greedy heuristics, which are designed specifically for this model. Even for a fixed small seed set size, SKIM is significantly faster than TIM.
Moreover, our algorithm is efficient and accurate enough to be executed exhaustively, producing a full permutation of the nodes for networks with billions of edges. For the first time, we provide the full (approximate) Pareto front of influence versus seed set size. These relations showcase a basic property of the network, and the general pattern that a small fraction of nodes influences a large fraction of the network. In contrast, most previous studies we are aware of only considered seed sets with at most 50 nodes, revealing only a very restricted view of this relation.
A propagation instance G = ( V,E ) is specified by the edge set E . The influence of a set of nodes S in instance G is the number of nodes reachable from S using the edges E : where the predicate S ; u holds if u  X  S or if there is a forward path from a node in S to the node u .

Our input is specified as a set G = { G ( i ) } of `  X  1 prop-The influence of S over all instances { G ( i ) } is the average single-instance influence: The set of propagation instances can be derived from cascade traces or generated by a probabilistic model.

The input can also be specified as a probabilistic model, such as Independent Cascade (IC) [19], which defines a dis-tribution G over instances G  X  X  that share a set V of nodes. In this case, the influence of G is defined as the expectation
We are interested in influence oracles and in influence maximization . Influence queries are specified by a seed set S  X  V and the goal is to compute (or estimate) the influence Inf ( G ,S ) . Influence oracles, after efficient prepro-cessing of the input, allow us to support very fast queries. Influence maximization is the problem of finding a seed set S  X  V with maximum influence, where | S | = s is given. We are interested in efficiently computing a seed set whose influence is close to the maximum one, as well as in comput-ing a sequence of seeds so that each prefix has influence that is close to maximum for its size.
At the heart of our approach are combined reachability sketches , which are summary structures X u that we associate with each node u . The combined sketches can be defined with respect either to a set G = { G ( i ) } of `  X  1 instances or to a probabilistic model G .

We first consider as input a set of `  X  1 instances. We de-fine the reachability set of a node u in instance G as R ( { v | u ; G v } , where u ; G v means that v is reachable from u in G . Considering all instances, the combined reacha-bility set is a set of node-instance pairs: R u = { ( v,i v } . The influence of a set of nodes S on instances { G ( i ) thus be expressed as
Inf ( { G ( i ) } ,S ) = This is the average over the instances { G ( i ) } (with i  X  the number of nodes reachable from at least one node in S
The combined reachability sketch of a node captures its reachability information across instances. The sketches we use are the bottom-k min-hash sketches [7, 10] X v of the combined reachability sets R v : We associate with each node-instance pair ( v,i ) an independent random rank value r ( i ) U [0 , 1] , where U [0 , 1] is the uniform distribution on [0 The combined reachability sketch of u is the set of the k smallest rank values amongst { r ( i ) v | ( v,i )  X  R u } where Bottom-k of a set is its subset consisting of the k smallest values. When there is a single instance ( ` = 1 ) the combined reachability sketches are the same as the reacha-bility sketches of Cohen [7].

We define the threshold rank  X  u of each node u as which is the k th lowest rank value in R u . (For a set Y of cardinality | Y | &lt; k , we define k th ( Y )  X  1 .) Therefore, when | X u | = k we have  X  u = max { X u } , and  X  u = 1 otherwise. The cardinality | R u | can be estimated from X u using a bottom-k cardinality estimator. The estimate is | X u | if has a Coefficient of Variation (CV), which is the ratio of the standard deviation to the mean, that is never more than 1 /  X  k  X  2 and is well concentrated [7]. By applying Chernoff bounds with c &gt; 1 , we obtain that using k = (2 + c )  X  2 ln n , the probability of having relative error larger high probability on estimating the influence of all nodes.
Instead of using ranks drawn from U [0 , 1] , we can work with integral permutation ranks with respect to a permutation on the n` node-instance pairs. We can also structure the permutation so that each sequence in positions in + 1 to ( i + 1) n for integral i  X  0 has each node appear in exactly one pair. The associated instance with a node v in chunk i randomly selected from instances j for which the pair ( v,j does not have a permutation rank of in or less (independently for each node). One can show that this can only improve estimation accuracy [8]. Only the first min { k,` } n positions can be included in combined reachability sketches of nodes.
When estimating influence, we can convert permutation ranks to random ranks using the exponential distribution [7]. We can also estimate cardinality of a subset of the D = n` elements directly from permutation ranks [ D ] , using the unbiased estimator 1 + ( k  X  1)( D  X  1) / ( T  X  1) , where the threshold T is the k th smallest permutation rank. This estimator can be interpreted as setting aside the element with permutation rank T , and estimating the fraction (of the other D  X  1 elements) that is in our set by the fraction of such elements with rank smaller than T , which is ( k  X  1) / ( We now define sketches with respect to a binary IC model G , presented as a graph with probabilities p e associated with its edges. The influence of a set of nodes S is The sketches we define for G also contain at most k rank values, but provide approximation guarantees with respect to (7) . The sketches can be interpreted as the sketches computed for ` instances generated according to the model G  X  G as `  X   X  . When doing so, at the limit, each unique rank value corresponds to a unique instance, so we do not need to explicitly represent  X  X nstances. X  We work with structured permutation ranks (Section 3.1). Since it suffices to consider the first kn ranks, this conveniently removes the dependence of the rank representation on ` . We can similarly apply an estimator to the k th smallest rank T  X  kn  X  k to estimate influence: Instead of estimating cardinality (which goes to infinity with ` ) and dividing by ` using the estimator influence using n ( k  X  1) / ( T  X  1) .
In this section we present our Sketch-based Influence Max-imization (SKIM) algorithm. We first review Greedy , the greedy algorithm for influence maximization (working with ` instances) presented by Kempe et al. [19]. Greedy is applied with respect to the influence objective Inf ( G ,S defined in Equation (2) . It starts with an empty seed set S =  X  . In each iteration, it adds to S the node v with maximum marginal gain ,
Inf ( G ,S  X  X  v } )  X  Inf ( G ,S ) = This is the same as choosing v maximizing Inf ( G ,S  X  X  v }
SKIM approximates exact Greedy by ensuring that at each iteration , with sufficiently high probability, or in expec-tation over iterations, the node we choose to add to the seed set has a marginal gain that is close to the maximum one. To do so, it suffices to compute sketches only to the point that the node with the maximum estimated marginal gain is revealed. To maintain accuracy, we maintain a residual problem and respective sketches.

SKIM constructs (partial) combined reachability sketches by adapting a construction of reachability sketches [7]: It processes node-instance pairs ( u,i ) by increasing rank, per-forming a reverse reachability search in G ( i ) from u . The sketch X v of each visited node v is augmented with the rank r u of the pair. For a given value of k , the first node u whose sketch reaches size k is also the node with maximum estimated influence. This is because the bottom-k cardinality estimate of a node depends only on the k th smallest rank in
X u ,  X  u (which is a complete sufficient statistic for cardi-nality estimation from the sketch [8]); see Equation (6) . For the node u ,  X  u is equal to the rank r ( i ) u of the last processed pair ( u,i ) . For other nodes v with incomplete sketches, we know that  X  v  X  r ( i ) u , so their estimate is lower.
Sketch building is suspended once the node v with max-imum estimated influence is found. SKIM then adds v to the seed set and generates a residual problem, with v and all node-instance pairs it covers removed from the instances G The (partially computed) sketches of each remaining node u are updated using X u  X  X u \ X v , which deletes from the sketch the ranks of all covered node-instance pairs.
The process of building sketches is then resumed on the residual problem, working with updated partial sketches and instances. We continue processing node-instance pairs Algorithm 1: Sketch-based Influence Maximization // Initialization forall the pairs ( u,i ) do covered[ u,i ]  X  false forall the nodes v do size[ v ]  X  0 index  X  hash map of node-instance pairs to nodes seedlist  X  X  X  // List of seeds &amp; marg. influences rank  X  0 shuffle the n` node-instance pairs ( u,i ) // Compute seed nodes while | seedlist | &lt; n do return( seedlist ) in increasing rank order, starting from the first rank that exceeds  X  v and skipping pairs that are already covered.
We provide pseudocode for SKIM as Algorithm 1. Instead of maintaining the actual partial sketches X v , the algorithm only keeps their cardinalities size [ v ] . To support correct and efficient updates of the sketches, we maintain an inverted in-dex index [ u,i ] that lists, for each rank value r ( i ) all nodes v such that r ( i ) u  X  X v . The entry for rank created and populated when we perform a reverse reachabil-ity search from pair ( u,i ) . The algorithm outputs the list seedlist of pairs (  X  i ,I i ) , where {  X  i } is a permutation of the nodes according to the order they are selected into the seed set, and I i is the marginal influence of  X  i .

The surprising property of our construction is that this whole iterative process is very efficient. If we run SKIM with a fixed k = c  X  2 log n , Section 4.1 will show that we obtain the following worst-case performance guarantees:
Theorem 4.1. SKIM runs in time O ( n` + P i | E ( i ) | + m The permutation {  X  i } of nodes has the property that with probability 1  X  1 /n  X ( c ) , for all s  X  [ n ] , the set of seed nodes S = {  X  1 ,..., X  s } , has Inf ( { G ( i ) } ,S )  X  ) arg max
It is not hard to show that the influence of a node v in the residual problem of iteration i is equal to its marginal influence with respect to S = {  X  1 ,..., X  i  X  1 } in the original problem. Therefore, I i , which is the influence of  X  i in the residual problem of iteration i , is the marginal influence of with respect to S = {  X  1 ,..., X  i  X  1 } in the original problem. Thus, by definition, for all s  X  [ n ] and S = {  X  1 ,..., X  Inf
We also show that the partial sketches correctly capture a component of the sketches computed for the residual problem:
Lemma 4.1. At the end of an iteration selecting v , each updated partial sketch X u is equal to the set of entries of the combined reachability sketch X 0 u of u in the residual problem that have rank value at most  X  v .

Proof sketch. The content of each sketch X u before computing the residual is clearly a superset of all reach-able node-instance pairs ( z,i ) with rank r ( i ) z  X   X  v residual problem. We can then verify that entries are re-moved from X u only and for all covered node-instance pairs
We now analyze the running time of SKIM. All updates of the residual problem together take time linear in the size of { G ( i ) } , since nodes and edges that are covered by the current seed set are removed once visited and never consid-ered again. The remaining component of the computation is determined by the number of times ranks are inserted (and removed) from sketches. Inserting a value to X u involves a scan of all (remaining) incoming edges to u in an instance. Removals of ranks can be charged to insertions. So we need to bound the total number of rank insertions:
Lemma 4.2. The expected total number of rank insertions at a particular node is O ( k ln n ) .

Proof sketch. Consider a sketch X v . We can show, viewing the sketches as uniform samples of reaching pairs, that each rank value removal corresponds to cardinality X  X nd hence influence (marginal gain) X  X eing reduced in expecta-tion by a factor of 1  X  1 /k . The initial influence is at most n , so there are at most k ln ( nk ) insertions until the marginal influence is reduced below 1 /k , at which point we do not need to consider the node.
 The running time is dominated by the sum over nodes v , of the number of times a rank is inserted to the sketch of v , times the in-degree of v (the maximum over instances). From the lemma, we obtain a bound of O ( km ln n ) on the total number of insertions. Thus, we obtain a bound of O ( km ln ( n )+ P i | G ( i ) | ) on the running time of the algorithm.
To obtain an approximation that is within 1 + with good probability, we can choose a fixed k = c  X  2 log n , for some constant c . The relative error of each influence estimate of a node in an iteration is at most with probability of at least 1 1 influence among n nodes in each of at most n iterations), all estimates are within a relative error of with probability that approximation ratio of the  X  X pproximate X  greedy algorithm we work with, which uses seeds with close to maximum instead of maximum marginal gain:
Lemma 4.3. With any submodular and monotone objec-tive function, approximate greedy, which iteratively chooses a node with marginal gain that is at least (1  X   X  ) of the maximum, has an approximation ratio of at least (1  X  (1  X  1 /s ) s  X  O (  X  )) . The same claim holds in expectation when the selection is well concentrated, that is, its probability of being below (1  X  a X  ) times the maximum decreases exponentially with a &gt; 1 .

Proof. The argument extends the analysis of exact greedy by Nemhauser et al. [21]. For any s , and after selecting any set U of seeds, the maximum marginal gain by adding a single node is always at least 1 /s of the maximum possible gain for s nodes. When using the approximation, this is at least (1  X   X  ) /s of the maximum possible gain. Therefore, after approximate greedy selection of s nodes, the influence is at least 1  X  (1  X  (1  X   X  ) /s ) s  X  1  X  (1  X  1 /s ) s  X  O the first order term of the Taylor expansion.
This worst-case analysis is too pessimistic, both for the approximation ratio and running time. In our experiments, we tested SKIM with a fixed k , and observed that the com-puted seed sets had influence that is much closer to the exact greedy selection than indicated by the worst-case bounds.
The explanation is that the influence distribution on real inputs is heavy-tailed, with the vast majority of nodes having a much smaller influence than the one of maximum influence. One factor of O ( log n ) in the worst-case running time is due to a  X  X nion bound X  ensuring a relative error of for all nodes in all iterations, with high probability. With a heavy tail distribution, we can identify the maximum with a small error if we ensure a small error only on the few nodes that have influence close to the maximum. Furthermore, when the maximum influence is separated out from other influence values, our approximate maximum is more likely to be the node with actual maximum influence. Moreover, the estimation error over iterations averages out, so as the seed set gets larger we can work with lower accuracy and still guarantee good approximation.

We propose incorporating error estimation that is adaptive rather than worst-case. This facilitates tighter confidence bounds on the estimation quality of our output. It also allows us to adjust the sketch parameter k during computation in order to meet pre-specified accuracy and confidence levels.
Let the discrepancy in an iteration be the gap between the actual maximum and the marginal influence of the selected seed. We will bound the sum of discrepancies across iterations by maintaining a confidence distribution on this sum.
The estimation uses two components. (i) The exact mar-ginal influence I s of the selected node in each iteration, as well as the sum I = P seed set. The value I s is computed when generating the residual problem. (ii) Noting in each iteration the size of the second largest sketch (excluding the last processed rank). Intuitively, if the second largest sketch is much smaller than the first one, it is more likely that the first one is the actual maximum. We bound the discrepancy in a single iteration using Chernoff bounds. The probability that the sum of independent Bernoulli trials falls below its expectation  X  more than  X  X  is We use this to bound the probability that the discrepancy exceeds  X  , where  X  is the exact marginal gain of our selected seed node. We consider the second largest sketch size, k 0 k  X  1 (the last rank of  X  is not considered part of the sketch even if included). We use Z = k 0 ,  X  =  X   X (1 + ) , and  X 
Finally, to maintain an upper bound on the confidence-error distribution of the sum of discrepancies, we take a convolution, after each iteration, of the current distribution with the distribution of the current iteration.
SKIM can be adapted for higher concurrency by running the sketch-building phases in batches of ranks. We can also adapt it to process inputs presented as an IC model instead of as a set of instances. This yields a more efficient implementation than when generating a set of instances using simulations and running SKIM on them. In IC-model SKIM, the residual problem is a collection of partial models and sketch building is performed on the probabilistic model. We omit details due to space limitations.
We now present an accurate and efficient oracle for binary influence, which is based on precomputing a combined reacha-bility sketch (as defined in Section 3) for each node. We pre-process a set of ` instances G = { G ( i ) } using O ( k P computation and working storage of O ( k ) per node. The preprocessing generates combined reachability sketches X v of size O ( k ) for each node v  X  V .

Theorem 5.1. Given a set { X v } of combined reachability sketches for G with parameter k , influence queries Inf ( for a set S of nodes can be estimated in O ( | S | k log | S | from the sketches { X u | u  X  S } . The estimate is non-negative and unbiased, has CV at least 1 / concentrated, meaning that the probability that the relative error exceeds a/
We next present the two components of our oracle: esti-mating the influence of S from the sketches of the nodes in and efficiently computing all combined reachability sketches.
We show how to use the combined reachability sketches of a set of nodes S to estimate the influence of S , as given in Equation (4) . In graph terms, this means estimating the cardinality of the union S with u  X  S . The influence Inf ( G ,S ) is the union cardinality divided by the number of instances ` and, accordingly, is esti-mated using \ S rank  X  u of each node u ; see Equation (6).

From the bottom-k sketches of each set R u for u  X  S we can unbiasedly estimate the cardinality of the union S One way to do this is to compute the bottom-k sketch of the union [7], which has threshold value  X  = k th { S and apply the cardinality estimator ( k  X  1) / X  . This would already conclude the proof of Theorem 5.1.

In our implementation, we use a strictly better union cardinality estimator that uses all the (at most k | S | ) values in the set of sketches instead of just the k th smallest: This estimator, proposed by Cohen and Kaplan [11], can be computed from the | S | sketches in time O ( | S | k log | S | first sorting the | S | sketches by decreasing threshold, and then identifying for each distinct rank value the threshold of the first sketch that contains it. When the sets R u are all the same, the estimate is the same as applying an estimator to the bottom-k sketch on the union, but Equation (10) can have up to a factor of p | S | lower CV when the sets R u are sufficiently disjoint. Moreover, this estimator is an optimal sum estimator in that it minimizes variance given the information available in the sketches.
 We can also derive a permutation version of Equation (10) . The simplest way is to treat the permutation rank T as a uniform rank r = ( T  X  1) / ( `n  X  1) which is the probability that the rank of another node is smaller than T .
When there is a single instance G = ( V,E ) , the combined sketches are simply reachability sketches [7, 10]. Reachability sketches Y v for all nodes can be computed very efficiently, using at most mk edge traversals in total, where m is the number of edges [7].

Algorithm 2 computes combined sketches by applying the pruned searches algorithm of Cohen [7] on each instance G obtaining a sketch Y ( i ) v for each node, and combining the results. The combined sketch X v is obtained by taking the bottom-k values in the union of the ` sketches, defined as X
The algorithm runs in O ( k P storing all sets of sketches, we can compute and merge concur-rently or sequentially, but after each step, take the bottom-values in the current bottom-k set and the newly computed sketch for instance G ( i ) : X v  X  bottom-k { X v ,Y ( i ) fore, the additional run time storage requirement for sketches is
O ( nk ) . This gives us the worst-case bounds on the com-putation stated in Theorem 5.1. We implemented our algorithms in C++ using Visual Studio 2013 with full optimization. All experiments were run on a machine with two Intel Xeon E5-2690 CPUs and 384 GiB of DDR3-1066 RAM, running Windows 2008R2 Server. Each Algorithm 2: Combined reachability sketches forall the nodes u  X  V do shuffle the n` node-instance pairs ( u,i ) forall the instances i do return( sketches ) CPU has 8 cores (2.90 GHz, 8  X  64 kiB L1, 8  X  256 kiB, and 20 MiB L3 cache), but all runs are sequential for consistency.
We ran our experiments on benchmark networks avail-able as part of the SNAP [24] and WebGraph [2] projects. More specifically, we test social ( Epinions , Slashdot , TwitterFollowers , LiveJournal , Orkut , Friendster , Twitter laboration ( AstroPh ), and web ( Slovakia , Slovakia &gt; ) networks. Slovakia &gt; is obtained from Slovakia by reversing all arcs (in-fluence follows the reverse direction of links).

Kempe et al. [19] proposed two natural ways of associating probabilities with edges in the binary IC model: the uniform scheme assigns a constant probability p to each directed edge (they used p = 0 . 1 and p = 0 . 01 ), whereas in the weighted cascade (wc) scheme the probability is the inverse of the degree of the head node (making the probability that a node is influenced less dependent on its number of neighbors). We consider the wc scheme by default, but we will also experiment with the uniform scheme (un). These two schemes are the most commonly tested in previous studies of scalability [20, 6, 5, 18, 22, 25].
This section evaluates SKIM, our new sketch-based influ-ence maximization algorithm. By default we set the num-ber of sampled instances to ` = 64 and compute sketches with k = 64 entries. (These choices will be justified in later experiments.) To evaluate the actual influence values of the seeds computed by SKIM, we use a set of 512 different sam-pled instances, in which we simply run BFSes a posteriori.
Table 1 summarizes the performance of our algorithm on several networks of varying sizes with up to almost two billion edges. Besides the network sizes, the table reports results for three seed set sizes s : 50, 1000 and n , i.e., computing full permutation. In each case, it reports the total running time of our algorithm as well as the total influence of the related seed set as a percentage of n . (Note that for s = n this value is 100 % by definition, so we omit it in the table.) For s and 1000 , the table also reports the corresponding numbers Table 1: Performance of SKIM and IRIE. SKIM uses k = 64 , ` = 64 , and we evaluate the influence on 512 (dif- X  X NF X ) computed within the time limit (*). for IRIE [18], one of the fastest available heuristics that can generate full permutations. We use our own implementation of IRIE, which is somewhat faster than the one evaluated in the original paper. Except for s = n , we set an execution time limit of two hours; we report  X  X NF X  and the corresponding number of computed seeds for those runs that did not finish. The table shows that the influences computed by IRIE and SKIM are very close; sometimes SKIM being better. However, SKIM is significantly faster, outperforming IRIE by several orders of magnitude on many instances. In particular, when computing 1000 instead of 50 seeds, SKIM X  X  speedup over IRIE becomes more evident as IRIE X  X  running time grows linearly with the number of seed nodes, whereas with SKIM it decreases with the size of the residual problem. As a result, we can compute the 1000 most influential nodes on a graph with 65 million nodes and 1.8 billion edges (Friendster) in just 22 minutes. Similarly, computing a full influence ordering with SKIM takes less then 5.5 hours on all graphs. ence maximization algorithm we are aware of. We ran their implementation (kindly given to us by the authors) to re-port figures on our instances. As in their experiments, we set the  X  parameter of TIM + to 1 . 0 . Table 2 reports the Table 2: Comparing SKIM and TIM + regarding in-fluence and running time for 50 and 1000 seeds. influence (as percentage of n ) as well as the running time for on Friendster , Twitter , and Slovakia &gt; with 1000 seeds, and generally the two are never more than a factor of three apart. However, recall that SKIM actually computes a sequence of nodes such that every prefix of this sequence also (approxi-rerun to obtain a smaller set of maximally influential nodes. We next argue why our paremeter choices are reasonable. First, we evaluate the impact of the number ` of instances on the solution quality. Figure 1 (left) reports the quality of the seed nodes found by Greedy (GRE) when we use different ` values during the algorithm, but evaluate the quality of the resulting seed set on 4096 (different) instances. We observe that increasing ` does help quality, but only up to a certain point. In particular, values beyond 64 yield modest improvements. Since our running times depend on ` , we use this value by default.

Figure 2 compares SKIM to GRE, IRIE, and DEG (in-cluding nodes by order of decreasing degree) on two inputs: Slashdot and TwitterFollowers . For SKIM, we test various values for k (4, 16, 64, 256). We report the influence error when compared to GRE (top) and the running time (bot-tom). We observe that the error for SKIM decreases as we increase k , k = 64 being the sweet spot, after which solution quality does not improve by much anymore. Running times increase for all algorithms with the size of the seed set, but SKIM is consistently the fastest algorithm for any size.
Figure 3 evaluates the performance of SKIM and IRIE on the two IC schemes (wc,un), using TwitterFollowers as input. We observe that SKIM matches the solution quality of IRIE but is significantly faster.

Finally, Figure 4 shows the influence (top) and running time (bottom) of SKIM when computing the full permutation. We plot the relative influence and running time (both as percentage) subject to the number of computed seed nodes as the algorithm progresses (also as percentage of n ). To the best of our knowledge, we are the first who are able to compute (approximately) the full Pareto front of influence versus seed set size on graphs with billions of edges within a few hours only. The tradeoff seems to characterize the core of the network: On Slovakia &gt; and Twitter , 0.1% of the nodes already cover almost 50% of the entire graph, while on Slashdot and Friendster , 0.1% of the seeds only cover 25 X 30% of the graph, albeit with a faster growth. Other instances have a slower growth in influence, but on all instances 10% of the nodes cover at least 50% of the graph. Regarding running time, we observe that all instances exhibit similar behavior. In particular, more than 50% of the total running time is spent computing the first 10% of seed nodes. This section evaluates our influence oracle (cf. Section 5). We use the IC model (with wc probabilities) to generate a set of ` = 64 instances. We build combined reachability sketches of size k = 64 for this set of instances and evaluate the performance of our oracle (cf. Section 2).

Table 3 summarizes the performance of our oracle on sev-eral networks. It reports the time spent for preprocessing and the required space (in MiB) to store the combined sketches. Queries are evaluated for seed set sizes s of 1, 50, and 1000. For each s , we generate 100 seed sets whose nodes are selected uniformly at random. We report the average running time of the query (estimator) in microseconds and the relative error of the estimated influence when compared to the exact influence of the respective seed set.

We observe that preprocessing times are reasonable for all graphs while space consumption is essentially linear in the number of nodes. For example, on LiveJournal (the biggest instance tested), the sketches require 2.3 GiB of space, which we computed in just 34 minutes. The influence of a single node can then be estimated in 1 X 2  X  s, while for 1000 seed nodes we require 5.2 ms. Note that the query time is almost independent of the graph size. Using k = 64 , the error stays well below 10% for one seed node, and decreases significantly for larger seed sets (to around 1% for s = 1000 ).
Figure 5 shows in detail how the error of the estimator ( axis) decreases when the seed set size increases ( x axis). To better evaluate the performance of estimating the union of several reachability sets, we use the following neighborhood generator for queries: For each query, it first picks a node random with probability proportional to its degree. From u exhaustively grows a BFS of the smallest depth l such that the tree contains at least s nodes. The nodes for the seed set are then uniformly sampled from this tree. With this generator, we expect the reachability sets of seed nodes to highly overlap. Figure 1: Evaluating different numbers of simula-tions (left) and evaluating the average error of our oracle on 1000 random seeds, subject to varying ` . The right plot is discussed in Section 6.2. Figure 2: Evaluating influence and running time for several algorithms. The legend applies to all plots. Looking at the figure, we observe that the estimation error of our oracle decreases rapidly for increasing s . Also, running queries from the neighborhood generator (right) compared to the uniform one (left), has almost no effect on the estimation error; for 50 seed nodes it is even better on many instances.
Finally, Figure 1 (right) reports the performance of the oracle for fixed instances on the general IC model. We vary the number ` of instances generated by simulations when building the oracle, but compute the error on a different set of 8192 instances. Since our oracle implementation is optimized for fixed instances, we see a higher error with 64 . We can also see that the error decreases with the number of simulations. We conclude that for an IC model oracle, it is beneficial to construct sketches that have approximation guarantees with respect to the IC model itself (cf. Section 3.2) rather than work with simulations.
We presented highly scalable algorithms for binary influ-ence computation. SKIM is a sketch-space implementation of the greedy influence maximization algorithm that scales it by Figure 3: Evaluating SKIM and IRIE on the uni-form (un) and weighted cascade (wc) models. The legend applies to both plots. Figure 4: Evaluating influence permutations (top) and running time (bottom) on several instances.
 The legend applies to both plots.
 Table 3: Evaluating our influence oracle with ` = 64 . several orders of magnitude, to graphs with billions of edges. SKIM computes a sequence of nodes such that each prefix has a probabilistic guarantee on approximation quality that is close to that of Greedy . We also presented sketch-based influence oracles, which after a near-linear processing of the instances can estimate influence queries in time proportional to the number of seeds. Our experimental study focused on instances generated by an IC model, since the fastest algorithms we compared with only apply in this model. Our experiments revealed that SKIM is accurate and faster than other algorithms by one to two order of magnitude.
In future work, we plan to develop a SKIM-like algorithm for timed influence , where edges have lengths that are inter-preted as transition times and we consider both the speed and scope of infection [15, 4, 9, 1, 12]. We also plan to use sketches to efficiently estimate the Jaccard similarity of Figure 5: Evaluating our oracle for seed sets of varying size, which are selected uniformly at ran-dom (left) or with our BFS-based method (right). the influence sets of two nodes, which we believe to be an effective similarity measure [9].
