 Sergey Levine svlevine@stanford.edu Vladlen Koltun vladlen@stanford.edu Algorithms for inverse optimal control (IOC), also known as inverse reinforcement learning (IRL), recover an unknown reward function in a Markov decision pro-cess (MDP) from expert demonstrations of the corre-sponding policy. This reward function can be used to perform apprenticeship learning, generalize the ex-pert X  X  behavior to new situations, or infer the expert X  X  goals (Ng &amp; Russell, 2000). Performing IOC in con-tinuous, high-dimensional domains is challenging, be-cause IOC algorithms are usually much more computa-tionally demanding than the corresponding  X  X orward X  control methods. In this paper, we present an IOC algorithm that efficiently handles deterministic MDPs with large, continuous state and action spaces by con-sidering only the shape of the learned reward function in the neighborhood of the expert X  X  demonstrations. Since our method only considers the shape of the re-ward function around the expert X  X  examples, it does not integrate global information about the reward along alternative paths. This is analogous to trajec-tory optimization methods, which solve the forward control problem by finding a local optimum. However, while the lack of global optimality is a disadvantage for solving the forward problem, it can actually be advantageous in IOC. This is because it removes the assumption that the expert demonstrations are glob-ally optimal, thus allowing our algorithm to use exam-ples that only exhibit local optimality. For complex tasks, human experts might find it easier to provide such locally optimal examples. For instance, a skilled driver might execute every turn perfectly, but still take a globally suboptimal route to the destination. Our algorithm optimizes the approximate likelihood of the expert trajectories under a parameterized reward. The approximation assumes that the expert X  X  trajec-tory lies near a peak of this likelihood, and the result-ing optimization finds a reward function under which this peak is most prominent. Since this approach only considers the shape of the reward around the exam-ples, it does not require the examples to be globally optimal, and remains efficient even in high dimensions. We present two variants of our algorithm that learn the reward either as a linear combination of the provided features, as is common in prior work, or as a nonlin-ear function of the features, as in a number of recent methods (Ratliff et al., 2009; Levine et al., 2010; 2011). Most prior IOC methods solve the entire forward con-trol problem in the inner loop of an iterative proce-dure (Abbeel &amp; Ng, 2004; Ratliff et al., 2006; Ziebart, 2010). Such methods often use an arbitrary, possi-bly approximate forward solver, but this solver must be used numerous times during the learning process, making reward learning significantly more costly than the forward problem. Dvijotham and Todorov avoid repeated calls to a forward solver by directly learn-ing a value function (Dvijotham &amp; Todorov, 2010). However, this requires value function bases to impose structure on the solution, instead of the more common reward bases. Good value function bases are difficult to construct and are not portable across domains. By only considering the reward around the expert X  X  tra-jectories, our method removes the need to repeatedly solve a difficult forward problem, without losing the ability to utilize informative reward features. More efficient IOC algorithms have been proposed for the special case of linear dynamics and quadratic re-wards (LQR) (Boyd et al., 1994; Ziebart, 2010). How-ever, unlike in the forward case, LQR approaches are difficult to generalize to arbitrary inverse problems, because learning a quadratic reward matrix around an example path does not readily generalize to other states in a non-LQR task. Because of this, such meth-ods have only been applied to tasks that conform to the LQR assumptions (Ziebart, 2010). Our method also uses a quadratic expansion of the reward func-tion, but instead of learning the values of a quadratic reward matrix directly, it learns a general parameter-ized reward using its Hessian and gradient. As we show in Section 5, a particularly efficient variant of our algorithm can be derived when the dynamics are linearized, and this derivation can in fact follow from standard LQR assumptions. However, this approxi-mation is not required, and the general form of our algorithm does not assume linearized dynamics. Most previous methods also assume that the expert demonstrations are globally optimal or near-optimal. Although this makes the examples more informative insofar as the learning algorithm can extract relevant global information, it also makes such methods unsuit-able for learning from examples that are only locally optimal. As shown in the evaluation, our method can learn rewards even from locally optimal examples. We address deterministic, fixed-horizon control tasks with continuous states x = ( x 1 ,..., x T ) T , continuous actions u = ( u 1 ,..., u T ) T , and discrete time. Such tasks are characterized by a dynamics function F , which we define as as well as a reward function r ( x t , u t ). Given the initial state x 0 , the optimal actions are given by IOC aims to find a reward function r under which the optimal actions match the expert X  X  demonstrations, given by D = { ( x (1) 0 , u (1) ) ,..., ( x ( n ) 0 , u gorithm might also be presented with reward features f : ( x t , u t )  X  R that can be used to represent the un-known reward r . Unfortunately, real demonstrations are rarely perfectly optimal, so we require a model for the expert X  X  behavior that can explain subopti-mality or  X  X oise. X  We employ the maximum entropy IRL (MaxEnt) model (Ziebart et al., 2008), which is closely related to linearly-solvable MDPs (Dvijotham &amp; Todorov, 2010). Under this model, the probability of the actions u is proportional to the exponential of the rewards encountered along the trajectory: 1 where Z is the partition function. Under this model, the expert follows a stochastic policy that becomes more deterministic when the stakes are high, and more random when all choices have similar value. In prior work, the log likelihood derived from Equation 1 was maximized directly. However, computing the partition function Z requires finding the complete policy under the current reward, using a variant of value iteration (Ziebart, 2010). In high dimensional spaces, this be-comes intractable, since this computation scales expo-nentially with the dimensionality of the state space. In the following sections, we present an approxima-tion to Equation 1 that admits efficient learning in high dimensional, continuous domains. In addition to breaking the exponential dependence on dimensional-ity, this approximation removes the requirement that the example trajectories be globally optimal, and only requires approximate local optimality. An example of a locally optimal but globally suboptimal trajectory is shown in Figure 1: although another path has a higher total reward, any local perturbation of the trajectory decreases the reward total. To evaluate Equation 1 without computing the par-tition function Z , we apply the Laplace approxima-tion, which locally models the distribution as a Gaus-sian (Tierney &amp; Kadane, 1986). Note that this is not equivalent to modeling the reward function itself as a Gaussian, since Equation 1 uses the sum of the rewards along a path. In the context of IOC, this corresponds to assuming that the expert performs a local optimiza-tion when choosing the actions u , rather than global planning. This assumption is strictly less restrictive than the assumption of global optimality.
 Using r ( u ) to denote the sum of rewards along path ( x 0 , u ), we can write Equation 1 as We approximate this probability using a second order Taylor expansion of r around u : r (  X  u )  X  r ( u ) + (  X  u  X  u ) T Denoting the gradient  X  X   X  u as g and the Hessian  X  2 r  X  u 2 H , the approximation to Equation 1 is given by = from which we obtain the approximate log likelihood Intuitively, this likelihood indicates that reward func-tions under which the example paths have small gradi-ents and large negative Hessians are more likely. The magnitude of the gradient corresponds to how close the example is to a local peak in the (total) reward landscape, while the Hessian describes how steep this peak is. For a given parameterization of the reward, we can learn the most likely parameters by maximizing Equation 2. In the next section, we discuss how this objective and its gradients can be computed efficiently. We can optimize Equation 2 directly with any opti-mization method. The computation is dominated by the linear system H  X  1 g , so the cost is cubic in the path length T and the action dimensionality. We will describe two approximate algorithms that evaluate the likelihood in time linear in T by linearizing the dynam-ics. This greatly speeds up the method on longer ex-amples, though it should be noted that modern linear solvers are well optimized for symmetric matrices such as H , making it quite feasible to evaluate the likeli-hood without linearization for moderate length paths. To derive the approximate linear-time solution to H  X  1 g , we first express g and H in terms of the deriva-tives of r with respect to x and u individually: Since r ( x t , u t ) depends only on the state and action at time t ,  X  H and  X  H are block diagonal, with T blocks. To build the Jacobian J , we differentiate the dynamics: Future actions do not influence past states, so J is block upper triangular. Using the Markov property, we can express the nonzero blocks recursively: We can now write g and H almost entirely in terms of matrices that are block diagonal or block triangular. Unfortunately, the final second order term  X  H does not exhibit such convenient structure. In particular, the Hessian of the last state x T with respect to the actions u can be arbitrarily dense. We will therefore disregard this term. Since  X  H is zero only when the dynamics are linear, this corresponds to linearizing the dynamics. 5.1. Direct Likelihood Evaluation We first describe an approach for directly evaluating the likelihood under the assumption that  X  H is zero. We first exploit the structure of J to evaluate J  X  g in time linear in T , which is essential for computing g . This requires a simple recursion from t = T to 1: where z g accumulates the product of  X  g with the off-diagonal elements of J . The linear system h = H  X  1 g can be solved with a stylistically similar recursion. We first use the assumption that  X  H is zero to factor H : where PJ T = I . The nonzero blocks of P are and B  X  t is a pseudoinverse of the potentially nonsquare matrix B t . This linear system is solved in two passes: an upward pass to solve (  X  HP + J  X  H )  X  h = g , and a downward pass to solve J T h =  X  h . Each pass is a block generalization of forward or back substitution and, like the recursion in Equation 3, can exploit the structure of J to run in time linear in T . However, the upward pass must also handle the off-diagonal entries of P and the potentially nonsquare blocks of J , which are not invertible. We therefore only construct a partial solution on the upward pass, with each  X  h t expressed in terms of  X  h t  X  1 . The final values are reconstructed on the downward pass, together with the solution h . The complete algorithm computes h = H  X  1 g and the determinant | X  H | in time linear in T , and is included in Appendix A of the supplement.
 For a given parameterization of the reward, we deter-mine the most likely parameters by maximizing the likelihood with gradient-based optimization (LBFGS in our implementation). This requires the gradient of Equation 2. For a reward parameter  X  , the gradient is As before, the gradients of g and H can be expressed in terms of the derivatives of r at each time step, which allows us to rewrite the gradient as  X  L  X  X  1 2 1 2 1 2 where [ H  X  1 ] ttij denotes the ij th entry in the block tt . The last sum vanishes if  X  H is zero, so all quantities can be computed in time linear in T . The diagonal blocks of H  X  1 and J T H  X  1 J can be computed while solving for h = H  X  1 g , as shown in Appendix A of the supplement. To find the gradients for any reward parameterization, we can compute the gradients of  X  g ,  X  g ,  X 
H , and  X  H , and then apply the above equation. 5.2. LQR-Based Likelihood Evaluation While the approximate likelihood in Equation 2 makes no assumptions about the dynamics of the MDP, the algorithm in Section 5.1 linearizes the dynam-ics around the examples. This matches the assump-tions of the commonly studied linear-quadratic regula-tor (LQR) setting, and suggests an alternative deriva-tion of the algorithm as IOC in a linear-quadratic sys-tem, with linearized dynamics given by A t and B t , quadratic reward matrices given by the diagonal blocks of  X 
H and  X  H , and linear reward vectors given by  X  g and  X  g . A complete derivation of the resulting algorithm is presented in Appendix B of the supplement, and is similar to the MaxEnt LQR IOC algorithm described by Ziebart (Ziebart, 2010), with an addition recursion to compute the derivatives of the parameterized re-ward Hessians. Since the gradients are computed re-cursively, this method lacks the convenient form pro-vided by Equation 4, but may be easier to implement. We can use the objective in Equation 2 to learn reward functions with a variety of representations. We present one variant that learns the reward as a linear combi-nation of features, and a second variant that uses a Gaussian process to learn nonlinear reward functions. 6.1. Learning Linear Reward Functions In the linear variant, the algorithm is provided with features f that depend on the state x t and action u t . The reward is given by r ( x t , u t ) =  X  T f ( x t , u t weights  X  are learned. Letting  X  g ( k ) ,  X  g ( k ) ,  X  H ( k ) denote the gradients and Hessians of each feature with respect to actions and states, the full gradients and Hessians are sums of these quantities, weighted respect to  X  k is simply  X  g ( k ) , and the gradients of the other matrices are given analogously. The likelihood gradient is then obtained from Equation 4.
 When evaluating Equation 2, the log determinant of the negative Hessian is undefined when the determi-nant is not positive. This corresponds to the example path lying in a valley rather than on a peak of the energy landscape. A high-probability reward function will avoid such cases, but it is nontrivial to find an initial point for which the objective can be evaluated. We therefore add a dummy regularizer feature that ensures that the negative Hessian has a positive deter-minant. This feature has a gradient that is uniformly zero, and a Hessian equal to the negative identity. The initial weight  X  r on this feature must be set such that the negative Hessians of all example paths are positive definite. We can find a suitable weight simply by doubling  X  r until this requirement is met. During the optimization, we must drive  X  r to zero in order to solve the original problem. In this way,  X  r has the role of a relaxation, allowing the algorithm to explore the parameter space without requiring the Hessian to always be negative definite. Unfortunately, driving  X  r to zero too quickly can create numerical instabil-ity, as the Hessians become ill-conditioned or singular. Rather than simply penalizing the regularizing weight, we found that we can maintain numerical stability and still obtain a solution with  X  r = 0 by using the Aug-mented Lagrangian method (Birgin &amp; Mart  X  X nez, 2009). This method solves a sequence of maximization prob-lems that are augmented by a penalty term of the form where  X  ( j ) is a penalty weight, and  X  ( j ) is an estimate of the Lagrange multiplier for the constraint  X  r = 0. After each optimization,  X  ( j +1) is increased by a factor of 10 if  X  r has not decreased, and  X  ( j +1) is set to This approach allows  X  r to decrease gradually with each optimization without using large penalty terms. 6.2. Learning Nonlinear Reward Functions In the nonlinear variant of our algorithm, we represent the reward function as a Gaussian process (GP) that maps from feature values to rewards, as proposed by Levine et al. (Levine et al., 2011). The inputs of the Gaussian process are a set of inducing feature points F = [ f 1 ... f n ] T , and the noiseless outputs y at these points are learned. The location of the inducing points can be chosen in a variety of ways, but we follow Levine et al. and choose the points that lie on the example paths, which concentrates the learning on the regions where the examples are most informative. In addition to the outputs y , we also learn the hyperparameters  X  and  X  that describe the GP kernel function, given by k ( f i , f j ) =  X  exp  X  This kernel is a variant of the radial basis function kernel, regularized by input noise  X  2 (since the outputs are noiseless). The GP covariance is then defined as K ij = k ( f i , f j ), producing the following GP likelihood: log P ( y , X , X  | F ) =  X  The last term in the likelihood is the prior on the hyperparameters. This prior encourages the feature weights  X  to be sparse, and prevents degeneracies that occur as y  X  0. The latter is accomplished with a prior that encodes the belief that no two inducing points are deterministically dependent, as captured by their partial correlation: This prior is discussed in more detail in previous work (Levine et al., 2011). The reward at a feature point f ( x t , u t ) is given by the GP posterior mean, and can be augmented with a set of linear features f ` : where  X  = K  X  1 y , and k t is a row vector corresponding to the covariance between f ( x t , u t ) and each inducing log likelihood, before the proposed approximation, is obtained by using the GP likelihood as a prior on the IOC likelihood in Equation 1: log P ( u | x 0 ) = X Only the IOC likelihood is altered by the proposed ap-proximation. The gradient and Hessian of the reward with respect to the states are and the kernel derivatives are given by The feature derivatives  X  g ( k ) and  X  H ( k ) are defined in the previous section, and  X  g and  X  H are given analogously. Using these quantities, the likelihood can be computed as described in Section 5. The likelihood gradients are derived in Appendix C of the supplement.
 This algorithm can learn more expressive rewards in domains where a linear reward basis is not known, but with the usual bias and variance tradeoff that comes with increased model complexity. As shown in our evaluation, the linear method requires fewer examples when a linear basis is available, while the nonlinear variant can work with much less expressive features. We evaluate our method on simulated robot arm con-trol, planar navigation, and simulated driving. In the robot arm task, the expert sets continuous torques on each joint of an n -link planar robot arm. The reward depends on the position of the end-effector. Each link has an angle and a velocity, producing a state space with 2 n dimensions. By changing the number of links, we can vary the dimensionality of the task. An exam-ple of a 4-link arm is shown in Figure 2. The complex-ity of this task makes it difficult to compare with prior work, so we also include a simple planar navigation task, in which the expert takes continuous steps on a plane, as shown in Figure 3. Finally, we use human-created examples on a simulated driving task, which shows how our method can learn complex policies from human demonstrations on a more realistic domain. The reward function in the robot arm and navigation tasks has a Gaussian peak in the center, surrounded by four pits. The reward also penalizes each action with the square of its magnitude. The IOC algorithms are provided with a grid of 25 evenly spaced Gaussian features and the squared action magnitude. In the nonlinear test in Section 7.2, the Cartesian coordinates of the arm end-effector are provided instead of the grid. We compare the linear and nonlinear variants of our method with the MaxEnt IRL and OptV algorithms (Ziebart et al., 2008; Dvijotham &amp; Todorov, 2010). We present results for the linear time algorithm in Sec-tion 5.1, though we found that both the LQR variant and the direct, non-linearized approach produced sim-ilar results. MaxEnt used a grid discretization for both states and actions, while OptV used discretized actions and adapted the value function features as described by Dvijotham and Todorov. Since OptV cannot learn action-dependent rewards, it was provided with the true weight for the action penalty term.
 To evaluate a learned reward, we first compute the op-timal paths with respect to this reward from 32 ran-dom initial states that are not part of the training set. We also find the paths that begin in the same initial states but are optimal with respect to the true reward. In both cases, we compute evaluation paths that are globally optimal, by first solving a discretization of the task with value iteration, and then finetuning the paths with continuous optimization. Once the evalu-ation paths are computed for both reward functions, we obtain a reward loss by subtracting the true reward along the learned reward X  X  path from the true reward along the true optimal path. This loss is low when the learned reward induces the same policy as the true one, and high when the learned reward causes costly mistakes. Since the reward loss is measured entirely on globally optimal paths, it captures how well each algorithm learns the true, global reward, regardless of whether the examples are locally or globally optimal. 7.1. Locally Optimal Examples To test how well each method handles locally optimal examples, we ran the navigation task with increasing numbers of examples that were either globally or lo-cally optimal. As discussed above, globally optimal examples were obtained with discretization, while lo-cally optimal examples were computed by optimizing the actions from a random initialization. Each test was repeated eight times with random initial states for each example.
 The results in Figure 4 show that both variants of our algorithm converge to the correct policy. The lin-ear variant requires fewer examples, since the features form a good linear basis for the true reward. MaxEnt assumes global optimality and does not converge to the correct policy when the examples are only locally op-timal. It also suffers from discretization error. OptV has difficulty generalizing the reward to unseen parts of the state space, because the value function features do not impose meaningful structure on the reward. 7.2. Linear and Nonlinear Rewards On the robot arm task, we evaluated each method with both the Gaussian grid features, and simple features that only provide the position of the end effector, and therefore do not form a linear basis for the true reward. The examples were globally optimal. The number of links was set to 2, resulting in a 4-dimensional state space. Only the nonlinear variant of our algorithm could successfully learn the reward from the simple features, as shown in Figure 5. Even with the grid features, which do form a linear basis for the reward, MaxEnt suffered greater discretization error due to the complex dynamics of this task, while OptV could not meaningfully generalize the reward due to the in-creased dimensionality of the task. 7.3. High Dimensional Tasks To evaluate the effect of dimensionality, we increased the number of robot arm links. As shown in Figure 6, the processing time of our methods scaled gracefully with the dimensionality of the task, while the qual-ity of the reward did not deteriorate appreciably. The processing time of OptV increased exponentially due to the action space discretization. The MaxEnt dis-cretization was intractable with more than two links, and is therefore not shown. 7.4. Human Demonstrations We evaluate how our method handles human demon-strations on a simulated driving task. Although driv-ing policies have been learned by prior IOC methods (Abbeel &amp; Ng, 2004; Levine et al., 2011), their discrete formulation required a discrete simulator where the agent makes simple decisions, such as choosing which lane to switch to. In constrast, our driving simulator is a fully continuous second order dynamical system. The actions correspond directly to the gas, breaks, and steering of the simulated car, and the state space in-cludes position, orientation, and linear and angular velocities. Because of this, prior methods that rely on discretization cannot tractably handle this domain. We used our nonlinear method to learn from sixteen 13-second examples of an aggressive driver that cuts off other cars, an evasive driver that drives fast but keeps plenty of clearance, and a tailgater who follows closely behind the other cars. The features are speed, devi-ation from lane centers, and Gaussians covering the front, back, and sides of the other cars on the road. Since there is no ground truth reward for these tasks, we cannot use the reward loss metric. We follow prior work and quantify how much the learned policy resem-bles the demonstration by using task-relevant statistics (Abbeel &amp; Ng, 2004). We measure the average speed of sample paths for the learned reward and the amount of time they spend within two car-lengths behind and in front of other cars, and compare these statistics with those from an unobserved holdout set of user demon-strations that start in the same initial states. The re-sults in Table 1 show that the statistics of the learned policies are similar to the holdout demonstrations. Plots of the learned rewards are shown in Figure 7. Videos of the optimal paths for the learned rewards can be downloaded from the project website, along with the supplementary appendices and source code: http://graphics.stanford.edu/projects/cioc . We presented an IOC algorithm designed for continu-ous, high dimensional domains. Our method remains efficient in high dimensional domains by using a local approximation to the reward function likelihood. This approximation also removes the global optimality re-quirement for the expert X  X  demonstrations, allowing the method to learn the reward from examples that are only locally optimal. Local optimality can be eas-ier to demonstrate than global optimality, particularly in high dimensional domains. As shown in our evalua-tion, prior methods do not converge to the underlying reward function when the examples are only locally op-timal, regardless of how many examples are provided. Since our algorithm relies on the derivatives of the re-ward features to learn the reward function, we require the features to be differentiable with respect to the states and actions. These derivatives must be pre-computed only once, so it is quite practical to use fi-nite differences when analytic derivatives are unavail-able, but features that exhibit discontinuities are still poorly suited for our method. Our current formulation also only considers deterministic, fixed-horizon control problems, and an extension to stochastic or infinite-horizon cases is an interesting avenue for future work. In addition, although our method handles examples that lack global optimality, it does not make use of global optimality when it is present: the examples are always assumed to be only locally optimal. Prior methods that exploit global optimality can infer more information about the reward function from each ex-ample when the examples are indeed globally optimal. An exciting avenue for future work is to apply this ap-proach to other high dimensional, continuous problems that have previously been inaccessible for inverse opti-mal control methods. One challenge with such applica-tions is to generalize and impose meaningful structure in high dimensional tasks without requiring detailed features or numerous examples. While the nonlinear variant of our algorithm takes one step in this direc-tion, it still relies on features to generalize the reward to unseen regions of the state space. A more sophisti-cated way to construct meaningful, generalizable fea-tures would allow IOC to be easily applied to complex, high dimensional tasks.
 We thank the anonymous reviewers for their construc-tive comments. Sergey Levine was supported by NSF Graduate Research Fellowship DGE-0645962.
 Abbeel, Pieter and Ng, Andrew Y. Apprenticeship learning via inverse reinforcement learning. In Pro-ceedings of ICML , 2004.
 Birgin, Ernesto G. and Mart  X  X nez, Jos  X e Mario. Practical augmented lagrangian methods. In Encyclopedia of Optimization , pp. 3013 X 3023. 2009.
 Boyd, S., El Ghaoui, L., Feron, E., and Balakrishnan, V. Linear Matrix Inequalities in System and Control Theory . SIAM, Philadelphia, PA, June 1994.
 Dvijotham, Krishnamurthy and Todorov, Emanuel. Inverse optimal control with linearly-solvable MDPs. In Proceedings of ICML , 2010.
 Levine, Sergey, Popovi  X c, Zoran, and Koltun, Vladlen.
Feature construction for inverse reinforcement learn-ing. In Advances in Neural Information Processing Systems . 2010.
 Levine, Sergey, Popovi  X c, Zoran, and Koltun, Vladlen.
Nonlinear inverse reinforcement learning with gaus-sian processes. In Advances in Neural Information Processing Systems . 2011.
 Ng, Andrew Y. and Russell, Stuart J. Algorithms for inverse reinforcement learning. In Proceedings of ICML , 2000.
 Ratliff, Nathan, Bagnell, J. Andrew, and Zinkevich,
Martin A. Maximum margin planning. In Proceed-ings of ICML , 2006.
 Ratliff, Nathan, Silver, David, and Bagnell, J. Andrew.
Learning to search: Functional gradient techniques for imitation learning. Autonomous Robots , 27(1): 25 X 53, 2009.
 Tierney, Luke and Kadane, Joseph B. Accurate ap-proximations for posterior moments and marginal densities. Journal of the American Statistical Asso-ciation , 81(393):82 X 86, 1986.
 Ziebart, Brian D. Modeling Purposeful Adaptive Be-havior with the Principle of Maximum Causal En-tropy . PhD thesis, Carnegie Mellon University, 2010. Ziebart, Brian D., Maas, Andrew, Bagnell, J. Andrew, and Dey, Anind K. Maximum entropy inverse rein-forcement learning. In AAAI Conference on Artifi-
