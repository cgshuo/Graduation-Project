 Due to the rapid proliferation of the eX tensible Markup Language [1], a rapidly growing number of XML documents have been produced. This is especially true in web-based applications, where the underlying data model is intrinsically semi-structured. Subsequently the need for sharing XML documents by different applications and multiple users is incr easing. Concurrency control of access and update on the same XML document is thus an important issue that any XML data management system must resolve. For different XML data management system, the mechanism used for concurrency control is also different. 
There are essentially three ways of storing XML documents. The simplest way is to store XML documents in a file system and access the content of them via a standardized API, such as DOM [2]. But this is not a good idea for concurrency control, for isolation must be done at the document level. The second alternative is to document is shredded into one or more relational tables or stores as a CLOB or BLOB object. This seems a good idea, for concurrency control has been studied extensively in the context of traditional database management systems. Unfortunately, existing concurrency control methods used for traditional DBMS have been shown to be XML database management system. Though native XML database does not mean to management, since everything can be tailored to the best for manipulation of XML documents. Therefore this idea has been adopted by more and more researchers and quite a number of native XML databases has been built in last several years [7][8][9][10]. 
Despite of the popularity of native XML databases, little work has been done under the umbrella of concurrency control of XML documents. This is partly because that query is much more frequent than update in XML environment, and the standard query language for XML, namely XQuery [11], lacks the functionality of update. But XML has been proposed [11] and W3C has also proposed its requirements for XML update language recently [12]. Therefore, synchronization and concurrency control mechanism is crucial for native XML database. Based on these observations, we introduce a multiversion concurrency control protocol, namely MPX, which can be integrated into a native XML database and provide superior concurrency control functionality. 
The remainder of this paper is organized as follows. Section 2 reviews current work on XML concurrency control. Section 3 defines the data model and transaction model used by MPX. Section 4 presents the core protocol of MPX. Section 5 is experimental evaluation and its result, and section 6 wraps up the paper with a conclusion. Concurrency control is well studied for traditional database, and several effective protocols has been proposed, such as two-phase locking, timestamp-ordering and tree locking protocols etc [13]. Tree Locking prot ocols are often used for hierarchical data [14], but it X  X  not suitable for XML actually, although XML is also roughly a tree [6]. 
However, processing of concurrent querying and updating of XML data has received no attention for a long time, even in most native XML database management systems. For example, the Lore database management system for semistructured data and XML simply use page-based strict two phase locking for concurrency control [15][16]. Other native XML databases, such as Tamino, use locks on the document level. 
Recently, with the advent of native and XML-enabled databases, several forerunners in this area. In last 2 years, they proposed several protocols. DGLOCK [18] proposed by Grabs et al. and the transaction model proposed by J. Hidders et al [19][20]. DGLOCK is a protocol for semantic locking on DataGuide [21], which is a combination and derivation of graph-based locking protocol and predicate lock. The distinguishing character istic of DGLOCK is that it locks path index instead of the document itself. However, DGLOCK is insufficient for handling IDREFs and the predicate lock it used is expensive and restrictive. Moreover, whether query without predicates, two path locking schemes, namely path lock propagation scheme and path lock satisfiability scheme can be used. However, predicate and reference via IDREFs in path expression are not mentioned and may be troublesome. The common limitation of path-based protocols is that they are bound with a path based language and complex path expressions can hardly be treated efficiently. Other existing protocols can be classified as node-based protocols. In this category, G. Moerkotte et al proposed several lock-based and timestamp-based protocols. In [22], three lock-based protocols, namely Node2PL, NO2PL and OO2PL, are locks, thus may bring a burden to the system. In [23], two timestamp-based protocols, namely, XTO and XCO, are proposed. All protocols proposed in [22] and [23], however, are meant to be used with a specific API (DOM). Moreover, the treatment of IDREFs is complex and in timestamp-based protocols, cascadelessness can not be guaranteed. 
Despite of the limitations we have mentioned, all existing protocols are simple and easy to be integrated into a native XML database management system, which is very environment, where query is much common that update. In all existing protocols, a single update operation can block a number of queries, which prohibit the system from achieving a better degree of concurrency. 
On the contrary, the protocol we proposed, MPX, solved the above problems based on multiversion. MPX is simple but powerful, it can guarantee serializability and cascadelessness. And in MPX, read-only transactions and update transactions will never block each other. In this section, we present some essential concepts before the core protocol of MPX is introduced. 3.1 Data Model Many data models have been used for XML data, e.g. OEM, DOM and the XPath data model, among which the XPath data model is most suitable for native XML databases. Our data model is derived from the XPath data model, with some modifications for simplicity and extensions for multiversion. In our data model a document is a directed graph, which is defined as follows. Definition 1. (document) A XML document d is a tuple set of nodes, : EN N  X  denotes the set of tree edges and rN  X  is the root. 
The data model for a document is similar to other data models, but in our data model, the content of a node is quite different, since a node can have multiple versions. Different versions of the same node can be totally different, except that they must have the same node identifier. id n n n , and each version value indicating whether k n has been deleted. For ease of illustration, we take l , v , dn to denote the label, value, version number and the existence of discussed in next section. element node k n , () k ln is the name of it and () k vn is not defined. For an attribute text node k n , () k ln is defined to be  X #text X  and () k vn is the literal value of it. 
Our data model is extremely flexible. For example, elements can be renamed by modifying the l attribute. Elements can also be changed into texts by changing the l requirements in the W3C X  X  official document [1]. 3.2 Transaction Definition 3. (transaction) A transaction t is a series of read or write operations, with a commit operation in the end. A read-only transaction is a transaction without write operations. An update transaction is a transaction with at least one write operations. modification, insertion or deletion. But for concurrency control they are treated roughly in the same way. Not all sequences of operations are reasonable in practice. For example, based on the root. In order to capture the characteristic of feasible sequences of operations, we define the concept of valid transaction. following requirements. 1) Before the transaction write a node, it must read it first so long as the write operation is not an insertion; 2) Before a transaction read a node, it must read all ancestors of it. 
The first proposition is straightforward, for before a transaction updates or deletes proposition is also reasonable, for conceptually XPath and XQuery queries are executed in a top down manner. That is, the execution of a XPath and XQuery querie always starts from the root of the document and searches downward in the document tree based on the path expression. This is also the truth for DOM, another popular API for XML. Though there can be IDREF and IDREFS links in the document, and the path expression can navigate through links, the usage of them is really rare in typical by adding read operations of the ancestors of the link target. So in this paper, we only concentrate on valid transactions, without loss of generality. The same solution can be DataGuide. control protocol for XML documents in detail here. Our protocol MPX, which stands based protocols, graph-based protocols and multiversion-based protocols in concurrency control. 
MPX relies on a global version number  X  for its functionality.  X  is just a counter that never decrease. Each transaction t is also assigned to a version number, which is number of t is denoted by () t  X  . Each version k n of a node n has a version number  X  too. MPX differentiates between read-only transactions and update transactions. Suppose a transaction t issues an operation on node n , MPX operates as follows. is a read-only transaction, then the cont ent returned is the most recent version of n other words, the content read by (, ) rtn is k n , which satisfies the following requirements: 3. Version k n has not been deleted, that is, () k d n false = . 
In some case, the required version k n does not exist. For example, node n has just aborted. In this situation, the read operation is simply ignored. getting the lock, it reads the latest valid version of n as in a read-only transaction. should also be acquired. If the lock conflicts with a lock of another transaction, t will be blocked until the conflict has been resolved or killed by the deadlock detector. 
After t gets the lock successfully, it operates in the following way. number to  X  ; 2. Otherwise, find the same version k n to be update as in read operation. number. If the write operation is a deletion, () j dn is set to true. 
At the time when an update transaction t commits, it carries out the following operations in order: 1. For each version k n created by t , sets () k n  X  to 1  X  + ; 2. Increments  X  by 1; 3. Releases all locks held by t . version number of all versions create by t is  X  , it will be ignored base on MPX. aborts, MPX follows the rule of rigorous two-phase locking for update transactions. 
The protocol is not complex, but it ensures several  X  X ice X  features, which are depicted in the following theorems. Theorem 1: If all transactions are valid transactions, MPX can ensure serializability, recoverable and cascadelessness. Sketch of proof Moreover, since a read-only transaction never reads  X  X irty X  version created by uncommitted update transaction, recoverable and cascadelessness are obviously guaranteed. For two update transactions, since MPX use the combination of two serializability, recoverable and cascadelessness are ensured. 
Furthermore, since read-only transactions never acquire any lock, they are never That is, we have the following theorem. Theorem 2: Read-only transactions will never be blocked base on MPX. At the same time, update transactions will never be blocked by read-only transactions. In order to test the performance of MPX, we implement a prototype system on top of DOM. Together with MPX, two other protocols presented by G. Moerkotte, namely OO2PL and XCO, are also implemented for comparison. We choose these two timestamp-based protocol respectively [22][23]. 
The dataset we used for experiments are generate by the XML generator of XMark [24] with factor 0.1, roughly 10MB in size (we have also run the test on smaller and also drew from XMark. For simplicity, we only kept XPath expressions. For update transactions, we make 50% percent of queries to updates. For ease of implementation, the update operations just mark something to be updated without modifying the content of it, so that physical recovery is no t needed if a transactions rollbacks. This is not a big issue, for we concentrate on concurrency control only, except that the transaction throughput should be a little lower for protocols that have higher abortion rate. 
Each transaction, despite of read-only and update, consists of roughly 5 queries or ranging from 0 to 50 milliseconds. 5.1 Varying the Number of Concurrent Transactions This subsection shows the performance of each protocol with different number of transactions and 30% update transactions. The performance is measured in four parameters, which are depicted in Fig 1. 
Fig 1(a) depicts the percentage of aborted transactions as a function of number of concurrent transactions. Obviously, more concurrent transactions will lead to higher XCO. Similarly, Fig 1(b), Fig 1(c) and Fig 1(d) show the successful transactions per second, the average response time for successful transactions and the average response time for successful read-only transactions, respectively. As we can see in Fig transaction throughput, even in low degree of concurrency. The reason is that OO2PL will acquire much more locks than MPX, thus results in a high overhead. For response time, XCO is slightly better than MPX for it never waits for locks. However, for response time of read-only transactions, MPX is obviously the winner. And only MPX can guarantee a constant response time for read-only transactions. 5.2 Varying the Percentage of Update Transactions update transactions, ranging from zero to nearly one hundred. The experiment is conducted with 10 concurrent transactions. 
As shown in Fig 2(a), the rate of aborted transactions grows when the percentage of update transactions become higher. In all situations, MPX leads to least abortions. XCO also performs OK when the portion of update transactions is low or median, but shows that the transaction throughputs of MPX and XCO are much the same, much higher than OO2PL. In Fig 2(c), we can see that when the portion of update transactions is high, OCX is the winner. Th is is because that conceptually MPX uses two-phase locking for update transactions and have to wait on locks. However, for although the response time of OCX is the lowest in high update oriented environment, its abortion rate is also very high. 5.3 Typical Query Oriented Environments As we have stated before, most XML application are query oriented. That is, most transactions are read-only transactions. This subsection shows the performance of zero to 10. Similarly, the experiment is conducted with 10 concurrent transactions. (c) Response time (d) Response time for read-only transactions 
As we can see from Fig 3, MPX is quite suitable for typical query oriented environments. The transaction throughput, average response time and response time for read-only transactions of MPX are much the same as XCO. However, MPX has a superior feature that its abortion rate if extremely low in query oriented environments. Multiversion concurrency control schemes have been used by some traditional XML database has not been investigate so far. In this paper, we represent a multiversion concurrency control protocol, namely MPX, for native XML database. ability to ensure recoverability and cascadelessness. However, which distinguishes MPX from other protocols the most is that in MPX read-only transactions and update transactions never block each other. 
We have conducted thorough experiments on MPX and other two existing leading protocols, OO2PL and XCO. The results show that almost in all situations, MPX wins the contest. The non-blocking of read-only transactions and update transactions And we can see multiversion shows its power in native XML database again. 
However, to implement a multiversion XML database may be a tough task. For work, e.g. storage system, has to be done. 
