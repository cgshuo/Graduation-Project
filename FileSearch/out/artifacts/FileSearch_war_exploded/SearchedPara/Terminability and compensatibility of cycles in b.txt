 1. Introduction
Business process management systems (BPMSs) and workflow management systems (WfMSs) are increasingly used not only to automate business processes but also to manage them as important corporate assets [3,25,26,33,43] . BPTrigger is a part of efforts toward integrated process management (IPM) which was proposed as a business process management ap-proach to support the entire process lifecycle [16] . Within the context of IPM, a Web-based BPMS, called ProcessWare , was developed with an XML-based process definition language, called IPM-EPDL [17] . ProcessWare enables platform-inde-pendent execution of business processes. IPM-EPDL is a directly executable process definition language. In terms of process enactment, it is similar to BPEL which is becoming the industry standard in business process automation. BPTrigger was pro-posed to augment IPM-EPDL for constraint checking and exception handing [7] . This paper introduces the cycle resolution approach of BPTrigger. A prototype system based on this paper has been implemented [19] .

BPTrigger is a process-oriented trigger model that provides economy of specification and more efficient execution than database (DB) trigger for complex business constraints that must be applied to several business processes [7] . Similar to
DB trigger, however, BPTrigger may introduce a cycle in the underlying business process which may result in non-termination.
Exploiting the meaning of cycles in business processes, however, it is possible to determine whether certain cycles will terminate or not. For example, a cycle can be introduced to use an alternative resource for a business process since the cur-tive resources are finitely available, then the process will eventually terminate unless the failed resource is reused repeatedly. This kind of situation can occur naturally with consumable resources. For example, a process/activity errors).

In the WfMC reference model, the term  X  X  X esource X  is used to address a workflow/process participant such as a program or a machine [36] . In this paper, resources of a process/activity mean physical or logical goods used as input to the process/ activity. A process may repeatedly consume or use a resource in such a small quantity that it appears to be a never-ending cycle. If the resource is continuously consumed in a quantity greater than zero, however small, then it will be eventually exhausted causing the cycle to end at least in a centrally coordinated environment. In other words, the cycle will be even-tually broken unless the resource consumption quantity converges to zero as the cycle progresses. It is possible to mathe-matically determine the convergence of resource consumption if the cycle depth is used for specifying the resource resource at least in the marginal quantity is guaranteed to terminate if the associated resource is finitely available.
Exploiting the characteristics of process activities, it may also be possible to avoid ill-defined cycles in terms of compen-satibility. Introducing a cycle in a business process may require compensating or undoing the executed activities of the pro-cess, some of which are not compensatible or undoable. For example, if a cycle is introduced to disassemble and reprocess the parts that are joined with bolts and nuts, then the cycle may be allowed. If the parts are welded, however, the cycle may ther, a cycle may include several activities that need to be compensated to achieve the purpose of the cycle. Hence, analyzing the meaning or intention of a cycle against each activity to be compensated is required.

This paper presents an approach to determine the terminability of a cycle introduced by a BPTrigger in a business process and determine whether a cycle introduced by a BPTrigger is allowable in terms of compensatibility. Examining the meaning of cycles that can occur in business processes, the paper classifies them into rework , incremental , decremental and replacement types in terms of process resources. Then, it identifies the conditions for certain cycle types to terminate with the marginal quantity assumption. Adopting and extending the concept of activity types proposed for well-formed sphere [4] , process how to detect and avoid an ill-defined cycle that may not be allowed, comparing the activity types and compensation oper-is shown that co-existence of an incremental cycle and a decremental cycle which involve the same resource is the only case that can result in non-termination caused by multiple cycles excluding rework cycles that can cause non-termination individ-ually. To detect such a case, an additional procedure is proposed which uses a composite cycle graph constructed from individ-
With the proposed approach, it is possible to detect and avoid certain cycles that can cause non-termination and cycles that may not be allowed in terms of compensatibility, which offers advantages over database trigger. The proposed approach is also expected to contribute to analysis for well-designed business processes as well as transactional workflow research. Espe-cially, some limitations of well-formed sphere are addressed. Alonso and Hagen proposed the concept of well-formed sphere well-formed sphere also guarantees termination in some cases. They did not, however, consider the terminability of work-The remainder of the paper is organized as follows. In Section 2 , related research is reviewed. After a brief introduction of
BPTrigger, Section 3 discusses the types and meaning of cycles in business processes, process activities, and compensation operations. Section 4 informally describes how to determine whether a cycle is terminable and well-defined in terms of compensatibility. Section 5 formally presents cycle analysis procedures for terminability and compensatibility along with a validation example. Finally, Section 6 concludes the paper. 2. Related work
The approach proposed in this paper exploits the meaning of cycles and business process activities. It adopts and extends the notion of activity types proposed by Hagen and Alonso [4] for well-formed sphere that defines the behavior of fault tol-process that forms a well-formed sphere guarantees atomicity. It will finish successfully once retriable activities, which are the terminability issue for workflows with cycles. Further, they assumed separate exception handlers that can roll back pivotal activities, which may not always hold. By definition, pivotal activities are not compensatible or retriable. As such, more generally using characteristics of resources, activities, and cycles.
 BPTrigger was proposed for failure-handling by extending the ECA model [28,30] from the business process perspective [7] .
Business processes must be correctly defined to avoid any costly maintenance in deployment stage [42] . Especially, cycles in business processes can cause significant waste of valuable enterprise resources. Several approaches have been proposed to solve the problem. The most notable approach is to use Petri nets and formal semantics in terms of transition systems. Recent works on EPCs [12,20] and YAWL [41] clearly illustrate this approach. Alternatively, graph-based analysis techniques can be usedtoanalyzecyclesinbusinessprocesses.SadiqandOrlowska [38] proposedanalgorithmthatemploysasetofgraph reduc-tendedthegraph reductiontechniquetohandlecyclicmodels.vander Aalstetal. [44] showedthatthesetofreductionrulesfor detection of structural conflicts presented by Sadiq and Orlowska is not complete. They proposed an alternative algorithm that translates a workflow graph into a workflow net, a subclass of Petri nets that provides numerous analysis tools.
In the transactional workflow area, several studies were conducted to detect cycles using various analysis tools [15,39,40] . There were projects such as Exotica and Meteor to build large-scale workflow management systems (WfMSs) with transactional support [6,9] . There were also several efforts for process exception handling and compensation using BPEL pensation) to Petri nets. With a translated Petri net, various static analyses of the target business process (for example, to determine whether it is safe and bounded) can be performed as well as simulation. Their approach, however, does not include means to statically resolve cycles which are handled by the approach proposed in this paper. Kamath and Ramamri-tham [23] used the notion of compensation for error handling and proposed a novel approach called opportunistic compen-sation and re-execution for error handling. Another noteworthy approach for failure-handling was proposed by Unruh et al. [2] . They proposed a goal-based semantic compensation approach in which compensation works are declaratively specified and dynamically determined at runtime.

Terminability of active databases and/or rule systems is an important research issue for which a number of papers have been published. Baralis and Widom [10] developed a general framework to provide static analysis techniques for predicting whether a given rule set, including both condition X  X ction (CA) and event X  X ondition X  X ction (ECA) active database rules, is guaranteed to terminate and whether rule execution is confluent (guaranteed to have a unique final state) or not. They showed how a propagation algorithm can be applied to check the termination and confluence for sets of CA and ECA rules. the XML context.

Existing commercial DBMSs are adopting simple and practical approaches for non-termination or deadlock prevention. To guard against an indefinite loop, a transaction will be aborted with an abrupt message if a certain large maximum recursion depth is reached [35] . This simple approach, however, may lead to a failure of the process which may eventually succeed in committing. In another approach, a transaction sets a timeout every time it makes an operation request [29] . If it does not receive the acknowledgement that the operation has been executed successfully before the timeout expires, then it assumes that it is involved in a deadlock and aborts. This approach may abort transactions that may not be deadlocked, thus, causing unnecessary rollbacks [27] . Another drawback of the algorithm is that the timeout scheme can neither guarantee that a transaction can finish, nor that a transaction will not be aborted an indefinite number of times. Despite these problems, the algorithm performs surprisingly well in distributed DBMSs and is used by many commercial DBMSs [29] . To alleviate the drawbacks of the timeout approach, some systems (e.g., Oracle) use a deadlock detector at each site which is responsible for detecting local deadlocks.

In this paper, a cycle analysis graph (CAG) is introduced to formally represent a cycle as a graph and determine whether it will terminate or not. Then, it is proved that the termination determination is correct by using several lemmas. Recently, there have been several studies to analyze graph models using graph transformation techniques. Baresi and Pezze [21] showed how graph transformation can be used to analyze software systems. Godard et al. [11] used a graph rewriting scheme to detect the termination of distributed computations. These techniques may be used to augment the proofs for terminability in this paper. 3. Cycles in business processes
After a brief introduction of basic features of BPTrigger, this section discusses the types of cycles that can occur in busi-ness processes with BPTriggers. Then, the notations and concepts for analyzing terminability and compensatibility are introduced. 3.1. BPTrigger: a process-oriented trigger
DB triggers are used to enforce integrity constraints related to data stored in databases [31,32] . They are not adequate, however, for complex business constraints that must be applied to several business processes, hence, involving many data items. Further, current DB triggers may cause serious performance degradation including non-termination [45] .
Park and Choi proposed BPTrigger to overcome these limitations of current DB triggers [7] . They defined BPTrigger by extending the ECA model [27,30] from the business process perspective. Unlike a DB trigger that must be defined on each data item participating in a constraint and checked every time the data item is updated, a BPTrigger is defined on a business process and checked before, after, or at a specific time of the process execution. The action of a BPTrigger, which is invoked when the condition is evaluated as true, is a process/activity that handles the exception/error specified by the condition. Fig. 1 shows the top-level syntax of BPTrigger using the extended BNF notation.

Fig. 2 shows an example of BPTrigger that enforces an inventory policy. It states that the activity for placing an emergency purchase order must be executed if the current inventory level is not sufficient after the inventory counting activity is per-formed. Several advantages of BPTrigger were discussed including a possible performance gain in [7] . 3.2. Cycles in business processes with BPTriggers
Executing a business process often involves a cycle. For example, an iteration cycle is a simple repetition of one or several not cause non-termination. Another type of iteration cycle shown in Fig. 4 , however, does not terminate since the condition to exit the cycle is unsatisfiable.

These two iteration cycles can be considered to be of the same type where the iteration exit condition of the former is
This assumption is made to present the proposed approach in the context of BPTrigger. The approach, however, can be applied to a general process model.

The BPTrigger in Fig. 2 is an example of forward exception/error handling which handles an exception/error without re-executing the target process. Exceptions in business processes are, however, often handled in a backward manner which introduces cycles. That is, previously executed activities of a business process must be re-executed to handle an excep-tion/error since the process cannot proceed with the currently used resources.
 bolts and nuts, and activity A5 inspects the entire assembly and attaches a label. Fig. 6 shows the BPTrigger syntax for specifying cycles and compensation operations extending the syntax in Fig. 1 . Note that the activities in the example may be executed concurrently in different environments or locations. For example, A1 may be performed in a machining shop while A3 is executed at a preparation station.
 they are too small. For the example X  X  sake, it is assumed that holes can be drilled even if chrome is coated on part a.
The BPTrigger in Fig. 7 states that activity A1 should be re-executed after undoing A4 if the exception specified in the con-dition clause arises. UNDO(A4) is specified to disassemble the entire assembly so that part a can be re-drilled. That is, the
BPTrigger introduces a cycle for backward exception/error handling. A cycle to handle an exception like this one, which can An exception may occur in a business process when some of the currently used resources of the process are not sufficient.
A cycle that re-executes a process with incrementing some of its currently used resources to handle this kind of exception will be called an incremental cycle. Fig. 8 shows an example of an incremental cycle which re-executes activity A2 if the chrome-coating on part a is not thick enough.

The syntax of REDO operation is extended to specify additional resource handling required for re-execution of the target ger in Fig. 8 states that additional chrome should be supplied and activity A2 should be re-executed after undoing A4 if the exception specified in the condition clause occurs. As indicated in this example, an incremental cycle is defined by a BPTrig-ger that requires an ADD operation before its re-execution target.

Similar to an incremental cycle, a cycle that re-executes a process with decrementing some of its resources will be called a decremental cycle. Fig. 9 shows an example of a decremental cycle which re-executes activity A2 if the chrome-coating on part a is too thick. For the example X  X  sake, it is assumed that chrome coating can be removed.
 REDO(A) AFTER DELETE( r ) specifies that resource r should be deleted or removed before activity A is re-executed. The
BPTrigger in Fig. 9 states that a certain amount of chrome should be removed after undoing A4 and A2, and activity A2 should be re-executed if the exception specified in the condition clause arises. As indicated in this example, a decremental cycle is defined by a BPTrigger that requires a DELETE operation before its re-execution target.

A cycle to re-execute a process with an alternative resource is required if the process cannot proceed with the currently used resource. The resource that fails the condition for the process to proceed must be replaced. This type of cycle will be called a replacement cycle. Fig. 10 shows an example of a replacement cycle which re-executes activity A1 if the holes on part a are too big. A new instance of part a must be supplied to activity A1 since the old instance cannot be re-used.
REDO(A)AFTERREPLACE( r )specifiesthatthefailedresource r shouldbescrappedandanewinstanceof r shouldbesupplied example,areplacementcycleisdefinedbyaBPTriggerthatrequiresaREPLACEoperationbeforeitsre-executiontarget.Section 4.1 will discuss why a REPLACE operation is needed instead of a DELETE operation followed by an ADD operation. 3.3. Compensation operation and activity type
As illustrated by the above examples, a cycle may require an operation such as UNDO for compensating or undoing a pro-be re-executed. An activity that can be undone by the activity performer using the equipments for the activity itself will be called undoable . Activity A4 is an example of the undoable activity type.

Some activities require additional activities to compensate, that is, possibly by different performers using additional equipments and/or resources. Such an activity will be called a recoverable activity. Activity A3 is an example of the recover-able activity type. For the example X  X  sake, it is assumed that heating is required to separate the parts combined with glue.
Fig. 11 shows an example BPTrigger that introduces a cycle to re-execute activity A3 with more glue if parts b and c are not glued strong enough.
 compensated with an UNDO WITH operation.
 tion 5 will present procedures to determine the terminability and compensatibility of a cycle using the notion of cycle anal-ysis graph constructed from a process definition and BPTriggers declared on the process. In a cycle analysis graph, each node is an activity that is undoable, recoverable, or fatal type declared by the (human) process definer. 4. Terminability and compensatibility
This section informally discusses the proposed cycle analysis approach. First, the following extension is made to the pre-viously introduced BPTrigger specification convention for cycles: a BPTrigger must specify all activities to be re-executed as well as compensation operations required to handle an exception/error. Each activity to be re-executed must be specified with a REDO operation. For example, the BPTrigger in Fig. 10 is redefined as shown in Fig. 12 .

The BPTrigger in Fig. 12 specifies the following: if the exception specified in the CONDITION clause arises, then undo activity A4 to separate part a from the entire assembly, replace part a with a new instance, and re-execute activities A1 fol-the activities to be re-executed. This extension requires that a normal control flow is overridden by an exception handling control flow. The reason for the extension is explained below.
 As the above example shows, a cycle is introduced when the target activity of a BPTrigger and the last activity in its ACTION clause are the same. For a cycle, compensation operations are specified followed by the activities to be re-executed.
The activities to compensate and whether to compensate them with UNDO or UNDO WITH must be decided by the BPTrigger definer who specifies the exception handling. For the above example, only A4 needs to be undone to separate part a from the entire assembly. This decision making cannot be automated. Further, additional operations required for an UNDO WITH operation can be decided only by the BPTrigger definer.

Activities to compensate for exception handling are known as compensation scope or recovery area for which satisfiable solutions have not been provided [8,18] . But, some guidelines can be given. For example, the activities that are independent of the resource that causes a cycle do not have to be compensated. The BPTrigger in Fig. 12 does not enforce Activity A3 to be undone since its resources parts b and c are independent of part a that causes the cycle. The activities to re-execute for a cycle must also be decided by the BPTrigger definer. To illustrate the difficulty of automating this decision making, the BPTrigger in Fig. 7 is redefined as in Fig. 13 .

Since the above cycle is introduced to enlarge the holes on part a which is already chrome-coated, it is not necessary to re-execute A2 that coats chrome on part a. As this example shows, it may not be necessary to re-execute all the previously exe-cuted process activities. Hence, it is required to specify the activities for the exception handling that suppress the normal flow. Note that the activities that are compensated (with UNDO or UNDO WITH) must be re-executed.
 For a set of BPTriggers defined on a business process, analysis for terminability and compensatibility will be performed.
The remainder of this section discusses the core idea of the analysis. 4.1. Terminability
An incremental cycle requires only an addition of a resource. Hence, it does not cause non-termination if it involves a ment, decrement, or replacement) which is greater than zero. Continuously incrementing a resource will eventually make
On the other hand, decremental cycles do not cause non-termination regardless of their resource types with the marginal quantity assumption. It is because continuously decrementing a resource that is being used by a process will eventually sat-isfy the condition for the process to proceed (i.e., to exit the cycle).

A replacement cycle is introduced to re-execute activities of the target process with an alternative resource which re-quires discarding the currently used resource. Hence, if the resource is consumable and finitely available, then the process ginal quantity assumption. That is, a replacement cycle does not cause non-termination if it involves a consumable and finite resource type.

For a replacement cycle involving non-consumable, hence, reusable resource type to terminate (or not to cause non-ter-mination), the resource that fails the condition for the process to proceed should not be reused repeatedly. The REPLACE operation introduced in Section 3.2 has an additional requirement of discarding or scrapping failed resources so that they are not reused. This is why a REPLACE operation is needed to specify a replacement cycle in stead of a DELETE operation fol-lowed by an ADD operation.

A rework cycle may result in non-termination since the BPTrigger that introduces the cycle will be invoked repeatedly cannot satisfy the tolerance for meeting the lower bound for the holes, the BPTrigger will be invoked repeatedly.
Table 1 summarizes the terminability of a cycle introduced by a BPTrigger. Section 5.1 will present a terminability anal-ysis procedure based on the table. The approach proposed in this paper is limited since business processes often involve log-ical, hence, reusable and infinite resources. A process that involves a finite resource, however, will eventually finish successfully or fail since the resource will be exhausted even though the process involves other infinite resources. Further, expense up to a certain amount depending on her/his financial status or position. An example that involves logical but finite resources will be provided in Section 5.3 .

Although individual cycles terminate, they may interact, causing non-termination. Co-existence of an incremental cycle and a decremental cycle that involve the same resource, for example, may result in non-termination since the BPTrigger for the former repeatedly causes the BPTrigger for the latter to be invoked and vice versa. To illustrate this kind of non-termi-nation, consider the following scenario with the BPTriggers in Figs. 8 and 9 redefined as follows: tion 5.2 will present a procedure to detect this kind of situation. 4.2. Compensatibility
As discussed in Section 3.2 , each process activity is of undoable, recoverable, or fatal type. If a compensation operation specified in a BPTrigger is not compatible with the type of the activity to be compensated by the compensation operation, then the cycle will be called ill-defined . A compensation operation UNDO(A) is compatible only if the type of activity A is an additional operation required to compensate activity A). Other cases are incompatible. Especially, any compensation oper-ations for fatal activities are not compatible.

An ill-defined cycle should be disallowed since one or more activities in the cycle cannot be properly compensated. That state in which the process activities can be re-executed. Hence, ill-defined cycles must be detected before their target pro-cesses are executed and the corresponding BPTriggers must be corrected or removed.
 and undoable respectively. All the cycles introduced so far are not ill-defined.
 The cycle defined by the following BPTrigger is an example of an ill-defined cycle.
 The BPTrigger in Fig. 16 contains UNDO(A3) while A3 is of recoverable type. Hence, this cycle must be disallowed.
Table 2 summarizes the meaning and compatibility of activity types and compensation operations. Section 5.1 will pres-ent a procedure to detect ill-defined cycles. 5. Cycle analysis
This section formally presents cycle analysis procedures using the notion of cycle analysis graph. Especially, a procedure is proposed which checks the terminability of multiple cycles using a composite cycle analysis graph constructed from cycle analysis graphs of the associated cycles. It will be shown that only co-existence of an incremental cycle and a decremental cycle that involves the same resource may result in non-termination, which will be detected by the proposed procedure.
Finally, the section presents a validation example. 5.1. Cycle analysis graph
A BPTrigger that introduces a cycle is represented as a directed graph, called cycle analysis graph . As mentioned in Section same. For each BPTrigger that introduces a cycle, a cycle analysis graph is constructed to check whether the cycle is termi-nable and well-defined or not in terms of compensatibility.

In this section, a component of a BPTrigger is referred to as the name of the corresponding non-terminal symbol introduced in Figs. 1 and 6 . Further, the dot notation is used to refer to an inner-level non-terminal symbol. For example, re-executed by BPTrigger Example 4 0 in Fig. 12 are A1, A2, A4, and A5.

A cycle analysis graph is composed of a set of nodes and a set of arcs that connect pairs of nodes in the node set. Each activity specified in the action X  X escription clause of a BPTrigger is included as a node in the corresponding cycle analysis graph, whether it is the target of compensation or the target of re-execution. Each arc in a cycle analysis graph is specified The cycle analysis graph is formally defined as follows.
 Definition 1 (Cycle analysis graph). A cycle analysis graph G extracted from a BPTrigger bpt is a tuple ( N , A ) such that where n .type 2 { X  X  X ndoable X ,  X  X  X ecoverable X ,  X  X  X atal X  X .

A ={ h on , dn ij on is O i 1 .activity if i &gt; 1 or bpt. event X  X escription.process X  X vent.activity if i = 1, then dn is O is the i th operation in bpt.action X  X escription ( i P 1)}.
 to dn (i.e., O i .activity) as follows:  X  a .type = undo, a .property =  X  if O i = UNDO( dn ),  X  a .type = undo, a .property = { a 0 }if O i = UNDO( dn ) WITH ( a 0 ),  X  a .type = redo, a .property =  X  if O i = REDO( dn ),  X  a .type = redo, a .property = {replace( r )} if O i = REDO( dn ) AFTER REPLACE( r ),  X  a .type = redo, a .property = {add( r )} if O i = REDO( dn ) AFTER ADD( r ),  X  a .type = redo, a .property = {delete( r )} if O i = REDO( dn ) AFTER DELETE( r ).

The following graphical convention is adopted. Each node is represented as a small circle along with its type. The label of an arc denotes the property of the arc. Arcs are classified into two groups, compensation arc set CA and re-execution arc set RA according to the type of arcs as follows.

For an arc a =&lt; on , dn &gt; in A ,  X  if its type is undo, then a is in CA represented as ondn ,  X  if its type is redo, then a is in RA represented as ondn .
 Fig. 17 shows the cycle analysis graph of the BPTrigger in Fig. 12 .

The re-execution arc that corresponds to the first REDO operation in the action-description clause of a BPTrigger is execution arc as follows.

Definition 2 ( Cycle analysis graph type ). For a cycle analysis graph whose first re-execution arc is fra , its type is  X  replacement if fra .property = {replace( r )} where r is a resource,  X  incremental if fra .property = {add( r )} where r is a resource,  X  decremental if fra .property = {delete( r )} where r is a resource,  X  rework if fra .property =  X  .
 cycle analysis graph is replacement .

The compensatibility and terminability of a BPTrigger that introduces a cycle can be checked by analyzing its corresponding cycle analysis graph. As discussed in Section 4.2 , a BPTrigger with mismatches of activity types and compensation operations is ill-defined and must be avoided. Based on Table 2 in Section 4.2 , the following procedure checks the compensatibility of a BPTrigger in terms of cycle analysis graph.

Procedure Check _ Compensatibility (Graph G) { _iteration=number of nodes included in N of G;
FOR (i = 1; i &lt; = _iteration; i++) { }
RETURN  X  X  X ell-defined X ; }
Intheaboveprocedure,I_CA( n )isasetofincomingcompensationarcstothenode n ,definedasI_CA( n )={ h on , n ij on 2 N , h on , n i2 CA }. A node is compatible with compensation operations only if its type is undoable and the properties of all incoming compensationarcstothenodeare X   X   X ,oritstypeis recoverable andthepropertiesofallincomingcompensationarcstothenode in terms of compensatibility and the Check_Compensatibility procedure will return  X  X  X ell-defined X . Otherwise, the procedure operations are compatible with the associated activities. Hence, the procedure must be run before any process is executed.
For a BPTrigger that is well defined (in terms of compensatibility), its terminability is checked. Based on Table 1 in Section 4.1 , the following procedure checks the terminability of a BPTrigger in terms of cycle analysis graph.

Procedure Check _ Individual _ Terminability (Graph G) { _pr = property of the first re-execution arc of G; IF (_pr == X  X   X   X ) RETURN  X  X  X ay not terminate X ;
ELSE IF (_pr ==  X  X  X add( r ) } X ) { } ELSE IF (_pr== X  X  X delete(r)} X ) RETURN  X  X  X erminate X ;
ELSE IF (_pr== X  X  X replace(r)} X ) {
The terminability of a cycle analysis graph depends on its type and characteristics of the resource related to its first re-execution arc (_targetResource in the above procedure). In the above procedure, Check_R_Features() is a function which returns characteristics (such as finite or consumable) of the resource passed as a parameter. 5.2. Composite cycle analysis graph
As illustrated by the examples in Figs. 14 and 15 , non-termination can be caused by multiple cycles each of which ter-minates. Detection of non-termination caused by multiple BPTriggers is formalized using the notion of a composite cycle graph constructed from the cycle analysis graphs of the associated cycles (see Fig. 16 ).
 Definition 3 (Composite cycle analysis graph).
 A composite cycle analysis graph CCAG(CAG1,CAG2) of the cycle analysis graph CAG1 and CAG2 is defined as follows. Let CCAG(CAG1,CAG2) = (N,A), CAG1 = (N1,A1), and CAG2 = (N2,A2), then N ={ n j n 2 N 1or n 2 N 2}, A ={ a j a 2 A 1or a 2 A 2}.
 For each arc a in A1 \ A2, a = {pr1,pr2} where a .property = {pr1} for CAG1 and a .property = {pr2} for CAG2.
If the two participating cycle analysis graphs of a composite graph are disconnected, then non-termination will not occur since the two cycles are guaranteed of termination individually and will not invoke each other (since they are disconnected).
Further, if the two participating cycle analysis graphs do not involve the same resource, then non-termination will not occur since the two cycles are guaranteed of termination individually and they will not invoke each other since they are indepen-dent in terms of their resources. Two cycles are said to interact when they do not satisfy these two conditions. Definition 4 ( Interacting cycle analysis graphs ).
 Two cycle analysis graphs CAG1 and CAG2 interact, denoted as CAG1 ^ CAG2, when they satisfy the following conditions. Let CAG1 = (N1,A1) and CAG2=(N2,A2), then
CAG2.event X  X escription.process X  X vent.activity 2 N of CAG1 orCAG1.event X  X escription.process X  X vent.activity 2 N of CAG2. r 1= r 2 where r 1 is the target resource of CAG1 and r 2 is the target resource of CAG2, fra 2.property = {replace( r 2)}, {add( r 2)} or {delete( r 2)}, fra 2 is the first re-execution arc of CAG2).
Fig. 18 shows an example composite cycle analysis graph that combines two constituent cycle analysis graphs. Cycle analysis graphs CAG1 and CAG2 interact because they involve the same resource r and A2 is included in the node sets of the both graphs.

Rework cycles, which may cause non-termination, are detected by Check_Individual_Terminability procedure in Section 5.1 . Since rework cycles are excluded, six possible combinations of interacting cycle types must be examined to determine the terminability of multiple cycles. First, consider the case of two interacting incremental cycles. Since both cycles keep adding the (common) resource, each one will eventually satisfy its exit condition or fail if the remaining resources do not satisfy the condition Fig. 19 illustrates the argument. Given two incremental cycles C1 and C2, assume that the value of their target resource to exit the cycles are V1 and V2 respectively. That is, cycle C1 (or C2) will be broken when the value of its target resource is greater than V1 (or V2). Further, assume that C1 will be activated prior to C2. Fig. 19 a and b illustrates the cases where V1 &lt; V2 and the initial value of the target resource is less than V1.
 the termination of C1. The remainder of the figures in Fig. 19 shows all other combinations in terms of V1, V2 and the initial value of the target resource. A similar argument can be made for the case where both interacting cycles are of decremental type. Hence, the following lemmas can be proved. Complete and formal proofs of the lemmas in this section can be found in [19] .
 Lemma 1. Two interfering incremental cycles will not cause non-termination.
 Lemma 2. Two interfering decremental cycles will not cause non-termination.

A replacement cycle substitutes the current instance of its target resource with a new one, which will not affect the termination behavior of other cycles. For interacting cycles including a replacement cycle, the following lemmas can be proved.
 Lemma 3. Interacting incremental and replacement cycles will not cause non-termination.
 Lemma 4. Interacting decremental and replacement cycles will not cause non-termination.
 Lemma 5. Two interacting replacement cycles will not cause non-termination.

Finally, when an incremental cycle and a decremental cycle interact (or vice versa), non-termination can occur since one cycle increases the target resource while the other cycle decreases it. Hence, the following lemma can be proved. Lemma 6. Interacting incremental and decremental cycles may cause non-termination.
 The terminability of multiple interfering BPTriggers can be checked by the following procedure.

Procedure Check _ Composite _ Terminability (CompositeGraph CCAG(G1, G2)) { _pr1=property of the first re-execution arc of G1; _pr2=property of the first re-execution arc of G2; _targetActivity1=target activity of G1; _targetActivity2=target activity of G2; IF (_pr1== X  X  X add(r1)} X ) {
ELSE IF (_pr1 ==  X  X  X delete(r1)} X ) {
ELSE IF (_pr1== X  X  X replace(r1)} X ) { IF (_pr2 ==  X  X  X add(r2)} X ) {
ELSE IF (_pr2== X  X  X delete(r2)} X ) {
ELSE IF (_pr2== X  X  X replace(r2)} X ) {
IF ( (G1.type ==  X  X  X ncremental X  &amp; &amp; G2.type ==  X  X  X ecremental X ) k (G1.type ==  X  X  X ecremental X  &amp; &amp; G2.type ==  X  X  X ncremental X ) ) {
ELSE RETURN  X  X  X erminate X ; } }
The above procedure will return  X  X  X ay not terminate X  when a composite cycle analysis graph contains a pair of incremen-tal and decremental constituent graphs. Applying the above procedure to all pairs of non-rework cycles defined on a process will determine the terminability of the process. The overall termination analysis proceeds as follows: Before a BPTrigger is invoked, the Check_Individual_Terminability procedure is executed.

If a rework cycle is detected, then the target process must pre-empted (i.e., it fails) or the BPTrigger must be executed only a limited number of times before pre-empting the process using cycle depth or timer.

If an incremental cycle or a decremental cycle is detected, then the Check_Composite_Terminability procedure is exe-cuted with each interacting cycle. If it is determined that the BPTrigger may cause non-termination with any other
BPTriggers, then the target process must be pre-empted (i.e., it fails) or the BPTrigger must be executed for only a limited times.
 For all other cases, BPTriggers will be executed normally.

It must be noted that a cycle may not occur or may be broken if there are switches or branches on some of the activities included in the cycle. Hence, preemption of the target process would be prohibitive. Less prohibitive measures such as cycle depth or timer may be applied. 5.3. Validation example
This section illustrates and validates the proposed cycle analysis procedures using an example. Fig. 20 shows a travel vou-cher process that will be used as the validation example. It proceeds as follows: accounts to be applied against a voucher are selected in activity A1; information on transportation such as type and fare is entered in activity A2; information on hotel reservation is entered in activity A3; travel voucher is written with summing all expenses in activity A4; finally, payment is made to the requestor in activity A5. Before the payment is made, several conditions are checked to ensure that the selected accounts are eligible and they have sufficient balance, etc. Note that this example involves logical and reusable resources whereas the example in Section 3 involves physical and consumable resources.

In the above process, activities A1 and A4 are undoable . A2 and A3 are, however, recoverable since they require addi-tional canceling activities or activities notifying the requestor to cancel her/his reservations to compensate. Activity A5 is also considered recoverable in the sense that it can be undone if the requestor returns the paid travel expense to compensate.

Fig. 21 shows five BPTriggers to handle various exceptions for the example process. Notice that these BPTriggers are defined on the process voucher activity (i.e., A4) and their conditions are evaluated after the execution of the activity.
The first BPTrigger handles an exception that must be raised when the sum of all expenses has an erroneous value from a miscalculation.  X  X ONFIRM() X  is a built-in function that sends a parameterized message to the activity performer and evaluates to true if she/he sends an affirmative reply. When the total expense is greater than the available budget and the activity performer judges it as a miscalculation, the first BPTrigger will be fired (which will enforce re-execution of A4). The second BPTrigger handles an exception that must be raised when the transportation fare is greater than its upper limit. The required action of this BPTrigger is to reprocess the travel voucher with an alternative transportation choice (for example, bullet train) after canceling the first choice (for example, airplane). The second BPTrigger does not include an additional activity of canceling the first transportation choice. This will be detected as an ill-defined cycle because activity A2 is recoverable but not undoable. The third BPTrigger handles an exception that must be raised when the selected account set does not have sufficient balance for the voucher. The required action for this BPTrigger is to add accounts if there are any available to process the voucher. In the BPTrigger definition,  X  X ccounts X  is the set of selected accounts. Finally, the last BPTrigger handles an exception that must be raised when some of the selected accounts are not used for the voucher at all. In this case, the required action is to delete the accounts that are not used for the voucher. In the BPTrigger definition, OLD denotes the object state of an account in  X  X ccounts X  before the BPTrigger BPTrigger.
 Fig. 22 shows the cycle analysis graphs which are constructed from the BPTriggers in Fig. 21 .

The characteristics of the cycle analysis graphs are summarized in Table 3 . For example, the first re-execution arc of CAG1 is h A4,A4 i and the type of CAG1 is rework since the property of the first re-execution arc is portation X  is the target resource of CAG2 and will be replaced with an alternative before re-executing A2. The target resource of CAG3 is  X  X ccounts X  which will be incremented before re-executing A1, and the target resource of CAG4 is  X  X ccounts X  which will be decremented before re-executing A1.

The results of applying the Check_Compensatibility procedure introduced in Section 5.1 for the example BPTriggers and how the procedure detects ill-defined cycles are summarized in Fig. 23 . As indicated in the figure, CAG2 is ill-defined in terms of compensatibility because its compensation arc to A2 is incompatible with the type of A2 (see the underlined part of the figure). Since A2 is recoverable , the property of h A4,A2 i should not be not have incompatible compensation arcs.

The results of applying the Check_Individual_Terminability procedure introduced in Section 5.1 for the example BPTrig-gers cycles are summarized in Fig. 24 . The procedure detects that only CAG1 may cause non-termination since it is rework type.

Among the cycle analysis graphs in Fig. 22 , CAG3 and CAG4 interact (i.e., CAG3 ^ CAG4) because they involve the same target resource  X  X ccounts X  and CAG3.event X  X escription.process X  X vent.activity (i.e., A4) is included in the node set of G4. The composite cycle analysis graph combining CAG3 and CAG4 is constructed as shown in Fig. 25 .

Fig. 26 summarizes the result of applying the Check_Composite_Terminability procedure introduced in Section 5.2 to the composite cycle analysis CCAG(CAG3, CAG4). The BPTriggers in Fig. 21 c and d, whose cycle analysis graphs are CAG3 and
CAG4 respectively, introduce a pair of interacting incremental and decremental cycles. Hence, they may result in non-termination.
 6. Conclusion
BPTrigger is a process-oriented trigger model that provides economy of specification and efficient execution for complex proach to determine the terminability of a cycle introduced by a BPTrigger in a business process and determine whether a cycle introduced by a BPTrigger is allowable in terms of compensatibility.

The paper classified cycles that can occur in business processes into rework, incremental, decremental and replacement types in terms of resource usage. Then, it identified the conditions for certain cycle types to terminate with the marginal quantity assumption that there is a smallest unit of resource change which is greater than zero. Incremental cycles will not cause non-termination if they are introduced for handling finitely available resources. Decremental cycles will not result in non-termination regardless of their resource types. Replacement cycles will not cause non-termination if they involve fi-nite resources and failed resources are not reused repeatedly. Rework cycles may result in non-termination since the BPT-riggers that introduce the cycles will be invoked repeatedly unless the conditions that cause the reworks are corrected. In addition to individual cycles, co-existence of an incremental cycle and a decremental cycle that involve the same resource may cause non-termination. A process with cycles that may result in non-termination may be pre-empted or some other measures such as cycle depth or timer must be applied.

This paper classified process activities into undoable, recoverable, and fatal types in terms of compensatibility. Then, it discussed how to detect and avoid an ill-defined cycle that may not be allowed, comparing the activity types and compen-sation operations in the cycle. If a compensation operation specified in a BPTrigger is not compatible with the type of the activity to be compensated by the compensation operation, then the cycle is ill-defined. A BPTrigger that introduces an ill-defined cycle must be corrected or removed before its target process is executed.
 Finally, the paper formally presented the analysis procedures to determine the terminability and compensatability of a
BPTrigger using the notion of cycle analysis graph along with a validation example. Especially, it was shown that co-exis-tence of an incremental cycle and a decremental cycle which involve the same resource is the only case that can result in non-termination caused by multiple cycles excluding rework cycles that can cause non-termination individually. To detect such a case, an additional procedure was proposed which uses a composite cycle graph constructed from individual cycle analysis graphs.

With the proposed approach, it is possible to detect and avoid certain cycles that can cause non-termination and cycles that may not be allowed in terms of compensatibility, which offers additional advantages over database triggers. The pro-posed approach is also expected to contribute to analysis for well-designed business processes as well as transactional work-flow research. Especially, some limitations of well-formed sphere have been addressed.

One of the merits of the presented approach is that non-termination situations and ill-defined cycles can be detected with syntactic analysis of only action parts of BPTriggers. Further, simple extensions are made to typical compensation operations.
However, it has a few limitations. The presented approach assumes that a BPTrigger defines an exception involving only one resource and one type of cycle. It is needed to investigate whether an exception involving multiple resources and multiple cycle types can be equivalently specified by multiple BPTriggers. Further, the expressive power of BPTrigger is limited, especially, in terms of specifying trigger conditions and quantities of resource increment, decrement, or replacement. It is needed to study how to deal with a cycle that adds/deletes/replaces a resource in a series of quantities that converges to zero. A safeguard such as cycle depth or timer may be applied. Further, it may be possible to fail the target business process by mathematically determining whether a series of resource addition/deletion/replacement converges to zero.
Further research issues include inference of recovery area, specification of concurrent action statements, and incorpora-tion of semantic exception handling features to express dynamicity of real world business processes. Performance of BPTrig-ger needs to be tested in distributed environments with a full implementation of its prototype engine. Moreover, the applicability of the proposed approach to standard process languages such as BPEL should be tested using BPEL. Finally, graph transformation tools such as AGG may be used to augment the lemmas that validated the terminability of various cy-cle types in this paper [24] .
 Acknowledgements The authors would like to thank the Ministry of Education of Korea for its financial support toward the Electrical and Computer Engineering Division at POSTECH through its BK21 program.

References
