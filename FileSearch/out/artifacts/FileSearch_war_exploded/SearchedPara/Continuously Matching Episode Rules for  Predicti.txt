 In many applications, events such as specific TCP connections in an intrusion derive event associations represented as rules from the past events. The second one is our work. 
Fig. 1 shows an example of the discovered rule in the form  X  D  X  where  X  is called graph, where each vertex represents an event, and each edge from vertex v to vertex u corresponding to vertex u. To be specific, according to the predicate  X  in Fig. 1, event there are two time bounds associated with th e rule and the predicate, respectively. For accord with the specified temporal orders in the predicate, we can predict that all the prediction problem mines out such kind of rules with two time bounds (called episode rule ) from the past events. 
In the second step, whether all the events in the predicate have appeared according depicted in Fig. 2, and we are to match the ep isode rule in Fig. 1. Notice that events a, b, c, and d occur within the time interval [3, 8), which satisfies the temporal constraint in the predicate. Thus, we should give the alarm that the consequent, or event f, may occurrences of the events corresponding to the matching of the predicate as predicate episode occurrence . 
The discovery of episode rules has been widely discussed over the past few years episode rule matching. Since events arrive in streaming in all the applications mentioned above, how to efficiently match a number of episode rules in this problem of continuously matching episode rules over the stream of events. events over the stream. However, only the occurrences that give non-repetitive the example of the episode rule in Fig. 1 and the stream of events in Fig. 2. It can be {(a,3), (b,5), (c,6), (d,7)} (we use (e,t) to denote the event e with an occurring time t), Since the predicted interval [8,12) is included in [8,14) and becomes trivially deal with all the possible combinations of events within the specified time bounds to rules to be matched simultaneously. Moreover, events usually come in bursts. There is hence required. 
Our problem is related to three research topics. 1) Mining graph patterns from these methods are applied to a static graph database searching, which is very different from our work of continuous retrieval in the streaming environment. 3) Graph over DBMSs [2]. These works are similar to ours. However, we are to retrieve episodes within the specified time bounds and the repetitive reports of predicted time intervals should be avoided. So we cannot directly apply these algorithms to address our problem. occurrence and rejected event occurrence were introduced to address the first challenge mentioned above. With the constraints in our problem definition, the method ToFel to solve this problem. ToFel makes use of the topological characteristic the user-required episode occurrences, and thus avoid the backward scan of the experiments with respect to different scales and distributions of the query set and the stream, we show that ToFel is efficient and effective in the stream environment. description of the problem statement. Section 3 presents our rule matching algorithm. future directions of our work in Section 5. section, we first give the definitions related to the episode, and then present the basic concepts concerning the rule matching problem. Episode: An episode is a directed acyclic graph g, where each vertex corresponds to an event, and each directed edge (u,v) indicat es that the event corresponding to u must episodes consisting of vertices corresponding to different events. However, our corresponding to an identical event. (a i corresponding to v in S. (  X  occurrence of the predicate  X  with the time bound  X   X  over the event stream, and give introduce the concepts of mi-latest occurrence and rejected event occurrence, and give a clear definition of the rule matching problem. Definition 1. Minimal occurrence. A minimal occurrence O of a predicate episode  X  is 
We can focus only on the minimal occurrences and report their predicted intervals without loss of any desired information of the prediction. Meanwhile, there may exist several different occurrences with the same time interval, which give the same predicted interval. &lt;t &lt;t e . We call (e,t k ) the latest occurrence of e in [t s ,t e ) on  X  . [t of  X  . (  X  (v [t [t the minimal occurrences of  X  . 
For example, consider Fig. 1 and Fig. 2, where the latest occurrences of events a, b, occurrence of the predicate episode in the in terval [1,8) is the occurrence O = &lt;(a,3), (b,5), (c,6), (d,7)&gt;, which is also a minimal occurrence. Definition 4. Mi-latest occurrence. The mi-latest occurrence of a predicate episode  X  occurrence of  X  . 
We define the rule matching problem by the concept of mi-latest occurrence. The rule matching problem is to give predicted intervals of only the mi-latest occurrences to the user. Definition 5. The rejected event occurrence . Given a predicate episode  X  with (  X  v  X  (v i ) in interval (t i ,t i j ). appear later than O. occurrence of  X  (For the detailed proof of the lemmas in this paper, please refer to our technical report [1]). 
To conclude this section, only the latest occurrences with no rejected event occurrences are the mi-latest occurrences we are looking for. This is the basic of our approach, whose correctness can be guaranteed if such occurrences are always targeted during the rule matching process.  X  ,  X   X  X  , conf). ToFel builds a queue of event occu rrences that are likely to be parts of discuss which event occurrences should be kept in the queues and on which condition continuously monitoring of the stream. 
For each vertex of  X  , we implement a queue to store its corresponding event occurrence of  X  with another coming event occurrence. 
As time passes and more and more events arrive, we maintain the queues and only keep those useful occurrences. Since the queues is to store only the occurrences likely to contribute to the results, the occurrences whose occurring time t X  satisfies that t X  +  X   X   X  t (the current time) should be removed. In this condition, the maintenance of the mi-latest occurrence, we should adjust the queue by removing the rejected event occurrences. This condition is called rejected-event invocation. Both invocation forms are important for the correctness of our answer as well as the space saving. Definition 6. The nearest parent occurrence . Given any two event occurrences (  X  (  X  parent occurrence of (  X  (u),t X ). from child occurrence to its nearest parent ones, and maintain a counter for each parent occurrence indicating the number of nlinks between it and its child occurrences. 
In the following, we point out the principles for the maintenance of the queues and the further removal of other useless occurrences. A first, if there is no nlink between (  X  (  X  (v),t X ) can not be linked by any of the later child occurrences, and can be removed counts of those parent occurrences should be decreased by one accordingly. This may further cause the zero count of some of its parent occurrences. We should then adopt about principle again, and remove the parent occurrences with zero counts, except for vertex to several of its ancestors. We call this queue maintenance principle the parent-occurrence maintenance . Moreover, when an occurrence (  X  (v),t) is removed, the event occurrences that can be reached from (  X  (v),t) by nlinks should be removed too. This maintenance principle is called child-occurrence maintenance . 
To sum up, once an event  X  (v) comes at time t, v  X  V(  X  ), if v is not a sink of  X  , we Otherwise, if v is a sink of  X  , we detect whether the mi-latest occurrence of  X  exists. maintenance, 2) push (  X  (v),t) into Q v , and perform the parent-occurrence maintenance, and 3) check whether there exists a mi-latest occurrence according to Lemma 2 presented later. If a mi-latest occurrence exists, the rejected-event invocation will call mi-latest occurrence from the queues of event occurrences. (  X  (v),t) kept in Q v , and (  X  (v),t) is the latest occurrence of  X  (v) so far. of  X  . If there is a mapping occurrence of v (  X 
The correctness of ToFel can be proved as follows. Whenever a new mi-latest each sink occurrence comes, we check if there exists a mi-latest occurrence by Lemma 2. And, we can prove that the time complexity of ToFel is O(n). [1] as well as the scalability on the structure of the episode and the size of the dataset. For the parameter settings, please refer to [1]. 
Fig. 3 shows the average execution time at each timestamp with respect to the number, ToFel always outperforms DirectMatch. And the increasing ratio in running time of ToFel is less than that of DirectMatch significantly. This can be explained that when matching an episode, ToFel only concerns the events likely to form the mi-result shows the slow increase in CPU time as well as the smaller time requirement of approaches have the constant average running time at each timestamp no matter how the size of the stream changes. occurrences such that no repetitive predicted intervals are reported. Besides, we build one timestamp. Moreover, a series of experiments demonstrate the high performance future work, we will focus on utilizing the common substructures among the predicate episodes so as to more efficiently process a batch of them simultaneously. Acknowledgments. This work was partially supported by the NSC Program for Advanced Technologies and Applications for Next Generation Information Networks (II) under the grant number NSC 95-2752-E-007-004-PAE, and the NSC under the contract number 95-2627-E-004-002-. 
