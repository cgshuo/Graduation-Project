 Real-time distributed groupware se nds several kinds of messages with varying quality-of-service requirements. Howe ver, standard network protocols do not provide th e flexibility needed to support these different requirements (either providing too much reliability or too little), leading to poor performance on real-world networks. application-level networking te chnique called adaptive forward error correction (AFEC) for r eal-time groupware. AFEC can maintain a predefined level of reliability while avoiding the overhead of packet acknowledgem ent or retransmission. We analysed the requirements of ty pical real-time groupware systems and developed an AFEC technique to meet these needs. We tested the new technique in an experiment that measured message reliability and latency using TCP, plain UDP, UDP with non-adaptive FEC, and UDP with our AFEC scheme, under several simulated network conditions. Our re sults show that for awareness messages that can tolerate some loss, FEC approaches keep latency at nearly the plain-UDP level while dramatically technique that can maintain a specified level of reliability and also minimize delay as network cond itions change. Our study shows that groupware AFEC can be a usef ul tool for improving the real-world performance and usability of real-time groupware. H.5.3 [ Information Interfaces and Presentation ]: CSCW Performance, Design, Reliability, Human Factors. Synchronous groupware, latency, reliability, adaptive FEC Real-time distributed groupware often sends several different requirements. For example, awareness messages like telepointer updates need low latency, but do not need to be completely reliability guarant ees, but may not make strict latency demands. In addition, some message types can have different requirements depending on context, such as when telepointers are used for communicative gestures (where more messages will be needed to show smooth movement) instead of for general group awareness (where low-granularity positional in formation is often sufficient). The QoS requirements of real-time groupware must be met either developer. The dramatic improvements to Internet availability and pervasiveness over the past several years suggest that groupware X  X  QoS requirements can be easily me t by standard protocols and techniques, but experience shows that this is not always the case. There are two main problems. First, Internet networks are not real-time interaction through gr oupware. Although some network there are still many settings where both delay and loss are common. For example, problems can be caused when connecting from one broadband network to another, when using wireless or cellular networks, when connecting across inter-continental links, when network traffic is heavy, or when working in rural or remote regions with less-developed infra structure [1,3,20,22,26]. As a result, users  X  even in North America or Europe  X  may frequently experience loss rates above 5% and delays above 250ms, with such as packets that are out of order or too late to be useful). Second, the network protocols that groupware developers use most commonly (TCP in particular) are poorly suited to real-time retransmission completes. Many groupware messages do not need latency, and thus interaction can suffer greatly. As a result, game developers and groupware researchers have moved to UDP-based transport for real-time groupware. UDP has many advantages for tuned to the needs of groupware  X  for example, they often provide 100% reliability and often force in-order delivery, when groupware messages have varyi ng reliability and ordering requirements, and would benefit from a more flexible approach. Forward Error Correction (FEC) [2,19,22] is a technique well known in the networking world that could provide this flexibility, and could form the basis for a groupware-centered application-level reliability scheme. FEC duplicates messages in successive retrieved from a later packet. FEC has the advantage of providing reliability without requiring ac knowledgment or retransmission (which cause the latency problems of TCP-style reliability). In addition, adaptive versions of FEC (AFEC) can provide a wide current network conditions [2]: in low loss situations, the adaptive technique reduces redundancy which also reduces bandwidth balance between reliability and latency is met. real-time groupware. However, although many researchers have no thorough analysis of the technique to establish its effects on the performance of r eal-time groupware. correction for groupware. We develop an AFEC technique time groupware, and carry out an evaluation to see the effects on groupware performance. Our study shows that the technique works very well at managing lo ss and latency in real-world status and to changing demands at the application level. To make our AFEC technique widely avai lable to groupware developers, we have built a reference im plementation on top of the open-source Lidgren UDP library [14]. In this work, we provide strong evidence that AFEC is a powerful and practical technique for maintaining QoS requirements in real-time groupware; the benefits to user-level experien ce can substantially improve the usability of real-time collaboration at a distance. Network issues for real-time systems have been studied in several domains, including distributed sy stems, networking, and CSCW. We review this research below, focusing on issues that are of greatest relevance to our inves tigation of FEC for groupware. aspects of computer networks that define performance levels for distributed systems. Many CSCW papers mention QoS and its model or deliver QoS. This may be because QoS in real-time groupware is complex compared to other classes of applications, nature of the tasks and interaction techniques [8,10]. associated QoS parameters . An early QoS model designed specifically for groupware is described by Mathur and Prakash are many other characteristics that could be considered for a complete QoS model of groupware, such as security, frequency, resolution, accuracy, precedence, and authenticity (which are described in the generic IS O/IEC QoS model [14]). Managing QoS in groupware is also different from other groupware sessions. Unlike systems that only transport streaming media (e.g., VoIP), groupware QoS techniques must adjust to the group dynamics. For example, Gr eenhalgh [10] describes a QoS possible to improve performance by considering individual QoS characteristics  X  such as delay and loss as discussed below. Delay is a fact of life in real-world distributed applications because information must be transmitted across a network and time that elapses between an event and its display at another motion) looks halting and jerky [11]. Delays can have severe effects on collaboration  X  on coordination, communication, and understanding of the shared situation. Delay can make turn-taking difficult to negotiate, can hinder social about the timing or simultaneit y of key events [4,11]. delay can negatively affects user s of real-time groupware  X  but the effects of delay depend a great deal on the type of application, the granularity of the interaction. Fo r example, a study of a Pong-style Studies of tightly-coupled coordina ted interaction (where people must act based on what another person is doing) have also shown negative effects of latencies at or above 100ms [28]. Jitter has also interaction, and other studies show that these delays do not always affect users X  perceptions in game environments [26]. Researchers have also considered numerous strategies for reducing or hiding network delay, such as dead-reckoning or local overall view of groupware QoS, but are not required for our work on reliability (although delay-comp ensation techniques can be integrated with the tec hniques proposed here). A second reality of distributed groupware is that not all messages can be successfully delivered to receivers. There are two main reasons for these delivery failures  X  packet loss and loss caused by out-of-order or late delivery. Packet loss occurs whenever network packets sent by a distributed system fail to reach their destination, and is caused by a variety of problems including signal degradation, interference, congestion at even be losses induced by comm unication protocols themselves (e.g., some versions of the 802.11 protocol [25]). Order-based loss occurs when a message is unusable at the example, telepointer messages that are delivered either late or out of order are no longer useful for showing a person X  X  current location (although they may still be used to show traces [12]). describes general behavior over time. Second, and more distribution of loss at the local level. Burst loss means losing more burst length (the number of consecutive packets lost), and the burst frequency (the rate at which bursts occur) [23]. Although many networks have near-zero loss on average, there are still many settings and situations where loss can be a problem. North American Internet providers, showed hourly average loss rates above 2% 104 times, and above 5% 45 times (rolling hourly averages, sampled every ten minutes). Even low loss rates can be problematic if losses occur in bursts, a phenomenon that is common when traffic levels are high [1]. Losses on wireless networks (cel lular networks and wireless LANs) can be much higher, up to and even higher than 20% on average for long-distance WiFi networks [20]. Overall, these reliability of messages in distributed systems. There are two main approaches: protocol-based reliability, and application-level techniques. Some communications protocols (e .g., TCP/IP) build reliability general tools that cannot be adequately tuned to the needs of real-time groupware. the infrastructural approach to reliability. TCP is simple to use for programmers, and guarantees delivery (and in-order sequencing) of messages. However, guaranteed in-order delivery does not match the QoS requirements of many types of groupware messages, and the considerable resources used for acknowledging and retransmitting lost information leads to severe performance problems when TCP is used on real-world networks [5,7]. The other network protocol used for real-time groupware is guarantees, custom protocols are often built on top of UDP to deliver various QoS levels [7]. Application-level protocols are voice and video information. Some researchers have used RTP for real-time groupware applications (e.g. [8]), and there are RTP payload formats for common groupw are message types including text messages and te lepointers. The performance of RTP for groupware has not been tested, however, and some analyses indicate that RTP is not well suited to delivering the wide range of QoS requirements exhibited by real-time groupware [24]. There is an overall trend (e.g., as seen in networked game libraries are many advantages to working at the level of messages instead. For example, if two message types have differing QoS likely to be met by a message-level approach. in an application-level protocol based on UDP/IP: retransmission, path diversity, and fo rward error correction. There are two main ways to do this  X  by acknowledging all information when it arrives (ACK-based) or by requesting information when loss is detected (NACK-based) [25]. ACK-acknowledged; NACK-based techniques do not have this overhead, but require message se quence numbers in order to subsequent packets have arrived (it is also possible to send termination packets to indicate the end of a transmission). Path diversity schemes sends informa tion redundantly over two separate network routes, which can improve reliability because different network routes have uncorrelated loss patterns [16]. This networks do not support the ability to define a network route, and so this technique is not yet feasib le in most real-world situations. Forward error correction (FEC) improves reliability by repeating information in subsequent network packets [2,19]. In the event that a packet is lost, the information can be recovered when subsequent packets arrive (see Figure 1). No retransmission is total amount of information. In addition, this method is only partially reliable, since burst losse s that are larger than the amount FEC-3 duplicates the previous three messages in each new packet. There are several variants of FEC that have been investigated, and situations [19]; as described belo w, FEC is also well suited to the needs of real-time groupware. repeated in subsequent packets, allowing lost information (e.g., message 26) to be re covered without retransmission. Adaptive FEC (AFEC) dynamically adjusts the amount of redundancy in order to meet Qo S requirements while attempting to minimize the network cost of sending repeated information [2]. Adaptive FEC requires that the network conditions and the current reliability levels be monitored, and that an adaptation service conditions or changing requirements. Interleaved FEC is another variant of the basic FEC technique that disperses contiguous information among several packets by p s a l e s c b i n I n n t i c t e A s m G d t e s c t o w d d r T c c a t h s b a A g a a a a d A s t h p er second (4 m s ending messag e a nd 14 in packet e ss contiguous i s moother recon s c omes at the co s b e reordered an d n formation is re n developing a n n eed to conside r i me groupware, c ould affect the e chnique itself.
 A FEC techniqu e s ubstantial diff e m edia applicatio n G roupware app l d epending on th e e lepointer upda t s mall number o f c ause shared da t o a diagram m u w ould make m o d ifferentiate be t d elivery, and a w equirements, b u T ransactions o c c ompared with c an be far less s e ar e sent to indic h e requiremen t s ensitivity, as w b ased protocol a lthough alterna t A wareness mes s g uaranteed deliv a re not efficient a pproach either b a cceptable for a wareness mess a d elay while guar Table 1. Mess a A s an example, s ystem, and id e h ose types (se e consid e applic a user a n our o w assigni n values In add i descri b that af f Small a aware n networ k b ytes w messa g implie s p otenti a additio n event o compl e multi m resolut i time g r should due to t M ultip l of gro u with d i latenc y means t manag e and lo s the re decisio inform a B ursty messa g examp l system editing Figure The cl u way t h often a consist e aware n when s cluster i (e.g. j u recove r must d contai n requirements are met. A similar re quirement is mentioned in IETF RFC 2793 when using redundancy in text messaging applications. different tasks can produce very di fferent message patterns within the same groupware system. Differe nt people take on different that they work. For example, Figure 3 shows a summary of message types generated by four users carrying out a single shared task in a shared workspace [5]: two users show relatively balanced totals for four different messa ge types, and two users differ dramatically. These dynamic diff erences mean that a groupware FEC technique must be able to respond to application-level and preferences or application monito ring might determine that a user who gestures frequently to co mmunicate should have different QoS requirements for te lepointer messages. 
Figure 3: Message types generated by four users during a We designed an AFEC technique that is tailored to meet the selection algorithm (which dete rmines the number of redundant messages to be included in an ou tgoing packet). Our technique is minimum and maximum reliability requirements for each message from the packet error rate (PER), which is the percentage of packets lost. Note that with reliable protocols, MER is always zero and for unreliable protocols, MER is equal to PER. When using error correction, PER is greater than or equal to MER because messages contained in lost packets can be recovered. One might ask why we would ever set a non-zero minimum for sending accompanying video at higher resolution). The encoding scheme that we used is simple: redundant messages are included in their entirety and in their original form, rather than being distributed over several packet s or sent at lower resolution. This approach works because of the small size of awareness messages. Several redundant messages can be added to each burst losses. The total number of redundant messages still varies, however, depending on the network bandwidth, the actual message size, and the message frequency. packet. For example, adding just one redundant message allows full recovery from any single lost packet. If two packets are never lost in a row, this scheme would provide full reliability. In scheme must include as many re dundant messages in each packet as the maximum burst length, in order to prevent any message loss. In cases where this cannot be achieved, the number of the burst minus the number of redundant messages in a packet. Since it is difficult to predict loss occurrence and burst length [1], required to meet MER requireme nts in advance. Although MER can be reduced significantly using a fixed amount of redundancy, non-adaptive schemes cannot guarantee reliability. An adaptive approach is required to meet MER requirements while keeping the amount of redundancy to a minimum. The need to accommodate MER requirements for a variety of message types also makes the adaptive logic more complex. In our technique, the receiver monitors each message type separately to ensure that MER requirement s are being met, and tells the sender when to add or remove redundancy. The sender uses a be many participants in a groupware system, MER is monitored separately for each user by the receiver, and the redundancy requirements are tracked separately for each user by the sender. In the next two sections we prov ide more details on the elements of groupware AFEC that are required in the receiver and the sender of a message (see Figure 4). they stay between the minimum and maximum values set out for each message type from each user. Incoming packets consist of one current message and some number of redundant messages, all reverse order from oldest to ne west (thus, redundant messages are because the messages they contain will have been recovered already. The receiver checks for message loss using message indexes (described below); if loss has occurred, the receiver that has not been seen before (including recovered and new messages) is then processed as required. Message loss detection is perform ed using message indexes. The highest received index is stored for each message type, and if the index of a message exceeds this value by more than one, the number of lost messages is re ported and the MER for that message type is updated. To be ab le to record MER correctly for each message type, we need to know what type of message was lost. Therefore, we specify type within the index using a numeric message type code that pr ecedes the index number. Current MER is calculated using the previous 1000 messages only, rather than all of the messa ges during the life of the session. This is necessary to allow the system to react to changes in in different behavior. Otherwise, average rates would be spread increases. The rolling average coul d also be accomplished using a time-based window; however, since the message frequency is number of redundant messages in a packet). The receiver is responsible for deciding when to increase or MER exceeds the maximum MER, the code set size must be increased so that more messages can be recovered. When the MER is below the minimum, the code set size must be decreased to avoid unnecessary redundancy (sin ce it increases traffic without MERs are above the maximum, a negative acknowledgement increase the amount of redundancy for the specified message type. If a MER is below its minimum value, the receiver sends a decrease acknowledgement (D EC) message, which tells the sender to reduce the redundancy fo r the specified message type. Since groupware awareness messages are often clustered, code set size is only be updated when there is significant activity. With low activity, there is a risk of overcompensation because the code selector runs in a timed thread and could update the system several times without re ceiving new information. requirements as requested by th e receiver. The code selection algorithm works to ensure that the correct number of redundant messages is included in each packet as requested by the receiver. The sender keeps a history buffer of each message type and knows how many times each message has been sent. When recent message and moves back through the history list. Only messages whose requireme nts have not yet been met are included. amount of redundancy added does not exceed the path maximum transfer unit (path MTU) for the network route. The path MTU is path MTU is exceeded, the packet will be divided into smaller packets, which adds delay. Ther efore, the path MTU must be discovered by the system and shoul d not be exceeded. In the case that adding redundancy will exceed the path MTU, the sender sends as many messages as it can without exceeding the path MTU and sends a notification to the receiver that the QoS requirements cannot be met and should be lowe red. Adjustment of requirements can be handled automatically by the application or by the user through a dialog. Finally, since groupwar e messages are often strongly clustered, times in which there are no messages to be sent are detected and a meet redundancy requirements for the last few messages of the cluster. Without adding message s after a cluster, MER would appear to be higher for the last few messages in each burst. It is important to note that messages recovered using FEC or AFEC arrive at the same time as the newest message, which information. One method is to use client-side buffering, which movement, improving accuracy without adding latency [12]. Figure 4: AFEC operation: incoming and redundant messages are combined based on the Code Selector X  X  decisions; encoded messages are sent via UDP and decoded at the Receiver, which The GW-AFEC technique has been implemented both in Java and in C# using the Lidgren UDP libra ry [15]. The system includes all work with many groupware architectures and event schemes. Our implementation is available at http://hci.usask.ca/gw-afec/. We ran a set of experiments to see how the GW-AFEC technique would compare with TCP, plain UDP, and non-adaptive fixed-length FEC schemes under a variety of network conditions. Network conditions were simulated on a LAN using a software-based network-disabling emulator [21]. For each experiment, we measured MER and latency for each message. Our goals were to determine the following:  X  How a guaranteed protocol like TCP compares with UDP- X  How FEC performance compares to plain UDP for a variety  X  If and when non-adaptive FEC performs poorly;  X  How AFEC compares with non-adaptive FEC;  X  If and when AFEC performs poorly. movement trail. We used this common awareness technique to real world groupware applicatio ns. An input message trace was recorded by moving a mouse manually in a manner that simulated messages that happen in a gro upware applicati on. The update updates/second for all tests. on the same machine, but with messages sent through a server on a different machine on the LAN. Th e network emulator ran on the between the two clients. This setup enabled accurate latency measurements using the system clock on the client machine. Loss rates, loss patterns, and amount of bandwidth were specified using the emulator to simulate different network conditions:  X  Loss rates . We used three loss rates: 0%, 10%, and 20%.  X  Loss patterns . Two different loss patterns were used: random  X  Bandwidth . Each experiment was run using two levels of sizes (i.e., number of redundant messages) between 2 and 7. Since characteristics, we consider each as an independent technique, and that in Figures 5 and 7, we show FEC-3, which was the best-performing of the non-adaptive techniques). The experiments with AFEC were run with a target MER range of 5% minimum and 6% maximum. In a telepointer example, this means that we want to ensure that at least 94% of position interaction being supported. For each experiment, we measured message latency and MER. The results from our experiments are organized by the goals stated the advantages and disadvantages of the basic FEC approach, and the behavior and performance of groupware AFEC. Our first investigation compares a ll protocols in terms of message latency and message e rror rate. Figure 5 shows average latency in a 56Kbps channel with 10% random loss for TCP, UDP, FEC-3 (i.e. FEC with code set size of 3), and groupware AFEC. Figure 7 shows MER for the same set of conditions. The most obvious TCP X  X  acknowledgment and retransm ission policy lead to large as loss increases, TCP quickly becomes unusable. In addition, the high variance in latency with TCP (Figure 6) makes it difficult for users to adapt to the delay. In contrast, all of the schemes based on UDP maintain a low average latency. Differences am ong these three schemes can be higher traffic in a limited channe l generally corresponds to higher packet in this scenario, and so has slightly higher latency. differences between the protocols. Since TCP is a guaranteed reliable protocol, MER is always 0%. Since UDP provides no reliability control, its MER will always be approximately equal to the packet loss rate (here 10%). Groupware AFEC has a MER of 5%, which is within the bounds of the target MER of 5-6%. FEC-used bandwidth that could have been better allocated to a different information channel (such as a video stream). 
Figure 5: Average latency, by protocol, 56Kbps available 
Figure 6: Typical variation in TCP and UDP latency, 56Kbps 
Figure 7: MER by protocol, 56Kbps available bandwidth, 10% random loss. The target bounds for MER (5%-6%) are We tested non-adaptive FEC with several different code set sizes. some experiments non-adapti ve FEC showed the best performance for both MER and latency. However, these cases appropriate choice for the network conditions. When the code set size was not appropriate for conditions, then non-adaptive FEC showed either higher latency or an MER that was below the target range, indicating excess bandwidth usage. One variable that greatly affected non-adaptive FEC was loss pattern. Random loss experiment s resulted in very low MERs. Tests with burst loss, however , resulted in much higher MER values. The poor performance occu rred because messages are lost whenever the size of the burst exceeds the code set size. In general, although non-adaptive FEC provides an enormous improvement over plain UDP, an ina ppropriate choice of code set size can lead to reduced performance. This can be seen in Figure 7, where, the latency and MER of FEC with various code set sizes different performance extremes, only a few values provide a balance between latency and error rate. The performance of AFEC was always equal to or better than that of non-adaptive FEC, as long as it was possible to meet the target MER range without exceeding th e available bandwidth. AFEC shows optimal performance over time because it always moves towards the minimum code set size needed to meet the target MER range. In cases where non-adaptive FEC exceeded the cases where FEC did not meet reliability requirements. The MER for AFEC varied between 4% and 7%, but was most often within AFEC was still able to meet the target MER range with low latency, as long as the available bandwidth was sufficient. 
Figure 8. Average latency and MER for non-adaptive FEC with various code set sizes, and AFEC (white circle), on a 56Kbps channel with burst loss (burst size of 1-10 and 2% Figures 9 and 10 illustrate these differences and show how AFEC works. Figure 9 shows latency of various techniques as loss increases from zero to 20%. Because AFEC varies its code set however, this is the minimum la tency possible when maintaining the QoS requirements for MER. 
Figure 9. Average latency of different protocols at three loss The behaviour of AFEC is illustra ted in the packet trace shown in Figure 10. At the start of the trace, AFEC has a code set size that is slightly too large, resulting in a gradual decline in MER past the specified minimum. Once below 5%, AFEC reduces code set size latency decreases. The reduction in code set size is not enough to prevent another decline past the minimum (line B), so AFEC rapidly. When the MER is observed outside the maximum, code does not reduce it below the maximum, so another code-set increase is made (line D), also increasing latency. 
Figure 10: MER (upper) and per-message latency (lower) for 1000 AFEC packets, on a 56Kbps channel with 20% random loss. Vertical lines indicate points at which AFEC changed its Note that the latency spikes in Figure 10 result from the latency of recovered messages, not from pack et latency. Whenever messages are recovered, additional latency results from the time between the information. Thus, message latency in AFEC is always slightly higher than packet latency. Finally, our experiments showed certain conditions where the low bandwidth resulted in high amounts of latency. This problem arose when AFEC attempted to increase its code set size past the bandwidth limits in order to m eet MER requirements. However, when used with rate control, this problem can be avoided. These experiments compared the effectiveness of TCP, UDP, FEC, and AFEC for sending real-time awareness data under a drawn from our results:  X  TCP is not suitable for sending real-time interactive  X  FEC produces substantial re liability increases over UDP  X  Optimal code set size is impo ssible to determine beforehand  X  AFEC can meet a predefined MER range while minimizing  X  When it is not possible to meet the level of reliability without Our experiments reinforce earlier indications that TCP is not suitable for sending real-time interactive messages where under lossy conditions. These results help to confirm that TCP should not be used for sending re al-time awareness information. Non-adaptive FEC is simple to implement and provides large without adding substantial latency. However, a small code set size Several factors affect the amount of latency that is added, and the level of reliability attainable using FEC. The amount of latency added by FEC depends on the available network bandwidth, message size, message frequency, number of However, low available-bandwidth conditions can cause the problem described above, where c ode set size can not be supported by the network. Therefore, when clients have large amounts of bandwidth is low, the code set size must be set at a level that does not exceed resources. The level of reliability provided by FEC depends on the loss type, sequence of lost messages to be recovered. Higher loss rates in a row are lost result in high reliability from FEC, while longer smaller code set size is sufficient. optimal choice depends on severa l unpredictable parameters: loss rate, loss pattern, and availa ble bandwidth. If the programmer knew the network conditions beforehand, an optimal code set size programmer is left with the problem of determining the optimal s ize. Therefore, the code set size must be selected conservatively reliability versus latency under unknown conditions. AFEC improves on non-adaptive FE C by dynamically adapting its size to the minimum that still maintains the desired MER range. In cases where non-adaptive FEC exceeds the required level of reliability, AFEC will always produce lower latency. When non-adaptive FEC does not meet the MER requirements, AFEC will requirements, as long as this do es not exceed the path MTU. The only remaining problem with AFEC is that it is sometimes message frequency. In these cases, either rate can be decreased or MER requirements can be lowe red. The GW-AFEC module presented here does not include adaptive rate control, although this can be added in future work. Overall, GW-AFEC is an effective technique for sending real-time interactive messages. AFEC should be considered as an under a wide range of conditions, and because its complexity would be best abstracted away from application programmers. GW-AFEC is one of several applic ation-level techniques that can help to improve groupware performance and usability on real-world networks. There are several future possibilities both for networking. To develop better techniques for supporting real-time characteristics. Howe ver, better knowledge of both network and techniques that can be applied to groupware. requirements, we can refine GW-AFEC and develop other opportunities of real-time groupware. Some techniques have been compensation [28,29]); we are also planning to explore techniques such as adaptive concurrency policies, distributed load balancing, collection of networking techniques can eventually be brought together in a new real-time groupware toolkit. Our experiments show that AFEC is an effective technique for reliability requirem ents while minimizing latency under lossy conditions. AFEC works by adap tively adjusting the amount of redundancy in packets so that lost messages can be recovered without requiring retransmi ssion. Groupware messages are generally small, which allows several redundant messages to be added to each packet. This allows AFEC to recover lost messages, even when burst losses occur. AFEC for groupware is different from AFEC for multimedia due to several key differences between the application types. Since groupware sends many different message types with different tracking support for multiple message type. Irregular bursts of messages that occur in groupware can be handled by detecting breaks between bursts and sending redundant information at the end of the bursts. Groupware X  X  sm all messages and payload types compressed portions of historic messages. An experiment comparing several protocols in realistic lossy network conditions shows that non-adaptive FEC improves on the dynamic network conditions, however, this choice is impossible to make correctly, whereas GW-AFEC is able to move towards the TCP is unsuitable for sending r eal-time interactive messages, especially under lossy conditions. Our results show that GW-groupware messages, and that re ducing delay while providing needed reliability can substantia lly improve groupware usability. 1. Bolot, J-C End-to-end packet delay and loss behavior in the 2. Bolot, J-C, Fosse-Parisis, S., Towsley, D. Adaptive FEC-3. Chebrolu, K., Raman, B., and Sen, S., Long-distance 802.11b 4. Claypool, M., and Claypool, K., La tency and player actions in 5. Dyck, J., and Gutwin, C., and Makaroff, D., Using Behaviour 6. Dyck, J., Gutwin, C., Subramanian, S., and Fedak, C. High-7. Dyck, J., Gutwin, C., Graham, N., and Pinelle, D., Beyond the 8. Fr X con, E., Greenhalgh, C., Sten ius, M., The DiveBone -an 9. Gracanin, D., Zhou, Y., and DaSilva, L. Quality of Service for 10. Greenhalgh, C., Benford, S., Craven, M. Patterns of network 11. Gutwin, C. Effects of Network Delay on Group Work in 12. Gutwin, C. Traces: Vi sualizing the Immediate Past to Support 13. IETF Network Working Group, RFC 1151, Version 2 of the 14. ISO/IEC. Quality of Service: Framework . ISO/IEC 13236, 15. Lidgren UDP Library. code.google.com/p/lidgren-network-16. Liang, Y., Steinbach, E., Girod, B. Real-time voice 17. Marsic, I. Real-Time Colla boration in Heterogeneous 18. Mathur, A., Prakash, A. A Protocol Composition-Based 19. Nafaa, A., Taleb, T., and Murphy, L., Forward Error 20. Sheth, A., Nedevschi, S., Patra, R., Surana, S., Subramanian, 21. Shunra Software Ltd. The Cloud WAN Emulator , 2000. 22. Smed, J., Kaukoranta, K., and Hakonen, H. A Review on 23. Peterson, L., and Davie, B., Computer Networks , 5 th 24. Perkins, C., Crowcroft, J., Notes on the use of RTP for shared 25. Perkins, C., Hodson, O., Hardman, V., A survey of packet loss 26. Quax, P., Monsieurs, P., Lamotte, W., De Vleeschauwer, D., 27. Salyers, D., Striegel, A., and Poellabauer, C., Wireless 28. Savery, C, Graham, N., and Gutwin, C., The human factors of 29. Stuckel, D., and Gutwin, C., The effects of local lag on 30. Vaghi, I., Greenhalgh, C., Benford, S. Coping with 
