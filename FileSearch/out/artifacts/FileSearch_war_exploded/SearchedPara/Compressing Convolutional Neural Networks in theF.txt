 Convolutional neural networks (CNN) are increasingly used in many areas of computer vision. They are particularly attractive because of their ability to  X  X bsorb X  great quantities of labeled data through millions of parameters. However, as model sizes increase, so do the storage and memory requirements of the classifiers, hindering many applications such as image and speech recognition on mobile phones and other devices. In this paper, we present a novel net-work architecture, Frequency-Sensitive Hashed Nets (FreshNets), which exploits inherent redundancy in both convolutional layers and fully-connected layers of a deep learning model, leading to dramatic savings in memory and storage consumption. Based on the key observation that the weights of learned convolutional fil-ters are typically smooth and low-frequency, we first convert filter weights to the frequency domain with a discrete cosine transform (DCT) and use a low-cost hash function to randomly group fre-quency parameters into hash buckets. All parameters assigned the same hash bucket share a single value learned with standard back-propagation. To further reduce model size, we allocate fewer hash buckets to high-frequency components, which are generally less important. We evaluate FreshNets on eight data sets, and show that it leads to better compressed performance than several relevant baselines.
  X  Information systems  X  Data mining;  X  Computing method-ologies  X  Supervised learning; Neural networks; Model compression; convolutional neural networks; hashing
In the recent years convolutional neural networks (CNN) have led to impressive results in image classification [15, 30, 48, 63], ob-ject detection [19, 58], image retrieval [43], image caption genera-tion [26, 37, 58], face verification [47, 55], video understanding [27] and audio classification [35]. Problems that seemed impossibly hard only five years ago can now be solved at better than human accuracy [24]. Although CNNs have been known for a quarter of a century [17], only recently have their superb generalization abil-ities been accepted widely across the machine learning and com-puter vision communities. This broad acceptance coincides with the release of very large collections of labeled data [12]. Deep net-works and CNNs are particularly well suited to learn from large quantities of data, in part because they can have arbitrarily many parameters. As data sets grow, so do model sizes. In 2012, the first winner of the ImageNet competition that used a CNN had already 240MB of parameters and the most recent winning model, in 2014, required 567MB [50].

Independently, there has been another parallel shift of computing from servers and workstations to mobile platforms. As of January 2014 there have already been more web searches through smart phones than computers 1 . Today speech recognition is primarily used on cell phones with intelligent assistants such as Apple X  X  Siri, Google Now or Microsoft X  X  Cortana. As this trend continues, we are expecting machine learning applications to also shift increas-ingly towards mobile devices. However, the disjunction of deep learning with ever increasing model sizes and mobile computing reveals an inherent dilemma. Mobile devices have tight memory and storage limitations. For example, even the most recent iPhone 6 only features 1GB of RAM, most of which must be used by the operating system or the application itself. In addition, develop-ers must make their apps compatible with the most limited phone still in circulation, often restricting models to just a few megabytes of parameters. In addition to memory limitations, there are also low-power restrictions. Loading 500MB of parameters for a deep network from SSD drive to memory, to maybe just classify a single image, requires a significant amount of energy.

In response, there has been a recent interest in reducing the model sizes of deep networks. Denil et al. [13] use low-rank decomposi-http://tinyurl.com/omd58sq tion of the weight matrices to reduce the effective number of pa-rameters in the network. Bucilua et al. [5] and Ba et al. [2] show that complex models can be compressed into 1-layer neural net-works. Independently, the model size of neural networks can be re-duced effectively through reduced bit precision [9]. Meanwhile, the conventional wisdom that fully connected layers contain more pa-rameters is no longer true. More and more parameters are shifting towards convolutional layers. For example, GoogleNet [54] con-tains 11 layers involving convolutions 2 with only one single fully connected layer on the top. As a result, 85% of the parameters lie in the convolutional layers. A recent work proposed by Long et al. [36] advocates fully convolutional training which replaces the fully connected layers with the convolutional layer. All of these make the compression of the convolutional layers a must.
In this paper we propose a novel approach for neural network compression targeted especially for CNNs. We build on recent work by Chen et al. [6], who show that weights of fully connected networks can be effectively compressed with the hashing trick [60]. Due to the nature of local pixel correlation in images ( i.e. spatial locality), filters in CNNs tend to be smooth. We transform these filters into frequency domain with the discrete cosine transform (DCT) [42]. In frequency space, the filters are naturally domi-nated by low frequency components. Our compression takes this smoothness property into account and randomly hashes the fre-quency components of all CNN filters at a given layer into one com-mon set of hash buckets. All components inside one hash bucket share the same value. As lower frequency components are more pronounced than higher frequencies, we allow collisions only be-tween similar frequencies and allocate fewer hash buckets for the high frequencies (which are less important).

Our approach has several compelling properties: 1. The number of parameters in the CNN is independent of the number of convo-lutional filters; 2. During testing we only need to add a low-cost hash function and the inverse DCT transformation to any existing CNN code for filter reconstruction; 3. During training, the hashed weights can be learned with simple back-propagation [3] X  X he gra-dient of a hash bucket value is the sum of gradients of all hashed frequency components in that bucket.

We evaluate our compression scheme on eight deep learning im-age benchmark data sets and compare against four competitive base-lines. Although all compression schemes lead to lower test accu-racy as the compression increases, our FreshNets method is by far the most effective compression method and yields the lowest gen-eralization error rates on almost all tested tasks.

The rest of the paper is organized as follows. Section 2 intro-duces background on feature hashing and discrete cosine transfor-mation. We describe FreshNets in Section 3 and review the litera-ture in Section 5. Experimental results are presented in Section 6. Section 7 draws the conclusion.
Feature Hashing ( a.k.a the hashing trick) [11, 49, 60] has been previously studied as a technique for reducing model storage size. In general, it can be regarded as a dimensionality reduction method that maps an input vector x  X  R d to a much smaller feature space via a mapping  X  : R d  X  R k where k d . The mapping  X  is a composite of two approximately uniform auxiliary hash functions h :
N  X  X  1 ,...,k } and  X  : N  X  X  X  1 , +1 } . The j th element of the
We count the inception layers as convolutional layers as they con-sist of multi-scale convolutional filters. k -dimensional hashed input is defined as As shown in [60], a key property of feature hashing is its preserva-tion of inner product operations, where inner products after hashing produce the correct pre-hash inner product in expectation: This property holds because of the bias correcting sign factor  X  ( i ) . With feature hashing, models are directly learned in the much smaller space R k , which not only speeds up training and evaluation but also significantly conserves memory. For example, a linear classi-fier in the original space could occupy O ( d ) memory for model parameters, but when learned in the hashed space only requires O ( k ) parameters. The information loss induced by hash collision is much less severe for sparse feature vectors and can be counteracted through multiple hashing [49] or larger hash tables [60].
Methods built on the DCT [1, 42] are widely used for compress-ing images and movies, including forming the standard technique for JPEG [41, 59]. DCT expresses a function as a weighted com-bination of sinusoids of different phases/ frequencies where the weight of each sinusoid reflects the magnitude of the correspond-ing frequency in the input. When employed with sufficient numeri-cal precision and without quantization or other compression opera-tions, the DCT and inverse DCT (projecting frequency inputs back to the spatial domain) are lossless. Compression is made possible in images by local smoothness of pixels ( e.g. a blue sky) which can be well represented regionally by fewer non-zero frequency com-ponents. Though highly related to the discrete Fourier transforma-tion (DFT), DCT is often preferable for compression tasks because of its spectral compaction property where weights for most images tend to be concentrated in a few low-frequency components of the DCT [42]. Further, the DCT transformation yields a real-valued representation, unlike the DFT whose representation has imaginary components. Given an input matrix V  X  R d  X  d , the corresponding matrix V  X  R d  X  d in frequency domain after DCT is defined as: where c ( i 1 ,i 2 ,j 1 ,j 2 ) = cos  X  is the cosine basis function, and s j = q 1 d when j =0 and s otherwise. We use the shorthand f dct to denote the DCT operation in Eq. (1), i.e. V = f dct ( V ) . The inverse DCT converts V from the frequency domain back to the spatial domain, reconstructing V without loss: We denote the inverse DCT function in Eq. (2) as f  X  1 dct f dct ( V ) .
Here we present FreshNets, a method for using weight sharing to reduce the model size (and memory demands) of convolutional Figure 1: A schematic illustration of FreshNets. Two spatial filters are re-constructed from the frequency weights in vector w . The frequency weights are accessed with two hash func-tions and then transformed to the spatial domain. The vector w is partitioned into sub-vectors w j shared by all entries with similar frequency (corresponding to index sum j = j 1 + j Colors indicate which hash bucket was accessed. neural networks. Similar to the work of Chen et al. [6], we achieve smaller models by randomly forcing weights throughout the net-work to share identical values. Unlike previous work, we imple-ment the weight sharing and gradient updates of convolutional fil-ters in the frequency domain . These sharing constraints are made prior to training, and we learn frequency weights under the sharing assignments. Since the assignments are made with a hash function, they incur no additional storage.

We begin by deriving the equivalent filter representation after the DCT, and describe an efficient random weight-sharing scheme in the frequency space implemented using the hashing trick. Next we show how to learn the parameters in the frequency domain with standard back-propagation. At last, we describe a scheme to take advantage of filter smoothness by allocating more shared weights to low frequency components.
Let the matrix V k`  X  R d  X  d denote the weight matrix of the d  X  d convolutional filter that connects the k th input plane to the ` output plane. (For notational convenience we assume square filters and only consider the filters in a single layer of the network.) The weights of all filters in a convolutional layer can be denoted by a 4 -dimensional tensor V  X  R m  X  n  X  d  X  d where m and n are the number of input planes and output planes, respectively, resulting in a total of m  X  n  X  d 2 parameters. Convolutional filters can be represented equivalently in either the spatial or frequency domain, mapping between the two via the DCT and its inverse. We denote the filter in frequency domain as and recover the original spatial representation through as defined in Eq. (1) and (2), respectively. The tensor of all filters
After the lossless conversion via DCT, filters in frequency do-main V k` remain the same size as equivalent filters in the spatial domain V k` . We propose to use weight sharing to reduce the num-ber of parameters in the frequency domain. With filters in a fre-quency representation, V k` , we would like to reduce the number of model parameters to exactly K values stored in a weight vector w  X  R K , where K m  X  n  X  d 2 . To achieve this, we randomly assign a value from w to each filter frequency weight in V . A na X ve implementation of this random weight sharing would introduce an auxiliary matrix for V to track the weight assignments, using to significant additional memory. To address this problem, Chen et al. [6] advocate use of the hashing trick to (pseudo-)randomly as-sign shared parameters. Using the hashing trick, we tie each filter weight V k` j 1 j 2 to an element of w indexed by the output of a hash function h (  X  ) : where h ( k,`,j 1 ,j 2 )  X  X  1 ,  X  X  X  ,K } , and  X  ( k,`,j 1 a sign factor computed by a second hash function  X  (  X  ) to preserve inner-products in expectation as described in Section 2. With the mapping in Eq. (5), we can implement shared parameter assign-ments with no additional storage cost. For a schematic illustration, see Figure 1. The figure also incorporates a frequency sensitive hashing scheme discussed later in this section. Note that the same K weights in w are shared across all filters in the convolutional layer. This way, we compress the whole V k` which contains mnd parameters into a K -dimensional weight vector w . In other words, adding more convolutional filters does not change the model size, as all filter values are  X  X ecycled X  from already existing filters. We can arbitrarily control the number of effective parameters in each layer simply by adjusting K .
Typical convolutional neural networks learn filters in the spatial domain. As our shared weights are stored in the frequency domain, we derive the gradient with respect to the filter parameters in the frequency space. Following Eq. (2), we express the gradient of parameters in the spatial domain with respect to their counterparts in the frequency domain:
Let L be the loss function adopted for training. Using standard back-propagation, we can derive the gradient with respect to the filter parameters in the spatial domain,  X  L  X  X  k` with Eq. (6), we express the gradient of L in the frequency domain: Comparing with Eq. (1), we see that the gradient in the frequency Figure 2: An example of a filter in spatial (left) and frequency domain (right). domain is merely the DCT of the gradient in the spatial domain:
In a nutshell, there is a straightforward procedure for learning filter parameters V k` in the frequency domain. In the feedforward phase, we reconstruct spatial domain weights V k` with the inverse DCT transformation f  X  1 dct ( V k` ) . During back-propagation, after computing the traditional gradient  X  L  X  V k` in the spatial domain, we use the inverse DCT to compute the gradient  X  L  X  V k` in the frequency domain (8). These steps can be efficiently implemented using off-the-shelf DCT software.

Note that V k` are virtual parameters and we still need to com-pute the gradient over the real weight vector w  X  R K . We compute gradient for each shared weight w i by simply summing over the gradient at each filter parameter where the weight is assigned, i.e. where [ A ] j 1 j 2 denotes the ( j 1 ,j 2 ) entry in matrix A .
Figure 2 shows a filter in spatial (left) and frequency (right) do-mains. In the spatial domain CNN filters are smooth [30] due to the local pixel smoothness in natural images. In the frequency do-main this corresponds to components with large magnitudes in the low frequencies, depicted in the upper left half of V k` in Figure 2, with small indices ( j 1 ,j 2 ) . Correspondingly, the high frequencies, in the bottom right half of V k` , with large indices ( j magnitudes near zero.

As stated earlier, the filters in the spatial domain V k` cally  X  X mooth X  and in the frequency domain most weight intensities are in the low-frequency regions. The low frequency regions corre-spond to entries with small indices ( j 1 ,j 2 ) and the low frequency entries typically have much larger norms than higher frequency val-ues (entries with larger indices ( j 1 ,j 2 ) .

As components of different frequency regions tend to be of dif-ferent magnitudes (and thereby varying importance to the spatial structure of the filter), we want to avoid collisions between high and low frequency components. Therefore, we assign separate hash spaces to different frequency regions. As shown in Figure 3, each frequency region owns a separate hash space. In particular, we par-tition the K values of w into sub-vectors w 0 ,..., w 2 d  X  2 Figure 3: This figure illustrates the frequency domain of all filters. Cells in the same frequency region share the same color. Each frequency region is an antidiagonal stripe across all m  X  n filters.
 K ,...,K 2 d  X  2 , where P j K j = K . This partitioning allows parameters with the same frequency, corresponding to their index sum j = j 1 + j 2 , to be hashed into a corresponding dedicated hash space w j , as shown in Figure 4. We rewrite Eq. (5) with the new frequency sensitive shared weight assignments: where h j (  X  ) maps an input key to a natural number in { 1 ,  X  X  X  ,K and j = j 1 + j 2 . With frequency-sensitive hashing, the gradient with respect to the real weight is the same as the one in Eq (10) except the hash function h is replaced with a new hash function g as follows: Here, the hash function g is defined as where j = j 1 + j 2 is the index of a frequency region, and A P p =0 K p is a cumulative sum of the size of the first j hash spaces. The new hash function allows each hash space to be independent from each other. Though there seem to be 2 d  X  1 number of hash functions, all h j s can be implemented by a single hash function  X  h that takes 5 input arguments with the last argument being j , as follows: .

We define a compression rate r j  X  (0 , 1] for each frequency region j and assign K j = r j N j where N j is the number of vir-tual parameters in the j th frequency regions. A smaller r more collisions during hashing, leading to increased weight shar-ing. Since lower frequency components tend to be of higher impor-tance, making collisions more hurtful, we commonly assign larger r (fewer collisions) to low-frequency regions. Intuitively, given a size budget for the whole convolutional layer, we want to squeeze the hash space of high frequency region to save space for low fre-quency regions. These compression rates can either be assigned by hand or determined programmatically by cross-validation, as demonstrated in Section 6.
In a nutshell, we summarize the training procedure of FreshNets as follows.

Initialization phase: Figure 4: This figure illustrates the frequency domain of a filter. The redder a cell is, the higher frequency. Based on the index sum j = j 1 + j 2 , the real weight vector w is divided into 2 d  X  1 subvectors w j , each of which takes charge of a frequency region.
Feedforward phase:
Backpropagation phase: All the above training operations can be implemented in existing CNN packages by modifying the computational procedure for back propagation.
Several recent studies have confirmed that there is significant re-dundancy in the parameters learned in deep neural networks. Re-cent work by Denil et al. [13] learns parameters in fully-connected layers after decomposition into two low-rank matrices, i.e. W = AB where W  X  R m  X  n , A  X  R m  X  k and B  X  R k  X  n . In this way, the original O ( mn ) parameters could be stored with O ( k ( m + n )) storage, where k min( m,n ) .

Several works apply related approaches to speed up the evalua-tion time with convolutional neural networks. Two works propose to approximate convolutional filters by a weighted linear combina-tion of basis filters [25, 45]. In this setting, the convolution opera-tion only needs to be performed with the small set of basis filters instead of all the filters. The desired output feature maps are com-puted by matrix multiplication as the weighted sum of these basis convolutions.

Further speedup can be achieved by learning rank-one basis fil-ters so that the convolution operations are very cheap to compute [14, 33]. Based on this idea, Denton et al. [14] advocate decomposing the four-dimensional tensor of the filter weights into a sum of dif-ferent rank-one, four-dimensional tensors and show some encour-aging results. In addition, they adopt bi-clustering to group filters such that each subgroup can be better approximated by rank-one tensors. Courbariaux et al. [10] introduce BinaryConnect that en-forces weights in neural networks to take on binary values. This replaces many multiply-accumulate operations by simple accumu-lations, leading to less power-hungry and fast computation.
There is a distinctive difference between FreshNets and the above works. In each of the above works, evaluation time is the main fo-cus, with any resulting storage reduction achieved merely as a side effect. However, with the trend toward architectures with fewer fully connected layers and additional convolutional layers [54], com-pression of filters is of increasing importance.

Another technique for speeding up convolutional neural network evaluation is computing convolutions in the Fourier frequency do-main, as convolution in the spatial domain is equivalent to (com-paratively lower-cost) element-wise multiplication in the frequency domain [38, 57]. Unlike FreshNets, for a filter of size d  X  d and an image of size n  X  n where n &gt; d , Mathieu et al. [38] convert the filter to its frequency domain of size n  X  n by oversampling the frequencies, which is necessary for doing element-wise multiplica-tion with a larger image but also increases the memory overhead at test time. Training in the Fourier frequency domain may be ad-vantageous for similar reasons, particularly when convolutions are being performed over large 3-D volumes [4].

Other works focus entirely on compressing the fully-connected layers of CNNs. A branch of these works propose to post-process a trained convolutional net. Leveraging the similarity between con-nections, Gong et al. [20] learns a convolutional net in advance, and then applies kmeans clustering on the weight values for quan-tization. These clusters form a smaller-size codebook for all the weights. With similar spirit, another work by Han et al. [23] recur-sively train a neural network and prune unimportant connections based on their weight magnitude. Han et al. [22] further combine the techniques of pruning and quantization to achieve more com-pression.

A few recent works [52, 61] also adopt the quantization tech-niques. However, with quantization, each connection still needs to store the index to the cluster it belongs to, which limits its potential for compression. Other works focus on matrix or tensor decom-position for compression. For example, Yang et al. [62] adopt the fastfood transformation [32] for compressing the fully connected layers, and Kim et al. [28] investigate general tensor decomposi-tion with rank selection for compressing the entire network.
Most relevant to this work is HashedNets [6] which compresses the fully connected layers of deep neural networks. This method uses the hashing trick to efficiently implement parameter sharing prior to learning, achieving notable compression with less loss of accuracy than the competing baselines which relied on low-rank decomposition or learning in randomly sparse architectures.
Another recent work by Rippel et al. [46] proposes to learn weight parameters in the frequency domain for faster convergence of learn-ing, which is a fundamentally different goal compared with Fresh-Nets. In addition, they adopts discrete Fourier transformation (DFT) [8] while FreshNets uses DCT.
In this section, we conduct several comprehensive experiments on several benchmark datasets to evaluate the compression perfor-mance of FreshNets. We experiment with eight benchmark datasets: CIFAR 10 [29], CIFAR 100 [29], SVHN [39] and five challenging variants of 34, 44]. The CIFAR 10 dataset contains 60000 images of 32  X  32 pixels with three color channels. Images are selected from ten classes with each class consisting of 6000 unique instances.
The CIFAR 100 dataset also contains 60000 32  X  32 images, but is more challenging since the images are selected from 100 classes (each class has 600 images). For both CIFAR datasets, 50000 im-ages are designated for training and the remaining 10000 images for testing. To improve accuracy on CIFAR 100, we augment by horizontal reflection and cropping [30], resulting in 0 . 8 M training images.

The SVHN dataset is a large collection of digits ( 10 classes) cropped from real-world scenes, consisting of 73257 training images, 26032 testing images and 531131 less difficult images for additional train-ing.

In our experiments, we use all available training images, for a to-tal of 604388 training samples. For the MNIST variants [31], each variation either reduces the training size ( MNIST -07) or amends the original digits by rotation ( ROT ), background superimposition ( RAND and BG -IMG ), or a combination thereof ( BG -ROT ). We pre-process all datasets with whitening (except CIFAR 100 and which were prohibitively large). We compare the proposed FreshNets with four baseline methods: HashedNets [6], low-rank decomposition (LRD) [13], filter drop-ping (DropFilt) and frequency dropping (DropFreq). HashedNets was first proposed to compress fully-connected layers in deep neu-ral networks via the hashing trick. In this baseline, we apply the hashing trick directly to the convolutional layer by hashing filter weights in the spatial domain. This induces random weight sharing across all filters in a single convolutional layer.

Additionally, we compare against low-rank decomposition of the convolutional filters [13]. Following the method in [14], we un-fold the four-dimensional filter tensor to form a two dimensional matrix on which we apply the low-rank decomposition. The pa-rameters of the decomposition are fine-tuned via back-propagation. DropFreq learns parameters in the DCT frequency domain but sets high frequency components to 0 to meet the compression require-ment. DropFilt compresses simply by reducing the number of fil-ters in each convolutional layer.

The experimental environment is an off-the-shelve desktop with two 8-core Intel(R) Xeon(R) processors of 2.67 GHz and 128 GB RAM. All methods were implemented using Torch7 [7] and run on NVIDIA GTX TITAN graphics cards with 2688 cores and 6 GB of global memory. Model parameters are stored and updated as 32 bit floating-point values. 3 We further hold out 20% data from the train-ing set as the validation set for early stopping. In particular, if the
The compression rates of all methods could be further improved by learning and storing parameters in lower precision [9, 21]. validation error does not decrease for a number of epochs, the train-ing would stop and output the model with the lowest validation er-ror. Hyperparameters are selected for all algorithms with Bayesian optimization [40, 51] and hand tuning on the validation set. We use the open source Bayesian Optimization MATLAB implementation  X  X ayesopt.m X  from Gardner et al. [18]. 4 All our reported results are based on the test error performance.
We adopt the neural network architecture shown in Table 1 for all datasets. The architecture is a deep convolutional neural network consisting of five convolutional layers (with 5  X  5 filters) and one fully-connected layer. Before convolution, input feature maps are zero-padded such that output maps remain the same size as the (un-padded) input maps after convolution. Max-pooling is performed after convolutions in layers 2 , 4 and 5 with filter size 2  X  2 and stride 2 , reducing both input map dimensions by half. Rectified linear units are adopted as the activation function throughout. The output of the network is a softmax function over labels.
In this architecture, the convolutional layers hold the majority of parameters ( 1 . 2 million in convolutional layer v.s. 40 thou-sand in the fully connected layer with 10 output classes). During training, we optimize parameters using mini-batch gradient descent with batch size 64 and momentum 0 . 9 . We use 20 percent of the training set as a validation set for early stopping. For FreshNets, we use a frequency-sensitive compression scheme which increases weight sharing among higher frequency components. 5 For all base-lines, we apply HashedNets [6] to the fully connected layer at the corresponding level of compression. All error results are reported on the test set.

Table 2(a) and (b) show the comprehensive evaluation of all meth-ods under compression ratios 1 / 16 and 1 / 64 , respectively. We ex-clude DropFilt and DropFreq in Table 2(b) because neither sup-ports 1 / 64 compression in this architecture for all layers. For all methods, the fully connected layer (top layer) is compressed by HashedNets [6] at the corresponding compression rate. In this way, the final size of the entire network respects the specified compres-sion ratio. For reference, we also show the error rate of a stan-dard convolutional neural network (CNN, columns 2 and 8) with the fully-connected layer compressed by HashedNets and no com-pression in the convolutional layers. Excluding this reference, we highlight the method with best test error on each dataset in bold .
We discern several general trends. In Table 2(a), we observe the performance of the DropFilt and DropFreq at 1 / 16 compres-sion. At this compression rate, DropFilt corresponds to a network 1 / 16 filters at each layer: 2 , 4 , 4 , 8 , 16 at layers 1  X  5 respectively. This architecture yields particularly poor test accuracy, including essentially random predictions on three datasets. DropFreq, which at 1 / 16 compression parameterizes each filter in the original net-work by only 1 or 2 low-frequency values in the DCT frequency space, performs with similarly poor accuracy. Low rank decom-position (LRD) and HashedNets each yield similar performance at both 1 / 16 and 1 / 64 compression. Neither explicitly considers the smoothness inherent in learned convolutional filters, instead com-pressing the filters in the spatial domain. Our method, FreshNets, consistently outperforms all baselines, particularly at the higher compression rate as shown in Table 2(b).

Using the same model in Table 1, Figure 5 shows more com-http://tinyurl.com/bayesopt
We evaluate several frequency-sensitive schemes later in this sec-tion, but for this comprehensive evaluation we set frequency com-pression rates by a rescaled beta distribution with  X  = 0 . 25 and  X  = 2 . 5 for all layers. depending on the dataset. connected layer is compressed by HashNets for all methods , including CNN.
Compression Ratio Figure 6: Results with different frequency sensitive compres-sion schemes, each adopting a different beta distribution as the compression rate for each frequency. The inner figure shows normalized test error of each scheme on CIFAR 10 with the beta distribution hyper-parameters. The outer figure depicts the corresponding beta distributions. The setting  X  = 0 . 2 , X  = 2 . 5 (blue line), which compresses low frequencies the least and high frequencies the most, yields lowest error. plete curves of test errors with multiple compression factors on the CIFAR 10 and ROT datasets.
As mentioned in Section 3.4, we allow a higher collision rate in the high frequency components than in the low frequency compo-nents for each filter.

To demonstrate the utility of this scheme, we evaluate several hash compression schemes. Systematically, we set the compression rate of the j th frequency band r j with a parameterized function, i.e. r = f ( j ) . In this experiment, we use the beta distribution: where x = j +1 2 k  X  1 is a real number between 0 and 1, k is the filter size, and Z is a normalizing factor such that the resulting distribu-tion of parameters meets the target parameter budget K , i.e. when:
We adjust  X  and  X  to control the compression rate for each fre-quency region. As shown in Figure 6, we have multiple pairs of  X  and  X  , each of which results in a different compression scheme. For example, if  X  = 0 . 25 and  X  = 2 . 5 , the compression rate mono-tonically decreases as a function of component frequency, meaning more parameter sharing among high frequency components (blue curve in Figure 6).

To quickly evaluate the performance of each scheme, we use a simple four-layer FreshNets where the first two layers are DCT-hashed convolutional layers (with 5  X  5 filters) containing 32 and 64 feature maps respectively, and the last two layers are fully con-nected layers.

We test FreshNets on CIFAR 10 with each of the compression schemes shown in Figure 6. In each, weight sharing is limited to be within groups of similar frequencies, as described in Section 3.4, however number of unique weights shared within each group is whereas HashedNets does not. varied. We denote the compression scheme with  X , X  = 1 (red curve) as a frequency-oblivious scheme since it produces a uniform compression independent of frequency.

In the inset bar plot in Figure 6, we report test error normalized by the test error of the frequency-oblivious scheme and averaged over compression rates 1 , 1 / 2 , 1 / 4 , 1 / 16 , 1 / 64 , and 1 / 256 . We can see that the proposed scheme with fewer shared weights allo-cated to high frequency components (represented by the blue curve) outperforms all other compression schemes. An inverse scheme where the high frequency regions have the lowest collision rate (purple curve) performs the worst. These empirical results fit our assumption that the low frequency components of a filter are more important than the high frequency components.
We investigate the smoothness of the learned convolutional fil-ters in Figure 7 by visualizing the filter weights (first layer) of (a) a standard, uncompressed CNN, (b) FreshNets, and (c) HashedNets (with weight sharing in the spatial domain). For this experiment, we again apply a four layer network with two convolutional layers but adopt larger filters ( 11  X  11 ) for better visualization.
All three networks are trained on MNIST , and both FreshNets and HashedNets have 1 / 16 compression on the first convolutional layer. When plotting, we scale the values in each filter matrix to the range [0 , 255] . Therefore, white and black pixels stand for large positive and negative weights, respectively. We observe that, although they are more blurry due to the compression, the filter weights of FreshNets are still smooth while weights in HashedNets appear more chaotic.
In this paper we present FreshNets, a method for learning convo-lutional neural networks with dramatically compressed model stor-age. We introduce negligible efficiency overhead (since most run-ning time is still spent on convolutional operations) but obtain a dramatically smaller convolutional neural network. Harnessing the hashing trick for parameter-free random weight sharing and lever-aging the smoothness inherent in convolutional filters, FreshNets compresses parameters in a frequency-sensitive fashion such that significant model parameters ( e.g. low-frequency components) are better preserved. As such, FreshNets preserves prediction accuracy better than competing baselines at high compression rates.
We believe that the proposed compression techniques will have broad impacts on real-world applications, such as better image and speech recognition on mobile phones and other devices. In the fu-ture, we will investigate more on the frequency structure of Fresh-Nets and explore additional hashing schemes. Moreover, we will investigate its integration with other implementation schemes such as low precision representation of weights. The authors are supported in part by the IIS-1343896, DBI-1356669, III-1526012, IIA-1355406, IIS-1149882 and EFRI-1137211 grants from the National Science Foundation of the United States, a Mi-crosoft Research New Faculty Fellowship, a Washington Univer-sity URSA grant, and a Barnes-Jewish Hospital Foundation grant. [1] N. Ahmed, T. Natarajan, and K. R. Rao. Discrete cosine [2] J. Ba and R. Caruana. Do deep nets really need to be deep? [3] C. M. Bishop. Neural Networks for Pattern Recognition . [4] T. Brosch and R. Tam. Efficient training of convolutional [5] C. Bucilua, R. Caruana, and A. Niculescu-Mizil. Model [6] W. Chen, J. T. Wilson, S. Tyree, K. Q. Weinberger, and [7] R. Collobert, K. Kavukcuoglu, and C. Farabet. Torch7: A [8] T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein. [9] M. Courbariaux, Y. Bengio, and J.-P. David. Low precision [10] M. Courbariaux, Y. Bengio, and J.-P. David. Binaryconnect: [11] A. Dasgupta, R. Kumar, and T. Sarl X s. A sparse johnson: [12] J. Deng, W. Dong, R. Socher, L.-J. Li, K. Li, and L. Fei-Fei. [13] M. Denil, B. Shakibi, L. Dinh, N. de Freitas, et al. Predicting [14] E. L. Denton, W. Zaremba, J. Bruna, Y. LeCun, and [15] J. Donahue, Y. Jia, O. Vinyals, J. Hoffman, N. Zhang, [16] J. Duchi, E. Hazan, and Y. Singer. Adaptive subgradient [17] K. Fukushima. Neocognitron: A self-organizing neural [18] J. Gardner, M. Kusner, K. Weinberger, J. Cunningham, et al. [19] R. Girshick, J. Donahue, T. Darrell, and J. Malik. Rich [20] Y. Gong, L. Liu, M. Yang, and L. Bourdev. Compressing [21] S. Gupta, A. Agrawal, K. Gopalakrishnan, and P. Narayanan. [22] S. Han, H. Mao, and W. J. Dally. A deep neural network [23] S. Han, J. Pool, J. Tran, and W. Dally. Learning both weights [24] K. He, X. Zhang, S. Ren, and J. Sun. Delving deep into [25] M. Jaderberg, A. Vedaldi, and A. Zisserman. Speeding up [26] A. Karpathy and L. Fei-Fei. Deep visual-semantic [27] A. Karpathy, G. Toderici, S. Shetty, T. Leung, R. Sukthankar, [28] Y.-D. Kim, E. Park, S. Yoo, T. Choi, L. Yang, and D. Shin. [29] A. Krizhevsky and G. Hinton. Learning multiple layers of [30] A. Krizhevsky, I. Sutskever, and G. E. Hinton. Imagenet [31] H. Larochelle, D. Erhan, A. Courville, J. Bergstra, and [32] Q. Le, T. Sarl X s, and A. Smola. Fastfood-computing hilbert [33] V. Lebedev, Y. Ganin, M. Rakhuba, I. Oseledets, and [34] Y. LeCun, L. Bottou, Y. Bengio, and P. Haffner.
 [35] H. Lee, P. Pham, Y. Largman, and A. Y. Ng. Unsupervised [36] J. Long, E. Shelhamer, and T. Darrell. Fully convolutional [37] J. Mao, W. Xu, Y. Yang, J. Wang, Z. Huang, and A. Yuille. [38] M. Mathieu, M. Henaff, and Y. LeCun. Fast training of [39] Y. Netzer, T. Wang, A. Coates, A. Bissacco, B. Wu, and A. Y. [40] M. Pelikan. Bayesian optimization algorithm. In [41] M. Rabbani and R. Joshi. An overview of the jpeg 2000 still [42] K. R. Rao and P. Yip. Discrete cosine transform: algorithms, [43] A. Razavian, H. Azizpour, J. Sullivan, and S. Carlsson. Cnn [44] S. Rifai, P. Vincent, X. Muller, X. Glorot, and Y. Bengio. [45] R. Rigamonti, A. Sironi, V. Lepetit, and P. Fua. Learning [46] O. Rippel, J. Snoek, and R. P. Adams. Spectral [47] F. Schroff, D. Kalenichenko, and J. Philbin. Facenet: A [48] P. Sermanet, D. Eigen, X. Zhang, M. Mathieu, R. Fergus, and [49] Q. Shi, J. Petterson, G. Dror, J. Langford, A. Smola, and [50] K. Simonyan and A. Zisserman. Very deep convolutional [51] J. Snoek, H. Larochelle, and R. P. Adams. Practical bayesian [52] G. Souli X , V. Gripon, and M. Robert. Compression of deep [53] I. Sutskever, J. Martens, G. Dahl, and G. Hinton. On the [54] C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed, [55] Y. Taigman, M. Yang, M. Ranzato, and L. Wolf. Deepface: [56] T. Tieleman and G. Hinton. Lecture 6.5-rmsprop: Divide the [57] N. Vasilache, J. Johnson, M. Mathieu, S. Chintala, [58] O. Vinyals, A. Toshev, S. Bengio, and D. Erhan. Show and [59] G. K. Wallace. The jpeg still picture compression standard. [60] K. Q. Weinberger, A. Dasgupta, J. Langford, A. Smola, and [61] J. Wu, C. Leng, Y. Wang, Q. Hu, and J. Cheng. Quantized [62] Z. Yang, M. Moczulski, M. Denil, N. de Freitas, A. Smola, [63] M. D. Zeiler and R. Fergus. Visualizing and understanding
