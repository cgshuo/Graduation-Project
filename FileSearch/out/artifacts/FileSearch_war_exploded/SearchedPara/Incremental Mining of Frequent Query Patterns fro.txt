
Existing studies for mining frequent XML query patterns mainly introduce a straightforward candidate generate-and-test strategy and compute frequencies of candidate query patterns from scratch periodically by checking the entire transaction database, which consists of XML query patterns transformed from user queries. However, it is nontrivial to maintain such discovered frequent patterns in real XML databases because there may incur frequent updates that may not only invalidate some existing frequent query patterns but also generate some new frequent ones. Accordingly, existing proposals are inefficient for the evolution of the transaction database. 
To address these problems, this paper presents an efficient algorithm IPS-FXQPMiner for mining frequent XML query patterns without candidate maintenance and costly tree-containment checking. We transform XML queries into sequences through a one-to-one mapping and then mine the frequent sequences to generate frequent XML query patterns. More importantly, based on IPS-FXQPMiner, an efficient incremental algorithm, Incre-FXQPMiner is proposed to incrementally mine frequent XML query patterns, which can minimize the I/O and computation requirements for handling incremental updates. Our experimental study on various real-life datasets demonstrates the efficiency and scalability of our algorithms over previous known alternatives. 
XML has become a standard for information representation and exchange over the Internet. As many researches have been undertaken on XML indexing [MS99, KSB + 02, CLO03], caching [YLH03] and answering [BOB + 04, MS05], discovering frequent XML query patterns turns out to be a significant and effective premise of query optimization for its capability of  X  X ocus X  capturing. The rapid growth of XML repositories has provided the impetus to design and develop systems that can store and query XML data efficiently, and discovering frequent XML query patterns (FXQPs) has recently attracted large amount of attention because the answers of these queries can be stored and cached to improve query performance. 
There have been many studies on efficient discovery of frequent patterns for XML queries. Traditional frequent pattern mining approaches typically follow a straightforward candidate generate-and-test strategy, which includes two phases of frequent pattern generation and containment testing. The recent tree-structured data mining research mainly moves towards efficient frequent pattern enumeration and fast containment testing algorithms. 
FastMiner proposed in [YLH03] is the current state-of-the-art algorithm about this problem. Given the user log database composed of a set of XML queries, it models them as unordered trees with special XML query constructs like descendant edges or wildcards, and extends frequent structure mining techniques to extract frequent subtrees based on the semantics of the queries. However, a drawback of existing studies is that they can X  X  handle the evolution of the log database, because they have to compute the frequencies of candidate query patterns from scratch in order to get the most up-to-date frequent query patterns. Therefore, as the user queries dynamically join the original database, existing methods are not suitable for the condition that the log database is updated at a relatively high rate since it is very expensive to rerun the discovering program on the set of all transactions by unnecessary I/O cost and computation. From this point, it is important to study efficient algorithms for incremental update of FXQPs as the query collection changes. Chen et al. [CYW04] propose an algorithm about incremental mining of frequent XML queries based on FastMiner [YLH03]. However, it is also based on the straightforward candidate generate-and-test strategy and will induce inefficiency. 
Motivated by the need of this observation, this paper proposes, IPS-FXQPMiner , an efficient algorithm to mine frequent XML query patterns with neither candidate maintaining nor costly tree-containment checking. We transform XML queries to sequences via a one-to-one mapping and mine the frequent sequences to generate frequent XML query patterns. Subsequently, an efficient incremental algorithm is proposed to incrementally mine frequent XML query patterns. Our contributions: z We introduce the notion of Inverted Pr X fer z We present an efficient index for incrementally z We conducted an extensive performance study 
The paper is organized as follows. We formalize the frequent XML query pattern mining problem in section 2. Section 3 presents an effective sequencing algorithm for mining frequent XML query patterns on the static database. In section 4, we present an algorithm to incrementally mine frequent XML query patterns. A thorough experimental study is demonstrated in section 5. We review the related work in section 6 and make a conclusion in section 7. XML queries are mainly expressed with XPath or XQuery, which conform to the regular path expressions. An XML query can be modeled as a labeled tree, and each vertex denotes a node of the query and each edge denotes the relationship of two nodes. In addition to tag names, a query pattern tree may also contain wildcards * and //. The wildcard * indicates ANY label in DTD, while // indicates zero or more labels. Definition 1 XML Query Pattern (XQP). An XML Query Pattern can be defined as a tree XQP=&lt;V, E&gt;, where V is the vertex set, E is the edge set. Each edge e= (v 1 ,v 2 ) indicates node v 1 is the parent of node v Each vertex v X  X  label is one of the tag values in {  X  //  X ,  X * X  }  X  tagSet, where tagSet is the set of all element and attribute names in a schema. We define a partial order  X  X  , which is reflexive, and for any label t in tagSet, t  X  X  *  X  X  // , that is, t can match *, which in turn can match // . Definition 2 Rooted SubTree (RST). Given an XQP= follows: (1) Root(RST)=Root(XQP) and (2) V  X  X  X  V, E  X  X  X  E issue is how to count the occurrence of a tree pattern in the database. In this paper, we use the concept of extended subtree inclusion, a sound approach to testing containment of query pattern trees. Definition 3 Extended Subtree Inclusion [YLH03] . Let subtree(p) and subtree(q) be two subtrees with root nodes p and q respectively. Let children(v) denote the set composed of child nodes of v. We can recursively determine if subtree(p) is included/contained in sub-tree(q) (subtree(q) is also said to include/contain sub-tree(p)), denoted by subtree(p)  X  subtree(q), as follows: p  X  X  q and (1) both p and q are leaf nodes; or (2) p is a leaf node and q=//, then  X  q  X  X  X  children(q) (3) both p and q are non-leaf nodes, and one of the 
XML query pattern tree, the ancestor-descendant relationship in the XML query is denoted as a vertex  X // X  in this paper. For example, the two XQPs, in Fig. 1 (a) and (b), are equivalent. All XQPs are represented as (b) in this paper. The patterns (e), (f) and (g) are rooted subtrees of (b), (d) and (c) respectively. RST c is included in XQP a and XQP b (also in XQP c ), and RST is included in XQP a but not in XQP c . Thus, 
ASupp (RST c )=3, and ASupp (RST b )=2. Fig. 1 shows the inclusion of XQPs. 
We in this section introduce some concepts and then formalize the frequent XQP mining problem and the incremental frequent XQP mining problem. Definition 4 Transaction database. A transaction database D is a collection of XQPs, D= {XQP 1 ,...,XQP n }, which is transformed from a set of XML queries issued against a given XML data source. Definition 5 Absolute and Relative Support. Absolute support of a rooted subtree RST refers to the number of XQPs that contain it in D, denoted as ASupp D (RST). Relative support is the percentage of XQPs that contain RST in D, denoted as RSupp D (RST)=ASupp D (RST) / |D|, where |D| is the size of D. Definition 6 Incremental and Updated Database . Suppose a set of new XML query patterns, d, is to be added to the transaction database D. The database D is referred to as the original database, the database d as the incremental database, and the database D  X  =D+d as the updated database.
 Frequent XQP Mining Problem: Given a database D= { XQP 1 , XQP 2 , ... , XQP n } and a minimum relative support min_sup in the range of (0,1], find a set, denoted as  X  (D) , composed of all the frequent RSTs in D such that for each RST in  X  (D) , RSupp (RST)  X  min_sup holds. We use the relative support as our measure of frequency in this paper. Incremental Frequent XQP Mining Problem: Given an original database D with its frequent RSTs  X  minimum relative support min_sup in the range of (0,1], and the incremental database d , then the Incremental Frequent XQP mining is a process to find the set, denoted as  X  (D  X  ) , composed of all the frequent RSTs in D such that for each RST in  X  (D  X  ) , RSupp (RST)  X  min_sup holds. 
Existing mining algorithms always directly mine updated database D  X  from scratch, thus involve many unnecessary scans on D and d without help of  X  (D) . In next sections, by taking account of  X  (D) , we will present a novel algorithm that incrementally mine the frequent XML query patterns. In our approach, we use a sequence to represent an XQP and transform frequent XQP mining problem to frequent sequence mining problem, which leads to a dramatic improvement over existing mining approaches. Tree Sequencialization. Our approach starts with a valid and effective sequencing method for XQP. Ad hoc sequencing methods such as depth-first and Pr X fer have been used for XML indexing [KSB + 02, CLO03]. Pr X fer sequence [RM04, KRM + 05] and ViST [WPF + 03] are succinct tree encoding methods. Pr X fer (1918) proposed a method that constructed a one-to-one correspondence between a labeled tree and a sequence by removing nodes from the tree one at a time [P18]. The algorithm to construct a sequence from tree T with n nodes labeled from 1 to n works as follows. 
From T n , delete a leaf with the smallest label to form that is the parent of the deleted node. Repeat this node to be deleted), and continue until only two nodes joined by an edge are left. The sequence (a 1 , a 2 , ... ,a is called the Pr X fer sequence of tree T n . From the sequence (a 1 ,a 2 , ... , a n  X  2 ), the original tree T reconstructed. The length of the Pr X fer sequence of tree T is n  X  2. In fact, we can construct a Pr X fer sequence of length n  X  1 for T n by continuing the deletion of nodes till only one node is left. Any numbering scheme can be used in above process to label an XML document tree as long as it associates each node in the tree with a unique number between one and the total number of nodes. This guarantees a one-to-one mapping between the tree and the sequence. Without loss of generality, post-order is used to uniquely number tree nodes. It helps a Pr X fer sequence be constructed for an XQP by using the node removal method. 
This sequence consists entirely of post-order numbers and is called NPS (Numbered Pr X fer Sequence) [RM04]. If each number in a NPS is replaced by its corresponding tag, a new sequence that consists of XML tags can be constructed, which is called LPS (Labeled Pr X fer Sequence). On the basis of LPS, ELPS (Extended Labeled Pr X fer Sequence) and ENPS (Extended Numbered Pr X fer Sequence) [KRM + 05] can be constructed by extending leaf nodes of the document tree with dummy child nodes [RM04]. Clearly the leaf node labels of the original tree are kept in ELPS. However, NPS, LPS, ELPS and ENPS are not suitable to Frequent XQP Mining Problem. Therefore, IPS (Inverted labeled Pr X fer Sequence) and INPS (Inverted Numbered Pr X fer Sequence) are introduced, which invert ELPS and ENPS respectively. Observe that, IPS preserves the parent-child, ancestor-descendant and sibling order relationships as shown in Property 1. Property 1. Suppose IPS=(e 1 ,e 2 ,...,e m ), INPS=(n n ,...,n m ) are sequences of an XQP.  X  i,j, 1  X  i&lt;j  X  m. If n &gt;n i+1 , then e i is the parent of e i+1 ; if n ancestor of e i ; if n i &gt;n j and  X  X  X  t, i&lt;t&lt;j, n is the parent of e j . Example: In Fig. 2 , ELPS is constructed by inserting leaf nodes e,c,c,e into corresponding position of LPS, and the leaf node must be preceding and neighboring its parent. We can get IPS of the XQP in Fig. 2(a), adedcacabe, by inverting its ELPS, ebacacdeda. IPS of the RST in 2(b) is adcabe, and its INPS is 764721; As n (6)&gt;n 3 (4), e 2 =d is a parent of e 3 =c; as n e =c is a descendent of e 4 =a. 
However, IPSs of some equivalent queries may be different. For example, the four XML queries in Fig. 3 are equivalent, but their IPSs are not the same. Since these four queries are equivalent, the absolute support of them should be four. However, the IPSs of these queries are different, and the absolute support of them is one for the four queries respectively. To address this issue, the query is normalized into a unique form in a following way: for any node that has more than one child, its children are sorted by their labels in lexicographical order. Accordingly, we can transform the queries to their unique forms, and all the equivalent queries are normalized to a same unique form. Hence, there is a one-to-one mapping between equivalent queries and a certain IPS. For example, the queries in Fig. 3 can be normalized to their unique form, XQP i . 
Consider S a and S b are two sequences, S a 1  X  i 1 &lt;i 2 &lt; ... &lt;i n  X  m, such that a 1 =b called a super-sequence of S a , and S a is a sub-sequence of S b . However, not all of the sub-sequences of IPS are valid and some subsequences do not represent a RST of an XQP and even can not represent a tree structure. For example, in Fig. 2, RST IPS = adcabe (RST IPS denotes the IPS of RST in this paper) is a subsequence of XQP IPS = adedcacabe , which can represent a valid RST of this XQP, but some sequences e.g. aeace cannot represent a valid RST. Hence, we introduce the notion of valid subsequence and Lemma 1 is proposed to distinguish which subsequences are valid ones. Definition 7 Valid subsequence . Given an XQP and its sequence S, S a is a valid subsequence of S iff S subsequence of S and the subtree that S a represents is a RST of XQP. Lemma 1. Consider S is a sequence of an XQP, S INPS = ( S S ( s 1 = s =max ( S 1 ,...,S n ) and  X  s k &gt;s k+ 1 (1  X  k&lt;m ) ,  X  X  X  t, i Example: In Fig. 2, adcabe(764721) is a valid sub-sequence of adedcacabe since it satisfies Lemma 1 . aeace(75731) is not a valid subsequence of adedcacabe, because there is an item d(6) between a(7) and e(5), which violates the constraint of Lemma 1 . 
As tree inclusion in Definition 3, we need to introduce subsequence inclusion, and accordingly present how to count the occurrence of a valid sequence in databases. Definition 8 Subsequence inclusion . Given two sequences s and S of two different XQPs, s IPS = ( s ... , s p ), s INPS =( n 1 , n 2 , ... , n p ) and S ( N exists 1  X  i 1  X  ...  X  i p  X  m , such that s 1  X  X   X  k , j , 1  X  k &lt; j  X  p , satisfy:  X  i = v (1  X  k  X  p ). s k  X  X  to the partial order. i) means that // can be matched by more than one labels. ii) and iv) ensure that s and S have the same tree structure, and // can match zero label in ii). iii) means that // can X  X  be matched by any leaf label, such as, a*dc can not be included in a //, but included in a // c . 
A sequence database SDB contains a set of tuples in The absolute support of a valid subsequence Vs is the number of tuples that contain Vs in SDB, denoted by ASupp ( Vs ). The relative support is the percentage of tuples that contain Vs in SDB, denoted by RSupp ( Vs ), where RSupp ( Vs )= ASupp ( Vs )/|SDB|. Example: In Fig. 1, XQP a IPS =a//cab//ebd, RST c IPS =abe, XQP b IPS =a*dca*e. RST c IPS is included in XQP a tively, and b matches * in XQP b IPS . abe is not properly included in XQP a IPS , because there is no item in abe to match d in XQP a IPS , however, abe is properly included in RST a IPS (ab//e). RST b IPS =a*dc, is included in XQP where (i 1 , i 2 , i 3 , i 4 ) is (1,2,2,3)(* and d both match //). 
Consider the test whether a path a/b/f is included in a/b//e. If it is not known that there exists a path a/b/f//e, then it cannot be concluded that the first path is included in the second path. This is because it is possible for a DTD declaration to include a/b/d/e but not a/b/f//e. In order to handle these situations, it needs to take into account the DTD and perform some expansions of the XQPs. Interested readers are referred to [YLH03] for the details. Frequent Valid Sequence Mining Problem: Given a sequence database D ={S 1 ,S 2 , ... ,S n } and a minimum relative support min_sup in the range of (0, 1], find a set, denoted as  X  (D) , composed of all the frequent valid subsequences Vseqs in D such that for each Vseq , RSupp D ( Vseq )  X  min_sup holds. Incremental Frequent Valid Sequence Mining Prob-lem: Given an original sequence database D with its frequent valid subsequence set  X  (D) , a minimum relative support min_sup in the range of (0, 1], and an incremental database d for D , then Incremental Frequent Valid Sequence Mining is a process to find the set, denoted as  X  (D  X  ) , composed of all the frequent valid subsequences, Vseqs in D  X  such that for each Vseq in  X  (D  X  ) , RSupp D  X  ( Vseq )  X  min_sup holds. From the earlier observations, we can transform Frequent XQP Mining Problem to Frequent Valid Sequence Mining Problem, and transform Incremental Frequent XQP Mining Problem to Incremental Frequent Valid Sequence Mining Problem. According-ly, we devise two efficient mining algorithms for the two sequence-based problems in next sections. q }, in the preprocessing phase, the first step in a sequence based XML query pattern mining algorithm is to normalize the input queries into their unique forms, and then transform each query into a sequence. The complexity of normalization and building IPSs are O(|XQP| 2 ) and O(|XQP|) respectively, where |XQP| is the number of nodes in XQP. In this way, we get the the original database D and incremental database d in our running example of this paper, while Table 1 shows the corresponding sequence database. 
Traditional frequent subtree mining approaches, such as FastXMiner, typically follow the straightforward candidate generate-and-test strategy. The algorithms with this strategy usually generate a large number of candidate subtrees and need to perform a lot of costly subtree containment testing. To avoid the generate-and-test paradigm and reduce the costly subtree contain-ment testing, we exploit the BI-Directional parent-child checking scheme to find the frequent sequences based on the property of IPS. Obviously parent-child checking is much cheaper than containment testing of tree structure data. That X  X  the key why we exploit frequent sequence mining to resolve frequent XQP mining problem. Assisted with the parent-child information embedded in IPS, it will be proved in following that the parent-child relationship checking is efficient and linear with the size of query patterns. among the set of items (labels in tagSet and *, //), I, in conceptually the complete search space of sequence mining forms a sequence tree. The process of constructing the sequence tree is as follows. The root node of the tree is the root of the XQPs, recursively a node N at level L in the tree is extended by adding one item to get a child node at the next level L+1 and the children of a node N are generated and arranged according to the chosen lexicographical ordering. In Fig. 5, each node contains a frequent sequence and its corresponding absolute support. As an assumption, min_sup is 1/2 in all the examples of this paper. Apparently, not all the frequent sequences in Fig. 5 correspond to valid tree structures. For example,  X  ad  X  is not a valid sequence though with support of 2, since  X  ad  X  is not a valid subsequence according to Lemma 1. frequent pattern mining algorithms have elaborated that depth-first searching is more efficient in mining long patterns than breadth-first searching. Thus, in our approach we traverse XQPs in depth-first order. Pei et al [PHM + 01] introduce an efficient pseudo-projection method for enumerating frequent sequences. In this paper, a similar pseudo-projection method is adopted in order to reduce space complexity. A certain node in the sequence tree is always treated as a prefix sequence. By adding one item in I, a prefix sequence can grow to be a longer sequence as its child node. According to downward closure property [AS94], it only needs to extend a prefix sequence using the set of its locally frequent items. To our best knowledge, to establish the frequent items w.r.t a prefix, a well-known method is used that builds the projected database for the prefix and scans it to count the items. Definition 9 Projected sequence of a prefix sequence. Given an input sequence S=e 1 e 2 ...e n which after we remove the first instance of the prefix S i in S is called the projected sequence w.r.t. prefix e 1 e 2 ...e i Definition 10 Projected database of a prefix sequence. Given an input sequence database SDB, the complete set of projected sequences in SDB w.r.t. a prefix sequence e 1 e 2 ...e i is called the projected database w.r.t. prefix e 1 e 2 ...e i in SDB.

For example, the projected sequence of prefix sequence ac in sequence acabd is abd . The projected database of prefix sequence ab in D is ( d ,  X  , ab ). 
There are many subsequences of a certain sequence, but not all of them are meaningful from the application point of view, that is, some of them can represent a subtree of XQP, but some others may not. We can check whether a subsequence is a valid subsequence via Lemma 1. However, to mine the frequent valid sequences, we need to address the issue that how to add a valid local item to extend a prefix sequence. Definition 11 Valid local item. Given a prefix sequence S and its projected sequence PS, where S IPS = e (ne 1 ,ne 2 ,...,ne j ), then a local item e w.r.t. S is called a valid local item of S, if e satisfies: i)  X  m, 1  X  m  X  j, e  X  X  pe m ,ne m-1 =n i and ne m &lt;n ii)  X  m, 2  X  m  X  j, e  X  X  pe m , pe m-1 = //, ne m-2 =n iii)  X  m, 1  X  m  X  j, e  X  X  pe m , ne m &gt;n i . and // will be matched by zero label in ii); while the local items that satisfy iii) are ancestors of e i . item. We first initialize the root node as the first frequent sequence s 1 , and then enumerate the valid local item e of the given prefix sequence s 1 the number of the sequences that contain the valid local item e , i.e., ASupp (&lt; s 1 , e&gt; ). If RSupp (&lt; s &lt; s 1 ,e&gt; is a frequent sequence. We iteratively enumerate the valid local items until there is no valid local item. Especially, when enumerating a valid local item, // in projected sequence can be matched by any zero or more labels or *, while * can be matched by any label. Example: In Fig. 1 , XQP a IPS =a//cab//ebd, RST b IPS a*dc. Suppose the current sequence is a, as * can match // , so * is a valid item w.r.t. a for XQP can be matched by zero or more labels, its projected sequence can be cab//edb, and also can be //cab//ebd. In this way, a is extended to a*, then the next item d is checked, but it is not a valid item w.r.t. cab//edb, because the item d in this projected sequence does not satisfy Definition 11. However, it is a valid item w.r.t. //cab//ebd since d can match // . In the same way, a*dc is included in a//cab//ebd. Lemma 2. Given a valid local item e w.r.t. a prefix node corresponding to e m must be on the left most path of the subtree corresponding to prefix e 1 e 2 ...e i . 
The sequence extension framework in our approach is left most extension, which complies with the right most extension strategy adopted in [Z02,YLH03], and it removes redundancy in frequent sequence mining. valid sequence extension and frequent sequence enu-meration, we derive our algorithm, IPS-FXQPMiner as illustrated in Fig. 6, which avoids costly tree contain-ment testing and prunes the unrelated search space efficiently under the local item X  X  validity checking. IPS-FXQPMiner enumerates the complete set of frequent sequences, which is similar to the pseudo-projection-based PrefixSpan algorithm. It normalizes XML query patterns into their unique forms (line 2), and converts the input XML query patterns into a set of sequences through the sequencing method described in section 2.2(line 3). To mine the frequent valid sequence, it recursively calls its subroutine Freq_Valid_Seq (line 4): for a certain prefix PS, if it is non-empty, output it (line 6), scan projected database PS_SDB once to find the locally valid frequent items (line 7) via Definition 11, each frequent item e i can be chosen in lexicographi-cal order to grow PS to get a new prefix PS i (line 10), scan PS_SDB once again to build pseudo-projection database for each new prefix PS i (line 11). Furthermore, one can easily figure out that the order of the frequent sequence enumeration is consistent with the depth-first traversal of the frequent sequence tree. Example: Fig. 7 lists how to enumerate the valid local items. For the three sequences in D, suppose current frequent valid prefix sequence is a, and the projected sequences of them are caabd, // eab and cdcbab respectively. To reduce the storage space, only a pointer is recorded for each projected sequence instead of the whole sequence. In this paper, the starting position of the projected sequence in original sequence is recorded. It is obvious that c is a valid item for caabd(5(a)&gt;4(c)) and cdcbab(5(a)&gt;4(c)), but c is not a valid item for //eab (there is no ac//e in DTD). In this way, RSupp(ac)=2/3&gt;1/2, and it is a frequent valid sequence. Then, we want to check whether item a is a valid item for aabd, dcbab w.r.t. ac, and there are two a which are both valid items for aabd, thus there are two projected sequences abd and bd for aabd, however only one of them is frequent in this running example. Although we can mine the frequent query patterns on the updated database via IPS-FXQPMiner from scratch, it is not efficient for the evolving database. Therefore, we in this section present how to incrementally mine frequent XML query patterns. 
Suppose  X  (D) ,  X  (d) ,  X  (D u ) are the sets composed of frequent sequences of D , d , D u respectively, and original database D is already mined and  X  ( D ) has been gotten through IPS-FXQPMiner . We first mine the incremental database d using IPS-FXQPMiner and get  X  ( d ), and then generate the up-to-date frequent sequence set, i.e.,  X  (D u ) through  X  (D) and  X  (d) . 
Valid sequences ( Vseqs ) of D and d are classified into four categories: 1)  X  ( D )  X   X  ( d ), that is, all of the Vseqs that are frequent in both D and d . frequent in D but infrequent in d . 3)  X  ( d )- X  ( D ), that is, all of the Vseqs that are frequent in d but infrequent in D . 4) Other sequences, that is, all of the Vseqs that are infrequent in both D and d . Lemma 3. Vseqs in the first category must be frequent in the updated database D u . Vseqs in the fourth category can not be frequent in D u .

We can determine whether the sequences in the first category or fourth category are frequent or not in D according to Lemma 3. However, it is not easy to check whether the sequences in the second category or third category are frequent. Accordingly, we need to check whether each sequence in  X  ( D )- X  ( d ) is still frequent in D , and each sequence in  X  ( d )- X  ( D ) is a new frequent sequence of D u . 
For each sequence Vseq in  X  ( D )- X  ( d ), we scan d to count the number of sequences ( ASupp d ( Vseq )), which contain Vseq , and then check whether ( ASupp  X  (D) ( Vseq ) + ASupp d ( Vseq ))/| D u |  X  min_sup holds; In the same way, we can check whether each sequence in  X  ( d )- X  ( D ) is frequent. Although this approach is more efficient than mining the updated database from scratch, it may involve some unnecessary scans of D and d . For example, abd is frequent in d , but infrequent in D . Although only XQP 1 IPS ( acaabd ) contains it, it has to scan all the sequences in D . To scan D and d as few as possible, we introduce some concepts and accordingly present the novel index, which is constructed for the original and incremental database. Definition 12 Direct-Prefix Sequence. Given a sequence S=(e 1 e 2 ...e i ), S  X  = (e 1 e 2 ...e i-1 prefix sequence of S.
 Definition 13 Path-Prefix Sequence. Given a sequence S, S INPS = (e 1 ...e n ). S  X  I NPS =(e  X  1 e ) is path-prefix sequence of S (1  X  i 1 &lt;,...,&lt;i e  X  =max(e 1 ,...,e n ) and  X  k, 1  X  k &lt; j, e  X  k &gt;e  X  i prefix sequence of S. 
A path-prefix sequence e 1 ...e j represents the path from node e 1 to node e j w.r.t its corresponding XQP, the parent of e k+ 1 . Definition 14 Quasi-Frequent Sequence. Sequence S is a frequent sequence if RSupp(S)  X  min_sup; Sequence S is a quasi-frequent sequence if its direct-prefix sequence and its proper path-prefix sequence(if any) are both frequent. The quasi-frequent sequence but not frequent is called a Q/F sequence.

According to the apriori property, if a sequence is not a quasi-frequent sequence, it can not be frequent. Accordingly, if a specified sequence is a quasi-frequent sequence, we need not scan the projected database to count its absolute support. 
In our approach, we construct the F&amp;Q/F-index for the transaction database. F-index preserves each frequent sequence, while Q/F-index preserves each Q/F sequence  X  . Sequences in F&amp;Q/F-index are sorted in lexicographical order and each sequence maintains its absolute support and IDList , where IDList records a set of tuples ( Sid , Pointer ), Sid is the identifier of its super-sequences and Pointer is used to record its corres-ponding projected sequence in D . Given a frequent or Q/F sequence, its super-sequences and projected sequences can be gotten easily through its IDList . 
The reason why F&amp;Q/F-index is constructed is that: for any sequence in F&amp;Q/F-index , the database has to be scanned to check whether it is frequent during mining frequent sequences, thus its absolute support and IDList are recorded by the way, which is similar to record a table in dynamic programming. F&amp;Q/F-index can be constructed during mining the frequent query patterns. Once IPS-FXQPMiner detects a valid sequence is frequent or quasi-frequent, we record the IDList and ASupp for this sequence and inserts it into F&amp;Q/F-index in lexicographical order .
 Example: Table 2 shows the F&amp;Q/F-index of D and d respectively. In database d, abd is a valid subsequence of Seq 4 (XQP 4 IPS ) and a*d is a valid subsequence of Seq 6 , since * can be matched by any label, ASupp(abd)=2 and abd is a frequent sequence in d. ASupp of a // e in F-index d is 2, and this means that there are two sequences which contain a // e in d. Its IDList is (5,4) and (6,4) means its super-sequences are Seq 5 and Seq 6 , and the two corresponding projected sequences are: the subsequence of Seq 5 obtained from the 4 th item to the last item and the subsequence of Seq obtained from the 4 th item to the last item. In this section, we present an algorithm, Incre-FXQPMiner , to incrementally mine frequent query patterns with the help of F&amp;Q/F-index . Without loss of generality, suppose the original database has been mined and F&amp;Q/F-index has been constructed. 
We first mine d through IPS-FXQPMiner , and then obtain the frequent Vseq s of the updated database D through merging original mining results of D , i.e.,  X  ( D ) and the new mining results of d , i.e.,  X  ( d ). In addition, to efficiently mine the frequent sequences, Vseq s in  X  (D) - X  (d) and  X  (d) - X  (D) are sorted by | Vseq | in ascending order, respectively. 
Since all the sequences in  X  ( D ) or  X  ( d ) are sorted in through the merge-join of  X  ( D ) and  X  ( d ), which only costs O(|  X  ( D )|+|  X  ( d )|). We need to check whether the Vseqs in  X  ( D )- X  ( d )=  X  ( D )- X  ( D )  X   X  ( d ) and  X  ( d )- X  ( D )  X   X  ( d ) are frequent or not in D u . Without loss of generality, we only introduce how to check the former.  X  Vseq  X   X  (D) - X  (d) , Vseq cannot be frequent in d . Let DVseq , PPVseq are direct-prefix and proper path-prefix sequences of Vseq respectively. As | DVseq |&lt;| Vseq |, | PPVseq |&lt;| Vseq |, so whether DVseq and PPVseq are frequent in D  X  has been processed. Therefore, if one of PPVseq (if any) and DVseq is infrequent, then it is obvious that Vseq is infrequent. Otherwise, it needs to scan Q/F-index of d or F-index of D  X  to check whether Vseq is frequent: 1) if Vseq is in Q/F-index of d , Asupp D+d ( Vseq ) and 
Vseq D+d . IDList can be gotten according to Q/F-index of d , and thus, 2) else, as DVseq is frequent, Vseq must be in F-index of D  X  , thus we scan each projected sequence, PS_DVseq of DVseq according to DVseq d . IDList in 
F-index of D  X  , then check whether item e is a valid item of PS_DVseq w.r.t. DVseq ( Vseq =&lt; DVseq , e &gt;) and count the number of PS_DVseqs in d , i.e., 
ASupp d ( Vseq ), where each PS_DVseq contains the valid item e , finally, record Vseq d .IDList , and thus, 
Incre-FXQPMiner (Fig. 8 ) first mines the frequent sequences of d (line 2), and then gets  X  ( D )  X   X  ( d ) (line 3). For each sequence Vseq in  X  ( D )- X  ( d ) or  X  ( d )-it checks whether Vseq is frequent in D  X  by calling its subroutine IncreMiner (lines 5, 6): if Vseq is in Q/F-index of db ( db=D or db=d ), it checks whether Vseq is frequent according to Q/F-index of db (lines 10, 11); otherwise, checks whether Vseq is frequent according to its direct-prefix sequence X  X  F-index in D  X  (lines 12-15), and lastly constructs F&amp;Q/F-index (lines 16-20). Example: F&amp;Q/F-index of D and d are constructed as shown in Table 2.  X  (D)= { ab;ac;aca;acab } ,  X  (d)= { ab; abd;ac;af;a//;a//e;a//ea;a//eaf } ,  X  (D)  X   X  (d)= { ab;ac } ,  X  (D)- X  (d)= { aca;acab } ,  X  (d)- X  (D)= { abd;af;a//;a//e; a//ea;a//eaf } . The F-index of D  X  is illustrated in Table3. All the sequences in  X  (D)  X   X  (d) must be frequent in D Suppose VSeq= abd in  X  (d)- X  (D) and DVSeq=ab is the direct-prefix sequence of VSeq. As DVSeq is frequent in D , so abd is quasi-frequent in D  X  . As abd is in Q/F-index of D, ASupp D+d ( VSeq ) =ASupp D.Q/F-index ( VSeq ) + ASupp  X  (d) (VSeq)=3; VSeq D+d .IDList=VSeq  X  (d) .IDList  X  VSeq D.Q/F-index .IDList= { (1,nil),(4,nil),(6,nil) } , thus abd is frequent in D  X  . In the same way, aca,acab,a//,a//e, a//ea are also frequent in D  X  .  X  (D  X  )=(  X  (D)  X  { aca;acab }  X  { abd;a//;a//e;a//ea } = { ab;abd;ac;aca; acab;a//;a//e; a//ea } . 
This section evaluates the performance of our algorithms and demonstrates the efficiency and scalability of our approach. FastXMiner is the most efficient algorithm for frequent XML query pattern discovery in candidate generate-and-test manner. increQPMiner [CYW04] is the best algorithm for incrementally mining frequent XML query patterns, which is evolved from FastXMiner. We compare IPS-FXQPMiner with FastXMiner on the static database, and compare our incremental algorithm with increQPMiner on the evolving database for different datasets varying min_sup values and the number of queries. The datasets we used are DBLP, XMark and SigmodRecord. According to the DTDs of these three datasets, some  X // X  and  X * X  nodes are added to construct the XQPs as the input of our experiments. Different characteristics of XQPs are shown in Table 4. In contrast, the average number of nodes, maximum depth and fan-out of XQPs reflect the complexity of the dataset. All the datasets follow the default Zipfian distribution. All the experiments are carried out on a computer with Pentium III 1.14 GHz and 1G RAM by implementing in C++. Firstly , we compare IPS-FXQPMiner with FastXMiner by varying min_sup . In this comparison, we chose 200,000 XQPs in each dataset as our experimental data. Fig. 9 shows the comparison results between the two algorithms on the static database. We can see IPS-FXQPMiner outperforms FastXMiner on each dataset. As well, the time needed for FastXMiner at support 0.2% is always a bit more than that at 2%. This is because with the decreasing of min_sup , the  X  X traightforward generate-and-test X  style mining algorithms need to match an increasing number of frequent candidates, while IPS-FXQPMiner avoids redundant sequences testing by dynamic enumeration and pruning after parent-child constraint is applied. algorithm by varying the number of XQPs on three datasets and fixing min_sup at 1%. Fig. 10 shows the performance results on XMark, DBLP and SigmodRecord respectively. We can observe that IPS-FXQPMiner has better scalability than FastXMiner. Especially, on SigmodRecord, when the number of XQPs is 200,000, IPS-FXQPMiner costs only 25s while FastXMiner costs 45s. This further demonstrates the effectiveness of our sequence enumeration method IPS-FXQPMiner and FastXMiner on the evolving transaction database in this section. algorithms by varying min_sup on SigmodRecord. The number of queries in the incremental database d is a quarter of that in the original database D . Two incremental algorithms incrementally mine the frequent XQPs, while the two incremental algorithms mine the frequent XQPs on D  X  directly. We can see our incremental algorithm outperforms the other ones. This demonstrates that incremental mining is more efficient than mining from scratch. When min_sup is 2%, Incre-FXQPMiner costs one seventh of FastXMiner, a quarter of IPS-FXQPMiner and half of increQPMiner. by varying the number of XQPs on SigmodRecord and fixing min_sup at 1%. In Fig. 12(a), the number of queries in d is a quarter of that in D , while in Fig.12 (b), the number of queries in d is twice of that in D . We can see Incre-FXQPMiner outperforms increQPMiner, IPS-FXQPMiner and FastXMiner. This is because our incremental algorithm takes full advantage of mining results of D , while increQPMiner only makes use of a part of the mining results. 
Mining frequent substructures of trees, graphs and sequences has drawn much attention as an essential data mining task, with various applications including market and customer analysis, web log analysis, pattern discovery in protein sequences and XML frequent patterns, and so on. 
For tree and graph mining, frequent pattern discovering was first addressed in biological science. Dehaspe et al [DTK98] proposed an efficient algorithm to mine frequent substructures in protein and chemical compounds. In graph database, algorithm FSG in [KK01] was considered as a fast miner for discovering connected sub-graphs by extending the notion of level-by-level expansion of [AS94]. Motivated by discovering user navigation patterns in web surfing, Zaki [Z02] proposed sub tree mining algorithm in forest, which faced more complex data situation. FREQT [AAK + 02], TreeFinder [TRS02] aimed at finding frequent subtrees in a collection of semi-structured documents, but still cannot solve the problem of XML query pattern mining due to the existence of  X * X  and  X // X . 
To our best knowledge, FastXMiner [YLH03] was the most efficient mining algorithm for XML frequent query pattern discovery, as only valid candidate XQPs are enumerated by FastRSTGen for costly containment testing. It still follows the traditional idea of generate-and-test paradigm for tree-structured data mining. Global query pattern tree needs to be generated for XQP enumeration, as well as expensive candidate generation and containment testing. Another closest related work is finding the frequent substructures from a collection of semi-structured Web documents [WL00]. On the other hand, for sequence mining, [SA96, MCP98, HPM + 00, AJY + 02] mainly focused on general and constraint-based sequence mining problems. Various researches have been done on frequent episode mining [YHA03], cyclic association rule mining [ORS98], temporal relation mining [BWJ98], partial periodic pattern mining [HDY99], and long sequential pattern mining in noisy environment [YYW + 02]. But the voice of a frequent pattern mining algorithm should not mine all frequent patterns but only the closed ones come out with convincing arguments for its better efficiency and more compact results without valuable information loss. CloSpan [YHA03] and BIDE [WH04] were two well-known closed sequence mining algorithms, where CloSpan still follows the candidate maintenance-and-test paradigm and BIDE adopts BI-Directional Extension to avoid candidate maintenance. This paper presents an efficient algorithm, IPS-FXQPMiner for mining frequent XML query patterns, which replaces expensive tree containment testing with cheap parent-child validity checking. The novel techniques proposed in IPS-FXQPMiner include a unique sequence representation and an efficient frequent sequence enumeration method. More importantly, the proposed sequence-based method can speed up mining frequent XML query patterns through checking the parent-child relationship. 
We introduce an effective index for incremental mining frequent query patterns, and accordingly, an efficient incremental mining algorithm is proposed, which can incrementally mine frequent patterns for the evolving transaction database effectively. 
The thorough experimental results give us rich confidence to believe that our algorithms outperform existing algorithms in terms of efficiency, scalability as well as answerability. This work is supported by the National Natural Science Foundation of China under Grant No. 60573094, Tsinghua Basic Research Foundation under Grant No. JCqn2005022, Basic Research Foundation of Tsinghua National Laboratory for Information Science and Technology (TNList), Zhejiang Natural Science Foun-dation under Grant No. Y105230, and 973 Program under Grant No.2006CB303103. 
