 1. Introduction
The advent of the service oriented architecture (SOA) [71], where services are the key entities populating future informa-tion processing architectures, has important implications that reach far beyond classical software engineering. The fact that services will be conceptualized, implemented, and integrated with different services in possibly multiple locations and should still be able to interact seamlessly, brings about important interoperability issues on both business and technical levels.

Developing automated verification procedures and appropriate analysis techniques will be a major driving force to a smooth(er) adoption of this new software paradigm [14,20,4,60] . Verification of collaborative business processes has some important economic impact as well, as services and more specifically their composition in collaborative business processes will be the foundation of future software products as well as Business-to-Business integration (B2Bi) scenarios. Interopera-bility at the data and process level becomes a critical issue in these integration scenarios.

In this paper, the focus is on the development of a collaborative business process verification technique which results in a detailed assessment report on the compatibility of the partner processes. For the moment the verification approach is limited to checking process level incompatibilities only, data aspects being subject of further research. The presented ver-ification technique is mainly motivated by the fact that many analysis techniques are mostly based on low-level process definitions and that they reduce the compatibility issue to a simple yes X  X o problem [55,28,53] . To reduce the complexity of the models to be verified, this paper first proposes an approach for modeling collaborative business processes that hides the micro-level coordination and allows focusing on high-level units of collaboration. Then the paper proposes a Petri Net based verification technique for these high-level process definitions and puts forward a strict formal compatibility crite-rion, which identifies four levels of semantic compatibility: complete, strong, one-way strong and weak. These (in)com-patibility types can be used to create detailed reports on the compatibility between the parties of a collaborative business process. Such an analysis report should not only answer the compatibility question (compatible or not), it should also give detailed information about the reasons of the incompatibility (why are they incompatible?), the degree of the compatibility (how bad is it?) and provide an overview of the differences between the processes (which scenarios are sup-ported and which are not?).

The remainder of this paper is structured as follows. First, in Section 2, the basics of collaborative business process mod-eling are briefly explained. Some problems concerning message-based business process modeling are also elaborated on in
Section 2. Section 3 discusses a new interaction paradigm for collaborative business processes based on atomic business activities. This approach is then used in Section 4 where we introduce an efficient and complete verification technique based voted to the discussion of related work both concerning the process modeling approach and verification techniques. In Sec-tion 7, the conclusions of the paper are discussed and some issues for further research are identified. 2. Message-based collaborative process modeling approaches
Many techniques, approaches and languages have been put forward to model collaborative business processes. Some of these techniques were particularly developed for the business processing modeling discipline, such as BPMN [76,78] , BPEL [1], EPC [44]. Some evolved or emerged from other conceptual modeling areas, such as finite state machines [36,16] , activity diagrams [58], P -calculus [56] and Petri Nets [62]. Very often there is an emphasis on implementation aspects, especially when business processes are modeled the way they are executed. Collaboration and interaction are not often addressed in business process models. In [72], the authors propose a case-based view on the processes which is a paradigm that focuss-es mainly on the case-data instead of the control flow aspects as in the traditional approaches. The control flow view of pro-cesses is also the one taken in this paper.

The emergence of Web Service Technologies has resulted in the development of several message-oriented modeling ap-proaches [76,1] : collaborative business processes are modeled by describing the consecutive sending and receiving of mes-sages between the partners. Although these approaches may be useful for the implementation and enactment of collaborative business processes, they also confront modelers with significant disadvantages. Indeed, these techniques are often platform dependent, essentially binary (peer-to-peer) in nature, and not capable of modeling complex variations in business processes.

An auction choreography, introduced in [12], will be used throughout this paper. This scenario involves three parties: a auction service is responsible for the coordination of the auction itself and receives bids from bidders that are interested in the product(s) sold. The highest bidder wins the auction. The auction finishes when the products are paid and delivered. The BPMN version [12] of this auction choreography is modeled in Fig. 1 .

As we can see from this example, the classical and message-based way of modeling collaborative processes is as follows: 1. One process is defined for each party in the collaboration. In BPMN these will typically be drawn in one pool per party but multiple pools may be used to model a partner X  X  process. 2. Parties collaborate with each other by sending and receiving messages (either synchronously or asynchronously). In
BPMN these will be drawn as message arrows connecting activities in different pools. In BPEL these give rise to the def-initions of send, receive and/or pick constructs.

The message-based approach allows detailing the interaction and communication direction between the partners of the process. However, this also has some substantial drawbacks. Firstly, these one-to-one message exchanges are at a too low abstraction level to aptly describe business processes and badly affect the comprehensibility of the process models [5,22,18,17,37] . Moreover, in a message-based business process model some messages have an important business meaning (bid), others are mainly modeled and introduced as receive control messages (acknowledge_bid) and do not have a business meaning on their own as they merely represent technical and/or coordination issues.

Moreover, modeling collaborative processes by interconnecting participants X  processes with (send and receive) mes-sages works fine for smaller processes and in the case when only two participants are involved in a collaboration. But when more than two parties are involved in a collaboration, an increasing amount of  X  X  X oordination overhead X  is intro-duced as the number of participants increases. As an example, consider a document that needs to be signed by three par-ties A, B and C. In a message-based approach the global activity  X  X  X ign X  is necessarily decomposed into three separate activities  X  X  X ign-by-A X ,  X  X  X ign-by-B X  and  X  X  X ign-by-C X . Subsequently a coordination pattern must be defined to send the doc-ument around in order to obtain the three signatures. This will result in the definition of additional activities such as  X  X  X end-signed-by-A/B/C X ,  X  X  X eceive-signed-by-A/B/C X  and the definition of the necessary correlation information. Obviously, many different patterns can be defined: signatures can be collected in different orders, one party or an additional party can be made responsible for collecting the signatures, responsibilities for monitoring the progress must be assigned, and so on. To make things worse, adding a participant to the signature activity requires the redefinition of the coordina-tion protocol.
 An additional consideration is that collaborations should be verified in the first place at the level of business semantics.
Potential errors and incompatibilities must be intercepted at that level. Verification at the implementation level is too late and may be misleading, as sometimes implementation workflows may be patches of fundamental errors in the business pro-cesses. By using a message-oriented modeling approach technical aspects, coordination aspects and business semantics are mixed. Verification becomes more tedious as it is unclear whether identified problems are technical issues, coordination is-sues or fundamental business collaboration problems. This stresses again the need for a high-level description of business processes, in a platform and implementation independent way.

This discussion leads to a final problem: the absence of formal semantics in many (popular) business process modeling standards. Having a metamodel for the modeling standard is not sufficient: verification and analysis of business processes at the conceptual level requires a sound mathematical base for the modeling techniques. The mix of constructs found in the languages makes it possible to obtain models with a range of semantic errors which are impossible to identify automatically. Many approaches have been introduced to analyse the BPMN and BPEL process models.

In practice, some of these approaches merely check the models at execution level. Sometimes, the combined message-based model of interconnected local business processes is transformed into techniques with a more formal semantical ba-sis, such as there are: finite state machines, Petri Net, P -calculus. The main drawbacks of these approaches are that they focus on low-level process descriptions and that the outcome of the verification process yields a yes/no at the level of the global model, whereas a more detailed analysis on which scenarios are supported or not by each local process would be useful. Furthermore, the computation of the global process yields the risk of scalability problems. Almost none of the re-search so far (except [73]) addresses the performance and scalability of the proposed verification techniques. In Section 6, the main research literature on this issue is reviewed and some shortcomings of these approaches are addressed in more detail.
 3. Introducing a better paradigm for business process interaction 3.1. Interaction through atomic business activities
The disadvantages of using message-based modeling techniques have been discussed in the previous section. In this sec-tion, we propose to alleviate the problems associated with the message-based interaction paradigm by using a gate-based multi-party interaction paradigm with conjunctive parallelism and a fixed set of participants [42]. 4 a solution for the verification problem is proposed.

Since at high-level of business modeling, the choice of the exact coordination pattern does not (yet) matter, we will model a business process as a sequence of  X  X  X tomic business activities X . These basic business activities typically require multi-party interaction. When the number of parties exceeds one, each of these basic activities requires further detailing of the coordi-nation protocol further on, but a compatibility check at the higher-level should be able to make abstraction of these details.
Such an approach is in line with the idea of microflows as structuring concept described by Zdun et al. [81] and the notion of  X  X  X usiness protocol X  proposed by Desai and Singh [17,18] as granules from which business processes can be composed.
In this paper, we will formulate a business process as a composition of such granules, which we will call  X  X  X tomic business activities X . These atomic business activities will be treated as black boxes. The identification of the relevant atomic business activities, the modeling of the participants and the elaboration of a microflow or coordination protocol to ensure the correct notification and handling of the activity by all participants is beyond the scope of this paper. concerned with the formal modeling of processes as traces of atomic business activities and their use for collaborative busi-ness processes. The main characteristics and underlying assumptions of atomic business activities, relevant for the verifica-tion of collaborative processes are as follows: 1. The term business refers to the fact that such a joint activity represents a real world phenomenon. Showing an error mes-sage on a screen is not a business activity. Neither is searching a particular item in a product database. Business activities happen in a business reality (with or without information systems). 2. The term atomic refers to the undecomposable, indivisible nature of an individual activity step. Although multiple parties, computer applications and software components may be involved in realizing and coordinating this activity, the business expresses the desire that the activity is either handled in its entirety or not at all. 4. The number of participants involved in an atomic business activity is one to many. 5. Each of the parties can impose business rules as preconditions to the atomic business activity. 6. Communication between the parties in a collaborative business process is achieved by specifying common business activ-ities, i.e. the business activity is added in the flow of each of the parties. 7. The definition of sequence constraints on the atomic business activities creates a temporal ordering on the activities which support the specification of the business process flow (e.g. sequence, iteration, selection).

Points 3 X 6 are the basic ingredients required to define the coordination protocol at the lower-level of detail. The micro-flow for handling an atomic business activity will consist of message exchanges for notification purposes ((4) X (6)), but also for validation purposes (5) (e.g. checking if there are unpaid orders). In particular, all parties involved in an atomic business activity may enforce business rules and constraints as preconditions on the activity (5). If one party finds one or more pre-conditions to be violated, the entire system rejects the request for executing the atomic business activity, and no processing (3) should take place by any of the participants (4). If processing has already occurred, it is rolled back or compensated, depending on the desired business coordination protocol. In this sense, atomic business activities incorporate a transactional aspect. In that way, from a top down perspective an atomic business activity requires a set of notification and coordination messages.

The elaboration of the coordination protocol is not the prime focus of this paper. For more information on modeling pro-cesses with atomic business activities and their use as coordination units in process and Web services composition, the read-er is referred to [50,48,49,68,69,57] . In Section 6, the approach is compared to similar approaches for simplifying process definition, and positioned to workflow and interaction patterns.

Fig. 2 gives an overview of the presented approach and shows the relationship between the higher-level representation of the business process using atomic business activities and the lower-level implementation details in for instance BPEL. 3.2. Running example To illustrate process modeling with the use of atomic business activities, we redefine the auction choreography in Fig. 3 .
The rationale behind the identified atomic business activities is as follows: the auction request -message and the creation confirm -message are two messages to indicate that the auction has been started or created. Therefore, these messages are log-ically grouped into the atomic business activity create auction , which indicates that both the seller and the auction service should participate and should be able to execute the atomic business activity in order to create the auction (see assumptions presented above). The biggest advantage of using the atomic business activity approach is demonstrated in multi-party inter-
Confirm -message to the seller, the End Confirm -message to all losing bidders and a End Confirm -message to the winner of the acting parties, i.e. it boils down to a single stop auction atomic business activity in which three types of parties participate. 3.3. Atomic business activities as multi-party interaction mechanism
From the business processes modeling and verification perspective, we are mainly interested in points 6 (communication) and 7 (sequence constraints) described above. To ease the formal modeling of the communication and sequencing aspect of business activities that require multi-party interaction, we can combine the formalism of multi-party interactions as defined in Hoare X  X   X  X  X ommunicating Sequential Processes X  [40] with Petri Nets. In CSP (and also in ACP), processes are defined as se-quences, choices and iterations of atomic actions but processes synchronize on common activities rather than by mapping send and receive messages as is done in e.g. CCS [56].

The message-based approach of communication as proposed by Milner [56] means that: with a being a send activity, a a receive activity and s refers to a successful communication.

The CSP counterpart, which uses synchronization on common activities results in
The real advantages of the CSP approach surface when multiple parties interact, i.e. synchronize on a common activity. For three parties this results in which is a straightforward extension of the binary case in (2). Expressing multi-party interaction in CCS cannot be defined as a straightforward extension of (1): it necessitates detailing the coordination of parties by means of send and receive mes-sages, resulting in a much more complex expression.

In the next section, we propose a technique for verifying the compatibility of collaborative processes using gate-based multi-party interaction as in CSP. As an example, suppose that we have two business processes P 1 and P 2, which collaborate combination of processes does not deadlock: P 1 k P 2  X  0. However, this notion of compatibility needs some refinement. First of all, even if the parallel composition does not deadlock, there still may be some compatibility problems, for example if activity c disappears from the global process P 1 k P 2. Therefore, Section 4 will identify several levels of compatibility.
Furthermore, the fact that an atomic business activity is about notifying a desire to execute an activity as response to a specific atomic business activity, induces a slightly different notion of deadlock. In the well-known example of the Dining
Philosophers [21], philosophers can pick-up a fork whenever they like to do so. In the proposed business process modeling approach, each activity is evaluated against preconditions before it is accepted. As such, the coordination protocol can pre-vent a philosopher to pick-up a fork if this would lead to a deadlock. Furthermore since we specify the processes at class level, this means the number of instances is not necessarily fixed. We hence need to check a system that can deal with an arbitrary number of instances, or even where instances can enter and leave the system. For the dining philosophers, this means that we do not know in advance how many forks and philosophers there are.

For the auction system, it means that at specification time the number of bidders is not fixed and that at run time bidders are allowed to enter and leave the system. At specification-level , a deadlock free system means that there is a scenario in which philosophers can eat (no deadlock), i.e. the set of traces for the combined system is not empty. At design and imple-mentation time , the coordination protocol should be designed in such a way that no deadlock will occur. If we make the anal-ogy with a labyrinth, at specification time we verify whether there is a path that leads to the exit. At implementation time we need to ensure not to engage in a death-end path. The verification proposed in this paper focuses on the first aspect: ensuring the existence of valid scenarios. The elaboration of protocols that ensure deadlock free execution is another line of (comple-mentary) research. 4. The verification of collaborative business processes
The remainder of the paper is devoted to the explanation of a Petri Net language based verification technique for collab-orative business processes. First of all, a short introduction to Petri Net theory and Petri Net languages is presented. Next, different compatibility types are introduced as a measure of to which degree process components in collaborative business processes are (in)consistent. It is shown how these consistency measures can be verified by means of Petri Net languages.
Next, the problem of multi-party collaborations is explicitly discussed, showing how some binary consistency measures can be extended to multi-party collaborative processes. 4.1. Petri Net theory
Petri Net theory has been applied in a wide variety of domains, ranging from astronomy, chemistry, nuclear physics, soci-ology, workflow management and business process modeling [61]. Its success is partially motivated by its mathematical ba-sis, its graphical representation, the presence of many analysis techniques and its executable nature. Mathematically, a Petri used: places are represented with the symbol s and for transitions the symbols h or | are used. Directed arcs connect places with transitions and vice versa.
In order to represent the state of a Petri Net, two additional concepts have been introduced: tokens and markings. The execution of a Petri Net is defined by its firing game semantics which defines the rules for firing transitions and moving to-kens from the input places to the output places. The distribution of the tokens in the places represents the state of the Petri Net and is called a marking.

The use of Petri Nets for modeling business processes was already proposed by Ellis [23] and Zisman [82] in the seven-ties. Today, many researchers are taking the same path and extensive research results have been obtained in this domain [73,34,20,53] , for an overview see [74,75] . It was soon observed that Petri Net theory was a valuable technique for the ver-ification, analysis and simulation of business processes. Unfortunately, some business process patterns are difficult to model using regular Petri Net theory [74]. Therefore, it was shown in [8,9,11] how the control flow aspects of a business process can be modeled using deterministic Petri Net languages by defining a deterministic labeling function and a set of final markings.

In formal language theory, a language is constructed by defining a set of rules on the concatenation of symbols. Such a combination of symbols is a word and if the word respects the rules it is an element of the language. The rules of the Petri
Net language are defined by the Petri Net structure; the symbols of the language are the labels of the transitions; and the words are constructed by looking at the supported firing sequences. To define the language the definition of a Petri Net should be extended with a labeling function ( s ), an initial marking ( l plays a crucial role in the generated Petri Net language [30,61] . By changing these definitions a single Petri Net can generate multiple languages. Therefore, we have shown in [9] that the control flow dimension of a business process can be modeled by means of an L-type Petri Net language .

A language L is an L-type Petri Net language iff there exists a labeled Petri Net PN =( N , s , l
L ( PN )={ s ( b ) 2 R * | b 2 T * and d ( l 0 , b )= l b . A final marking must exactly be reached to generate a word of an L-type language. Only those words that bring the Petri
Net in a final state are accepted. Thus, the control flow dimension is modeled by specifying an L-type Petri Net language on the business process activities: BP = L ( PN , l 0 , s , F ).

The following example illustrates the use of Petri Net language theory for business process modeling. The Petri Net lan-guage of the Petri Net shown in Fig. 4 with initial marking l follows: BP = L ( PN , l 0 , s , F )=( Create Auction Start Auction Bid * Stop Auction ). 4.2. Deterministic Petri Net languages
A typical discussion in concurrency theory which has an important impact on the verification of business processes as well, deals with the moment of choice [38]. The typical example is the distinction between the processes in Fig. 5 a and b. based approaches both processes are considered equal as their traces are the same ( A B , A C ). Concurrency theory on the other hand, advocates that both processes are different as they differ in the moment of choice.

The use of deterministic Petri Net languages prohibits the definition of the process in which multiple transitions with the for business process modeling and to make the distinction in the moment of choice we make the following assumptions: 1. If the choice represents a truly non-deterministic choice, i.e. the choice is made independent of any rules and guards, we consider that from a control flow requirements perspective both models mean exactly the same. Indeed, from a conceptual modelling perspective, the control flow aspects of a process model specify the scenarios/traces supported by the business. Obviously process models specify other aspects as well, e.g. data and resources, but these are not taken into consideration for verifying behavioural compatibility in this paper. Since the traces of both processes are equivalent we prefer the deterministic model above the non-deterministic one., i.e. the choice is made as late as possible. 2. If the choice is not truly non-deterministic, this means that there is some way to make a distinction between the two paths, e.g. by means of conditions relating to input data, resources, or any other aspect. Until now, we have abstracted from guards in the business process models, but in fact the activities in processes could be labeled and interpreted as [c1]A B + [c2]A C. This is analoguous to the guards used in UML to label transitions in State Charts. Transitions are not only labeled with activities but can be preceded by a guard expressing the condition which should be met to enable the transition, e.g.  X  X  X c1] X . This results in a clear distinction between the two branches of the choice. Here we consider that  X  X  X c1]A X  and  X  X  X c2]A X  are two different activities which can be renamed as  X  X  X 1 X  and  X  X  X 2 X . In this way the deterministic property of the Petri Net language is never violated.

This approach was motivated by analysing the gateway behaviour of the Business Process Modeling Notation (BPMN) [76], which is the standard notation for modeling business processes. BPMN provides four gateway types to model splits (and merges) in a process model. Two of them can be used to model exclusive decisions in a process model: the exclusive gateway and the complex gateway. The exclusive gateway has two types: data based and event based. The data based exclusive decision uses a boolean expression based on data values to choose between two or more alternative paths.
The event based exclusive decision works a little bit different. In this case an exclusive path is chosen based on the occur-rence of an event. Either way, non of the options supports the modelling of a truly non-deterministic choice. Therefore, a choice can be modeled using the condition as a uniqueness term to make a distinction between two equal tasks, i.e. using the approach as discussed in (2), as discussed above. The complex gateway can also be used to model decisions in a pro-cess diagram. The BPMN specification (version 1.1) states that  X  X  X hen the Complex Gateway is used as a Decision, then an expression determines which of the outgoing Sequence Flow will be chosen for the Process to continue.  X  This also motivates the approach taken above.

In [11], we have shown that deterministic Petri Net languages can be used to model the workflow patterns maintained in [79].
 In what follows, it is shown how these Petri Net languages provide a basis for verifying collaborating Business Processes.
First, the fundamental concepts are introduced in the context of the simplest case, i.e. binary collaborations. Next, the ver-ification technique is extended to the case of multi-party collaborations. 4.3. Semantic compatibility in binary interactions
As explained in Section 3.3, we define process compatibility, as the ability to execute a business scenario that satisfies the sequence constraints imposed by all parties. Depending on the number of scenarios that are supported, different types of semantic compatibility are identified.

Apart from assessing the behavioral compatibility, there is also the issue of data compatibility, which requires that for each activity, at the time when it is performed, the appropriate input data is available. The input data should be accurate and in a suitable format. This creates so-called data dependencies between services, because often (part of) the required in-put data is to be provided by other services, e.g. as part of the SOAP message that triggers the activity. In this way, data com-patibility between the participants is also a prerequisite to successfully execute a collaborative process. Although beyond the possible patterns in [31].

The strongest type of semantic compatibility 4 is called complete semantic compatibility . Two processes are called com-pletely semantically compatible when they define the same sequence constraints (i.e. the same language) on the atomic busi-ness activities in which they participate. Complete semantic compatibility is the strongest form of semantic compatibility which indicates that the collaborative business process will execute without any deadlock.

Note that morphological equivalence of PN 1 and PN 2 (and also the same initial and final markings) is a sufficient but not a required condition for language equivalence, i.e. two Petri Nets can generate the same language without having the same structure. On the other hand, alphabet equivalence (unless you take unreachable transitions into account) is a required con-dition for language equivalence. In the running example the participation of each of the partners differs and as a result lan-guage equivalence is never the case:
This first definition is only applicable in a limited number of cases and therefore this definition should be extended in order to take into account specific aspects of business process modeling. Two problems require a weakening of the definition.
First of all, we discuss the fact that each party of the collaborative business process may have a set of atomic business activ-the Auction Service and the Seller and Bidders ). The complete semantic compatibility definition requires alphabet equivalence, hence, the Auction Service, Seller and Bidders can never initiate a successful interaction. Secondly, it will be demonstrated how the direction of the communication is also an important aspect in collaborative processes.

As noted before, alphabet equivalence is a necessary condition for language equivalence (and complete semantic compat-ibility). Of course one can come up with multiple reasons that cause the set of atomic business activities between participants needed. In order to deal with this problem, a second compatibility notion is introduced ( strong semantic compatibility ), which states that two business processes are compatible when their languages on the common alphabet are equivalent.
More formally, let the behavior of two business processes, BP ness processes BP 1 and BP 2 are called strongly semantically compatible BP common alphabet of the two processes: R c = R 1 \ R 2 . L ( PN the common alphabet R c .

If we evaluate the interactions between the Seller and the Auction Service (see Fig. 3 ), the language differences are obvi-ous, and as such the collaborative business process can never be completely semantically compatible. In order to assess the strong semantic compatibility definition we need to consider the common alphabet: R ondly, each of the business processes is projected on this common alphabet (i.e. remove the transitions labeled Deliver , Pay , StartAuction and Bid ) from the business processes. Finally, the projected languages are compared:
This definition solves the first problem of alphabet differences. A second problem stems from the fact that equality of lan-guages is not always absolutely required for a meaningful collaboration between partners. In fact it could be sufficient to have at least one supported scenario to allow for collaboration. This problem will be tackled by introducing a specific rela-tionship between the partners of a collaborative business process.

The rationale behind the relationship, which is further referred to as the initiator X  X ooperator relationship , stems from the initiator and cooperator role, which refer to the fact the initiator partner uses or consumes functionality of the cooperator process. In the case that both processes use each others functionality, they are called peer processes and in this case strong semantic compatibility is required for a successful collaboration. Essentially, the initiator X  X ooperator relationship is a way to indicate whether a party (the initiator) enforces its scenarios on the cooperator of the relationship. For instance, in an adapted version of the auction example (see Fig. 6 ), it could be possible that the Seller is the privileged partner in the col-laboration which means he can enforce some rules on the other partners. Only if all scenarios of the Seller are supported by the Bidder, they will be able to cooperate. This case is called one-way strong semantic compatibility . Accordingly, it is of course possible that the Bidder process supports additional scenarios which are not required for a collaboration with that specific Seller .

Let the behavior of two business processes, BP 1 and BP 2
BP and BP 2 are called one-way strong semantically compatible BP " a 2 L ( PN 1 | R c ): a 2 L ( PN 2 | R c ).

We know from the previous discussion that the Seller is the initiator of the collaboration and enforces its rules to the other the Seller process and the Bidders process are not one-way strong semantically compatibility, as there is a scenario of the Seller which is not supported by the Bidders:
Additionally, it may be interesting to introduce an even weaker definition of semantic compatibility, obviously called weak semantic compatibility . Two business processes are weakly semantically compatible if they share at least one com-mon scenario.

Let the behavior of two business processes, BP 1 and BP 2
BP 1 and BP 2 are called weakly semantically compatible BP 1
In the running example the Seller is the initiator in the interaction with the Bidders. From the previous discussion, we know that the Seller process and the bidders process are not one-way strongly semantically compatible. They are, however, weak semantically compatible as there are scenarios from the Seller process that are supported by the Bidders process but not all:
The use of Petri Net languages offers some other advantages as well. For instance, detailed analysis reports comparing the languages may be generated. When two business processes are weakly semantically compatible, there is at least one sce-nario that can be executed. A typical management question could be the following: how bad is the inconsistency between the processes or what percentage of the scenarios is supported? These types of questions can be readily answered by using the proposed verification technique which generates detailed analysis reports on the supported and unsupported scenarios.
The verification output of the running example would indicate that the Seller and the Bidders process are weakly semanti-cally compatible. The technique will also generate a list of all supported scenarios and all unsupported scenarios. Such a de-tailed verification report provides crucial information to closely assess the compatibility issues of a collaborative business process. Especially, the unsupported scenarios provide interesting information, as the unsupported scenario may be very exceptional and occurring only once every 50,000 transactions, meaning that the incompatibility problem is less severe than first thought: 4.4. Semantic compatibility in multi-party interactions
The complexity of multi-party collaborations requires a modification of the verification techniques proposed so far, in such a way that they can be used to assess the compatibility of a multi-party collaboration by checking the consistency using a one-versus-all approach.

Consider the following three business processes as depicted in Fig. 7 : BP
Each pair of binary collaborative business processes is strongly semantically compatible, i.e. BP
BP 2 /. BP 3 . Thus, this multi-party collaborative business process should execute and no deadlock situations may occur. How-ever, a thorough analysis of the collaboration leads to the conclusion that nothing will happen. There is not one single activ-ity that can be executed without violating a sequence constraint in one of the other processes, i.e. the collaborative business process is in a deadlock situation, e.g. A is enabled in BP enabled in BP 3 , but apparently not in BP 2 , and so on.

This problem is caused by the fact that the binary verification technique presented in the previous paragraph does not take into account the complex synchronized behavior of the collaboration as a whole. A possible solution to this problem is to compute the synchronized (global) behavior of the collaborative business process which can be easily computed (cf. further). The downside of this solution is that the semantic compatibility criterion can no longer be applied to this synchro-nized behavior and we are limited to check the global behavior for the traditional deadlock situations.

Therefore, a one-versus-all strategy is proposed which allows to apply the consistency criterion in multi-party collabo-rative business processes as well. This strategy consists of computing the global behavior of all but one business process, e.g. BP 1 k BP 2 , which is then verified using our semantic compatibility definitions with the other business process, i.e. BP verification step is then repeated for each of the interactions. The global behavior of the business process can be computed by means of a transition fusion algorithm such as the JOIN-procedure presented in [14] or variants of the parallel operator de-fined in [15] which is developed in [9].

Consider the running example in which the consistency between the three processes BP ticed before, the binary version of the verification technique is unable to properly assess the consistency. Therefore, the glo-bal behavior of the process must be computed. As an illustration, the global behavior of BP semantic compatibility criterion is used to assess the consistency of BP
The construction of the parallel behavior of BP 1 and BP 2 language L ( BP 1 k BP 2 )={ abd }. The verification of the various types of semantic compatibility will now be illustrated, as follows: Completesemantic compatibility: Since alphabet differences are present ( R cesses are not completely semantically compatible.

Strong semantic compatibility: The projected languages of the business processes on the common alphabet R are as follows L (( BP 1 k BP 2 )| R C )={ A D } and L ( BP strongly semantically compatible.
 One-way strong semantic compatibility: Suppose that BP 3 uses functionality of the collaborative business process
BP 1 k BP 2 . The scenarios (i.e. language) of BP 3 are not a subset of the scenarios of BP not one-way strongly semantically compatible.

Weak semantic compatibility: Finally, it is easy to see that there is not one scenario that is supported by the two pro-cesses, thus weak semantic compatibility is also not the case.

Suppose that the BP 3 is defined as in Fig. 9 . In this case the consistency between BP results: Completesemantic compatibility: Since alphabet differences are present ( R cesses are not completely semantically compatible.

Strong semantic compatibility: The projected languages of the business processes on the common alphabet R are as follows L (( BP 1 k BP 2 )| R C )={ A D } and L ( BP not strongly semantically compatible.
 One-way strong semantic compatibility: Suppose that BP 3 uses functionality of the collaborative business process
BP 1 k BP 2 . The scenarios (i.e. language) of BP 3 are not a subset of the scenarios of BP ported. Therefore, these processes are not one-way strongly semantically compatible. On the other hand, suppose that
BP 1 k BP 2 uses functionality of BP 3 . In this case all scenarios of BP are one-way strongly semantically compatible.

Weak semantic compatibility: In any case there is a scenario ( A D ) which is supported by the two processes, thus they are weakly semantically compatible.

The starting point of the proposed approach is the existence of multiple independent partners that wish to collaborate based on their local business processes. An interesting but slightly different problem is discussed in [14] where the realiz-ability of a global choreography is investigated. Concretely, the realizability property checks whether all sequence con-straints of the global choreography can be imposed by the local processes. For instance, assume four business processes ( BP 1 = BP 2 ={ A B }, BP 3 = BP 4 ={ C D }) for which the following relationships hold: BP with BP 2 and the same goes for BP 3 and BP 4 . Obviously, some sequence constraints cannot be modeled in the local processes. For instance, what if the global business process constrains the communication sequence among these partners as follows:
BP global ={ A B C D }? This constraint is not locally enforceable [14]. The proposed verification technique, however, can be easily used to test the compatibility of the local processes with the global process in the same way as described above.
From this discussion it is clear that the verification of a multi-party distributed business process is a complex problem which should be performed with great care. In a first step the normal  X  X  X ne-to-one X  X emantic compatibility definitions can be used to check such a process. If inconsistencies are discovered the business processes should be changed accordingly.
If no inconsistencies are identified, the processes should still be checked for conformance with the parallel behavior of the other processes. It is only when these processes are consistent, that one is completely certain that the business process will be able to execute without any problems. 5. Automating semantic compatibility verification Checking semantic compatibility in collaborative business processes is a complex exercise which involves multiple steps. verified in their binary interactions, i.e. whenever two partners have common activities they will be checked for consistency. Next, all partners are confronted with the global behavior of the collaboration by checking it on a one-versus-all strategy.
Table 1 gives an overview of the different semantic compatibility definitions. The second column shows how the various types of semantic compatibility can be verified by means of Petri Net languages, which will be discussed further on in this section.

The definitions of semantic compatibility are logically related, i.e. complete semantic compatibility automatically implies strong semantic compatibility, etc. Because of these relationships semantic compatibility can be checked incrementally which is also reflected in the conceptual overview of the analysis techniques shown in Fig. 10 . The following relationships hold:
The computability of semantic compatibility is highly dependent on the closure properties and decidability of specific operators on the Petri Net language types. Many of the developed algorithms use the closure properties ( Table 2 ) and decid-ability results ( Table 3 ) of different Petri Net languages (for more information see [61]). Closure properties and decidability results of Petri Net languages provide additional insight in understanding the particular features and limitations of these lan-guages. Three major types of closures can be defined, as follows: A language can be closed for a certain operator, noted as (+).
 A language can be not-closed for a certain operator, noted as ( ).
 A language can be semi-closed for a certain operator, noted as ( ).

Although many other closure properties are mentioned in the literature, these closure types are sufficient for the purpose of business process verification. Table 2 defines the closure properties of the different types of Petri Net languages (indicated in the columns) with respect to the main operators (indicated in the rows) that are needed in the context of business processes:
If a language of type X (column) is closed for an operator Y (row), then the result of the application of Y on two languages of type X is always a Petri Net language of type X.

If a language of type X (column) is not-closed for an operator Y (row), then the result of the application of Y on two lan-guages of type X can be a language which cannot be generated by a Petri Net.

If a language of type X (column) is semi-closed for an operator Y (row), then the result of the application of Y on two lan-guages of type X is always a Petri Net language, but not always of type X.
 In Table 3 , several relevant decidability results are presented for the verification (by computation) of properties for Petri Nets and their languages. The following properties are of interest for business process verification: Reachability: can a specific marking be reached from the initial marking of a Petri Net? Bisimilarity: can one Petri Net be mapped on another one by means of a bisimulation map? Weak bisimilarity: bisimularity with the inclusion of the empty string.

The results presented in Tables 2 and 3 are used extensively in the algorithm for verifying collaborating Petri Nets. A road-map for the verification algorithm is given in Fig. 10 , which is the overview for the subsequent discussion of the various ele-ments in the algorithm:
Businessprocess modeling: The business process modeling step consists of the translation of the business process model to Petri Net languages. This step is for now a manual step but multiple researchers are looking at automated ways to translate BPMN or BPEL models to Petri Nets. For more information see [39] or the BPMN to Petri Net transformer [19]. These results are applicable as BPMN can be used to model the business processes using the atomic business activ-ities (see the examples).

Alphabet comparison: The alphabet comparison step is performed by simple set comparison and helps to determine whether complete semantic compatibility is possible or not. If the alphabets differ then complete semantic compatibility should never be checked.
 Check CSC: Complete semantic compatibility is checked by means of the bisimilarity game introduced by Janc  X  ar [41].
Bisimulation is an equivalence relation between state transition systems and is decidable for deterministic Petri Net lan-guages (see Table 3 ). This bisimilarity game allows the verification of language equivalence of deterministic Petri Net languages.

Language projection: If the alphabets are not equivalent, language projection is performed. Essentially, two techniques exist: reduction and k -relabeling. Because of the determinism constraint k -relabeling is not an option and language pro-jection is performed by applying standard reduction techniques as presented in for instance [30]. Language projection could also be achieved by implementing the results presented in [25]. Eshuis et al. define a two-step formal approach to construct a customized process view on a business process which allows to hide unnecessary details in a consistent way.
Check SSC: Strong semantic compatibility is computed the same way as complete semantic compatibility but now the projected languages are compared.

Complement: In this step the complement of the Petri Net language is computed. This is the most complex part of the algorithm and it is based on the proof of complementing deterministic Petri Net languages by Pelz [59]. Table 2 also shows this favorable result about deterministic Petri Net languages, as it is semi-closed on the complement operator, i.e. the result of the complement algorithm is also a Petri Net language (of type L ). The proof was corrected [9] and the subsequent algorithm was extensively checked in terms of its performance results. The algorithm scales really well (i.e. computation time is maximum 2 s) for small and medium-sized problems (i.e. these are Petri Nets with the number of transitions and number of places ranging between 1 and 50). For large problems, i.e. the number of transitions and places oscillates between 50 and 100, the performance of the algorithm degrades, however with a maximum computation time of 4 min for the largest example.

Bisimilarity based reduction: The computation time of the complement algorithm is highly dependent on the complex-ity of the used Petri Net language. Therefore, before the computation of the complement a technique called bisimilarity based reduction [9] can be performed to reduce the complexity and computation time of the algorithm.

Check owSSC: In this step, the initiator X  X ooperator relationship that may exist between two business partners is explic-itly taken into account. It is checked whether the language of the initiator is a subset of the language of the cooperator.
Note that checking the subset operator can be achieved by verifying that the intersection of the first language and the complement of the second language is empty. From Tables 2 and 3 it follows that the complement and the intersection operator are computable. The emptiness problem can be reduced to the reachability problem which is also decidable [43].
Check WSC: The weak semantic compatibility check is simply performed by investigating whether or not the intersection of the languages is empty or not. Standard techniques [61] can be used to compute the intersection of two or more Petri Net languages.

Analysis report: Of course, for each of these steps an analysis report with detailed information about the problems is gen-erated. The generated information stems from a thorough analysis of the reachability tree, which allows us to create the list of unsupported and supported scenarios between the processes. 6. Related work
Today, the BPM market has been overwhelmed by a number of different BPM products which are focused on the design and enactment of business process models. Other important aspects such as verification, validation, simulation and perfor-mance analysis are only weakly supported. Often, the type of verification offered by these products is limited to a syntax check and does not consider behavioral (semantic) aspects, by examining potential deadlocks or livelocks.

The execution of collaborative business processes is a complex process which requires the definition of many aspects, for a good overview we refer to Bussler [6]: events or activities, security issues, data compatibility, and a protocol which de-scribed the interaction between the partners. A successful collaboration requires a good fit and correct implementation of all these aspects. In this paper the focus is on the control flow verification of (collaborative) business processes. The verifi-cation technique proposed in this paper strongly relies on the concept of atomic business activities as basic granules from which processes are composed. We therefore first present related research on similar process modeling approaches. Subse-quently we review related work on business process verification. 6.1. Similar business process modeling approaches
In the literature one can find two main groups of approaches to simplify process definition and process modeling. A first
The idea is to decompose a process in so called microflows. Microflows are considered as a sort of granules that structure a business process and hide or abstract from low-level activities and interactions. In that way it allows to raise the abstraction level in the original process definition by only using microflows. The basic idea is to first design microflows (e.g. protocols) and then continue with the high-level process design. The idea of microflows as structuring concept is clearly described by
Zdun et al. [81]. They distinguish between two general types of process flow: macroflow representing the higher-level busi-ness process, and microflow addressing the process flow within a macroflow activity. Another similar approach can be found in the many studies about so called Web services conversations [2,80,7,4,35] . Roughly spoken, conversations can be consid-ered as well-described (low-level) interactions between specific services (partners), which can be used as a kind of module in a high-level process. Finally, the research about interactions protocols or business protocols by Desai and Singh is certainly worth to mention too [18,67] . They argue that business processes are conventionally modeled directly as monolithic flows, as a result of which these flows are often more complex than necessary and lack modularity [18]. Therefore, they propose to model business processes as composition of business protocols . Similar to the conversation-based method the concept of business protocols is presented as a (design) abstraction which provides information about which sequence of message ex-changes or interactions can occur between several parties. Directly developing composite business flows is harder than mod-eling individual business protocols and then putting them together. Thus, protocol-based process modeling can be viewed as a structured approach wherein protocols are granules [18].

A second large cluster of techniques simplifies process definition by using multiple views on a process model, which are mainly based on the principle of separation of concerns [65,37,46,66,29] . In this group of approaches there are typically two kinds of views used. In a first case the views are considered independent of each other, but all views together define the com-plete process at hand. As an example, Schmit et al. presented a composition modeling methodology that is based on several layers or views with the same level of abstraction [65]. They make a distinction between workflow, transaction and security aspects, hoping that this layering technique eases later corrections (e.g., adjusting transaction quality of service parameters).
In the second case, a distinction is made between business and technical processes, the latter being software realizations of the first [37].

The atomic business activity approach can be considered as combination of both worlds. In particular, atomic business activities can be considered as a kind of reusable granules, so that they can be used as a building blocks for business pro-cesses, while technical details as coordination issues are hidden for the process designer. Dealing with technical issues is the responsibility of the implementation architecture. Instead of defining specific low-level microflows, conversation or interactions protocols per activity, we have shown in [57] that it is possible to use default notification and coordination protocols.

One-way to assess the usability of a business process modeling approach is by checking the ability to model the set of workflow patterns introduced in [45] and further developed in [79], and by checking the conformance with the set of service interaction patterns developed by [3].In [10], we have shown the use of the atomic business activity approach, combined with the Petri Net modeling technique, for business process modeling by illustrating how the workflow patterns can be modeled.

In [3], the authors have introduced a set of service interaction patterns that occur often in collaborative business pro-cesses. The atomic business activity approach can be related to these service interaction patterns in two ways. First of all, the most prevalent question deals with how the atomic business activity approach is able to model and capture the seman-tics of these different patterns. Some examples towards the use of these interaction patterns are included in the auction example. The send/receive pattern can be found in the beginning of the process where the auction is initiated. The one-to-many send pattern can be observed where the auction service sends a message to all unsuccessful bidders. The racing incom-ing messages pattern can be observed where the bidders wait for a positive or negative answer of the auction service. One can clearly see that the atomic business activity approach (see Fig. 3 ) models interaction by identifying common activities and address this question the other way, i.e. by asking how service interaction patterns can be used to implement atomic busi-ness activities. An atomic business activity may involve multiple participants, therefore we require a multilateral interaction pattern for implementation [3]. Additionally, given that atomic business activities require services to send and receive multi-ple messages, the processing of an atomic business activity can be realized using a multi-transmission interaction pattern .Asa result we believe that the atomic multicast notification pattern is the best candidate for implementing atomic business activ-ities. The elaboration of the coordination protocol is not the prime focus of this paper. 6.2. Business process verification approaches
In most of the approaches to verify a collaborative process, the combined picture of interconnected processes is translated to a modeling language that supports formal analysis, e.g. finite state machines [27,26] , guarded automata [28] or Petri Nets [73,34,20,53,14,55] . Then the global behavior of the business process is checked for some specific characteristics, e.g. dead-lock freeness, livelock freeness, soundness, etc. If possible the shortest path to this deadlock situation is computed and an analysis report of the consistency is generated.

The work of Wodtke et al. [77], focused on adding a formal foundation for distributed workflow execution. They devel-oped a simplified operational semantics of state and activity charts that is tailored to use in workflow specifications. Reach-ability sets and symbolic model checking techniques are used to verify the correctness of the process models.
In [73], van der Aalst explored the use of Petri Nets in workflow management. A restricted type of Petri Nets, called Work-flow Nets (WF-Nets) are introduced to model the process view on a workflow. The authors continue by defining the sound-ness property on workflows nets. Soundness requires proper termination of each case and the absence of dead tasks in the
WF-Net. This property can be used to analyze workflows or business processes for deadlock situations. When the global behavior of the collaborative business process is present or can be computed this property can be used to determine the deadlock freeness of collaborative business processes as well.

In [34], Hamadi et al. propose a Petri Net based algebra for the modeling of control flows in a Web service composition. A service composition is modeled through the use of typical constructs (sequence, iteration and arbitrary sequence) and some more complex constructs, e.g. parallel with communication, discriminator, selection and refinement. Furthermore, they dis-cuss some analysis techniques to verify deadlock and livelock freeness of the Web service composition which are based on fundamental properties of Petri Nets, such as the liveness and boundedness properties.

Dijkman and Dumas [20] propose a multi-viewpoint approach for service oriented design. They have integrated four views on processes: interface behavior, provider behavior, choreography and orchestration. They also defined a mechanism to verify the consistency of the models. The approach is based on the notions of a send and receive event, and the combi-nation of both which is called an interaction. Their technique acknowledges the need for a modeling technique that makes abstraction of the message exchanges but it is not clear how the approach can be used to create detailed compatibility reports.

In [53], Martens proposes a Petri Net based modeling and verification technique for collaborative business processes. He defines his own quality criterion (usability) from which he decides on the compatibility of Web services. The notion of work-flow modules and weak soundness is introduced, which are variations of the workflow nets and soundness property of van der Aalst. Two Web Services are said to be semantically compatible if the composed system is usable. If there exists an envi-ronment of the workflow module and if the composed system of the module and the environment is weak sound, then the workflow module is called usable and the collaborative business process is consistent. This technique can be used to check the deadlock freeness of a service composition but cannot be used to pinpoint the areas where processes differ.
The Web services verification approach of Foster et al. [27,26] is based on a finite state machine description of Web ser-vices orchestrations. More specifically, a BPEL process is translated in a Finite State Process notation, which is then compiled to a Labeled Transition System (LTS). This LTS is then verified using the Labeled Transition System Analyzer. Their verification approach is mainly based on liveness (starvation of progress) and safeness (deadlock freeness) of the composition.
The work of Fu et al. [28] is based on guarded automata and Promela. Guarded automata are used as an intermediate rep-resentation of a BPEL process. They define their own quality property on interacting processes, called synchronizability. A composite Web service is called synchronizable if it satisfies the following conditions: synchronous compatibility, autonomy and lossless composition. Afterwards the SPIN model checker is used for the verification of the synchronizability property.
Haller et al. [33,32] tackle the consistency between choreography models and workflow models from an interesting point of view. They provide with m3po (multi-metamodel process ontology) an ontology which allows the extraction of choreog-raphy models from internal workflow models which makes the consistency verification between workflow (private process) and choreography (public process) redundant. The verification of the choreography should still be performed as the approach is mainly focussed on the consistency between public and private process models.

Eshuis et al. [24] propose an efficient approach to verify the conformance of BPEL processes. Their approach is structural, thus avoiding the typical state space explosion problems of many other techniques. By translating each BPEL process in a tree structure and by deriving the process type the BPEL processes can be compared. This matchmaking process can be performed on-the-fly and is very efficient. However, for a complete verification some semantical analysis may be needed.
The approach of Decker et al. [14] is based on checking the consistency (realizability) of the local business processes with a global choreography which was already briefly discussed above. In [13], the authors describe a framework in which they relate compatibility of services at implementation level and consistency between an interface and the actual implementa-tion. Their discussion on symmetric consistency relations (i.e. a consistency relation should not be symmetric) is also re-flected in our definition of one-way strong semantic compatibility.

The research on operating guidelines is related as well. In [54], automata where used to model services and their interac-tions. The authors define operating guidelines which are the complete set of strategies supported by a service, which is used to assess the compatibility of a requestor X  X  service. In, for instance [55], they propose the use of open workflow nets (oWFN), which are an extension to workflow nets [73], and operating guidelines to detect inconsistencies between services. Such an operating guideline resembles the Petri Net languages that we propose in that we also compare all scenarios of the business processes. These operating guidelines of the provider service are then used to check the compatibility of a requester service.
This is done by comparing the requester X  X  behavior to a subtree of the operating guideline with matching annotations. The authors extended their work in [52], in which they make a distinction between intended and unintended behavior to build customized operating guidelines . These customized operating guidelines characterizes all processes that can communicate deadlock freely with a given process satisfying a given constraint. The approach was also used to analyze interacting BPEL processes [51]. These verification approaches are similar to the one described in the paper, in that they are also based on the strategies (scenarios) of the process. Another approach based on the oWFNs is the one proposed by Schmidt [64] in which the author studies the problem of controllability of oWFNs. A control-theoretic approach is used to check the usability property of oWFNs, defined in [53].

The main difference between the approach proposed in this paper and the verification techniques reviewed so far is their restricted capabilities for verifying overall consistency. In the approach proposed in this paper the compatibility between collaborative business processes is not answered by means of a simple yes or no answer. Rather a report is produced that assesses the compatibility in much more detail. In this way the proposed verification technique is not only able to pinpoint the problem area but the report also contains information on the degree of compatibility (unsupported scenarios) between the business processes.

A second concern is about the scalability of the presented verification techniques. Almost none of the references so far (except [73,55] ) address the performance and scalability of the proposed verification techniques. Without a sound perfor-mance analysis, the actual usability of the verification techniques in real-life examples becomes cumbersome. In [9], we have demonstrated that our approach scales well and can be used in realtime settings for small and medium-sized processes (i.e. the number of atomic business activities between 0 and 50). For larger process (more than 50 activities) the algorithms per-form worse but can still be used for design-time verification. The algorithms developed in this research have also been stress-tested by using artificially generated Petri Nets with the number of states ranging from 22 to 120,000. Real-life busi-ness processes with 120,000 states are rare and therefore our approach is usable in almost all realistic settings.
Our business process modeling approach has been validated through consultancy and case studies in the banking, insur-ance and telecom sectors, e.g. the one described in [47]. Also, a prototype web service based implementation of the micro-flows was presented in [57].

Finally, examining the total global synchronized behavior of the collaborating business processes remains an important non-trivial problem. Just computing global behavior without mechanisms for tracing back potential difficulties to individual cies to the actual local business processes. 7. Conclusion and further research
Collaborative business processes will be the foundation of future software products as well as B2Bi scenarios. Therefore, efficient modeling, verification and analysis techniques are essential in current and future software engineering methodol-ogies. In this paper, a motivation was given why many of the current business process modeling languages and techniques are too low-level (message-based) to model business processes. High-level business processes can and should be verified and analyzed to find problems related to the business semantics of the process in early phases of the development life-cycle. A new collaborative process modeling approach based on atomic business activities was discussed which models business pro-cesses on a higher-level of abstraction. Without going in too much detail the workings of the approach were explained and the application of the approach in collaborative business process modeling was discussed. In the remainder of the paper a complete verification technique for collaborative business processes was elaborated. Of course this technique assumes pro-cesses based on atomic business activities, which allows an elegant verification in several steps.

Traditional verification techniques approach the consistency problem from a pure yes or no point of view, i.e. the pro-cesses are consistent or not. Additionally, these techniques merely focus on finding inconsistencies (i.e. deadlock) between the processes, while a report on the differences and unsupported scenarios between the processes is at least equally impor-tant. That is why in this paper so much attention was given to the possibilities of generating intermediate detailed analysis reports on the degree of compatibility of the business processes. Several levels of semantic compatibility (complete, strong, one-way and weak) are used as an indication of the kind of compatibility between the processes. The Petri Net language equivalent of these compatibility types was given in order to illustrate how the verification can be achieved. Although the verification was first discussed for two collaborating processes, it was subsequently extended to the case of multi-party collaborations. A one-versus-all strategy was introduced to verify a multi-party collaborative business process for compat-ibility. Finally, an overview of the complete analysis process and the performance of the algorithms is given.
Reports on the similarities and more importantly on the differences of the supported scenarios can be used for supporting management decisions. In many occasions, for instance in long-term relationships, the complete compatibility of the busi-ness processes is a critical requirement, i.e. the cost to analyze and alter the business processes is economically acceptable.
On the other hand, in short-term relationships it could be sufficient to have at least a few compatible scenarios for both busi-ness processes. The additional cost and time to make the business processes completely consistent may be too high to be economically interesting. Such a detailed analysis report can be used in support of the management decision whether or not to engage in a long-or short-term relationship. Sometimes a 90% support rate is sufficient and economically relevant in setup situations, while a 99% support rate is required for (more) long-term collaborative business processes. Such a deci-sion requires a detailed analysis report of the (in)compatibility which is not offered by traditional verification techniques.
Further research on the verification process is focusing on the optimization of the algorithms and the possibilities to apply reduction techniques in the algorithms. In parallel other lines of research are conducted on data compatibility and on imple-menting business processes with atomic business activities.
 Acknowledgements
This research was part of a project funded by the Research Fund K.U. Leuven (OT 05/07) and (IOF-HB/07/022), whose sup-port is gratefully acknowledged.

References
