 Current approaches to RDF graph indexing suffer from weak data locality, i.e., information regarding a piece of data ap-pears in multiple locations, spanning multiple data struc-tures. Weak data locality negatively impacts storage and query processing costs. Towards stronger data locality, we propose a Three-way Triple Tree (TripleT) secondary mem-ory indexing technique to facilitate flexible and efficient join evaluation on RDF data. The novelty of TripleT is that the index is built over the atoms occurring in the data set, rather than at a coarser granularity, such as whole triples occurring in the data set; and, the atoms are indexed regardless of the roles (i.e., subjects, predicates, or objects) they play in the triples of the data set. We show through extensive empirical evaluation that TripleT exhibits multiple orders of magni-tude improvement over the state-of-the-art, in terms of both storage and query processing costs.

RDF [9] is becoming the data model of choice in many emerging data generation and sharing scenarios. RDF data sets (often referred to as  X  X raphs X  of  X  X riples X ) are typically generated in social semantic domains where often a fixed schema is not available a priori. The natural flexibility and expressivity of triples was recognized early in the develop-ment of modern logic [11]. Triples, which treat both objects and relationships as first-class citizens, blur the traditional divide between data and metadata, allowing for freer on-the-fly generation of data. This is in contrast to previous graph-oriented data models, which have more rigidly main-tained the distinction between data and metadata [2].
The format and flexibility of RDF call for new query paradigms and processing techniques [6]. At the heart of many RDF query languages, including the W3C standard language SPARQL [12], are basic graph patterns [7]. Re-cent research has begun to make headway on understanding fundamental theoretical (e.g., [7]) and engineering (e.g., [10, 14]) aspects of basic graph pattern query processing.
In this paper, we focus on the problem of scalable in-dexing of RDF data, to support efficient processing of ba-sic graph patterns. As we discuss below, current indexing techniques suffer from weak data locality, in the sense that information about a piece of data can appear in multiple lo-cations, possibly spanning several different data structures. Weak data locality negatively impacts storage and query processing costs. Towards stronger data locality, we propose a Three-way Triple Tree (TripleT) secondary memory index. The novelty of TripleT is that, in contrast to state of the art approaches, (1) the index is built over the atoms occurring in the graph, rather than at a coarser granularity, such as whole triples occurring in the graph; and (2) the atoms are indexed regardless of the roles they play in the triples of the graph. TripleT is robust in the face of the dynamic un-structured nature of typical RDF graphs. Furthermore, the proposal is conceptually quite simple. We show through ex-tensive empirical evaluation that TripleT exhibits multiple orders of magnitude improvement over the state of the art, in terms of both storage and query processing costs.
We begin with a brief presentation of basic notation and definitions used in the paper, a statement of the indexing problem considered, and an overview of the state of the art.
Data model. Full details of the RDF data model can be found in the W3C standards [9, 12]. For our purposes here, let A be an enumerable set of atoms (e.g., Unicode strings). A triple is an element ( s, p, o )  X  X  X A X A , typically inter-preted as a statement to the effect that X  X bject o stands in re-lationship p to subject s . X  Hence, the first element s is called the subject of the triple; p is called the predicate ; and o is called the object . An RDF graph is a finite set of triples. In a graph G , let S ( G ) denote the set of atoms appearing as sub-jects; P ( G ) the set of atoms appearing as predicates; O ( G ) the set of atoms appearing as objects; and A ( G ) = S ( G )  X  P ( G )  X  X  ( G ). For example, in graph G of Figure 1, we have S ( G ) = { Yamada , Herzog , McShea , doc1 , doc2 , doc3 , knows } .
Basic graph patterns. Let V be an enumerable set of variables, disjoint from A . A simple access pattern (SAP) is an element of ( A  X  V )  X  ( A  X  V )  X  ( A  X  V ) . In other words, an SAP is a triple in which roles (i.e., subjects, pred-icates, and objects) may be either atoms or variables. A basic graph pattern (BGP) is a conjunction of one or more set of variables occurring in BGP P , and consider the set M ( P ) of functions f which map A X  X  ( P ) into A , such that f is the identity on A : Then, the semantics of BGP P on a graph G is the set where ( a, b, c )  X  P means that ( a, b, c ) is an SAP occurring in P . In other words, P ( G ) is the set of bindings for the variables of P , such that each binding maps all of the SAPs of P into triples of G .

Example 1. Consider the query  X  X hat are the dates and types of documents on which McShea was a performer? X  over the graph G given in Figure 1, as a BGP:
P = ( McShea , performed , ? doc ) On G , we have only one valid binding, P ( G ) = { X  ? doc : doc3 , ? date : 29 . 6 . 09 , ? type : MP3  X  X  .
 BGPs are essentially conjunctive queries tailored for the RDF data model [7]. Joins between the SAPs of a BGP are induced by the co-occurrence of variables and atoms. There are six native BGP join types: subject-subject, subject-predicate, subject-object, predicate-predicate, predicate-object, and object-object joins. In Example 1, there is a subject-object join between the SAP ( McShea , performed , ? doc ) and both of the other SAPs, due to the co-occurrence of vari-able ? doc . Likewise, there is a subject-subject join between (? doc, createdOn , ? date ) and (? doc, type , ? type ).
The problem. How can we index a graph G to support efficient evaluation of BGPs on G ? We specifically focus on the design of native RDF index data structures, i.e., indexes which support the full range of BGP join patterns. State of the art solutions. In what follows, we use the B+tree secondary-memory data structure [3] to implement the various indexing techniques considered. We assume fa-miliarity with this data structure and its use in conjunctive query processing. To the best of our knowledge, the two major competitive proposals for native RDF indexing are multiple access patterns (MAP) and HexTree.

MAP. In this approach, all three positions of triples are indexed: subjects (S), predicates (P), and objects (O), for some permutation of S, P, and O. MAP requires up to six separate B+trees, corresponding to the six possible order-ings of roles: SPO, SOP, PSO, POS, OSP, OPS. For ex-ample, for each ( s, p, o )  X  G , it is the case that o # p # s is a key in the OPS index on G (where  X  # X  is some reserved separator symbol). A BGP join evaluation requires two or more look-ups, potentially in different trees, followed by sort merge joins. Major systems employing the MAP technique include Virtuoso, YARS, and RDF-3X [5, 8, 10].

HexTree. Recently in the Hexastore system, Weiss et al. [15] have proposed indexing two roles at a time. This approach requires up to six separate data structures corre-sponding to the six possible orderings of roles: SO, OS, SP, PS, OP, PO. Payloads are shared between indexes with sym-metric orderings. For example, for each ( s, p, o )  X  G , it is the case that s # p is a key in the SP index on G , p # s is a key in the PS index on G , and both of these keys point to a shared payload of { o  X  X  ( G ) | ( s, p, o )  X  G } . As with MAP, join evaluation requires two or more look-ups, potentially in different trees, followed by sort merge joins. Hexastore has only been proposed and evaluated as a main-memory data structure [15]. We propose HexTree as an effective secondary-memory realization of the Hexastore proposal us-ing the B+tree data structure.
 Limitations of current solutions. In both MAP and HexTree, information about a piece of data can appear in multiple locations, possibly spanning several different data structures. For example, consider the atom doc1 in the graph of Figure 1. In the MAP indexing scheme, locating all triples related to doc1 requires lookups in three different data structures: the SPO B+tree (or the SOP B+tree) to lo-cate those triples in which the atom occurs as a subject (e.g.,  X  doc1 , type , PDF  X  ), the PSO (or POS) B+tree to determine that the atom does not occur as a predicate, and the OSP (or OPS) B+tree to locate those triples in which the atom occurs as an object (e.g.,  X  Yamada , authored , doc1  X  ). Simi-larly, reconstructing doc1 in the HexTree indexing scheme also requires three separate lookups.
 This loss of data locality is a primary limitation of the MAP and HexTree indexing schemes. Weak data locality leads to (1) redundant storage (e.g., each B+tree in the MAP scheme contains a separate copy of essentially the same set of data), and (2) increased query processing costs (e.g., performing a join on an atom can require multiple indepen-dent index look-ups). We next present an indexing scheme designed with an eye towards strengthened data locality.
Towards stronger data locality, we propose indexing the key-space A ( G ), regardless of the particular roles the atoms of A ( G ) play in the triples of G . For a key k , the pay-load is all triples of G in which atom k occurs. In par-ticular, the payload for k consists of three  X  X uckets X : one for all pairs ( p, o ) where ( k, p, o )  X  G , one for all pairs ( s, o ) where ( s, k, o )  X  G , and one for all pairs ( s, p ) where ( s, p, k )  X  G . In other words, there is one bucket apiece for all those triples where k occurs as a subject, for all those triples where k occurs as a predicate, and for all those triples where k appears as an object. For example, on the graph of Figure 1, the payload for doc1 would consist of an object bucket  X  ( Yamada , authored )  X  , a subject bucket  X  ( 4 / 5 , rating ) , ( PDF , type )  X  , and a predicate bucket  X  X  .
To facilitate query processing (e.g., for merge joins), we keep the pairs in each of the buckets sorted. By default, the subject bucket is sorted in OP order, the predicate bucket in SO order, and the object bucket in SP order. These choices are based on the assumption that subjects are more selective than objects, and objects are more selective than predicates. Of course, selectivities will be dependent on the character-istics of G , and sort orders can be chosen as necessary (or, even both sort orders can be materialized if warranted).
We note two features of TripleT. First, the keys in TripleT are 1/3 the length of those in MAP and 1/2 those in Hex-Tree. Consequently, there is a higher branching factor in the TripleT B+tree. Furthermore, the key-space indexed by TripleT, A ( G ), itself is potentially much smaller that those indexed in the MAP and HexTree schemes. Taken together, these reductions lead to shallower indexes and hence lower lookup costs, relative to MAP and HexTree.

Second, TripleT requires just one index, leading to stronger data locality and non-trivial reduction in storage costs rel-ative to MAP and HexTree, while efficiently supporting all BGP join types. For example, a subject-object join induced by the co-occurrence of an atom k can be evaluated by a single look-up on k followed by a merge-join between the subject and object buckets of k  X  X  payload. A join induced by the co-occurrence of a variable is implemented as multi-ple look-ups followed by sort merge joins, just as with MAP and HexTree.
 Example 2. Consider the BGP P 1 = ( Herzog , authored , ? d 1 )  X  ( Herzog , performed , ? d To compute P 1 ( G ) using TripleT requires a single lookup of Herzog followed by a lookup in the resulting payload X  X  subject bucket for authored #? d 1 and performed #? d 2 . The crossproduct of all matches is then formed.

Next, consider the BGP P 2 = ( McShea , performed , ? d 1 (? d 1 , createdOn , ? d 2 ) . To compute P 2 ( G ) with TripleT re-quires: (1) a lookup of performed ; followed by (2) a lookup of McShea #? d 1 in the predicate bucket of the resulting pay-load; (3) a lookup of createdOn ; followed by (4) the retrieval of the predicate bucket of the resulting payload; and finally (5) a direct merge join of the results of (2) and (4) on ? d In general, we have the TripleT join algorithm for two SAPs S 1 and S 2 presented in Algorithm 3.1. Note that we (1) abuse our notation, and let A ( S ) denote the set of atoms occurring in SAP S and, (2) set aside the degenerate case which occurs when either of the SAPs is atom-free, which necessitates an (index) nested loops join.
 TripleT exhibits the same advantages as MAP and Hex-Tree, as compared to earlier RDF storage and indexing pro-posals, e.g., robustness in the face of dynamic data (e.g., schema independence); concise handling of multivalued re-sources; avoidance of nulls; and, all pairwise joins are fast merge-joins (see the detailed discussion of these advantages in [1, 15]). Furthermore, the additional benefits of simplic-ity, reduced size, and strengthened data locality distinguish the TripleT proposal from the state of the art.
We implemented MAP, HexTree, and TripleT using 8K blocks and 32-bit references, in virtual memory, using Python 2.5.2. All experiments were executed on a pair of 2.66 GHz dual-core Intel Xeon processors with 16 GB RAM running Mac OS X 10.4.11.
 Each experiment was performed using (1) synthetic data,
Input :  X  a basic graph pattern P = S 1  X  S 2
Output : P ( G ), the evaluation of P on G begin end Algorithm 3.1: TripleT join algorithm for SAPs S 1 , S 2 (2) the DBPedia data set; 1 and (3) the Uniprot data set. DBPedia is an extraction of the well-known Wikipedia on-line encyclopedia. Uniprot is a comprehensive collection of protein sequence and annotation data. For (1), we built two synthetic data sets (the results presented below are the aver-ages over these two sets). In the first set, we randomly gen-erated n triples over n 1 / 3 unique atoms, for n = 1 , 000 , 000, to n = 6 , 000 , 000, in increments of one million, where rep-etitions of atoms were allowed within triples. In the second set, we randomly generated n triples over ceiling ( n 1 / 3 unique atoms, for n = 1 , 000 , 000, to n = 6 , 000 , 000, in in-crements of one million, where repetitions of atoms within triples were disallowed. For (2) and (3), we took an arbi-trary sample of 10,000,000 triples from each data collection. After cleaning, we kept 6,000,000 triples in each collection.
Comparing index size. In increments of 1 million triples, from 1 to 6 million triples, we built the three index types. The plots of the resulting index sizes, in 8K blocks, are shown in Figures 2(a)-2(c).

TripleT was up to 259 times smaller, with a typical two orders of magnitude savings in storage cost. This cost re-duction is due to (1) TripleT uses just one B+tree, whereas MAP and HexTree both require three B+trees, and (2) the key size in TripleT is 1/3 that of MAP and 1/2 that of Hex-Tree, leading to significantly higher branching factor of the B+tree (and hence shallower trees).
 Comparing query performance. We measured the I/O cost for evaluating BGP join patterns between two SAPs. Since a join is induced by virtue of the SAPs sharing ei-ther an atom, a variable, or both, we considered four sub-scenarios, covering the basic ways in which SAPs may be joined: (1) computing the join of two variable-free SAPs having one atom in common, e.g., ( a , b , c )  X  ( a , d , e ); (2) com-puting the join of two SAPs having one atom in common, one SAP having a single variable and the other variable-SAPs having no atoms in common, each having a single variable, which they share, e.g., ( a , b , ? v )  X  (? v, c , d ); (4) computing the join of two SAPs having one atom in com-mon, each having one variable, which they also share, e.g., ( a , b , ? v )  X  ( a , c , ? v ). These scenarios cover the whole range of basic BGP join types, and were chosen to give the indexes a complete work out.

For each data set, for each size (1-6 million), we gener-ated ten random BGPs of each of these four scenarios, and measured their evaluation cost using MAP, HexTree, and TripleT. The average I/O costs are given in Figures 2(d)-2(f). We observe from these experiments that TripleT al-ways out-performed MAP and HexTree, with down to only 17.6% of their I/O costs for query processing. This perfor-mance improvement is due to (1) the smaller keyspace and size of TripleT, and (2) reduced lookup costs for some basic types of BGPs, due to stronger data locality. As demonstrated on both synthetic and real data sets, TripleT is multiple orders of magnitude smaller than MAP and HexTree, and exhibits significantly reduced I/O costs for join processing across the full range of RDF join patterns. Both of these improvements are due in large part to the improved data locality of the TripleT indexing scheme, as discussed above.

We have focused in this work on scalable indexing, specif-ically to support efficient join processing. Based on the re-sults of this study, there are several complementary direc-tions for further research on TripleT: (1) Recently a full-scale benchmark suite for RDF data management research has been developed [13]. Further analysis of TripleT on such benchmarks may suggest useful refinements or extensions of the data structure. (2) As a role-free approach to index-ing the relationships of data in an RDF graph, it might be profitable to store additional information in the TripleT payload structure. For example, we are currently investi-gating payload structures to efficiently support keyword and path queries [4] with TripleT. (3) Finally, we are currently investigating heuristics, statistics, and algorithms for BGP join-order optimization (e.g., [10, 14]), especially tailored for TripleT.
 Acknowledgments. We thank Sriram Mohan, Michael Schmidt, and Melanie Wu for their many helpful comments.
