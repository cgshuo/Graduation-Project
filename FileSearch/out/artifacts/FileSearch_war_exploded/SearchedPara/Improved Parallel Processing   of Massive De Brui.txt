 Whole Genome sequencing is one of the most fundamental problems in Biology. Since 1977, when Sanger sequencing method appeared, tens of thousands of genome sequence has been sequen c number of species that ne e shows that most of the d i results can lead to reveal t h genetic diagnosis, gene the r
Whole Genome sequen c sequence of short reads. amplification is referred t o randomly broken into man y read), the short read is the n Figure 1. The second step which is usually referred a to be is NP-hard [1], reduc e
There are two types of s model [2]. On an overlap g r edge between two reads i f exceeds a certain threshol d finding a Hamilton path t h [2]. Another model is base d cut into small fragments o f the graph. If there are k -1 c directed edge exists betwe e produce a corresponding p been transformed into find i the read path [4]. The pr o various lengths exist in t introduce errors into thes e sequencing machines. T h complicated. 
Many optimization criteria and heuristics have been presented to deal with assembly problem. Early, the length of fragments obtained by the Sanger sequencing already spent $3 billion in 3 years. More recently, genome sequencing entered in a era of large-scale applications due to the second-generation sequencing technology (also technology, namely, high throughput, short sequence and high coverage. For high-throughput sequencing, a sequencing machine can simultaneously sequence millions of reads, which greatly reduces the whole cost. For short sequence, it stands for that the sequence length is between 25-80 bp in general. In this regard, genome assembly With the increasing of the coverage, the total number of reads also increases greatly. reference genome. Therefore, in the face of the second generation of gene sequencing technology, De Bruijn graph model has a great advantage and become much popular. The proposed algorithms based n De Bruijn graph includes Euler[3], ALLPATHS[6], Velvet[7], IDBA[8], SOAPdenovo[9], ABySS[10] and YAGA[11]. Euler, ALLPATHS, Velvet and IDBA algorithms are serial algorithms, only suitable for small data sets. SOAPdenovo is multi-threaded SMP mainframe-based algorithm, which can process a large data set. But it also spends more than 40 hours on human genome [9] and the required infrastructure is very expensive. The main phases of genome assembly based on De Bruijn graph is as follows: First, De Bruijn graph construction. Second, errors correction. To remove the known compress a single chain in the De Bruijn graph into a single compact node, which also after constructed is extremely sparse, chain nodes ratio is more than 99% [12]. Bruijn graph by constructing a De Bruijn graph in distributed manner for the focuses on improving the efficiency of parallel graph simplification. The main contribution of this paper is to formulate the graph simplification problem into graph ranking problem with a total of four times global sorting and a multi-round recursion. node only once. Our algorithm has a computing complexity of p X / X  X  X  and communication complexity of  X  X  X  X  , which is smaller than YAGA algorithm, here g is the length of genome reference, p is the number of processors.
 construction. Section 3 describes parallel graph simplification. We show experimental results in section 4. Section 5 concludes this paper. We first explain the definition of De Bruijn graph. Then, in order to achieve efficient distributes the storage of the graph across multiple computational nodes. 2.1 Defining De Bruijn Graph Let s be a DNA sequence of length n , which is a sequence consists of the four bases, reverse sequence of  X   X  s complementary sequence (for example  X  X  X  X  X  X  X  , then then reversing and the resulted sequence. The complementary rules are  X   X T,T X  X  X : A,C  X  G,G  X  C X  . complementary. The notation  X  is the ordering relation between the two k -mers with corresponding k -molecule with an example. 2.2 Structure of De Bruijn Graph The node structure in our De Bruijn graph is different from the existing one of YAGA representation does not store edges explicitly. Let X  X  consider a De Bruijn graph node, which is a k -molecule (as shown in Figure 3). positive k -mer using the rule {A: 00, C: 01 G: 10 T: 11} (shown in Figure 4). In turn, the 64 bit unsigned integer forms the ID field (or simply ID) of the node. Since we have encode the low 2k bits of the ID. And the remaining high bits are filled with 0. bases {A, C, G, T}, a node can connect to eight adjacent nodes at most, corresponding edge. We use an 8-bit char type variable to store these edges. The bit with value of 1 indicates that the existence of this edge, otherwise, it means there is no corresponding corresponding to the A C G T; the after 4 bits represent the edges of negative k -mer, 4 to 7 corresponding to A C G T. For example, the node TAG owns three edges connected to three nodes (TTA AGT and TAG), as defined above, we use the positive k -mer TAG to represent the node. We set the third bit of arc field to 1. It means that CCT, for the number of the bit is the third and in the top 4. The edges record of node represent the existence of these edges. Accord ingly, only 9 bytes is used to store one node in our De Bruijn graph. 2.3 Parallel De Bruijn Graph Construction Algorithm given below. Step 1: Read short sequences in parallel. Step 2: Parallel segmentation of k -mers (see Figure 5). Step 3: Distribute all k -molecules. graph traversal starting from multiple sources in the graph. 3.1 The De Bruijn Graph Simplification Problem large number of erroneous paths, which give rise to three types of erroneous Figure 6. Therefore, after the De Bruijn graph construction, the immediate processing processing is to simplify the De Bruijn graph by finding all chains in the graph. After simplification, the size of the graph can be reduced sharply, almost about 90% off and the graph can be processed for latter tasks su ch as processing branches and repeats in a single machine easily. simplification algorithm, we assume the pr ocessing to remove erroneous connections notations and a detailed description of the problem. We call a node with a degree of 1 as the 1 degree node . A node with degree of 2, by an incoming edge and an outgoing edge, is called as the chain node . The chain node can lead to a chain. all nodes with a degree of 2, by two incoming edges or two outgoing edges, as well as all nodes with containing chain nodes only. Nodes at both ends of the chain are called as end node . Although an end node is not part of the chain, the chain can be obtained by traversal from it. In Figure 7, the green nodes are chain nodes, which are the target of simplification. traversed for it has two incoming edges or two outgoing edges. 3.2 Parallel De Bruijn Graph Simplification Algorithm Overview. Our algorithm directly traverses from an end node of a chain to the other end node to simplify the chain. 
Therefore, we use two threads for each processor, which collectively performs the chain, on the other hand, thread B is de dicated for inter-process communications. The requests on traversing end nodes. Data Structure. Each processor has two Maps. One is locationMap, which store nodes before simplification. Another is subGraphMap which stores nodes after identifying chains. Algorithm. Based on the above data structure, we outline the algorithm as below: 3.3 Analysis communication cost is very large. The computational complexity of four times global the cost of four times of global sort, the cost of other involved processing is also very large. 
In our algorithm, each processor directly traverses from the local end node to get all most. Also our algorithm successfully prevents a chain from being visited twice. So, each node is requested twice at most, the communication complexity is  X  X  X  X  . Our assembly software is written in C++ and MPI. The experimental platforms includes 10 servers interconnected by InfiniBand network, which is configured as 16-core, 32G shared memory. We choose Yeast and C.elegans genomes, using Perl scripts automatically generated yeast test data with 17, 007, 362 reads and C.elegans test data, which consists of 140, 396, 108 reads. The length of reads ranges from 36bp compaction on a large distributed De Bruijn graph. most part time on the third phase is network transmission cost. But, in our algorithms most nodes only be moved once, that is an efficient optimization. Figure 10 indicates about 8 times. total time is reduced from 3844s to 375s with the speedup being 10 times. We propose to use depth-first traversal over the underlying De Bruijn graph once By testing the two data sets, the experimental results show that the algorithm has great scalability. After the completion of the graph simplification, the scale of the graph is includes resolving branches and repeats using pair-end information in a single machine. We will study these problems in our future work. This work is supported by NSFC of China (Grant No. 61103049) and Shenzhen Internet Industry Development Fund (Grant No. JC201005270342A). The authors would like to thank the anonymous reviewers for their helpful comments. 
