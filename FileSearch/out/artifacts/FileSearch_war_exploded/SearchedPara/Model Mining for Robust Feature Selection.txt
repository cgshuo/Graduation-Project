 A common problem with most of the feature selection meth-ods is that they often produce feature sets X  X odels X  X hat are not stable with respect to slight variations in the training data. Different authors tried to improve the feature selec-tion stability using ensemble methods which aggregate dif-ferent feature sets into a single model. However, the ex-isting ensemble feature selection methods suffer from two main shortcomings: (i) the aggregation treats the features independently and does not account for their interactions, and (ii) a single feature set is returned, nevertheless, in var-ious applications there might be more than one feature sets, potentially redundant, with similar information content. In this work we address these two limitations. We present a general framework in which we mine over different feature models produced from a given dataset in order to extract patterns over the models. We use these patterns to derive more complex feature model aggregation strategies that ac-count for feature interactions, and identify core and distinct feature models. We conduct an extensive experimental eval-uation of the proposed framework where we demonstrate its effectiveness over a number of high-dimensional problems from the fields of biology and text-mining.
 I.5.2 [ Pattern Recognition ]: Design Methodology X  Fea-ture evaluation and selection Algorithms, Performance, Experimentation feature selection, stability, model mining, high-dimensional data, classification
High-dimensional datasets are becoming more and more abundant in the field of data mining. A traditional approach of tackling the high-dimensional learning problems is based on the application of feature selection methods to select a set of features X  X eature models X  X s small as possible that ac-curately describe the learning examples.

A common problem with most of the feature selection methods is that they often produce feature models that are not stable (or robust) with respect to slight variations in the training set. This can be problematic when we want to iden-tify a handful of features which are important for the given mining problem and present them to the domain experts together with quantifiable evidence of their robustness and stability. A typical application domain in which the stability and robustness of the selected features are of paramount im-portance is biology. The analysis of biological samples using high-throughput technologies produces learning instances of very high dimensionality, tens of thousands or even hun-dreds of thousands. Very often this high dimensionality is coupled with a limited number of samples. In such cases, the low stability of the selected features, often coupled with their weak discriminatory power, raises questions about the scientific significance of these discoveries [10, 9]. We can identify two sources of feature model instability. The first is a high level of feature redundancy (a situation that is very typical in biological problems); this can make the feature selection methods to produce unstable feature sets simply because they can select different features among the redundant features. In such cases very different feature sets can be equivalent predictors of some outcome because they describe different aspects of the same phenomenon. The sec-ond major cause of instability is the  X  X nderspecification X  in the sample space with respect to the feature dimensionality, a problem often described as the High Dimensionality Small Sample Size (HDSSS) problem. In the HDSSS setting we do not have adequate statistics, and very often slight varia-tions in the training data can produce radical changes in the feature models. For example, it was shown in [6] that for typical biological problems at least one order of magnitude more training instances are needed to reach an acceptable level of feature stability. However, the HDSSS problem is here to stay since sample availability is often limited due to unsurpassable practical constrains, while our ability to measure different variables is ever increasing.

A common approach to derive more robust feature sets is to use ensemble feature selection over bootstrap samples [18, 1, 9]. More specifically, the feature selection algorithm we want to  X  X tabilize X  is applied on a number of random sub-samples of the training data, and the different outputs are subsequently aggregated to produce a new, hopefully more stable, feature set. Almost all the existing algorithms focus on feature selection methods that produce feature rankings (or feature scores that can be trivially converted to rank-ings) and output an aggregated ranking, based on which the desired number of features can be finally selected. The existing aggregation strategies are most often based on the averaging of the individual rankings [18, 1], or the (soft) frequency of selection of individual attributes [15, 16, 9]. A common characteristic of all these methods is that they treat the features independently and do not consider feature interactions. Moreover, from the existing literature there is no consensus of whether the aggregated feature sets, in ad-dition to the boosted stability, also bring an improvement in terms of predictive performance.

Although the existing approaches based on ensemble fea-ture selection are conceptually simple and were shown to give rise to more stable feature sets they have two main limitations. First, as already mentioned, the aggregation operators are usually based on simple averaging techniques that consider attributes independently, and as such they of-ten generate  X  X rtificial X  structures that would not have been produced by the original feature selection method. For ex-ample average feature ranks produced over the models of a sparsity-imposed algorithm, such as LASSO, most likely do not correspond to any output of that algorithm [21]. In general, for feature models whose elements are generated independently from each other, such as the ones obtained by univariate feature selection methods, the standard tech-niques based on simple averaging are expected to be appro-priate. In cases where the components of the feature selec-tion models are not independent, a typical example of these are models produced by multivariate feature selection meth-ods, the simple strategies might not be sufficient, and other techniques that account for feature interactions is needed.
The second limitation is that the existing aggregation techniques return a unique feature model. Nevertheless, in problems with high levels of redundancy it might very well be the case that there are more than one feature sets, re-dundant between them, with similar information content. In such situations the domain experts might prefer the iden-tification of a number of alternative feature models , all of which describe different aspects of the same problem.
In this work we address these limitations and present a general framework in which we mine over feature models to extract feature patterns that we will use to derive more stable feature models and to identify distinct but equiva-lent, in terms of predictive behavior, feature models. We define aggregation operators over the feature models which we exploit to aggregate and summarize the different fea-ture models. The model aggregation operators we formalize range from the simplest strategies that treat attributes in-dependently, to the more complex ones that are structure-preserving and account for feature interactions. We perform an in-depth empirical study where we evaluate our frame-work on a number of biological and text mining datasets where we demonstrate the effectiveness of our approach. The remainder of this paper is organized as follows. In Section 2 we present the feature model mining framework. In Section 3 we present the experimental setup that we will use evaluate our framework, and in Section 4 we present the experimental results. In Section 5 we review the related work, and we summarize our work in Section 6.
In this section we present a general framework for feature model mining and describe a number of mining methods that operate over feature models. Our goal is to improve the stability and robustness of the feature selection as well as to provide the means to identify alternative feature selection models of equal quality.

We will first introduce some notation. Let D = { ( x 1 ,y ..., ( x n ,y n ) } be a labeled dataset, where x i  X  i -th instance and y i  X  Y its class label. Feature selection identifies the most important features so that instances can be represented in a lower dimensional space without a sig-nificant loss of discriminatory power; most often, the num-ber of desired features m is controlled by the user. Fol-lowing the ideas that appeared recently in ensemble feature selection [18, 9] we generate b base feature models from b bootstrap subsamples of D using a given feature selection method. These base models will become the target of the feature model mining that we will present soon. Feature selection models come roughly in the following three flavors:
In this work, we focus on the r and s representations; the output of a feature selection method that produces feature weightings can be always converted to a ranking. 1 We de-note by R = { r 1 ,..., r b } and S = { s 1 ,..., s b } the feature rankings and subsets produced from the b bootstrap sub-samples of the given dataset by the application of a given feature selection method. We will present a number of un-supervised feature model mining operators f which operate over R or S , in fact most of the methods that we will present will work with the S representation. The different operators will aggregate the base feature models, while taking into ac-count the feature model structures and systematically iden-tify alternative feature models. By feature model structures here we mean the specific combinations of features, reflecting feature interactions and dependencies, that different feature selection algorithms are able to uncover according to their underlying learning bias. The signature of the feature model mining operators will be: where F is either R or S , and k is a user specified parameter that defines the number of alternative feature models. We classify the operators to two groups according to the aggre-gation strategy they follow. In the first group, Single Model Aggregation , we have strategies that aggregate the different base feature models into a single model, i.e. k = 1. In the second group, Multiple Model Aggregation , we have strate-gies that produce a number of distinct models. [2] argues against directly aggregating weights X  X cores w i especially those that correspond to p -values of univariate statistical tests.
We will start with a description of the first group which is the one that contains most of the proposed strategies. We separate the strategies of this group to different cate-gories with respect to how they construct their final model, in terms of the model components of the base feature mod-els, and how close is the final solution they produce to those that the feature selection algorithm would have generated.
In this category we have just two strategies avgRank and mostFreq , that produce the final model by looking at the individual feature scores, obtained either from their ranks or from their frequencies. More precisely, in avgRank [18, 1, 2, 9] the score l of the l th feature is the average of its rankings, i.e. score l = P b i =1 r il . In mostFreq [15, 16, 9] we consider the frequency of the features that appear in S , i.e. score l = P b i =1 s il . In both cases, the final set of m features is selected according to their score l . These two strategies make no effort what so ever to capture feature model struc-tures since they treat the features independently. If one used a univariate feature selection to generate the base fea-ture sets this is no problem, since no such structure exists. However, if the base feature sets have been produced by a multivariate feature selection algorithm, then it is probable that the final feature set will not reflect particular feature combinations that have been found informative by the fea-ture selection algorithm since these aggregation strategies do not consider longer structures.

Here we consider strategies that search for frequent item-sets over the different base feature sets, and then establish the union of the most frequent itemsets, until the number of distinct features in the union reaches m , i.e. the desired feature cardinality. One can think this strategy as the com-bination of frequent  X  X odel fragments X  in to a final single feature model.

To limit the number of returned frequent itemsets, which depending on the dataset and the feature selection method can render the method computationally infeasible, we only focus on the frequent maximal [3] and closed [20] itemsets, giving respectively rise to the maxApr and closedApr strate-gies. An itemset is closed if no superset has the same sup-port, and maximal if no superset is frequent. We note that for a given support threshold we have FMI  X  FCI  X  FI, where FCI, FMI and FI are respectively the set of all the frequent closed, all the frequent maximal, and all the fre-quent itemsets. The elements in FCI that are not in FMI necessarily have non-lower support with respect to those of FMI, and hence are in general shorter than those of FMI. Additionally, the elements in FCI are more redundant (as measured by the average number of items they share) than the elements of FMI. Both maxApr and closedApr can be seen as an extension of mostFreq ; in the latter method the cardinality of the returned itemsets is trivially restricted to one and the threshold is specified not on the minimum sup-port but on the number of returned itemsets.

In this category we have a number of strategies which se-lect in a principled manner one of the base feature models, namely the most representative one. Clearly, the solutions fully reflect the learning bias of the feature selection algo-rithm that generate the base feature sets. The different ap-proaches rely on different combinations of frequent itemset discovery and clustering techniques.

The simplest strategy of this category is mostRep . Here, the final feature model is simply the median model of the set of base models S . We use the median instead of the aver-age because the former preserves the model structure since the median is actually an element of the underlying set. The underlying assumption of the mostRep strategy is that there is a meaningful median element over S . This is a valid as-sumption only if the feature models form a single unimodal cluster. However, in general we cannot assume that S has such unimodal structure. We thus introduce the largeMed strategy which uses the k -medoid clustering algorithm and the average silhouette criterion [12] to determine the best number of clusters and returns as the final feature model the medoid of the largest cluster. As before we rely in k -medoids instead of k -means because the averaging process does not necessarily preserve the feature model structures discovered by the feature selection algorithm. In this category we have two more strategies, medMaxApr and medClosedApr , which can be seen as the counterparts of maxApr and closedApr that preserve exactly the feature model structure of the fea-ture selection algorithm. Both of them define IS top as the set that contains the frequent feature sets with the top sup-port. Then, they determine all base feature models that are supersets of at least one element of the IS top , and constitute the S 0 set of base feature models. The final feature model is the median feature set of S 0 . In that sense these two strate-gies try to find the most representative base feature set using as initial seeds the most frequent feature itemsets.
Overall, what we have in the single model aggregation strategies is a spectrum of different approaches which are distinguished according to the degree to which they respect the structure of the original base feature models and the bias of the feature selection algorithm that produced them. At the lower end we have the Univariate Strategies ( US ) which completely ignore these using an univariate approach to select the features that will be included in the final fea-ture model. In the middle of the spectrum we have the Model Component Combination Strategies ( MCCS ) which detect frequent model fragments X  X ubsets of the base feature sets X  X hat appear frequently within the base feature sets and produce the final model by bringing together these model fragments. Finally, we have at the higher end the Exact Structure Preservation Strategies ( ESPS ) that output as a final model one of the base feature sets of S ; the methods of this group differ on how they select the prototypical feature set. The simplest method returns just the median of S , fol-lowed by the method that returns the median of the largest cluster, to the most complicated that return the median of the base feature sets that are supersets of the most frequent itemsets.
The aggregation strategies of this group take as input the base feature models and produce as output k different fea-ture models. The simplest strategy of the group, allMed , applies the k -medoid clustering algorithm on set of the base feature models S and returns the medoid of each cluster. Clearly, the cardinality of the k feature models is dictated by that of the base feature models, so if it is m for the latter, it will also be m for the former. In addition to the clustering-based approach we also have two of frequent pattern-based approaches. The first one, allClosedApr , produces as output k feature models that correspond to the k highest support frequent closed itemsets. 2 Unlike allMed here we do not have control over the cardinality of the aggregated feature sets. It might very well be the case that this cardinality will be quite low since we are selecting the top frequent itemsets; de-pending on the dataset and the value of k the most frequent itemsets can easily consist of only single items X  X eatures. In order to be able to better control the cardinality of the final feature sets we derive an alternative of this strategy which we name medClosedApr . Here instead of simply returning as feature sets directly the top k itemsets we first get all the base feature models from S that contain the itemset(s) with the highest support, and return the corresponding k medoids. Like that each aggregated feature model will now have as many features as the base feature models.
In this section we investigate the behavior and perfor-mance of the different model aggregation strategies presented in Section 2. We have two suites of experiments dealing with the single and multiple model aggregation strategies.
We start with the single model aggregation strategies and evaluate them, over a panel of datasets and feature selec-tion methods, both in terms of the stability of the aggre-gate feature models that they produce as well as in terms of the classification error they result to when these models are passed to a number of classification algorithms. Concretely, given a feature selection algorithm we generate b base fea-ture models which will then be aggregated into a single one by each one of the different aggregation strategies. On each one of the aggregated models we train a classifier using a given classification algorithm. One of the primary goals of these experiments is to see whether the model aggregation strategies that account for the base feature model structures can bring an improvement over the univariate aggregation strategies.

In the second suite of experiments we examine the behav-ior of the multiple model aggregation strategies. We evalu-ate them with respect to a number of dimensions, namely the diversity of the multiple feature models they produce, the average errors of classifiers trained on them using some given classification algorithm, as well as the prediction agreement of the produced classifiers. What we want to examine is whether using the multiple model aggregation strategies we can produce very diverse feature models, i.e. feature models that deliver different descriptions of the classification prob-lem, which give rise to accurate classifiers, i.e. the feature models are discriminatory, and that are  X  X emantically simi-lar X , i.e. deliver the same predictions when they are asked to classify the same instance.

We set the cardinality of the base and the aggregate fea-ture models m to 20. We performed additional experiments with different values of this parameter; however, these re-sults reveal similar trends. We set the number of boot-strap samples b to 150. We implemented feature aggregation
We also defined and experimented with a similar strategy obtained using the concepts of frequent maximal itemsets; however, its behavior was similar to that of allClosedApr . and performance computation (Section 3.1) using the R lan-guage.
To estimate the stability of feature models produced by a feature selection algorithm, or by a single model aggregation strategy coupled with a given feature selection algorithm, we compare the feature models generated over a number of vari-ations of the input dataset. In this study we opted for N-fold stratified cross-validation (CV) with N = 10, resulting in a set of N feature sets S 0 = { s 1 ,..., s N } . The different fea-ture models are cross-compared and the average similarity sim avg is computed: where sim (  X  ,  X  ) is a similarity measure between two feature models. In this work we follow [11] and define sim ( s i  X  f j | , where f i is a set of identifiers of selected features from s i and | X | denotes the set cardinality. The sim measure takes values in [0 , 1], zero when there is no overlap and one when the two sets are identical, and allows comparisons also between feature sets of different cardinalities. We also note that the performance measure (1) will be also used in the second set of experiments to measure the diversity of the feature models generated by methods from Section 2.2; in this case sim (  X  ,  X  ) will correspond to the average similarity between all the k feature models.

As already mentioned, to asses the predictive performance of a feature model aggregation method we estimate the error of a classification algorithm trained over the feature model produced by the given aggregation method. We estimate this performance measure using exactly the same fold sep-aration as the one in the 10-fold CV used in the stability estimation.

To quantify the predictive agreement of two classifica-tion models c 1 and c 2 trained over the same input dataset but using different feature sets we measure the percent-age of identical predictions over some test dataset D { x 1 ,..., x 0 l } . Concretely, we compute agree ( c 1 ,c bel assigned to the instance x 0 i by the c { 1 | 2 }  X  ( a,b ) = 1 if a = b , and 0 otherwise. The overall agreement of the k models produced by a multiple model aggregation strategy is then given by: The final agreement estimation is the average of (2) over the 10-CV folds (again, we have exactly the same folds as in the error and stability estimation).

We control the statistical differences of the errors of two methods using the McNemar X  X  test, and the paired T-test for the stability and prediction agreement; for all of them we set the significance level to 0.05. To acquire a better picture of the relative performances of the different methods we estab-lish a ranking schema for each one of the performance mea-sures based on the results of the pairwise comparisons. More precisely, if one method is significantly better than another one, it is credited with one point; if there is no significant difference then both are credited with 0 . 5 points; finally, if it is significantly worse it is credited with zero points. Clearly, the more points one method scores the higher its ranking will be. If we compare n different methods then the maxi-mum number of points that one can obtain is n  X  1 if it is significantly better than all the other methods; if there is no significant difference then each will get ( n  X  1) / 2 points.
We experiment with high-dimensional data from three application domains: proteomics, genomics and text min-ing. The proteomics datasets, ovarian , prostate , and stroke , are mass spectrometry datasets. The genomics datasets, leukemia , nervous , colon , are DNA-microarray datasets. The text mining datasets, disease, alt ernative, describe classifi-cations of sentences to relevant or non-relevant to given top-ics; features are word frequencies. The references to these datasets are in [11]. In Table 1 we give a short description of them.
To create the base feature models we will use the fol-lowing feature selection methods: Information Gain (IG) , Chi-Square (CHI) [5], Symmetrical Uncertainty (SYM) [5], ReliefF (RELIEF) [17], SVMRFE [7], SVMONE and Cor-relation Based Feature Selection (CFS) [8]. The first three methods are univariate feature selection methods; the re-maining are multivariate methods that are in principle able to detect and exploit feature interactions. RELIEF delivers a weighting of the features by computing distances among each of the training instances and their 10-nearest neigh-bors, and estimating the contribution of each feature in these distances. SVMRFE is based on repetitive applications of linear SVM where the P% lowest ranked features are elimi-nated at each iteration. The ranks of the features are based on the order in which they are eliminated and the weights assigned to them by the linear SVM . In our experiments we set P to 10% and the complexity parameter C of the linear SVM to 0.5. We also included a simple linear support vector machine ( SVMONE ) which is equivalent to SVMRFE with a single iteration. CFS evaluates the worth of a subset of attributes by considering the individual predictive ability of each feature along with the degree of redundancy between them. Subsets of features that are highly correlated with the class while having low inter-correlation are preferred. We note that CFS is the only method in this study which automatically determines the appropriate feature cardinal-ity and hence we do not control for the m parameter. We used the WEKA implementation of these algorithms.

Since, as we mentioned, feature selection and feature model aggregation methods do not deliver classification models we had to use classification algorithms in order to train from their results classification models that we can use to estimate the discriminatory power of the feature models that they produce. We have chosen the classification algorithms in Table 1: Statistics on the datasets. n , p and c denote respectively the number of training instances, data dimensionality and the number of classes.
 such a manner that they represent distinct learning paradigms. We experiment with Decision Tree (J48) , SVM and 1NN learning algorithms. We used the WEKA implementation of the algorithms; we set the parameters to default values, except for the C parameter of SVM which was set to 0.5.
We will first experiment with and study the performance of the different single model aggregation strategies, and then that of the multiple model aggregation strategies.
Each one of the single model aggregation operators was applied on the b base feature models produced by each one of the seven different feature selection algorithms over a given dataset. The resulting aggregated feature models were sub-sequently passed to the three classification algorithms in or-der to have an estimate of their discriminatory power. The results over the different classification algorithms do not dif-fer considerably so we will present only those of the SVM . We fix a feature selection algorithm and we rank the dif-ferent aggregation operators with respect to the predictive error of the SVM models produced over their respective ag-gregated feature models, and with respect to the stability of their aggregated feature models. Ranking is done as de-scribed previously according to the points accumulated in terms of the significant wins and losses. Since for a given feature selection method we are comparing eight aggregation operators, plus one baseline which is the plain application of the given feature selection method ( nobagg ), the maxi-mum number of points that one operator can score for a given dataset, if it is significantly better than all the rest, is eight; if there is no difference then everybody will all get four points.

In Table 2 we give these error and stability ranks for each aggregation operator averaged over all the different datasets with which we experimented. In this table the upper value in each cell is the error-based rank of the aggregation operator (indicated by the row) for the given feature selection algo-rithm (indicated in the column header); the bottom value is the respective stability rank. Clearly, error takes prece-dence over stability; a very high stability rank is useless if it is accompanied with a very low error rank.

Examining the averaged ranks (the last column of Table 2) we see that the best method in terms of its average error rank is closedApr that scores 5.6 points, followed by maxApr with 5.0 points, and mostFreq with 4.9; the latter has exactly the same number of points X  X ank X  X s the baseline method, nobagg . Essentially, the two strategies that manage to im-prove the predictive performance over the baseline are the two strategies that combine model components. When it comes to the average stability rank, the top ranked aggrega-tion operator is the mostFreq with 6.5 points, closely followed by closedApr with 6.3 points, and avgRank with 6.2 points; all three methods are better than the baseline in terms of the stability which scores 5.3 points. The four remaining ag-gregation operators, medMaxApr, medClosedApr, largeMed and mostRep , do not seem to bring any improvement nei-ther with respect to error nor to stability compared to the baseline method. Note that all of them are exact structure preservation operators, i.e. they return as the final feature model one of the b base feature models.

The difference in the performance, both in terms of error and stability, of closedApr and maxApr is puzzling since the two methods follow the same principle to produce the final feature set, i.e. the combination of frequent feature model components. Their only difference is that the first makes use of frequent closed itemsets, while the latter relies on fre-quent maximal itemsets. In order to try to understand this difference, we took a look at the number of top itemsets that each of the two methods needs to combine, in order to reach the desired number of m selected features, as well as the av-erage size and support of these itemsets. In Table 3 we give the results for the alt dataset; however, the patterns that we will right away describe are the same over the different datasets. First, observe that the average itemset cardinal-ity of the two methods is very similar: around 12 and 13 for the univariate feature selection methods, six to seven for the multivariate feature selection methods, and four to five for the CFS feature selection method. This difference between the univariate and multivariate methods is logical given the fact that univariate feature selection methods do not model for feature interactions and select a number individual (likely redundant) features with a similar (and potentially high) support from the b samples of the data; consequently, the combinations of these individual features will also have a high support. On the other hand, the multivariate methods exploit feature interactions and hence the selected subsets of features will have a lower support and will be shorter in length. The difference in support of frequent itemsets be-tween these two classes of feature selection methods can be observed in Table 3. The lowest average itemset cardinality for CFS could be explained by the fact in this algorithm we do not control for resulting feature cardinalities.
When we now look at the average number of itemsets that need to be merged in order to arrive at the desired number of features we see that maxApr gets there with much less itemsets, on average 20% of that closedApr needs. Thus, the itemsets produced by maxApr are much more diverse in terms of the features they contain compared to those of closedApr , which, as already mentioned in Section 2.1, is expected given that the itemsets produced by closedApr in-clude those produced by maxApr . In the former method the itemsets are variants around a core set of features which explains why it needs so many more itemsets to get to the desired number of features. This also gives us a hint on why there is a difference in performance between closedApr and maxApr : the former method aggregates shorter and more general core sets of features with a higher support, while maxApr aggregates longer sets of features that are placed  X  X ower X  in the apriori lattice, but which are nevertheless overly specific and do not  X  X eneralize X  well. The last col-umn in Table 3 demonstrates the lower average support of itemsets produced by maxApr in comparison with closedApr .
Overall, the two univariate aggregation operators achieve an important improvement over the baseline in terms of the stability of the final feature model they produce; how-ever, their predictive performance is the same, mostFreq , or even worse, avgRank , than the baseline. The operator that achieves the best predictive performance is closedApr ; Table 3: Averages of: number of frequent itemsets required to attain m distinct features, itemsets size, and support, for the alt dataset.
 its score is better than the baseline, and in addition it has the second best stability score very close to the best. So, overall it comes as the best strategy for feature model ag-gregation. Remember here that closedApr works by com-bining frequent model fragments into a single model, while the two univariate approaches examine each feature on its own. While the univariate approach can improve the stabil-ity, it fails to improve the predictive performance. For the latter capturing larger model structures seems to be more important. The performance of the operators that preserve exactly the feature model structure by picking one of the original base models is quite disappointing. All of them are worse than the baseline method. Among them the ones that combine frequent itemsets and then find the medoids, med-MaxApr and medClosedApr , have the worse performance. The two clustering medoid variants, largeMed and mostRep , fair a bit better, namely in terms of error, however their sta-bility is equally low. The low stability of the exact structure preserving variants can be explained by the fact that actu-ally they do not perform any kind of aggregation, but try to select among the base models the most representative one, however, by doing so the chances that there will be a larger overlap over the different final models are reduced.
We will now drill further down to the results given in Ta-ble 2 in order to get an idea of how the different model aggregation strategies fair with respect to the two distinct feature selection paradigms that we have here, namely uni-variate and multivariate. While the univariate aggregation strategy avgRank seems to have the strongest advantage in the case of univariate feature selection algorithm IG, this advantage is not persistent over the other two univariate feature selection algorithms, CHI and SYM. On the same time the mostFreq operator, while similar in spirit to av-gRank , does not perform particularly well with the univari-ate feature selection algorithms; for IG and CHI it has a performance that is worse than the baseline with respect to both error and stability. The closedApr performance with CHI and SYM is quite good both in terms of error as well as stability. When we examine the four multivariate feature se-lection algorithms we see that mostFreq has an excellent sta-bility performance with all of them, it is ranked top in three of the four. However, in terms of predictive performance it is quite poor, for three out of the four feature selection algo-rithms it is actually worse than the baseline. The closedApr has also a stability performance that is similar to that of mostFreq , however, in addition it also has a very good error performance, being better than the baseline method in all four multivariate feature selection algorithms, and the best in two of them.

Overall, while univariate feature aggregation strategies can improve the feature selection stability they fail to de-liver similar gains in terms of the predictive performance, compared to the baseline method with no aggregation. Ex-ploiting the feature model structure information, as it is done by the model component combination strategies, can improve not only the stability but also the predictive perfor-mance. However, what is important in the latter category is how these model components are discovered, as it is evident by the strong advantage of closedApr compared to maxApr .
We now turn to the experimentation with the multiple model aggregation strategies. We will examine the k multi-ple models that each strategy computes with respect to the accuracy they achieve, the agreement of their predictions, and their model similarity, i.e. the average number of fea-tures they have in common. We want to describe the degree to which we can have different feature models of good pre-dictive performance, that produce similar predictions, and have a relatively small feature overlap. The eventual goal is to provide the domain experts with a more global picture of the mechanism that underlines the training data, than what they would have obtained with a single feature set.
As in the first suite of experiments we evaluate each model aggregation strategy with each one of the seven feature se-lection algorithms. Subsequently, on each one of the feature models that a given aggregation strategy will output for a given feature selection algorithm, we train a classifier using a given classification algorithm. We report the prediction agreement of the resulting classifiers, computed by (2), their average accuracy, and the average feature model similarity, computed by (1). We estimate these quantities using 10-fold CV. We present the results for all three classification algo-rithms that we used. For all the model aggregation strategies we set the number of different models to k = 10. We per-formed additional experiments with different values of this parameter; however, these results reveal similar trends. For each model aggregation strategy and classification algorithm we highlight the feature selection algorithm that achieves the top rank according to the statistical significance tests over the different performance measures.

The results for the leukemia dataset are given in Table 4 (for other datasets similar trends hold). First, we notice that the multiple models generated by allClosedApr are of lower predictive performance, as measured by the average classification error, in comparison with the models obtained by the clustering-based allMed strategy; the classification error for allClosedApr is on average three times higher than for allMed . As already noted in Section 2, this is a result of the fact that unlike allMed , in allClosedApr we do not control for the cardinality of the aggregated feature sets. In the examined dataset this cardinality is low which naturally leads to low discriminatory power of the feature models; in fact, most of the top frequent itemsets are of cardinality just each strategy and classifier, for each performance measure. one. The low cardinalities of the resulting multiple models in allClosedApr have also a direct effect of the prediction agreement and the average model similarity, which are con-sistently lower than it is the case for allMed . The second observation is that the performance of medClosedApr , as measured by the three evaluation metrics, is very similar to that of allMed . This a consequence of the fact that a number ( k = 10) of (frequent closed) itemsets with high-est support is contained in a large fraction of base feature models, and hence the input the k-medoids algorithm in both allMed and medClosedApr is similar, resulting in simi-lar medoids generated by these strategies. Finally, we note the good performance of SVM coupled with allMed with re-spect to both agreement and error, and an acceptable level of model similarity. In particular coupling allMed , SVM and SVMRFE , it is possible to generate quite diverse feature signatures (average model similarity of 0.21) which never-theless give rise to powerful (classification error of 0.03) and  X  X emantically similar X  (prediction agreement of 0.98) mod-els. The classification error of SVM coupled with allMed is not statistically different compared to the corresponding baselines in which we only do standard feature selection and classification (these results are not reported in Table 4).
The traditional approach to stabilize feature selection al-gorithms in learning problems with redundant features fo-cuses on selecting relevant and non-redundant feature sub-sets in a pre-processing step; examples include CFS and Markov blankets. [19] addressed the redundancy problem by grouping correlated features together and treating these groups as the entities over which feature selection will take place; this work was refined in [14]. A related idea was proposed in [21] where the authors identified the problem of instability of LASSO for problems with high feature cor-relations, and proposed a regularization technique based on mixing different norms ( X  X lastic nets X ). All these approaches return a unique set of features. However, in many applica-tions, as argued in this paper, it is more beneficial to be able to identify alternative but equivalent solution sets.
The main difference between the methods from [19, 14, 21] and our framework is that the former consider, explic-itly or implicitly, groups of redundant features, which are in-cluded or excluded from the model simultaneously, whereas we aim at explicitly providing domain experts with groups of features that account for different aspects of a problem at hand. Moreover, the approaches from [19, 14, 21] con-sider specific notions of feature redundancy (e.g. the linear correlation in [19]), whereas our framework is more flexi-ble as the notion of redundancy varies and depends on the feature selection algorithms (it is the linear correlation only for CFS ). Finally, the previous works select the individual subsets within a specialized feature selection algorithm (e.g. regression regularized with the mixed norms [21]), while we identify the different solutions a-posteriori, based on sets of features which can be generated by using virtually any fea-ture selection method.

As already mentioned, in the context of ensemble feature selection, the most popular methods are univariate aggre-gation strategies. Two more complex exceptions were pre-sented in [4] and [13], both aggregating elements of R . The former method is inspired by the well known PageRank al-gorithm and can be seen as a direct extension of mostFreq where all the pairs of top ranked features are considered, and the appearances of the different pairwise feature rela-tionships (feature a ranked before feature b , or vice versa) are counted. These counts give rise to the corresponding frequencies, based on which the final aggregate ranking of attributes is generated. Our aggregation strategies based on frequent itemsets are considerably more general as they can account for higher-order feature interactions (see Ta-ble 3). The method from [13] is similar to mostRep as it looks for a feature model whose weighted distance to all the input models is minimal; the returned ranking does not nec-essarily appear in the set of input transactions. The authors consider two different distance measures over rankings and weight the elements by various performance measures. In this study we have shown that the single model aggregation strategies based on clustering do not fare well in comparison with the other proposed strategies. We also note that the methods from [4, 13] give rise to an aggregate ranking only for the most discriminating features.
In this paper we presented a general framework in which we mine over different feature models produced from a given dataset in order to extract patterns over the models. We use these patterns to derive more complex feature model aggregation strategies that account for feature interactions, and identify core and distinct feature models.

We empirically examined our framework on a number of high-dimensional datasets. The empirical evidence suggests that our framework is effective in comparison with the exist-ing aggregation techniques. We demonstrated that the exist-ing univariate aggregation techniques, although appropriate in many cases, are not the best solutions overall. While univariate feature aggregation strategies can improve the feature selection stability they fail to deliver similar gains in terms of the predictive performance, compared to the baseline method with no aggregation. Exploiting the fea-ture model structure information, as it is done by the model component combination strategies, can improve not only the stability but also the predictive performance. What is how-ever important is how these model components are discov-ered, as it is evident by the strong advantage of closedApr compared to maxApr . We also observed the poor perfor-mance of the operators that preserve exactly the feature model structure by picking one of the original base models. Overall, we recommend the closedApr aggregation strategy that provides a good compromise between the stability and predictive performances. When it now comes to the multi-ple models aggregation strategies we demonstrated that it is possible to construct distinct feature models of good pre-dictive performance, that produce similar predictions, and have a relatively small feature overlap. Such diverse and yet equivalent feature models describe different aspects of the same problem, and hence provide domain experts with a more global picture of the mechanism under study. We recommend the allMed technique that is based on the k-medoids clustering algorithm and hence easy to implement.
This work was partially funded by the European Com-mission through EU projects DebugIT (FP7-217139) and e-LICO (FP7-231519). The support from the COST Action BM072 ( X  X rine and Kidney Proteomics X ) is also gratefully acknowledged. [1] T. Abeel et al. Robust biomarker identification for [2] A.-L. Boulesteix and M. Slawski. Stability and [3] D. Burdick, M. Calimlim, and J. Gehrke. Mafia: A [4] R. P. DeConde et al. Combining results of microarray [5] R. Duda, P. Hart, and D. Stork. Pattern Classification [6] L. Ein-Dor et al. Thousands of samples are needed to [7] I. Guyon, J. Weston, S. Barnhill, and V. Vapnik. Gene [8] M. A. Hall. Correlation-based Feature Subset Selection [9] A.-C. Haury, P. Gestraud, and J.-P. Vert. The [10] J. P. Ioannidis. Microarrays and molecular research: [11] A. Kalousis, J. Prados, and M. Hilario. Stability of [12] L. Kaufman and P. J. Rousseeuw. Finding Groups in [13] S. Lin and J. Ding. Integration of ranked lists via [14] S. Loscalzo, L. Yu, and C. Ding. Consensus group [15] M. S. Pepe et al. Selecting differentially expressed [16] X. Qiu, Y. Xiao, A. Gordon, and A. Yakovlev.
 [17] M. Robnik- X  Sikonja and I. Kononenko. Theoretical and [18] Y. Saeys, T. Abeel, and Y. Van de Peer. Robust [19] L. Yu, C. Ding, and S. Loscalzo. Stable feature [20] M. J. Zaki. Generating non-redundant association [21] H. Zou and T. Hastie. Regularization and variable
