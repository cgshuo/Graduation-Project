 1. Introduction  X 
Q=//book[author=  X  Chen  X  ]//chapter/title  X  can be represented as a twig (small tree) pattern. Intuitively, it returns the named by  X  Chen  X  .

In practice, XML data may be very large, complex and have deep nested elements. Thus, ef have been proposed to match such twig patterns. These approaches (i) labels of two elements, one can identify the ancestor  X  descendant, parent other useful information is provided .
  X  0.5.1.1  X  as an example again. Since we see that its path is determine whether this path matches a path query (e.g.  X  // section / text provides us an extraordinary chance to develop a new ef fi descendant edges, TwigStack guarantees that each intermediate path solution contributes to individual path expressions which do not contribute to fi develop more powerful labeling schemes to speed up the ef four algorithms and their properties.  X  queries with wildcards in internal nodes.  X  patterns (GTP [5,9] ). In order to ef fi ciently answer GTP, we propose GTJFast to ef the I/O cost.  X 
GTJFastTL algorithms guarantee the optimality for queries with only parent results and query performance . 1.1. Organization concludes the paper. 2. Preliminaries 2.1. Data model and XML twig pattern
The query twig pattern edges are either parent  X  child or ancestor query and data nodes by using the term  X  node  X  to refer to a query node and the term document.

Given a query twig pattern Q and an XML document D , a match of Q in D is identi elements in D , such that: (i) the query node predicates are satis can match any single tag; and (ii) the parent  X  child and ancestor 2.2. Dewey ID labeling scheme
Dewey ID , each element is presented by a vector: (i) the root is labeled by a empty string label ( s ). x , where u is the x -th child of s . Dewey ID supports ef is, element u is an ancestor of element s if and only if label ( u ) is a pre labeled  X  1.2.3.4  X  , then the parent of u is  X  1.2.3  X  and the grandparent is directly reduced to string matching . For example, if we know that the label straightforward to identify whether the element matches a path pattern (e.g. (and twig) pattern. 3. Extended Dewey and FST easily extended to multiple documents by introducing document ID information. 3.1. Extended Dewey sequence of integers, we can convert it into the sequence of element names. clue before labeling the XML document. In addition, in the case that speci
Schema are used to allow appearance of any tag names de fi schema to understand the child names clue . The whole XML document has to be scanned to hidden in  X  ANY  X  speci fi cation.
 easily create a mapping from an integer to an element name. Suppose CT ( t )={ t assign an integer x i to e i such that x i mod n = i . Thus, according to the value of x
CT ( book )={ author , title , chapter }. Suppose e i is a child element of book and x
The extended Dewey label of each element can be ef fi ciently generated by a depth -de with parent s in an XML tree,  X  (1)  X  if u is a text value, then x = tag in CT ( t s )( k  X  {0,1,..., n  X  1 }), where t s denotes the tag of element s . (2.1) if u is the fi rst child of s , then x = k ; order traversal of the tree. For instance, the label of chapter under book( third tag in its child names clue, starting from 0), y =4 (for the last component of x =4 = 3 3 + 2 = 5. So chapter is assigned the label  X  0.5 the book. Our function for label generation explicitly considers the order of sibling nodes. We show space complexity of extended Dewey using the following theorem. the labels for every two neighboring elements under s is no more than | CT ( t the length of each component i of extended Dewey label is at most log
Since m and | CT ( t s not alter asymptotic space complexity of the original Dewey. 3.2. Finite state transducer
Given the extended Dewey label of any element, we can use a which will be used to de fi ne FST.

De fi nition 3.3. (Function F ( t , x )) Let Z denotes the non-negative integer set and
XML document T . Given an tag t in T , suppose CT ( t )={ t k = x mod n .

De fi state i is the tag of the root in the document; (iv) the state transition function
Dewey label, but independent of the complexity of schema de 3.3. Dynamic XML labeling
Assuming a DTD is a  X  ( b | c ) , for instance, considering an XML document with the root a respective extended Dewey labels are assigned 1, 2 and 4 ( a 1, 3 and 7 instead. If a new element b 2 is inserted between c component that increases the depth of the node in the tree.
 label ( s ). x ,where s is the parent of u .Foranyelement u with parent s in an XML tree, ( k  X  {0,1,..., n  X  1 }), where t s denotes the tag of element s . (2.1.) if u is the fi rst child of s , then x =2 k +1; fi ancestry: 3.5.6.2.1 is a child of 3.5, and a grandchild of 3.
 suppose CT ( t )={ t 0 , t 1 ,  X  , t n  X  1 }, a dynamic function DF ( t , x ): denote the integer set. DFST is a 5-tuple ( N , S , i ,  X  state transition function  X  is de fi ned as follows. For  X  root is a , given a label 3, k =3 mod (2*2)=3, then t (3+1)/2 existing labels remain the same with any insertion of sequence. 4. Twig pattern matching 4.1. Path matching algorithm tags appear in leaf node of query . For each visited element, we then perform string matching against it. As a result, we evaluate the path pattern ef ensure that each output solution is our desired fi nal answer. ef fi ciently by simply comparing element names. When path queries contain ancestor 4.2. Twig matching algorithm results. We will fi rst introduce some data structures and notations. 4.2.1. Data structures and notations
Let Q denote a twig pattern and p n denote a path pattern from the root to the node n of the following query node operations: isleaf: Node  X  Bool; isBranching: Node
Associated with each leaf node f in a query twig pattern there is a stream T  X  1.2  X  precedes  X  1.3  X  and  X  1.3  X  precedes  X  1.3.1  X  . The operations over a stream T current element of the stream T f to be its next element. The function eof ( T ancestors and descendants of e , respectively (both including e ).
Algorithm TJFast keeps a data structure during execution: a set S an ancestor  X  descendant or parent  X  child relationship. So the maximal size of S document. Each element cached in sets likely participates in query answers. Set S
Algorithm 1 TJFast. 1: for each f  X  leafNodes(root) do locateMatchedLabel( f ) 2: while ( X end(root)) do 3: f act =getNext( topBranchingNode ) 4: outputSolutions( f act ) 5: advance( T fact ) 6: locateMatchedLabel( f act ) 7: end while 8: mergeAllPathSolutions()
Procedure locateMatchedLabel( f ) /* Assume that the path from the root to element get( T f node f */ 1: while  X (( n 1 / n 2 /  X  / n k matches pattern p f )  X  ( n 2: advance( T f ) 3: end while
Function end ( n ) 1: Return  X  f  X  leafNodes ( n )  X  eof ( T f )
Procedure outputSolutions( f ) 1: Output path solutions of current ( T f )topattern p f such that in each solution s , b  X  e  X  S b ) 4.2.2. TJFast next stream T f matches any branching node b can be found in the corresponding set S element in line 8. 1
Algorithm 2 getNext(n). 1: if (isLeaf( n )) then return n 2: else for each n i  X  dbl( n ) do 3: f i = getNext ( n i ) 4: if ( isBranching ( n i )  X  empty ( S ni )) then return f 5: e i = max { p | p  X  MB ( ni , n )} 6: max= maxarg i { e i } 7: min= minarg i { e i } 8: for each n i  X  dbl( n ) do 9: if (  X  e  X  MB ( n i , n ): e  X  ancestors ( e max )) then return f 10: for each e  X  MB( n min , n )do 11: if ( e  X  ancestors ( e max )) then updateSet( S n , e ) 12: return f min
Function MB( n , b ) 1: if (isBranching( n )) then Let e be the maximal element in set S 2: else Let e =current( T n )
Procedure clearSet( S , e ) 1: Delete any element a in the set S such that a  X  ancestors(e) and a
Procedure updateSet( S , e ) 1: clearSet( S , e ) 2: Add e to set S identify the next stream to process; and the second is to update the sets S the currentelementscannot forma matchfor thesubtree rooted with n from stream T f otherwise we return f min such that the current element e output in Procedure outputSolutions . In line 18 of Algorithm 2, before an element e ancestor of (or equals) each other element e b easy reference. There are three input streams T b , T f and T c  X  and e min =f in line 10 and 11 of Algorithm 2. In line 18, c and getNext (a)=b. Finally path solutions ( a 1 , b 1 ),( a e , g 1 ) matches the individual path pattern a // c // e / g , it is not output for c 4.3. Analysis of TJFast Next, we fi rst show the correctness of TJFast and then analyze its complexity. with the new inserted element e new , according to the Order Property, label( e )
Lemma 4.3. In line 18 of Function getNext, if element e  X  solution.

Proof. ( Induction on the number of calls to getNext ): Consider the empty before this call. Since element e is not a pre fi xof e e , e cannot involve in the solutions of the future elements in stream T solution for the previous elements. But now e does not appear in set S shows that for any element e that matches a branching node, if e participates in any theorem.
 descendant relationships between branching nodes and their children.
Theorem 4.5. Consider an XML database D and a twig query Q with only ancestor the longest label in the input lists .
 edges are only ancestor  X  descendant relationships, then in line 18 of getNext , since e n  X  intermediate path solution output in TJFast is guaranteed to contribute to descendant relationships in branching edges.  X  its pre fi x, the total space complexity of S b is O( d 2 longer guaranteed to be I/O optimal. For example, consider a query b , a 2 , c 2 , such that a 2 has children b 2 , c 1 . There are two streams T solution. Thus, optimality can no longer be guaranteed. 5. Generalized tree pattern matching 5.1. Generalized tree pattern pattern. Fig. 6 depicts two sample XQuery statements and their respective GTPs.
Next we propose a new holistic algorithm, called GTJFast, to ef 5.2. GTJFast algorithm
GTP, and then formally show our algorithm GTJFast followed by theoretical analysis. 5.2.1. Optimization on non-return nodes and compactly record the existences of non-return elements.
 properties. 5.2.2. Optimization on optional return nodes 5.2.3. Algorithm the corresponding relationship (P  X  CorA  X  D relationship) between c and b is satis outputList(e) is a potential fi nal resultrelated to e , where b in the following example.

Example 5.1. Seethequeryand exampledocumentin Fig. 7 , theBitArrayof a children b 1 and c 2 . Since c is the return node, a 1 is associated with c nodes are accessed, and the partial matching results are maintained in sets, and
However, the differences between GTJFast and TJFast are summarized as follows.
Algorithm 3 GTJFast. 1: for each f  X  leafNodes(root) 2: locateMatchedLabel( f ) 3: endfor 4: while ( X  end ( root )) do 5: f act =getNext( topBranchingNode ) 6: advance( T fact ) 7: locateMatchedLabel( f act ) 8: end while 9: emptyAllSets(root); 10: mergeAllPathSolutions();
Procedure emptyAllSets( q ) 1: if ( q is not a leaf node) then 2: for each child c of q do 3: emptyAllSets( c ); 4: end for 5: end if 6: for Each element e in Sq do 7: emptySet( q , e ); 8: end for
Procedure emptySet( q , e ) 1: if (all bits in BitArray( e ) are  X  1  X  ) then 2: if ( q is an output node) then 3: Add e to the output list of the nearest ancestor branching node of q ; 4: end if 5: if ( q is the top branching node) then 6: output the outputList( e ); 7: end if 8: end if are scanned, and c 1 is return from getNext. As b 1 has two children, its bitArray is its existence is recorded in a 1 (10), which shows that the subtree rooted with b is transferred to S a . As the BitArray of a 1 is  X  11  X  . g query path pattern.
 Algorithm 4. updateSet(S, e).

Procedure updateSet( S , e ) 1: clearSet( S , e ); 2: add e to set S ; 3: Assume that the query node type of S is q ; 4: for  X  q  X  , s.t. q  X  is a child of q do 5: if (  X  e  X  with type q  X  s.t. e  X  satisfy the relationship between q and q 6: BitArray( e , q  X  )=1; 7: else BitArray( e , q  X  )=0; 8: end for 9: if (all bits in BitArray( e ) are  X  1  X  ) then 10: if ( q is not the top branching node) then 11: updateAncestorSet( q , e ); 12: else 13: output the outputList( e ); 14: end if 15: end if
Procedure updateAncestorSet ( q , e ) 1: Assume the nearest ancestor branching node of q is q  X  2: for any element e  X  in S q  X  do 3: if (BitArray( e  X  , q )==  X  0  X  ) then 4: Set BitArray( q  X  , q )be  X  1  X  ; 5: Add all elements in outputList( e ) to outputList( e 6: if ((all bits in BitArray( b ) are  X  1  X  )  X  (q is not the top branching node)) then 7: updateAncestorSet ( q  X  , e ); 8: end if 9: end if 10: end for 5.3. Analysis of GTJFast preliminary lemma.

Lemma 5.3 . In Algorithm GTJFast, suppose any element e is removed from set S all bits in BitArray ( e ) are  X  1  X  .

Proof. In Procedure updateSet of Algorithm GTJFast, when any new element e is inserted to S of children of q , if and only if there is an element e  X  (lines 4  X  10). Therefore, when all bits of BitArray( e ) are following result.

Proof. In Procedure clearSet of Algorithm GTJFast, any element e that is deleted from set S belong to fi nal query answers by Lemma 5.3 , as all bits in BitArray( e ) are algorithm.  X  guarantees that each output path solutions belong to fi nal answers.
Theorem 5.5. Consider an XML database D and a generalized tree query Q with only ancestor and d is the length of the longest label in the input lists .
 space and I/O cost is no greater than GTJFast in the worst case. longest label in the input lists, and | L | is the number of leaf nodes in Q . cost of GTJFast is often smaller than state-of-the-art algorithm Twig the worst case. 5.4. Comparison between GTJFast and Twig 2 Stack intermediate results for a large class of queries as shown in Theorem 5.5 . But Twig and practice with respective to the case of small memory.

Twig 2 Stack needs to buffer all b 1 to b n and c 1 to c m
Therefore, although the worst case of both GTJFast and Twig 6. Tree pattern matching on tag + level by introducing our motivation. 6.1. Motivation the example XML data and their fi rst elements are c 1 and d current cursors point to all four elements c 1 , c 2 , d 1 and level numbers . 6.2. Level pruning fi streams: ( c ,2),( c ,3),( c ,4), ( d ,2),( d ,3), where the
It turns out that when the twig query contains more parent level pruning.
 6.3. Holistic algorithms TJFastTL and GTJFastTL based on tag+level results. 6.3.1. Query with only parent  X  child edges any query solution.

Algorithm 5 Level pruning. level numbers that likely participate in query answers.*/ 1: pruneParent(root) 2: pruneChildren(root)
Procedure pruneParent( n ) 1: if isLeaf( n ) then return 2: for n i  X  childNodes( n ) do 3: pruneParent( n i ) 4: if ( ni, n ) is a parent  X  child edge then 5: delete elements in levels ( n ) that cannot fi nd child level in levels ( ni ) 6: else 7: delete elements in levels ( n ) that cannot fi nd descendant level in levels ( n 8: end if 9: end for
Procedure pruneChildren( n ) 1: if isLeaf( n ) then return 2: for n i  X  childNodes( n ) do 3: if ( n i , n ) is a parent  X  child edge then 4: delete elements in levels ( n i ) that cannot fi nd parent level in levels ( n ) 5: else 6: delete elements in levels ( n i ) that cannot fi nd ancestor level in levels ( n ) 7: end if 8: pruneChildren( n i ) 9: end for branching node n , we do not use max function and directly let e element. Recall that Algorithm TJFast (and GTJFast) can only ensure that all e node n in the path solutions of current element of each stream T (and GTJFastTL) guarantees that each intermediate path solution contributes to
Algorithm 6 getNext of TJFastTL and GTJFastTL. /* This following algorithm is used to evaluate query with only parent
Function getNext(n) 1: if (isLeaf( n )) then 2: return n 3: else 4: for each n i  X  dbl( n )do 5: f i = getNext ( n i ) 6: if ( isBranching ( n i )  X  empty( S n 7: return f i 8: e i = MB ( n i , n ) 9: end for 10: max= maxarg i { ei } 11: min= minarg i { ei } 12: for each n i  X  dbl( n ) do 13: if (  X  e  X  MB ( n i , n ): e  X  ancestors ( e max )) 14: return f i 15: endif 16: end for 17: if ( e min == e max ) updateSet( S n , e min ) 18: return f min 19: end if 6.3.2. Query with parent  X  child and ancestor  X  descendant edges
To evaluate a query with both parent  X  child and ancestor this new scenario. 6.4. Analysis of TJFastTL and GTJFastTL
In the section, we show the correctness of TJFastTL and GTJFastTL to analyze the ef QonD.

Proof. There are two cases. (1) When queries contain only parent
S
The correctness is obvious if the original algorithms are correct. optimal class of TJFast by including queries with only parent
Theorem 6.2. Consider an XML database D and a tree query Q with (i) only parent in the sum of the sizes of input and output lists .
 query class to guarantee the I/O optimality than TJFast ( GTJFastTL ). 7. Experimental evaluation 7.1. Experimental setup 7.1.1. Testbed and data set [26] , iTwigJoin [10] and Twig 2 Stack [8] in JDK 1.4 using the use region encoding labeling scheme.

Twig 2 Stack are ef fi cient for different applications. TwigStack [5] is very ef relationships. TwigStackList [26] is ef fi cient on answering queries with parent Twig 2 Stack [8] is proposed to process generalized XML tree pattern queries. characteristics of each data set.
 7.1.2. UTF-8 encoding compressed binary representation. In particular, we used UTF-8 encoding as an ef (2 7.1.3. Labels size
We compare the labels size of four labeling schemes in Table 3 . From this table, our 10% since it helps to improve the performance of XML twig pattern matching. 7.2. Performance analysis 7.2.1. Path queries branching nodes. For this purpose we fi rst use XMark benchmark data and four path queries algorithms in Fig. 11 (a, b).

An immediate observation from the fi gures is that TJFast is more ef 400% more disk I/Os than those required by TJFast (e.g. PQ2). times of both techniques, as well as the number of elements read and the size of disk better performance than PathStack. The performance of PathStack degrades signi that of TJFast is almost not affected at all. 7.2.2. Twig query pattern while TQ4 contains only parent  X  child relationships. TQ3 contains only ancestor node and its children, but TQ5 contains both parent  X  child and ancestor Number of elements read (thousand) Query Number of elements read (million) Query path length and the size of intermediate results . solutions when query contains parent  X  child edges. For example, in TQ only 22,565 are useful. More than 95% intermediate solutions output by TwigStack are number of useful solutions. fact that TJFast reduces the I/O cost of TwigStackList by reading labels of only leaf nodes. combine PPS data partition with our extended Dewey labeling scheme in this paper. TJFastTL than that of TJFast in Fig. 14 (b).
 con elements than Twig 2 Stack for seven twig queries, which is easily to understand, as Twig we TJFastTL is always the win ner in this competition. Twig 2 signi fi cantly reduce I/O cost.
 explore. 7.2.3. Generalized XML Tree queries axis. 7.2.3.2. GTJFastTL vs. Twig 2 Stack. Finally, we compare GTJFastTL with Twig many useless elements. 7.2.4. Summary
According to the experimental results, we draw the following three conclusions. elements for all internal query nodes is very small.
BitArray to maintain the intermediate matching results to signi 8. Related work and deleting data.
 iTwigJoin can be applied on different data partition strategies (e.g. Tag+Level and Pre generalholisticalgorithmcalledTSGeneric+basedonindexesbuiltonelementlabels.Theirmethodcan sub-linear performance for selective queries. But for evaluating queries with parent et al. [11] proposed a bi-labeling scheme: D-Label and P-Label for accelerating parent did not fully explore the nice property of Dewey labels and only modi their algorithm is still not ef fi cient for processing queries with parent queries (i.e. queries which only require to return output nodes) with P
A  X  are time consuming. 9. Conclusions and future work pre fi
Exciting follow-up research can be centered around improving ef indexing data introduces more cost on index storage and internal nodes traversal. Our create a smaller B+tree. The current preliminary idea is to mine twig query log to work.
 Acknowledgement
References
