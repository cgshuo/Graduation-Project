 We present Tweet2Vec , a novel method for generating general-purpose vector representation of tweets. The model learns tweet embeddings using character-level CNN-LSTM encoder-decoder. We trained our model on 3 million, randomly se-lected English-language tweets. The model was evaluated using two methods: tweet semantic similarity and tweet sen-timent categorization, outperforming the previous state-of-the-art in both tasks. The evaluations demonstrate the power of the tweet embeddings generated by our model for various tweet categorization tasks. The vector representations gen-erated by our model are generic, and hence can be applied to a variety of tasks. Though the model presented in this pa-per is trained on English-language tweets, the method pre-sented can be used to learn tweet embeddings for different languages.
  X  Information systems  X  Document representation;  X  Computing methodologies  X  Neural networks; In-formation extraction; Lexical semantics; Twitter; Embedding; Tweet; Convolutional Neural Networks; CNN; LSTM; Tweet2Vec; Encoder-decoder
In recent years, the micro-blogging site Twitter has be-come a major social media platform with hundreds of mil-lions of users. The short (140 character limit), noisy and idiosyncratic nature of tweets make standard information re-trieval and data mining methods ill-suited to Twitter. Con-sequently, there has been an ever growing body of IR and data mining literature focusing on Twitter. However, most of these works employ extensive feature engineering to create The first two authors contributed equally to this work. task-specific, hand-crafted features. This is time consuming and inefficient as new features need to be engineered for ev-ery task.

In this paper, we present Tweet2Vec , a method for gen-erating general-purpose vector representation of tweets that can be used for any classification task. Tweet2Vec removes the need for expansive feature engineering and can be used to train any standard off-the-shelf classifier (e.g., logistic re-gression, svm, etc). Tweet2Vec uses a CNN-LSTM encoder-decoder model that operates at the character level to learn and generate vector representation of tweets. Our method is especially useful for natural language processing tasks on Twitter where it is particularly difficult to engineer features, such as speech-act classification and stance detection (as shown in our previous works on these topics [13, 12]).
There has been several works on generating embeddings for words, most famously Word2Vec by Mikolov et al. [9]). There has also been a number of different works that use encoder-decoder models based on long short-term memory (LSTM) [11], and gated recurrent neural networks (GRU) [1]. These methods have been used mostly in the context of machine translation. The encoder maps the sentence from the source language to a vector representation, while the de-coder conditions on this encoded vector for translating it to the target language. Perhaps the work most related to ours is the work of Le and Mikolov [7], where they extended the Word2Vec model to generate representations for sentences (called ParagraphVec ). However, these models all function at the word level, making them ill-suited to the extremely noisy and idiosyncratic nature of tweets. Our character-level model, on the other hand, can better deal with the noise and idiosyncrasies in tweets. We plan to make our model and the data used to train it publicly available to be used by other researchers that work with tweets.
In this section, we describe the CNN-LSTM encoder-decoder model that operates at the character level and generates vec-tor representation of tweets. The encoder consists of convo-lutional layers to extract features from the characters and an LSTM layer to encode the sequence of features to a vec-tor representation, while the decoder consists of two LSTM layers which predict the character at each time step from the output of encoder.
Character-level CNN (CharCNN) is a slight variant of the deep character-level convolutional neural network intro-duced by Zhang et al [15]. In this model, we perform tem-poral convolutional and temporal max-pooling operations, which computes one-dimensional convolution and pooling functions, respectively, between input and output. Given a discrete input function f ( x )  X  [1 ,l ] 7 X  R , a discrete kernel function k ( x )  X  [1 ,m ] 7 X  R and stride s , the convolution g ( y )  X  [1 , ( l  X  m + 1) /s ] 7 X  R between k ( x ) and f ( x ) and pooling operation h ( y )  X  [1 , ( l  X  m + 1) /s ] 7 X  R of f ( x ) is calculated as: where c = m  X  s + 1 is an offset constant.

We adapted this model, which employs temporal convo-lution and pooling operations, for tweets. The character set includes the English alphabets, numbers, special characters and unknown character. There are 70 characters in total, given below:
Each character in the tweets can be encoded using one-hot vector x i  X  { 0 , 1 } 70 . Hence, the tweets are represented as a binary matrix x 1 .. 150  X  { 0 , 1 } 150 x 70 with padding wherever necessary, where 150 is the maximum number of characters in a tweet (140 tweet characters and padding) and 70 is the size of the character set.

Each tweet, in the form of a matrix, is now fed into a deep model consisting of four 1-d convolutional layers. A convolution operation employs a filter w  X  R l , to extract n-gram character feature from a sliding window of l characters at the first layer and learns abstract textual features in the subsequent layers. The convolution in the first layer operates on sliding windows of character (size l ), and the convolutions in deeper layers are defined in a similar way. Generally, for tweet s , a feature c i at layer h is generated by: is a rectified linear unit.

This filter w is applied across all possible windows of char-acters in the tweet to produce a feature map. The output of the convolutional layer is followed by a 1-d max-overtime pooling operation [2] over the feature map and selects the maximum value as the prominent feature from the current filter. In this way, we apply n filters at each layer. Pool-ing size may vary at each layer (given by p ( h ) at layer h ). The pooling operation shrinks the size of the feature rep-resentation and filters out trivial features like unnecessary combination of characters. The window length l , number of filters f , pooling size p at each layer are given in Table 1. We define CharCNN ( T ) to denote the character-level CNN operation on input tweet matrix T . The output from the last convolutional layer of CharCNN(T) (size: 10  X  512) is subsequently given as input to the LSTM layer. Since LSTM works on sequences (explained in Section 2.2 and 2.3), pool-ing operation is restricted to the first two layers of the model (as shown in Table 1).
 Figure 1: Illustration of the CNN-LSTM Encoder-Decoder Model In this section we briefly describe the LSTM model [4]. Given an input sequence X =( x 1 ,x 2 ,...,x N ), LSTM com-putes the hidden vector sequence h =( h 1 ,h 2 ,...,h and output vector sequence Y =( y 1 ,y 2 ,...,y N ). At each time step, the output of the module is controlled by a set of gates as a function of the previous hidden state h t 1 and the input at the current time step x t , the forget gate f t gate i t , and the output gate o t . These gates collectively de-cide the transitions of the current memory cell c t and the current hidden state h t . The LSTM transition functions are defined as follows:
Here,  X  is the sigmoid function that has an output in [0, 1], tanh denotes the hyperbolic tangent function that has an output in [  X  1 , 1], and denotes the component-wise mul-tiplication. The extent to which the information in the old memory cell is discarded is controlled by f t , while i t the extent to which new information is stored in the current memory cell, and o t is the output based on the memory cell c . LSTM is explicitly designed for learning long-term depen-dencies, and therefore we choose LSTM after the convolution layer to learn dependencies in the sequence of extracted fea-tures. In sequence-to-sequence generation tasks, an LSTM defines a distribution over outputs and sequentially predicts tokens using a softmax function.
 where g is the activation function. For simplicity, we define LSTM ( x t ,h t  X  1 ) to denote the LSTM operation on input x at time-step t and the previous hidden state h t  X  1 .
The CNN-LSTM encoder-decoder model draws on the in-tuition that the sequence of features (e.g. character and word n-grams) extracted from CNN can be encoded into a vector representation using LSTM that can embed the meaning of the whole tweet. Figure 1 illustrates the complete encoder-decoder model. The input and output to the model are the tweet represented as a matrix where each row is the one-hot vector representation of the characters. The procedure for encoding and decoding is explained in the following section. Given a tweet in the matrix form T (size: 150  X  70), the CNN (Section 2.1) extracts the features from the character representation. The one-dimensional convolution involves a filter vector sliding over a sequence and detecting features at different positions. The new successive higher-order window representations then are fed into LSTM (Section 2.2). Since LSTM extracts representation from sequence input, we will not apply pooling after convolution at the higher layers of Character-level CNN model. The encoding procedure can be summarized as: where g = H conv is an extracted feature matrix where each row can be considered as a time-step for the LSTM and h t the hidden representation at time-step t . LSTM operates on each row of the H conv along with the hidden vectors from previous time-step to produce embedding for the subsequent time-steps. The vector output at the final time-step, enc is used to represent the entire tweet. In our case, the size of the enc N is 256.
The decoder operates on the encoded representation with two layers of LSTMs. In the initial time-step, the end-to-end output from the encoding procedure is used as the original input into first LSTM layer. The last LSTM decoder gen-erates each character, C , sequentially and combines it with previously generated hidden vectors of size 128, h t  X  1 the next time-step prediction. The prediction of character at each time step is given by: where C t refers to the character at time-step t , T t represents the one-hot vector of the character at time-step t . The result from the softmax is a decoded tweet matrix T dec , which is eventually compared with the actual tweet or a synonym-replaced version of the tweet (explained in Section 3) for learning the parameters of the model.
We trained the CNN-LSTM encoder-decoder model on 3 million randomly selected English-language tweets popu-lated using data augmentation techniques, which are useful for controlling generalization error for deep learning mod-els. Data augmentation, in our context, refers to replicat-ing tweet and replacing some of the words in the replicated tweets with their synonyms. These synonyms are obtained from WordNet [3] which contains words grouped together on the basis of their meanings. This involves selection of re-placeable words (example of non-replaceable words are stop-words, user names, hash tags, etc) from the tweet and the number of words n to be replaced. The probability of the number, n , is given by a geometric distribution with pa-rameter l in which P [ n ]  X  l n . Words generally have several synonyms, thus the synonym index m , of a given word is also determined by another geometric distribution in which P [ s ]  X  r m . In our encoder-decoder model, we decode the encoded representation to the actual tweet or a synonym-replaced version of the tweet from the augmented data. We used p = 0 . 5, r = 0 . 5 for our training. We also make sure that the POS tags of the replaced words are not completely different from the actual words. For regularization, we ap-ply a dropout mechanism after the penultimate layer. This prevents co-adaptation of hidden units by randomly setting a proportion  X  of the hidden units to zero (for our case, we set  X  = 0 . 5).

To learn the model parameters, we minimize the cross-entropy loss as the training objective using the Adam Opti-mization algorithm [5]. It is given by where p is the true distribution (one-hot vector representing characters in the tweet) and q is the output of the softmax. This, in turn, corresponds to computing the negative log-probability of the true class. We evaluated our model using two classification tasks: Tweet semantic relatedness and Tweet sentiment classifica-tion . The first evaluation is based on the SemEval 2015-Task 1: Paraphrase and Semantic Similarity in Twitter [14]. Given a pair of tweets, the goal is to predict their semantic equiva-lence (i.e., if they express the same or very similar meaning), through a binary yes/no judgement. The dataset provided for this task contains 18K tweet pairs for training and 1K pairs for testing, with 35% of these pairs being paraphrases, and 65% non-paraphrases.

We first extract the vector representation of all the tweets in the dataset using our Tweet2Vec model. We use two fea-tures to represent a tweet pair. Given two tweet vectors r and s , we compute their element-wise product r  X  s and their abso-lute difference | r  X  s | and concatenate them together (Similar to [6]). We then train a logistic regression model on these features using the dataset. Cross-validation is used for tun-ing the threshold for classification. In contrast to our model, most of the methods used for this task were largely based on extensive use of feature engineering, or a combination of feature engineering with semantic spaces. Table 2 shows the performance of our model compared to the top four mod-els in the SemEval 2015 competition, and also a model that was trained using ParagraphVec . Our model ( Tweet2Vec ) outperforms all these models, without resorting to extensive task-specific feature engineering.
 Table 2: Results of the paraphrase and semantic similarity in Twitter task.

The second evaluation is based on the SemEval 2015-Task 10B: Twitter Message Polarity Classification [10]. Given a tweet, the task is to classify it as either positive, negative or neutral in sentiment. The size of the training and test sets were 9,520 tweets and 2,380 tweets respectively (38% positive, 15% negative, and 47% neutral).

As with the last task, we first extract the vector represen-tation of all the tweets in the dataset using Tweet2Vec and use that to train a logistic regression classifier using the vec-tor representations. Even though there are three classes, the SemEval task is a binary task. The performance is measured as the average F1-score of the positive and the negative class. Table 3 shows the performance of our model compared to the top four models in the SemEval 2015 competition (note that only the F1-score is reported by SemEval for this task) and ParagraphVec . Our model outperforms all these models, again without resorting to any feature engineering. Table 3: Results of Twitter sentiment classification task.
In this paper, we presented Tweet2Vec , a novel method for generating general-purpose vector representation of tweets, using a character-level CNN-LSTM encoder-decoder archi-tecture. To the best of our knowledge, ours is the first at-tempt at learning and applying character-level tweet embed-dings. Our character-level model can deal with the noisy and peculiar nature of tweets better than methods that generate embeddings at the word level. Our model is also robust to synonyms with the help of our data augmentation technique using WordNet.

The vector representations generated by our model are generic, and thus can be applied to tasks of different nature. We evaluated our model using two different SemEval 2015 tasks: Twitter semantic relatedness, and sentiment classi-fication. Simple, off-the-shelf logistic regression classifiers trained using the vector representations generated by our model outperformed the top-performing methods for both tasks, without the need for any extensive feature engineer-ing. This was despite the fact that due to resource limi-tations, our Tweet2Vec model was trained on a relatively small set (3 million tweets). Also, our method outperformed ParagraphVec , which is an extension of Word2Vec to handle sentences. This is a small but noteworthy illustration of why our tweet embeddings are best-suited to deal with the noise and idiosyncrasies of tweets.

For future work, we plan to extend the method to include: 1) Augmentation of data through reordering the words in the tweets to make the model robust to word-order, 2) Ex-ploiting attention mechanism [8] in our model to improve alignment of words in tweets during decoding, which could improve the overall performance.
