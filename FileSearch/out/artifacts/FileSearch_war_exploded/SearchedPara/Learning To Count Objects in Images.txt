 The counting problem is the estimation of the number of objects in a still image or video frame. It arises in many real-world applications including cell counting in microscopic images, monitoring crowds in surveillance systems, and performing wildlife census or counting the number of trees in an aerial image of a forest.
 We take a supervised learning approach to this problem, and so require a set of training images with annotation. The question is what level of annotation is required? Arguably, the bare minimum of anno-tation is to provide the overall count of objects in each training image. This paper focusses on the next level of annotation which is to specify the object position by putting a single dot on each object instance in each image. Figure 1 gives examples of the counting problems and the dotted annotation we consider. Dotting (pointing) is the natural way to count objects for humans, at least when the number of objects is large. It may be argued therefore that providing dotted annotations for the training images is no harder for a human than giving just the raw counts. On the other hand, a spatial arrangement of the dots provides a wealth of additional information, and this paper is, in part, about how to exploit this  X  X ree lunch X  (in the context of the counting problem). Overall, it should be noted that dotted annotation is less labour-intensive than the bounding-box annotation, let alone pixel-accurate annotation, traditionally used by the supervised methods in the computer vision community [15]. Therefore, the dotted annotation represents an interesting and, perhaps, under-investigated case.
 This paper develops a simple and general discriminative learning-based framework for counting objects in images. Similar to global regression methods (see below), it also evades the hard problem of detecting all object instances in the images. However, unlike such methods, the approach also takes full and extensive use of the spatial information contained in the dotted supervision.
 The high-level idea of our approach is extremely simple: given an image I , our goal is to recover a density function F as a real function of pixels in this image. Our notion of density function loosely Figure 1: Examples of counting problems . Left  X  counting bacterial cells in a fluorescence-light microscopy corresponds to the physical notion of density as well as to the mathematical notion of measure. Given the estimate F of the density function and the query about the number of objects in the entire image I , the number of objects in the image is estimated by integrating F over the entire I . Furthermore, integrating the density over an image subregion S  X  I gives an estimate of the count of objects in that subregion. Our approach assumes that each pixel p in an image is represented by a feature vector x p and models the density function as a linear transformation of x p : F ( p ) = w T x p . Given a set of training images, the parameter vector w is learnt in the regularized risk framework, so that the density function estimates for the training images matches the ground truth densities inferred from the user annotations (under regularization on w ).
 The key conceptual difficulty with the density function is the discrete nature of both image observations (pixel grid) and, in particular, the user training annotation (sparse set of dots). As a result, while it is easy to reason about average densities over the extended image regions (e.g. the whole image), the notion of density is not well-defined at a pixel level. Thus, given a set of dotted annotation there is no trivial answer to the question: what should be the ground truth density for this training example. Consequently, this local ambiguity also renders standard pixel-based distances between density functions inappropriate for the regularized risk framework.
 Our main contribution, addressing this conceptual difficulty, is a specific distance metric D between density functions used as a loss in our framework, which we call the MESA distance (where MESA stands for Maximum Excess over SubArrays , as well as for the geological term for the elevated plateau). This distance possess two highly desirable properties: 1. Robustness. The MESA distance is robust to the additive local perturbations of its arguments such as independent noise or high-frequency signal as long as the integrals (counts) of these perturbations over larger region are close to zero. Thus, it does not matter much how exactly we define the ground truth density locally, as long as the integrals of the ground truth density over the larger regions reflect the counts correctly. We can then naturally define the  X  X round truth X  density for a dotted annotation to be a sum of normalized gaussians centered at the dots. 2. Computability. The MESA distance can be computed exactly via an efficient combinatorial algo-rithm (maximum sub-array [8]). Plugging it into the regularized risk framework then leads to a convex quadratic program for estimating w . While this program has a combinatorial number of linear con-straints, the cutting-plane procedure finds the close approximation to the globally optimal w after a small number of iterations.
 The proposed approach is highly versatile. As virtually no assumptions is made about the features x p , our framework can benefit from much of the research on good features for object detection. Thus, the confidence maps produced by object detectors or the scene explanations resulting from fitting the generative models can be turned into features and used by our method. 1.1 Related work.
 A number of approaches tackle counting problems in an unsupervised way, performing grouping based on self-similarities [3] or motion similarities [27]. However, the counting accuracy of such fully unsu-pervised methods is limited, and therefore others considered approaches based on supervised learning. Those fall into two categories: Figure 2: Processing results for a previously unseen image . Left  X  a fragment of the microscopy image. Em-Counting by detection: This assumes the use of a visual object detector, that localizes individual object instances in the image. Given the localizations of all instances, counting becomes trivial. However, object detection is very far from being solved [15], especially for overlapping instances. In particular, most current object detectors operate in two stages: first producing a real-valued confidence map; and second, given such a map, a further thresholding and non-maximum suppression steps are needed to locate peaks correspoinding to individual instances [12, 26]. More generative approaches avoid non-maximum suppression by reasoning about relations between object parts and instances [6, 14, 20, 33, 34], but they are still geared towards a situation with a small number of objects in images and require time-consuming inference. Alternatively, several methods assume that objects tend to be uniform and disconnected from each other by the distinct background color, so that it is possible to localize individual instances via a Monte-Carlo process [13], morphological analysis [5, 29] or variational optimization [25]. Methods in these groups deliver accurate counts when their underlying assumptions are met but are not applicable in more challenging situations.
 Counting by regression: These methods avoid solving the hard detection problem. Instead, a direct mapping from some global image characteristics (mainly histograms of various features) to the number of objects is learned. Such a standard regression problem can be addressed by a multitude of machine learning tools (e.g. neural networks [11, 17, 22]). This approach however has to discard any available information about the location of the objects (dots), using only its 1-dimensional statistics (total number) for learning. As a result, a large number of training images with the supplied counts needs to be provided during training. Finally, counting by segmentation methods [10, 28] can be regarded as hybrids of counting-by-detection and counting-by-regression approaches. They segment the objects into separate clusters and then regress from the global properties of each cluster to the overall number of objects in it. We now provide the detailed description of our framework starting with the description of the learning setting and notation. 2.1 Learning to Count We assume that a set of N training images (pixel grids) I 1 ,I 2 ,...I N is given. It is also assumed that each pixel p in each image I i is associated with a real-valued feature vector x i p  X  R K . We give the examples of the particular choices of the feature vectors in the experimental section. It is finally assumed total number of objects annotated by the user.
 The density functions in our approaches are real-valued functions over pixel grids, whose integrals over image regions should match the object counts. For a training image I i , we define the ground truth density function to be a kernel density estimate based on the provided points: Here, p denotes a pixel, N ( p ; P, X  2 1 2  X  2 ) denotes a normalized 2D Gaussian kernel evaluated at p , with the mean at the user-placed dot P , and an isotropic covariance matrix with  X  being a small value (typically, a few pixels). With this definition, the sum of the ground truth density P p  X  I entire image will not match the dot count C i exactly, as dots that lie very close to the image boundary result in their Gaussian probability mass being partly outside the image. This is a natural and desirable behaviour for most applications, as in many cases an object that lies partly outside the image boundary should not be counted as a full object, but rather as a fraction of an object.
 transformation of the feature representation that approximates the density function at each pixel: where w  X  R K is the parameter vector of the linear transform that we aim to learn from the training data, and F i (  X | w ) is the estimate of the density function for a particular value of w . The regularized risk framework then suggests choosing w so that it minimizes the sum of the mismatches between the ground truth and the estimated density functions (the loss function) under regularization: Here,  X  is a standard scalar hyperparameter, controlling the regularization strength. It is the only hyper-parameter in our framework (in addition to those that might be used during feature extraction). After the optimal weight vector has been learned from the training data, the system can produce a density estimate for an unseen image I by a simple linear weighting of the feature vector computed in each pixel as suggested by (2). The problem is thus reduced to choosing the right loss function D and computing the optimal w in (3) under that loss. 2.2 The MESA distance The distance D in (3) measures the mismatch between the ground truth and the estimated densities (the loss) and has a significant impact on the performance of the entire learning framework. There are two natural choices for D :  X  One can choose D to be some function of an L P metric, e.g. the L 1 metric (sum of absolute per-pixel differences) or a square of the L 2 metric (sum of squared per-pixel differences). Such choices turns (3) into standard regression problems (i.e. support vector regression and ridge regression for L 1 and
L 2 2 cases respectively), where each pixel in each training image effectively provides a sample in the training set. The problem with such loss is that it is not directly related to the real quantity that we care about, i.e. the overall counts of objects in images. E.g. strong zero-mean noise would affect such metric a lot, while the overall counts would be unaffected.  X  As the overall counts is what we ultimately care about, one may choose D to be an absolute or squared difference between the overall sums over the entire images for the two arguments, e.g. (3) into the counting-by-regression framework discussed in Section 1.1. Once again, we get either the support vector regression (for the absolute differences) or ridge regression (for the squared differ-ences), but now each training sample corresponds to the entire training image. Thus, although this choice of the loss matches our ultimate goal of learning to count very well, it requires many annotated images for training as spatial information in the annotation is discarded.
 Given the significant drawbacks of both baseline distance measures, we suggest an alternative, which we call the MESA distance. Given an image I , the MESA distance D MESA between two functions F 1 ( p ) and F ( p ) on the pixel grid is defined as the largest absolute difference between sums of F 1 ( p ) and F 2 ( p ) over all box subarrays in I : Here, B is the set of all box subarrays of I .
 The MESA distance (in fact, a metric) can be regarded as an L  X  distance between combinatorially-long vectors of subarray sums. In the 1D case, it is related to the Kolmogorov-Smirnov distance between probability distributions [23] (in our terminology, the Kolmogorov-Smirnov distance is the maximum of absolute differences over the subarrays with one corner fixed at top-left; thus the strict subset of B is considered in the Kolmogorov-Smirnov case). Figure 3: Comparison of distances for matching density functions . Here, the top-left image shows one of the The MESA distance has a number of desirable properties in our framework. Firstly, it is directly related to the counting objective we want to optimize. Since the set of all subarrays include the full image, D
MESA ( F 1 ,F 2 ) is an upper bound on the absolute difference of the overall count estimates given by the two densities F 1 and F 2 . Secondly, when the two density functions differ by a zero-mean high-frequency signal or an independent zero-mean noise, the D MESA distance between them is small, because positive and negative deviations of F 1 from F 2 pixels tend to cancel each other over the large regions. Thirdly, D MESA is sensitive to the overall spatial layout of the denisities. Thus, if the difference between F 1 and F 2 is a low-frequency signal, e.g. F 1 and F 2 are the ground truth densities corresponding to the two point sets leaning towards two different corners of the image, then the D MESA distance between F 1 and F 2 is large, even if F 1 and F 2 sum to the same counts over the entire image. These properties are illustrated in Figure 3.
 The final property of D MESA is that it can be computed efficiently. This is because it can be rewritten as: Computing both inner maxima in (5) then constitutes a 2D maximum subarray problem , which is finding solutions. Perhaps, the simplest of the efficient ones (from [8]) is an exhaustive search over one image dimension (e.g. for the top and bottom dimensions of the optimal subarray) combined with the dynamic programming ( Kadane  X  X  algorithm [7]) to solve the 1D maximum subarray problem along the other dimension in the inner loop. This approach has complexity O ( | I | 1 . 5 ) , where | I | is the number of pixels in the image grid. It can be further improved in practice by replacing the exhaustive search over the first dimension with branch-and-bound [4]. More extensive algorithms that guarantee even better worst-case complexity are known [31]. In our experiments, the algorithm [8] was sufficient, as the time bottleneck lied in the QP solver (see below). 2.3 Optimization We finally discuss how the optimization problem in (3) can be solved in the case when the D MESA distance is employed. The learning problem (3) can then be rewritten as a convex quadratic program: Here,  X  i are the auxiliary slack variables (one for each training image) and B i is the set of all subarrays in image i . At the optimum of (6) X (7), the optimal vector  X  w is the solution of (3) while the slack variables equal the MESA distances:  X   X  i = D MESA F 0 i (  X  ) ,F i (  X |  X  w ) .
 The number of linear constraints in (7) is combinatorial, so that a custom QP-solver cannot be applied directly. A standard iterative cutting-plane procedure, however, overcomes this problem: one starts with only a small subset of constraints activated (we choose 20 boxes with random dimensions in random subset of images to initialize the process). At each iteration, the QP (6) X (7) is solved with an active subarrays corresponding to the most violated constraints among (7). To do that, for each image we find the subarrays that maximize the right hand sides of (7), which are exactly the 2D maximum subarrays of F i (  X  )  X  F i (  X | The boxes j B 1 i and j B 2 i corresponding to these maximum subarrays are then found for each image i . If the corresponding constraints are activated, and the next iteration is performed. The iterations terminate when for all images the sums corresponding to maximum subarrays are within (1 + ) factor from j  X  i convergence in a small number of iterations to the approximation of the global minimum. Setting to 0 solves the program (6) X (7) exactly, while it has been shown in similar circumstances [16] that setting to a small finite value does not affect the generalization of the learning algorithm and brings the guarantees of convergence in small number of steps. Our framework and several baselines were evaluated on counting tasks for two types of imagery shown in Figure 1. We now discuss the experiments and the quantitative results. The test datasets and the densities computed with our method can be further assessed qualitatively at the project webpage [1].
 Bacterial cells in fluorescence-light microscopy images. Our first experiment is concerned with syn-thetic images, emulating microscopic views of the colonies of bacterial cell, generated with [19] (Fig-ure 1-left). Such synthetic images (Figure 1-left) are highly realistic and simulate such effects as cell overlaps, shape variability, strong out-of-focus blur, vignetting, etc. For the experiments, we generated a dataset of images (available at [1]), with the overall number of cells varying between 74 and 317. Few annotated datasets with real cell microscopy images also exist. While it is tempting to use real rather than synthetic imagery, all the real image datasets to the best of our knowledge are small (only few images have annotations), and, most importantly, there always are very big discrepancies between the annotations of different human experts. The latter effectively invalidates the use of such real datasets for quantitative comparison of different counting approaches.
 Below we discuss the comparison of the counting accuracy achieved by our approach and baseline ap-proaches. The features used in all approaches were based on the dense SIFT descriptor [21] computing using [32] software at each pixel of each image with the fixed SIFT frame radius (about the size of the cell) and fixed orientation. Each algorithm was trained on N training images, while another N images were used for the validation of metaparameters. The following approaches were considered: 1. The proposed density-based approach. A very simple feature representation was chosen: a codebook of K entries was constructed via k-means on SIFT descriptors extracted from the hold-out 20 images. Then each pixel is represented by a vector of length K , which is 1 at the dimension corresponding to the entry of the SIFT descriptor at that pixel and 0 for all other dimensions. We used training images to learn the vector w as discussed in Section 2.1. Counting is then performed by summing the values w t assigned to the codebook entries t for all pixels in the test image. Figure 2-right gives an example of the respective density (see also [1]). Table 1: Mean absolute errors for cell counting on the test set of 100 fluorescent microscopy images. The Counting-by-Regression [17] 2 . 07 2 . 66 2 . 78 N/A N/A N/A Counting-by-Regression [28] 1 . 80 2 . 34 2 . 52 4 . 46 N/A N/A Counting-by-Segmentation [28] 1 . 53 1 . 64 1 . 84 1 . 31 N/A N/A Table 2: Mean absolute errors for people counting in the surveillance video [10]. The columns correspond to 2. The counting-by-regression baseline. Each of the training images was described by a global histogram of the entries occurrences for the same codebook as above. We then learned two types of regression (ridge regression with linear and Gaussian kernels) to the number of cells in the image. 3. The counting-by-detection baseline. We trained a detector based on a linear SVM classifier. The SIFT descriptors corresponding to the dotted pixels were considered positive examples. To sample negative examples, we built a Delaunay triangulation on the dots and took SIFT descriptors corresponding to the pixels at the middle of Delaunay edges. At detection time, we applied the SVM at each pixel, and then found peaks in the resulting confidence map (e.g. Figure 2-middle) via non-maximum suppression with the threshold  X  and radius  X  using the code [18]. We also considered a variant with the linear correction of the obtained number to account for systematic biases ( detection+correction ). The slope and the intercept of the correction for each combination of  X  ,  X  , and regularization strength were estimated via robust regression on the union of the training and validation sets. 4. Application-specific method [29]. We also evaluated the software specifically designed for analyzing cells in fluorescence-light images [29]. The counting algorithm here is based on adaptive thresholding and morphological analysis. For this baseline, we tuned the free parameter (cell division threshold) on the test set, and computed the mean absolute error, which was 16.2 .
 The meta-parameters ( K , regularization strengths, Gaussian kernel width for ridge regression,  X  and  X  for non-maximum suppression) were learned in each case on the validation set. The objective minimized during the validation was counting accuracy. For counting-by-detection, we also considered optimizing detection accuracy (computed via Hungarian matching with the ground truth), and, for our approach, we also considered minimizing the MESA distance with the ground truth density on the validation set. The results for a different number N of training and validation images are given in Table 1, based on 5 random draws of training and validation sets. A hold out set of 100 images was used for testing. The proposed method outperforms the baseline approaches for all sizes of the training set.
 Pedestrians in surveillance video. Here we focus on a 2000-frames video dataset [10] from a camera overviewing a busy pedestrian street (Figure 1-right). The authors of [10] also provided the dotted ground truth for these frames, the position of the ground plane, and the region of interest, where the counts should be performed. Recently, [28] performed extensive experiments on the dataset and reported the performance of three approaches (two counting-by-regression including [17] and the hybrid approach: split into blobs, and regress the number for each blob). The hybrid approach in [28] required more detailed annotations than dotting (see [28] for details). For the sake of comparison, we adhered to the experimental protocols described in [28], so that the performance of our method is directly comparable. In particular, 4 train/test splits were suggested in [28]: 1)  X  X aximal X : train on frames 600:5:1400 (in Matlab notation) 2)  X  X ownscale X : train on frames 1205:5:1600 (the most crowded) 3)  X  X pscale X : train on frames 805:5:1100 (the least crowded) 4)  X  X inimal X : train on frames 640:80:1360 (10 frames). Testing is performed on the frames outside the training range. For future reference, we also included two additional scenarios ( X  X ense X  and  X  X parse X ) with multiple similar splits in each (permitting variance estimation). Both scenarios are based on splitting the 2000 frames into 5 contiguous chunks of 400 frames. In each of the two scenarios, we then performed training on one chunk and testing on the other 4. In the  X  X ense X  scenario we trained on 80 frames sampled from the training split with uniform spacing, while in the  X  X parse X  scenario, we took just 10 frames.
 difference image with the previous frame, and the background subtracted image have to be combined to achieve the best performance (a simple median filtering was used to estimate the static background image). We used a randomized tree approach similar to [24] to get features combining these modalities. Thus, we first extracted the primary features in each pixel including the absolute differences with the previous frame and the background, the image intensity, and the absolute values x -and y -derivatives. On the training subset of the smallest  X  X inimal X  split, we then trained a random forest [9] with 5 randomized trees. The training objective was the regression from the appearance of each pixel and its neighborhood to the ground truth density. For each pixel at testtime, the random forest performs a series of simple tests comparing the value of in the particular primary channel at location defined by a particular offset with the particular threshold, while during forest pretraining the number of the channel, the offset and the threshold are randomized. Given the pretrained forest, each pixel p gets assigned a vector x p of dimension equal to the total number of leaves in all trees, with ones corresponding to the leaves in each of the five trees the pixel falls into and zeros otherwise. Finally, to account for the perspective distortion, we multiplied x p by the square of the depth of the ground plane at p (provided with the sequence). Within each scenario, we allocated one-fifth of the training frames to pick  X  and the tree depth through validation via the MESA distance.
 The quantitative comparison in Table 2, demonstrates the competitiveness of our method.
 Overall comments. In both sets of experiments, we tried two strategies for setting  X  (kernel width in the definition of the ground truth densities): setting  X  = 0 (effectively, the ground truth is then a sum of delta-functions), and setting  X  = 4 (roughly comparable with object half-size in both experiments). In the first case (cells) both strategies gave almost the same results for all N , highlighting the insensitivity of our approach to the choice of  X  (see also Figure 3 on that). The results in Table 1 is for  X  = 0 . In the second case (pedestrians),  X  = 4 had an edge over  X  = 0 , and the results in Table 2 are for that value. At train time, we observed that the cutting plane algorithm converged in a few dozen iterations (less than 100 for our choice = 0 . 01 ). The use of a general-purpose quadratic solver [2] meant that the training times were considerable (from several seconds to few hours depending on the value of  X  and the size of the training set). We anticipate a big reduction in training time for the purpose-built solver. At test time, our approach introduces virtually no time overhead over feature extraction. E.g. in the case of pedestrians, one can store the value w t computed during learning at each leaf t in each tree, so that counting would require simply  X  X ushing X  each pixel down the forest, and summing the resulting w t from the obtained leaves. This can be done in real-time [30]. We have presented the general framework for learning to count objects in images. While our ultimate goal is the counting accuracy over the entire image, during the learning our approach is optimizing the loss based on the MESA-distance. This loss involves counting accuracy over multiple subarrays of the entire image (and not only the entire image itself). We demonstrate that given limited amount of training data, such an approach achieves much higher accuracy than optimizing the counting accuracy over the entire image directly (counting-by-regression). At the same time, the fact that we avoid the hard problem of detecting and discerning individual object instances, gives our approach an edge over the counting-by-detection method in our experiments.
 Acknowledgements . This work is suppoted by EU ERC grant VisRec no. 228180. V. Lempitsky is also supported by Microsoft Research projects in Russia. We thank Prof. Jiri Matas (CTU Prague) for suggesting the detection+correction baseline.
