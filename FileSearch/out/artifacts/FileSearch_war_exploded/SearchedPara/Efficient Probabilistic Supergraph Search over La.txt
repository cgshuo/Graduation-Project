 In recent years, with the emergence of a number of new real appli-cations, such as protein-protein interaction (PPI) networks, visual pattern recognition, and intelligent traffic systems, managing huge volumes of uncertain graphs has attracted much attention in the database community. Currently, most existing fundamental queries over graphs only support deterministic (or certain) graphs, although real graph data are often noisy, inaccurate, and incomplete. In this paper, we study a new type of uncertain graph query, proba-bilistic supergraph containment query over large uncertain graphs. Specifically, given an uncertain graph database UGD which con-tains a set of uncertain graphs, a deterministic query graph q ,and a probabilistic threshold  X  , a probabilistic supergraph containment query is to find the set of uncertain graphs from UGD , denoted as UGD q , such that UGD q = { ug i  X  UGD | Pr ( ug i  X  q )  X  where Pr ( ug i  X  q ) means the likelihood that ug i is a subgraph of q . We prove that the computation of Pr ( ug i  X  q ) is hard and design an efficient filtering-and-verification framework to avoid the expensive computation. In particular, we propose an ef-fective filtering strategy and a novel probabilistic inverted index, called PS-Index , to enhance pruning power in the filtering phase. Furthermore, the candidate graphs which pass the filtering phase are tested in the verification phase via an efficient unequal proba-bility sampling-based approximation algorithm. Finally, we verify the effectiveness and efficiency of the proposed methods through extensive experiments.
 H.2.4 [ Database Management ]: Systems-Query processing Algorithm, Experimentation, Performance Uncertain Graphs, Graph Querying, Probabilistic Supergraph Query
Due to the emergence of many real-world applications of un-certain graphs, such as protein-protein interaction (PPI) network analysis [7, 15, 17], visual pattern recognition [2, 3], social net-work mining [1], and intelligent traffic monitoring [9], etc., query processing over large uncertain graphs has attracted much attention in the database community. Several uncertain graph queries, proba-bilistic subgraph (or subgraph similarity) queries [24, 23], k nearest neighbor ( k NN) query over uncertain graphs [13], uncertain short-est path query [9], and uncertain distance-constraint reachability query [10], have been studied recently.

In this paper, we investigate another fundamental graph query, supergraph containment query , in large uncertain graphs. As a motivating example for this query, we consider the case in PPI networks where existences of some interactions are defined with uncertainty. Specially, in a PPI network[7, 17], vertices repre-sent proteins, edges represent interactions between proteins, the la-bels of vertices are the COG functional annotations of proteins. It is reasonable to model a PPI network as an uncertain graph [23, 24, 13, 27, 26, 28]. In particular, when researchers study some new types of PPI structures, they want to efficiently identify what new PPI structures can be included by some known important PPI structures (which may represent important PPI structural proper-ties) with high probability. Therefore, it is essential to study the containment relationship where some uncertain graphs are con-tained into a given query graph.

The problem of supergraph containment query over determinis-tic graphs is defined as follows [5]: Given a deterministic graph database, GD = { g 1 ,...,g n } and a query graph q ,itistofind the answer set GD q = { g i  X  GD | g i  X  q } ,where g i  X  means that g i is a subgraph of q . The containment relationship between a query graph and each deterministic graph is determined by subgraph isomorphism test, which is a NP-complete problem. Compared with deterministic graphs, it is much harder for uncer-tain graphs to decide such a containment relationship between a query graph and each uncertain graph due to the inherent uncer-tainty. According to the widely adopted possible world semantic over uncertain graphs [23, 24, 27, 28], each possible world graph of a given uncertain graph is a possible instance of the uncertain graph. Therefore, the problem of probabilistic supergraph contain-ment query over uncertain graphs is described as follows. Given an uncertain graph database, UGD = { ug 1 ,...,ug n } , a query graph q , and a probabilistic threshold  X  ( 0 &lt; X   X  1 ), this query is to find all uncertain graphs ug i  X  UGD such that Pr ( ug i  X  q )  X  where Pr ( ug i  X  q ) is the supergraph contai nment probability (SCP) between q and ug i . In reality, SCP is equal to the sum of the probabilities of all the possible world graphs that are contained by q . We will illustrate this problem via the following example. E XAMPLE 1( Probabilistic Supergraph Containment Query ). Figure 1 shows an uncertain graph database including four un-certain graphs. The vertices are labeled from a letter set, A, B, C, D (in this example, we ignore labels of edges for the succinct reason as it is easy to extend labels on edges). In addition, each vertex and each edge are associated with a real number indicating their existence probab ilities. As an example, all possible world graphs of ug 2 are shown in Figure 3 where every real number below each possible world graph represents the existence proba-bility of suc h a possible world graph. Si nce each possible world graph is an instantiation of an uncertain graph, the sum of prob-abilities of 18 possible world graphs of ug 2 equals to 1. Given the probabilistic threshold  X  =0.7, the SCP between q (as shown in Figure 2) and ug 2 can be calculated as follows: Pr ( ug q ) = Pr ( pw 1 )+ Pr ( pw 2 )+ Pr ( pw 3 )+ Pr ( pw 4 )+ Pr ( Pr ( pw 6 )+ Pr ( pw 7 )+ Pr ( pw 8 )+ Pr ( pw 9 )+ Pr ( pw 11 Pr ( pw 12 )+ Pr ( pw 13 )+ Pr ( pw 15 )=0 . 352 &lt; 0 . 7 . Thus, ug 2 cannot be returned as a final result. Similarly, we can also check ug
Based on the aforementioned problem statement, a naive solu-tion is to sequentially scan all uncertain graphs and calculate their SCP one by one. It is obviously inefficient. In addition, a closely related work, targeting at probabilistic subgraph search over un-certain graphs, was proposed recently [24]. This work designs an efficient search framework in three steps: structural pruning, prob-abilistic pruning and verification. For an uncertain graph database, this method first neglects all probabilities of uncertain graphs and uses existing techniques of subgraph search in deterministic graphs to prune some uncertain graphs. Then, it further uses probabilistic pruning to filter more candidates. Finally, it refines the final re-sult in the verification phase. Unfortunately, we cannot adopt the aforementioned framework in [24] since there are intrinsic differ-ences between subgraph search and supergraph search over uncer-tain graphs. Here, we firstly define several notations for the conve-nience of explanation.

We denote the uncertain graph database as UGD , and its corre-sponding deterministic graph database as GD , which is obtained by removing all the existence probability values in UGD .More-over, their query results with the same query graph q are denoted as UGD q and GD q , respectively. For subgraph search over uncertain graphs, we usually observe | UGD q | X | GD q | ,where | UGD and | GD q | mean the sizes of UGD q and GD q . On the contrary, |
UGD q | X | GD q | in supergraph search over uncertain graphs. For example, if an edge, AB which includes two vertices A and B ,is a query graph in the subgraph query, the probabilistic threshold  X  =0 . 5 , GD AB = { ug 1 ,ug 2 } and UGD AB = { ug 1 } , respec-tively. Thus, | GD AB | =2 &gt; 1= | UGD AB | in Figure 1. In contrast to the subgraph query, given the supergraph query q in Figure 2, GD q = { ug 1 } and UGD q = { ug 1 ,ug 4 } with respect to  X  =0 . 5 .Inotherwords, | GD q | =1 &lt; 2= | UGD q | for the su-pergraph queries in Figure 1. Therefore, when | UGD q | X | it is reasonable to firstly obtain the candidate set by the structural pruning techniques used in the deterministic subgraph search then further filter the candidates via th e probabilistic pruning methods. However, when | UGD q | X | GD q | , we cannot use the result set of deterministic supergraph search as the candidate set because un-certain graphs may be over-pruned in the structural pruning phase. Therefore, the structural pruning pruning adopted in [24] cannot be applied to solve our problem.

From the above discussion, we discover a probabilistic super-gaph filtering strategy. Before introducing the filtering strategy, we first define the concept of feature graphs , which is a determinis-tic graph and a subgraph of at least a deterministic graph in GD . Based on feature graphs, the filtering strategy is, given a feature subgraph f ,if f q and Pr ( f  X  ug i )= p , Pr ( ug i  X  q 1  X  p ,where Pr ( f  X  ug i ) is the subgraph isomorphism proba-bility between f and ug i , which is the sum of the probabilities of all possible world graphs of ug i that contains q . In other words, if f q and p  X   X  , ug i can be pruned. A formal descriptions and proofs of above properties will be given in Section 3. We illustrate the above filtering strategy with the following example.
E XAMPLE 2( Probabilistic Supergraph Filtering Strategy ). Given an uncertain graph database in Figure 1, a query graph q in the left of Figure 2, a probabilistic threshold  X  =0.7, a feature subgraph f in the right of Figure 2, and all possible world graphs of ug 2 in Figure 3, based on the aforementioned filtering strategy, we can firstly find f q , and Pr ( f  X  ug 2 )= Pr ( pw 16 )+ Pr ( 0 . 467 &gt; 0 . 3=1  X  0 . 7 . Thus, ug 2 is pruned.

According to the aforementione d filtering strategy, it is still non-trivial to decide an optimal feature graph that best serves the prun-ing efficiently. In this work, we further propose an effective prob-abilistic inverted index, PS-Index . In addition, in order to speed up the verification step, we design an efficient sampling algorithm to calculate SCP . To sum up, we make the following contributions:
The rest of the paper is organized as follows. Our problem for-mulation and complexity analysis are introduced in Section 2. In Section 3, we propose our solution framework toward the proba-bilistic supergraph containment query. Based on our probabilistic supergaph filtering logic, an optimal feature selection approach and a novel index, PS-Index which help eliminate redundant computa-tion, are elaborated in Section 4. An unequal-probability-sampling-based approximate algorithm in the verification phase is shown in Section 5. Experimental studies and related work are reported in Section 6 and Section 7, respectively. Finally, we conclude in Sec-tion 8.
In this section, we first review preliminaries with respect to de-terministic graph search in Section 2.1. Then, we introduce our uncertain graph model and problem statement in Section 2.2. In addition, a summary of notations is shown in Table 1.
D EFINITION 1. (Deterministic Graph) A labeled undirected graph is denoted as g = &lt; V,E,L v ,L e &gt; , where 1) V is the set of ver-tices; 2) E is the set of edges; 3) L v is a label function assigning labels to each vertex in V ;4) L e is a label function assigning labels to each edge in E .

D EFINITION 2. (Subgraph Isomorphism) Given two graphs, g V,E,L v ,L e &gt; and g = &lt;V ,E ,L v ,L e &gt; , a subgraph isomor-phism from g to g is an injective function f : V  X  V , such that 1)  X  u  X  V , L v ( u )= L E and L e ( u, v )= L e ( f ( u ) ,f ( v )) .

D EFINITION 3. (Subgraph and Supergraph) Given two graphs, g and g , if there is a subgraph isomorphism from g to g , g is a subgraph of g , denoted as g  X  g , and g is called a supergraph of g .

D EFINITION 4. (Subgraph Query) Given a deterministic graph database GD = { g 1 ,...,g n } and a query graph q , the problem of subgraph query is to find the query answer set D q = { GD | q  X  g i } .

D EFINITION 5. (Supergraph Containment Query) Given a de-terministic graph database GD = { g 1 ,...,g n } and a query graph q , the problem of supergraph containment query is to find the query answer set D q = { g i  X  GD | g i  X  q } .
In this subsection, we first introduce the uncertain graph model based on the possible world semantics. Then, we define several im-portant concepts in uncertain graph query, such as the subgraph iso-morphism probability and the supergraph containment probability. Finally, we give the problem statement and analyze the complexity of this problem.

D EFINITION 6. (Uncertain Graph) Given a deterministic graph g = &lt;V,E,L v ,L e &gt; , a corresponding uncertain graph is defined ug = &lt; V,E,L v ,L e ,P v ,P e &gt; , where 1) P v : V  X  [0 injective function assigning existence probabilities to each vertex in V ;2) P e : E  X  [0 , 1] is also an injective function assigning exis-tence probabilities to each e dge in E (where existence pr obabilities of edges assigned by P e are actually conditional probabilities when endpoints of edges exist).

D EFINITION 7. (Possible World Graph) Given an uncertain graph ug = &lt; V,E,L v ,L e ,P v ,P e &gt; , a possible world graph of ug is an instance of ug and is denoted pw ( ug )= &lt;V ,E ,L v,L e&gt; , where 1) V  X  V ;2) E  X  E  X  ( V  X  V ) ;3) L v is a label function assigning labels to V ;4) L e is a label function assigning labels to E . L v and L e may assign the same labels of L v and L non-existence if the corresponding vertex and edge do not exist in this instance
Similar to previous studies of uncertain graph query [23, 24, 26, 27, 28], we also assume that both the existence probabilities of vertices and the conditional probabilities of edges of an uncertain graph are mutually independent. Thus, we can compute the prob-ability of a possible world graph of a uncertain graph ug , denoted Pr ( pw ( ug )) , as follows.

In addition, the set of all possible worlds implicated from UGD is denoted as PW in this paper. Based on the aforementioned def-initions, we introduce the concept of the supergraph containment probability and the problem statement as follows.
 D EFINITION 8. (Supergraph C ontainment Probability (SCP)) Given an uncertain graph ug and a deterministic query graph q ,the supergraph containm ent probability between q and ug is defined: where PW ( ug ) means the set all possible world graphs generated from ug , pw i ( ug )  X  q and pw i ( ug )  X  PW ( ug ) mean that possi-ble world graphs which are contained by q .
 Problem Statement (Probabilistic Supergraph Containment Query over Uncertain Graph Databases) : Given an uncertain graph database UGD = { ug 1 ,...,ug n } , a deterministic query graph q and a probabilistic threshold  X  , this problem is to find the query answer set UGD q = { ug i  X  UGD | Pr ( ug i  X  q )  X 
Based on the problem statement, a naive solution is to scan each uncertain graph in UGD and compute the SCP one by one. Unfor-tunately, as shown in the following theorem, the problem of com-puting the SCP is # P-hard.

T HEOREM 1. (The Complexity of Supergraph Containment Prob-ability (SCP) Computation) It is a # P-hard to compute the super-graph containm ent probability.

Proof (Sketch): In order to prove the problem of computing the supergraph containment probability is # P-hard, we reduce it from the monotone DNF counting problem ( # MDNF), which is known to be # P-complete [20].

Consider an instance of # MDNF: Given a monotone DNF for-mula F = C 1  X  X  X  X  X  C n , with n clauses and m Boolean vari-ables v 1 ,...,v m . In each clause C i = y 1  X  X  X  X  X  y l ,wehave y  X  X  v 1 ,...,v m } and each variable can appear at most once. The #
MDNF problem is to count the number of satisfying assignments of variables for the formula F .

We map the above instance of # MDNF to an uncertain graph ug , where each edge e j corresponds to a variable v j . Moreover, there are n possible world graphs, pw 1 ( ug ) ,...,pw n ( the uncertain graph ug ,where pw i ( ug ) corresponds to a clause C Figure 4: The uncertain graph ug and the query graph q con-structed by v 1  X  v 2  X  ( v 1  X  v 2 ) For each possible world graph pw i ( ug ) and each edge e e  X  pw i ( ug ) if and only if v j appears in the clause C i words, when a query graph q is given, a truth assignment satisfies F if and only if the corresponding possible world graph pw is contained by q . Therefore, the probability Pr ( F ) equals to the probability Pr ( ug  X  q ) . For instance, given a formula F v  X  ( v 1  X  v 2 ) , we map it to the corresponding uncertain graph ug in Figure 4.
In this section, our framework will be introduced as follows. 1. Offline Index Construction : Firstly, we discover all proba-2. Filtering : Based on the PS-Index ,wetest q against indexed 3. Verification : For the uncertain graphs passing the filtering
Given a query graph q , a feature set F , the query response time based on the above framework is: where T SCP ( q,ug i ) is the time to check whether the supergraph containment probability between q and ug i is greater than the given a probabilistic threshold  X  (0  X   X   X  1) , T SubIsm ( f,q ) to test whether a feature f is the subgraph of the query graph q , (namely this time equals to the time of subgraph isomorphism test between the two deterministic graphs), and T IndexSearch is the time to find the candidate set C q in the index.

According to the formula 3, we know that T SCP ( q,ug i ) hard operation, T SubIsm ( f,q ) is a NP-hard operation, and T can be finished in the polynomial time. Thus, it is reasonable that T
IndexSearch is ignored in the total cost model. Moreover, the total cost can be simplified to the formula 4: where | C q | is the size of the candidate set, AveT SCP is the aver-age time of computing the supergraph containment probability, is the size of the feature set, AveT SubIsm is the average time of testing the subgraph isomorphism.

In addition, an important fact is that AveT SCP is usually sev-eral orders more than AveT SubIsm , even though we adopt the ap-proximation algorithm to compute SCP . This fact will be fur-ther verified in our experiments. In the deterministic environment, there is the subgraph isomorphism test instead of the computa-tion of SCP . Thus, the formula 4 can be simplified to ( | |
F | )  X  AveT SubIsm . To save the cost, existing works of super-graph query in deterministic graphs always try to minimize the size of | C q | + | F | . However, in the problem of supergraph query in uncertain graphs, we have to first guarantee the minimum size of |
C q | , then try to decrease the size of | F | as far as possible due to
In Section 1, we introduce the basic idea of the probabilistic su-pergraph filtering strategy. Since the filtering strategy is the base of the feature selection and index construction, we provide the com-plete proof in this subsection. Moreover, we first define the concept of subgraph isomorphi sm probability due to the requirement of this filtering strategy.

D EFINITION 9. (Subgraph Isomorphism Probability (SIP)) Given an uncertain graph ug and a deterministic query graph q , the sub-graph isomorphism probability between q and ug is defined: where PW ( ug ) means the set all possible world graphs generated from ug , q  X  pw i ( ug )  X  pw i ( ug )  X  PW ( ug ) means the possible world graphs which include q .

Based on the definition of subgraph isomorphism probability, we have the following lemma.

L EMMA 1. (The Upper Bound of Supergraph Containment Prob-ability) Given a deterministic query graph q , an uncertain graph ug , and a feature subgraph f ,if f q and Pr ( f  X  ug )= p ,then Pr ( ug  X  q )  X  1  X  p .

Proof (Sketch): According to the definition of SIP (Definition 9), we know that and f q . In addition, the above possible world graphs ( pw PW ( ug ) and f  X  pw i ( ug ) ) must not contain q . Thus, these possi-ble world graphs whic h support proba bilities to Pr ( f  X  not provide the probabilities to Pr ( ug  X  f ) . Hence, Pr q )  X  1  X  p if Pr ( f  X  ug )= p . Hence, the lemma holds.
Based on Lemma 1, we can further obtain the probabilistic su-pergraph filtering strategy as follows.

T HEOREM 2. (Probabilistic Supergraph Pruning) Given a de-terministic query graph q , an uncertain graph ug , a feature sub-graph f , and a probabilistic threshold  X  ,if f q and Pr ( ug ) &gt; 1  X   X  ,then ug can be safely pruned.

Proof (Sketch): Since f q and Pr ( f  X  ug )  X  1  X   X  , we can obtain Pr ( ug  X  q ) &lt; 1  X  (1  X   X  ) &lt; X  based on Lemma 1. Then, ug will not be in the final result set and can be safely pruned.
In this section, we discuss in detail the PS-Index including the initial feature generation, feature selection and index construction. According to the probabilistic supergraph filtering strategy in Section 3.2, it is important for the pruning method to select signif-icant features. Inspired by the pr evious researches of graph search in deterministic graphs [5, 21], we adopt a two-step approach to choose features. In the first step, we discover frequent subgraphs in uncertain graphs [26, 28] to produc e the initial feature set, denoted F from the initial feature set in orde r to remove redundant features.
In this subsection, we focus on how to generate the initial fea-ture set efficiently. Although the existing works of uncertain graph search use the deterministic frequent subgraph mining technique to generate the initial feature set [23, 24], we will encounter two challenges in our problem if the deterministic frequent subgraph mining technique is directly adopted. 1) Which method should be used in both deterministic and uncertain frequent subgraph mining methods? 2) Could we enhance the efficiency of the feature gener-ation process if we employ the uncertain frequent subgraph mining technique?
For the first challenge, the deterministic frequent subgraph min-ing methods ignore the uncertainty in uncertain graphs to gener-ate the initial feature set including meaningless features. Since the existing solutions of uncertain subgraph query depend on the de-terministic structural pruning, it needs the deterministic frequent subgraph mining methods to support. However, in the supergraph containment query, structural pruning does not work. Hence, we choose the uncertain frequent subgraph mining to generate the ini-tial feature set for saving the uncertainty of uncertain graphs.
For the second challenge, the efficiency of uncertain frequent subgraph mining is the major bo ttleneck. Since the frequency of each subgraph pattern becomes a random variable in the uncer-tain environment, existing works of uncertain frequent subgraph mining include two different probabilistic semantics. One method uses the expectation of the frequency to measure whether each sub-graph pattern is frequent [28]. The other method calculates the probability that the frequency is greater than minsup threshold to test whether this subgraph pattern is frequent [26]. We select the expectation-based framework since the recent research [19] proves that the expectation-based semantics is much faster and has the same effect with the probabilistic frequent semantics. Unfortu-nately, even though we employ the expectation-based semantics, the efficiency of uncertain frequent subgraph mining is still low due to the inherent high complexity of computing SIP .Inor-der to speed up the process of feature generation, we propose a probabilistic-bounding-based method, which adopts a tight lower and upper bound to estimate the SIP of a subgraph pattern and an uncertain graph instead of the original exact check. In other words, we continue to use the existing expectation semantics-based uncer-tain frequent subgraph mining framework but replace the existing SIP computation method to the following strategies: 1) If the sum of lower bounds of an subgraph is greater than the threshold, the subgraph is frequent; 2) If the sum of upper bounds of an sub-graph is lower than the threshold, the subgraph is infrequent; 3) If the threshold is in the interval between the sums of lower bounds and upper bounds, we have to adopt the existing sampling-based method to estimate the expectation of frequency of the subgraph. The two bounds are shown in the following lemma.
 L EMMA 2. (The Lower/Upper Bound of Subgraph Isomorphism Probability) Give n a deterministic subgraph f , an uncertain graph ug (whose corresponding deterministic graph is denoted g ), if there are m subgraph isomorphism instances of f in g ,where SI i sents the i-th subgraph isomorphism instance, the SIP of f and ug , Pr ( f  X  ug ) , satisfies, where Pr ( SI i ) means the existence pr obability of th e i-th sub-graph isomorphism instance.

Proof (Sketch): Because the SIP computation can be reduced the problem of computing a probabilistic DNF formula [24, 28], Pr ( f  X  ug ) can be transformed to the form Pr ( SI 1  X  X  X  X  X  where SI i represents the i-th subgraph isomorphism instances. Ac-cording to the de Caen probability inequality [8] and the Kwerel probability inequality [16], we can obtain the following lower up-per and the upper bound of Pr ( SI 1  X  X  X  X  X  SI m ) , respectively.
Pr ( SI 1  X  X  X  X  X  SI m )  X  Pr ( SI 1  X  X  X  X  X  SI m )  X { Thus, the lemma holds.

According to Lemma 2, we can significantly enhance the effi-ciency of the feature generation process since the tight lower and upper bounds can be performed in polynomial time. Based on the initial feature set, we can employ the redundancy-aware feature selection algorithm [5] to select the final feature set consisting of an effective probabilistic inverted index, called PS-Index ,tostore these features in the next subsection.
After obtaining the selected feature set, we construct a prefix-search-tree-based index, which allocates a depth-first-search-based order for each feature in the inde x construction phase. The detail of PS-Index is defined as follows.
 D EFINITION 10. (PS-Index) Given an uncertain graph database UGD = { ug 1 ,...,ug n } a initial feature set F 0 and a selected feature set F = { f 1 ,...,f t } , a PS-Index constructed on UGD consists of the following three components:
A Feature Array. It stores the set of all features in F .Each element in this array has two pointers. A pointer is used to locate each feature in the prefix search tree. The other pointer points to the corresponding list of lower/upper bounds of each feature.
A List of Probabilistic Bound-based Arrays. It stores the set of all lower and upper bounds of selected features in each uncertain graph. Each unit in this array contain the lower and upper bounds of a feature in all uncertain graphs and is located by a pointer from the corresponding feature array.

A Prefix Search Tree. It is constructed in two steps. In the first step, the prefix search tree stores all features from F 0 , each node of such tree represents a feature by the DFS code, which translate a graph into a unique edge sequence, which is generated by per-forming a depth-first search (DFS) in a graph. [21]. Each node also has a pointer which can locate the corresponding element in feature array. In the second step, the nodes which is not chosen in F is labeled as an empty node. Please note that the second step can be quickly finished by the list of pointers from the feature array.
Based on the definition of PS-Index , the index can be constructed easily. Firstly, we can construct the prefix search tree by the depth-first-search-based order, meanwhile, the feature array is also built. Secondly, to the select ed features, we build their proba bilistic bound-based arrays in memory. For the features which fail to be selected, we set them as empty nodes in the prefix tree and store their proba-bilistic bound-based arrays in disk. Examp le 3 will further illustrate the construction of PS-Index .

E XAMPLE 3( PS-Index ). Given an uncertain graph database which includes n uncertain graphs, a selected feature set F ,we can build a PS-Index shown in Figure 5. The three components of the PS-Index is explained as follow. The feature array is in the most left in Figure 5. The list o f probabilistic bound-based feature array is shown in the middle in Figure 5, where each row represents n pairs of lower and upper bounds that the corresponding feature graph is contained n uncertain graph. The prefix search tree is in the right in Figure 5. We can observe that each element of feature array has a pointer pointing t he probabilistic bound-based feature array and another pointer pointing such feature in the prefix tree (Due to the limited space, we only show two pair pointers of f 1 and f code [21]) has also a pointer to find the corresponding location in the feature array. For example, feature f 2 is loaded in the prefix tree, but it is set as empty node after loading the selected feature set. Thus, f 2 is shown as a white node. On the contrary, f 1 is a selected feature and is stored in the prefix search tree as a blue node in Figure 5.

Therefore, the PS-Index has two advantages. 1) In the query phase, the PS-Index has the anti-monotonic property of pruning. In the other words, if f i is a prefix of f j and f i satisfies the pruning condition, f j will not be checked. 2) The depth-first-search-order-based index structure can maximize the pruning power.
For the remaining uncertain graphs after the filtering phase, we have to check their supergraph containment probabilities (SCP). Because calculating SCP is known to be a # P-hard problem, we focus on how to design an efficient sampling-based approximation algorithm to solve it in this section. In Section 5.1, we review some backgrounds of sampling techniques and propose a simple-random-sampling-based algorithm to calculate SCP . In order to improve the efficiency of calculating SCP , we design an unequal-probability-sampling-based algorithm in Section 5.2.
Since it is infeasible to calculate the SCP of the given query graph and an uncertain graph exactly due to the high computa-tional complexity, the sampling-based solutions are practical and efficient. According to the sampling perspective, the population of this sampling is the set of all possible world graphs, the SCP is the estimated unknown proportion, which is also called the estimated parameter because sampling is essentially an estimation problem.
To facilitate our discussion, we define the concept of supergraph containment checking, which is an independent Bernoulli trial.
D EFINITION 11. (supergraph containment checking) Given an uncertain graph ug , a possible world graph from ug , pw i a deterministic query graph q , the supergraph containment check-ing between q and pw i ( ug ) is where pw i ( ug )  X  q means that pw i ( ug ) is a subgraph of q .
Based upon the supergraph containment checking, we propose a simple-random-sampling-based (SRS) algorithm to calculate SCP , which is shown in Algorithm 1.

In the SRS algorithm ,wesample n possible world graphs. For each possible world graph, we check whether the possible world graph ug i is contained by the given deterministic query graph q . According to the supergraph containment checking, we can obtain the successful number of supergraph containment in n samples and Algorithm 1: Simple-Random-Sampling-based Algorithm (SRS) can calculate the mean as the estimated SCP . Moreover, Lemma 4 reports the bias and variance of SRS algorithm .
 L EMMA 3. (Unbiasedness and Variance of Simple-Random-Sampling Approach) The simple-random-sampling approach is unbiased. In addition, the variance of this approach is 1 n SCP (1  X  SCP SCP is the estimated SCP.

Proof (Sketch): According to Algorithm 1, we know that the estimator (estimated SCP )is SCP = 1 n n i =1 SCC ( pw i ( Therefore, the expectation of SCP is, Hence, the estimator SCP is unbiased.

Since SCC ( pw i ( ug )) is a random variable which is an indepen-dent Bernoulli trial, n i =1 SCC ( pw i ( ug )) is a random variable following the Binomial distribution, the variance of SCP is, Thus, the lemma holds.
Although the simple-random-sampling-based approach can esti-mate SCP , it is not suitable for large-scale uncertain graphs and the high accurate requirement. The high accuracy leads to very large size of samplings, and each sampling needs to do a supergraph con-tainment checking, which is a subgraph isomorphism test. Thus, the simple-random-sampling-based approach is infeasible for large uncertain graphs. Thus, we propose an efficient approximation al-gorithm, unequal-probab ility-sampling-based (UPS) algorithm ,to estimate SCP . The basic idea is to group the space of samplings to avoid 2 | V | + | E | sampling spaces and reduce the number of sub-graph isomorphism tests, where | V | and | E | are the size of vertices and edges of the corresponding deterministic graph of the given uncertain graph, respectively.

Based on our basic idea, we first introduce how to reduce the size of possible sampling spaces then discuss how to avoid the number of subgraph isomorphism tests. To facilitate our discussion, we introduce the concept of maximal common subgraph between a de-terministic query graph and an uncertain graph.
 D EFINITION 12. (Maximum Common Subgraphs (MCS) [14]) Given an uncertain graph ug , a deterministic query graph q ,the maximum common subgraphs of ug and q is the set of largest con-nected subgraphs of the corresponding deterministic graph of ug that is subgraph isomorphic to q , denoted as MS = { ms 1 Note that the size of a graph is measured by the number of edges. The number of maximum common subgraphs may not be unique. Figure 6: The Sampling Spaces of SRS and UPG Algorithms
For example, given the uncertain graph ug 2 in Figure 1 and the query graph q in Figure 2, they have only one maximum common subgraph ms , which is the rightmost one in Figure 2.

Based on the concept of maximum common subgraphs, we pro-pose an early stopping strategy, which can divide all possible world graphs into several groups and stop each sampling process as early as possible, in the following lemma. Since we only want to know which possible world graphs are contained or are not contained by the query graph, it is not necessary to sample each possible world graph exactly. Instead, we try to end each sample as early as possi-ble as long as the containment relationship is known.

L EMMA 4. (Early Stopping Strategy) Given an uncertain graph ug , a deterministic query graph q , the set of maximum common subgraphs MS = { ms 1 ,...,ms m } , and the current sampled graph g s (the sets of vertices and edges of g s are denoted as V or E in , the sets of vertices and edges which are sampled and do not appear in g s are denoted as V out or E out , respectively), this sampling can be stopped if the one of the following two conditions is satisfied,
Condition 1: g s must be contained by q if there is at least a maximum common subgraph ms i in MS such that V ug \ V mc i V are the sets of vertices and edges of ug and mc i , respectively.
Condition 2: g s must not be contained by q if V in \ V q E in \ E q =  X  ,where V q and E q are the sets of vertices and edges of q , respectively.

Proof (Sketch): For the condition 1, V ug \ V mc i and E ug E mc i means the sets of vertices and edges which belong to the corresponding deterministic graph of ug and are not contained by q . If the condition holds, these aforementioned vertices and edges do not appear in the current sampled graph g s , thus g s contained by q .

For the condition 2, V in \ V q =  X  or E in \ E q =  X  means that there are at least one vertex or one edge which is in g s contained by q . Hence, g s must not be contained by q under this condition. Thus, the lemma holds.
 We illustrate the early stopping strategy via the example.
E XAMPLE 4( Early Stopping Strategy ). Given an uncertain graph ug 2 in Figure 1, a query graph q in the leftmost of Figure 2, and their maximum common subgraph in the rightmost of Figure 2, we show the complete sampling space of ug 2 , which should include 2 | V | + | E | possible world graphs, in Figure 6(a). Each path in Fig-ure 6(a) corresponds to a sampling in SRS algorithm. Figure 6(b) shows the sampling space based on the early stopping strategy. We can find that each sampling does not need to traverse a path in-stead of ends as early as possible. Thus, the early stopped sampled graph usually includes a set of possible world graphs. Note that a sampling process must end if this sampling only satisfies any early Algorithm 3: RecursiveSampling (RS) stopping condition. Hence, it is im possible that multiple early stop-ping conditions hold at the same time. To sum up, we can observe that the size of sampling space based on the early stopping strategy is significantly smaller than that of SRS algorithm.

The early stopping strategy reduces the size of the sampling space, we further hope to avoid the number of subgraph isomorphism tests as well. Thus, we employ a classi cal unbiased unequa l-probability-sampling estimator, the Horvitz-Thompson estimator SCP HT which can not only depend on the distinct samples but also provide a smaller variance than that of the simple-random-sampling estima-tor. In other words, the duplicate samples are not considered. Thus, the number of subgraph isomorphism tests is significant smaller than that of simple-random-sampling estimator, which has to test subgraph isomorphism for each sample.
 D EFINITION 13. (Horvitz-Thompson Estimator ( SCP HT )[18]) Given an uncertain graph ug , a query graph q , the size of samples n , the weight of each sample based on the early stopping strategy w (1  X  i  X  n ) , the Horvitz-Thompson estimator is where  X  i =1  X  (1  X  q i ) n , q i is the sampled probability, v is the number of distinct sampled graphs.

Based on the early stopping strategy and the Horvitz-Thompson estimator, we design an efficient unequal-probability-sampling-based ( UPS ) algorithm. The pseudo codes of UPS algorithm is shown in Algorithm 2. This algorithm first finds the set of maximum com-mon subgraphs in line 1. In lines 3-7, the algorithm performs n samples. In each sample, it recursively call a sub-procedure, called as RecursiveSampling , to calculate the parameters w i and  X  Horvitz-Thompson estimator. In addition, the sampled graph is not duplicate of previous sampling, it is just computed into the estima-tor. The final estimator, namely SCP , is returned in line 8.
In Algorithm 2, the core is the sub-procedure, RecursiveSam-pling (RS) , which is shown in Algorithm 3. The two conditions of the early stopping strategy are used to end the recursive procedure in lines 1-4. If the two conditions cannot be satisfied, this algo-rithm continues to select a new vertex or edge to sample randomly in lines 5-9. Note that this algorithm always prefers to choose ver-tices since the probab ilities of edges are the c onditional probabili-ties under two corresponding vertices already appear. It is easer to satisfy the early stopping strategy if we first sample vertices.
In this section, we report the experimental results for the effi-ciency of proposed algorithms. In order to conduct a fair compari-son, all the experiments are performed on an Intel(R) Core(TM) i7 3.40GHz PC with 4GB main memory, running on Microsoft Win-dows 7. Moreover, all the algorithms were implemented and com-piled using Microsoft X  X  Visual C++ 2010.

In order to test our proposed methods, we use a real-world un-certain graph database and a synthetic dataset which is a classical deterministic graph datasets with the synthetic probability distri-bution. For the real dataset, it comes from a real protein-protein interaction (PPI) network database, STRING 1 , which includes the PPI networks of organisms. In a PPI network, vertices represent proteins, edges represent interactions between proteins, the labels of vertices are the COG functional annotations of proteins, and the existence probabilities of edges derive from the STRING database. We extract 1000 uncertain graphs from STRING. The average num-bers vertices and edges of 1000 uncertain graphs are 43.2 and 97.5, respectively. Moreover, the average existence probabilities of edges in our dataset is 0.486. Please note that each numerical value in this dataset is always a 3-digit integer within the interval between 150 and 999. In fact, the integer is the decimal value of the cor-responding probab ility. Besides the real uncer tain graph database, we allocate probabilities which follow Gaussian distribution to a classical deterministic graph databset. Assigning probabilities to deterministic database in order to generate uncertain data is widely accepted by the previous related works [10, 24, 23]. The determin-istic graph dataset, denoted AIDS [5], has been widely used to test deterministic graph queries. It extracts 10000 graphs from the orig-inal 43,905 structured chemical compounds. The average numbers vertices and edges of AIDS are 24.3 and 26.5, respectively. We set probabilities of vertices and edges with high mean (0.8) and low variance (0.1). The characteristics of and the default parameters above datasets are shown in Table 2. We also prepare the query sets and graph databases in a way similar to the existing uncertain graph queries [10, 24, 23]. Each query set q i contains 100 con-nected query graphs. Note that i in q i means the number of edges in q i ,suchas q 5 0 , q 1 00 , etc. We also randomly select 2K, 4K, 6K, 8K and 10K graphs from AIDS and set probabilities to them for the scalability test. In addition, th e sample size is set to be 1000 for SRS and UPS algorithms.
In this subsection, we verify the efficiency of the proposed al-gorithms and pruning strategies. We compare three algorithms: http://string-db.org/newstring_download/ Table 2: Characteristics and Default Parameters of Datasets NoPruning , SRSPruning ,and UPSPruning . PS-Index . NoPruning uses SRS algorithm in the verification phase and has on the prun-ing method (Theorem 2) in the filtering phase. Both SRSPruning and UPSPruning employ the PS-Index and pruning strategy but use SRS and UPS algorithms in their verification phase, respectively.
Varying Size of Query. Figures 7(a) and 7(b) show the total run-ning time of the three competitive algorithms w.r.t. size of query in STRING and AIDS datasets, respectively. When the size of query increases, we observe that the running time of all the algorithms goes up. UPSPruning is always the fastest algorithm, NoPruning is the slowest one, and SRSPruning is faster than NoPruning .
It is reasonable because UPSPruning and SRSPruning employ the PS-Index and the probabilistic pruning to avoid most SCP computation. However, NoPruning has no the pruning and only calculates SCP with each uncertain graph. Furthermore, UPSPrun-ing uses the early stopping strate gy and the unequa l-probability-sampling estimator to reduce the sampling spaces and avoid re-dundant subgraph isomorphism tests. Hence, UPSPruning outper-forms SRSPruning in the two datasets.

Varying Probabilistic Threshold. Figures 7(c) -7(d) report the running time w.r.t. probabilistic threshold . We can find that UP-SPruning is the fastest algorithm in most of time. Different from the results w.r.t size of query , we observe that, by increasing prob-abilistic threshold , the total running time reduces. Moreover, the changing trends of the running time of UPSPruning and SRSPrun-ing is relative stable. The pruning power of probabilistic pruning is further reported in the next subsection.
To better verify the effect of our proposed pruning, in this sub-section, we report the pruning ratio of the probabilistic pruning on Figures 7(e) -7(f). Due to the space limitation, we only show the pruning ratio w.r.t. size of query of the two sampling algorithms. The results of pruning ratio w.r.t other parameters are similar.
Varying Size of Query. Figures 7(e) and 7(f) show the pruning ratio w.r.t. size of query in STRING and AIDS datasets, respec-tively. The pruning ratio in STRING dataset is smaller than that on AIDS dataset. The smaller pruning ratio explains the reason that the computation saved in STRING is less than that in AIDS. Moreover, the less pruning ratio makes sense because the average probabilities of vertices and edges in AIDS follows the Gaussian distribution (mean=0.8, variance=0.1), most vertices and edges in AIDS likely appear. Thus, the probability of Pr ( f  X  ug ) is high, the pruning condition in Theorem 2 can be satisfied easily.
In this subsection, we report the verification time and the approx-imation quality of the two algorithms. However, due to the space limitation, we only show the verification time of the two sampling algorithms in STRING.
 Varying Size of Query. Figures 7(g) shows the comparison of SRS and UPS algorithms in the verification step. We can observe that UPS algorithm outperforms SRS algorithm in efficiency. In particular, UPS is significantly faster than SRS when the size of query is large. This result also verifies that the early stopping strat-egy and unequal-probability-sampling-based estimator can reduce the sample space and avoid duplicate subgraph isomorphism tests. (g)
Approximation Quality. Besides offering efficient running time, the accuracy of sampling-based approximation algorithms is the other important evaluation criterion. We use the precision which the accuracy of approximation algorithms. Please note that AR means the result generated from the approximation algorithm, and ER is the result generated from the exact algorithm. Table 3 shows the precision and the recall w.r.t varying probabilistic threshold in the STRING dataset. That is because the variance of UPS estima-tor is usually lower than that of SRS .
In this subsection, we report t he scalability of our proposed algo-rithms. In Figure 7(h), increasing the number of uncertain graphs in the dataset from 2k to 10k, we observe that the running time curves of the UP SP runing and SRSPruning algorithms al-most change linearly. However, the running time curve of NoPrun-ing algorithm is exponential. In add ition, the slopes of the curves of UP SP runing and SRSPruning are different. The slope of UP SP runing is smaller than that of SRSPruning . This result is reasonable because UP SP runing and SRSPruning use the PS-Index and probabilistic pruning techniques. Most unqualified uncertain graphs are pruned in the filtering step. Furthermore, the early-stopping-strategy can reduced the running time in each sam-ple, thus slope of curve of UP SP runing is smaller.
In this section, we will review the related work from two cate-gories, query processing in deterministic and uncertain graphs.
There are two types of closely related graph queries in determin-istic graphs: subgraph query and supergraph containment query. Due to the limited space, we only discuss the related work of su-pergraph containment query in this subsection.
 Supergraph containment query aims to find all graphs g i  X  and g i  X  q from the given graph database GD . Most existing solutions adopt another filtering logic, called the exclusion logic [5], to avoid unnecessary subgraph isomorphism tests.

Firstly, Chen et al. [5] first proposed the concept of supergraph containment query and design a contrast-subgraph-based index ( c-index ). Especially, in order to obtain the maximum pruning power, c-index designs a redundancy-aware feature selection method. Zhang et al. [25] proposed a novel tree structure, GPTree ,tointegrate the graph database for saving the redundant subgraph isomorphism tests. In addition, a set of significant frequent subgraphs is mined as the indexing features in this method. Recently, Cheng et al. [6] design a new low-cost index, IG-index , based on a method of graph integration, which is used to approximately share the most com-mon subgraphs in the graph database. In addition, based on this low-cost index, some result graphs can be directly returned with-out subgraph isomorphism test. Thus, the verification process will be dramatically speeded up. However, in uncertain scenario, the aforementioned approaches cannot be extended easily since edges in common subgraphs may have dif ferent probab ilities. If we only store the lowest probability fo r each edge of a common subgraph, the pruning effect of the index will be reduced significantly.
In this subsection, we mainly review four kinds of uncertain graph query techniques. A probabilistic XML ( PXML ) database can be considered as a special uncertain graph database. Nierman et al. [12] first proposed a simple PXML model, ProDB , which used the probabilistic tree structure to model PXML databases. Kimelfeld et al. [11] summarized previous works of probabilistic XML and provided a series of efficient algorithms for different probabilistic XML models. Moreover, based on the PrXML { ind,mux } model, Chang et al. [4] proposed the efficient ranking algorithm for prob-abilistic twig matching results. The aforementioned studies mainly focused on the efficient probability computation over uncertain tree. Thus, they may have polynomial-time solution due to the constraints of the XML data. However, our work aims to a general uncertain graph query, which is # P-hard problem.

Besides querying over PXML databases, distance-based queries over uncertain graphs also attracted much attention recently. Yuan et al. [22] proposed the shortest path query over general uncertain graphs under the possible world semantics. Hua et al. [9] defined several probabilistic shortest path queries over uncertain road net-works. In addition, Jin et al. [10] provided the work of reacha-bility query over uncertain graph uncertain the possible world se-mantics. Potamias et al. [13] extended the concept of the uncertain distance and proposed several definition and efficient solutions of k NN query over uncertain graphs. The above queries mainly base upon the concept of uncertain distances, which becomes a random variable in the uncertain graphs. However, our work handles mul-tiple uncertain graphs rather than an uncertain graph.

Since PPI networks are considered as real uncertain graph datasets, the other related topic is to handle PPI networks data in bioinfor-matics. [7] aimed to predict protein functions based on different level neighbours and topological weights. Furthermore, [17] pro-vided a comparison of different approaches estimating the protein interaction confidence, namely the probabilities of edges in uncer-tain graphs. Therefore, the aforementioned two works considered different issues with our paper.

In addition, the most closely related research to our work is about probabilistic subgraph query over uncertain graphs. Yuan et al. pro-posed the first work of probabilistic subgraph search over uncer-tain graphs [24]. Two efficient probabilistic pruning methods and a probabilistic inverted index were designed. Furthermore, Yuan et al. [23] defined the problem of probabilistic subgraph similar-ity search over uncertain graphs and provided the efficient solu-tion, which included an effective matrix index and the lower and upper bound-based probabilistic pruning met hods. Even though the two works utilizes the filtering-and-verification framework, our solution has the essential differences with the uncertain subgraph queries. Uncertain subgraph queries need to construct two indexes, deterministic graph index and probabilistic index, for the deter-ministic and probabilistic pruning, and aim to calculate the sub-graph isomorphism probability. However, for the probabilistic su-pergraph containment query, the deterministic index has no contri-bution. Our work needs to efficiently handle the supergraph con-tainment probability instead of th e subgraph isomorphism proba-bility. In addition, Zou et al. [27] proposed the problem of finding top-k maximal cliques in an uncertain graph. Besides the afore-mentioned work of uncertain graph queries, uncertain graph mining has also been studied recently. Zou et al. presented mining algo-rithm based on expected support s emantic [28] an d probabilistic semantic, respectively [26].
In this paper, a new uncertain graph query, probabilistic super-graph containment query, is proposed. We prove that this problem is # P-hard. Due to the high computational complexity, a proba-bilistic supergaph filtering strategy and a filtering-and-verification framework have been designed in order to avoid tedious computa-tion. Moreover, a novel probabilistic inverted index, PS-Index ,is developed to speed up the query processing. An unequal-probability-sampling-based algorithm is also proposed to efficiently compute supergraph containment probabilities in the verification phase. Ex-tensive experiments on both real and synthetic datasets verify the effectiveness and efficiency of the proposed methods.
The authors thank Prof. Bogdan Cautis and the anonymous re-viewers for their insightful and constructive comments. This work is supported in part by the Hong Kong RGC Project N_HKUST637/13, National Grand Fundamental Research 973 Program of China un-der Grant 2012-CB316200, National Natural Science Foundation of China (NSFC) Grant No. 61328202, Microsoft Research Asia Gift Grant, Microsoft Research Asia Fellowship 2012 and Google Faculty Award 2013.
