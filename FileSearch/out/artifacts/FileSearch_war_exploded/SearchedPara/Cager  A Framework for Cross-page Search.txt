 Existing search engines have page as the unit of information of retrieval. They typically return a ranked list of pages, each being a search result containing the query keywords. This within-one-page constraint disallows utilization of re-lationship information that is often available and greatly beneficial. To utilize relationship information and improve search precision, we explore cross-page search, where each answer is a logical page consisting of multiple closely related pages that collectively contain the query keywords. We have implemented a prototype Cager , providing cross-page search and visualization over real datasets.
 Categories and Subject Descriptors: H.3.3 [Informa-tion Storage and Retrieval]: Information Search and Retrieval X  Search process General Terms: Algorithms, Design, Performance Keywords: Cross-page search, Keyword search over graphs
Information retrieval and Web search can be considered as a process of using what we know to retrieve what we want. What we want is the information need and hopefully to be returned by search engines as search results. What we know regarding the information need is typically represented as a set of query keywords.

Existing search engines have page as the unit of informa-tion of retrieval. Given a query as a set K of keywords, they typically return a ranked list of pages, each being a search result containing K . This within-one-page constraint disallows utilization of relationship information that can be greatly beneficial. For example, we want to visit p , the homepage of Jiawei who has two coauthors Edward and David . Edward and David may not appear on p and this relationship information cannot be utilized to retrieve p . In this study we explore cross-page search that returns logical pages as search results. A logical page consists of multiple physical pages that collectively contain the query keywords. Cross-page search as keyword search over graphs.
 When a user issues a query K , the keywords in K are se-mantically related, forming a coherent topic or theme with respect to the user X  X  information need. A search result p is relevant if the query keywords in p conform to their intended semantic relationship. Information retrieval techniques use certain syntactic relationship to capture this semantic rela-tionship among query keywords. For example, search en-gines commonly require K to co-exist within one page for the page to be considered relevant.

For a logical page P that crosses multiple pages, the syn-tactic relationship among query keywords needs to be es-tablished from the syntactic relationship among the pages in P . Thus, to facilitate cross-page search over a corpus, we must first establish the relationship among pages in the corpus. In particular, we can build one or more data graphs over the corpus, where nodes denote pages and two nodes are connected if they are semantically related. For example, based on the information that Jiawei has Edward and David as coauthors, we can connect the homepage of Jiawei to the ones of Edward and David . Hyperlinks can also be used as edges to connect nodes. Building data graphs is essential to cross-page search and related to information extraction and data integration. It is not the focus of this study.
After transforming the corpus into a data graph, cross-page search can be modeled as a problem of keyword search over graphs, which has received much attention recently from the fields of databases, data mining, information re-trieval and Web search [6, 2, 1, 3, 4, 8]. Graphs are a con-venient generic data model for structured, semi-structured, and unstructured data.

Existing models. Over the years, various models and algorithms for keyword search over graphs have been pro-posed. Most existing models are tree-based. A typical ex-ample is to search for Steiner trees as query answers [6, 2]. Non-tree-based models include the r -radius Steiner graph model [5] and the multi-center induced graph model [7]. Ex-isting models are mainly proposed in the context of keyword search over relational databases, assuming in-memory data graphs. This assumption is unrealistic in the Web setting, where we must deal with massive, disk-resident data graphs and provide a comprehensive solution for effective and effi-cient query processing. r -hop constraint. We propose a framework for scalable cross-page search, defining a so-called r -hop constraint that can be incorporated into any answer model to form answers that can be searched efficiently. In addition, the constraint will not hamper the effectiveness of the answer model.
Definition 1. ( r -hop constraint and r -hop graphs) Let G be a data graph and C be an answer graph, which is a sub-graph of G . The r -hop constraint on C requires that every connected component of C must be reachable from some key-word node outside the component within r hops. An answer graph is an r -hop graph if it satisfies the r -hop constraint.
The r -hop constraint has an important implication that every node in an r -hop graph must be reachable from some keyword node within r hops. However, the two constraints are not equivalent. The latter cannot imply the former.
Example 1. Suppose r = 1, a star or a clique consisting of only keyword nodes is an r -hop graph. In Figure 1, r = 2 and the dark-colored nodes denote keyword nodes. (a) and (c) are not 2-hop graphs. In (a), the left keyword node is not reachable from another keyword node within 2 hops. In (c), every node is reachable from some keyword node within 2 hops; however, the connected component containing the left three nodes is not.

As to be detailed later, r -hop graphs can be searched ef-ficiently by properly indexing G . Suppose there are l key-words in query K , only l number of IO X  X  are needed to re-trieve a much smaller subgraph of G that can well fit into memory. It is provable that the retrieved subgraph contains all the r -hop graphs with respect to K . Then, searching can be performed on the small in-memory subgraph, instead of the original data graph G .

The r -hop constraint is indeed a relevancy constraint. It disallows  X  X angling X  component in an answer graph that has no strong syntactic and semantic relationship with keyword nodes. In the context of cross-page search, it is a necessary relevancy constraint and would not become a functional re-striction of the original answer model.

Contributions. (1) We study cross-page search as a problem of keyword search over graphs, targeting scalable query processing that existing models fail to provide for disk-resident data graphs. (2) We propose a generic frame-work, defining the r -hop constraint that can be effectively incorporated into any answer model to enable efficient query processing. (3) We implement a prototype Cager , providing cross-page search and visualization over real datasets.
Let K = { k 1 ,  X  X  X  , k l } be a query represented by a set of keywords. Let G ( V, E ) be a data graph, where V represents pages and E represents semantic connections (e.g., hyper-links) among pages. G may not fit into memory. In this study we assume an unweighted, undirected graph. How-ever, our framework can be easily extended to weighted (both nodes and edges), directed graphs.

An answer C for query K is a subgraph of G that contains all or some keywords in K . A node in C can be a keyword node that maps to one or more keywords, or a structural node that connects keyword nodes. We assume C satisfies the r -hop constraint and is an r -hop graph.

To search for the answer graphs efficiently for query pro-cessing, we take advantage of an r -radius graph index I for G that extends the conventional inverted index.

Two observations. We start with introducing two ob-servations that motivate the way our graph index I is con-structed and used in query processing.

Let N r ( v ) denote the set of nodes that are reachable from node v within r hops. Let G r ( v ) denote the r -radius neigh-borhood of node v , which is the induced subgraph of G from N ( v ). The following observation states that the union of all answer graphs is a subgraph of G 0 ( V 0 , E 0 ), the union of the r -radius neighborhoods of all keyword nodes in G . Observation 1. Let v 1 ,  X  X  X  , v n be the keyword nodes in V with respect to query K . Let C 1 ,  X  X  X  , C m be the answers that are r -hop graphs. S m i =1 C i is a subgraph of G 0 S
This observation can be easily proved based on the fact that every node in an r -hop graph must be reachable from some keyword node within r hops.

Note that all existing models, tree-based or bounded sub-graphs, produce answers that are unions of keyword node-to-keyword node paths. G 0 ( V 0 , E 0 ) contains some nodes and edges that are not on any such path. The following obser-vation states that such nodes and edges cannot be part of any answer graph.

Observation 2. Let P h denote the set of keyword node-to-keyword node paths of length h in G 0 ( V 0 , E 0 ). Let C be the answers that are r -hop graphs. S m i =1 C i is a subgraph
Obviously, G 00 is a subgraph of G 0 . Based on Observation 1, we construct a graph index I that allows us to retrieve G 0 with minimal IO. Based on Observation 2, we derive G 00 from G 0 by applying simple intersections. Then, we can perform searching on G 00 , a much, much smaller portion of the data graph G . These are the fundamental ideas based on which our query processing framework gains efficiency.
Retrieving G 0 from graph index I . Basically, I stores the r -radius neighborhood G r ( v ) for each v  X  V . For a keyword k i , we use I h ( k i ) to denote the set of nodes in V that are h -hops away from some node that maps to k i . For example, I 0 ( k i ) denotes the set of nodes in V that map to k . Let I ( k i ) denote the postings list for keyword k i conventional inverted index, I ( k i ) = I 0 ( k i ) for each keyword in the dictionary. Our graph index I extends the inverted index, where I ( k i ) = I 0 ( k i )  X  I 1 ( k i )  X  I 2 ( k addition, the edges from the nodes in I h +1 ( k i ) to the nodes in I h ( k i ) are also stored in the form of pointers.
For a query K = { k 1 ,  X  X  X  , k l } , V 0 = S l i =1 I ( k retrieve G 0 , we can simply read I ( k i ) for each keyword in K into memory, together with the corresponding edges. G 0 can well fit into memory, and the retrieval takes only l number of IO X  X .

Obtaining G 00 from G 0 . Let P h ( k i , k j ) denote a set of paths of length h connecting two keyword nodes k i and k j G 00 contains keyword node-to-keyword node paths of lengths up to r . Any such path belongs to P r ( k i , k j ) for some h, i, j where 0  X  h  X  r and 1  X  i, j,  X  l . It is possible that k where the paths in P r ( k i , k j ) connect two nodes that map to the same keyword. In case h = 0 and k i 6 = k j , P h Algorithm 1 Query Processing Framework Input: G , K , I : G is a data graph. K is a query represented Output: A ranked list of answers that are r -hop graphs. 1: for each i from 1 to l 2: retrieve I ( k i ); 3: for each h from 0 to r 4: perform I h 1 ( k i )  X  I h 2 ( k j ), where h 1 + h 2 5: search G 00 ( V 00 , E 00 ) with an algorithm for a pre-defined 6: score and rank the answers; corresponds to a degenerate set of paths, each being a single node that maps to both keywords k i and k j .

To obtain P h ( k i , k j ), we can perform an intersection op-eration on I h 1 ( k i ) and I h 2 ( k j ), where h 1 + h why, I h 1 ( k i )  X  I h 2 ( k j ) contains a set of nodes, each connect-ing to some k i node in h 1 hops and some k j node in h 2 Note that there can be different combinations of h 1 and h 2 that add up to h . We choose the pair that has the smallest section time.

Search answers on G 00 . As we have established previ-ously, the union of all answer graphs, G 00 , G 0 and G are in turn subgraphs. We only need to search G 00 for the answers. In this study, we target a generic scalability solution for any existing model, thus we do not provide the search algorithm that is attached to the model. The query processing frame-work is summarized and commented in Algorithm 1.
To demonstrate and evaluate the utility of our framework, we have implemented a prototype Cager (http://ir.sdu.edu. cn/cager/) on DBLP coauthorship data graph (dblp.uni-trier.de/xml, 834,609 authors, 585,468 papers) data graph with author profile pages as nodes and coauthorship as edges.
Answer model. Cager used r = 1 for the r -hop con-straint, and maximal star as the actual answer model. In particular, in an answer C , all nodes are keyword nodes and they form a star. In contrast to most existing models that search for minimal trees, we return maximal stars in order to reduce redundancy.
 Architecture. Figure 2 shows the architecture of Cager . From the dataset dblp.xml, the preprocessor builds a data graph G . It first extracts paper titles and authors. For each author, it constructs a profile page containing the papers from the author. Then, it creates edges between nodes based on the coauthorship information. From the data graph G , the indexder builds a r -radius ( r = 1) graph index I .
Note that the format of our profile pages differs from that of DBLP. In particular, we do not list author names for papers. We force author names to appear in different pages for the purpose of demonstrating cross-page search using author names as queries.
When a user issues a query K , the parser parses K and passes it to the query processor. The query processor first loads G 0 ( V 0 , E 0 ) from the index I for K . Then, it uses sev-eral intersections to obtain G 00 ( V 00 , E 00 ). Then, it searches on G 00 ( V 00 , E 00 ) for query answers that are maximal stars containing K . Then, it scores and ranks the answers. Then, the ranked answers are fed to the visualizer, which presents to the user a ranked list of answer graphs.

Demonstration scenario. Suppose we want to search for the profile page of either Jiawei , Edward or David who has coauthored with other two. We may issue a query  X  X i-awei, Edward, David X . From the results we can see that, although these author names are not selective (numerous dif-ferent Jiawei X  X , Edward X  X  and David X  X ), we can still quickly locate the author page we want because there are a very selective number of answers that conform to the required coauthor relationship.

For each query, a ranked list of answer graphs will be dis-played, each being a logical page containing multiple pages. The relationship among pages is also clearly presented.
This work was supported in part by the NSF of China (61103151, 61173068), the Excellent Middle-Aged and Youth Scientists Foundation of Shandong Province of China (BS201 2DX017), and the Research Enhancement Program of Texas State University. [1] S. Agrawal, S. Chaudhuri, and G. Das. Dbxplorer: A [2] G. Bhalotia, A. Hulgeri, C. Nakhe, S. Chakrabarti, and [3] V. Hristidis and Y. Papakonstantinou. Discover: [4] V. Kacholia, S. Pandit, S. Chakrabarti, S. Sudarshan, [5] G. Li, B. C. Ooi, J. Feng, J. Wang, and L. Zhou. Ease: [6] W.-S. Li, K. S. Candan, Q. Vu, and D. Agrawal. [7] L. Qin, J. X. Yu, L. Chang, and Y. Tao. Querying [8] C. Sun, C.-Y. Chan, and A. K. Goenka. Multiway
