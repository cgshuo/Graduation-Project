 Data completeness is commonly regarded as one of the key aspects of data quality. With this paper we make two main contributions: (i) we develop techniques to reason about the completeness of a query answer over a partially complete database, taking into ac-count constraints that hold over the database, and (ii) we imple-ment them by an encoding into logic programming paradigms. As constraints we consider primary and foreign keys as well as finite domain constraints. In this way we can identify more situations in which a query is complete than was possible with previous work. For each combination of constraints, we establish characterizations of the completeness reasoning and we show how to translate them into logic programs. As a proof of concept we ran our encodings against test cases that capture characteristics of a real-world sce-nario.
 H.2.7 [ Database Management ]: Database Administration X  Re-pository, Data warehouse, Security, integrity, and protection Data Quality; Data Completeness; Answer Set Programming
In database applications such as information integration and de-cision support, one is interested in data sets that are complete, in the sense that the data represent all relevant facts that hold in the real world. In many situations, though, it is only possible to guar-antee partial completeness of the data, which means that for certain aspects of the application domain the data are complete, but not for others. In such a situation, one would like to know at least whether the available data are sufficient to answer a given query completely, that is, whether the answers to the query over the available data are the same as if the data set were complete [5, 6, 8, 9].
 School Information System. A typical scenario is the manage-ment of administrative data that are contributed by people. An ex-ample is the management of school data in the province of Bolzano, c  X  which motivated the work reported here. Data in the school infor-mation system of the province are often incomplete because each school is individually responsible for inserting its data into the sys-tem and because for certain kinds of data the contribution is op-tional. Decision makers, however, need to know whether or not the statistics on which they base the allocation of resources to schools are derived from complete data. As often some parts of the data are complete, one would like to automatically provide guarantees that some query answers are guarantees and hint at those that need further checks.
 Example. Consider the following example of a partially com-plete school database. Among other data, the database contains facts about pupils and classes, e.g.,  X  X ohn belongs to class a1 at Newton school X , pupil ( john , a1 , newton ) , or  X  X lass a1 at Newton school is at level 1 and it belongs to the science branch X , class ( a1 , newton , 1 , sci ) .

Assume we know that we have all pupils from class a1 and all pupils from class b2 at Newton school. Thus, the query that asks for  X  X ll pupils in class a1 at Newton school X , Q a1n ( N )  X  pupil ( N , a1 , newton ) , has a complete answer. However, if we consider the query that asks for  X  X ll science pupils at Newton school X , Q pleteness assumptions above we cannot say whether the query an-swer of Q sn is complete. Note that, in principle, there can be other classes different from a1 and b2 .

Databases typically come with integrity constraints such as pri-mary and foreign keys. But there can be also other kinds of con-straints that restrict the domains of attributes.
 Example (cont X  X ). Continuing the example, assume that there is a constraint on the class relation, saying that  X  X f a class at Newton school belongs to the science branch then that class has a class code among a1 and b2  X , expressed with class { school = newton , branch = sci } [ ccode ] = { a1 , b2 } . We call this a conditional finite domain constraint.
 Now we can reason in the following way. The query Q sn selects Newton pupils from the science branch. Since the above constraint holds for the class relation, and pupil is joined with class , pupils in Q sn must be either from class a1 or b2 . Considering that we are complete for a1 and b2 , as assumed above, we conclude that we are complete for all pupils selected by Q sn . Assume further that there exists a foreign key from pupil to class in our database, pupil [ ccode , sname ]  X  class [ ccode , sname ] . Then we have all records of class that can be joined with pupil , i.e. we have all class records selected by Q sn . Overall, assuming the constraint and the foreign key, we can conclude that the answer to Q sn is complete.
 Related Work. Motro [17] was the first to formalize incomplete databases and completeness of queries. Levy [15], in addition, in-troduced a format for assertions that say which parts of a relational database are complete. We call these assertions table complete-ness or TC statements. He raised the problem to determine whether a set of such TC statements imply that some given query can be answered completely. Razniewski and Nutt [20] showed how to re-duce this completeness reasoning problem to containment of con-junctive queries [4] and gave a comprehensive analysis of its com-plexity, considering several variants of queries and assertions. In particular, they showed that for the most expressive queries and as-sertions they considered, completeness reasoning is  X  P 2 Such a degree of difficulty is reached, for instance, if queries and assertions are expressed by conjunctive queries and if finite-domain constraints hold over the database.
 Contributions. In this work, we consider databases that are in-complete in that entire tuples are missing. We address the problem of completeness reasoning for conjunctive queries and for TC state-ments in the presence of constraints. We generalize the previously investigated problem by taking into consideration two kinds of con-straints. The first are primary and foreign key constraints, the sec-ond one are a new kind of constraints, that we call conditional finite domain constraints (CFDCs), which restrict the domain of relation attributes depending on the values of other attributes. CFDCs are more expressive than classical finite domains constraints (FDCs). On the other hand, if we have a database instance at disposal, rea-soning about completeness with a database instance is typically in-tractable [20], and therefore not feasible for large instances in real-istic scenarios. In this respect, we expect that CFDCs offer a good trade-off that allows for feasible running times while still carrying more information than FDCs.

Further, we provide a new approach to completeness reasoning which gives rise to an implementation technique of the problem that was not obvious from previous work [19]. A demonstrator system, MAGIK, which realizes our approach and which is publicly acces-sible on the Web 1 has been implemented based on the techniques in this paper and was presented in [21] and [22].

Our approach consists of two steps. First, we develop theorems that provide a syntactic characterization of the reasoning tasks for each combination of constraints. Based on these, we develop en-codings of the problems into logic programming formalisms, where disjunction occurs in the head of the rules that encode CFDCs. One can run such encodings using Answer Set Programming (ASP) solvers (or Prolog engines if there are no CFDCs) such that the re-sulting program under cautious reasoning entails a test fact if and only if the original problem has the answer  X  X es X . While logic pro-gramming is conceptually close to the characterizations, they can in principle also be used to establish encodings into other paradigms.
In the paper we present some of the proofs. For more technical ones we only provide the intuition, due to the space limitations. Complete proofs can be found in [18].

We tested our encoding using two state-of-the-art ASP solvers, dlv 2 [14] and clingo 3 [10], and one Prolog implementation, swi 4 . The obtained results show that our encoding is able to pro-cess inputs that mirror the requirements of real world systems.
The remainder of the paper is organized as follows. In Section 2, we recall basic definitions from database theory and fix our nota-tion. Section 3 formally introduces completeness reasoning. In Section 4, we characterize completeness reasoning in the absence of constraints and present our encoding for this case. Characteri-zation and encoding are generalized in Section 5 to take account of key and foreign key constraints, and in Section 6 to conditional finite domain constraints into account, while the combination of both is studied in Section 7. Section 8 investigates the problem of finding a complete generalization of an incomplete query. Section 9 reports on our experiments and Section 10 concludes. Relational Databases and Conjunctive Queries. We assume an infinite set of constants, dom , and a database schema,  X  denote the arity of R . In the following, we assume the schema to be fixed. For a relation R with arity n , an atom is an expression R ( t 1 ,..., t n ) , where t 1 ... t n are either elements of dom or variables. We denote constants with lower-case and variables with upper-case letters. A database instance D is a finite set of ground atoms, that is, atoms that contain only constants. We sometimes refer to the atoms in an instance as facts. For a relation R , we denote as R ( D ) condition is a set of atoms.

A conjunctive query is written as Q (  X  X )  X  B , where B is a con-dition and  X  X is a tuple of variables, each of which occurs also in B . We call B the body of Q , the variables in  X  X the distinguished vari-ables and the other variables in B the nondistinguished variables . Given a conjunctive query Q (  X  X )  X  B and an instance D , an answer to Q is a tuple  X   X  X , where  X  is an assignment of domain values to variables such that  X  B  X  D . The set of all answers to Q over D is written as Q s ( D ) . Similarly, we define Q b ( D ) as the bag of answers that contains as many copies of a tuple as there are assignments re-turning it. We say that Q is evaluated under set or bag semantics, respectively, if we refer to the set or bag of answers.
 Constraints. Database systems allow one to formulate condi-tions, so-called (integrity) constraints, that all instances of a data-base have to satisfy. Many of them can be captured in logic and allow for more inferences when reasoning about instances and que-ries. In this paper, we consider key constraints, foreign key con-straints, and conditional finite domain constraints.

A primary key (PK) constraint has the form Key ( R , A ) , where R is a relation symbol and A is a sublist of att ( R ) . A foreign key (FK) constraint has the form R [ A ]  X  S [ B ] , where R , S , are relations, A is a sublist of att ( R ) , and B is from Key ( S , B ) . Satisfaction of PK and FK constraints are defined as usual (cf. [1]).

In this paper, we also consider weakly acyclic sets of FK con-straints, which have been introduced by Fagin et al. For the defini-tion, we refer to their paper [7].

A conditional finite domain (CFD) constraint has the form R { A = constants of the same length as A , a is an attribute from att ( R ) that is not in A , and W is a set of constants. An instance D satisfies such ilarly. Alternatively, if A = a 1 ,..., a n and  X  v = v the condition A =  X  v as a list of equalities, a 1 = v 1 example, the CFD constraint that states  X  X  class at Newton school from the science branch has as code either a1 or b2  X , is expressed as class { school = newton , branch = sci } [ ccode ] = { a1 , b2 } . If A and  X  v are empty in a CFD constraint, we simply write R [ a ] = W and call this a finite domain (FD) constraint.

We will use K and F generically to denote sets of FK, and CFD constraints, respectively. Logic Programming. A disjunctive rule has the form where the A  X  X  and B  X  X  are atoms (see [11]). If k = 1, that is, the head consists of a single atom, we say that the rule is a Horn rule. A fact is a Horn rule with empty body (we omit  X   X   X ). A rule with empty head (the empty disjunction) is a denial . (We avoid the common term  X  X ntegrity constraint X  in this paper to avoid confusion with integrity constraints over databases.) An answer-set program is a finite set of disjunctive rules. For the theory of answer set programs we refer to [23] and [3]. A positive logic program contains only Horn rules. Positive logic programs can be executed under SLD resolution as implemented in Prolog [2]. Running Example. Our examples build upon a toy schema from the school world with the three relations Here, pupil ( fred , a1 , newton ) means that Fred is a pupil of class a1 at Newton school; class ( a1 , newton , 1 , sci ) means that class a1 at Newton school is a 1 st level class that belongs to the science branch; and takes ( fred , chess ) means that Fred is taking chess as an extracurricular activity.

Underlined attributes indicate the primary key, which in our no-tation can be expressed as the key constraints Key ( pupil , { name } ) , also consider two FK constraints, which say that every class, iden-tified by class code and school name, referred to by a pupil tuple occurs in the class relation, and every pupil name referred to by a takes tuple occurs in the pupil relation. Formally, this is expressed as pupil [ ccode , sname ]  X  class [ ccode , sname ] and takes [ name ]  X  pupil [ name ] . Finally, we consider a CFD constraint that restricts classes at Newton school to belong either to the science or the hu-manities branch, expressed as class { sname = newton } [ branch ] = { sci , hum } .
 The conjunctive query Q s1n , defined by the rule asks for  X  X he names of all pupils from Newton school of the 1 that attend a class from the science branch X .
 Query and Table Completeness. When stating that data is in-complete, one must have a conceptual complete reference. We model an incomplete database in the style of [17] as a pair of database instances D = ( D i , D a ) , where D a  X  D i . Here, D the ideal state and D a the available state. In an application, the state stored in a DBMS is the available state, which often represents only a part of the facts that hold in reality. The facts holding in reality constitute the ideal state, which however is unknown. (Later on we will introduce table completeness statements as a way to express meta-information about the extent to which the available state cap-tures the ideal state.)
Data are accessed by posing queries. We would like to know whether a database has sufficient information to answer a query completely, that is, whether the query is complete. If we can infer from meta-information that a query is complete, we know that the answer we receive over the available database is the same as the one we would get over the (hypothetical) ideal database.
We write Compl s ( Q ) and Compl b ( Q ) , respectively, to indicate that Q is complete under set or bag semantics. The first state-ment is satisfied by an incomplete database D = ( D i , D satisfied if Q b ( D i ) = Q b ( D a ) .

With table completeness (TC) statements we specify that parts of a table are complete. A TC statement, written Compl ( R (  X  s ) ; G ) , has two components, a relational atom R (  X  s ) and a condition G . In the sequel, we will denote a TC statement generically as C . As an example, consider The first statement asserts that the table pupil contains all records of pupils from science classes, while the second asserts that the table class contains all records of classes at level 1.

To define the semantics of a TC statement C , we associate a query Q C (  X  s )  X  R (  X  s ) , G to it. Then C is satisfied by D = ( D written D | = Compl ( R (  X  s ) ; G ) , if Q C ( D i )  X  R ( D the ideal instance D i is used to determine those tuples in the ideal version R ( D i ) that satisfy G , and that the statement C is satisfied if these tuples are present in the available version R ( D a the query associated to C as Q C . For instance, the query associated
To reason about completeness, we define for every set C of TC statements the operator T C that maps database instances to database instances. If C is a TC statement about R , then we define T { R (  X  t ) |  X  t  X  Q C ( D ) } . For C we define The operator T C is monotonic, and for every instance D , the pair ( D , T C ( D )) is an incomplete database satisfying C , and T smallest set (wrt set inclusion) for which this holds. We formalize this with the following claim that we need for the proofs later on.
P ROPOSITION 1 ([20]). Let C be a set of TC statements. Then a) T C ( D )  X  D, for all database instances D; b) ( D i , D a ) | = C iff T C ( D i )  X  D a , for all D
We say that C entails the completeness of Q with respect to set semantics, written C | = Compl s ( Q ) , if every incomplete database D that satisfies the statements in C , also satisfies Compl meaning of  X  C | = Compl b ( Q )  X  is defined analogously.
The completeness reasoning problem is to check, given C and Q , whether the entailments above hold. An instance of this problem for set semantics is to check whether { C sci , C lev1 }| = Compl (which intuitively holds and which we prove to hold in Section 4).
Let F be a set of CFD constraints and K be a set of key and FK constraints. We say that D = ( D i , D a ) satisfies F (resp., K ) if D satisfies F (resp., K ). Note that, due to D a  X  D i , this implies that also D a satisfies F and that D a satisfies the key constraints in K . We say that K is enforced over D if both D i and D a satisfy K . If D satisfies K , this means that in the real world, represented by the ideal database, the FK constraints hold. If K is enforced over D , then the constraints of K hold also over the available database. For instance, we may know that all pupils at our school belong to a class (because there are no external pupils), but the information about the levels and branches of classes contained in the relation class has not been entered into the available database. In that case, D satisfies pupil [ ccode , sname ]  X  class [ ccode , sname ] , but the constraint is not enforced. We say that C entails the completeness of Q wrt F , and write C | = F Compl s ( Q ) , if every D that satisfies both C and F , also satisfies Compl s ( Q ) . Analogously, we define  X  | = K means that only such D  X  X  are considered where K is enforced.
From [20] we know that the completeness reasoning problem, both for set and bag semantics, can be reduced to query contain-ment (cf. [4] and [13]). Reasoning in the presence of FD constraints can be reduced to containment with respect to FD constraints [19].
In previous work, Razniewski and Nutt reduced completeness reasoning to query containment by which they readily obtained complexity results [20]. However, the reduction did not give rise to an implementation technique. In this paper, we will reduce com-pleteness checking to the question whether a test query returns a specific result over a test database. We will then use these char-acterizations to translate completeness checks into logic programs that can be executed by ASP or Prolog engines.

In the rest of the paper, we always consider a set of TC state-ments C and a conjunctive query Q defined by the rule Q ( R (  X  t 1 ) ,..., R n (  X  t n ) .
 Characterizing Completeness Reasoning. While developing our approach, we illustrate it with an example. Consider the query Q s1n in (1) and the set C sci,lev1 = { C sci , C lev1 } comprising the TC statements in (2) and (3). Suppose D = ( D i , D a ) satisfies C Consider an answer, say n 0 , returned by Q s1n over the ideal instance D . Then D i contains two atoms of the form pupil ( n 0 , c and class ( c 0 , newton , 1 , sci ) . Now, due to C sci pupil ( n 0 , c 0 , newton ) , and due to C lev1 , the atom class ( c sci ) is in D a , too. Consequently, Q s1n returns n 0 also over D D and D a were arbitrary, this shows that C sci,lev1 | = Compl
Using the T C transformation in (4), we can generalize this ap-proach to a completeness test. We define the set of facts D we call the canonical database of Q , obtained by freezing the atoms in the body of Q . ( X  X reezing X  variables is a well-known concept in logic programming and database theory, which allows one to treat a variable like a constant.) Thus, where  X  is the substitution that maps each variable X to the  X  X rozen version X   X  X of X .

To check whether Q is complete we apply T C to D Q and check whether Q can retrieve the frozen tuple of distinguished variables. C be a set of TC statements, and Q (  X  X )  X  B be a conjunctive query. Then
P ROOF . (  X  ) Suppose that C | = Compl s ( Q ) . To show that Q ( T C ( D Q )) , we construct the pair D Q = ( D Q , T C an incomplete database according to Proposition 1 a). Obviously, it holds that T C ( D Q )  X  T C ( D Q ) , and thus from Proposition 1 b) we conclude that D Q | = C . Hence, D Q | = Compl s ( Q ) and Q ( D Q ( T C ( D Q )) . Further, D Q is the frozen version of the body of Q , where the output variables  X  X have been substituted with  X   X 
X  X  Q ( D Q ) , and it follows that  X   X  X  X  Q ( T C ( D Q (  X  ) Suppose that  X   X  X  X  Q ( T C ( D Q )) . We want to show that C | = Compl s ( Q ) . To this end let D = ( D i , D a ) be an incomplete database such that D | = C . Suppose that  X  c  X  Q ( D i  X  c  X  Q ( D a ) . Let  X  be an assignment satisfying Q over D trieves  X  c . Then  X   X  X =  X  c and  X  B  X  D i , where B is the body of Q . Since C | = Compl s ( Q ) , it follows that T C (  X  B )  X  D a satisfying assignment for Q over T C ( D Q ) that retrieves  X   X 
X =  X   X  X and  X  B  X  T C ( D Q ) = T C (  X  B ) . Consider the composed assignment  X  X   X  1  X  . Because of the inclusion just derived, it holds that  X  X   X  1  X  B  X   X  X   X  1 T C (  X  B ) . It also holds that T (  X  X   X  1  X  B ) , since  X  may map a variable to a constant appearing in C , or may map distinct variables to the same constant, thus en-abling more TC statements in C to be applied. Moreover, we have been derived above. In summary, we have shown that  X  X   X  1 isfies Q over D a . We verify that  X  c =  X   X  X =  X  X   X  1 which implies that  X  c is the result retrieved by Q over D assignment  X  X   X  1  X  , so that  X  c  X  Q ( D a ) .
 Encoding Completeness Reasoning. For any Q and C , the check whether  X   X  X  X  Q ( T C ( D Q )) can be encoded into a positive logic pro-gram. As a set of facts, the program contains the atoms in D we extend our signature by two additional relation symbols R R for every R in  X  , to be able to reason about the ideal and avail-able instances. We also introduce a copy rule r R : R i ( for every relation and denote the set of all such copy rules as P Thus, any model of D Q and P  X  contains an  X  X deal X  copy of D
Next, to capture the reasoning with TC statements, we introduce for each C  X  C , C = Compl ( R (  X  s ) ; G ) , the rule r where the i in G i indicates that all relation symbols are replaced by their ideal version. For example, r C sci is the rule pupil pupil i ( N , C , S ) , class i ( C , S , L , sci ) and r B )  X  class i ( C , S , 1 , B ) . The set of all rules for statements in C is
Intuitively, D Q is a prototypical instance where Q returns an an-swer, namely, the prototypical answer  X   X  X . Applying the copy rules in P  X  turns D Q into an ideal database D i Q . In the following, we use ideal ( D ) or D i (resp., avail ( D ) or D a ) to denote the ideal copy (resp., the available copy) of the instance D . The application of the statement rules in P C then amounts to computing the available instance avail ( T C ( D i Q )) . It remains to check whether Q returns the answer  X   X  X also over avail ( T C ( D i Q )) .

To this end, we introduce the boolean test query Q s , which is obtained from Q by replacing each relation symbol by its avail-able version and freezing the distinguished variables. Formally, Q s is defined by the rule r Q s = Q s  X  R a  X  is the substitution that maps every distinguished variable to its frozen version. In our example, the test query is Q s s1n C , newton ) , class a ( C , newton , 1 , sci ) .

In addition to the program P C , encoding C , we define P P  X  X  r Q s } , as the program encoding Q .

T HEOREM 3 (S ET E NCODING ). Let Q be a conjunctive query and C be a set of TC statements. Then C | = Compl s ( Q ) iff 1. the atom Q s is in the answer set of P C  X  P s Q , or 2. the goal Q s succeeds with P C  X  P s Q under SLD resolution.
P ROOF . 1. To prove the claim it is sufficient to show that Q ( T C ( D Q )) if and only if the atom Q s is in the answer set of P P . From this and Theorem 2 the claim follows directly. Since P  X  P s Q is a positive program, it has a unique answer set that cor-responds to the least fixed point (LFP) of the program. By the pro-gram definition, the LFP of the program is consists of the facts in (i) D Q , (ii) the ideal copy D i Q produced by P  X  , (iii) the available version avail ( T C ( D Q )) of T C ( D Q ) , obtained by applying the pro-gram P C on D i Q , and (iv) possibly the ground atom Q s produced by the rule r Q s over the facts from avail ( T C we have that Q s is in the LFP of the encoding program if and only if  X   X  X  X  Q ( T C ( D Q )) . 2. For SLD resolution it holds that each SLD-provable ground atom of a program belongs to the least Herbrand model (LHM) of the program. Since, in our case, the LFP of the answer set program is the same as the LHM of the Prolog program, the claim follows from Case 1.

Recall that in the definition of the test query, we freeze the dis-tinguished variables because we want to test whether Q returns and we do not freeze the non-distinguished variables because we do not want to impose constraints on how  X   X  X is retrieved. To see why this definition works, consider the query which asks for  X  X ll pupils that take chess, which in addition take some activity X  (which may be chess). Suppose, our data are com-plete for all pupils that take chess, expressed by the TC statement C ch , that has rule form takes a ( N , chess )  X  takes i ( N , chess ) . The ideal copy of the canonical database D Q cht is D i Q ceed for our test query Q s cht  X  takes a ( n 0 , chess ) , takes the variable A can be bound to chess . Thus, the check in Theorem 3 returns the intuitively expected answer  X  X es X .
 Completeness Under Bag Semantics. Under bag semantics, a query returns an answer tuple as many times as there are satisfying assignments for that tuple. Thus, a set C may entail completeness of Q under set, but not under bag semantics. The query Q cht returns each pupil that takes chess as many times as there are activ-ities taken by that pupil. Thus, under bag semantics the additional atom takes ( N , A ) makes sense, as it does not change the answers as such, but the multiplicity with which they appear. The query now asks,  X  X ow many activities does each chess taker take? X 
For reasoning under bag semantics, it no longer suffices to check whether each answer of Q over D i is also an answer over D whether each satisfying assignment for Q over D i is retained over D . Intuitively, the freezing assignment  X  is a prototypical satis-fying assignment for Q over the prototypical ideal database D The minimal available database that, together with D Q , satisfies C , is T C ( D Q ) . To test whether  X  is also a satisfying assignment over T ( D Q ) , we simply check whether D Q  X  T C ( D Q ) .
 C be a set of TC statements, and Q be a conjunctive query. Then
P ROOF . (  X  ) As in the proof of Theorem 2, we observe that ( D
Q , T C ( D Q )) | = C . Hence, ( D Q , T C ( D Q )) | = Compl the number of times a tuple occurs as an answer of Q over T is the same it occurs over D Q . Since T C ( D Q )  X  D Q possible if every assignment that satisfies Q over D Q also satisfies Q over T C ( D Q ) . In particular, the freezing mapping signment that satisfies Q over D Q =  X  B where B is the body of Q . By the argument above,  X  also satisfies Q over T C ( D Q ) , and hence  X 
B  X  T C ( D Q ) , that is, D Q  X  T C ( D Q ) . (  X  ) Suppose D Q  X  T C ( D Q ) . Let D = ( D i , D a ) | = C for an in-complete database D and let  X  c  X  Q ( D i ) . We show that  X  c appears the same number of times as answer to Q over D a as it does over D Since D a  X  D i , it suffices to show that each assignment  X  c over D i also returns  X  c over D a . Similar to the proof for the case of set semantics, one can show that T C (  X  B )  X  D a . Further, from D Q  X  T C ( D Q ) it follows that  X  X   X  1 (  X  B )  X   X  X   X  1 T  X  X   X  1 T C (  X  B )  X  T C (  X  X   X  1  X  B ) = T C (  X  B ) for the same reasons as in the proof of Theorem 2. Altogether,  X  B  X  T C (  X  B ) . Then, from  X 
B  X  T C (  X  B )  X  D a we conclude  X  B  X  D a . This implies that also a satisfying assignment for Q over D a , which returns  X  c .
This characterization can be readily encoded into a logic pro-gram. Instead of freezing only the distinguished variables of Q , we freeze all variables in Q . We thus define Q b by the rule r Q maps every variable to its frozen version. The encoding of Q is now P b Q : = D Q  X  P  X   X  X  r Q b } .

T HEOREM 5 (B AG E NCODING ). Let Q be a conjunctive que-ry and C be a set of TC statements. Then C | = Compl b ( Q ) iff 1. the atom Q b is in the answer set of P C  X  P b Q , or 2. the goal Q b succeeds with P C  X  P b Q under SLD resolution.
P ROOF S KETCH . 1. Due to Theorem 4, it suffices to prove that the atom Q b is in the answer set of P C  X  P b Q iff D Q  X  T ilarly to the case of set semantics, this can be proved by showing that the test D Q  X  T C ( D Q ) succeeds if and only if the rule r 2. As for Theorem 3, the claim follows from the fact that a ground atom can be SLD-resolved iff it belongs to the least Her-brand model (LHM) of the program. In our encoding, the LHM corresponds to least fixed point of the program. Thus, the claim follows from Claim 1.

The tests in Theorems 2 and 4 can be performed in nondetermin-istic polynomial time, which complies with the overall complexity of the problems, which are NP-complete.
Foreign keys can help us draw additional conclusions about que-ry completeness. We provide an example for both the effects of unenforced and enforced FKs.
 Example. Consider the query Q n ( N )  X  pupil ( N , C , newton ) . Re-call that for each class, identified by its code and the name of its school, the relation class records the level and branch of that class. Assume that our database is  X  X omplete for those pupils at Newton school that attend a class that belongs to some level and branch, X  If there may exist classes at Newton school present in the pupil relation but not in class relation, then the completeness of Q not follow. However, if we know that every class in the application domain has a level and belongs to a branch, we can express this by stating that the FK pupil [ ccode , sname ]  X  class [ ccode , sname ] holds (without being enforced). In this case, for every pupil record there exists a corresponding class record in the ideal database, hence the above TC statement is enough to guarantee the completeness of Q
However, if we ask for all pupils attending a class of the science branch at Newton school, Q sn ( N )  X  pupil ( N , C , newton ) , class ( C , newton , L , sci ) , then the non-enforced FK does not guarantee com-pleteness, since then for every pupil record a corresponding class record exists in the ideal database, representing the state of the real world, but such class records may not be present in the available database so that we cannot identify classes of the science branch. If the FK holds and is enforced, then all such records must be present, and the completeness of Q sn is ensured.

We will characterize query completeness in the presence of key and weakly acyclic FK constraints, both for non-enforced and en-forced semantics. We assume that the bodies of the conjunctive queries to be checked for completeness satisfy the key constraints, of key constraints can be achieved efficiently by chasing the body with the key constraints (see [12]).

The conceptual tool needed for foreign key reasoning is the chase with inclusion dependencies (IDs), which generalize foreign-key constraints. Johnson and Klug defined two versions, the oblivious chase, which introduces a new atom whenever an ID is  X  X pplica-ble, X  and the restricted or standard chase, which only introduces a new atom for an applicable ID if the ID is not yet satisfied [12]. We will use an intermediate chase version, introduced by Mar-nette [16], the oblivious Skolem chase , which generates atoms with Skolem terms whenever an ID is applicable, and the atom to be gen-erated does not exist yet. The oblivious Skolem chase bears some similarity with the restricted chase in that a chase step is blocked if the corresponding ID is satisfied by an atom with Skolem terms.
To apply this chase, IDs are translated into rules with Skolem terms in the head. For instance, the foreign key from pupil to class is translated into the rule which introduces a new class atom for every pupil atom, with a new level and branch generated by two Skolem functions that take the keys of the class atom as arguments. Let K be a set of FKs. We denote the result of chasing a set of (ground) atoms D with the rules obtained from K as Ch K ( D ) . If K is clear from the context, we drop the subscript and write Ch ( D ) . In general, chase termination is not guaranteed for FKs.
 From now on, we consider only weakly acyclic sets of FKs [7]. Weakly acyclic tuple generating dependencies (which are more gen-eral constraints than FKs) have been introduced in the context of data exchange as syntactic class that ensures termination of the re-stricted chase for every instance [7]. Marnette extended this re-sult to the oblivious Skolem chase [16]. Under this assumption, Ch K ( D ) is always finite for a finite D .

Now, we can formulate a result for non-enforced FKs that gener-alizes Theorems 2 and 4 by replacing the prototypical database D with the chase of D Q .
 Let C be a set of TC statements, K be a weakly acyclic set of FKs, and Q be a conjunctive query. Then 1. C | = K Compl s ( Q )  X  X  X   X   X  X  X  Q ( T C ( Ch K ( D Q 2. C | = K Compl b ( Q )  X  X  X  D Q  X  T C ( Ch K ( D Q )) .

P ROOF I DEA . 1. (  X  ) The proof is based on a similar construc-tion as the one for Theorem 2. In this case we take D Q = ( Ch ( D T ( Ch ( D Q ))) as an incomplete database. (  X  ) This direction is more involved. We have to cope with the difficulty that applying our chase to a database instance that satis-fies the key constraints in K may result in an instance that no more satisfies the keys because of additional atoms with Skolem terms. sci ) } with rule (6) adds the atom class ( a1 , newton , f class is violated.

We compensate this proliferation of atoms by introducing for K a new set inclusion relation  X  K (and based on that an equivalence re-lation  X  K ) that regards atoms as identical if the keys implies they are the same. With respect to this inclusion relation, the opera-tor Ch K () is idempotent and monotonic. Moreover, for any con-stant tuple  X  c , query Q , and database instances D , D Skolem terms, we have that  X  c  X  Q ( D ) implies  X  c  X  Q ( D ) , whenever D  X  K D 0 . Then the proof of Theorem 2 can be generalized to the new setting, replacing set inclusion and equality with  X  K 2 . Can be shown in the similar way as Claim 1 by generalizing the ideas in the proof of Theorem 2.

If the FKs are enforced, we also need to extend the available database obtained by applying T C to the chase of D Q to satisfy K . However, this cannot be done by chasing this result a second time. To see this, consider the query Q sn from above and the TC state-ment C p = Compl ( pupil ( N , C , S ) ; true ) , which states that the table pupil is complete. Together with the enforced FK from pupil to class this implies completeness of Q sn , since then any available database must contain (i) all pupils and (ii) the class of each pupil. Let us try to reach this consequence by reasoning about the pro-class ( c , newton , l , sci ) } and Ch K ( D Q sn ) = D Q ready a class for the pupil in D Q sn . Applying T T ( Ch K ( D Q sn )) = { pupil ( n , c , newton ) } , since we are complete for pupil , but not for class . The chase would add a new class atom, say, over the database { pupil ( n , c , newton ) , class ( c , newton , l cause it looks for pupils in a science class.

Clearly, instead of generating a new class atom, we should have isfy the FK. To achieve this, we define the chase operator Ch which, given an incomplete database ( D i , D a ) where D extends D a to satisfy K by copying atoms from D i . Formally, if where S (  X  t )[ B ] = R (  X  s )[ A ] . The result is denoted as Ch
To formalize the reasoning performed in the previous example, we combine the two chase operators and the T C operator to a new operator K C , defined as K C ( D ) = Ch a K ( Ch ( D ) , T means that (i) we chase D to obtain an ideal db that satisfies the for-eign keys in K , (ii) apply T C , and (iii) extend the result by copying atoms from Ch K ( D ) .
 C be a set of TC statements, K be a weakly acyclic set of FKs, and Q be a conjunctive query. Then 1. C | = e K Compl s ( Q )  X  X  X   X   X  X  X  Q ( K C ( D Q )) 2. C | = e K Compl b ( Q )  X  X  X  D Q  X  K C ( D Q ) .
 The proof generalizes the techniques for showing Theorem 6. Now we extend our encoding so that it supports reasoning under FKs. Since a partial database satisfies an FK constraint if the ideal database satisfies it, we introduce for every FK constraint a rule like the one in (6), albeit for the ideal version of the relations in-volved. For instance, instead of (6), we introduce the rule class S , f class , level ( C , S ) , f class , branch ( C , S ))  X  pupil the set of all FK rules obtained from K as P i K , where  X  that the rules create atoms for the ideal instance.

Finally, to model reasoning about enforced foreign keys, we in-troduce rules that copy foreign key atoms from the ideal to the available database. For example, the rule for the FK from pupil to class is We denote the set of all such rules obtained from K as P e  X  e indicates enforcement.

We are now ready to state the encoding theorems for reasoning about FKs, whose proofs are consequences of the Characterization Theorems 6 and 7.
 Let Q and C be as previously. Let K be a weakly acyclic set of FK constraints. Then C | = K Compl s ( Q ) iff 1. the atom Q s is in the answer set of P C  X  P i K  X  P s 2. Q s succeeds with P C  X  P i K  X  P s Q under SLD resolution.
Similar Encoding Theorems hold for any combination of set/bag semantics and non-enforced/enforced semantics. For bag seman-tics, we have to replace the rule set P s Q by P b semantics we have to add the rule set P e K . Finite domain constraints make it necessary to reason by cases. Example. We take up again the example from the introduction, with the query asking for the pupils from the science branch at Newton school, the CFDC F sn = class { school = newton , branch = sci } [ ccode ] = { a1 , b2 } , stating that the only science classes at Newton school are a1 and b2 , and the TC statements C a1n = Compl ( pupil ( N , stating completeness for the pupils of classes a1 and b2 . The TC statements alone do not entail completeness of Q sn , because in prin-ciple there could be other science classes. However, together with the CFDC, they do imply completeness.

The characterization in Theorem 2, though, does not apply here because the operators T C a1n and T C b2n map the frozen body of Q the empty set. They transfer pupil atoms where the class code is a1 or b2 . Therefore, a reasoning procedure has to instantiate the codes in all ways permitted by the CFDC before applying the T C If the test of Theorem 2 succeeds for all such instantiations, then we can conclude completeness.

In the following, we develop concepts that allow us to character-ize completeness wrt CFDCs and then provide an encoding of the characterizing condition. Since CFDCs are essentially disjunctive, we encode reasoning only into answer set programming, which supports disjunctive rules, while Prolog does not.

Let F be a fixed set of CFDCs. Suppose B is a conjunction of atoms. Let  X  be a substitution that maps each variable Y of B either to a constant occurring in F (a proper constant) or to the frozen version of Y . We say that  X  satisfies B and F if the instance satisfies F . We say that a substitution  X  0 is at least as general as written  X  0  X  , if for all variables Y in B and all proper constants c we have that  X  0 Y = c implies  X  Y = c . We say that  X  is an F -case of C if  X  is maximally general among all substitutions satisfying B and F . For instance, the body of the query Q sn has two { F cases,  X  a1 , which substitutes the variable C with a1 and freezes all other variables, and  X  b2 , which is analogously defined. By denote the set of all F -cases of B .

We remark that by a reduction of the 3-colorability problem one can construct a set F 3col of CFDCs such that it is NP-hard to decide whether  X  F 3col , B 6 = /0 for a conjunction B . It is also not difficult to see that in polynomial time one can verify whether a substitution is an F -case of B . Thus, checking whether  X  F , B 6 = /0 is NP-complete. We now generalize Theorem 2 to CFD constraints. We drop the analogous generalization of Theorem 4 due to the limited space. Let C be a set of TC statements, F be a set of CFD constraints, and Q (  X  X )  X  B be a conjunctive query. Then
P ROOF I DEA . For  X   X   X  F , B we define the substitution  X   X 
Y if  X  Y is a constant, and  X   X  Y = Y otherwise. That is,  X  stitutes variables that are subject to a CFD constraint by one of the possible values and leaves the other variables as they are. The proof then exploits the fact that over any database satisfying F , a query Q (  X  X )  X  B is equivalent to the union of conjunctive queries S  X   X  F , B Q  X  , where each Q  X  is defined as Q  X  (  X   X   X 
Condition (7) stipulates a test comprising the following steps: (i) Instantiate the query body B in all possible ways permitted by the CFD constraints. This amounts to considering all possible ways in which an answer to Q can be retrieved. (ii) For each such instan-tiation  X  B , compute T C (  X  B ) , the set of atoms that must be present in any available database if the ideal database contains  X  B . (iii) Eval-uate Q over T C (  X  B ) and check whether the result contains prototypical answer to Q over  X  B . We now show how to encode (i) F -cases, (ii) the operator T C , and (iii) the final test into disjunc-tive rules.
 The starting point is again the canonical database D Q . Since D consists of ground atoms, which cannot be instantiated, we have to mimic the instantiation by cases. To this end, we introduce a new binary predicate val , where intuitively val ( t , v ) indicates that the term t is instantiated by the value v . To achieve modularity, we keep the encodings of Q , F , and C independent from each other. Therefore, no information as to which variable can be instantiated by which value should influence the encoding of Q . We achieve this by introducing val ( t , t ) for each term in D Q both for original constants and for frozen variables. The set of all such facts is de-noted as Val Q . Then we require that every term can have at most one val -value other than itself, which can be seen as a requirement for val to be functional. This can be expressed by the denial r To mimic the instantiation of the query body by cases, we introduce for each CFD constraint F = R { a 1 = v 1 ,..., a n = v n w } the disjunctive rule r F as which nondeterministically binds the term in attribute position a sitions a 1 ,..., a n are bound to v 1 ,..., v n , respectively. Thus, the rules encoding F into the program P F : = { r F | F  X  F } X  X  r
We keep the rules P  X  that copy D Q into the ideal database D However, to make the TC rules applicable to facts with val -bind-ings, we need to unfold them. For an atom A = R ( t 1 ,..., t unfolding consists of the atom A u = R ( Y 1 ,..., Y n ) , where each ar-gument is replaced by a fresh variable, and the set of val -bindings U to translate a TC statement C into the rule r C : R R ( t 1 ,..., t n ) , G i . The unfolded rule for C is then where the unfolding ( G i ) u of the condition G i and the set of value atoms U G i are defined analogously to the case of single atoms. For example the rule r u C pupil a ( N 1 , C 1 , S 1 )  X  pupil i ( N 1 , C 1 , S 1 ) , val ( N 1 , N ) , val ( C 1 class i ( C 2 , S 2 , L 2 , B 2 ) , val ( C 2 , C ) , val ( S The program consisting of the unfolded rules is denoted as P { r u C | C  X  C } .

Let Q ( X 1 ,..., X n )  X  B be the query which we want to check for completeness. We have to modify the test query in two ways, first by unfolding, and second by adding val -atoms to encode the check whether Q returns  X   X  X over T C (  X  B ) . Thus, the rule r query Q u s is where the x j are the frozen versions of the X j . For example, the test query for Q sn in (7) is
Q u sn  X  pupil a ( N 1 , C 1 , S 1 ) , class a ( C 2 , S 2 where n 0 is the frozen version of N . Let P s , u Q : = D be the set of rules about Q .

T HEOREM 10 (ASP E NCODING OF CFDC S ). Let Q be a con-junctive query, C a set of TC statements, and F a set of CFD con-straints. Then
As in Theorem 5, we obtain an analogous encoding of bag com-pleteness checks by modifying the rule for the test query. In order to ensure that no assignment is lost, we add to the body of the rule for Q u b for every variable Y in Q an atom val ( y , Y ) with the frozen version y of Y .
Foreign keys, in particular combined with conditional finite do-mains, allow for a larger set of inferences.
 Example. Consider Q n ( N )  X  pupil ( N , C , newton ) , which asks for the names of all pupils at Newton school, and assume the FK and CFD constraints from our running example hold. Consider as well the TC statement C sci in (2) and an analogous statement C which asserts completeness for pupils in humanities classes. Now, Q n is complete because every pupil of Newton school belongs to a class of some branch (by the FKs), the only possible branches are sci and hum (by the CFDCs), and we are complete for each by C and C hum . Note that we arrived at this conclusion without assuming that the FKs are enforced.

We now sketch how the constructions in Sections 5 and 6 can be combined to reasoning about CFDCs and FKs in conjunction. First we provide a characterization of completeness under set semantics. The difference with respect to Theorem 9 is now that we have to consider all cases of the chase of the body B of Q instead of B alone. One can show that it still does not matter which version of the chase is used.

T HEOREM 11 (C HARACTERIZATION ). Let C be a set of TC statements, K be a weakly acyclic set of FKs, F be a set of CFDCs, and Q (  X  X )  X  B be a conjunctive query. Then
The characterization theorem for enforced FKs is a modifica-tion of Theorem 7 where Ch a is to be applied to ( T (  X  ( Ch K ( B )))) for every  X  in  X  F , Ch K ( B ) .

For the encoding, there are now two modifications with respect to the case of plain FKs. The first is that every new term that is created by a chase rule must be a value of itself. The second is that the copy rules for enforced semantics need to be unfolded. For example, for the FK from pupil to class , we have to add the rule which makes every new level term a value of itself. A similar rule is also needed for the branch of a class.

Let K be a set of FKs. We denote the extension of P K by these rules as P u K . Similarly, we denote the set of unfolded versions of the copy rules as P e , u K . With these rules we can now encode complete-ness reasoning that considers both FKs and CFDCs into answer set programming.

T HEOREM 12 (ASP E NCODING ). Let Q, C , and F as before and let K be a weakly acyclic set FK constraints. Then 1. C | = F , K Compl s ( Q )  X  X  X  2. C | = e F , K Compl s ( Q )  X  X  X 
An analogous result holds for bag semantics.
We performed experiments to find out what is the maximal size of problems that can be solved with our encodings on standard Pro-log and Answer Set Programming (ASP) platforms and how the running time depends on the input. Since we expect that in applica-tions there are many constraints that are not relevant to a reasoning problem, we also explored how the performance is influenced by irrelevant information.
 We performed four tests and ran them on two state-of-the-art ASP reasoners, dlv and clingo . We also ran the first test on the swi Prolog implementation. The experiments were executed on a desktop machine with an Intel i5 3.40GHz CPU and 8GB mem-ory. Each experiment was repeated ten times and since the time measurements were close, we show here average running times.
For the tests, we extended our schema with two relations: school which model that every school belongs to some school cluster and is of a certain type, e.g., school ( newton , cluster5 , middle ) , and that each school cluster is in some district and has the status public or private, e.g., schoolcluster ( cluster5 , north , pub ) . Test 1. We studied the cost of reasoning with FKs with the query which asks for  X  X ll 1 st level pupils from public clusters. X  We as-serted that we are complete for pupils, expressed by pupil sname ]  X  class [ ccode , sname ] , class [ sname ]  X  school [ sname ] , and school [ scluster ]  X  schoolcluster [ scluster ] . So, Q under these assertions.

To simulate reasoning in the presence of irrelevant information, we added TC statements of the form where $ c ranged over { 1 , 10 , 10 2 } and $ s ranged over { 1 , 10 ,..., 10 5 } , which gave rise to 8 test cases with 10 0 to 10 7 irrelevant TC statements.

The results in Figure 1 show that all systems could deal with sets of up to 10 6 TC statements. While swi Prolog could deal also with the largest input, the ASP reasoners timed out after 30 minutes. Moreover, for small and large sets of TC statements, swi was one order of magnitude faster than the ASP reasoners. Test 2. We wanted to assess the cost of reasoning with CFDCs. We ran this test only on ASP reasoners, since implementing CFD reasoning in Prolog requires the usage of meta-programming pred-icates to cope with disjunctive rules. We reasoned about the query which asks for  X  X ll pupils from a class at a high school. X 
We enumerated all possible schools, class levels, and class branches with FDCS of the form class {} [ sname ] = { s class {} [ level ] = { l 1 ,..., l m } , and class {} [ branch ] = { b In addition, we asserted that we have complete information about range over all school names, class levels, and branches, resp. The combination of the CFD constraints and the TC statements entail that Q high is complete. To conclude completeness, all possible cases combining school name, class level, and branch must be ex-plored. We varied the sizes of these three domains in such a way that the number of cases (and the number of TC statements for class) ranged from 1 to 10 6 .

From the results in Figure 2 we observe that for both clingo and dlv the running times were linear in the size of the input. Both reasoners could cope with up to 1 mio cases. The fastest reasoner, dlv , could process 10 4 cases within less than 1 second, which we deem acceptable.
 Test 3. We wanted to check whether the running time observed in Test 2 depended on the size of the input or on the number of cases. We constructed an extreme setup where we had a small input, but a large number of cases, and where completeness of the query fol-lowed already from few TC statements, while the case analysis was not needed to conclude completeness. We reasoned about the query which asks for  X  X ll pupils from public clusters, X  in the presence of TC statements that assert the completeness of each of the relations these TCSs guaranteed the completeness of Q pub .

Additionally, we asserted a chain of CFDCs that did not con-tribute to the completeness of Q pub , but made the reasoning more complicated. Specifically, we stated that there are i different dis-district d there are j different public school clusters, schoolcluster { district = d , status = pub } [ scluster ] = { sc and that for each such cluster there are m different schools, while for each school, there are n different levels.

We varied the parameters i , j , m , n and k to be 1 or 10 ( i could be also 100) to obtain different sizes of CFDCs, which gave rise to problems with 10 p answer sets, where p = 0 ,..., 6.

Figure 3 displays the running times as depending on the number of answer sets, instead on the input size, which is logarithmically smaller. We observed running times linear in the number of an-swer sets, which correspond to the number of possible cases, but exponential in the size of the input. The running time, measured in this way, is approximately 10 times faster, than in Test 2, where the case analysis was actually needed. We conclude that reasoning about irrelevant cases takes time, but less than about relevant cases. Test 4. We wanted to assess the cost of reasoning jointly about FKs and CFDCs. To this end, we slightly modified the setup of Test 3: (i) we dropped the TC statement asserting the completeness of class , and (ii) added the enforced FK constraint pupil [ ccode , sname ]  X  class [ ccode , sname ] , which ensures the presence of all class information needed for the query.

The results in Figure 4 show that the number of answer sets that reasoners could cope with before the 30 minutes timeout dropped from 10 6 to 10 4 and that the running time was no more linear in the number of cases.
 In summary, our encoding of completeness reasoning allows for efficient reasoning with foreign keys in the presence of large num-bers of TC statements, while reasoning about CFDCs depends in the first place on the number of cases covered by a set of CFDCs, rather than the input size. For combinations of FKs and CFDCs, the performance is not yet fully satisfactory.
We presented techniques to reason about query completeness over partially complete databases satisfying primary and foreign key constraints as well as conditional finite domain constraints. This generalizes previous work on query completeness and allows one to identify more situations in which queries are complete than was possible before. Our approach also provides a basis for the im-plementation of these reasoning techniques. We provided syntactic characterizations of completeness reasoning tasks which are inde-pendent of any implementation. In a second step, we used them to develop provably correct encodings into logic programming, with and without disjunctive rules, depending on the constraints involed. The encodings can be executed immediately by Prolog engines or ASP solvers.

As a proof of concept, we tested these encodings in a scenario that reflects the requirements of an administrative information sys-tem. The results suggest that the encodings are adequate for medi-um-sized data sets, as they may occur in the administration of a cluster of schools or a university. Currently, we are working on the integration of completeness management into the research in-formation system of a university.
 Acknowledgments. This work was partially supported by the pro-ject  X  X anaging Completeness of Data (MAGIC) X , funded by the province of Bolzano, and the project  X  X ompleteness-Aware Query-ing and Navigation on the Web of Data (CANDy), funded by the Free University of Bozen-Bolzano. X  We thank the anonymous re-viewers for their helpful comments. [1] S. Abiteboul, R. Hull, and V. Vianu. Foundations of [2] K. Apt and M. van Emden. Contributions to the theory of [3] C. Baral. Knowledge Representation, Reasoning, and [4] A. Chandra and P. Merlin. Optimal implementation of [5] A. Cort X s-Calabuig, M. Denecker, O. Arieli, and [6] A. Cort X s-Calabuig, M. Denecker, O. Arieli, and [7] R. Fagin, P. G. Kolaitis, R. J. Miller, and L. Popa. Data [8] W. Fan and F. Geerts. Relative information completeness. In [9] W. Fan and F. Geerts. Capturing missing tuples and missing [10] M. Gebser, B. Kaufmann, A. Neumann, and T. Schaub. [11] M. Gelfond and V. Lifschitz. Classical negation in logic [12] D. S. Johnson and A. C. Klug. Testing containment of [13] A. Klug. On conjunctive queries containing inequalities. J. [14] N. Leone, G. Pfeifer, W. Faber, T. Eiter, G. Gottlob, S. Perri, [15] A. Levy. Obtaining complete answers from incomplete [16] B. Marnette. Generalized schema-mappings: from [17] A. Motro. Integrity = Validity + Completeness. ACM TODS , [18] S. Paramonov. Query completeness X  X  logic programming [19] S. Razniewski and W. Nutt. Checking query completeness [20] S. Razniewski and W. Nutt. Completeness of queries over [21] O. Savkovi  X  c, M. Paramita, S. Paramonov, and W. Nutt. [22] O. Savkovi  X  c, M. Paramita, A. Tomasi, and W. Nutt. [23] P. Simons, I. Niemel X , and T. Soininen. Extending and
