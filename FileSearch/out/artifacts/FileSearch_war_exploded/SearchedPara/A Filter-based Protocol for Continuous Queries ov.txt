 In typical location-based services (LBS), moving objects (e.g., GPS-enabled mobile phones) report their locations through a wireless network. An LBS server can use the location information to answer various types of continuous queries . Due to hardware limitations, location data reported by the moving objects are often uncertain. In this paper, we study efficient methods for the execution of Continuous Possible Nearest Neighbor Query (CPoNNQ) that accesses imprecise location data. A CPoNNQ is a standing query (which is active during a period of time) such that, at any time point, all moving objects that have non-zero probabilities of being the nearest neighbor of a given query point are reported. To handle the continuous nature of a CPoNNQ, a simple solution is to require moving objects to continuously report their locations to the LBS server, which evaluates the query at every time step. To save communication bandwidth and mobile devices X  batteries, we develop two filter-based pro-tocols for CPoNNQ evaluation. Our protocols install  X  X il-ter bounds X  on moving objects, which suppress unnecessary location reporting and communication between the server and the moving objects. Through extensive experiments, we show that our protocols can effectively reduce communi-cation costs while maintaining a high query quality. H.2.8 [ Database Management ]: Database Applications Algorithms, Performance continuous queries, uncertain database, communication cost  X  Work done in the University of Hong Kong
With the advances in mobile computing devices and mo-bile communication technologies, various location-based ser-vices (LBS), such as navigation and map-based services, have emerged. Fig. 1(a) shows a simple location-based sys-tem in which a location server maintains a database that continuously registers the most updated locations of a set of moving objects. The location of the moving objects can be acquired by positioning devices, e.g., Global Positioning System (GPS). Once the location of an object is captured, it is reported as a location update to the location server through a wireless network. The location information col-lected at the server can support different spatial queries, for instance,  X  X ell me whether one of my friends is in the same building as me X .
 Figure 1: (a) A simple location-based system. (b) An
Due to the imprecision of location sensing devices, loca-tion values captured by the moving objects are only approx-imation at best [1, 2, 3, 4]. The actual locations of objects are therefore uncertain. Various studies have been conduct-ed on how to improve the quality of queries X  answers given that object locations are uncertain. The most prominent approach is to impose an uncertainty model on objects X  lo-cations and evaluate queries based on this model [2, 5, 6, 7]. A typical uncertainty model defines an uncertainty region for each object, which is a closed region that confines the possible location of that object. For example, in Fig. 1(b), the location uncertainty of objects is modeled using circular uncertainty regions.

One of the most studied spatial queries is the nearest neighbor query (NNQ). Given a query point q , the NNQ on q returns the object that is the closest to q in space. With location uncertainty, the answer to an NNQ is uncer-tain as well. An approach is to evaluate the possibility of each object being the NNQ X  X  answer. Efficient methods have previously been put forward to solve this problem [2, 3, 6, 8]. We note that existing solutions to the NNQ problem assume that a snapshot of the objects X  locations (and their uncer-tainty models) is given. The answer returned, therefore, is good only for a particular time instant. In many cases, how-ever, we are interested in answering an NNQ continuously over an extensive period of time. For example, one might want to be continuously informed about which battalion is the closest to a military base while the troops are in motion. In this case, the NNQ is a standing query that is evaluated continuously.

We remark that existing methods for answering NNQ are inadequate in handling continuous NNQ. This is because a s-napshot of the moving objects X  locations have to be reported at every single time step. This imposes big demands on the communication bandwidth and battery power on the mobile devices, as well as on the computation overhead on the lo-cation server. To solve this problem, we consider two ideas: (1) Objects that have a zero chance of being the answer of an NNQ could be muted (i.e., they do not have to report their locations by each time step and their locations need not be considered by the location server in computing NNQ answers). (2) Location updates that do not change the NNQ answer need not be sent. Note that these two ideas help re-ducing the number of location updates (messages) sent from the moving objects as well as reducing the number of ob-jects that have to be processed in determining the nearest neighbor. Continuous NNQ can therefore be answered more efficiently.

To realize the two ideas, we study the evaluation of Con-tinuous Possible Nearest Neighbor Query (or CPoNNQ ). Giv-en a query point q ,the CPoNNQ on q returns all moving objects that have non-zero probabilities of being the closest neighbors of q . As an example, in Fig 1(b), we see that the location of object o 4 is always farther away from q than that of object o 1 . Therefore object o 4 is not a possible nearest neighbor of q . The same can be said for object o 5 .Thean-swer set of executing CPoNNQ on q is therefore { o 1 ,o 2 Solving CPoNNQ realizes the first of the above two ideas. In particular, objects that are not in the answer set of a given CPoNNQ need not be handled and their location updates can be safely ignored.

We realize the second idea by studying message-efficient methods for executing CPoNNQ . Specifically, we propose filter-based protocols to avoid redundant location-update mes-sages. A filter-based protocol installs filter bounds on each object. Essentially, a filter bound is a simple distance con-straint that can be easily verified by the moving object. As long as an object satisfies its filter bounds, its location up-dates can be suppressed because the protocol ensures that those updates do not affect the query answer. We propose two filter-based protocols. For the first one, the basic filter protocol (BFP), we focus on designing effective filter bounds whose violations precisely capture the moments at which the CPoNNQ answer could be changed. When such vi-olations occur, moving objects are probed for their most updated locations and new revised filters are installed in them. For the second protocol, the optimized filter proto-col (OFP), we focus on identifying objects whose locations need not be reported and filter bounds that need not be updated even when filter violations occur. OFP can there-fore save even more communication bandwidth and battery power compared with BFP.

The rest of paper is organized as follows. Section 2 presents the related work. We introduce the system model and define the CPoNNQ in Section 3. The Basic Filter Protocol (BF-P) and the Optimized Filter Protocol (OFP) are presented in Sections 4 and 5, respectively. We give our experimen-tal results evaluating the performances of BFP and OFP in Section 6. In Section 7 we conclude the paper with a brief discussion on the future work.
Filter bound algorithms. To support continuous query evaluation in LBS and sensor networks, location and sen-sor data are constantly acquired from the external environ-ments. Due to the limited battery power of the sensing devices (e.g., mobile phones and temperature sensors), as well as network bandwidth, it is crucial to maintain a low communication cost during query evaluation. Recently, the concept of filter bounds have been proposed, which controls when a sensor should report its value. In [9, 10, 11], the au-thors proposed filter bound protocols for nearest neighbor queries. The authors in [12, 13, 14] developed filter bound protocols for range and top-k queries. The work in [10] stud-ied the use of filter bounds in a peer-to-peer environment. However, all these work do not consider the important issue of data uncertainty , which can lead to incorrect results if it is not managed carefully. So far, few filter bound algorithm-s have considered data uncertainty. The authors in [7, 15] studied filter bound algorithms for continuous range queries on uncertain data. These protocols treat the user query range as a filter bound, and send it to the sensors involved. It is not clear how this protocol can be used to handle a CPoNNQ , since the query range is not defined in a CPoN-NQ . In this paper, we explain how to design filter bounds for supporting this query, which, to our best knowledge, has not been studied before.

Nearest neighbor queries for uncertain data. In [2, 3, 16], the problem of efficiently evaluating a nearest-neighbor query on uncertain data was studied. They assume a snapshot query model; that is, the query is evaluated on-ly once. A CPoNNQ stays in the system for an extensive amount of time, during which query answers need to be con-stantly refreshed. In [6], the authors studied the evaluation of a continuous NNQ. That paper focuses on how to incre-mentally recompute a query answer, after a new data value is received. However, it does not control when a sensor should report its value, and therefore cannot reduce communication costs. In this paper, we examine the use of filter bound pro-tocols, with the goal of reducing communication and energy costs. Since the server receives less updates from sensors, the computation cost between the server and the sensors, as demonstrated in our experiments, can also be reduced.
We now describe the architecture of an LBS system, and formally define CPoNNQ (Section 3.1). In Section 3.2, we describe a simple protocol for maintaining the answer of a CPoNNQ . Table 1 lists the symbols used in the paper.
Fig. 2 depicts an LBS system. It consists of three parties: users, a location server, and a number ( k )ofmovingobject-s maintained in the database (DB). We assume that each moving object is equipped with a positioning device, which captures the location of the object periodically with a peri-odicity of once every dt seconds. Different objects could have different periodicities ( dt ). In our simplest protocol (called baseline in Section 3.2), the location of a moving object is sent to the server as a location update message immediate-ly after it is generated. Once the server receives an update message (from any object), it registers the update in the un-certain database together with the timestamp at which the update is generated. We can consider time being marked by a sequence of such timestamps &lt;t 0 ,t 1 , ..., &gt; .Inthispa-per, we define a timestamp to be a time instant at which an update is generated by an object. Between two consecutive timestamps, no location updates are made and the answer to a CPoNNQ is considered unchanged. We assume that the uncertainty region of a moving object is represented by a circular region similar to the one shown in Fig. 1(b) and the server can deduce the uncertainty region of an object based on the received location value.

A user submits a CPoNNQ to the location server, which processes the query via a Query Manager. This module accesses the uncertain database, and computes the answer based on the latest locations of the objects and their uncer-tainty regions. We now formally define a CPoNNQ below:
Definition 1. Given a query point q , a time interval [ t a Continuous Possible Nearest Neighbor Query (or CPoNNQ in short) returns an answer set A ( t )foreach timestamp t  X  [ t s ,t e ] such that all and only those objects with non-zero probabilities of being the nearest neighbor of q at timestamp t are in A ( t ).

As we have mentioned in Section 1, we aim to achieve savings in communication bandwidth by applying the filter-based protocols. In Fig. 2, the server employs a Filter Man-ager, which determines the filters to be sent to and installed at the moving objects. These filters are computed based on the standing CPoNNQ and the objects X  locations. Once a CPoNNQ terminates (i.e., whose end time t e is passed), the Filter Manger removes the filters that are associated with the query from the objects. The details of the Filter Man-ager will be covered in Sections 4 and 5. Figure 3: (a)Illustrating n i ( t ) and f i ( t ) .(b)Distanceof We now discuss a baseline protocol for processing CPoN-NQ .A CPoNNQ with an interval [ t s , t e ] submitted to the server becomes active at t s .At t s , the server broadcasts a message to all objects to acquire their most updated lo-cations and activates their periodic location updates. The server then computes the answer set A ( t s ) by executing the procedure ComputePoNNQ (Algorithm 1. We will elaborate on this procedure shortly.) After that, each moving object o reports its location to the server once every dt i second-s, where dt i is the periodicity of o i . Whenever a location update arrives at the server, ComputePoNNQ is executed again to refresh the answer. If the answer differs from the one of the previous timestamp, the revised answer will be reported to the user. At the end time of the query, t e ,if there are no more standing CPoNNQ s, the server instructs the moving objects to turn off location update messages.
At a given timestamp t , the procedure ComputePoNNQ first computes n i ( t )and f i ( t ), which are the distances from q to the nearest point and the farthest point of each object o  X  X  uncertainty region, respectively. Fig. 3(a) illustrates these quantities. Then, the object with the smallest f i ( t )is identified as the min-max object .Let  X  ( t ) be the index of this object and so f  X  ( t ) ( t )=min k i =1 { f i ( t ) distance. It is easy to observe that for any object o j , o the inequality are thus collected into the answer set A ( t ). Although baseline maintains a correct answer set for CPoN-NQ , it is very expensive because each object has to report its updated locations at every timestamp. To reduce the communication cost for sending location updates, we next propose two filter-based protocols, namely BFP and OFP.
With the Basic Filter Protocol (BFP), at either the start time of a query or when a location update is received at the server, the server computes filter bounds that are sent and installed at each moving object. At any timestamp t , let t u ( t u  X  t )be the most recent timestamp at which fil-ter bounds are made. For each object o i ,recallthat n i ( t ) and f i ( t ) are the nearest and the farthest distances of the query point q from the uncertainty region of o i (see Fig-ure 3). The filter bounds installed by the server on object o at timestamp t u are two intervals: [ l ( n i ( t u )) ,u ( n f ( t ), respectively 2 (see Figure 3(c)). As object o i moves, its location and hence its uncertainty region change. However, as long as n i ( t )and f i ( t ) are within the intervals defined by their filter bounds, any location updates generated by o i suppressed. This gives us the following filtering rule:
By suppressing update messages, our filter-based proto-cols save communication bandwidth. The key to the proto-cols is how to set the filters correctly so that the answer set to a CPoNNQ remains correct despite missing updates. In the rest of this section, we will first describe BFP by assum-ing that filters are correctly set. Then, in Section 4.1, we show how filters are derived and prove their correctness.
BFP is shown in Algorithm 2. It consists of an initial-ization phase, a maintenance phase, and a cleanup phase.
To simplify our correctness proof, each interval is closed on the left and open on the right.
The parameter t u shown in the intervals indicates that the filter bounds were set at t u , which is the timestamp of the most recent update. Since there are no location updates between two consecutive timestamps, the filter bounds set at t u remain valid and are in effect at t , the current time instant.
 The initialization phase is similar to that of the Baseline Protocol (Section 3.2). At the start time, t s ,ofa CPoNNQ , the server broadcasts a message to all the objects to acquire their locations and computes the answer set A ( t s ). Then, the server derives the filter bounds for all the objects and sends the bounds to them. After that, the server switches to the maintenance phase. During the maintenance phase, when an update arrives (because a filter bound is violated by an object), the server probes all the objects to acquire their locations and recomputes the answer set. It revises the filter bounds and sends the bounds to the objects. At the end time of the query, the server enters the cleanup phase. It instructs objects to remove their filter bounds that are associated with the query.
In Section 3.2, at timestamp t , we define o  X  ( t ) to be the of all objects. We have argued that for any object o j , o A ( t )iff n j ( t )  X  f  X  ( t ) ( t ). The object o  X  ( t ) satisfy the above inequality, and the objects that do not satisfy the inequality thus form three groups of objects. We denote them as o  X  ( t ) , M ( t ), and F ( t ), respectively. Our protocol BFP defines three sets of filter bounds, one for each group.
 Definition 2. o  X  ( t ) , M ( t ) and F ( t ) At any timestamp t , the min-max object o  X  ( t ) is the one such that f  X  ( t ) ( t )=min { f i ( t ) | o i  X  DB } . 3
Let t u be the timestamp at which the most recent up-date was received at the server. By our definition, o  X  ( t is the min-max object at timestamp t u . Its min-max dis-tance f  X  ( t u ) ( t u ) determines the sets M ( t u )and F ( t together, they define the answer set A ( t u )attimestamp t We note that the three groups of objects o  X  ( t ) , M ( t )and F ( t ) are defined based on the three conditions mentioned in Definition 2. Specifically, they are:
If there are more than one such objects, we randomly pick (1)  X  -condition: The object o  X  ( t ) has to satisfy f  X  ( t ) min { f i ( t ) | o i  X  DB } . (2) M -condition: All objects o j  X  M ( t )havetosatisfy n (3) F -condition: All objects o i  X  F ( t )havetosatisfy n f
Now, at any timestamp t&gt;t u , if we can guarantee that the three conditions hold when we substitute  X  ( t )=  X  ( t M ( t )= M ( t u ), and F ( t )= F ( t u ), then we have A ( t )= A ( t u ). That is, the answer set remains unchanged.
To ensure that the conditions hold, BFP determines three demarcations. The purpose of these demarcations is to de-tect any potential violations of the three conditions. As an example, we can set a demarcation at a cutoff value c such that at any timestamp t&gt;t u , the min-max object at timestamp t u , i.e., o  X  ( t u ) , submits an update message only if f  X  ( t u ) ( t ) &lt;c and any object o j  X  M ( t u ) submits an update message only if n j ( t )  X  c . Then, if no messages are received jects o j  X  M ( t u ). If we can further show that  X  ( t )=  X  ( t then f  X  ( t u ) ( t )= f  X  ( t ) ( t ), and hence n j ( t ) &lt;f objects o j  X  M ( t u ). As a result, the M -condition stays valid if we substitute M ( t )by M ( t u ).

BFP uses three cutoff values , c 1 ( t u ), c 2 ( t u ), and c detect the violations of the M -condition, the F -condition, and the  X  -condition, respectively. Specifically, c 1 ( t value between max { n i ( t u ) | o i  X  M ( t u ) } and f c 1 ( t u )=(1  X   X  )  X  max { n i ( t u ) | o i  X  M ( t u ) } The exact value of c 1 ( t u ) is controlled by  X  ,whichisare-al value between 0 and 1. Here we assume that  X  =0 . 5, i.e., c 1 ( t u ) is in the middle of max { n i ( t u ) | f  X  ( t u ) ( t u ). We also tested different values of  X  in our ex-periments. The cutoff values c 2 ( t u )and c 3 ( t u ) are similarly defined: c 2 ( t u )=(1  X   X  )  X  f  X  ( t u ) ( t u )+  X   X  min { n i ( t c 3 ( t u )=(1  X   X  )  X  f  X  ( t u ) ( t u )+  X   X  min { f i ( t Fig. 4 illustrates c 1 ( t u ), c 2 ( t u ), and c 3 ( t u filter bounds of each object based on these values, as shown in Table 2. For example, for o  X  ( t u ) , the bounds of f is [ c 1 ( t u ) , min { c 2 ( t u ) ,c 3 ( t u ) } ); for o of n j ( t )is[0 ,c 1 ( t u )). So, if no filter bounds are violated, we have,  X  o j  X  M ( t u ) ,n j ( t ) &lt;c 1 ( t u )  X  f our previous discussion, this is exactly what we wanted to achieve with the demarcation c . Notethatitiseasyto verify that the intervals shown in Table 2 are well-defined. For example, we can show that c 1 ( t u )  X  min { c 2 ( t Table 2: Filter bounds for o  X  ( t u ) , M ( t u ) and F ( t timestamp t We now prove the correctness of BFP.

Lemma 1. Let t u be the most recent timestamp at which filter bounds of objects are set. For any timestamp t&gt;t no filter violations have occurred since t u , A ( t )= A ( t Proof: Following our discussion, it suffices to show that the three conditions, namely,  X  -condition, M -condition, and F -condition all hold if we substitute  X  ( t )by  X  ( t u ), M ( t )by M ( t u ), and F ( t )by F ( t u ).  X  -condition : If we substitute  X  ( t )by  X  ( t u ), the  X  -condition becomes f  X  ( t u ) ( t )=min { f i ( t ) | o i  X  DB } , i.e., o the min-max object at timestamp t . Since no filter viola-tions have occurred, from Table 2, we know that (1) f  X  ( t u ) ( t ) &lt; min { c 2 ( t u ) ,c 3 ( t u ) (2)  X  o j  X  M ( t u ) ,f j ( t )  X  c 3 ( t u ), and (3)  X  o i  X  F ( t u ) ,f i ( t ) &gt;n i ( t )  X  c 2 ( t u Hence, f  X  ( t u ) ( t ) &lt;f j ( t ),  X  o j  X  ( M ( t u { o  X  ( t u ) } .The  X  -condition thus follows.

M -condition : We have already shown that the M -condition holds if  X  ( t )=  X  ( t u ). With the proof that the  X  -condition holds, the M -condition follows.

F -condition : With the three substitutions, the F -condition ter violations, according to Table 2, we have (1) f  X  ( t min { c 2 ( t u ) ,c 3 ( t u ) } and (2)  X  o i  X  F ( t u ) ,n the F -condition follows.

In summary, if no filter violations have occurred since t then at any timestamp t&gt;t u , A ( t )= A ( t u ). Thus, BFP correctly maintains the answer set at timestamp t .
Corollary 1. Given a CPoNNQ with start time t s and end time t e , BFP correctly maintains the answer set of the query at any timestamp t  X  [ t s ,t e ] .
 Proof: Let there be m and only m filter violations within the interval ( t s ,t e ], which occur at timestamps t u 1 t m . Let us use t u 0 to denote t s ,and t u m +1 to denote t any timestamp t u i (0  X  i  X  m ), the server broadcasts to all the objects to acquire their locations. Hence the answer sets at those timestamps are correctly computed. For any other timestamps t , such that t u i &lt;t&lt;t u i +1 for some 0 protocol BFP returns A ( t u i ) as the answer. From Lemma 1, we know that A ( t )= A ( t u i ). Hence BFP maintains correct answer sets at all timestamp t  X  [ t s ,t e ].
The main drawback of BFP is that whenever an update is received from an object, a large maintenance cost is involved:
If the cardinality of M ( t u )iszero,thereisno c 1 ( t u c ( t u )exist,here u ( f i ( t )) is c 2 ( t u ).
Recall that the filter bound intervals are closed on the left andopenontheright. O distance from q
O distance from q (a) (b) the server has to request for the locations of all objects, recompute their filter bounds, and send these bounds to the objects. This is not always necessary. We now show how the maintenance overhead for two types of updates in BFP can be reduced. In this improved solution, Optimized Filter Protocol (OFP) , updates other than those related to o  X  and M are handled in the same way as in BFP. In Sections 5.1 and 5.2, we explain how to efficiently handle updates related to object o  X  and M , respectively.
We again let t u be the timestamp at which the most recent filter bounds are set by the server. Let t u be the timestamp at which filter bounds were set just before t u . We define the update event , called e  X  , for object o  X  ( t u ) , which occurs at timestamp t u : When e  X  occurs, o  X  ( t u ) sends its location to the server. In-stead of undergoing the costly maintenance phase of BFP, the server executes Algorithm 3. The algorithm has two goals: (1) it produces the correct answer set A ( t u )(Steps 1-8), and (2) assigns filters correctly to the objects (Steps 9-20), which is proved by the following two lemmas.
Lemma 2. Steps 1-8 of Algorithm 3 correctly derive the query answer (i.e., A ( t u ) )attimestamp t u .
 Proof: We first claim that  X  ( t u )=  X  ( t u ). Observe that: (1) o  X  ( t u ) is the min-max object from time t  X  [ t u (3) No filter violations have occurred at any timestamp t [ t ,t u ).

Hence, o  X  ( t u ) is the min-max object at timestamp t u Step 3 correctly assigns  X  ( t u )to  X  ( t u ).

We next show that M ( t u )and F ( t u ) can be correctly obtained. Step 2 fetches the latest values of M ( t u )and o  X  ( t u ) . Step 3 copies the information obtained at timestamp t u to the sets defined at timestamp t u . In Steps 4-8, we check whether it is possible for some object o i  X  M ( t u to be moved to F ( t u ). This is illustrated in Fig. 5(b), where after o  X  ( t u ) (dotted-line rectangle) has moved to the left at t u , f  X  ( t u ) ( t u ) is smaller than n i ( t o .Hence,this o i becomes a member of F ( t u ), as handled by Steps 6-7. Notice that all objects in F ( t u )remainin F ( t u ), since (1) for all o i  X  F ( t u ) ,n i ( t u ) c ( t u ) &gt;c 1 ( t u ) &gt;f  X  ( t u ) ( t u ). Thus, n Hence, Steps 1-8 correctly derives A ( t u ).

In Step 8, the variable m2f indicates whether an object o , originally in M ( t u ), now belongs to F ( t u ). It is used to compute filter bounds, as discussed next.
Lemma 3. Let t u be the most recent timestamp at which filter bounds of objects are set by Steps 9-20 of Algorithm 3. For any timestamp t&gt;t u , if no filter violations have oc-curred since t u ,then A ( t )= A ( t u ) . Proof: We now prove that  X  -condition, M -condition, and F -condition all hold if we substitute  X  ( t )by  X  ( t u ), M ( t )by M ( t u ), and F ( t )by F ( t u ).  X  -condition : Lemma 2 shows that we correctly obtain  X  ( t u )and M ( t u ). In Step 3, we get their latest values. Hence, c 1 ( t u )and c 3 ( t u ) can be set in the same way as BFP (Step 9). However, we cannot use Equation 2 to set c 2 ( t since the values of objects in F ( t u )are not acquired by the algorithm. Our solution is to assign another value to c 2 by considering two scenarios:  X 
M ( t u )= M ( t u ). This is illustrated in Fig. 5(a), where af-ter o  X  ( t u ) (dotted rectangle) has moved to the left at times-tamp t u , f  X  ( t u ) ( t u ) is larger than all the n i o  X  M ( t u ). Hence, M ( t u )= M ( t u ), and F ( t u )= F ( t Step 13 assigns c 2 ( t u )to c 2 ( t u ). This is correct, because: Lemma 2), (3) min { n i ( t u ) | o i  X  F ( t u ) } X  c 2 ( t u )(  X  for F ( t u ), and F ( t u )= F ( t u )).
 We can thus see that: Observe that c 2 ( t u ) is within the same range ( f  X  ( t place c 2 ( t u )by c 2 ( t u ) in Table 2, and use arguments similar to those of Lemma 1 to show that the  X  -condition holds.  X 
M ( t u )  X  M ( t u ). There exists object o i ,where o i but o i  X  F ( t u ). This is shown in Fig. 5(b). In Step 11, c ( t u ) is assigned the value of Observe that: (1) F ( t u )= F ( t u )  X  ( M ( t u )  X  M ( t u )), (2) min { n i ( t u ) | o i  X  ( M ( t u )  X  M ( t u )) } &lt;c tion in M ( t u )), (3) min { n i ( t u ) | o i  X  F ( t u ) } X  c 2 ( t u )(  X  F ( t u )).

Since c 2 ( t u ) &gt;c 1 ( t u ), we have min { n i ( t u Equation 2, we obtain Equation 5. Following the proof of Lemma 1, we see that the  X  -condition holds.

M -condition : Step 2 of Algorithm 3 acquire the newest values of o  X  ( t u ) and M ( t u ). Step 9 uses these results to compute c 1 ( t u )and c 3 ( t u ). Since these two values are used to compute the bound of M ( t u ) in Table 2, we can use the same argument of Lemma 1 to show that the M -condition holds.

F -condition : We have argued that the new value of c ( t u ), set in Steps 10-13, leads to the satisfaction of the  X  -condition. We can use a similar argument to show that the F -condition holds. The details are skipped due to space limitation. Notice that when m2f is false, the old values of c ( t u )areusedas c 2 ( t u ). According to Table 2, F ( t need to send the filters to F ( t u ) (Steps 14-16). When m2f is true, the filter bounds computed based on c 2 ( t u ) obtained in Step 11 are sent to all objects in F ( t u ) (Steps 17-20).
The advantage of Algorithm 3 is that it does not require the updated location of F ( t u ). In case m2f is false, F ( t is large, this can save a significant amount of communication cost.
Another update event, related to the set M , also allows communication cost savings. Let o m be an object in M ( t We now define the update event, called e M , for any object o , as follows: When this event occurs, o m sends its updated location value to the server. Two scenarios occur:  X  M ( t u )= M ( t u ), as illustrated in Fig. 5(c).  X  M ( t u )  X  M ( t u ), as shown in Fig. 5(d).

Notice that the cases described here are exactly the same as the ones for event e  X  . Specifically, in Fig. 5(a) and Fig. 5(c), no object in M ( t u )moveto F ( t u ), whereas in Fig. 5(b) and Fig. 5(d), one or more objects change their type from M ( t u )to F ( t u ). Moreover, the upper bound u ( n m ( t u )) mentioned in e M is c 1 ( t u ), which is the same as the lower bound l ( f  X  ( t u ) ( t u )) described in e  X  solution we developed for handling e M , Algorithm 4, is a slightly changed version of Algorithm 3. The main benefit of this algorithm is that if m2f is false, the update and filter bound assignment effort for F ( t u ) is saved. Otherwise, if n to F ( t u ) (Steps 17-20). The detailed proof of this algorithm, which is similar to that of Algorithm 3, is skipped here due to space limitation.

To summarize, OFP is an enhanced version of BFP. In particular, the filter violation events e  X  and e M are handled by Algorithms 3 and 4 respectively. To manage other kinds of filter violation, OFP borrows the event handling method of BFP. Next, we discuss the experimental results of our protocols.
We now report the results obtained from the performance studies on the three protocols: the Baseline, the Basic Fil-ter Protocol (BFP), and the Optimized Filter Protocol (OF-P). In Section 6.1, we describe the experimental setup. We present the experimental results in Section 6.2.
We use VanetMobiSim [17], an open-source vehicular traf-fic generator, to simulate the movement of objects. This sim-ulator can handle multi-lane roads, speed limits for different road categories, and traffic lights. We use the environment data provided by the TIGER data source [18], where the map used is a 10km  X  10km region clipped from Washing-ton DC. The simulation time (logical) is 300 seconds. In our experiments, an object X  X  motion is based on the Intelligent Driver Model with Lane Changing model [19], which regu-lates an object X  X  speed based on the movement of neighbor-ing objects. The speed range of an object provided by this simulator is between 8.33 and 13.89m/s. We assume that every object is equipped with a GPS device, which can be used to obtain the current location of the object. The GPS device captures the location of the object once every second (i.e., periodicity dt = 1). The number of objects simulated is 1 k by default, producing a total of 300 k location values. The error of a location value is represented by a circle, with a radius of 10m. This number is based on the result of G-PS error analysis provided by [20]. According to [21], the amount of energy required for sending (receiving) a message of each object is 77.4mJ (25.2mJ).

For each CPoNNQ, its query point is randomly generated within the map. Unless stated otherwise, each query has a lifetime of 300 seconds. In the latter part of the experi-ments, we will also explain the details of simulating multi-ple concurrent queries. We compare the performance of the three protocols studied here (i.e., baseline, BFP, and OFP) in terms of their communication and energy costs for exe-cuting a CPoNNQ. For communication costs, we measure their number of uplink and downlink messages. An uplink message is used by an object to send a location update to the server, while a downlink message is used by the server to send filter information to an object. We present the total number of these messages per second. We also analyze the rate of energy consumed by the objects for sending and re-ceiving messages. Each data point presented in the figures is obtained by averaging over the results for 100 queries.
The simulation program is developed in Java, and the ex-periments are performed by using a PC, with a configuration of Intel E8300 2.83GHz CPU and 2048MB of main memory. Table 3 summarizes the parameters and their values used. 1. Scalability. Fig. 6(a) illustrates the communication costs against the database size. For the baseline protocol, the number of messages increases linearly, because the larg-er the number of objects, the more uplink messages will be generated (Fig. 6(b)). Notice that BFP performs better than baseline: it saves about 56% of the number of messages Table 3: Parameters used in the experiments (de-fault values are marked with asterisks) created by baseline. This is because the filters installed to objects by BFP effectively reduces the number of uplink messages. As we can see from Fig. 6(b), when the number of objects, k , is 1,000, baseline generates 1,000 uplink mes-sages per second, while BFP produces 117 of them, which is 88 . 3% less. The price of this improvement is the use of more downlink messages (Fig. 6(c)). While baseline does not produce any downlink messages, BFP needs 117 of them at k =1 , 000. However, since the number of uplink messages saved by BFP (883) is much higher than that of the downlink messages it generates (117), the total number of messages required by BFP is still less than that of baseline. Fig. 6(a) shows that OFP outperforms BFP. On average, OFP requires 22% less messages than BFP. This is because OFP uses better routines to handle events e  X  and e M ,which reduce the number of uplink messages required (Fig. 6(b)). Since fewer uplink messages are received by the server, it also has less chance to generate downlink messages. Hence, the number of downlink messages required by OFP is less than that of BFP (Fig. 6(c)). At k =1 , 000, the number of downlink messages drops from 117 (for BFP) to 96 (for OFP). Consequently, OFP needs fewer messages than BFP.
We also study the energy consumption costs of the pro-tocols. As we can see from Fig. 6(d) that the overall trend of energy consumption is similar to that of the communi-cation costs in Fig. 6(a). They can be explained by the reasons stated above. Notice that there is an importance difference between these two figures. Particularly, BFP ad-dresses an improvement of 71% over baseline in terms of energy consumption cost, which is larger than the savings in communication costs (56%). This is because the amount of energy required for sending an uplink message is about 3 times that of the downlink messages. Hence, the amount of energy saved by BFP, relative to baseline, is higher than the relative amount of communication costs it saves. We can make a similar observation about OFP. While OFP requires 22% less messages than BFP, it consumes 24% energy less than BFP. 2. Effect of Uncertainty Region Size. In the second set of experiments, we examine the effect of uncertainty region size on the performance of the protocols. Here we use the radius of the uncertainty region to denote its size. Notice that if the radius equals zero, it means that all locations of objects are exact. As shown in Fig. 7(a), the total number of messages remains unchanged for baseline; for BFP and OFP, the communication cost increases with the radius. To under-stand why, first observe that when the size of an uncertainty region increases, the value of f  X  ( t ) ( t )attimestamp t increas-es accordingly. Hence, more objects may become a member of the answer set (i.e., M ( t )), and satisfy the M-condition at the time filters are installed at them. Secondly, with a larger uncertainty region, an object previously not in an an-Figure 6: Effect of scalability: (a) Total # of messages; swer set can become a member of M ( t ) more easily. Since the size of M ( t ) is larger, the chance that the M-condition is later violated by any of the objects in M ( t )alsoincreases. Finally, with a larger M ( t ), the chance that any of these objects becomes o  X  later also rises. When this occurs, fil-ters need to be regenerated for both BFP and OFP, thereby increasing their costs. Nevertheless, over a wide range of un-certainty region sizes, both protocols are still much better than baseline. When the radius is 300, for instance, BFP saves about 35% of messages required by baseline. In gener-al, OFP performs better than BFP; when the radius is 300, it saves about 34% of BFP X  X  communication cost. Fig. 7(b) illustrates the energy consumption costs of the three proto-cols. The performance is similar to Fig. 7(a), and the trend can be explained by using the same reason we just discussed. Figure 7: Effect of uncertainty region size: (a) Total # 3. Effect of  X  . Recall that the parameter  X  , defined in Section 4, is used to determine the cutoff values (i.e., c c ( t ), and c 3 ( t )). Fig. 8(a) shows how the communication cost of BFP is affected by this value. We can see that the number of messages is the minimum at around  X  =0 . 6, and is the highest when  X  is very small (0.1) or large (0.9). To understand why, recall from Table 2 that the three cutoff Figure 8: Effect of  X  : (a) Total # of messages; and (b) values determine the filter bounds used in BFP. When  X  in-creases, the three cutoff values, as well as the lower bound-s of the filters, increase. When objects move towards the query point q , these filter bounds are violated more easily. For example, at timestamp t u , for object o  X  ( t u ) ,thelower bound of f  X  ( t u ) ( t )is c 1 ( t u ). When  X  increases, so is c If o  X  ( t u ) moves towards q , f  X  ( t u ) ( t )decreases,andsoitcan violate the lower bound more easily. When  X  approaches 1, even a slight decrease of f  X  ( t u ) ( t ) can cause a filter viola-tion event. We can similarly argue that moving  X  closer to 0 decreases the upper bounds of filters, thereby increasing the chance of filter violation. If a filter violation occurs, a large maintenance cost can incur: collecting positions from objects, and sending filters to them, in Steps 10-13 of Algo-rithm 2. Hence, the performance of BFP suffers from the use of extremely small or large values of  X  .

In these experiments, we use  X  =0 . 5, which is just 1% worse than the optimal case (  X  =0 . 6). Moreover, observe that over a wide range of  X  (0.3 to 0.7), the performance of BFP is relatively stable. A similar observation can be made for OFP (Fig. 8(a)), as well as energy consumption costs (Fig. 8(b)). Without any knowledge about the movement patterns of objects (e.g., whether they tend to move towards or away from q ),  X  =0 . 5 is a reasonable choice. Figure 9: Computational Time vs. (a) # of objects; and 4. Computational Time Analysis. Next, we measure the computational time required by the server for support-ing the protocols studied here. Fig. 9(a) shows that this quantity increases with the database size, for all the proto-cols. To understand why, notice that the server needs to (1) retrieve the objects X  locations and compute the initial query results; and (2) recompute query results and filter infor-mation upon receiving uplink messages from the objects of interest. When the number of objects increases, the burden of handling activities (1) and (2) becomes heavier. Observe that BFP requires less time than baseline. For example, when k =10 , 000, BFP requires 38% less computational time than baseline. This is because the filters employed in BFP significantly reduces the number of update messages to be sent to the server (c.f. Fig. 6). Hence, the computational effort required to handle (2) for BFP is also less than base-line. The computational time of OFP is smaller than that of BFP. For instance, when k =10 , 000, OFP requires 32% less time than BFP. This is because in OFP, when events e  X  and e M occur, the server does not need to handle the locations of objects in F ( t u ).
 Fig. 9(b) shows the effect of the uncertainty region size. As explained before, a larger uncertainty region triggers more updates, and therefore the effort of handling activi-ty (2) increases. Again, OFP is the winner here. Figure 10: Results on multiple queries: (a) Total # of 5. Multiple Queries. In the final set of experiments, we examine the performance of our protocols in handling multiple queries, which are submitted to the system at dif-ferent times. The simulation period spans a total of 1800 seconds. The starting time of each query is randomly dis-tributed during the simulation period, and the lifetime of each query follows a uniform distribution in [180 , 600] sec-onds. To handle simultaneous query requests, we need to make some slight adjustments to our protocols. Specifically, the server has to maintain the filter information for every query; for each object, the filters for each query are stored. After a query has finished its execution, the server and the objects delete their filter information about this query. In these experiments, we assume that the object is capable of storing the filter information of all queries.

Figs. 10(a) and (b) show the performance result under this setting. On average, BFP saves 71% of messages and 81% of energy required by the baseline. Compared with BFP, OFP saves 21% of messages, and 22% of energy. Hence, under the multiple-user environment, OFP still performs the best.
Uncertainty management is an important issue in location-based services. In this paper, we study the communication cost of evaluating a CPoNNQ. We examine two filter-based protocols , namely BFP and OFP, where filter bounds are used to control when objects should report their updates. The OFP, which is an enhanced version of BFP, demon-strates superior performance in both communication and energy consumption costs. In this paper, we study how to improve the system X  X  performance in handling events e  X  and e
M . Our next step is to consider other events (e.g., when an object changes from type F to M ). We will also extend our approaches to support other complex queries in an LBS, such as k -nearest neighbor queries and skyline queries. Reynold Cheng, Yifan Jin, and Yinuo Zhang were support-ed by the Research Grants Council of Hong Kong (GRF Projects 711110, 711309E, 513508). We would like to thank the anonymous reviewers for their insightful comments. [1] D. Pfoser and S. Jensen. Capturing the uncertainty of [2] R. Cheng et al. Probabilistic verifiers: Evaluating [3] H. Kriegel et al. Probabilistic nearest-neighbor query [4] R. Cheng, D. Kalashnikov, and S. Prabhakar.
 [5] R. Cheng et al. Evaluating probability threshold [6] J. Chen et al. Scalable processing of snapshot and [7] Y. Zhang, R. Cheng, and J. Chen. Evaluating [8] Y. Tao, D. Papadias, and Q. Shen. Continuous nearest [9] J. Zhu et al. A probabilistic filter protocol for [10] C. Chow, M. Mokbel, and H. Leong. On efficient and [11] K. Mouratidis et al. A threshold-based algorithm for [12] R. Cheng et al. Adaptive stream filters for entity-based [13] R. Cheng et al. Filtering data streams for entity-based [14] C. Olston et al. Adaptive filters for continuous queries [15] J. Chen et al. A probabilistic filter protocol for [16] G. Trajcevski et al. Continuous probabilistic [17] J. H  X  arri et al. Vanetmobisim: generating realistic [18] http://www.census.gov/geo/www/tiger/shp.html . [19] M. Fiore et al. Vehicular mobility simulation for [20] Bradford W. and James J. Spilker. GPS error [21] MPR-Mote Processor Radio Board User X  X  Manual .
