 XML(eXtensible Markup Language) is a standard for representing and exchanging information on the Internet. As such, more documents can be represented in XML documents. However, because the size of XML documents is very large and their types vary, it is necessary to provide means to manage XML document collection[1,2,3,4]. Clustering the related XML documents is a potential research topic in integrating a large XML document collection. Several research approaches had tackled the issue. intermediate DTD in order to integrate DTDs. Although this approach addresses the problem of clustering DTDs, it can X  X  be directly applied to XML documents. Yun Shen et al. [6] propose a clustering technique for schemaless XML documents. And this introduces a decomposition mechanism of a tree model, called macro-path. The value among these macro-path sequences from each XML document. Though this cluster the XML documents. In this approach, an XML document is defined as a sequence of ePaths with associated element contents, and a bitmap index is constructed contents of the ePaths are integrated into the bitmap index. Though bitcube can support clustering XML documents, it requires too much space for a large amount of documents. Doucet. et al. [8] address the problem of clustering a homogenous collection of text-based XML documents. In this approach each document is tags. And it applies k-means algorithm to group XML document by element tags and texts. However, this approach ignores the structural information in XML documents. And also there are some researches[3,9,10,11] to extract common structures from XML documents. [9] constructs a tree structure from elements in XML documents and estimates semantic similarity of different document by comparing the tree then finds a subset of the frequent trees. But the multi relational tree structure can X  X  be detected, because it is based on the label pairs. 
The conventional technique used for the previous XML document clustering approaches[5,6,8] is a hierarchical agglom erative clustering[12], denoted HAC. But it needs in general the number of clusters, and also it is based on a measure of pairwise similarity between documents. Therefore, it is difficult to determine both correct parameter and similarity computation method between XML documents. 
In this paper, we propose a new XML clustering technique based on sequential pattern mining, which doesn X  X  need a measure of pairwise similarity between XML documents. We first extract the representative structures of frequent pattern including hierarchy structure information from documents by the sequential pattern mining method. Then, we create document clusters by applying the CLOPE algorithm[13] and the concept of large items[14]. In this step, we consider an XML document as a transaction. The proposed method is useful for document management and retrieval of the similar structure in large amounts of schemaless XML documents. 
The remaining of the paper is organized as follows. Section 2 describes the method extracting the representative structure of XML documents. Section 3 defines our section 4. Section 5 concludes the paper. An XML document can be modeled as a tree T(N, E) where N is a set of nodes and E such that n i  X  n j . In this paper, the tree model representing XML document is rooted, directed, and node-labeled, and we ignore the order between siblings because we focus on hierarchical path structure of elements in an XML document. 
In order to support the clustering of large scale XML document collection, we extract the path information from XML documents, called Mine X_path( mX_path ). It both attribute node and content node in an XML document. Therefore, any tuple content node in a path. We focus on paths of elements with content value, not considering attribute in an XML document because attributes in an XML document doesn X  X  much influence on structure information. Therefore we don X  X  admit null value in representing mX_path. We formally define Mine X_path( mX_path ) as follows. Definition 1 (Mine X_path(mX_path)). Given a node n i with content value in an XML document tree, mX_path of node n i is defined as a 2-tuple(PrefixPath(n i ), ContentNode(n i )). An XML document(X_Doc i ) consists of many mX_path sequences, and the order of mX_paths is ignored because we judge structural similarity based on the degree of common structures between XML documents. An mX_path sequence is denoted as follows. where PrefixPath(n i ) is an ordered sequence of tag name from root to node n i-1 which includes hierarchical structure. ContentNode(n i ) is a sequence of tag names with content value under the same PrefixPath(n i ) sequence and the order among the content sequence is ignored, but duplicating element names are not omitted. The mX_paths extracted from an XML document imply multiple association and level information of elements in an XML document. Example 1. Figure 1 shows an example of XML document tree. We first construct an element mapping table based on the Figure 1, as shown in Figure 2. mX_path in each document, we map similar elements on an mX_path to the same integer corresponding to the element mapping table of Figure 2, as shown in Figure 3. To consider semantics of element name of mX_path in each document, we use WordNet Java API[15] while constructing the element mapping table and determine whether two elements are synonyms. 
We finally extract representative structures of each document on the basis of the transformed mX_path sequences in Figure 3, using PrefixSpan algorithm [16]. The frequent paths from PrefixPath sequences of the mX_paths by PrefixSpan algorithm. mX_paths.

When we find frequent structures from PrefixPath sequences of the mX_paths , mX_path i is regarded as the sequence_id and a PrefixPath sequence of the mX_path is considered to be a sequence. And also we consider each element of PrefixPath as items of the sequence. The complete algorithm is given as follows. Algorithm mX_path_FrequentSearch Input: mX_path sequences in an XML document (X_Doc i ) the minimum support threshold min_sup (the total number of mX_paths in a Output: the complete set of frequent path Fp i 1. Find the set of frequent paths Fp i in the set of PrefixPath sequence which is a part -call PrefixSpan algorithm (refer to [16]) 2. Find the set of frequent paths Fp i considering the ContentNode of each mX_path
After finding the set of frequent paths in each document, we input the frequent paths of length over min_length(the average maximal frequent structure length * length_rate  X  (0 &lt;  X   X  1)) into clustering algorithm. Example 2. Consider Figure 3. Assume that min_sup is 2 and length_rate is 0.6. The length_1{1:6, 5:2, 10:2} and length_2{1/5:2, 1/10:2}. And the frequent full path by result, is {1/3:2, 1/5/6:2, 1/10/11:2}. After that, we can get the min_length(3 * 0.6 = 2). As a result, we input length_2{1/5, 1/10, 1/3}and length_3{1/5/6, 1/10/11} over min_length for clustering. To perform clustering, we assume an XML document as a transaction, the frequent structures extracted from each document as the items of the transaction, and then we perform the document clustering using the notion of large items. allocation gain. Definition 2 (Cluster Allocation Gain). The cluster allocation gain is the sum of the equation expresses this. where G is the occurrence rate(H) to individual item(W) in a cluster, H = T (the total occurrence of the individual items) / W (the numbers of the individual items), and G = T/W 2 . |C i (Tr)| is the number of transactions included in the cluster C i . 
Gain is a criterion function for cluster allocation of the transaction, and the higher the rate of the common items, the more the cluster allocation gain. Therefore we allocate a transaction to the cluster to be the largest Gain . However if we use only the individual items like CLOPE, it causes some problems as follows. Example 3. Assume that transaction t 4 = {f, c} is to be inserted, under the condition respectively. If t 4 is allocated to C 1 or C 2 , Gain is = t is allocated to a new cluster, Gain is =  X  +  X  +  X  allocated to a new cluster by definition 2. As you see in this example, we can get the considerably higher allocation gain about a new cluster, because Gain about a new cluster equals W / 2 W . Due to this, it causes the production of many clusters over the regular size, so that it may reduce cluster cohesion. In order to improve this problem, we define the large items and the cluster participation as follows. Definition 3 (Large Items). Item support of cluster C i is defined as the number of the item in the cluster C i . number of the transactions including the item i j in the cluster C i . We represent it as follows. |t | is the number of the items of the transaction t k . In example 3, if there is any cluster that satisfies the given minimum participation about insertion of t4, our approach does not produce a new cluster, but allocate t4 to the existing cluster with maximum participation. Therefore, cluster participation can control the number of cluster. When  X  1 is small, the production of the cluster is suppressed. 
The key step is finding the destination cluster for allocating a transaction, which is the most time sensitive part in clustering algorithm. But we can easily find the cluster of the largest Gain through calculating the difference operation about current Gain as follows. Definition 5 (Dif ference Operation). The difference operation is the different Gain ( Add_Gain(  X  + ) ) which is formally defined as follows. individual items when the transaction is inserted. We can compute the change value Add_Gain(  X  + ) . 
We also reuse the cluster participation(Definition 4) to compute the Gain about the only clusters that satisfy the newly given cluster participation  X  2 . The XML document clustering algorithm by difference operation is shown in Figure 4(  X  1 and 2 can have different value.) XML_C, we conducted intensive experiments, comparing XML_C with CLOPE and HAC. The data used were 300 schemaless XML documents, selected from 8 topics (i.e., book, club, play, auction, company, department, actor, and movies), taken from the Wisconsin X  X  XML data bank[17]. In the first step of the experiments, in order to extract the representative structure of each document, we set the minimum_support to average maximal frequent structure length. The average maximal length and the number of frequent path structure extracted in each document are 4.3 and 6.2 respectively. 
To perform HAC algorithm, we generated the similarity matrix, computing similarity among the decomposed mX_path sequences from XML documents in the same manner of [6], and then we grouped XML documents on the basis of the matrix, using hierarchical clustering technique[12]. 
Figure 5 illustrates the execution time of the algorithms as the number of document increases. The important result in this experiment is that the performance of XML_C is comparable to that of CLOPE, while be ing much better than HAC. This is because hand, XML_C has slightly better performance than CLOPE. It shows that XML_C performance in contrast to CLOPE. find a cluster(C i ) maximizing add_Gain (C); allocate t to an existing cluster C j ; 
For quality measure of clustering result, we adopted the cluster cohesion and the inter-cluster similarity, and we defined as follows. T(C i ) in the cluster C i . This is calculated by the following formula, and if it is near 1, it is a good quality cluster. common large items of the cluster C i and C j . We calculate the inter-cluster similarity by the following formula, and if it is near 0, it is the good clustering. |L(C i  X  C j )| is the total occurrence number of the common large items, and |L(C i +C j )| is the total occurrence number of the large items in the cluster C i and C j . 
To measure Coh (C i ) and Sim (C i ,C j ), it needs large items in the cluster, but CLOPE according to the given minimum support from the clustering results in the same manner of XML_C, after running both CLOPE and HAC respectively. The result of the cluster cohesion and the inter-cluster similarity according to the minimum support is shown in Figure 6 and Figure 7. 
As we expected, the XML_C exhibits the highest cluster cohesion among these three algorithms in Figure 6. XML_C keeps it well with approximately probability nearly 1. Clearly, it gets better result by considering the distribution of common structures in each cluster during the cluster assignment. On the other hand, the cluster cohesion of HAC has the lowest performance since it does not consider common depends on the similarity measure. 
Figure 7 shows inter-cluster similarity measurement, and the performance ranking of three algorithms is HAC &gt; XML_C &gt; CLOPE ( X &gt; X  means better). The explanation here is that HAC produces the smaller number of clusters than XML_C and CLOPE, even if we set the number of cluster similar to that produced by XML_C and CLOPE. This had an effect on the inter-cluster similarity measurement of HAC, with the smallest variation. 
By observing both Figure 6 and Figure 7, we can easily realize there exist relations between the number of clusters and inter-cluster similarity, and also between the number of clusters and cluster cohesion. The smaller the number of clusters produces, the smaller inter-cluster similarity we can get. Contrariwise, if the smaller the number of cluster produces, the larger cluster cohesion we can get. 
Further more, the bad result of HAC, which both cluster cohesion and inter-cluster similarity are low at the same time, was why it performed clustering by not common XML_C is due to the global criterion co nsidering both the common structures and individual structures in a cluster together. 
In summary, we can determinate that XML_C is better overall at cluster cohesion XML documents together and gathers dissimilar structured XML documents apart. In this paper, we proposed a new approach to XML document clustering method without using any measure of pairwise similarity. We first extracted the representative structures of XML documents using the sequential pattern mining, which focused on element path including hierarchal element information in the XML document. And then we performed clustering based on similar structure using notion of large items to improve cluster quality and performance, considering that an XML document as a transaction and the extracted frequent structures from documents as the items of the transaction. Our experiments showed that our approach could get the higher cluster cohesion and the lower inter-cluster similarity, taking less time to perform. 
Our future works include a way to cluster XML documents by considering both element and content at the same time. 
