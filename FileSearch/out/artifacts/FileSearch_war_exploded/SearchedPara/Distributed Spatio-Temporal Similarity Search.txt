 In this paper we introduce the distributed spatio-temporal similarity search problem: given a query trajectory Q ,we want to find the trajectories that follow a motion similar to Q, when each of the target trajectories is segmented across a number of distributed nodes. We propose two novel algo-rithms, UB-K and UBLB-K, which combine local computa-tions of lower and upper bounds on the matching between the distributed subsequences and Q . Such an operation gen-erates the desired result without pulling together all the distributed subsequences over the fundamentally expensive communication medium. Our solutions find applications in a wide array of domains, such as cellular networks, wildlife monitoring and video surveillance. Our experimental evalu-ation using realistic data demonstrates that our framework is both efficient and robust to a variety of conditions. H.3 [ Information Storage and Retrieval ]: Algorithms, Design, Performance, Experimentation Spatio-temporal Similarity Search, Top-K Query Processing
The advances in networking technologies along with the wide availability of GPS technology in commodity devices, make spatiotemporal records nowadays ubiquitous in many different domains including cellular networks, wildlife moni-toring and video surveillance. The enormous growth in spa-tiotemporal records in conjunction with the emerging in-network storage model, constitute centralized spatiotempo-ral query processing techniques obsolete in many respects. Copyright 2006 ACM 1-59593-433-2/06/0011 ... $ 5.00.
To stimulate our description consider the Enhanced 911 (e911) 1 service, which was recently enforced by the Federal Communications Commission (FCC) to all US cellular ser-vice providers. In e911 , each provider must be able to locate wireless 911 callers within a 50 to 300 meters accuracy, when required. In order to satisfy t he FCC requirements, carriers had the choice to either add GPS technology into their cell phones (the handset solution ), or to estimate the position of a caller using the timing of signals emitted from the phone to the base station (the network solution ). The bottom line of both approaches, is that base stations scattered around US neighborhoods must be able to provide the precise lo-cation of any cell phone user at any given moment. In the event of a 911 call, the accurate location information will be transmitted towards the local state and government agen-cies that can take further action. An important point is that the generated data remains in-situ , at the base station that generated the data, until some event of interest occurs.
The above example shows three important points : i) spatiotemporal data becomes available in an ever growing number of applications; ii) organizations realize that a dis-tributed data storage and query processing model is in many occasions more practical than storing everything centrally. A category of applications for which this is particularly true, are sensor and RFID-related technologies that try to capture the physical world at a high fidelity; and iii) many of the generated spatiotemporal records might become outdated before they are ever utilized (for instance a cell phone user might never actually make a 911 call), which again shows that centralization might be a wasteful approach.
In this paper we propose techniques to overcome the in-herent problems of the centralized scenario. Specifically, we formulate the Distributed Spatio-Temporal Similarity Search problem and devise techniques to solve this problem effi-ciently. To formalize our description, let A denote a spatio-temporal trajectory defined as a sequence of l multidimen-sional tuples { a 1 , ..., a l } . Each tuple is characterized by two spatial dimensions and one temporal dimension (i.e. a ( x i ,y i ,t i ),  X  i  X  [1 ..l ]). A segment or subsequence of a tra-jectory A , is defined as a collection of r consecutive tuples [ a ..a i + r ](i+r  X  l ). Note that the segments of each trajec-tory A , are located at different remote sites, depending on the site that collected the data. In real applications a tra-jectory will usually span many such sites, depending on the coverage provided by each access point. http://www.fcc.gov/911/enhanced/
We denote the natural fragmentation of each trajectory as spatial fragmentation , because a trajectory is sliced up into several disjoint subsequences which reside on spatially dis-tributed sites. Our objective is to answer the query:  X  X eport the objects (i.e. trajectories) which follow a similar spatio-temporal motion with Q  X  ,where Q is some query trajectory. The notion of similarity captures the trajectories which dif-fer only slightly, in the whole sequence, from the given search query Q . More formally, the tuples of each target trajectory A , are compared with the points of Q within some tem-poral and spatial window. Other queries, such as pattern queries [12], which look at the pattern of a trajectory rather than individual points, are similarly interesting but outside of the scope of this paper.

Research to this day, has focused on computing similarity queries assuming that the querying entity has access to all the trajectories in advance, or becomes aware of them in a streaming fashion (Section 2 provides an overview). While the centralized model serves well many scenarios where the transfer of data is inexpensive, it is not appropriate for en-vironments with expensive communication mediums, such as wireless sensor networks [16], or environments where the distributed sites generate large quantities of spatio-temporal records (e.g. the e911 scenario).

Our approach is optimized for retrieving the K most simi-lar trajectories to a query Q , for a user parameter K .There-fore the queries do not retrieve the whole universe of an-swers. Additionally, the techniques we propose employ tra-jectory matching techniques that have been shown to be accurate and tolerant to noise and outliers while featuring an extremely low computational overhead. In this paper we mainly use the Longest Common Subsequence (LCSS) [9] as a distance measure, but the techniques can easily be ex-tended to work with Dynamic Time Warping (DTW) [5] as well. Our main contributions are summarized as following: 1. We introduce and formalize the problem of finding 2. We propose the UB-K and UBLB-K algorithms, which 3. We propose DUB LCSS and DLB LCSS ,whichare
The remainder of the paper is organized as follows: Sec-tion 2 provides an overview of related research, Section 3 formulates the problem and our notation. Section 4 de-scribes our distributed query processing algorithms, UB-K and UBLB-K , which utilize upper and lower bound scores on a variety of distance measures in order to compute the K most similar trajectories to a query trajectory Q .Theexact mechanism of generating the upper bounds ( DUB LCSS ) and lower bounds ( DLB LCSS ) is described in Section 5. In Section 6, we present an experimental study of our al-gorithms using 25,000 car trajectories moving in the city of Oldenburg (Denmark) and Section 7 concludes the paper.
To the best of our knowledge the distributed spatiotem-poral similarity search problem has not been addressed in the literature before. However spatio-temporal queries have been an intense area of research over the last years [1, 4, 13, 19, 20, 22, 24, 26]. This resulted in the development of efficient access methods [13, 15, 22, 24] and similarity measures [5, 9, 24] for predictive [23], historical [24] and complex spatio-temporal queries [12]. All these techniques, as well as the frameworks for spatio-temporal queries [18, 21, 25], work in a completely centralized setting. Our tech-niques on the other hand are decentralized and keep the data in-situ , which is more appropriate for environments with expensive communication mediums and for large scale applications that generate huge amounts of spatiotemporal records.

One problem with the in-situ storage of trajectories is that query processing now becomes significantly more complex. Finding similar trajectories in a distributed fashion might require sophisticated techniques and interactions to uncover the potentially very large n umber of answers. Note that a query of the type  X  X ind which other trajectories are similar to trajectory Q X  yields fuzzy answers, thus it is meaning-ful to limit the cardinality of the answer set to some user defined threshold K. Otherwise, the user would end up re-trieving a large number of less relevant answers. Solutions to the above Top-K query processing problem, have tradition-ally been provided by the database community in a variety of contexts including middleware systems [10, 11], web accessi-ble databases [7, 17, 27], stream processors [2], peer-to-peer systems [3] and other distributed systems [8, 28].
In general, a Top-K query returns the K highest ranked answers to a user defined similarity function. For instance the query by example:  X  X ind the K=5 images that are most similar to some query image Q X  , returns the five pictures that minimize the average distance for a set of given dimen-sions (e.g. using features such as color, texture, etc). A top-k query returns a subset of the complete answer set, in order to minimize some cost metric that is associated with the retrieval of the complete answer set. Such a cost is usually measured in terms of disk accesses or network trans-missions, depending on where the data physically resides.
The TA [11] algorithm and its variants are well established and understood algorithms for computing top-k queries in a centralized setting. A fundamental assumption underlying these algorithms is that the exact score is available for each dimension of the similarity function. For instance, given some image p i and some query image Q , we have a similarity score associated with each of its dimensions (i.e. 0.7 simi-larity with respect to color, 0.94 similarity with respect to texture etc). The total similarity of p i and Q , is then simply be the average of these scores (i.e. 0.82). Exact scores are also the underlying assumption of distributed top-K query processing algorithms proposed in recent literature, namely the TPUT [8], TJA [28] and TPAT [14].

Unfortunately such exact scores are not available in our setting and therefore none of the above top-k query pro-cessing solutions can be utiliz ed in our case. To understand this first assume that we map, using a 1:1 correspondence, each query dimension to a distributed site. The most similar trajectory A is the one that maximizes the similarity to Q across all dimensions (i.e. all sites).

A naive solution would be to calculate some exact similar-ity score at each remote site and then combine these scores using any of the aforementioned top-k query processing al-gorithms. For instance, by utilizing the Euclidean distance ( L 2 ) ,givenas | Q  X  A | = 2 a set of exact scores, which express the distance of Q to A . However the matching between Q and A , would only occur between points of identical time positions. As a result, it would neither be flexible to out-of-phase matches (e.g. if we have two identical trajectories but the first one moves earlier in time) nor tolerant to noisy data (e.g. we have two iden-tical trajectories but the first has some slight deviation in its spatial movement). Disregarding these parameters might result in an extremely poor similarity matching.

Therefore we opt for a multidimensional similarity mea-sure that takes into account out-of-phase matches and grace-fully handles noisy data. In particular, we use the Longest Common Subsequence that will be described in Section 5.2. Using such a measure in a distributed environment limits us to a lower and upper bound on the similarity score be-tween a query trajectory Q and A i . For instance, we might only know that the similarity of Q to some subsequence A 1 is between 0.88 and 0.92 and that the similarity of Q to A 2 is between 0.85 and 0.90. Thus, we can not deter-mine which of the two trajectories is more similar to Q. For instance if the real similarity is F ullM ( Q, A 1 )=0 . 89 and F ullM ( Q, A 2 )=0 . 90 then A 2 is the most similar one; on the contrary if F ullM ( Q, A 1 )=0 . 89 and F ullM ( Q, A 2 )=0 . 87 then A 1 is the most similar.

The above description shows that by having score bounds, rather than exact scores, is not enough to identify the most similar trajectories. This creates a challenging problem: How to calculate the top-K answers if we have score bounds rather than exact scores? We will provide two novel al-gorithms that solve this problem in an iterative fashion. Such algorithms might potentially have many other applica-tions outside the spatiotemporal similarity search domain, although we will not explore these possibilities here.
In this section we provide the notation used throughout the paper. Specifically, we formalize our data and query model. The main symbols and their respective definitions are summarized in Table 1.
 y time Figure 2: Two Spatially Fragmented Trajectories A 1 ,A 2
Let G denote a 2-dimensional matrix of points in the xy-plane that represents the coordinate space of some ge-ographic area. Without loss of generality, we assume that the points in G are logically organized into x  X  y cells as illus-trated in Figure 2. Each cell contains an access point ( AP ) that is assumed to be in communication range from every point in its cell. 2
Although the coordinate space is assumed to be parti-tioned in square cells, other geometric shapes such as vari-able size rectangles or Voronoi polygons are similarly appli-cable but outside the scope of this paper. This partitioning of the coordinate space simply denotes that in our setting, G is covered by a set of AP s .Nowlet { A 1 ,A 2 , ..., A note a set of m objects moving in G . At each discrete time instance, object A i (  X  i  X  m ) generates a spatio-temporal record r = { A i ,t i ,x i ,y i } ,where t i denotes the timestamp on which the record was generated, and ( x i ,y i ) the coordi-nates of A i at t i . The record r is then stored locally at the closest AP for l discrete time moments after which it is dis-carded. Therefore at any given point every access point AP maintains locally the records of the last l time moments.
A trajectory can be conceptually thought of as a contin-physically it is spatially fragmented across several cells (see Figure 2). Similarly, the spatio-temporal query is also rep-not spatially fragmented.
Our objective is to answer efficiently top-K queries of the type: given a trajectory Q , retrieve the K trajectories which
The terms access point and cell are used interchangeably. Figure 3: (a) METADATA : Lower and Upper bounds are the most similar to Q . First note that the similarity query Q is initiated by some querying node QN , which dis-seminates Q to all cells that intersect the query Q .We call the intersecting regions candidate cells . Upon receiv-ing Q , each candidate cell executes locally a lower bounding matching function ( LowerM ) and an upper bounding func-tion ( UpperM ) on all its local subsequences (these functions will be described in Section 5.2). This yields 2  X  m local dis-tance computations to Q by each cell (one for each bound). To speed up computations we could utilize spatiotemporal access methods similar to those proposed in [24]. The con-ceptual array of lower ( LB ) and upper bounds ( UB ) for an example scenario of three nodes ( C 1 ,C 2 ,C 3 ) is illustrated in Figure 3a. We will refer to the sum of bounds from all cells as METADATA and to the actual subsequence trajectories stored locally by each cell as DATA . Obviously, DATA is orders of magnitudes more expensive than METADATA to be transferred towards QN . Therefore we want to in-telligently exploit METADATA to identify the subset of DAT A that produces the K highest ranked answers. Fig-ure 3b illustrates two typical topologies between cells: star and hierarchy. Our proposed algorithms are equivalently ap-plicable to both of them although for the remainder of the paper we use a star topology to simplify our description.
In order to find the K trajectories that are most similar to a query trajectory Q , QN can fetch all the DATA and then perform a centralized similarity computation using the F ullM ( Q, A i )(  X  i  X  m ) method, which is one of the LCSS, DTW or other L p -Norm distance measures presented in Sec-tion 5. Centralized is extremely expensive in terms of data transfer and delay.
In this section we present two novel distributed query pro-cessing algorithms, UB-K and UBLB-K , which find the K most similar trajectories to a query trajectory Q .TheUB-K algorithm uses an upper bound on the matching between Q and a target trajectory A i , while UBLB-K uses both a lower and an upper bound on the matching. The description on how these bounds are acquired is delayed until Section 5.
The UB-K algorithm is an iterative algorithm for retriev-ing the K most similar trajectories to a query Q . The algo-rithm minimizes the number of DATA entries transferred to-wards QN by exploiting the upper bounds from the META-DATA table. Notice that METADATA contains the bounds of many objects that will not be in the final top-K result. In order to minimize the cost of uploading the complete METADATA table to QN we utilize a distributed top-K Algorithm 1 : UB-K Algorithm Input: Query Q , m Distributed Trajectories, Result Pa-rameter K , Iteration Step  X  .
 Output: K trajectories with the largest match to Q . 1. Run any distributed top-K algorithm for Q and find 2. Fetch the ( X   X  1) trajectories from the cells and com-3. If the  X th UB is smaller or equal to the K th largest query processing algorithm, such as TPUT [8], TJA [28] and TPAT [14], that transfers only the most necessary en-tries from the METADATA table towards QN . These algo-rithms do the following function: Given a set of n distributed scores for each of m objects, they return the K objects with the highest score across all n sites. Note that in our setting, these scores are the local upper bounds. In the experimental evaluation we utilize the TJA algorithm, although any other distributed top-k algorithm is applicable as well. Description: Algorithm 1 presents UB-K . In the first step of the algorithm, QN retrieves the  X  highest UBs with the assistance of a distributed top-K algorithm. The param-eter  X  expresses the user confidence in the METADATA bounds. For example when the user is confident that the METADATA table contains tight bounds, then  X  might be set to a small value. 3 In the second step, QN fetches the exact trajectory (i.e. DATA )for X   X  1trajectories A i iden-tified in the first step. It then performs a local computation of F ullM ( Q, A i ) and determines their full matching to the query Q . If the  X th highest UB is smaller or equal to the K th highest full matching value, we terminate with the final result. Otherwise, we perform another iteration by increas-ing the parameter  X  by  X  .
 Example: Consider the example scenario of Figure 4. As-sume that the query is to find the top-2 trajectories ( K =2) across C 1 ,C 2and C 3. In the first step, QN computes the UBs of the highest  X  METADATA entries (i.e. A 4 ,A 2 ,A 0 using a distributed top-k algorithm. These entries are the ones that have the highest average UB across the three cells. The entries below A 0 in the METADATA table are not available to the querying node QN at this point. In the
In this paper we initialize  X  as K +1. second step QN will fetch the subsequences of the trajec-tories identified in the first step. Therefore QN has now the complete trajectories for A 4 and A 2 (right side of Fig-ure 4). QN then computes the following full matching: F ullM ( Q, A 4 ) = 23, F ullM ( Q, A 2 ) = 22 using the Longest Common Subsequence described in Section 5. Since the  X th highest UB ( A 0 = 25) is larger than the K th highest full match ( A 2 = 22), the termination condition is not satis-fied in the third step. To explain this, consider a trajec-tory X with a UB of 24 and a full match of 23. Obviously X is not retrieved yet (because it has a smaller UB than 25). However, it is a stronger candidate for the top-2 result than ( A 2 , 22), as X has a full match of 23 which is larger than 22. Therefore we initiate the second iteration of the UB-K algorithm in which we compute the next  X  (  X  =2) METADATA entries and full values F ullM ( Q, A 0 ) = 16, F ullM ( Q, A 3 ) = 18. Now the termination has been satis-fied because the  X th highest UB ( A 9 , 18) is smaller than the K th highest full match ( A 2 , 22). Finally we return as the top-2 answer the trajectories with the highest full matches (i.e. { ( A 4 , 23) , ( A 2 , 22) } ).
 Theorem 1. The UB-K algorithm always returns the most similar objects to the query trajectory Q.
 Proof: Let A denote some arbitrary object returned as an answer by the UB-K algorithm ( A  X  Result ), and B some arbitrary object that is not among the returned re-sults ( B/  X  Result ). We want to show that F ullM ( Q, B ) F ullM ( Q, A )alwaysholds.

Assume that F ullM ( Q, B ) &gt; F ullM ( Q, A ). We will show that such an assumption leads to a contradiction. Since A  X  Result and B/  X  Result it follows from the first step of the algorithm that ub B  X  ub A . In the second phase of the algorithm we fetch the trajectory A and calculate F ullM ( Q, A ). By using the assumption, we can now draw the following conclusion: F ullM ( Q, A ) &lt; F ullM ( Q, B ) ub
B  X  ub A . When the algorithm terminates in the third step, with A among its answers, we know that ub X ,for some object X, was smaller or equal to the Kth largest full score (i.e. ub X  X  ...  X  F ullM ( Q, A )). But it is also true that ub B  X  ub X (as object B was not chosen in the first step of the algorithm), which yields ub B  X  ub X  X  F ullM ( Q, A ) and subsequently F ullM ( Q, B )  X  F ullM ( Q, A ) (by defini-tion F ullM ( Q, B )  X  ub B ). This is a contradiction as we assumed that F ullM ( Q, B ) &gt; F ullM ( Q, A )
The UBLB-K algorithm is, similarly to UB-K ,anitera-tive algorithm for retrieving the K most similar trajecto-ries. However it has two subtle differences: (i) It uses both an upper bound (UB) and a lower bound (LB) in order to determine whether the top K trajectories have been found and (ii) It transfers the candidate trajectories in a final bulk step rather than incrementally.
 Description: Algorithm 2 presents UBLB-K . The first step of this algorithm is identical to UB-K with the difference that we also compute a distributed LB. This comes at a very small network and delay overhead as this is performed in parallel with the UB computation. In the second step, QN checks if the  X th highest UB is smaller or equal to the K th highest LB. If that is the case then QN certainly Algorithm 2 : UBLB-K Algorithm Input: Query Q , m Distributed Trajectories, Result Pa-rameter K , Iteration Step  X  .
 Output: K trajectories with the highest match to Q . 1. Run any distributed top-K algorithm for Q and find 2. If the  X th highest UB is smaller or equal to the K th 3. Fetch the trajectory for objects which have a UB big-knows that the top-K trajectories are in the candidate list constructed in the first step. Therefore QN proceeds to step 3 in which it fetches all trajectories with UB larger than the K th highest LB. Notice that if the  X th highest UB is larger than the K th highest LB, then we would proceed to step 1 for another iteration with a larger parameter  X . The intu-ition behind UBLB-K is that the termination condition can be identified based on the LB rather than the full matching. Therefore we are not required to incrementally fetch the dis-tributed trajectories, but we can fetch them all together in a final bulk step.
 Example: Consider the example of Figure 5, which this time presents both bounds in METADATA . In the first step we compute the LB and UB for the first  X  METADATA en-tries (i.e. A 4 ,A 2 ,A 0 ). We observe that the  X th highest UB ( A 0 , 25), is larger than the K th highest LB ( A 2 , 21). There-fore the termination condition of step 2 is not satisfied. The intuition behind this condition is in fact the same as for the UB-K case. Specifically, the existence of some trajectory X withaUB24andafullmatchingof23wouldcreatea stronger candidate for the top-2 result than the current can-didate ( A 2 , 21 , 27). Therefore we initiate the second itera-tion in which we compute the next  X  (  X  =2) METADATA entries A 3 ,A 9 . Now the  X th highest UB (18) is smaller than the K th highest LB (21). Therefore QN can safely proceed to the final bulk transfer step knowing that the re-sult is among the candidates. Instead of fetching all can-didates however, QN only fetches the trajectories with UB larger than the K th highest LB which is 21. Therefore QN are the only candidates with UB larger than K th highest LB ( A 2 , 21). After QN performs the final bulk transferring step it calculates the full match of the retrieved candidates and simply returns the top-2 trajectories with the highest match to the query (i.e. { ( A 4 , 23) , ( A 2 , 22) } ). Theorem 2. The UBLB-K algorithm always returns the most similar objects to the query trajectory Q.
 Proof: Similar to Theorem 1 UB-K vs. UBLB-K: Comparing the two algorithms we can observe that in many cases (like our example), UBLB-K might terminate and retrieve less DATA entries at the ex-pense of an increased overhead of METADATA entries. Note that the DATA entries are orders of magnitudes more expen-sive to be transferred than METADATA entries. The sav-ings increase when the LBs are tighter, which consequently allows QN to determine faster whether the top-K results have been found. The savings of UBLB-K are also increased for larger values of  X . Note that UB-K has to always re-trieve  X  full trajectories while UBLB-K , based on the LBs, can be more selective. These observations are validated in Section 6.
 Incremental Deepening into Top-K Results: Since both our algorithms fetch the highest METADATA incre-mentally (e.g. they find the top K , X +  X  , X +2  X  , ... UBs at increasing iterations), QN can cache the METADATA and DATA it has received in the previous iterations and only request for the new METADATA and DATA in a new it-eration. Consider for example Figure 4, where in the first iteration, QN fetches the trajectories of { A4, A2 } .Inthe second iteration, QN only needs to fetch the trajectories of A0 and A3, since the top 2 trajectories have already been fetched in the previous iteration.
 Global Clock Independence: It is important to men-tion that our algorithms operate correctly in the absence of a global clock. This is true because the various phases of our algorithms are not defined as a function of time. How-ever, when nodes are not synchronized then this might result in the computation of incorrect answers to the respective queries. We emphasize that this is not attributed to the operation of our algorithms but rather to the out-of-order trajectories. In fact even the centralized algorithm would be affected by the same problems in this case.
In the previous section we have discussed how our pro-posed distributed query processing algorithms work by uti-lizing locally computed lower and upper bound scores on the matching between a query Q and the respective trajec-tories. In this section we describe how these bounds are calculated. We start out by providing an overview of dis-tance measures that were propo sedinacentralizedsetting, where the querying node has access to the complete trajec-tory of some moving object. We then provide extensions for computing these distances in a distributed setting. In par-ticular, we will focus on a distributed version of the Longest Common Subsequence, which i s utilized in this work. denote two 2-dimensional trajectories with sizes l 1 and l respectively. The most straightforward way to compute the similarity between A and B is to use any of the L p -Norm distances, such as the Manhattan ( L 1 ), Euclidean ( L 2 Chebyshev ( L  X  ) . Although this family of distances can be calculated very efficiently, it is not flexible to out-of-phase matches and not tolerant to noisy data because the points are only matched at identical time positions.

The Dynamic Time Warping (DTW) [5] , solves some of the matching inefficiencies associated with the L p -Norm dis-tances by allowing local stretching of the sequences to opti-mize the matching. However its performance might deteri-orate in the presence of noisy data in which outliers distort the true distance between sequences.

The Longest Common Sub-Sequence (LCSS) similarity has been extensively used in many 1-dimensional sequence prob-lems such as string matching. The 2-dimensional adaptation of LCSS using the L  X  4 is defined as following: Definition Given integers  X  and , the Longest Common Sub-Sequence similarity LCSS  X , ( A, B ) between two sequences A and B is defined as: where the  X  and are user defined thresholds that allow flexible matching in the time and the space domain respec-tively. LCSS can deal more efficiently with outliers, because outliers are simply dropped from the matching and so large outliers do not skew the measure. Similar to DTW, LCSS can be computed by a dynamic programming algorithm with a time complexity of O (  X   X  ( l 1 + l 2 ))[9].

Even though LCSS offers many desirable properties, its time complexity of O (  X   X  ( l 1 + l 2 )) might constitute it in-efficient for large values of l 1 ,l 2 or  X  , so it is desirable to give a technique to upper bound the LCSS similarity. The idea of the technique proposed in [24] is to encapsulate the query trajectory Q within a bounding envelope and then find the intersection between the envelope and the trajecto-ries. For simplicity consider the 1-dimensional case where Q= ( q x :1 ,...,q x : l 1 ) denotes a query and A= ( a x :1 a trajectory. Suppose that we replicate each point Q i for  X  time instances before and after time i and that we also repli-cate each point Q i for space instances above and below Q (see Figure 6). The area contained in the union of all these points defines the Minimum Bounding Envelope (MBE) of the query trajectory Q. The notion of the bounding envelope can be trivially extended to more dimensions.

The LCSS similarity between the envelope of Q and a sequence A is defined as:
We could also use L 1 or L 2 for the recursion step Figure 6: To upper bound LCSS  X , ( A, Q ) ,weusethe
Note that the LCSS similarity of an envelope and a se-quence does not depend on and  X  . These have been incor-porated in the building of the envelope. It can be computed in O ( min ( l 1 ,l 2 )). For example, in Figure 6 the LCSS sim-ilarity between MBE Q and sequence A is 48 because this represents the total intersection length. This value repre-sents an upper bound on LCSS  X , ( A, Q ). For any two tra-jectories Q and A , LCSS  X , ( A, Q )  X  LCSS ( MBE Q ,A ).
The similarity measures presented in the previous section are only applicable to the centralized scenario, where all the segments of a target trajectory are stored locally at the QN . In this section we show how to compute the Longest Common Subsequence LCSS  X , ( Q, A i ) in a distributed set-ting. In particular we present techniques to upper bound ( UpperM ) and lower bound ( LowerM ) the LCSS match-ing. These bounds can then be exploited, using the UB-K and UBLB-K algorithms described in the previous section, in order to find the K most similar trajectories in a com-pletely distributed fashion.

Recall that in a distributed setting each trajectory A i ( i m ) is spatially fragmented over n cells. We define as A the segment of the trajectory A i ( i  X  m ) that lies inside cell c j ( j  X  n ). We note that A ij may not be continuous, however this does not present a problem since each point in the trajectory is uniquely identified. Therefore each local subsequence can still be matched over the query Q ,which is assumed to be available in its entirety to each cell.
The basic idea of our approach is to perform local com-putations of partial lower and upper bounds at each cell and then combine these partial results to give upper and lower bounds for LCSS  X , ( Q, A i )(  X  i  X  m ). This allows us to perform the computation in parallel and to minimize the amount of data transferred to QN .

Note that the only other alternatives are to either trans-fer all A ij (  X  i  X  m,  X  j  X  n )to QN (the Centralized solu-tion) or to perform the dynamic programming computation of LCSS  X , ( Q, A i )(  X  i  X  m ) in a distributed setting. The latter approach is lengthy and expensive, as it requires the communication of the execution state between neighboring cells for each pair ( Q, A i )(  X  i  X  m ).
 Algorithm 3 : DUB LCSS Algorithm Input: n distributed cells, m trajectories per cell (each de-noted as A ij ( i  X  m , j  X  n )), query trajectory Q . Output: DUB LCSS  X , ( MBE Q ,A i ),  X  i  X  m 1. Each cell c j ( j  X  n )uses LCSS ( MBE Q ,A ij )tocalcu-2. The upper bound DUB LCSS  X , ( MBE Q ,A i )( i  X  Figure 7: The local upper bound computations of the
Algorithm 3 presents our distributed upper bound algo-rithm on LCSS ( DUB LCSS ). Theideaistohaveeachcell c (  X  j  X  n ) locally match its local subsequences A ij (  X  m )to Q using the upper bounding method LCSS ( MBE Q ,A ij presented in section 5.1. Note that this is a simple and cheap operation since each trajectory point in the local sub-sequence A ij is associated with a timestamp. We then sim-ply perform a parallel addition of these individual results which yields an upper bound on the LCSS matching. Fig-ure 7 illustrates the operations of the algorithm. The cor-rectness of DUB LCSS is established by Theorem 3. Theorem 3. For any query trajectory Q and any dis-tributed trajectory A i the following holds: LCSS  X , ( Q, A i )  X  DUB LCSS ( MBE Q ,A i ).
 Proof: By construction, the aggregate similarity for a tra-jectory A i is computed by adding the local similarity compu-tation in each of the n cells: trajectory point (x,y) is in LCSS  X , ( Q, A i ), then this point must be within  X  and from the query Q . The trajectory points returned by LCSS ( MBE Q ,A ij ) are all the points in Algorithm 4 : DLB LCSS Algorithm Input: n distributed cells, m trajectories per cell (each de-noted as A ij ( i  X  m , j  X  n )), query trajectory Q . Output: DLB LCSS  X , ( Q, A i ),  X  i  X  m 1. For each trajectory A i ,cell c j ( j  X  n ) finds the time 2. Each cell c j ( j  X  n ) performs a local computation of 3. The lower bound DLB LCSS  X , ( Q, A i )(  X  i  X  m ), Figure 8: The local lower bound lb(Q,A) in the pro-A ij that are within  X  and from the query Q . It follows that P j =1 LCSS ( MBE Q ,A ij )  X  LCSS  X , ( Q, A i ) which reduces to LCSS  X , ( Q, A i )  X  DUB LCSS ( MBE Q ,A i )
Algorithm 4 presents our distributed lower bound algo-rithm on LCSS . The idea is again to perform n distributed computations with a local similarity function, and then per-form a parallel addition of these individual results. Our lower bound is computed by having each cell c j ( j  X  n ), to perform a local computation of LCSS  X , ( Q ij ,A ij )( m,  X  j  X  n ), without extending the warping window  X  out-side A ij . The correctness of DLB LCSS ( Q, A i )isestab-lished by Theorem 4. Figure 8 illustrates the computation of the local lower bound.
 Theorem 4. For any query trajectory Q and any dis-tributed trajectory A i the following holds: DLB LCSS ( Q, A i )  X  LCSS  X , ( Q, A i ).
 Proof: According to [9], a dynamic programming algorithm can be used to compute the LCSS similarity of two trajecto-ries by constructing a matching matrix. Consider Figure 9, where we illustrate a matching matrix for two trajectories Q and A. Suppose we set the parameter  X  as 2.5 and as 0.5, then the matching matrix M[i][j] is marked with X as local matching of Q[i] and A[j], and O as non-matching. Notice that the matching is only computed and considered within a  X  -diagonal zone (the gray blocks) as we constraint the matching window size. The common subsequences of Q and A can be found by counting matches in the matrix. Figure 9: Lower Bounding LCSS: In LCSS, the match-
The algorithm will start from the right bottom block of the matrix M [ ][ ]( is the length of the two trajectories), jump to the left-up neighbor when the current block is match-ing, and jump to the left or the up neighbor when the cur-rent block is not matching, until we reach the left-top block M [1][1]. The LCSS(Q, A) is then the largest number of matching blocks (dark-gray blocks) we get. Algorithm 4 di-vides the query Q into non-overlapping segments Q ij in the same manner as A i is divided into A ij . In the matching ma-trix, these segments can be represented by the sub-matrices in the diagonal line (as the sub-matrices in bold frame in Figure 9). As shown in Figure 9, any matching in the sub-matrices is also a valid matching in the global matrix. Since the sub-matrices do not overlap with each other, the LCSS computation of the l  X  l matrix can be lower bounded by the summation of LCSSs of non-overlapping sub-matrices at diagonal line.
 Therefore DLB LCSS ( Q, A i )  X  LCSS  X , ( Q, A i )
In this section we present an extensive experimental evalu-ation of the three similarity search methods: (i) Centralized , (ii) UB-K and (iii) UBLB-K . We have implemented a trace driven simulator in GNU C++ which takes as an input a spatio-temporal dataset and then splits it into n equi-width cells. Our dataset and methodology are described below. Dataset: For our evaluation we use the OLDENBURG dataset, which includes 25,000 trajectories generated over the Oldenburg street map, using the Network-based Gen-erator of Moving Objects [6]. The spatial universe of this dataset is 23,500 x 23,500 points and each trajectory has a length of 500 temporal points. The dataset has an overall size of 200MB (each spatio-temporal record in this paper is 16 bytes). Our queries for the above dataset are syn-thetically derived with the addition of interpolated peaks of Gaussian noise. This created variations in the pattern of these trajectories. Our results are averages over 10 queries. Methodology: Our performance measures are: (i) Bytes , (ii) Time and (iii) Messages required for finding the K most similar trajectories to Q . Our communication protocol is structured in the following way: Each message is associated with a 40 byte header. This is augmented with an additional 6 byte application layer header that includes: (i) The Cell identifier (1 byte), (ii) the Message size (4 bytes) and the depth of a cell from the querying node QN (1 byte). We measure the total communication cost Bytes as a summa-tion of message cost (40 bytes header cost per message) and the data cost (i.e. the cost of communicating DATA and METADATA between QN and all the cells). In order to allow reproducible and comparable results we perform our experiments on a single host using a simulated dedicated bandwidth of 128KBps for the edges between QN and the cells. Our edges have a random latency between 0-100ms which is typical for Internet environments. Since the cells can transmit their results back to QN in parallel, we con-sider only the longest time of each round.
Figure 10 illustrates the three performance parameters as a function of the cell numbers for the three alternatives (  X  X entralized X ,  X  X B-K X  and  X  X BLB-K X  )usingtheOLDEN-BURG dataset. In all cases UB-K and UBLB-K return the same result with Centralized . However, UB-K and UBLB-K require two to three orders o f magnitudes less bytes and are two orders of magnitudes faster than Centralized . We also noticed that UB-K performs in less iterations than UBLB-K . Specifically, we found that UB-K required 1-3 it-erations while UBLB-K required 2-6 iterations. This was attributed to the conservative parameter  X  (studied in Sec-tion 6.2).
 For the Messages graph, we observe that UB-K and UBLB-K require more messages than Centralized .Thisisbecause the UB-K and UBLB-K algorithms include multiple rounds of METADATA and partial DATA communications between QN and each cell, while the centralized method just per-forms one round of full DATA transmission. It is impor-tant to notice that these METADATA messages are small in size and therefore are cheaper to be transferred, in terms of bytes, than transferring DATA .
In our UB-K and UBLB-K algorithms,  X  is the number of top-K METADATA to fetch in each iteration. In this ex-perimental series we study the impact of the parameter  X  to the minimization of the bandwidth cost between the query node and cells. As shown in Figure 11a, when  X  increases, the number of iterations in UB-K and UBLB-K decreases.
This is due to the fact that a larger step length  X  , yields more candidates in each round and therefore the iteration stop condition is satisfied much earlier. A consequence of increasing  X  is also the fact that the message cost is signif-icantly reduced (although this is not directly shown in the figures). This is explained by the fact that a small  X  yields many small-sized packet transmissions from the cells to QN, while a larger  X  yields a few larger-sized packet transmis-sions.

Thedownsideofincreasing  X  , is that the Bytes parameter (data and message cost), now increases for both UB-K and UBLB-K as shown in figures 11b and 11c respectively. This is attributed to the fact that a larger  X  , will yield more METADATA and DAT A candidate transfers towards QN . Figure 11 shows that, for a small K (e.g.  X  50), the Bytes parameter remains low with  X  set to 50%K  X  100%K. If K is large (e.g.  X  150), the parameter  X  should be kept small as the data cost is so dominant that the message cost is negligible.
This paper introduces and formalizes the distributed tra-jectory similarity search problem. We propose two novel distributed query processing algorithms that provide an ef-ficient and exact solution to this problem. Our algorithms exploit a partial lower and upper bounds on the LCSS sim-ilarity, which is computed locally by each node. Compre-hensive experiments with realistic data shows that UB-K and UBLB-K are orders of magnitudes more efficient in terms of network traffic and delay. Our approach can eas-ily be extended to lower bound the DTW distance as well. Since DTW is a distance, our distributed retrieval tech-niques would have to find the K trajectories with the small-est distances to the query. To do that we can modify our UB-K algorithm to work with lower bounds instead. We would like to thank Michalis Vlachos (IBM TJ Watson) for his help in developing the spatiotemporal similarity mea-sures. We would also like to thank Eamonn Keogh (UCR) for the interesting discussions and ideas. This work was supported by grants from NSF ITR #0220148, #0330481. [1] Al-Taha K. , Snodgrass R., and Soo M., [2] Babcock B. and Olston C.,  X  X istributed Top-K [3] Balke W.-T., Nejdl W., Siberski W., Thaden U., [4] Basch J., Guibas L. and Hershberger J.,  X  X ata [5] Berndt D., Clifford J.,  X  X sing Dynamic Time [6] Brinkhoff T.,  X  X  Framework for Generating [7] Bruno N., Gravano L. and Marian A.,  X  X valuating [8] Cao P. and Wang Z.,  X  X fficient Top-K Query [9] Das G., Gunopulos D., Mannila H.,  X  X inding Similar [10] Fagin R.,  X  X ombining Fuzzy Information from [11] Fagin R., Lotem A. and Naor M.,  X  X ptimal [12] Hadjieleftheriou M., Kollios G., Bakalov P., Tsotras [13] Kollios G., Gunopulos D., Tsotras V.J.,  X  X n [14] Yu H., Li H., Wu P., Agrawal D., Abbadi A.E., [15] Kollios G., Gunopulos D., Tsotras V.J., Delis A., [16] Madden S.R., Franklin M.J., Hellerstein J.M., Hong [17] Bruno N., Gravano L. and Marian A.,  X  X valuating [18] Mokbel M., Xiong X. and Aref W.G.,  X  X INA: [19] Papadias D., Mamoulis N., Delis V.,  X  X pproximate [20] Saltenis S., Jensen C.S.,  X  X ndexing of Moving objects [21] Saltenis S., Jensen C.S., Leutenegger S.T., Lopez [22] Tao Y., Papadias D.,  X  X he MV3R-Tree: A [23] Tao Y., Sun J. and Papadias D.,  X  X nalysis of [24] Vlachos M., Hadjieleftheriou M., Gunopulos D., [25] Xiong X., Mokbel M.F., Aref W.G.,  X  X EA-CNN: [26] Xia T., Zhang D., Kanoulas E., Du Y.,  X  X n [27] Xiong L. , Chitti S., Liu L.,  X  X op-k Queries across [28] Zeinalipour-Yazti D., Vagena Z., Gunopulos D.,
