 With the rapid development of high-performance processors and the diffusion of high-speed networks, distributed com puting environments, where performance, reliability, and availability are all achieved, are gaining much attention. In par-ticular, tailored networks built on top of other (existing) networks, called overlay networks , are emerging as a practical way to construct application-oriented net-works on user demand. Nodes (or peers) in an overlay are virtually (or logically) connected by links provided by the underlying network. Peer-to-peer (P2P) net-works are also a kind of overlay network, as they are constructed on top of the Internet.

P2P networks can be categorized roughly into two types, hybrid and pure, according to the way peers belonging to the network are organized. A hybrid P2P network has a central server, which is responsible for managing information about peers and shared resources. In suc h systems, the central server could be both a bottle neck and single point of failure.

To cope with this problem, pure P2P systems are emerging. In contrast with hybrid P2P systems, peers in a pure P2P sy stem act equally; hence, there is no central server or central router. Pure P2P systems can further be categorized as unstructured and structured . In the unstructured type, a query is forwarded to as many peers as possible. The network traffi c caused by flooding grows as the number of peers becomes large, which is a major disadvantage of unstructured systems.
Structured P2P networks, on the other hand, try to overcome such problems using a Distributed Hash Table (DHT), which is a mechanism residing in data (or a peer) in the network. In a typical DHT, individual hosts or data are mapped to a key by a hash function, and then located at a point in a keyspace. The keyspace is divided into several subspaces, and each host is responsible for a specific portion of the network. In addition, a global protocol locates the peer responsible for a given key. In this way, a search is performed, without flooding, by forwarding the request in steps using the protocol.
 For several years, demands have grown to share domain-specific data using P2P networks. In such networks, Extensible Markup Language (XML) [1] has usually been used as a de facto standard for data representation and exchange. For this reason, an efficient means for the storage and retrieval of XML data in structured P2P networks is impor tant. However, managing XML data in a DHT is not a trivial task: XML data are modeled as trees, whereas DHTs assume complete matching between a given search key and data, given the nature of hash functions. That means flexible search of XML data using DHTs is a challenging task [2]. Several papers have addressed this problem [3,4].

This paper proposes a novel scheme for managing XML data using DHT. Key features follow: 1. We decompose XML data based on textual values, such as text and attribute 2. To allow internal nodes that are not stored in a C-DHT to be queried,
We finally confirm the effectiveness of the proposed scheme with a series of experiments. Experimental results show that our proposed scheme performs well compared to existing methods. 2.1 Distributed Hash Table (DHT) The Distributed Hash Table (DHT) is a c lass of decentralized distributed sys-tems. In a DHT, peers and objects are ma pped to sets of keys in a space, called  X  X eyspace. X  The mapping is usually done by a hash function, such as SHA-1. The keyspace is partitioned into several subs paces (keyspace partition), according to the scheme the DHT follows. Each participating peer in the network is responsi-ble for maintaining the data in the assigned partition. When a request is issued, the message is forwarded from peer to peer until it reaches the peer that main-tains the desired object. There are sev eral variations of DHT according to the way keyspace is organized and how the routing table is maintained. Well-known implementations are Chord [6], Pastry [7], Tapestry [8], and CAN [9].
This work adopts Chord [6] as the underlying DHT. In Chord, a circular form of keyspace ( X  X den tifier space X ) with 2 N keys is assumed. Here, N is called  X  X cale factor. X  A peer (data) is mapped to the identifier circle by a hash function. Supposing a peer is of the key k , it maintains the following information: 1) neighboring peers X  information, predecessor ( k )and successor ( k ), 2) the peer is responsible for the data within the range of [ predecessor ( k )+1 ,k ]. and 3) a routing table ( X  X inger table X ) with N entries, each of which is a pointer to the 0 ,...,N  X  1). From the configuration, the average number of hops to reach to the desired peer is O ( log 2 ) N . 2.2 XML, XPath, and Path-Prefix Tree XML [1] is a metalanguage for marking up semistructured data. XML data includes a properly nested tag structure, making it possible to extract a tree structure from XML data using syntax analysis. An XML tree is therefore mod-eled as a tree of T =( V, E, r )where V denotes the set of nodes consisting of root, element, text, and attribute, E denotes the set of edges, and r  X  V represents the root of the tree.
 To locate an arbitrary node (or subtree) in XML data, XPath [5] is used. An XPath expression consists of a number of location steps separated by  X / X , and a location step comprising an axis , node test , and optional predicates .Inthis paper, we employ a subset of XPath called core XPath, which allows child (/), descendant axes (//), and predicates ([]).

When managing XML data, path expressions play an important role, and we attempt to introduce a data structure, path-prefix tree ,withwhichwecan compactly represent the set of possible path expressions contained in an XML data. To introduce the path-prefix tree, let us first define the absolute path expression of an XML node.
 Definition 1 (Absolute path expression). For a given XML tree T , the ab-solute path expression of a node v is denoted as PE ( v )= /t 1 /t 2 /.../t n ,where t ,...,t n are the node (element) names from the root to v ,and n is the depth of v . The following defines the path-prefix tree.
 Definition 2 (Path-prefix tree). The path-prefix tree of a given set of XML data is a tree T p containing all absolute path expressions of the XML data. Note that a path-prefix tree of XML data is essentially the same as the Strong DataGuide [10]. We therefore do not go into detail on how to construct it. There is a simple one-path algorithm to construct the Strong DataGuide and we can borrow the idea to construct the path-prefix tree. As discussed in Section 1, there are two technical challenges in the problem of XMLdatamanagementusingaDHT:1)HowtomapXMLdatatoaDHTfor subsequent query processing; and 2) Ho w to process a given query and retrieve the result as a set of arbitrary XML fragments.

When storing XML data in a DHT, a straightforward approach is to use a mapping scheme for mapping XML data to relational tables, and to store the resulting relational table in a DHT. Having constructed a DHT, given an XML query, it is decomposed and distribut ed around the peers in the DHT. [4] takes a similar strategy. It seems such approaches do not scale easily, i.e., even for a simple path query without predicates, a structural join [11] for each path step is needed, which is costly to process.

Another possibility is to shred the XML data being stored, and store the pieces in DHT with their path expression s as the keys [4]. This approach is quite effective if the XML schema is fixed, an d there are a limited number of query patterns, by which we can decide where to partition the XML data. However, the disadvantage is that it lacks flexibility to cope with queries that include descendant axes (//), because there is no way to obtain appropriate search keys. To cope with this problem, we propose a novel scheme for storing and querying XML data using DHTs. We map every leaf node, including text nodes, attribute nodes, and empty elements, to a DHT. In other words, we do not map internal nodes, because necessary information is all stored in the textual nodes and, by contrast, internal (element) nodes are acting as containers. By omitting those nodes, we can significantly reduce the number of keys stored in a DHT. Beyond that, to provide an entry point for querying (omitted) internal nodes, we con-struct a path-prefix tree and store it in another DHT. A query is processed as collaborations of the two DHTs. 3.1 Content-DHT (C-DHT) In the proposed scheme, we use two kinds of DHTs. One is Content-DHT (C-DHT) for managing the contents of XML data. As discussed above, given XML data, we basically extract all leaf nodes, including text nodes, attribute nodes, or empty elements, and put them into a DHT with the following information with its element (or attribute) name as the key: where peerID is the key of the peer that keeps the original XML data, docID is the document ID (or filename), pathexp is the absolute path expression of the node, label is the node label that represents structural information of the node, and value is the value of the node.

For the node label, there are many candidate schemes for encod-ing structural information of XML trees [12]. Small examples are pre-order and postorder pair [13], range labeling [14], and the Dewey or-der [15]. In this work, we attempt to use the Dewey order for several reasons. One is that we can repre-sent detailed structural relationships, not only ancestor-descendant rela-tionship, but also parent-child and or-der relationships among sibling nodes. This is important to ensure that we can reconstruct an XML fragment from only its leaf nodes, even if we do not have all nodes of an XML subtree. Another fea ture is that we can replace it with an-other insert-friendly labeling scheme like ORDPATHs [16] to cope with updates in XML data.

Figure 1 depicts a storage example of C-DHT. An XML tree is constructed from XML data and node labels are assigned. Of the nodes, only three text nodes are extracted and put in a DHT. Notice that in the table below, we intend to show the entire list of indexes in the DHT, even if it is not distributed in the figure. In a working system, each row is distributed to peers according to the key value.

An important point here is that by omitting internal nodes, we can signif-icantly reduce the number of entries to a DHT. We do not show the detailed statistics due to the page limitation, but we found that 40% to 50% of entries can be omitted for real XML data, such as DBLP Bibliography, Gene Ontology, and INEX. This gives a significant impact on both storage and search performance on the peers.
 Reconstructing XML fragments from leaf nodes. As mentioned, we can reconstruct XML data from a list of lea f nodes even if we do not have a complete list of nodes that includes internal nodes . This becomes possible because we have the absolute path expression and the Dewey label for each leaf node.
Let us look at Figure 1. In the figure are three leaf nodes, whose absolute path expressions and Dewey labels are (/mail/text, 1.1.1), (/mail/text/keyword, 1.1.2.1), (/mail/text/emph, 1.1.3.1). All the internal nodes can be extracted by taking i -th prefixes of the path expressions and the Dewey labels, i.e., by taking the first prefix, we get (/mail, 1), and (/mail/text, 1.1) by the second prefix, and so on. In this way, we can reconstr uctanXMLfragmentfromalistofleaf nodes.
 Query processing by C-DHT. Suppose p is an core XPath query of the element (or attribute) name, and optional p i is a predicate. For simplicity, let us begin with a simple path expression that does not contain any predicates. How to process queries including predicates will be discussed later. Query processing proceeds as follows: 1. First extract the element (or attribute) name at the bottom ( e n ), and look 2. Then, for each candidate result with key e n , check if the absolute path expres-
For example, queries  X /mail/text/emph X ,  X //emph X , and  X /mail//emph X  can be processed in the same way. Specifically, once candidate results are found, we translate the queries  X //emph X  and  X /mail//emph X  to regular expressions  X /*/emph X  and  X /mail/*/emph X  for subsequent string match with the absolute path expressions in the candidates. In addition, queries like  X //abc/emph X  will be omitted at the string match phase.

In this way, we can flexibly answer XPath queries, but we cannot query inter-nal nodes because there is no entry point in a C-DHT for them. For this reason, we need an additional index called Structure-DHT (S-DHT). 3.2 Structure-DHT (S-DHT) To provide a clue to querying internal nodes, we additionally maintain structural information about stored XML data. For that purpose, we use the path-prefix tree mentioned above. In practice, we can use it as a structural summary of a set of XML data because it captures all possible path expressions appearing in the XML data.

Given a path-prefix tree, we map every node to S-DHT with the element (or attribute) name as its key. The value is a tuple of the form: where pathexp represents the absolute path expression of the node in the path-prefix tree, child is a set of child nodes, and count shows the number of corre-sponding XML nodes in the stored XML data.

Figure 2 illustrates an example of S-DHT. Again, this table attempts to show the contents of a DHT, and each tuple is distributed to a peer with respect to the key value in a real system. From the figure, we see that the structure of the path-prefix tree is completely captured in the mapped table except for ordinal information among sibling nodes. Specifically, with the child attribute, we can determine the possible occurrences of ch ild elements. Notice that  X #TEXT X  is a special symbol representing text node. If the node is an empty element, the child is  X #EMPTY X . Such information structure is similar to the content model of XML schema languages such as DTD. The count attribute maintains statistical information that can be used in query planning.
 Query processing using S-DHT combined with C-DHT. Query process-ing is simple. For a given query p = /e 1 /.../e n , we attempt to look for all leaf nodes contained in subtrees that are rooted by p by referring to C-DHT and S-DHT concurrently. Specifically, we first look up C-DHT with search key e n and find tuples that have path expressions conforming to p . We then put them in the result set. In the next step, we look up S-DHT with search key e n looking for an internal node that matches the query p . If we find entries that match p , we rewrite the query by concatenating p and the child element X  X  name, and continue until the complete list of leaf nodes is obtained.

Following is the algorithm Retrieve that processes a given core XPath query using C-DHT and S-DHT. Suppose we can refer to the a attribute of t tuple by t.a in the following discussion, e.g., t.pathexp denotes the path expression of t tuple.
 Processing branching queries. We have discussed simple (non-branching) queries that do not contain predicates. We can deal with branching cases as an ex-tension of the simple path expression case in that two or more simple path expres-sions are processed. Suppose we are given the following query /mail/text [ emph =  X  A  X  X . By parsing the query, we can extract all simple path expressions contained in the query, i.e., /mail/text and /mail/text/emph .Wethencall Retrieve for each that yields several lists of leaf nodes. For each list, we extract the root of each subtree by computing the common prefix of both the absolute path expres-sion and the Dewey label. Finally, we perform structural join [11] on them to filter out unnecessary candidates. 3.3 Discussions Load balancing. In the proposed scheme, the variation of keys in the DHTs is obviously bounded by the number of elements (attributes), which may cause an unbalanced load among peers. This means that even if there are 10,000 peers, Algorithm 1. Retrieve( p ) approximately only 10 peers are under load if we have only 10 kinds of ele-ments. From one perspective, this is an advantage because related information is clustered, which achieves efficient qu ery processing. However, it may cause a problem if there are extremely large entries.

To cope with large entries, w e might introduce parameter M ,whichisthe maximum number of entries for each key (element or attribute name). If the number is too high, the peer tries to find another peer to share the load. When processing a query, the peer originally responsible for the key acts as the mediator to collect necessary information from the peers sharing the load, and to respond to the request. This section describes an im plementation of the proposed scheme. Our prototype system is implemented using the Overlay Weaver [17], which is a toolkit for constructing P2P networks. It provides a wide range of functionalities, which are necessary for implementing P2P networks; it enables us to simulate a large-scale virtual P2P network as well as real P2P networks.
 Since our scheme is based on the basic functionalities of DHTs, the following APIs are needed in the implementation: put(key, value, ttl )] Put a value with key . ttl (time to live) specifies the get(key) Getthesetofvalueswith key . remove(key, [value )] Remove all the values with key from the DHT. If op-
The prototype system comprises two main modules, publish and search .The publish module, taking XML data as the input, parses the data to extract leaf nodes and also to construct the path-prefix tree. The extracted leaf nodes are put in the C-DHT. The constructed path-prefix tree is then traversed by putting each node to the S-DHT. If an entry with the same key and the same path expression is already registered, the count value is incremented by one. The search module basically does the same thing as described in Section 3. Experimental setup. We have conducted a series of experiments to confirm effectiveness of the proposed scheme. The datasets contain two kinds of synthetic XML data generated by XMark [18] and XBench [19], and the sizes are 10MB and 50MB.
 For benchmark queries, we used the fi ve XPath queries given in Table 1. Queries 1 and 2 are simple path expressions, 3 and 4 contain predicates, and 5 contains descendant axes.

For the baseline, which is to be compared with the proposed scheme, we have also implemented XP2P [3] using Overl ay Weaver, and compare the number of messages needed to process each query by changing the number of peers from 200 to 600.

All the experiments are made using a PC with 4-way Intel Xeon 3GHz proces-sor and 6GB Memory running Linux kernel 2.6.9-24. The version of Java Runtime Environment is 1.5.0 07.
 Experimental results. In Figures 3 a) to e), the horizontal and vertical axes show the number of peers and the number of messages, respectively. Viewing the figures, we observe that 1) the number of messages grows linearly as the number of peers grows; 2) our (proposed) scheme outperforms XP2P in that fewer messages are necessary; 3) it seems that the performance of our scheme is more stable, whereas XP2P X  X  performance changes depending on queries, e.g., more messages are required if the query expression is long, because XP2P must navigate a query expression from the head to tail by looking up a DHT; and 4) even if a query contains predicates ([]) or descendant axes (//), our scheme can process it efficiently.

Figure 3 f) shows load distribution with 50MB datasets. As the figure re-veals, from the nature of the scheme, the load distribution in our system is not balanced, whereas the load is balanced in XP2P. This behavior is consid-ered beneficial in that relat ed data are clustered, which results in better query performance. However, this also sugge sts the need to cope with extreme cases where most of the load is assigned to some (a limited number of) peers. We might introduce the technique discussed in Section 3.3. A number of papers have addressed the problem of XML data management in P2P networks [3,4,20]. XP2P [3] and XPeer [4] are based on DHT, while yet another XPeer [20] is based on hybrid P2P system. In XP2P [3], XML data is fragmented and stored in a DHT with its path expression. By contrast, XPeer [4] stores XML data using node-based decomposition. These other papers differ from our work in that they do not use DHT.

From a different perspective, many effor ts attempt to deal with various kinds of data. [21] tries to deal with RDF (Resource Description Framework) us-ing DHT [22]. RDF data is decomposed to a set of triples, which is the non-decomposable unit of RDF data, and then stored in DHT. [23,24] deal with re-lational data, trying to construct relational storage that can perform relational query processing in a P2P environment. In this paper, we have proposed a novel scheme for storing and querying XML data using DHT. We introduced two kinds of DHTs: Content-DHT (C-DHT) and Structure-DHT (S-DHT) for maintaining both the content and structure of XML data. Using the DHTs, we decompose XML data based on textual values such as text and attribute nodes (and leaf nodes for empty elements) and store them in the C-DHT. Additionally, to maintain structural information of the XML data, we construct a path-prefix tree and map it to the S-DHT. Query processing is achieved using the DHTs concurrently. Experimental results show that the proposed scheme performs well, ev en for queries that contain predicates or descendant axes (//). In the future, we will extend the current work to cope with updates and more complex queries like XQuery.
 Acknowledgements. This research is partly supported by the Grant-in-Aid for Scientific Research (#15300029 and #17700110) from Japan Society for the Promotion of Science (JSPS), Japan, and Grant-in Aid from Core Research for Evolutinal Science and Technology (CREST), Japan.

