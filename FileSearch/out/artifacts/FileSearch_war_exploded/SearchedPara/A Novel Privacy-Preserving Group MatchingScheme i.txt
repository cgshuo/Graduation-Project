 Social networks are changing our lifestyle and becoming an inseparable part of our daily lives. For example, Twitter [1] which is a well-known micro-blogging site enables users to share real-time information. The group service has been frequently used in social networks and allowed strangers with similar profiles to construct new relationships and share information. Generally, groups are con-sisted of users with common attributes, such as educational backgrounds and illness symptoms. In many situations, a group is only described by its classifi-cation, several keywords and a short introduction. These features may not be enough for users to decide which group is the most appropriate to join, especially when a few groups have similar keywords and introductions. In order to choose a suitable group to join, a stranger outside of the groups needs to collect profile in-formation about each group member. In addition, attributes of users sometimes contain sensitive and private information, thus they don X  X  want to disclose their profiles or exact matching results to untrusted users or any third party. Such a problem is referred to as group matching by Wang et al. in [2]. However, there are two main problems in existing works for group matching problem.

The first one is that only the stranger obtains the matching results while each group member learns nothing. In most practical applications, when a stranger who is an outsider of an existing group applies to join it, he just needs to simply send the reasons for application to the manager of this group. Since the reasons submitted by stranger may be incomplete or fake, it is inconvenient for the group manager to determine whether to agree to the application. In addition, sometimes other group members don X  X  fully trust the group manager and they want to make their own decisions. In order to enable all group members to participate in the decision process and ma ke a better decision jointly, each group member needs to learn more inform ation about stranger X  X  profile.

Another problem is that existing systems rely mostly on exponential opera-tions and have high computation cost, so they are not lightweight and practical enough to be used in mobile social netw orks. The proliferation of networked portable devices such as smart phones and PADs, enables people to use social networking services anytime and anywhe re. However, networked portable devices have limited computational abilities, and we have to consider computation cost in mobile social networks.
 Our Contribution. In this paper, we focus on the above problems and propose a novel scheme to realize group matching by utilizing private set intersection (PSI) [3] and a semi-trusted third party. Our contributions can be summarized as follows:  X  Our scheme helps both stranger and each group member to make better de- X  We limit the risk of privacy exposure and only necessary information of each  X  We utilize a semi-trusted third party to improve the computation efficiency Organization. The remainder of this paper is organized as follows. In Section 2, we discuss the related works. In Section 3, we present the system model and design goals. Section 4 describes the details of our scheme. We give the thorough security proof in Section 5 and analyze the efficiency of our scheme by comparison with an existing work in Section 6. Finally, we briefly conclude this paper in Section 7. Existing works related to our proposed scheme are mainly in the area of private set intersection (PSI) fir st introduced by Freedman et al. in [3]. Freedman et al. base their protocol on oblivious polynomial evaluation and the protocol is single-output, i.e., during the process, only one party learns the set intersection while the other one doesn X  X  obtain any results. There have been other single-output PSI protocols. Based on oblivious polynomial evaluation, Dachman-Soled et al. [4] present an efficient two-party prot ocol which is robust in the presence of malicious adversaries. In [5], Hazay and Lindell claim a different protocol based on oblivious pseudo random functions and the proposed protocol is improved in complexity by Jarecki and Liu [6]. Cristofaro and Tsudik [7] propose protocols for plain and authorized private set intersection (PSI and APSI) and they base their protocols on blind RSA signatures. In [8], Agrawal et al. adopt another approach based on commutative encryptio n to realize private set intersection, which is extended by Vaidya et al. [9] to multiparty setting.

Above single-output protocols only allow one user to obtain the results, while in most situations, both of the two parties are desirable to learn the intersection of their attribute sets. Several mutual PSI protocols have been proposed. Kissner and Song exploit the first mutual PSI protocol in [10]. The proposed protocol builds upon oblivious polynomial evaluation and enables several set operations such as union, intersection, and element reduction operations. Camenisch and Zaverucha [11] have applied certified sets to private set intersection problem and ensured that all inputs are valid and bound to each protocol participant by utilizing a trusted third party. In [12], Kim et al. claim a more efficient mutual PSI scheme which is the first system with linear computational complexity in semi-honest model. Recent work in [13], Dong et al. present the first fair mutual PSI protocol by utilizing an offline semi-trusted third party arbiter which can resolve disputes blindly without obtaining any sensitive information from users. However, these mutual pro tocols can X  X  be utilized in group matching problem directly. Users from the same group are familiar, and a group member may exchange the intersection between him a nd stranger with other group members to learn more about the stranger X  X  private attributes. In addition, above protocols reveal the exact matching information which is undesirable in our work.
Based on private set intersection (PSI), there have been several practical sys-tems designed for special purposes in social networks. The E-SmallTalker scheme [14] exploited by Yang et al. adopts iterative bloom filter (IBF) to denote at-tribute sets and enables a user to matc h people in physical proximity. Lu et al. [15] present a secure symptoms matching protocol by utilizing a trusted author-ity. The FindU scheme [16] proposed by Li et al. allows a user to find the one who best matches with him in mobile social networks. The proposed protocol is based on the FNP scheme [3], but they utilize secret sharing to calculate poly-nomial evaluation without using additi ve homomorphic encry ption. Recently in [2], Wang et al. introduce Gmatch that allows a user to find the most appropri-ate group to join without disclosing each user X  X  private information and exact matching results. In the Gmatch system, only the stranger outside of the groups obtains the matching results while each group member learns nothing and the proposed scheme relies mostly on exponentiation operations. 3.1 System Model Our system is a mobile social network consisting of a stranger S , a group P and a semi-trusted third party C , and each user processes a networked portable device such as smart phones and PADs (as illustrated in Fig. 1). The stranger S , who launches the matching procedure, is an outsider of group P and has n attributes in his profile which is denoted as A s = { a s, 1 ,...,a s,n } . The group P has d group members P 1 ,...,P d and P i has m attributes in his profile which is denoted as A i = { a i, 1 ,...,a i,m } . For simplicity, we assume each group member has the same size of attribute set, i.e., |A i | = m, 1  X  i  X  d . All attributes of every user X  X  profile need to be kept privat e, and they are stored in local portable devices by each user. The se mi-trusted third party C is a computation center with high computational ability to help users complete the matching process, but it doesn X  X  access and collect each user X  X  a ttributes.
During the matching procedure, stranger S wants to collect the intersection set between him and each group member in order to decide whether group P is suitable and appropriate to join. When S applies to join P ,eachgroupmember in P wishes to learn the size of intersection set between him and stranger S to determine whether to agree to S  X  X  application. In this paper, we cite the definition of matched attribute and matching degree used in [2]. If an attribute in a group member X  X  attribute set is also in stranger S  X  X  attribute set, it is called a matched attribute. Otherwise, it is an unmatched attribute. The total number of group members, who has the attribute equal to the attribute a s,j in stranger S  X  X  profile, is described as the matching degree D j of a s,j . The matching result learnt by stranger S can be denoted by the matching degree between S and P , which is described as D ( P )= { D 1 ,...,D n } . 3.2 Adversary Model In this paper, we only consider attacks from insiders who are participators of the matching process. We assume all participators including stranger S ,group members P 1 ,...,P d andthethirdparty C are honest-but-curious (HBC). That means all parties will honestly follow the scheme, but may try to obtain more in-formation than allowed. We will prove our protocol X  X  security under HBC model. We also consider several certain active attacks and analyze how the proposed scheme is secure against them. In addition, we assume that users from the same group are familiar and they may exchange information to learn more about stranger X  X  private profile, while stranger S or any group member can X  X  collude with the semi-trusted third party C . 3.3 Design Goals Security Goals Definition 1 (Security Goal 1 (SG-1)): When the scheme ends, stranger S only learns the matching degree D ( P )= { D 1 ,...,D n } from group P without knowing any unmatched attribute of group members and the exact matching information, i.e., each result X  X  corresponding group member and whether two results are from the same user.
 Definition 2 (Security Goal 2 (SG-2)): If stranger S doesn X  X  apply to join the group P ,eachgroupmemberin P will learn nothing about S  X  X  attributes, in-cluding the intersection set between them and the size of it. If S applies to join, each group member will only learn the si ze of the intersection set between him and S without knowing what the exact matching attributes are.
 Definition 3 (Security Goal 3 (SG-3)): In any phase of our scheme, the semi-trusted third party C can X  X  learn more than what can be derived from the values sent to him, his outputs and their corresponding group members.
 Usability and Efficiency. For group matching in mobile social networks, it is better to require as few human interactions as possible. In this paper, stranger S only needs to determine which group is the most suitable and whether to join it, while group members in P need to decide whether to accede to S  X  X  application. In addition, networked portable devices have limited computational abilities, and our scheme should be lightweight and efficient enough in computation to be used in mobile social networks. In this section, we propose a novel scheme designed for group matching in social networks. The proposed scheme is based on the FNP protocol [3] and we take advantage of a semi-trusted third party C to help compute the polynomial eval-uations without using additive homomorphic encryption. Our scheme consists of four phases: Setup , Computation , Matching and Application .The Application phase is only executed when stranger S applies to join the group P . We assume that each party has a public/private key pair for secure communication and the encryption algorithms are denoted as Enc c ,Enc s ,Enc 1 ,...,Enc d .Atfirst,all attributes in each user X  X  profile are encoded in Z p . Details of each phase are listed as follows.
 Setup. Stranger S first constructs a n-degree polynomial f ( x ), whose n roots are all in his set of attributes and all his attributes are f ( x ) X  X  roots: After generating the polynomial f ( x ), stranger S generates { r i,j } 1  X  j  X  m and {  X  member P i . crypting them with the private key, group member P i generates { r i,j } 1  X  j  X  m Fig. 2).
 Computation. After decrypting the received values with his own private key, for each attribute a i,j in P i  X  X  profile. C first calculates the intermediate result and encrypts it with stranger S  X  X  public key. Then C packages the encrypted in random order.
 Matching. Upon receiving the packages fro m the semi-trusted third party C , key and computes Because the value f ( a i,j ) is randomized by random numbers r i,j and r i,j gen-erated by S and P i respectively in Setup phase, stranger S will get an at-tribute in his profile or a random number from the result F i,j .Ifvalue F i,j is equal to one attribute a s,k in S  X  X  profile, a i,j represents a matched attribute which equals a s,k .Otherwise, a i,j is an unmatched attribute. Obviously, if a i,j is a matched attribute, it is a root of polynomial f ( x ), i.e., f ( a i,j )=0.Then F
Since stranger S and group member P i jointly randomize the value  X  0 by generating r i,j and r i,j respectively, and the results are sent by third party C in random order, S won X  X  learn F i,j  X  X  corresponding group member and whether the semi-trusted third party C can calculate the correct intermediate results without learning more than what can be derived from the values sent to him, his outputs and their corresponding group members. In our scheme, the value Enc s ( r i,j r i,j  X  0 + a i,j ) can X  X  be sent to stranger S by P i directly, otherwise S won X  X  know its corresponding intermediate result.

After computing all results { F i,j } 1  X  i  X  d, 1  X  j  X  m and comparing them with his own attributes, S learns each attribute a s,k  X  X  matching degree D k and decides whether to join group P . If stranger S determines to join it, the Application phase will be executed. Otherwise, the matching procedure is done.
 Application. Stranger S first generates {  X  i,j } 1  X  j  X  m randomly from Z p for each group member P i . Then he calculates { r i,j  X  0  X   X  i,j } 1  X  j  X  m and sends { member P i sends { Enc c ( r i,j ) } 1  X  j  X  m to C .

Upon receiving these values and decrypting them, third party C computes and encrypts it with group member P i  X  X  public key. Then C packages the interme-diate result Enc i ( z i,j ) and its corresponding Enc i (  X  i,j ), and sends the packages { Fig. 3).

Group member P ( i ) decrypts the received values with his private key and verifies Because the values f ( a i,j ) is randomized by random number r i,j generated by S in Setup phase, P ( i ) will get zero or a random number from the result F i,j .Ifthe equation is valid, then a i,j is a matched attribute. Otherwise it X  X  an unmatched attribute. This is because if a i,j is a matched attribute, it is a root of polyno-mial f ( x ), i.e., f ( a i,j ) = 0. Since stranger S has sent r i,j  X  0 to group member P ( i ) in the first phase, S should utilize  X  i,j to re-randomize it in Application phase. Otherwise, P ( i ) will learn which attribute the intermediate result z i,j correspondences to.

After calculating all the results F i,j and comparing them with zero, P ( i ) will learn the size of the intersect ion set between him and stranger S .Then P ( i )can decide whether to agree to S  X  X  application. 5.1 Security Under the HBC Model Theorem 1. Assuming the semi-trusted third party C sends all the packages { parameters { r i,j } 1  X  j  X  m are random, we can achieve SG-1. proof: In our scheme, sending all the packages in random order by C will blind from S the correspondence between P i and the intermediate results z i,j . In addi-or a random number, and S can learn nothing from r i,j r i,j  X  0 . Thus stranger S just learns whether F i,j represents a matched attribute and what the matching attribute is, but can X  X  learn its corresponding group member, any unmatched attributes or whether two computing results are from the same group member. Note that, to realize SG-1, { r i,j } 1  X  j  X  m don X  X  have to be random. Theorem 2. Assuming the semi-trusted third party C sends all the packages { eters { r i,j } 1  X  j  X  m are random, we can achieve SG-2. proof: In our protocol, if stranger S doesn X  X  apply to join group P , group mem-bers in P won X  X  receive any responses from the semi-trusted third party C and they learn nothing about the matching results and S  X  X  profile.
 are sent to P i by C in random order, and r i,j  X  0 is re-randomized by  X  i,j , P i won X  X  learn the corresponding attribute of the intermediate result z i,j . In addition,  X  i,j can X  X  be equal to r i,j  X  0 directly for P i knowing the relationship between r i,j  X  0 and its corresponding attribute. The value f ( a i,j ) is randomized by r i,j ,so F i,j is zero or a random number and group member P i just learns weather F i,j represents a matched attribute or not. Since r i,j is generated by stranger S for each attribute in group members X  profi les, group members can learn nothing more than the matching results by exchanging information with each other. However, if the size of the intersection set between S and P i equals to the size of P  X  X  own attribute set, i.e., |A s A i | = |A i | , P i will learn that all his attributes be random.
 generated randomly, we can achieve SG-3. proof: In any phase of our protocol, since the inputs received by the semi-trusted third party C are randomized, and some parameters used to calculate matching results are encrypted, C can learn nothing more than what can be derived from the values sent to him, his outputs and their corresponding group members. In the Application phase, even though C knows the values r i,j , it doesn X  X  effect the security of our scheme. 5.2 Security Against Active Attacks the random numbers r i,j in function F i,j = r i,j r i,j f ( a i,j )+ a i,j won X  X  work and then F i,j is equal to the attribute a i,j . This kind of active attacks is re-ferred to as zero polynomial attacks [3]. In our scheme, group member P i sends realize zero polynomial attacks. To prev ent this type of attacks, upon receiving the values r i,j  X  0 from stranger S , P i should first test r i,j  X  0 ? =0.
In order to increase the possibility of joining group P , a malicious stranger S can use a large attribute set or launches the procedure many times to find out as many matched attributes in group members X  profiles as possible. The former attack can be prevented by limiting the size of all users X  attribute sets, the same approach as in [16]. The second attack can be prevented by auditing the times that stranger S runs the matching scheme to compute the intersection set with the same group in a short time by the semi-trusted third party C .
 In this section, we evaluate the performance of our scheme and compare it against the Gmatch scheme without batch verification [2]. We test the two schemes on the same hardware and OS, and our experimental environment is a 3.4GHz system with the OpenSSL library. We use RSA protocol to encrypt data to be transmitted and the length of the private/public key is 1024bits. In addition, we assume | p | = 160bits.
In experiments, we change the size of stranger S  X  X  profile n , the size of group member P i  X  X  profile m and the number of group members d respectively and measure the total run time at stranger S ,groupmember P i and the semi-trusted third party C . Since the Gmatch scheme doesn X  X  include a third party, Fig. 4(c), Fig. 5(c) and Fig. 6(c) only show our system X  X  run time on C .AsshowninFig. 4(a), Fig. 5(a) and Fig. 6(a), we can see that, our scheme is more efficient than the Gmatch scheme on S  X  X  client. Especially in Fig. 6(a), when only changing the number of group members d , the total run time of S increases linearly with d in our scheme, while the Gmatch scheme increases exponentially. From Fig. 4(b), Fig. 5(b) and Fig. 6(b), the run time at each group member is only linearly affected by n and m , while the Gmatch scheme is affected by n , m and d .This is because we don X  X  use ring signature and additive homomorphic encryption in our scheme. Fig. 4(c), Fig. 5(c) and Fig. 6(c) show that the semi-trusted third party C  X  X  run time increase linearly with n , m and d . Although the total run time at C is much larger than that at stranger S and group member P i ,itis acceptable for users.

The performance evaluation of the two schemes show that in all settings our scheme is much more efficient and faster than the Gmatch scheme, and it is prac-tical and lightweight enough in computation to be used on networked portable devices. That is because our scheme take advantage of the semi-trusted third party C to help calculate the polynomial and send the results to stranger S instead of using additive homomorphic encryption and ring signature. Our sys-tem relies mostly on modular multiplication while the Gmatch scheme included many exponentiation operations and bilinear operations. Considering the semi-trusted third party utilized in our system is easy to access and can be provided by service providers, the assumption of the existing of a third party is realizable in social networks. In this paper, we propose a novel protocol to realize group matching by utilizing private set intersection (PSI) and a semi-trusted third party. During our scheme, by collecting different kinds of matching information, the stranger outside of the groups can make a better decision when choosing the most suitable group to join, and each group member can decide whether to agree to the stranger X  X  application. We provide the thorough security analysis on our scheme and prove its security under honest-but-curious (H BC) model and against several certain active attacks. By comparison with an existing work, we show our system is practical and efficient in computation to be used in social networks. Acknowledgement. This work was supported by National Natural Science Foundation of China under Grant 61232005, 61100237, 91118006.

