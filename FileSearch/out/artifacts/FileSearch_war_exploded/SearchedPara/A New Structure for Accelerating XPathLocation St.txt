 As XML has been so successful in being adopted as a universal data exchange for-mat, particularly in he World Wide Web, the problem of managing and querying XML documents poses interesting challenges to database researchers. Although XML documents could have rather complex internal structures, they share the same data type underlying the XML paradigm: ordered tree. Tree nodes rep-resent document elements, attributes or text data, while edges represent the element-subelement (or parent-child) relationship.

To retrieve such tree-shaped data, s everal XML query languages have been proposed in the literature. Examples include XPath [2] and XQuery [3]. XQuery is being standardized as a major XML query language. The main building block of XQuery is XPath, which addresses part of XML documents for retrieval [16]. For example,  X  paragraph//section  X  is to find all sections that are contained in each paragraph. Here, the do uble slash  X // X  represents the ancestor -descendant relationship. A single slash  X / X  in an XPath represents a parent -child relation-ship, for example  X  section/f igure  X .

In line with the tree-centric nature of XML, XPath provides operators to describe path traversals in a tree-shaped document. Path traversals evaluate to a collection of subtrees (forests), which may then, recursively, be subject to further traversal. Starting from a so-called context node, an XPath query traverses its input document using a number of location steps. For each step, an axis describes which document nodes (and the subtrees below these nodes) form the intermediate result forest for this step. The XPath specification [2] lists a family of 13 axes (among these the children and descendant-or-self axes, probably more widely known by their a bbreviations / and //, respectively).
Generally speaking, XPath expressions specify a tree traversal via two para-meters: (1) a context node (not necessarily for the root) which is the starting point of the traversal, (2) and a sequence of location steps syntactically sepa-rated by /, evaluated from left to right. Given a context node, a step X  X  axis (only one step of a regular XPath expressions) establishes a subset of document nodes. This set of nodes, or forest, provides the context nodes for the next step which is evaluated for each node of the forest in turn. The results are unioned together and sorted in document order. To illustrate the semantics of the XPath axes, Figure 1 depicts the result forests for three steps along different axes taken from context node e (note that the preceding axis does not include the ancestors of the context node). Table 1 lists all XPath axes.
It is important and basic work to efficiently implement XPath axes on XML documents. In work [1], R*-tree has been successfully applied to implementing XPath axes and the method proposed in [1] is able to support all XPath axes. In [1], each node of an XML document is labeled with a five-dimensional tuple. All the nodes of the XML document are mapped to a point set in a five-dimensional space. T. Grust made it clear that each of the XPath axes can be implemented by a range query on the above five-dimensi onal space. Thus, R*-tree is helpful to improving the query performance of the range queries of XPath axes. This method has been proved efficient in [1]. However, according to our investigations, most of the range queries for the XPath axes are partially-dimensional range queries (i.e., the number of query dimensions in each of the range queries is less than five, although the R*-tree is built in five-dimensional space). If the existing multidimensional indices (such as R*-tree, which is used in [1]) are used for such range queries, then a great deal of information that is irrelevant to the queries also has to be read from disk, which hea vily degrades the query performance. Based on this observation, in this study, a new multidimensional index structure (called Adaptive R*-tree) is proposed to support XPath axes more efficiently. The discussions and experiments with various datasets indicate that Adaptive R*-tree is better suited to XML documents, especially large documents.
In the remainder of this paper, Section 2 is some related works and our ob-servation is presented in Section 3. Section 4 presents the proposed method, a new index structure for XPath axes, including its structure and algorithm. The experiment results are presented in Section 5. Section 6 concludes this paper and point out the future works. The concept of regular path expressions d ominates this field of research by far [4, 5, 6, 7]. The work [4] presented an index over the prefix-encoding of the paths in an XML document tree (in a prefix-encoding, each leaf l of the document tree is prefixed by the sequence of element tags encountered during a path traversal from the document root to l ). Since tag sequences obviously share common pre-fixes in such a scheme, a variant of the Patricia-tree is used to support lookups. Clearly, the index structure is tailored to respond to path queries that originate in the document root. Paths that do not have the root as the context node need multiple index lookups or require a post-processing phase (as does a restore of the document order in the result forest). In [4], so-called refined paths are pro-posed to remedy this drawback. Refined paths, however, have to be preselected before index loading time.

The T-index structure, proposed by Milo and Suciu in [6], maintains (approx-imate) equivalence classes of document nodes which are indistinguishable with respect to a given path template. In general, a T-index does not represent the whole document tree but only those document parts relevant to a specific path template. The more permissive and the larger the path template, the larger the resulting index size. This allows to trade space for generality, however, a specific T-index supports only those path traversals matching its path template (as re-ported in [6], an effective applicability test for a T-index is known for a restricted class of queries only).

There is other related work that is not directly targeted at the construc-tion of index structures for XML. In [8], the authors discuss relational support for containment queries. Especially the multi-predicate merge join (MPMGJN) presented in [8] would provide an almost perfect infrastructure for the XPath accelerator. MPMGJN join supports multiple equality and inequality tests. The authors report an order of magnitude speed-up in comparison to standard join algorithms.

The work [1] successfully adopts multidimensional index structure in process-ing XML queries. It proposes an XPath accelerator that can completely live inside a relational database system, i.e., it is a relational storage structure in the sense of [10]. The implementation of the proposal in [1] benefits from ad-vanced index technology, esp. the R-tree, that has by now found its way into mainstream relational database systems. It has been developed with a close eye on the XPath semantics and is thus able to support all XPath axes.

The main contributions of [1] are that (1) it proposed a five-dimensional de-scriptor (labeling schema) for each node of the XML document, (2) it made it clear that, using this labeling schema, each of the 13 XPath axes can be mapped to a range query in the five-dimensiona l descriptor-space, and (3) the range queries for XPath axes were implemented using R*-tree.

In this paper, based on the work [1], we will (1) present our observations on the range queries of XPath axes, and (2) a ccording to the features of these range queries, present a new index structure (instead of R*-tree) to further improve the query performance of XPath axes. Since our work is based on [1], the key idea of [1] is described as follows. 2.1 Labeling Schema and Mapping XPath Axes to Range Queries Each node v of an XML document is represented by the following five-dimensional descriptor: desc ( v )= &lt;pre ( v ), post ( v ), par ( v ), att ( v ), na m e ( v ) &gt; , where pre ( v )and post ( v ) are the preorder and the postorder of v , respectively. par ( v ) is the preorder of parent node of v . att ( v ) is a Boolean value indicating whether v is attribute node or not. The last one, na m e ( v ) is the name of v .In this way, all the nodes in an XML document can be mapped to a set of points in the five-dimensional descriptor space (or say labeling space ).

As others have noted [5, 8, 11], one can use pre ( v )and post ( v ) to efficiently characterize the descendants v of v .Wehavethat v is a descendant of v  X   X  pre ( v ) &gt;pre ( v )  X  post ( v ) &lt;post ( v )(1) Inthesameway,wehavethat v is a ancestor of v  X   X  pre ( v ) &lt;pre ( v )  X  post ( v ) &gt;post ( v )(2) v is a preceding node of v  X   X  pre ( v ) &lt;pre ( v )  X  post ( v ) &lt;post ( v )(3) v is a following node of v  X   X  pre ( v ) &gt;pre ( v )  X  post ( v ) &gt;post ( v )(4)
According to the above four equa-tions, we can see that the four XPath axes of descendant , ancestor , preceding and following can be mapped to range queries in the two-dimensional space of preorder / postorder , which is shown in Fig. 2. With the help of the other items in the five-dimensional descriptor, the other XPath axes also can be mapped to range queries. Table 2 presents the ranges of all the XPath axes.
 Like [1], the two axes of self and na m espace are omitted since they are so simple. 2.2 Implementation of Range Queries Using R*-Tree Since all of the XPath axes can be mapped to range queries in the five-dimensional descriptor-space, R*-tree (used in [1]) seems helpful to improving the range query performance. Because w e will propose a new structure to further improve the range query performance, R*-tree is briefly recalled here.
R*-tree [12] is a hierarchy of nested multidimensional MBRs. Each non-leaf node of the R*-tree contains an array of entries, each of which consists of a pointer and an MBR. The pointer refers to one child node of this node and the MBR is the minimum bounding rectangle of the child node referred to by the pointer. Each leaf node of the R*-tree contains an array of entries, each of which consists of an object identifier and the object itself (for point-object datasets) or its MBR (for extended object datasets). In the present paper, object and tuple are used interchangeably. In the R*-tree, the root node corresponds to the entire index space and each of the other nodes represents a sub-space (i.e., the MBR of all of the objects contained in this region) of the space formed by its parent node. Note that, each MBR in R*-tree nodes is denoted by two points. One is the lowest vertex with the minimum coordinate in each axis and the other is the upper-most vertex with the maximum coordinate in each axis. When R*-tree is used for a range query, all of the nodes intersecting the query range are accessed and their entries have to be checked. From the above-mentioned Table 2, we can observe that most of the query ranges of XPath axes only use partial items of the five-dimensional descriptor. For example, child axis only uses par and att ; parent axis only uses pre .Inthis paper, the range queries that only use partial (rather than all) dimensions of the entire space are called partially-dimensi onal range queries (denoted as PD range queries). Contrarily, the range queries that use all dimensions of the entire space are called all-dimensional range queries (denoted as AD range queries).
We want to note that all the existing multidimensional indices are designed to evaluate AD queries. This is because all of the objects are clustered in the leaf nodes according to their information in all index dimensions and every node contains information of its entries in all of the index dimensions. Actually, they can also evaluate PD range queries as follows. Using one n -dimensional index in the entire n -dimensional index space, one PD range query using d ( d&lt;n )query dimensions can be evaluated by simply extending the query range in each of the ( n  X  d ) irrelevant index dimensions to the entire data range.

However, a disadvantage of using all-dimensional indices for PD range queries is that each node of the index contains n -dimensional information, but only d -dimensional information is necessary for a PD range query using only d ( d&lt;n ) dimensions. This means that a great deal of unnecessary information, i.e., the information in the irrelevant dimensions, also has to be read from disk, which de-grades the query performance. In other words, the irrelevant information in the index nodes decreases capacity (fanout) of each node. Directing to this disadvan-tage and considering that most of the query ranges of XPath axes are PD range queries, a new index structure for indexing XML data is proposed in this paper. According to the features of the range queries of XPath axes, a new index struc-ture, called Adaptive R*-tree (denoted as AR*-tree), is proposed to improve the performance of such range queries. 4.1 Structure The key concept of AR*-tree is to divide each of the n -dimensional R*-tree nodes into n one-dimensional nodes (these n one-dimensional nodes are called a node -group ), each of which holds information in only one dimension, while each node of R*-tree holds information in all of the dimensions of the index space. Like each node in R*-tree, each node-group in AR*-tree corresponds to an n -dimensional subspace in the index space. Every entry of nodes in each index node-group corresponds to an edge of the corresponding subspace, while each entry of one R*-tree index node corresponds to a subspace.
Figure 3 shows the structure dif-ference between R*-tree nodes and AR*-tree node-group. All of the en-tries with the same index in the n nodes of this node-group form a com-plete n -dimensional MBR in the index space. Whereas every entry in R*-tree nodes includes MBR information in all of the dimensions, each entry in the nodes of AR*-tree includes only one-dimensional information. The term en-try of node-group, which refers to the set of entries having the same index distributed in all the different nodes of one node-group, is used hereinafter. One entry of each index node-group corre-sponds to a complete MBR in the index space. In Fig. 3, all of the entries in an ellipse form an complete entry of the node-group, which is a complete MBR in the entire index space.

The question then arises as to whether the total number of nodes in AR*-tree becomes n times that in R*-tree, because each node of R*-tree has been divided into n nodes. However, this is not the case because the maximum number of entries in each node of AR*-tree is up to approximately n times that in R*-tree since the dimensionality of each node in AR*-tree becomes 1. The structure of AR*-tree guarantees that it can be applied to PD range queries with any combinations of the query dimensions and that only the relevant one-dimensional nodes are visited.

The main advantage of AR*-tree over R*-tree (all-dimensional index) is that, for PD range queries, only the relevant nodes of the accessed node-groups need be visited and the other nodes, even if they are in the same node-groups, can be skipped. In R*-tree, information in all of the index dimensions is contained in each R*-tree node, but only information in the query dimensions are necessary for PD range queries, which means that a great deal of irrelevant information has to be loaded from disk and this certainly degrades the search performance, especially for large datasets. 4.2 Algorithms of AR*-Tree The insert algorithm of AR*-tree is a naive extensions of the counterparts of R*-tree. After the new tuple reaches the leaf node-group, it is divided and stored in different nodes of the leaf node-group according to dimension. If some node-group must be split, then all of its nodes have to be split at the same time and the split may be up propagated. After a delete operation, if the node-group under-flowed, then all of its nodes should be deleted at the same time and all of its entries are inserted to the AR*-tree again. That is, all of the nodes in each node-group must be born simultaneously and die simultaneously.

A range query algorithm for AR*-tree, which can be used for AD range queries and PD range queries, is shown in Table 3.

Staring with the root node-group, each entry of the current node-group needs to be checked to determine whether its MBR intersects the query range. If its MBR intersects the query range, and the current node-group is not at the leaf level, then this algorithm is invoked recursively with the corresponding child node-group. Note that, when each entry e of the current node-group is checked, (1) not all of the nodes in the current node-group have to be accessed (such irrelevant nodes are skipped), and (2) even, not all of the nodes in the relevant dimensions (query dimensions) have to be visited. That is, further checks are not necessary after the current entry is found not to intersect the query range in some dimension. 5.1 Experiment Process The process of our experiments is shown in Fig. 4.
 XML Documents. The XML documents used in our experiments are generated by XMLgen [17], an easily accessible XML generator, which is developed for the Xmark benchmark project [14]. Using XMLgen, three documents shown in Table 4 were generated and used. In this table, XMLgen factor were given as a size factor to control document sizes.
 Figure 5 is the distribution of the nodes in the 5.5 MB XML document. Because Figure 5 (a) contains a total of 103,135 nodes, it could not be seen clearly. Figure 5 (b) is a partial enlargement, in which there are nearly 200 nodes of this XML document. The X axis represents preorder and the Y axis postorder.
 Reader. Based on Libxml2 [15] which is an XML C parser and toolkit, we built a loader to obtain one accel table for each XML document, which is used to build the indices. Because the XML documents have a total of 77 different node names, all of the possible node names are encoded from 0 to 76 in order to be dealt with by R*-tree and AR*-tree.
 Accel Table. Each tuple of accel table is the five-dimensional descriptor of one node of an XML document. As mentioned above, all of the node names are encoded from 0 to 76. The accel table is directly used to build R*-tree and AR*-tree.
 R*-Tree and AR*-Tree. An R*-tree and an AR*-tree are constructed for the accel table of each XML document. The node size is set to 4096 bytes. Performance Test. We assume that the multidimensional index is disk-resident, which is reasonable for large datasets. Thus, the query performance is tested in term of the number of node accesses. Except the three XPath axes of self, attribute, and namespace (they are too simple and performance difference between R*-tree and AR*-tree could not be shown clearly), the query perfor-mance of all the other 10 XPath axes are tested using R*-tree and AR*-tree, respectively. By comparing the query performance of XPath axes on R*-tree and AR*-tree, we will see which of R*-tree and AR*-tree is better suited to XPath axes. 5.2 Experiment Result The experiment result is shown in Tables 5. The context nodes for different XML documents are chosen independently. That is, the same XPath axis is possibly tested with different context nodes for different data documents. Certainly, for the sake of comparison, all the tests on R*-tree and AR*-tree for the same XML documents used the same context nodes.

From the above experiment, we can obtain the following observation. Except the XPath axes of ancestor (including ancestor-or-self) and preceding-sibling, for which the advantage of AR*-tree is not shown very clearly, AR*-tree performs clearly better than R*-tree for the other seven XPath axes. As mentioned in Section 1, the query performance of XPat h axes is very important because that the main building block of XQuery is XPath and XPath expressions consists of a sequence of XPath axis operations, which are evaluated from left to right. Moreover, each step of an XPath expression (one XPath axis operation) often obtain a great number of intermediate results, which means that the evaluation of one XPath expression may need a great number of XPath axis operations. Thus, any improvement on the query performance of XPath axes will be significant. Multidimensional indices have been successfully introduced to the field of query-ing on XML data. And, the query performance of XPath axes is very important because they are the main building blocks of XQuery. The evaluation of one XPath expression may need a great number of XPath axis operations since each step of an XPath expression (one XPath axis operation) often obtain a great number of intermediate results. Thus, any improvement on the query perfor-mance of XPath axes will be significant. The existing methods that introduced multidimensional indices to implementing XPath axes apply all-dimensional in-dices (e.g., R*-tree in [1]). In this paper, a new multidimensional index structure, called AR*-tree, was proposed and discussed. The discussion and experiments using various XML documents showed that the proposed method has a clear performance advantage for XPath axes compared with R*-tree, a famous and popular all-dimensional index structure. As one of future works, the performance of AR*-tree for XPath axes will be examined using some other kinds of XML documents.
 This research was supported in part by the Japan Society for the Promotion of Science through Grants-in-Aid for Scientific Research 17650031 and 16200005. In addition, the authors would like to thank Mr. Satoshi Tani, who conducted the experiments, and to thank Prof. Kunihiko Kaneko for his helpful comments.
