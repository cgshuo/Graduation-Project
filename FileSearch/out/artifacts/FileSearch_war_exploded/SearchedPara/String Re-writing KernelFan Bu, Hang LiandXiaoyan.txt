 Learning for sentence re-writing is a fundamental task in natural language processing and information retrieval, which includes paraphrasing, textual en-tailment and transformation between query and doc-ument title in search.

The key question here is how to represent the re-writing of sentences. In previous research on sen-tence re-writing learning such as paraphrase identifi-cation and recognizing textual entailment, most rep-resentations are based on the lexicons (Zhang and Patrick, 2005; Lintean and Rus, 2011; de Marneffe et al., 2006) or the syntactic trees (Das and Smith, 2009; Heilman and Smith, 2010) of the sentence pairs.

In (Lin and Pantel, 2001; Barzilay and Lee, 2003), re-writing rules serve as underlying representations for paraphrase generation/discovery. Motivated by the work, we represent re-writing of sentences by all possible re-writing rules that can be applied into it. For example, in Fig. 1, (A) is one re-writing rule that can be applied into the sentence re-writing (B). Specifically, we propose a new class of kernel func-tions (Sch  X  olkopf and Smola, 2002), called string re-writing kernel (SRK), which defines the similarity between two re-writings (pairs) of strings as the in-ner product between them in the feature space in-duced by all the re-writing rules. SRK is different from existing kernels in that it is for re-writing and defined on two pairs of strings . SRK can capture the lexical and structural similarity between re-writings of sentences and does not need to parse the sentences and create the syntactic trees of them.

One challenge for using SRK lies in the high com-putational cost of straightforwardly computing the kernel, because it involves two re-writings of strings (i.e., four strings) and a large number of re-writing rules. We are able to develop an instance of SRK, referred to as kb-SRK, which directly computes the number of common rewriting rules without explic-itly calculating the inner product between feature vectors, and thus drastically reduce the time com-plexity.

Experimental results on benchmark datasets show that SRK achieves better results than the state-of-the-art methods in paraphrase identification and rec-ognizing textual entailment. Note that SRK is very flexible to the formulations of sentences. For ex-ample, informally written sentences such as long queries in search can also be effectively handled. The string kernel function, first proposed by Lodhi et al. (2002), measures the similarity between two strings by their shared substrings. Leslie et al. (2002) proposed the k-spectrum kernel which repre-sents strings by their contiguous substrings of length k . Leslie et al. (2004) further proposed a number of string kernels including the wildcard kernel to fa-cilitate inexact matching between the strings. The string kernels defined on two pairs of objects (in-cluding strings) were also developed, which decom-pose the similarity into product of similarities be-tween individual objects using tensor product (Basil-ico and Hofmann, 2004; Ben-Hur and Noble, 2005) or Cartesian product (Kashima et al., 2009).

The task of paraphrasing usually consists of para-phrase pattern generation and paraphrase identifica-tion. Paraphrase pattern generation is to automat-ically extract semantically equivalent patterns (Lin and Pantel, 2001; Bhagat and Ravichandran, 2008) or sentences (Barzilay and Lee, 2003). Paraphrase identification is to identify whether two given sen-tences are a paraphrase of each other. The meth-ods proposed so far formalized the problem as clas-sification and used various types of features such as bag-of-words feature, edit distance (Zhang and Patrick, 2005), dissimilarity kernel (Lintean and Rus, 2011) predicate-argument structure (Qiu et al., 2006), and tree edit model (which is based on a tree kernel) (Heilman and Smith, 2010) in the classifica-tion task. Among the most successful methods, Wan et al. (2006) enriched the feature set by the BLEU metric and dependency relations. Das and Smith (2009) used the quasi-synchronous grammar formal-ism to incorporate features from WordNet, named entity recognizer, POS tagger, and dependency la-bels from aligned trees.

The task of recognizing textual entailment is to decide whether the hypothesis sentence can be en-tailed by the premise sentence (Giampiccolo et al., 2007). In recognizing textual entailment, de Marn-effe et al. (2006) classified sentences pairs on the basis of word alignments. MacCartney and Man-ning (2008) used an inference procedure based on natural logic and combined it with the methods by de Marneffe et al. (2006). Harmeling (2007) and Heilman and Smith (2010) classified sequence pairs based on transformation on syntactic trees. Zanzotto et al. (2007) used a kernel method on syntactic tree pairs (Moschitti and Zanzotto, 2007). We formalize sentence re-writing learning as a ker-nel method. Following the literature of string kernel, we use the terms  X  X tring X  and  X  X haracter X  instead of  X  X entence X  and  X  X ord X .

Suppose that we are given training data consisting of re-writings of strings and their responses where  X  denotes the character set,  X   X  = S  X  i = 0  X  i de-notes the string set, which is the Kleene closure of set  X  , Y denotes the set of responses, and n is the number of instances. ( s i , t i ) is a re-writing consist-ing of the source string s i and the target string t y is the response which can be a category, ordinal number, or real number. In this paper, for simplic-ity we assume that Y = { X  1 } (e.g. paraphrase/non-paraphrase). Given a new string re-writing ( s , t )  X   X   X   X   X   X  , our goal is to predict its response y . That is, the training data consists of binary classes of string re-writings, and the prediction is made for the new re-writing based on learning from the training data.
We take the kernel approach to address the learn-ing task. The kernel on re-writings of strings is de-fined as satisfying for all ( s i , t i ) , ( s j , t j )  X   X   X   X   X  where  X  maps each re-writing (pair) of strings into a high dimensional Hilbert space H , referred to as feature space. By the representer theorem (Kimel-dorf and Wahba, 1971; Sch  X  olkopf and Smola, 2002), it can be shown that the response y of a new string re-writing ( s , t ) can always be represented as where  X  i  X  0 , ( i = 1 ,  X  X  X  , n ) are parameters. That is, it is determined by a linear combination of the sim-ilarities between the new instance and the instances in training set. It is also known that by employing a learning model such as SVM (Vapnik, 2000), such a linear combination can be automatically learned by solving a quadratic optimization problem. The ques-tion then becomes how to design the kernel function for the task. Let  X  be the set of characters and  X   X  be the set of strings. Let wildcard domain D  X   X   X  be the set of strings which can be replaced by wildcards.

The string re-writing kernel measures the similar-ity between two string re-writings through the re-writing rules that can be applied into them. For-mally, given re-writing rule set R and wildcard do-main D, the string re-writing kernel (SRK) is defined as where  X  ( s , t ) = (  X  r ( s , t )) r  X  R and where n is the number of contiguous substring pairs of ( s , t ) that re-writing rule r matches, i is the num-ber of wildcards in r , and  X   X  ( 0 , 1 ] is a factor pun-ishing each occurrence of wildcard.

A re-writing rule is defined as a triple r = (  X  s ,  X  t ,  X  ) where  X  s ,  X  t  X  (  X   X  X  X  X  ) and target string patterns and  X   X  ind  X  (  X  s )  X  ind  X  ( denotes the alignments between the wildcards in the two string patterns. Here ind  X  (  X  ) denotes the set of indexes of wildcards in  X  .

We say that a re-writing rule (  X  s ,  X  t ,  X  ) matches a string pair ( s , t ), if and only if string patterns  X  s  X  t can be changed into s and t respectively by sub-stituting each wildcard in the string patterns with an element in the strings, where the elements are de-fined in the wildcard domain D and the wildcards  X  [ i ] and  X  t [ j ] are substituted by the same elements, when there is an alignment ( i , j )  X   X  .

For example, the re-writing rule in Fig. 1 (A) can be formally written as r = (  X  s ,  X  t ,  X  ) where  X   X  Fig. 1 (B).

String re-writing kernel is a class of kernels which depends on re-writing rule set R and wildcard do-main D. Here we provide some examples. Obvi-ously, the effectiveness and efficiency of SRK de-pend on the choice of R and D.
 Example 1. We define the pairwise k-spectrum ker-nel (ps-SRK) K ps k as the re-writing rule kernel un-D. It can be shown that K ps k (( s 1 , t 1 ) , ( s 2 K k ( s 1 , s 2 ) K alent to the k-spectrum kernel proposed by Leslie et al. (2002).
 Example 2. The pairwise k-wildcard kernel (pw-SRK) K pw k is defined as the re-writing rule kernel under R = { (  X  s ,  X  t ,  X  ) |  X  s ,  X  t  X  (  X   X  X  X  X  ) k , D =  X  . It can be shown that K pw k (( s 1 , t 1 ) , ( s K cial case (m=k) of the (k,m)-wildcard kernel pro-posed by Leslie et al. (2004).

Both kernels shown above are represented as the product of two kernels defined separately on strings s consider the alignment relations between the strings. Next we propose another instance of string re-writing kernel, called the k -gram bijective string re-writing kernel (kb-SRK). As will be seen, kb-SRK can be computed efficiently, although it is defined on two pairs of strings and is not decomposed (note that ps-SRK and pw-SRK are decomposed). 5.1 Definition The kb-SRK has the following properties: (1) A wildcard can only substitute a single character, de-writing rule are of length k . (3) The alignment is a one-to-one mapping between the wildcards in the string patterns. Formally, the k-gram bijective string re-writing kernel K k is defined as a string re-writing kernel under the re-writing rule set R = { ( wildcard domain D =  X  .

Since each re-writing rule contains two string pat-terns of length k and each wildcard can only substi-tute one character, a re-writing rule can only match k -gram pairs in ( s , t ) . We can rewrite Eq. (2) as (  X  s ,  X  t ) , otherwise For ease of computation, we re-write kb-SRK as
K k (( s 1 , t 1 ) , ( s 2 , t 2 )) where 5.2 Algorithm for Computing Kernel A straightforward computation of kb-SRK would be intractable. The computation of K k in Eq. (4) needs computations of  X  K k conducted O (( n  X  k + 1 ) 4 ) times, where n denotes the maximum length of strings. Furthermore, the computation of  X  K k in Eq. (5) needs to perform matching of all the re-writing rules with the two k -gram pairs (  X  s (  X  s 2 ,  X  t 2 ), which has time complexity O ( k ! ) .
In this section, we will introduce an efficient algo-rithm, which can compute  X  K k and K k with the time complexities of O ( k ) and O ( kn 2 ) , respectively. The latter is verified empirically. 5.2.1 Transformation of Problem
For ease of manipulation, our method transforms the computation of kernel on k-grams into the com-putation on a new data structure called lists of dou-bles. We first explain how to make the transforma-tion.

Suppose that  X  1 ,  X  2  X   X  k are k-grams, we use  X  [ i ] and  X  2 [ i ] to represent the i -th characters of them. We call a pair of characters a double. Thus  X   X   X  denotes the set of doubles and  X  D s ,  X  D t  X  (  X   X   X   X   X  ) k denote lists of doubles. The following operation combines two k -grams into a list of doubles. We denotes  X  1  X   X  2 [ i ] as the i -th element of the list. Fig. 3 shows example lists of doubles combined from k-grams.

We introduce the set of identical doubles I = { ( c , c ) | c  X   X  } and the set of non-identical doubles  X   X   X  and I T N = /0.

We define the set of re-writing rules for double lists R D = { r D = (  X  D s ,  X  D t ,  X  ) |  X  D s ,  X  D t is a bijective alignment } where  X  D s and  X  D t are lists of identical doubles including wildcards and with length k . We say rule r D matches a pair of double and  X  D t by substituting each wildcard pair to a dou-ble in  X   X   X  , and the double substituting the wild-ble when there is an alignment ( i , j )  X   X  . The rule set defined here and the rule set in Sec. 4 only differ on the elements where re-writing occurs. Fig. 4 (B) shows an example of re-writing rule for double lists. The pair of double lists in Fig. 3 can match with the re-writing rule. 5.2.2 Computing  X  K k
We consider how to compute  X  K k by extending the computation from k -grams to double lists.

The following lemma shows that computing the weighted sum of re-writing rules matching k -gram pairs (  X  s puting the weighted sum of re-writing rules for dou-ble lists matching (  X  s Lemma 1. For any two k-gram pairs (  X  s (  X  s 2 ,  X  t 2 ) , there exists a one-to-one mapping from the set of re-writing rules matching them to the set of re-writing rules matching the corresponding double lists (  X  s
The re-writing rule in Fig. 4 (A) matches the k-gram pairs in Fig. 2. Equivalently, the re-writing rule for double lists in Fig. 4 (B) matches the pair of double lists in Fig. 3. By lemma 1 and Eq. 5, we have double lists r D with i wildcards matches (  X  D s ,  X  D t to compute the weighted sum of re-writing rules for double lists matching (  X  s we can work on the  X  X ombined X  pair of double lists instead of two pairs of k -grams.

Instead of enumerating all possible re-writing rules and checking whether they can match the given pair of double lists, we only calculate the number of possibilities of  X  X enerating X  from the pair of double lists to the re-writing rules matching it, which can be carried out efficiently. We say that a re-writing rule of double lists can be generated from a pair of double the definition of R D , in each generation, the identi-cal doubles in  X  D s and  X  D t can be either or not sub-stituted by an aligned wildcard pair in the re-writing Algorithm 1: Computing  X  K k
Input : k -gram pair (  X  s
Output :  X  K k ((  X  s
Set (  X  D s ,  X  D t ) = (  X  s
Compute #  X   X   X  (  X  D s ) and #  X   X   X  (  X  D t ) ; result =1; for each e  X   X   X   X  satisfies # e (  X  D s )+ # e (  X  D t ) 6 = 0 do 5 g e = 0, n e = min { # e (  X  D s ) , # e (  X  D t ) } ; 6 for 0  X  i  X  n e do 8 result = result  X  g ; return result ; rule, and all the non-identical doubles in  X  D s and  X  D t must be substituted by aligned wildcard pairs. From this observation and Eq. 6,  X  K k only depends on the number of times each double occurs in the double lists.

Let e be a double. We denote # e (  X  D ) as the num-ber of times e occurs in the list of doubles  X  D . Also, for a set of doubles S  X   X   X   X  , we denote # S (  X  D ) as a vector in which each element represents # e (  X  D ) of each double e  X  S. We can find a function g such that
Alg. 1 shows how to compute  X  K k . #  X   X   X  ( . ) is com-puted from the two pairs of k-grams in line 1-2. The final score is made through the iterative calculation on the two lists (lines 4-8).

The key of Alg. 1 is the calculation of g e based on a i (line 7). Here we use a of possibilities for which i pairs of aligned wildcards can be generated from e in both  X  D s and  X  D t . a ( e ) be computed as follows. (1) If e  X  N and # e (  X  D s ) 6 = # e (  X  D t ) , then a for any i . (2) If e  X  N and # e (  X  D s ) = # e (  X  D t ) = j , then a j ! and a ( e ) i = 0 for any i 6 = j .
We next explain the rationale behind the above computations. In (1), since # e (  X  D s ) 6 = # e (  X  D t impossible to generate a re-writing rule in which all the occurrences of non-identical double e are substi-tuted by pairs of aligned wildcards. In (2), j pairs of aligned wildcards can be generated from all the oc-currences of non-identical double e in both  X  D s and  X  t . The number of combinations thus is j !. In (3), a pair of aligned wildcards can either be generated or not from a pair of identical doubles in  X  D s and  X  t . We can select i occurrences of identical double e from  X  D s , i occurrences from  X  D t , and generate all possible aligned wildcards from them.

In the loop of lines 4-8, we only need to con-sider a ( e ) i for 0  X  i  X  min { # e (  X  D s ) , # e (  X  a i = 0 for the rest of i .

To sum up, Eq. 7 can be computed as below, which is exactly the computation at lines 3-8.
For the k-gram pairs in Fig. 2, we first create lists of doubles in Fig. 3 and compute #  X   X   X  (  X  ) for them (lines 1-2 of Alg. 1), as shown in Fig. 5. We next compute K k from #  X   X   X  (  X  D s ) and #  X   X   X  (  X  D Fig. 5 (lines 3-8 of Alg. 1) and obtain K k = ( 1 )( 1 +  X  )(  X  2 )( 2  X  4 )( 1 + 6  X  2 + 6  X  4 ) = 12  X  12 + 24  X  10 14  X  8 + 2  X  6 . 5.2.3 Computing K k
Algorithm 2 shows how to compute K k . It pre-pares two maps m s and m t and two vectors of coun-frequency of each #  X   X   X  ( . ) . Recall that # N (  X  s denotes a vector whose element is # e (  X  s e  X  N. #  X   X   X  (  X  s ment is # e (  X  s
One can easily verify the output of the al-gorithm is exactly the value of K k . First,  X  K ((  X  s # (  X  t those  X  s key (lines 10-13). We group the k -gram pairs by their key in lines 2-5 and lines 6-9.

Moreover, the following relation holds  X 
K  X  Algorithm 2: Computing K k
Input : string pair ( s 1 , t 1 ) and ( s 2 , t 2 ) , window
Output : K k (( s 1 , t 1 ) , ( s 2 , t 2 ))
Initialize two maps m s and m t and two counters c s and c t ; for each k-gram  X  s 3 for each k-gram  X  s 2 in s 2 do 4 Update m s with key-value pair for each k-gram  X  t 7 for each k-gram  X  t 2 in t 2 do 8 Update m t with key-value pair for each key  X  m s . keys  X  m t . keys do 11 for each v s  X  m s [ key ] do 12 for each v t  X  m t [ key ] do 13 result+= c s [ v s ] c t [ v t ] g ( v s , v t ) ; return result; other k -grams. Therefore, we only need to take # der each key and count its frequency. That is to say, #  X   X  provides sufficient statistics for computing  X  K k . The quantity g ( v s , v t ) in line 13 is computed by Alg. 1 (lines 3-8). 5.3 Time Complexity The time complexities of Alg. 1 and Alg. 2 are shown below.
 For Alg. 1, lines 1-2 can be executed in # (  X  D s ) 6 = 0 or # e (  X  D t ) 6 = 0 . Since  X  e  X   X   X   X   X  is less than 4 k , which results in the O ( k ) time com-plexity of Alg. 1.
 It is easy to see that if the maps and counters in the algorithm are implemented by hash maps, the time complexities of lines 2-5 and lines 6-9 are O ( kn 2 ) . However, analyzing the time complexity of lines 10-13 is quite difficult.

Lemma 2 and Theorem 1 provide an upper bound of the number of times computing g ( v s , v t ) in line 13, denoted as C .
 Lemma 2. For  X  s grams ( s 2 ) , we have #  X   X   X  (  X  s # Theorem 1. C is O ( n 3 ) .

By Lemma 2, each m s [ key ] contains at most n  X  k + 1 elements. Together with the fact that  X  key m s [ key ] = ( n  X  k + 1 ) It can be also proved that C is O ( n 2 ) when k = 1.
Empirical study shows that O ( n 3 ) is a loose upper bound for C . Let n avg denote the average length of s , t 1 , s 2 and t 2 . Our experiment on all pairs of sen-tences on MSR Paraphrase (Fig. 6) shows that C is in the same order of n 2 avg in the worst case and C / n 2 avg decreases with increasing k in both average case and worst case, which indicates that C is O ( n 2 ) and the overall time complexity of Alg. 2 is O ( kn 2 ) . We evaluated the performances of the three types of string re-writing kernels on paraphrase identifica-tion and recognizing textual entailment: pairwise k -spectrum kernel (ps-SRK), pairwise k -wildcard ker-nel (pw-SRK), and k -gram bijective string re-writing kernel (kb-SRK). We set  X  = 1 for all kernels. The performances were measured by accuracy (e.g. per-centage of correct classifications).

In both experiments, we used LIBSVM with de-fault parameters (Chang et al., 2011) as the clas-sifier. All the sentences in the training and test sets were segmented into words by the tokenizer at OpenNLP (Baldrige et al., ). We further conducted stemming on the words with Iveonik English Stem-mer ( http://www.iveonik.com/ ).
 We normalized each kernel by  X  K ( x , y ) =  X  window sizes k . We also tried to combine the kernels with two lexical features  X  X nigram precision and recall X  proposed in (Wan et al., 2006), referred to as PR. For each kernel K, we tested the window size settings of K 1 + ... + K k together with the combination with PR and we report the best accuracies of them in Tab 1 and Tab 2. 6.1 Paraphrase Identification The task of paraphrase identification is to examine whether two sentences have the same meaning. We trained and tested all the methods on the MSR Para-phrase Corpus (Dolan and Brockett, 2005; Quirk et al., 2004) consisting of 4,076 sentence pairs for training and 1,725 sentence pairs for testing.
The experimental results on different SRKs are shown in Table 1. It can be seen that kb-SRK out-performs ps-SRK and pw-SRK. The results by the state-of-the-art methods reported in previous work are also included in Table 1. kb-SRK outperforms the existing lexical approach (Zhang and Patrick, 2005) and kernel approach (Lintean and Rus, 2011). It also works better than the other approaches listed in the table, which use syntactic trees or dependency relations.

Fig. 7 gives detailed results of the kernels under different maximum k -gram lengths k max with and without PR. The results of ps-SRK and pw-SRK without combining PR under different k are all be-low 71%, therefore they are not shown for clar-ity. By comparing the results of kb-SRK and pw-SRK we can see that the bijective property in kb-SRK is really helpful for improving the performance (note that both methods use wildcards). Further-more, the performances of kb-SRK with and without combining PR increase dramatically with increasing k max and reach the peaks (better than state-of-the-art) when k max is four, which shows the power of the lex-ical and structural similarity captured by kb-SRK. 6.2 Recognizing Textual Entailment Recognizing textual entailment is to determine whether a sentence (sometimes a short paragraph) can entail the other sentence (Giampiccolo et al., 2007). RTE-3 is a widely used benchmark dataset. Following the common practice, we combined the development set of RTE-3 and the whole datasets of RTE-1 and RTE-2 as training data and took the test set of RTE-3 as test data. The train and test sets con-tain 3,767 and 800 sentence pairs.

The results are shown in Table 2. Again, kb-SRK outperforms ps-SRK and pw-SRK. As indicated in (Heilman and Smith, 2010), the top-performing RTE systems are often built with significant engi-neering efforts. Therefore, we only compare with the six systems which involves less engineering. kb-SRK still outperforms most of those state-of-the-art methods even if it does not exploit any other lexical semantic sources and syntactic analysis tools.
Fig. 8 shows the results of the kernels under dif-ferent parameter settings. Again, the results of ps-SRK and pw-SRK without combining PR are too low to be shown (all below 55%). We can see that PR is an effective method for this dataset and the overall performances are substantially improved af-ter combining it with the kernels. The performance of kb-SRK reaches the peak when window size be-comes two. In this paper, we have proposed a novel class of ker-nel functions for sentence re-writing, called string re-writing kernel (SRK). SRK measures the lexical and structural similarity between two pairs of sen-tences without using syntactic trees. The approach is theoretically sound and is flexible to formulations of sentences. A specific instance of SRK, referred to as kb-SRK, has been developed which can bal-ance the effectiveness and efficiency for sentence re-writing. Experimental results show that kb-SRK achieve better results than state-of-the-art methods on paraphrase identification and recognizing textual entailment.
 This work is supported by the National Basic Re-search Program (973 Program) No. 2012CB316301.
