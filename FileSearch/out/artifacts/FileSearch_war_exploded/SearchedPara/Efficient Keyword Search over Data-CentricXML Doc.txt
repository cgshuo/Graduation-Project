 Keyword search is a proven and widely accepted mechanism for querying in document systems and World Wide Web . Database research community has recently recognized the benefits of keyw ord search and has been introducing keyword search capability into relational databases [3,7,10,15,17,19,23] and XML databases [4,5,6,9,11,12,13,16,18,20,21,22,25,26,28].

Traditional query processing approaches on relational and XML databases are constrained by the query constructs imposed by the languages such as SQL and XQuery. Firstly, the query languages themselves are hard to comprehend for non-database users. For example, the XQuery is fairly complicated to grasp. Secondly, these query languages require the queries to be posed against the underlying, sometimes complex, database schemas. These traditional querying methods are powerful but unfriendly to the non-expert users. Keyword search is proposed as an alternative means for querying the databases, which is simple and yet familiar to most internet users as it only requires the input of some keywords. While keyword search has been proven to be effective for text documents (e.g. HTML documents), the problem of keyword search on the structured data (e.g. relational databases) and the semi-structured data (e.g. XML databases) is not straightforward and well studied.
 name year paper
Keyword search in text documents take s as the answers the documents that are more interrelated with the input keywords, while in relational databases it takes the correlative tuples in the database that contain all (or a part of) the keywords as the answers. However, it still remains an open problem that, for XML documents, what should be the answer for keyword search? The notion of Lowest Common Ancestor (LCA) has b een introduced to answer keyword queries over XML documents [13]. And more recently, Meaningful LCA (MLCA), Smallest LCA(SLCA), Grouped Distance Minimum Connecting Tree(GDMCT) have been proposed to improve the efficien cy and effectiveness of keyword search against LCA in [22,28,16], respectively. However, the answer of keyword search should not be limited to just the LCAs, as LCAs themselves cannot explain how the keywords are connected. Although t he subtrees proposed in some existing methods [16,22], which are composed of LCAs and their relevant keywords, may be more meaningful as the answer of keyword search over XML documents, these subtrees are not meaningful enough to capture the overall structural information to answer keyword queries.

Intuitively, for keyword search over text documents, it is evident that the documents that contain all the keywords should be the answer. Furthermore, some other relevant and meaningful information is also contained in the answer. Similarly, for relational databases, the interrelated tuples connected by primary-foreign key relationships and containing all (or a part of) the keywords should be the answer. Moreover, some other rele vant and meaningful data besides the elements that contain some keywords are also adhered to those tuples by the way. However, for XML documents, it is not straightforward to retrieve the subtrees connected by the content nodes that directly contain s ome keywords. Accord-ingly, it is much harder to retrieve the integrated subtrees (like the documents and interrelated tuples) connected by the content nodes and complementary nodes that do not contain any keyword but contain some relevant and meaning-ful data as the complementarity to answer keyword queries meaningfully, since it is rather difficult to determine which nodes are complementary nodes and can be adhered to the answer. For example, in Figure 1, if a user inputs keywords of {  X  X ML X , X 2006 X , X  X LDB X  } , he expects to get the subtree circled by the double dotted lines as the answer, and the two authors should be adhered to the answer as they are complementary nodes and relevant to the keyword query.

Therefore, we in this paper investigate h ow to retrieve those subtrees, namely self-integrated trees, which contain s ome complementary nodes as the comple-mentarity to capture the focuses of keyword queries, besides the content nodes. More importantly, each self-integrated tree can represent an integrated meaning to answer a keyword query. In addition, t o accelerate the retrieval of those mean-ingful self-integrated trees, we introduce the B + -Tree index and Bloom Filter to improve the efficiency. To the best of our knowledge, this is the first paper to generate the meaningful self-integrat ed trees with complementary nodes as the answer of keyword search over XML documents.

To summarize, we make the following contributions,  X  We propose how to divide a data-centric XML document into self-integrated  X  We introduce the B + -Tree index and Bloom Filter to accelerate the retrieval  X  We conducted a set of extensive experiments to evaluate our method, and
The rest of this paper is structured as fo llows. Section 2 prop oses the meaning-ful self-integrated trees as the answer of keyword search over XML documents. We then introduce the B + -Tree index and Bloom Filter to accelerate the re-trieval of those meaningful self-integrated trees in Section 3. Section 4 provides the extensive experimental study. We r eview the related work in Section 5 and make a conclusion in Section 6. We first briefly outline the XML data model in Section 2.1 and then introduce the concept of Self-Integrated Trees in Section 2.2. Finally we give an efficient algorithm to generate those meaningful self-integrated trees in Section 2.3. 2.1 Overview An XML document can be modelled as a rooted, ordered, and labeled tree. We in this paper mainly consider the data-centric XML document, which has a concrete schema that is mainly used to describe how the structure information is organized. For instance, DBLP [1] is a typical data-centric XML document.
Most of existing studies take the subtr ees, which contain all the keywords (e.g., the conjunctive predicate) or a part of the keywords (e.g., the disjunctive predicate), as the answer of a given keyword query. They mainly first compute the lowest common ancestors (LCAs) of the content nodes that directly contain at least one keyword and then take the subtrees rooted at LCAs as the answer. However, they involve huge computation and thus lead to inefficiency. In addi-tion, the existing approaches cannot introduce some relevant nodes that do not contain any keyword into the answer. For example, in Figure 1, suppose, a user wants to retrieve the author of those papers, which are published in 2006 and entitled with a keyword  X  X ML X , but the user does not know how to input the keyword w.r.t. author ,as conf and journal have different structures about the tag/label of author . Thus, all the existing studies cannot deal with this situation as it is hard to select suitable keywords as input.

Therefore, we in this paper mainly discuss how to generate those self-integrated and meaningful subtrees, which capture all the relevant data, as the answers of keyword queries, even with limited keywords, over XML documents. 2.2 Meaningful Self-integrated Trees We introduce how to divide the XML document into different meaningful sub-trees. Each subtree itself can represen t an integrated meaning while different subtrees have little interrelationship. For example, in Figure 1, we can divide the XML document into three subtrees as circled by the dotted lines. We ob-serve that the three subtrees can describe i ntegrated meanings r espectively. Ac-cordingly, for any keyword query, if any of these three subtrees contains all the keywords, it should be an answer.

In addition, to meaningfully divide an XML document into some integrated subtrees, the division should capture the following properties, 1. Each subtree represents an integrated meaning and thus can capture all the 2. Each subtree contains some other relevant nodes as the complementarity to 3. All the subtrees can be generated an d indexed in advance, thus the answer, To achieve our goal, we give the concept of Self-Integrated Trees as follows. Definition 1 ( Self-Integrated Trees ) . Given a data-centric XML document D and its schema (or DTD) S , a Self-Integrated tree w.r.t. D and S is the subtree of D , which can represent an integrated and meaningful structural information. A self-integrated tree is a subtree of an XML document, which can represent an integrated meaning. For example, in Figur e 1, the three circled subtrees are self-integrated subtrees. A ccordingly, we take the meaningful self-integrated subtrees that contain all the keywords as the answer of a keyword query.

We can generate all the self-integrated subtrees according t othesemanticsof the schema as follows. We first analyze and divide the schema into meaningful parts according to the semantics, and accordingly divide the XML document into Algorithm 1: Merge-Join Algorithm some self-integrated subtrees based on the division of the schema. Moreover, all the self-integrated subtrees ca n be generated and indexed off-line.
In addition, for any term in the XML document, k i , the existing studies first retrieve the inverted lists of the content nodes w.r.t. k i , and then compute the LCA of each combination of the content nodes, finally return the subtrees rooted at LCAs as the answer. However, it is inefficient to compute all the LCAs as there are many combinations of the content nodes. Therefore, we in this paper propose a novel inverted index to accelerate the retr ieval of the meaningful self-integrated subtrees. We assign each self-integrate d subtree with a distinct identifier(ID), and then for any term, k i , we record the IDList of all the IDs which contain k i . In addition, we maintain the statistical information for k i , i.e., the number of IDs that contain k i , and this statistics will be us ed to accelerate the retrieval of the meaningful self-integrated subt rees in Section 3.2. Accordingly, given a and then compute SIIDSet = q i =1 I i , which is exactly the set composed of the IDs that contain all the keywords. Finally, we can retrieve the meaningful self-integrated subtrees as the ans wer according to those IDs in SIIDSet . 2.3 Algorithm to Generate the Mea ningful Self-integrated Trees We in this section introduce an efficient algorithm, Merge-Join , to generate the meaningful self-integrated trees. Without loss of generality, we suppose all the IDLists w.r.t. a keyword query are sorted by their IDs and thus we can merge-join these IDLists with one scan of each I DList to generate the intersection of these IDLists, which is composed of all the IDs that appear in every IDList. The detailed algorithm is illustrated in Figure 2.
 Merge-Join first retrieves the IDLists, each of which is composed of the IDs that contain a keyword (line 4), and then while each IDList is not empty (line 5), if an ID w.r.t. a self-integrated subtree appears in every IDList (line 6), the self-integrated tree w.r.t. it must contain all the keywords and thus this ID is added into SIIDSet (line 7). In addition, the first element of each IDList is popped from the corresponding IDList (lines 8-9). On the contrary, if the first element in an IDList, e.g., I j . first (), is smaller than that of another responding IDList (lines 10-12). To com pute the intersection of those IDLists, SIIDSet , we repeat these steps until one IDList is empty. Finally, we retrieve the meaningful self-integrated trees, SITreeSet , according to SIIDSet (line 13). 3.1 B + -Tree Indices We in this section propose the B + -tree index to accelerate the retrieval of the meaningful self-integrated trees. For a k eyword query, the sizes of keyword lists generally are not the same, and even the size of one keyword list is far less than those of the other ones. For example, suppose a user wants to retrieve the paper entitled with a keyword  X  X ML X  and having an author of  X  X om X . The number of the self-integrated subtrees w. r.t.  X  X om X  generally be far smaller than those w.r.t. title or author . Accordingly, some self-i ntegrated trees w.r.t. author and title , which cannot contain all the keywords, should not be in the answer, and therefore, we propose the B + -tree index to skip those self-integrated trees. However, the B + -tree index only improves the CPU cost while the bottleneck is the I/O cost to retrieve the self-integrated trees associated with the input keywords, and hence we present Bloom Filter to further improve the performance in the next section. 3.2 Bloom Filter We in this section propose Bloom Filter to improve the efficiency of retrieving the meaningful self-integrated trees. As we all know, Bloom Filter is a probabilistic method to quickly test membership in a large set by using multiple hash functions and thus is efficient to test whether an element is in a set, therefore, we borrow it to efficiently retrieve the meaningful self-integrated trees.

A Bloom Filter employs a vect or for representing a set of n elements (also called keys) so as to support membership queries. It was invented by Burton Bloom in 1970 [8] and was proposed for use in the web context by Marais and Bharat [24] as a mechanism for identifying which pages have associated com-ments stored within a common knowledge server.

The idea behind Bloom Filter is to allocate a vector v of m bits, initially all set to 0, and then choose k independent hash functions, h 1 , h 2 ,..., h k ,eachwith in v are set to 1 (A particular bit might be set to 1 multiple times.). Given a query for testing whether e is in the set, we check the bits at positions h 1 ( e ), h ( e ),..., h k ( e ). If any of them is 0, then certainly e is not in the set. Otherwise we conjecture that e is in the set although there is a certain probability that we are wrong. This is called a  X  X alse positive X , or, for historical reasons, a  X  X alse drop X . The parameters k and m should be chosen such that the probability of a false positive (and hence a false hit) is acceptable.

The salient feature of Bloom filters is that there is a clear tradeoff between m and the probability of a false positive. Observe that after inserting n keys into a Hence the probability of a false positive in this situation is,
The right hand side is minimized for k = ln 2  X  m/n , in which case it becomes (1 / 2) k =(0 . 6185) m/n .Infact k must be an integer and in practice we might chose a value less than the optimal to reduce computational overhead. In addition, we give two examples about this probability, for example, if m/n =20 and k =10, the probability is 8.89e-05. While if m/n =24 and k =8, the probability is 4.17e-05.
To achieve our goal to retrieve all the meaningful self-integrated subtrees according to bloom filter, we maintain a bloom filter for each self-integrated tree, and the bloom filter preserves the ke ywords in this self-integrated tree, that is, we insert all the keywords in this self-integrated tree into the set of the bloom filter. Accordingly, we can test whe ther a self-integrated tree contains all the keywords of a keyword query. However, there may be many candidate self-integrated trees but only few of them contain all the keywords. Therefore, we introduce an optimization to improve the retrieval of the meaningful self-integrated subtrees as follows. For each term, we record the number of the self-integrated trees that contain it and thus we can get the minimal IDList w.r.t. a keyword query, which has the minimal size. Subsequently we retrieve the bloom filters w.r.t. the self-integrated trees in the minimal IDList and then test whether each candidate self-integrated tree contains all the keywords, if so, this subtree should be an answer; otherwise it cannot be. Finally, we can generate all the meaningful self-integrated subtrees through filtering out false positives (if any). Moreover, we give the complexity of Bloom Filter here. Given a keyword query, K The I/O cost of the method based on bloom filter is to retrieve IDs in the minimal IDList, e.g., I 1 , and the corresponding bloom filters, thus it is very efficient when one keyword list has smaller size, e.g., |I 1 | q i =2 |I i | . Therefore, bloom filter improves the I/O cost significantly. In addition, the complexity of CPU is contained in a candidate self-integrated tree through computing hash values improves the efficiency of retrieving the meaningful self-integrated trees, and we will experimentally demonstrate that bloom filter in practice outperforms B + -tree, which in turns is better than Merge-Join in Section 4.
 Example 1. Given a keyword query {  X  X ML X , X 2006 X , X  X uthor X  } , and suppose |I bloom filter first retrieves the IDList of  X  X ML X , e.g., { 1,12,16,66,80 } , subse-quently, it needs to test whether  X 2006 X  and  X  X uthor X  are in these five candidate self-integrated trees. Each bloom filter w.r.t. a self-integrated tree preserves an m -bits vector, and we compute the hash values of the given k (here, e.g., 3) hash functions on  X  X ML X , and if one of the hash values is 0, the keyword  X  X ML X  is not in the self-integrated tree; otherw ise, the self-integrated tree may con-tain keyword  X  X ML X . Then, we test whether the candidate self-integrated trees, which contain both  X  X ML X  and  X 2006 X , contain keyword  X  X uthor X , if so, these self-integrated trees should contain a llthekeywordsandmaybetheanswer. We have designed and performed a compreh ensive set of experiments to evaluate the performance of our approach. We used the real dataset DBLP [1] in our ex-periments, and the raw file was about 340MB. The experiments were conducted on an Intel(R) Pentium(R) 2.4GHz co mputer with 512MB o f RAM running Win-dows XP Professional. The algorithms were implemented in Java and the parsing of the XML files was performed using the SAX API of the Xerces Java Parser. We compared our approach with the state-of-the-art approaches, GDMCT[16] and SLCA [28]. We implemented the Indexed Lookup Eager algorithm(IL) for SLCA since IL was the best one among the three proposed algorithms of SLCA.
Furthermore, to better understand the performance of our method on different keyword queries with various characteris tics, we selected several keyword queries with distinct keyword numbers from 2 to 6 , respectively. To further evaluate the performance of our algorithms for the key word queries with different selectivi-ties, we performed our experiments usin g various sets of keywords with different frequencies, namely low, medium and high, with respective keyword frequency range of 1 to 100, 101 to 10000, and above 10000. Accordingly, we varied the fre-quencies of keywords and computed the corresponding elapsed time to compare our methods with the existing approaches. 4.1 Evaluation of Our Three Methods We first evaluated our proposed methods, Merge-Join , B + -tree and Bloom Fil-ter, on different queries with various characteristics. In Figure 3, each query contains a keyword of small frequency (10 in Figure 3( a ),100 in Figure 3( b ), 1000 in Figure 3( c )), and all other keywords of keyword queries have high fre-quency of 1000,000. For example, each query of Figure 3( b )inthe#keywords=5 category contains five keywords where one of them has frequency of 100 and the other four have frequency of 1000,000.
 We can observe that, the performance of B + -treeismoreefficientthan Merge-Join as B + -tree can skip many irrelevant elements. Moreover, Bloom Fil-ter only depends on the minimal IDList with fewest elements but is essentially independent of other IDLists with high fr equencies, therefore, it outperforms B + -tree and Merge-Join significantly, especially when one keyword list has low frequency while others have high frequencies.

Keywords in Figure 4 have the same frequency as shown in the caption. B + -tree and Bloom Filter perform a little better than Merge-Join in most exper-iments since the former two algorithm s perform best when the frequencies of keyword lists vary greatly. While all the keyword lists in Figure 4 have the same size, thus B + -tree is a little better than Merge-Join as B + -tree lookup is more likely efficient than the scan of Merge-Join . In addition, Bloom Filter improves the I/O cost and thus is still better than the other two methods. 4.2 Comparison with the Existing Approaches We in this section compared B + -tree and Bloom Filter with the existing ap-proaches, and we still employed the keywo rd queries with different keyword fre-quencies and with the same keyword frequency as illustrated in Figure 5 and Figure 6 respectively. We can observe that both B + -tree and Bloom filter are better than GDMCT and SLCA, and Bloom Filter outperforms the other ap-proaches significantly when the keywords have distinct frequencies. In addition, although when the keywords have the same frequency or have little difference, our two methods still beat the other two existing approaches. More importantly, Bloom Filter outperforms all the other me thods for various keyword queries, and this further reflects that Bloom Filter ac hieves high efficiency and performs best for keyword search over data -centric XML documents. The first area of research related to ou r work is the computation of the LCA of two or more nodes, which has been studied in [14,27]. As an extension of LCA, MLCA, SLCA and GDMCT have recently been proposed to answer keyword queries over XML documents in [22], [28] and [16] respectively. On the other hand, XRANK [13] and XSEarch [12] are systems facilitating keyword search for XML documents, which return subtr ees as answers for the keyword queries. However, XRANK does not return connect ed trees to explain how the keywords are connected to each other. Furthermore, only the most specific result is out-put. They also present a ranking method, which, given a tree T containing all the keywords, assigns a score to T using an adaptation of PageRank for XML documents. Their ranking techniques are orthogonal to the retrieval method, and thus can easily be incorporated in other works. XSEarch focuses on the se-mantics and the ranking of the results, and during execution it uses an all-pairs interconnection index (i.e., for any two nodes in an XML document, it has to record whether they are interrelated or n ot) to check the connectivity between the nodes, which is not efficient for large XML documents and thus is imprac-ticable in practice. XKeyword [18] is a system that offers keyword proximity search over XML documents that confor m to an XML schema, however, it needs to compute candidate networks and thus is constrained by the schemas.
In addition, DISCOVER [17], BANKS [7] and DBXplorer [3] are systems built on top of relational databases. DISCOVER and DBXplorer output trees of tuples connected through p rimary-foreign key relationships that contain all the keywords of the query, while BANK S identifies connected trees in a la-belled graph by using an approximation to the Steiner tree problem, which is an NP-hard problem. More recently, Liu et al. [23] proposed a novel ranking strategy to solve the effectiveness problem for relat ional databases, which employs phrase-based and concept-based models to impro ve search effectiveness. While Kimefeld et al. [19] demonstrated keyword proximity search in relational databases, which shows that the answer of keyword proximity search can be enumerated in ranked order with polynomial delay, under data complexity.

Furthermore, various XML full-text query languages have also been proposed, such as, [4,9,20,21], and a workshop INEX [2], INitiative for the Evaluation of XML Retrieval, aiming at evaluating XML retrieval effectiveness, has also been organized. More recently, two algebras f or keyword search over XML documents have been proposed [5,26]. [5] presents the XFT algebra that accounts for element nesting in XML document structure to evaluate queries with complex full-text predicates, while [26] demonstrates several optimization techniques that guar-antees better efficiency for keyword sea rch over tree-structured documents. We propose the self-integrated trees to an swer keyword queries over data-centric XML documents. Each meaningful self-in tegrated tree contains all the keywords and can represent a compact and integrated meaning to answer keyword queries. More importantly, besides the content n odes which directly contain at least one keyword, the meaningful self-integrated tree still contains some other relevant nodes as the complementarity to explain how the keywords are connected and how the self-integrated tree answers the keyword query.

In addition, we propose the B + -tree index to accelerate the retrieval of all the meaningful self-inte grated trees. Moreover, we introduce Bloom Filter to further enhance the performance of retrieving those meaningful self-integrated trees, which can improve the I/O cost dramatically and thus achieves much higher efficiency. Finally, we conducted a set of extensive experiments and the experimental results demonstrate that our method achieves high efficiency and outperforms the existing approaches significantly.
 This work is in part supported by the National Natural Science Foundation of China under Grant No.60573094, the National Grand Fundamental Research 973 Program of China under Grant No.2006C B303103, the National High Technology Development 863 Program of China under Grant No.2006AA01A101, Tsinghua Basic Research Foundation under Grant No. JCqn2005022, Basi c Research Foun-dation of Tsinghua National Laboratory for Information Science and Technology (TNList), and Zhejiang Natural Sc ience Foundation under Grant No. Y105230.
