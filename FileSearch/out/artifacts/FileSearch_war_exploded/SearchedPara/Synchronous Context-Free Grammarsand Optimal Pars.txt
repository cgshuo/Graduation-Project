 University of Rochester Universit ` a di Padova length for a fixed grammar, but the degree of the polynomial depends on the grammar. Specifi-show that any algorithm for finding the strategy with the lowest time complexity would imply improved approximation algorithms for finding the treewidth of general graphs. 1. Introduction
Synchronous context-free grammars (SCFGs) generalize context-free grammars (CFGs) automata theory; it was developed under the name syntax-direct translation sche-mata to model compilers for programming languages (Lewis and Stearns 1968; Aho and Ullman 1969). SCFGs are widely used today to model the patterns of re-ordering between natural languages, and they form the basis of many state-of-the-art statistical machine translation systems (Chiang 2007).
 parsing problem for CFGs is rather well understood nowadays, our knowledge of the parsing problem for SCFGs is quite limited, with many questions still left unanswered. In this article we tackle one of these open problems.
 in length (Aho and Ullman 1972), as for instance in the well-known Chomsky normal parsing with SCFG depends on the grammar. More precisely, for a fixed SCFG, parsing is polynomial in the length of the string. The degree of the polynomial depends on the length of the grammar X  X  rules, the re-ordering patterns represented by these rules, as well as the strategy used to parse each rule. The complexity of finding the best parsing strategy for a fixed SCFG rule has remained open. This article shows that it is NP-hard to find the binary parsing strategy having the lowest space complexity. We also consider the problem of finding the parsing strategy with the lowest time complexity, and we show that it would require progress on long-standing open problems in graph theory either to find a polynomial algorithm or to show NP-hardness.
 adequate empirically (Huang et al. 2009). Longer rules are of theoretical interest because of the naturalness and generality of the SCFG formalism. Longer rules may also be of practical interest as machine translation systems improve.
 rule into a sequence of smaller steps, which we refer to as a parsing strategy . Each step of a parsing strategy collects nonterminals from the right-hand side of an SCFG rule into a subset, indicating that a portion of the SCFG rule has been matched to a subsequence binary if it combines two subsets of nonterminals at each step to create a new subset.
We consider the two problems of finding the binary parsing strategy with optimal time and space complexity. For time complexity, there is no benefit to considering parsing lowest complexity can be achieved with no factorization whatsoever; however, con-sidering binary parsing strategies can provide an important trade-off between time and space complexity. Our results generalize those of Crescenzi et al. (2015), who show NP-completeness for decision problems related to both time and space complexity for linear parsing strategies, which are defined to be strategies that add one nonterminal at a time.
SCFG rule, and relates the parsing problem to properties of the graph. Our results for space complexity are based on the graph theoretic concept of carving width , whose decision problem is NP-complete for general graphs. Section 3 relates the space com-plexity of the SCFG parsing problem to the carving width of a graph constructed from the SCFG rule. In Section 4, we show that any polynomial time algorithm for optimizing the space complexity of binary SCFG parsing strategies would imply a polynomial time algorithm for carving width of general graphs. Our results for time complexity are based on the graph theoretic concept of treewidth . In Section 5, we show that any polynomial time algorithm for the decision problem of the time complexity of binary
SCFG strategies would imply a polynomial time constant X  X actor approximation algo-rithm for the treewidth of general graphs. In the other direction, NP-completeness of the decision problem of the time complexity for SCFG would imply the NP-completeness of treewidth of general graphs of degree six. These are both long-standing open problems in graph theory. 2. Synchronous Context-Free Grammars and Parsing Strategies
In this section we informally introduce the notion of synchronous context-free grammar and define the computational problem that we investigate in this article. We assume 208 summarize the adopted notation. Throughout this article, for any positive integer n we write [ n ] to denote the set { 1, ... , n } . 2.1 Synchronous Context-Free Grammars
As usual, a CFG has a finite set of rules having the general form A  X   X  , where A is symbols. A synchronous context-free grammar is a rewriting system based on a finite set of so-called synchronous rules. Each synchronous rule has the general form [ A  X  , A 2  X   X  2 ], where A 1  X   X  1 and A 2  X   X  2 are CFG rules. By convention, we refer to
A 1  X   X  1 and A 2  X   X  2 as the Chinese and English components of the synchronous rule, respectively. Furthermore,  X  1 ,  X  2 must be synchronous strings. This means that there exists a bijection between the occurrences of nonterminals in  X  nonterminals in  X  2 , and that this bijection is explicitly provided by the synchronous rule. Nonterminal occurrences that correspond under the given bijection are called linked nonterminal occurrences, or just linked nonterminals when no ambiguity arises. We assume that linked nonterminals always have the same label.
 where A , B are nonterminal symbols and a , b , c , d are terminal symbols. We have indi-cated the bijection associated with the synchronous rule by annotating the nonterminal occurrences with natural numbers, with the intended meaning that linked nonterminals get the same number. We refer to this number as a nonterminal X  X  index . of a pair of strings by the SCFG. In fact, in an SCFG we can only apply a synchronous rule to linked nonterminals. To illustrate this, we use our running example and consider synchronous rule to the linked nonterminals, written
Note that we have renamed the indices in the synchronous rule to make them disjoint from the indices already in use in the synchronous string to be rewritten. Although this is unnecessary in this first derivation step, this strategy will always be adopted to avoid conflicts in more complex derivations. We can move on with our derivation by applying once more our synchronous rule to rewrite the linked A nonterminals, obtaining In this derivation, the renaming of the indices is crucial to avoid conflicts.
Using our notion of derivation, one can start from [ S 1 , S of strings [ u , v ] entirely composed of terminal symbols. Whenever this is possible, we say that [ u , v ] is in the translation generated by the SCFG, meaning that v is one of the possible translations of u . Example 1
Consider the following list of synchronous rules, where symbols s used later as references
What follows is a valid derivation of the SCFG, obtained by rewriting at each step the linked nonterminals with the Chinese component occurring at the left-most position in the sentential form
It is not difficult to see that the given SCFG provides the translation { [ a d c q b p a p ] | p , q  X  1 } .
 what we do with CFG derivations. More precisely, an SCFG derivation is represented
Furthermore, linked nonterminals in the SCFG derivation are annotated in the parse trees to indicate the place of application of some synchronous rule.
 Example 2
The SCFG derivation for string pair [ aaabbbccdd , ddccbbbaaa ] in Example (1) is associated with the following tree pair: 210 tion of the (occurrences of the) nonterminal symbols in the two rule components. More precisely, the nonterminals in the right-hand side of the Chinese rule component are re-used in the right-hand side of the English component, but with a different ordering, as defined by the bijection associated with the rule. This reordering is at the core of the translation schema implemented by the SCFG. We will often use the permutation view of a synchronous rule in later sections.
 have the same label. In natural language processing applications, this is by far the most common assumption, but one might also drop this requirement. The results presented in this article do not rest on such a restriction. 2.2 Parsing Strategies
The recognition and the parsing problems for SCFGs are natural generalizations of the same problems defined for CFGs. Given an SCFG of interest, in the recognition problem one has to decide whether an input pair [ u , v ] can be generated. In addition, for the parsing problem one has to construct a parse forest, in some compact representation, programming techniques are used, it turns out that recognition and parsing algorithms are closely related, since the elementary steps that are performed during recognition can be memoized and later used to construct the desired parse forest.
 erable gap in the space and time complexity for recognition and parsing based on these two classes. More specifically, for a fixed CFG, we can solve the recognition problem in time cubic in the length of the input string, using standard dynamic programming techniques. In contrast, for a fixed SCFG we can still recognize the input pair [ u , v ] in polynomial time, but the degree of the polynomial depends on the specific structure of the synchronous rules of the grammar, and can be much larger than in the CFG case. A similar scenario also holds for the space complexity. The reason for this gap is informally explained in what follows.
 notion is the one of parsing strategy. Recognition algorithms can be seen as sequences of elementary computational steps in which two parse trees that generate non-overlapping act order in which these elementary steps should be carried out. Generally speak-constructed.
 of Kay (1980). The algorithm adopts a parsing strategy that visits the nonterminals in the right-hand side of a rule one at a time and in a left-to-right order, combining the associated parse trees accordingly. Parse trees are then compacted into so-called chart edges, which record the two endpoints of the generated substring along with other grammar information. Chart parsing can be generalized to SCFGs. However, in the latter case parse trees no longer generate single substrings: They rather generate tuples with several substrings. This can be ascribed to the added component in synchronous rules and to the re-ordering of the nonterminals across the two components. will be formally defined later). It is well-known among parsing practitioners that the connected to the space and time performance of the algorithm. A binary parsing strat-egy of fan-out  X  has space complexity O ( n 2  X  ) and time complexity at most O ( n where n is the sentence length (Seki et al. 1991; Gildea 2010). If we adopt the appropriate parsing strategy, we can reduce the fan-out, resulting in asymptotic improvement in the space and time complexity of our algorithm. To illustrate this claim we discuss a simple example.
 Example 3
Consider the synchronous rule The permutation associated with this rule is schematically visualized in Figure 1. a time and in ascending order of k . For instance, at the first step we combine B attested when we construct the parse tree consisting of occurrences B has a fan-out of 4.
 of a tree. This time, at the first step (node n 1 in Figure 3a. At the second step (node n 3 ), we combine the result of node n again constructing a parse tree with fan-out three, as depicted in Figure 3b, and so on.
This strategy is non-linear, because it might combine parses containing more than one nonterminal occurrence each; see Figure 3c. From Figure 1 it is not difficult to check that at each node n k the constructed parse has fan-out bounded by 3. We therefore conclude that our second strategy is more efficient than the left-to-right one.
 212 rule depends on the adopted parsing strategy. In order to optimize the computational resources of a parsing algorithm, we need to search for a parsing strategy that minimizes the maximum fan-out of the intermediate parse trees. The problem that we investigate in this article is therefore the one of finding optimal parsing strategies for synchronous rules, where in this context optimal means with a value of the maximal fan-out as small as possible. 2.3 Fan-out and Parsing Optimization to precisely define the computational problem that is investigated in this article. the i th occurrence (from left to right) in the right-hand side of the Chinese component component of s . Each pair  X  h , i  X  , h  X  [2] and i  X  [ r ], is called an occurrence . nent are indexed sequentially. That is, the index of  X  1, i  X  is i . Let  X  be the permutation internal node of  X  s represents the operation of combining the linked pairs below the left node with the linked pairs below the right node. These operations must be performed in a bottom X  X p fashion.
 number of right and left boundaries in y ( n ).
 the substrings in the rule components of s that are spanned by the occurrences in y ( n ).
Dividing this total number by two provides the number of substrings spanned by the occurrences in y ( n ). We therefore define the fan-out at node n as strategy provides space and time bounds for a dynamic programming parsing algo-rithm adopting that strategy. Given an input synchronous rule s , we wish to find the parsing strategy that minimizes quantity where  X  ranges over all possible parsing strategies for s , and n ranges over all possible nodes of  X  . One of the two main results in this article is that this optimization problem is NP-hard. 3. Cyclic Permutation Multigraphs and Carving Width properties of a specific graph derived from the rule X  X  permutation.
 be several occurrences of a given element. We use ] as the merge operation defined for multisets: This operation preserves the number of occurrences of the merged multisets. 214 vertices.
 P vertices in V exactly once. In the following, the edges in A will be called red and the edges in B will be called green . Our definition is based on the permutation multigraphs of Crescenzi et al. (2015), which differ in that they consist of two acyclic Hamiltonian paths.
 i  X  [ r ], along with (  X  1, 0  X  ,  X  2, 0  X  ), form the vertices of M in the English component.
 a corresponding SCFG rule by, first, choosing an arbitrary vertex as representing the left-hand side nonterminal, and then following the red cycle to obtain the sequence of Chinese nonterminals, and finally following the green cycle to obtain the sequence of English nonterminals.
 Example 4
Consider the SCFG rule s of Equation (1) in Example (3). Figure 4 shows the
English component (green edge). Note that, as a special case, we consider the linked (  X  1, r  X  ,  X  2,  X   X  1 ( r )  X  ) and (  X  1,  X  ( r )  X  ,  X  2, r  X  ).
 complement set of S , that is, S is the set of linked pairs from M to see that the multiset of edges connecting S and S corresponds to the set of boundaries of any parse tree associated with the linked pairs in S . We can apply this property to parsing strategies, which we have previously defined as rooted binary trees, in order to count the boundaries that are open after completing some parsing step represented by an internal node n , which we have defined as bd ( n ). Consider for instance the parsing strategy shown in Figure 2, and consider the internal node n collected nonterminals B 2 , B 3 , and B 4 , and we have bd ( n can see that the number of edges of the multigraph that connect S with S is six, that is, exactly the value of bd ( n 3 ). In order to express these observations in a mathematical way, we need to introduce the notions of tree layout, width, and carving width, which we borrow from graph theory.
 vertex of G at each leaf. To avoid confusion, in what follows we use the term node when referring to vertices of layout trees and we use the term arc when referring to edges of layout trees. Edges of G are routed along the arcs of T . A simple example is provided in Figure 5, showing a graph G and a tree layout T of G .
 through that arc. We define this notion more precisely in what follows. We start with some auxiliary notation. Let V be the set of vertices of G and let S be any subset of V . in S and vertices in the complement set S = V \ S . Let a be an arc in a tree layout T of G , and let T 1 and T 2 be the two components of the graph obtained by removing a from T .
Let also L ( T 1 ) be the subset of V appearing at the leaves of T number of edges in G that cross between T 1 and T 2 :
The maximum width among all of the arcs of T is the carving width of T . The carving width of T in Figure 5 is 3. The carving width of G is the minimum carving width over all possible tree layouts of G : 216 given integer is an NP-complete problem (Seymour and Thomas 1994). Throughout this article, we extend to multigraphs all of the discussed notions of tree layout, width, and carving width, in the obvious way. Because graphs are a subset of multigraphs, carving width of multigraphs is also an NP-complete problem.
 show an important property that relates the notions of fan-out (equivalently, boundary count) and carving width. Let s be an SCFG rule with r linked pairs. Recall that a parsing strategy for s is a rooted binary tree where each leaf node is a linked pair representing some nonterminal from the right-hand side of s . We attach to the root of our parsing resulting tree has r + 1 leaves, and can therefore be used as a tree layout for the cyclic permutation multigraph M s encoding s . Furthermore, each internal node of the tree layout is associated with a parsing step.
 Example 5
Consider the SCFG rule s in Equation (1) and the associated cyclic permutation multi-graph M s shown in Figure 4. Consider also the parsing strategy  X 
Figure 2. By attaching the linked pair (  X  1, 0  X  ,  X  2, 0  X  ) to the root node of  X  tree layout T for M s , which is shown in Figure 6. Observe that every linked pair (vertex) and the edges of M s are routed along arcs of T . Let a be an arc of T and let n be the node below a , with respect to the root node. Observe how edges that are routed along a correspond to boundaries that are open at the associated step n of the parsing strategy  X  s . Lemma 1
The minimum fan-out of any parsing strategy of an SCFG rule s is half of the carving width of the cyclic permutation multigraph constructed from s .
 Proof
Let M s be the cyclic permutation multigraph derived from s . Consider a parsing strategy  X  for s . We construct a tree layout T M leaf node for the left-hand side nonterminal to the root of  X  permutation multigraph is placed at the corresponding leaf of the tree layout. When the two nonterminals sharing a given boundary are combined, the edge representing the boundary is routed along the two arcs below the node for this combination. The edges representing the left-most and right-most boundaries of the rule X  X  Chinese and
English components are routed through the node for the parsing strategy X  X  root, because they must continue through the root to reach the leaf representing the left-hand side nonterminal. At each arc a of T M the right-hand side of Equation (2), and thus half the carving width of T the fan-out of  X  s .
 constructed from T M side of s , and choosing the adjacent node as the parsing strategy X  X  root. As before, the fan-out of  X  s is half the carving width of T M is also the minimum carving width over all tree layouts. 4. Carving Width of Cyclic Permutation Multigraphs
In this section, we reduce the problem of carving width of general graphs to the problem of carving width of cyclic permutation multigraphs, defined in Section 3. This reduction involves constructing a cyclic permutation multigraph from an input graph as outlined in Section 4.1. The details of the construction are given in Section 4.2, and the proof of NP-completeness for carving width of the resulting multigraphs is given in Section 4.3. parsing strategy for an SCFG rule is an NP-hard problem. 4.1 General Idea
Suppose that we are given an instance of the general carving width problem, consisting of a graph G and a positive integer k , where we have to decide whether the carving integers in [ n ], where n  X  2 is the number of vertices of G . Our reduction consists in the construction of a cyclic permutation multigraph M such that the carving width of M is equal to 4 k if and only if the carving width of G is equal to k .
 with a gadget in M consisting of two components. The first component is a grid-like component is a grid-like graph G i of 4 k rows and 4 k columns. Besides the edges of the grids X i and G i , M also includes some extra edges, called interconnection edges . For each i  X  [ n ], there are some interconnection edges connecting G 218 and X j .
 red and green paths within M , so that M satisfies the definition of cyclic permutation multigraph. Second, the connections between component pairs X structure of the source graph G , as will be explained in more detail later. This second condition guarantees that an optimal tree layout T M optimal tree layout T of G , by placing each X i and G i component under the leaf node schematically depicted in Figure 7. 4.2 Construction
In this section, we define precisely the grid-like graphs X source graph G , and outline the overall structure of the cyclic permutation multigraph
M constructed from G . whenever we reach a vertex i , we continue our path by arbitrarily choosing an edge
Algorithm 1 Procedure for depth-first traversal of G starting at i 1: procedure DFS( i ) 2: append i to path 3: if each edge ( i , j ) has already been visited then 4: return 5: for each edge ( i , j ) not already visited (in arbitrary order) do 6: DFS( j ) 7: append i to path 8: return  X  1, 2, 5, 2, 1, 3, 6, 3, 7, 4, 1, 4, 7, 3, 1  X  . been visited, we backtrack to previous vertices of our path, until we reach edges that have not already been visited. The path construction stops when we reach the starting vertex and all of the edges of G have been visited. Algorithm 1 provides a recursive global variable initialized as the empty sequence of vertices. A simple example is also shown in Figure 8.
 following properties.
The first bullet says that each edge of G is traversed exactly twice, the first time in one direction and the second time in the opposite direction. The second bullet is a direct consequence of the first bullet. These properties will be used in the specification of cyclic permutation multigraph M . rows and 2 d i columns. In addition to the edges of the grid, X of interconnection edges that connect X i to component G depicted in Figure 9. (A complete example for components X later.) let g ( i ) m , n be the vertex in the m th row and n th column of G 220
Overall, this specification provides 4 d i edges connecting X later, 2 d i of these edges belong to the red path and 2 d involved, because we need to reproduce the topology of G and, at the same time, we need to construct a red and a green path within M . For each vertex j that is a neighbor of vertex i in G , we add two red edges between the left column of X column of X j , and two green edges between the top row of X
X neighbors of i is induced from the depth-first traversal of G specified by Algorithm 1 in Section 4.2.1.
 input, so that i 1 = i 2 m + 1 = 1. We use a function df  X  counts the number of interconnection edges already established for the left column before the k th edge ( i k , i k + 1 ) of  X  is processed. In this way, df available position in the left column (equivalently, top row) of X edge of  X  .
 is used to enter grid X 1 for the first time, and is therefore placed at vertex x all other edges of  X  that are placed at X 1 need to be shifted by one position. This means have to treat the case of i = 1 and k = 2 m in a special way.
 tion 4.2.1 that, for an edge ( i , j ) of G , there exists a unique k such that i in  X  , and there exists a unique k 0 such that i k 0 = j and i connection edges between X i and X j : two edges from when the depth-first traver-sal first explores the edge from i to j , and two edges from when the depth-first traversal travels back from j to i . This amounts to 4 d grid X i . 4.2.3 Component G i . We now turn to (multi)graph G i , i  X  [ n ], which embeds a square grid with 4 k rows and 4 k columns; here k is the positive integer in the input instance of the carving width problem in our reduction; see Section 4.1. We have already introduced we need to double some occurrences of the edges internal to the grid G connect the red and green paths within M . We remind the reader that M is defined as a multigraph; therefore we can introduce multiple edges joining the same pair of vertices (red or green) to two edges joining the same pair of vertices. An overall picture of G schematically presented in Figure 10 for d i = 3 and k = 5.
 222
This set of edges form the red extra edges of G i . Symmetrically, for each red extra edge ( g has row and column reversed for both endpoints. Example 6 We now provide an example that uses the specifications in this and the previous section.
Consider the graph G in Figure 5, and let k = 4. Assume the depth-first traversal of G the cyclic permutation multigraph M shown in Figure 11.
 Because d 3 = 3, X 3 has size 6  X  6. Because vertex 3 is connected to vertices 1, 2, and 4 in G , grid X 3 has two red and two green interconnection edges to each of the components
X , X 2 , and X 4 . Consider now all the edges of G impinging on vertex 3. These edges when visiting the first column of X 3 from top to bottom, we touch upon the red interconnection edges for grids X 2 , X 4 , X 4 , X 1 , X found for the green interconnection edges, when visiting the first row of X right.

G in M . We have 2 d 3 = 6 red interconnection edges connecting G the  X  (3) p edges of Section 4.2.2, for p  X  [6]. Each edge  X  g , and edge  X  (3) 6 impinges on vertex g (3) 8,1 . A symmetrical pattern is seen for the green interconnection edges  X  (3) q , q  X  [6], connecting G 3 and X 224 4.2.4 Cyclic Permutation Multigraph M. To summarize the previous sections, the cyclic permutation multigraph M contains components X i and G i components X i and G i , M also contains some interconnection edges. More precisely, for each vertex i of G , M contains 2 d i red edges  X  ( i ) p and G i . Furthermore, for each edge ( i , j ) of G , M contains two red edges and two green edges connecting X i and X j .
 mentioned above form a red Hamiltonian cycle and a green Hamiltonian cycle over the vertices of M . We start by observing that, within each component G are symmetric, in the sense that the green Hamiltonian cycle can be obtained from the red Hamiltonian cycle by switching the first and the second indices of each vertex in an edge. In other words, within G i the green Hamiltonian cycle can be obtained from the red Hamiltonian cycle by a rotation along the axis from vertex g is also apparent from Figure 10. A similar observation holds for the components X apparent from Figure 9, and for the interconnection edges. For this reason, we outline in the following only the red Hamiltonian cycle of M .
 first traversal of G specified by Algorithm 1 in Section 4.2.1. Each time the depth-first traversal visits node i of G , the red cycle travels across one row of X then passes through G i , and then travels across the next row in X
Exactly how the red cycle travels through G i differs for the first d visited and the final time; see Figure 10. The first d i  X  1 times that G cycle travels from left to right across one row, descends to the next row, and traverses it follows. It travels left to right across row 2( d i  X  1) + 1 of G 2 k  X  2( d i  X  1)  X  1 rows in the upper half of G i . Upon reaching vertex g from its right and proceeding to the left, the red cycle moves to g internal to the grid. This choice is designed to ensure, for reasons that will become clear later, that none of the extra edges added to the grid underlying G grid X  X  four quadrants.
 and then zig-zags across the next 2 k  X  1 rows of the lower half of G vertex g ( i ) 4 k ,1 , the red cycle jumps to vertex g ( i ) toward the right to reach g ( i ) 2 k + 1,2 k , moves to g and finally proceeds toward the left to reach g ( i ) 2 k ,1 by the red cycle.
 the bottom row of X i to reach vertex x ( i ) 2 d the next vertex j of G in the depth-first traversal, as already mentioned. 4.3 NP-Completeness cyclic permutation multigraph is less than or equal to a given integer is an NP-complete problem. We develop this result by means of several intermediate lemmas, reducing from the carving width decision problem for a general graph. Throughout this section, we assume that G , k , and M are defined as in the previous sections.
 Lemma 2
Within a tree layout T M of M , we can organize all vertices of G a (connected) subtree T G the width of any arc internal to T G remaining nodes of T M .
 Proof
It has been shown by Kozawa, Otachi, and Yamazaki (2010) that the carving width of an m  X  m grid with m even is m . We adapt here their construction to show the statement of the lemma.
 shown by black dotted lines in Figure 12. Consider first the upper left quadrant. We build a linear subtree T UL by adding vertices of this quadrant one at a time in column major order. More specifically, we add columns of the quadrant from left to right, and we add vertices within each column from top to bottom, as shown Figure 12. We use symmetrical constructions for the bottom left quadrant, the bottom right quadrant, 226 and the upper right quadrant of G i , resulting in the linear trees T respectively. The top-most nodes of the linear trees T UL node n L ; similarly, the top-most nodes of T UR and T BR and n L and n R are connected together. This completes the specification of the tree layout T remaining nodes of the tree layout T M . See again Figure 12.
 the width of any arc connecting T UL to the remaining nodes of T has 4 k 2 leaf nodes and 4 k 2 internal nodes. Let us name the internal nodes of T bottom to top, using integers in [4 k 2 ] in increasing order. Because the width of T not decrease at the increase of d i , in what follows we consider the worst case of d 4 k edges of G i , namely, the interconnection edges of G to arc (1, 2) of T UL , we lose the two interconnection edges impinging on vertex g but those edges are replaced by two new internal edges of G and ( g ( i ) 1,1 , g ( i ) 1,2 ). Therefore, arc (1, 2) of T T impinging on the newly added vertex of G i replaced by two new edges of G on the same vertex. This process goes on until we reach the arc that connects node 4 k (the top-most node of T UL ) to node n L . This arc routes the 4 k edges of the upper left quadrant that reach the upper right quadrant and the lower left quadrant. of the three remaining quadrants of G i . Because the trees T metrical to T UL , the former trees must also have an upper bound of 4 k on the width of their internal arcs as well as on the width of the arcs connecting these trees to the remaining nodes of T M . Finally, we observe that the arc connecting nodes n routes 4 k edges of G i , namely the edges from the two left quadrants to the two right quadrants.

G . Therefore, the analysis provided in the proof of Lemma 2 can also be used to prove the next lemma.
 Lemma 3
Within a tree layout T M of M , we can organize all vertices of X subtree T X arc internal to T X of T M .
 immediately above x ( i ) 1,1 as top-most, and the node immediately above x most. We can now prove the correctness of our reduction for one direction. Lemma 4 If G has a tree layout T of carving width k , then M has a tree layout T width 4 k .
 Proof
Each leaf node of T is associated with a vertex i of G . The main idea of this proof is to construct a tree layout T M by using T as the top level of T tree layout for each grid X i and G i under the node of T associated with vertex i . As an example, for the cyclic permutation multigraph M of Figure 11, this will provide the tree layout schematically depicted in Figure 7.
 tree layout T ( X i ) from Lemma 3. The connection arc is created from the bottom-most internal node of subtree T UL of T ( G i ), to the top-most node of T ( X
T ( X i ) is in turn connected to the tree layout T for G . The connection is established by merging the bottom-most internal node of T ( X i ) and the leaf node of T associated with vertex i of G .
 width at most 4 k . The edges of M that are routed through the arc connecting T ( G
T ( X i ) are exactly the 4 d i  X  4 k interconnection edges between G
M routed through the connection between T ( X i ) and T are the 4 d edges between X i and all the X j for j a neighbor of vertex i in G . Finally, the top-level subtree T within T M also has carving width at most 4 k . To see this, observe that for each used as a subtree of the tree layout T M routes two red and two green edges connecting components X i and X j of M . Because the carving width of the tree layout T of G is k , we conclude that the carving width of the tree layout T within T show that if M has a tree layout of carving width 4 k , then G has a tree layout of carving width k . This will be Lemma 8, for which we will need to develop a few intermediate lemmas. We introduce our first intermediate lemma by means of a simple example. Example 7 subtree of a tree layout T M of M . Let a be the arc that connects the bottom right quadrant of the grid to the remainder of the layout. Using the notation in the proof of Lemma 2, arc a can be written as ( n R , n BR ), with n BR the top-most node of linear tree T that there are 4 k edges of M routed through arc a (in Figure 12 we have k = 3). These are the 2 k red edges that connect the bottom right quadrant with the bottom left quadrant of G i , and the 2 k green edges that connect the bottom right quadrant with the top right quadrant. These 4 k edges of M are all internal to grid G vertices within G i . Finally, observe the subtree rooted at node n from G i .
 the choice of the tree layout T M . In fact the next lemma shows that, for every choice of a tree layout of M having carving width 4 k , and for every grid G always exists an arc that satisfies the properties of Example 7. Intuitively, this happens when we pick up a sufficiently large set of vertices of a grid G of edges connecting the vertices in our set to the remaining vertices of G means that, in any tree layout T M , any subtree T i containing a sufficiently large set of vertices of G i must route a large number of edges from G
T to the rest of T M . If T M has bounded carving width, the edges routed through arc a saturate the width of this arc, making it impossible for other vertices not from G placed within T i . In other words, there is always some core set of vertices from G is placed in some subtree of a tree layout of M , and this subtree must exclude vertices from other grids. 228 Lemma 5 an arc a i of T M satisfying all of the following properties: (i) The width of a i is 4 k . (ii) The edges of M routed through a i are all internal to grid G (iii) One of the two subtrees obtained by removing a i from T (iv) The subtree below a i contains at least 4 k 2 vertices from G Proof
For a subtree T of T M , let L i ( T ) be the number of vertices of G T . Consider an arc a of T M , and let T 1 and T 2 be the two subtrees of T removing a from T M ; this is exemplified in Figure 13. We say that a is balanced for G if the choice of a minimizes | L i ( T 1 )  X  L i ( T 2 ) | .
 Yamazaki (2010, Lemma 3.1). Assume that a is a balanced arc in T be the number of vertices of G i . Without loss of generality, we assume that L
L ( T 2 ). Because | G i | = L i ( T 1 ) + L i ( T 2 ), this implies L must have L i ( T 1 ) &gt; 1, otherwise a would not be balanced. Then the root of T have two children, rooting subtrees T 0 1 and T 00 1 of T
L implies L i ( T 2 )  X  1 3 | G i | . To summarize these inequalities, we have
For each vertex i of G , we now choose a i in the statement of the lemma to be a balanced arc for G i . In the following discussion we focus on an arbitrary choice of i  X  [ n ], and again we let T 1 and T 2 be the two subtrees of T M obtained by removing a
L ( T 1 )  X  L i ( T 2 ), so that we can use Equation (6). that, for any choice of s nodes from S with 1 3 | G i | X  s  X  1 of S connecting the chosen nodes to nodes in the complement set. For this claim, see claim must also be true for the edges internal to G i , since G
Equation (6) we then have that at least 4 k edges internal to G
Furthermore, since T M has carving width 4 k , the width of a conclude that conditions (i) and (ii) are both satisfied.
 specification in Section 4.2 that the sub-multigraph of M induced by N (This is the very reason why we introduced the components X
M .) This implies that for any pair of vertices in N i , there exists a path in M connecting the two vertices that is entirely composed of edges that are not internal to G
T and T 2 have some vertex from N i , there would be an edge not internal to G through a i , in contrast to condition (ii). We therefore conclude that one among T subtree below a i .
 thermore, 4 k 2 &lt; 1 3 | G i | , and hence both T 1
Assume that 2 d vertices in the left-most column of Q and 2 d vertices in the top-most row of Q have been selected as connector vertices . Observe that the number of connector corner of Q is selected twice or not. Let S be any subset of the vertices of Q . Recall from
Section 3 that the edge boundary of S in Q , written  X  Q ( S ), is the set of edges of Q that connect vertices in S and vertices in S , the complement set of S .
 Lemma 6 left-most column and 2 d connector vertices in the top-most row of Q . Let also S be a set of vertices of Q such that | S | X  4 k 2 and S does not contain any connector vertex. Then |  X  ( S ) | X  4 d .
 Proof
We distinguish three cases in the following, depending on whether the set S contains any entire column and/or any entire row of Q .

Propositions 4.4, 4.5, and 4.7].) Let r be the number of rows of Q that have at least one column of Q is not in S . This means that at least one edge of this row is in the set  X  for a total of r edges in  X  Q ( S ). A similar argument applies to the number of columns c of Q that have at least one vertex in S .
 is well known that the arithmetic mean ( r + c ) / 2 is always larger than or equal to the geometric mean 4 k  X  4 d . 230 at least one entire row of Q but no entire column. In the first case we have r = 4 k and, we have c = 4 k and thus 4 k  X  4 d edges in  X  Q ( S ).
 case each row of Q has at least one vertex in S . Because the connector vertices are all contained in the set S , each of the 2 d rows of Q that have a connector vertex contributes at least one edge to the set  X  Q ( S ). A symmetrical argument applies to the 2 d columns of Q that have a connector vertex. Again, because the rows and the columns of Q have disjoint edges, we conclude that |  X  Q ( S ) | X  4 d .
 each vertex i of G with an arc a i of T M having some specific properties. Similarly, our next lemma associates each edge ( i , j ) of G with a set of four paths in T are routed through a i and through a j , and do not share any of their edges. Using this property, we will later be able (in Lemma 8) to derive the carving width of G from the carving width of M . We use a simple example here to illustrate the special paths we are looking for.
 Example 8 we have d i = k = 3. We report G i in Figures 14 and 15, where for convenience we have layout that connects the bottom right quadrant of G i to the remainder of the layout. associate four paths with each neighbor, for a total of 12 paths routed through a more precisely, the segment of these paths that starts at an edge of M routed through a and ends at some edge of M that leaves G i to reach grid X starting with the red edges that connect the bottom right quadrant with the bottom left quadrant of G i . These paths reach the six vertices in the left-most column of G connected with the grid X i and will eventually reach the grids X through arc a i , starting with the green edges that connect the bottom right quadrant with the top right quadrant of G i . These paths reach the six vertices in the top-most row of G that will eventually reach the grids X j and G j for each neighbor j of i . the top left quadrant of G i but do not share any of their edges. To see this, consider the diagonal of the top left quadrant from the bottom left corner to the upper right corner.
Notice then that the paths in Figure 14 use the vertical edges of G the paths in Figure 14 use the horizontal edges above the diagonal, and the paths in Figure 15 use the vertical edges above the diagonal.
 T
M we can associate each edge ( i , j ) of G with a set of four paths in M that are edge disjoint. We need to introduce some auxiliary notation. Let T as in Lemma 5. Consider an arc ( i , j ) in the source graph G . A path in M is called an ( i , j ) -path for T M if it starts at a vertex inside the subtree below a the definition of this subtree) and it ends at a vertex inside the subtree below a say that two paths in M are edge disjoint if they do not share any edge (they might however share some vertex). 232 Lemma 7
Let T M be a tree layout of M having carving width 4 k . There exists a set P of paths in M satisfying both of the following properties: (i) For every edge ( i , j ) in the source graph G , P contains four ( i , j )-paths for (ii) Every two paths in P are edge-disjoint.
 Proof
We call connector edges the edges of M that are not internal to any component G i  X  [ n ]. We call connector vertices those vertices of G connector edge. In this way, each G i has 4 d i  X  1 connector vertices. These are placed in the left-most column of G i and in the top-most row of G i the connector vertices of G i must all be outside of the subtree of T let us assume that some connector vertex of G i is found inside the tree below a connector vertices are connected to vertices outside of G internal to G i inside the tree below a i , against Lemma 5(iii), or else there would be a connector edge routed through a i , against Lemma 5(ii). We therefore conclude that the connector vertices of G i must all be outside of the tree below a of three sub-paths, called segments , specified as follows.
From now on, we focus on a specific vertex i of G and prove the existence of 4 d specifying the three segments of the paths.
 through arc a i . We know that k  X  d i , since the carving width of a graph is always at least its degree. Thus we start our segments with any choice of 4 d through arc a i . We now show that these edges can be extended to 4 d the 4 d i  X  1 connector vertices of G i , without sharing any of their edges. We do this by reducing our problem to a network flow problem.
 to a flow through G i having capacity one. The existence of 4 d is then equivalent to the existence of a flow of capacity 4 d the 4 d i  X  1 connector vertices of G i . Let V ( G i ) be the set of vertices of G min-cut theorem states that this flow can be realized if and only if any cut of G source vertices on one side and the target vertices on the other side has capacity not less than 4 d i .

V ( G i ) be a vertex set including all the vertices in the subtree below a the 4 d i  X  1 connector vertices of G i . If we can show the relation for any choice of S as before, then we have proved the existence of the desired 4 d disjoint segments.
 below a i has size greater than or equal to 4 k 2 , by Lemma 5(iv). Furthermore, observe that there are 2 d i connector vertices of G i in the left-most column of Q as well as 2 d connector vertices in the top-most row. Under these conditions, we can apply Lemma 6 to the grid Q , with d = d i  X  k , and derive Equation (7). We then conclude that there exist 4 d edge disjoint first segments starting at vertices in the subtree below a the left-most column of G i there is a red segment to some connector vertex in the left-most column of G j , where j is some neighbor of i in G . Symmetrically, for every connector vertex in the top-most row of G i there is a green segment to some connector vertex in the top-most row of some G j . This provides a total of 4 d all edge disjoint, by construction of the components X h , h  X  [ n ], and by construction of the interconnection edges.
 show the existence of 4 d i edge disjoint third segments ending at a vertex in the subtree below a j .
 the proof, we observe that two paths in P having disjoint start vertices must have edge disjoint first segments, since these segments are defined for edges that are internal to having disjoint end vertices.
 Lemma 8
If M has a tree layout T M of width at most 4 k , then G has a tree layout T of width at most k .
 Proof
For each i  X  [ n ], let arc a i and the subtree below a i by r ( a i ) the root of the subtree below a i . The tree layout T of G is constructed from T as follows. 234
Observe that T has exactly n leaves, represented by the nodes r ( a place each vertex i of G at node r ( a i ). We show now that this tree layout of G has width no larger than k .
 preserved in the construction of T ; otherwise, let a M be an arbitrary arc of T been merged into a (in the third bullet of the construction). Assume that w of a . According to the definition of width of an arc, there are exactly w such that the paths in T joining nodes r ( a i ) and r ( a of edges.
 a total of 4 w a paths through M that are pairwise edge-disjoint. From the construction of T , we know that arc a M must be in the path within T M are unique in a tree. This implies that, in the tree layout T M associated with the edges in S a must all be routed through arc a paths are pairwise edge-disjoint, we conclude that there must be 4 w M routed through a M . Because in our tree layout the width of a write 4 w a  X  4 k and hence w a  X  k . Since arc a was chosen arbitrarily, this concludes our proof.
 Theorem 1
Let M be a cyclic permutation multigraph and let k  X  1 be some integer. The problem of deciding whether M has carving width less than or equal to k is NP-complete. Proof
For the hardness part, we reduce from the problem of deciding whether a (stan-dard) graph G has carving width less than or equal to k , which is an NP-complete problem, as already mentioned. We construct the cyclic permutation multigraph M polynomial time in the size of the input. By combining Lemmas 4 and 8, we have that G has carving width k if and only if M has carving width 4 k . This completes our reduction.
 computation can be carried out in linear time. 4.4 NP-Completeness of Fan-out strategies for an SCFG rule. Theorem 2 whether there exists a binary parsing strategy for s with fan-out less than or equal to k is NP-complete.
 Proof
This directly follows from Lemma 1 and from Theorem 1. 5. Time Complexity
In this section, we address the problem of finding the parsing strategy with the optimal time complexity. The time complexity of one combination step in a parsing strategy is number of distinct endpoints of the spans being combined. Time complexity can differ from space complexity due to the fact that the time complexity takes into account which endpoints are shared in the two groups of spans being combined.
 theoretic concept of treewidth, which we now proceed to define precisely. A tree de-composition of a graph G = ( V , E ) is a type of tree having a subset of G  X  X  vertices at each node. We define the nodes of this tree T to be the set I , and its edges to be the set
F . The subset of V associated with node i of T is denoted by X therefore defined as a pair ( { X i | i  X  I } , T = ( I , F )), where each X and tree T has the following properties 236
The treewidth of a tree decomposition ( { X i } , T ) is max graph is the minimum treewidth over all tree decompositions where TD ( G ) is the set of valid tree decompositions of G . We refer to a tree decomposi-tion achieving the minimum possible treewidth as being optimal.
 treewidth 1, a graph consisting of one large cycle has treewidth 2, and a fully connected graph of n vertices has treewidth n  X  1. Low treewidth indicates some treelike structure in the graph, as shown by the example with treewidth 2 in Figure 16. As an example of the running intersection property, note that the vertex N appears in three adjacent nodes of the tree decomposition. Finding the treewidth of a graph is an NP-complete problem (Arnborg, Corneil, and Proskurowski 1987).
 plexity of parsing for a given SCFG rule. Dependency graphs (known under a large number of different names) are used to represent the interaction between variables in constraint satisfaction problems, and have one vertex for each variable, and an edge between vertices representing any two variables that appear together in a constraint. In parsing problems, the variables consist of indices into the string being parsed, and the constraints require that a nonterminal on the right-hand side of a rule has previously been identified. Thus, the graph has a vertex for each endpoint involved in the rule, and a clique for each nonterminal (including the left-hand side nonterminal) connecting all its endpoints.
 Example 9
The dependency graph for a CFG rule with n nonterminals, including the left-hand shown in the left part of Figure 17. The five vertices represent the possible endpoints that need to be considered when parsing any instantiation of the rule, and each arc is a nonterminal appearing in the rule, including the left-hand side nonterminal. In this way, each nonterminal has two endpoints, and adjacent nonterminals share one endpoint. x nonterminal in the right-hand side and one endpoint with the right-most nonterminal in the right-hand side.
 vertices and n cliques of size four. For instance, the SCFG rule [ S  X  A the parsing rule has a consistent value at each step. Treewidth depends on the number of vertices in the largest cluster of the tree decomposition, which in turn determines the largest number of endpoints involved in any combination step of the parsing strategy.

Given an input graph G to the treewidth problem, we construct an SCFG rule using techniques similar to those in the previous section. We then show that finding the pars-ing strategy with optimal time complexity for this rule would imply an approximation bound on the treewidth of the original graph G .
 problem consisting of a graph G and integer k , we construct a cyclic permutation multigraph M as in the previous section, with the exception that the grid G only 2 d i rows and 2 d i columns. This grid, shown in Figure 18, is a simplified version of the grid used in Figure 10. Furthermore, there are no gadgets X each edge ( i , j ) in G , there are a total of four edges in M connecting G refer to these edges as connector edges , and we refer to edges internal to some G internal edges .
 from adjacent edges in M , as shown in Figure 19. As is required for the dependency graph representation, this gives us a graph with one vertex corresponding to each boundary between adjacent nonterminals in the SCFG rule and a clique connecting the 238 vertices for the four boundary points of each nonterminal (two boundaries in English and two in Chinese).

We refer to the subgraph of D derived from vertex i of G as D consists of connector vertices and internal vertices derived from edges of M incident on vertices of G i , and the edges of D connecting these vertices. We refer to the vertices of D i as red or green, depending on whether they are derived from red or green edges in M .
 multigraph M is the dependency graph for some SCFG rule r . Interpret an arbitrary vertex in M as the left-hand side nonterminal. Each green edge represents a boundary in
English shared between two nonterminals, including the boundary shared between the first right-hand side nonterminal and the left-hand side nonterminal, and the boundary shared between the last right-hand side nonterminal and the left-hand side nonterminal. Similarly, each red edge represents the boundary between two nonterminals in Chinese.
We then replace each edge in M with a vertex in D , and replace each vertex in M with a clique in D . D is the dependency graph for an SCFG rule, because it has a vertex for each boundary, and a clique that connects the boundaries of each nonterminal (including the left-hand side nonterminal).
 Theorem 3
A polynomial time algorithm for finding the parsing strategy of an SCFG rule having the lowest time complexity would imply a polynomial time constant-factor approximation algorithm for the treewidth of graphs of fixed degree. Proof
Let T be a tree decomposition of G having treewidth k  X  1, and let  X  ( G ) be the maximum degree of a vertex of G . Let M and D be the cyclic permutation multigraph and the dependency graph, respectively, constructed from G as previously specified. We can construct a tree decomposition T D of D having treewidth 4 k  X  ( G )  X  1 by replacing each occurrence of vertex i in T with the 4 d i connector vertices in D that are derived from the 4 d i connector edges in M that are adjacent to G adding vertices from D i one at a time. That is, we process the nodes in D major order, at each step constructing a new node in the tree decomposition of D by adding one vertex of D i , either red or green, and removing the corresponding vertex from the previous red or green column respectively. In sum, if k  X  1 = OPT = tw ( G ), then derived from SCFG rules. Given a tree decomposition T D of D of treewidth k valid tree decomposition T G of G having treewidth at most 2 k by replacing each connector vertex in T D with the corresponding two vertices i and j of G , and replacing occurrences of internal vertices of D with the corresponding vertex i of
G . This is a valid tree decomposition of G , because of the following.
Thus, by constructing D from G , finding an optimal tree decomposition of D , and then translating the result into a tree decomposition of G , we have a tree decomposition of G having width SOL where SOL  X  2 tw ( D ). Combining the results, we have
Therefore, an algorithm for minimizing the treewidth of dependency graphs of SCFG rules would imply the existence of a constant-factor approximation algorithm for the treewidth of graphs of fixed degree.
 the treewidth of graphs of fixed degree is a longstanding open problem. Therefore
Theorem 3 suggests that designing a polynomial time algorithm for finding the parsing strategy of an SCFG rule having optimal time complexity is a difficult task. 240 for SCFG parsing would also require progress on a longstanding open problem, as stated by the following theorem.
 Theorem 4
If it is NP-hard to find the parsing strategy with optimal time complexity for an SCFG rule, then it is also NP-hard to find the treewidth of graphs of degree 6. Proof
Dependency graphs constructed from an SCFG rule have degree at most 6. This is because each vertex in the graph is a member of two cliques corresponding to the two nonterminals meeting at a given boundary point in the rule. Each clique has three other vertices, for a total degree of 6. Any NP-hardness result for dependency graph of SCFG rules would imply NP-hardness for general graphs of degree 6. 6. Conclusion In the context of machine translation, the problem of synchronous parsing with an
SCFG corresponds to the problem of analyzing parallel text into grammar derivations, often as part of learning a translation model with Expectation Maximization or related algorithms. The synchronous parsing problem also applies to decoding with an SCFG and an integrated n -gram language model.
 but with the degree of the polynomial depending on the specific grammar. A loose time upper bound obtained using dynamic programming techniques is O ( n n is the sentence length and r is the maximum rule length, that is, the maximum number of linked nonterminals in the right-hand side of a rule. Gildea and (2007) show a lower bound of  X  ( n cr ) for some constant c , meaning that the exponent would require progress on approximation algorithms for the treewidth of general graphs.
 with the space complexity of dynamic programming parsing is novel to this article. In previous work, Crescenzi et al. (2015) used the notion of graph cutwidth to investigate space complexity for SCFGs restricted to linear parsing strategies, that is, strategies that add only one nonterminal at a time. However, graph cutwidth does not extend to the general binary parsing strategies that we consider in this article.
 existing linear-time algorithms for computing the tree layout of graphs of bounded carving width (Thilikos, Serna, and Bodlaender 2000), and approximation algorithms for carving width such as the O (log n )-factor approximation algorithm of Khuller,
Raghavachari, and Young (1994). The connection of time complexity to treewidth means and Dechter (2004). We can also apply linear time algorithms for graphs of bounded treewidth (Bodlaender 1996), and approximation algorithms such as the approximation algorithm of Feige, Hajiaghayi, and Lee (2005).
 systems (LCFRSs) (Vijay-Shankar, Weir, and Joshi 1987), our hardness results also apply to the latter class. Therefore our results generalize those of Crescenzi et al. (2011), who show NP-hardness for optimizing space and time complexity for LCFRSs, again with the restriction for linear parsing strategies.

SCFGs, investigated by Huang et al. (2009). Rule factorization is the problem of replac-that the language generated by the overall grammar is preserved. (The algorithm for casting a CFG in Chomsky normal form is an example of rule factorization.) As already mentioned in the Introduction, it is known that SCFGs do not admit any canonical binary form (Aho and Ullman 1972). This means that, when we attempt to factorize
SCFG rules, because they span more than two substrings; see again Figure 3. However, when viewing a SCFG as a LCFRS, factorization is always possible, and the parsing strategy trees defined in Section 2.3 directly provide a binary factorization of a SCFG into a LCFRS. Under this view, the problems investigated in this article are related to the problem of detecting rule factorizations for certain LCFRS, where we require that the factorized LCFRS are space or time optimal when used in standard algorithms for parsing based on dynamic programming. Rule factorization for general LCFRS has been investigated by G  X  omez-Rodr  X   X guez et al. (2009) and Gildea (2010). found in space or time O ( r k ), respectively, by parsing the SCFG rule X  X  right-hand itself, represented as a string of nonterminals, with a grammar representing all possible pars-ing strategies. Such a grammar can be constructed by instantiating all possible LCFRS rules of space or time complexity O ( n k ). If a parse of the SCFG rule X  X  right-hand side is found, the resulting parse tree can be used as a parsing strategy for the original rule. Acknowledgments References 242
