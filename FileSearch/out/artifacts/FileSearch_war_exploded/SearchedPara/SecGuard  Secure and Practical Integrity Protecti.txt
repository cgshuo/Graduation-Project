 Background. As the increment of the Internet-scale, computer systems are faced with more threats. For example, the Internet worms can compromise and propagate hosts by compromising vulnerable computer systems. Compromised hosts may be organized to launch large-scale network attacks. Most exis ting efforts defend against such attacks by using the network-level techniques (e.g., firewalls and NIDS). However, the study in [1] claims that network-level solutions cannot resist such attacks fundamentally, because: 1) software on hosts are buggy, and 2) disc retionary access control (DAC) mechanism is insufficient against network-based attacks. Therefore, the problem should be addressed by introducing mandatory access control (MA C) mechanism into operating systems. Existing MAC models (e.g., DTE [2,3], SELinux [4], Apparmor [5,6], and LIDS [7]) are very complex to configure and difficult to use. For example, there are many different categories of objects in SELinux; moreover, after configuring such MAC models, some existing applications will not be used. On the other hand, there has also been some efforts on practical MAC models (e.g., LOMAC [8] and UMIP [1]). However, these solutions only provide heuristic approaches without strong guarantees (e.g., provable guarantees). Furthermore, these models are evaluated only against synthetic attacks and designed based on some strong assumptions. For example, UMIP model allows the remote system administration through secure shell daemon (sshd) to be completely trustworthy (this means the integrity level of that process can not drop). Nevertheless, attackers can actually always successfully exploit bugs in such daemon program, and then  X  X verwhelm X  the system. In summary, it is still an open question that how to design a secure and practical MAC model to protect the integrity of operating systems. Our approach and contributions. This paper presents SecGuard, a secure and prac-tical integrity protection model for operating systems. SecGuard aims to resist three categories of threats: network-based threat, IPC communication threat, and contamina-tive file threat 1 . SecGuard has the following contributions: 1) SecGuard secures operat-ing systems from three categories of threats: network-based threat, IPC communication threat, and contaminative file threat; 2) S ecGuard is a practical MAC model, and it is easier to be configured and used than the existing MAC models; 3) SecGuard provides provable guarantees; therefore, the security of the model can be ensured in theory; and 4) SecGuard has been developed as a prototype system in Linux, and we present some representative designs and evaluations.
 Roadmap. The rest of this paper is organized as fo llows. Threat scenarios and assump-tions are described in Section 2. Section 3 sh ows details of SecGuard. Our evaluations are given in Section 4. Finally, we conclude in Section 5. Threat Scenarios. SecGuard aims to defend agains t three categories of threats: 1) Network-based threat. Because the applica tions of system may contain some bugs, at-tackers are able to utilize the network to inject malicious code into our hosts. Even though the attackers will not launch the activ e attack, careless users still might also download the malicious code into their local hosts from insecure network; 2) IPC communication threat. When two proce sses communicate with each other, one pro-cess might read the IPC object owned by the other process. However, the IPC object might contain malicious codes which can destroy the integrity of systems; and 3) Con-taminative file threat. The most common way to destroy the integrity of system is one particular process may read the system objects carrying malicious code, and thus the data owned by this process will be modified by the malicious code.
 Assumptions. Three assumptions: 1 ) We assume that network server and client pro-grams contain bugs and can be exploited by the attacker; 2 ) We assume that users may make careless mistakes in their operations, e.g., downloading a malicious file from the Internet and reading it; and, 3 ) We assume that the attacker cannot physically access the host. Based on the above assumptions, SecGuard aims to ensure attackers can only obtain limited privileges (not root information) and cannot compromise the operating system integrity under most attack behaviors . In this section, we discuss all the deta ils of SecGuard. Because we have developed SecGuard as a prototype system for Linux by using the Linux Security Module (LSM) framework [9], the description of SecGuard is mainly based on our design for Linux. Actually, SecGuard can be easily adopted to other UNIX variants with minor changes. Design of SecGuard X  X  integrity labels. SecGuard assigns two integrity labels to sub-jects (e.g., processes) in the system: important integrity label of subject (denoted as s i ( s ) )and current integrity label of subject (denoted as s c ( s ) ). Both of s i ( s ) and s c ( s ) have two levels (i.e., values): high or low. Meanwhile, SecGuard also assigns objects (e.g., files) with two integrity labels. They are important integrity label of object (denoted as o i ( o ) )and current integrity label of object (denoted as o c ( o ) ) respectively. The same as s i ( s ) and s c ( s ) , both of o i ( o ) and o c ( o ) also have two levels: high or low. Notice that we define important integrity level as the level of important integrity label, and define current integrity level as the level of current integrity label. How to initialize the level of integrity labels for subjects? In SecGuard, only the important integrity levels of root processes (system-level processes) are high, and their current integrity levels are high in the startup. Normal processes X  important integrity levels should be set to low, and their current integrity levels are also set to low. When a process (subject) is created, it will inherit both the important integrity level and current integrity level from its parent process. In sub-process X  X  life cycle, its important integrity level can not be changed. On the other hand, the current integrity level of subject can be changed dynamically according to the security policy of SecGuard model.
 How to initialize the level of integrity labels for objects? SecGuard introduces a novel Initialization Algorithm for initializing the level of integrity labels of objects in the system. The algorithm leverages existing DAC information of system to initialize the configuration of integrity level for objects. Notice that we only pay attention to the 9-bits mechanism for DAC, and the current DAC enhanced by ACL mechanism is not our consideration, since the information provided by ACL mechanism is not used by Initialization Algorithm. To elaborate the Initialization Algorithm clearly, we present the meanings of symbols of the algorithm in Table 1. The Initialization Algorithm ini-tializes the configuration of integrity level for objects in the system based on three key steps which are shown in Algorithm 1. More details of Initialization Algorithm are shown in [10].
 SecGuard X  X  security properties. In SecGuard, when a subject accesses an object or communicates with a subject, the accessed object or subject must be in available state; If a subject can read an object, the current inte grity level of the subject must dominate (i.e., be higher than or equal to) the current integrity level of the object and the important integrity level of the subject must dominate the important integrity level of the object; If a subject can modify the content of an object, the current integrity level of the subject must dominate the important integrity level of the modified object. Due to the limited space, we move formal description of SecG uard X  X  security properties to [10]. SecGuard X  X  security policies. The level-changed conditions of a subject X  X  current in-tegrity are shown in Fig. 1: 1 ) When a subject receives the traffic from network (e.g., downloads some files or scripts), the subject drops its current integrity level to low; 2 ) After a subject, whose current integrity level is high, communicates with a subject whose current integrity level is low, the former drops its current integrity level to low, and 3 ) When a subject, whose current integrity level is high, reads an object whose cur-rent integrity level is low, the subject drops its current integrity level to low. Due to the limited space, we move formal description of SecGuard X  X  security policies to [10]. Provable guarantees. We provide provable guarantees to SecGuard. Due to the limited space, we move all the formal proofs to [10]. We have developed SecGuard as a prototype protection system for Linux based on the Linux Security Module (LSM) framework. Due to the space constraints, we only present some representative designs and evaluations. We move all the details of our experiments to [10].
 Prototype. The basic implementation of SecGuard is as follows. Each process has two integrity labels, and when the one is created, it inherits the important integrity level from its parent process. SecGuard can not restrict the process whose current integrity level is high; however, a low current integrity process cannot perform any sensitive operation in the system. If a process can send a request, it must be authorized by both the DAC of the system and SecGuard. Due to the space constraints, we cannot present details for the implementation of SecGuard.
 Evaluation of practicability of SecGuard. In order to evaluate the practicability of SecGuard, we built a server with Fedora Core 8 , and enabled SecGuard as a security module loaded during the system booting. The existing programs of the system have not been affected after our security module loading. After that we installed some normal applications and the system can still provide services. SecGuard contributes several features of practicability on the operating system: the novel initialization algorithm, without complex configuration of integrity labels, and existing application programs and common practices for using can still be used under SecGuard.
 Evaluation of secu rity of SecGuard. Actually, our formal proof has provided strong guarantees to SecGuard (see [10] for details). Here, we use Linux Rootkit Family (LRK) to attack our system. The LRK is a well-known rootkit of user-mode and it can replace many system programs and introduce some new programs to build backdoors and to hide adversaries. LRK can be installed su ccessfully and replaces the current SSH dae-mon in the system when SecGuard was closed. Then, we connect to the server as root with the predefined password. When SecGuard run, installation is failed and system returns a permitted error. Thus, our system remained security under SecGuard. This paper presents SecGuard, a novel secure and practical integrity protection model for operating systems. Aiming to three threats in systems: network-based threat, IPC communication threat, and contaminative fi le threat, SecGuard provides a robust de-fense for operating systems, and leverages i nformation in the existing discretionary access control mechanism to initialize integrity labels both for processes and files in systems. Furthermore, SecGuard provides provable guarantees to SecGuard. Finally, we describe the implementation of SecGuard for Linux and evaluations.
 We thank the anonymous reviewers for helpful comments. This work is supported in part by the National Natural Science Foundation of China under Grant No. 60873238 , No. 60970135 and No. 61073156 , as well as Accessing-Verifica tion-Protection oriented secure operating system prototype under Grant No. KGCX2-YW-125.

