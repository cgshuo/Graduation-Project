 1. Introduction
XML is by now the de facto standard for exporting and exchanging data on the web. In this model, data is represented in a tree structured form. 1 Query languages for XML are mainly based on the specification of tree patterns to be matched against the data tree. For instance, XPath [1] which lies at the core of XQuery [2]  X  the standard query language for XML  X  specifies branching path expressions that essentially define tree patterns. 1.1. The problem
XML data does not have to comply with a schema. Even if the data comply with some schema, a user might not have full knowledge of it. Formulating a TPQ that will retrieve the desired results becomes complex. The reason is that, as we explain below, the user has to specify an order for the elements in every path of a tree-pattern query (TPQ) even though (a) the user might not know this order, and (b) the user might not be interested in imposing an structures even if they export the same information or information from the same knowledge domain. Since elements may be ordered differently in these structures, querying all these data sources in an integrated way becomes an issue: usually, a single TPQ is not able to retrieve the desired information from all of them.
Consider, for instance, the TPQs shown in Fig. 1 for a bibliographic XML document. These queries involve descendant relationships (depicted with double arrows) which denote a path of zero or more elements between specifying which one. The output node (the node returned to the user) is shown boxed.

Even though TPQs provide some freedom in the specification of a tree structure (e.g. through the use of descendant relationships and wildcards), they all have a common restrictive structural requirement: in every root-to-leaf path, there is a total order for the nodes . It is not possible in a TPQ to indicate that two nodes n and n 2 occur in a path without specifying a precedence relationship between them: node n 1 has to precede node n 2 or vice-versa.

Specifying queries in this context with languages like XPath or XQuery is a complex task [9,14,27,22] .In addition, the user might have to specify a number of tree patterns that are exponential on the number of ele-ments in the query [27,22] . To deal with this problem several approaches try to introduce query languages that relax the structure of a tree pattern in a query [24,14,9,19,20] . An even more challenging issue is to assign semantics to these queries so that they return to the user fragments of the XML tree that are meaningful (that is, the queries are not matched to unrelated parts of the XML document). 1.2. Limitations of previous approaches
Two different solutions have been suggested to deal with the dependence of queries for XML from the structure of the data: one that adapts the structureless keyword-search techniques to query tree-structured data, and one that extends structured TPQ languages with keyword search capabilities.

The first solution modifies keyword-based techniques used by search engines for HTML to distinguish between text (data) and elements (metadata). It also modifies these techniques to return fragments of the doc-uments that contain the keywords, as is appropriate for XML, instead of links to documents [24,14,9] . This solution offers a very convenient way for specifying queries, even for a naive user. Nevertheless, its major lim-querying tree-structured data for two reasons: (a) they can express user requirements and therefore, refine the query answer, and (b) they can express structural constraints that are known to hold in order to speed up the evaluation of the queries.

The second solution is applied to extend structured query languages for XML to enable keyword search [10,19,20] . However, these languages cannot avoid having a syntax which is complex for the simple user [9,14,27,22] .

To face the challenge of assigning semantics to queries so that they return meaningful answers, most approaches exploit directly or indirectly the notion of Lowest Common Ancestor (LCA) of a set of nodes in the XML tree. However, in most practical cases, the information in the XML tree is incomplete (e.g. optional elements/values in the schema of the document are missing), or irregular (e.g. different structural pat-terns coexist in the same document) [3] . For instance, examining the DBLP data set (data collected in May 2006) we found that almost 10% of the  X  X  X ook X  X  entries and over 1% of  X  X  X rticle X  X  entries do not have an author, while almost all  X  X  X roceedings X  X  entries do not have authors (this latter one is reasonable and expected). In such cases, the approaches of the first solution (the structureless keyword-based solution), even if they succeed in retrieving all the meaningful answers, they comprise only a tiny percentage of meaningful answers in their answer set. Most of the answers are meaningless. In other words, these approaches have low precision. Our experiments in Section 7 with DBLP-based data sets show that in some cases the precision falls below 1% for some approaches. Clearly, such a low precision is a serious limitation for those approaches.
A recent approach (MLCAS [19,20] ) of the second solution (the solution that extends TPQs with keyword capabilities) shows improved precision. However, the percentage of meaningful answers returned (i.e. the recall) is low. In our experiments in Section 7 , the recall of the MLCAS approach falls below 60% for several cases of XML data. Clearly, the poor recall cannot be improved by further imposing structural restrictions. This performance is not satisfactory for data integration environments for which this approach is intended. In addition, it employees different semantics for the keyword part (MLCAS) and the structured part of a query (XQuery). As a consequence, structural restrictions in a query cannot be used to recuperate answers that are not returned by the keyword search. 1.3. Our approach
In this paper, we introduce an original approach which addresses the problem of query dependence from the structure by allowing a partial specification of tree patterns in queries. Partial tree-pattern queries (PTPQs) relax the requirement of total node order in the paths of the tree pattern. Structural restrictions in PTPQs can be flexibly specified fully, partially or not at all. To provide some intuition, we show in Fig. 2 a simple PTPQ.
This PTPQ has three (partial) paths surrounded by dotted lines. Nodes are labeled. Node labels preceded necessarily related through a total order: an author can precede a title in a path or vice versa. Undirected edges labeled by the symbol between two nodes from different partial paths indicate that these two nodes coincide (that is, these two nodes denote a single node shared by the two partial paths). For instance, in Fig. 2 , the two nodes labeled by  X  X  X ubject X  X  denote a common node of partial paths 1 and 2. Notice that PTPQs can be struc-tureless keyword queries when they comprise a single element in each partial path. They can also be queries with partial specification of the tree structure. Such an example is the query of Fig. 2 . Finally, they can be queries that define regular tree patterns like those of Fig. 1 .

We suggest an original approach for assigning semantics to our PTPQ language. The originality of our approach relies on the use of structural summaries of the XML document for identifying structural patterns (TPQs) for a given query. Using a partial order between TPQs, we identify those of them (called meaningful
TPQs) that return meaningful answers. Previous approaches identify meaningful answers by operating locally on the data (usually computing Lowest Common Ancestors of nodes in the XML tree). In contrast, our approach operates globally on structural summaries of data to compute meaningful TPQs. This overview of data gives an advantage to our approach compared to previous ones. 1.4. Contribution
The main contributions of this paper are the following:  X  We introduce a query language with variables (wildcards) that allows partial specification of the structure of the tree patterns. Queries in this language do not cast to the structure of a specific XML tree. The PTPQ language can be used by a user to specify structural constraints on keywords, without the knowledge of a complex TPQ language like XQuery.  X  We define structural summaries of data called index graphs. We show how index graphs can be used to compute a set of fully specified TPQs (complete TPQs) for a PTPQ that together compute the answers of the PTPQ.  X  We use a partial order on the complete TPQs for a PTPQ to determine those of them that are meaningful.
The meaningful TPQs are used to assign semantics to PTPQs. The novelty of our approach relies on the fact that not only the data, but also tree patterns in the structure of the XML tree are taken into account in specifying the meaningful answers of a PTPQ. Further, our approach seamlessly applies this semantics both to PTPQs without structural restrictions (keyword queries) and to PTPQs that fully specify tree patterns.  X  We compare our approach with previous approaches that query tree structured data with, and without, structural restrictions. We analyse cases where our approach succeeds in returning meaningful answers that escape other approaches. We also analyse cases where our approach succeeds in excluding meaningless answers that are returned by other approaches.  X  We have implemented and experimentally evaluated our approach. Our approach shows better recall com-pared to previous ones. In addition, in most cases, it allows for a better precision among approaches with similar recall. The precision can be further improved since our approach allows for specifying structural restrictions the user might want to impose or knows that they hold on the data. This feature is not available to languages that are restricted to keyword queries.  X  Besides the quality of the results, we have evaluated our approach in terms of performance. Our experimen-tal results show that it largely outperforms and scales better than the only previous approach that allows for keywords and structured queries.  X  The meaningful TPQs generated by our approach are tree patterns. Therefore, they can be evaluated using any XQuery engine, and their execution can benefit from optimization techniques developed up to now for
XQuery (e.g. [15,4,7] ). 1.5. Outline
The rest of the paper is organized as follows. The next section discusses related work. Section 3 presents the data model and the query language. Index graphs and complete TPQs for a PTPQ are introduced in Section 4 .
In Section 5 , we present our novel semantics for the PTPQ language. Our approach is compared with previous one in Section 6 . It is experimentally evaluated in terms of quality of results and performance in Section 7 .We conclude and suggest future work in Section 8 . 2. Related work
A traditional data integration approach would use mapping rules between a global structure and local structures [8] to generate multiple TPQs. However, this approach requires extensive manual intervention and is complex and subject to errors.

Olteanu et al. [23] and Olteanu [22] consider XPath expressions with backward predicates and show that they can be equivalently rewritten as sets of expressions with forward predicates. These works relate to ours since we also evaluate PTPQs by generating equivalent sets of TPQs. However, they differ from ours in two respects: (a) they do not address the issue of assigning meaningful semantics to queries which is the main focus of our paper, and (b) in rewriting queries, they do not consider index graphs. The use of index graphs allows us not only to limit the number of tree-pattern queries generated to those that reflect patterns existing in the data, but also to generate complete TPQs that is, TPQs that do not involve ancestor X  X escendant structural relation-ships and wildcards.

A number of papers deal with the assignment of meaningful semantics to keyword-based query languages for XML [24,14,9,19,27,20] . All of them are based on some variation of the concept of Lowest Common Ancestor (LCA). The query language in [9] allows also some primitive structural restrictions to be expressed. Li et al. [19,20] provides an extension of XQuery to allow users to query an XML document without full knowledge of the structure. It uses the concept of Meaningful Lowest Common Ancestor Structure (MLCAS) of a set of nodes for assigning semantics to keyword queries. We analytically compare our approach with the three approaches in [24,9,19,20] in Section 6 and experimentally in Section 7 . Our approach shows better recall in all cases, including cases where the XML data are incomplete. Among approaches with similar recall, our approach shows better precision in most cases. In [27] the concept of Smallest Lowest Common Ancestor (SLCA) is used to assign semantics to keyword queries. This semantics is similar to that of the MLCA approach. Therefore, we do not directly compare it to ours.

In order to cope with low precision some approaches extend the database techniques with information retrie-val techniques. In this direction, they rank the answers of keyword search queries on XML documents according to their estimated relevance [9,12] . Information retrieval systems using ranking functions may trade recall for precision. The PTPQ language is a database query language. Therefore, it does not employ any ranking func-tions. Its goal is to not miss any meaningful answer and to exclude as many meaningless answers as possible.
Some languages employ approximation techniques to search for answers when the initial query is too restricted to return any. They either relax the structure of the queries or the matchings of the queries to the data [16,5] . In contrast to our language, these languages return approximate (not exact) answers.
Several papers focus on providing efficient algorithms for evaluating LCAs for keyword queries [24,14,9,19,20,27,13] . Our approach is different and does not have to explicitly compute LCAs of nodes in the XML tree. In contrast, it computes a number of meaningful TPQs for PTPQs that involve keywords and/or structural restrictions. This computation is done mainly on a structural summary of data, which is usu-ally much smaller than the data itself. For this reason, our experimental results show that our approach largely outperforms the MLCAS approach. Since TPQs can be evaluated using an XQuery engine, our approach can directly take advantage of the various optimization techniques developed so far for XQuery [15,4,7] .
A partial tree-pattern query language is introduced in [25] and its query containment problem is addressed in [26] . However, this language does not comprise variables (wildcards) and descendant-or-self precedence relationships as the language we consider in this paper. More importantly, the problem of assigning meaning-ful semantics to the queries is not addressed in those papers. 3. The partial tree-pattern query language
We present in this section the data model and our query language that allows for partially specifying the structure of a tree pattern. Our goal in this paper is to focus on the structural aspects of the query language. Therefore, we abstract other features that a full-fledged commercial query language would normally comprise. 3.1. Data model
Let E be an infinite set of elements that includes a distinguished element r , X be an infinite set of variables , and V be an infinite set of values . Variables range over elements, and play the role of wildcards in tree-pattern queries. Here, we use variables to distinguish between different wildcard nodes. Symbols e , x , and v (possibly with indices) refer systematically to an element, a variable, and a value respectively. The term construct (denoted c ) refers indiscreetly to an element or a variable.
As is usual, we model XML documents as trees. Nodes in an XML tree are labeled by elements or values. In particular, the root node of an XML tree is the only node labeled by element r . Values can label only leaf nodes. Attributes of elements in an XML document are modeled as (sub)elements. For simplicity we assume that the same element does not label two nodes on the same path (that is, the XML trees are not recursive). We discuss in the next section how this restriction can be relaxed.

Fig. 3 shows three XML trees T 1 , T 2 ,and T 3 from different data sources that record bibliographic infor-mation in different formats (a slight extension of an example introduced in [19,20] ). T 1 and T 3 categorize the data based on the publication year, while T 2 categorizes the data based on the type of publication (article year of publication. We are interested in retrieving information by issuing the same query against all these data sources, even though the information is structured differently in each one of them. Therefore, we view all these
XML trees as one tree T rooted at r . 3.2. Query language
Definition 3.1. A Partial Tree-Pattern Query (PTPQ) is a triple Q  X  X  P ; S ; O  X  , where: (a) P is a nonempty set of triples  X  p ; A ; R  X  called Partial Paths (PPs). p is the name of the PP. The names of (c) O is a set of PPs in P . These PPs are called output PPs of Q .

We graphically represent PTPQs using graph notation. Each PP of a PTPQ Q is represented as a (not nec-essarily connected) graph of nodes identified with, and labeled by, the constructs of the PP. If a node n in the graph has an annotation V in Q , it is labeled by the predicate c = V instead of the construct c . The name of each PP is shown by the corresponding PP graph. The names of the output PPs of Q are shown boxed. Child, descendant and descendant-or-self precedence relationships in a PP are depicted using the arrows ! , ) ,and = ) , respectively, between the corresponding nodes in the PP graph. In particular, descendant precedence relationships of the form r ) c and r = ) c in a PP are shown only with the presence of node c in the PP graph. Variable names are preceded by a * sign, while values are shown between quotes. A node sharing graph p j labeled by the symbol.

Suppose that we want to find the title and year of publications authored by  X  X  X ary X  X  [19,20] . We are not interested to restrict the type of publication we are looking for, and actually we do not know what type of publications are recorded in the XML data. Further, assume that we know that title and author are not cat-egorization features in our XML document(s), and therefore they should appear below any categorization ele-ment. We formulate this PTPQ as shown in Fig. 4 . Symbols x and y denote variables, while p 1 and p 2 are the output PPs of the PTPQ. As another example, consider the query that finds additional authors of publications of which  X  X  X ary X  X  is an author and also the title and year of those publications. In this case, assume that we expect author  X  X  X ary X  X  and the other author to be sibling nodes and descendants of a publication node which has a descendant node  X  X  X itle X  X . We do not have any idea about the placement of node  X  X  X ear X  X  besides the fact that it should relate in some way to the publication. This PTPQ is shown in Fig. 5 .
 The answer of a PTPQ is based on the concept of PTPQ embedding.
 Definition 3.2. An embedding of a PTPQ Q to an XML tree T is a mapping M of the constructs of the PPs of Q to nodes in T such that: (a) An element e of Q is mapped by M to a node in T labeled by e ; a variable v of Q is mapped by M to a (b) The constructs of a PP in Q are mapped by M to nodes in T that are on the same path. (c) If a construct c has an annotation V in a PP p (that is, a predicate c = V is specified in p ), then the image (e) " l [ p i ] l [ p j ]in Q , M ( l [ p i ]) and M ( l [ p j ]) coincide.

We call image of a PP p in Q under M , denoted M ( p ), the path from the root of T that comprises all the images of the constructs of p under M and ends in one of them. Notice that more than one PP of Q may have their image on the same root-to-leaf path of T ( M does not have to be a bijection). The concept of image of a PP is extended to apply to PTPQs in a straightforward way.
 We initially define the answers of a PTPQ on an XML tree as follows.

Definition 3.3. The answer set A of a PTPQ Q on an XML tree T is the set of subtrees of T formed by the images of the output PPs of Q under all possible embeddings of Q to T . The subtrees comprise also the child value nodes of the elements. The subtrees in A are called answers of Q on T .
 Fig. 6 shows the images of PTPQ Q 1 of Fig. 4 under three of the possible embedding of Q 1 to the XML tree
T of Fig. 3 . The values of the elements are additionally included in the images for clarity. The images of the output PPs of Q in the figures are shown with thicker arrow edges. More specifically, Fig. 6 a X  X  correspond to embeddings of Q 1 to the XML trees T 1 , T 2 and T 3 respectively that constitute the tree T of Fig. 3 .
Observe that the language is able to retrieve with one query the title and year of the publications of Mary from different parts of the XML tree, even though these parts structure the data in different ways.
The previous definition of the answer set of a PTPQ accepts any possible embedding of Q to T . This gen-erality allows embeddings that do not relate elements and values in the way the user was expecting when for-mulating the query. We call the answers corresponding to these embeddings meaningless answers. For instance, each of the images of Q 1 shown in Fig. 6 correctly corresponds to a publication (a book in this case) authored by  X  X  X ary X  X . However, this is not the case with the images of Q 1 in Fig. 7 under three other embed-dings of Q 1 into T . In each one of them, year and/or title values do not correspond to a publication authored by  X  X  X ary X  X  even though these values appear in an answer with  X  X  X ary X  X . In Section 5 , we will present a tech-nique that excludes these subtrees and returns answers to the user that are meaningful.
 4. Evaluating PTPQs using complete TPQs We show now how PTPQs can be evaluated using TPQs. We first discuss index graphs for XML trees. Then, we use index graphs to construct a set of complete TPQs whose answers, taken together, form the answer of a given PTPQ. Besides allowing us to evaluate PTPQs, the complete TPQs of a PTPQ provide the basis for defining meaningful semantics for PTPQs in the next section. 4.1. Index graphs
Given a partitioning of the nodes of an XML tree T , an index graph for T is a graph G such that: (a) every node in G is associated with a distinct equivalence class of element nodes in T , and (b) there is an edge in G from the node associated with the equivalence class a to the node associated with the equivalence class b ,iff there is an edge in T from a node in a to a node in b . Index graphs have been referred to with different names in the literature including  X  X  X ath summaries X  X ,  X  X  X ath indexes X  X  and  X  X  X tructural summaries X  X . They differ in the equivalence relations they employ to partition the nodes of the XML tree which includes simulation and bisimulation [21,17] or even semantic equivalence relations [25] . Index graphs have been extensively studied in recent years in both the  X  X  X xact X  X  [11,21,6] and the  X  X  X pproximate X  X  flavor [18,17] . A common characteristic of those approaches is that the index graph is used as a back end for evaluating a class of path expressions without accessing the XML tree. To this end, the equivalence classes of the XML tree nodes are attached to the corresponding index graph nodes.

For the needs of PTPQs we define index graphs where the equivalence classes are formed by all the nodes labeled by the same element in the XML tree. Fig. 8 shows the index graph G of the XML tree T of Fig. 3 .
In contrast to other approaches, the equivalence classes of the XML tree nodes are not kept with the index graph. Therefore, PTPQs are ultimately evaluated on the XML tree. Even though the index graph for an XML tree is not a schema in the form of a DTD or an XML Schema, we take advantage of it in the same way schema information is exploited in relational databases. We use index graphs to support the evaluation of a PTPQ through the generation of a set of complete TPQs. 4.2. Complete TPQs for a PTPQ If G is the index graph of an XML tree T , we say that T underlies G . Given a PTPQ Q and an index graph G , Q can be evaluated by computing a set of complete TPQs whose answers, taken together, are equal to the answer of Q on any XML tree underlying G .By complete TPQ we mean a TPQ that involves only child rela-tionships and no variables (and therefore, a TPQ that completely specifies a tree pattern). Intuitively, a com-plete TPQ satisfies both: the structural and value constraints of the PTPQ, and the structural constraints of the index graph.
 Definition 4.1. Let Q be a PTPQ and G be an index graph. A complete TPQ (CTPQ) for Q on G is a TPQ U without variables (wildcards) and descendant precedence relationships which is rooted at a node labeled by r and satisfies the following conditions: (a) There is a mapping M from the nodes of Q to the nodes of U that respects paths, labeling elements, pre-(b) There is a mapping M 0 from the nodes of U to the nodes of G that respects labeling elements and child
Fig. 9 shows two of the CTPQs of the PTPQ Q 1 of Fig. 4 on the index graph G of Fig. 8 . The output nodes have their labels boxed.

Clearly, a CTPQ can be seen as a PTPQ (without variables and descendant or descendant-or-self prece-dence relationships) where the node sharing expressions are defined by the common nodes of different root-to-leaf paths. The output PPs of the corresponding PTPQ are defined by the paths of the CTPQ that comprise output nodes. Then, we can define the answer of a CTPQ to be to the answer of the corresponding PTPQ. We can now show the following proposition.
 Proposition 4.1. Let Q be a PTPQ, G be an index graph, and U 1 , ... ,U k ,k P 1, be all the CTPQs of Q on G. Therefore, the answers of a PTPQ Q on an XML tree T can be computed by determining the set U of all the CTPQs of Q on the index graph of T and by computing the answers of each CTPQ in U on T .

Consider the XML tree T ( Fig. 3 ) and its index graph G ( Fig. 8 ). Consider also the PTPQ Q 1 ( Fig. 4 ), and of CTPQ U 1 . Similarly, the answer of Q 1 on T shown in Fig. 7 c is also an answer of CTPQ U 3 .
Note that the approach presented in this paper can be easily extended to handle recursive XML trees (that is, XML trees that involve more than one node labeled by the same element in one path of the tree), and PTPQs that include multiple nodes labeled by the same element in the same PP. In this case, CTPQs for a
PTPQ are generated using an index tree instead of an index graph. An index tree is a tree structure similar to an 1-index 2 [21] with the exception that no pointers to the data are stored in the index. The absence of cycles in the index tree allows one to deal with recursive XML trees and PTPQs. 5. Using complete TPQs to exclude meaningless answers
In this section, we assign semantics to our PTPQ language that returns meaningful answers. In contrast to previous approaches which exclude embeddings of the query to the data tree [24,9,19,20] , our approach excludes CTPQs of a PTPQ. In this sense, our approach relies both on data and on structural patterns of data, instead of relying exclusively on data.

Based on the results of the previous section, we consider that, given an XML tree T (and its index graph G ), the answer of a PTPQ is the union of the answers of its CTPQs on G . However, some of these CTPQs may return meaningless answers. Consider, for instance, again, the PTPQ Q 1 ( Fig. 4 ) and the XML tree of Fig. 3 along with its index graph G in Fig. 8 . The CTPQ U 3 ( Fig. 9 b) of Q 1 on G returns (among others) the answer of Fig. 7 c which is meaningless. Therefore, this CTPQ of Q 1 should not be used for computing the answers of Q . Analogously to query answers, we characterize a CTPQ of PTPQ Q on G as meaningful with respect to T if it returns a meaningful answer on T . Otherwise, it is characterized as meaningless with respect to T . In order to formally define meaningful CTPQs we need to introduce a transformation for CTPQs. 5.1. A transformation for complete TPQs Let Q be a PTPQ, T be an XML tree and G be its index graph. Fig. 10 shows two CTPQs, U and U 0 ,ofa PTPQ Q on an index graph G . CTPQ U comprises three subtrees T a , T b and T c . T a is the subtree of U rooted a and b respectively). The node labeled by c can coincide with the root of U . However, the node labeled by a cannot coincide with the node labeled by c , and the node labeled by b cannot coincide with the node labeled by c (that is, the node labeled by c is an ancestor of the nodes labeled by a and b ). Labels a and b can be equal. Subtree T 0 b in U 0 is a tree identical to T b except that its root is labeled by a instead of b . CTPQ U 0 can be obtained from U by removing the subtree T c below the node labeled by c , and by making T 0 b a subtree of the node labeled by a . We define the transformation TR on CTPQs as a transformation that transforms a CTPQ of the form of U into a CTPQ of the form of U 0 . Notice that CTPQ U 0 has at least one node less than CTPQ U .

We formally define meaningful CTPQs in the next subsection but we provide some intuition now on the transformation TR . Consider a CTPQ U 0 resulting by applying TR to a CTPQ U . Our intention is to charac-terize U as meaningless with respect to T , and to exclude it from consideration in computing the answers of Q , if U 0 returns an answer on T . To understand this idea, observe that there is a 1 X 1 mapping f from the nodes of U 0 to the nodes of U that respects node labels and child precedence relationships (with the exception of the child precedence relationships from the node labeled by a in T 0 b ). Then, the following proposition holds: Proposition 5.1. Assume that CTPQ U 0 results by applying transformation TR to a CTPQ U. If n 0 is the lowest not a descendant of f(n 0 )inU.

Since, there is an image of Q under an embedding to T (and therefore an answer of Q on T ) that closely relates the nodes as determined by U 0 , any image of Q under an embedding to T (and the corresponding answer) that relates the nodes in the looser way determined by U is not meaningful, and should be excluded from generating an answer.

To clarify the use of transformation TR , we show next some applications of it on the CTPQs of our running example. We consider PTPQ Q 1 ( Fig. 4 ) on index graph G ( Fig. 8 ) that underlies the XML tree T ( Fig. 3 ). Fig. 11 shows three CTPQs U 1 , U 2 and U 3 of Q 1 on G . Dotted lines denote the subtrees T a , T b , and T c of transformation TR as they are graphically shown in Fig. 10 . The CTPQ U 2 will be excluded from consider-ation in the evaluation of Q 1 on T because TPQ U 1 returns an answer on T .

Similarly to U 2 , CTPQ U 3 will be excluded from consideration. Notice that in the case of CTPQ U 2 , the roots of T a and T b are labeled by the same element  X  X  X ook X  X , while in the case of CTPQ U 3 they are labeled by different elements  X  X  X ook X  X  and  X  X  X rticle X  X .

Fig. 12 shows applications of transformation TR in sequence. The CTPQ U 6 is excluded from consideration because of the CTPQ U 5 . Then, the CTPQ U 5 is also excluded because of the CTPQ U 4 .

Finally, Fig. 13 shows some other applications of transformation TR in sequence. Notice that T b in Fig. 13 c (and consequently T 0 b in Fig. 13 d) are empty. Observe that the CTPQ U 8 has an extra branch from the root with respect to CTPQ U 7 . 5.2. Determining the meaningful complete TPQs Next, we formally define the concept of meaningful CTPQ of a PTPQ on an index graph. Consider a PTPQ Q , an XML tree T , and its index graph G . Let U be the set of CTPQs of Q on G . We define a binary relation on U as follows: for every U ; U 02 U , U 0 U if and only if U 0 can be obtained by applying a sequence of transformations TR to U . Clearly, is a strict partial order.
 Definition 5.1. A CTPQ U 2 U is called meaningless with respect to T if there is another CTPQ U 02 U such that (a) U 0 U , and (b) U 0 has an answer on T . Otherwise, it is called meaningful with respect to T .
We can now update the definition of the answer set of a PTPQ given in Section 3.2 . We provide a new def-inition for the answer set of a PTPQ so that it comprises only answers of meaningful CTPQs. The new def-inition is based on Proposition 4.1 and Definition 5.1 .
 Definition 5.2. Let Q be a PTPQ, T be an XML tree and G be an index graph. Let also U 1 , ... , U k , k P 1, be respectively, on T , then A = [ i 2 [1, k ] A i .
 Consider the CTPQ U 3 shown in Fig. 9 b. As mentioned in Section 4.2 , U 3 , evaluated on the XML tree T of Fig. 3 , returns the meaningless answer of Fig. 7 c. CTPQ U 3 is also shown in Fig. 11 and it is characterized by Definition 5.1 as meaningless. Therefore, it will not be used to generate answers for the PTPQ Q 1 ( Fig. 4 )on T . In contrast, CTPQ U 1 of Fig. 9 a returns only the meaningful answer of Fig. 6 a. CTPQ U 1 , is also shown in Fig. 11 . One can see that Transformation TR cannot be applied to U 1 . Therefore, it is correctly characterized by Definition 5.1 as meaningful, and will be used to generate answers for the PTPQ Q 1 on T . One can check that when it comes to evaluate Q 1 on T , transformation TR excludes all CTPQs for Q 1 on G ( Fig. 8 ) except the CTPQs U 1 , U 4 and U 7 of Figs. 11 X 13 , respectively, and the variations of those CTPQs where label  X  X  X ook X  X  is replaced by  X  X  X rticle X  X .

Since the meaningful CTPQs are TPQs, their evaluation can be implemented on top of an XQuery engine and benefit from the extensive optimization techniques that have been developed up to now for XQuery [15,4,7] . 6. Analysis of previous approaches and comparison
In this section, we compare the semantics of our query language with the semantics of three other well known query languages for XML that aim at excluding meaningless answers [24,9,19,20] . In most practical cases, the information in the XML tree is incomplete (e.g. optional elements/values in the schema of the doc-ument are missing), or irregular (e.g. different structural patterns coexist in the same document). Therefore, we also take this parameter into account in our comparison.

Schmidt et al. [24] suggest the meet operator to let the users query an XML document without knowledge of the elements and the structure. Queries are sets of keywords to be matched against the values of the XML document. This approach exploits the structure of the XML tree and is based on merely computing the Lowest Common Ancestor (LCA) of the nodes in the XML tree that match the keywords. The computation of the LCAs is done bottom up. When the LCA of a set of nodes that match the keywords is computed, these nodes are excluded from further consideration. The meet operator might fail to return a meaningful answer when a node is a descendant of another node of similar type (logical hierarchy) and the information in the XML tree is not complete. Consider, for instance, the XML tree of Fig. 14 and a keyword query consisting of the keywords  X  X  X ary X  X ,  X  X  X itle X  X  and  X  X  X ear X  X . This approach considers only keywords that are values but we allow also key-words that are elements in this example as this does not affect the computation of LCAs. The meet operator will fail to return the subtree rooted at the node labeled by bib which is the meaningful answer. The reason is that another LCA node is identified first (the node labeled by  X  X  X ook X  X ) and the subtree rooted at this node is excluded from further consideration. The meet operation will also fail to exclude meaningless answers in case of incomplete information even for a flat XML tree (that is, a tree that does not contain logical hierarchies). Consider, for instance, the same keyword query and the XML tree T 1 of Fig. 3 . The meet operator will return the meaningless answer shown in Fig. 7 b.

XSEarch [9] is a semantic search engine for XML. It uses a simple query language that allows keyword specifications (values and/or elements) and a primitive structural restriction (a node labeled by an element key-word has a descendant node labeled by a value keyword). The answers are subtrees that contain the keyword labeled nodes. XSEarch uses the concept of Interconnection Relationship to capture the meaningful XML subtree for a set of nodes that match the keywords. Two nodes n 1 and n 2 are interconnected if the path from n to n 2 through their LCA does not contain two distinct nodes labeled by the same element. Nodes n 1 and n 2 can have the same label though. The interconnection relationship is extended to multiple nodes through an all-pair or a star n -ary relationship. XSEarch allows only query answers where the nodes matched by the keywords are all-pair or star related. Intuitively, nodes in the XML tree represent entities and element labels represent their type. Nodes with the same label represent entities of the same type. Descendant nodes of a node n are assumed to belong to the entity n represents. Two nodes that are meaningfully related should not belong to different entities of the same type. XSEarch rarely fails to return a meaningful answer. However, it usually fails to exclude meaningless answers even if the XML tree is flat, and does not have incomplete information.
Consider the keyword query Q 1 specifying the elements  X  X  X itle X  X  and  X  X  X ear X  X  and the value  X  X  X ary X  X  on the XML tree of Fig. 3 . XSEarch fails to exclude the meaningless answer of Fig. 7 c. The reason is that any two of the nodes that match the keywords are interconnected (in contrast, XSEarch succeeds in excluding the meaning-less answer of 7 a because this one contains two nodes which are both labeled by  X  X  X ib X  X ). Similarly, query Q 1 issued against the XML tree of Fig. 14 which has a logical hierarchy fails to exclude the several meaningless subtrees-answers rooted at the node labeled by the  X  X  X ook X  X .

Li et al. [19,20] extend XQuery to enable users to query XML documents without full knowledge of the structure. This work is closer to ours compared to the previous two because it allows the user to specify exten-sive structural restrictions in a query besides keywords. To compute a query, this approach finds the LCA node of the set of nodes that match the keywords, and treats the subtree rooted at this node as the context for query evaluation. It employs a particular version of LCA, called Meaningful Lowest Common Ancestor
Structure (MLCAS). The MLCAS of two nodes n 1 and n 2 (and therefore that of any superset of those two nodes) does not exist if two other nodes of the same type (that is, nodes labeled by the same element) have an LCA which is a descendant of the LCA of n 1 and n 2 . The MLCAS approach fails to return meaningful answers when the XML data contains logical hierarchies even if there is no incomplete data in it. Consider, for instance, query Q 1 specifying the elements  X  X  X itle X  X  and  X  X  X ear X  X  and the value  X  X  X ary X  X  on the XML tree of
Fig. 15 . Under the MLCAS semantics, the answer set of the query does not contain the subtree-answer rooted at the node labeled by element  X  X  X ib X  X  (shown with bold arrows in Fig. 15 ), which, intuitively, is the answer the  X  X  X ost related X  X  to query Q 1 . The answer set will contain only the subtree-answer rooted at the node labeled by  X  X  X eference X  X . When the XML data is incomplete, the MLCAS approach fails to exclude meaningless answers. For instance, the keyword query Q 1 specifying the elements  X  X  X itle X  X  and  X  X  X ear X  X  and the value  X  X  X ary X  X  on the
XML tree of Fig. 3 will return the meaningless answer of Fig. 7 b because there are articles in the XML tree T that have only a title (and no author) and articles that have an author (and no title). Another drawback of this approach is that the semantics for the keyword queries (MLCAS) is different than the semantics for the struc-tural queries (XQuery). Therefore, the structural restrictions cannot be taken into account in determining the meaningful answers of a query in the first place. If a meaningful answer of a query is not contained in the subtrees returned by the keyword search part of the query, it cannot by recovered by further evaluating the structural part of the query. Notice that, in contrast, in our approach both the structural restrictions and the keywords in a query determine the meaningful TPQs that, in turn, compute the answers of a query.
Our approach successfully returns all the meaningful and eliminates all the meaningless answers of the examples discussed in this section. Its success is due to the original way it uses to evaluate the meaningful answers of a query. Previous approaches identify meaningful answers by operating locally on the data by com-puting LCAs of nodes in the XML tree. In contrast, our approach operates globally on structural summaries of data (index graphs) to compute meaningful TPQs. This overview of data gives an advantage to our approach compared to previous ones. 7. Experimental evaluation
We implemented our approach (abbreviated as PTPQ), and we experimentally compared it to previous approaches on two aspects: the quality of the returned results, and the efficiency of their computation. 7.1. Quality
In order to assess the quality of our approach, we implemented the three approaches discussed in Section 6 (Meet [24] , XSEarch [9] , and MLCAS [19,20] ). We ran detailed experiments to compare their Recall (defined as the proportion of relevant materials retrieved) and Precison (defined as the proportion of retrieved materials that are relevant). These parameters have been used for years for measuring the quality of keyword search in information retrieval systems. As our language is a database language, we did not use ranking functions com-bined with threshold values to trade recall for precision (or vice versa). 7.1.1. Experimental setting
We used real-world DBLP data of the size of 324 MB collected from http://dblp.uni-trier.de/xml/ in May 2006. To simplify the document for the experiments, we retained only three publication types:  X  X  X ook X  X ,  X  X  X rti- X  X  X ear X  X . As the original DBLP data is flat, for evaluation purposes, we restructured it into three types of data sets that comply respectively with the schemas shown compactly as dags in Fig. 16 . All subelements of pub-lications in the three schemas are optional as in the original DBLP schema. Publications of the schema Type 1 do not have references. Publications of schemas Type 2 or Type 3 may have references. We consider also ref-erences to be publications. Therefore, schemas Type 2 and 3 contain logical hierarchies. One difference between schema Type 2 and Type 3 is that publications of schema Type 3 are categorized by year.
Besides the structure of the document, the  X  X  X ncompleteness X  X  of the data also affects the effectiveness of the  X  X  X ear X  X , and  X  X  X uthor X  X , otherwise it is incomplete . For the experiments, we considered data sets that have dif-ferent percentages of incomplete publications.

The data sets for the three schema types are generated as follows. A program loads a set of sampled from the original DBLP data. Another program randomly chooses a set of publications among them for removal of some of their subelements. One or at most two subelements can be removed from each publication.
The percentage of incomplete publications for different publication types can be specified through input parameters. Finally, an XML creator reassembles the publications to an XML document. The structure of the generated XML file, determined also by an input parameter, can be any one of the three types shown in Fig. 16 .

As the distinction between keywords that are values and keywords that are elements is insignificant for the semantics of the queries in all approaches, in our experiments, we query only for elements. We used keyword queries that comprise at least two of the elements  X  X  X itle X  X ,  X  X  X ear X  X , and  X  X  X uthor X  X . We also ran experiments on queries with more than three keywords and the results were similar. We also considered two of the previous keyword queries with structural restrictions. We used these queries to experimentally compare only our approach (PTPQ) and the MLCAS approach since these are the only two that allow the specification of non-primitive structural restrictions.

For all three LCA-based approaches, we consider that the answer of a query is the subtree whose leaves are the nodes that match the keywords and whose root is their LCA (the way it is defined in each approach). Thus two distinct matchings of the keywords with the same LCA determine two different answers. For each query and each type of data set, we wrote a fully specified query in XQuery that expresses what the user is seeking. We used the answers of these queries as a reference for computing precision and recall.

For each query and each type of data set, we have run the four approaches on six XML documents with increasing percentage of incomplete publications in the range from 0 (all the publications are complete) to 50% (half the publications are incomplete).

We ran the experiments on a Pentium 2.40 GHz computer with 512 MB of RAM running Windows XP Pro-fessional. We implemented all keyword search techniques in Java and used the SAX API of the Xerces Java
Parser for the parsing of XML files. Berkeley DB XML 2.2.13 was used to store XML files and run XQuery. 7.1.2. Experimental results for keyword queries without structural restrictions
We first consider keyword queries without structural restrictions. Fig. 17 shows precision and recall of the two keyword query {author, year} for the three types of documents varying the percentage of incomplete pub-lications in the documents.

Both XSEarch and PTPQ have perfect recall on all types of documents both for complete and incomplete data. Meet has also perfect recall on Type 1 and 2 documents but performs slightly worse on Type 3 docu-ments when the data is not complete. MLCAS has also perfect recall on Type 1 documents. In contrast, its recall is degraded on Type 2 documents and it drops below 60% on Type 3 documents both for complete and incomplete data. This is due to the fact MLCAS cannot handle the logical hierarchies appearing in Type 2 and 3 documents.

PTPQ shows perfect precision on Type 1 document (no logical hierarchies). Its precision starts above 60% for complete data and goes slightly up as the percentage of incomplete publications increases on Type 2 and 3 documents. The opposite trend is followed by the precision of Meet and MLCAS on all types of documents. They start at 100% with complete data and drop as the percentage of incomplete publications increases. The precision of XSEarch is, in general, low and is not affected significantly by the increase of the percentage of incomplete information.

Fig. 18 shows the precision and recall of the two-keyword query {title, author} for the three types of doc-uments varying the percentage of incomplete publications in the documents. We omit the plots of the query {title, year} as they are analogous to those of the query {title, author}.

All four approaches shown in Fig. 18 are similar trends to those shown in Fig. 17 . Meet and XSEarch show on the average even lower precision. Their recall is perfect for all types of documents both for complete and incomplete data. Interestingly, the recall of MLCAS improves when the percentage of incomplete publications increases, reaching 100% for a percentage of 50% of incomplete publications. The reason is that when the number of incomplete publications increases, a number of  X  X  X ook X  X ,  X  X  X rticle X  X , and  X  X  X nproceedings X  X  elements (which are missed anyway by the MLCAS approach) are not anymore correct answers.

Fig. 19 shows the precision and recall of the three-keyword query {title, author, year} for the three types of documents varying the percentage of incomplete publications in the documents. The trends are similar to those of two-keyword queries with a slight degradation of the recall of Meet, and an average degradation of the precision of XSEarch and Meet. 7.1.3. Experimental results for keyword queries with structural restrictions
We now consider queries that involve also structural restrictions. We use two of the previous keyword que-ries where the  X  X  X uthor X  X  and  X  X  X itle X  X  keyword elements are both child nodes of some (the same) element. This structural restriction can be formulated on the keyword queries {author, title}, and {title, author, year}. We call the first one Q s 2 and the second one Q s 3 .

Fig. 20 shows the precision and recall of query Q s 2 for Type 3 documents varying the percentage of incom-plete publications in the document (for Type 1 document the precision and recall are perfect for both approaches). Both approaches show for Q s 2 the same recall as for the corresponding query without structural restrictions ( Fig. 18 ), which for the PTPQ approach is 100%. Both approaches improve their precision achiev-ing a perfect one.

Fig. 21 shows the precision and recall of query Q s 3 for Types 2 and 3 documents varying the percentage of incomplete publications in the document. The PTPQ approach has perfect recall. The MLCAS approach has for Q s 3 the same recall as for the corresponding query without structural restrictions ( Fig. 19 ). Both approaches improve their precision but the improvement is more important for PTPQ.

In summary, MLCA shows good precision which can be improved with structural restrictions. However, its recall is low (it falls below 60% in some cases). Its recall cannot be improved when additional structural restrictions are imposed since the semantics for the keyword part of the query is different than that of the struc-tural part of the query. Therefore, answers missed in the evaluation of the keyword search part of the query cannot be recovered during the evaluation of the structural part. PTPQ does not show this drawback. Its recall is perfect with and without structural restrictions, while additional structural restrictions improve its recall. 7.2. Performance
In order to assess the performance of our approach, we compared it to the MLCAS approach for two rea-sons: (a) MLCAS also allows the specification of structural constraints, and (b) MLCAS has been embedded into Timber [15] , an XML database management system. In order to guarantee a unique experimental com-parison environment, we used Timber also for the evaluation of the meaningful CTPQs of our approach. In this section, we present the experiments conducted to evaluate the performances of PTPQ approach and MLCAS approach on generating meaningful answers and report results obtained. 7.2.1. Experimental setting
We compare the time cost of evaluating an MLCAS-embedded XQuery, with that of the PTPQ approach, which generates a set of meaningful CTPQs, and then evaluates their corresponding XQuery expression.
We used original DBLP datasets. We retained only the properties of  X  X  X ear X  X ,  X  X  X uthor X  X ,  X  X  X itle X  X ,  X  X  X ublisher X  X , and  X  X  X SBN X  X  for each publication as these are the ones that we used in queries, and removed other properties such as  X  X  X olume X  X  and  X  X  X ages X  X . In the experiments we used five different sizes of datasets: 95 KB, 21 MB, 29 MB, 95 MB and 148 MB. We used the same platform as the one used for the quality experiments.
Running queries with several keywords and no structural constraints in the MLCAS approach takes a lot a time when the data set is larger than 90 KB. We used the following four queries in the experiments: Query 1: A pure two keyword query ( X  X  X ww X  X  and  X  X  X itle X  X ).

Query 2: A three keyword query ( X  X  X itle X  X ,  X  X  X ear X  X  and  X  X  X SBN X  X ) with a variable and a structural constraint: Query 3: A three keyword query ( X  X  X itle X  X ,  X  X  X rticle X  X  and  X  X  X ear X  X ) with a structural constraint:  X  X  X itle X  X  is a Query 4: A two keyword query ( X  X  X itle X  X  and  X  X  X nproceedings X  X ) with a structural constraint:  X  X  X itle X  X  is a descen-
For each approach, we ran the four queries on the five data sets. The running time of PTPQ queries consists of the time for generating meaningful CTPQs and the time for evaluating these CTPQs (translated into XQue-ry expressions). The running time of an XQuery expression on Timber reflects the execution of its physical plan and does not include the time for parsing the expression. We run each query five times on each data set, and we recorded the average running time. The running time of MLCAS queries is merely the time Timber records for these queries. 7.2.2. Experimental results
Fig. 22 respectively report the execution time of the MLCAS and PTPQ approaches. Note that the y -axis is on a logarithmic scale. We can see that the time for generating meaningful CTPQs is insignificant, only around 1% of the total evaluation time for the PTPQ approach. We can also see that the execution time of MLCAS approach is larger than that of PTPQ approach in some cases by over two orders of magnitude. Such a big difference in execution time is expected as the MLCAS approach works solely on data while the PTPQ approach exploits index graphs whose size is much smaller than that of underlying data. Moreover, we can see that the PTPQ approach scales much better than the MLCAS approach.

Our experiment results show that the PTPQ approach outperforms the MLCAS approach in both query performance and quality of results. 8. Conclusion
Current applications export and exchange XML data. In this context, a major challenge is the querying of the data when the structure is not fully known, and the integrated querying of multiple data sources that export data with structural differences and irregularities.

We have introduced a query language with wildcards that allows partial specification of a tree pattern. Our query language flexibly allows the specification of the full spectrum of queries from structureless keyword que-ries to complete tree-pattern queries. We have suggested an original approach for assigning semantics to this language. In contrast to previous approaches that operate locally on data, our approach operates globally on structural summaries of data to extract tree patterns. An experimental evaluation of the quality of our approach shows that it has a perfect recall for both XML documents with complete and incomplete data.
It also shows better precision, in most cases, compared to approaches with similar recall. Our approach can be directly implemented on top of an XQuery engine. An experimental evaluation of its efficiency shows that it outperforms and scales better than the only previous approach that allows for structural constraints in the queries and has been integrated into an XQuery engine.

An extension direction of the current work involves using multiple query optimization techniques to iden-tify commonalities between the meaningful complete TPQs of a PTPQ. These commonalities can then be exploited in deriving an efficient  X  X  X lobal X  X  plan that evaluates all the meaningful complete TPQ together.
References
