 discovering distributed services and automatically generating service processes. heterogeneous message types. Since web services are developed independently, it is the input message type of the following service. When executing such a process, process engines will abort abnormally for incompatible message types. 
Most of web service composition systems avoid this problem by selecting service they have to abandon many an available service candidate because of incompatible our knowledge, no previous study has so far sufficiently investigated the problem of message heterogeneity. 
Three questions arise for message heterogeneity problem: (1) how to formalize the service composition systems; (3) how to make an implementation. (1) We formalize this problem as the problem of XML transformation based on schemas. Messages in web services are formatted in XML and their schemas are defined in WSDL documents. Thus, XML transformation technology can help to remove all cases of message heterogeneity. (2) We propose to transform heterogeneous messages with a message transfor-have incompatible message types. In this way, our solution can be seamlessly integrated into current composition systems. (3) We implement message transformation automatically on the basis of automated schema matching. Available information in message schemas is fully utilized for matching between schemas. 
The remainder of this paper is organized as follows. In Section 2, we introduce mechanism for adapting heterogeneous messages. In Section 5, we present the algorithms to automated schema match. Section 6 gives our experiment methods and results and Section 7 gives the concluding remarks. 2.1 Message-Level Composition Although current research on service composition mainly focuses on composition possibility and process optimization, there are a few papers that refer to message-level composition. However, their work aims to find the services with compatible message types. They do not take into consideration the problem of message heterogeneity. For example, B. Medjahed discussed the composability of web services from multiple levels including message similarity [1]. E. Sirin defines generic message match, denoting the match between the services whose output type is a subclass of the other service's input type [2]. Meteor-S offers graphical user interface for process designer to link messages among services [3]. They avoid this problem by filtering those service candidates owning incompatible message types. 2.2 Web Service Flow Languages Here we analyze how the two main web service flow languages, OWL-S and BPEL4WS, support heterogeneous message transformation. OWL-S OWL-S [4] is defined as OWL-based Web service ontology, aiming to facilitate the automation of Web service tasks, including automated Web service composition. each other in terms of the semantics of the concepts. It is useful for service matchmaking but it is irrelevant to the problem of message heterogeneity. BPEL4WS BPEL4WS [5] provides a language for the formal specification of business processes the help of XPath language. It is effective when both messages are locally compatible. However, it will become tedious for assigning data respectively for each element problem is to transform the heterogeneous messages in third-party side. 2.3 Message Heterogeneity in Distributed Systems A similar problem exists in distributed systems, where distributed components communicate one another with messages. Several message communication technologies, such as IIOP in CORBAR and Java Message Service in J2EE, are developed. However, the problem can be easily solved in this field because the required one, then errors in the distributed system will be thrown out without considering compensation. Thus, the solution in traditional distributed systems can not apply to web service composition systems. We analyze the problem of message heterogeneity in web service composition by a in function level to offer comprehensive functionality. The output message of both messages have different element names and orders in structure. Besides name concatenated by the contents of more than one request element. Moreover, one parameters, and each source corresponds to one schema with its own namespace. Thus, a great diversity of message heterogeneity increases the difficulty of this problem. 
Fortunately, messages are represented with XML format and their schemas can be retrieved from WSDL document. Thus XML transformation technology can be used to remove the heterogeneity of messages when composing web services. We take request messages as Source Data, the schemas of request message as Source Schemas, and the schema of input message as Target Schema. This problem is equal to transform the source XML data conformed to source schemas to result XML data conformed to target schema. In this section, we first present a new automatic message transforming component in Section 4.1. Then we discuss how to integrate it with current web service composition systems in Section 4.2. 4.1 Message Transforming Component Although there are many XML transforming components, they do not support automated transformation and (or) do not co nsider the message match characteristics described in Section 5.1. We develop a new automated message transformation component based on the match algorithm on message schemas. As shown in Fig. 2, it takes source schemas, target schema and source data as input, matches source schema to target schema by applying match algorithm, then generates XSLT scripts according conformed to the target schema. The framework of this component contains four parts, including Schema Matcher, XSLT Generator, XSLT Engine Wrapper and Web Service Interface. 
Schema Matcher accepts source schemas and target schema as inputs and applies hierarchical structures and search match pairs between source schema tree and target schema tree. The match algorithm is described in details in Section 5. 
XSLT Generator reads match rules and automatically generates transformation we choose XSLT language as transformation script because it is popular and powerful enough. Moreover, there are several stable XSLT engines, such as XALAN and XT. 
As the entire match rules are translated into XSLT scripts, we use XSLT Engine to complete the transformation process. XSLT Engine takes XSLT scripts and source data as input, interprets XSLT and generates the result XML document conformed to the target schema. 4.2 Integration into Web Service Composition Systems To seamlessly integrate message transforming component into current composition systems, we deploy it as a web service, named Message Transformation Service. message transformation service can be inserted ahead of current service to smooth and can be invoked multiple times in one process wherever heterogeneous messages exist. It can also return the generated XSLT scripts for testing in debug environment. 
If service process is manually designed, process designers can decide where this service should be inserted in the process. If the process is automatically generated, it is decided by the schema comparator, a tool developed in message transformation the match algorithm on message schemas. Message transforming component also users. For automated composition systems, the correctness of transforming results hardly depends on the accuracy of match between schemas. In Section 5, we discuss match algorithm in details. XML Schema Match takes two xml schemas called source schema and target schema semantically to each other. Lots of previous work on automated schema match has been developed in the context of data integration and information retrieval. However, more work can be done besides applying previous ones because here message schema available information in schema to get match candidates in terms of the similarity of elements. Finally, a match algorithm is presented which selects the correct match candidate for each element in the target schema. 5.1 Message Schema Match Characteristics Since service message is defined with W3C XML Schema language, message schema match is essentially equal to XML schema match. However, there are several distinct algorithm. z Web service message usually has simple structure. Service message is mainly z Multiple source schemas match to single target schema. Recall that service's z Message schema match is driven by target schema. Traditional schema matches 5.2 Match Approaches The available information for message schema match includes the usual properties of schema elements, such as name, description, data type, cardinality and schema structure, etc. Message schema match approaches find multiple match candidates and each one will be estimated the degree of similarity by a normalized numeric value in the range 0-1. 
Formally expressed, assume i S is the set of elements in the i th source schema, S is the match candidates can be represented as: the most common in message match. We will expand to the cases of 1:n and n:1 cases information in schema to get the similarity of both elements. 5.2.1 Name Matching Name matching counts the similarity of schema elements based on their names. Several methods can be used to measure the similarity of two names, including VSM simple hierarchy, we utilize dictionary to count them for better results. 
For element name 1 and element name 2 , we divide them into several words name similarity of two elements is represented as follows: Assume w is the nearest ancestor of 1 i w and 2 j w in WordNet, then them in WordNet. If 1 i w and 2 j w are equal, the result is 1. As seen in this equation, more synonym two words are, more close to 1 the result is. 5.2.2 Constraint Filtering including data types, value range, optionality, cardinality, etc. Commonly speaking, if Element constraints can not be used alone fo r matching because there may be lots of approaches (e.g., name matching) to filter the match candidates. If the two elements in element, then match on them is unreasonable since they have incompatible data types. We use the following formula to adjust the similarity: The function i f corresponds to the i th constraint, described as follows: Here i  X  is a constant between 0 and 1 for the i th constraint. It denotes implicitly the adjusted dynamically according to match resu lts. Now two kinds of constraints, data type and cardinality, are mainly considered because the constants on them are far less name but with incompatible data types, however, the pair of them is still likely to be kicked off from match candidate set. 5.3 Match Algorithm After applying match approaches on each target element t k , we obtain match candidate set match(t k ) . However, it is not the final mission of message schema match. Only one candidate should be selected for each targ et element respectively from corresponding match candidate set, which is used as a match rule for transforming messages. 
Recall one of the characteristics in message schema matching is that multiple usually to be that one source schema "occupies" one local part of target schema. Even including its parent, brothers and childre n. For arbitrary match candidate between ij s match can be measured with context match rate: has higher context match rate than the former one, and consequently it is more likely to be the correct one. 
We designed the match algorithm shown in Fig. 4. _____________________________________________________________________ Step 1: get match candidate set for each target element Input: S ---all source elements, T ---all target elements Output: mTable ---an instance of hash table foreach ( t in T ) foreach ( j in S ) Step 2: Select correct match candidate Input: mTable ---obtained from step 1 Output: rules ---vector containing picked match candidate Traverse T in the order of top-down , t denotes current traversed element. achieve match(t) from mTable ; foreach ( , st &lt;&gt; in match(t) ) _____________________________________________________________________ 
In this algorithm, Step 1 finds all the match candidates between source schemas and target schema. Step 2 traverses the target schema top-down meanwhile selects the pair with the biggest context match rate for each target element. This solution is implemented in SEWSIP, a prototype of semantic-based web service composition system [9]. It publishes message transformation service in the URL of http://keg.cs.tsinghua.edu.cn/sewsip/services/msg/. We experiment on this prototype to testify the capability of our solution. 6.1 Data Sets We tried to collect web service description (including WSDL documents and web service text description) from as many so urces as possible for our experiments. Four approaches were applied for service collection. (1) We look up UDDI centers to find web services, including IBM center (http://www-3.ibm.com/services/uddi/find), services in Web service search engines li ke http://www.salcentral.com/search.aspx (3) We download web service description from service collection website like http://www.xmethods.net/. (4) We search Web services at Google (http://www. google.com) with "wsdl" or "asmx" as the file suffix. 
We mainly collect services in the domains of weather, address lookup, news booking and hotel booking. These kinds of services define message types with commonly containing &lt;date&gt; and &lt;city&gt; parameters. Hotel booking services have the most complex message types with more than ten parameters. 
Finally, 118 available WSDL documents in the 4 domains are selected, and we publish them in the URL of http://keg.cs.tsinghua.edu.cn/sewsip/rawdata/ws/. We Table 1 shows classification statistics on data sets. 6.2 Experiment Methods and Evaluation Measures message heterogeneity. For each domain, we extract keywords from WSDL documents in this domain as function description, and selected the typical input utilizing message types as search criteria affect the searching results. We measure the services and T denotes the total number of services in the corresponding domain. 
The second experiment is to evaluate message schema match algorithm. We arbitrarily group two WSDL documents from the same domain, and annotate the message schemas to see if they can be matched correctly. Firstly, we apply name approach alone on the data set. Then we combine name approach, description approach and constraint filtering together. Finally, we apply the comprehensive match algorithm described in Fig. 4. We measure the results with precision and recall rate. m denotes the auto-generated match pairs and match pairs. 6.3 Experiment Results respectively represent domain names, number of selected services by both function description ( C 2 ) and ( C 2 -C 1 ). 
Table 3 shows the experiment results for the second experiment. The columns represent respectively data sets, results for name approach, results for combining name approaches and constraint filtering, and results for message match algorithm. 6.4 Discussion (1) The results in Experiment 1 indicate that utilizing message types as one of searching criterion seriously re duces the searching rate. More than half services have to be abandoned because of incompatible message types. We can see from the enhance the numbers of service candidates, especially when the message types are complex. (2) The results of Experiment 2 show that match algorithm can not highly enhance the precision and recall compared with hybrid approaches when the message types are simple. Algorithm 1 select match candidate according to context match rate based on the match similarity from hybrid approaches. When message structure is simple, little context information can be utilized to distinguish correct match pair from others. In this paper, we have investigated the problem of message heterogeneity in web service composition. We have defined the problem as XML transformation based on schemas. We have proposed a solution to integrate the operation of message transformation into current web service composition systems. Fully utilizing available information in message schemas, we implement automated message schema match sufficiently considering th e characteristics of message schemas, so that we can transform heterogeneous messages automatically and dynamically. 
As future work, we plan to make further improvement on the accuracy of schema match. The match pattern of 1:n and n:1 will be supported and instance-level data will be utilized for schema match. 
