 1. Introduction
An important issue in modern information systems and e-commerce applications is to provide support for inter-opera-converting their own data to/from this form.

The key tasks in data exchange can be roughly divided into two groups. 1. Intensional tasks, which concern the management of the schema mapping between the source and target schema. Among  X  containment of different mappings, and (c) the operations of the mappings, e.g., the inversion and composition. 2. Extensional (data-level) tasks, for the defined mapping between the source and target schema and the given source ing against the target schema, in a way that is consistent with the source data.
Data exchange has received an increasing attention from both the research community and the tool market, due to the Miller, Hernandez, &amp; Fagin, 2002 ) is also built and partly incorporated into commercial systems. ever-growing XML data with data exchange settings.
 ness of XML, and to help achieve better target instance.
 type is given in bracket.
 the title and author of a paper in a subtree rooted at a paper element.
 variables) are introduced in the target instance, e.g., variable r the target instance are actually quite different.
 instance is far from satisfactory. (a) Intuitively, variable r null value. Since the source values related to r 1 and r 2
One might be tempted to organize them together since this is allowed by the target schema (one writer node can have according to the structural constraints imposed by target DTD.
 book is determined by its title, then we can conclude that r we can also merge works by leveraging this.
 we get a much better target instance in Fig. 1 . h 1.1. Contributions exchange setting ( D S , D T , R ST ), where D S , D T and R the data exchange, by capitalizing on the data exchange setting and target constraints. which allows one to restructure documents by leveraging variety forms of navigation and comparisons of data values. instance, among other things. this helps improve data compactness. (c) We provide a chase method to reason about missing data based on non-key preciseness. that our algorithms scale well, and help generate good solutions. We contend that our techniques yield a promising method for the construction of XML data exchange solutions. 1.2. Related work
We next discuss related works. 1.2.1. Relational data exchange Popa, 2005 ), or slight extensions ( Hernandez et al., 2007; Yu &amp; Popa, 2004 ). ones, since the XML data model, the mapping language between DTDs, and the XML constraints are much more complicated than the relational counterparts. We have to invent most basic notions and present new techniques. 1.2.2. XML data exchange (in polynomial time), on the basis of tractable cases ( Amano et al., 2009; Arenas &amp; Libkin, 2008 ). has considered target constraints in the XML data exchange setting.

The XML Stylesheet Language for Transformations (XSLT) can be employed to implement some basic data exchange mention the involvement of target constraints.

An alternative approach to handling XML data exchange is to employ relational data exchange and transformation tech-od can generally only be applied to some restricted settings. 1.2.3. Extracting and restructuring data implementation of a data exchange rely on the already known source and target schemas, and the pre-defined mapping mapping between the schemas, alleviating the need for fully understanding the transformation language. data.
 proposed, which can extract, select, rename and restructure XML data.
 change techniques cannot handle this kind of relations directly. 1.3. Organization clusions and future work in Section 7 . 2. Preliminaries
We review some related preliminary definitions in this section. 2.1. DTD the production of e for each e in Ele . P ( e ) is a regular expression of the form: a :  X  j b bute names; (e) r is a distinguished type in Ele , called the root type . original text node. Moreover, any path (query) involving the text node can be easily converted as well. edge denotes disjunction. 2.2. Path
Here is the empty path, @ a 2 Att , e 2 Ele , and  X  X / X  X  denotes the concatenation of two paths. A path l path if l 1 = r ; (b) a leaf path if l k is an attribute name; and (c) a singleton path if each l ( i 2 {2, ... , k }), i.e., l i is either an element type that occurs once and is in the form of ... , l 2.3. XML instance
We use lab ( v ) to denote the label of a node v , and val ( bute nodes v and v 0 ,if lab ( v )= lab ( v 0 ) and val (
In an XML instance T conforming to D , a node v 2 is reachable from node (b) Q = Q 0 / l , there is a node v 0 such that v 0 is reachable from node { use v s Q t to denote this node. If v is the root node, we write { s Q t } for { val ( v s author /@ name t ) =  X  X  X ef X  X . h 3. XML data exchange setting Recall that a relational data exchange setting ( Fagin et al., 2005 ) is a triple ( S , T , R R
ST is given in the form u s  X  x ; y  X ! w t  X  x ; z  X  , where u instance J , they satisfy the above dependency if whenever u new tuples in the target instance.
 fine the mapping between source and target schemas, in the form of source-to-target dependencies. In addition, we practical cases for an efficient generation of the target instance.
 the source instance can be collected and assigned to attributes in the target instance. 3.1. Element node formula
The basic component of a tree pattern is element node formula , which is defined by: where e 2 Ele ,@ a 1 , ... ,@ a n 2 M ( e ), and x 1 , ... , x labeled e and possibly has a set of n attribute child nodes. Variables x 3.2. Tree pattern
Based on element node formula , tree pattern is defined by: simply write p if x is clear from the context.

Example 3. info [ dept [ person (@ name = x 1 ,@ pid = y 1 work . person has two attribute nodes @ name and @ pid , whose values are bounded by variables x three attributes @ pid ,@ title and @ year , whose values are bounded by variables y Fig. 2 shows some tree patterns in the format of trees, and the first one is exactly what we have just discussed. h with a constant or a labeled null value. 3.3. Satisfaction of a tree pattern
Given a node v of an XML instance T , a tree pattern p  X  x  X  is satisfied on inductively as follows: 1. ( T , v ) s c , iff (a) if c :  X  e , then v is labeled e ; (b) if c :  X  e (@ a 1 = x 1 , ... ,@ a n = x n ), then v is labeled e , and val ( 2. ( T , v ) s c [ p ], iff ( T , v ) s c , and there is a child node v 0 of v such that ( T , v 0 ) 3. ( T , v ) s c [// p ], iff ( T , v ) s c , and there is a descendant node v 0 of v such that ( T , v 0 ) 4.  X  T ; v  X  s c p 0 1 ; p 0 2 , iff  X  T ; v  X  s c p 0 1 and  X  T ;
Fig. 1 by a mapping s , where s ( x 1 ) :  X   X  X  X om X  X , s ( y of corresponding free variables of the pattern. h
Remark 1. We present more concepts related to tree patterns. 1. A tree pattern p is satisfied on an XML instance T by s (written T sider this kind of satisfaction in this paper. structural constraints imposed by the DTD. 3. A tree pattern p is fully specified if descendant  X  X // X  X  is not used.
 (a), (c) cannot be expressed by former notions ( Amano et al., 2010, 2009 ), because constants are involved. 3.4. Equality formula
To this end, we add explicit data value comparisons by introducing an extra formula k k  X  x  X  to denote a formula that is a conjunction of equality atoms of the form x and  X  X  X  X  X  is a constant in Const . k  X   X  x  X  is satisfied by a mapping s  X  x  X  (written s k k  X  x  X  true, where x i is a variable in x .If x is clear from the context, we use k dependencies. 3.5. Source-to-target dependencies
Source-to-target dependencies are expressions of the form: where p S and p T are tree patterns compatible with source DTD D We use x to indicate the common free variables in p S and p (resp. p T ) and k = (resp. k 0  X  ) source (resp. target) tree pattern and equality formula. for every mapping function s  X  x ; y  X  such that (a) S s p that (a) s  X  x  X  X  s 0  X  x  X  , (b) T s 0 p T  X  x ; z  X  and (c) s 0 k 3.6. XML data exchange An XML data exchange setting ( Arenas &amp; Libkin, 2008 ) is a triple ( D DTD, and R ST is a set of source-to-target dependencies from D instance T is called a solution of S w.r.t. the data exchange setting ( D all the dependencies in R ST .
 of constant values are implemented.
 shown in Fig. 2 . The source pattern is satisfied on the source instance by a mapping s , where s ( x :  X   X  X  X om X  X ; s also satisfies the source equality formula x  X  X  X 1 X  X , s 0 ( x 3 ) :  X   X  X  X om X  X , s 0 ( z 1 ) :  X   X  X  X aper X  X , s 0 ( z target pattern satisfied on the second target instance, where s 00 ( z w of the target pattern. h
Remark 2. We have identified some practical cases for an efficient implementation of target instance constructions. 1. In a source-to-target dependency, we require that p S (resp. p target) DTD, no source instance has a solution. efficiency. 3. In a target equality formula k 0  X   X  x ; z  X  , it is easy to see that equality atoms of the form x paper, we assume target equality formula is composed of atoms of the form: z 4. Canonical target instance construction Given an XML data exchange setting ( D S , D T , R ST ) and a source instance S conforming to D dependencies in R ST and the target schema D T .
 Algorithm 1. Algorithm Canonical Algorithm. Canonical takes as input the data exchange setting ( D addressed shortly. (a) Canonical employs T set as an auxiliary structure (line 1). (b) For each source-to-target dependency r pattern p S and equality formula k = , Canonical identifies all the source mappings s , such that p common variable of p S and p T to the same constant as s does, i.e., s 0  X  x  X  X  s  X  x  X  ; s 0 also makes k be found, Canonical constructs an XML tree T p T s 0 such that the target tree pattern p
T to T set (lines 5 X 6). (e) After all the partial results are collected in T to produce the canonical instance that conforms to target schema D pattern is satisfied on the instance by a mapping s which maps x and  X  X 100 X  X , respectively; s also makes the formula y 1 = y constructed. It copies the values for x 1 , x 2 and x 3 from the source, assigns constant value  X  X  X aper X  X  to z the labeled null value is denoted by a variable s 1 .

Similarly, the second source-to-target dependency in Fig. 2 leads to target fragments 2 and 3; the source pattern is identify two distinct constants  X  X  X 1 X  X  and  X  X  X 2 X  X .
 conforms to the target DTD. The final result is the canonical target instance shown in Fig. 1 . h
Remark 3. We present more details of algorithm Canonical . 1. For each source-to-target dependency r ST of the form p source instance S , and the collection of attribute values that make k target tree pattern (line 4). (a) For all the variables in x , i.e., the common free variables in p any arbitrary ordering can be used. We write r i s j if r posed of atoms of the form: z i = x j ,or z i =  X  X  X  X  X , or z null value is identified with a constant value by s 0 ( z z i = z j , they are processed inductively: (i) if both z by s 0 ( z i ) :  X  s 0 ( z j ) (w.l.o.g. we assume s 0 ( z no mapping s 0 exists in this case. variables in p T , i.e., the variables in x or z . Canonical constructs the XML tree T p T  X  u  X  X  e  X  @ a 1  X  u 1 ; ... ; @ a n  X  u n  X  X  p 1  X  u ... ,@ a n with values s 0 ( u 1 ), ... , s 0 ( u n ), and k distinct children target tree pattern is compatible with schema D T , each partial result generated by Canonical can conform to D merge nodes by following constraints imposed by DTD; this will be formulated in Section 5 . 4. Finally, Canonical will introduce some default element nodes according to target schema D b  X  , then v has no element child nodes. (c) If P ( e )is b b 1 + ... + b n , then v has one element child node def ( b and s 0 ( z 3 ) :  X   X  X  X alue1 X  X . (c) Canonical constructs T r attributes are added according to target schema, and we get the canonical target instance. h 5. Incorporating target constraints 5.1. XML constraints most commonly discussed.
 applications.
 h (a) = a. The symbol set of an XML instance T is composed of all the attribute values in T . 5.1.1. An XML constraint model
A constraint r is of the form  X  Q ; Q 0 ;  X  Q 1 ; ... ; Q singleton leaf path. X j  X  j 2f 1 ; 2 g X  is a sequence of values [ x u (resp. w ) is either a variable or a constant; if u (resp. w ) is a variable, it occurs in X the variables and constants in X 1 ; X 2 , u and w .
 2 { v s Q 0 t }, if val ( v j s Q i t )= h ( x ji ) for all i 2 {1, ... , n }, j 2 {1,2}, then h ( u )= h ( w ).
We call v context node, v 1 , v 2 target nodes, v j s Q i T R if T r for every r 2 R .

Example 8. Formally, the constraints suggested in Example 1 can be defined as follows: 1. The publication year of a book is determined by its title. 2. The publication source of a book is determined by its title. 3. The writer X  X  name is a key. 4. For each writer, the combination of type and title of his work is a key.
Remark 4. Observe the following. enhances its expressive power. Moreover, it can be verified that the constraint model is safe : given a constraint j 2 {1,2}). 2. Constraints r 1 , r 2 are functional dependencies, while constraints r whole XML document, two writer nodes cannot agree on the values of their @name attribute nodes, otherwise there is a contradiction ( X  X 0 = 1 X  X ). Indeed, a key constraint can always be given in the form ( Q , Q 0 ,( Q eman, Davidson, Fan, Hara, &amp; Tan, 2003; Hartmann &amp; Link, 2009 ). combination of type and title of a work is therefore not unique inside the whole instance. tional ones, and are hence more widely applicable in real applications ( Bohannon et al., 2007; Fan, 2008 ). 5.2. Merging overlaps paper  X  X  X 1 X  X  written by  X  X  X om X  X  according to constraints r (a) only one node is reserved for each element type or attribute name; and (b) labeled nulls s constraints. 5.2.1. Structural constraints
We employ two kinds of constraints imposed by the target schema (DTD). 1. Singleton. We call a child e 1 of e a singleton if each e has at most one e singleton e 1 nodes occur under an e element node, then the two e 2. Incompatibility. We call two child nodes e 1 , e 2 of e incompatible if they cannot occur simultaneously, i.e., e 5.2.2. Merging nodes
We present details for the merging of nodes v 1 and v 2 . ferent constants as their values, then the merging fails. (b) If one attribute node, say by s i , and v 2 has a constant value  X  X  X  X  X , then replace all the occurrences of s s j respectively, then replace all the occurrences of r i by s 2. The general case for merging two nodes v 1 , v 2 is to merge the two subtrees rooted at (a) If v 1 and v 2 are two attribute nodes, then this is the simple case discussed before. (b) Now
We replace v 1 , v 2 with a single node v carrying the same label as two incompatible nodes v 0 , v 00 , the merging fails. 5.2.3. Merging based on keys of his work, a specific work can be found in the instance.
 ( Q , ... , Q n )) immediately precedes R 0 1 ; R 0 2 ;  X  P 1 sure of the immediately precedes relation. (c) A set K of keys is transitive if for any key ( R other key ; R 0 2 ;  X  P 1 ; ... ; P m  X  2 K that precedes ( R keys.

Example 9. Consider the two keys defined in Example 8 , they are transitive since we can find absolute key r have the same type and title, and hence are merged by following r  X  X  X 1 X  X  (resp.  X  X 1998 X  X ), according to the singleton constraints imposed by target DTD. h 5.3. Chasing missing data singleton and key constraints, as discussed in Section 5.2 .

Consider the constraints defined in Example 8 again. Constraints r way. As an example, the equality of nulls r 1 and r 2 should be enforced according to r flicts w.r.t. target constraints.
 T where s r , or (c) a constant in T or R . Recall that f is required to preserve constants. clear that (a) if T R T 0 and T 0 R T , then T = T 0 ; and (b) if T ent constants, we therefore introduce a special XML instance denoted as X for such situations. 5.3.1. Chase Given two XML instances S , T , and a set R of non-key constraints. We write T  X  1. X  X  R X ; 2. if T R , T  X  R T ; otherwise $ r 2 R , T = r . W.l.o.g., let r  X  X  Q ; Q symbol mapping h , $ v 2 { s Q t }, $ v 1 , v 2 2 { v s Q 0 t }, val ( lates r . S is then obtained from T by a single application of one of the following rules: (a) if h ( u ) and h ( w ) are two distinct constants, then S = X ;
A chase of T by R is a maximal sequence T = T 1 , T 2 , ... , T and T i  X  T i +1 . We say that a chase succeeds if T n  X  X ; otherwise we say that a chase fails. r (resp. s 3 with s 2 ). W.l.o.g., we assume r 2 r 1 (resp. s result minimally differs from the original instance w.r.t.
 deterministic result ( Theorem 4 ).
 last element of a chase of T by R ,S R ; (3) If S is an instance in a chase of T by R and S  X  X ,T
Proof sketch: (3) Let the chase be T = T 1 , ... , T n , and S = T i . We prove by induction on i . T of T by R ,ifT R F and F R , then S R F.

Proof sketch: Let the chase be T = T 1 , ... , T n , and S = T induction hypothesis T k R F , there exists a mapping f as described before from T
Due to conflict w.r.t. r 2 R via a mapping h , T k +1 is obtained from T g ( h ( u )) = h ( w ). Since h ( u ) and h ( w ) are symbols in T therefore T k +1 R F via mapping f . h chase of T by R and T R F, then F = R .
 Proof sketch: Let S be the last but one element in the chase of T that ends with X , that is, S  X  Next we assume S R F , via a mapping f .
 serves constants. F violates r via f h . h
Theorem 4. T  X  X is an XML instance, and R is a set of non-key constraints. If two chases of T end with S respectively, S 1 =S 2 .

Proof sketch: By Theorem 1 , T R S 2 , and S 2 R . S 1 is an instance in a chase, by Theorem 2 , S follows S 1 = S 2 . h 6. Experimental study data exchange solutions. 6.1. Experimental setting are employed to control the data characteristics, for an in-depth analysis. then design an XML data exchange setting, in which (a) the target DBLP data are reorganized following authors name as a key and employ it to merge authors. 2. Book data. We scrape book information using the same keyword from three web sites, Google Books, Amazon and Book the search keyword. We implement data exchange by extracting data from the sources, and create target functional are many missing values (nulls) in the canonical instance. We mainly evaluate the performance of chase on Book data. functional dependencies. We then introduce noise to some of the attribute nodes. When noise is introduced, (a) with probability p 1 , target nodes of keys have same values on their child value nodes and (b) with probability p w.r.t. target constraints. 6.2. Optimization techniques and implementation
We next propose techniques to improve the efficiency of our algorithms; these techniques have been implemented when conducting the experiments. 1. Given a key ( Q , Q 0 ,( Q 1 , ... , Q n )), under the subtree rooted at s Q i t for all i 2 {1, ... , n }. We find it is too expensive to compare all the pairs of parisons is significantly reduced with the help of this technique, and hence the efficiency is improved. we build an index for each labeled null when the null is introduced in Algorithm Canonical . If a null r another null s j later, we merge the index for r i with that for s We have implemented all the algorithms in Java. All experiments are run on a machine with Intel Pentium Dual CPU
E2140, 1 GB memory, Ubuntu Linux 10.10. The experimental results report the average over five runs. 6.3. Experimental results
We next present our findings. 6.3.1. Exp-1: Effectiveness shown). These confirm that constraints help achieve better target instance. that constraints help improve the data quality. 6.3.2. Exp-2: Efficiency and scalability impact of source tree patterns, target constraints and noise ratio, using synthetic data. of nodes in target instance is larger than that in source instance (about three times for the experimental data). sults are given in Fig. 4 f.
 DBLP target instance grows much faster.

To further analyze the performance of our methods, we use synthetic data (XMark). We first investigate the impact of source tree patterns on the evaluation time. By varying the number of nodes in source instance from 30 K to 180 K in of the results are reported in Fig. 4 g, where patterns P and P 2 on XMark instances return the same result. The only difference is that P
The results tell us the following. (a) The evaluations of P over three different subtrees are accessed and compared in the evaluation of pattern P leads to some performance degradation.

We then evaluate the scalability of merging on XMark. By fixing p p with the increase of p 1 . Moreover, the overhead incurred by larger p caused by merging; the original instance with 120 K nodes has less than 50 K nodes after merging with p noise ratio ( p 2 ), and the number of non-key constraints ( j R j ). The basic setting is: j T j =60K, p time is governed by the time for value comparisons. The increase of p 7. Conclusions and future work
In this article, we consider the problem of target instance construction for XML data exchange. We have presented an methods.

In this paper, we develop techniques to construct XML target instances, based on the pre-defined mapping between the ) automatically generate the source-to-target dependencies by mapping schema elements between the source schema and future work to present techniques for generating the mapping in our enriched mapping language via some user-friendly Acknowledgments ence Foundation of China.
 References
