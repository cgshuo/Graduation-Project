 While current biomedical ontology repositories offer primitive query capabilities, it is difficult or cumbersome to support ontology based semantic queries directly in semantically annotated biomedical databases. The problem may be largely attributed to the mismatch betw een the models of the ontologies and the databases, and the mismatch between the query interfaces of the two systems. To fully realize semantic query capabilities based on ontologies, we develop a system DBOntoLink to provide unified semantic query interfaces by extending database query languages. With DBOntoLink, sema ntic queries can be directly and naturally specified as exte nded functions of the database query languages without any programming needed. DBOntoLink is adaptable to different ontol ogies through customizations and supports major biomedical ont ologies hosted at the NCBO BioPortal. We demonstrate the us e of DBOntoLink in a real world biomedical database with seman tically annotated medical image annotations. H.3.5 [Information Stor age and Retrieval] :On-line Information Services -Web-based services; H.2.3 [Database Management] : Languages -query languages Ontology, query languages Biomedical ontologies have pr oliferated in biomedical domains to support semantic queries, semantic interoperability and data integration [1, 2]. The National Center for Biomedical Ontology (NCBO) BioPortal [3, 4, 5] alone hosts nearly five million terms for about 260 ontologies. Example ontologies include NCI Thesaurus for cancer, RadLex [6] for radiology image annotations, GO [7] for genes, et c. Increasingly, biomedical databases are becoming semantic enabled through semantically annotated data models, i.e., da ta objects are described through links to ontological concepts. Ex amples are AIM model for NCI Image Markup and Annotation project [8], and the pathology analytical imaging standards (PAIS) project [9, 10]. Such semantically annotated databases provide the opportunity to support ontology based semantic queries. For example, a concept may be relaxed to provide more semantically related results: one may return descendant terms " gliosarcoma " and " giant cell glioblastoma " when a term " astrocytoma (WHO grade IV) " is posed in a query. Such operations need interplay between ontology queries and database queries, and require querying an ontology repository and integrating the results into database queries for further processing. Custom coding to support such que ries is possible, but requires major programming on translating queries back and forth between databases and ontology repositories . Such an approach is not generic either, and repeated development is needed for similar queries for each new database. Meanwhile, database users often prefer writing queries with a decl arative query language, such as SQL for tabular data and XQuery for XML data. For example, for above concept relaxation query, a user may want to specify a SQL query with a simple extended function like getHyponym(term) , without any additional programming. The gap in support for convenient ontology based queries in biomedical databases is exacerbated by the limitations of current biomedical repositories, includi ng complex interfaces, primitive query operations, and overhead of network communications. While biomedical repositories such as NCBO BioPortal provide the management and query capabilities for ontologies, the query interfaces are normally designed for machine consumption and are cumbersome for humans. For example, for the getHyponym query to retrieve a list of desce ndant terms, it can be supported by writing codes to submit queries to an ontology repository, e.g., NCBO BioPortal. The results returned from NCBO Portal interfaces, however, are very complex XML documents that have to be parsed, filtered and aggregat ed before further processing. In addition, ontology repositories normally provide primitive queries. To support a complex semantic query such as getHyponym , a user has to develop his/her own application with multiple queries on the ontology repository and additional semantic reasoning on query results. For example, for getHyponym query, recursive calls have to be called until no more descendant nodes are found. The limitation and mismatch of ontology repositories make it difficult to directly support the requirements of declarative, expressive and reusable semantic queries on biomedical database systems. This motivates us to develop DBOntoLink , a system to provide a middle layer between ontology repositories and semantically annotated databases to support semantic queries in the databases with declarative languages and interfaces. DBOntoLink provides the following salient features: i) support a comprehensive set of ontology based semantic operators as general functions extended for DBMSs; ii) allow users to write semantic queries by calling such functions expressed in standard database query languages without any programming needed; iii) automate semantic query tran slation between databases and ontology repositories; iv) achieve high efficiency through caching management of semantic queries; and v) support high adaptability to different biomedical ontol ogies through customizations. BioPortal implements ontol ogy services as two types of interfaces: SOAP based Web Services and RESTful based services. The latter processes HTTP URL formatted requests and responds with a set of result in th e form of XML. For example, to query the properties and related concepts of "lung" in RadLex, the following URL needs to be issued. In the expression, "45137" is the ontology version id and "RID29152" is the concept id. The result is an XML doc ument with 483 lines and a very complex XML schema. These interfaces are designed for machine based queries and processing, a nd have the following limitations for human: inconvenience for interpretation and editing, lack of advanced semantic operations , complex and often redundant XML result, and network delay. User defined functions (UDFs) in DBMSs provide an opportunity for close integration of ontology repositories into the database. A UDF could return a single value or tabular value  X  which can be further converted into a table view for SQL operations. Comprehensive applica tion logic, such as composing complex semantic operations on an ontology repository, can be realized as logically extended f unctions for SQL. It is thus expressive and convenient to us e. Next we discuss the overall architecture and methods of our work. DBOntoLink has three major components: the ontology repository, the semantic adapter, and the database extension. We rely on BioPortal (with its RESTful interfaces) as the ontology repository since it is the most commonly used biomedical ontology repository. The Semantic adapter provides a mediation layer between databases and the ontology repository, by supporting a comprehensive set of semantic operations. The semantic adapter sends requests to BioPortal, parses, processes and composes query results. Operations implemented in the semantic adapter are consumed by databases, in which semantic operations are wrapped as user defined functions to be invoked by SQL or XQuery queries. The semantic adapter provides three major components: the semantic query engine for pro cessing the semantic operations, caching management for caching query results to improve performance, and configuration management to configure the system for different ontologies (Figure 1). The semantic query engine provides semantic reasoning, query requesting and processing, and it interfaces with databases. The workflow of the engine is as follows: 1. When an adapter interface receives a function call issued by a UDF, the semantic reasoner analyzes the procedures and requests needed to answer this call. It then submits requests through the ontology connector. 2. Once the ontology connector receives a query request, it first checks the caching manager to see if this query has been previously issued. If the resu lt is already cached, it will be retrieved from the cache database directly. 3. If the query result is not cached, the ontology connector will issue RESTful requests composed by the request builder and transfers returned XML results to result parser. XML result, and passes them to the semantic reasoner via ontology connector. 5. After all the required information has been collected through multiple ontology repository calls, the semantic reasoner list of records. Transparently, this semantic adapter works as a translation engine to interpret expressive, simple semantic operations (seen by end users and applications) into a process of complex operations of ontology repository queries, result filtering and restructuring. To improve the efficiency when processing queries, we implement caching for query results to avoid the overhead of multiple query requests to remote repositories. Both metadata of concepts and relations between concepts are cached. The caching management provides significan t speedup of semantic query processing, as the performance st udy of Section 6 demonstrates. hierarchies and relationships [11]. DBOntoLink provides customization to define the mappi ng between relation label and its conceptual meaning, as well as the mapping between ontology name and the used version. This is defined in an XML based ontology via the configuration loader when the adapter is initialized. This class of functions empl oys the search service of BioPortal to retrieve a term's metadata.  X  getDescription : Retrieve description or definition of a term.  X  getSemanticType : Obtain the semantic type or role of a term.  X  getChildCount : Retrieve the count of all child terms.  X  getRelevantTerm : Retrieve all the relevant terms for each Operations in this set are implemented based on the term service of BioPortal, and focus on retrieving related concepts for a given concept.  X  getHyponym: When a user speci fies a query with a term,  X  getHypernym : In many cases, there may not be any result  X  getSynonym : Queries using a precise term often suffer from  X  getSibling : Retrieve concepts that belong to the same The operations in this se t examine relations among multiple concepts.  X  getCommonAncestor : Given a set of terms, return ancestral  X  getCommonDescendant : Given a set of terms, return mutual  X  getRelation : Discover relation between two concepts, check The operation in this set adapts the annotation service of BioPortal.  X  getAnnotation : Annotate the terms in given text, return score We first implement the a bove semantic operations as Java based APIs, and then port them into upper level interfaces: UDFs for databases, as discussed next. Implementation of UDFs wraps the Java APIs as database user defined functions based on specifi c database UDF specifications. We use DB2 in our current impl ementation. These UDFs can be directly invoked by SQL queries just as normal SQL functions, therefore they offer great usability and convenience for database users. A scalar function, such as getDescription, getChildCount and checkRelation, returns a single value for each record of a query. For example, the following SQL que ry retrieves the description for all the terms in the column " Cell_Name ": A table function, such as getHyponym, getCommonAncestor and getAnnotation , can be applied in the FROM clause of a SQL query. For example, the following query selects records with Cell_Name as the hyponym of " Giant Cell ", with results ordered by the relevance rank: AIM is a caBIG project deve loped by Northwestern University and Stanford University [8]. The goal of AIM is to provide standardization for image annota tion and markup, especially for clinical trials. The Anatomic Entity, ImagingObservation, and ImagingObservationCharacteristic classes represent essential features for an annotation, and relies on an ontology (e.g., RadLex or NCI Thesaurus) or controlled vocabulary to populate the data. The representation of AIM data is an XML based format. We use the LIDC dataset [12] for our examples and load the dataset into DB2 database with XML documents stored as XML type. Next we show one sample use case that the XQuery/SQL queries are semantically enriched with the UDFs we developed: retrieve all SELECT * 
FROM table (getHyponym( 'NCI' , 'Giant Cell' , 1) ) AS a , mytable AS b WHERE a.terms = b. cell_name ORDER BY a.rank SELECT cell_name , getDescription ('NCI' , a.cell_name ) 
FROM m y table AS a the image annotation documents that contain the descendant terms of the term " lobular organ ": We present experimental results of typical UDFs with sample test cases summarized in Table 1. The experiment is performed with the NCI Thesaurus ontology hosted at BioPortal, and the database we use is IBM's DB2 V9.7. The machine we use for the test is a desktop with i5-760 at 2.8GHz, 8GB of RAM, 1TB RAID 0 (2 x 500GB SATA7200rpm HDDs) hard drive. The running time for each query is the average of 10 executions. getDescription Retrieve the description of "Abnormal Cell" getChildCount Retrieve child node amount of "Abnormal Cell" getHypernym Retrieve the parent node of "Neoplastic Cell" getHyponym Retrieve the child nodes of "Neoplastic Cell" checkIfAdjunct Check if concepts "Abnormal Germ Cell" and getRelation Retrieve the relation of "Abnormal Cell" and getCommonAnc estors comparison between methods without caching and with local caching. The experiment of querying without catching shows that simple queries take around 1 second as only one or two HTTP requests are needed. However, comp lex queries take much longer. This is because many complex queries are reasoned as queries with recursive operations that result in multiple repository requests. Such performance is unacceptable when a query runs across many terms. With caching, most queries run within 0.1 second, a significant performance improvement. While ontologies are prolifer ating in biomedical domains, most biomedical data are available as structured data managed in relational DBMS or XML DBMS. There is a lack of tools to ease the integration and use of ontologi es in databases using standard query languages or query interfaces. DBOntoLink provides a bridge layer between ontology repositories and databases to support semantic operations direc tly inside a database based on standard database query language s. Executed on top of existing ontology repositories, DBOntoLink supports a comprehensive set of generalized semantic operators , and makes them available as expressive functions that directly accessible in a database or application. Through caching, DBOntoLink provides superior performance for most queries. This research is supporte d in part by PHS Grant UL1RR025008 from the CTSA program, R01LM009239 from the National HHSN261200800001E. [1] Cimino, J. J. and Zhu, X. (2006). The practical impact of [2] Rubin, D. L., Shah, N. H. and Noy, N. F. (2007). Biomedical [3] NCBO BioPortal. bioportal.bioontology.org/. [4] Noy NF, Shah NH, Whetzel PL, Dai B, Dorf M, Griffith N, [5] Whetzel PL, Noy NF, Shah NH, Alexander PR, Nyulas C, [6] RadLex: A Lexicon for Unif orm Indexing and Retrieval of [7] Gene Ontology. http://www.geneontology.org/. [8] Channin, D., P. Mongkolwat, V. Kleper, K. Sepukar, and D. [9] Pathology Analytical Imaging Standards (PAIS). [10] Wang F, et al: A Data Model and Database for High-[11] Smith B, Ceusters W, Klagge s B, K X hler J, Kumar A, Lomax [12] S. G. Armato III, McNitt-Gray M. F., and et al. The Lung declare namespace ns1 ="gme://caCORE.caCORE/3.2/edu.north western.radiology.AIM "; for $a in db2-fn:xmlcolumn ('XMLTABLE.XMLCOLUMN' )/ ns1:ImageAnnotation for $hypo in db2-fn:sqlquery ("select xmlcast(terms as xml) from table (getHyponym( 'NCI' , 'lobular organ ', 1))") where $a/ ns1:imagingObservationCollection / ns1:ImagingObservation / ns1:imagingObservationCharacteristicCollection / ns1:ImagingObservationCharacteristic / @ codeMeaning = $hypo return $a 
