 A semantic class is a collecti on of items (words or phrases) sharing common semantic properties. This paper proposes an approach to constructing one or multiple semantic classes for an input item. Two challenges are a ddressed: multi-membership, and noise-tolerance. H.3 [ Information Storage and Retrieval ]: Information Search and Retrieval  X  search process ; I.2 [ Artificial Intelligence ]: Learning  X  knowledge acquisition Algorithms, Experimentation Semantic class, Lexical semantic relationship, Noise-tolerance Semantic class construction [1,3,4,5 ] tries to discover the peer or sibling relationship among phrases by organizing them into semantic classes. For example, {red, white, black, blue, pink...} is a semantic class consisting of color instances. Semantic classes may have their applications both in natural language processing and in web search [4]. This paper aims at discovering semantic classes from massive web documents. Given a collec tion of web documents, some raw semantic classes (abbreviated as RASC, Table 1) can be obtained by applying specific patterns (Table 2) to every web page [4,5]. RASCs cannot be treated as the u ltimate semantic classes, because they are typically noisy and incomplete. In addition, the information of one real semantic class may be distributed in a lot of RASCs. With a RASC collecti on in hand, when given an item (a term or a phrase) as a query, we are required to generate one or multiple semantic classes to which the item belongs. We want to meet two im portant requirements here: multi-membership , and noise-tolerance . Multi-membership means that one item may belong to multiple semantic classes. For example, term  X  X incoln X  can simultaneously represent a person, a place, or a car brand name. Web pages may co ntain many irregular or even invalid sentences and complex ta g structures, resulting in noisy RASCs (see Table 1). Existing pattern-based approach es only provide very limited support to multi-membership. Some approaches simply take the RASCs as final semantic classes [5], or merge all RASCs with the are mutually improved and cleaned by an iterative process. The output of the algorithm is the cleaned C R and G I . Each vertex of G I corresponds to an item a ppearing in at least one RASC of C R . And the weight of an edge represents the similarity between the items corresponding to the edge X  X  two vertices, computed as, pattern via which the RASC is extracted, and w ( P ) is the weight corresponding to site i . By this formula, we try to distinguish the reliability of different patterns and punish term similarity contributions from the sa me site (or domain). Cleaning C R with G I is achieved by removing from each RASC the item(s) whose average similarity to other items in the RASC is much smaller than the average similarity between every pair of items in the RASC. Dominant item class generation : In this phase, we derive for each item a new item class called its dominant item class (DIC). All DICs constitute a new collection called C D . We take top-m ( m =100 in implementation) neighbors of t as candidate items. Each candidate item nbr is checked for being a DIC member of t . Some conditions should be satisfied: First, t should be top neighbors of nbr . Second, the similarity between nbr and t should not be too small relati ve to the average similarity between nbr and its top neighbors. Semantic class generation : Receives a query item q as input, and generates a list of semantic cl asses to which the item belongs. Before answering queries, an inverted index is built from all the dominant item classes. Via the inverted index, all dominant item classes containing one specified item can be quickly accessed. When given a query, we first re trieve all DICs containing the query, and then use an agglomer ative hierarchical clustering (AHC) algorithm to generate the final semantic classes. The average similarity between every item in C 1 and every item in C 2 . Item graph G I is used here for looking up item similarity. By using ODP (the Open Direct ory Project: http://www.dmoz.org) URLs as seeds, we crawled abou t 40 million English web pages in a breadth-first way. RASCs are extracted via applying a list of sentence structure patterns and HTML tag patterns. Table 3 shows the semantic classe s generated by our approach for some sample queries. We can see that our approach is able to effectively supporting multi-memb ership, i.e., assigning one item into multiple semantic classes. The first phase of our approach is critical for dealing with noise in the original RASCs. To test the noise-tolerance ability of our approach, we compare it with an alternative one called NaiveIGC (Na X ve item graph constructi on), in which the item graph G I is constructed in a simple way, without iteratively cleaning G I and C and without computing item sim ilarities using Formula 2.1. Instead, the similarity between two items is computed by simply counting the number of RASCs containing them. 
