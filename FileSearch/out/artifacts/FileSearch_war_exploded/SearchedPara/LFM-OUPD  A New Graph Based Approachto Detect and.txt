 Open source libraries and frameworks has mushroomed in the nearly ten years. Modern software industry cumulatively depends on third-party APIs provided by open source organizations [22]. Inevitably, programmers extensively leverage Application Programming Interfaces (APIs) to implement functionality and per-form various tasks, which support code reuse and help unify programming expe-rience. However, APIs have grown exponentially and become more inseparable from software development current days. For instance, to establish a primary website using SpringMVC framework, programmers need to invoke dozens of APIs, including data storage API, Java Messaging Service (JMS), ServletAPI experienced programmers find it impossible to gain a thorough understanding of each API. Furthermore, various barriers factors [11], [3] cause APIs hard to learn, such as insufficient or inadequate examples, unspecified issues with API X  X  structural design, uncompleted or ambiguous documentation. Therefore, assist-ing programmers fully comprehend APIs effectively and efficiently with less effort is a critical job.
 about an API, they have to browse the documentation or code examples even articles on Internet for solutions manually. Also, they experiment with APIs or ask colleagues sometimes.
 source for programmers while learning usages of APIs [11]. This is also evident by the rapid development of code search engines (CSEs). Recent work has helped programmers alleviate burden and better understand individual APIs. These ap-proaches focus on source code analyzing, API usage mining, API pattern clus-tering and code candidates ranking. To extract API usage pattern from client code, most source code analyzers are based on Eclipse X  X  JDT compiler. In the stage of API usage recommendation, various clustering and ranking algorithms are proposed. [16] utilizes Pearson Correlation Coefficient (PCC) to measure the similarity between two items, and proposes a user-group item-based collaborative filtering approach CF for recommendation. [7] precomputed similarities between APIs using Relational Topic Modeling (RTM) and visualize API usage in the call graph view. Both UP-Miner and MAPO[22] are based on BIDE algorithm to mine closed sequential method pattern for detect API usages.
 tures similar to social networks. In this situation network community discovery methods will be suitable to explore the programming information raw data. In this paper, we propose an approach LFM-OUPD(Local fitness measure for de-tecting overlapping usage patterns) for API usage facility from data analytics perspective to help recommend proper code examples. We collect corresponding API method sequences from data set, and construct links among API method elements, storing as graph structure. A mining algorithm based on Local fit-ness measure(LFM) is provided to detect usage patterns. After identifying and ranking API usage patterns pattern with various features, we select the most ap-propriate examples for the programmers. At last, we evaluate the effectiveness of our approach using a Google Guava API case study. 1 an approach, LFM-OUPD, to detect and rank API usage pattern in software repository and recommend proper code examples for programmers. A case study on Google Guava is conducted to evaluate the effectiveness of this approach in section III. Section IV summarizes related work including various recommending systems and technologies. Lastly, we conclude this paper in section V. Aiming at addressing identified issued during finding proper API code exam-ples, a recommendation approach, LFM-OUPD(Local fitness measure for de-tecting overlapping usage patterns), is proposed. In LFM-OUPD, API method sequences are extracted based on the API implementation to model implicit API usage dependencies. LFM-OUPD takes these API usage dependencies as bases for recommendation to keep the suggested API usage pattern candidates appropriate for developers.
 programmer specifies the name of an API method that needs code examples as a query. Then, the corresponding method information of target API method are collected from existing data set. LFM-OUPD utilizes a method sequences graph constructor(Section 2.1) to capture the detailed structural links among API method elements in conceptual source codes and storing as graph struc-ture. An API usage pattern detector(Section 2.2) is proposed for classifying and mining different API usage patterns from the method sequence diagram. An optimized candidate API usage recommender(Section 2.3) will also be useful in processing and generating sorted API usage pattern list quickly. Finally, proper API usage patterns and code examples candidates of different API usages are recommended to the API programmers. 2.1 Method Sequences Graph Constructor Preparing Data Set For most APIs with rich set of client code on Internet, potential sources files with code examples can be directly collected from existing data source. We collect data from Open Source Software(OSS) repositories on GitHub. 2 We consider projects hosted on GitHub that provide APIs features could meet our basic data quality requirement.
 projects within GitHub and use them to gather fine-grained type-based informa-tion traversing each project file of each API client. We download all the related client GitHub project files and extract the relevant API method usage informa-tion among these code snippets.
 Collecting Corresponding API Method Sequences After API method queries accepted from programmers, our approach performs search to obtain related method information from API usage data set. We locate all the class files where target API method ever appeared and collect their method invocation information together. We conduct a method sequence for each class file, which follows a method invocation sequential order. In addition, the information about class name, project name, url access of Github class and so on will also be collected and stored.
 Constructing Links Among API Method Elements After collecting cor-responding API method sequences, the detailed structural links among API method elements in conceptual source codes are captured and stored as graph structure illustrated in figure 3. We have selected this type of storage method because the extracted API information can be naturally expressed in forms of call graphs among the entities. Nodes in the graph represent API methods, such as  X  X om.google.common.cache.CacheBuilder.newBuilder() X . The edge in this di-rected graph represents methods sequential order appearing in the same class file. Take for example, if there is  X  X  X  &gt; B X  , that means method B appeared fol-lowed by method A in class files. Also, the weight of this edge represents the number of times that method A and B occur together. Weight of edge is an im-portant metric to evaluate the tightness of two API method, which contributes to detect API usage pattern in the latter section.
 2.2 API Usage Pattern Detector The method sequence graph can be treated as a directed weighted complex net-work. We transfer the API usage pattern detecting question to the exploration question of high weight code sequences. Recent years, researchers propose many classical community detecting algorithms[8,20,2,5] to investigate complex net-works and their natural characteristics. Lancichinetti[4] proposed a overlapping community detecting algorithm(Local fitness measure, LFM), based on the local optimization of a fitness function. The core principle of LFM is suitable to ex-plore the division of method sequences in the directed source code element graph. In this section, we propose a local extension algorithm of detecting overlapping usage patterns(LFM-OUPD) based on LFM.
 Directed Degree Centrality of Method Node In directed weighted source code graph, a method node owns a large directed degree centrality usually means that the node is in the center of overall code network, and this node is close to the neighboring method nodes. This kind of node is called core seed node of the directed source code graph. The directed degree centrality of one node is affected by weighted in-degree and weighted out-degree of the node. In order to search a node with a high directed degree centrality in the directed weighted code graph, we introduce a definition of directed degree centrality C i : out-degree, and  X  is the weight parameter, which is used to adjust the weight of in-degree and out-degree in the directed degree centrality.
 Neighbour Nodes Calculation Rules Considering the characteristics of method sequence diagram, the neighbour nodes of UP i is identified as successor of leaf nodes in UP i , and predecessor of parent nodes in UP i . We don X  X  take successor or predecessor of other nodes in UP i into consideration when finding neighbour nodes. As the code snippets are naturally existed as a single directed method chain diagram, the mined results are expected to be a method sequence diagram which only one-way direction flows permitted. What noteworthy the fact is that, if there is a sub-ring in the method sequence diagram, we treat the sub-ring as a whole to determine whether it is a parent or leaf node, and find there common successor or predecessor.
 Directed Fitness Function of API Usage Patterns Directed Fitness Func-tion of API Usage Patterns f( UP i ) is utilized to measure the extent of impact when a node joins the API usage pattern UP i . As the internal connection is close and the external connection is sparse, when f( UP i ) reaches the peak, optimal division of a method sequence UP i is produced. If one node has a significant impact on its neighborhood sequences, the node is divided into multiple API Usage Patterns, and then the overlapping method sequence structure is formed. Consider the characteristics of directed weighted edge graph structure, f( UP i ) is defined as: sents total weight of edges directed from leaf nodes in UP i to neighbour nodes, W parent represents total weight of edges directed from neighbour nodes to parent nodes in UP i ,  X  is the threshold parameter used to control the size of the API usage pattern produced. Considering the characteristics of method sequence di-agram and neighbour nodes calculation rules, the method sequence list need to be single directed. Thus, the fitness function only cares about edges pointed to parent nodes in UP i , and edges comes from leaf nodes in UP i , when calculating weights between UP i and outside.
 API Usage Patterns Detecting Algorithm Based on LFM algorithm, the method sequences graph, and constantly merge the neighbors to produce the API usage pattern. Firstly, the largest node with directed degree centrality is found as the core node, and the neighbor nodes with the greatest influence on the directed fitness function f( UP i ) are merged continuously. Finally, the API usage pattern UP i is produced. After forming a usage pattern, select the core node in the rest nodes to continue next division of the usage pattern, and ultimately all the nodes in the graph are included in the usage patterns. Algorithm 1 describe the overall process of detecting API usage patterns algorithm.
 Input: Method Squences Graph, threshold parameter = 1 Output: Usage Patterns Collection 1. Calculate the directional center of each node in the graph 2. Select nodei with the largest center degree as core seed node 3. Initialize Usage pattern UPi containing only nodei 4. Calculate neighbor nodes of UPi 5. Add neighbor node to UPi respectively, and calculate f(UPi) 6. If node with the largest change in f(UPi) &gt; 0 7. Merge that node into UPi 8. Repeat Step 4-7 untile f(UPi) reach the largest 9. If there are nodes not in usage patterns 10. Select rest nodei with the largest degree as core node 11. Jump to Step 3 2.3 Candidate API Usage Recommender Candidate API patterns ranking mechanism is also required to evaluate score of usage pattern and assist to pick appropriate API usage pattern candidates. There are three appropriateness metrics: cohesiveness, availability and correctness to calculate the final score, which is positive correlated with the importance of a API usage pattern. The final score is the summation of the three metrics. The higher the score value, the more appropriate the API usage for recommendation. We use total weight of edges between nodes in UP i , W in all as cohesiveness metric. The second evaluates the availability of a usage pattern, if there are too many island method calls appearing in a pattern, this metric will be decrease. The third metric evaluate the significance of all the method calls respected to correct API usage. We consider only method calls of third-party method, If there occurs a method called by a developer X  X  own class in a usage pattern, the significance will be decreased. 2.4 Candidate Code Examples Recommender We use the following recommendation mechanism to rank code examples of one API usage pattern and pick the code snippets with the best demonstrative effect: we prefer code snippet with less lines; prefer examples containing more comments; prefer code examples using less methods apart from those in the target API usage pattern. We conducted an experimental case study on LFM, and LFM-OUPD. The case study is performed to investigate whether LFM-OUPD can assist programmers figure out API usage patterns and locate code examples effectively. 3.1 Setup To establish the current dataset, we focus our effort on one programming lan-guage, Java, and we select one specific API library, Google Guava. 3 . This made our data collection and processing more relevant and manageable. We utilized data set offered by Sawant[14], which downloaded over 3000 projects from GitHub and extracted method invocation information into relational database. 3.2 CacheBuilder Case The CacheBuilder class 4 in Google Guava provides support to actually construct cache instances and set the desired features. It uses fluent style of building and provides various options of setting properties on the cache. CacheBuilder offers two different handy initialization mechanisms. The first initialization mecha-nism performs initialization from a CacheLoader, which is typically as easy as implementing the method  X  X  load(K key) throws Exception X . The second handy mechanism performs from a Callable, which is more flexible, identified when cache.get() is invoked. Different code examples are required to demonstrate the utilization of two initialization mechanisms.
 study aims to investigate whether LFM-OUPD can assist programmers locate API pattern and code snippet examples of interest efficiently. Table 1 illustrates the API usage pattern detecting results by LFM. LFM returns 2484 API us-age patterns from the API method-based sequences diagram. There are 16 API usage patterns containing target API approach method. Only two of them are valid usage patterns that correctly demonstrate CacheBuilder usages. However, these two method sequences still missed approaches comparing to representative code examples. Column  X  X xample X  stands for the number of class files where the mined API sequences all appeared together. This metric is used to valuate the popularity of the API usage pattern, and the final recommended code snippets will be selected from these example candidates.
 sequences diagram. There are 76 API usage patterns containing target API ap-proach method CacheBuilder.newBuilder(), and have been sorted by ranking scores. By inspecting top 10 API method-based sequence graph of each can-didate, the mapping between API usage patterns and different CacheBuilder cache mechanisms is summarized in table 2 . There are eight valid usage pattern candidates that correctly demonstrate CacheBuilder usages. Method sequence candidates from pattern 1to 4 demonstrate mechanism of setting eviction cache features with different requestor objects and attributes. Method sequence dia-gram from pattern 5 demonstrates mechanism of initialization from a Cache-Loader. API usage pattern 6 demonstrates mechanism of initialization from a Callable. Sequence candidates from pattern 7 to 8 demonstrate mechanism of reference-based eviction. We take the results of pattern 5 as an example, the cor-responding method sequence for  X  X nitialization from a CacheLoader X  usage is as follows, and code snippet of  X  X acheBuilder.newBuilder X  for this pattern returned by our approach is illustrated in figure 4. com.google.common.cache.CacheBuilder.newBuilder com.google.common.cache.CacheBuilder.maximumSize com.google.common.cache.CacheBuilder.build com.google.common.cache.LoadingCache.get grammers to identify different API usages. Also, LFM-OUPD greatly help pro-grammers pick up appropriate representative code examples transformed from API usage candidates with less selecting and modification effort. Several recommendation systems[10,13,9,1] have been designed to suggest rele-vant API usage examples for supporting programming tasks. They can be or-ganized in the following categories according to the data-mining mechanisms of their proposed techniques: web search based recommendation, social media based recommendation, online code search based recommendation.
 Web Search Based Recommendation Some researches try to extract re-lated information from numerous web pages, then deliver uniform views to pro-grammers. Mica[15] aims at identifying specific relevant API elements, such as methods and class names. It uses Google Web APIs to generate better web search results based on predefined dictionary. APIExamples[18] performs in-depth analysis on the collected code snippets and descriptive texts from web pages, including usage examples clustering and ranking. It provides two kinds of user interaction style: an IDE plug-in and a web search portal.
 Social Media Based Recommendation Other contributions tried to lever-age modern Q&amp;A websites to provide efficient recommendations. Various tech-nology forums offer concise answers and rich technical contexts including exe-cutable code snippets. Example Overflow[21] uses built-in social mechanisms of the popular technical forum, Stack Overflow 5 to recommend embeddable and high quality code. To ensure retrieval of high-quality results, Example Overflow follows a conservative approach by only choosing accepted answers having code snippets inside. It is based on Apache Lucene library and currently deployed as a free and public website. 6 Online Code Search Based Recommendation The most related contribu-tions are those interested in mining API usage pattern from common online code search engine and code snippet recommender. Current CSEs nearly wholly lever-age text-oriented information-retrieval(IR) techniques that disregards inherent structure of source code. To address this problem, researchers have presented numerous approaches [6,12,19,13,17] to improve defects of CSEs or develop a new recommendation engine. These are generally designed to work in the form of integrated development environment (IDE) plug-in to interact with program-mers. MAPO[22] mines API usage pattern from large number of code snippets gathered by online code search engines such as Google Code Search. 7 In par-ticular, based on the BIDE algorithm, MAPO combines frequent subsequence mining with clustering to mine closed sequential pattern. In addition, it provides a recommender integrated with Eclipse IDE. In this work , an approach, LFM-OUPD, is proposed to recommend proper code examples for assisting programmers learning API more efficiently. LFM-OUPD is a new graph based approach, accepting an API method name as the query and collecting corresponding code files from related data set. The detailed structural links among API method elements in conceptual source codes are captured and stored as graph structure. In LFM-OUPD, a mining algorithm based on LFM is presented to detect candidates of different API usage patterns. Also three appropriateness metrics are provided to assist ranking and recommending usage pattern. The effectiveness of LFM-OUPD is evaluated through a comparison case study. The study results confirm that, given an API method, LFM-OUPD can detecting its various usages and recommend reliable code examples.
