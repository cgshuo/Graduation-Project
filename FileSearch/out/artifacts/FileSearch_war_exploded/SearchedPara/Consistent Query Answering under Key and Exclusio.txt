 } Research in consistent query answering studies the defini-tion and computation of  X  X eaningful X  answers to queries posed to inconsistent databases , i.e., databases whose data do not satisfy the integrity constraints (ICs) declared on their schema. Computing consistent answers to conjunctive queries is generally coNP-hard in data complexity, even in the presence of very restricted forms of ICs (single, unary keys). Recent studies on consistent query answering for database schemas containing only key dependencies have an-alyzed the possibility of identifying classes of queries whose consistent answers can be obtained by a first-order rewrit-ing of the query, which in turn can be easily formulated in SQL and directly evaluated through any relational DBMS. In this paper we study consistent query answering in the presence of key dependencies and exclusion dependencies . We first prove that even in the presence of only exclusion dependencies the problem is coNP-hard in data complex-ity, and define a general method for consistent answering of conjunctive queries under key and exclusion dependencies, based on the rewriting of the query in Datalog with nega-tion. Then, we identify a subclass of conjunctive queries that can be first-order rewritten in the presence of key and exclusion dependencies, and define an algorithm for comput-ing the first-order rewriting of a query belonging to such a class of queries. Finally, we compare the relative efficiency of the two methods for processing queries in the subclass above mentioned. Experimental results, conducted on a real and large database of the computer science engineering degrees of the University of Rome  X  X a Sapienza X , clearly show the computational advantage of the first-order based technique. H.2.3 [Database Management]: Languages X  X uery lan-guages; F.2.0 [Analysis of Algorithms and Problem Com-plexity]: General.
 Copyright 2005 ACM 1-59593-140-6/05/0010 ... $ 5.00. Theory, Algorithms, Experimentation.
 Inconsistency, Computational Complexity, Query Rewrit-ing.
Suppose to have a database whose data violate the in-tegrity constraints (ICs) declared on its schema. What are the answers that have to be returned to queries posed to such a database? The standard approach to this prob-lem is through data cleaning, i.e., by explicitly modifying the data in order to eliminate violation of ICs: only when data are  X  X epaired X , i.e., are consistent with the ICs, queries can be answered. However, in many situations it would be much more desirable to derive significant information from the database even in the presence of data inconsistent with the ICs. Indeed, in many application scenarios, the ex-plicit repair of data is not convenient, or even not possible. This happens, for instance, in data integration applications, which provide a unified, virtual view of a set of autonomous information sources [5].

This alternative approach is the one followed by research in consistent query answering , which studies the definition (and computation) of  X  X eaningful X  answers to queries posed to databases whose data do not satisfy the ICs declared on the database schema [1, 14, 4]. All these approaches are based on the following principle: schema is stronger than data . In other words, the database schema (i.e., the set of in-tegrity constraints) is considered as the actually reliable in-formation (strong knowledge), while data are considered as information to be revised (weak knowledge). Therefore, the problem amounts to deciding how to  X  X epair X  (i.e., change) data in order to reconcile them with the information ex-pressed in the schema. Therefore, the intuitive semantics of consistent query answering can be expressed as follows: a tuple t is a consistent answer to a query q in an inconsistent database D if t is an answer to q in all the repairs of D , i.e., in all the possible databases obtained by (minimally) modifying the data in D to eliminate violations of ICs.
Example 1. Let D = { r ( a, b ) } be a database whose schema contains the declaration of a key dependency on the first attribute of r . Since the database instance does not vio-late the key dependency on r , the only repair of the database is D itself. Hence, the following query q ( X, Y ) : X  r ( X, Y ) has the consistent answer t =  X  a, b  X  . Now, let D 0 be the database instance obtained by adding the fact r ( a, c ) to D . D 0 is inconsistent with the key dependency, and has two pos-which is an answer to q in both repairs, it follows that there are no consistent answers to the query q in D 0 . In contrast, observe that the query q 0 ( X ) : X  r ( X, Y ) has the answer  X  a  X  both in D and in D 0 , which can be therefore considered con-sistent.

Recent studies in this area have established declarative se-mantic characterizations of consistent query answering over relational databases, decidability and complexity results for consistent query answering, as well as techniques for query processing [1, 6, 14, 4, 3, 5]. In particular, it has been shown that computing consistent answers of conjunctive queries (CQs) is coNP-hard in data complexity, i.e., in the size of the database instance, even in the presence of very restricted forms of ICs (single, unary keys).  X From the algorithmic viewpoint, the approach mainly followed is query answering via query rewriting: (i) First, the query that must be processed (usually a conjunctive query) is reformulated in terms of another, more complex query. Such a reformulation is purely intensional, i.e., the rewritten query is independent of the database instance; (ii) Then, the reformulated query is evaluated over the database instance. Due to the semantic nature and the inherent com-plexity of consistent query answering, Answer Set Program-ming (ASP) is usually adopted in the above reformulation step [14, 3, 5], and stable model engines like DLV [15] can be used for query processing.

An orthogonal approach to consistent query answering is the one followed by recent theoretical works [1, 6, 13], whose aim is to identify subclasses of CQs whose consistent answers can be obtained by rewriting the query in terms of a first-order (FOL) query. The advantage of such an approach is twofold: first, this technique allows for computing consistent answers in time polynomial in data complexity (i.e., for such subclasses of queries, consistent query answering is compu-tationally simpler than for the whole class of CQs); second, consistent query answering in these cases can be performed through standard database technology, since the FOL query synthesized can be easily translated into SQL and then eval-uated by any relational DBMS. On the other hand, this ap-proach is only limited to polynomial subclasses of the prob-lem. In particular, Fuxman and Miller in [13] have stud-ied databases with key dependencies, and have identified a broad subclass of CQs that can be treated according to the above strategy.

In this paper we study consistent query answering in the presence of key dependencies and exclusion dependencies , a well-known class of ICs. Notice that exclusion dependencies are not only typical of relational database schemas, but are also relevant and very common in languages for conceptual modeling, e.g., ontology languages [2]: indeed such depen-dencies allow for modeling partitioning/disjointness of enti-ties. This makes the study of exclusion dependencies par-ticularly important for the broad applicability of consistent query answering.

Our contribution can be summarized as follows: 1. We prove that consistent answering of conjunctive 2. We define a method for consistent query answering 3. We extend the work of [13] to the presence of exclu-4. We compare the relative efficiency of these two meth-Our experimental results clearly show, for KE -simple queries, the computational advantage of the specialized first-order based technique over the more general one based on Datalog  X  . In particular, the results indicate that the advan-tage of the first-order based technique grows with the num-ber of database tuples that violate the ICs. Such results thus provide, in a general sense, an experimental validation of the first-order based approach: its computational advantage is not only theoretical, but also can be effectively measured when applied to practical, realistic scenarios. However, it turns out that the general method based on Datalog  X  , al-though not specifically tailored for KE -simple queries, proves particularly efficient in the presence of few data inconsisten-cies.

In the next section, we briefly introduce the formal frame-work of consistent query answering. In Section 3, we prove coNP-hardness of consistent query answering under only ex-clusion dependencies, and present our Datalog  X  rewriting and our algorithm for first-order rewriting in the presence of key and exclusion dependencies. In Section 4, we present our experimental results, and in Section 5 we address related work and conclude the paper. http://sv.mat.unical.it/infomix .
Syntax. A database schema S is a triple  X  X  , K , E X  , where:
A term is either a variable or a constant symbol. An atom is an expression of the form p ( t 1 , . . . , t n ) where p is a relation symbol of arity n and t 1 , . . . , t n is a sequence of n terms (either variables or constants). An atom is called fact if all the terms occurring in it are constants. A database instance D for S is a set of facts over A . We denote as r the set { t | r ( t )  X  X } .

A conjunctive query of arity n is an expression of the form h ( x 1 , . . . , x n ) : X  a 1 , . . . , a m , where the atom h ( x is called the head of the query (denoted by head ( q )), and a , . . . , a m , called the body of the query (and denoted by body ( q )), is a set of atoms, such that all the variables occur-ring in the query head also occur in the query body. In a conjunctive query q , we say that a variable is a head vari-able if it occurs in the query head, while we say that a variable is existential if it only occurs in the query body. Moreover, we call an existential variable shared if it occurs at least twice in the query body (otherwise we say that it is non-shared ). A FOL query of arity n is an expression of the form { x 1 , . . . , x n |  X ( x 1 , . . . , x n ) } , where x are variable symbols and  X  is a first-order formula with free variables x 1 , . . . , x n .

Semantics. First, we briefly recall the standard evalua-tion of queries over a database instance. Let q be the CQ h ( x 1 , . . . , x n ) : X  a 1 , . . . , a m and let t =  X  c ple of constants. A set of facts I is an image of t w.r.t. q if there exists a substitution  X  of the variables occurring in q such that  X  ( head ( q )) = h ( t ) and  X  ( body ( q )) = I . Given a database instance D , we denote by q D the evaluation of q over D , i.e., q D is the set of tuples t such that there exists an image I of t w.r.t. q such that I  X  X  .

Given a FOL query q and a database instance D , we de-note by q D the evaluation of q over D , i.e., q D = { t 1  X ( t 1 , . . . , t n ) is the first-order sentence obtained from  X  by replacing each free variable x i with the constant t i .
Then, we define the semantics of queries over incon-sistent databases. A database instance D violates the KD key ( r ) = { i 1 , . . . , i k } iff there exist two distinct facts r ( c 1 , . . . , c n ), r ( d 1 , . . . , d n ) in D such that c each j such that 1  X  j  X  k . Moreover, D violates the r ( c 1 , . . . , c n ), r 2 ( d 1 , . . . , d m ) in D such that c each ` such that 1  X  `  X  k .

Let S =  X  X  , K , E X  be a database schema. A database instance D is legal for S if D does not violate any KD in K and does not violate any ED in E .
 A set of ground atoms D 0 is a repair of D under S iff: (i) D 0  X  D ; (ii) D 0 is legal for S ; (iii) for each D 00 such that D 0  X  D 00  X  D , D 00 is not legal for S . In words, a repair for D under S is a maximal subset of D that is legal for S .
Let q be a CQ. A tuple t is a consistent answer to q in D under S iff, for each repair D 0 of D under S , t  X  q D 0 Example 2. Consider the database schema S =  X  X  , K , E X  , where A comprises the relations Journal ( title, editor ) , ConfPr ( title, editor ) and Editor ( name, country ) , K comprises the dependen-cies key ( Journal ) = { 1 } , key ( ConfPr ) = { 1 } , key ( Editor ) = { 1 } , E comprises the dependency Journal [1]  X  ConfPr [1] =  X  . Consider the database instance D described below It is easy to see that D is not consistent with the KDs on Journal and ConfPr of S . Then, the repairs of D under S are:
Let q ( x, z ) : X  Journal ( x, y ) , Editor ( y, z ) be a user query. The consistent answers to q in D under S are { X  TODS , USA  X  X  .
Computational Complexity. The problem of comput-ing consistent answers to conjunctive queries over inconsis-tent databases in the presence of KDs (under the repair semantics introduced in Section 2) is coNP-hard in data complexity [4, 6]. In the following, we prove that such a problem is coNP-hard in data complexity also for schemas in which only EDs occur 2 .

Theorem 3. Let S =  X  X  ,  X  , E X  be a database schema con-taining only EDs, D a database instance for S , q a CQ of arity n over S , and t an n -tuple of constants. The problem of establishing whether t is a consistent answer to q in D under S is coNP-hard with respect to data complexity. Proof (sketch). We prove coNP-hardness by reducing the 3-colorability problem to the complement of our problem. Consider a graph G =  X  V, E  X  with a set of vertices V and edges E . We define a relational schema S =  X  X  ,  X  , E X  where A consists of the relation edge of arity 2, and the relation col of arity 5, and E contains the dependencies col [3]  X  col [4] =  X  , col [3]  X  col [5] =  X  , col [4]  X  col [5] =  X  . The instance D is defined as follows: D = { col ( n, 1 , n,  X  ,  X  ) , col ( n, 2 ,  X  , n,  X  ) , col ( n, 3 ,
We consider the decision problem associated to query an-swering (see e.g., [6]) Where each occurrence of the meta-symbol  X  denotes a dif-ferent constant not occurring elsewhere in the database. In-tuitively, to represent the fact that vertex n  X  V is assigned with color i  X  { 1 , 2 , 3 } , D assigns to col a tuple in which i occurs as second component and n occurs as first and also as 2 + i -th component. The EDs of S impose that consis-tent instances assign no more than one color to each node. Finally, we define the query q  X  edge ( x, y ) , col ( x, z, w 1 , w 2 , w 3 ) , col ( y, z, w On the basis of the above construction it is possible to show that G is 3-colorable (i.e., for each pair of adjacent vertices, the vertices are associated with different colors) if and only if the empty tuple  X  X  is not a consistent answer to q in D under S (i.e., the boolean query q has a negative answer).
Datalog  X  Rewriting. We now provide a sound and complete query rewriting technique for consistent query an-swering in the presence of key and exclusion dependencies. To this aim, we make use of Datalog  X  , i.e., Datalog enriched with (unstratified) negation, under stable model semantics [10]. From a computational point of view, Datalog  X  is coNP-complete with respect to data complexity, and therefore is well suited for dealing with the high computational com-plexity of our problem.

The rewriting that we present in the following extends the one proposed in [4] for CQs specified over database schemas with KDs, in order to properly handle the presence of EDs. The rewriting is employed in the system INFOMIX. Anal-ogously to other proposals that solve consistent query an-swering via query rewriting (although for different classes of constraints and query languages, see, e.g., [14, 3]), the basic idea of the technique is to encode the constraints of the relational schema into a Datalog  X  program, such that the stable models of the program yield the repairs of the database instance D .
 Definition 4. Given a CQ 3 q and a schema S , the Datalog  X  program  X ( q, S ) is defined as the following set of rules 4 : 1. the rule corresponding to the definition of q ; 2. for each relation r  X  X  , the rules 3. for each exclusion dependency
The present rewriting is not actually restricted to CQs, since it can be immediately extended to general Datalog  X  queries.
Without loss of generality, we assume that the attributes in the key precede all other attributes in r , that i 1 = j 1 , . . . , i k = j k = k , ` 1 = 1 , . . . , ` h = h , and m 1 , . . . , m h = h + h . 4. for each exclusion dependency r [ ` 1 , . . . , ` h
Furthermore, we denote with  X  ( D ) the database instance obtained from D by replacing each predicate symbol r with r .

Informally, for each relation r ,  X ( q, S ) contains (i) a rela-tion r D that represents r D ; (ii) a relation r that represents a subset of r D that is consistent with the KD for r and the EDs that involve r ; (iii) an auxiliary relation r that rep-resents the  X  X omplement X  of r , i.e., the subset of r D that together with r results inconsistent with the EDs and KDs on the schema. Notice that the extension of r depends on the choice made for r (and vice-versa), and that such choices are made in a non-deterministic way (enforced by the use of the unstratified negation). The above rules force each stable model M of  X ( q, S )  X   X  ( D ) to be such that r M is a maximal subset of tuples from r D that are consistent with both the KD for r and the EDs in E that involve r .
 Example 2.(contd.) The Datalog  X  rewriting  X ( q, S ) of the query q ( x, z ) : X  Journal ( x, y ) , Editor ( y, z ) is the following program: The first rule of the rewriting encodes the query. The sec-ond, third and fourth rule establish the relationship between each relation and the corresponding complementary predi-cate. The fifth, sixth, and seventh rule encode the KDs of S , whereas the last two rules encode the ED.

We now state correctness of our encoding with respect to the semantics of consistent query answering.

Theorem 5. let S =  X  X  , K , E X  be a database schema, D be a database instance for S , and q be a CQ over S . A tuple t is a consistent answer to q in D under S iff t  X  q M for each stable model M of  X ( q, S )  X   X  ( D ) .

From the above theorem and Theorem 3 it follows that the consistent query answering problem under KDs and EDs is coNP-complete in data complexity.

FOL Rewriting. Let us now consider a different ap-proach to consistent query answering, which aims at identi-fying subclasses of queries for which the problem is tractable. This is the line followed in [1, 6, 13]. In particular, in [13] the authors define a subclass of CQs, called C tree , for which they prove tractability of consistent query answering in the presence of KDs, and provide a FOL rewriting technique. The class C tree is based on the notion of join graph: a join graph of a query q is the graph that contains ( i ) a node N for every atom in the query body, ( ii ) an arc from N i to N iff an existential shared variable occurs in a non-key position in N i and occurs also in N j , ( iii ) an arc from N i to N existential shared variable occurs at least twice in N i , and one occurrence is in a non-key position. According to [13], C tree is the class of conjunctive queries ( a ) without repeated relation symbols, ( b ) in which every join condition involves the entire key of at least one relation and ( c ) whose join graph is acyclic. As pointed out in [13], this class of queries is very common, since cycles are rarely present in queries used in practice. However, no repeated symbols may occur in the queries, and queries must have joins from non-key attributes of a relation to the entire key of another one.
We now extend the work of [13] as follows: Let us describe in detail our technique. Henceforth, given a CQ q , we denote by R q the set of relation symbols occurring in body ( q ). Given a database schema S =  X  X  , K , E X  and a CQ q , we denote by O E ( q ) the set of relation symbols O E words, O E ( q ) contains each relation symbol s  X  X  such that there exists an exclusion dependency between s and r in E , where r is a relation symbol occurring in body ( q ). Definition 6. Let S =  X  X  , K , E X  be a database schema. A conjunctive query q is KE -simple if q  X  X  + tree , and In words, a query q is KE -simple if it belongs to the class C tree , and if both there are no EDs between relations that are in O E ( q ), and each ED between a relation r  X  R q and a relation s  X  O E ( q ) does not involve non-key attributes of r or s . Notice that this last condition does not limit the applicability of our approach in many practical cases. For example, in relational databases obtained from ER-schemas, EDs are typically specified between keys.

For KE -simple CQs, we present in the following a query rewriting algorithm which, given a query q , produces a FOL rewriting, whose evaluation over any database instance D for the database schema S returns the consistent answers to q in D under S . The basic idea of the algorithm is to specify a set of conditions, expressible in FOL, that, if verified over a database instance D , for a given tuple t , guarantee that in any repair of D there is an image of t w.r.t q , i.e., t is a consistent answer to q in D . We point out that, for non-KE -simple CQs, such conditions cannot be specified in FOL. Observe that, in our approach, the FOL rewriting is then in turn translated into SQL, and query evaluation is performed by means of standard DBMS query answering techniques. This further encoding does not present particular difficulties, and due to space limit we omit such transformation.
In order to construct our join graph we need the following definition.

Definition 7. Let S =  X  X  , K , E X  be a database schema, q be a CQ, and a = r ( x 1 , . . . , x n ) be an atom (of arity n ) occurring in R q . Then, let key ( r ) = { i 1 , . . . , i K , and let 1  X  i  X  n . The type of the i -th argument of a in q , denoted by type ( a, i, q ) is defined as follows: 1. If i 1  X  i  X  i k , then: 2. Otherwise ( i /  X  X  i 1 , . . . , i k } ):
Terms typed by KB or B are called bound terms , other-wise they are called unbound . We call the typing of a in q the expression of the form r ( x 1 /t 1 , . . . , x n /t n t is the type of the argument x i in q .

The following algorithm KEFolRewrite computes the FOL rewriting to a KE -simple conjunctive query q . In the algo-rithm, JG ( q ) denotes the join graph of q , in which each node N i is labelled with the typing of the corresponding atom a in q . Furthermore, roots ( JG ( q )) denotes the set of nodes that are roots in JG ( q ) (notice that for KE -simple queries the join graph is a forest, since it is acyclic). Basically, the algorithm builds the join graph of q and then builds the first-order query by invoking the algorithm FolTree on all the nodes that are roots of the join graph.
The algorithm FolTree is defined in Figure 1. Roughly speaking, the algorithm FolTree ( N, E ) returns a first-order formula that constitutes the encoding of the whole subtree of the join graph of the query whose root is the node N . To do that, the algorithm computes two subformulas f 1 and f . The formula f 1 contains an atom whose predicate is the predicate r labelling the node N , in which the unbound variables of r are renamed with new existentially quantified variables. Furthermore, f 1 contains an atom of the form a relation s . Intuitively, when evaluated over a database in-stance D , each such atom checks that there are no facts of the form s ( t s )  X  X  that violate the ED together with a fact of the form r ( t r )  X  D , which is in an image I of a tuple t w.r.t. the input query q , i.e., the atom guarantees that I is not contradicted w.r.t. the ED. The formula f 2 is empty only when all non-key arguments of the atom r are existen-tial non-shared variables (i.e., of type U ). Otherwise, the formula f 2 is a universally quantified implication. In such an implication, the antecedent is an atom whose predicate is r , and the consequent is a conjunction of equality con-ditions and other subformulas: more precisely, there is an equality condition for each non-key argument in r of type B , and a subformula for each successor N 0 of N in the join graph of q , computed by recursively invoking FolTree on N Intuitively, f 2 enforces the joins between r and each atom labelling the successors of r in the join graph of q . At the same time f 2 ensures that, when evaluated over a database instance D , if there exists a fact of the form r ( t r )  X  X  that violates the KD specified on r together with a fact of the form r ( t r )  X  D , which is in the image of a tuple t w.r.t. q , r ( t r ) belongs to another image of t w.r.t. q . In other words, the atom guarantees that in any repair there exists an image of t (w.r.t. the KD on r ). Such a check is iterated for other KDs by recursively invoking FolTree . The following example illustrates the way the algorithm works.
 Example 2.(contd.) It is easy to verify that the query q ( x, z ) : X  Journal ( x, y ) , Editor ( y, z ) is KE -simple. Now, by applying the algorithm KEFolRewrite and FolTree we obtain:
By evaluating the rewriting over D we get { X  TODS , USA  X  X  , i.e., the set of consistent answers to q in D under S . Next, we state soundness and completeness of the algorithm.
Theorem 8. Let S =  X  X  , K , E X  be a database schema, q be a KE -simple conjunctive query over S , and q r be the FOL rewriting returned by KEFolRewrite ( q ) . Then, for every database instance D for S , a tuple t is a consistent answer to q in D under S iff t  X  q D r .
 As a corollary, consistent query answering for KE -simple conjunctive queries over database schemas with KDs and EDs is polynomial in data complexity. We now present some experimental results comparing the FOL and the Datalog  X  rewriting previously described. To perform the experiments, we implemented a rewriting mod-ule that translates CQs issued over the database schema into both FOL queries and Datalog  X  queries. FOL queries are in turn translated by the module into SQL queries. Then, we ran the SQL queries on a MySQL 4.1.10 instance of the test database, while we executed Datalog  X  queries on DLV [15]. The experiments were conducted on a double processor machine, with 3 GHz Pentium IV Xeon CPU and 2 GB of main memory, running the Linux operating system.

The test database holds information about the computer science engineering degrees of the university of Rome  X  X a Sapienza X  and contains 27 tables with an overall size of over 200.000 tuples. In Figure 2, we present the portion of the test database schema that is relevant for the queries (in the figure,  X  r/n  X  indicates that relation r is of arity n ). Due to space limits, we only report details about three of the queries we tested:
The queries have been posed on various instances of the test database with an increasing number of pairs of tuples violating some ICs. Figure 3, shows experimental results. In the charts 3(a), 3(b) and 3(c), the execution time of the SQL encoding and of the Datalog  X  program are compared for queries Q 0 , Q 2 , and Q 3 . As expected, from a certain inconsistency level on, the execution time of the Datalog encoding has an exponential blow-up; in contrast, the exe-cution time for the SQL encoding is constant on the average, and for Q 3 (Figure 3(b)) it decreases: although this might be surprising, it turns out that some inconsistency allows the SQL engine to prune the search space for query answering. Moreover, the chart presented in Figure 3(d) compares, on a logarithmic scale, the execution time of all queries at the highest inconsistency level. It shows that the SQL encoding is always more efficient when the degree of data inconsis-tency grows; however, it turns out that the method based on Datalog  X  and DLV proves particularly efficient in the presence of few data inconsistencies.
The present work provides a general experimental valida-tion of the first-order rewriting approach to the optimization of consistent query answering. Of course, the applicability of our technique is limited to the class of KE -simple queries. For general CQs, the use of a more expressive, and compu-tationally harder, query language like Datalog  X  is necessary.
Very recently, the first prototype implementations of con-sistent query answering have appeared, and the first efforts towards optimization of query processing are emerging.
Within INFOMIX, several optimizations are currently un-der development to improve consistent query answering for more expressive classes of queries [9, 8]. In this respect, binding propagation techniques based on magic sets might significantly reduce execution time for Datalog  X  programs on DLV [11], even if the coNP structure of the Datalog  X  encoding suggests that the efficiency of the SQL rewriting can be hardly reached (especially for a large number of in-consistencies).

The ConQuer system [12] implements an extension of the technique of [13] which allows to rewrite in SQL queries belonging to the class C tree enriched with aggregates. Ex-periments show that the overhead of evaluating rewritten queries is not onerous if compared with evaluation of the original query over the inconsistent database. Therefore, [12] focuses on comparing standard query answering and consistent query answering, while our experiments compare two different query answering techniques. In this respect, we point out that optimization of our SQL rewriting was outside the scope of the present paper.

Finally, Hippo [7] is a system for consistent answering of union of conjunctive queries without existential variables in the presence of denial constraints. Hence, this approach is different from our in terms of both query language and integrity constraints allowed. Moreover, Hippo techniques are not based on rewritings.

As future work, we aim at extending our approach to other forms of ICs (e.g., foreign keys) and at optimizing the SQL rewriting produced by KEFolRewrite . This research has been partially supported by the Project INFOMIX (IST-2001-33570) funded by the EU. [1] Marcelo Arenas, Leopoldo E. Bertossi, and Jan [2] Franz Baader, Diego Calvanese, Deborah McGuinness, [3] Loreto Bravo and Leopoldo Bertossi. Logic [4] Andrea Cal` X , Domenico Lembo, and Riccardo Rosati. [5] Andrea Cal` X , Domenico Lembo, and Riccardo Rosati. [6] Jan Chomicki and Jerzy Marcinkowski. On the [7] Jan Chomicki, Jerzy Marcinkowski, and Slawomir [8] Chiara Cumbo, Wolfgang Faber, Gianluigi Greco, and [9] Thomas Eiter, Michael Fink, Gianluigi Greco, and [10] Thomas Eiter, Georg Gottlob, and Heikki Mannilla. [11] Wolfgang Faber, Gianluigi Greco, and Nicola Leone. [12] Ariel Fuxman, Elham Fazli, and Ren  X ee J. Miller. [13] Ariel Fuxman and Ren  X ee J. Miller. First-order query [14] Gianluigi Greco, Sergio Greco, and Ester Zumpano. A [15] Nicola Leone, Gerald Pfeifer, Wolfgang Faber,
