 To enable information integration, schema matching is a critical step for discovering semantic correspondences of attributes across heterogeneous sources. While complex matchings are common, because of their far more complex search space, most existing tech-niques focus on simple 1:1 matchings. To tackle this challenge, this paper takes a conceptually novel approach by viewing schema matching as correlation mining , for our task of matching Web query interfaces to integrate the myriad databases on the Internet. On this  X  X eep Web, X  query interfaces generally form complex match-ings between attribute groups (e.g., { author } corresponds to { first name , last name } in the Books domain). We observe that the co-occurrences patterns across query interfaces often reveal such com-plex semantic relationships: grouping attributes (e.g., { first name , last name } ) tend to be co-present in query interfaces and thus pos-itively correlated. In contrast, synonym attributes are negatively correlated because they rarely co-occur. This insight enables us to discover complex matchings by a correlation mining approach. In particular, we develop the DCM framework, which consists of data preparation , dual mining of positive and negative correlations, and finally matching selection . Unlike previous correlation mining algorithms, which mainly focus on finding strong positive correla-tions, our algorithm cares both positive and negative correlations, especially the subtlety of negative correlations, due to its special importance in schema matching. This leads to the introduction of a new correlation measure, H -measure, distinct from those proposed in previous work. We evaluate our approach extensively and the results show good accuracy for discovering complex matchings. H.2.5 [ Database Management ]: Heterogeneous Databases; H.2.8 [ Database Management ]: Database Applications X  Data Mining Algorithms, Measurement Grants IIS-0133199 and IIS-0313260. Any opinions, findings, and conclusions or recommendations expressed in this publication are those of the author(s) and do not necessarily reflect the views of the funding agencies.
 Copyright 2004 ACM 1-58113-888-1/04/0008 ... $ 5.00.
 data integration, deep Web, schema matching, correlation mining, correlation measure
In recent years, we have witnessed the rapid growth of databases on the Web, or the so-called  X  X eep Web. X  A July 2000 survey [3] estimated that 96,000  X  X earch cites X  and 550 billion content pages in this deep Web. Our recent study [6] in December 2002 estimated between 127,000 to 330,000 deep Web sources. With the virtually unlimited amount of information sources, the deep Web is clearly an important frontier for data integration.

Schema matching is fundamental for supporting query media-tion across deep Web sources. On the deep Web, numerous online databases provide dynamic query -based data access through their query interfaces , instead of static URL links. Each query interface accepts queries over its query schemas (e.g., author , title , subject , ... for amazon.com ). Schema matching (i.e., discovering semantic correspondences of attributes) across Web interfaces is essential for mediating queries across deep Web sources.
 In particular, matching Web interfaces in the same domain (e.g., Books, Airfares), the focus of this paper, is an important prob-lem with broad applications. In particular, we often need to search over alternative sources in the same domain such as purchasing a book (or flight ticket) across many online book (or airline) sources. Given a set of Web interfaces in the same domain, this paper solves the problem of discovering matchings among those interfaces. We notice that our input, a set of Web pages with interfaces in the same domain, can be either manually [7] or automatically [13, 12] col-lected and classified.

On the  X  X eep Web, X  query schemas generally form complex match-ings between attribute groups. In contrast to simple 1:1 matching, complex matching matches a set of m attributes to another set of n attributes, which is thus also called m : n matching . We observe that, in query interfaces, complex matchings do exist and are actu-ally quite frequent. For instance, in Books domain, author is a syn-onym of the grouping of last name and first name , i.e., { author } = { first name , last name } ; in Airfares domain, { passengers } = { adults , seniors , children , infants } . Hence, discovering complex matchings is critical to integrate the deep Web.

Although 1:1 matching has got great attention [18, 9, 15, 10], m : n matching has not been extensively studied, mainly due to the much more complex search space of exploring all possible com-binations of attributes (as Section 7 will discuss). To tackle this challenge, we investigate the co-occurrence patterns of attributes across sources, to match schemas holistically . Unlike most schema matching work which matches two schemas at a time, we match all the schemas at the same time. This holistic matching provides the co-occurrence information of attributes across schemas and thus enables ef fi cient mining-based solutions. For instance, we may ob-serve that last name and first name often co-occur in schemas, while they together rarely co-occur with author , as Figure 1 illus-trates. More generally, we observe that grouping attributes (i.e., at-tributes in one group of a matching e.g., { last name , first name } ) tend to be co-present and thus positively correlated across sources. In contrast, synonym attributes (i.e., attribute groups in a matching) are negatively correlated because they rarely co-occur in schemas.
These dual observations motivate us to develop a correlation mining abstraction of the schema matching problem. Speci fi cally, given Web pages containing query interfaces, this paper develops a streamlined DCM framework for mining complex matchings, con-sisting of automatic data preparation and correlation mining ,as Figure 2 shows. Since the query schemas in Web interfaces are not readily minable in HTML format, as preprocessing, the data preparation step prepares  X  schema transactions  X  for mining (Sec-tion 5). Then the correlation mining step, the main focus of this paper, discovers complex matchings with dual mining of positive and negative correlations (Section 3). We name the whole match-ing process as DCM , since the core of the algorithm is the d ual c orrelation m ining part.

Unlike previous correlation mining algorithms, which mainly focus on fi nding strong positive correlations, our algorithm cares both positive and negative correlations. Hence, we need to develop measures for both positive correlations and negative ones. Our schema matching task is particularly interested in negative corre-lations, since on one hand, they re fl ect the synonym relationships among attributes, on the other hand, they have not been extensively explored and applied before.

To ensure the quality of the mining result (i.e., the complex match-ings), the chosen measures should satisfy some quality require-ments, based on our observation of query schemas (Section 4). In particular, from the extremely non-uniform distribution of schema attributes, we identify that: 1) Both the positive and negative corre-lation measures should be robust for the sparseness problem (i.e., the sparseness of schema data may  X  exaggerate  X  the effect of co-absence), which has also been noticed as the  X  null invariance  X  prop-erty by recent correlation mining work [20, 16, 14]. 2) The negative correlation measure should be robust for the rare attribute problem (i.e., the rare attributes may not be convincing to judge their neg-ative correlations). Since none of the existing measures [20, 4] is robust for both the sparseness problem and the rare attribute prob-lem, we develop a new measure, H -measure, robust against both problems in measuring negative correlations.

To evaluate the matching performance and H -measure, we test the DCM framework on the datasets in the UIUC Web integration repository [7]. First, we test DCM on the TEL-8 dataset, which contains raw Web pages over 447 deep Web sources in 8 popu-lar domains, and the result shows good target accuracy . Second, we compare the DCM framework with the MGS framework [10], which also matches Web interfaces with the same insight of explor-ing a holistic approach, on its BAMM dataset. The result shows that DCM is empirically close to MGS in discovering simple matchings and further DCM can fi nd complex matchings, which is not sup-
Figure 2: From matching to mining: the DCM framework. ported by MGS . Third, we compare H -measure with other mea-sures on the TEL-8 dataset and the result shows H -measure out-performs the others in most cases.

There are several applications of our work: First, while pursu-ing holistic matching, our result can naturally address the pairwise matching problem. For instance, given the matching { author } = { last name , fi rst name } found by our approach, we can match { author } in some schema S A to { last name , fi rst name } in an-other schema S B . Second, our work is a critical step to construct a global Web interface for each domain. Speci fi cally, among the synonyms in a matching, we can pick the most popular one as the representative in the global interface and use that matching to build the mappings from the global interface to local ones.
 In our development, we also observed several interesting issues. Can we mine interesting patterns over cross-domain Web inter-faces? How to systematically decide the threshold values for min-ing? How can our approach bene fi t from exploring other informa-tion on the Web? We discuss these open issues in Section 8.
In summary, the contributions of this paper are:  X  We build a conceptually novel connection between the schema  X  We develop correlation measures that are robust for not only
The rest of the paper is organized as follows: Section 2 presents our motivating observations of integrating the deep Web. Section 3 develops the mining and selection algorithms. Section 4 proposes a new correlation measure, H -measure. Section 5 presents the data preparation step. Section 6 reports our experiments. Section 7 re-views related work and and Section 8 discusses several further op-portunities and open issues, and then concludes this paper.
As Section 1 brie fl y introduced, our key insight is on connecting matching to mining, which this section further motivates with a concrete example. Consider a typical scenario: suppose user Amy, who wants to book two fl ight tickets from city A to city B , one for her and the other for her 5-year old child. To get the best deal, she needs to query on various airfare sources by fi lling the Web query interfaces. For instance, in united.com ,she fi lls the query interface with from as city A , to as city B and passengers as 2. For the same query in fl yairnorth.com ,she fi lls with depart as city A , destination as city B , adults as 1, seniors as 0, children as 1 and infants as 0.

This scenario reveals some critical characteristics of the Web in-terfaces in the same domain. First, some attributes may group to-gether to form a  X  larger  X  concept. For instance, the grouping of adults , seniors , children and infants denotes the number of pas-sengers. We consider such attributes that can be grouped as group-ing attributes or having grouping relationship , denoted by putting them within braces (e.g., { adults , seniors , children , infants } ).
Second, different sources may use different attributes for the same concept. For instance, from and depart denote the city to leave from, and to and destination the city to go to. We consider such semantically equivalent attributes (or attribute groups) as syn-onym attributes or having synonym relationship , denoted by  X  =  X  (e.g., { from } = { depart } , { to } = { destination } ).
Grouping attributes and synonym attributes together form com-plex matchings . In complex matching, a set of m attributes is matched to another set of n attributes, which is thus also called m : n matching , (in contrast to the simple 1:1 matching). For in-stance, { adults , seniors , children , infants } = { passengers } is a 4:1 matching in the above scenario.

To tackle the complex matching problem, we exploit the co-occurrence patterns to match schemas holistically and thus pursue a mining approach. Unlike most schema matching work which matches two schemas at a time, we match all the schemas at the same time. This holistic view provides the co-occurrence informa-tion of attributes across many schemas, which reveals the semantics of complex matchings. (Such co-occurrence information cannot be observed when schemas are matched only in pairs.) For instance, we may observe that adults , seniors , children and infants often co-occur with each other in schemas, while they together do not co-occur with passengers . This insight enables us to discover com-plex matchings with a correlation mining approach. In particular, in our application, we need to handle not only positive correlations, a traditional focus, but also negative ones, which have rarely been extensively explored or applied.

By matching many schemas together, this holistic matching nat-urally discovers a more general type of complex matching  X  a match-ing may span across more than two attribute groups. Still consider the Amy scenario, if she tries a third airline source, priceline.com , she needs to fi ll the interface with departure city as city A , ar-rival city as city B , number of tickets as 2. We thus have the matching { adults , seniors , children , infants } = { passengers } = { number of tickets } , which is a 4:1:1 matching. Similarly, we have two 1:1:1 matchings { from } = { departure city } = { depart } and { to } = { arrival city } = { destination } . We name this type of matching n -ary complex matching , which can be viewed as an aggregation of several binary m : n matchings.

In particular, we develop a new approach, the DCM framework, to mine n -ary complex matchings. Figure 2 illustrates this min-ing process: 1) As preprocessing, data preparation (Section 5) pre-pares  X  schema transactions  X  for mining by extracting and cleaning the attribute entities in Web interfaces. 2) As the main focus of this paper, the correlation mining step (Section 3) discovers n -ary complex matchings by fi rst fi nding potential attribute groups using positive correlations and then potential complex matchings using negative correlations. Last, matching selection chooses the most con fi dent and consistent matchings from the mining result. 3) Also, since pursuing a mining approach, we need to choose appropriate correlation measures. We discuss this topic in Section 4.
We view a schema as a transaction , a conventional abstraction in association and correlation mining. In data mining, a transaction is a set of items; correspondingly, in schema matching, we consider a schema as a set of attribute entities . An attribute entity contains attribute name, type and domain (i.e., instance values). Before min-ing, the data preparation step (Section 5) fi nds syntactically similar entities among schemas. After that, each attribute entity is assigned a unique attribute identifier . While the mining is over the attribute entities, for simplicity of illustration, we use the attribute name of each entity, after cleaning, as the attribute identi fi er. For instance, the schema in Figure 1(c) is thus, as a transaction of two attribute entities, written as { title , author } .

Formally, we consider the schema matching problem as: Given the input as a set of schemas S I = { S 1 ,...,S u } in the same do-main, where each schema S i is a transaction of attribute identi-fiers, find all the matchings M = { M 1 ,...,M v } .Each M n -ary complex matching G j 1 = G j 2 = ... = G j w ,whereeach G j k is an attribute group and G j k  X  M j should represent the synonym relationship of attribute groups G j 1 ,..., G j w and each G j k should represent the grouping relation-ship of attributes in G j k .

Motivated by our observations on the schema data (Section 2), we develop a correlation mining algorithm, with respect to the above abstraction (Figure 2). First , group discovery :Wemine positively correlated attributes to form potential attribute groups. A poten-tial group may not be eventually useful for matching; only the ones having synonym relationship (i.e., negative correlation) with other groups can survive. For instance, if all sources use last name , fi rst name , and not author , then the potential group { last name , fi rst name } is not useful because there is no matching (to author ) needed. Second , matching discovery : Given the potential groups (including singleton ones), we mine negatively correlated attribute groups to form potential n -ary complex matchings. A potential matching may not be considered as correct due to the existence of con fl icts among matchings. Third , matching selection :Tosolvethe con fl icts, we develop a selection strategy to select the most con fi -dent and consistent matchings from the mining result. Section 3.1 discusses the group and matching discovery and Section 3.2 the matching selection.

After group discovery, we need to add the discovered groups into the input schemas S I to mine negative correlations among groups. (A single attribute is viewed as a group with only one attribute.) Speci fi cally, an attribute group is added into a schema if that schema contains any attribute in the group. For instance, if we discover that last name and fi rst name have grouping relation-ship, we consider { last name , fi rst name } as an attribute group, denoted by G lf for simplicity, and add it to any schema contain-ing either last name or fi rst name , or both. The intuition is that although a schema may not contain the entire group, it still par-tially covers the concept that the group denotes and thus should be counted in matching discovery for that concept. Note that we do not remove singleton groups { last name } and { fi rst name } when adding G lf , because G lf is only a potential group and may not survive in matching discovery.
While group discovery works on individual attributes and match-ing discovery on attribute groups, they can share the same mining process. We use the term  X  items  X  to represent both attributes and groups in the following discussion of mining algorithm.

Correlation mining, at the heart, requires a measure to gauge cor-relation of a set of n items; our observation indicates pairwise cor-relations among these n items. Speci fi cally, for n groups form-ing synonyms, any two groups should be negatively correlated, since they both are synonyms by themselves (e.g., in the match-ing { destination } = { to } = { arrival city } , negative correlations exist between any two groups). We have similar observation on the attributes with grouping relationships. Motivated by such observa-tions, we design the measure as: where m is some correlation measure for two items (e.g., the mea-sures surveyed in [20]). That is, we de fi ne C min as the minimal value of the pairwise evaluation, thus requiring all pairs to meet this minimal  X  strength.  X 
C min has several advantages: First, it satis fi es the  X  apriori  X  fea-ture and thus enables the design of an ef fi cient algorithm. In cor-relation mining, the measure for quali fi cation purpose should have a desirable  X  apriori  X  property (i.e., downward closure), to develop an ef fi cient algorithm. (In contrast, a measure for ranking purpose should not have this  X  apriori  X  feature, as Section 3.2 will discuss.) C min satis fi es the  X  apriori  X  feature since given any item set A and its subset A  X  ,wehave C min ( A , m )  X  C min ( A  X  , m ) because the minimum of a larger set (e.g., min( { 1,3,5 } )) cannot be higher than its subset (e.g., min( { 3,5 } )). Second, C min can incorporate any measure m for two items and thus can accommodate different tasks (e.g., mining positive and negative correlations) and be customized to achieve good mining quality.
 Leveraging the  X  apriori  X  feature of C min , we develop Algorithm A
PRIORI C ORR M INING (Figure 3) for discovering complex match-ings, in the spirit of the classic Apriori algorithm for association mining [1]. That is, we fi nd all the correlated items with length l +1 based on the ones with length l .

With C min , we can directly de fi ne positively correlated attributes in group discovery and negatively correlated attribute groups in matching discovery. A set of attributes { A 1 , ..., A n correlated attributes , denoted by PC ,if C min ( { A 1 , ..., A  X  T p ,where m p is a measure for positive correlation and T a given threshold. Similarly, a set of attribute groups { G G m } is negatively correlated attribute groups , denoted by NC ,if C min ( { G 1 , ..., G m } , m n )  X  T n ,where m n is a measure for neg-ative correlation and T n is another given threshold.

Algorithm N-ARY S CHEMA M AT C H I N G shows the pseudo code of the complex matching discovery (Figure 3). Line 2 (group dis-covery) calls A PRIORI C ORR M INING to mine PC. Lines 3-6 add the discovered groups into S I . Line 8 (matching discovery) calls A
PRIORI C ORR M INING to mine NC. Similar to [1], the time com-plexity of N-ARY S CHEMA M AT C H I N G is exponential with respect to the number of attributes. But in practice, the execution is quite fast since correlations exist among semantically related attributes, which is far less than arbitrary combination of all attributes.
Correlation mining can discover true semantic matchings and, as expected, also false ones due to the existence of coincidental correlations. For instance, in Books domain, the mining result may have both { author } = { fi rst name , last name } , denoted by M and { subject } = { fi rst name , last name } , denoted by M can see M 1 is correct, while M 2 is not. The reason for having the false matching M 2 is that in the schema data, it happens that subject does not often co-occur with fi rst name and last name . The existence of false matchings may cause matching con fl icts. For instance, M 1 and M 2 con fl ict in that if one of them is cor-rect, the other one will not. Otherwise, we get a wrong match-ing { author } = { subject } by the transitivity of synonym relation-ship. Since our mining algorithm does not discover { author } = { subject } , M 1 and M 2 cannot be both correct.

Leveraging the con fl icts, we select the most con fi dent and con-sistent matchings to remove the false ones. Intuitively, between con fl icting matchings, we want to select the more negatively cor-related one because it indicates higher con fi dence to be real syn-onyms. For example, our experiment shows that, as M 2 is coinci-dental, it is indeed that m n ( M 1 ) &gt;m n ( M 2 ) , and thus we select M 1 and remove M 2 . Note that, with larger data size, semantically correct matching is more possible to be the winner. The reason is that, with larger size of sampling, the correct matchings are still negatively correlated while the false ones will remain coincidental and not as strong.

Before presenting the selection algorithm, we need to develop a strategy for ranking the discovered matchings. That is, for any n -ary complex matching M j : G j 1 = G j 2 = ... = G j w ,wehavea score function s ( M j ,m n ) to evaluate M j under measure m
While Section 3.1 discussed a measure for  X  qualifying  X  candi-dates, we now need to develop another  X  ranking  X  measure as the score function. Since ranking and quali fi cation are different prob-lems and thus require different properties, we cannot apply the measure C min (Equation 1) for ranking. Speci fi cally, the goal of quali fi cation is to ensure the correlations passing some threshold. It is desirable for the measure to support downward closure to enable an  X  apriori  X  algorithm. In contrast, the goal of ranking is to com-pare the strength of correlations. The downward closure enforces, by de fi nition, that a larger item set is always less correlated than its subsets, which is inappropriate for ranking correlations of different sizes. Hence, we develop another measure C max , the maximal m value among pairs of groups in a matching, as the score function s . Formally, C
It is possible to get ties if only considering the C max value; we thus develop a natural strategy for tie breaking. We take a  X  top-k  X  approach so that s in fact is a set of sorted scores. Speci fi cally, given matchings M j and M k ,if C max ( M j ,m n ) = C max we further compare their second highest m n values to break the tie. If the second highest values are also equal, we compare the third highest ones and so on, until breaking the tie.

If two matchings are still tie after the  X  top-k  X  comparison, we choose the one with richer semantic information. We consider matching M j semantically subsumes matching M k , denoted by M j M k , if all the semantic relationships in M k are covered in M j . For instance, { arrival city } = { destination } = { to } { arrival city } = { destination } because the synonym relationship in the second matching is subsumed in the fi rst one. Also, { author } = { fi rst name , last name }{ author } = { fi rst name } because the synonym relationship in the second matching is part of the fi rst.
Combining the score function and the semantic subsumption, we rank matchings with following rules: 1) If s ( M j ,m n ) &gt;s ( M M j is ranked higher than M k .2)If s ( M j ,m n )= s ( M and M j M k , M j is ranked higher than M k .3)Otherwise,we rank M j and M k arbitrarily. Algorithm G ET M AT C H I N G F
IRST (Figure 4) illustrates the pseudo code of choosing the highest ranked matching with this strategy.
 Algorithm M AT C H I N G S ELECTION shows the selection algorithm. We apply a greedy selection strategy by choosing the highest ranked matching, M t , in each iteration. After choosing M t , we remove the inconsistent parts in remaining matchings (lines 6 -10). The fi nal output is the selected n -ary complex matchings without con fl ict. Note that we need to do the ranking in each iteration instead of sorting all the matchings in the beginning because after removing the con fl icting parts, the ranking may change. The time complex-ity of Algorithm M AT C H I N G S ELECTION is O ( v 2 ) ,where v is the number of matchings in M .
 Example 1: Assume running N-ARY S CHEMA M AT C H I N G in Books domain fi nds matchings M as (matchings are followed by their scores): M 1 : { author } = { last name , fi rst name } ,0.95 M 2 : { author } = { last name } ,0.95 M 3 : { subject } = { category } ,0.92 M 4 : { author } = { fi rst name } ,0.90 M 5 : { subject } = { last name , fi rst name } ,0.88 M 6 : { subject } = { last name } ,0.88and M 7 : { subject } = { fi rst name } , 0.86.
 In the fi rst iteration, M 1 is ranked the highest and thus selected. In particular, although s ( M 1 ,m n )= s ( M 2 ,m n ) , M higher since M 1 M 2 . Now we remove the con fl icting parts of the other matchings. For instance, M 2 con fl icts with M thor . After removing author , M 2 only contains one attribute and is not a matching any more. So we remove M 2 from M . Similarly, M 4 and M 5 are also removed. The remaining matchings are M M 6 and M 7 . In the second iteration, M 3 is ranked the highest and thus also selected. M 6 and M 7 are removed because they con fl ict with M 3 .Now M is empty and the algorithm stops. The fi nal output is thus M 1 and M 3 .
In this section, we discuss the positive measure m p and the nega-tive measure m n , used as the component of C min (Equation 1) for positive and negative correlation mining respectively in Algorithm N-
As discussed in [20], a correlation measure by de fi nition is a test-ing on the contingency table . Speci fi cally, given a set of schemas and two speci fi ed attributes A p and A q , there are four possible combinations of A p and A q in one schema S i : A p ,A present in S i , only A p presents in S i , only A q presents in S A ,A q are co-absent in S i .The contingency table [5] of A A q contains the number of occurrences of each situation, as Fig-ure 5 shows. In particular, f 11 corresponds to the number of co-presence of A p and A q ; f 10 ,f 01 and f 00 are denoted similarly. f is the sum of f 11 and f 01 ; f +0 , f 0+ and f 1+ are denoted similarly. f ++ is the sum of f 11 , f 10 , f 01 and f 00 .

The design of a correlation measure is often empirical. To our knowledge, there is no good correlation measure universally agreed upon [20]. For our matching task, in principle any measure can be applied. However, since the semantic correctness of the mining re-sult is of special importance for the schema matching task, we care more the ability of the measures on differentiating various corre-lation situations, especially the subtlety of negative correlations, which has not been extensively studied before.

We fi rst identify the quality requirements of measures, which are imperative for schema matching, based on the characteristics of Web query interfaces. Speci fi cally, we observe that, in Web in-terfaces, attribute frequencies are extremely non-uniform, similar to the use of English words, showing some Zipf-like distribution. For instance, Figure 6 shows the attribute frequencies in Books do-main: First, the non-frequent attributes results in the sparseness of the schema data (e.g., there are over 50 attributes in Books domain, but each schema only has 5 in average). Second, many attributes are rarely used, occurring only once in the schemas. Third, there exist some highly frequent attributes, occurring in almost every schema.
These three observations indicate that, as the quality require-ments, the chosen measures should be robust against the follow-ing problems: sparseness problem for both positive and negative correlations, rare attribute problem for negative correlations, and frequent attribute problem for positive correlations. In this section, we discuss each of them in details.
 The Sparseness Problem
In schema matching, it is more interesting to measure whether attributes are often co-present (i.e., f 11 ) or cross-present (i.e., f and f 01 ) than whether they are co-absent (i.e., f 00 ). Many correla-tion measures, such as  X  2 and Lift , include the count of co-absence in their formulas. This may not be good for our matching task, be-cause the sparseness of schema data may  X  exaggerate  X  the effect of co-absence. This problem has also been noticed by recent correla-tion mining work such as [20, 16, 14]. In [20], the authors use the null invariance property to evaluate whether a measure is sensitive to co-absence. The measures for our matching task should satisfy this null invariance property.
 Example 2: Figure 7(a) illustrates the sparseness problem with an example. In this example, we choose a common measure: the Lift lar behavior.) The value of Lift is between 0 to +  X  . Lift =1 means independent attributes, Lift &gt; 1 positive correlation and Lift &lt; 1 negative correlation. Figure 7(a) shows that Lift may give a higher value to less positively correlated attributes. In the scenario of schema matching, the table in Figure 7(a2) should be more positively correlated than the one in Figure 7(a1) because in Figure 7(a2), the co-presence ( f 11 ) is more frequently observed than the cross-presence (either f 10 or f 01 ), while in Figure 7(a1), the co-presence has the same number of observations as the cross-presence. However, Lift cannot re fl ect such preference. In partic-ular, Figure 7(a1) gets a much higher Lift and Figure 7(a2) is even evaluated as not positively correlated. Similar example can also be found for negative correlation with Lift . The reason Lift gives an inappropriate answer is that f 00 incorrectly affects the result. We explored the 21 measures in [20] and the  X  2 measure in [4]. Most of these measures (including  X  2 and Lift ) suffer the sparse-ness problem. That is, they consider both co-presence and co-absence in the evaluation and thus do not satisfy the null invariance property. The only three measures supporting the null invariance property are Confidence , Jaccard and Cosine .
 The Rare Attribute Problem for Negative Correlation
Although Confidence , Jaccard and Cosine satisfy the null invari-ance property, they are not robust for the rare attribute problem, when considering negative correlations. Speci fi cally, the rare at-tribute problem can be stated as when either A p or A observed, the measure should not consider A p and A q as highly negatively correlated because the number of observations is not convincing to make such judgement. For instance, consider the Jac-card (i.e., Jaccard = f 11 when both f 11 and f 10 + f 01 are fi xed. Therefore, to some de-gree, Jaccard cannot differentiate the subtlety of correlations (e.g., f 10 = 49, f 01 =1and f 10 = 25, f 01 = 25), as Example 3 illus-trates. Other measures such as Confidence and Cosine have similar problem. This problem is not critical for positive correlation, since attributes with strong positive correlations cannot be rare. Example 3: Figure 7(b) illustrates the rare attribute problem. In this example, we choose a common measure: the Jaccard .The value of Jaccard is between 0 to 1 . Jaccard close to 0 means neg-ative correlation and Jaccard close to 1 positive correlation. Fig-ure 7(b) shows that Jaccard may not be able to distinguish the situa-tions of rare attribute. In particular, Jaccard considers the situations in Figure 7(b1) and Figure 7(b2) as the same. But Figure 7(b2) is more negatively correlated than Figure 7(b1) because A p in Fig-ure 7(b1) is more like a rare event than true negative correlation.
To differentiate the subtlety of negative correlations, we develop a new measure, H -measure (Equation 3), as the negative correla-tion m n .Thevalueof H is in the range from 0 to 1. An H value close to 0 denotes a high degree of positive correlation; an H value close to 1 denotes a high degree of negative correlation.
H -measure satis fi ed the quality requirements: On one hand, sim-ilar to Jaccard , Cosine and Confidence , H -measure satis fi es the null invariance property and thus avoids the sparseness problem by ignoring f 00 . On the other hand, by multiplying individual effect re fl ecting subtle variation of negative correlations.
 The Frequent Attribute Problem for Positive Correlation
For positive correlations, we fi nd that Confidence , Jaccard , Co-sine and H -measure are not quite different in discovering attribute groups. However, all of them suffer the frequent attribute prob-lem. This problem seems to be essential for these measures: Al-though they avoid the sparseness problem by ignoring f 00 cost, they lose the ability to differentiate highly frequent attributes from really correlated ones. Speci fi cally, highly frequent attributes may co-occur in most schemas just because they are so frequently used, not because they have grouping relationship (e.g., In Books domain, isbn and title are often co-present because they are both very frequently used). This phenomenon may generate uninterest-ing groups (i.e., false positives ) in group discovery.
 Example 4: Figure 7(c) illustrates the frequent attribute problem with an example, where we still use Jaccard as the measure. Fig-ure 7(c) shows that Jaccard may give a higher value to independent attributes. In Figure 7(c1), A p and A q are independent and both of them have the probabilities 0.9 to be observed; while, in Fig-ure 7(c2), A p and A q are really positively correlated. However, Jaccard considers Figure 7(c1) as more positively correlated than Figure 7(c2). In our matching task, a measure should not give a high value for frequently observed but independent attributes.
The characteristic of false groupings is that the f 11 value is very high (since both attributes are frequent). Based on this characteris-Speci fi cally, we de fi ne the positive correlation measure m where T d is a threshold to fi lter out false groupings. To be consis-tent with m n , we also use the H -measure in m p .
The query schemas in Web interfaces are not readily minable in HTML format; as preprocessing, data preparation is essential to prepare  X  schema transactions  X  for mining. As shown in Fig-ure 2, data preparation consists of: 1) form extraction  X  extracting attribute entities from query interfaces in Web pages, 2) type recog-nition  X  recognizing the types of the attribute entities from domain values, and 3) syntactic merging  X  syntactically merging these at-tribute entities.

Form extraction reads a Web page with query forms and extracts the attribute entities containing attribute names and domains. For instance, the attribute about title in Figure 1(c) is extracted as name =  X  title of book  X  , domain = any ,where  X  domain = any  X  means any value is possible. This task is itself a challenging and independent problem. We solved this problem by a parsing approach with the hypothesis of the existence of hidden syntax [21]. Note that there is no data cleaning in this step and thus the attribute names and domains are raw data.

After extracting the forms, we perform some standard normal-ization on the extracted names and domains. We fi rst stem attribute names and domain values using the standard Porter stemming al-gorithm [17]. Next, we normalize irregular nouns and verbs (e.g.,  X  children  X  to  X  child,  X  X  colour  X  to  X  color  X  ). Last, we remove com-mon stop words by a manually built stop word list, which contains words common in English, in Web search (e.g.,  X  search  X  ,  X  page  X  ), and in the respective domain of interest (e.g.,  X  book  X  ,  X  movie  X  ). We then perform type recognition to identify attribute types. As Section 5.1 discusses, type information helps to identify homonyms (i.e., two attributes may have the same name but different types) and constrain syntactic merging and correlation-based matching (i.e., only attributes with compatible types can be merged or matched). Since the type information is not declared in Web interfaces, we de-velop a type recognizer to recognize types from domain values.
Finally, we merge attribute entities by measuring the syntactic similarity of attribute names and domain values (e.g., we merge  X  title of book  X  to  X  title  X  by name similarity). It is a common data cleaning technique to merge syntactically similar entities by ex-ploring linguistic similarities. Section 5.2 discusses our merging strategy.
While attribute names can distinguish different attribute entities, the names alone sometimes lead to the problem of homonyms (i.e., the same name with different meanings)  X  we address this problem by distinguishing entities by both names and types. For instance, the attribute name departing in the Airfares domain may have two meanings: a datetime type as departing date, or a string type as departing city. With type recognition, we can recognize that there are two different types of departing : departing (datetime) and departing (string) , which indicate two attribute entities.
In general, type information, as a constraint, can help the sub-sequent steps of syntactic merging and correlation-based match-ing. In particular, if the types of two attributes are not compatible, we consider they denote different attribute entities and thus neither merge them nor match them.

Since type information is not explicitly declared in Web inter-faces, we develop a type recognizer to recognize types from domain values of attribute entities. For example, a list of integer values de-notes an integer type. In the current implementation, type recogni-tion supports the following types: any, string, integer, fl oat, month, day, date, time and datetime. (An attribute with only an input box is given an any type since the input box can accept data with different types such as string or integer.) Two types are compatible if one can subsume another (i.e., the is-a relationship). For instance, date and datetime are compatible since date subsumes datetime. Figure 8 lists the compatibility of all the types in our implementation.
We clean the schemas by merging syntactically similar attribute entities, a common data cleaning technique to identify unique enti-ties [8]. Speci fi cally, we develop name-based merging and domain-based merging by measuring the syntactic similarity of attribute names and domains respectively. Syntactic merging increases the observations of attribute entities, which can improve the effect of correlation evaluation.

Name-based Merging : We merge two attribute entities if they are similar in names. We observe that the majority of deep Web sources are consistent on some concise  X  core  X  attribute names (e.g.,  X  title  X  ) and others are variation of the core ones (e.g.,  X  title of book  X  ). Therefore, we consider attribute A p is name-similar to attribute A q if A p  X  sname  X  A q  X  s name (i.e., A p is a variation of A )and A q is more frequently used than A p (i.e., A q is the major-ity). This frequency-based strategy helps avoid false positives. For instance, in Books domain, last name is not merged to name be-cause last name is more popular than name and thus we consider them as different entities.

Domain-based Merging : We then merge two attribute entities if they are similar in domain values. In particular, we only consider attributes with string types, since it is unclear how useful it is to measure the domain similarity of other types. For instance, in Air-fares domain, the integer values of passengers and connections are quite similar, although they denote different meanings.
We view domain values as a bag of words (i.e., counting the word frequencies). We name such a bag aggregate values , denoted as V A for attribute A .Givenaword w , we denote V A ( w ) as the frequency of w in V A . The domain similarity of attributes A A q is thus the similarity of V A p and V A q . In principle, any reason-able similarity function is applicable here. In particular, we choose
The above three steps, form extraction, type recognition and syn-tactic merging, clean the schema data as transactions to be mined. More detailed discussion about these data cleaning steps can be found at the extended report [11].
We choose two datasets, TEL-8 dataset and BAMM dataset, of the UIUC Web integration repository [7] as the testbed of the DCM framework. The TEL-8 dataset contains raw Web pages over 447 deep Web sources in 8 popular domains. Each domain has about 20-70 sources. The BAMM dataset contains manually extracted attribute names over 211 sources in 4 domains (with around 50 sources per domain), which was fi rst used by [10].

In the experiment, we assume a perfect form extractor to extract all the interfaces in the TEL-8 dataset into query capabilities by manually doing the form extraction step. The reason we do not apply the work in [21] is that we want to isolate the mining process to study and thus fairly evaluate the matching performance. After extracting the raw data, we do the data cleaning according to the process explained in Section 5. Then, we run the correlation mining algorithm on the prepared data in each domain. Also, in the results, we use attribute name and type together as the attribute identi fi er for an attribute entity since we incorporate type recognition in data preparation to identify homonyms (Section 5).

To evaluate the matching performance and the H -measure, we extensively test the DCM framework on the two datasets. First, we test our approach on the TEL-8 dataset and the result shows good target accuracy . Second, we compare the DCM framework with the MGS framework [10], which also matches Web inter-faces by a statistical approach, on its BAMM dataset. The result shows that DCM is empirically close to MGS in discovering simple matchings and further DCM can fi nd complex matchings, which is not supported by MGS . Third, we compare the H -measure with other measures on the TEL-8 dataset and the result shows that H -measure outperforms the others in most cases. We compare experimentally discovered matchings, denoted by M h , with correct matchings written by human experts, denoted by M c . In particular, we adopt the target accuracy , a metric initially developed in [10], by customizing the target questions to the com-plex matching scenario. The idea of the target accuracy is to mea-sure how accurately that the discovered matchings answer the target questions. Speci fi cally, for our complex matching task, we consider the target question as, given any attribute, to fi nd its synonyms (i.e., word with exactly the same meaning as another word, e.g., subject is a synonym of category in Books domain), hyponyms (i.e., word of more speci fi c meaning, e.g., last name is a hyponym of author ) and hypernyms (i.e., word with a broader meaning, e.g, author is a hypernym of last name ).

It is quite complicated to use different measures for different semantic relationships, we therefore report an aggregate measure for simplicity and, at the same time, still re fl ecting semantic dif-ferences. For our discussion here, we name synonym, hyponym and hypernym together as closenym  X  meaning that they all denote some degrees of closeness in semantic meanings. Our target ques-tion now is to ask the set of closenyms of a given attribute. Example 5: For instance, for matching { A } = { B , C } , the closenym sets of attributes A , B , C are { B , C } , { A } , { A } respectively. In par-ticular, the closenym sets of B does not have C since B and C only have grouping relationship. In contrast, for matching { A } = { B } = { C } , the closenym sets of attributes A , B , C are { B , C } , { A , C } , { A , C } respectively. We can see that the difference of matchings can be re fl ected in the corresponding closenym sets.

Except this difference in target question, we use the same met-ric of target accuracy as [10]. Speci fi cally, we assume a  X  random querier  X  to ask for closenym set of each attribute according to the its frequency. The answer to each question is closenym set of the queried attribute in discovered matchings. We de fi ne Cls ( A as the closenym set of attribute A j .Given M c and M h , the preci-sion and recall of the closenym sets of attribute A j are:
Since more frequently used attributes have higher probabilities to be asked in this  X  random querier,  X  we compute the weighted av-erage of all the P A j  X  sand R A j  X  sasthe target precision and target of attribute A j in the dataset (i.e., its number of occurrences in dif-ferent schemas). Therefore, target precision and target recall of M h with respect to M c are:
To illustrate the effectiveness of the mining approach, we only list and count the  X  semantically dif fi cult  X  matchings discovered by the correlation mining algorithm, not the simple matchings by the syntactic merging in the data preparation (e.g., { title of book } to { title } ). Our experiment shows that many frequently observed matchings are in fact  X  semantically dif fi cult  X  and thus cannot be found by syntactic merging.
 Result on the TEL-8 Dataset : In this experiment, we run our al-gorithm (with H -measure as the correlation measure) on the TEL-8 dataset. We set the thresholds T p to 0.85 and T d to 0.6 for positive correlation mining and T n to 0.75 for negative correlation mining. We empirically get these numbers by testing the algorithm with var-ious thresholds and choose the best one. As Section 8 will discuss, more systematic study can be investigated in choosing appropriate threshold values.

Figure 9 illustrates the detailed results of n -ary complex match-ings discovered in Books domain. The step of group discovery found 5 likely groups ( G 1 to G 5 in Figure 9). In particular, m gives a high value (actually the highest value) for the group of last name (any) and fi rst name (any). The matching discovery found 6 likely complex matching ( M 1 to M 6 in Figure 9). We can see that M 1 and M 3 are fully correct matchings, while others are partially correct or incorrect. Last, the matching selection will choose M and M 3 (i.e., the correct ones) as the fi nal output.

Figure 10 shows the results on Airfares and Movies. (The results of other domains can be found at the extended report [11]). The third column denotes the correctness of the matching. In partic-ular, Y means a fully correct matching, P a partially correct one and N an incorrect one. Our mining algorithm does fi nd inter-esting matchings in almost every domain. For instance, in Air-fares domain, we fi nd 5 fully correct matchings, e.g., { destination (string) } = { to (string) } = { arrival city (string) } .Also, { passenger (integer) } = { adult (integer), child (integer), infant (integer) } is partially correct because it misses senior (integer).

Since, as a statistical method, our approach replies on  X  suf fi cient observations  X  of attribute occurrences, it is likely to perform more favorably for frequent attributes (i.e., the head-ranked attributes in Figure 6). To quantify this  X  observation  X  factor, we report the target accuracy with respect to the attribute frequencies. In particular, we consider the attributes above a frequency threshold T (i.e., the num-ber of occurrences of the attribute over the total number of schemas is above T ) in both discovered matchings and correct matchings to measure the target accuracy. Speci fi cally, we run the algorithms on all the attributes and then report the target accuracy in terms of the frequency-divided attributes. In the experiment, we choose T as 20% and 10%.

Consider the Airfares domain, if we only consider the attributes above 20% frequency in the matching result, only 12 attributes are above that threshold. The discovered matchings in Figure 10 become { destination (string) } = { to (string) } , { departure date (datetime) } = { depart (datetime) } ,and { return date (datetime) = return (datetime) } . (The other attributes are removed since they are all below 20% frequency.) These three matchings are exactly the correct matchings the human expert can recognize among the 12 attributes and thus we get 1.0 in both target precision and recall. Next, we apply the 10% frequency threshold and get 22 attributes. The discovered matchings in Figure 10 are unchanged since all the attributes (in the matchings) are now passing the threshold. Com-pared with the correct matchings among the 22 attributes, we do miss some matchings such as { cabin (string) } = { class (string) } and { departure (datetime) = departure date (datetime) } .Also, some matchings are partially correct such as { passenger (inte-ger) } = { adult (integer), child (integer), infant (integer) } . Hence, we get 1.0 in target precision and 0.71 in target recall.
Figure 11 lists the target accuracies of the 8 domains under thresh-olds 20% and 10%. From the result, we can see that our approach does perform better for frequent attributes.
 Result on the BAMM Dataset :Wetestthe DCM framework on the BAMM dataset used in [10]; the result shows that DCM is em-pirically close to the MGS framework in [10] on discovering sim-ple 1:1 matchings and further we can fi nd complex matchings that MGS cannot. Since the BAMM dataset only contains manually ex-tracted attribute names, we skip the data preparation step in this ex-periment. The result shows that we can discover almost all the sim-ple 1:1 matchings found by MGS . In particular, we fi nd { subject } = { category } in Books, { style } = { type } = { category } in Auto-mobiles, { actor } = { artist } and { genre } = { category } in Movies, and { album } = { title } and { band } = { artist } in MusicRecords. Further, DCM can fi nd the complex matchings { author } = { last name , fi rst name } in Books, while MGS can only fi nd either { author } = { last name } or { author } = { fi rst name } . Evaluating the H -Measure : We compare the H -measure with other measures and the result shows that H -measure gets better tar-get accuracy. As an example, we choose Jaccard (  X  ) as the measure we compare to. With Jaccard ,wede fi ne the m p and m n as and
We set t he T p and T n for this Jaccard -based m p and m 0.5 and 0.9 respectively. We compare the target accuracy of H -measure and Jaccard in the situation of 10% frequency threshold. The result (Figure 12) shows that H -measure is better in both target precision and target recall in most cases. Similar comparisons show that H -measure is also better than other measures such as Cosine and Confidence .
Schema matching is important for schema integration [2, 19] and thus has got great attention. However, existing schema matching works mostly focus on simple 1:1 matching [18, 9, 15] between two schemas. Complex matching has not been extensively studied, mainly due to the much more complex search space of exploring all possible combinations of attributes. Consider two schemas with u and v attributes respectively, while there are only u  X  v potential 1:1 matchings, the number of possible m : n matchings is exponential. Also, it is still unclear that how to compare the similarity between two groups of attributes. In contrast, this paper proposes to dis-cover complex matchings by holistically matching all the schemas together. Speci fi cally, we explore the co-occurrences information across schemas and develop a correlation mining approach.
Unlike previous correlation mining algorithms, which mainly fo-cus on fi nding strong positive correlations [1, 20, 16, 14, 4], our algorithm cares both positive and negative correlations. In particu-lar, as a new application for correlation mining, the correctness of schema matching mainly depends on the subtlety of negative cor-relations. We thus study the rare attribute problem and develop the H -measure, which empirically outperforms existing ones on eval-uating negative correlations.

Our previous schema matching work, the MGS framework [10], also matches Web interfaces by exploiting holistic information. Al-though built upon the same insight, DCM is different from MGS in: 1) abstraction : DCM abstracts schema matching as correlation mining, while MGS as hidden model discovery by applying sta-tistical hypothesis testing. The difference in abstraction leads to fundamentally different approaches. 2) expressiveness : DCM fi nds m : n matchings, while MGS currently fi nds 1:1 matchings and it is unclear that how it can be extended to support m : n matchings.
In our development of the mining-based matching approach, we also observed several further opportunities and open issues that warrant more investigation. First, it is interesting to know whether our observation and approach can cross the domain boundary. Specif-ically, given a set of Web interfaces across different domains, we hope to know whether there still are interesting patterns that reveal some semantic relationships among attributes, as we have observed for sources in one domain.

Second, more systematic study can be investigated for choosing appropriate correlation measures and threshold values. In this pa-per, we choose the H -measure based on the observations of the data and the threshold values according to the empirical experi-ments. We expect a more formal and systematic study to help the design of measures and the evaluation of threshold values.
Third, to validate and re fi ne the matching results, we may send some trial probings through Web interfaces. For instance, given two online movie sources, one using actor and the other using star ,we can send some sample queries on these two sources with same val-ues on actor and star . If they often return overlapping results, we consider the matching { actor } = { star } is correct. However, this probing brings new challenges to solve. In particular, for complex matchings (e.g., { author } = { last name , fi rst name } ), schema composition has to be done before probing, which is itself a dif-fi cult problem. Also, it is unclear that how to automatically collect sample queries for each domain. Last, with current techniques, it is dif fi cult to accurately compare the query results in Web pages.
In summary, this paper explores co-occurrence patterns among attribute to tackle the complex matching problem. This exploration is well suited for the integration of large-scale heterogenous data sources, such as the deep Web. Speci fi cally, we abstract complex matching as correlation mining and develop the DCM framework. Further, we propose a new correlation measure, H -measure, for mining negative correlations. Our experiments validate the effec-tiveness of both the mining approach and the H -measure.
