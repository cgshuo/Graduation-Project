 Guimei Liu  X  Jinyan Li  X  Limsoon Wong Abstract A complete set of frequent itemsets can get undesirably large due to redundancy when the minimum support threshold is low or when the database is dense. Several concise representations have been previously proposed to eliminate the redundancy. Generator based representations rely on a negative border to make the representation lossless. However, the number of itemsets on a negative border sometimes even exceeds the total number of frequent itemsets. In this paper, we propose to use a positive border together with frequent generators to form a lossless representation. A positive border is usually orders of magnitude smaller than its corresponding negative border. A set of frequent generators plus its positive border is always no larger than the corresponding complete set of frequent itemsets, thus it is a true concise representation. The generalized form of this representation is also proposed. We develop an efficient algorithm, called GrGrowth, to mine generators and positive borders as well as their generalizations. The GrGrowth algorithm uses the depth-first-search strategy to explore the search space, which is much more efficient than the breadth-first-search strategy adopted by most of the existing generator mining algorithms. Our experiment results show that the GrGrowth algorithm is significantly faster than level-wise algorithms for mining gen-erator based representations, and is comparable to the state-of-the-art algorithms for mining frequent closed itemsets.
 Keywords Frequent itemset mining  X  Generator  X  Concise representation  X  Positive border  X  Data mining 1 Introduction Frequent itemset mining is an important problem in the data mining area. It was first intro-duced by Agrawal et al. [ 1 ] in the context of transactional databases. The problem can be described as follows. Let I ={ a 1 , a 2 ,..., a n } be a set of items and D ={ t 1 , t 2 ,..., t N } be a transaction database, where t i ( i  X  X  1 , N ] ) is a transaction and t i  X  I . Each sub-set of I is called an itemset . If an itemset contains k items, then it is called a k -itemset. The support of an itemset l in D is defined as support ( l ) =|{ t | t  X  Dandl  X  t }| or support ( l ) =|{ t | t  X  Dandl  X  t }| / | D | . Given a transaction database, denoted as D ,anda predefined minimum support threshold, denoted as s , if the support of an itemset in D is no less than s , then the itemset is called a frequent itemset . The task of frequent itemset mining is to find all the frequent itemsets with respect to a given minimum support threshold from a given transaction database.

The number of frequent itemsets can be undesirably large, especially on dense datasets where long patterns are prolific. Many frequent itemsets are redundant because their support can be inferred from other frequent itemsets. Generating too many frequent itemsets not only requires extensive computation cost and I/O cost but also defeats the primary purpose of data mining in the first place. Increasing the minimum support threshold may reduce the number of itemsets, but some useful itemsets may be missed because they fail to pass the high minimum support threshold. Therefore, it is desirable to remove the redundancy to make the result size manageable even when the minimum support is low and/or the dataset is dense.
Several concepts have been proposed to eliminate the redundancy from a complete set of frequent itemsets, including frequent closed itemsets [ 23 ], generators [ 3 ] and generalizations of generators [ 9 , 19 ]. Frequent closed itemsets are the maximal itemsets among the itemsets appearing in the same set of transactions and generators are the minimal ones. Frequent closed itemset mining has been well studied and several efficient algorithms have been pro-posed to mine frequent closed itemsets [ 22 , 24 , 26 , 28 , 29 ]. However, little efforts have been put on developing efficient algorithms for mining generator based representations. In some applications, generators are more preferable than closed itemsets. For example, generators are more appropriate for classification than closed itemsets because closed itemsets contain some redundant items that are not useful for classification, which also violates the minimum description length principle.

A representation is lossless if we can decide for any itemset whether it is frequent and we can determine the support of the itemset if it is frequent, using only information of the representation without accessing the original database. Frequent generators alone are not adequate for representing a complete set of frequent itemsets because if an itemset is not included in the set of frequent generators, there is no way to know whether it is because the itemset is not frequent or because the itemset is not a generator. Existing generator based representations [ 9 , 18 , 19 ] use a negative border together with frequent generators to form a lossless representation. A negative border is composed of the itemsets whose subsets are fre-quent generators but themselves are not frequent. There can be numerous infrequent itemsets on a negative border. We have observed that negative borders are often very large, sometimes the negative border alone is larger than the corresponding complete set of frequent itemsets. For example, the total number of frequent itemsets is 122450 in dataset BMS-POS [ 30 ] with minimum support of 0.1%, while the number of itemsets on the negative border is 236912. To solve this problem, we propose a new concise representation of frequent itemsets, which uses a positive border together with frequent generators to form a lossless representation. All the itemsets on a positive border are frequent but are not generators, therefore the size of frequent generators and their positive border is always no larger than the complete set of frequent itemsets.

Existing algorithms for mining generator based representations adopt the candidate generate-and-test approach and use the breadth-first-search strategy to explore the search space, which needs to scan the database multiple times and generate and test a large number of candidate itemsets. It has been shown that the breadth-first-search strategy is inferior to the depth-first-search strategy and becomes very inefficient on dense datasets. In this paper, we propose an efficient algorithm, called GrGrowth, to mine generator based representations. GrGrowth adopts the pattern growth approach and uses the depth-first-search strategy to explore the search space. An appropriate exploration order is chosen so that non-generators can be pruned during the mining process to save mining cost.

The main contributions of the paper are summarized as follows: (1) We propose a new concise representation of frequent itemsets, which uses a positive border instead of a nega-tive border together with frequent generators to represent a complete set of frequent itemsets. The size of the new representation is guaranteed to be no larger than the total number of frequent itemsets; thus it is a true concise representation. Our experiment results show that a positive border is usually orders of magnitude smaller than its corresponding negative bor-der. (2) The completeness of the new representation is proved, and an algorithm is given to derive the support of an itemset from the new representation. We also present an algorithm to regenerate the complete set of frequent itemsets from the proposed concise representation. (3) We develop an efficient algorithm, GrGrowth, to mine frequent generators and positive borders. The GrGrowth algorithm and the concept of positive borders can be both applied to generalizations of generators, such as disjunction-free sets and generalized disjunction-free sets [ 18 , 19 ].

The rest of the paper is organized as follows. Section 2 presents related work. The formal definitions of generators and generator based representations are given in Sect. 3 . Section 4 describes the GrGrowth algorithm. The experiment results are shown in Sect. 5 . Finally, Sect. 6 concludes the paper. 2 Related work The problem of removing redundancy while preserving semantics has drawn much attention in the data mining area. Several concepts have been proposed to remove redundancy from a complete set of frequent itemsets, including frequent closed itemsets [ 23 ], generators [ 3 ] and generalizations of generators [ 7 , 9  X  11 , 19 ].

The concept of frequent closed itemsets is proposed by Pasquier et al. [ 23 ]. An itemset is closed if all of its supersets are less frequent than it. A level-wise algorithm A-Close is developed to mine frequent closed itemsets, which uses frequent generators as intermedi-ate results to mine frequent closed itemsets. The A-Close algorithm is not very efficient. Several algorithms have been proposed to mine frequent closed itemsets more efficiently. The CHARM algorithm [ 29 ] uses the vertical mining technique. Algorithms CLOSET [ 26 ] and CLOSET+ [ 28 ] are based on the pattern growth algorithm FP-growth [ 15 ]. Bonchi and Lucchese propose a framework to mine closed itemsets that also satisfy user-specified con-straints [ 5 ]. Pan et al. [ 22 ] consider the situation where the datasets contain a large number of columns but a small number of rows, and propose the CARPENTER algorithm, which performs a row-wise enumeration instead of the column-wise enumeration adopted by pre-vious work. Pei et al. [ 25 ] propose a more restrictive concept, condensed frequent pattern base, to further reduce result size. An itemset is a condensed frequent pattern base if all of its proper supersets are significantly less frequent than it. Chi et al. [ 13 ] address the problem of mining closed frequent itemsets over a data stream sliding window using limited memory space. There is also some work on mining Top-k closed patterns [ 16 , 27 ].

The concept of generators is first introduced by Bastide et al. [ 3 ]. They use generators together with frequent closed itemsets to mine minimal non-redundant association rules. The same group of authors also use generators and a counting inference technique [ 4 ] to improve the performance of the Apriori algorithm [ 2 ]. Bykowski et al. [ 9 ] propose another con-cept X  X isjunction-free generator to further reduce result size. Generators or disjunction-free generators alone are not adequate to represent a complete set of frequent itemsets. Bykowski et al. use a negative border together with disjunction-free generators to form a lossless repre-sentation. Kryszkiewicz et al. [ 19 ] generalize the concept of disjunction-free generator and propose to mine generalized disjunction-free generators. Boulicaut et al. [ 7 ] generalize the generator representation from another direction and propose the  X  -free-sets representation. Itemset l is  X  -free if the support difference between l and l  X  X subsetsislessthan  X  . Boulicaut et al. also use a negative border together with  X  -free-sets to form a concise representation. The  X  -free-sets representation is not lossless unless  X  = 0.

Mannila et al. [ 21 ] first propose the notion of condensed representation, and they show that using the inclusion X  X xclusion principle one can obtain approximate confidences of arbitrary boolean rules. Based on the inclusion X  X xclusion principle, Calders et al. [ 10 ] propose the concept of non-derivable frequent itemsets, which is equivalent to  X  -disjunction-free sets. Calders et al. develop a level-wise algorithm NDI [ 10 ] and a depth-first algorithm dfNDI [ 12 ] to mine non-derivable frequent itemsets. The dfNDI algorithm is shown to be much more efficient than the NDI algorithm. Calders et al. [ 11 ] review previous concise representations and propose the concept of k -free sets and several types of borders to form lossless represen-tations. However, the computation cost for inferring support from the concise representations using these borders is very high.

In our previous work [ 20 ], we have proposed a concise representation of frequent itemsets using frequent generators and a positive border. In this paper, besides adding more detailed explanations on the proposed concise representation, we present an optimization technique to further reduce the size of the positive border based representation, and experiments are conducted to show the reduction. We also describe the GrGrowth algorithm in much more details and add more experimental results. Furthermore, we present an algorithm to recover the complete set of frequent itemsets from the proposed concise representation, and have conducted experiments to compare the time used to regenerate the complete set of frequent itemsets from the positive border based representation with that from the negative border based representation. 3 Positive border based representations In this section, we give the formal definitions of generators and positive borders, and prove that the set of frequent generators in a database and its positive border form a lossless rep-resentation of the complete set of frequent itemsets. We also give an algorithm to infer the support of an itemset and an algorithm to recover the complete set of frequent itemsets from positive border based representations. 3.1 Definitions Definition 1 (Generator) Itemset l is a generator if there does not exist l such that l  X  l and support ( l ) = support ( l ) .

Equivalent definitions for generators have been given in [ 3 , 18 , 19 ]. According to the def-inition, the empty set  X  is a generator in any database. If an itemset is a generator in a database and its support is no less than a given minimum support threshold, we call the itemset a frequent generator . Generators also have the anti-monotone property as shown in [ 18 ].
 Property 1 (anti-monotone property) If l is not a generator, then  X  l  X  l , l is not a generator.
 Property 1 implies that if itemset l is a generator, then all of its subsets are generators. The reason being that if one of the subsets of l is not a generator, then l cannot be a generator according to Property 1 .
 Example 1 Table 1 (a) shows an example transaction database containing six transactions. With minimum support of 2, the set of frequent itemsets are shown in Table 1 (b) and the set of frequent generators are shown in Table 1 (c). For brevity, a frequent itemset { a 1 , a 2 ,..., a m } with support s is represented as a 1 a 2 ... a m : s . Many frequent itemsets are not generators. For example, itemset e is not a generator because it has the same support as  X  . Consequently, all the supersets of e are not generators.

Frequent generators alone are not adequate for representing the complete set of frequent itemsets. Some researchers use a negative border together with frequent generators to make the representation lossless [ 18 , 19 ]. The negative border of a set of frequent generators FG , denoted as NBd ( FG ) ,isdefinedas NBd ( FG ) ={ l | lisnot frequent  X  l /  X  FG  X  (  X  l  X  l , l  X  FG ) } . 1 As we have observed, a negative border is often larger than the corresponding complete set of frequent itemsets. In this paper, we propose the concept of positive border to make generator based representations lossless and truly concise.
 Definition 2 (The positive border of FG ) Let FG be the set of frequent generators in a database with respect to a minimum support threshold. The positive border of FG is defined as PBd ( FG ) ={ l | lis frequent  X  l /  X  FG  X  (  X  l  X  l , l  X  FG ) } .
 Example 2 Table 1 (d) shows the positive border of frequent generators with minimum sup-port of 2 in the database shown in Table 1 (a). We represent an itemset l on a positive border as a pair l , x ,where x is an item, l = l  X  X  x } and support ( l ) = support ( l ) . For example, itemset e is on the positive border and it has the same support as  X  , hence it is represented as  X , e . The second pair a , d represents itemset ad .

Note that for any non-generator itemset l , there must exist item x  X  l such that the itemset obtained by removing x from l has the same support as l ,thatis, support ( l ) = support ( l ) , where l = l  X  X  x } . The reason being that if no such item x exists, then l must be a generator according to Definition 1 .Item x is called a redundant item of l . The itemsets on positive borders are not generators, therefore any itemset l on a positive border can be represented as apair l , x such that l = l  X  X  x } and support ( l ) = support ( l ) . For itemset l on a positive border, there are possibly more than one pairs of l and x satisfying that l = l  X  X  x } and support ( l ) = support ( l ) . Any pair can be chosen to represent l .
 Proposition 1 Let F I and F G be the complete set of frequent itemsets and the set of frequent generators in a database respectively, and P Bd ( FG ) be the positive border of F G, we have FG PBd ( FG ) =  X  and F G PBd ( FG )  X  F I , thus | FG |+| PBd ( FG ) | X | FI | . The above Proposition is true by the definition of frequent generators and positive borders. Proposition 1 states that a set of frequent generators plus its positive border is always a subset of the complete set of frequent itemsets, thus it is a true concise representation. Next we prove that this representation is lossless. We say a representation of frequent itemsets is lossless if given any itemset, we can infer whether the itemset is frequent from the representation and get the support of the itemset if it is frequent.
 Proposition 2  X  frequent itemset l, if l /  X  F G and l /  X  PBd ( FG ) ,then  X  l  X  PBd ( FG ) such that l  X  l.
 Proof We prove the proposition using induction on the length of the itemsets.

The empty set is a generator, so any frequent length-1 itemsets must either be in FG or be in PBd ( FG ) .
 Let | l |= 2. The fact that l /  X  FG and l /  X  PBd ( FG ) means that  X  l  X  l such that l /  X  FG . Itemset l cannot be  X  because  X   X  FG . Hence l must be a length-1 frequent itemset and l  X  PBd ( FG ) . The above proposition is true for l = 2.
 Assume that the above proposition is true for | l | X  k ( k  X  0).

Let | l |= k + 1. The fact that l /  X  FG and l /  X  PBd ( FG ) means that  X  l  X  l such that l /  X  FG .If l  X  PBd ( FG ) , then the proposition is true. Otherwise by using the assumption, there must exist l  X  l such that l  X  PBd ( FG ) . Hence the proposition is also true because l  X  l  X  l .
 Proposition 3  X  itemset l and item a, if su ppor t ( l ) = support ( l { a } ) ,then  X  l  X  l, support ( l ) = support ( l { a } ) .
 Proof The fact that support ( l ) = support ( l { a } ) implies that for any transaction t con-taining l , t must also contain item a . Given any transaction t containing l , t contains l because l  X  l , hence t must also contain a .Sowehave support ( l ) = support ( l { a } ) . Theorem 1 Given F G and P Bd ( FG ) and the support of the itemsets in F G PBd ( FG ) , for any itemset l, we can determine: (1) whether l is frequent, and (2) the support of l if l is frequent. Algorithm 1 InferSupport Algorithm Proof If l  X  FG or l  X  PBd ( FG ) , we can obtain the support of l directly.

Otherwise if there exists itemset l such that l  X  l and l  X  PBd ( FG ) ,let l be the itemset such that l = l  X  X  a } , support ( l ) = support ( l ) and l  X  FG ,wehave support ( l ) = support ( l { a } ) and l = l  X  X  a } X  l  X  X  a } . According to Proposition 3 ,wehave support ( l  X  X  a } ) = support ( l ) . We remove item a from l . This process is repeated until there does not exist l such that l  X  PBd ( FG ) and l  X  l . The resultant itemset is denoted as  X  l ,and  X  l can be in two cases: (1)  X  l  X  FG or  X  l  X  PBd ( FG ) ,then l must be frequent and then l must be infrequent because otherwise it conflicts with Proposition 2 .

It directly follows from Proposition 1 and Theorem 1 that the set of frequent generators in a database and its positive border form a concise and lossless representation of the complete set of frequent itemsets. 3.2 Regenerating frequent itemsets 3.2.1 Inferring the support of a single itemset From the proof of Theorem 1 , we can get an algorithm for inferring the support of an itemset from positive border based concise representations. Intuitively, if an itemset is not a generator, then the itemset must contain some redundant items which make the itemset a non-generator. Removing these redundant items does not change the support of the itemset. We represent an itemset l on a positive border as l , a ,where l = l  X  X  a } and support ( l ) = support ( l ) ,so the redundant items can be easily identified. When inferring the support of an itemset, we first use positive borders to remove redundant items from the itemset. If the resultant itemset is a generator, then the original itemset is frequent and its support equals to the resultant itemset, otherwise the itemset is infrequent. Algorithm 1 shows the pseudo-codes of the algorithm. Example 3 To check whether itemset bcde is frequent and obtain its support if it is frequent, we first search in the positive border shown in Table 1 (d) for the subsets of bcde .Wefind  X , e , so item e is removed. Then we continue to search for the subsets of bcd and find c , d . Item d is removed and the resultant itemset is bc . There is no subset of bc in Table 1 (d). We Algorithm 2 RecoverCompleteFI Algorithm search bc in Table 1 (c) and find bc is a generator. Therefore, itemset bcde is frequent and its support is 2.

To check whether itemset acdh is frequent and obtain its support if it is frequent, we first search for its subsets in Table 1 (d). We find c , d , so item d is removed. We continue the search and find h , c is a subset of ach , so item c is removed. There is no subset of ah in Table 1 (d). Itemset ah does not appear in Table 1 (c) either, so itemset acdh is not frequent. 3.2.2 Recovering the complete set of frequent itemsets To recover the complete set of frequent itemsets from FG and PBd ( FG ) , we not only need to infer the support of the itemsets that are neither frequent generators nor on the positive bor-der, but also need to generate the itemsets themselves. We enumerate these frequent itemsets following the mining framework of the pattern-growth approach [ 15 ].
 The pseudo-codes for generating the complete set of frequent itemsets from FG and PBd ( FG ) are shown in Algorithm 2 . Algorithm 2 traverses the search space in depth-first order, and grows a frequent itemset from its prefix as the pattern growth approach. When Algorithm 2 is first called, l is set to  X  and E ( l ) is set to the set of items appearing in the database. For each frequent itemset l , Algorithm 2 generates the set of items in E ( l ) that are frequent with l (line 2 X 6), denoted as F l , and then extends l by each of the items in F l recursively (line 9 X 12). The items in F l are sorted into descending order of their supports (line 7), and the candidate extensions of itemset l  X  X  i } ,where i  X  F l , includes all the items that are before i in F l (line 12). At line 4, testing whether sup &gt; 0 is true is equivalent to testing whether sup  X  ms is true because function InferSup returns  X  1 if the itemset is infrequent.
 The main difference between Algorithm 2 and a pattern growth algorithm such as FP-growth is that the support of an itemset is inferred from FG and PBd ( FG ) in Algo-rithm 2 (line 3), while the support of an itemset is obtained by scanning conditional databases in FP-growth. 3.3 Generalized forms of positive borders We can also define positive borders for k -disjunction-free sets, which are generalized forms of generators.
 Definition 3 ( k -disjunction-free set) Itemset l is a k -disjunction-free set if there does not support ( l ) .
 According to Definition 3 , if an itemset is a k -disjunction-free set, it must be a ( k -1)-disjunc-tion-free set. Generators are 1-disjunction-free sets. The disjunction-free sets proposed by Bykowski et al. [ 9 ] are 2-disjunction-free set. The generalized disjunction-free sets proposed by Kryszkiewicz et al. [ 19 ]are  X  -disjunction-free sets. If the support of a k -disjunction-free set is no less than a given minimum support threshold, then the k -disjunction-free set is called a frequent k-disjunction-free set .
 Example 4 In the example shown in Table 1 , itemset bd is a generator, but it is not a 2-disjunction-free set because support ( bd ) = X  support ( X ) + support ( b ) + support ( d ) . Definition 4 (The positive border of FG k ) Let FG k be the set of frequent k -disjunction-free sets in a database with respect to a minimum support threshold. The positive border of FG k is defined as PBd ( FG k ) ={ l | lisfrequent  X  l /  X  FG k  X  (  X  l  X  l , l  X  FG k ) } . Proposition 4 Given a transaction database and a minimum support threshold, we have FG k PBd ( FG k ) =  X  and ( FG k + 1 PBd ( FG k + 1 ))  X  ( FG k PBd ( FG k ))  X  FI, where k = 1 , 2 ,... .
 Proof According to Definition 4 , FG k PBd ( FG k ) =  X  .  X  l  X  FG k + 1 PBd ( FG k + 1 ) ,if l  X  FG k + 1 ,then l  X  FG k according to Definition 3 .
If l is in PBd ( FG k + 1 ) ,then l can be in two cases: (1) l  X  FG k ;or(2) l /  X  FG k .In the second case, l must be in PBd ( FG k )) because  X  l  X  l , l  X  FG k + 1  X  FG k . In both cases, we have l  X  FG k PBd ( FG k ) . Therefore, FG k + 1 PBd ( FG k + 1 ) is a subset of FG k PBd ( FG k ) .

This proposition indicates that with the increase of k , the concise representations using frequent k -disjunction-free sets and positive borders become more and more concise. How-ever, the cost for deriving the support of an itemset increases. There is a trade-off between the size of a representation and the deriving cost when choosing a concise representation.
The set of frequent k -disjunction-free sets ( k &gt; 1) in a database and its positive border also form a lossless concise representation of the complete set of frequent itemsets. The proof is similar to the proof of Theorem 1 . We omit it here. 3.4 Discussion Thesizeof FG PBd ( FG ) can be further reduced without harming its completeness. Given an itemset l  X  FG ,ifthereexist l  X  PBd ( FG ) such that l = l { a } , support( l ) = support ( l ) and l is represented as l , a , then itemset l can be eliminated from FG because its support can be inferred from l .
 Example 5 In the database shown in Table 1 (a) with minimum support of 2, the reduced set of frequent generators is shown in Table 2 (a) and the positive border is shown in Table 2 (b). Five itemsets are removed from Table 1 (c). For example, itemset  X  :6 is removed because of  X , e :6, and itemset a :3 is eliminated because of a , d :3.
We denote the reduced set of frequent generators in a database as FG  X  .Thecostfor inferring the support of an itemset using FG  X  and PBd ( FG ) is almost the same as that using FG and PBd ( FG ) : (1) if itemset l  X  PBd ( FG ) or l  X  FG  X  , then the support of l is obtained directly; (2) if itemset l is not in FG  X  but one of l  X  X supersetsisin PBd ( FG ) and the superset is represented as l , a ,then l must have the same support as the superset; otherwise (3) we remove the redundant items from l as described in Algorithm 1 ,ifthe resultant itemset  X  l is in FG  X  PBd ( FG ) or one of  X  l  X  X  supersets is in PBd ( FG ) ,then l is frequent and its support can be obtained, otherwise l is infrequent. 4 The GrGrowth Algorithm In this section, we first describe how to mine frequent generators and positive borders, and then describe how to extend the GrGrowth algorithm to mine k -disjunction-free sets and their positive borders.

The GrGrowth algorithm adopts the pattern growth approach. It constructs a conditional database for each frequent generator. According to the anti-monotone property, if an itemset is not a generator, then none of its supersets can be a generator. It implies that if a frequent itemset is not a generator, then there is no need to construct its conditional database because none of the frequent itemsets discovered from its conditional database can be a generator. The GrGrowth algorithm prunes non-generators during the mining process to save mining cost. 4.1 Conditional database construction The GrGrowth algorithm uses the compact data structure FP-tree [ 15 ] to store conditional databases. An FP-tree is constructed from the original database in two database scans. In the first database scan, frequent items are counted and sorted into descending frequency order, denoted as F . Frequent items that appear in every transaction of the original database are removed from F because they are not generators, nor the itemsets containing them can be generators based on the anti-monotone property. In the second database scan, the FP-tree storing all the conditional databases of the frequent items in F are constructed. We use an example to show how an FP-tree is constructed from a transaction database. The second column of Table 3 shows an example transaction database containing six transac-tions, which is the same as the example database used in the previous section. The minimum support threshold is set to 2. We first scan the database to count frequent items. There are seven items frequent in the database and they are sorted into descending frequency order: F that is, support ( e ) = support ( X ) . Therefore, itemset e is not a generator, nor any itemset containing item e can be a generator based on the anti-monotone property. We remove item e from F . The resulting F is used for constructing the header table of the FP-tree. We divide the search space into six sub search spaces according to the six frequent items in the header table: (1) itemsets containing only item d ; (2) itemsets containing item b but not any item after b ; (3) itemsets containing a but not any item after a ; (4) itemsets containing item c but not any item after c ; (5) itemsets containing item h but not containing i ; and (6) itemsets containing item i . Accordingly, six conditional databases are constructed from the original database such that all the itemsets in item a i  X  X  search space can be discovered from a i  X  X  conditional database.

In the second database scan, the GrGrowth algorithm constructs an FP-tree that stores all the conditional databases. For each transaction, infrequent items and items appearing in every transaction are removed and the remaining items are sorted according to their order in F . The resulting transactions are called projected transactions andtheyareshowninthe third column of Table 3 . The projected transactions are inserted into the FP-tree as shown in Fig. 1 .

In an FP-tree, the conditional database of item a i , denoted as D a i , consists of all the branches starting from a node containing item a i up to the root. For example, item c  X  X  con-ditional database consists of 3 branches cabd : 1, cbd : 1and cd : 1, which represent transactions 1, 3 and 5 in Table 3 and the frequent items after item c are excluded. To facil-itate the traversal of the conditional databases, a node-link pointer and a parent pointer are maintained at each FP-tree node. The node-link pointers link all the FP-tree nodes contain-ing the same item together. The first FP-tree node of each frequent item is maintained in the header table. Starting from the first FP-tree node maintained in the header table and travers-ing along the node-links of a frequent item, we can obtain all the branches contained in the conditional database of the item.

The FP-tree constructed from the original database contains the complete information for mining frequent itemsets. Once the FP-tree is constructed from the original database, the remaining mining is conducted on the FP-tree and there is no need to access the original database. Mining individual conditional databases is similar to mining the original database. It also has two steps. When mining itemset l  X  X  conditional database D l , we first scan D l to find frequent items in D l , denoted as F l .Let a i be a frequent item in D l .If l { a i } is not a generator, then a i is removed from F l . In the second step, a new FP-tree is constructed from D l if the number of frequent items in F l is greater than 1. Otherwise, the mining on D l is finished. 4.2 Search space exploration order The GrGrowth algorithm explores the search space using the depth-first-search strategy. During the mining process, the GrGrowth algorithm needs to check whether an itemset is a generator by comparing the support of the itemset with that of its subsets. To be able to do the checking, the subsets of an itemset should be discovered before the itemset. The GrGrowth algorithm sorts frequent itemsets in descending order of their frequency, and the sub search space of a frequent item includes all the items before it in the order. In other words, the most frequent item has the smallest sub search space, which is actually empty, and the most infrequent item has the largest sub search space, which includes all the other frequent items. To guarantee that all the subsets of a frequent itemset are discovered before that itemset, the GrGrowth algorithm traverses the search space tree in descending frequency order. In the example shown in Table 3 and Fig. 1 , the conditional database of item d is first processed, and then the conditional databases of item b , item a and so on. The conditional database of item i is processed last. 4.3 Pruning non-generators When mining itemset l  X  X  conditional database D l , the GrGrowth algorithm first traverses D l FP-tree which stores the conditional databases of the frequent items in F l .Accordingtothe anti-monotone property, there is no need to include item a j  X  F l into the new FP-tree if l { a j } is not a generator.

Non-generators are identified in two ways in the GrGrowth algorithm. One way is to check whether support ( l { a i } ) = support ( l ) for all a i  X  F l . This checking is performed immediately after all the frequent items in D l are discovered and it incurs little overhead. The second way is to check whether there exists itemset l such that l  X  ( l { a i } ) and not necessary to compare l { a i } with all of its subsets. Based on the anti-monotone property of frequent generators, it is adequate to compare l { a i } with its length-| l | subsets.
During the mining process, the GrGrowth algorithm maintains the set of frequent gener-ators that have been discovered so far in a hash table to facilitate the subset checking. The hash function hashes an itemset to an integer and it is defined as follows: where l is a generator, or d er ( i ) is the position of item i if the frequent items in the original database are sorted into descending frequency order, and L table is the size of the hash table and it is a prime number. In the above hash function, both the id of an item and the position of an item in descending frequency order are used. The purpose is to reduce the possibility that two different items are mapped into the same value. The reason being that the position of an item in descending frequency order depends on the frequency of the item and it is independent of the id of the item. Our experiment results have showed that the above hashing function is very effective in avoiding conflicts.
The FP-tree structure provides additional pruning capability. If itemset l  X  X  conditional database D l contains only one branch, then there is no need to construct a new FP-tree from D l even if there are more than one frequent items in D l that can be appended to l to form frequent generators. The reason being that if D l contains only one branch, then  X  a  X  D l and a j  X  D l , l { a i , a j } cannot be a generator because support ( l { a i , a j } ) = min { support ( l { a i } ), support ( l { a j } ) } . 4.4 Generating positive borders In the GrGrowth algorithm, generating positive borders incurs no additional cost. When checking whether frequent itemset l is a generator, there are three possibilities: (1) All the subsets of l are generators and all of them are more frequent than l . In this case, itemset l is a generator. (2) All the subsets of l are generators but there exists l  X  l such that support ( l ) = support ( l ) . In this case, itemset l is on the positive border according to Definition 2 . (3) Not all of the subsets of l are generators. In this case, itemset l is neither a generator nor on the positive border, and it should be discarded.

Algorithm 3 shows the pseudo-codes of the GrGrowth Algorithm. During the mining pro-cess, the GrGrowth algorithm maintains the set of frequent generators discovered so far in a hash table. At line 3, the GrGrowth algorithm checks whether itemset l { i } is a generator by searching the immediate subsets of l { i } in the hash table. If l { i } is not a generator, then it is removed from F l (line 4), otherwise it is inserted into the hash table (line 8). Algorithm 3 GrGrowth Algorithm Theorem 2 (Correctness of GrGrowth) Given a transaction database and a minimum sup-port threshold, Algorithm 3 discovers all frequent generators and the positive border, and only frequent generators and the positive border are produced. Proof The GrGrowth algorithm explores the search space systematically in depth-first order, and only non-generators that are not on the positive border are pruned during the mining process based on Property 1 , therefore, GrGrowth discovers the complete set of frequent generators and the positive border. For every itemset generated during the mining process, GrGrowth check whether it is a generator or on the positive border, therefore only frequent generators and the positive border are produced by GrGrowth. 4.5 Mining k -disjunction-free sets The algorithm for mining frequent k -disjunction-free sets ( k &gt; 1) and their positive borders is almost the same as Algorithm 3 . The only difference is the subset checking at line 3 in Algorithm 3 . When checking whether itemset l is a generator, we need to compare l only with we need to retrieve all of its subsets of length no less than | l | X  k and check whether there 5 A performance study In this section, we study the size of positive borders and negative borders, and the efficiency of the GrGrowth algorithm. The experiments were conducted on a 3.00Ghz Pentium IV with 2GB memory running Microsoft Windows XP professional. All codes were complied using Microsoft Visual C++ 6.0.

Table 4 shows the datasets used in our performance study. All these datasets are available at http://fimi.cs.helsinki.fi/data/ .Table 4 shows some statistical information of the datasets used in our performance study, including the size of the datasets, the number of transactions, the number of distinct items, the maximal transaction length (column  X  X axTL X ) and the aver-age transaction length (column  X  X vgTL X ). Dataset accidents is provided by Karolien Geurts, and it contains traffic accident data. BMS-POS, BMS-WebView-1 and BMS-WebView-2 are three sparse datasets containing click-stream data [ 30 ]. Datasets chess, connect-4, mushroom and pumsb are obtained from the UCI machine learning repository 2 and they are very dense. Dataset pumsb_star is a synthetic dataset produced from pumsb by Roberto J. Bayardo [ 17 ]. Dataset retail is provided by Tom Brijs and it contains the retail market basket data from an anonymous Belgian retail store [ 8 ]. The last two datasets are two synthetic datasets generated using IBM synthetic dataset generation code. 3 5.1 Size comparison between negative borders and positive borders The first experiment is to compare the size of positive borders with that of negative borders. In all our experiments, we use the negative border defined by Kryszkiewicz et al. [ 18 , 19 ], which is smaller than the negative border defined by Bykowski et al. [ 9 ].

Table 5 shows the total number of frequent itemsets (the  X  X I X  column), the number of fre-quent generators (the  X  X G X  column), the size of the negative border of FG (the  X  X Bd(FG) X  column), the size of the positive border of FG (the  X  X Bd(FG) X  column), the number of frequent  X  -disjunction-free generators (the  X  FG  X   X  column), the size of the negative bor-der of FG  X  (the  X  X Bd( FG  X  ) X  column) and the size of the positive border of FG  X  (the  X  X Bd( FG  X  ) X  column). The minimum support thresholds are shown in the second column. Here we do not use the optimization technique described in Sect. 3.4 .

The numbers in Table 5 indicate that negative borders are often significantly larger than the corresponding complete sets of frequent itemsets on sparse datasets. For example, in dataset retail with minimum support of 0.005%, the number of itemsets on the negative border of FG is 64914318, which is about 43 times larger than the total number of frequent itemsets and about 585 times larger than the number of itemsets on the positive border of FG .The negative borders shrink little with the increase of k on sparse datasets. Even with k = X  ,it is still often the case that negative borders are much larger than the corresponding complete sets of frequent itemsets on sparse datasets. This is unacceptable for a concise representa-tion. On the contrary, the positive border based representations are always smaller than the corresponding complete sets of frequent itemsets, thus are true concise representations.
When k = 1, positive borders are usually orders of magnitude smaller than the corre-sponding negative borders as shown in the 5th and 6th column of Table 5 . When k = X  , the size of positive borders becomes larger than that of negative borders on some datasets, especially dense datasets. Nevertheless, the set of k -disjunction-free sets in a database plus its positive border is always no larger, usually significantly smaller, than the complete set of frequent itemsets for any k , while the negative borders of frequent  X  -disjunction-free sets are still tens of times larger than the complete set of frequent itemsets on some datasets.
An interesting observation from Table 5 is that with the increase of k , the size of negative borders decreases because FG k shrinks, but the size of positive borders usually increases. The reason being that when negative borders are used in concise representations, the fre-quent itemsets in ( FG k  X  FG k + 1 ) are discarded when k increases, but some of the itemsets in ( FG k  X  FG k + 1 ) are put into PBd ( FG k + 1 ) when positive borders are used. Therefore, on some datasets, the size of positive borders eventually exceeds, but is still comparable to, that of negative borders. Table 6 shows the value of k and the size of positive borders and neg-on these datasets. The new itemsets in PBd ( FG k + 1 ) come from FG k  X  FG k + 1 ,sothe increase of the size of PBd ( FG k + 1 ) is bounded by | FG k  X  FG k + 1 | .

As discussed in Sect. 3.4 , the size of FG  X  PBd ( FG ) can be further reduced by remov-ing frequent generators which have a superset in PBd ( FG ) .Table 7 shows the number of frequent generators that can be removed using this optimization technique (the  X #PatRmd X  column). In most cases, the number of frequent generators that can be removed is close to the size of the corresponding positive borders, which means that the size of FG  X   X  PBd ( FG ) is close to that of FG . 5.2 Recovering time of the complete set of frequent itemsets Table 8 shows the time used to recover the complete set of frequent itemsets from the positive border based representation and the negative border based representation. Here we did not use the optimization technique described in Sect. 3.4 . The running time is the average of 10 runs, and it includes the time for loading frequent generators and itemsets on the borders into the main memory, but does not include the time for outputting frequent itemsets. On dataset retail with minimum support of 0.005% and T40I10D100k with minimum support of 0.1%, negative borders are too large to fit into the main memory, so the time for NBd ( FG ) is not shown.

We use the same algorithm as Algorithm 2 to recover the complete set of frequent itemsets from the negative border based representation. The support of an itemset l is inferred from FG and NBd ( FG ) as follows. We first check whether there exists an itemset l in NBd ( FG ) such that l is a subset of l .Ifsuch l exists, then l is not frequent, otherwise, the support of l is set to be the minimal support of its subsets. For both the positive border based representation and the negative border based representation, we use the hash table structure described in Sect. 4.3 to store frequent generators and the itemsets on the borders to accelerate subset searching.

Table 8 shows that on sparse datasets, the recovering time using NBd ( FG ) is similar to that using FBd ( FG ) , while on dense datasets, recovering the complete set of frequent item-sets from FG and PBd ( FG ) is significantly faster than that from FG and NBd ( FG ) .The reason being that NBd ( FG ) is faster for determining infrequent itemsets, while PBd ( FG ) is more efficient for retrieving the support of frequent itemsets. On dense datasets, most of the candidate itemsets checked by procedure InferSup are frequent as shown in the last two columns of Table 8 . The  X #TotalChecks X  column shows the total number of calls of procedure InferSup in Algorithm 2 , and the  X #CheckedFreq X  column shows the number of calls of procedure InferSup that return positive support. One special case is that on dataset retail, only a small number of the calls of procedure InferSup return positive support, but the recovering time using PBd ( FG ) is much less than that using NBd ( FG ) . The reason being that the negative borders on dataset retail are hundreds or even thousands of times larger than the corresponding positive borders. It indicates that positive borders can also benefit from its small size for inferring the support of itemsets. 5.3 Mining time The second experiment is to study the efficiency of the GrGrowth algorithm. We compare the GrGrowth algorithm with two algorithms. One is the FPClose algorithm [ 14 ], which is one of the state-of-the-art frequent closed itemset mining algorithms. The other is a level-wise algorithm for mining frequent generators and positive borders, denoted as  X  X priori-FG X  in the figures. We implement the level-wise algorithm based on Christian Borgelt X  X  implemen-tation of the Apriori algorithm [ 6 ]. We pick six datasets for this experiment. Figure 2 shows the running time of the three algorithms. The running time includes both CPU time and I/O time.

Overall, the GrGrowth algorithm outperforms the other two algorithms. In particular, it is much (usually one or two orders of magnitude) faster than the level-wise algorithm Apriori-FG for the same task of mining frequent generators and positive borders. On data-sets accidents and BMS-POS, GrGrowth and FPClose show similar performance; and both of them are significantly faster than the level-wise algorithm Aprioir-FG. On sparse data-set retail, GrGrowth performs much better than Apriori-FG and also than FPClose. For the three dense datasets (chess, connect-4 and pumsb), Apriori-FG constantly shows the worst performance among the three algorithms. However, the GrGrowth algorithm is about 2 time faster than FPClose on chess and about three times faster than FPClose on connect-4, and is comparable to FPClose on pumsb. The slightly inferior performance of GrGrowth compared to FPClose on dataset pumsb is caused by the longer output time of GrGrowth than that of FPClose. On dataset pumsb, the number of frequent generators is about 3 times larger than the number of frequent closed itemsets on pumsb with minimum support of 50%. Though the number of frequent generators is significantly larger than the number of frequent closed patterns in some cases, we observed in this work that the number of frequent generators is often close to the number of frequent closed itemsets. The main reason that the GrGrowth algorithm can be faster than FPClose in many cases is that FPClose checks whether an itemset is closed through superset searching, while GrGrowth checks whether an itemset is a gener-ator by searching the immediate subsets of the itemset. The number of immediate subsets of an itemset is bounded by the length of the itemset, while the number of potential supersets of an itemset is exponential to the number of items not in the itemset, so checking whether an itemset is a generator is usually much cheaper than checking whether an itemset is closed. 6Conclusion In this paper, we have proposed a new concise representation for frequent itemsets, which uses a positive border instead of a negative border together with frequent generators to form a lossless concise representation. Positive border based representations are true concise repre-sentations in the sense that the number of frequent generators plus the number of itemsets on the positive border is always no more than the total number of frequent itemsets. This is not true for negative border based representations. An efficient depth-first algorithm GrGrowth has been developed to mine frequent generators and positive borders. It has been shown to be much faster than a classic level-wise algorithm.

We have proposed a generalized form of the positive border and also a generalized form of the new representation. The GrGrowth algorithm can be easily extended for mining the generalized positive borders and the generalized representations, thus we provide a unified framework for concisely representing and efficiently mining frequent itemsets through gen-erators, positive borders and their respective generalizations. References Author Biographies
