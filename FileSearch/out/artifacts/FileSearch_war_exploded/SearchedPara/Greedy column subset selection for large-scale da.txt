 Ahmed K. Farahat  X  Ahmed Elgohary  X  Ali Ghodsi  X  Mohamed S. Kamel Abstract In today X  X  information systems, the availability of massive amounts of data neces-sitates the development of fast and accurate algorithms to summarize these data and represent them in a succinct format. One crucial problem in big data analytics is the selection of rep-resentative instances from large and massively distributed data, which is formally known as the Column Subset Selection problem. The solution to this problem enables data analysts to understand the insights of the data and explore its hidden structure. The selected instances can also be used for data preprocessing tasks such as learning a low-dimensional embedding of the data points or computing a low-rank approximation of the corresponding matrix. This paper presents a fast and accurate greedy algorithm for large-scale column subset selection. The algorithm minimizes an objective function, which measures the reconstruction error of the data matrix based on the subset of selected columns. The paper first presents a cen-tralized greedy algorithm for column subset selection, which depends on a novel recursive formula for calculating the reconstruction error of the data matrix. The paper then presents a MapReduce algorithm, which selects a few representative columns from a matrix whose columns are massively distributed across several commodity machines. The algorithm first learns a concise representation of all columns using random projection, and it then solves a generalized column subset selection problem at each machine in which a subset of columns are selected from the sub-matrix on that machine such that the reconstruction error of the concise representation is minimized. The paper demonstrates the effectiveness and efficiency of the proposed algorithm through an empirical evaluation on benchmark data sets. Keywords Column subset selection  X  Greedy algorithms  X  Distributed computing  X  Big data  X  MapReduce 1 Introduction Recent years have witnessed the rise of the big data era in computing and storage systems. Withthegreatadvancesininformationandcommunicationtechnology,hundredsofpetabytes of data are generated, transferred, processed and stored every day. The availability of this overwhelming amount of structured and unstructured data creates an acute need to develop fast and accurate algorithms to discover useful information that is hidden in the big data. One information in a succinct format.

Although different algorithms for clustering and dimension reduction can be used to summarize big data, these algorithms tend to learn representatives, whose meanings are tend to produce centroids, which encode information about thousands of data instances. The meanings of these centroids are hard to interpret. Even clustering methods that use data instances as prototypes, such as k -medoid [ 42 ], learn only one representative for each cluster, which is usually not enough to capture the insights of the data instances in that cluster. In addition, using medoids as representatives implicitly assumes that the data points are distributed as clusters and that the number of those clusters is known ahead of time. This assumption is not true for many data sets. On the other hand, traditional dimension reduction algorithms such as latent semantic analysis (LSA) [ 16 ] tend to learn a few latent concepts in the feature space. Each of these concepts is represented by a dense vector, which combines thousands of features with positive and negative weights. This makes it difficult for the data analyst to understand the meaning of these concepts. Even if the goal of representative selection is to learn a low-dimensional embedding of data instances, learning dimensions whose meanings are easy to interpret allows the understanding of the results of the data mining algorithms, such as understanding the meanings of data clusters in the low-dimensional space.

The acute need to summarize big data to a format that appeals to data analysts motivates the development of different algorithms to directly select a few representative data instances and/or features. This problem can be generally formulated as the selection of a subset of columns from a data matrix, which is formally known as the column subset selection (CSS) problem [ 3 , 6 , 7 , 22 , 29 ]. Although many algorithms have been proposed for tackling the CSS problem, most of these algorithms focus on randomly selecting a subset of columns with the goal of using these columns to obtain a low-rank approximation of the data matrix. In this case, these algorithms tend to select a relatively large number of columns. When the goal is to select a very few columns to be directly presented to a data analyst or indirectly used to interpret the results of other algorithms, the randomized CSS methods are not going to produce a meaningful subset of columns. One the other hand, deterministic algorithms for CSS, although more accurate, do not scale to work on big matrices with massively distributed columns.

This paper addresses the aforementioned problem by first presenting a fast and accurate greedy algorithm for column subset selection. The algorithm minimizes an objective function, which measures the reconstruction error of the data matrix based on the subset of selected columns. The paper presents a novel recursive formula for calculating the reconstruction error of the data matrix and then proposes a fast and accurate algorithm, which selects the most representative columns in a greedy manner. The paper then presents a distributed column subset selection algorithm for selecting a very few columns from a big data matrix with massivelydistributedcolumns.Thealgorithmstartsbylearningaconciserepresentationofthe data matrix using random projection. Each machine then independently solves a generalized column subset selection problem in which a subset of columns is selected from the current sub-matrix such that the reconstruction error of the concise representation is minimized. A required number of columns. The proposed algorithm is designed to be executed efficiently over massive amounts of data stored on a cluster of several commodity nodes. In such settings of infrastructure, ensuring the scalability and the fault tolerance of data processing jobs is not a trivial task. In order to alleviate these problems, MapReduce [ 15 ] was introduced to simplify large-scale data analytics over a distributed environment of commodity machines. Currently, MapReduce (and its open source implementation Hadoop [ 56 ]) is considered the most successful and widely used framework for managing big data processing jobs. The approach proposed in this paper considers the different aspects of developing MapReduce-efficient algorithms.

The contributions of the paper can be summarized as follows:  X  The paper first presents a fast and accurate algorithm for column subset selection (CSS),  X  The paper presents a novel recursive formula for calculating the reconstruction error of  X  The paper proposes an algorithm for distributed CSS, which first learns a concise repre- X  To facilitate CSS from different sub-matrices, a fast and accurate algorithm for general- X  A MapReduce-efficient algorithm is proposed for learning a concise representation using  X  Medium-and large-scale experiments have been conducted on benchmark data sets in
The rest of the paper is organized as follows. Section 2 describes the notations used throughout the paper. Section 3 gives a brief background on the CSS problem and the MapRe-duce framework. Section 4 describes the centralized greedy algorithm for CSS. The proposed MapReduce algorithm for distributed CSS is described in detail in Sect. 5 . Section 6 reviews the state-of-the-art CSS methods and their applicability to distributed data. In Sect. 7 ,an empirical evaluation of the proposed method is described. Finally, Sect. 8 concludes the paper. 2 Notations The following notations are used throughout the paper unless otherwise indicated. Scalars in the distributed environment. In addition, the following notations are used: For a set S : | S | the cardinality of the set.
 For a vector x  X  R m : x i i -th element of x . x the Euclidean norm ( 2 -norm) of x .
 For a matrix A  X  R m  X  n :
A ij ( i , j ) -th entry of A .
 A i : i -th row of A .
 A : j j -th column of A .
 A : S the sub-matrix of A which consists of the set S of columns.
 A T the transpose of A .

A F the Frobenius norm of A : A F = i , j A 2 ij .
A S a rank-l approximation of A based on the set S of columns, where | S |= l . 3 Background This section reviews the necessary background on the column subset selection (CSS) problem and the MapReduce paradigm used to develop the large-scale CSS algorithm presented in this paper. 3.1 Column subset selection (CSS) The column subset selection (CSS) problem can be generally defined as the selection of the most representative columns of a data matrix [ 3 , 6 , 7 ]. The CSS problem generalizes the problem of selecting representative data instances, as well as the unsupervised feature selection problem. Both are crucial tasks that can be directly used for data analysis or as preprocessing steps for developing fast and accurate algorithms in data mining and machine learning.

Although different criteria for column subset selection can be defined, a common criterion that has been used in much recent work measures the discrepancy between the original matrix 20  X  22 , 29 ]. Most of the recent work either develops CSS algorithms that directly optimize this criterion or uses this criterion to assess the quality of the proposed CSS algorithms. In the present work, the CSS problem is formally defined as Problem 1 (Column Subset Selection) Given an m  X  n matrix A andaninteger l ,finda subset of columns L such that | L |= l and where P ( S ) is an m  X  m projection matrix which projects the columns of A onto the span of
The criterion F ( S ) = A  X  P ( S ) A 2 F represents the sum of squared errors between the original data matrix A and its rank-l column-based approximation (where l =| S | ), In other words, the criterion F ( S ) calculates the Frobenius norm of the residual matrix E = A  X   X  A S . Other types of matrix norms can also be used to quantify the reconstruction error. Some of the recent work on the CSS problem [ 3 , 6 , 7 ] derives theoretical bounds for both the Frobenius and spectral norms of the residual matrix. The present work, however, focuses on developing algorithms that minimize the Frobenius norm of the residual matrix. The projection matrix P ( S ) can be calculated as where A : S is the sub-matrix of A , which consists of the columns corresponding to S .
It should be noted that if the subset of columns S is known, the projection matrix P ( S ) can be derived as follows. The columns of the data matrix A can be approximated as linear combinations of the subset of columns S : where T is an l  X  n matrix of coefficients, which can be found by solving the following optimization problem.
 This is a least-squares problem whose closed-form solution is T  X  = A T : S A : S Substituting with T  X  in  X  A S gives
The set of selected columns (i.e., data instances or features) can be directly presented to a further analysis. For instance, the selected columns can be used to obtain a low-dimensional representation of all columns into the subspace of selected ones. This representation can be calculated as follows. 1. Calculate an orthonormal basis Q for the selected columns, 2. Embed all columns of A into the subspace of Q ,
The selected columns can also be used to calculate a column-based low-rank approxima-tion of A [ 22 ]. Given a subset S of columns with | S |= l ,arank-l approximation of the data matrix A can be calculated as:
In order to calculate a rank-k approximation of the data matrix A where k  X  l ,the following procedure suggested by Boutsidis et al. [ 3 ] can be used. 1. Calculate an orthonormal basis Q for the columns of A : S and embed all columns of A 2. Calculate the best rank-k approximation of the embedded columns using singular value 3. Calculate the column-based rank-k approximation of A as: This procedure results in a rank-k approximation of A within the column space of A : S that achieves the minimum reconstruction error in terms of Frobenius norm [ 3 ]: Moreover, the leading singular values and vectors of the low-dimensional embedding W can be used to approximate those of the data matrix as follows: elements approximate the leading k singular values of A . 3.2 MapReduce paradigm MapReduce [ 15 ] was presented as a programming modelto simplify large-scale data analytics over a distributed environment of commodity machines. The rationale behind MapReduce is to impose a set of constraints on data access at each individual machine and communication between different machines to ensure both the scalability and fault tolerance of the analytical tasks. Currently, MapReduce has been successfully used for scaling various data analysis kernel k -means clustering [ 23 ].

A MapReduce job is executed in two phases of user-defined data transformation functions, namely map and reduce phases. The input data are split into physical blocks distributed among the nodes. Each block is viewed as a list of key-value pairs. In the first phase, the key-value pairs of each input block b are processed by a single map function running independently on the node where the block b is stored. The key-value pairs are provided one-by-one to the map function. The output of the map function is another set of intermediate key-value pairs. The values associated with the same key across all nodes are grouped together and provided as an input to the reduce function in the second phase. Different groups of values are processed in parallel on different machines. The output of each reduce function is a third set of key-value pairs and collectively considered the output of the job. It is important to note that the set of the intermediate key-value pairs is moved across the network between the nodes, which incurs significant additional execution time when much data are to be moved. For complex analytical tasks, multiple jobs are typically chained together [ 24 ] and/or many rounds of the same job are executed on the input data set [ 25 ].

In addition to the programming model constraints, Karloff et al. [ 40 ]definedasetof computational constraints that ensure the scalability and the efficiency of MapReduce-based analytical tasks. These computational constraints limit the used memory size at each machine, the output size of both the map and reduce functions and the number of rounds used to complete a certain tasks.

The MapReduce algorithms presented in this paper adhere to both the programming model constraints and the computational constraints. The proposed algorithm aims also at minimizingtheoverallrunningtimeofthedistributedcolumnsubsetselectiontasktofacilitate interactive data analytics. 4 Greedy column subset selection The column subset selection criterion presented in Sect. 3.1 measures the reconstruction error of a data matrix based on the subset of selected columns. The minimization of this criterion is a combinatorial optimization problem whose optimal solution can be obtained in O n l mnl [ 6 ]. This section describes a deterministic greedy algorithm for optimizing this criterion, which extends the greedy method for unsupervised feature selection recently proposed by the greedy CSS algorithm is described in details. 4.1 Recursive selection criterion The recursive formula of the CSS criterion is based on a recursive formula for the projection matrix P ( S ) , which can be derived as follows.
 Lemma 1 Given a set of columns S . For any P  X  S , where R ( R ) is a projection matrix which projects the columns of E = A  X  P ( P ) A onto the span of the subset R = S \ P of columns, Proof Define a matrix B = A T : S A : S , which represents the inner product over the columns of the sub-matrix A : S . The projection matrix P ( S ) can be written as:
Without loss of generality, the columns and rows of A : S and B in Eq. ( 6 ) can be rearranged such that the first sets of rows and columns correspond to P :
Let S = B RR  X  B T PR B  X  1 PP B PR be the Schur complement [ 48 ]of B PP in B .Usingthe block-wise inversion formula [ 48 ], B  X  1 can be calculated as: Substitute with A : S and B  X  1 in Eq. ( 6 ): from the 4th and 5th terms: Take out S  X  1 A T : R  X  B T PR B  X  1 PP A T : P as a common factor from the 2nd and 3rd terms:
The first term of Eq. ( 7 ) is the projection matrix, which projects the columns of A onto the span of the subset P of columns: P ( P ) = A : P A T : P A : P term can be simplified as follows. Let E be an m  X  n residual matrix, which is calculated as: E = A  X  P ( P ) A . The sub-matrix E : R can be expressed as: Since projection matrices are idempotent, then P ( P ) P ( P ) = P ( P ) and the inner product E Substituting with P ( P ) = A : P A T : P A : P E respectively, Eq. ( 7 ) can be expressed as: The second term is the projection matrix which projects the columns of E onto the span of the subset R of columns: This proves that P ( S ) can be written in terms of P ( P ) and R as: P ( S ) = P ( P ) + R ( R )
This means that projection matrix P ( S ) can be constructed in a recursive manner by first calculating the projection matrix which projects the columns of A onto the span of the subset P of columns, and then calculating the projection matrix which projects the columns of the residual matrix onto the span of the remaining columns. Based on this lemma, a recursive formula can be developed for  X  A S .
 Corollary 1 Given a matrix A and a subset of columns S . For any P  X  S , where E = A  X  P ( P ) A, and  X  E R is the low-rank approximation of E based on the subset R = S \ P of columns.
 Proof Using Lemma ( 1 ), and substituting with P ( S ) in Eq. ( 1 )gives: The first term is the low-rank approximation of A based on P :  X  A P = P ( P ) A . The second gives: E : R E . Substituting E T : R A with E T : R E in Eq. ( 9 ) proves the corollary.
This means that the column-based low-rank approximation of A based on the subset S of columns can be calculated in a recursive manner by first calculating the low-rank approxi-mation of A based on the subset P  X  S , and then calculating the low-rank approximation of the residual matrix E based on the remaining columns.

BasedonCorollary( 1 ), a recursive formula for the column subset selection criterion can be developed as follows.
 Theorem 2 Given a set of columns S . For any P  X  S , where E = A  X  P ( P ) A, and  X  E R is the low-rank approximation of E based on the subset R = S \ P of columns.
 Proof Using Corollary ( 1 ), the CSS criterion can be expressed as: Using the relation between the Frobenius norm and the trace function, 1 the right-hand side can be expressed as: As R ( R ) R ( R ) = R ( R ) (an idempotent matrix), F ( S ) can be expressed as: F ( S ) = trace E T E  X  E T R ( R ) R ( R ) E = trace E T E  X   X  E R  X  E R = E 2 Replacing E 2 F with F ( P ) proves the theorem.

The term  X  E R 2 F represents the decrease in reconstruction error achieved by adding the subset R of columns to P . In the following section, a novel greedy heuristic is presented to optimize the column subset selection criterion based on this recursive formula. 4.2 Greedy selection algorithm This section presents an efficient greedy algorithm to optimize the column subset selection criterion presented in Sect. 3.1 . The algorithm selects at each iteration one column such that the reconstruction error for the new set of columns is minimized. This problem can be formulated as follows: Problem 2 At iteration t ,findcolumn p such that, where S is the set of columns selected during the first t  X  1 iterations.

A na X ve implementation of the greedy algorithm is to calculate the reconstruction error for each candidate column and then select the column with the smallest error. This imple-mentation is, however, computationally very complex, as it requires O ( m 2 n 2 ) floating-point operations per iteration. A more efficient approach is to use the recursive formula for calcu-lating the reconstruction error. Using Theorem 2 , i .Since F ( S ) is a constant for all candidate columns, an equivalent criterion is: This formulation selects the column p which achieves the maximum decrease in recon-struction error. Using the properties that: trace ( AB ) = trace ( BA ) and trace ( aA ) = atrace ( A ) where a is a scalar, the new objective function  X  E { i } follows: This defines the following equivalent problem.
 Problem 3 (Greedy Column Subset Selection) At iteration t ,findcolumn p such that, where E = A  X   X  A S ,and S is the set of columns selected during the first t  X  1 iterations.
The computational complexity of this selection criterion is O n 2 m per iteration, and it requires O ( nm ) memory to store the residual of the whole matrix, E , after each iteration. In order to reduce these memory requirements, a memory-efficient algorithm can be proposed calculate the column subset selection criterion without explicitly calculating and storing the residual matrix E at each iteration. The algorithm is based on a recursive formula for calculating the residual matrix E .

Let S ( t ) denote the set of columns selected during the first t  X  1 iterations, E ( t ) denote column selected at iteration t . The following lemma gives a recursive formula for residual matrix at the start of iteration t + 1, E ( t + 1 ) . Lemma 2 E ( t + 1 ) can be calculated recursively as: tuting A  X   X  A S  X  X  p } and A  X   X  A S with E ( t + 1 ) and E ( t ) , respectively, gives: with this formula in the above equation proves the lemma.

Let G be an n  X  n matrix which represents the inner products over the columns of the residual matrix E : G = E T E . The following corollary is a direct result of Lemma 2 . Corollary 3 G ( t + 1 ) can be calculated recursively as: Proof This corollary can be proved by substituting with E ( t + 1 ) T (Lemma 2 )in G ( t + 1 ) = E
To simplify the derivation of the memory-efficient algorithm, at iteration t ,define  X  = G : p and  X  ( t ) as follows: or in terms of A and previous  X   X  X  as:  X  ( t ) and  X  ( t ) can be calculated in terms of A and previous  X   X  X  as follows:
The column subset selection criterion can be expressed in terms of G as:
Thefollowingtheoremgivesrecursiveformulasforcalculatingthecolumnsubsetselection criterion without explicitly calculating E or G . Theorem 4 Let f i = G : i 2 and g i = G ii be the numerator and denominator of the where  X  represents the Hadamard product operator.
 Proof Based on Eq. ( 14 ), f ( t ) i can be calculated as: Similarly, g ( t ) i can be calculated as:
Let f = f i i = 1 ... n and g = g i i = 1 ... n , f ( t ) and g ( t ) can be expressed as: where  X  represents the Hadamard product operator, and . is the 2 norm.

Based on the recursive formula of G (Eq. 15 ), the term G  X  at iteration ( t  X  1 ) can be expressed as: Substituting with G  X  in Eq. ( 19 ) gives the update formulas for f and g .

This means that the greedy criterion can be memory efficient by only maintaining two score variables for each column, f i and g i , and updating them at each iteration based on their previous values and the columns selected so far.

Algorithm 1 shows the complete greedy CSS algorithm. Algorithm 1 Greedy Column Subset Selection 5 Distributed column subset selection on MapReduce This section describes a MapReduce algorithm for the distributed column subset selection problem. Given a big data matrix A whose columns are distributed across different machines, the goal is to select a subset of columns S from A such that the CSS criterion F ( S ) is minimized.

One na X ve approach to perform distributed column subset selection is to select different subsets of columns from the sub-matrices stored on different machines. The selected sub-sets are then sent to a centralized machine where an additional selection step is optionally performed to filter out irrelevant or redundant columns. Let A ( i ) be the sub-matrix stored at machine i , the na X ve approach optimizes the following function. data. The resulting set of columns is the union of the sets selected from different sub-matrices:
The na X ve approach, however simple, is prone to missing relevant columns. This is because the selection at each machine is based on approximating a local sub-matrix, and accord-ingly, there is no way to determine whether the selected columns are globally relevant or not. For instance, suppose the extreme case where all the truly representative columns hap-pen to be loaded on a single machine. In this case, the algorithm will select a less-than-required number of columns from that machine and many irrelevant columns from other machines.

In order to alleviate this problem, the different machines have to select columns that best approximate a common representation of the data matrix. To achieve that, the proposed algo-rithm first learns a concise representation of the span of the big data matrix. This concise representation is relatively small, and it can be sent over to all machines. After that, each machine can select columns from its sub-matrix that approximate this concise representa-tion. The proposed algorithm uses random projection to learn this concise representation and proposes a generalized column subset selection (CSS) method to select columns from different machines. The details of the proposed methods are explained in the rest of this section. 5.1 Random projection The first step of the proposed algorithm is to learn a concise representation B for a distrib-uted data matrix A . In the proposed approach, a random projection method is employed. Random projection [ 1 , 14 , 46 ] is a well-known technique for dealing with the curse-of-the-dimensionality problem. Let be a random projection matrix of size n  X  r , and given a data matrix X of size m  X  n , the random projection can be calculated as Y = X . It has been shown that applying random projection to X preserves the pairwise distances between vectors in the row space of X with a high probability [ 14 ]: where is an arbitrarily small factor.
 SincetheCSScriterion F ( S ) measuresthereconstructionerrorbetweenthebigdatamatrix A and its low-rank approximation P ( S ) A , it essentially measures the sum of the distances between the original rows and their approximations. This means that when applying random approximately equal to that of A when both are approximated using the subset of selected columns: So, instead of optimizing A  X  P ( S ) A 2 F , the distributed CSS can approximately optimize Let B = A , the distributed column subset selection problem can be formally defined as Problem 4 (Distributed Column Subset Selection) Given an m  X  n ( i ) sub-matrix A ( i ) which where B = A , is an n  X  r random projection matrix, S is the set of the indices of the candidate columns and L ( i ) is the set of the indices of the selected columns from A ( i ) .
A key observation here is that random projection matrices whose entries are sampled i . i . d from some univariate distribution can be exploited to compute random projection on MapReduce in a very efficient manner. Examples of such matrices are Gaussian random
In order to implement random projection on MapReduce, the data matrix A is distributed in a column-wise fashion and viewed as pairs of i , A : i where A : i is the i -th column of A . Recall that B = A can be rewritten as and since the map function is provided one columns of A at a time, one does not need to worry about pre-computing the full matrix . In fact, for each input column A : i ,anewvector : needs to be sampled from . So, each input column generates a matrix of size m  X  r , which means that O ( nmr ) data should be moved across the network to sum the generated n matrices at m independent reducers each summing a row B j : to obtain B . To minimize that network cost, an in-memory summation can be carried out over the generated m  X  r Algorithm 2 Fast Random Projection on MapReduce matrices at each mapper. This can be done incrementally after processing each column of A . That optimization reduces the network cost to O ( cmr ) ,where c is the number of physical blocks of the matrix. 2 Algorithm 2 outlines the proposed random projection algorithm. The term emit is used to refer to outputting new key ,v alue pairs from a mapper or a reducer. 5.2 Generalized column subset selection This section presents the generalized column subset selection algorithm, which will be used to perform the selection of columns at different machines. While Problem 1 is concerned with the selection of a subset of columns from a data matrix which best represent other columns of the same matrix, Problem 4 selects a subset of columns from a source matrix which best represent the columns of a different target matrix. The objective function of Problem 4 represents the reconstruction error of the target matrix B based on the selected columns from the source matrix, and the term P ( S ) = A : S A T : S A : S projects the columns of B onto the subspace of the columns selected from A .
 In order to optimize this new criterion, a greedy algorithm can be introduced. Let  X  F ( S ) =
B  X  P ( S ) B 2 F be the distributed CSS criterion, the following theorem derives a recursive formula for  X  F ( S ) .
 Theorem 5 Given a set of columns S . For any P  X  S , where F = B  X  P ( P ) B, and  X  F R is the low-rank approximation of F based on the subset R = S \ P of columns of E = A  X  P ( P ) A.
 and multiplying both sides with gives Low-rank approximations can be written in terms of projection matrices as Algorithm 3 Greedy Generalized Column Subset Selection Using B = A , Let F = E . The matrix F is the residual after approximating B using the set P of columns This means that Substituting in  X  F ( S ) = B  X  P ( S ) B 2 F gives Using F = B  X  P ( P ) B gives Using the relation between Frobenius norm and trace, Using  X  F ( P ) = F 2 F and  X  F R = R ( R ) F proves the theorem.

Using the recursive formula for  X  F ( S  X  X  i } ) allows the development of a greedy algorithm which at iteration t optimizes
Let G = E T E and H = F T E , the objective function of this optimization problem can be simplified as follows This allows the definition of the following generalized CSS problem.
 Problem 5 (Greedy Generalized CSS) At iteration t ,findcolumn p such that where H = F T E , G = E T E , F = B  X  P ( S ) B , E = A  X  P ( S ) A and S is the set of columns selected during the first t  X  1 iterations.

For iteration t ,define  X  = H : p and  X  = H : p / G pp =  X  /  X  p . The vector  X  ( t ) can be
Similarly, the numerator and denominator of the selection criterion at each iteration can be calculated in an efficient manner using the following theorem.
 Theorem 6 Let f i = H : i 2 and g i = G ii be the numerator and denominator of the greedy where  X  represents the Hadamard product operator.

As outlined in Sect. 5.1 , the algorithm X  X  distribution strategy is based on sharing the concise representation of the data B among all mappers. Then, independent l ( b ) columns from each mapper are selected using the generalized CSS algorithm. A second phase of selection is run over the c b = 1 l ( b ) (where c is the number of input blocks) columns to find ) = l / c  X  b  X  1 , 2 ,... c ). Algorithm 4 sketches the MapReduce implementation of the distributed CSS algorithm. It should be emphasized that the proposed MapReduce algorithm requires only two passes over the data set, and its moves a very few amount of the data across the network.

Regarding the memory requirements of the proposed method, in the map phase of the random projection stage (Algorithm 2 ), the needed memory per node is of O ( mr ) ,which memory to sum the corresponding rows of  X  B i . The memory complexity of the map phase of the selection stage (Algorithm 4 ) is that required for storing the matrices A ( b ) and B . Let q denote the number of columns loaded into the matrix A ( b ) in Algorithm 4 (lines 3:4); the memory complexity of the mapper of Algorithm 4 is of O ( m ( q + r )) . Similarly, let Algorithm 4 Distributed CSS on MapReduce p (lines 9:10). The memory complexity of the reduce phase of Algorithm 4 is of O ( m ( p + r )) . Hence, the overall memory complexity per node required by the proposed approach can be bounded by O ( m ( r + max ( q , p ))) . 6 Related work Different approaches have been proposed for selecting a subset of representative columns from a data matrix. This section focuses on briefly describing these approaches and their applicability to massively distributed data matrices. The column subset selection (CSS) meth-ods can be generally categorized into randomized, deterministic and hybrid. 6.1 Randomized methods The randomized methods sample a subset of columns from the original matrix using carefully chosen sampling probabilities. The main focus of this category of methods is to develop fast algorithms for column subset selection and then derive a bound for the reconstruction error of the data matrix based on the selected columns relative to the best possible reconstruction error obtained using Singular Value Decomposition (SVD).

Frieze et al. [ 29 ] was the first to suggest the idea of randomly sampling l columns from a matrix and using these columns to calculate a rank-k approximation of the matrix (where l  X  k ). The authors derived an additive bound for the reconstruction error of the data matrix. This work of Frieze et al. was followed by different papers [ 20 , 21 ] that enhanced the algo-rithm by proposing different sampling probabilities and deriving better error bounds for the reconstruction error. Drineas et al. [ 22 ] proposed a subspace sampling method which samples columns using probabilities proportional to the norms of the rows of the top k right singular vectors of A . The subspace sampling method allows the development of a relative error bound (i.e., a multiplicative error bound relative to the best rank-k approximation). However, the subspace sampling depends on calculating the leading singular vectors of a matrix which is computationally very complex for large matrices.
Deshpande et al. [ 18 , 19 ] proposed an adaptive sampling method which updates the sam-pling probabilities based on the columns selected so far. This method is computationally very same paper, Deshpande et al. also proved the existence of a volume sampling algorithm (i.e., sampling a subset of columns based on the volume enclosed by their vectors) which achieves a multiplicative ( l + 1)-approximation. However, the authors did not present a polynomial time algorithm for this volume sampling algorithm.

Column subset selection with uniform sampling can be easily implemented on MapRe-duce. For non-uniform sampling, the efficiency of implementing the selection on MapReduce is determined by how easy are the calculations of the sampling probabilities. The calcula-tions of probabilities that depend on calculating the leading singular values and vectors are time-consuming on MapReduce. On the other hand, adaptive sampling methods are compu-tationally very complex as they depend on calculating the residual of the whole data matrix after each iteration. 6.2 Deterministic methods The second category of methods employs a deterministic algorithm for selecting columns such that some criterion function is minimized. This criterion function usually quantifies the reconstruction error of the data matrix based on the subset of selected columns. The deterministic methods are slower, but more accurate, than the randomized ones.
In the area of numerical linear algebra, the column pivoting method exploited by the QR decomposition [ 30 ] permutes the columns of the matrix based on their norms to enhance the numerical stability of the QR decomposition algorithm. The first l columns of the permuted matrix can be directly selected as representative columns. The Rank-Revealing QR (RRQR) decomposition [ 2 , 11 , 31 , 52 ] is a category of QR decomposition methods which permute columns of the data matrix while imposing additional constraints on the singular values of the two sub-matrices of the upper triangular matrix R corresponding to the selected and non-selected columns. It has been shown that the constrains on the singular values can be used to derive an theoretical guarantee for the column-based reconstruction error according to spectral norm [ 7 ].

Besides methods based on QR decomposition, different recent methods have been pro-posed for directly selecting a subset of columns from the data matrix. Boutsidis et al. [ 7 ] proposed a deterministic column subset selection method which first groups columns into clusters and then selects a subset of columns from each cluster. The authors proposed a general framework in which different clustering and subset selection algorithms can be employed to select a subset of representative columns.  X ivril and Magdon-Ismail [ 9 , 10 ] presented a deter-ministic algorithm which greedily selects columns from the data matrix that best represent the right leading singular values of the matrix. This algorithm, however accurate, depends on the calculation of the leading singular vectors of a matrix, which is computationally very complex for large matrices.

Recently, Boutsidis et al. [ 3 ] presented a column subset selection algorithm which first calculates the top-k right singular values of the data matrix (where k is the target rank) and then uses deterministic sparsification methods to select l  X  k columns from the data matrix. The authors derived a theoretically near-optimal error bound for the rank-k column-based approximation. Deshpande and Rademacher [ 17 ] presented a polynomial time determinis-tic algorithm for volume sampling with a theoretical guarantee for l = k . Quite recently, Guruswami and Sinop [ 32 ] presented a deterministic algorithm for volume sampling with theoretical guarantee for l &gt; k . The deterministic volume sampling algorithms are, however, more complex than the algorithms presented in this paper, and they are infeasible for large data sets.

ThedeterministicalgorithmsaremorecomplextoimplementonMapReduce.Forinstance, it is time-consuming to calculate the leading singular values and vectors of a massively dis-tributed matrix or to cluster their columns using k -means. It is also computationally complex to calculate QR decomposition with pivoting. Moreover, the recently proposed algorithms for volume sampling are more complex than other CSS algorithms as well as the one presented in this paper, and they are infeasible for large data sets. 6.3 Hybrid methods A third category of CSS techniques is the hybrid methods which combine the benefits of both the randomized and deterministic methods. In these methods, a large subset of columns is randomly sampled from the columns of the data matrix and then a deterministic step is employed to reduce the number of selected columns to the desired rank.

For instance, Boutsidis et al. [ 6 ] proposed a two-stage hybrid algorithm for column subset selection which runs in O min n 2 m , nm 2 . In the first stage, the algorithm samples c = O ( l log l ) columnsbasedonprobabilitiescalculatedusingthe l -leadingrightsingularvectors. In the second phase, a Rank-revealing QR (RRQR) algorithm is employed to select exactly l columns from the columns sampled in the first stage. The authors suggested repeating the selection process 40 times in order to provably reduce the failure probability. The authors proved a good theoretical guarantee for the algorithm in terms of spectral and Frobenius term. However, the algorithm depends on calculating the leading l right singular vectors which is computationally complex for large data sets.

The hybrid algorithms for CSS can be easily implemented on MapReduce if the ran-domized selection step is MapReduce efficient, and the deterministic selection step can be implemented on a single machine. This is usually true if the number of columns selected by the randomized step is relatively small. 6.4 Related work on unsupervised feature selection The column subset selection problem is a generalized variant of the unsupervised feature selection problem in which the columns of the data matrix represent features. Much research has been done on the unsupervised feature selection problem. This includes, but not limited to, (1) methods that depend on the Principal Component Analysis (PCA) method to search for similarities between data instances, such as the Laplacian score (LS) [ 34 ] and the spectral feature selection method (a.k.a., SPEC) [ 59 ], and (3) methods that directly select features Cluster Feature Selection (MCFS) [ 8 ]. In addition to these categories, there are methods for unsupervised feature selection that optimize PCA-like criteria such as the Convex Principal Feature Selection (CPFS) [ 49 ], and methods that depend on clustering the features into groups and selecting representative features from each group, such as the Feature Selection using Feature Similarity (FSFS) [ 51 ].

Although a variety of methods for unsupervised feature selection can be used for column subset selection, many of these methods optimize objective functions that are different from that of Problem 1 , and some of them assume that there is a cluster structure in the data. This accordingly limits the direct applicability of these methods to the column subset selection problem. 6.5 Comparison with related work The greedy column subset selection algorithm presented in Sect. 4 belongs to the category of deterministic algorithms. In comparison with QR-based methods, the greedy CSS algorithm can be implicitly used to calculate a Q -less incomplete QR factorization of the data matrix A : where is a permutation matrix which sorts the first l columns according to their selec-tion order. The permutation of the columns of the embedding matrix W produces an upper triangular matrix.
 The greedy CSS algorithm differs from the greedy algorithm proposed by  X ivril and position of the data matrix, which is computationally complex, especially for large matrices. The proposed algorithm is also more efficient than the recently proposed volume sampling algorithms [ 17 , 32 ].

In comparison with other CSS methods, the distributed algorithm proposed in this paper is designed to be MapReduce efficient. In the selection step, representative columns are selected based on a common representation. The common representation proposed in this work is based on random projection. This is more efficient than the work of  X ivril and Magdon-Ismail [ 10 ] which selects columns based on the leading singular vectors. In comparison with other deterministic methods, the proposed algorithm is specifically designed to be parallelized, which makes it applicable to big data matrices whose columns are massively distributed. On the other hand, the two-step of distributed then centralized selection is similar to that of the hybrid CSS methods. The proposed algorithm, however, employs a deterministic algorithm at the distributed selection phase which is more accurate than the randomized selection employed by hybrid methods in the first phase.

In connection to the unsupervised feature selection problem, a variant of the greedy algo-rithm presented in this paper has previously been proposed for the unsupervised feature selection problem [ 27 , 28 ] where it has shown superior performance to other state-of-the-art methods for unsupervised feature selection. However, the algorithm proposed by Farahat et distributed across different machines. 7 Experiments Two sets of experiments have been conducted. The first set of experiments has been con-ducted on medium-sized data sets in order to evaluate the efficiency and effectiveness of the centralized greedy CSS algorithm in comparison with state-of-the-art methods for CSS. The second set of experiments has been conducted on two big data sets to evaluate the efficiency and effectiveness of the distributed CSS algorithm on MapReduce.

Experiments have been conducted on eight benchmark data sets, whose properties are summarized in Table 1 . 3 The first six data sets were used to conduct the centralized exper-iments. The Reuters-21578 is the training set of the Reuters-21578 collection [ 44 ]. The Reviews and LA1 are document data sets from TREC collections. 4 The preprocessed ver-sions of Reviews and LA1 that are distributed with the CLUTO Toolkit [ 41 ]wereused.The MNIST-4K is a subset of the MNIST data set of handwritten digits. 5 The PIE-20 and YaleB-38 are preprocessed subsets of the CMU PIE [ 53 ] and Extended Yale Face [ 43 ] data sets, respectively. The PIE-20 and YaleB-38 data sets have been used by He et al. [ 35 ]toevaluate different face recognition algorithms. Besides, the distributed experiments were conducted on two data sets. The RCV1-200K is a subset of the RCV1 data set [ 45 ] which has been prepared and used by Chen et al. [ 12 ] to evaluate parallel spectral clustering algorithms. The TinyImages-1M data set contains 1 million images that were sampled from the 80 million tiny images data set [ 55 ] and converted to grayscale.

Similar to previous work on CSS, the different methods are evaluated according to their ability to minimize the reconstruction error of the data matrix based on the subset of selected columns. In order to quantify the reconstruction error across different data sets, a relative accuracy measure is defined as where  X  A U is the rank-l approximation of the data matrix based on a random subset U of columns,  X  A S is the rank-l approximation of the data matrix based on the subset S of columns Decomposition (SVD). This measure compares different methods relative to the uniform sampling as a baseline with higher values indicating better performance. 7.1 Evaluation of centralized greedy CSS In the medium-scale experiments, the following CSS methods are compared. 6  X  UniNoRep : is uniform sampling of columns without replacement.  X  qr : is the QR decomposition with column pivoting [ 30 ] implemented by the MATLAB  X  SRRQR : is the strong rank-revealing QR decomposition [ 31 ]. Algorithm 4 of [ 31 ]was  X  ApproxSVD : is the sparse approximation of Singular Value Decomposition (SVD) [ 9 ,  X  HybridCSS : is the hybrid column subset selection algorithm proposed by Bousidis et  X  GreedyCSS : is the greedy column subset selection method described in Algorithm 1 .  X  RndGreedyCSS : is the greedy algorithm for the generalized column subset selection in
For all the data sets, the percentage of selected columns l / n is changed from 1 to 25% with increments of 2% and the relative accuracies and run times are measured. 10 Experiments with randomness were repeated ten times, and the average and standard deviation of measures were calculated.

Figures 1 and 2 show the relative accuracy measures and run times for different CSS methods on the six benchmark data sets. 11
Inaddition,Tables 2 and 3 showtherelativeaccuracymeasuresforthebestperformingCSS methods ( HybridCSS , ApproxSVD , GreedyCSS ,and RndGreedyCSS ). Each sub-table represents a data set and each column represents a percentage of selected columns. In order to test the statistical significance of the accuracy measures obtained by the proposed methods, the analysis of variance (ANOVA) procedure [ 36 ] is conducted for each sub-column. 12 In specific, the F -test is performed on all the accuracy measures in each sub-column to test the null-hypothesis that all the accuracy measures are drawn from populations with the same are conducted on pairs of the best performing methods. The F -statistic, p value, and results of the Tukey X  X  tests are reported in the table.

It can be observed from the figures and table that for all data sets, the GreedyCSS method significantly outperforms the UniNoRep , qr , SRRQR ,and HybridCSS methods in terms of relative accuracy, and it shows comparable accuracy to the ApproxSVD method for almost all data sets (where a = b in Tables 2 and 3 ). In terms of run times, for most of the data sets, the GreedyCSS scales better than the HybridCSS and ApproxSVD methods.

On the other hand, the RndGreedyCSS outperforms the UniNoRep , qr ,and SRRQR methods in terms of relative accuracy and shows comparable accuracy to the HybridCSS method. In terms of run times, the RndGreedyCSS is much more efficient than the Hybrid-CSS method and other methods for all data sets. It should also be noted that the SRRQR method achieves comparable accuracy to the qr method and both methods demonstrate lower approximation accuracies than other deterministic and hybrid methods. 7.2 Evaluation of distributed greedy CSS The distributed CSS method has been compared with different state-of-the-art methods. It should be noted that most of these methods were not designed with the goal of applying them to massively distributed data, and hence, their implementation on MapReduce is not straightforward. However, the designed experiments used the best practices for implementing the different steps of these methods on MapReduce to the best of the authors X  knowledge. In specific, the following distributed CSS algorithms were compared.  X  UniNoRep : is uniform sampling of columns without replacement. This is usually the  X  Hybrid (Uniform) , Hybrid (Column Norms) and Hybrid (SVD-based) : are different  X  DistApproxSVD : is an extension of the centralized algorithm for sparse approximation  X  DistGreedyCSS : is the distributed column subset selection method described in Algo-
Experiments with randomness were repeated three times, and the average and standard deviation of measures were calculated. For the methods that require the calculations of Singular Value Decomposition (SVD), the Stochastic SVD (SSVD) algorithm [ 33 ]isused to approximate the leading singular values and vectors of the data matrix. The use of SSVD significantly reduces the run time of the original SVD-based algorithms while achieving comparable accuracy. In the conducted experiments, the SSVD implementation of Mahout was used.

The distributed experiments were conducted on Amazon EC2 13 clusters, which consist of 10 instances for the RCV1-200K data set and 20 instances for the TinyImages-1M data set. Each instance has a 7.5 GB of memory and a two-cores processor. All instances are running Debian 6.0.5 and Hadoop version 1.0.3. The data sets were converted into a binary format in the form of a sequence of key-value pairs. Each pair consisted of a column index as the key and a vector of the column entries. That is the standard format used in Mahout 14 for storing distributed matrices.

Tables 4 and 5 show the average relative accuracies and run times for distributed CSS methods, respectively. In Table 4 , the analysis of variance (ANOVA) procedure was con-ducted on the accuracy measures in each sub-column. The statistical significance tests were performed as explained in Sect. 7.1 .

It can be observed from the table that for the RCV1-200K data set, the DistGreedyCSS methods (with random Gaussian and sparse random sing matrices) outperforms uniform sampling and hybrid methods in terms of relative accuracies. In addition, the run times of both of DistGreedyCSS methods are relatively small compared with the DistApproxSVD method which achieves accuracies that are statistically equivalent to the DistGreedyCSS methods for l = 10 and l = 100 (where a = b , a = c in the RCV1-200K sub-table of Table 4 ). Both the DistApproxSVD and DistGreedyCSS methods achieve very good approximation accuracies compared with randomized and hybrid methods. It should also be noted that using a sparse random sign matrix for random projection takes much less time than a dense Gaussian matrix, while achieving comparable approximation accuracies (where b = c in the RCV1-200K sub-table of Table 4 ). Based on this observation, the sparse random matrix has been used with the TinyImages-1M data set.

For the TinyImages-1M data set, although the DistApproxSVD achieves slightly higher approximation accuracies than DistGreedyCSS (with sparse random sign matrix), they are statistically equivalent for l = 10 and l = 100 (where a = b in the TinyImages-1M sub-table of Table 4 )andthe DistGreedyCSS selects columns in almost one-third of the time. The reason why the DistApproxSVD outperforms DistGreedyCSS for this data set is that its rank is relatively small (less than 1024). This means that using the leading 100 singular values to represent the concise representation of the data matrix captures most of the information in the matrix and accordingly is more accurate than random projection. The DistGreedyCSS , however, still selects a very good subset of columns in a relatively small time. 8Conclusion This paper proposes a novel algorithm, which greedily selects a subset of columns from a data matrix such that reconstruction error of the data matrix is minimized. The algorithm depends on a novel recursive formula for the reconstruction error of the data matrix, which presents an accurate and efficient MapReduce algorithm for selecting a subset of columns from a massively distributed matrix. The algorithm starts by learning a concise representation of the data matrix using random projection. It then selects columns from each sub-matrix that best approximate this concise approximation. A centralized selection step is then performed on the columns selected from different sub-matrices. In order to facilitate the implementation of the proposed method, a novel algorithm for greedy generalized CSS is proposed to perform the selection from different sub-matrices. In addition, the different steps of the algorithms are carefully designed to be MapReduce efficient. Experiments on medium and big data sets show that the proposed greedy CSS method significantly outperforms uniform sampling, QR-based sampling and the hybrid CSS methods in terms of relative accuracy, and it achieves comparable accuracy to that of the approximate SVD sampling. In terms of run times, the centralized and distributed greedy CSS methods are more efficient than the SVD-based hybrid method and the approximate SVD sampling.
 References
