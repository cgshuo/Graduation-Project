 2 College of Science and Engineering 4 School of Mathematics and Big Data Differential privacy enables organizations to collect accurate aggre-gates over sensitive data with strong, rigorous guarantees on indi-viduals X  privacy. Previous work has found that under differential privacy, computing multiple correlated aggregates as a batch, using an appropriate strategy , may yield higher accuracy than comput-ing each of them independently. However, finding the best strategy that maximizes result accuracy is non-trivial, as it involves solv-ing a complex constrained optimization program that appears to be non-convex. Hence, in the past much effort has been devoted in solving this non-convex optimization program. Existing approach-es include various sophisticated heuristics and expensive numerical solutions. None of them, however, guarantees to find the optimal solution of this optimization problem.

This paper points out that under ( ,  X  )-differential privacy, the optimal solution of the above constrained optimization problem in search of a suitable strategy can be found, rather surprisingly, by solving a simple and elegant convex optimization program. Then, we propose an efficient algorithm based on Newton X  X  method, which we prove to always converge to the optimal solution with linear global convergence rate and quadratic local convergence rate. Em-pirical evaluations demonstrate the accuracy and efficiency of the proposed solution.
Differential privacy [4, 2] is a strong and rigorous privacy pro-tection model that is known for its generality, robustness and effec-tiveness. It is used, for example, in the ubiquitous Google Chrome browser [6]. The main idea is to publish randomized aggregate in-formation over sensitive data, with the guarantee that the adversary cannot infer with high confidence the presence or absence of any in-dividual in the dataset from the released aggregates. An important goal in the design of differentially private methods is to maximize the accuracy of the published noisy aggregates with respect to their exact values.

Besides optimizing for specific types of aggregates, an impor-tant generic methodology for improving the overall accuracy of the released aggregates under differential privacy is batch processing , first proposed in [12]. Specifically, batch processing exploits the correlations between multiple queries, so that answering the batch as a whole can lead to higher overall accuracy than answering each query individually. For example, if one aggregate query Q1 (e.g., the total population of New York State and New Jersey) can be ex-pressed as the sum of two other queries (the population of New York and New Jersey, respectively), i.e., Q1 = Q2 + Q3, then we can simply answer Q1 by adding up the noisy answers of Q2 and Q3. Intuitively, answering two queries instead of three reduces the amount of random perturbations required to satisfy differential pri-vacy, leading to higher overall accuracy for the batch as a whole [12, 23]. In this paper, we focus on answering linear aggregate queries under differential privacy. Given a batch of linear aggre-gate queries (called the workload ), we aim to improve their overall accuracy by answering a different set of queries (called the strate-gy ) under differential privacy, and combining their results to obtain the answers to the original workload aggregates.

As shown in [12, 13, 23, 24, 10], different strategy queries lead to different overall accuracy for the original workload. Hence, an important problem in batch processing under differential privacy is to find a suitable strategy that leads to the highest accuracy. Such a strategy can be rather complex, rendering manual construction and brute-force search infeasible [23, 24]. On the other hand, the problem of strategy searching can be formulated into a constrained optimization program, and it suffices to find the optimal solution of this program. However, as we show later in Section 2, the program appears to be non-convex; hence, solving it is rather challenging. To the best of our knowledge, existing approaches resort to either heuristics or complex, expensive and unstable numerical method-s. To our knowledge, no existing solutions guarantee to find the optimal solution.

This paper points out that under the ( ,  X  )-differential privacy definition (also called approximate differential privacy, explained in Section 2), the constrained optimization program for finding the best strategy queries can be re-formulated into a simple and elegant convex optimization program. Note that although the formulation itself is simple, its derivation is rather complicated and non-trivial. Based on this new formulation, we propose the first polynomial solution COA that guarantees to find the optimal solution to the original constrained optimization problem in search of a suitable strategy for processing a batch of arbitrary linear aggregate queries under approximate differential privacy. COA is based on Newton X  X  method and it utilizes various non-trivial properties of the problem. We show that COA achieves globally linear and locally quadratic convergence rate. Extensive experiments confirm the effectiveness and efficiency of the proposed method.

The rest of the paper is organized as follows. Section 2 provides necessary background on differential privacy and overviews relat-ed work. Section 3 presents our convex programming formulation for batch linear aggregate processing under approximate differen-tial privacy. Section 4 describes the proposed solution COA. Sec-tion 5 contains a thorough set of experiments. Section 6 concludes the paper with directions for future work. In this paper, boldfaced lowercase letters denote vectors and uppercase letters denote real-valued matrices. We summarize the frequent notations in Table 1.
Using the notations summarized in Table 1, a common definition of differential privacy is ( ,  X  )-differential privacy [4], as follows:
D EFINITION 1 . Two databases D and D 0 are neighboring iff they differ by at most one tuple. A randomized algorithm M satis-fies ( , X  )-differential privacy iff for any two neighboring databases D and D 0 and any measurable output S in the range of M , we have
When  X  = 0 , the above definition reduces to another popular definition: -differential privacy (also called  X  X xact differential pri-vacy X ). This work focuses on the case where  X  &gt; 0 , which is some-times called approximate differential privacy. Usually,  X  is set to a value smaller than 1 | D | , where | D | is the number of records in the dataset D . Both exact and approximate definitions of differential privacy provide strong and rigorous privacy protection to the users. Given the output of a differentially private mechanism, the adver-sary cannot infer with high confidence (controlled by parameters and  X  ) whether the original database is D or any of its neighbors D , which differ from D by one record, meaning that each user can plausibly deny the presence of her tuple. An approximately differ-entially private mechanism can be understood as satisfying exact differential privacy with a certain probability controlled by param-eter  X  . Hence, it is a more relaxed definition which is particularly useful when the exact definition is overly strict for an application, leading to poor result utility.

One basic mechanism for enforcing approximate differential pri-vacy is the Gaussian mechanism [3], which injects Gaussian noise to the query results calibrated to the ` 2 sensitivity of the queries. Note that the Gaussian mechanism cannot be applied to exact dif-ferential privacy. Since the proposed method is based on the Gaus-sian mechanism, it is limited to query processing under approxi-mate differential privacy as well. Specifically, for any two neigh-bor databases D and D 0 , the ` 2 sensitivity  X ( Q ) of a query set Q is defined as  X ( Q ) = max D,D 0 k Q ( D ) ,Q ( D 0 ) k 2 . Given a database D and a query set Q , the Gaussian mechanism outputs a random result that follows the Gaussian distribution with mean Q ( D ) and magnitude  X  =  X ( Q ) /h ( , X  ) , where h ( , X  ) = / p 2 ln(2 / X  ) .
This paper focuses on answering a batch of m linear aggregate queries, Q = { q 1 ,q 2 ,...,q m } , each of which is a linear combina-tion of the unit aggregates of the input database D . For simplicity, in the following we assume that each unit aggregate is a simple count, which has an ` 2 sensitivity of 1. Other types of aggregates can be handled by adjusting the sensitivity accordingly. The query set Q can be represented by a workload matrix W  X  R m  X  n rows and n columns. Each entry W ij in W is the weight in query q on the j -th unit count x j . Since we do not use any other infor-mation of the input database D besides the unit counts, in the fol-lowing we abuse the notation by using D to represent the vector of unit counts. Therefore, we define D , x  X  R n , Q , W  X  R ( X  ,  X  means define). The query batch Q can be answered directly by:
Q ( D ) , Wx = X
Given a workload matrix W , the worse-case expected squared error of a mechanism M is defined as [12, 14, 17]: where the expectation is taken over the randomness of M . Without information of the underlying dataset, the lowest error achievable by any differentially private mechanism for the query matrix W and database is: where the infimum is taken over all differentially private mecha-nisms. If a mechanism M minimizes the objective value in Eq (1), it is the optimal linear counting query processing mechanism, in the sense that without any prior information of the sensitive data, it achieves the lowest expected error.

Matrix Mechanism. The first solution for answering batch lin-ear aggregate queries under differential privacy is the matrix mech-anism [12]. The main idea is that instead of answering the work-load queries W directly, the mechanism first answers a different set of r queries under differential privacy, and then combine their results to answer W . Let matrix A represent the strategy queries, where each row represent a query and each column represent a u-nit count. Then, according to the Gaussian mechanism, A can be answered using Ax +  X  b under ( , X  ) -differentially privacy, where  X  b denotes an m dimensional Gaussian random variable with scale || A || 2 ,  X  p 2 ln(2 / X  ) / , and k A k p,  X  is the maximum ` mong all column vectors of A . Accordingly, the matrix mechanism answers W by: where A  X  is the Moore-Penrose pseudo-inverse of A .

Based on Eq (2), Li et al. [12] formalize the strategy searching problem for batch linear counting query processing in Eq(1) into the following nonlinear optimization problem:
In the above optimization program, p can be either 1 or 2, and the method in [12] applies to both exact and approximate differen-tial privacy. This optimization program, however is rather difficult to solve. The pseudoinverse of A  X  of A involved in Program (3) is not a continuous function, as it jumps around when A is ill-conditioned. Therefore, A  X  does not have a derivative, and we cannot solve the problem with simple gradient descent. As pointed out in [24], the solutions in [12] are either prohibitively expensive (which needs to iteratively solve a pair of related semidefinite pro-grams that incurs O ( m 3 n 3 ) computational costs), or ineffective (which rarely obtains strategies that outperform naive methods). Low-Rank Mechanism. Yuan et al. [24] propose the Low-Rank Mechanism (LRM), which formulates the batch query problem as the following low-rank matrix factorization problem: where B  X  R m  X  r , L  X  R r  X  n . It can be shown that Program (4) and Program (3) are equivalent to each other; hence, LRM can be viewed as a way to solve the Matrix Mechanism optimization pro-gram (to our knowledge, LRM is also the first practical solution for this program). The LRM formulation avoids the pseudo-inverse of the strategy matrix A ; however, it is still a non-linear, non-convex constrained optimization program. Hence, it is also difficult to solve. The solution in LRM is a sophisticated numeric method based first-order augmented Lagrangian multipliers (ALM). This solution, however, cannot guarantee to find the globally optimal strategy matrix A , due to the non-convex nature of the problem formulation.

Further, the LRM solution may not converge at all. Specifical-ly, it iteratively updates B using the formula: B  X  (  X  WL  X  L T )(  X  LL T + I )  X  1 , where  X  is the penalty parameter. When L is low-rank, according to the rank inequality for matrix multipli-cation, it leads to: rank ( B )  X  rank ( L ) . Therefore, the equality constraint W = BL may never hold since we can never express a full-rank matrix W with the product of two low-rank ones. When this happens, LRM never converges. For this reason, the initial value of L needs to be chosen carefully so that it is not low-rank. However, this problem cannot be completed avoided since during the iterations of LRM, the rank of L may drop. Finally, even in cases where LRM does converge, its convergence rate can be slow, leading to high computational costs as we show in the experiments. In particular, the LRM solution is not necessarily a monotone de-scent algorithm, meaning that the accuracy of its solutions can fluc-tuate during the iterations.

Adaptive Mechanism. In order to alleviate the computational overhead of the matrix mechanism, adaptive mechanism (AM) [13] considers the following optimization program: where Q  X  R m  X  n is from the singular value decomposition of the workload matrix W = QDP with D  X  R n  X  n , P  X  R n  X  n and d = diag ( D )  X  R n , i.e., the diagonal values of D . AM then computes the strategy matrix A by A = Q diag (  X  )  X  R where diag (  X  ) is a diagonal matrix with  X  as its diagonal values.
The main drawback of AM is that it searches over a reduced sub-space of A , since it is limited to a weighted nonnegative combina-tion of the fixed eigen-queries Q . Hence, the candidate strategy matrix A solved from the optimization problem in (5) is not guar-anteed to be the optimal strategy. In fact it is often suboptimal, as shown in the experiments.

Exponential Smoothing Mechanism. Based on a reformula-tion of matrix mechanism, the Exponential Smoothing Mechanism (ESM) [23] considers solving the following optimization program: where max is a function that retrieves the largest element in a vec-tor. This function is hard to compute since it is non-smooth. The authors use the soft max function smax ( v ) =  X  log P n i to smooth this term and employ the non-monotone spectral pro-jected gradient descent for optimizing the non-convex but smooth objective function on a positive definiteness constraint set.
One major problem with this method is that Program (6) in-volves matrix inverse operator, which may cause numerical insta-bility when the final solution (i.e., the strategy matrix) is of low rank. Further, since the problem is not convex, the ESM solution does not guarantee to converge to the global optimum, either.
The proposed solution, presented next, avoids all the drawbacks of previous solutions: it is fast, stable, numerically robust, and most importantly, it guarantees to find the optimal solution.
This section presents the a convex optimization formulation for finding the best strategy for a given workload of linear aggregate queries. The main idea is that instead of solving for the strat-egy matrix A that minimizes result error directly, we first solve the optimal value for X = AA T , and then obtain A accordingly. Note that there can be multiple strategy matrices A from a given X = AA T , in which case we simply output an arbitrary one, since they all lead to the same overall accuracy for the original workload W . As we show soon, the objective function with respect to X is convex; hence, the proposed solution is guaranteed to find the global optimum. The re-formulation of the optimization program involves a non-trivial semi-definite programming lifting technique to remove the quadratic term, presented below.

First of all, based on the non-convex model in Program (3), we have the following lemma 1 .

L EMMA 1 . Given an arbitrary strategy matrix A , we can al-ways construct another strategy A 0 satisfying (i) k A 0 k and (ii) J ( A ) = J ( A 0 ) , where J ( A ) is defined in in Program (3). By Lemma 1 , the following optimization program is equivalent to Program (3).
All proofs can be found in the full version of the paper [22]. This paper focuses on approximate differential privacy where p = 2 . Moreover, we assume that V = W T W is full rank. If this assumption does not hold, we simply transform V into a full rank matrix by adding an identity matrix scaled by  X  , where  X  approach-es zero. Formally, we have: Let X = A T A 0 . Using the fact that ( k A k 2 ,  X  ) 2 = k diag ( X ) k and A  X  A  X  T = X  X  1 , we have the following matrix inverse opti-mization program (note that X and V are both full-rank): Interestingly, using the fact that || X /n || X  tr ( X /n )  X  1 , one can approximate the matrix inverse via Neumann Series 2 and rewrite the objective function in terms of matrix polynomials 3 . Although other convex semi-definite programming reformulations/relaxations exist (discussed in the full version of the paper [22]), we focus on Program (9) and provide convex analysis below.

Convexity of Program (9). Observe that the objective function of Program (9) is not always convex unless some conditions are imposed on V and X . For instance, in the the one-dimensional case, it reduces to the inversely proportional function f ( x ) = with k &gt; 0 . Clearly, f ( x ) is convex on the strictly positive space and concave on the strictly negative space.

The following lemma states the convexity of Program (9) under appropriate conditions.

L EMMA 2 . Assume that X 0 . The function F ( X ) =  X  X  X  1 is convex (resp., strictly convex) if V 0 (resp., V 0 ).
Since V is the covariance matrix of W , V is always positive semidefinite. Therefore, according to the above lemma, the objec-tive function of Program (9) is convex. Furthermore, since V is strictly positive definite, the objective function F ( X ) is actually strictly convex. Therefore, there exists a unique optimal solution for Program (9).

Dual program of Program (9). The following lemma describes the dual program of Program (9).

L EMMA 3 . The dual program of Program (9) is the following: max where y  X  R n is associated with the inequality constraint diag ( X )  X  1 .

Lower and upper bounds for Program (9). Next we establish a lower bound and an upper bound on the objective function of Program (9) for any feasible solution.

L EMMA 4 . For any feasible solution X in Program (9), its ob-jective value is sandwiched as max(2 k W k  X   X  n, k W k 2  X  /n ) +  X   X  F ( X )  X   X  2 ( k W k where  X  = max i k S (: ,i ) k 2 , i  X  [ n ] , and S comes from the SVD decomposition that W = U X S .

The parameter  X   X  0 serves as regularization of the convex prob-lem. When  X  &gt; 0 , we always have V 0 . As can be seen in our subsequent analysis, the assumption that V is strictly positive def-inite is necessary in our algorithm design.

Problem formulation with equality constraints. We next re-formulate Program (9) in the following lemma.
F ( X ) =  X  ( X /n )  X  1 , V /n  X  =  X  P  X  k =0 ( I  X  X /n )
L EMMA 5 . Assume V 0 . The optimization problem in Pro-gram (9) is equivalent to the following optimization program:
Program (10) is much more attractive than Program (9) since the equality constraint is easier to handle than the inequality con-straint. As can be seen in our algorithm design below, this equali-ty constraint can be explicitly enforced with suitable initialization. Hence, in the rest of the paper, we focus on solving Program (10).
First-order and second-order analysis. It is not hard to veri-fy that the first-order and second-order derivatives of the objective function F ( X ) can be expressed as (see page 700 in [1]): Since our method (described soon) is a greedy descent algorithm, we restrict our discussions on the level set X which is defined as: X , { X | F ( X )  X  F ( X 0 ) , and diag ( X ) = 1 , and X 0 } We now analyze bounds for the eigenvalues of the solution in Program (10), as well as bounds for the eigenvalues of the Hessian matrix and the gradient matrix of the objective function in Program (10). The following lemma shows that the eigenvalues of the solu-tion in Program (10) are bounded.

L EMMA 6 . For any X  X  X , there exist some strictly positive constants C 1 and C 2 such that C 1 I X C 2 I where C 1 = ( The next lemma shows the the eigenvalues of the Hessian matrix and the gradient matrix of the objective function in Program (10) are also bounded.

L EMMA 7 . For any X  X  X , there exist some strictly positive constants C 3 ,C 4 ,C 5 and C 6 such that C 3 I H ( X ) C C
A self-concordant function [16] is a function f : R  X  R for ful in the analysis of Newton X  X  method. A self-concordant barrier function is used to develop interior point methods for convex opti-mization.

Self-Concordance Property . The following lemma establishes the self-concordance property of Program (10).
 L EMMA 8 . The objective function  X  F ( X ) = C 2 4 F ( X ) =  X  X  X  1 , V  X  with X  X  X is a standard self-concordant function, where C is a strictly positive constant with C , 6 C 3 2 tr ( V ) The self-concordance plays a crucial role in our algorithm design and convergence analysis. First, self-concordance ensures that the current solution is always in the interior of the constraint set X 0 [16] , which makes it possible for us to design a new Cholesky decomposition-based algorithm that can avoid eigenvalue decom-position 4 . Second, self-concordance controls the rate at which the second derivative of a function changes, and it provides a check-able sufficient condition to ensure that our method converges to the global solution with (local) quadratic convergence rate.
Although Cholesky decomposition and eigenvalue decomposition share the same computational complexity ( O ( n 3 )) for factorizing a positive definite matrix of size n , in practice Cholesky decom-position is often significantly faster than eigenvalue decomposition (e.g. by about 50 times for a square matrix of size n = 5000 ). Algorithm 1 Algorithm COA for Solving Program (10) 3: Initialize k = 0 4: while not converge do 5: Solve the following subproblem by Algorithm 2: 8: (2) there is sufficient decrease in the objective. 11: Increment k by 1 Algorithm 2 A Modified Conjugate Gradient for Finding D as in Program (15) 6: for l = 0 to T do 11: return D
In this section, we provide a Newton-like algorithm COA to solve Program (10). We first show how to find the search direc-tion and the step size in Sections 4.1 and 4.2, respectively. Then we study the convergence property of COA in Section 4.3. Finally, we present a homotopy algorithm to further accelerate the conver-gence. For notational convenience, we use the shorthand notation F k = F ( X k ) , G k = G ( X k ) , H k = H ( X k ) , and D = D ( X to denote the objective value, first-order gradient, hessian matrix and the search direction at the point X k , respectively.
Following the approach of [20, 9, 25], we build a quadratic ap-proximation around any solution X k for the objective function F ( X ) by considering its second-order Taylor expansion: f (  X  ; X k ) = F k +  X   X  , G k  X  + 1 Therefore, the Newton direction D k for the smooth objective func-ton F ( X ) can then be written as the solution of the following e-quality constrained quadratic program: After the direction D k is computed, we employ an Arimijo-rule based step size selection to ensure positive definiteness and suffi-cient descent of the next iterate. We summarize our algorithm COA in Algorithm 1. Note that the initial point X 0 has to be a feasible solution, thus X 0 0 and diag ( X 0 ) = 1 . Moreover, the positive definiteness of all the following iterates X k will be guaranteed by the step size selection procedure (refer to step 7 in Algorithm 1).
This subsection is devoted to finding the search direction in Eq (14). With the choice of X 0 0 and diag ( X 0 ) = 1 , Eq(14) reduces to the following optimization program: min At first glance, Program (15) is challenging. First, this is a con-strained optimization program with n  X  n variables and n equality constraints. Second, the optimization problem involves computing and storing an n 2  X  n 2 Hessian matrix H k , which is a daunting task in algorithm design.

We carefully analyze Problem (15) and propose the following solutions. For the first issue, Eq (15) is actually a unconstrained quadratic program with n  X  ( n  X  1) variable. In order to handle the diagonal variables of  X  , one can explicitly enforce the diag-onal entries of current solution and its gradient to 0 . Therefore, the constraint diag (  X  ) = 0 can always be guaranteed. This im-plies that linear conjugate gradient method can be used to solve Problem (15). For the second issue, we can make good use of the Kronecker product structure of the Hessian matrix. We note that ( A  X  B ) vec ( C ) = vec ( BCA ) ,  X  A , B , C  X  R n  X  n vector vec ( D )  X  R n 2  X  1 , using the fact that the Hessian matrix can be computed as H =  X  G  X  X  X  1  X  X  X  1  X  G , the Hessian-vector product can be computed efficiently as: H vec ( D ) = vec (  X  GDX  X  X  X  1 DG ) , which only involves matrix-matrix computation. Our modified linear conjugate gradient method for finding the search direction is summarized in Algorithm 2. Note that the algorithm involves a parameter T controlling the maximum number of iter-ations. The specific value of T does not affect the correctness of COA, only its efficiency. Through experiments we found that a value of T = 5 usually leads to good overall efficiency of COA.
After the Newton direction D is found, we need to compute a step size  X   X  (0 , 1] that ensures positive definiteness of the next iterate X +  X  D and leads to a sufficient decrease of the objective function. We use Armijo X  X  rule and try step size  X   X  {  X  with a constant decrease rate 0 &lt;  X  &lt; 1 until we find the smallest t  X  N with  X  =  X  t such that X +  X  D is (i) positive definite, and (ii) satisfies the following sufficient decrease condition [20]: where 0 &lt;  X  &lt; 0 . 5 . We choose  X  = 0 . 1 and  X  = 0 . 25 in our experiments.

We verify positive definiteness of the solution while computing its Cholesky factorization (takes 1 3 n 3 flops). We remark that the C-holesky factorization dominates the computational cost in the step-size computations. To reduce the computation cost, we can reuse the Cholesky factor in the previous iteration when evaluating the objective function (that requires the computation of X  X  1 crease condition in Eq (16) has been considered in [20] to ensure that the objective value not only decreases but also decreases by a certain amount  X  k  X   X  G k , D k  X  , where  X  G k , D k  X  measures the op-timality of the current solution.

The following lemma provides some theoretical insights of the line search program. It states that a strictly positive step size can always be achieved in Algorithm 1. This property is crucial in our global convergence analysis of the algorithm.
 L EMMA 9 . There exists a strictly positive constant  X  &lt; min(1 , ,C 8 ) such that the positive definiteness and sufficient descent conditions (in step 7-8 of Algorithm 1) are satisfied. Here C pendent of the current solution X k . The following lemma shows that a full Newton step size will be selected eventually. This is useful for the proof of local quadratic convergence.

L EMMA 10 . If X k is close enough to global optimal solution will be satisfied with step size  X  k = 1 .
First, we provide convergence properties of Algorithm 1. We prove that Algorithm 1 always converges to the global optimum, and then analyze its convergence rate. Our convergence analysis is mainly based on the proximal point gradient method [20, 9] for composite function optimization in the literature. Specifically, we have the following results (proofs appear in the full version [22]):
T HEOREM 1 . Global Convergence of Algorithm 1. Let { X k be sequences generated by Algorithm 1. Then F ( X k ) is nonin-creasing and converges to the global optimal solution.

T HEOREM 2 . Global Linear Convergence Rate of Algorithm 1. Let { X k } be sequences generated by Algorithm 1, Then { X converges linearly to the global optimal solution.

T HEOREM 3 . Local Quadratic Convergence Rate of Algorith-m 1. Let { X k } be sequences generated by Algorithm 1. When X is sufficiently close to the global optimal solution, then { X verges quadratically to the global optimal solution.

It is worth mentioning that Algorithm 1 is the first polynomial al-gorithm for linear query processing under approximate differential privacy with a provable global optimum guarantee.

Next we analyze the time complexity of our algorithm. Assume that COA converges within N coa outer iterations (Algorithm 1) and T coa inner iterations (Algorithm 2). Due to the O ( n 3 ) complexity for Cholesky factorization (where n is the number of unit counts), the total complexity of COA is O ( N coa  X  T coa  X  n 3 ) . Note that the running time of COA is independent of the number of queries m . In contrast, the current state-of-the-art LRM has time complexity O ( N lrm  X  T lrm  X  min( m,n ) 2  X  ( m + n )) (where N lrm number of outer and inner iterations of LRM, respectively), which involves both n and m . Note that ( N coa  X  T coa ) in the big O nota-tion is often much smaller than ( N lrm  X  T lrm ) in practice, due to the quadratic convergence rate of COA. According to our experiments, typically COA converges with N coa  X  10 and T coa  X  5 .
In Algorithm 1, we assume that V is positive definite. If this is not true, one can consider adding a deceasing regularization param-eter to the diagonal entries of V . We present a homotopy algorithm for solving Program (9) with  X  approaching 0 in Algorithm 3.
The homotopy algorithm used in [19, 5] have shown the advan-tages of continuation method in speeding up solving large-scale optimization problems. In continuation method, a sequence of opti-mization problems with deceasing regularization parameter is solved until a sufficiently small value is arrived. The solution of each op-timization is used as the warm start for the next iteration.
In Eq (8), a smaller  X  is always preferred because it results in more accurate approximation of the original optimization in Pro-gram (9). However, it also implies a slower convergence rate, ac-cording to our convergence analysis. Hence the computational cost of our algorithm is high when small  X  is selected. In Algorithm 3, a series of problems with decreasing regularization parameter  X  are solved by using Algorithm 1, and the solution of each run of Algorithm 1 is used as the initial solution X 0 of the next iteration. In this paper, Algorithm 3 starts from a large  X  0 = 1 , and it stops when the preferred  X   X  10  X  10 arrives.
 Algorithm 3 A Homotopy Algorithm for Solving Eq (9) with  X  approaching 0. 1: Input: workload matrix W 2: Output: X 3: Specify the maximum iteration T = 10 5: for i = 0 to T do
This section experimentally evaluates the effectiveness of the proposed convex optimization algorithm COA for linear aggregate processing under approximate differential privacy. We compare COA with six existing methods: Gaussian Mechanism (GM) [15], Wavelet Mechanism (WM) [21], Hierarchical Mechanism (HM) [7], Exponential Smoothing Mechanism (ESM) [23, 12], Adap-tive Mechanism (AM) [13, 12] and Low-Rank Mechanism (LR-M) [23, 24]. Qardaji et al. [18] proposed an improved version of HM by carefully selecting the branching factor. Similar to HM, this method focuses on range processing, and there is no guarantee on result quality for general linear aggregates. A detailed exper-imental comparison with [18] is left as future work. Moreover, we also compare with a recent hybrid data-and workload-aware method [11] which is designed only for range queries and exact d-ifferential privacy. Since a previous study [24] has shown that LRM significantly outperforms MWEM, we do not compare with Expo-nential Mechanism with Multiplicative Weights update (MWEM). Although the batch query processing problem under approximate differential privacy in Program (9) can be reformulated as a stan-dard semi-definite programming problem which can be solved by interior point solvers, we do not compare with it either since such method requires prohibitively high CPU time and memory con-sumption even for one single (Newton) iteration.

For AM, we employ the Python implementation obtained from the authors X  website: http://cs.umass.edu/~chaoli. We use the de-fault stopping criterion provided by the authors. For ESM and LRM, we use the Mablab code provided by the authors: http:// yuanganzhao.weebly.com/. For COA, we implement the algorithm in Matlab (refer to the Appendix in [22]) and only report the results of Algorithm 1 with the parameter  X  = 10  X  3 . We performed al-l experiments on a desktop PC with an Intel quad-core 2.50 GHz CPU and 4GBytes RAM. In each experiment, every algorithm is executed 20 times and the average performance is reported.
Following the experimental settings in [24], we use four real-world data sets ( Search Log , Net Trace , Social Network and UCI Adult ) and fours different types of workloads ( WDiscrete , WRange , WMarginal and WRelated ). In WDiscrete , each entry is a random variable follows the bernoulli distribution; in WRange , each query sums the unit counts in a range whose start and end points are ran-domly generated following the uniform distribution. WMarginal contains queries uniformly sampled from the set of all two-way marginals. For WRelated , we generate workload matrix by low-rank matrix multiplication [24]. Moreover, we measure average squared error and computation time of all the methods. Here the average squared error is the average squared ` 2 distance between the exact query answers and the noisy answers. The privacy pa-rameters are set to = 0 . 1 ,  X  = 0 . 0001 in our experiments for all methods, except for DAWA, which has = 0 . 1 ,  X  = 0 since it answers queries under exact differential privacy.
 Convergence Behavior of COA: Firstly, we verify the conver-gence property of COA using all the datasets on all the workloads. We record the objective value (i.e. the expected error), the opti-mality measure (i.e. k G k k F ) and the test error on four datasets at every iteration k and plot these results in Figure 1.
 We make three important observations from these results. (i) The objective value and optimality measure decrease monotonical-ly. This is because our method is a greedy descent algorithm. (ii) The test errors do not necessarily decrease monotonically but tend to decrease iteratively. This is because we add random gaussian noise to the results and the average squared error is expected to de-crease. (iii) The objective values stabilize after the 10 th iteration, which means that our algorithm has converged, and the decrease of the error is negligible after the 10 th iteration. This implies that one may use a looser stopping criterion without sacrificing accuracy. Impact of Varying Number of Unit Counts: We now evaluate the accuracy performance of all mechanisms with varying domain size n from 64 to 8192, after fixing the number of queries m to 1024. We report the results of all mechanisms on the 4 different work-loads in Figures 2, 3, 4 and 5, respectively. We have the following observations. (i) COA obtains comparable results with LRM, the current state of the art. Part of the reason may be that, the random initialization strategy makes LRM avoid undesirable local minima. In addition, COA and LRM achieve the best performance in all set-tings. Their improvement over the naive GM is over two orders of magnitude, especially when the domain size is large. (ii) WM and HM obtain similar accuracy on WRange and they are comparable to COA and LRM. This is because they are designed for range queries optimization. (iii) AM and ESM have similar accuracy and they are usually strictly worse than COA and LRM. Moreover, the accuracy of AM and ESM is rather unstable on workload WMarginal . For ESM, this instability is caused by numerical errors in the matrix in-verse operation, which can be high when the final solution matrix is low-rank. Finally, AM searches in a reduced subspace for the opti-mal strategy matrix, leading to suboptimal solutions with unstable quality.
 Impact of Varying Number of Queries: In part of the section, we test the impact of varying the query set cardinality m from 32 to 8192 with n fixed to 512. The accuracy results of all mecha-nisms on the 4 different workloads are reported in Figures 6, 7, 8 and 9. We have the following observations. (i) COA and LR-M have similar performance and they consistently outperform all the other methods in all test cases. (ii) On WDiscrete and WRange workloads, AM and ESM show comparable performance, which is much worse performance than COA and LRM. (iii) On WDiscrete , WRange and WRelated workload, WM and HM improve upon the naive Gaussian mechanism; however, on WMarginal , WM and H-M incur higher errors than GM. AM and ESM again exhibit similar performance, which is often better than that of WM, HM, and GM. Impact of Varying Rank of Workload: Past studies [23, 24] show that it is possible to reduce the expected error when the workload matrix has low rank. In this set of experiments, we manually con-trol the rank of workload W to verify this claim. Recall that the parameter s determines the size of the matrix C  X  R m  X  s size of the matrix A  X  R s  X  n during the generation of the WRelated workload. When C and A contain only independent rows/columns, s is exactly the rank of the workload matrix W = CA . In Figure 10, we vary s from 0 . 1  X  min( m,n ) to 1  X  min( m,n ) . We observe that both LRM and COA outperform all other methods by at least one order of magnitude. With increasing s , the performance gap gradually closes. Meanwhile, COA X  X  performance is again compa-rable to LRM.
 Running Time Evaluations: We now demonstrate the efficiency of LRM, ESM and COA for the 4 different types of workloads. Other methods, such as WM and HM, requires negligible time s-ince they are essentially heuristics without complex optimization computations. From our experiments we obtain the following re-sults. (i) In Figure 11, we vary m from 32 to 8192 and fix n to 1024. COA requires the same running time regardless of the num-ber of queries m , whereas the efficiency of LRM deteriorates with increasing m . (ii) In Figure 12, we vary n from 32 to 8192 and fix m to 1024. We observe that COA is more efficient than LRM when n is relatively small (i.e., n &lt; 5000 ). This is mainly because COA converges with much fewer iterations than LRM. Specifically, we found through manual inspection that COA converges within about N coa = 10 outer iterations (refer to Figure 1) and T coa = 5 inner n=1024 on workload WRange. iterations (refer to our Matlab code in the full version [22]). In con-tract, LRM often takes about N lrm = 200 outer iterations and about T lrm = 50 inner iterations to converge. When n is very large (e.g., when n = 8192 ) and m is relatively small (1024), COA may run s-lower than LRM due to the former X  X  cubic runtime complexity with respect to the domain size n . (iii) In Figure 13, we vary n from 32 to 8192 and fix m to a lager value 2048. We observe that COA is much more efficient than LRM for all values of n . This is because the runtime of COA is independent of m while LRM scale quadrat-ically with min( m,n ) , and COA has quadratic local convergence rate. These results are consistent with the convergence rate analysis and complexity analysis in Section 4.3.
 COA v.s. DAWA: DAWA [11] targets very different application-s compared to the proposed solution COA. In particular, DAWA focuses on range processing under exact (i.e., -) differential priva-cy, whereas COA addresses arbitrary linear counting queries under approximate (i.e., ( ,  X  )-) differential privacy. Adapting DAWA to approximate differential privacy is non-trivial, because at the core of DAWA lies a dynamic programming algorithm that is specially designed for ` 1 cost and the Laplace mechanism (refer to Section 3.2 in [11]). Further, DAWA replies on certain assumptions of the underlying data, e.g., adjacent counts are similar in value, whereas COA is data-independent. Hence, their relative performance de-pends on the choice of parameter  X  , as well as the dataset.
We compare COA with different values of  X  ranging from 0.01 to 0.00001 against DAWA on workload WRange , since DAWA focus-es on range queries. For brevity, we only present the experimental result on a real dataset ( Social Network ) and a synthetic one called Random Uniform . Specifically, the sensitive data Random Uniform consists of a random vector x  X  R n drawn from the uniform distri-bution with mean zero and variance 10. Experimental comparisons of COA and DAWA on other datasets can be found in the full ver-sion [22]. Figure 14 shows the results with varying domain size n and the number of queries m . We have the following observations. (i) On the Random Uniform dataset, the performance of DAWA is rather poor, since this synthetic dataset does not satisfy the assump-tion that adjacent aggregates have similar values. (ii) COA gener-ally achieves better performance than DAWA when  X   X  0 . 0001 . (iii) With a fixed number of queries m = 1024 , COA significant-ly outperforms DAWA when n is large. (iv) DAWA outperforms COA only when  X  is very small, and the dataset happens to satisfy its assumptions. In such situations, one potential way to improve COA is to incorporate data-dependent information through a post-processing technique (e.g., [8, 10]), which is outside of the scope of this paper and left as future work.
In this paper we introduce a convex re-formulation for optimiz-ing batch linear aggregate queries under approximate differential privacy. We provide a systematic analysis of the resulting con-vex optimization problem. In order to solve the convex problem, we propose a Newton-like method, which is guaranteed to achieve globally linear convergence rate and locally quadratic convergence rate. Extensive experiment on real world data sets demonstrate that our method is efficient and effective.

There are several interesting directions for future research. First-ly, it is worthwhile to extend the proposed method to develop hy-brid data and workload aware differentially private algorithms [11, 10]. Secondly, it is interesting to investigate convex relaxation-s/reformulations to handle the squared/absolute sum error under d-ifferential privacy.
 We would like to thank Prof. Shaohua Pan (SCUT) for her helpful discussions and the reviewers for their valuable comments. This re-search is partly supported by the research grant for the Human Cen-tered Cyber physical Systems Programme at the Advanced Digital Sciences Center from Singapore X  X  A*STAR. This research is al-so supported in part by Postdoctoral Science Foundation of Chi-na (2015M572317), Fundamental Research Funds for Central U-niversities, NSFC of Guangdong Joint Found (U1501254), NSF of China (61402182, 61472089 and 61572143), NSF of Guangdong (2014A030306004 and 2014A030308008), and Science and Tech-nology Planning Project of Guangdong (2013B051000076, 2015B-010108006 and 2015B010131015). [1] J. Dattorro. Convex Optimization &amp; Euclidean Distance [2] C. Dwork. A firm foundation for private data analysis. [3] C. Dwork, K. Kenthapadi, F. McSherry, I. Mironov, and [4] C. Dwork, F. McSherry, K. Nissim, and A. Smith.
 [5] B. Efron, T. Hastie, I. Johnstone, and R. Tibshirani. Least [6]  X . Erlingsson, V. Pihur, and A. Korolova. Rappor: [7] M. Hay, V. Rastogi, G. Miklau, and D. Suciu. Boosting the [8] J. Lee, Y. Wang, and D. Kifer. Maximum likelihood [9] J. D. Lee, Y. Sun, and M. A. Saunders. Proximal [10] C. Li. Optimizing linear queries under differential privacy. [11] C. Li, M. Hay, G. Miklau, and Y. Wang. A data-and [12] C. Li, M. Hay, V. Rastogi, G. Miklau, and A. McGregor. [13] C. Li and G. Miklau. An adaptive mechanism for accurate [14] C. Li and G. Miklau. Optimal error of query sets under the [15] F. McSherry and I. Mironov. Differentially private [16] Y. Nesterov and A. Nemirovski. Interior-point Polynomial [17] A. Nikolov, K. Talwar, and L. Zhang. The geometry of [18] W. Qardaji, W. Yang, and N. Li. Understanding hierarchical [19] R. Tibshirani. Regression shrinkage and selection via the [20] P. Tseng and S. Yun. A coordinate gradient descent method [21] X. Xiao, G. Wang, and J. Gehrke. Differential privacy via [22] G. Yuan, Y. Yang, Z. Zhang, and Z. Hao. Convex [23] G. Yuan, Z. Zhang, M. Winslett, X. Xiao, Y. Yang, and [24] G. Yuan, Z. Zhang, M. Winslett, X. Xiao, Y. Yang, and [25] S. Yun, P. Tseng, and K. Toh. A block coordinate gradient
