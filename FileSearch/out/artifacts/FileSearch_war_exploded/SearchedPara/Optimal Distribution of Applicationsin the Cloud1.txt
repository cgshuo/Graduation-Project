 The cloud computing paradigm offers a well documented set of benefits to enterprises and individuals with respect to transferring capital to operational expenses, potentially unlimited access to computational resources, and utility-based charging for the use of these resour ces [4]. In this respect, cloud computing offers a platform for innovative information systems that are partially or com-pletely implemented using cloud offer ings. In order however to reap the full benefits of cloud computing, application design and development must move beyond the mere re-packaging of applications in virtual machines (VMs) and offering them as part of Infrastructure as a Service (IaaS) solutions [1]. For ex-ample, novel services like Database as a Service (DBaaS) offerings can be used in designing and realizing new applications, or while migrating and accordingly adapting existing applications for the cloud. Furthermore, when considering the variation of pricing models across cloud providers [22], it becomes possible to select from different cloud offerings, e.g. different configurations of the AWS EC2 service 1 , in order to identify an optimal in terms of operational expenses distribution of the application.

Toward this goal, a number of approaches provide decision support for mi-grating existing applications to the cloud, see for example [2,10,16]. However, these approaches do not consider as part of their process the application topol-ogy , i.e. the combination of application-specific components , middleware solutions like the application server used, and the underlying infrastructure (VMs on ei-ther a local server, or on cloud offerings) hosting both of them and allowing the application to operate. Using the taxonomy proposed in [1], such approaches usu-ally provide support for migration type III, meaning that the whole application stack (components, middleware and OS) is bundled in a VM image and moved to a cloud provider for hosting. In this respect, these approaches are limited in their capabilities when considering the distribution of the application across cloud offerings and/or local, in-house servers.
 On the other hand, initiatives like the TOSCA standard [6], Cloud Blueprints [20] or CloudML [7] allow for a portable and interoperable topo-logical description of the application stack that can be used for the distributed deployment of the application across cloud providers. Using these initiatives, it becomes possible for the application devel oper to explore the application design space and model which cloud offering to use to host which parts of the applica-tion stack. However, what these approaches lack is decision support capabilities towards optimally selecting the best of the identified application topologies in a given situation. This is a deficiency that this work aims to address by bringing together cloud migration decision support with these cloud-aware topology de-scription approaches. The proposed approach does not make any assumptions with respect to the technologies used and as such it is suitable for use in both generic and domain-specific information systems.

The main contribution of this work can therefore be summarized as a technology-agnostic formal framework that provides the means to:  X  Model, verify and automatically generate alternative scenarios for the dis- X  Evaluate each one of these distributio n scenarios with respect to various
The remaining of this paper is structured as follows: the following section (Section 2) discusses a motivating scenario that illustrates the challenges that this work is addressing. Section 3 builds on existing models and languages to provide a formalization of the notion of application topology and affiliated concepts. Section 4 uses this formalization to develop a method for the optimal selection between alternative (acceptable) applic ation topologies, which is demonstrated in practice in Section 5. Related approaches are discussed in Section 6, and the paper concludes in Section 7 by providing also the outline for future work. For purposes of further motivating this work we adapt the Web Shop application topology discussed in [6]. We abstract away from the TOSCA notation used in [6] and represent the topology of the application as the nodes and edges with solid lines in the graph of Fig. 1. The application itself consists of three tiers: front end, back end and persistence as a database. The WebShop Frontend component is developed as a set of PHP files deployed in a PHP container. The container is in turn configured and deployed as an Apach e Web server module, with the server running inside a Windows 2003 Server OS installed on top of an IBM zSeries server. The WebShop Backend component is a Web application packaged in a WAR (Web application ARchive) file running inside an Apache Tomcat servlet container (requiring also the installation of the Oracle Java Virtual Machine (JVM) in the same OS), while the MySQL RDBMS is used as a database server for the ProductDB database. The latter two tiers are deployed in a Windows 7 image provided by the Amazon Web Services (AWS) EC2 service as part of their Reserved Instances offerings 2 .

The application topology in Fig. 1 is already deployed in a distributed manner, in the sense that the components from the different tiers are deployed and oper-ated in different infrastructure solutions, with the front end in a physical server on premises, and the back end and persistence in an IaaS offering. However, the application topology shown in Fig. 1 is only one of the possibilities for distribut-ing the application. As also shown in Fig. 1, and marked with dashed lines in the figure, it is also possible to separate the back end from the persistence tier and deploy them in different EC2 offerings (denoted by the  X  X lt hosted on X  relation-ship), one or both of which could be an Ubuntu Linux OS image. Furthermore, the ProductDB database could also be migrated to the Amazon RDS 3 DBaaS solution, which is compatible with the MySQL RDBMS.

Each one of these topologies has a differe nt impact on essential characteristics of the application such as operational expenses, deployment time, scalability op-portunities, performance, etc. Different pr icing models are used, for example, for IaaS and DBaaS offerings, taking into account different parameters, e.g. num-ber of CPUs per VM in the former case and size of egress traffic per month in the latter. Furthermore, migrating the ProductDB to AWS RDS can be better suited for profiting from some charact eristics offered out of the box by DBaaS offerings, e.g. multi-instance management, high availability, automated scaling, etc., as re-engineering the application t o deal with data consistency issues across database replicas is not required.

There are therefore two major challeng es that this work is addressing: first, how to infer the existence of possible topologies for a given application, and second, how to optimally select amongst these alternative topologies for a given set of characteristics like operational co sts. In the following section we introduce a formal framework that provides us with the fundamentals necessary towards dealing with these challenges. So far we have been using the term  X  X pplication topology X  in a rather informal manner to denote the model for the deployment of the application components in middleware solutions (e.g. the Apache Tomcat container in Fig. 1), and the con-sequent deployment of the resulting software stack in an appropriate infrastruc-ture solution (e.g. the zSeries server, or the EC2 VM offering). Before proceeding further we first formalize this notion: Definition 1 (Application Topology). An application topology is a labeled graph G =( N L ,E L ,s,t ) where N is a set of nodes, E is a set of edges, L aset of labels, and s, t the source and target functions s, t : E L  X  N L .Thetopology graph is called typed ,ifthelabelset L contains only elements &lt; name:type &gt; (for nodes) and &lt; type &gt; (for edges), in which case the graph is denoted by T . Most existing works for cloud-oriented topology description like the TOSCA specification [6], the Cloud Blueprinting approach [20], and the CloudML lan-guage [7], or involving such a description as in, e.g. the MOCCA [13] framework, use this typed topology graph model, in order to provide a concrete description of the application and middleware components and cloud offerings involved under a unified model. Similar approaches are also used by cloud service providers like Amazon with CloudFormation 4 , as well as the OpenNebula initiative 5 or Open-Stack Heat 6 , with a clear orientation towards facilitating and/or automating the deployment, provisioning and management of applications on cloud solu-tions. For this purpose they need a complete and a priori defined description of the application topology that can be distributed across multiple cloud offerings.
However, as discussed in the previous section, this is a limited view of the pos-sibilities available in distributing the application across cloud solutions. Looking at the case of the Web Shop application, it can be observed that there is a con-ceptual distinction between the applic ation components on one hand (denoted with double lines in Fig. 1), and the middleware components like the Apache Web server and the cloud offerings like the AWS EC2 service on the other. More specifically, while the former part is unique and specific for the Web Shop ap-plication, the latter can actually be reused and even shared across multiple applications similar to the Web Shop. In this respect, the typed topology model used by approaches like TOSCA should therefore only be interpreted as one possible instantiation of the application topology. In order to be able to model and explore this possibility space, the notion of a type graph with inheritance as formally defined in [5] and [12] can be used: Definition 2 (Type Graph with Inheritance, following [5]). A type graph with inheritance TG I is a triple ( TG,I,A ) consisting of a type graph TG = ( N,E,s,t ) (with a set of nodes N ,asetofedges E and a target function s, t : E  X  N ), an inheritance graph I sharing the same set of nodes N ,andaset N
A  X  N , called abstract nodes. For each node n  X  I the inheritance clan relation is defined by clan ( n ) I = { n  X  N | X  path n  X   X  X  X  n  X  I } where n  X  clan ( n ) I (i.e. the path of length 0 is included).
 TG I is therefore a graph where the nodes and edges are types, and where edges denoting the inheritance/subtype relation type, as in UML class diagrams, is allowed between nodes. Bardohl et al. use the concept of abstract nodes in [5] for types that have only inheritance relations with other nodes, meant to denote generic classes of nodes like e.g. Web Server. Using the clan morphism relation clan ( n ) I allows for navigating the inheritance-type edges in TG I graphs, which is instrumental in producing typed graphs. In this respect, thinking of the applica-tion topological description as a graph morphism over TG I produces potentially multiple typed topology graphs depending on the availability of sibling nodes in inheritance relations with abstract nodes (e.g.  X  X pache HTTP Server X  and  X  X BM WebSphere X  for the  X  X eb Server X  node). The concept of viable topology builds on this capability: Definition 3 (Viable Topology). Atypedtopology T is viable w.r.t. a type graph with inheritance TG I , iff all elements of T are labeled (typed) over the elements of TG I , i.e. there exists a graph morphism m : TG I  X  T which uses the inheritance clan relation. Based on this definition, the topology of the Web Shop application of Fig. 1 can therefore be classified as viable under the TG I graph of Fig. 2. In addition to including the same types as the typed topology of Fig. 1 connected through edge types inheritance,  X  X onsists of X  and  X  X osted on X , the TG I also incorporates types like  X  X inux OS X  as a subtype of the  X  X S X  node that were not included in Fig. 1 (marked with dashed lines in Fig. 2). There are two ways to look at the morphism m that translates TG I to T : top-down , with T being generated or validated against TG I ,and bottom-up , with TG I being abstracted from one particular typed topology T and potentially being reused across different viable topologies. In order to facilitate the discussion, the following terms are being introduced: Definition 4 (  X ,  X  and  X  -topology). The type graph with inheritance TG I for a viable application topology T is called its  X  -topology .Wedenoteby  X  -topology the application-specific sub-graph of a  X  -topology, and by  X  -topology the non application-specific (and therefore reusable) sub-graph of a  X  -topology. In the  X  -topology of Fig. 2, for example, the upper nodes (above the dotted line) belong to the  X  -topology of the Web Shop application, while the lower nodes (below the line) belong to its  X  -topology. The distinction between  X  -and  X  -topology is purely functional in nature, and the border between them can be moved dynamically per application to accommodate the application needs. For example, if the Web Shop front-end component requires exclusively a Windows 2003 Server OS due to the way that it was implemented, then the whole subgraph under it can be moved to the  X  -topology of the application to reflect this fact. Alternatively, all the necessary components for the front end (PHP container, Web server and OS) can be bundled together with the Web Shop front end component, in which case the  X  X ebShop Frontend X  node in the graph of Fig. 2 can be replaced by an equivalent  X  X ebShop FrontendBundle X  (in the  X  -topology) that is connected directly with the  X  X hysical Server X  node with a  X  X osted on X  relation. In this manner, resource requirements as explicit constraints on the possible topologies, as discussed in both [6] and [20], can be specified.
Finally, a set of viable topologies V for an application can be generated given the  X  -topology of the application and a generic  X  -topology that can even be standardized in a domain or enterprise by merging the two graphs using the inheritance relationship. Using the resulting  X  -topology, a set of viable topolo-giescanthenbeinferredfromthe  X  -topology by applying different morphisms m ( i ) : TG I  X  T ( i ) ,i  X  1 to it, resulting in different topologies T ( i )  X  X  .We assume without loss of generality that there always exists a viable topology for an application, i.e. |V|  X  1. In the following sections we only consider viable topologies in the discussion, unless explicitly stated otherwise. The introduction of  X  -topologies provides us the tools to deal with the first of the challenges identified in Section 2, i.e. i nferring the existence of possible (vi-able) topologies for an application. The richer in terms of available types the  X  -topology used is, the bigger the size of the viable topologies set V for the application. In the following we build on the introduced formalisms in order to address the second identified challenge, i.e. optimal w.r.t. a given set of dimen-sions selection among these possible topologies for a given set of parameters, in a formal manner.

For this purpose, we first introduce (a set of) utility functions as the means to quantitatively evaluate a topology along one or more dimensions, and then we formulate the optimal topology selection problem in order to identify the steps involved in solving it. 4.1 Optimization Utility Function Let X  X  assume a set of functions F on the domain of real numbers R of the form F = { f ( a 1 ,...,a n ) | n  X  1 ,f : R  X   X  R } , and a mapping function f map from each topology in the set of all viable topologies for all applications V to this set f map : V  X  F .Wethendenoteby u ( i )  X  F the function u ( i ) ( a 1 ,...,a n )= f Providing concrete values P ( i ) =( p 1 ,...,p n ) for the arguments A ( i ) allows for Function u ( i ) is essentially the utility function for the topology T ( i ) ,inthe sense that it evaluates the dimension on which the optimization takes place by providing a mapping from the set V to R asshowninFig.3,where r ( i ) = purposes of simplifying the discussion we assume that functions u ( i ) are by defi-nition monotonic.

Different utility functions can be defined for the same topology depending on whichdimensionistakenunder consideration.Furthermore,theconcretedefinition of each utility function depends on the types of the nodes in the  X  -topology of the application. For example, for the initial topology T (1) of the Web Shop application in Fig. 1 the operational expenses of the application are decomposed into the ex-penses opex zSeries of operating the IBM zSeries server hosting the Web Shop front end for a time period of  X  months, and into the cost opex EC 2 m 1 .large of using the AWS  X  X C2 m1.large X  offering for the same time period. For the former, opex zSeries can be calculated using a method like the one discussed by Walker in [23] as the product of the electricity cost, power cons umption for operation and cooling, server utilization and number of hours of operation. Assuming that utilization z is stable over time we can simplify the formula as: where k e is the cost of electricity per hour of operation and h  X  the total hours of op-eration in  X  . For the latter, as discussed in [2], the cost calculation function can be inferredbythe(publiclyavailable)pricing policiesineachcloudprovider X  X Website. In particular for the  X  X C2 m1.large X  Rese rved Instances offering in the European Region using Linux, operational expenses (in US dollars) can be written analyti-2013 7 : where h  X  ,asinthecaseof opex zSeries , is the total amount of hours that the offering has been used in period  X  ,and k initial ,k perHour the initial cost for the reservation of instances and the cost of th e offering per hour of use, respectively.
Assuming that the application owner has a fixed budget k max that is allowed to spend on operational expenses, it follows from Equations 1 and 2 that
The utility function u ( i ) and arguments set A ( i ) for each topology in V can be defined in a similar fashion. In principle, if utility (and therefore optimization of the distribution) considers more than o ne dimensions, e.g. cost and deployment time, then it can be written as a weighted and normalized sum of functions. How-ever for the purposes of this work, we rest rict the discussion to single-dimension optimization and leave the multiple dimension problem for future work. 4.2 Optimal Topology Selection Following from the above, optimizing the distribution of an application for a given set of parameters (values) P , which constitutes the application profile , can therefore be viewed as the (partial) ordering of the set V of the viable topologies for the application based on the evaluation of their utility functions for (potentially a subset of) P .

More specifically, starting from the partial ordering and given the assumption that the utility functions u ( i ) are monotonic in nature, then ordering the evaluation of these functions allows for the ordering of the viable topologies, e.g. and without loss of generality:
Given therefore an application profile P and by identifying the appropriate utility functions in the set U X  F for the set of viable topologies V ,theoptimal distribution of the application can be selected by Equation 3. V can be first trimmed down to a smaller size (which would allow for better performance given the number of evaluations and comparisons required) by applying a set of filter with condition( j ),1  X  j  X  k written as logical formulas e.g. Apache Tomcat  X  T ( i ) to denote whether an Apache Tomcat typed node appears in T ( i ) .
In terms of automating this process, optimally distributing an application across cloud offerings with respect to one or more dimensions (e.g. operational expenses) and for a set of predefined constraints C (e.g. the data layer of the application must remain on premises) can be decomposed into the following steps: 1. If no  X  -topology is available, then construct and merge the  X  -topology of the 2. Generate the set of viable topologies V from the  X  -topology by traversing 3. Prune down V by iteratively applying the filter functions sigma ( j ) for each 4. For each viable topology T ( i ) remaining in V , identify the utility function 5. Construct the set of parameter values P = |V| i P ( i ) ,  X  u ( i )  X  X  . 7. Select the topology corresponding to the value max { r ( i ) | 1  X  i  X |V|} .
In the following section we demonstrate how these steps can be applied in practice for the Web Shop application presented in Section 2 in order to optimize the distribution of the application in terms of operational expenses and with a set of architectural constraints. The evaluation of our methodology presented in this work is based on the Web Shop application described in Section 2. More specifically, as discussed in the previous sections, Fig. 2 outlines some of the alternative viable topologies for the application, such as hosting the database on AWS RDS instead of a virtual machine, and so on. In the following we show how the proposed method can be used to optimize the distribution of the application w.r.t. operational expenses. For evaluation purposes we came up with a synthetic application profile P for the Web Shop application to be used in the fifth step of the optimization process discussed in the previous section. This profile, shown in Table 1, ensures that alternative viable topologies hosted on different Cloud providers are comparable. Furthermore, for reasons of completeness we also considered similar offerings to AWS EC2 and RDS provided by Windows Azure and Rackspace that we do not show explicitly in Fig. 2 but nevertheless include in the following discussion.
In terms of the proposed method, Fig. 2 already illustrates a  X  -topology for the application containing offerings from only one cloud provider (AWS). Traversing the graph in the figure and generating viable topologies follows from the use of inheritance clan relation in the choice of e.g. Linux instead of Windows for the back end of the application. In order to limit the search space we define the con-T ( i ) : WebShop FrontEnd  X   X  X  X  IBM zSeries , i.e. the application front end must be deployed on an IBM zSeries server, and c provider =( AWS EC 2  X  T cloud offerings only from one provider at a time are allowed to avoid latency between providers. The remaining viable topologies in V after applying the filter functions  X  front  X   X  provider for the offerings of the three cloud providers (AWS, Azure and Rackspace) are depicted in Table 2. For example, T (1) is the initial topology, T (2) is its variation that uses two smaller Amazon EC2 m1.medium instances, both with a different operating system, for a separate deployment of the Web Shop X  X  back end and persistence tiers, etc.

The equivalent provider offerings that can be used, and the monetary cost projected for each T ( i ) for the application profile P is calculated by utilizing the Nefolog system [24]. For a given application usage profile and time inter-val, Nefolog provides cloud offerings matching and cost estimation capabilities as RESTful services. For the given application profile and viable topologies, we first used the Offerings Matcher service to identify a set of offerings from the two additional to AWS providers (Windows Azure and Rackspace) that are equiva-lent to the AWS offerings used in Fig. 1. We then invoked the Cost Calculator service for each of the identified offerings , and the results of the service invoca-tion was stored in an N  X  M matrix, where N is the Cost Calculator operation query parameters (using the application profile in Table 1) and M the projected cost of each Cloud offering for each T ( i ) topology. The total cost of operational expenses opex ( i ) for each T ( i ) with application profile parameters from Table 1 is shown in Table 2.

By denoting with opex max the maximum calculated cost ($154,134 for a Win-dows server and database solution in Rackspace for 15 months of use), choosing for utility function (so that the utility function is monotonically decreasing with the cost) and by using the application profile in Table 1 it can be seen that: From this it can therefore be concluded that for the given application profile, the optimal w.r.t. operational expenses distribution of the Web Shop application is represented by the viable topology T (4) , i.e. using a single Windows Azure VM to host both the back end and persistence tier of the application. Looking only at topologies that are deployed on AWS offerings, it can also be seen that it is cheaper to distribute the application back end and persistence tier across two smaller VMs instead of a larger one. It is obvious from the above that elasticity is not considered in these results. Adding to the application profile the use of multiple VMs to cope with variation in demand would potentially result in a different ordering of the topologies. However, adding this capability to the presented framework is at this point in time future work. As discussed in the introductory section, decision support-oriented approaches like Kingfisher [21], CloudGenius [16], CloudAdoption [10] and MDSS [2] focus on assisting application designers in migrating their applications to the cloud. The main focus of these works is on optimal cloud offering selection for a given application that is essentially treated as a monolithic artifact. These approaches are therefore limited in their usefulness in light of multiple potential application topologies considering the distribution of the application across offerings.
The Cloud Blueprinting approach [19,20] defines a blueprint as an abstract description of cloud service offerings that facilitates the selection, customiza-tion and composition of cloud services into service-based applications. Blueprint templates allow the application developers to define the requirements of the ap-plication in terms of functional capabilities, QoS characteristics, and deployment and provisioning resources as target bluepr ints. In this respect, target blueprints are equivalent to  X  -topologies. However, the blueprinting approach is geared to-wards matching requirements with available solutions in a repository, having no equivalent concept to  X  -topology, and lacking therefore the ability to generate viable topologies for an application.

The proposed approach shares a similarity with other existing works, inthe sense that they use application topologies to optimize for a set of dimensions usually involving operational expenses. For example, the work in [18] presents DADL, a language to describe the architecture, behavior and needs of a distributed applica-tion to be deployed on the cloud, as well as describing available cloud offerings for matching purposes. Similarly, in [3], the authors proposean approachthat matches and dynamically adapts the allocation of infrastructure resources to an application topology in order to ensure SLAs. CloudMig [8] is another approach that builds on an initial topology ofthe application thatis adapted through model transformation in order to optimize the distribution of the application across cloud offerings. The optimization in this case also focuses on SLA compliance in a trade-off relation to operational expenses. The approach in [17] uses a Palladio-basedapplication topol-ogy model in order to distribute an application across different cloud providersaim-ing at optimizing for availability and operational expenses.

Nevertheless, all of the above approaches assume that the application topology is already known (and fixed), and are restricted to VM-based IaaS solutions. Our approach takes into account also non-VM cloud offerings like DBaaS offerings, and allows for the dynamic generation of a cceptable application topologies, which may also include alternative application stacks based on the richness of the  X  -topology of the application. This observation also applies to the most relevant for our proposal work, the MOCCA framework [13] which also discusses the optimization of the application to cloud offerings based on introducing variability points in the application topology.

In terms of non-cloud scenarios, optimization of the application distribution has been discussed as part of various approaches like [11,14] and [15]. These approaches focus on performance engineering that is not discussed in the scope of this work, and in this sense they can be useful in extending the current work. However, it is necessary to evaluate first to which extend their underlying appli-cation topology models can be leveraged for cloud applications. The previous sections motivated the need for moving away from the practice of thinking of applications as monolithic stacks to be deployed in one VM, either in the cloud or in in-house servers. Multi-tiered applications in particular can be seen as an aggregation of application-specific components, middleware solutions supporting these components, and of the underlying infrastructure in which they are being deployed and provisioned. The availability of cloud offerings beyond the VM-oriented IaaS solutions, and the proliferation of cloud services competing for market share create both opportunities and challenges for application engineers. Optimizing the distribution of an application across potentially multiple cloud offerings is therefore an important requirement for reaping the benefits of the cloud computing paradigm.

Toward this goal, in this work we proposed a theoretical framework that sup-ports decision making in identifying the optimal application distribution. For this purpose we approached application topology models as typed graphs and leveraged existing work on introducing inheritance relationships between nodes in them. Using the concept of type graph with inheritance we introduced the concept of  X  -topologies as an abstraction over two distincts parts of an appli-cation topology:  X  -topology, the application specific aspect of the model, and  X  -topology, being reusable across different applications. We then showed how  X  -topologies can be used to generate viable topologies as alternative deployment scenarios for the application, taking in to account different types of cloud of-ferings. Based on this foundation we then proposed a generic definition of the optimization distribution problem as a mapping from the application topology domain to the set of real numbers, which allows for the (partial) ordering of alternative solutions and therefore simplifies the optimization.

One clear deficiency of the proposed approach is the ability to scale with the number of nodes in the  X  -topology. Rich  X  -topologies are of course necessary in order to be able to generate as many alternative solutions as possible, but the richer the  X  -topology used is, the larger the s pace that needs to be searched through. Realizing the topology generation and selection algorithm discussed in Section 4.2, evaluating its complexity for real-world examples and dealing with potential scalability problems is in our immediate future plans.

For purposes of illustrative examples and evaluation throughout this work the focus was on operational expenses, and showing how the most cost-efficient application topology can be identified. Beyond offering the opportunity for con-crete examples and easily verifiable results with publicly available information, this choice was also based on what is perceived to have driven the growth of cloud computing, i.e. cost reduction due to economies of scale on the provider side. However, the presented framework is not limited to optimization for op-erational expenses. As discussed in the previous section, there are a number of available performance engineering approaches that can be used to extend this work, e.g. [11,14,15]. To this goal, investigating the role of the workload of the application as reflected in its distribution across (topological) nodes is of interest for future work, as well as the effect of network latency between cloud offerings of the same and different providers (see also the discussion in [1] building on [9]). Finally, evaluating the impact of different scalability strategies, expanding on works like [21,22], is as mentioned in Section 5 an example of an additional optimization dimension to be introduced in future work.
 Acknowledgment. This work is partially funded by the FP7 EU-FET project 600792 ALLOW Ensembles.

