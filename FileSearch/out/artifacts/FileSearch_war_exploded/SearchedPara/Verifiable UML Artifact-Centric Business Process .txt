 Artifact-centric business process models have gained increas-ing momentum recently due to their ability to combine struc-tural (i.e., data related) with dynamical (i.e., process re-lated) aspects. In particular, two main lines of research have been pursued so far: one tailored to business artifact mod-eling languages and methodologies, the other focused on the foundations for their formal verification. In this paper, we merge these two lines of research, by showing how recent the-oretical decidability results for verification can be fruitfully transferred to a concrete UML-based modeling methodology. In particular, we identify additional steps in the methodol-ogy that, in significant cases, guarantee the possibility of verifying the resulting models against rich first-order tem-poral properties. Notably, our results can be seamlessly transferred to different languages for the specification of the artifact lifecycles.
 D.2.4 [ Software Engineering ]: Software/Program Verifi-cation X  formal methods ; H.2.1 [ Database Management ]: Logical Design X  Data models Business artifacts, formal verification, UML, BPM
A business process consists of several activities performed in coordination in order to achieve a business goal [22]. Since business processes are key to achieving an organization X  X  goals, they should be free of errors and performed in an optimal way.

Traditional approaches to business process modeling have been based on a process -or activity -centric perspective, that is, they have tended to focus on the ordering of the activities that need to be carried out, underspecifying or ignoring the data needed by the process.

An alternative to activity-centric process modeling is the artifact -centric (or data -centric) approach. Artifact-centric process models represent both structural (i.e. the data) and dynamic (i.e. the activities or tasks) dimensions of the pro-cess. For this reason, they have grown in importance in re-cent years. One of the research lines in this topic is focused on finding the best way of representing artifact-centric pro-cess models. Several graphical alternatives have been pro-posed, such as Guard-Stage-Milestone (GSM) models [15], BPMN with data [18], PHILharmonic Flows [17] or a com-bination of UML and OCL [9], to mention a few examples.
Despite this variety, it is important to guarantee the cor-rectness of these models. In order to do so, a second line of research has focused on the foundations for the formal verification of artifact-centric business process models. The greatest part of these works represent the business process using models grounded on logic, such as Data-centric Dy-namic Systems (DCDS) [1, 2, 5]. However, the problem with these models grounded on logic is that they are not practi-cal at the business level as they are complex and difficult to understand by the domain experts.

In this paper, we merge these two lines of research, by showing how recent theoretical decidability results for verifi-cation can be fruitfully transferred to a concrete UML-based modeling methodology. In particular, we identify sufficient conditions over the models used by this methodology which guarantee decidabilty of verification. We also show how de-cidability of verification can be achieved when one of such conditions is not fulfilled. These results represent a signifi-cant step forward in the area since, to our knowledge, this is the first time that conditions for decidability are stated on models understandable by model experts, which are speci-fied at a high level of abstraction.

As an aside result of our work, we identify a particular class of models, called shared instances , characterized by the fact that there are two (or more) artifacts which share a read-only object. In this particular case, decidability is achieved by limiting the number of static objects with which an artifact can be related, by ensuring that all queries are navigational starting from the artifact and by imposing that no path of associations among two classes is navigated back and forth. Under these conditions, we can achieve decidabil-ity of verification without having to restrict reasoning over a bounded number of artifacts. More importantly, these re-sults are not only applicable to our UML and OCL models, but can be extended to other languages for artifact-centric process models that fulfill the same conditions.
The rest of the paper is structured as follows. Section 2 i ntroduces our framework. Section 3 presents our example, over which we will show the decidability conditions. Section 4 reports the decidability results. Finally, Sections 5 and 6 review the related work and present our conclusion.
For space reasons, only selected proofs appear in the pa-per. Full proofs are available in a technical report [6].
To facilitate the analysis of artifact-centric business pro-cess models, we base our work on the BALSA framework [14]. It establishes four different dimensions that should be present in any artifact-centric business process model:  X  Business Artifacts: Business artifacts represent the data that the business requires to achieve its goals. They have an identifier and may be related to other business arti-facts. One way of representing business artifacts is by using an entity-relationship model or a UML class diagram. Both diagrams are able to represent the business artifacts, their relationships and establish constraints on both.  X  Lifecycles: Lifecycles are used to represent the evolution of an artifact during its life, from the moment it is created until it is destroyed. Intuitively, they can be graphically rep-resented by means of statecharts or state machine diagrams.  X  Services: Services are atomic units of work in the busi-ness process. They are in charge of evolving the process. As such, they make changes to artifacts by creating, updat-ing and deleting them. They may be represented in different ways: alternatives range from using natural language to logic or with operation contracts specified in OCL.  X  Associations: Associations establish restrictions on the way services may change artifacts, that is, they impose con-straints on services. They may be represented using a proce-dural representation, such as a workflow or BPMN, or using a declarative representation, such as condition-action rules. In contrast to artifacts, whose evolution we wish to track, in many instances, businesses need to keep data in the system that does not really evolve. In order to distinguish this data from artifacts, we will refer to it as objects .

In this paper, we adopt the instantiation of BALSA in [9, 10], representing the aforementioned dimensions using UML [16] and OCL [20]. Both UML and OCL are stan-dard languages generally used for, but not limited to, con-ceptual modeling. In particular, we use: UML class di-agrams for artifact, object, and relationship types; UML state machine diagrams for artifact lifecycles; UML activity diagrams for associations, and OCL operation contracts for services. We call this concrete modelling approach BALSA UML (BAUML for short). However, this does not restrict our result to this subset of diagrams: the results are extend-able to the rest of alternatives.

Technically, we define a BAUML model B as a tuple hM , O , S , Pi , where:  X  M is a UML class diagram, in which some classes repre-sent (business) artifacts. Given two classes A and B , we say that A is a B , written A  X  M B , if A = B or A is a direct or indirect subclass of B in M . Furthermore, given a class A and a (binary) association R in M , we write A = M  X  R ( A = M  X  R  X  resp.) if A is the domain of R (image of R resp.) according to M . We also denote by R | 1 and R | 2 the role names attached to the domain and image classes of R . We denote the set of artifacts in M as artifacts ( M ) and, when convenient, we use artifacts ( B ) interchangeably. Each ar-tifact is the top class of a hierarchy whose leaves are sub-classes with a dynamic behavior (their instances change from one subclass to another). Each subclass represents a specific state in which an artifact instance can be at a certain mo-ment in time. We denote by a-classes ( M ) ( a-classes ( B ) resp.) the set of such subclasses, including the artifacts themselves. Given a class S  X  a-classes ( M ), we denote by art S the class S itself if S is an artifact, or the class A if A is an artifact and S is a possibly indirect subclass of A . Given an artifact A  X  artifacts ( M ), we denote by a-states ( A ) the set of leaves in the hierarchy with top class A .  X  O is a set of OCL constraints over M .  X  S is a set of UML state transition diagrams, one per artifact in artifacts ( M ). In particular, for each artifact A  X  artifacts ( M ), S contains a state transition diagram S
A = h V, v 0 , E, T i , where V is a set of states, v 0  X  V is the initial state, E is a set of events, and T  X  V  X  E  X  OCL M is a set of transitions between pairs of states, each labelled by an event in E and by an OCL condition over M . In particular, the states V of S A exactly mirror the classes in a-states ( A ), so that S A encodes the allowed event-driven transitions of an artifact instance of type A from the current state to a new subclass (i.e., a new artifact state). More-over, the initial transitions leading to v 0 always result in the creation of an instance of the artifact being specified by S  X  P is a set of UML activity diagrams, such that for every transition diagram h V, v 0 , E, T i  X  S , and for every event  X   X  E , there exists one and only one activity diagram P  X  P . With a slight abuse of notation, given a state transition diagram S  X  S , we denote by P S  X  P the set of activity diagrams referring to all events appearing in S .
 In this paper, we will not impose any restriction on the control-flow structure of such activity diagrams, but only on their atomic tasks and conditions. For this reason, given an artifact A  X  artifacts ( M ), we respectively de-note by tasks ( A ) and conditions ( A ) the set of atomic tasks and conditions appearing in the state transition diagram S , also considering all activity diagrams related to S A . We then define tasks ( B ) = S A  X  artifacts ( M ) tasks ( A ) and over, we assume that every task in tasks ( A ) that does not belong to the activity diagram of an initial transition takes in input an instance of the artifact type in S a and that every condition in conditions ( A ) is in the scope of such artifact.
In BAUML, conditions are expressed as OCL queries over the UML class diagram M . Similarly, each (atomic) task is associated to a so-called operation contract , which expresses a precondition on the executability of the task, and a post-condition describing the effect of the task, both formalized in terms of OCL queries over M . The semantics of the op-eration contract is that the task can only be executed when the current information base satisfies its precondition, and that, once executed, the task brings the information base to a new state that satisfies the task postcondition. In this light, tasks represent services in the terminology of BALSA.
We present a relevant example based on a system for a company that registers orders from customers, and stores information about the orders made by the company to its suppliers. Our example is likely to specify a simplified ver-sion of the artifact-centric process models of an online shop like Amazon. We use a set of UML diagrams and OCL operation contracts to represent the example in a modeler-friendly way according to the BALSA framework.

Figure 1 shows the class diagram that represents the busi-ness artifacts and classes of our example. Artifacts are char-acterized by having several substates, represented as sub-classes, with a disjointness constraint. This constraint is necessary to ensure that each artifact evolves correctly. In addition, artifacts have a lifecycle, in our case represented as a UML state machine.

Logically, business artifacts, objects and associations to which they participate are created, updated, and destroyed by executing different services or tasks. However, we as-sume that some classes/associations are read-only , i.e., their extension is not changed by the processes. This is the case, e.g., for ItemType in our example. Figure 1 shows two busi-ness artifacts: Order and SupplierRequest . Order has two substates: RequestedOrder and SentOrder , that track the order X  X  evolution. A RequestedOrder is related to various ItemType s, indicating the products that the customer wishes to purchase. On the other hand, SentOrder is related to Item s, which have a certain ItemType . That is, SentOrder s are directly related to specific items identified by their se-rial number. Notice that apart from the artifact itself, the associations makes , has , and buys in which it takes part, are also created and deleted by the process.

Similarly, SupplierRequest represents the requests made to the supplier. It has two possible substates: PlacedSup-pRequest and ReceivedSuppRequest , and it is related to ItemType , the association class that results from this rela-tionship states information about the quantity of items of a certain type that have been requested to the supplier.
We call the artifact structure in this example shared in-stances by two artifacts ( shared instances for short), because multiple artifacts (even of a different type) can be associated to the same object. While an object might be related to an arbitrary number of artifact instances, the opposite does not hold, i.e., we naturally model an upper bound on the num-ber of objects to which an artifact instance is related, so as to control the amount of information attached to the same artifact instance (e.g., consider the cardinalities of the buys association in Figure 1).

Both artifacts Order and SupplierRequest evolve inde-pendently from each other, with a lifecycle specified by the state machines of Figure 2. Their meaning is very intuitive. In the case of Order , when event Order Products takes place, the RequestedOrder is created. When we have a requested order and event Send Order executes, the order is sent to the customer and the artifact changes its state to SentOrder . Figure 3: Activity diagrams for the events of O rder The state machine diagram for SupplierRequest is analo-gous to that of Order .

Each of the events in the lifecycle transitions ( Order Prod-ucts , Send Order , Order Products at Supplier and Receive Supplier Order ) are further defined using an activity dia-gram, which shows the units of work (i.e., the tasks) that are carried out, together with their execution order. Figure 3 shows the activity diagrams for the events of Order . As for the Order Products event, the first task creates a new order, and the second task, which can be executed many times, adds an item type to the order that has been previously created. As for the Send Order event, the task adds the items to the order, marking it as sent.

Each activity diagram only gives an intuitive idea of what each task does. In order to specify tasks formally, we use OCL operation contracts, each of which has a precondition and a postcondition. Below we show the OCL operation contracts for the tasks in Figure 3. CreateNewCustomerOrder receives as input the neces-sary parameters to create a new instance of the artifact RequestedOrder . Its precondition makes sure that no other order with the same identifier exists. It returns the RequestedOrder that has been created with the input parameters. This is an example of the kind of operation that is used to create new artifact instances, and that is typically associated to transitions leading to the initial artifact state ( Order Products in this example). AddItemType adds an ItemType to the order that has been created in the previous operation. Its precondition checks that the item type has not been already added to the order, and the postcondition creates the relationship between the given order and the right item type.
Notice that we assume that the artifact instance that is re turned by the first operation, CreateNewCustomerOrder , is reused in the following operations. This assumption is necessary to ensure that we are always dealing with the same artifact instance. AssignItemsToOrder checks whether for the given Requeste-dOrder o it is the case that there are available items (i.e., that have not been assigned to a SentOrder ) for each of the requested item types. If so, o becomes a SentOrder that is associated to an available item for each of the requested item types.

These operation contracts show that the only elements that are created are the artifact itself and its relationships to other objects. Notice again that class ItemType , which is shared by Order and SupplierRequest , is never modified by the tasks, and is in fact read-only. Moreover, all the actions that are not attached to the initial transition take as input an instance of the artifact type whose evolution is being modelled in the corresponding state machine, as required by our methodology. Notice that the navigation of all the OCL expressions in the pre and postconditions starts from the instance of the artifact flowing in the state transition diagram: an Order (or one of its subclasses) in our example.
Given a BAUML model, it is interesting to check that it fulfills desired properties that ensure its correctness, such as the artifact termination property: once an artifact instance is created, it should eventually evolve to a terminal state. This is addressed in the next section.
The purpose of this section is to carefully analyze the interaction between the dynamic and static component of BAUML models, so as to single out the various sources of undecidability when it comes to their verification. We show in particular that all the restrictions we introduce towards decidability of verification are in fact required: by relaxing just one of them, verification becomes again undecidable.
To specify temporal properties over BAUML models, we adopt the logic  X  L p , a variant of first-order  X  -calculus that has been recently introduced to specify requirements about the evolution of data-aware processes, jointly considering the temporal dimension as well as the data maintained in the different system states [1]. We recap here the main aspects of  X  L p [1], contextualizing it to the case of BAUML models. Given a BAUML model B , the logic  X  L p is defined as: where Q is a possibly open FO query, Z is a second order predicate variable, and the following assumption holds: in live ( ~x )  X h X  X   X  and live ( ~x )  X  [  X  ] X , the variables ~x are exactly the free variables of  X , once we substitute to each bounded predicate variable Z in  X  its bounding formula  X Z.  X   X  [1]. This requirement expresses that  X  L p quantifies only over those objects/artifacts that persist in the system, i.e., con-tinue to stay in the active domain of the system.

We make use of the following abbreviations:  X   X  1  X   X  2 =  X  (  X   X  1  X   X   X  2 ),  X  [  X  ] X  =  X h X  X  X   X ,  X   X Z.  X  =  X   X Z.  X   X [ Z/  X  Z ],  X   X  x. A ( x )  X   X  =  X  (  X  x. A ( x )  X   X   X ),  X  live ( ~x )  X  h X  X   X  =  X  ( live ( ~x )  X  [  X  ]  X   X ),  X  live ( ~x )  X  [  X  ] X  =  X  ( live ( ~x )  X  h X  X  X   X ). The last two abbreviations show that  X  L p allows one to  X  X ontrol X  what happens when quantification ranges over a value that disappears from the current active domain: in the  X  case the property trivializes to true , in the  X  case it trivializes to false .

Among the properties of interest for BAUML models, we consider in particular the fundamental requirement of ar-tifact termination . Intuitively, this property states that in all possible evolutions of the system, whenever an artifact instance of a certain type is present in the system, it must persist in the system until it eventually reaches (in a finite amount of computation steps) a proper termination state. Remember that such a state will have a counterpart in the UML model of B , which will contain a subclass for that specific state. By denoting with term A  X  a-states ( A ) the proper termination state of artifact A  X  artifacts ( B ), and by considering the standard FOL encoding of UML classes as unary predicates, the artifact termination property can be formalized in  X  L p as follows:  X Z. ^
In the following, all the undecidability results we give do not only hold for the  X  L p logic in general, but specifically for the artifact termination property. Furthermore, we do only consider data coming from a countably infinite unordered domain, and that can only be compared for (in)equality. We thus avoid any assumption on the structure of data do-mains, and consider only string and boolean attributes 1 . In this light, our results witness that it is not possible to achieve meaningful restrictions towards decidability just by restrict-ing the property specification logic, but that it is instead necessary to suitably restrict the expressiveness of BAUML models themselves.

Since all the undecidability proofs rely on the encoding of 2-counter machines [19] into the specific class of BAUML models under analysis, we start by briefly recapping 2-counter machines.
We follow the original formulation in [19]. A counter is a memory register that stores a non-negative integer. Given two positive integers n, m  X  N + , an m -counter machine C with counters c 1 , . . . , c m is a program with n commands: where each CMD k (for index k  X  { 1 , . . . , n  X  1 } ) is either an increment command or a conditional decrement command.
Given i  X  { 1 , . . . , m } , an increment command for counter i , written INC ( i, ), is a command that increases the counter
A boolean attribute can be considered as a special string attribute that can only be assigned to the special strings true or false . This constraint can be easily expressed in OCL. c o f one unit, and then jumps to the next instruction. For-mally, for k, k  X   X  { 1 , . . . , n  X  1 } , tional decrement instruction for counter i and instruction k , written CDEC ( i, k  X  , k  X  X  ), tests whether the value of counter i is zero. If so, it jumps to instruction k  X  ; otherwise, it decreases counter i of one unit, and then jumps to instruc-tion k  X  X  . Formally, for k, k  X  , k  X  X   X  { 1 , . . . , n  X  1 } , command k : CDEC ( i, k  X  , k  X  X  ) means k : if c i = 0 then GOTO k  X  ; else { c i := c i  X  1; GOTO k An input for an m -counter machine is an m -tuple h d 1 , . . . , d m i of values in N initializing its counters. Given an m -counter machine C and an input I of size m , we say that C halts on input I if the execution of C with counter initial values set by I eventually reaches the last, HALT command.
It is well-known that checking whether a 2-counter ma-chine halts on a given input is undecidable [19], and it is easy to strengthen this result as follows:
Corollary 4.1. It is undecidable to check whether a 2-counter machine halts on input h 0 , 0 i .

In the following, we say that a 2-counter machine halts if it halts on input h 0 , 0 i .
We start by showing that, if we do not impose restrictions on the shape of OCL queries used in the pre-/post-conditions of tasks and in the decision points of a BAUML model, then verification of artifact termination is undecidable. We say that a BAUML model is unrestricted if it does not impose any restriction on the shape of such queries.
 Theorem 4.2. Checking termination over unrestricted BAUML models is undecidable.
 Proof. By reduction from the halting problem of 2-counter machines, which is undecidable (cf. Corol-lary 4.1). Specifically, given a 2-counter machine C , we produce a corresponding unrestricted BAUML model B C = trated in Table 1. The idea behind the reduction is as follows. M contains a single artifact 2CM , which can be ready or halted, the latter being the termination state ( term 2CM = Halted2CM ), as it can be clearly seen in S u specified in diagram S 2CM , the init operation is activated only if the extension of Flag is empty. In this case, a new artifact instance of Ready2CM and a new object of type Flag are si-multaneously created. The creation of a Flag object has the effect of blocking the possibility of creating new instances of Ready2CM , in turn ensuring that only a single instance of Ready2CM will be created, and that only one execution of P run will run. In fact, the only instance of 2CM that enters S 2CM will move to the halted state by executing the activ-ity diagram P run . In turn, P run encodes the program of C , by combining the process fragments obtained by translat-ing the single commands in C as specified in Table 1. Two classes Item 1 and Item 2 are used to mirror the two coun-ters. In particular, at a given moment in time, the number of instances of Item i represents the value of counter i . In this light: (i) incrementing counter i translates into the cre-ation of a new instance of Item i ; (ii) testing whether counter i is 0 translates into checking whether the extension of class Item i is empty; (iii) decrementing counter i translates into the deletion of one of the current instances of Item i . Table 1 shows how these three aspects can be formalized in terms of activity diagrams and OCL queries (focusing on counter 1). The diamond gateways at the beginning of each fragment are used to properly merge multiple incoming paths.
The claim follows by observing that C halts if and only if the unique instance of 2CM that enters S 2CM also reaches the Halted2CM state, i.e., properly terminates.
T he proof of Theorem 4.2 relies on the fact that artifact in-stances freely manipulate (i.e., create, read, delete) instances of other classes. Towards decidability, we have therefore to properly control how artifact instances relate to other ob-jects. In this light, we suitably restrict OCL expressions, by allowing only so-called navigational expressions.
 To define navigational queries over a BAUML model B = hM , O , S , Pi , we start by partitioning the associations and classes in M into two sets: a read-only set M r , and a read-write set M rw . Intuitively, M r represents the portion of M whose data are only accessed, but never updated, by the execution of tasks, whereas M rw represents the portion of M that can be freely manipulated by the tasks. These two sets can either be directly specified by the modeler, or easily extracted by inspecting all postconditions of opera-tions present in P , marking a class C as read-write every time a sub-expression obj . oclIsNew () appears in some op-eration, and obj is an instance of C . In this light, all arti-facts presents in M are always part of the read-write set: artifacts ( M )  X  M rw .

Given an object obj , an OCL expression is navigational from obj if it is defined by means of the usual OCL opera-tions like exists, select, . . . , but in which each subexpression is a boolean combination of expressions Q i that obey to one of the following two types:  X  Q i only uses role and class names from M r ;  X  Q i has the form of a path o.r 1  X   X   X  r n , which starts from o and navigates through roles r 1 to r n , where each r i is either a role or an attribute, and where o is either the original object obj , or a variable used in the current operation. A BAUML model B = hM , O , S , Pi is navigational if:  X  For every operation in P , with the exception of the init operation, the OCL expressions used in its pre-and post-conditions are navigational from a , where a is (the name of) the artifact instance taken in input by the operation.  X  Every condition in conditions ( B ) is an OCL expression that is navigational from (the name of) the artifact instance present in the scope of the condition.
 Navigational BAUML models do not allow artifact instances to share objects from read-write classes. Indeed, for an ar-tifact instance to establish a relation with an object of class C previously created by another artifact instance, it is nec-essary to write an OCL query that selects objects of type C , but this query is not navigational.
 In spite of this observation, we will see that restricting BAUML models to navigational queries is still not suffi-cient, but additional requirements are needed towards de-cidability. The first requirement is related to the way OCL expressions navigate the roles in M . Given a navigational BAUML model B = hM , O , S , Pi , and given a role r in M , if there exists an OCL expression in B that mentions r , then pre: Item1 . allInstances ()  X  exists ( i | i . id = id ) post:  X  ( Item1 . allInstances ()  X  exists ( i | i . id = id )) w e say that r is a target role , written trg B ( r ), otherwise we say that r is a source role , written src B ( r ). We use this no-tion to define the notion of dependency between two classes. Given classes C 1 and C n +1 in M , we say that C n +1 depends on C if there exists a tuple h A 1 , . . . , A n i of binary associations such that each A i connects C i and C i +1 , and the role of A attached to C i +1 is a target role. We then say that B is bidi-rectional if it is navigational and there exists a class in M that depends on itself or on one of its super/sub-classes, uni-directional if it is navigational and there is no class in M that depends on itself or on one of its super/sub-classes. In-tuitively, for a unidirectional BAUML model it is possible to mark each association in its UML model as directed (since no association can have both nodes as targets), and the re-sulting directed graph is acyclic. See for example Table 2. This property, in turn, can be tested in NLogSpace . We now correspondingly characterize navigation in  X  L p . Without loss of generality, we consider only binary rela-tions 2 . A pseudo-navigational  X  L p property has the form  X  ::= true | false | A ( x ) |  X  A ( x ) |  X  1  X   X  2 |  X  1 where, in the last row, variable x is exactly the single free variable of  X , once we substitute to each bounded predicate variable Z in  X  its bounding formula  X Z.  X   X  (resp.,  X Z.  X  Notice that pseudo-navigational properties are in negation normal form, and that they constitute indeed a fragment
N on-binary relations can be removed through reification. of  X  L p . In fact, even if they do not make use of live , they always guard quantification and next-state transitions with classes and/or relations, which imply the corresponding quantified objects to be in the current active domain.
Given a unidirectional BAUML model B = hM , O , S , Pi , we characterize the fact that a closed, pseudo-navigational  X  L p property  X  is navigationally compatible with B as:  X   X  contains a subformula of the form  X  x.A ( x )  X   X ( x ) or  X  x.A ( x )  X   X ( x ).  X  The largest subformula of  X  of the form  X  x.A ( x )  X   X ( x ) or  X  x.A ( x )  X   X ( x ) is such that: A  X  a-classes ( B ), and A and x are compatible with  X , written cmp x A ( X ) = true , according to the notion of compatibility defined below. Given a class C in M , a variable x , and a pseudo-navigational open  X  L property  X ( x ), we define cmp x C ( X ) as: (1) true if  X   X  { true , false , Z } (2) C  X  M A  X  A  X  M C if  X   X  { A ( x ) ,  X  A ( x ) } (3) cmp x C ( X  1 )  X  cmp x C ( X  2 ) if  X   X  {  X  1  X   X  2 ,  X  (4) cmp x C ( X ) if  X   X  {  X Z.  X  ,  X Z.  X  } (5) false if  X   X  { X  y.A ( y )  X   X ( y ) ,  X  y.A ( y )  X   X ( y ) } (6) trg B ( R | 2 )  X  cmp y C  X  ( X )  X  (( C  X  M  X  R )  X  (  X  R  X  (7) trg B ( R | 1 )  X  cmp y C  X  ( X )  X  (( C  X  M  X  R  X  )  X  (  X  R  X   X  (8) ( C  X  M A  X  A  X  M C )  X  cmp x C ( X )
Intuitively, the formulae above state that: (1) C and x are always compatible with non-first-order subformulae. (2) C and x are compatible with first-order components of the form A ( x ) or  X  A ( x ) if classes A and C belong to the same hi-erarchy according to M ; this means that navigation through classes is only allowed in the context of the same hierar-c hy. (3) boolean connectives distribute the compatibility check to all their inner sub-formulae. (4) fixpoint constructs push the compatibility check to their inner sub-formulae. (5) compatibility is broken if new quantified variables over classes are introduced in the formula. This means that at most one quantification over classes is allowed in a pseudo-navigational property to be navigationally compatible with B . (6) and (7) deal with navigation along a binary relation, from the first to the second component in (6), and from the second to the first component in (7). In particular, (6) states that the formula can quantify over the second component of a relation R where x points to the first component if: (i) the second component of R is a target role in B , witnessing that  X  agrees with the unidirectional navigation imposed by B over R ; (ii) class C belongs to the same hierarchy of the domain class for R , according to M ; (iii) C  X  and y are nav-igationally compatible with the inner formula  X , where y is the newly quantified variable, and C  X  is the image class for R according to M . (7) works in a similar way, by simply inverting the second and first components of R . (8) next-state transition formulae are compatible if the class used in the guard belongs to the same hierarchy of C , and C and x are compatible with the inner subformula.

Notice that termination properties are always guaran-teed to be navigationally compatible with the corresponding BAUML model, since A and term A belong by definition to the same hierarchy.
 Unfortunately, the following result shows that restricting BAUML models to be unidirectional is not sufficient to ob-tain decidability of checking termination properties. Theorem 4.3. Checking termination of unidirectional BAUML models is undecidable.
 Proof. Given a 2-counter machine C , we produce a corresponding unidirectional BAUML model B C = trated in Table 2. M  X  contains a single artifact 2CM , which can be ready or halted, the latter being the termination state ( term 2CM = Halted2CM ), as attested by S  X  2CM . When the init operation is applied, a new instance m of Ready2CM is cre-ated, attaching to it two dedicated objects of type Counter , using respectively role c 1 and c 2 of the associations hasC 1 and hasC 2. Such Counter objects mirror the two counters of C . In particular, each of the two Counter objects attached to m has a 1-to-many association with Item : at a given time, the number of items attached to m.c 1 ( m.c 2 resp.) repre-sents the value of the first (second resp.) counter in C .
The artifact instance m then executes the process corre-sponding to the run event, which suitably encodes the pro-gram of C : (i) incrementing the first counter translates into the inclusion of a new Item to the items of m.c 1, i.e., to the set m.c 1 .items ; (ii) testing whether the first counter is 0 translates into checking whether set m.c 1 .items is empty; (iii) decrementing the first counter translates into the re-moval of one item from set m.c 1 .items (it is not impor-tant which). Table 2 shows how these three aspects can be formalized in terms of activity diagrams and OCL queries The management of the second counter is analogous, with the only difference that it involves m.c 2 .items in place of m.c 1 .items . Figure 4 intuitively shows the evolution of a specific configuration of the system in response to the appli-cation of two operations.

Observe that, as graphically depicted in M  X  (consistently with the operations), B C is unidirectional: all OCL expres-sions (except from that in init ) are navigational in m , and navigation unidirectionally flows from 2CM to Counter to Item . Furthermore, no two objects of type Counter , nor two objects of type Item , are shared by different instances of 2CM . This means that every instance of Ready2CM runs the process corresponding to the program of C in total isolation with other instances of Ready2CM ) and, consequently, either all halt or none halt. The claim follows by observing that C halts if and only if all instances of Ready2CM eventually reaches the Halted2CM state, i.e., properly terminate.
T he source of undecidability in Theorem 4.3 relies in the contains relation of M  X  (cf. Table 2), which relates its tar-get role items with an unbounded cardinality. To overcome this issue, we introduce the notion of cardinality-bounded BAUML model. A BAUML model B = hM , O , S , Pi is cardinality-bounded if B is navigational and each target role in M has a bounded cardinality, i.e., is associated to a car-dinality constraint whose upper bound is numeric. B is N-cardinality-bounded if the maximum upper bound associated to a target role is N . If there exists at least a target role with unbounded cardinality, i.e., associated to a cardinality constraint whose upper bound is  X  , then B is instead said to be cardinality-unbounded . Notice that no cardinality re-striction is imposed, for cardinality-bounded models, on the cardinalities associated to roles that are not target roles.
With all these notions at hand, we are now able to state the main result of this paper.

Theorem 4.4. Let B be an arbitrary unidirectional, cardinality-bounded BAUML model. Verifying whether B satisfies a  X  L p property navigationally compatible with B is decidable, and reducible to finite-state model checking. Proof. Let B = hM , O , S , Pi be a cardinality-bounded, unidirectional BAUML model, and let  X  be a  X  L p property navigationally compatible with B . On the one hand, by in-specting the notion of navigational compatibility, one can notice that  X  is  X  X ooted X  in a single artifact class S , sub-ject to the outermost subformula of the form  X  x.S ( x )  X   X ( x ) (or  X  x.S ( x )  X   X ( x )). Navigational compatibility then en-sures that  X  only mentions relations and classes that can be reached by navigating M using is-a relationships (in both directions), or associations, in a direction that is compatible with the unidirectionality imposed by B .

On the other hand, as pointed out in Section 4.4, in a navi-gational model like B it is impossible for artifact instances to share objects that belong to read-write classes. This means that the evolution of an artifact instance is completely in-dependent from that of the other artifact instances of the same type art S , or other artifact types.

By combining these two observations, we obtain that  X  obeys to a sort of isolation property :  X   X  does not distinguish whether the system contains evolv-ing artifact instances of types different than art S ;  X   X  does not distinguish whether the instances of art S evolve in isolation, or co-evolve in a concurrent way. This isolation property is a data-aware variant of the free-choice property of Petri nets. Thanks to such property, in-stead of directly considering the whole concurrent evolution of the system, in which unboundedly many artifact instances p re:  X  ( m . c1 . items  X  exists ( i  X  | i  X  . id = id )) post: m . c1 . items  X  exists ( i | i . oclIsNew ()  X  i . id = id ) = m . c 1 . items  X  isEmpty () pre: m . c1 . items  X  exists ( i | i . id = id ) post:  X  ( m . c1 . items  X  exists ( i | i . id = id )) could be created over time and evolved in parallel, one can consider a faithful, sound and complete abstraction of the system, which accounts only for the concurrent evolution of those instances of type art S present in the initial database of B , plus an additional artifact instance of type art S , nonde-terministically created and evolved in addition to the others.
Let b i be the number of artifact instances of type art S present in the initial database of the system. From the fact that B is unidirectional and cardinality-bounded, we have that each artifact instance can create only a bounded amount of objects during its evolution. In fact, the num-ber of objects that can be created by an artifact instance is bounded by ( k  X  N ) l +1 , where: (i) k is the number of relations in the schema (which bounds the number of rela-tions that are collectively attached to an artifact/class in the schema), (ii) N is the maximum cardinality upper bound at-tached to a target role belonging to a path rooted in art and (iii) l is the length of the longest navigational path rooted in art S . As a consequence, by considering the afore-mentioned sound and complete abstraction, we have that at most ( b i +1)  X  N l +1 objects and artifact instances are simulta-neously present in a system snapshot. The claim then follows by: (i) applying the translation from BAUML models to data-centric dynamic systems (DCDSs) [1], provided in [10]; (ii) observing that the bound ( b i +1)  X  N l +1 implies that the obtained DCDSs is state-bounded; (iii) recalling that veri-fication of  X  L p properties over state-bounded DCDSs is de-cidable, and reducible to finite-state model checking [1].
An important open point is whether cardinality-b oundedness is a sufficient restriction for decidability per s`e, i.e., without necessarily imposing unidirectionality. The following theorem provides a strong, negative answer to this question, witnessing that both restrictions are simultane-ously required towards decidability.

Theorem 4.5. Checking termination of 1-cardinality-bounded, bidirectional BAUML models is undecidable.
As argued in Section 4.4, unidirectional BAUML models are not able to make artifact instances share (read-write) ob-jects. In this section, we study what happens if we relax uni-directionality so as to support this feature. A unidirectional BAUML model with shared instances B = hM , O , S , Pi is a BAUML model in which, inside navigational expressions, it is possible to add free queries over M rw , provided that they do not contain t he expression oclIsNew (). Intuitively, this means that new objects can only be created through stan-dard navigational OCL expressions, but at the same time it is possible to establish associations with already existing objects that are not reachable by simply navigating from the artifact instance. The following theorem shows that this relaxation makes verification again undecidable.

Theorem 4.6. Checking termination of 1-cardinality-bounded, unidirectional BAUML models with shared in-stances is undecidable.

We close this thorough analysis by showing that, if we introduce a bound on the number of artifact instances that are simultaneously active in the system, verification becomes decidable for this specific class of BAUML models. This technique cannot be applied to unrestricted nor unbounded BAUML models: by inspecting the proofs of Theorems 4.2 and 4.3, one can easily notice that undecidability holds even when there is just a single active artifact instance.
Theorem 4.7. Verification of  X  L p properties over cardinality-bounded, unidirectional BAUML models with shared instances of read-write classes is decidable and reducible to finite-state model checking when the number of simultaneously active artifact instances is bounded. Proof. Let B be a cardinality-bounded, unidirectional BAUML model. By combining unidirectionality and cardinality-boundedness, we have that an artifact instance can create only a bounded amount of objects during its evo-lution. In fact, the number of objects that can be created is bounded by ( k  X  N ) l +1 , where k , N and l are as in the proof of Theorem 4.4. Since the number of simultaneously active artifact instances is bounded, say, by a number b , then at each time point the number of objects and artifact instances present in the overall system is bounded by b  X  ( k  X  N ) claim then follows by: (i) applying the translation from BAUML models to DCDSs, described in [10]; (ii) observ-ing that the bound b  X  ( k  X  N ) l +1 implies that the obtained DCDS is state-bounded; (iii) recalling that verification of  X  L p properties over state-bounded DCDSs is decidable, and reducible to finite-state model checking [1].
 It is important to observe that bounding the number of si-m ultaneously active artifact instances still allows one to cre-ate an unbounded amount of artifact instances over time, provided that they do not accumulate in the same snapshot. In this light, Theorem 4.7 closely resembles the result given in [21] for business artifacts specified in the GSM notation.
To show the practical relevance of these results, we re-turn to our example, presented in Section 3. It is a re-alistic example of a data-centric business process. At the same time it is a cardinality-bounded, unidirectional model with shared instances coming from a read-only relation ( ItemType ). Hence, it falls into the case of Theorem 4.4, for which verification is decidable even in presence of unbound-edly many simultaneously active artifact instances. In the case where artifacts share a read-write relation, decidability requires an additional bound on the number of simultane-ously active artifact instances, so as to fall into Theorem 4.7.
This section will examine alternative representations for artifact-centric business process models, with the focus on the data dimension. In those cases where it is possible, we will review the decidability results that have been obtained for the formal verification of these models. However, most of these results are applicable to models grounded on logic or mathematical notations that do not provide a practical business level representation. We will first begin by looking at alternative graphical representations and we will continue with alternatives grounded on logic.

Apart from the work in [9] that we have considered in this paper, there are also other approaches that use UML class diagrams to represent the data dimension, such as [11]. However, [11] turns to proclets (a labeled Petri net with ports) to represent the internal lifecycle of the artifact and how it relates to other artifacts.

ER models [4] are similar to UML class diagrams as they also allow representing the relationships between the arti-facts and their attributes. The PHILharmonic Flows frame-work [17] represents business processes with data in a graph-ical way, using a model which falls in-between a UML dia-gram and a database schema representation. Unlike our approach, it does not distinguish between what we call busi-ness artifacts and objects.

Another alternative is to extend BPMN to allow the repre-sentation of data-dependencies in the business process model [18]. However, [18] does not have a specific diagram show-ing the relationships between the data or artifacts. The Guard-Stage-Milestone (GSM) approach [15, 8] represents the artifact and its lifecycle in one model, which shows the guards, stages and milestones involved in the evolution of an artifact. In contrast to the UML class diagram, GSM does not show graphically the relationships between the artifacts: they are encoded as attributes instead.

Several works deal with the formal verification of GSM models and study their decidability. For instance, [21] uses an approach that is very close to ours. It relies on the no-tion of state-boundedness to guarantee decidability. Simi-larly, [3] deals with decidability of GSM models but taking agents (i.e. users or automatic systems) into consideration. [13] also applies model checking to these models, but its im-plementation restricts the data types and only admits one artifact instance. Both [3] and [13] use CTL or a variant of CTL, neither of which are as powerful as  X  -calculus.
There are several works [1, 2, 5] that deal with verification of artifact-centric business process models represented by means of a data-centric dynamic system (DCDS). DCDSs are grounded on logic. [1] represents artifacts by means of a relational database schema, [2] uses a knowledge and action base defined in a variant of Description Logics, and [5] maps an ontology to a DCDS. All these works define the properties to be checked in variants of  X  -calculus. They ensure decidability either by state-boundedness [1, 5] or by limiting the calls to functions that obtain new values [2, 1].
Works such as [7] and [12] also verify the fulfillment of properties by the model but they both define properties in variants of LTL or CTL (respectively), making them less powerful than  X  -calculus. [7] represents the data by means of a database schema. It allows the use of integrity con-straints in the data and arithmetic operations, requiring the condition of feedback-freedom (i.e. output variables cannot be reused from one function to the next) to guarantee decid-ability. [12] opts for bounding the domain values or to limit the language that is used instead. Artifacts are represented by means of a tuple which includes a set of attributes.
W e have analyzed the decidability of verification for artifact-centric business process models defined according to the BALSA framework and at a high level of abstraction. That is, we have lifted the decidability conditions from the formal, low-level representations, to the business level, to es-tablish conditions which can be considered by the modeler of the process. Although we have focused on the represen-tation of these elements using UML, our results could be extended to other forms of representation.

As a result of our analysis, we have concluded that veri-fication of artifact-centric process models is only decidable when: (i) artifacts are linked to a bounded number of ob-jects, (ii) two different artifacts only share read-only objects, (iii) expressions in the pre and postconditions of the opera-tions are navigational starting from the artifact instance be-ing manipulated, and (iv) the associations specified among two classes are not navigated back and forth. If any of these four conditions is relaxed, then we end-up with undecidabil-ity. Regaining decidability when the model contains shared read-write objects requires to put a bound on the number of simulatenously active artifact instances. Although these conditions are restrictive, they still allow for the definition of relevant situations in practice.

As further work, we would like to pursue this line of re-search so as to characterize concrete, real-life settings for which decidability of verification is guaranteed. We also plan to provide a more fine-grained characterization of how read and write operations might interact without undermining decidability. Finally, we aim at studying the practical appli-cability of our verification techniques, by understanding how the exponentiality in the data that is inherent in data-aware systems can be tamed, through a suitable modularization/-partitioning of the data into independent portions. This research has been partially supported by the EU FP7 IP project Optique ( Scalable End-user Access to Big Data ), grant agreement n. FP7-318338, MICINN projects TIN2011-24747 and TIN2008-00444, Grupo Consolidado, the FEDER funds and Universitat Polit`ecnica de Catalunya. [1] B. Bagheri Hariri, D. Calvanese, G. D. Giacomo, [2] B. Bagheri Hariri, D. Calvanese, M. Montali, [3] F. Belardinelli, A. Lomuscio, and F. Patrizi.
 [4] K. Bhattacharya, R. Hull, and J. Su. A data-centric [5] D. Calvanese, G. D. Giacomo, D. Lembo, M. Montali, [6] D. Calvanese, M. Montali, M. Esta  X nol, and [7] E. Damaggio, A. Deutsch, and V. Vianu. Artifact [8] E. Damaggio, R. Hull, and R. Vacul  X  X n. On the [9] M. Esta  X nol, A. Queralt, M.-R. Sancho, and [10] M. Esta  X nol, M.-R. Sancho, and E. Teniente. Reasoning [11] D. Fahland, M. D. Leoni, B. F. van Dongen, and [12] C. E. Gerede and J. Su. Specification and verification [13] P. Gonzalez, A. Griesmayer, and A. Lomuscio.
 [14] R. Hull. Artifact-centric business process models: [15] R. Hull et al. Business artifacts with [16] ISO. ISO/IEC 19505-2:2012 -OMG UML [17] V. K  X  unzle and M. Reichert. PHILharmonicFlows: [18] A. Meyer, L. Pufahl, D. Fahland, and M. Weske. [19] M. L. Minsky. Computation: Finite and Infinite [20] OMG. OCL version 2.4. Technical report, OMG, 2014. [21] D. Solomakhin, M. Montali, S. Tessaris, and R. D. [22] M. Weske. Business Process Management: Concepts,
