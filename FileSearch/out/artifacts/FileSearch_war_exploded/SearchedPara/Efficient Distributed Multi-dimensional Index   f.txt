 The ubiquity of location-enabled devices such as intelligent mobiles, GPS and sensors produce tremendous amount of data which are heterogeneous and dynamic in many them efficiently, such as the storage, index, query and analysis of data. In particular, efficient index method is crucial to improve the efficiency of query and analysis. 
As is well known, centralized multi-dimensional index technology has been exten-sively studied in traditional DBMSs. However, they cannot meet the increasingly NoSQL databases emerge to satisfy relevant needs such as HBase, Cassandra, and MongoDB etc. NoSQL databases have prominent capabilities of high scalability, store model which is efficient to support single-key index. And they respond to query cally require multi-dimensional query, which NoSQL databases cannot support effi-ciently. Nowadays, the solutions of NoSQL database to respond multi-dimensional query requests are MapReduce and Table-Scan. But in case of multi-dimensional query request, they are inefficient and costly, especially when the selectivity of query request is low. Consequently, a distributed multi-dimensional index should be appropriate to meet all requirements. multi-dimensional query requests for big data management. 
In summary, the contributio ns of this paper are:  X 
We propose a new Efficient Distributed Multi-dimensional Index new two-layered index framework: the top global index is K-d tree and the bottom index is ZPR-tree.  X 
We propose a new R-Tree [12] variant query performance. Further it makes use of the bottom-up building method based on MapReduce to build ZPR-tree in parallel.  X 
We present an analysis for the cost of two range query methods of ZPR-tree theo-retically.  X 
We experimentally evaluate EDMI and ZPR-tree in distributed clusters. The results demonstrate that the query performance of ZPR-tree is better than other Packed R-trees and R*-Tree. EDMI has better query performance than other index methods involved in related work.
 The rest of this paper is organized as follows. Section 2 presents the related work. We present our new index framework tecture and construction of EDMI and the R-tree variants cusses query processing on EDMI and analyzes the cost of two range query methods of ZPR-tree theoretically. Section 5 presents an extensive experimental evaluation of EDMI and ZPR-tree. Section 6 concludes our paper and points out our future work. Distributed multi-dimensional index for big data management has caught tremendous distributed storage architecture. A) The storage architecture of index framework is based on Peer-to-Peer system. [1] proposes a general index framework of the cloud. The index framework has index framework selects nodes from local indexes by respective cost model and orga-nizes them together to form global index. RT-CAN [2] is a specific index framework based on such architecture. In detail, the local index is R-tree, and the network com-municate protocol is C 2 overlay which extends CAN [3] protocol. Another representa-tive framework is QT-Chord [4]. Its local index is MX-CIF quad tree and it is based on Chord overlay. B) The storage architecture of index framework is based on master-slave style. 
EMINC [5] has two-layered indexes as well. R-Tree as the global index is stored in stores the boundary information of each indexed dimension on each slave node. Each leaf node of the R-tree contains a node cube and one or more pointers that point to the slave nodes corresponding to its node cube. MD-HBase [6] leverages a multi-dimensional index structure layered key-value store. Z-order curve is used to partition entire data space into different subspaces, an d K-d tree or Quad-Tree is used to group positive scans of Z-order curve. The storage of MD-HBase is based on HBase. 
Both the storage architectures of index framework have advantages and disadvan-tages. The major problems of first one are that (1) communication overhead be-comes excessive for routing query requests between computer nodes and that network laten-cy severely influences the performance of query;(2) the index framework cannot meet the frequent data insert, delete and update requirement because communication over-time of peer-to-peer system which accesses the local index in local disk is faster than that of the second index framework. The second index framework which adopts mas-ter-slave architecture locates the target computer node easily and reduces communica-tion overhead largely. Besides, the fault-tolerant ability of master-slave architecture is stronger than peer-to-peer system and its ava ilability and security is better than peer-paper correspondingly. 
We present a new index framework EDMI to improve the query performance architecture of EDMI in detail. 3.1 The Architecture of EDMI EDMI is a two-layered index framework; Figure 1 presents the architecture of EDMI. partition entire data space into several subspaces. The bottom layer consists of several ZPR-trees. Each ZPR-tree indexes data items in each subspace. It is worth mentioning the split dimension of adaptive K-d tree can be different from each other in the same corresponds to maximum spread coordinate in the subspace is chosen as the split di-mension. And point-based adaptive K-d tree is a complete binary tree, it is effective to subspace. 
ZPR-tree is a new R-Tree variant we present in this paper. We will introduce ZPR-tree in detail in section 3.2. 
The procedure of constructing EDMI has two phases. The first phase is the con-using MapReduce [7],[8]. The number of R-trees is the same with the number of leaf nodes in K-d tree. In map phase, the task is reading all raw data from HBase and par-titioning them into different groups; and in reduce phase, the task is building an ZPR-tree for each group using method in Section 3.3 and writing all ZPR-trees into HBase. Figure 2 illustrates the procedure of construction EDMI using MapReduce. 3.2 Z-Order Prefix R-Tree Z-Order Curve and Z-Order Prefix Code Z-order curve is one of the most popular space filling curves, which can be used for linearization of multi-dimensional data. The Z-value of a point in multi-dimensions is Figure 3 illustrates a Z-order curve in 2D space with 6 bits length Z-value. For exam-used as the name for each subspace. Z-order curve has two important properties: (1) If subspace A encloses subspace B , the name of subspace A is a prefix of that of sub-(2) If subspace A doesn't has the same Z-order prefix with subspace B , the subspace A spaces in different colors in Figure 3. Z-Order Prefix R-Tree Z-order Prefix R-tree (ZPR-tree) is a new variant of R-tree presented by us. ZPR-tree inherits the properties of Z-order curve. There are some additional new features:  X  tree node share the common Z-order pref ix according to property (1) above.  X 
ZPR-tree eliminates the overlap of MBRs for R-tree nodes at the same level ac-cording to property (2) of Z-order curve.  X 
The leaf nodes of ZPR-tree not only store the actual data items and their MBR, but also the common Z-order prefix in the leaf nodes. the space utilization, entry numbers of one R-tree node is confined between m (where cording to Z-order prefix, entry number of one sub-node may be smaller than m . And policies of ZPR-tree according to various practical demands.  X 
M-guarantee ZPR-tree. This policy restricts the entry numbers of ZPR-tree node is no larger than M . The advantage of M-guarantee ZPR-tree is that there are no over-sized nodes in ZPR-tree and the total MBR area of ZPR-tree nodes is small. How-ever, the nodes number of ZPR-tree is large and the space utilization of ZPR-tree node is so small that I/O frequencies of query request will increase.  X  m-guarantee ZPR-tree. This policy restricts the entry numbers of ZPR-tree node is node, avoids smaller-sized nodes, and reduces the I/O access times. However, this 
Besides, the total MBR area of ZPR-tree nodes is relatively large and the false pos-itive scans will increase with query processing. We present the experimental evaluation of these two policies of ZPR-tree in the sec-tion 5. And the experimental results prove the theoretical analysis above. 3.3 The Bottom-Up Construction of ZPR-Tree To improve the insert throughput of ZPR-tree, we adopt bottom-up method to con-struct ZPR-tree. The bottom-up method is similar to Packed Hilbert R-tree, but takes nodes until the root of ZPR-tree is generated level by level from leaf nodes. In Figure 4, we give the construction procedures of ZPR-tree based on two different split poli-We present the tree structure of generated ZPR-tree in Figure 5. 4.1 Range Query Cost Model for ZPR-Tree Range Query As for processing range query on EDMI, we present two different methods. One is the traditional method for all tree indexes: traverse ZPR-tree from root to leaf (denoted as process range query of ZPR-tree. Leaf-Scan can only be used in ZPR-tree because it is stored in HBase which is based on key-value storage model. We use level number prefix in dictionary ascend order level by level, which can be scanned easily if given a specific range. In general, traversing tree is more efficient than Leaf-Scan because of less false positive scans; however, we observe that one 'scan' operation is much faster than several 'get' operations to fetch the same number records in HBase. We present a cost model to evaluate the cost of two range query methods and adopt the cheaper one to execute range query. involved in one query box Q . Formula (1) and (2) calculate the numbers of involved leaf nodes corresponding to Q and total cost of Leaf-Scan method. tree. C HBaseScan is cost of average 'scan' operation of HBase. Formula (3) is used to estimate the number of node access or 'get' operation. Formula (4) is total cost of Traversing-Tree. Formul a (5) is the cost of processing range query on ZPR-tree. and load them into main memory when R-tree is built for query processing. Range Query of EDMI range query algorithm for Q to returns all serial numbers of ZPR-trees which intersect But for each ZPR-tree, it only executes a sub-query which is the intersection of boun-procedure of handling a range query for area Q . Algorithm 1. RangeQuery Input: query Q 
Output: Result 1: TreeList  X  KDTreeRangeQuery(KDTree,Q) 2: for each ZPRTree in TreeList do 3: subQ  X  FindIntersection(ZPRTree, Q); 5: Result.add(TraversingTree(ZPRTree,subQ)) 6: else Result.add(LeafScan(ZPRTree,subQ)) 7: end for 8: return Result 4.2 Point Query Point query can be treated as a special case of range query that the size of query box number of ZPR-tree that may contain P would be picked out. Next query service will the overlap of MBRs for R-trees at the same level, a point query at most involves one its information to client, otherwise return null to client. 4.3 K-Nearest Neighbor Query points nearest to the center C , according to some distance metric. In this paper, we use a traditional method for KNN query. First query service sets 1 as the initial radius of query, then executes KNN query on K-d tree and ZPR-tree and gets all results whose execute the query on new radius, until the size of result set is equal with or larger than K . Algorithm 2 specifies the procedure of KNN query on EDMI. Algorithm 2. K-nearest neighbor Query Input: the center C and the parameter K 
Output: Result 1: radius  X  1 2: do 3: TreeList  X  KDTreeKnnQuery(KDTree,C,radius) 4: for each ZPRTree in TreeList do 5: Result.add(ZPRTreeKnnQuery(ZPRTree,C,radius)) 6: if Result.size&lt;K then 7: radius  X  ExpandRadius(K, Result.size) 8: while Result.size &lt;k 9: if Result.size&gt;k then 10: Sort Result by distance to C in ascend order 11: Result  X  Sublist(Result, 0, K) 12: return Result plemented based on Hadoop 1.0.4 and HBase 0.94.2. Our testing infrastructure in-E5645 2.4GHz Xeon CPU, and each CPU has 6 cores. Memory of each computer is 48GB; the disk size is 2TB, running Red Hat Enterprise 5.5 operating system. All the computer nodes are in the same rack, the network is 1Gbps. We perform our experi-attributes, including ID, timestamp, longitude, latitude, and moving direction. 5.1 Experimental Evaluation on ZPR-Tree Packed Hilbert R-tree [11] (PHR-tree), Packed Z-order R-tree (PZR-tree), and R*-3. All these tree indexes are implemented in Java and stored in HBase table. 
We use average node access times as the metric in point query experiment to eva-Value stored databases, reducing random reading times is more effective than reduc-ing total reading size in improving the query performance. So in our experiments, we adopt both NA and SR as evaluation criterions of range query performance and give a weighted score that NA (0.6) is more important than SR (0.4). Formula (6) gives how the weighted score is calculated. NA Ri and SR Ri denote NA and SR of R-tree i . 
Table 1 depicts the construction time of R-tree variants. We can see that m-because M-guarantee ZPR-tree has more nodes and Hilbert encoding is much slower than Z-order encoding. R*-tree is much sl ower than Packed R-trees because it cannot support bottom-up construction and spends much time in node split. guarantee ZPR-tree performs best on 2D and 3D point query because it eliminates the overlap and has smaller overall MBR area. But on 4D and 5D point query, m-guarantee ZPR-tree exceeds M-guarantee ZPR-tree because M-guarantee ZPR-tree's height increases to 4. Packed Z-order R-tree is the worst of all on point query because of much overlap between MBRs and bigger overall MBR area. 
Figure 6(b),(c) shows the weighted scores of R-tree variants on range query, (b) for different dimensions under 0.01% selectivity and (c) for different selectivity under the same dimension; the calculation of score has been introduced in Formula (6). M-guarantee ZPR-tree is the best choice when the selectivity is 0.001%. But as selec-tivity increases, m-guarantee becomes the better one because its NA is much less than reveal that M-guarantee ZPR-tree performs best of all on point query and low selec-making it the best overall performance of all R-tree variants above. 5.2 Experimental Evaluation on EDMI We complete a series of experiments to compare the performance of EDMI with MD-HBase for three storage models (Table per Bucket, Region per Bucket and Share Ta-ble). We test point, range and KNN query on the synthetic dataset above. We use the average latency time of query processing to evaluate query performances. Figure 7(a) illustrates the performance of EDMI and MD-HBase on point query. milliseconds but EDMI is about 5 times faster than MD-HBase. Figure 7(b) and 7(c) dimensions under 0.01% selectivity. We can conclude that EDMI exceeds MD-HBase over 10 times on range query and the gap becomes larger as selectivity and dimension HBase employ scan. Figure 7(d) shows the performance of EDMI X  X  KNN query, which turns out that EDMI can process KNN query efficiently on different dimen-sions and K parameters. In general, EDMI is much more efficient than MD-HBase on point and range query processing, and it can process KNN query efficiently as well. In this paper, we propose a new multi-dimension index framework X  X DMI. EDMI is based on HBase and it has two layers: the top layer is K-d tree and the bottom layer is avoid the overlap of MBRs for R-trees on multi-dimensional point data and it has the other Packed R-trees and R*-tree; and we verify this in our experiment by comparing ZPR-tree with other R-tree variants. EDMI efficiently supports point, range and KNN query on HBase. In our experiments, we compare EDMI with MD-HBase and prove that EDMI has much better multi-dimensional query performance. 
We only focus on efficient construction from static datasets and high multi-on supporting frequent insertion and update operations on EDMI in the future. More-over, ZPR-tree will be extended to index various types of data not merely point data. 
